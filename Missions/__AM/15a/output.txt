// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20694 0 0
// InitMacro ;
  19: CALL 20862 0 0
// InitNature ;
  23: CALL 17360 0 0
// InitArtifact ;
  27: CALL 17977 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4641 0 0
// PrepareAlliance ;
  48: CALL 1429 0 0
// PrepareArabian ;
  52: CALL 6413 0 0
// PrepareRussian ;
  56: CALL 8422 0 0
// PrepareLegion ;
  60: CALL 6845 0 0
// Action ;
  64: CALL 10987 0 0
// MC_Start ( ) ;
  68: CALL 23027 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: LD_INT 10
 280: PUSH
 281: EMPTY
 282: LIST
 283: LIST
 284: LIST
 285: LIST
 286: PUSH
 287: LD_OWVAR 67
 291: ARRAY
 292: PPUSH
 293: LD_INT 28
 295: PPUSH
 296: CALL 44569 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 10
 305: PUSH
 306: LD_INT 11
 308: PUSH
 309: LD_INT 13
 311: PUSH
 312: LD_INT 15
 314: PUSH
 315: EMPTY
 316: LIST
 317: LIST
 318: LIST
 319: LIST
 320: PPUSH
 321: CALL 45629 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 325: LD_INT 1
 327: PPUSH
 328: LD_INT 29
 330: PUSH
 331: EMPTY
 332: LIST
 333: PPUSH
 334: CALL 45722 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 338: LD_ADDR_EXP 122
 342: PUSH
 343: LD_EXP 122
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 22
 353: PUSH
 354: LD_INT 2
 356: PUSH
 357: EMPTY
 358: LIST
 359: LIST
 360: PUSH
 361: LD_INT 25
 363: PUSH
 364: LD_INT 15
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PUSH
 371: EMPTY
 372: LIST
 373: LIST
 374: PPUSH
 375: CALL_OW 69
 379: PPUSH
 380: CALL_OW 1
 384: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 385: LD_INT 1
 387: PPUSH
 388: LD_INT 13
 390: PUSH
 391: LD_INT 2
 393: PUSH
 394: LD_INT 1
 396: PUSH
 397: LD_INT 31
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: LIST
 404: LIST
 405: PUSH
 406: LD_INT 13
 408: PUSH
 409: LD_INT 2
 411: PUSH
 412: LD_INT 1
 414: PUSH
 415: LD_INT 31
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: LIST
 423: PUSH
 424: LD_INT 13
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 1
 432: PUSH
 433: LD_INT 28
 435: PUSH
 436: EMPTY
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: PUSH
 442: LD_INT 13
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 1
 450: PUSH
 451: LD_INT 28
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: PUSH
 460: LD_INT 13
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: LD_INT 28
 471: PUSH
 472: EMPTY
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: PUSH
 478: LD_INT 13
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 28
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PUSH
 496: LD_INT 13
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 2
 504: PUSH
 505: LD_EXP 78
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 44887 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 529: LD_INT 1
 531: PPUSH
 532: LD_INT 4
 534: PPUSH
 535: CALL 45072 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 539: LD_INT 2
 541: PPUSH
 542: LD_INT 10
 544: PUSH
 545: LD_INT 11
 547: PUSH
 548: LD_INT 12
 550: PUSH
 551: LD_INT 14
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 45629 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 564: LD_INT 2
 566: PPUSH
 567: LD_INT 14
 569: PUSH
 570: EMPTY
 571: LIST
 572: PPUSH
 573: CALL 45722 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 577: LD_INT 2
 579: PPUSH
 580: LD_INT 21
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 51
 591: PUSH
 592: EMPTY
 593: LIST
 594: LIST
 595: LIST
 596: LIST
 597: PUSH
 598: LD_INT 22
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 52
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: LIST
 615: PUSH
 616: LD_INT 22
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 52
 627: PUSH
 628: EMPTY
 629: LIST
 630: LIST
 631: LIST
 632: LIST
 633: PUSH
 634: LD_INT 24
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 47
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: PUSH
 652: LD_INT 24
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 47
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 24
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 47
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: LD_INT 24
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 3
 696: PUSH
 697: LD_INT 47
 699: PUSH
 700: EMPTY
 701: LIST
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 24
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 47
 717: PUSH
 718: EMPTY
 719: LIST
 720: LIST
 721: LIST
 722: LIST
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PPUSH
 734: CALL 44887 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 738: LD_INT 2
 740: PPUSH
 741: LD_INT 5
 743: PPUSH
 744: CALL 45072 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 748: LD_INT 2
 750: PPUSH
 751: LD_INT 0
 753: PPUSH
 754: CALL 45502 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 758: LD_INT 3
 760: PPUSH
 761: LD_INT 10
 763: PUSH
 764: LD_INT 12
 766: PUSH
 767: LD_INT 14
 769: PUSH
 770: LD_INT 15
 772: PUSH
 773: EMPTY
 774: LIST
 775: LIST
 776: LIST
 777: LIST
 778: PUSH
 779: LD_OWVAR 67
 783: ARRAY
 784: PPUSH
 785: LD_INT 24
 787: PPUSH
 788: CALL 44569 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 792: LD_INT 3
 794: PPUSH
 795: LD_INT 10
 797: PUSH
 798: LD_INT 11
 800: PUSH
 801: LD_INT 13
 803: PUSH
 804: LD_INT 15
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PPUSH
 813: CALL 45629 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 817: LD_INT 3
 819: PPUSH
 820: LD_INT 13
 822: PUSH
 823: EMPTY
 824: LIST
 825: PPUSH
 826: CALL 45722 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 830: LD_ADDR_EXP 122
 834: PUSH
 835: LD_EXP 122
 839: PPUSH
 840: LD_INT 3
 842: PPUSH
 843: LD_INT 22
 845: PUSH
 846: LD_INT 8
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 25
 855: PUSH
 856: LD_INT 15
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: EMPTY
 864: LIST
 865: LIST
 866: PPUSH
 867: CALL_OW 69
 871: PPUSH
 872: CALL_OW 1
 876: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 13
 882: PUSH
 883: LD_INT 2
 885: PUSH
 886: LD_INT 1
 888: PUSH
 889: LD_INT 31
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: PUSH
 898: LD_INT 13
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 31
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 13
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: LD_INT 2
 924: PUSH
 925: LD_INT 32
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 14
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 28
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 14
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 28
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: LIST
 968: LIST
 969: PUSH
 970: LD_INT 14
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 1
 978: PUSH
 979: LD_INT 28
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: LIST
 986: LIST
 987: PUSH
 988: LD_INT 14
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 1
 996: PUSH
 997: LD_INT 28
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: LIST
1004: LIST
1005: PUSH
1006: LD_INT 14
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_EXP 78
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PPUSH
1036: CALL 44887 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1040: LD_INT 3
1042: PPUSH
1043: LD_INT 4
1045: PPUSH
1046: CALL 45072 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1050: LD_INT 4
1052: PPUSH
1053: LD_INT 10
1055: PUSH
1056: LD_INT 12
1058: PUSH
1059: LD_INT 11
1061: PUSH
1062: LD_INT 15
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PPUSH
1071: CALL 45629 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1075: LD_INT 4
1077: PPUSH
1078: LD_INT 33
1080: PUSH
1081: EMPTY
1082: LIST
1083: PPUSH
1084: CALL 45722 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 5
1093: PUSH
1094: LD_INT 6
1096: PUSH
1097: LD_INT 7
1099: PUSH
1100: LD_INT 9
1102: PUSH
1103: LD_INT 10
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: PPUSH
1113: CALL 46040 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1117: LD_INT 4
1119: PPUSH
1120: LD_INT 54
1122: PPUSH
1123: LD_INT 85
1125: PPUSH
1126: LD_INT 2
1128: PPUSH
1129: LD_INT 25
1131: PUSH
1132: LD_INT 16
1134: PUSH
1135: LD_INT 17
1137: PUSH
1138: LD_INT 18
1140: PUSH
1141: LD_INT 22
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PPUSH
1151: CALL 45834 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 7
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 1
1184: PUSH
1185: LD_INT 6
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 5
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: LD_INT 7
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 5
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 1
1220: PUSH
1221: LD_INT 6
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 5
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 3
1238: PUSH
1239: LD_INT 12
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 3
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 3
1256: PUSH
1257: LD_INT 13
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 44887 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PPUSH
1284: CALL 45072 0 2
// MC_SetTame ( 4 , powellApe ) ;
1288: LD_INT 4
1290: PPUSH
1291: LD_INT 11
1293: PPUSH
1294: CALL 45453 0 2
// end ;
1298: LD_VAR 0 1
1302: RET
// every 0 0$1 trigger debug do var i ;
1303: LD_EXP 1
1307: IFFALSE 1405
1309: GO 1311
1311: DISABLE
1312: LD_INT 0
1314: PPUSH
// begin enable ;
1315: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1316: LD_ADDR_VAR 0 1
1320: PUSH
1321: LD_INT 22
1323: PUSH
1324: LD_INT 7
1326: PUSH
1327: EMPTY
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 2
1333: PUSH
1334: LD_INT 21
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 21
1346: PUSH
1347: LD_INT 2
1349: PUSH
1350: EMPTY
1351: LIST
1352: LIST
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 3
1361: PUSH
1362: LD_INT 24
1364: PUSH
1365: LD_INT 1000
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: PUSH
1372: EMPTY
1373: LIST
1374: LIST
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL_OW 69
1385: PUSH
1386: FOR_IN
1387: IFFALSE 1403
// SetLives ( i , 1000 ) ;
1389: LD_VAR 0 1
1393: PPUSH
1394: LD_INT 1000
1396: PPUSH
1397: CALL_OW 234
1401: GO 1386
1403: POP
1404: POP
// end ;
1405: PPOPN 1
1407: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1408: LD_EXP 16
1412: PUSH
1413: LD_INT 5
1415: GREATEREQUAL
1416: IFFALSE 1428
1418: GO 1420
1420: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1421: LD_STRING ACH_ARTIFACT
1423: PPUSH
1424: CALL_OW 543
1428: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1429: LD_INT 0
1431: PPUSH
1432: PPUSH
1433: PPUSH
1434: PPUSH
1435: PPUSH
// uc_side := 7 ;
1436: LD_ADDR_OWVAR 20
1440: PUSH
1441: LD_INT 7
1443: ST_TO_ADDR
// tmp := [ ] ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: EMPTY
1450: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1451: LD_ADDR_EXP 17
1455: PUSH
1456: LD_STRING JMM
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 14a_
1467: PPUSH
1468: CALL 51341 0 3
1472: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1473: LD_ADDR_EXP 49
1477: PUSH
1478: LD_STRING Burlak
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: LD_STRING 14a_
1489: PPUSH
1490: CALL 51341 0 3
1494: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1495: LD_ADDR_EXP 32
1499: PUSH
1500: LD_STRING Joan
1502: PPUSH
1503: LD_EXP 1
1507: NOT
1508: PPUSH
1509: LD_STRING 13a_
1511: PPUSH
1512: CALL 51341 0 3
1516: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1517: LD_ADDR_EXP 18
1521: PUSH
1522: LD_STRING Roth
1524: PPUSH
1525: LD_EXP 1
1529: NOT
1530: PPUSH
1531: LD_STRING 13a_
1533: PPUSH
1534: CALL 51341 0 3
1538: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1539: LD_ADDR_EXP 35
1543: PUSH
1544: LD_STRING Gossudarov
1546: PPUSH
1547: LD_EXP 1
1551: NOT
1552: PPUSH
1553: LD_STRING 13a_
1555: PPUSH
1556: CALL 51341 0 3
1560: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1561: LD_ADDR_EXP 23
1565: PUSH
1566: LD_STRING Denis
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 13a_
1577: PPUSH
1578: CALL 51341 0 3
1582: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1583: LD_ADDR_EXP 33
1587: PUSH
1588: LD_STRING DeltaDoctor
1590: PPUSH
1591: LD_EXP 1
1595: NOT
1596: PPUSH
1597: LD_STRING 13a_
1599: PPUSH
1600: CALL 51341 0 3
1604: ST_TO_ADDR
// if DeltaDoctor then
1605: LD_EXP 33
1609: IFFALSE 1627
// tmp := tmp ^ DeltaDoctor ;
1611: LD_ADDR_VAR 0 5
1615: PUSH
1616: LD_VAR 0 5
1620: PUSH
1621: LD_EXP 33
1625: ADD
1626: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1627: LD_ADDR_EXP 31
1631: PUSH
1632: LD_STRING Simms
1634: PPUSH
1635: LD_EXP 1
1639: NOT
1640: PPUSH
1641: LD_STRING 13a_
1643: PPUSH
1644: CALL 51341 0 3
1648: ST_TO_ADDR
// if Simms then
1649: LD_EXP 31
1653: IFFALSE 1671
// tmp := tmp ^ Simms ;
1655: LD_ADDR_VAR 0 5
1659: PUSH
1660: LD_VAR 0 5
1664: PUSH
1665: LD_EXP 31
1669: ADD
1670: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1671: LD_ADDR_EXP 29
1675: PUSH
1676: LD_STRING Frank
1678: PPUSH
1679: LD_EXP 1
1683: NOT
1684: PPUSH
1685: LD_STRING 13a_
1687: PPUSH
1688: CALL 51341 0 3
1692: ST_TO_ADDR
// if Frank then
1693: LD_EXP 29
1697: IFFALSE 1715
// tmp := tmp ^ Frank ;
1699: LD_ADDR_VAR 0 5
1703: PUSH
1704: LD_VAR 0 5
1708: PUSH
1709: LD_EXP 29
1713: ADD
1714: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1715: LD_ADDR_EXP 36
1719: PUSH
1720: LD_STRING Kirilenkova
1722: PPUSH
1723: LD_EXP 1
1727: NOT
1728: PPUSH
1729: LD_STRING 13a_
1731: PPUSH
1732: CALL 51341 0 3
1736: ST_TO_ADDR
// if Kirilenkova then
1737: LD_EXP 36
1741: IFFALSE 1759
// tmp := tmp ^ Kirilenkova ;
1743: LD_ADDR_VAR 0 5
1747: PUSH
1748: LD_VAR 0 5
1752: PUSH
1753: LD_EXP 36
1757: ADD
1758: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1759: LD_ADDR_EXP 37
1763: PUSH
1764: LD_STRING Titov
1766: PPUSH
1767: LD_EXP 1
1771: NOT
1772: PPUSH
1773: LD_STRING 13a_
1775: PPUSH
1776: CALL 51341 0 3
1780: ST_TO_ADDR
// if Titov then
1781: LD_EXP 37
1785: IFFALSE 1803
// tmp := tmp ^ Titov ;
1787: LD_ADDR_VAR 0 5
1791: PUSH
1792: LD_VAR 0 5
1796: PUSH
1797: LD_EXP 37
1801: ADD
1802: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1803: LD_ADDR_EXP 38
1807: PUSH
1808: LD_STRING Fadeev
1810: PPUSH
1811: LD_EXP 1
1815: NOT
1816: PPUSH
1817: LD_STRING 13a_
1819: PPUSH
1820: CALL 51341 0 3
1824: ST_TO_ADDR
// if Fadeev then
1825: LD_EXP 38
1829: IFFALSE 1847
// tmp := tmp ^ Fadeev ;
1831: LD_ADDR_VAR 0 5
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 38
1845: ADD
1846: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1847: LD_ADDR_EXP 39
1851: PUSH
1852: LD_STRING Dolgov
1854: PPUSH
1855: LD_EXP 1
1859: NOT
1860: PPUSH
1861: LD_STRING 13a_
1863: PPUSH
1864: CALL 51341 0 3
1868: ST_TO_ADDR
// if Dolgov then
1869: LD_EXP 39
1873: IFFALSE 1891
// tmp := tmp ^ Dolgov ;
1875: LD_ADDR_VAR 0 5
1879: PUSH
1880: LD_VAR 0 5
1884: PUSH
1885: LD_EXP 39
1889: ADD
1890: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1891: LD_ADDR_EXP 40
1895: PUSH
1896: LD_STRING Petrosyan
1898: PPUSH
1899: LD_EXP 1
1903: NOT
1904: PPUSH
1905: LD_STRING 13a_
1907: PPUSH
1908: CALL 51341 0 3
1912: ST_TO_ADDR
// if Petrosyan then
1913: LD_EXP 40
1917: IFFALSE 1935
// tmp := tmp ^ Petrosyan ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_VAR 0 5
1928: PUSH
1929: LD_EXP 40
1933: ADD
1934: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1935: LD_ADDR_EXP 41
1939: PUSH
1940: LD_STRING Scholtze
1942: PPUSH
1943: LD_EXP 1
1947: NOT
1948: PPUSH
1949: LD_STRING 13a_
1951: PPUSH
1952: CALL 51341 0 3
1956: ST_TO_ADDR
// if Scholtze then
1957: LD_EXP 41
1961: IFFALSE 1979
// tmp := tmp ^ Scholtze ;
1963: LD_ADDR_VAR 0 5
1967: PUSH
1968: LD_VAR 0 5
1972: PUSH
1973: LD_EXP 41
1977: ADD
1978: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1979: LD_ADDR_EXP 42
1983: PUSH
1984: LD_STRING Oblukov
1986: PPUSH
1987: LD_EXP 1
1991: NOT
1992: PPUSH
1993: LD_STRING 13a_
1995: PPUSH
1996: CALL 51341 0 3
2000: ST_TO_ADDR
// if Oblukov then
2001: LD_EXP 42
2005: IFFALSE 2023
// tmp := tmp ^ Oblukov ;
2007: LD_ADDR_VAR 0 5
2011: PUSH
2012: LD_VAR 0 5
2016: PUSH
2017: LD_EXP 42
2021: ADD
2022: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2023: LD_ADDR_EXP 43
2027: PUSH
2028: LD_STRING Kapitsova
2030: PPUSH
2031: LD_EXP 1
2035: NOT
2036: PPUSH
2037: LD_STRING 13a_
2039: PPUSH
2040: CALL 51341 0 3
2044: ST_TO_ADDR
// if Kapitsova then
2045: LD_EXP 43
2049: IFFALSE 2067
// tmp := tmp ^ Kapitsova ;
2051: LD_ADDR_VAR 0 5
2055: PUSH
2056: LD_VAR 0 5
2060: PUSH
2061: LD_EXP 43
2065: ADD
2066: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2067: LD_ADDR_EXP 44
2071: PUSH
2072: LD_STRING Lipshchin
2074: PPUSH
2075: LD_EXP 1
2079: NOT
2080: PPUSH
2081: LD_STRING 13a_
2083: PPUSH
2084: CALL 51341 0 3
2088: ST_TO_ADDR
// if Lipshchin then
2089: LD_EXP 44
2093: IFFALSE 2111
// tmp := tmp ^ Lipshchin ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 5
2104: PUSH
2105: LD_EXP 44
2109: ADD
2110: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2111: LD_ADDR_EXP 45
2115: PUSH
2116: LD_STRING Petrovova
2118: PPUSH
2119: LD_EXP 1
2123: NOT
2124: PPUSH
2125: LD_STRING 13a_
2127: PPUSH
2128: CALL 51341 0 3
2132: ST_TO_ADDR
// if Petrovova then
2133: LD_EXP 45
2137: IFFALSE 2155
// tmp := tmp ^ Petrovova ;
2139: LD_ADDR_VAR 0 5
2143: PUSH
2144: LD_VAR 0 5
2148: PUSH
2149: LD_EXP 45
2153: ADD
2154: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2155: LD_ADDR_EXP 46
2159: PUSH
2160: LD_STRING Kovalyuk
2162: PPUSH
2163: LD_EXP 1
2167: NOT
2168: PPUSH
2169: LD_STRING 13a_
2171: PPUSH
2172: CALL 51341 0 3
2176: ST_TO_ADDR
// if Kovalyuk then
2177: LD_EXP 46
2181: IFFALSE 2199
// tmp := tmp ^ Kovalyuk ;
2183: LD_ADDR_VAR 0 5
2187: PUSH
2188: LD_VAR 0 5
2192: PUSH
2193: LD_EXP 46
2197: ADD
2198: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2199: LD_ADDR_EXP 47
2203: PUSH
2204: LD_STRING Kuzmov
2206: PPUSH
2207: LD_EXP 1
2211: NOT
2212: PPUSH
2213: LD_STRING 13a_
2215: PPUSH
2216: CALL 51341 0 3
2220: ST_TO_ADDR
// if Kuzmov then
2221: LD_EXP 47
2225: IFFALSE 2243
// tmp := tmp ^ Kuzmov ;
2227: LD_ADDR_VAR 0 5
2231: PUSH
2232: LD_VAR 0 5
2236: PUSH
2237: LD_EXP 47
2241: ADD
2242: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2243: LD_ADDR_EXP 48
2247: PUSH
2248: LD_STRING Karamazov
2250: PPUSH
2251: LD_EXP 1
2255: NOT
2256: PPUSH
2257: LD_STRING 13a_
2259: PPUSH
2260: CALL 51341 0 3
2264: ST_TO_ADDR
// if Karamazov then
2265: LD_EXP 48
2269: IFFALSE 2287
// tmp := tmp ^ Karamazov ;
2271: LD_ADDR_VAR 0 5
2275: PUSH
2276: LD_VAR 0 5
2280: PUSH
2281: LD_EXP 48
2285: ADD
2286: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2287: LD_ADDR_EXP 50
2291: PUSH
2292: LD_STRING Belkov
2294: PPUSH
2295: LD_EXP 1
2299: NOT
2300: PPUSH
2301: LD_STRING 13a_
2303: PPUSH
2304: CALL 51341 0 3
2308: ST_TO_ADDR
// if Belkov then
2309: LD_EXP 50
2313: IFFALSE 2331
// tmp := tmp ^ Belkov ;
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 5
2324: PUSH
2325: LD_EXP 50
2329: ADD
2330: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2331: LD_ADDR_EXP 51
2335: PUSH
2336: LD_STRING Gnyevko
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13a_
2347: PPUSH
2348: CALL 51341 0 3
2352: ST_TO_ADDR
// if Gnyevko then
2353: LD_EXP 51
2357: IFFALSE 2375
// tmp := tmp ^ Gnyevko ;
2359: LD_ADDR_VAR 0 5
2363: PUSH
2364: LD_VAR 0 5
2368: PUSH
2369: LD_EXP 51
2373: ADD
2374: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2375: LD_ADDR_EXP 34
2379: PUSH
2380: LD_STRING Coonie
2382: PPUSH
2383: CALL_OW 25
2387: ST_TO_ADDR
// if not Lisa then
2388: LD_EXP 19
2392: NOT
2393: IFFALSE 2439
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2395: LD_ADDR_EXP 19
2399: PUSH
2400: LD_STRING Lisa
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13a_
2411: PPUSH
2412: CALL 51341 0 3
2416: ST_TO_ADDR
// if Lisa then
2417: LD_EXP 19
2421: IFFALSE 2439
// tmp := tmp ^ Lisa ;
2423: LD_ADDR_VAR 0 5
2427: PUSH
2428: LD_VAR 0 5
2432: PUSH
2433: LD_EXP 19
2437: ADD
2438: ST_TO_ADDR
// end ; if not Donaldson then
2439: LD_EXP 20
2443: NOT
2444: IFFALSE 2490
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2446: LD_ADDR_EXP 20
2450: PUSH
2451: LD_STRING Donaldson
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13a_
2462: PPUSH
2463: CALL 51341 0 3
2467: ST_TO_ADDR
// if Donaldson then
2468: LD_EXP 20
2472: IFFALSE 2490
// tmp := tmp ^ Donaldson ;
2474: LD_ADDR_VAR 0 5
2478: PUSH
2479: LD_VAR 0 5
2483: PUSH
2484: LD_EXP 20
2488: ADD
2489: ST_TO_ADDR
// end ; if not Bobby then
2490: LD_EXP 21
2494: NOT
2495: IFFALSE 2541
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2497: LD_ADDR_EXP 21
2501: PUSH
2502: LD_STRING Bobby
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13a_
2513: PPUSH
2514: CALL 51341 0 3
2518: ST_TO_ADDR
// if Bobby then
2519: LD_EXP 21
2523: IFFALSE 2541
// tmp := tmp ^ Bobby ;
2525: LD_ADDR_VAR 0 5
2529: PUSH
2530: LD_VAR 0 5
2534: PUSH
2535: LD_EXP 21
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cyrus then
2541: LD_EXP 22
2545: NOT
2546: IFFALSE 2592
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2548: LD_ADDR_EXP 22
2552: PUSH
2553: LD_STRING Cyrus
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13a_
2564: PPUSH
2565: CALL 51341 0 3
2569: ST_TO_ADDR
// if Cyrus then
2570: LD_EXP 22
2574: IFFALSE 2592
// tmp := tmp ^ Cyrus ;
2576: LD_ADDR_VAR 0 5
2580: PUSH
2581: LD_VAR 0 5
2585: PUSH
2586: LD_EXP 22
2590: ADD
2591: ST_TO_ADDR
// end ; if not Brown then
2592: LD_EXP 24
2596: NOT
2597: IFFALSE 2643
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2599: LD_ADDR_EXP 24
2603: PUSH
2604: LD_STRING Brown
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13a_
2615: PPUSH
2616: CALL 51341 0 3
2620: ST_TO_ADDR
// if Brown then
2621: LD_EXP 24
2625: IFFALSE 2643
// tmp := tmp ^ Brown ;
2627: LD_ADDR_VAR 0 5
2631: PUSH
2632: LD_VAR 0 5
2636: PUSH
2637: LD_EXP 24
2641: ADD
2642: ST_TO_ADDR
// end ; if not Gladstone then
2643: LD_EXP 25
2647: NOT
2648: IFFALSE 2694
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2650: LD_ADDR_EXP 25
2654: PUSH
2655: LD_STRING Gladstone
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13a_
2666: PPUSH
2667: CALL 51341 0 3
2671: ST_TO_ADDR
// if Gladstone then
2672: LD_EXP 25
2676: IFFALSE 2694
// tmp := tmp ^ Gladstone ;
2678: LD_ADDR_VAR 0 5
2682: PUSH
2683: LD_VAR 0 5
2687: PUSH
2688: LD_EXP 25
2692: ADD
2693: ST_TO_ADDR
// end ; if not Cornel then
2694: LD_EXP 27
2698: NOT
2699: IFFALSE 2745
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2701: LD_ADDR_EXP 27
2705: PUSH
2706: LD_STRING Cornel
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13a_
2717: PPUSH
2718: CALL 51341 0 3
2722: ST_TO_ADDR
// if Cornel then
2723: LD_EXP 27
2727: IFFALSE 2745
// tmp := tmp ^ Cornel ;
2729: LD_ADDR_VAR 0 5
2733: PUSH
2734: LD_VAR 0 5
2738: PUSH
2739: LD_EXP 27
2743: ADD
2744: ST_TO_ADDR
// end ; if not Houten then
2745: LD_EXP 26
2749: NOT
2750: IFFALSE 2796
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2752: LD_ADDR_EXP 26
2756: PUSH
2757: LD_STRING Houten
2759: PPUSH
2760: LD_EXP 1
2764: NOT
2765: PPUSH
2766: LD_STRING 13a_
2768: PPUSH
2769: CALL 51341 0 3
2773: ST_TO_ADDR
// if Houten then
2774: LD_EXP 26
2778: IFFALSE 2796
// tmp := tmp ^ Houten ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_EXP 26
2794: ADD
2795: ST_TO_ADDR
// end ; if not Gary then
2796: LD_EXP 28
2800: NOT
2801: IFFALSE 2847
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2803: LD_ADDR_EXP 28
2807: PUSH
2808: LD_STRING Gary
2810: PPUSH
2811: LD_EXP 1
2815: NOT
2816: PPUSH
2817: LD_STRING 13a_
2819: PPUSH
2820: CALL 51341 0 3
2824: ST_TO_ADDR
// if Gary then
2825: LD_EXP 28
2829: IFFALSE 2847
// tmp := tmp ^ Gary ;
2831: LD_ADDR_VAR 0 5
2835: PUSH
2836: LD_VAR 0 5
2840: PUSH
2841: LD_EXP 28
2845: ADD
2846: ST_TO_ADDR
// end ; if not Kikuchi then
2847: LD_EXP 30
2851: NOT
2852: IFFALSE 2898
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2854: LD_ADDR_EXP 30
2858: PUSH
2859: LD_STRING Kikuchi
2861: PPUSH
2862: LD_EXP 1
2866: NOT
2867: PPUSH
2868: LD_STRING 13a_
2870: PPUSH
2871: CALL 51341 0 3
2875: ST_TO_ADDR
// if Kikuchi then
2876: LD_EXP 30
2880: IFFALSE 2898
// tmp := tmp ^ Kikuchi ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_EXP 30
2896: ADD
2897: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2898: LD_ADDR_VAR 0 5
2902: PUSH
2903: LD_VAR 0 5
2907: PUSH
2908: LD_STRING 13a_others
2910: PPUSH
2911: CALL_OW 31
2915: UNION
2916: ST_TO_ADDR
// tmp := tmp diff 0 ;
2917: LD_ADDR_VAR 0 5
2921: PUSH
2922: LD_VAR 0 5
2926: PUSH
2927: LD_INT 0
2929: DIFF
2930: ST_TO_ADDR
// if tmp < 15 then
2931: LD_VAR 0 5
2935: PUSH
2936: LD_INT 15
2938: LESS
2939: IFFALSE 3027
// for i = 15 downto tmp do
2941: LD_ADDR_VAR 0 2
2945: PUSH
2946: DOUBLE
2947: LD_INT 15
2949: INC
2950: ST_TO_ADDR
2951: LD_VAR 0 5
2955: PUSH
2956: FOR_DOWNTO
2957: IFFALSE 3025
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2959: LD_ADDR_OWVAR 21
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: LD_INT 3
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: PUSH
2974: LD_INT 1
2976: PPUSH
2977: LD_INT 2
2979: PPUSH
2980: CALL_OW 12
2984: ARRAY
2985: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2986: LD_INT 0
2988: PPUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 4
2994: PPUSH
2995: CALL_OW 12
2999: PPUSH
3000: LD_INT 8
3002: PPUSH
3003: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3007: LD_ADDR_VAR 0 5
3011: PUSH
3012: LD_VAR 0 5
3016: PUSH
3017: CALL_OW 44
3021: ADD
3022: ST_TO_ADDR
// end ;
3023: GO 2956
3025: POP
3026: POP
// if not debug then
3027: LD_EXP 1
3031: NOT
3032: IFFALSE 3212
// selected = CharacterSelection (  , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3034: LD_ADDR_VAR 0 4
3038: PUSH
3039: LD_STRING 
3041: PPUSH
3042: LD_INT 15
3044: PUSH
3045: LD_INT 14
3047: PUSH
3048: LD_INT 13
3050: PUSH
3051: LD_INT 12
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_OWVAR 67
3064: ARRAY
3065: PPUSH
3066: LD_INT 15
3068: PUSH
3069: LD_INT 14
3071: PUSH
3072: LD_INT 13
3074: PUSH
3075: LD_INT 12
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: PUSH
3084: LD_OWVAR 67
3088: ARRAY
3089: PPUSH
3090: LD_INT -5
3092: PUSH
3093: LD_EXP 17
3097: PUSH
3098: LD_EXP 49
3102: PUSH
3103: LD_EXP 18
3107: PUSH
3108: LD_EXP 32
3112: PUSH
3113: LD_EXP 23
3117: PUSH
3118: LD_EXP 35
3122: PUSH
3123: LD_INT -2
3125: PUSH
3126: LD_INT -3
3128: PUSH
3129: LD_INT -5
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PUSH
3144: LD_VAR 0 5
3148: ADD
3149: PPUSH
3150: LD_INT 1
3152: PUSH
3153: LD_INT 4
3155: PUSH
3156: LD_INT 2
3158: PUSH
3159: LD_INT 1
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: PUSH
3166: LD_INT 3
3168: PUSH
3169: LD_INT 5
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: LD_INT 3
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: LIST
3182: PUSH
3183: LD_INT 9
3185: PUSH
3186: LD_INT 0
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: LIST
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: CALL_OW 42
3209: ST_TO_ADDR
3210: GO 3291
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3212: LD_ADDR_VAR 0 4
3216: PUSH
3217: LD_EXP 37
3221: PUSH
3222: LD_EXP 38
3226: PUSH
3227: LD_EXP 39
3231: PUSH
3232: LD_EXP 40
3236: PUSH
3237: LD_EXP 41
3241: PUSH
3242: LD_EXP 42
3246: PUSH
3247: LD_EXP 43
3251: PUSH
3252: LD_EXP 44
3256: PUSH
3257: LD_EXP 45
3261: PUSH
3262: LD_EXP 46
3266: PUSH
3267: LD_EXP 47
3271: PUSH
3272: LD_EXP 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: ST_TO_ADDR
// uc_nation := 1 ;
3291: LD_ADDR_OWVAR 21
3295: PUSH
3296: LD_INT 1
3298: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3299: LD_INT 5
3301: PPUSH
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 6
3310: PPUSH
3311: LD_INT 100
3313: PPUSH
3314: CALL 56205 0 5
// veh := CreateVehicle ;
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: CALL_OW 45
3327: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3328: LD_VAR 0 3
3332: PPUSH
3333: LD_INT 7
3335: NEG
3336: PPUSH
3337: CALL_OW 242
// SetDir ( veh , 3 ) ;
3341: LD_VAR 0 3
3345: PPUSH
3346: LD_INT 3
3348: PPUSH
3349: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3353: LD_VAR 0 3
3357: PPUSH
3358: LD_INT 31
3360: PPUSH
3361: LD_INT 0
3363: PPUSH
3364: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3368: LD_EXP 17
3372: PPUSH
3373: LD_VAR 0 3
3377: PPUSH
3378: CALL_OW 52
// if Joan then
3382: LD_EXP 32
3386: IFFALSE 3458
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3388: LD_INT 3
3390: PPUSH
3391: LD_INT 3
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: LD_INT 11
3399: PPUSH
3400: LD_INT 100
3402: PPUSH
3403: CALL 56205 0 5
// veh := CreateVehicle ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: CALL_OW 45
3416: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3417: LD_VAR 0 3
3421: PPUSH
3422: LD_INT 3
3424: PPUSH
3425: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3429: LD_VAR 0 3
3433: PPUSH
3434: LD_INT 30
3436: PPUSH
3437: LD_INT 0
3439: PPUSH
3440: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3444: LD_EXP 32
3448: PPUSH
3449: LD_VAR 0 3
3453: PPUSH
3454: CALL_OW 52
// end ; if Roth then
3458: LD_EXP 18
3462: IFFALSE 3534
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3464: LD_INT 3
3466: PPUSH
3467: LD_INT 3
3469: PPUSH
3470: LD_INT 1
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: LD_INT 100
3478: PPUSH
3479: CALL 56205 0 5
// veh := CreateVehicle ;
3483: LD_ADDR_VAR 0 3
3487: PUSH
3488: CALL_OW 45
3492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3493: LD_VAR 0 3
3497: PPUSH
3498: LD_INT 3
3500: PPUSH
3501: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3505: LD_VAR 0 3
3509: PPUSH
3510: LD_INT 30
3512: PPUSH
3513: LD_INT 0
3515: PPUSH
3516: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3520: LD_EXP 18
3524: PPUSH
3525: LD_VAR 0 3
3529: PPUSH
3530: CALL_OW 52
// end ; if Denis then
3534: LD_EXP 23
3538: IFFALSE 3610
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3540: LD_INT 5
3542: PPUSH
3543: LD_INT 3
3545: PPUSH
3546: LD_INT 1
3548: PPUSH
3549: LD_INT 9
3551: PPUSH
3552: LD_INT 100
3554: PPUSH
3555: CALL 56205 0 5
// veh := CreateVehicle ;
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: CALL_OW 45
3568: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3569: LD_VAR 0 3
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3581: LD_VAR 0 3
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 0
3591: PPUSH
3592: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3596: LD_EXP 23
3600: PPUSH
3601: LD_VAR 0 3
3605: PPUSH
3606: CALL_OW 52
// end ; uc_nation := 3 ;
3610: LD_ADDR_OWVAR 21
3614: PUSH
3615: LD_INT 3
3617: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3618: LD_INT 22
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 100
3632: PPUSH
3633: CALL 56205 0 5
// veh := CreateVehicle ;
3637: LD_ADDR_VAR 0 3
3641: PUSH
3642: CALL_OW 45
3646: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3647: LD_VAR 0 3
3651: PPUSH
3652: LD_INT 7
3654: NEG
3655: PPUSH
3656: CALL_OW 242
// SetDir ( veh , 3 ) ;
3660: LD_VAR 0 3
3664: PPUSH
3665: LD_INT 3
3667: PPUSH
3668: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3672: LD_VAR 0 3
3676: PPUSH
3677: LD_INT 31
3679: PPUSH
3680: LD_INT 0
3682: PPUSH
3683: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3687: LD_EXP 49
3691: PPUSH
3692: LD_VAR 0 3
3696: PPUSH
3697: CALL_OW 52
// if Gossudarov then
3701: LD_EXP 35
3705: IFFALSE 3792
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3707: LD_INT 22
3709: PPUSH
3710: LD_INT 3
3712: PPUSH
3713: LD_INT 1
3715: PPUSH
3716: LD_INT 51
3718: PPUSH
3719: LD_INT 100
3721: PPUSH
3722: CALL 56205 0 5
// veh := CreateVehicle ;
3726: LD_ADDR_VAR 0 3
3730: PUSH
3731: CALL_OW 45
3735: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3736: LD_VAR 0 3
3740: PPUSH
3741: LD_INT 3
3743: PPUSH
3744: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3748: LD_VAR 0 3
3752: PPUSH
3753: LD_INT 30
3755: PPUSH
3756: LD_INT 0
3758: PPUSH
3759: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3763: LD_EXP 35
3767: PPUSH
3768: LD_VAR 0 3
3772: PPUSH
3773: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3777: LD_VAR 0 3
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 100
3787: PPUSH
3788: CALL_OW 290
// end ; for i in selected do
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: LD_VAR 0 4
3801: PUSH
3802: FOR_IN
3803: IFFALSE 4361
// begin uc_nation := GetNation ( i ) ;
3805: LD_ADDR_OWVAR 21
3809: PUSH
3810: LD_VAR 0 2
3814: PPUSH
3815: CALL_OW 248
3819: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3820: LD_VAR 0 2
3824: PUSH
3825: LD_EXP 19
3829: PUSH
3830: LD_EXP 20
3834: PUSH
3835: LD_EXP 22
3839: PUSH
3840: LD_EXP 21
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: LIST
3850: IN
3851: IFFALSE 3874
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3853: LD_INT 5
3855: PPUSH
3856: LD_INT 3
3858: PPUSH
3859: LD_INT 1
3861: PPUSH
3862: LD_INT 6
3864: PPUSH
3865: LD_INT 100
3867: PPUSH
3868: CALL 56205 0 5
3872: GO 4308
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 42
3883: PUSH
3884: LD_EXP 47
3888: PUSH
3889: LD_EXP 45
3893: PUSH
3894: LD_EXP 37
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: LIST
3903: LIST
3904: IN
3905: IFFALSE 3936
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3907: LD_INT 24
3909: PPUSH
3910: LD_INT 1
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: LD_INT 46
3918: PPUSH
3919: LD_INT 65
3921: PPUSH
3922: LD_INT 75
3924: PPUSH
3925: CALL_OW 12
3929: PPUSH
3930: CALL 56205 0 5
3934: GO 4308
// if i = Karamazov then
3936: LD_VAR 0 2
3940: PUSH
3941: LD_EXP 48
3945: EQUAL
3946: IFFALSE 3969
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3948: LD_INT 22
3950: PPUSH
3951: LD_INT 3
3953: PPUSH
3954: LD_INT 1
3956: PPUSH
3957: LD_INT 52
3959: PPUSH
3960: LD_INT 100
3962: PPUSH
3963: CALL 56205 0 5
3967: GO 4308
// if i = Brown then
3969: LD_VAR 0 2
3973: PUSH
3974: LD_EXP 24
3978: EQUAL
3979: IFFALSE 4002
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3981: LD_INT 3
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 13
3992: PPUSH
3993: LD_INT 100
3995: PPUSH
3996: CALL 56205 0 5
4000: GO 4308
// if uc_nation = nation_american then
4002: LD_OWVAR 21
4006: PUSH
4007: LD_INT 1
4009: EQUAL
4010: IFFALSE 4161
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4012: LD_INT 3
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: LD_INT 5
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: LIST
4025: PUSH
4026: LD_OWVAR 21
4030: PUSH
4031: LD_INT 3
4033: MOD
4034: PUSH
4035: LD_INT 1
4037: PLUS
4038: ARRAY
4039: PPUSH
4040: LD_INT 1
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: LIST
4053: PUSH
4054: LD_OWVAR 21
4058: PUSH
4059: LD_INT 3
4061: MOD
4062: PUSH
4063: LD_INT 1
4065: PLUS
4066: ARRAY
4067: PPUSH
4068: LD_INT 1
4070: PPUSH
4071: LD_INT 11
4073: PUSH
4074: LD_INT 4
4076: PUSH
4077: LD_INT 5
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: LIST
4084: PUSH
4085: LD_INT 6
4087: PUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 9
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: PUSH
4099: LD_INT 6
4101: PUSH
4102: LD_INT 9
4104: PUSH
4105: LD_INT 12
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: PUSH
4118: LD_OWVAR 21
4122: PUSH
4123: LD_INT 3
4125: MOD
4126: PUSH
4127: LD_INT 1
4129: PLUS
4130: ARRAY
4131: PUSH
4132: LD_INT 1
4134: PPUSH
4135: LD_INT 3
4137: PPUSH
4138: CALL_OW 12
4142: ARRAY
4143: PPUSH
4144: LD_INT 65
4146: PPUSH
4147: LD_INT 75
4149: PPUSH
4150: CALL_OW 12
4154: PPUSH
4155: CALL 56205 0 5
// end else
4159: GO 4308
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4161: LD_INT 22
4163: PUSH
4164: LD_INT 23
4166: PUSH
4167: LD_INT 23
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: LIST
4174: PUSH
4175: LD_OWVAR 21
4179: PUSH
4180: LD_INT 3
4182: MOD
4183: PUSH
4184: LD_INT 1
4186: PLUS
4187: ARRAY
4188: PPUSH
4189: LD_INT 1
4191: PUSH
4192: LD_INT 3
4194: PUSH
4195: LD_INT 1
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: LIST
4202: PUSH
4203: LD_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: MOD
4211: PUSH
4212: LD_INT 1
4214: PLUS
4215: ARRAY
4216: PPUSH
4217: LD_INT 1
4219: PPUSH
4220: LD_INT 45
4222: PUSH
4223: LD_INT 43
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 46
4236: PUSH
4237: LD_INT 45
4239: PUSH
4240: LD_INT 44
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: LIST
4247: PUSH
4248: LD_INT 46
4250: PUSH
4251: LD_INT 43
4253: PUSH
4254: LD_INT 45
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: LIST
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_OWVAR 21
4271: PUSH
4272: LD_INT 3
4274: MOD
4275: PUSH
4276: LD_INT 1
4278: PLUS
4279: ARRAY
4280: PUSH
4281: LD_INT 1
4283: PPUSH
4284: LD_INT 3
4286: PPUSH
4287: CALL_OW 12
4291: ARRAY
4292: PPUSH
4293: LD_INT 65
4295: PPUSH
4296: LD_INT 75
4298: PPUSH
4299: CALL_OW 12
4303: PPUSH
4304: CALL 56205 0 5
// end ; veh := CreateVehicle ;
4308: LD_ADDR_VAR 0 3
4312: PUSH
4313: CALL_OW 45
4317: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4318: LD_VAR 0 3
4322: PPUSH
4323: LD_INT 3
4325: PPUSH
4326: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4330: LD_VAR 0 3
4334: PPUSH
4335: LD_INT 30
4337: PPUSH
4338: LD_INT 0
4340: PPUSH
4341: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4345: LD_VAR 0 2
4349: PPUSH
4350: LD_VAR 0 3
4354: PPUSH
4355: CALL_OW 52
// end ;
4359: GO 3802
4361: POP
4362: POP
// if artifactArCaptured then
4363: LD_EXP 9
4367: IFFALSE 4453
// begin uc_nation := nation_american ;
4369: LD_ADDR_OWVAR 21
4373: PUSH
4374: LD_INT 1
4376: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4377: LD_INT 3
4379: PPUSH
4380: LD_INT 3
4382: PPUSH
4383: LD_INT 3
4385: PPUSH
4386: LD_INT 12
4388: PPUSH
4389: LD_INT 100
4391: PPUSH
4392: CALL 56205 0 5
// veh := CreateVehicle ;
4396: LD_ADDR_VAR 0 3
4400: PUSH
4401: CALL_OW 45
4405: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4406: LD_VAR 0 3
4410: PPUSH
4411: LD_INT 3
4413: PPUSH
4414: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4418: LD_VAR 0 3
4422: PPUSH
4423: LD_INT 198
4425: PPUSH
4426: LD_INT 22
4428: PPUSH
4429: LD_INT 0
4431: PPUSH
4432: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4436: LD_VAR 0 3
4440: PPUSH
4441: LD_INT 4
4443: PPUSH
4444: LD_INT 50
4446: PPUSH
4447: CALL_OW 290
// end else
4451: GO 4472
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 5
4458: PPUSH
4459: LD_INT 267
4461: PPUSH
4462: LD_INT 226
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 58
// end ; uc_nation := nation_american ;
4472: LD_ADDR_OWVAR 21
4476: PUSH
4477: LD_INT 1
4479: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4480: LD_INT 3
4482: PPUSH
4483: LD_INT 3
4485: PPUSH
4486: LD_INT 3
4488: PPUSH
4489: LD_INT 12
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 56205 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4509: LD_VAR 0 3
4513: PPUSH
4514: LD_INT 3
4516: PPUSH
4517: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4521: LD_VAR 0 3
4525: PPUSH
4526: LD_INT 218
4528: PPUSH
4529: LD_INT 23
4531: PPUSH
4532: LD_INT 0
4534: PPUSH
4535: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4539: LD_VAR 0 3
4543: PPUSH
4544: LD_INT 4
4546: PPUSH
4547: LD_INT 30
4549: PPUSH
4550: CALL_OW 290
// uc_nation := nation_russian ;
4554: LD_ADDR_OWVAR 21
4558: PUSH
4559: LD_INT 3
4561: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4562: LD_INT 22
4564: PPUSH
4565: LD_INT 3
4567: PPUSH
4568: LD_INT 3
4570: PPUSH
4571: LD_INT 51
4573: PPUSH
4574: LD_INT 100
4576: PPUSH
4577: CALL 56205 0 5
// veh := CreateVehicle ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: CALL_OW 45
4590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 3
4598: PPUSH
4599: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4603: LD_VAR 0 3
4607: PPUSH
4608: LD_INT 214
4610: PPUSH
4611: LD_INT 20
4613: PPUSH
4614: LD_INT 0
4616: PPUSH
4617: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4621: LD_VAR 0 3
4625: PPUSH
4626: LD_INT 4
4628: PPUSH
4629: LD_INT 40
4631: PPUSH
4632: CALL_OW 290
// end ; end_of_file
4636: LD_VAR 0 1
4640: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
4647: PPUSH
4648: PPUSH
4649: PPUSH
4650: PPUSH
4651: PPUSH
4652: PPUSH
// InitHc ;
4653: CALL_OW 19
// uc_side := 1 ;
4657: LD_ADDR_OWVAR 20
4661: PUSH
4662: LD_INT 1
4664: ST_TO_ADDR
// uc_nation := 1 ;
4665: LD_ADDR_OWVAR 21
4669: PUSH
4670: LD_INT 1
4672: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4673: LD_ADDR_VAR 0 2
4677: PUSH
4678: LD_INT 22
4680: PUSH
4681: LD_INT 1
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 21
4690: PUSH
4691: LD_INT 3
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PPUSH
4702: CALL_OW 69
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4724
// SetBLevel ( i , 10 ) ;
4710: LD_VAR 0 2
4714: PPUSH
4715: LD_INT 10
4717: PPUSH
4718: CALL_OW 241
4722: GO 4707
4724: POP
4725: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4726: LD_INT 387
4728: PPUSH
4729: CALL_OW 274
4733: PPUSH
4734: LD_INT 1
4736: PPUSH
4737: LD_INT 7500
4739: PPUSH
4740: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4744: LD_INT 387
4746: PPUSH
4747: CALL_OW 274
4751: PPUSH
4752: LD_INT 2
4754: PPUSH
4755: LD_INT 4000
4757: PPUSH
4758: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4762: LD_INT 387
4764: PPUSH
4765: CALL_OW 274
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 50
4775: PPUSH
4776: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4780: LD_INT 476
4782: PPUSH
4783: CALL_OW 274
4787: PPUSH
4788: LD_INT 1
4790: PPUSH
4791: LD_INT 5500
4793: PPUSH
4794: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4798: LD_INT 476
4800: PPUSH
4801: CALL_OW 274
4805: PPUSH
4806: LD_INT 2
4808: PPUSH
4809: LD_INT 4000
4811: PPUSH
4812: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4816: LD_INT 476
4818: PPUSH
4819: CALL_OW 274
4823: PPUSH
4824: LD_INT 3
4826: PPUSH
4827: LD_INT 10
4829: PPUSH
4830: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4834: LD_ADDR_EXP 52
4838: PUSH
4839: LD_STRING Powell
4841: PPUSH
4842: CALL_OW 25
4846: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4847: LD_EXP 52
4851: PPUSH
4852: LD_INT 387
4854: PPUSH
4855: CALL_OW 52
// tmp := [ ] ;
4859: LD_ADDR_VAR 0 6
4863: PUSH
4864: EMPTY
4865: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4866: LD_ADDR_EXP 19
4870: PUSH
4871: LD_STRING Lisa
4873: PPUSH
4874: LD_EXP 1
4878: NOT
4879: PPUSH
4880: LD_STRING 12p_
4882: PPUSH
4883: CALL 51341 0 3
4887: ST_TO_ADDR
// if Lisa then
4888: LD_EXP 19
4892: IFFALSE 4910
// tmp := tmp ^ Lisa ;
4894: LD_ADDR_VAR 0 6
4898: PUSH
4899: LD_VAR 0 6
4903: PUSH
4904: LD_EXP 19
4908: ADD
4909: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4910: LD_ADDR_EXP 20
4914: PUSH
4915: LD_STRING Donaldson
4917: PPUSH
4918: LD_EXP 1
4922: NOT
4923: PPUSH
4924: LD_STRING 12p_
4926: PPUSH
4927: CALL 51341 0 3
4931: ST_TO_ADDR
// if Donaldson then
4932: LD_EXP 20
4936: IFFALSE 4954
// tmp := tmp ^ Donaldson ;
4938: LD_ADDR_VAR 0 6
4942: PUSH
4943: LD_VAR 0 6
4947: PUSH
4948: LD_EXP 20
4952: ADD
4953: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4954: LD_ADDR_EXP 21
4958: PUSH
4959: LD_STRING Bobby
4961: PPUSH
4962: LD_EXP 1
4966: NOT
4967: PPUSH
4968: LD_STRING 12p_
4970: PPUSH
4971: CALL 51341 0 3
4975: ST_TO_ADDR
// if Bobby then
4976: LD_EXP 21
4980: IFFALSE 4998
// tmp := tmp ^ Bobby ;
4982: LD_ADDR_VAR 0 6
4986: PUSH
4987: LD_VAR 0 6
4991: PUSH
4992: LD_EXP 21
4996: ADD
4997: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4998: LD_ADDR_EXP 22
5002: PUSH
5003: LD_STRING Cyrus
5005: PPUSH
5006: LD_EXP 1
5010: NOT
5011: PPUSH
5012: LD_STRING 12p_
5014: PPUSH
5015: CALL 51341 0 3
5019: ST_TO_ADDR
// if Cyrus then
5020: LD_EXP 22
5024: IFFALSE 5042
// tmp := tmp ^ Cyrus ;
5026: LD_ADDR_VAR 0 6
5030: PUSH
5031: LD_VAR 0 6
5035: PUSH
5036: LD_EXP 22
5040: ADD
5041: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5042: LD_ADDR_EXP 24
5046: PUSH
5047: LD_STRING Brown
5049: PPUSH
5050: LD_EXP 1
5054: NOT
5055: PPUSH
5056: LD_STRING 12p_
5058: PPUSH
5059: CALL 51341 0 3
5063: ST_TO_ADDR
// if Brown then
5064: LD_EXP 24
5068: IFFALSE 5086
// tmp := tmp ^ Brown ;
5070: LD_ADDR_VAR 0 6
5074: PUSH
5075: LD_VAR 0 6
5079: PUSH
5080: LD_EXP 24
5084: ADD
5085: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5086: LD_ADDR_EXP 25
5090: PUSH
5091: LD_STRING Gladstone
5093: PPUSH
5094: LD_EXP 1
5098: NOT
5099: PPUSH
5100: LD_STRING 12p_
5102: PPUSH
5103: CALL 51341 0 3
5107: ST_TO_ADDR
// if Gladstone then
5108: LD_EXP 25
5112: IFFALSE 5130
// tmp := tmp ^ Gladstone ;
5114: LD_ADDR_VAR 0 6
5118: PUSH
5119: LD_VAR 0 6
5123: PUSH
5124: LD_EXP 25
5128: ADD
5129: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5130: LD_ADDR_EXP 26
5134: PUSH
5135: LD_STRING Houten
5137: PPUSH
5138: LD_EXP 1
5142: NOT
5143: PPUSH
5144: LD_STRING 12p_
5146: PPUSH
5147: CALL 51341 0 3
5151: ST_TO_ADDR
// if Houten then
5152: LD_EXP 26
5156: IFFALSE 5174
// tmp := tmp ^ Houten ;
5158: LD_ADDR_VAR 0 6
5162: PUSH
5163: LD_VAR 0 6
5167: PUSH
5168: LD_EXP 26
5172: ADD
5173: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5174: LD_ADDR_EXP 27
5178: PUSH
5179: LD_STRING Cornel
5181: PPUSH
5182: LD_EXP 1
5186: NOT
5187: PPUSH
5188: LD_STRING 12p_
5190: PPUSH
5191: CALL 51341 0 3
5195: ST_TO_ADDR
// if Cornel then
5196: LD_EXP 27
5200: IFFALSE 5218
// tmp := tmp ^ Cornel ;
5202: LD_ADDR_VAR 0 6
5206: PUSH
5207: LD_VAR 0 6
5211: PUSH
5212: LD_EXP 27
5216: ADD
5217: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5218: LD_ADDR_EXP 28
5222: PUSH
5223: LD_STRING Gary
5225: PPUSH
5226: LD_EXP 1
5230: NOT
5231: PPUSH
5232: LD_STRING 12p_
5234: PPUSH
5235: CALL 51341 0 3
5239: ST_TO_ADDR
// if Gary then
5240: LD_EXP 28
5244: IFFALSE 5262
// tmp := tmp ^ Gary ;
5246: LD_ADDR_VAR 0 6
5250: PUSH
5251: LD_VAR 0 6
5255: PUSH
5256: LD_EXP 28
5260: ADD
5261: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5262: LD_ADDR_EXP 30
5266: PUSH
5267: LD_STRING Kikuchi
5269: PPUSH
5270: LD_EXP 1
5274: NOT
5275: PPUSH
5276: LD_STRING 12p_
5278: PPUSH
5279: CALL 51341 0 3
5283: ST_TO_ADDR
// if Kikuchi then
5284: LD_EXP 30
5288: IFFALSE 5306
// tmp := tmp ^ Kikuchi ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_EXP 30
5304: ADD
5305: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5306: LD_ADDR_VAR 0 6
5310: PUSH
5311: LD_VAR 0 6
5315: PUSH
5316: LD_STRING 12p_others
5318: PPUSH
5319: CALL_OW 31
5323: UNION
5324: ST_TO_ADDR
// if tmp < 36 then
5325: LD_VAR 0 6
5329: PUSH
5330: LD_INT 36
5332: LESS
5333: IFFALSE 5400
// for i = 1 to 36 - tmp do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 36
5347: PUSH
5348: LD_VAR 0 6
5352: MINUS
5353: PUSH
5354: FOR_TO
5355: IFFALSE 5398
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5357: LD_INT 1
5359: PPUSH
5360: LD_VAR 0 2
5364: PUSH
5365: LD_INT 4
5367: MOD
5368: PUSH
5369: LD_INT 1
5371: PLUS
5372: PPUSH
5373: LD_INT 10
5375: PPUSH
5376: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5380: LD_ADDR_VAR 0 6
5384: PUSH
5385: LD_VAR 0 6
5389: PUSH
5390: CALL_OW 44
5394: ADD
5395: ST_TO_ADDR
// end ;
5396: GO 5354
5398: POP
5399: POP
// for i in tmp do
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_VAR 0 6
5409: PUSH
5410: FOR_IN
5411: IFFALSE 5436
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5413: LD_VAR 0 2
5417: PPUSH
5418: LD_INT 62
5420: PPUSH
5421: LD_INT 93
5423: PPUSH
5424: LD_INT 9
5426: PPUSH
5427: LD_INT 0
5429: PPUSH
5430: CALL_OW 50
5434: GO 5410
5436: POP
5437: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5438: LD_ADDR_EXP 93
5442: PUSH
5443: LD_EXP 93
5447: PPUSH
5448: LD_INT 4
5450: PPUSH
5451: LD_INT 22
5453: PUSH
5454: LD_INT 1
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: CALL_OW 69
5465: PUSH
5466: LD_EXP 52
5470: DIFF
5471: PPUSH
5472: CALL_OW 1
5476: ST_TO_ADDR
// uc_side := 0 ;
5477: LD_ADDR_OWVAR 20
5481: PUSH
5482: LD_INT 0
5484: ST_TO_ADDR
// uc_nation := 0 ;
5485: LD_ADDR_OWVAR 21
5489: PUSH
5490: LD_INT 0
5492: ST_TO_ADDR
// for i = 1 to 4 do
5493: LD_ADDR_VAR 0 2
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_INT 4
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5538
// begin InitHc ;
5509: CALL_OW 19
// hc_class := class_apeman ;
5513: LD_ADDR_OWVAR 28
5517: PUSH
5518: LD_INT 12
5520: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5521: CALL_OW 44
5525: PPUSH
5526: LD_INT 11
5528: PPUSH
5529: LD_INT 0
5531: PPUSH
5532: CALL_OW 49
// end ;
5536: GO 5506
5538: POP
5539: POP
// end ;
5540: LD_VAR 0 1
5544: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5545: LD_EXP 4
5549: NOT
5550: PUSH
5551: LD_INT 4
5553: PPUSH
5554: LD_INT 1
5556: PPUSH
5557: CALL 46353 0 2
5561: NOT
5562: AND
5563: IFFALSE 6335
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
5571: PPUSH
5572: PPUSH
// begin enable ;
5573: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5574: LD_INT 22
5576: PUSH
5577: LD_INT 1
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 23
5586: PUSH
5587: LD_INT 1
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: LD_INT 30
5596: PUSH
5597: LD_INT 3
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 69
5613: NOT
5614: IFFALSE 5618
// exit ;
5616: GO 6335
// if Prob ( 40 ) then
5618: LD_INT 40
5620: PPUSH
5621: CALL_OW 13
5625: IFFALSE 5752
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5627: LD_INT 4
5629: PPUSH
5630: LD_INT 5
5632: PUSH
5633: LD_INT 1
5635: PUSH
5636: LD_INT 2
5638: PUSH
5639: LD_INT 7
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: PUSH
5648: LD_INT 5
5650: PUSH
5651: LD_INT 1
5653: PUSH
5654: LD_INT 2
5656: PUSH
5657: LD_INT 7
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: PUSH
5666: LD_INT 5
5668: PUSH
5669: LD_INT 1
5671: PUSH
5672: LD_INT 2
5674: PUSH
5675: LD_INT 7
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: LD_INT 1
5689: PUSH
5690: LD_INT 2
5692: PUSH
5693: LD_INT 6
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_INT 5
5704: PUSH
5705: LD_INT 1
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 6
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: PUSH
5720: LD_INT 5
5722: PUSH
5723: LD_INT 1
5725: PUSH
5726: LD_INT 2
5728: PUSH
5729: LD_INT 6
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PPUSH
5746: CALL 44935 0 2
// end else
5750: GO 5875
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5752: LD_INT 4
5754: PPUSH
5755: LD_INT 5
5757: PUSH
5758: LD_INT 1
5760: PUSH
5761: LD_INT 2
5763: PUSH
5764: LD_INT 7
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 5
5775: PUSH
5776: LD_INT 1
5778: PUSH
5779: LD_INT 2
5781: PUSH
5782: LD_INT 9
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 5
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 9
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 5
5811: PUSH
5812: LD_INT 1
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 6
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: LIST
5826: PUSH
5827: LD_INT 5
5829: PUSH
5830: LD_INT 1
5832: PUSH
5833: LD_INT 2
5835: PUSH
5836: LD_INT 6
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 5
5847: PUSH
5848: LD_INT 1
5850: PUSH
5851: LD_INT 2
5853: PUSH
5854: LD_INT 6
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: PPUSH
5871: CALL 44935 0 2
// end ; repeat wait ( 0 0$1 ) ;
5875: LD_INT 35
5877: PPUSH
5878: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5882: LD_INT 4
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: CALL 46353 0 2
5892: PUSH
5893: LD_INT 6
5895: GREATEREQUAL
5896: IFFALSE 5875
// wait ( 0 0$30 ) ;
5898: LD_INT 1050
5900: PPUSH
5901: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5905: LD_ADDR_VAR 0 2
5909: PUSH
5910: LD_INT 4
5912: PPUSH
5913: LD_INT 1
5915: PPUSH
5916: CALL 46353 0 2
5920: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5921: LD_ADDR_EXP 112
5925: PUSH
5926: LD_EXP 112
5930: PPUSH
5931: LD_INT 4
5933: PPUSH
5934: LD_EXP 112
5938: PUSH
5939: LD_INT 4
5941: ARRAY
5942: PUSH
5943: LD_VAR 0 2
5947: DIFF
5948: PPUSH
5949: CALL_OW 1
5953: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5954: LD_ADDR_VAR 0 3
5958: PUSH
5959: LD_INT 0
5961: PPUSH
5962: LD_INT 2
5964: PPUSH
5965: CALL_OW 12
5969: ST_TO_ADDR
// if target then
5970: LD_VAR 0 3
5974: IFFALSE 6102
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5976: LD_ADDR_VAR 0 2
5980: PUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: LD_INT 24
5988: PUSH
5989: LD_INT 250
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PPUSH
5996: CALL_OW 72
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 1
6005: PUSH
6006: LD_VAR 0 2
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6052
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_INT 114
6021: PPUSH
6022: LD_INT 108
6024: PPUSH
6025: CALL_OW 297
6029: PUSH
6030: LD_INT 9
6032: GREATER
6033: IFFALSE 6050
// ComMoveXY ( i , 114 , 108 ) ;
6035: LD_VAR 0 1
6039: PPUSH
6040: LD_INT 114
6042: PPUSH
6043: LD_INT 108
6045: PPUSH
6046: CALL_OW 111
6050: GO 6011
6052: POP
6053: POP
// wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6061: LD_VAR 0 2
6065: PPUSH
6066: LD_INT 92
6068: PUSH
6069: LD_INT 114
6071: PUSH
6072: LD_INT 108
6074: PUSH
6075: LD_INT 9
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 72
6088: PUSH
6089: LD_VAR 0 2
6093: PUSH
6094: LD_INT 1
6096: MINUS
6097: GREATEREQUAL
6098: IFFALSE 5976
// end else
6100: GO 6226
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 129
6147: PPUSH
6148: LD_INT 139
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 129 , 139 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 129
6168: PPUSH
6169: LD_INT 139
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 129
6197: PUSH
6198: LD_INT 139
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end ; repeat wait ( 0 0$1 ) ;
6226: LD_INT 35
6228: PPUSH
6229: CALL_OW 67
// for i in tmp do
6233: LD_ADDR_VAR 0 1
6237: PUSH
6238: LD_VAR 0 2
6242: PUSH
6243: FOR_IN
6244: IFFALSE 6326
// begin if GetLives ( i ) > 251 then
6246: LD_VAR 0 1
6250: PPUSH
6251: CALL_OW 256
6255: PUSH
6256: LD_INT 251
6258: GREATER
6259: IFFALSE 6297
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 81
6268: PUSH
6269: LD_INT 1
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 69
6280: PPUSH
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 74
6290: PPUSH
6291: CALL_OW 115
6295: GO 6324
// if IsDead ( i ) then
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 301
6306: IFFALSE 6324
// tmp := tmp diff i ;
6308: LD_ADDR_VAR 0 2
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_VAR 0 1
6322: DIFF
6323: ST_TO_ADDR
// end ;
6324: GO 6243
6326: POP
6327: POP
// until not tmp ;
6328: LD_VAR 0 2
6332: NOT
6333: IFFALSE 6226
// end ;
6335: PPOPN 3
6337: END
// every 30 30$00 trigger not americanDestroyed do
6338: LD_EXP 4
6342: NOT
6343: IFFALSE 6412
6345: GO 6347
6347: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6348: LD_INT 63000
6350: PUSH
6351: LD_INT 42000
6353: PUSH
6354: LD_INT 31500
6356: PUSH
6357: LD_INT 21000
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PUSH
6366: LD_OWVAR 67
6370: ARRAY
6371: PPUSH
6372: CALL_OW 67
// if americanDestroyed then
6376: LD_EXP 4
6380: IFFALSE 6384
// exit ;
6382: GO 6412
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6384: LD_INT 4
6386: PPUSH
6387: LD_INT 5
6389: PUSH
6390: LD_INT 3
6392: PUSH
6393: LD_INT 1
6395: PUSH
6396: LD_INT 8
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: EMPTY
6406: LIST
6407: PPUSH
6408: CALL 44935 0 2
// end ; end_of_file
6412: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6413: LD_INT 0
6415: PPUSH
6416: PPUSH
6417: PPUSH
6418: PPUSH
6419: PPUSH
// side := 2 ;
6420: LD_ADDR_VAR 0 5
6424: PUSH
6425: LD_INT 2
6427: ST_TO_ADDR
// InitHc ;
6428: CALL_OW 19
// uc_side := side ;
6432: LD_ADDR_OWVAR 20
6436: PUSH
6437: LD_VAR 0 5
6441: ST_TO_ADDR
// uc_nation := 2 ;
6442: LD_ADDR_OWVAR 21
6446: PUSH
6447: LD_INT 2
6449: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6450: LD_ADDR_VAR 0 2
6454: PUSH
6455: LD_INT 22
6457: PUSH
6458: LD_INT 2
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 21
6467: PUSH
6468: LD_INT 3
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: PPUSH
6479: CALL_OW 69
6483: PUSH
6484: FOR_IN
6485: IFFALSE 6501
// SetBLevel ( i , 10 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 10
6494: PPUSH
6495: CALL_OW 241
6499: GO 6484
6501: POP
6502: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6503: LD_ADDR_VAR 0 4
6507: PUSH
6508: LD_INT 22
6510: PUSH
6511: LD_VAR 0 5
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 30
6522: PUSH
6523: LD_INT 32
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: LD_INT 58
6532: PUSH
6533: EMPTY
6534: LIST
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: PPUSH
6541: CALL_OW 69
6545: ST_TO_ADDR
// for i = 1 to 10 do
6546: LD_ADDR_VAR 0 2
6550: PUSH
6551: DOUBLE
6552: LD_INT 1
6554: DEC
6555: ST_TO_ADDR
6556: LD_INT 10
6558: PUSH
6559: FOR_TO
6560: IFFALSE 6632
// begin uc_nation := nation_nature ;
6562: LD_ADDR_OWVAR 21
6566: PUSH
6567: LD_INT 0
6569: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6570: LD_ADDR_OWVAR 28
6574: PUSH
6575: LD_INT 15
6577: ST_TO_ADDR
// hc_gallery :=  ;
6578: LD_ADDR_OWVAR 33
6582: PUSH
6583: LD_STRING 
6585: ST_TO_ADDR
// hc_name :=  ;
6586: LD_ADDR_OWVAR 26
6590: PUSH
6591: LD_STRING 
6593: ST_TO_ADDR
// un := CreateHuman ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: CALL_OW 44
6603: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6604: LD_VAR 0 3
6608: PPUSH
6609: LD_VAR 0 4
6613: PUSH
6614: LD_VAR 0 4
6618: PUSH
6619: LD_VAR 0 2
6623: MINUS
6624: ARRAY
6625: PPUSH
6626: CALL_OW 52
// end ;
6630: GO 6559
6632: POP
6633: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6634: LD_INT 503
6636: PPUSH
6637: LD_INT 27
6639: PPUSH
6640: LD_STRING 
6642: PPUSH
6643: LD_INT 8
6645: PUSH
6646: LD_INT 9
6648: PUSH
6649: LD_INT 10
6651: PUSH
6652: LD_INT 10
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: PUSH
6661: LD_OWVAR 67
6665: ARRAY
6666: PPUSH
6667: LD_INT 3000
6669: PUSH
6670: LD_INT 500
6672: PUSH
6673: LD_INT 150
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: LIST
6680: PPUSH
6681: LD_INT 16
6683: PUSH
6684: LD_INT 6
6686: PUSH
6687: LD_INT 6
6689: PUSH
6690: LD_INT 6
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: PPUSH
6699: CALL 59651 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6703: LD_ADDR_EXP 93
6707: PUSH
6708: LD_EXP 93
6712: PPUSH
6713: LD_INT 1
6715: PPUSH
6716: LD_INT 22
6718: PUSH
6719: LD_VAR 0 5
6723: PUSH
6724: EMPTY
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 23
6730: PUSH
6731: LD_INT 2
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PUSH
6738: LD_INT 3
6740: PUSH
6741: LD_INT 21
6743: PUSH
6744: LD_INT 2
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: PPUSH
6760: CALL_OW 69
6764: PPUSH
6765: CALL_OW 1
6769: ST_TO_ADDR
// end ;
6770: LD_VAR 0 1
6774: RET
// export Omar ; export function PrepareOmarAli ; begin
6775: LD_INT 0
6777: PPUSH
// uc_side := 5 ;
6778: LD_ADDR_OWVAR 20
6782: PUSH
6783: LD_INT 5
6785: ST_TO_ADDR
// uc_nation := 2 ;
6786: LD_ADDR_OWVAR 21
6790: PUSH
6791: LD_INT 2
6793: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6794: LD_ADDR_EXP 53
6798: PUSH
6799: LD_STRING Omar
6801: PPUSH
6802: CALL_OW 25
6806: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6807: LD_EXP 53
6811: PPUSH
6812: LD_INT 330
6814: PPUSH
6815: LD_INT 244
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6825: LD_EXP 53
6829: PPUSH
6830: LD_INT 252
6832: PPUSH
6833: LD_INT 220
6835: PPUSH
6836: CALL_OW 111
// end ; end_of_file
6840: LD_VAR 0 1
6844: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6845: LD_INT 0
6847: PPUSH
6848: PPUSH
6849: PPUSH
6850: PPUSH
6851: PPUSH
// side := 8 ;
6852: LD_ADDR_VAR 0 3
6856: PUSH
6857: LD_INT 8
6859: ST_TO_ADDR
// InitHc ;
6860: CALL_OW 19
// uc_side := side ;
6864: LD_ADDR_OWVAR 20
6868: PUSH
6869: LD_VAR 0 3
6873: ST_TO_ADDR
// uc_nation := 2 ;
6874: LD_ADDR_OWVAR 21
6878: PUSH
6879: LD_INT 2
6881: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6882: LD_ADDR_VAR 0 2
6886: PUSH
6887: LD_INT 22
6889: PUSH
6890: LD_VAR 0 3
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: PUSH
6899: LD_INT 21
6901: PUSH
6902: LD_INT 3
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: PUSH
6918: FOR_IN
6919: IFFALSE 6935
// SetBLevel ( i , 10 ) ;
6921: LD_VAR 0 2
6925: PPUSH
6926: LD_INT 10
6928: PPUSH
6929: CALL_OW 241
6933: GO 6918
6935: POP
6936: POP
// Schulz := NewCharacter ( Schulz ) ;
6937: LD_ADDR_EXP 54
6941: PUSH
6942: LD_STRING Schulz
6944: PPUSH
6945: CALL_OW 25
6949: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6950: LD_ADDR_EXP 55
6954: PUSH
6955: LD_STRING Kozlov
6957: PPUSH
6958: LD_INT 0
6960: PPUSH
6961: LD_STRING 
6963: PPUSH
6964: CALL 51341 0 3
6968: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6969: LD_EXP 55
6973: PPUSH
6974: LD_INT 22
6976: PUSH
6977: LD_INT 8
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 23
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 30
6996: PUSH
6997: LD_INT 8
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: LD_INT 1
7016: ARRAY
7017: PPUSH
7018: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7022: LD_EXP 55
7026: PPUSH
7027: LD_INT 3
7029: PPUSH
7030: LD_INT 10
7032: PPUSH
7033: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7037: LD_ADDR_VAR 0 5
7041: PUSH
7042: LD_INT 22
7044: PUSH
7045: LD_VAR 0 3
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: LD_INT 30
7056: PUSH
7057: LD_INT 32
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: LD_INT 58
7066: PUSH
7067: EMPTY
7068: LIST
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 69
7079: ST_TO_ADDR
// for i = 1 to 10 do
7080: LD_ADDR_VAR 0 2
7084: PUSH
7085: DOUBLE
7086: LD_INT 1
7088: DEC
7089: ST_TO_ADDR
7090: LD_INT 10
7092: PUSH
7093: FOR_TO
7094: IFFALSE 7166
// begin uc_nation := nation_nature ;
7096: LD_ADDR_OWVAR 21
7100: PUSH
7101: LD_INT 0
7103: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7104: LD_ADDR_OWVAR 28
7108: PUSH
7109: LD_INT 15
7111: ST_TO_ADDR
// hc_gallery :=  ;
7112: LD_ADDR_OWVAR 33
7116: PUSH
7117: LD_STRING 
7119: ST_TO_ADDR
// hc_name :=  ;
7120: LD_ADDR_OWVAR 26
7124: PUSH
7125: LD_STRING 
7127: ST_TO_ADDR
// un := CreateHuman ;
7128: LD_ADDR_VAR 0 4
7132: PUSH
7133: CALL_OW 44
7137: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7138: LD_VAR 0 4
7142: PPUSH
7143: LD_VAR 0 5
7147: PUSH
7148: LD_VAR 0 5
7152: PUSH
7153: LD_VAR 0 2
7157: MINUS
7158: ARRAY
7159: PPUSH
7160: CALL_OW 52
// end ;
7164: GO 7093
7166: POP
7167: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7168: LD_INT 324
7170: PPUSH
7171: LD_INT 3
7173: PPUSH
7174: LD_STRING 
7176: PPUSH
7177: LD_INT 8
7179: PUSH
7180: LD_INT 9
7182: PUSH
7183: LD_INT 10
7185: PUSH
7186: LD_INT 10
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: LIST
7194: PUSH
7195: LD_OWVAR 67
7199: ARRAY
7200: PPUSH
7201: LD_INT 3000
7203: PUSH
7204: LD_INT 500
7206: PUSH
7207: LD_INT 150
7209: PUSH
7210: EMPTY
7211: LIST
7212: LIST
7213: LIST
7214: PPUSH
7215: LD_INT 16
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: LD_INT 6
7223: PUSH
7224: LD_INT 8
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL 59651 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7237: LD_ADDR_EXP 93
7241: PUSH
7242: LD_EXP 93
7246: PPUSH
7247: LD_INT 3
7249: PPUSH
7250: LD_INT 22
7252: PUSH
7253: LD_VAR 0 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 23
7264: PUSH
7265: LD_INT 2
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 3
7274: PUSH
7275: LD_INT 21
7277: PUSH
7278: LD_INT 2
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: LIST
7293: PPUSH
7294: CALL_OW 69
7298: PUSH
7299: LD_EXP 54
7303: DIFF
7304: PPUSH
7305: CALL_OW 1
7309: ST_TO_ADDR
// end ;
7310: LD_VAR 0 1
7314: RET
// export function BuildKozlovBomb ; begin
7315: LD_INT 0
7317: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7318: LD_INT 332
7320: PPUSH
7321: CALL_OW 302
7325: NOT
7326: PUSH
7327: LD_INT 336
7329: PPUSH
7330: CALL_OW 302
7334: NOT
7335: OR
7336: IFFALSE 7340
// exit ;
7338: GO 7437
// ComChangeProfession ( Kozlov , 4 ) ;
7340: LD_EXP 55
7344: PPUSH
7345: LD_INT 4
7347: PPUSH
7348: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7352: LD_INT 336
7354: PPUSH
7355: LD_INT 25
7357: PPUSH
7358: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7362: LD_INT 35
7364: PPUSH
7365: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7369: LD_INT 25
7371: PPUSH
7372: LD_INT 8
7374: PPUSH
7375: CALL_OW 321
7379: PUSH
7380: LD_INT 2
7382: EQUAL
7383: IFFALSE 7362
// ComExitBuilding ( Kozlov ) ;
7385: LD_EXP 55
7389: PPUSH
7390: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7394: LD_EXP 55
7398: PPUSH
7399: LD_INT 332
7401: PPUSH
7402: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7406: LD_EXP 55
7410: PPUSH
7411: LD_INT 3
7413: PPUSH
7414: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7418: LD_INT 332
7420: PPUSH
7421: LD_INT 23
7423: PPUSH
7424: LD_INT 3
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 48
7432: PPUSH
7433: CALL_OW 125
// end ;
7437: LD_VAR 0 1
7441: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7442: LD_EXP 3
7446: NOT
7447: PUSH
7448: LD_INT 3
7450: PPUSH
7451: LD_INT 1
7453: PPUSH
7454: CALL 46353 0 2
7458: NOT
7459: AND
7460: IFFALSE 8316
7462: GO 7464
7464: DISABLE
7465: LD_INT 0
7467: PPUSH
7468: PPUSH
7469: PPUSH
// begin enable ;
7470: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7471: LD_INT 22
7473: PUSH
7474: LD_INT 8
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: PUSH
7481: LD_INT 23
7483: PUSH
7484: LD_INT 2
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 30
7493: PUSH
7494: LD_INT 3
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: NOT
7511: IFFALSE 7515
// exit ;
7513: GO 8316
// if Prob ( 40 ) then
7515: LD_INT 40
7517: PPUSH
7518: CALL_OW 13
7522: IFFALSE 7649
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7524: LD_INT 3
7526: PPUSH
7527: LD_INT 14
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 2
7535: PUSH
7536: LD_INT 28
7538: PUSH
7539: EMPTY
7540: LIST
7541: LIST
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 14
7547: PUSH
7548: LD_INT 1
7550: PUSH
7551: LD_INT 2
7553: PUSH
7554: LD_INT 28
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 14
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 28
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 28
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 14
7601: PUSH
7602: LD_INT 1
7604: PUSH
7605: LD_INT 2
7607: PUSH
7608: LD_INT 28
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: LIST
7615: LIST
7616: PUSH
7617: LD_INT 14
7619: PUSH
7620: LD_INT 1
7622: PUSH
7623: LD_INT 2
7625: PUSH
7626: LD_INT 26
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: PPUSH
7643: CALL 44935 0 2
// end else
7647: GO 7856
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7649: LD_INT 3
7651: PPUSH
7652: LD_INT 14
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: LD_INT 2
7660: PUSH
7661: LD_INT 27
7663: PUSH
7664: LD_INT 26
7666: PUSH
7667: LD_INT 26
7669: PUSH
7670: LD_INT 28
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: PUSH
7679: LD_OWVAR 67
7683: ARRAY
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 14
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: LD_INT 2
7699: PUSH
7700: LD_INT 27
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 26
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_OWVAR 67
7722: ARRAY
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 14
7732: PUSH
7733: LD_INT 1
7735: PUSH
7736: LD_INT 2
7738: PUSH
7739: LD_INT 26
7741: PUSH
7742: LD_INT 26
7744: PUSH
7745: LD_INT 29
7747: PUSH
7748: LD_INT 29
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: LIST
7755: LIST
7756: PUSH
7757: LD_OWVAR 67
7761: ARRAY
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 13
7771: PUSH
7772: LD_INT 1
7774: PUSH
7775: LD_INT 2
7777: PUSH
7778: LD_INT 26
7780: PUSH
7781: LD_INT 29
7783: PUSH
7784: LD_INT 29
7786: PUSH
7787: LD_INT 29
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: LIST
7794: LIST
7795: PUSH
7796: LD_OWVAR 67
7800: ARRAY
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 13
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: LD_INT 2
7816: PUSH
7817: LD_INT 29
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 14
7828: PUSH
7829: LD_INT 1
7831: PUSH
7832: LD_INT 2
7834: PUSH
7835: LD_INT 26
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: PPUSH
7852: CALL 44935 0 2
// end ; repeat wait ( 0 0$1 ) ;
7856: LD_INT 35
7858: PPUSH
7859: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7863: LD_INT 3
7865: PPUSH
7866: LD_INT 1
7868: PPUSH
7869: CALL 46353 0 2
7873: PUSH
7874: LD_INT 6
7876: GREATEREQUAL
7877: IFFALSE 7856
// wait ( 0 0$30 ) ;
7879: LD_INT 1050
7881: PPUSH
7882: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7886: LD_ADDR_VAR 0 2
7890: PUSH
7891: LD_INT 3
7893: PPUSH
7894: LD_INT 1
7896: PPUSH
7897: CALL 46353 0 2
7901: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7902: LD_ADDR_EXP 112
7906: PUSH
7907: LD_EXP 112
7911: PPUSH
7912: LD_INT 3
7914: PPUSH
7915: LD_EXP 112
7919: PUSH
7920: LD_INT 3
7922: ARRAY
7923: PUSH
7924: LD_VAR 0 2
7928: DIFF
7929: PPUSH
7930: CALL_OW 1
7934: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7935: LD_ADDR_VAR 0 3
7939: PUSH
7940: LD_INT 0
7942: PPUSH
7943: LD_INT 2
7945: PPUSH
7946: CALL_OW 12
7950: ST_TO_ADDR
// if target then
7951: LD_VAR 0 3
7955: IFFALSE 8083
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7957: LD_ADDR_VAR 0 2
7961: PUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_INT 24
7969: PUSH
7970: LD_INT 250
7972: PUSH
7973: EMPTY
7974: LIST
7975: LIST
7976: PPUSH
7977: CALL_OW 72
7981: ST_TO_ADDR
// for i in tmp do
7982: LD_ADDR_VAR 0 1
7986: PUSH
7987: LD_VAR 0 2
7991: PUSH
7992: FOR_IN
7993: IFFALSE 8033
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7995: LD_VAR 0 1
7999: PPUSH
8000: LD_INT 89
8002: PPUSH
8003: LD_INT 71
8005: PPUSH
8006: CALL_OW 297
8010: PUSH
8011: LD_INT 9
8013: GREATER
8014: IFFALSE 8031
// ComMoveXY ( i , 89 , 71 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 89
8023: PPUSH
8024: LD_INT 71
8026: PPUSH
8027: CALL_OW 111
8031: GO 7992
8033: POP
8034: POP
// wait ( 0 0$1 ) ;
8035: LD_INT 35
8037: PPUSH
8038: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8042: LD_VAR 0 2
8046: PPUSH
8047: LD_INT 92
8049: PUSH
8050: LD_INT 89
8052: PUSH
8053: LD_INT 71
8055: PUSH
8056: LD_INT 9
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: LIST
8063: LIST
8064: PPUSH
8065: CALL_OW 72
8069: PUSH
8070: LD_VAR 0 2
8074: PUSH
8075: LD_INT 1
8077: MINUS
8078: GREATEREQUAL
8079: IFFALSE 7957
// end else
8081: GO 8207
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8083: LD_ADDR_VAR 0 2
8087: PUSH
8088: LD_VAR 0 2
8092: PPUSH
8093: LD_INT 24
8095: PUSH
8096: LD_INT 250
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: PPUSH
8103: CALL_OW 72
8107: ST_TO_ADDR
// for i in tmp do
8108: LD_ADDR_VAR 0 1
8112: PUSH
8113: LD_VAR 0 2
8117: PUSH
8118: FOR_IN
8119: IFFALSE 8159
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8121: LD_VAR 0 1
8125: PPUSH
8126: LD_INT 147
8128: PPUSH
8129: LD_INT 4
8131: PPUSH
8132: CALL_OW 297
8136: PUSH
8137: LD_INT 9
8139: GREATER
8140: IFFALSE 8157
// ComMoveXY ( i , 147 , 4 ) ;
8142: LD_VAR 0 1
8146: PPUSH
8147: LD_INT 147
8149: PPUSH
8150: LD_INT 4
8152: PPUSH
8153: CALL_OW 111
8157: GO 8118
8159: POP
8160: POP
// wait ( 0 0$1 ) ;
8161: LD_INT 35
8163: PPUSH
8164: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8168: LD_VAR 0 2
8172: PPUSH
8173: LD_INT 92
8175: PUSH
8176: LD_INT 147
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: LD_INT 9
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: PPUSH
8191: CALL_OW 72
8195: PUSH
8196: LD_VAR 0 2
8200: PUSH
8201: LD_INT 1
8203: MINUS
8204: GREATEREQUAL
8205: IFFALSE 8083
// end ; repeat wait ( 0 0$1 ) ;
8207: LD_INT 35
8209: PPUSH
8210: CALL_OW 67
// for i in tmp do
8214: LD_ADDR_VAR 0 1
8218: PUSH
8219: LD_VAR 0 2
8223: PUSH
8224: FOR_IN
8225: IFFALSE 8307
// begin if GetLives ( i ) > 251 then
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 256
8236: PUSH
8237: LD_INT 251
8239: GREATER
8240: IFFALSE 8278
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8242: LD_VAR 0 1
8246: PPUSH
8247: LD_INT 81
8249: PUSH
8250: LD_INT 8
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 69
8261: PPUSH
8262: LD_VAR 0 1
8266: PPUSH
8267: CALL_OW 74
8271: PPUSH
8272: CALL_OW 115
8276: GO 8305
// if IsDead ( i ) then
8278: LD_VAR 0 1
8282: PPUSH
8283: CALL_OW 301
8287: IFFALSE 8305
// tmp := tmp diff i ;
8289: LD_ADDR_VAR 0 2
8293: PUSH
8294: LD_VAR 0 2
8298: PUSH
8299: LD_VAR 0 1
8303: DIFF
8304: ST_TO_ADDR
// end ;
8305: GO 8224
8307: POP
8308: POP
// until not tmp ;
8309: LD_VAR 0 2
8313: NOT
8314: IFFALSE 8207
// end ;
8316: PPOPN 3
8318: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8319: LD_EXP 55
8323: PPUSH
8324: CALL_OW 302
8328: PUSH
8329: LD_EXP 3
8333: NOT
8334: AND
8335: IFFALSE 8344
8337: GO 8339
8339: DISABLE
// BuildKozlovBomb ;
8340: CALL 7315 0 0
8344: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 8
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 48
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PPUSH
8369: CALL_OW 69
8373: IFFALSE 8421
8375: GO 8377
8377: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8378: LD_INT 22
8380: PUSH
8381: LD_INT 8
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 34
8390: PUSH
8391: LD_INT 48
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: EMPTY
8399: LIST
8400: LIST
8401: PPUSH
8402: CALL_OW 69
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: PPUSH
8411: LD_INT 173
8413: PPUSH
8414: LD_INT 96
8416: PPUSH
8417: CALL_OW 116
// end ; end_of_file
8421: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8422: LD_INT 0
8424: PPUSH
8425: PPUSH
8426: PPUSH
8427: PPUSH
8428: PPUSH
8429: PPUSH
8430: PPUSH
8431: PPUSH
8432: PPUSH
// side := 3 ;
8433: LD_ADDR_VAR 0 6
8437: PUSH
8438: LD_INT 3
8440: ST_TO_ADDR
// InitHc ;
8441: CALL_OW 19
// uc_side := side ;
8445: LD_ADDR_OWVAR 20
8449: PUSH
8450: LD_VAR 0 6
8454: ST_TO_ADDR
// uc_nation := 3 ;
8455: LD_ADDR_OWVAR 21
8459: PUSH
8460: LD_INT 3
8462: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_INT 22
8470: PUSH
8471: LD_VAR 0 6
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: LD_INT 21
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PUSH
8490: EMPTY
8491: LIST
8492: LIST
8493: PPUSH
8494: CALL_OW 69
8498: PUSH
8499: FOR_IN
8500: IFFALSE 8516
// SetBLevel ( i , 10 ) ;
8502: LD_VAR 0 2
8506: PPUSH
8507: LD_INT 10
8509: PPUSH
8510: CALL_OW 241
8514: GO 8499
8516: POP
8517: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8518: LD_ADDR_VAR 0 9
8522: PUSH
8523: LD_INT 22
8525: PUSH
8526: LD_VAR 0 6
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PUSH
8535: LD_INT 30
8537: PUSH
8538: LD_INT 34
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PPUSH
8549: CALL_OW 69
8553: ST_TO_ADDR
// if teleport then
8554: LD_VAR 0 9
8558: IFFALSE 8579
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8560: LD_VAR 0 9
8564: PUSH
8565: LD_INT 1
8567: ARRAY
8568: PPUSH
8569: LD_INT 123
8571: PPUSH
8572: LD_INT 122
8574: PPUSH
8575: CALL_OW 243
// hc_importance := 0 ;
8579: LD_ADDR_OWVAR 32
8583: PUSH
8584: LD_INT 0
8586: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8587: LD_ADDR_EXP 56
8591: PUSH
8592: LD_STRING Platonov
8594: PPUSH
8595: CALL_OW 25
8599: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8600: LD_ADDR_EXP 57
8604: PUSH
8605: LD_STRING Yakotich
8607: PPUSH
8608: CALL_OW 25
8612: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8613: LD_ADDR_EXP 58
8617: PUSH
8618: LD_STRING Gleb
8620: PPUSH
8621: CALL_OW 25
8625: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8626: LD_STRING 03_Cornel
8628: PPUSH
8629: CALL_OW 28
8633: IFFALSE 8681
// begin Bierezov := NewCharacter ( Mikhail ) ;
8635: LD_ADDR_EXP 59
8639: PUSH
8640: LD_STRING Mikhail
8642: PPUSH
8643: CALL_OW 25
8647: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8648: LD_EXP 59
8652: PPUSH
8653: LD_INT 197
8655: PPUSH
8656: LD_INT 111
8658: PPUSH
8659: LD_INT 9
8661: PPUSH
8662: LD_INT 0
8664: PPUSH
8665: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8669: LD_EXP 59
8673: PPUSH
8674: LD_INT 3
8676: PPUSH
8677: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8681: LD_EXP 56
8685: PPUSH
8686: LD_INT 126
8688: PPUSH
8689: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8693: LD_EXP 57
8697: PPUSH
8698: LD_INT 197
8700: PPUSH
8701: LD_INT 111
8703: PPUSH
8704: LD_INT 9
8706: PPUSH
8707: LD_INT 0
8709: PPUSH
8710: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8714: LD_EXP 58
8718: PPUSH
8719: LD_INT 197
8721: PPUSH
8722: LD_INT 111
8724: PPUSH
8725: LD_INT 9
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8735: LD_ADDR_VAR 0 5
8739: PUSH
8740: LD_INT 126
8742: PPUSH
8743: LD_INT 2
8745: PPUSH
8746: LD_STRING zhukov
8748: PPUSH
8749: LD_INT 9
8751: PUSH
8752: LD_INT 10
8754: PUSH
8755: LD_INT 10
8757: PUSH
8758: LD_INT 10
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_OWVAR 67
8771: ARRAY
8772: PPUSH
8773: LD_INT 9000
8775: PUSH
8776: LD_INT 1000
8778: PUSH
8779: LD_INT 300
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: LIST
8786: PPUSH
8787: LD_INT 21
8789: PUSH
8790: LD_INT 8
8792: PUSH
8793: LD_INT 13
8795: PUSH
8796: LD_INT 8
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: LIST
8803: LIST
8804: PPUSH
8805: CALL 59651 0 6
8809: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 267
8817: PPUSH
8818: CALL_OW 274
8822: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8823: LD_VAR 0 4
8827: PPUSH
8828: LD_INT 1
8830: PPUSH
8831: LD_INT 5000
8833: PPUSH
8834: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 2
8845: PPUSH
8846: LD_INT 200
8848: PPUSH
8849: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: LD_INT 200
8863: PPUSH
8864: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8868: LD_ADDR_EXP 93
8872: PUSH
8873: LD_EXP 93
8877: PPUSH
8878: LD_INT 2
8880: PPUSH
8881: LD_VAR 0 5
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_VAR 0 6
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: LD_INT 3
8900: PUSH
8901: LD_INT 21
8903: PUSH
8904: LD_INT 2
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PPUSH
8919: CALL_OW 69
8923: UNION
8924: PUSH
8925: LD_EXP 56
8929: DIFF
8930: PPUSH
8931: CALL_OW 1
8935: ST_TO_ADDR
// behemoths := [ ] ;
8936: LD_ADDR_EXP 60
8940: PUSH
8941: EMPTY
8942: ST_TO_ADDR
// behemothBuilders := [ ] ;
8943: LD_ADDR_EXP 61
8947: PUSH
8948: EMPTY
8949: ST_TO_ADDR
// j := 3 ;
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: LD_INT 3
8957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8958: LD_ADDR_VAR 0 2
8962: PUSH
8963: LD_INT 22
8965: PUSH
8966: LD_INT 3
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 25
8975: PUSH
8976: LD_INT 3
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: PPUSH
8987: CALL_OW 69
8991: PUSH
8992: FOR_IN
8993: IFFALSE 9043
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8995: LD_ADDR_EXP 61
8999: PUSH
9000: LD_EXP 61
9004: PPUSH
9005: LD_VAR 0 2
9009: PPUSH
9010: CALL 88078 0 2
9014: ST_TO_ADDR
// j := j - 1 ;
9015: LD_ADDR_VAR 0 3
9019: PUSH
9020: LD_VAR 0 3
9024: PUSH
9025: LD_INT 1
9027: MINUS
9028: ST_TO_ADDR
// if j = 0 then
9029: LD_VAR 0 3
9033: PUSH
9034: LD_INT 0
9036: EQUAL
9037: IFFALSE 9041
// break ;
9039: GO 9043
// end ;
9041: GO 8992
9043: POP
9044: POP
// end ;
9045: LD_VAR 0 1
9049: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9050: LD_INT 0
9052: PPUSH
9053: PPUSH
9054: PPUSH
9055: PPUSH
9056: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9057: LD_ADDR_VAR 0 4
9061: PUSH
9062: LD_INT 209
9064: PUSH
9065: LD_INT 149
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: LD_INT 219
9074: PUSH
9075: LD_INT 154
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 223
9084: PUSH
9085: LD_INT 149
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 232
9094: PUSH
9095: LD_INT 155
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: EMPTY
9103: LIST
9104: LIST
9105: LIST
9106: LIST
9107: ST_TO_ADDR
// if not behemothBuilders then
9108: LD_EXP 61
9112: NOT
9113: IFFALSE 9117
// exit ;
9115: GO 9221
// j := 1 ;
9117: LD_ADDR_VAR 0 3
9121: PUSH
9122: LD_INT 1
9124: ST_TO_ADDR
// for i in behemothBuilders do
9125: LD_ADDR_VAR 0 2
9129: PUSH
9130: LD_EXP 61
9134: PUSH
9135: FOR_IN
9136: IFFALSE 9219
// begin if IsInUnit ( i ) then
9138: LD_VAR 0 2
9142: PPUSH
9143: CALL_OW 310
9147: IFFALSE 9158
// ComExitBuilding ( i ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9158: LD_VAR 0 2
9162: PPUSH
9163: LD_INT 37
9165: PPUSH
9166: LD_VAR 0 4
9170: PUSH
9171: LD_VAR 0 3
9175: ARRAY
9176: PUSH
9177: LD_INT 1
9179: ARRAY
9180: PPUSH
9181: LD_VAR 0 4
9185: PUSH
9186: LD_VAR 0 3
9190: ARRAY
9191: PUSH
9192: LD_INT 2
9194: ARRAY
9195: PPUSH
9196: LD_INT 0
9198: PPUSH
9199: CALL_OW 230
// j := j + 1 ;
9203: LD_ADDR_VAR 0 3
9207: PUSH
9208: LD_VAR 0 3
9212: PUSH
9213: LD_INT 1
9215: PLUS
9216: ST_TO_ADDR
// end ;
9217: GO 9135
9219: POP
9220: POP
// end ;
9221: LD_VAR 0 1
9225: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9226: LD_INT 3
9228: PPUSH
9229: CALL 88139 0 1
9233: PUSH
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 37
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: AND
9264: IFFALSE 9450
9266: GO 9268
9268: DISABLE
9269: LD_INT 0
9271: PPUSH
9272: PPUSH
// begin enable ;
9273: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9274: LD_ADDR_VAR 0 2
9278: PUSH
9279: LD_INT 3
9281: PPUSH
9282: CALL 88139 0 1
9286: ST_TO_ADDR
// for i in tmp do
9287: LD_ADDR_VAR 0 1
9291: PUSH
9292: LD_VAR 0 2
9296: PUSH
9297: FOR_IN
9298: IFFALSE 9448
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9300: LD_VAR 0 1
9304: PPUSH
9305: LD_INT 7
9307: PPUSH
9308: CALL_OW 308
9312: PUSH
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 110
9322: PUSH
9323: LD_INT 2
9325: EQUAL
9326: NOT
9327: AND
9328: IFFALSE 9342
// SetTag ( i , 2 ) ;
9330: LD_VAR 0 1
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9342: LD_INT 81
9344: PUSH
9345: LD_INT 3
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 91
9354: PUSH
9355: LD_VAR 0 1
9359: PUSH
9360: LD_INT 12
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: LIST
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PPUSH
9372: CALL_OW 69
9376: NOT
9377: PUSH
9378: LD_VAR 0 1
9382: PPUSH
9383: CALL_OW 110
9387: PUSH
9388: LD_INT 2
9390: EQUAL
9391: NOT
9392: AND
9393: IFFALSE 9412
// ComAgressiveMove ( i , 64 , 93 ) else
9395: LD_VAR 0 1
9399: PPUSH
9400: LD_INT 64
9402: PPUSH
9403: LD_INT 93
9405: PPUSH
9406: CALL_OW 114
9410: GO 9446
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9412: LD_VAR 0 1
9416: PPUSH
9417: LD_INT 81
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: PPUSH
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 74
9441: PPUSH
9442: CALL_OW 115
// end ;
9446: GO 9297
9448: POP
9449: POP
// end ;
9450: PPOPN 2
9452: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9453: LD_EXP 2
9457: NOT
9458: PUSH
9459: LD_INT 2
9461: PPUSH
9462: LD_INT 1
9464: PPUSH
9465: CALL 46353 0 2
9469: NOT
9470: AND
9471: IFFALSE 10395
9473: GO 9475
9475: DISABLE
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
// begin enable ;
9482: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9483: LD_INT 22
9485: PUSH
9486: LD_INT 3
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 30
9495: PUSH
9496: LD_INT 3
9498: PUSH
9499: EMPTY
9500: LIST
9501: LIST
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PPUSH
9507: CALL_OW 69
9511: NOT
9512: IFFALSE 9516
// exit ;
9514: GO 10395
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9516: LD_ADDR_VAR 0 4
9520: PUSH
9521: LD_INT 22
9523: PUSH
9524: LD_INT 3
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 30
9533: PUSH
9534: LD_INT 34
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PPUSH
9545: CALL_OW 69
9549: ST_TO_ADDR
// if Prob ( 40 ) then
9550: LD_INT 40
9552: PPUSH
9553: CALL_OW 13
9557: IFFALSE 9684
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9559: LD_INT 2
9561: PPUSH
9562: LD_INT 22
9564: PUSH
9565: LD_INT 3
9567: PUSH
9568: LD_INT 3
9570: PUSH
9571: LD_INT 49
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 22
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 3
9588: PUSH
9589: LD_INT 49
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: PUSH
9598: LD_INT 22
9600: PUSH
9601: LD_INT 3
9603: PUSH
9604: LD_INT 3
9606: PUSH
9607: LD_INT 49
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: PUSH
9616: LD_INT 24
9618: PUSH
9619: LD_INT 3
9621: PUSH
9622: LD_INT 3
9624: PUSH
9625: LD_INT 46
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: LIST
9633: PUSH
9634: LD_INT 24
9636: PUSH
9637: LD_INT 3
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: LD_INT 46
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: PUSH
9652: LD_INT 24
9654: PUSH
9655: LD_INT 3
9657: PUSH
9658: LD_INT 3
9660: PUSH
9661: LD_INT 46
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL 44935 0 2
// end else
9682: GO 9807
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9684: LD_INT 2
9686: PPUSH
9687: LD_INT 24
9689: PUSH
9690: LD_INT 3
9692: PUSH
9693: LD_INT 3
9695: PUSH
9696: LD_INT 47
9698: PUSH
9699: EMPTY
9700: LIST
9701: LIST
9702: LIST
9703: LIST
9704: PUSH
9705: LD_INT 24
9707: PUSH
9708: LD_INT 3
9710: PUSH
9711: LD_INT 3
9713: PUSH
9714: LD_INT 47
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: LIST
9722: PUSH
9723: LD_INT 24
9725: PUSH
9726: LD_INT 3
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 47
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: LIST
9739: LIST
9740: PUSH
9741: LD_INT 24
9743: PUSH
9744: LD_INT 3
9746: PUSH
9747: LD_INT 3
9749: PUSH
9750: LD_INT 46
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 24
9761: PUSH
9762: LD_INT 3
9764: PUSH
9765: LD_INT 3
9767: PUSH
9768: LD_INT 46
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: LIST
9776: PUSH
9777: LD_INT 24
9779: PUSH
9780: LD_INT 3
9782: PUSH
9783: LD_INT 3
9785: PUSH
9786: LD_INT 46
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: PPUSH
9803: CALL 44935 0 2
// end ; if Difficulty > 1 then
9807: LD_OWVAR 67
9811: PUSH
9812: LD_INT 1
9814: GREATER
9815: IFFALSE 9845
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9817: LD_INT 2
9819: PPUSH
9820: LD_INT 24
9822: PUSH
9823: LD_INT 3
9825: PUSH
9826: LD_INT 3
9828: PUSH
9829: LD_INT 47
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: PUSH
9838: EMPTY
9839: LIST
9840: PPUSH
9841: CALL 44935 0 2
// repeat wait ( 0 0$1 ) ;
9845: LD_INT 35
9847: PPUSH
9848: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
9852: LD_INT 2
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL 46353 0 2
9862: PUSH
9863: LD_INT 6
9865: PUSH
9866: LD_INT 7
9868: PUSH
9869: LD_INT 7
9871: PUSH
9872: LD_INT 7
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: PUSH
9881: LD_OWVAR 67
9885: ARRAY
9886: GREATEREQUAL
9887: IFFALSE 9845
// wait ( 0 0$30 ) ;
9889: LD_INT 1050
9891: PPUSH
9892: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9896: LD_ADDR_VAR 0 2
9900: PUSH
9901: LD_INT 2
9903: PPUSH
9904: LD_INT 1
9906: PPUSH
9907: CALL 46353 0 2
9911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9912: LD_ADDR_EXP 112
9916: PUSH
9917: LD_EXP 112
9921: PPUSH
9922: LD_INT 2
9924: PPUSH
9925: LD_EXP 112
9929: PUSH
9930: LD_INT 2
9932: ARRAY
9933: PUSH
9934: LD_VAR 0 2
9938: DIFF
9939: PPUSH
9940: CALL_OW 1
9944: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9945: LD_ADDR_VAR 0 3
9949: PUSH
9950: LD_INT 0
9952: PPUSH
9953: LD_INT 1
9955: PPUSH
9956: CALL_OW 12
9960: ST_TO_ADDR
// if target then
9961: LD_VAR 0 3
9965: IFFALSE 10093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9967: LD_ADDR_VAR 0 2
9971: PUSH
9972: LD_VAR 0 2
9976: PPUSH
9977: LD_INT 24
9979: PUSH
9980: LD_INT 250
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: PPUSH
9987: CALL_OW 72
9991: ST_TO_ADDR
// for i in tmp do
9992: LD_ADDR_VAR 0 1
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: FOR_IN
10003: IFFALSE 10043
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10005: LD_VAR 0 1
10009: PPUSH
10010: LD_INT 139
10012: PPUSH
10013: LD_INT 89
10015: PPUSH
10016: CALL_OW 297
10020: PUSH
10021: LD_INT 9
10023: GREATER
10024: IFFALSE 10041
// ComMoveXY ( i , 139 , 89 ) ;
10026: LD_VAR 0 1
10030: PPUSH
10031: LD_INT 139
10033: PPUSH
10034: LD_INT 89
10036: PPUSH
10037: CALL_OW 111
10041: GO 10002
10043: POP
10044: POP
// wait ( 0 0$1 ) ;
10045: LD_INT 35
10047: PPUSH
10048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10052: LD_VAR 0 2
10056: PPUSH
10057: LD_INT 92
10059: PUSH
10060: LD_INT 139
10062: PUSH
10063: LD_INT 89
10065: PUSH
10066: LD_INT 9
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: PPUSH
10075: CALL_OW 72
10079: PUSH
10080: LD_VAR 0 2
10084: PUSH
10085: LD_INT 1
10087: MINUS
10088: GREATEREQUAL
10089: IFFALSE 9967
// end else
10091: GO 10235
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10093: LD_VAR 0 2
10097: PPUSH
10098: LD_VAR 0 4
10102: PUSH
10103: LD_INT 1
10105: ARRAY
10106: PPUSH
10107: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10111: LD_ADDR_VAR 0 2
10115: PUSH
10116: LD_VAR 0 2
10120: PPUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 250
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: ST_TO_ADDR
// for i in tmp do
10136: LD_ADDR_VAR 0 1
10140: PUSH
10141: LD_VAR 0 2
10145: PUSH
10146: FOR_IN
10147: IFFALSE 10187
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10149: LD_VAR 0 1
10153: PPUSH
10154: LD_INT 124
10156: PPUSH
10157: LD_INT 139
10159: PPUSH
10160: CALL_OW 297
10164: PUSH
10165: LD_INT 9
10167: GREATER
10168: IFFALSE 10185
// ComMoveXY ( i , 124 , 139 ) ;
10170: LD_VAR 0 1
10174: PPUSH
10175: LD_INT 124
10177: PPUSH
10178: LD_INT 139
10180: PPUSH
10181: CALL_OW 111
10185: GO 10146
10187: POP
10188: POP
// wait ( 0 0$1 ) ;
10189: LD_INT 35
10191: PPUSH
10192: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10196: LD_VAR 0 2
10200: PPUSH
10201: LD_INT 92
10203: PUSH
10204: LD_INT 124
10206: PUSH
10207: LD_INT 139
10209: PUSH
10210: LD_INT 9
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 72
10223: PUSH
10224: LD_VAR 0 2
10228: PUSH
10229: LD_INT 1
10231: MINUS
10232: GREATEREQUAL
10233: IFFALSE 10111
// end ; repeat wait ( 0 0$1 ) ;
10235: LD_INT 35
10237: PPUSH
10238: CALL_OW 67
// for i in tmp do
10242: LD_ADDR_VAR 0 1
10246: PUSH
10247: LD_VAR 0 2
10251: PUSH
10252: FOR_IN
10253: IFFALSE 10386
// begin if GetLives ( i ) > 251 then
10255: LD_VAR 0 1
10259: PPUSH
10260: CALL_OW 256
10264: PUSH
10265: LD_INT 251
10267: GREATER
10268: IFFALSE 10357
// begin if GetWeapon ( i ) = ru_time_lapser then
10270: LD_VAR 0 1
10274: PPUSH
10275: CALL_OW 264
10279: PUSH
10280: LD_INT 49
10282: EQUAL
10283: IFFALSE 10321
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10285: LD_VAR 0 1
10289: PPUSH
10290: LD_INT 81
10292: PUSH
10293: LD_INT 3
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: PPUSH
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 74
10314: PPUSH
10315: CALL_OW 112
10319: GO 10355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 81
10328: PUSH
10329: LD_INT 3
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PPUSH
10336: CALL_OW 69
10340: PPUSH
10341: LD_VAR 0 1
10345: PPUSH
10346: CALL_OW 74
10350: PPUSH
10351: CALL_OW 115
// end else
10355: GO 10384
// if IsDead ( i ) then
10357: LD_VAR 0 1
10361: PPUSH
10362: CALL_OW 301
10366: IFFALSE 10384
// tmp := tmp diff i ;
10368: LD_ADDR_VAR 0 2
10372: PUSH
10373: LD_VAR 0 2
10377: PUSH
10378: LD_VAR 0 1
10382: DIFF
10383: ST_TO_ADDR
// end ;
10384: GO 10252
10386: POP
10387: POP
// until not tmp ;
10388: LD_VAR 0 2
10392: NOT
10393: IFFALSE 10235
// end ;
10395: PPOPN 4
10397: END
// every 30 30$00 trigger not russianDestroyed do
10398: LD_EXP 2
10402: NOT
10403: IFFALSE 10472
10405: GO 10407
10407: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10408: LD_INT 105000
10410: PUSH
10411: LD_INT 84000
10413: PUSH
10414: LD_INT 63000
10416: PUSH
10417: LD_INT 52500
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_OWVAR 67
10430: ARRAY
10431: PPUSH
10432: CALL_OW 67
// if russianDestroyed then
10436: LD_EXP 2
10440: IFFALSE 10444
// exit ;
10442: GO 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 23
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 1
10455: PUSH
10456: LD_INT 48
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 44935 0 2
// end ; end_of_file
10472: END
// export function CustomEvent ( event ) ; begin
10473: LD_INT 0
10475: PPUSH
// end ;
10476: LD_VAR 0 2
10480: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10481: LD_VAR 0 2
10485: PPUSH
10486: LD_VAR 0 3
10490: PPUSH
10491: LD_INT 15
10493: PPUSH
10494: CALL_OW 309
10498: IFFALSE 10507
// YouLost ( MothContaminate ) ;
10500: LD_STRING MothContaminate
10502: PPUSH
10503: CALL_OW 104
// end ;
10507: PPOPN 3
10509: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10510: LD_VAR 0 2
10514: PPUSH
10515: LD_VAR 0 3
10519: PPUSH
10520: LD_INT 15
10522: PPUSH
10523: CALL_OW 309
10527: IFFALSE 10543
// begin wait ( 0 0$6 ) ;
10529: LD_INT 210
10531: PPUSH
10532: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10536: LD_STRING MothContaminateBomb
10538: PPUSH
10539: CALL_OW 104
// end ; end ;
10543: PPOPN 3
10545: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10546: LD_VAR 0 1
10550: PUSH
10551: LD_EXP 17
10555: EQUAL
10556: IFFALSE 10567
// begin YouLost ( JMM ) ;
10558: LD_STRING JMM
10560: PPUSH
10561: CALL_OW 104
// exit ;
10565: GO 10666
// end ; if un = Powell then
10567: LD_VAR 0 1
10571: PUSH
10572: LD_EXP 52
10576: EQUAL
10577: IFFALSE 10587
// americanDestroyed := true ;
10579: LD_ADDR_EXP 4
10583: PUSH
10584: LD_INT 1
10586: ST_TO_ADDR
// if un = Platonov then
10587: LD_VAR 0 1
10591: PUSH
10592: LD_EXP 56
10596: EQUAL
10597: IFFALSE 10607
// russianDestroyed := true ;
10599: LD_ADDR_EXP 2
10603: PUSH
10604: LD_INT 1
10606: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10607: LD_VAR 0 1
10611: PUSH
10612: LD_INT 22
10614: PUSH
10615: LD_INT 7
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PUSH
10622: LD_INT 21
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10657
// vehicleLostCounter := vehicleLostCounter + 1 ;
10643: LD_ADDR_EXP 15
10647: PUSH
10648: LD_EXP 15
10652: PUSH
10653: LD_INT 1
10655: PLUS
10656: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 48355 0 1
// end ;
10666: PPOPN 1
10668: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_VAR 0 2
10678: PPUSH
10679: CALL 50689 0 2
// end ;
10683: PPOPN 2
10685: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10686: LD_VAR 0 1
10690: PPUSH
10691: CALL 49757 0 1
// end ;
10695: PPOPN 1
10697: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10698: LD_VAR 0 1
10702: PUSH
10703: LD_INT 22
10705: PUSH
10706: LD_INT 8
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 30
10715: PUSH
10716: LD_INT 2
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 23
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 69
10742: IN
10743: IFFALSE 10770
// begin ComUpgrade ( building ) ;
10745: LD_VAR 0 1
10749: PPUSH
10750: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10754: LD_EXP 55
10758: PPUSH
10759: LD_VAR 0 1
10763: PPUSH
10764: CALL 59190 0 2
// exit ;
10768: GO 10779
// end ; MCE_BuildingComplete ( building ) ;
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL 49998 0 1
// end ;
10779: PPOPN 1
10781: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10782: LD_VAR 0 1
10786: PPUSH
10787: LD_VAR 0 2
10791: PPUSH
10792: CALL 48051 0 2
// end ;
10796: PPOPN 2
10798: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: LD_VAR 0 3
10813: PPUSH
10814: LD_VAR 0 4
10818: PPUSH
10819: LD_VAR 0 5
10823: PPUSH
10824: CALL 47671 0 5
// end ;
10828: PPOPN 5
10830: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10831: LD_VAR 0 1
10835: PPUSH
10836: LD_VAR 0 2
10840: PPUSH
10841: CALL 47252 0 2
// end ;
10845: PPOPN 2
10847: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10848: LD_VAR 0 1
10852: PPUSH
10853: LD_VAR 0 2
10857: PPUSH
10858: LD_VAR 0 3
10862: PPUSH
10863: LD_VAR 0 4
10867: PPUSH
10868: CALL 47090 0 4
// end ;
10872: PPOPN 4
10874: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: CALL 46865 0 3
// end ;
10894: PPOPN 3
10896: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_VAR 0 2
10906: PPUSH
10907: CALL 46750 0 2
// end ;
10911: PPOPN 2
10913: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10914: LD_VAR 0 1
10918: PPUSH
10919: LD_VAR 0 2
10923: PPUSH
10924: CALL 50984 0 2
// end ;
10928: PPOPN 2
10930: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_VAR 0 4
10950: PPUSH
10951: CALL 51200 0 4
// end ;
10955: PPOPN 4
10957: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: CALL 46559 0 2
// end ;
10972: PPOPN 2
10974: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10975: LD_VAR 0 1
10979: PPUSH
10980: CALL 104174 0 1
// end ; end_of_file
10984: PPOPN 1
10986: END
// export function Action ; begin
10987: LD_INT 0
10989: PPUSH
// InGameOn ;
10990: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10994: LD_INT 206
10996: PPUSH
10997: LD_INT 11
10999: PPUSH
11000: CALL_OW 86
// wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11011: LD_EXP 17
11015: PPUSH
11016: LD_STRING DStart-JMM-JMM-1
11018: PPUSH
11019: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11023: LD_EXP 49
11027: PPUSH
11028: LD_STRING DStart-JMM-Bur-1
11030: PPUSH
11031: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11035: LD_EXP 17
11039: PPUSH
11040: LD_STRING DStart-JMM-JMM-2
11042: PPUSH
11043: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11047: LD_EXP 49
11051: PPUSH
11052: LD_STRING DStart-JMM-Bur-2
11054: PPUSH
11055: CALL_OW 88
// InGameOff ;
11059: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11063: LD_STRING MStart
11065: PPUSH
11066: CALL_OW 337
// SaveForQuickRestart ;
11070: CALL_OW 22
// end ;
11074: LD_VAR 0 1
11078: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11079: LD_INT 7
11081: PPUSH
11082: LD_INT 255
11084: PPUSH
11085: LD_INT 219
11087: PPUSH
11088: CALL_OW 293
11092: IFFALSE 11701
11094: GO 11096
11096: DISABLE
11097: LD_INT 0
11099: PPUSH
// begin wait ( 0 0$3 ) ;
11100: LD_INT 105
11102: PPUSH
11103: CALL_OW 67
// alienSpotted := true ;
11107: LD_ADDR_EXP 10
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11115: LD_ADDR_VAR 0 1
11119: PUSH
11120: LD_INT 22
11122: PUSH
11123: LD_INT 7
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: PUSH
11130: LD_INT 23
11132: PUSH
11133: LD_INT 3
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PUSH
11140: LD_INT 21
11142: PUSH
11143: LD_INT 1
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: PUSH
11150: LD_INT 26
11152: PUSH
11153: LD_INT 1
11155: PUSH
11156: EMPTY
11157: LIST
11158: LIST
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: PUSH
11171: LD_EXP 49
11175: PUSH
11176: LD_EXP 37
11180: PUSH
11181: LD_EXP 39
11185: PUSH
11186: LD_EXP 40
11190: PUSH
11191: LD_EXP 47
11195: PUSH
11196: LD_EXP 46
11200: PUSH
11201: LD_EXP 41
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: DIFF
11215: ST_TO_ADDR
// DialogueOn ;
11216: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11220: LD_INT 255
11222: PPUSH
11223: LD_INT 219
11225: PPUSH
11226: LD_INT 7
11228: PPUSH
11229: LD_INT 20
11231: NEG
11232: PPUSH
11233: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11237: LD_INT 255
11239: PPUSH
11240: LD_INT 219
11242: PPUSH
11243: CALL_OW 86
// if speaker then
11247: LD_VAR 0 1
11251: IFFALSE 11269
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11253: LD_VAR 0 1
11257: PUSH
11258: LD_INT 1
11260: ARRAY
11261: PPUSH
11262: LD_STRING DAlienBase-RSol1-1
11264: PPUSH
11265: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11269: LD_EXP 17
11273: PPUSH
11274: LD_STRING DAlienBase-JMM-1
11276: PPUSH
11277: CALL_OW 88
// if IsOk ( Burlak ) then
11281: LD_EXP 49
11285: PPUSH
11286: CALL_OW 302
11290: IFFALSE 11311
// begin dwait ( 0 0$1 ) ;
11292: LD_INT 35
11294: PPUSH
11295: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11299: LD_EXP 49
11303: PPUSH
11304: LD_STRING DAlienBase-Bur-1
11306: PPUSH
11307: CALL_OW 88
// end ; if IsOk ( Roth ) then
11311: LD_EXP 18
11315: PPUSH
11316: CALL_OW 302
11320: IFFALSE 11334
// Say ( Roth , DAlienBase-Roth-1 ) ;
11322: LD_EXP 18
11326: PPUSH
11327: LD_STRING DAlienBase-Roth-1
11329: PPUSH
11330: CALL_OW 88
// if IsOk ( Gossudarov ) then
11334: LD_EXP 35
11338: PPUSH
11339: CALL_OW 302
11343: IFFALSE 11359
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11345: LD_EXP 35
11349: PPUSH
11350: LD_STRING DAlienBase-Gos-1
11352: PPUSH
11353: CALL_OW 88
11357: GO 11476
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11359: LD_ADDR_VAR 0 1
11363: PUSH
11364: LD_INT 22
11366: PUSH
11367: LD_INT 7
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 25
11376: PUSH
11377: LD_INT 4
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 21
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PUSH
11394: LD_INT 26
11396: PUSH
11397: LD_INT 1
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: PPUSH
11410: CALL_OW 69
11414: PUSH
11415: LD_EXP 18
11419: PUSH
11420: LD_EXP 17
11424: PUSH
11425: LD_EXP 49
11429: PUSH
11430: LD_EXP 37
11434: PUSH
11435: LD_EXP 47
11439: PUSH
11440: LD_EXP 46
11444: PUSH
11445: EMPTY
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: DIFF
11453: ST_TO_ADDR
// if speaker then
11454: LD_VAR 0 1
11458: IFFALSE 11476
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11460: LD_VAR 0 1
11464: PUSH
11465: LD_INT 1
11467: ARRAY
11468: PPUSH
11469: LD_STRING DAlienBase-Sci1-1
11471: PPUSH
11472: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11476: LD_INT 255
11478: PPUSH
11479: LD_INT 219
11481: PPUSH
11482: LD_INT 7
11484: PPUSH
11485: CALL_OW 331
// DialogueOff ;
11489: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11493: LD_INT 35
11495: PPUSH
11496: CALL_OW 67
// until IsSelected ( alien ) ;
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 306
11507: IFFALSE 11493
// if not artifactIResearched or not artifactIIResearched then
11509: LD_EXP 12
11513: NOT
11514: PUSH
11515: LD_EXP 13
11519: NOT
11520: OR
11521: IFFALSE 11701
// begin if IsOk ( Roth ) then
11523: LD_EXP 18
11527: PPUSH
11528: CALL_OW 302
11532: IFFALSE 11548
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11534: LD_EXP 18
11538: PPUSH
11539: LD_STRING DAlieBaseNotReady-Roth-1
11541: PPUSH
11542: CALL_OW 88
11546: GO 11701
// if IsOk ( Gossudarov ) then
11548: LD_EXP 35
11552: PPUSH
11553: CALL_OW 302
11557: IFFALSE 11573
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11559: LD_EXP 35
11563: PPUSH
11564: LD_STRING DAlieBaseNotReady-Gos-1
11566: PPUSH
11567: CALL_OW 88
11571: GO 11701
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11573: LD_ADDR_VAR 0 1
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_INT 7
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 23
11590: PUSH
11591: LD_INT 3
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: LD_INT 25
11600: PUSH
11601: LD_INT 4
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PUSH
11608: LD_INT 21
11610: PUSH
11611: LD_INT 1
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 26
11620: PUSH
11621: LD_INT 1
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: PPUSH
11635: CALL_OW 69
11639: PUSH
11640: LD_EXP 18
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 49
11654: PUSH
11655: LD_EXP 37
11659: PUSH
11660: LD_EXP 47
11664: PUSH
11665: LD_EXP 46
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: DIFF
11678: ST_TO_ADDR
// if speaker then
11679: LD_VAR 0 1
11683: IFFALSE 11701
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11685: LD_VAR 0 1
11689: PUSH
11690: LD_INT 1
11692: ARRAY
11693: PPUSH
11694: LD_STRING DAlieBaseNotReady-RSci1-1
11696: PPUSH
11697: CALL_OW 88
// end ; end ; end ;
11701: PPOPN 1
11703: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11704: LD_INT 24
11706: PPUSH
11707: LD_INT 7
11709: PPUSH
11710: CALL_OW 321
11714: PUSH
11715: LD_INT 2
11717: EQUAL
11718: IFFALSE 12409
11720: GO 11722
11722: DISABLE
11723: LD_INT 0
11725: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11726: LD_ADDR_VAR 0 1
11730: PUSH
11731: LD_INT 22
11733: PUSH
11734: LD_INT 7
11736: PUSH
11737: EMPTY
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 23
11743: PUSH
11744: LD_INT 3
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: PUSH
11751: LD_INT 25
11753: PUSH
11754: LD_INT 4
11756: PUSH
11757: EMPTY
11758: LIST
11759: LIST
11760: PUSH
11761: LD_INT 21
11763: PUSH
11764: LD_INT 1
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: LD_INT 26
11773: PUSH
11774: LD_INT 1
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL_OW 69
11792: PUSH
11793: LD_EXP 18
11797: PUSH
11798: LD_EXP 17
11802: PUSH
11803: LD_EXP 49
11807: PUSH
11808: LD_EXP 37
11812: PUSH
11813: LD_EXP 47
11817: PUSH
11818: LD_EXP 46
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: DIFF
11831: ST_TO_ADDR
// if not speaker then
11832: LD_VAR 0 1
11836: NOT
11837: IFFALSE 11841
// exit ;
11839: GO 12409
// DialogueOn ;
11841: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11845: LD_VAR 0 1
11849: PUSH
11850: LD_INT 1
11852: ARRAY
11853: PPUSH
11854: LD_STRING DArtefTechnology-RSci1-1
11856: PPUSH
11857: CALL_OW 88
// if IsOk ( Burlak ) then
11861: LD_EXP 49
11865: PPUSH
11866: CALL_OW 302
11870: IFFALSE 11884
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11872: LD_EXP 49
11876: PPUSH
11877: LD_STRING DArtefTechnology-Bur-1
11879: PPUSH
11880: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11884: LD_VAR 0 1
11888: PUSH
11889: LD_INT 1
11891: ARRAY
11892: PPUSH
11893: LD_STRING DArtefTechnology-RSci1-2
11895: PPUSH
11896: CALL_OW 88
// if Denis then
11900: LD_EXP 23
11904: IFFALSE 11921
// speaker := [ Denis ] else
11906: LD_ADDR_VAR 0 1
11910: PUSH
11911: LD_EXP 23
11915: PUSH
11916: EMPTY
11917: LIST
11918: ST_TO_ADDR
11919: GO 12027
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11921: LD_ADDR_VAR 0 1
11925: PUSH
11926: LD_INT 22
11928: PUSH
11929: LD_INT 7
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: LD_INT 23
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 25
11948: PUSH
11949: LD_INT 4
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: LD_INT 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 26
11968: PUSH
11969: LD_INT 1
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: PPUSH
11983: CALL_OW 69
11987: PUSH
11988: LD_EXP 18
11992: PUSH
11993: LD_EXP 17
11997: PUSH
11998: LD_EXP 49
12002: PUSH
12003: LD_EXP 37
12007: PUSH
12008: LD_EXP 47
12012: PUSH
12013: LD_EXP 46
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: DIFF
12026: ST_TO_ADDR
// if speaker then
12027: LD_VAR 0 1
12031: IFFALSE 12049
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12033: LD_VAR 0 1
12037: PUSH
12038: LD_INT 1
12040: ARRAY
12041: PPUSH
12042: LD_STRING DArtefTechnology-Sci1-2
12044: PPUSH
12045: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12049: LD_ADDR_VAR 0 1
12053: PUSH
12054: LD_INT 22
12056: PUSH
12057: LD_INT 7
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 3
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 25
12076: PUSH
12077: LD_INT 4
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 1
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 26
12096: PUSH
12097: LD_INT 1
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: PPUSH
12111: CALL_OW 69
12115: PUSH
12116: LD_EXP 18
12120: PUSH
12121: LD_EXP 17
12125: PUSH
12126: LD_EXP 49
12130: PUSH
12131: LD_EXP 37
12135: PUSH
12136: LD_EXP 47
12140: PUSH
12141: LD_EXP 46
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: DIFF
12154: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12155: LD_VAR 0 1
12159: PUSH
12160: LD_EXP 9
12164: PUSH
12165: LD_EXP 5
12169: OR
12170: AND
12171: IFFALSE 12405
// begin if arabianDestroyed and IsOk ( Burlak ) then
12173: LD_EXP 5
12177: PUSH
12178: LD_EXP 49
12182: PPUSH
12183: CALL_OW 302
12187: AND
12188: IFFALSE 12204
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12190: LD_EXP 49
12194: PPUSH
12195: LD_STRING DArtefTechnology-Bur-2
12197: PPUSH
12198: CALL_OW 88
12202: GO 12216
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12204: LD_EXP 17
12208: PPUSH
12209: LD_STRING DArtefTechnology-JMM-2
12211: PPUSH
12212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12216: LD_VAR 0 1
12220: PUSH
12221: LD_INT 1
12223: ARRAY
12224: PPUSH
12225: LD_STRING DArtefTechnology-RSci1-3
12227: PPUSH
12228: CALL_OW 88
// if Denis then
12232: LD_EXP 23
12236: IFFALSE 12253
// speaker := [ Denis ] else
12238: LD_ADDR_VAR 0 1
12242: PUSH
12243: LD_EXP 23
12247: PUSH
12248: EMPTY
12249: LIST
12250: ST_TO_ADDR
12251: GO 12359
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12253: LD_ADDR_VAR 0 1
12257: PUSH
12258: LD_INT 22
12260: PUSH
12261: LD_INT 7
12263: PUSH
12264: EMPTY
12265: LIST
12266: LIST
12267: PUSH
12268: LD_INT 23
12270: PUSH
12271: LD_INT 1
12273: PUSH
12274: EMPTY
12275: LIST
12276: LIST
12277: PUSH
12278: LD_INT 25
12280: PUSH
12281: LD_INT 4
12283: PUSH
12284: EMPTY
12285: LIST
12286: LIST
12287: PUSH
12288: LD_INT 21
12290: PUSH
12291: LD_INT 1
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: PUSH
12298: LD_INT 26
12300: PUSH
12301: LD_INT 1
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: PPUSH
12315: CALL_OW 69
12319: PUSH
12320: LD_EXP 18
12324: PUSH
12325: LD_EXP 17
12329: PUSH
12330: LD_EXP 49
12334: PUSH
12335: LD_EXP 37
12339: PUSH
12340: LD_EXP 47
12344: PUSH
12345: LD_EXP 46
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: DIFF
12358: ST_TO_ADDR
// if speaker then
12359: LD_VAR 0 1
12363: IFFALSE 12405
// if alienSpotted then
12365: LD_EXP 10
12369: IFFALSE 12389
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12371: LD_VAR 0 1
12375: PUSH
12376: LD_INT 1
12378: ARRAY
12379: PPUSH
12380: LD_STRING DArtefTechnology-Sci1-3
12382: PPUSH
12383: CALL_OW 88
12387: GO 12405
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12389: LD_VAR 0 1
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PPUSH
12398: LD_STRING DArtefTechnology-Sci1-3a
12400: PPUSH
12401: CALL_OW 88
// end ; DialogueOff ;
12405: CALL_OW 7
// end ;
12409: PPOPN 1
12411: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12412: LD_EXP 12
12416: IFFALSE 12611
12418: GO 12420
12420: DISABLE
12421: LD_INT 0
12423: PPUSH
// begin if Denis then
12424: LD_EXP 23
12428: IFFALSE 12445
// speaker := [ Denis ] else
12430: LD_ADDR_VAR 0 1
12434: PUSH
12435: LD_EXP 23
12439: PUSH
12440: EMPTY
12441: LIST
12442: ST_TO_ADDR
12443: GO 12551
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12445: LD_ADDR_VAR 0 1
12449: PUSH
12450: LD_INT 22
12452: PUSH
12453: LD_INT 7
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 23
12462: PUSH
12463: LD_INT 1
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 21
12482: PUSH
12483: LD_INT 1
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 26
12492: PUSH
12493: LD_INT 1
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: PPUSH
12507: CALL_OW 69
12511: PUSH
12512: LD_EXP 18
12516: PUSH
12517: LD_EXP 17
12521: PUSH
12522: LD_EXP 49
12526: PUSH
12527: LD_EXP 37
12531: PUSH
12532: LD_EXP 47
12536: PUSH
12537: LD_EXP 46
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: DIFF
12550: ST_TO_ADDR
// if not speaker then
12551: LD_VAR 0 1
12555: NOT
12556: IFFALSE 12560
// exit ;
12558: GO 12611
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12560: LD_VAR 0 1
12564: PUSH
12565: LD_INT 1
12567: ARRAY
12568: PPUSH
12569: LD_STRING DArtefTechnologyAm-Sci1-1
12571: PPUSH
12572: CALL_OW 88
// if IsOk ( Burlak ) then
12576: LD_EXP 49
12580: PPUSH
12581: CALL_OW 302
12585: IFFALSE 12599
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12587: LD_EXP 49
12591: PPUSH
12592: LD_STRING DArtefTechnologyAm-Bur-1
12594: PPUSH
12595: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12599: LD_EXP 17
12603: PPUSH
12604: LD_STRING DArtefTechnologyAm-JMM-1
12606: PPUSH
12607: CALL_OW 88
// end ;
12611: PPOPN 1
12613: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12614: LD_EXP 13
12618: IFFALSE 12808
12620: GO 12622
12622: DISABLE
12623: LD_INT 0
12625: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12626: LD_ADDR_VAR 0 1
12630: PUSH
12631: LD_INT 22
12633: PUSH
12634: LD_INT 7
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 23
12643: PUSH
12644: LD_INT 3
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 4
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 21
12663: PUSH
12664: LD_INT 1
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: LD_INT 26
12673: PUSH
12674: LD_INT 1
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: LIST
12687: PPUSH
12688: CALL_OW 69
12692: PUSH
12693: LD_EXP 18
12697: PUSH
12698: LD_EXP 17
12702: PUSH
12703: LD_EXP 49
12707: PUSH
12708: LD_EXP 37
12712: PUSH
12713: LD_EXP 47
12717: PUSH
12718: LD_EXP 46
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: DIFF
12731: ST_TO_ADDR
// if not speaker then
12732: LD_VAR 0 1
12736: NOT
12737: IFFALSE 12741
// exit ;
12739: GO 12808
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12741: LD_VAR 0 1
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: PPUSH
12750: LD_STRING DArtefTechnologyRu-RSci1-1
12752: PPUSH
12753: CALL_OW 88
// if IsOk ( Burlak ) then
12757: LD_EXP 49
12761: PPUSH
12762: CALL_OW 302
12766: IFFALSE 12780
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12768: LD_EXP 49
12772: PPUSH
12773: LD_STRING DArtefTechnologyRu-Bur-1
12775: PPUSH
12776: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12780: LD_VAR 0 1
12784: PUSH
12785: LD_INT 1
12787: ARRAY
12788: PPUSH
12789: LD_STRING DArtefTechnologyRu-RSci1-2
12791: PPUSH
12792: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12796: LD_EXP 17
12800: PPUSH
12801: LD_STRING DArtefTechnologyRu-JMM-1
12803: PPUSH
12804: CALL_OW 88
// end ;
12808: PPOPN 1
12810: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12811: LD_INT 24
12813: PPUSH
12814: LD_INT 7
12816: PPUSH
12817: CALL_OW 321
12821: PUSH
12822: LD_INT 2
12824: EQUAL
12825: PUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 255
12833: PUSH
12834: LD_INT 7
12836: EQUAL
12837: AND
12838: IFFALSE 12998
12840: GO 12842
12842: DISABLE
12843: LD_INT 0
12845: PPUSH
// begin if Denis then
12846: LD_EXP 23
12850: IFFALSE 12867
// speaker := [ Denis ] else
12852: LD_ADDR_VAR 0 1
12856: PUSH
12857: LD_EXP 23
12861: PUSH
12862: EMPTY
12863: LIST
12864: ST_TO_ADDR
12865: GO 12973
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12867: LD_ADDR_VAR 0 1
12871: PUSH
12872: LD_INT 22
12874: PUSH
12875: LD_INT 7
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PUSH
12882: LD_INT 23
12884: PUSH
12885: LD_INT 1
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 25
12894: PUSH
12895: LD_INT 4
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: PUSH
12902: LD_INT 21
12904: PUSH
12905: LD_INT 1
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 26
12914: PUSH
12915: LD_INT 1
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: PUSH
12934: LD_EXP 18
12938: PUSH
12939: LD_EXP 17
12943: PUSH
12944: LD_EXP 49
12948: PUSH
12949: LD_EXP 37
12953: PUSH
12954: LD_EXP 47
12958: PUSH
12959: LD_EXP 46
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: DIFF
12972: ST_TO_ADDR
// if not speaker then
12973: LD_VAR 0 1
12977: NOT
12978: IFFALSE 12982
// exit ;
12980: GO 12998
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12982: LD_VAR 0 1
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: LD_STRING DArtefTechnologyArStart-Sci1-1
12993: PPUSH
12994: CALL_OW 88
// end ;
12998: PPOPN 1
13000: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13001: LD_EXP 14
13005: IFFALSE 13286
13007: GO 13009
13009: DISABLE
13010: LD_INT 0
13012: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_INT 22
13020: PUSH
13021: LD_INT 7
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 23
13030: PUSH
13031: LD_INT 3
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 25
13040: PUSH
13041: LD_INT 4
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: LD_INT 21
13050: PUSH
13051: LD_INT 1
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PUSH
13058: LD_INT 26
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: PPUSH
13075: CALL_OW 69
13079: PUSH
13080: LD_EXP 18
13084: PUSH
13085: LD_EXP 17
13089: PUSH
13090: LD_EXP 49
13094: PUSH
13095: LD_EXP 37
13099: PUSH
13100: LD_EXP 47
13104: PUSH
13105: LD_EXP 46
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: DIFF
13118: ST_TO_ADDR
// if not speaker then
13119: LD_VAR 0 1
13123: NOT
13124: IFFALSE 13128
// exit ;
13126: GO 13286
// DialogueOn ;
13128: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-1
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-1
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-2
13171: PPUSH
13172: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13176: LD_EXP 17
13180: PPUSH
13181: LD_STRING DArtefTechnologyAr-JMM-2
13183: PPUSH
13184: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 1
13195: ARRAY
13196: PPUSH
13197: LD_STRING DArtefTechnologyAr-RSci1-3
13199: PPUSH
13200: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13204: LD_EXP 17
13208: PPUSH
13209: LD_STRING DArtefTechnologyAr-JMM-3
13211: PPUSH
13212: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13216: LD_VAR 0 1
13220: PUSH
13221: LD_INT 1
13223: ARRAY
13224: PPUSH
13225: LD_STRING DArtefTechnologyAr-RSci1-4
13227: PPUSH
13228: CALL_OW 88
// if IsOk ( Burlak ) then
13232: LD_EXP 49
13236: PPUSH
13237: CALL_OW 302
13241: IFFALSE 13255
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13243: LD_EXP 49
13247: PPUSH
13248: LD_STRING DArtefTechnologyAr-Bur-4
13250: PPUSH
13251: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13255: LD_EXP 17
13259: PPUSH
13260: LD_STRING DArtefTechnologyAr-JMM-4
13262: PPUSH
13263: CALL_OW 88
// DialogueOff ;
13267: CALL_OW 7
// wait ( 0 0$45 ) ;
13271: LD_INT 1575
13273: PPUSH
13274: CALL_OW 67
// spawnOmar := true ;
13278: LD_ADDR_EXP 11
13282: PUSH
13283: LD_INT 1
13285: ST_TO_ADDR
// end ;
13286: PPOPN 1
13288: END
// every 0 0$1 trigger spawnOmar do
13289: LD_EXP 11
13293: IFFALSE 13673
13295: GO 13297
13297: DISABLE
// begin PrepareOmarAli ;
13298: CALL 6775 0 0
// if not HasTask ( Omar ) then
13302: LD_EXP 53
13306: PPUSH
13307: CALL_OW 314
13311: NOT
13312: IFFALSE 13329
// ComMoveXY ( Omar , 252 , 220 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_INT 252
13321: PPUSH
13322: LD_INT 220
13324: PPUSH
13325: CALL_OW 111
// if not Omar then
13329: LD_EXP 53
13333: NOT
13334: IFFALSE 13338
// exit ;
13336: GO 13673
// repeat wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13345: LD_EXP 53
13349: PPUSH
13350: CALL_OW 314
13354: NOT
13355: PUSH
13356: LD_EXP 53
13360: PPUSH
13361: LD_INT 252
13363: PPUSH
13364: LD_INT 220
13366: PPUSH
13367: CALL_OW 297
13371: PUSH
13372: LD_INT 6
13374: GREATER
13375: AND
13376: IFFALSE 13393
// ComMoveXY ( Omar , 252 , 220 ) ;
13378: LD_EXP 53
13382: PPUSH
13383: LD_INT 252
13385: PPUSH
13386: LD_INT 220
13388: PPUSH
13389: CALL_OW 111
// until See ( 7 , Omar ) ;
13393: LD_INT 7
13395: PPUSH
13396: LD_EXP 53
13400: PPUSH
13401: CALL_OW 292
13405: IFFALSE 13338
// CenterNowOnUnits ( Omar ) ;
13407: LD_EXP 53
13411: PPUSH
13412: CALL_OW 87
// DialogueOn ;
13416: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13420: LD_EXP 53
13424: PPUSH
13425: LD_STRING DOmar-Omar-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DOmar-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13444: LD_EXP 53
13448: PPUSH
13449: LD_STRING DOmar-Omar-2
13451: PPUSH
13452: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13456: LD_EXP 17
13460: PPUSH
13461: LD_STRING DOmar-JMM-2
13463: PPUSH
13464: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13468: LD_EXP 53
13472: PPUSH
13473: LD_STRING DOmar-Omar-3
13475: PPUSH
13476: CALL_OW 88
// if IsOk ( Burlak ) then
13480: LD_EXP 49
13484: PPUSH
13485: CALL_OW 302
13489: IFFALSE 13505
// Say ( Burlak , DOmar-Bur-3 ) else
13491: LD_EXP 49
13495: PPUSH
13496: LD_STRING DOmar-Bur-3
13498: PPUSH
13499: CALL_OW 88
13503: GO 13517
// Say ( JMM , DOmar-JMM-3 ) ;
13505: LD_EXP 17
13509: PPUSH
13510: LD_STRING DOmar-JMM-3
13512: PPUSH
13513: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13517: LD_EXP 53
13521: PPUSH
13522: LD_STRING DOmar-Omar-4
13524: PPUSH
13525: CALL_OW 88
// case Query ( QAccept ) of 1 :
13529: LD_STRING QAccept
13531: PPUSH
13532: CALL_OW 97
13536: PUSH
13537: LD_INT 1
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13581
13545: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13546: LD_EXP 17
13550: PPUSH
13551: LD_STRING DQrAccept#1-JMM-1
13553: PPUSH
13554: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13558: LD_EXP 53
13562: PPUSH
13563: LD_INT 7
13565: PPUSH
13566: CALL_OW 235
// ComStop ( Omar ) ;
13570: LD_EXP 53
13574: PPUSH
13575: CALL_OW 141
// end ; 2 :
13579: GO 13630
13581: LD_INT 2
13583: DOUBLE
13584: EQUAL
13585: IFTRUE 13589
13587: GO 13629
13589: POP
// begin if IsOk ( Burlak ) then
13590: LD_EXP 49
13594: PPUSH
13595: CALL_OW 302
13599: IFFALSE 13615
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13601: LD_EXP 49
13605: PPUSH
13606: LD_STRING DQrAccept#2-Bur-1
13608: PPUSH
13609: CALL_OW 88
13613: GO 13627
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13615: LD_EXP 17
13619: PPUSH
13620: LD_STRING DQrAccept#2-JMM-1
13622: PPUSH
13623: CALL_OW 88
// end ; end ;
13627: GO 13630
13629: POP
// DialogueOff ;
13630: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 255
13643: PUSH
13644: LD_INT 7
13646: EQUAL
13647: IFFALSE 13658
// begin SetAchievement ( ACH_OMAR ) ;
13649: LD_STRING ACH_OMAR
13651: PPUSH
13652: CALL_OW 543
// exit ;
13656: GO 13673
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13658: LD_EXP 53
13662: PPUSH
13663: LD_INT 202
13665: PPUSH
13666: LD_INT 115
13668: PPUSH
13669: CALL_OW 111
// end ;
13673: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13674: LD_EXP 53
13678: PPUSH
13679: LD_INT 200
13681: PPUSH
13682: LD_INT 98
13684: PPUSH
13685: CALL_OW 297
13689: PUSH
13690: LD_INT 40
13692: LESS
13693: PUSH
13694: LD_EXP 2
13698: AND
13699: IFFALSE 13917
13701: GO 13703
13703: DISABLE
// begin SetSide ( Omar , 5 ) ;
13704: LD_EXP 53
13708: PPUSH
13709: LD_INT 5
13711: PPUSH
13712: CALL_OW 235
// if IsInUnit ( Omar ) then
13716: LD_EXP 53
13720: PPUSH
13721: CALL_OW 310
13725: IFFALSE 13736
// ComExitVehicle ( Omar ) ;
13727: LD_EXP 53
13731: PPUSH
13732: CALL_OW 121
// if IsInUnit ( Omar ) then
13736: LD_EXP 53
13740: PPUSH
13741: CALL_OW 310
13745: IFFALSE 13756
// ComExitBuilding ( Omar ) ;
13747: LD_EXP 53
13751: PPUSH
13752: CALL_OW 122
// wait ( 0 0$1 ) ;
13756: LD_INT 35
13758: PPUSH
13759: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13763: LD_EXP 53
13767: PPUSH
13768: LD_INT 203
13770: PPUSH
13771: LD_INT 120
13773: PPUSH
13774: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13778: LD_INT 35
13780: PPUSH
13781: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13785: LD_EXP 53
13789: PPUSH
13790: CALL_OW 306
13794: PUSH
13795: LD_EXP 53
13799: PPUSH
13800: LD_INT 203
13802: PPUSH
13803: LD_INT 120
13805: PPUSH
13806: CALL_OW 297
13810: PUSH
13811: LD_INT 6
13813: LESS
13814: OR
13815: IFFALSE 13778
// CenterNowOnUnits ( Omar ) ;
13817: LD_EXP 53
13821: PPUSH
13822: CALL_OW 87
// DialogueOn ;
13826: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13830: LD_EXP 17
13834: PPUSH
13835: LD_STRING DOmarContam-JMM-1
13837: PPUSH
13838: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13842: LD_EXP 53
13846: PPUSH
13847: LD_STRING DOmarContam-Omar-1
13849: PPUSH
13850: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13854: LD_EXP 17
13858: PPUSH
13859: LD_STRING DOmarContam-JMM-2
13861: PPUSH
13862: CALL_OW 88
// DialogueOff ;
13866: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13870: LD_INT 5
13872: PPUSH
13873: LD_INT 7
13875: PPUSH
13876: LD_INT 2
13878: PPUSH
13879: LD_INT 1
13881: PPUSH
13882: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13886: LD_INT 105
13888: PPUSH
13889: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13893: LD_EXP 53
13897: PPUSH
13898: LD_INT 203
13900: PPUSH
13901: LD_INT 120
13903: PPUSH
13904: CALL_OW 307
13908: IFFALSE 13886
// YouLost ( MothContaminate ) ;
13910: LD_STRING MothContaminate
13912: PPUSH
13913: CALL_OW 104
// end ;
13917: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13918: LD_EXP 4
13922: NOT
13923: PUSH
13924: LD_INT 22
13926: PUSH
13927: LD_INT 1
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: LD_INT 34
13936: PUSH
13937: LD_INT 8
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PPUSH
13948: CALL_OW 69
13952: AND
13953: IFFALSE 14072
13955: GO 13957
13957: DISABLE
// begin wait ( 0 0$5 ) ;
13958: LD_INT 175
13960: PPUSH
13961: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13965: LD_EXP 52
13969: PPUSH
13970: CALL_OW 302
13974: NOT
13975: PUSH
13976: LD_INT 22
13978: PUSH
13979: LD_INT 1
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 34
13988: PUSH
13989: LD_INT 8
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PPUSH
14000: CALL_OW 69
14004: NOT
14005: OR
14006: IFFALSE 14010
// exit ;
14008: GO 14072
// DialogueOn ;
14010: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14014: LD_EXP 52
14018: PPUSH
14019: LD_STRING DWinAmericans-Pow-1
14021: PPUSH
14022: CALL_OW 94
// if IsOk ( Burlak ) then
14026: LD_EXP 49
14030: PPUSH
14031: CALL_OW 302
14035: IFFALSE 14049
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14037: LD_EXP 49
14041: PPUSH
14042: LD_STRING DWinAmericans-Bur-1
14044: PPUSH
14045: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14049: LD_EXP 17
14053: PPUSH
14054: LD_STRING DWinAmericans-JMM-1
14056: PPUSH
14057: CALL_OW 88
// DialogueOff ;
14061: CALL_OW 7
// YouLost ( AmBomb ) ;
14065: LD_STRING AmBomb
14067: PPUSH
14068: CALL_OW 104
// end ;
14072: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14073: LD_EXP 2
14077: NOT
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 3
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 34
14091: PUSH
14092: LD_INT 48
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: CALL_OW 69
14107: AND
14108: IFFALSE 14227
14110: GO 14112
14112: DISABLE
// begin wait ( 0 0$5 ) ;
14113: LD_INT 175
14115: PPUSH
14116: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14120: LD_EXP 56
14124: PPUSH
14125: CALL_OW 302
14129: NOT
14130: PUSH
14131: LD_INT 22
14133: PUSH
14134: LD_INT 3
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: LD_INT 34
14143: PUSH
14144: LD_INT 48
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PPUSH
14155: CALL_OW 69
14159: NOT
14160: OR
14161: IFFALSE 14165
// exit ;
14163: GO 14227
// DialogueOn ;
14165: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14169: LD_EXP 56
14173: PPUSH
14174: LD_STRING DWinRussians-Pla-1
14176: PPUSH
14177: CALL_OW 94
// if IsOk ( Burlak ) then
14181: LD_EXP 49
14185: PPUSH
14186: CALL_OW 302
14190: IFFALSE 14204
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14192: LD_EXP 49
14196: PPUSH
14197: LD_STRING DWinRussians-Bur-1
14199: PPUSH
14200: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14204: LD_EXP 17
14208: PPUSH
14209: LD_STRING DWinRussians-JMM-1
14211: PPUSH
14212: CALL_OW 88
// DialogueOff ;
14216: CALL_OW 7
// YouLost ( RuBomb ) ;
14220: LD_STRING RuBomb
14222: PPUSH
14223: CALL_OW 104
// end ;
14227: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14228: LD_INT 7
14230: PPUSH
14231: LD_INT 22
14233: PUSH
14234: LD_INT 7
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PPUSH
14241: CALL_OW 70
14245: PUSH
14246: LD_EXP 4
14250: NOT
14251: AND
14252: IFFALSE 14281
14254: GO 14256
14256: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14257: LD_EXP 52
14261: PPUSH
14262: LD_STRING DSurrenderAmericans-Pow-1
14264: PPUSH
14265: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14269: LD_EXP 17
14273: PPUSH
14274: LD_STRING DSurrenderAmericans-JMM-1
14276: PPUSH
14277: CALL_OW 88
// end ;
14281: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14282: LD_INT 2
14284: PPUSH
14285: LD_INT 22
14287: PUSH
14288: LD_INT 7
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 70
14299: PUSH
14300: LD_EXP 2
14304: NOT
14305: AND
14306: PUSH
14307: LD_EXP 49
14311: AND
14312: IFFALSE 14341
14314: GO 14316
14316: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14317: LD_EXP 56
14321: PPUSH
14322: LD_STRING DSurrenderRussians-Pla-1
14324: PPUSH
14325: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14329: LD_EXP 49
14333: PPUSH
14334: LD_STRING DSurrenderRussians-Bur-1
14336: PPUSH
14337: CALL_OW 88
// end ;
14341: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14342: LD_EXP 4
14346: IFFALSE 14729
14348: GO 14350
14350: DISABLE
14351: LD_INT 0
14353: PPUSH
14354: PPUSH
14355: PPUSH
// begin MC_Kill ( 4 ) ;
14356: LD_INT 4
14358: PPUSH
14359: CALL 21104 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14363: LD_INT 1
14365: PPUSH
14366: LD_INT 7
14368: PPUSH
14369: LD_INT 1
14371: PPUSH
14372: LD_INT 1
14374: PPUSH
14375: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14379: LD_ADDR_VAR 0 3
14383: PUSH
14384: LD_INT 22
14386: PUSH
14387: LD_INT 1
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 26
14396: PUSH
14397: LD_INT 1
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: LD_INT 23
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: LIST
14418: PPUSH
14419: CALL_OW 69
14423: PUSH
14424: LD_EXP 52
14428: PUSH
14429: LD_EXP 25
14433: PUSH
14434: LD_EXP 22
14438: PUSH
14439: LD_EXP 21
14443: PUSH
14444: LD_EXP 28
14448: PUSH
14449: LD_EXP 26
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: DIFF
14462: ST_TO_ADDR
// if speaker then
14463: LD_VAR 0 3
14467: IFFALSE 14493
// begin DialogueOn ;
14469: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14473: LD_VAR 0 3
14477: PUSH
14478: LD_INT 1
14480: ARRAY
14481: PPUSH
14482: LD_STRING DSurrenderAmericans-Sol1-1a
14484: PPUSH
14485: CALL_OW 94
// DialogueOff ;
14489: CALL_OW 7
// end ; americanCapitulated := true ;
14493: LD_ADDR_EXP 6
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14501: LD_ADDR_VAR 0 2
14505: PUSH
14506: LD_INT 22
14508: PUSH
14509: LD_INT 1
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PUSH
14516: LD_INT 21
14518: PUSH
14519: LD_INT 1
14521: PUSH
14522: EMPTY
14523: LIST
14524: LIST
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PPUSH
14530: CALL_OW 69
14534: PUSH
14535: LD_INT 22
14537: PUSH
14538: LD_INT 1
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: LD_INT 21
14547: PUSH
14548: LD_INT 2
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: PUSH
14555: LD_INT 1
14557: PUSH
14558: EMPTY
14559: LIST
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: LIST
14565: PPUSH
14566: CALL_OW 69
14570: ADD
14571: ST_TO_ADDR
// if tmp then
14572: LD_VAR 0 2
14576: IFFALSE 14729
// repeat wait ( 0 0$1 ) ;
14578: LD_INT 35
14580: PPUSH
14581: CALL_OW 67
// for i in tmp do
14585: LD_ADDR_VAR 0 1
14589: PUSH
14590: LD_VAR 0 2
14594: PUSH
14595: FOR_IN
14596: IFFALSE 14678
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14598: LD_VAR 0 1
14602: PPUSH
14603: CALL_OW 310
14607: PUSH
14608: LD_VAR 0 1
14612: PPUSH
14613: CALL_OW 310
14617: PPUSH
14618: CALL_OW 247
14622: PUSH
14623: LD_INT 3
14625: EQUAL
14626: AND
14627: IFFALSE 14638
// ComExitBuilding ( i ) ;
14629: LD_VAR 0 1
14633: PPUSH
14634: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14638: LD_VAR 0 1
14642: PPUSH
14643: LD_INT 122
14645: PPUSH
14646: LD_INT 242
14648: PPUSH
14649: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14653: LD_VAR 0 1
14657: PPUSH
14658: LD_INT 35
14660: PPUSH
14661: CALL_OW 308
14665: IFFALSE 14676
// RemoveUnit ( i ) ;
14667: LD_VAR 0 1
14671: PPUSH
14672: CALL_OW 64
// end ;
14676: GO 14595
14678: POP
14679: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14680: LD_INT 22
14682: PUSH
14683: LD_INT 1
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: LD_INT 2
14692: PUSH
14693: LD_INT 21
14695: PUSH
14696: LD_INT 1
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: PUSH
14703: LD_INT 33
14705: PUSH
14706: LD_INT 1
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: PPUSH
14722: CALL_OW 69
14726: NOT
14727: IFFALSE 14578
// end ;
14729: PPOPN 3
14731: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14732: LD_EXP 2
14736: IFFALSE 15137
14738: GO 14740
14740: DISABLE
14741: LD_INT 0
14743: PPUSH
14744: PPUSH
14745: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14746: LD_INT 35
14748: PPUSH
14749: CALL_OW 67
// until IsDead ( Yakotich ) ;
14753: LD_EXP 57
14757: PPUSH
14758: CALL_OW 301
14762: IFFALSE 14746
// MC_Kill ( 2 ) ;
14764: LD_INT 2
14766: PPUSH
14767: CALL 21104 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14771: LD_INT 3
14773: PPUSH
14774: LD_INT 7
14776: PPUSH
14777: LD_INT 1
14779: PPUSH
14780: LD_INT 1
14782: PPUSH
14783: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14787: LD_ADDR_VAR 0 3
14791: PUSH
14792: LD_INT 22
14794: PUSH
14795: LD_INT 3
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 26
14804: PUSH
14805: LD_INT 1
14807: PUSH
14808: EMPTY
14809: LIST
14810: LIST
14811: PUSH
14812: LD_INT 23
14814: PUSH
14815: LD_INT 3
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: EMPTY
14823: LIST
14824: LIST
14825: LIST
14826: PPUSH
14827: CALL_OW 69
14831: PUSH
14832: LD_EXP 56
14836: PUSH
14837: LD_EXP 57
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: DIFF
14846: ST_TO_ADDR
// if speaker then
14847: LD_VAR 0 3
14851: IFFALSE 14901
// begin DialogueOn ;
14853: CALL_OW 6
// if Burlak then
14857: LD_EXP 49
14861: IFFALSE 14881
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14863: LD_VAR 0 3
14867: PUSH
14868: LD_INT 1
14870: ARRAY
14871: PPUSH
14872: LD_STRING DSurrenderRussians-RSol1-1
14874: PPUSH
14875: CALL_OW 94
14879: GO 14897
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14881: LD_VAR 0 3
14885: PUSH
14886: LD_INT 1
14888: ARRAY
14889: PPUSH
14890: LD_STRING DSurrenderRussians-RSol1-1a
14892: PPUSH
14893: CALL_OW 94
// DialogueOff ;
14897: CALL_OW 7
// end ; russianCapitulated := true ;
14901: LD_ADDR_EXP 7
14905: PUSH
14906: LD_INT 1
14908: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14909: LD_ADDR_VAR 0 2
14913: PUSH
14914: LD_INT 22
14916: PUSH
14917: LD_INT 3
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: LD_INT 21
14926: PUSH
14927: LD_INT 1
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: PPUSH
14938: CALL_OW 69
14942: PUSH
14943: LD_INT 22
14945: PUSH
14946: LD_INT 3
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: PUSH
14953: LD_INT 21
14955: PUSH
14956: LD_INT 2
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 1
14965: PUSH
14966: EMPTY
14967: LIST
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL_OW 69
14978: ADD
14979: ST_TO_ADDR
// if tmp then
14980: LD_VAR 0 2
14984: IFFALSE 15137
// repeat wait ( 0 0$1 ) ;
14986: LD_INT 35
14988: PPUSH
14989: CALL_OW 67
// for i in tmp do
14993: LD_ADDR_VAR 0 1
14997: PUSH
14998: LD_VAR 0 2
15002: PUSH
15003: FOR_IN
15004: IFFALSE 15086
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15006: LD_VAR 0 1
15010: PPUSH
15011: CALL_OW 310
15015: PUSH
15016: LD_VAR 0 1
15020: PPUSH
15021: CALL_OW 310
15025: PPUSH
15026: CALL_OW 247
15030: PUSH
15031: LD_INT 3
15033: EQUAL
15034: AND
15035: IFFALSE 15046
// ComExitBuilding ( i ) ;
15037: LD_VAR 0 1
15041: PPUSH
15042: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15046: LD_VAR 0 1
15050: PPUSH
15051: LD_INT 154
15053: PPUSH
15054: LD_INT 1
15056: PPUSH
15057: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 36
15068: PPUSH
15069: CALL_OW 308
15073: IFFALSE 15084
// RemoveUnit ( i ) ;
15075: LD_VAR 0 1
15079: PPUSH
15080: CALL_OW 64
// end ;
15084: GO 15003
15086: POP
15087: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15088: LD_INT 22
15090: PUSH
15091: LD_INT 3
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: PUSH
15098: LD_INT 2
15100: PUSH
15101: LD_INT 21
15103: PUSH
15104: LD_INT 1
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PUSH
15111: LD_INT 33
15113: PUSH
15114: LD_INT 1
15116: PUSH
15117: EMPTY
15118: LIST
15119: LIST
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: PUSH
15126: EMPTY
15127: LIST
15128: LIST
15129: PPUSH
15130: CALL_OW 69
15134: NOT
15135: IFFALSE 14986
// end ;
15137: PPOPN 3
15139: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15140: LD_INT 22
15142: PUSH
15143: LD_INT 8
15145: PUSH
15146: EMPTY
15147: LIST
15148: LIST
15149: PUSH
15150: LD_INT 21
15152: PUSH
15153: LD_INT 1
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 23
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PPUSH
15175: CALL_OW 69
15179: PUSH
15180: LD_INT 18
15182: LESS
15183: PUSH
15184: LD_EXP 55
15188: PPUSH
15189: CALL_OW 301
15193: OR
15194: PUSH
15195: LD_INT 324
15197: PPUSH
15198: CALL_OW 255
15202: PUSH
15203: LD_INT 7
15205: EQUAL
15206: OR
15207: IFFALSE 15220
15209: GO 15211
15211: DISABLE
// legionDestroyed := true ;
15212: LD_ADDR_EXP 3
15216: PUSH
15217: LD_INT 1
15219: ST_TO_ADDR
15220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15221: LD_INT 22
15223: PUSH
15224: LD_INT 2
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: PUSH
15231: LD_INT 21
15233: PUSH
15234: LD_INT 1
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PUSH
15241: LD_INT 23
15243: PUSH
15244: LD_INT 2
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: PPUSH
15256: CALL_OW 69
15260: PUSH
15261: LD_INT 9
15263: LESS
15264: IFFALSE 15277
15266: GO 15268
15268: DISABLE
// arabianDestroyed := true ;
15269: LD_ADDR_EXP 5
15273: PUSH
15274: LD_INT 1
15276: ST_TO_ADDR
15277: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15278: LD_EXP 5
15282: IFFALSE 15526
15284: GO 15286
15286: DISABLE
15287: LD_INT 0
15289: PPUSH
15290: PPUSH
// begin MC_Kill ( 1 ) ;
15291: LD_INT 1
15293: PPUSH
15294: CALL 21104 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15298: LD_ADDR_VAR 0 2
15302: PUSH
15303: LD_INT 22
15305: PUSH
15306: LD_INT 2
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: PUSH
15313: LD_INT 21
15315: PUSH
15316: LD_INT 1
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL_OW 69
15331: PUSH
15332: LD_INT 22
15334: PUSH
15335: LD_INT 8
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PUSH
15342: LD_INT 21
15344: PUSH
15345: LD_INT 2
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: LD_INT 1
15354: PUSH
15355: EMPTY
15356: LIST
15357: PUSH
15358: EMPTY
15359: LIST
15360: LIST
15361: LIST
15362: PPUSH
15363: CALL_OW 69
15367: ADD
15368: ST_TO_ADDR
// if tmp then
15369: LD_VAR 0 2
15373: IFFALSE 15526
// repeat wait ( 0 0$1 ) ;
15375: LD_INT 35
15377: PPUSH
15378: CALL_OW 67
// for i in tmp do
15382: LD_ADDR_VAR 0 1
15386: PUSH
15387: LD_VAR 0 2
15391: PUSH
15392: FOR_IN
15393: IFFALSE 15475
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15395: LD_VAR 0 1
15399: PPUSH
15400: CALL_OW 310
15404: PUSH
15405: LD_VAR 0 1
15409: PPUSH
15410: CALL_OW 310
15414: PPUSH
15415: CALL_OW 247
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15435
// ComExitBuilding ( i ) ;
15426: LD_VAR 0 1
15430: PPUSH
15431: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_INT 254
15442: PPUSH
15443: LD_INT 268
15445: PPUSH
15446: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15450: LD_VAR 0 1
15454: PPUSH
15455: LD_INT 34
15457: PPUSH
15458: CALL_OW 308
15462: IFFALSE 15473
// RemoveUnit ( i ) ;
15464: LD_VAR 0 1
15468: PPUSH
15469: CALL_OW 64
// end ;
15473: GO 15392
15475: POP
15476: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15477: LD_INT 22
15479: PUSH
15480: LD_INT 2
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: PUSH
15487: LD_INT 2
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 33
15502: PUSH
15503: LD_INT 1
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PPUSH
15519: CALL_OW 69
15523: NOT
15524: IFFALSE 15375
// end ;
15526: PPOPN 2
15528: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15529: LD_EXP 3
15533: IFFALSE 15885
15535: GO 15537
15537: DISABLE
15538: LD_INT 0
15540: PPUSH
15541: PPUSH
// begin MC_Kill ( 3 ) ;
15542: LD_INT 3
15544: PPUSH
15545: CALL 21104 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15549: LD_INT 8
15551: PPUSH
15552: LD_INT 7
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 1
15560: PPUSH
15561: CALL_OW 80
// DialogueOn ;
15565: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15569: LD_EXP 54
15573: PPUSH
15574: LD_STRING D15-Szulc-1
15576: PPUSH
15577: CALL_OW 94
// DialogueOff ;
15581: CALL_OW 7
// legionCapitulated := true ;
15585: LD_ADDR_EXP 8
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15593: LD_ADDR_VAR 0 1
15597: PUSH
15598: LD_INT 22
15600: PUSH
15601: LD_INT 8
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PUSH
15608: LD_INT 21
15610: PUSH
15611: LD_INT 3
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: LD_INT 23
15620: PUSH
15621: LD_INT 3
15623: PUSH
15624: EMPTY
15625: LIST
15626: LIST
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: PPUSH
15633: CALL_OW 69
15637: PUSH
15638: FOR_IN
15639: IFFALSE 15655
// SetLives ( i , 3 ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: LD_INT 3
15648: PPUSH
15649: CALL_OW 234
15653: GO 15638
15655: POP
15656: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15657: LD_ADDR_VAR 0 2
15661: PUSH
15662: LD_INT 22
15664: PUSH
15665: LD_INT 8
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: PUSH
15672: LD_INT 21
15674: PUSH
15675: LD_INT 1
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: PUSH
15682: EMPTY
15683: LIST
15684: LIST
15685: PPUSH
15686: CALL_OW 69
15690: PUSH
15691: LD_INT 22
15693: PUSH
15694: LD_INT 8
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 21
15703: PUSH
15704: LD_INT 2
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PUSH
15711: LD_INT 1
15713: PUSH
15714: EMPTY
15715: LIST
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: PPUSH
15722: CALL_OW 69
15726: ADD
15727: ST_TO_ADDR
// if tmp then
15728: LD_VAR 0 2
15732: IFFALSE 15885
// repeat wait ( 0 0$1 ) ;
15734: LD_INT 35
15736: PPUSH
15737: CALL_OW 67
// for i in tmp do
15741: LD_ADDR_VAR 0 1
15745: PUSH
15746: LD_VAR 0 2
15750: PUSH
15751: FOR_IN
15752: IFFALSE 15834
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15754: LD_VAR 0 1
15758: PPUSH
15759: CALL_OW 310
15763: PUSH
15764: LD_VAR 0 1
15768: PPUSH
15769: CALL_OW 310
15773: PPUSH
15774: CALL_OW 247
15778: PUSH
15779: LD_INT 3
15781: EQUAL
15782: AND
15783: IFFALSE 15794
// ComExitBuilding ( i ) ;
15785: LD_VAR 0 1
15789: PPUSH
15790: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15794: LD_VAR 0 1
15798: PPUSH
15799: LD_INT 10
15801: PPUSH
15802: LD_INT 1
15804: PPUSH
15805: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15809: LD_VAR 0 1
15813: PPUSH
15814: LD_INT 32
15816: PPUSH
15817: CALL_OW 308
15821: IFFALSE 15832
// RemoveUnit ( i ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: CALL_OW 64
// end ;
15832: GO 15751
15834: POP
15835: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15836: LD_INT 22
15838: PUSH
15839: LD_INT 8
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: PUSH
15846: LD_INT 2
15848: PUSH
15849: LD_INT 21
15851: PUSH
15852: LD_INT 1
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PUSH
15859: LD_INT 33
15861: PUSH
15862: LD_INT 1
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: LIST
15873: PUSH
15874: EMPTY
15875: LIST
15876: LIST
15877: PPUSH
15878: CALL_OW 69
15882: NOT
15883: IFFALSE 15734
// end ;
15885: PPOPN 2
15887: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15888: LD_EXP 4
15892: PUSH
15893: LD_EXP 2
15897: AND
15898: PUSH
15899: LD_EXP 3
15903: AND
15904: PUSH
15905: LD_EXP 5
15909: AND
15910: PUSH
15911: LD_EXP 6
15915: AND
15916: PUSH
15917: LD_EXP 7
15921: AND
15922: PUSH
15923: LD_EXP 8
15927: AND
15928: PUSH
15929: LD_EXP 53
15933: PPUSH
15934: CALL_OW 255
15938: PUSH
15939: LD_INT 5
15941: NONEQUAL
15942: PUSH
15943: LD_EXP 53
15947: PPUSH
15948: CALL_OW 301
15952: OR
15953: PUSH
15954: LD_EXP 53
15958: PPUSH
15959: CALL_OW 305
15963: NOT
15964: OR
15965: AND
15966: IFFALSE 17357
15968: GO 15970
15970: DISABLE
15971: LD_INT 0
15973: PPUSH
15974: PPUSH
// begin wait ( 0 0$5 ) ;
15975: LD_INT 175
15977: PPUSH
15978: CALL_OW 67
// music_class := 5 ;
15982: LD_ADDR_OWVAR 72
15986: PUSH
15987: LD_INT 5
15989: ST_TO_ADDR
// music_nat := 5 ;
15990: LD_ADDR_OWVAR 71
15994: PUSH
15995: LD_INT 5
15997: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15998: LD_EXP 15
16002: PUSH
16003: LD_INT 3
16005: LESS
16006: IFFALSE 16015
// SetAchievement ( ACH_ECONOMY ) ;
16008: LD_STRING ACH_ECONOMY
16010: PPUSH
16011: CALL_OW 543
// if tick < 60 60$00 then
16015: LD_OWVAR 1
16019: PUSH
16020: LD_INT 126000
16022: LESS
16023: IFFALSE 16039
// begin wait ( 3 ) ;
16025: LD_INT 3
16027: PPUSH
16028: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16032: LD_STRING ACH_ASPEED_19
16034: PPUSH
16035: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16039: LD_EXP 17
16043: PPUSH
16044: CALL_OW 87
// InGameOn ;
16048: CALL_OW 8
// DialogueOn ;
16052: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16056: LD_EXP 17
16060: PPUSH
16061: LD_STRING DEnd-JMM-JMM-1
16063: PPUSH
16064: CALL_OW 88
// if Joan then
16068: LD_EXP 32
16072: IFFALSE 16088
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16074: LD_EXP 32
16078: PPUSH
16079: LD_STRING DEnd-JMM-Joan-1
16081: PPUSH
16082: CALL_OW 88
16086: GO 16132
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16088: LD_EXP 19
16092: PUSH
16093: LD_EXP 19
16097: PPUSH
16098: CALL_OW 255
16102: PUSH
16103: LD_INT 7
16105: EQUAL
16106: AND
16107: PUSH
16108: LD_EXP 19
16112: PPUSH
16113: CALL_OW 305
16117: AND
16118: IFFALSE 16132
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16120: LD_EXP 19
16124: PPUSH
16125: LD_STRING DEnd-JMM-Lisa-1
16127: PPUSH
16128: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16132: LD_EXP 29
16136: PUSH
16137: LD_EXP 29
16141: PPUSH
16142: CALL_OW 305
16146: AND
16147: IFFALSE 16161
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16149: LD_EXP 29
16153: PPUSH
16154: LD_STRING DEnd-JMM-Frank-1
16156: PPUSH
16157: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16161: LD_EXP 22
16165: PUSH
16166: LD_EXP 22
16170: PPUSH
16171: CALL_OW 255
16175: PUSH
16176: LD_INT 7
16178: EQUAL
16179: AND
16180: PUSH
16181: LD_EXP 22
16185: PPUSH
16186: CALL_OW 305
16190: AND
16191: IFFALSE 16205
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16193: LD_EXP 22
16197: PPUSH
16198: LD_STRING DEnd-JMM-Cyrus-1
16200: PPUSH
16201: CALL_OW 88
// if Burlak then
16205: LD_EXP 49
16209: IFFALSE 16223
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16211: LD_EXP 49
16215: PPUSH
16216: LD_STRING DEnd-JMM-Bur-1
16218: PPUSH
16219: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16223: LD_EXP 32
16227: PUSH
16228: LD_EXP 19
16232: AND
16233: PUSH
16234: LD_EXP 19
16238: PPUSH
16239: CALL_OW 255
16243: PUSH
16244: LD_INT 7
16246: EQUAL
16247: AND
16248: PUSH
16249: LD_EXP 19
16253: PPUSH
16254: CALL_OW 305
16258: AND
16259: IFFALSE 16273
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16261: LD_EXP 19
16265: PPUSH
16266: LD_STRING DEnd-Burlak-Lisa-1
16268: PPUSH
16269: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16273: LD_EXP 50
16277: PUSH
16278: LD_EXP 50
16282: PPUSH
16283: CALL_OW 305
16287: AND
16288: IFFALSE 16302
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16290: LD_EXP 50
16294: PPUSH
16295: LD_STRING DEnd-JMM-Bel-1
16297: PPUSH
16298: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16302: LD_EXP 51
16306: PUSH
16307: LD_EXP 51
16311: PPUSH
16312: CALL_OW 305
16316: AND
16317: IFFALSE 16331
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16319: LD_EXP 51
16323: PPUSH
16324: LD_STRING DEnd-JMM-Gny-1
16326: PPUSH
16327: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16331: LD_EXP 27
16335: PUSH
16336: LD_EXP 27
16340: PPUSH
16341: CALL_OW 255
16345: PUSH
16346: LD_INT 7
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_EXP 27
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16363: LD_EXP 27
16367: PPUSH
16368: LD_STRING DEnd-JMM-Corn-1
16370: PPUSH
16371: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16375: LD_EXP 20
16379: PUSH
16380: LD_EXP 20
16384: PPUSH
16385: CALL_OW 255
16389: PUSH
16390: LD_INT 7
16392: EQUAL
16393: AND
16394: PUSH
16395: LD_EXP 20
16399: PPUSH
16400: CALL_OW 305
16404: AND
16405: IFFALSE 16419
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16407: LD_EXP 20
16411: PPUSH
16412: LD_STRING DEnd-JMM-Don-1
16414: PPUSH
16415: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16419: LD_EXP 21
16423: PUSH
16424: LD_EXP 21
16428: PPUSH
16429: CALL_OW 255
16433: PUSH
16434: LD_INT 7
16436: EQUAL
16437: AND
16438: PUSH
16439: LD_EXP 21
16443: PPUSH
16444: CALL_OW 305
16448: AND
16449: IFFALSE 16463
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16451: LD_EXP 21
16455: PPUSH
16456: LD_STRING DEnd-JMM-Bobby-1
16458: PPUSH
16459: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16463: LD_EXP 23
16467: PUSH
16468: LD_EXP 23
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: AND
16482: PUSH
16483: LD_EXP 23
16487: PPUSH
16488: CALL_OW 305
16492: AND
16493: IFFALSE 16507
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16495: LD_EXP 23
16499: PPUSH
16500: LD_STRING DEnd-JMM-Den-1
16502: PPUSH
16503: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16507: LD_EXP 25
16511: PUSH
16512: LD_EXP 25
16516: PPUSH
16517: CALL_OW 255
16521: PUSH
16522: LD_INT 7
16524: EQUAL
16525: AND
16526: PUSH
16527: LD_EXP 25
16531: PPUSH
16532: CALL_OW 305
16536: AND
16537: IFFALSE 16551
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16539: LD_EXP 25
16543: PPUSH
16544: LD_STRING DEnd-JMM-Glad-1
16546: PPUSH
16547: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16551: LD_EXP 30
16555: PUSH
16556: LD_EXP 30
16560: PPUSH
16561: CALL_OW 255
16565: PUSH
16566: LD_INT 7
16568: EQUAL
16569: AND
16570: PUSH
16571: LD_EXP 30
16575: PPUSH
16576: CALL_OW 305
16580: AND
16581: IFFALSE 16595
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16583: LD_EXP 30
16587: PPUSH
16588: LD_STRING DEnd-JMM-Yam-1
16590: PPUSH
16591: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16595: LD_EXP 24
16599: PUSH
16600: LD_EXP 24
16604: PPUSH
16605: CALL_OW 255
16609: PUSH
16610: LD_INT 7
16612: EQUAL
16613: AND
16614: PUSH
16615: LD_EXP 24
16619: PPUSH
16620: CALL_OW 305
16624: AND
16625: IFFALSE 16639
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16627: LD_EXP 24
16631: PPUSH
16632: LD_STRING DEnd-JMM-Brown-1
16634: PPUSH
16635: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16639: LD_EXP 34
16643: PUSH
16644: LD_EXP 34
16648: PPUSH
16649: CALL_OW 255
16653: PUSH
16654: LD_INT 7
16656: EQUAL
16657: AND
16658: PUSH
16659: LD_EXP 34
16663: PPUSH
16664: CALL_OW 305
16668: AND
16669: IFFALSE 16683
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16671: LD_EXP 34
16675: PPUSH
16676: LD_STRING DEnd-JMM-Con-1
16678: PPUSH
16679: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16683: LD_EXP 28
16687: PUSH
16688: LD_EXP 28
16692: PPUSH
16693: CALL_OW 255
16697: PUSH
16698: LD_INT 7
16700: EQUAL
16701: AND
16702: PUSH
16703: LD_EXP 28
16707: PPUSH
16708: CALL_OW 305
16712: AND
16713: IFFALSE 16727
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16715: LD_EXP 28
16719: PPUSH
16720: LD_STRING DEnd-JMM-Gary-1
16722: PPUSH
16723: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16727: LD_EXP 31
16731: PUSH
16732: LD_EXP 18
16736: AND
16737: PUSH
16738: LD_EXP 31
16742: PPUSH
16743: CALL_OW 305
16747: AND
16748: IFFALSE 16762
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16750: LD_EXP 31
16754: PPUSH
16755: LD_STRING DEnd-JMM-Sim-1
16757: PPUSH
16758: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16762: LD_EXP 26
16766: PUSH
16767: LD_EXP 26
16771: PPUSH
16772: CALL_OW 255
16776: PUSH
16777: LD_INT 7
16779: EQUAL
16780: AND
16781: PUSH
16782: LD_EXP 26
16786: PPUSH
16787: CALL_OW 305
16791: AND
16792: IFFALSE 16806
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16794: LD_EXP 26
16798: PPUSH
16799: LD_STRING DEnd-JMM-VanH-1
16801: PPUSH
16802: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16806: LD_EXP 39
16810: PUSH
16811: LD_EXP 39
16815: PPUSH
16816: CALL_OW 305
16820: AND
16821: IFFALSE 16835
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16823: LD_EXP 39
16827: PPUSH
16828: LD_STRING DEnd-JMM-Dol-1
16830: PPUSH
16831: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16835: LD_EXP 43
16839: PUSH
16840: LD_EXP 43
16844: PPUSH
16845: CALL_OW 305
16849: AND
16850: IFFALSE 16864
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16852: LD_EXP 43
16856: PPUSH
16857: LD_STRING DEnd-JMM-Kap-1
16859: PPUSH
16860: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16864: LD_EXP 46
16868: PUSH
16869: LD_EXP 46
16873: PPUSH
16874: CALL_OW 305
16878: AND
16879: IFFALSE 16893
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16881: LD_EXP 46
16885: PPUSH
16886: LD_STRING DEnd-JMM-Kov-1
16888: PPUSH
16889: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16893: LD_EXP 41
16897: PUSH
16898: LD_EXP 41
16902: PPUSH
16903: CALL_OW 305
16907: AND
16908: IFFALSE 16922
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16910: LD_EXP 41
16914: PPUSH
16915: LD_STRING DEnd-JMM-Sch-1
16917: PPUSH
16918: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16922: LD_EXP 37
16926: PUSH
16927: LD_EXP 37
16931: PPUSH
16932: CALL_OW 305
16936: AND
16937: IFFALSE 16951
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16939: LD_EXP 37
16943: PPUSH
16944: LD_STRING DEnd-JMM-Tit-1
16946: PPUSH
16947: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16951: LD_EXP 42
16955: PUSH
16956: LD_EXP 42
16960: PPUSH
16961: CALL_OW 305
16965: AND
16966: IFFALSE 16980
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16968: LD_EXP 42
16972: PPUSH
16973: LD_STRING DEnd-JMM-Obl-1
16975: PPUSH
16976: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16980: LD_EXP 44
16984: PUSH
16985: LD_EXP 44
16989: PPUSH
16990: CALL_OW 305
16994: AND
16995: IFFALSE 17009
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16997: LD_EXP 44
17001: PPUSH
17002: LD_STRING DEnd-JMM-Lip-1
17004: PPUSH
17005: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17009: LD_EXP 38
17013: PUSH
17014: LD_EXP 38
17018: PPUSH
17019: CALL_OW 305
17023: AND
17024: PUSH
17025: LD_EXP 49
17029: AND
17030: IFFALSE 17044
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17032: LD_EXP 38
17036: PPUSH
17037: LD_STRING DEnd-Burlak-Fad-1
17039: PPUSH
17040: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17044: LD_EXP 45
17048: PUSH
17049: LD_EXP 45
17053: PPUSH
17054: CALL_OW 305
17058: AND
17059: IFFALSE 17073
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17061: LD_EXP 45
17065: PPUSH
17066: LD_STRING DEnd-Burlak-Ptr-1
17068: PPUSH
17069: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17073: LD_EXP 47
17077: PUSH
17078: LD_EXP 47
17082: PPUSH
17083: CALL_OW 305
17087: AND
17088: IFFALSE 17102
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17090: LD_EXP 47
17094: PPUSH
17095: LD_STRING DEnd-Burlak-Kuz-1
17097: PPUSH
17098: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17102: LD_EXP 36
17106: PUSH
17107: LD_EXP 36
17111: PPUSH
17112: CALL_OW 305
17116: AND
17117: PUSH
17118: LD_EXP 49
17122: AND
17123: IFFALSE 17137
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17125: LD_EXP 36
17129: PPUSH
17130: LD_STRING DEnd-Burlak-Kir-1
17132: PPUSH
17133: CALL_OW 88
// if Burlak then
17137: LD_EXP 49
17141: IFFALSE 17155
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17143: LD_EXP 17
17147: PPUSH
17148: LD_STRING DEnd-Burlak-JMM-1
17150: PPUSH
17151: CALL_OW 88
// dwait ( 0 0$2 ) ;
17155: LD_INT 70
17157: PPUSH
17158: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17162: LD_EXP 54
17166: PPUSH
17167: LD_STRING DEnd-Szulc
17169: PPUSH
17170: CALL_OW 94
// dwait ( 0 0$1 ) ;
17174: LD_INT 35
17176: PPUSH
17177: CALL_OW 68
// if IsLive ( Burlak ) then
17181: LD_EXP 49
17185: PPUSH
17186: CALL_OW 300
17190: IFFALSE 17202
// med1 := 1 else
17192: LD_ADDR_VAR 0 1
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
17200: GO 17211
// med1 := - 1 ;
17202: LD_ADDR_VAR 0 1
17206: PUSH
17207: LD_INT 1
17209: NEG
17210: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17211: LD_EXP 12
17215: PUSH
17216: LD_EXP 13
17220: AND
17221: PUSH
17222: LD_EXP 14
17226: AND
17227: IFFALSE 17239
// med2 := 1 else
17229: LD_ADDR_VAR 0 2
17233: PUSH
17234: LD_INT 1
17236: ST_TO_ADDR
17237: GO 17248
// med2 := - 1 ;
17239: LD_ADDR_VAR 0 2
17243: PUSH
17244: LD_INT 1
17246: NEG
17247: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17248: LD_STRING Hero
17250: PPUSH
17251: LD_INT 1
17253: PPUSH
17254: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17258: LD_STRING Artefact
17260: PPUSH
17261: LD_VAR 0 2
17265: PPUSH
17266: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17270: LD_STRING ReconcileBurlak
17272: PPUSH
17273: LD_VAR 0 1
17277: PPUSH
17278: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17282: LD_OWVAR 67
17286: PUSH
17287: LD_INT 3
17289: GREATEREQUAL
17290: PUSH
17291: LD_VAR 0 1
17295: PUSH
17296: LD_INT 1
17298: EQUAL
17299: AND
17300: PUSH
17301: LD_VAR 0 2
17305: PUSH
17306: LD_INT 1
17308: EQUAL
17309: AND
17310: IFFALSE 17322
// SetAchievementEX ( ACH_AMER , 19 ) ;
17312: LD_STRING ACH_AMER
17314: PPUSH
17315: LD_INT 19
17317: PPUSH
17318: CALL_OW 564
// GiveMedals ( MAIN ) ;
17322: LD_STRING MAIN
17324: PPUSH
17325: CALL_OW 102
// InGameOff ;
17329: CALL_OW 9
// DialogueOff ;
17333: CALL_OW 7
// music_nat := 1 ;
17337: LD_ADDR_OWVAR 71
17341: PUSH
17342: LD_INT 1
17344: ST_TO_ADDR
// music_class := 4 ;
17345: LD_ADDR_OWVAR 72
17349: PUSH
17350: LD_INT 4
17352: ST_TO_ADDR
// YouWin ;
17353: CALL_OW 103
// end ; end_of_file
17357: PPOPN 2
17359: END
// export function InitNature ; begin
17360: LD_INT 0
17362: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17363: LD_INT 3
17365: PPUSH
17366: LD_INT 3
17368: PPUSH
17369: LD_INT 2
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 1
17377: PPUSH
17378: LD_INT 0
17380: PPUSH
17381: LD_INT 0
17383: PPUSH
17384: LD_INT 17
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: CALL 84704 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17394: LD_INT 2
17396: PPUSH
17397: LD_INT 1
17399: PPUSH
17400: LD_INT 1
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 18
17417: PPUSH
17418: LD_INT 0
17420: PPUSH
17421: CALL 84704 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17425: LD_INT 4
17427: PPUSH
17428: LD_INT 1
17430: PPUSH
17431: LD_INT 2
17433: PPUSH
17434: LD_INT 4
17436: PPUSH
17437: LD_INT 2
17439: PPUSH
17440: LD_INT 1
17442: PPUSH
17443: LD_INT 0
17445: PPUSH
17446: LD_INT 19
17448: PPUSH
17449: LD_INT 0
17451: PPUSH
17452: CALL 84704 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17456: LD_INT 0
17458: PPUSH
17459: LD_INT 0
17461: PPUSH
17462: LD_INT 0
17464: PPUSH
17465: LD_INT 0
17467: PPUSH
17468: LD_INT 0
17470: PPUSH
17471: LD_INT 0
17473: PPUSH
17474: LD_INT 9
17476: PPUSH
17477: LD_INT 0
17479: PPUSH
17480: LD_INT 20
17482: PPUSH
17483: CALL 84704 0 9
// end ; end_of_file
17487: LD_VAR 0 1
17491: RET
// every 0 0$30 do var time ;
17492: GO 17494
17494: DISABLE
17495: LD_INT 0
17497: PPUSH
// begin time := 0 0$30 ;
17498: LD_ADDR_VAR 0 1
17502: PUSH
17503: LD_INT 1050
17505: ST_TO_ADDR
// repeat wait ( time ) ;
17506: LD_VAR 0 1
17510: PPUSH
17511: CALL_OW 67
// if Prob ( 50 ) then
17515: LD_INT 50
17517: PPUSH
17518: CALL_OW 13
17522: IFFALSE 17551
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17524: LD_INT 1
17526: PPUSH
17527: LD_INT 5
17529: PPUSH
17530: CALL_OW 12
17534: PPUSH
17535: LD_INT 106
17537: PPUSH
17538: LD_INT 89
17540: PPUSH
17541: LD_INT 45
17543: PPUSH
17544: LD_INT 1
17546: PPUSH
17547: CALL_OW 56
// time := time + 0 0$3 ;
17551: LD_ADDR_VAR 0 1
17555: PUSH
17556: LD_VAR 0 1
17560: PUSH
17561: LD_INT 105
17563: PLUS
17564: ST_TO_ADDR
// if Prob ( 30 ) then
17565: LD_INT 30
17567: PPUSH
17568: CALL_OW 13
17572: IFFALSE 17618
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17574: LD_INT 525
17576: PPUSH
17577: LD_INT 735
17579: PPUSH
17580: CALL_OW 12
17584: PPUSH
17585: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17589: LD_INT 1
17591: PPUSH
17592: LD_INT 5
17594: PPUSH
17595: CALL_OW 12
17599: PPUSH
17600: LD_INT 21
17602: PPUSH
17603: LD_INT 26
17605: PPUSH
17606: LD_INT 12
17608: PPUSH
17609: LD_INT 1
17611: PPUSH
17612: CALL_OW 56
// end else
17616: GO 17654
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17618: LD_INT 700
17620: PPUSH
17621: LD_INT 1225
17623: PPUSH
17624: CALL_OW 12
17628: PPUSH
17629: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17633: LD_INT 1
17635: PPUSH
17636: LD_INT 5
17638: PPUSH
17639: CALL_OW 12
17643: PPUSH
17644: LD_INT 14
17646: PPUSH
17647: LD_INT 1
17649: PPUSH
17650: CALL_OW 55
// end ; if Prob ( 50 ) then
17654: LD_INT 50
17656: PPUSH
17657: CALL_OW 13
17661: IFFALSE 17707
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17663: LD_INT 700
17665: PPUSH
17666: LD_INT 1050
17668: PPUSH
17669: CALL_OW 12
17673: PPUSH
17674: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17678: LD_INT 1
17680: PPUSH
17681: LD_INT 5
17683: PPUSH
17684: CALL_OW 12
17688: PPUSH
17689: LD_INT 181
17691: PPUSH
17692: LD_INT 218
17694: PPUSH
17695: LD_INT 16
17697: PPUSH
17698: LD_INT 1
17700: PPUSH
17701: CALL_OW 56
// end else
17705: GO 17779
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17707: LD_INT 350
17709: PPUSH
17710: LD_INT 525
17712: PPUSH
17713: CALL_OW 12
17717: PPUSH
17718: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17722: LD_INT 1
17724: PPUSH
17725: LD_INT 5
17727: PPUSH
17728: CALL_OW 12
17732: PPUSH
17733: LD_INT 13
17735: PPUSH
17736: LD_INT 1
17738: PPUSH
17739: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17743: LD_INT 350
17745: PPUSH
17746: LD_INT 700
17748: PPUSH
17749: CALL_OW 12
17753: PPUSH
17754: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17758: LD_INT 1
17760: PPUSH
17761: LD_INT 5
17763: PPUSH
17764: CALL_OW 12
17768: PPUSH
17769: LD_INT 33
17771: PPUSH
17772: LD_INT 1
17774: PPUSH
17775: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
17779: LD_INT 65
17781: PUSH
17782: LD_INT 62
17784: PUSH
17785: LD_INT 55
17787: PUSH
17788: LD_INT 50
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: PUSH
17797: LD_OWVAR 67
17801: ARRAY
17802: PPUSH
17803: CALL_OW 13
17807: IFFALSE 17853
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17809: LD_INT 525
17811: PPUSH
17812: LD_INT 875
17814: PPUSH
17815: CALL_OW 12
17819: PPUSH
17820: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17824: LD_INT 1
17826: PPUSH
17827: LD_INT 5
17829: PPUSH
17830: CALL_OW 12
17834: PPUSH
17835: LD_INT 294
17837: PPUSH
17838: LD_INT 211
17840: PPUSH
17841: LD_INT 30
17843: PPUSH
17844: LD_INT 1
17846: PPUSH
17847: CALL_OW 56
// end else
17851: GO 17895
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17853: LD_INT 420
17855: PPUSH
17856: LD_INT 770
17858: PPUSH
17859: CALL_OW 12
17863: PPUSH
17864: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17868: LD_INT 1
17870: PPUSH
17871: LD_INT 5
17873: PPUSH
17874: CALL_OW 12
17878: PPUSH
17879: LD_INT 294
17881: PPUSH
17882: LD_INT 211
17884: PPUSH
17885: LD_INT 30
17887: PPUSH
17888: LD_INT 1
17890: PPUSH
17891: CALL_OW 56
// end ; if time > 2 2$20 then
17895: LD_VAR 0 1
17899: PUSH
17900: LD_INT 4900
17902: GREATER
17903: IFFALSE 17913
// time := 0 0$50 ;
17905: LD_ADDR_VAR 0 1
17909: PUSH
17910: LD_INT 1750
17912: ST_TO_ADDR
// until false ;
17913: LD_INT 0
17915: IFFALSE 17506
// end ;
17917: PPOPN 1
17919: END
// every 0 0$45 trigger tick < 10 10$00 do
17920: LD_OWVAR 1
17924: PUSH
17925: LD_INT 21000
17927: LESS
17928: IFFALSE 17976
17930: GO 17932
17932: DISABLE
// begin enable ;
17933: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17934: LD_INT 350
17936: PPUSH
17937: LD_INT 700
17939: PPUSH
17940: CALL_OW 12
17944: PPUSH
17945: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17949: LD_INT 3
17951: PPUSH
17952: LD_INT 5
17954: PPUSH
17955: CALL_OW 12
17959: PPUSH
17960: LD_INT 181
17962: PPUSH
17963: LD_INT 13
17965: PPUSH
17966: LD_INT 20
17968: PPUSH
17969: LD_INT 1
17971: PPUSH
17972: CALL_OW 56
// end ; end_of_file
17976: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17977: LD_INT 0
17979: PPUSH
// SetArtifactRes ( 7 , true ) ;
17980: LD_INT 7
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17990: LD_ADDR_EXP 62
17994: PUSH
17995: EMPTY
17996: PUSH
17997: EMPTY
17998: PUSH
17999: EMPTY
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18006: LD_ADDR_EXP 63
18010: PUSH
18011: LD_INT 1050
18013: PUSH
18014: LD_OWVAR 67
18018: MUL
18019: PUSH
18020: LD_INT 2800
18022: PUSH
18023: LD_OWVAR 67
18027: MUL
18028: PUSH
18029: LD_INT 1
18031: NEG
18032: PUSH
18033: EMPTY
18034: LIST
18035: LIST
18036: LIST
18037: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18038: LD_ADDR_EXP 64
18042: PUSH
18043: LD_INT 10
18045: PUSH
18046: LD_INT 35
18048: PUSH
18049: LD_INT 100
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18057: LD_ADDR_EXP 65
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: LD_INT 0
18070: PUSH
18071: EMPTY
18072: LIST
18073: LIST
18074: LIST
18075: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18076: LD_ADDR_EXP 67
18080: PUSH
18081: LD_INT 300
18083: PUSH
18084: LD_INT 500
18086: PUSH
18087: LD_INT 800
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: LIST
18094: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18095: LD_ADDR_EXP 68
18099: PUSH
18100: LD_INT 0
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 0
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18114: LD_ADDR_EXP 69
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: LD_INT 0
18124: PUSH
18125: LD_INT 0
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: LIST
18132: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18133: LD_ADDR_EXP 66
18137: PUSH
18138: LD_INT 0
18140: PUSH
18141: LD_INT 0
18143: PUSH
18144: LD_INT 0
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: LIST
18151: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18152: LD_ADDR_EXP 70
18156: PUSH
18157: LD_INT 4
18159: PUSH
18160: LD_INT 3
18162: PUSH
18163: LD_INT 1
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: PUSH
18171: LD_INT 5
18173: PUSH
18174: LD_INT 4
18176: PUSH
18177: LD_INT 2
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: LIST
18184: PUSH
18185: LD_INT 6
18187: PUSH
18188: LD_INT 3
18190: PUSH
18191: LD_INT 3
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: LIST
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18204: LD_ADDR_EXP 71
18208: PUSH
18209: LD_INT 0
18211: PUSH
18212: LD_INT 0
18214: PUSH
18215: LD_INT 0
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: ST_TO_ADDR
// end ;
18223: LD_VAR 0 1
18227: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18228: LD_INT 24
18230: PPUSH
18231: LD_INT 7
18233: PPUSH
18234: CALL_OW 321
18238: PUSH
18239: LD_INT 2
18241: EQUAL
18242: IFFALSE 19168
18244: GO 18246
18246: DISABLE
18247: LD_INT 0
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
// begin enable ;
18254: ENABLE
// for i = 1 to 3 do
18255: LD_ADDR_VAR 0 1
18259: PUSH
18260: DOUBLE
18261: LD_INT 1
18263: DEC
18264: ST_TO_ADDR
18265: LD_INT 3
18267: PUSH
18268: FOR_TO
18269: IFFALSE 19166
// begin pos := FindArtifact ( i + 2 ) ;
18271: LD_ADDR_VAR 0 2
18275: PUSH
18276: LD_VAR 0 1
18280: PUSH
18281: LD_INT 2
18283: PLUS
18284: PPUSH
18285: CALL_OW 469
18289: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18290: LD_ADDR_EXP 62
18294: PUSH
18295: LD_EXP 62
18299: PPUSH
18300: LD_VAR 0 1
18304: PPUSH
18305: LD_VAR 0 2
18309: PPUSH
18310: CALL_OW 1
18314: ST_TO_ADDR
// if pos then
18315: LD_VAR 0 2
18319: IFFALSE 19027
// begin case i of 1 :
18321: LD_VAR 0 1
18325: PUSH
18326: LD_INT 1
18328: DOUBLE
18329: EQUAL
18330: IFTRUE 18334
18332: GO 18411
18334: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18335: LD_ADDR_VAR 0 4
18339: PUSH
18340: LD_INT 22
18342: PUSH
18343: LD_INT 7
18345: PUSH
18346: EMPTY
18347: LIST
18348: LIST
18349: PUSH
18350: LD_INT 23
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 2
18362: PUSH
18363: LD_INT 30
18365: PUSH
18366: LD_INT 8
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 30
18375: PUSH
18376: LD_INT 7
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: LD_INT 30
18385: PUSH
18386: LD_INT 11
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: PPUSH
18404: CALL_OW 69
18408: ST_TO_ADDR
18409: GO 18519
18411: LD_INT 2
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18496
18419: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18420: LD_ADDR_VAR 0 4
18424: PUSH
18425: LD_INT 22
18427: PUSH
18428: LD_INT 7
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: PUSH
18435: LD_INT 23
18437: PUSH
18438: LD_INT 3
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: PUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 30
18450: PUSH
18451: LD_INT 8
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 30
18460: PUSH
18461: LD_INT 7
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 30
18470: PUSH
18471: LD_INT 11
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: LIST
18488: PPUSH
18489: CALL_OW 69
18493: ST_TO_ADDR
18494: GO 18519
18496: LD_INT 3
18498: DOUBLE
18499: EQUAL
18500: IFTRUE 18504
18502: GO 18518
18504: POP
// labs := [ alien ] ; end ;
18505: LD_ADDR_VAR 0 4
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: ST_TO_ADDR
18516: GO 18519
18518: POP
// if not labs then
18519: LD_VAR 0 4
18523: NOT
18524: IFFALSE 18528
// continue ;
18526: GO 18268
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18528: LD_ADDR_VAR 0 5
18532: PUSH
18533: LD_VAR 0 4
18537: PPUSH
18538: LD_EXP 62
18542: PUSH
18543: LD_VAR 0 1
18547: ARRAY
18548: PUSH
18549: LD_INT 1
18551: ARRAY
18552: PPUSH
18553: LD_EXP 62
18557: PUSH
18558: LD_VAR 0 1
18562: ARRAY
18563: PUSH
18564: LD_INT 2
18566: ARRAY
18567: PPUSH
18568: CALL_OW 73
18572: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18573: LD_VAR 0 5
18577: NOT
18578: PUSH
18579: LD_VAR 0 5
18583: PUSH
18584: LD_EXP 69
18588: PUSH
18589: LD_VAR 0 1
18593: ARRAY
18594: NONEQUAL
18595: OR
18596: IFFALSE 18701
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18598: LD_INT 7
18600: PPUSH
18601: LD_EXP 70
18605: PUSH
18606: LD_VAR 0 1
18610: ARRAY
18611: PUSH
18612: LD_INT 3
18614: ARRAY
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: LD_EXP 69
18623: PUSH
18624: LD_VAR 0 1
18628: ARRAY
18629: PPUSH
18630: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18634: LD_INT 7
18636: PPUSH
18637: LD_EXP 70
18641: PUSH
18642: LD_VAR 0 1
18646: ARRAY
18647: PUSH
18648: LD_INT 1
18650: ARRAY
18651: PPUSH
18652: LD_INT 0
18654: PPUSH
18655: LD_EXP 69
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PPUSH
18666: CALL_OW 468
// if nearestLab then
18670: LD_VAR 0 5
18674: IFFALSE 18701
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18676: LD_ADDR_EXP 69
18680: PUSH
18681: LD_EXP 69
18685: PPUSH
18686: LD_VAR 0 1
18690: PPUSH
18691: LD_VAR 0 5
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// end ; if not nearestLab then
18701: LD_VAR 0 5
18705: NOT
18706: IFFALSE 18710
// continue ;
18708: GO 18268
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18710: LD_VAR 0 5
18714: PPUSH
18715: LD_EXP 62
18719: PUSH
18720: LD_VAR 0 1
18724: ARRAY
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PPUSH
18730: LD_EXP 62
18734: PUSH
18735: LD_VAR 0 1
18739: ARRAY
18740: PUSH
18741: LD_INT 2
18743: ARRAY
18744: PPUSH
18745: CALL_OW 297
18749: PUSH
18750: LD_INT 8
18752: LESS
18753: IFFALSE 18950
// begin if not artifactsResearched [ i ] then
18755: LD_EXP 65
18759: PUSH
18760: LD_VAR 0 1
18764: ARRAY
18765: NOT
18766: IFFALSE 18847
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18768: LD_VAR 0 5
18772: PPUSH
18773: CALL_OW 461
18777: PUSH
18778: LD_INT 2
18780: EQUAL
18781: IFFALSE 18815
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18783: LD_INT 7
18785: PPUSH
18786: LD_EXP 70
18790: PUSH
18791: LD_VAR 0 1
18795: ARRAY
18796: PUSH
18797: LD_INT 3
18799: ARRAY
18800: PPUSH
18801: LD_INT 2
18803: PPUSH
18804: LD_VAR 0 5
18808: PPUSH
18809: CALL_OW 468
18813: GO 18845
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18815: LD_INT 7
18817: PPUSH
18818: LD_EXP 70
18822: PUSH
18823: LD_VAR 0 1
18827: ARRAY
18828: PUSH
18829: LD_INT 3
18831: ARRAY
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: LD_VAR 0 5
18840: PPUSH
18841: CALL_OW 468
// end else
18845: GO 18948
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 461
18856: PUSH
18857: LD_INT 2
18859: EQUAL
18860: PUSH
18861: LD_EXP 71
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: AND
18872: IFFALSE 18918
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18874: LD_INT 7
18876: PPUSH
18877: LD_EXP 70
18881: PUSH
18882: LD_VAR 0 1
18886: ARRAY
18887: PUSH
18888: LD_INT 1
18890: ARRAY
18891: PPUSH
18892: LD_EXP 70
18896: PUSH
18897: LD_VAR 0 1
18901: ARRAY
18902: PUSH
18903: LD_INT 2
18905: ARRAY
18906: PPUSH
18907: LD_VAR 0 5
18911: PPUSH
18912: CALL_OW 468
18916: GO 18948
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18918: LD_INT 7
18920: PPUSH
18921: LD_EXP 70
18925: PUSH
18926: LD_VAR 0 1
18930: ARRAY
18931: PUSH
18932: LD_INT 1
18934: ARRAY
18935: PPUSH
18936: LD_INT 1
18938: PPUSH
18939: LD_VAR 0 5
18943: PPUSH
18944: CALL_OW 468
// end else
18948: GO 19025
// begin if not artifactsResearched [ i ] then
18950: LD_EXP 65
18954: PUSH
18955: LD_VAR 0 1
18959: ARRAY
18960: NOT
18961: IFFALSE 18995
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18963: LD_INT 7
18965: PPUSH
18966: LD_EXP 70
18970: PUSH
18971: LD_VAR 0 1
18975: ARRAY
18976: PUSH
18977: LD_INT 3
18979: ARRAY
18980: PPUSH
18981: LD_INT 0
18983: PPUSH
18984: LD_VAR 0 5
18988: PPUSH
18989: CALL_OW 468
18993: GO 19025
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18995: LD_INT 7
18997: PPUSH
18998: LD_EXP 70
19002: PUSH
19003: LD_VAR 0 1
19007: ARRAY
19008: PUSH
19009: LD_INT 1
19011: ARRAY
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: LD_VAR 0 5
19020: PPUSH
19021: CALL_OW 468
// end ; end else
19025: GO 19164
// begin if not artifactsLabs [ i ] then
19027: LD_EXP 69
19031: PUSH
19032: LD_VAR 0 1
19036: ARRAY
19037: NOT
19038: IFFALSE 19042
// continue ;
19040: GO 18268
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19042: LD_INT 7
19044: PPUSH
19045: LD_EXP 70
19049: PUSH
19050: LD_VAR 0 1
19054: ARRAY
19055: PUSH
19056: LD_INT 3
19058: ARRAY
19059: PPUSH
19060: LD_INT 0
19062: PPUSH
19063: LD_EXP 69
19067: PUSH
19068: LD_VAR 0 1
19072: ARRAY
19073: PPUSH
19074: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19078: LD_INT 7
19080: PPUSH
19081: LD_EXP 70
19085: PUSH
19086: LD_VAR 0 1
19090: ARRAY
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: PPUSH
19096: LD_INT 0
19098: PPUSH
19099: LD_EXP 69
19103: PUSH
19104: LD_VAR 0 1
19108: ARRAY
19109: PPUSH
19110: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19114: LD_EXP 66
19118: PUSH
19119: LD_VAR 0 1
19123: ARRAY
19124: IFFALSE 19164
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19126: LD_ADDR_EXP 66
19130: PUSH
19131: LD_EXP 66
19135: PPUSH
19136: LD_VAR 0 1
19140: PPUSH
19141: LD_INT 0
19143: PPUSH
19144: CALL_OW 1
19148: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19149: LD_EXP 69
19153: PUSH
19154: LD_VAR 0 1
19158: ARRAY
19159: PPUSH
19160: CALL_OW 127
// end ; end ; end ;
19164: GO 18268
19166: POP
19167: POP
// end ;
19168: PPOPN 5
19170: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19171: LD_INT 0
19173: PPUSH
19174: PPUSH
19175: PPUSH
19176: PPUSH
19177: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19178: LD_VAR 0 2
19182: PUSH
19183: LD_EXP 70
19187: PUSH
19188: LD_INT 1
19190: ARRAY
19191: PUSH
19192: LD_INT 3
19194: ARRAY
19195: EQUAL
19196: IFFALSE 19319
// begin lab := artifactsLabs [ 1 ] ;
19198: LD_ADDR_VAR 0 6
19202: PUSH
19203: LD_EXP 69
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: ST_TO_ADDR
// if not lab then
19212: LD_VAR 0 6
19216: NOT
19217: IFFALSE 19221
// exit ;
19219: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19221: LD_VAR 0 6
19225: PPUSH
19226: LD_EXP 67
19230: PUSH
19231: LD_INT 1
19233: ARRAY
19234: PPUSH
19235: LD_INT 1
19237: PPUSH
19238: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19242: LD_EXP 68
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: IFFALSE 19270
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19252: LD_VAR 0 6
19256: PPUSH
19257: LD_EXP 68
19261: PUSH
19262: LD_INT 1
19264: ARRAY
19265: PPUSH
19266: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19270: LD_ADDR_EXP 66
19274: PUSH
19275: LD_EXP 66
19279: PPUSH
19280: LD_INT 1
19282: PPUSH
19283: LD_INT 1
19285: PPUSH
19286: CALL_OW 1
19290: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19291: LD_INT 7
19293: PPUSH
19294: LD_EXP 70
19298: PUSH
19299: LD_INT 1
19301: ARRAY
19302: PUSH
19303: LD_INT 3
19305: ARRAY
19306: PPUSH
19307: LD_INT 0
19309: PPUSH
19310: LD_VAR 0 6
19314: PPUSH
19315: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19319: LD_VAR 0 2
19323: PUSH
19324: LD_EXP 70
19328: PUSH
19329: LD_INT 2
19331: ARRAY
19332: PUSH
19333: LD_INT 3
19335: ARRAY
19336: EQUAL
19337: IFFALSE 19460
// begin lab := artifactsLabs [ 2 ] ;
19339: LD_ADDR_VAR 0 6
19343: PUSH
19344: LD_EXP 69
19348: PUSH
19349: LD_INT 2
19351: ARRAY
19352: ST_TO_ADDR
// if not lab then
19353: LD_VAR 0 6
19357: NOT
19358: IFFALSE 19362
// exit ;
19360: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19362: LD_VAR 0 6
19366: PPUSH
19367: LD_EXP 67
19371: PUSH
19372: LD_INT 2
19374: ARRAY
19375: PPUSH
19376: LD_INT 1
19378: PPUSH
19379: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19383: LD_EXP 68
19387: PUSH
19388: LD_INT 2
19390: ARRAY
19391: IFFALSE 19411
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19393: LD_VAR 0 6
19397: PPUSH
19398: LD_EXP 68
19402: PUSH
19403: LD_INT 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19411: LD_ADDR_EXP 66
19415: PUSH
19416: LD_EXP 66
19420: PPUSH
19421: LD_INT 2
19423: PPUSH
19424: LD_INT 1
19426: PPUSH
19427: CALL_OW 1
19431: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19432: LD_INT 7
19434: PPUSH
19435: LD_EXP 70
19439: PUSH
19440: LD_INT 2
19442: ARRAY
19443: PUSH
19444: LD_INT 3
19446: ARRAY
19447: PPUSH
19448: LD_INT 0
19450: PPUSH
19451: LD_VAR 0 6
19455: PPUSH
19456: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19460: LD_VAR 0 2
19464: PUSH
19465: LD_EXP 70
19469: PUSH
19470: LD_INT 3
19472: ARRAY
19473: PUSH
19474: LD_INT 3
19476: ARRAY
19477: EQUAL
19478: IFFALSE 19601
// begin lab := artifactsLabs [ 3 ] ;
19480: LD_ADDR_VAR 0 6
19484: PUSH
19485: LD_EXP 69
19489: PUSH
19490: LD_INT 3
19492: ARRAY
19493: ST_TO_ADDR
// if not lab then
19494: LD_VAR 0 6
19498: NOT
19499: IFFALSE 19503
// exit ;
19501: GO 20299
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19503: LD_VAR 0 6
19507: PPUSH
19508: LD_EXP 67
19512: PUSH
19513: LD_INT 3
19515: ARRAY
19516: PPUSH
19517: LD_INT 1
19519: PPUSH
19520: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19524: LD_EXP 68
19528: PUSH
19529: LD_INT 3
19531: ARRAY
19532: IFFALSE 19552
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19534: LD_VAR 0 6
19538: PPUSH
19539: LD_EXP 68
19543: PUSH
19544: LD_INT 3
19546: ARRAY
19547: PPUSH
19548: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19552: LD_ADDR_EXP 66
19556: PUSH
19557: LD_EXP 66
19561: PPUSH
19562: LD_INT 3
19564: PPUSH
19565: LD_INT 1
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19573: LD_INT 7
19575: PPUSH
19576: LD_EXP 70
19580: PUSH
19581: LD_INT 3
19583: ARRAY
19584: PUSH
19585: LD_INT 3
19587: ARRAY
19588: PPUSH
19589: LD_INT 0
19591: PPUSH
19592: LD_VAR 0 6
19596: PPUSH
19597: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19601: LD_VAR 0 2
19605: PUSH
19606: LD_EXP 70
19610: PUSH
19611: LD_INT 1
19613: ARRAY
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: EQUAL
19619: IFFALSE 19777
// begin lab := artifactsLabs [ 1 ] ;
19621: LD_ADDR_VAR 0 6
19625: PUSH
19626: LD_EXP 69
19630: PUSH
19631: LD_INT 1
19633: ARRAY
19634: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19635: LD_VAR 0 6
19639: PPUSH
19640: CALL_OW 274
19644: PPUSH
19645: CALL 88308 0 1
19649: PUSH
19650: LD_INT 3
19652: ARRAY
19653: PUSH
19654: LD_EXP 64
19658: PUSH
19659: LD_INT 1
19661: ARRAY
19662: LESS
19663: IFFALSE 19677
// begin HintSpec ( ArtifactCost , 2 ) ;
19665: LD_STRING ArtifactCost
19667: PPUSH
19668: LD_INT 2
19670: PPUSH
19671: CALL_OW 338
// exit ;
19675: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19677: LD_ADDR_EXP 71
19681: PUSH
19682: LD_EXP 71
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 0
19692: PPUSH
19693: CALL_OW 1
19697: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19698: LD_VAR 0 3
19702: PPUSH
19703: LD_VAR 0 4
19707: PPUSH
19708: LD_INT 7
19710: PPUSH
19711: LD_INT 12
19713: NEG
19714: PPUSH
19715: CALL_OW 330
// wait ( 0 0$30 ) ;
19719: LD_INT 1050
19721: PPUSH
19722: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19726: LD_VAR 0 3
19730: PPUSH
19731: LD_VAR 0 4
19735: PPUSH
19736: LD_INT 7
19738: PPUSH
19739: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19743: LD_EXP 63
19747: PUSH
19748: LD_INT 1
19750: ARRAY
19751: PPUSH
19752: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19756: LD_ADDR_EXP 71
19760: PUSH
19761: LD_EXP 71
19765: PPUSH
19766: LD_INT 1
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19777: LD_VAR 0 2
19781: PUSH
19782: LD_EXP 70
19786: PUSH
19787: LD_INT 2
19789: ARRAY
19790: PUSH
19791: LD_INT 1
19793: ARRAY
19794: EQUAL
19795: IFFALSE 20032
// begin lab := artifactsLabs [ 2 ] ;
19797: LD_ADDR_VAR 0 6
19801: PUSH
19802: LD_EXP 69
19806: PUSH
19807: LD_INT 2
19809: ARRAY
19810: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19811: LD_VAR 0 3
19815: PUSH
19816: LD_INT 81
19818: PUSH
19819: LD_INT 7
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 32
19831: PUSH
19832: LD_INT 3
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 28
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 30
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: LD_INT 35
19861: PUSH
19862: LD_INT 49
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: LD_INT 34
19871: PUSH
19872: LD_INT 49
19874: PUSH
19875: EMPTY
19876: LIST
19877: LIST
19878: PUSH
19879: LD_INT 30
19881: PUSH
19882: LD_INT 21
19884: PUSH
19885: EMPTY
19886: LIST
19887: LIST
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: LIST
19894: LIST
19895: LIST
19896: LIST
19897: PUSH
19898: EMPTY
19899: LIST
19900: LIST
19901: PPUSH
19902: CALL_OW 69
19906: IN
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20299
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19912: LD_VAR 0 6
19916: PPUSH
19917: CALL_OW 274
19921: PPUSH
19922: CALL 88308 0 1
19926: PUSH
19927: LD_INT 3
19929: ARRAY
19930: PUSH
19931: LD_EXP 64
19935: PUSH
19936: LD_INT 2
19938: ARRAY
19939: LESS
19940: IFFALSE 19954
// begin HintSpec ( ArtifactCost , 2 ) ;
19942: LD_STRING ArtifactCost
19944: PPUSH
19945: LD_INT 2
19947: PPUSH
19948: CALL_OW 338
// exit ;
19952: GO 20299
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19954: LD_ADDR_EXP 71
19958: PUSH
19959: LD_EXP 71
19963: PPUSH
19964: LD_INT 2
19966: PPUSH
19967: LD_INT 0
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// KillUnit ( x ) ;
19975: LD_VAR 0 3
19979: PPUSH
19980: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19984: LD_ADDR_EXP 16
19988: PUSH
19989: LD_EXP 16
19993: PUSH
19994: LD_INT 1
19996: PLUS
19997: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19998: LD_EXP 63
20002: PUSH
20003: LD_INT 2
20005: ARRAY
20006: PPUSH
20007: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20011: LD_ADDR_EXP 71
20015: PUSH
20016: LD_EXP 71
20020: PPUSH
20021: LD_INT 2
20023: PPUSH
20024: LD_INT 1
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20032: LD_VAR 0 2
20036: PUSH
20037: LD_EXP 70
20041: PUSH
20042: LD_INT 3
20044: ARRAY
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: EQUAL
20050: IFFALSE 20299
// begin lab := artifactsLabs [ 3 ] ;
20052: LD_ADDR_VAR 0 6
20056: PUSH
20057: LD_EXP 69
20061: PUSH
20062: LD_INT 3
20064: ARRAY
20065: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20066: LD_VAR 0 6
20070: PPUSH
20071: CALL_OW 274
20075: PPUSH
20076: CALL 88308 0 1
20080: PUSH
20081: LD_INT 3
20083: ARRAY
20084: PUSH
20085: LD_EXP 64
20089: PUSH
20090: LD_INT 3
20092: ARRAY
20093: LESS
20094: IFFALSE 20108
// begin HintSpec ( ArtifactCost , 2 ) ;
20096: LD_STRING ArtifactCost
20098: PPUSH
20099: LD_INT 2
20101: PPUSH
20102: CALL_OW 338
// exit ;
20106: GO 20299
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20108: LD_INT 37
20110: PPUSH
20111: LD_INT 1
20113: PPUSH
20114: CALL_OW 424
// time := 0 0$30 ;
20118: LD_ADDR_VAR 0 7
20122: PUSH
20123: LD_INT 1050
20125: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20126: LD_ADDR_EXP 71
20130: PUSH
20131: LD_EXP 71
20135: PPUSH
20136: LD_INT 3
20138: PPUSH
20139: LD_INT 0
20141: PPUSH
20142: CALL_OW 1
20146: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20147: LD_ADDR_OWVAR 47
20151: PUSH
20152: LD_STRING #Am15a-1
20154: PUSH
20155: LD_VAR 0 7
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// time := time - 0 0$1 ;
20171: LD_ADDR_VAR 0 7
20175: PUSH
20176: LD_VAR 0 7
20180: PUSH
20181: LD_INT 35
20183: MINUS
20184: ST_TO_ADDR
// until time = 0 0$00 ;
20185: LD_VAR 0 7
20189: PUSH
20190: LD_INT 0
20192: EQUAL
20193: IFFALSE 20147
// display_strings :=  ;
20195: LD_ADDR_OWVAR 47
20199: PUSH
20200: LD_STRING 
20202: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20203: LD_INT 37
20205: PPUSH
20206: LD_INT 0
20208: PPUSH
20209: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20213: LD_ADDR_VAR 0 8
20217: PUSH
20218: LD_INT 37
20220: PPUSH
20221: LD_INT 3
20223: PUSH
20224: LD_INT 21
20226: PUSH
20227: LD_INT 3
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PPUSH
20238: CALL_OW 70
20242: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20243: LD_VAR 0 3
20247: PPUSH
20248: LD_VAR 0 4
20252: PPUSH
20253: CALL_OW 84
// for un in list do
20257: LD_ADDR_VAR 0 9
20261: PUSH
20262: LD_VAR 0 8
20266: PUSH
20267: FOR_IN
20268: IFFALSE 20297
// TeleportUnit ( un , x , y , 12 , true ) ;
20270: LD_VAR 0 9
20274: PPUSH
20275: LD_VAR 0 3
20279: PPUSH
20280: LD_VAR 0 4
20284: PPUSH
20285: LD_INT 12
20287: PPUSH
20288: LD_INT 1
20290: PPUSH
20291: CALL_OW 483
20295: GO 20267
20297: POP
20298: POP
// end ; end ;
20299: PPOPN 9
20301: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20302: LD_INT 0
20304: PPUSH
20305: PPUSH
// begin labNum := 0 ;
20306: LD_ADDR_VAR 0 4
20310: PUSH
20311: LD_INT 0
20313: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20314: LD_ADDR_VAR 0 3
20318: PUSH
20319: DOUBLE
20320: LD_INT 1
20322: DEC
20323: ST_TO_ADDR
20324: LD_EXP 69
20328: PUSH
20329: FOR_TO
20330: IFFALSE 20364
// if artifactsLabs [ i ] = lab then
20332: LD_EXP 69
20336: PUSH
20337: LD_VAR 0 3
20341: ARRAY
20342: PUSH
20343: LD_VAR 0 1
20347: EQUAL
20348: IFFALSE 20362
// begin labNum := i ;
20350: LD_ADDR_VAR 0 4
20354: PUSH
20355: LD_VAR 0 3
20359: ST_TO_ADDR
// break ;
20360: GO 20364
// end ;
20362: GO 20329
20364: POP
20365: POP
// if not labNum then
20366: LD_VAR 0 4
20370: NOT
20371: IFFALSE 20375
// exit ;
20373: GO 20453
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20375: LD_INT 7
20377: PPUSH
20378: LD_EXP 70
20382: PUSH
20383: LD_VAR 0 4
20387: ARRAY
20388: PUSH
20389: LD_INT 3
20391: ARRAY
20392: PPUSH
20393: LD_INT 2
20395: PPUSH
20396: LD_VAR 0 1
20400: PPUSH
20401: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20405: LD_ADDR_EXP 68
20409: PUSH
20410: LD_EXP 68
20414: PPUSH
20415: LD_VAR 0 4
20419: PPUSH
20420: LD_VAR 0 2
20424: PPUSH
20425: CALL_OW 1
20429: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20430: LD_ADDR_EXP 66
20434: PUSH
20435: LD_EXP 66
20439: PPUSH
20440: LD_VAR 0 4
20444: PPUSH
20445: LD_INT 0
20447: PPUSH
20448: CALL_OW 1
20452: ST_TO_ADDR
// end ;
20453: PPOPN 4
20455: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20456: LD_INT 0
20458: PPUSH
20459: PPUSH
// begin labNum := 0 ;
20460: LD_ADDR_VAR 0 3
20464: PUSH
20465: LD_INT 0
20467: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20468: LD_ADDR_VAR 0 2
20472: PUSH
20473: DOUBLE
20474: LD_INT 1
20476: DEC
20477: ST_TO_ADDR
20478: LD_EXP 69
20482: PUSH
20483: FOR_TO
20484: IFFALSE 20518
// if artifactsLabs [ i ] = lab then
20486: LD_EXP 69
20490: PUSH
20491: LD_VAR 0 2
20495: ARRAY
20496: PUSH
20497: LD_VAR 0 1
20501: EQUAL
20502: IFFALSE 20516
// begin labNum := i ;
20504: LD_ADDR_VAR 0 3
20508: PUSH
20509: LD_VAR 0 2
20513: ST_TO_ADDR
// break ;
20514: GO 20518
// end ;
20516: GO 20483
20518: POP
20519: POP
// if not labNum then
20520: LD_VAR 0 3
20524: NOT
20525: IFFALSE 20529
// exit ;
20527: GO 20691
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20529: LD_INT 7
20531: PPUSH
20532: LD_EXP 70
20536: PUSH
20537: LD_VAR 0 3
20541: ARRAY
20542: PUSH
20543: LD_INT 3
20545: ARRAY
20546: PPUSH
20547: LD_INT 0
20549: PPUSH
20550: LD_VAR 0 1
20554: PPUSH
20555: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20559: LD_ADDR_EXP 65
20563: PUSH
20564: LD_EXP 65
20568: PPUSH
20569: LD_VAR 0 3
20573: PPUSH
20574: LD_INT 1
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20582: LD_ADDR_EXP 71
20586: PUSH
20587: LD_EXP 71
20591: PPUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 1
20604: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20605: LD_ADDR_EXP 66
20609: PUSH
20610: LD_EXP 66
20614: PPUSH
20615: LD_VAR 0 3
20619: PPUSH
20620: LD_INT 0
20622: PPUSH
20623: CALL_OW 1
20627: ST_TO_ADDR
// case labNum of 1 :
20628: LD_VAR 0 3
20632: PUSH
20633: LD_INT 1
20635: DOUBLE
20636: EQUAL
20637: IFTRUE 20641
20639: GO 20652
20641: POP
// artifactIResearched := true ; 2 :
20642: LD_ADDR_EXP 12
20646: PUSH
20647: LD_INT 1
20649: ST_TO_ADDR
20650: GO 20691
20652: LD_INT 2
20654: DOUBLE
20655: EQUAL
20656: IFTRUE 20660
20658: GO 20671
20660: POP
// artifactIIResearched := true ; 3 :
20661: LD_ADDR_EXP 13
20665: PUSH
20666: LD_INT 1
20668: ST_TO_ADDR
20669: GO 20691
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20690
20679: POP
// artifactIIIResearched := true ; end ;
20680: LD_ADDR_EXP 14
20684: PUSH
20685: LD_INT 1
20687: ST_TO_ADDR
20688: GO 20691
20690: POP
// end ; end_of_file
20691: PPOPN 3
20693: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20694: LD_INT 0
20696: PPUSH
// ar_miner := 81 ;
20697: LD_ADDR_EXP 79
20701: PUSH
20702: LD_INT 81
20704: ST_TO_ADDR
// ar_crane := 88 ;
20705: LD_ADDR_EXP 78
20709: PUSH
20710: LD_INT 88
20712: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20713: LD_ADDR_EXP 73
20717: PUSH
20718: LD_INT 89
20720: ST_TO_ADDR
// us_hack := 99 ;
20721: LD_ADDR_EXP 74
20725: PUSH
20726: LD_INT 99
20728: ST_TO_ADDR
// us_artillery := 97 ;
20729: LD_ADDR_EXP 75
20733: PUSH
20734: LD_INT 97
20736: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20737: LD_ADDR_EXP 76
20741: PUSH
20742: LD_INT 91
20744: ST_TO_ADDR
// ar_mortar := 92 ;
20745: LD_ADDR_EXP 77
20749: PUSH
20750: LD_INT 92
20752: ST_TO_ADDR
// ru_radar := 98 ;
20753: LD_ADDR_EXP 72
20757: PUSH
20758: LD_INT 98
20760: ST_TO_ADDR
// tech_Artillery := 80 ;
20761: LD_ADDR_EXP 80
20765: PUSH
20766: LD_INT 80
20768: ST_TO_ADDR
// tech_RadMat := 81 ;
20769: LD_ADDR_EXP 81
20773: PUSH
20774: LD_INT 81
20776: ST_TO_ADDR
// tech_BasicTools := 82 ;
20777: LD_ADDR_EXP 82
20781: PUSH
20782: LD_INT 82
20784: ST_TO_ADDR
// tech_Cargo := 83 ;
20785: LD_ADDR_EXP 83
20789: PUSH
20790: LD_INT 83
20792: ST_TO_ADDR
// tech_Track := 84 ;
20793: LD_ADDR_EXP 84
20797: PUSH
20798: LD_INT 84
20800: ST_TO_ADDR
// tech_Crane := 85 ;
20801: LD_ADDR_EXP 85
20805: PUSH
20806: LD_INT 85
20808: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20809: LD_ADDR_EXP 86
20813: PUSH
20814: LD_INT 86
20816: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20817: LD_ADDR_EXP 87
20821: PUSH
20822: LD_INT 87
20824: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20825: LD_ADDR_EXP 88
20829: PUSH
20830: LD_INT 88
20832: ST_TO_ADDR
// class_mastodont := 31 ;
20833: LD_ADDR_EXP 89
20837: PUSH
20838: LD_INT 31
20840: ST_TO_ADDR
// class_horse := 21 ;
20841: LD_ADDR_EXP 90
20845: PUSH
20846: LD_INT 21
20848: ST_TO_ADDR
// end ;
20849: LD_VAR 0 1
20853: RET
// every 1 do
20854: GO 20856
20856: DISABLE
// InitGlobalVariables ; end_of_file
20857: CALL 20694 0 0
20861: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20862: LD_INT 0
20864: PPUSH
20865: PPUSH
// skirmish := false ;
20866: LD_ADDR_EXP 91
20870: PUSH
20871: LD_INT 0
20873: ST_TO_ADDR
// debug_mc := false ;
20874: LD_ADDR_EXP 92
20878: PUSH
20879: LD_INT 0
20881: ST_TO_ADDR
// mc_bases := [ ] ;
20882: LD_ADDR_EXP 93
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_sides := [ ] ;
20889: LD_ADDR_EXP 119
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20896: LD_ADDR_EXP 94
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20903: LD_ADDR_EXP 95
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_need_heal := [ ] ;
20910: LD_ADDR_EXP 96
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_healers := [ ] ;
20917: LD_ADDR_EXP 97
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_build_list := [ ] ;
20924: LD_ADDR_EXP 98
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20931: LD_ADDR_EXP 125
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_builders := [ ] ;
20938: LD_ADDR_EXP 99
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_construct_list := [ ] ;
20945: LD_ADDR_EXP 100
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_turret_list := [ ] ;
20952: LD_ADDR_EXP 101
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20959: LD_ADDR_EXP 102
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_miners := [ ] ;
20966: LD_ADDR_EXP 107
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_mines := [ ] ;
20973: LD_ADDR_EXP 106
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_minefields := [ ] ;
20980: LD_ADDR_EXP 108
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_crates := [ ] ;
20987: LD_ADDR_EXP 109
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20994: LD_ADDR_EXP 110
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_crates_area := [ ] ;
21001: LD_ADDR_EXP 111
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// mc_vehicles := [ ] ;
21008: LD_ADDR_EXP 112
21012: PUSH
21013: EMPTY
21014: ST_TO_ADDR
// mc_attack := [ ] ;
21015: LD_ADDR_EXP 113
21019: PUSH
21020: EMPTY
21021: ST_TO_ADDR
// mc_produce := [ ] ;
21022: LD_ADDR_EXP 114
21026: PUSH
21027: EMPTY
21028: ST_TO_ADDR
// mc_defender := [ ] ;
21029: LD_ADDR_EXP 115
21033: PUSH
21034: EMPTY
21035: ST_TO_ADDR
// mc_parking := [ ] ;
21036: LD_ADDR_EXP 117
21040: PUSH
21041: EMPTY
21042: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21043: LD_ADDR_EXP 103
21047: PUSH
21048: EMPTY
21049: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21050: LD_ADDR_EXP 105
21054: PUSH
21055: EMPTY
21056: ST_TO_ADDR
// mc_scan := [ ] ;
21057: LD_ADDR_EXP 116
21061: PUSH
21062: EMPTY
21063: ST_TO_ADDR
// mc_scan_area := [ ] ;
21064: LD_ADDR_EXP 118
21068: PUSH
21069: EMPTY
21070: ST_TO_ADDR
// mc_tech := [ ] ;
21071: LD_ADDR_EXP 120
21075: PUSH
21076: EMPTY
21077: ST_TO_ADDR
// mc_class := [ ] ;
21078: LD_ADDR_EXP 134
21082: PUSH
21083: EMPTY
21084: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21085: LD_ADDR_EXP 135
21089: PUSH
21090: EMPTY
21091: ST_TO_ADDR
// mc_is_defending := [ ] ;
21092: LD_ADDR_EXP 136
21096: PUSH
21097: EMPTY
21098: ST_TO_ADDR
// end ;
21099: LD_VAR 0 1
21103: RET
// export function MC_Kill ( base ) ; begin
21104: LD_INT 0
21106: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21107: LD_ADDR_EXP 93
21111: PUSH
21112: LD_EXP 93
21116: PPUSH
21117: LD_VAR 0 1
21121: PPUSH
21122: EMPTY
21123: PPUSH
21124: CALL_OW 1
21128: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21129: LD_ADDR_EXP 94
21133: PUSH
21134: LD_EXP 94
21138: PPUSH
21139: LD_VAR 0 1
21143: PPUSH
21144: EMPTY
21145: PPUSH
21146: CALL_OW 1
21150: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21151: LD_ADDR_EXP 95
21155: PUSH
21156: LD_EXP 95
21160: PPUSH
21161: LD_VAR 0 1
21165: PPUSH
21166: EMPTY
21167: PPUSH
21168: CALL_OW 1
21172: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21173: LD_ADDR_EXP 96
21177: PUSH
21178: LD_EXP 96
21182: PPUSH
21183: LD_VAR 0 1
21187: PPUSH
21188: EMPTY
21189: PPUSH
21190: CALL_OW 1
21194: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21195: LD_ADDR_EXP 97
21199: PUSH
21200: LD_EXP 97
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: EMPTY
21211: PPUSH
21212: CALL_OW 1
21216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21217: LD_ADDR_EXP 98
21221: PUSH
21222: LD_EXP 98
21226: PPUSH
21227: LD_VAR 0 1
21231: PPUSH
21232: EMPTY
21233: PPUSH
21234: CALL_OW 1
21238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21239: LD_ADDR_EXP 99
21243: PUSH
21244: LD_EXP 99
21248: PPUSH
21249: LD_VAR 0 1
21253: PPUSH
21254: EMPTY
21255: PPUSH
21256: CALL_OW 1
21260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21261: LD_ADDR_EXP 100
21265: PUSH
21266: LD_EXP 100
21270: PPUSH
21271: LD_VAR 0 1
21275: PPUSH
21276: EMPTY
21277: PPUSH
21278: CALL_OW 1
21282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21283: LD_ADDR_EXP 101
21287: PUSH
21288: LD_EXP 101
21292: PPUSH
21293: LD_VAR 0 1
21297: PPUSH
21298: EMPTY
21299: PPUSH
21300: CALL_OW 1
21304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21305: LD_ADDR_EXP 102
21309: PUSH
21310: LD_EXP 102
21314: PPUSH
21315: LD_VAR 0 1
21319: PPUSH
21320: EMPTY
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21327: LD_ADDR_EXP 103
21331: PUSH
21332: LD_EXP 103
21336: PPUSH
21337: LD_VAR 0 1
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21349: LD_ADDR_EXP 104
21353: PUSH
21354: LD_EXP 104
21358: PPUSH
21359: LD_VAR 0 1
21363: PPUSH
21364: LD_INT 0
21366: PPUSH
21367: CALL_OW 1
21371: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21372: LD_ADDR_EXP 105
21376: PUSH
21377: LD_EXP 105
21381: PPUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: EMPTY
21388: PPUSH
21389: CALL_OW 1
21393: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21394: LD_ADDR_EXP 106
21398: PUSH
21399: LD_EXP 106
21403: PPUSH
21404: LD_VAR 0 1
21408: PPUSH
21409: EMPTY
21410: PPUSH
21411: CALL_OW 1
21415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21416: LD_ADDR_EXP 107
21420: PUSH
21421: LD_EXP 107
21425: PPUSH
21426: LD_VAR 0 1
21430: PPUSH
21431: EMPTY
21432: PPUSH
21433: CALL_OW 1
21437: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21438: LD_ADDR_EXP 108
21442: PUSH
21443: LD_EXP 108
21447: PPUSH
21448: LD_VAR 0 1
21452: PPUSH
21453: EMPTY
21454: PPUSH
21455: CALL_OW 1
21459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21460: LD_ADDR_EXP 109
21464: PUSH
21465: LD_EXP 109
21469: PPUSH
21470: LD_VAR 0 1
21474: PPUSH
21475: EMPTY
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21482: LD_ADDR_EXP 110
21486: PUSH
21487: LD_EXP 110
21491: PPUSH
21492: LD_VAR 0 1
21496: PPUSH
21497: EMPTY
21498: PPUSH
21499: CALL_OW 1
21503: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21504: LD_ADDR_EXP 111
21508: PUSH
21509: LD_EXP 111
21513: PPUSH
21514: LD_VAR 0 1
21518: PPUSH
21519: EMPTY
21520: PPUSH
21521: CALL_OW 1
21525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21526: LD_ADDR_EXP 112
21530: PUSH
21531: LD_EXP 112
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: EMPTY
21542: PPUSH
21543: CALL_OW 1
21547: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21548: LD_ADDR_EXP 113
21552: PUSH
21553: LD_EXP 113
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: EMPTY
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21570: LD_ADDR_EXP 114
21574: PUSH
21575: LD_EXP 114
21579: PPUSH
21580: LD_VAR 0 1
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21592: LD_ADDR_EXP 115
21596: PUSH
21597: LD_EXP 115
21601: PPUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21614: LD_ADDR_EXP 116
21618: PUSH
21619: LD_EXP 116
21623: PPUSH
21624: LD_VAR 0 1
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21636: LD_ADDR_EXP 117
21640: PUSH
21641: LD_EXP 117
21645: PPUSH
21646: LD_VAR 0 1
21650: PPUSH
21651: EMPTY
21652: PPUSH
21653: CALL_OW 1
21657: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21658: LD_ADDR_EXP 118
21662: PUSH
21663: LD_EXP 118
21667: PPUSH
21668: LD_VAR 0 1
21672: PPUSH
21673: EMPTY
21674: PPUSH
21675: CALL_OW 1
21679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21680: LD_ADDR_EXP 120
21684: PUSH
21685: LD_EXP 120
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: EMPTY
21696: PPUSH
21697: CALL_OW 1
21701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21702: LD_ADDR_EXP 122
21706: PUSH
21707: LD_EXP 122
21711: PPUSH
21712: LD_VAR 0 1
21716: PPUSH
21717: EMPTY
21718: PPUSH
21719: CALL_OW 1
21723: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21724: LD_ADDR_EXP 123
21728: PUSH
21729: LD_EXP 123
21733: PPUSH
21734: LD_VAR 0 1
21738: PPUSH
21739: EMPTY
21740: PPUSH
21741: CALL_OW 1
21745: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21746: LD_ADDR_EXP 124
21750: PUSH
21751: LD_EXP 124
21755: PPUSH
21756: LD_VAR 0 1
21760: PPUSH
21761: EMPTY
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21768: LD_ADDR_EXP 125
21772: PUSH
21773: LD_EXP 125
21777: PPUSH
21778: LD_VAR 0 1
21782: PPUSH
21783: EMPTY
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21790: LD_ADDR_EXP 126
21794: PUSH
21795: LD_EXP 126
21799: PPUSH
21800: LD_VAR 0 1
21804: PPUSH
21805: EMPTY
21806: PPUSH
21807: CALL_OW 1
21811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21812: LD_ADDR_EXP 127
21816: PUSH
21817: LD_EXP 127
21821: PPUSH
21822: LD_VAR 0 1
21826: PPUSH
21827: EMPTY
21828: PPUSH
21829: CALL_OW 1
21833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21834: LD_ADDR_EXP 128
21838: PUSH
21839: LD_EXP 128
21843: PPUSH
21844: LD_VAR 0 1
21848: PPUSH
21849: EMPTY
21850: PPUSH
21851: CALL_OW 1
21855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21856: LD_ADDR_EXP 129
21860: PUSH
21861: LD_EXP 129
21865: PPUSH
21866: LD_VAR 0 1
21870: PPUSH
21871: EMPTY
21872: PPUSH
21873: CALL_OW 1
21877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21878: LD_ADDR_EXP 130
21882: PUSH
21883: LD_EXP 130
21887: PPUSH
21888: LD_VAR 0 1
21892: PPUSH
21893: EMPTY
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21900: LD_ADDR_EXP 131
21904: PUSH
21905: LD_EXP 131
21909: PPUSH
21910: LD_VAR 0 1
21914: PPUSH
21915: EMPTY
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21922: LD_ADDR_EXP 132
21926: PUSH
21927: LD_EXP 132
21931: PPUSH
21932: LD_VAR 0 1
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21944: LD_ADDR_EXP 133
21948: PUSH
21949: LD_EXP 133
21953: PPUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21966: LD_ADDR_EXP 134
21970: PUSH
21971: LD_EXP 134
21975: PPUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21988: LD_ADDR_EXP 135
21992: PUSH
21993: LD_EXP 135
21997: PPUSH
21998: LD_VAR 0 1
22002: PPUSH
22003: LD_INT 0
22005: PPUSH
22006: CALL_OW 1
22010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22011: LD_ADDR_EXP 136
22015: PUSH
22016: LD_EXP 136
22020: PPUSH
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 0
22028: PPUSH
22029: CALL_OW 1
22033: ST_TO_ADDR
// end ;
22034: LD_VAR 0 2
22038: RET
// export function MC_Add ( side , units ) ; var base ; begin
22039: LD_INT 0
22041: PPUSH
22042: PPUSH
// base := mc_bases + 1 ;
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: LD_EXP 93
22052: PUSH
22053: LD_INT 1
22055: PLUS
22056: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22057: LD_ADDR_EXP 119
22061: PUSH
22062: LD_EXP 119
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: LD_VAR 0 1
22076: PPUSH
22077: CALL_OW 1
22081: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22082: LD_ADDR_EXP 93
22086: PUSH
22087: LD_EXP 93
22091: PPUSH
22092: LD_VAR 0 4
22096: PPUSH
22097: LD_VAR 0 2
22101: PPUSH
22102: CALL_OW 1
22106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22107: LD_ADDR_EXP 94
22111: PUSH
22112: LD_EXP 94
22116: PPUSH
22117: LD_VAR 0 4
22121: PPUSH
22122: EMPTY
22123: PPUSH
22124: CALL_OW 1
22128: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22129: LD_ADDR_EXP 95
22133: PUSH
22134: LD_EXP 95
22138: PPUSH
22139: LD_VAR 0 4
22143: PPUSH
22144: EMPTY
22145: PPUSH
22146: CALL_OW 1
22150: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22151: LD_ADDR_EXP 96
22155: PUSH
22156: LD_EXP 96
22160: PPUSH
22161: LD_VAR 0 4
22165: PPUSH
22166: EMPTY
22167: PPUSH
22168: CALL_OW 1
22172: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22173: LD_ADDR_EXP 97
22177: PUSH
22178: LD_EXP 97
22182: PPUSH
22183: LD_VAR 0 4
22187: PPUSH
22188: EMPTY
22189: PPUSH
22190: CALL_OW 1
22194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22195: LD_ADDR_EXP 98
22199: PUSH
22200: LD_EXP 98
22204: PPUSH
22205: LD_VAR 0 4
22209: PPUSH
22210: EMPTY
22211: PPUSH
22212: CALL_OW 1
22216: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22217: LD_ADDR_EXP 99
22221: PUSH
22222: LD_EXP 99
22226: PPUSH
22227: LD_VAR 0 4
22231: PPUSH
22232: EMPTY
22233: PPUSH
22234: CALL_OW 1
22238: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22239: LD_ADDR_EXP 100
22243: PUSH
22244: LD_EXP 100
22248: PPUSH
22249: LD_VAR 0 4
22253: PPUSH
22254: EMPTY
22255: PPUSH
22256: CALL_OW 1
22260: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22261: LD_ADDR_EXP 101
22265: PUSH
22266: LD_EXP 101
22270: PPUSH
22271: LD_VAR 0 4
22275: PPUSH
22276: EMPTY
22277: PPUSH
22278: CALL_OW 1
22282: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22283: LD_ADDR_EXP 102
22287: PUSH
22288: LD_EXP 102
22292: PPUSH
22293: LD_VAR 0 4
22297: PPUSH
22298: EMPTY
22299: PPUSH
22300: CALL_OW 1
22304: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22305: LD_ADDR_EXP 103
22309: PUSH
22310: LD_EXP 103
22314: PPUSH
22315: LD_VAR 0 4
22319: PPUSH
22320: EMPTY
22321: PPUSH
22322: CALL_OW 1
22326: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22327: LD_ADDR_EXP 104
22331: PUSH
22332: LD_EXP 104
22336: PPUSH
22337: LD_VAR 0 4
22341: PPUSH
22342: LD_INT 0
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22350: LD_ADDR_EXP 105
22354: PUSH
22355: LD_EXP 105
22359: PPUSH
22360: LD_VAR 0 4
22364: PPUSH
22365: EMPTY
22366: PPUSH
22367: CALL_OW 1
22371: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22372: LD_ADDR_EXP 106
22376: PUSH
22377: LD_EXP 106
22381: PPUSH
22382: LD_VAR 0 4
22386: PPUSH
22387: EMPTY
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22394: LD_ADDR_EXP 107
22398: PUSH
22399: LD_EXP 107
22403: PPUSH
22404: LD_VAR 0 4
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22416: LD_ADDR_EXP 108
22420: PUSH
22421: LD_EXP 108
22425: PPUSH
22426: LD_VAR 0 4
22430: PPUSH
22431: EMPTY
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22438: LD_ADDR_EXP 109
22442: PUSH
22443: LD_EXP 109
22447: PPUSH
22448: LD_VAR 0 4
22452: PPUSH
22453: EMPTY
22454: PPUSH
22455: CALL_OW 1
22459: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22460: LD_ADDR_EXP 110
22464: PUSH
22465: LD_EXP 110
22469: PPUSH
22470: LD_VAR 0 4
22474: PPUSH
22475: EMPTY
22476: PPUSH
22477: CALL_OW 1
22481: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22482: LD_ADDR_EXP 111
22486: PUSH
22487: LD_EXP 111
22491: PPUSH
22492: LD_VAR 0 4
22496: PPUSH
22497: EMPTY
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22504: LD_ADDR_EXP 112
22508: PUSH
22509: LD_EXP 112
22513: PPUSH
22514: LD_VAR 0 4
22518: PPUSH
22519: EMPTY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22526: LD_ADDR_EXP 113
22530: PUSH
22531: LD_EXP 113
22535: PPUSH
22536: LD_VAR 0 4
22540: PPUSH
22541: EMPTY
22542: PPUSH
22543: CALL_OW 1
22547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22548: LD_ADDR_EXP 114
22552: PUSH
22553: LD_EXP 114
22557: PPUSH
22558: LD_VAR 0 4
22562: PPUSH
22563: EMPTY
22564: PPUSH
22565: CALL_OW 1
22569: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22570: LD_ADDR_EXP 115
22574: PUSH
22575: LD_EXP 115
22579: PPUSH
22580: LD_VAR 0 4
22584: PPUSH
22585: EMPTY
22586: PPUSH
22587: CALL_OW 1
22591: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22592: LD_ADDR_EXP 116
22596: PUSH
22597: LD_EXP 116
22601: PPUSH
22602: LD_VAR 0 4
22606: PPUSH
22607: EMPTY
22608: PPUSH
22609: CALL_OW 1
22613: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22614: LD_ADDR_EXP 117
22618: PUSH
22619: LD_EXP 117
22623: PPUSH
22624: LD_VAR 0 4
22628: PPUSH
22629: EMPTY
22630: PPUSH
22631: CALL_OW 1
22635: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22636: LD_ADDR_EXP 118
22640: PUSH
22641: LD_EXP 118
22645: PPUSH
22646: LD_VAR 0 4
22650: PPUSH
22651: EMPTY
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22658: LD_ADDR_EXP 120
22662: PUSH
22663: LD_EXP 120
22667: PPUSH
22668: LD_VAR 0 4
22672: PPUSH
22673: EMPTY
22674: PPUSH
22675: CALL_OW 1
22679: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22680: LD_ADDR_EXP 122
22684: PUSH
22685: LD_EXP 122
22689: PPUSH
22690: LD_VAR 0 4
22694: PPUSH
22695: EMPTY
22696: PPUSH
22697: CALL_OW 1
22701: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22702: LD_ADDR_EXP 123
22706: PUSH
22707: LD_EXP 123
22711: PPUSH
22712: LD_VAR 0 4
22716: PPUSH
22717: EMPTY
22718: PPUSH
22719: CALL_OW 1
22723: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22724: LD_ADDR_EXP 124
22728: PUSH
22729: LD_EXP 124
22733: PPUSH
22734: LD_VAR 0 4
22738: PPUSH
22739: EMPTY
22740: PPUSH
22741: CALL_OW 1
22745: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22746: LD_ADDR_EXP 125
22750: PUSH
22751: LD_EXP 125
22755: PPUSH
22756: LD_VAR 0 4
22760: PPUSH
22761: EMPTY
22762: PPUSH
22763: CALL_OW 1
22767: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22768: LD_ADDR_EXP 126
22772: PUSH
22773: LD_EXP 126
22777: PPUSH
22778: LD_VAR 0 4
22782: PPUSH
22783: EMPTY
22784: PPUSH
22785: CALL_OW 1
22789: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22790: LD_ADDR_EXP 127
22794: PUSH
22795: LD_EXP 127
22799: PPUSH
22800: LD_VAR 0 4
22804: PPUSH
22805: EMPTY
22806: PPUSH
22807: CALL_OW 1
22811: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22812: LD_ADDR_EXP 128
22816: PUSH
22817: LD_EXP 128
22821: PPUSH
22822: LD_VAR 0 4
22826: PPUSH
22827: EMPTY
22828: PPUSH
22829: CALL_OW 1
22833: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22834: LD_ADDR_EXP 129
22838: PUSH
22839: LD_EXP 129
22843: PPUSH
22844: LD_VAR 0 4
22848: PPUSH
22849: EMPTY
22850: PPUSH
22851: CALL_OW 1
22855: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22856: LD_ADDR_EXP 130
22860: PUSH
22861: LD_EXP 130
22865: PPUSH
22866: LD_VAR 0 4
22870: PPUSH
22871: EMPTY
22872: PPUSH
22873: CALL_OW 1
22877: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22878: LD_ADDR_EXP 131
22882: PUSH
22883: LD_EXP 131
22887: PPUSH
22888: LD_VAR 0 4
22892: PPUSH
22893: EMPTY
22894: PPUSH
22895: CALL_OW 1
22899: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22900: LD_ADDR_EXP 132
22904: PUSH
22905: LD_EXP 132
22909: PPUSH
22910: LD_VAR 0 4
22914: PPUSH
22915: EMPTY
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22922: LD_ADDR_EXP 133
22926: PUSH
22927: LD_EXP 133
22931: PPUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: EMPTY
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22944: LD_ADDR_EXP 134
22948: PUSH
22949: LD_EXP 134
22953: PPUSH
22954: LD_VAR 0 4
22958: PPUSH
22959: EMPTY
22960: PPUSH
22961: CALL_OW 1
22965: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22966: LD_ADDR_EXP 135
22970: PUSH
22971: LD_EXP 135
22975: PPUSH
22976: LD_VAR 0 4
22980: PPUSH
22981: LD_INT 0
22983: PPUSH
22984: CALL_OW 1
22988: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22989: LD_ADDR_EXP 136
22993: PUSH
22994: LD_EXP 136
22998: PPUSH
22999: LD_VAR 0 4
23003: PPUSH
23004: LD_INT 0
23006: PPUSH
23007: CALL_OW 1
23011: ST_TO_ADDR
// result := base ;
23012: LD_ADDR_VAR 0 3
23016: PUSH
23017: LD_VAR 0 4
23021: ST_TO_ADDR
// end ;
23022: LD_VAR 0 3
23026: RET
// export function MC_Start ( ) ; var i ; begin
23027: LD_INT 0
23029: PPUSH
23030: PPUSH
// for i = 1 to mc_bases do
23031: LD_ADDR_VAR 0 2
23035: PUSH
23036: DOUBLE
23037: LD_INT 1
23039: DEC
23040: ST_TO_ADDR
23041: LD_EXP 93
23045: PUSH
23046: FOR_TO
23047: IFFALSE 24147
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23049: LD_ADDR_EXP 93
23053: PUSH
23054: LD_EXP 93
23058: PPUSH
23059: LD_VAR 0 2
23063: PPUSH
23064: LD_EXP 93
23068: PUSH
23069: LD_VAR 0 2
23073: ARRAY
23074: PUSH
23075: LD_INT 0
23077: DIFF
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23084: LD_ADDR_EXP 94
23088: PUSH
23089: LD_EXP 94
23093: PPUSH
23094: LD_VAR 0 2
23098: PPUSH
23099: EMPTY
23100: PPUSH
23101: CALL_OW 1
23105: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23106: LD_ADDR_EXP 95
23110: PUSH
23111: LD_EXP 95
23115: PPUSH
23116: LD_VAR 0 2
23120: PPUSH
23121: EMPTY
23122: PPUSH
23123: CALL_OW 1
23127: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23128: LD_ADDR_EXP 96
23132: PUSH
23133: LD_EXP 96
23137: PPUSH
23138: LD_VAR 0 2
23142: PPUSH
23143: EMPTY
23144: PPUSH
23145: CALL_OW 1
23149: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23150: LD_ADDR_EXP 97
23154: PUSH
23155: LD_EXP 97
23159: PPUSH
23160: LD_VAR 0 2
23164: PPUSH
23165: EMPTY
23166: PUSH
23167: EMPTY
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 1
23177: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23178: LD_ADDR_EXP 98
23182: PUSH
23183: LD_EXP 98
23187: PPUSH
23188: LD_VAR 0 2
23192: PPUSH
23193: EMPTY
23194: PPUSH
23195: CALL_OW 1
23199: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23200: LD_ADDR_EXP 125
23204: PUSH
23205: LD_EXP 125
23209: PPUSH
23210: LD_VAR 0 2
23214: PPUSH
23215: EMPTY
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23222: LD_ADDR_EXP 99
23226: PUSH
23227: LD_EXP 99
23231: PPUSH
23232: LD_VAR 0 2
23236: PPUSH
23237: EMPTY
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23244: LD_ADDR_EXP 100
23248: PUSH
23249: LD_EXP 100
23253: PPUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: EMPTY
23260: PPUSH
23261: CALL_OW 1
23265: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23266: LD_ADDR_EXP 101
23270: PUSH
23271: LD_EXP 101
23275: PPUSH
23276: LD_VAR 0 2
23280: PPUSH
23281: LD_EXP 93
23285: PUSH
23286: LD_VAR 0 2
23290: ARRAY
23291: PPUSH
23292: LD_INT 2
23294: PUSH
23295: LD_INT 30
23297: PUSH
23298: LD_INT 32
23300: PUSH
23301: EMPTY
23302: LIST
23303: LIST
23304: PUSH
23305: LD_INT 30
23307: PUSH
23308: LD_INT 33
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: LIST
23319: PPUSH
23320: CALL_OW 72
23324: PPUSH
23325: CALL_OW 1
23329: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23330: LD_ADDR_EXP 102
23334: PUSH
23335: LD_EXP 102
23339: PPUSH
23340: LD_VAR 0 2
23344: PPUSH
23345: LD_EXP 93
23349: PUSH
23350: LD_VAR 0 2
23354: ARRAY
23355: PPUSH
23356: LD_INT 2
23358: PUSH
23359: LD_INT 30
23361: PUSH
23362: LD_INT 32
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 30
23371: PUSH
23372: LD_INT 31
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 58
23386: PUSH
23387: EMPTY
23388: LIST
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PPUSH
23394: CALL_OW 72
23398: PPUSH
23399: CALL_OW 1
23403: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23404: LD_ADDR_EXP 103
23408: PUSH
23409: LD_EXP 103
23413: PPUSH
23414: LD_VAR 0 2
23418: PPUSH
23419: EMPTY
23420: PPUSH
23421: CALL_OW 1
23425: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23426: LD_ADDR_EXP 107
23430: PUSH
23431: LD_EXP 107
23435: PPUSH
23436: LD_VAR 0 2
23440: PPUSH
23441: EMPTY
23442: PPUSH
23443: CALL_OW 1
23447: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23448: LD_ADDR_EXP 106
23452: PUSH
23453: LD_EXP 106
23457: PPUSH
23458: LD_VAR 0 2
23462: PPUSH
23463: EMPTY
23464: PPUSH
23465: CALL_OW 1
23469: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23470: LD_ADDR_EXP 108
23474: PUSH
23475: LD_EXP 108
23479: PPUSH
23480: LD_VAR 0 2
23484: PPUSH
23485: EMPTY
23486: PPUSH
23487: CALL_OW 1
23491: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23492: LD_ADDR_EXP 109
23496: PUSH
23497: LD_EXP 109
23501: PPUSH
23502: LD_VAR 0 2
23506: PPUSH
23507: EMPTY
23508: PPUSH
23509: CALL_OW 1
23513: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23514: LD_ADDR_EXP 110
23518: PUSH
23519: LD_EXP 110
23523: PPUSH
23524: LD_VAR 0 2
23528: PPUSH
23529: EMPTY
23530: PPUSH
23531: CALL_OW 1
23535: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23536: LD_ADDR_EXP 111
23540: PUSH
23541: LD_EXP 111
23545: PPUSH
23546: LD_VAR 0 2
23550: PPUSH
23551: EMPTY
23552: PPUSH
23553: CALL_OW 1
23557: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23558: LD_ADDR_EXP 112
23562: PUSH
23563: LD_EXP 112
23567: PPUSH
23568: LD_VAR 0 2
23572: PPUSH
23573: EMPTY
23574: PPUSH
23575: CALL_OW 1
23579: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23580: LD_ADDR_EXP 113
23584: PUSH
23585: LD_EXP 113
23589: PPUSH
23590: LD_VAR 0 2
23594: PPUSH
23595: EMPTY
23596: PPUSH
23597: CALL_OW 1
23601: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23602: LD_ADDR_EXP 114
23606: PUSH
23607: LD_EXP 114
23611: PPUSH
23612: LD_VAR 0 2
23616: PPUSH
23617: EMPTY
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23624: LD_ADDR_EXP 115
23628: PUSH
23629: LD_EXP 115
23633: PPUSH
23634: LD_VAR 0 2
23638: PPUSH
23639: EMPTY
23640: PPUSH
23641: CALL_OW 1
23645: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23646: LD_ADDR_EXP 104
23650: PUSH
23651: LD_EXP 104
23655: PPUSH
23656: LD_VAR 0 2
23660: PPUSH
23661: LD_INT 0
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23669: LD_ADDR_EXP 117
23673: PUSH
23674: LD_EXP 117
23678: PPUSH
23679: LD_VAR 0 2
23683: PPUSH
23684: LD_INT 0
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23692: LD_ADDR_EXP 105
23696: PUSH
23697: LD_EXP 105
23701: PPUSH
23702: LD_VAR 0 2
23706: PPUSH
23707: EMPTY
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23714: LD_ADDR_EXP 116
23718: PUSH
23719: LD_EXP 116
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: LD_INT 0
23731: PPUSH
23732: CALL_OW 1
23736: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23737: LD_ADDR_EXP 118
23741: PUSH
23742: LD_EXP 118
23746: PPUSH
23747: LD_VAR 0 2
23751: PPUSH
23752: EMPTY
23753: PPUSH
23754: CALL_OW 1
23758: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23759: LD_ADDR_EXP 121
23763: PUSH
23764: LD_EXP 121
23768: PPUSH
23769: LD_VAR 0 2
23773: PPUSH
23774: LD_INT 0
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23782: LD_ADDR_EXP 122
23786: PUSH
23787: LD_EXP 122
23791: PPUSH
23792: LD_VAR 0 2
23796: PPUSH
23797: EMPTY
23798: PPUSH
23799: CALL_OW 1
23803: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23804: LD_ADDR_EXP 123
23808: PUSH
23809: LD_EXP 123
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: EMPTY
23820: PPUSH
23821: CALL_OW 1
23825: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23826: LD_ADDR_EXP 124
23830: PUSH
23831: LD_EXP 124
23835: PPUSH
23836: LD_VAR 0 2
23840: PPUSH
23841: EMPTY
23842: PPUSH
23843: CALL_OW 1
23847: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23848: LD_ADDR_EXP 126
23852: PUSH
23853: LD_EXP 126
23857: PPUSH
23858: LD_VAR 0 2
23862: PPUSH
23863: LD_EXP 93
23867: PUSH
23868: LD_VAR 0 2
23872: ARRAY
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 6
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 7
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 8
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: PPUSH
23913: CALL_OW 72
23917: PPUSH
23918: CALL_OW 1
23922: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23923: LD_ADDR_EXP 127
23927: PUSH
23928: LD_EXP 127
23932: PPUSH
23933: LD_VAR 0 2
23937: PPUSH
23938: EMPTY
23939: PPUSH
23940: CALL_OW 1
23944: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23945: LD_ADDR_EXP 128
23949: PUSH
23950: LD_EXP 128
23954: PPUSH
23955: LD_VAR 0 2
23959: PPUSH
23960: EMPTY
23961: PPUSH
23962: CALL_OW 1
23966: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23967: LD_ADDR_EXP 129
23971: PUSH
23972: LD_EXP 129
23976: PPUSH
23977: LD_VAR 0 2
23981: PPUSH
23982: EMPTY
23983: PPUSH
23984: CALL_OW 1
23988: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23989: LD_ADDR_EXP 130
23993: PUSH
23994: LD_EXP 130
23998: PPUSH
23999: LD_VAR 0 2
24003: PPUSH
24004: EMPTY
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24011: LD_ADDR_EXP 131
24015: PUSH
24016: LD_EXP 131
24020: PPUSH
24021: LD_VAR 0 2
24025: PPUSH
24026: EMPTY
24027: PPUSH
24028: CALL_OW 1
24032: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24033: LD_ADDR_EXP 132
24037: PUSH
24038: LD_EXP 132
24042: PPUSH
24043: LD_VAR 0 2
24047: PPUSH
24048: EMPTY
24049: PPUSH
24050: CALL_OW 1
24054: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24055: LD_ADDR_EXP 133
24059: PUSH
24060: LD_EXP 133
24064: PPUSH
24065: LD_VAR 0 2
24069: PPUSH
24070: EMPTY
24071: PPUSH
24072: CALL_OW 1
24076: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24077: LD_ADDR_EXP 134
24081: PUSH
24082: LD_EXP 134
24086: PPUSH
24087: LD_VAR 0 2
24091: PPUSH
24092: EMPTY
24093: PPUSH
24094: CALL_OW 1
24098: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24099: LD_ADDR_EXP 135
24103: PUSH
24104: LD_EXP 135
24108: PPUSH
24109: LD_VAR 0 2
24113: PPUSH
24114: LD_INT 0
24116: PPUSH
24117: CALL_OW 1
24121: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24122: LD_ADDR_EXP 136
24126: PUSH
24127: LD_EXP 136
24131: PPUSH
24132: LD_VAR 0 2
24136: PPUSH
24137: LD_INT 0
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// end ;
24145: GO 23046
24147: POP
24148: POP
// MC_InitSides ( ) ;
24149: CALL 24435 0 0
// MC_InitResearch ( ) ;
24153: CALL 24174 0 0
// CustomInitMacro ( ) ;
24157: CALL 217 0 0
// skirmish := true ;
24161: LD_ADDR_EXP 91
24165: PUSH
24166: LD_INT 1
24168: ST_TO_ADDR
// end ;
24169: LD_VAR 0 1
24173: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24174: LD_INT 0
24176: PPUSH
24177: PPUSH
24178: PPUSH
24179: PPUSH
24180: PPUSH
24181: PPUSH
// if not mc_bases then
24182: LD_EXP 93
24186: NOT
24187: IFFALSE 24191
// exit ;
24189: GO 24430
// for i = 1 to 8 do
24191: LD_ADDR_VAR 0 2
24195: PUSH
24196: DOUBLE
24197: LD_INT 1
24199: DEC
24200: ST_TO_ADDR
24201: LD_INT 8
24203: PUSH
24204: FOR_TO
24205: IFFALSE 24231
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24207: LD_ADDR_EXP 120
24211: PUSH
24212: LD_EXP 120
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
24229: GO 24204
24231: POP
24232: POP
// tmp := [ ] ;
24233: LD_ADDR_VAR 0 5
24237: PUSH
24238: EMPTY
24239: ST_TO_ADDR
// for i = 1 to mc_sides do
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: DOUBLE
24246: LD_INT 1
24248: DEC
24249: ST_TO_ADDR
24250: LD_EXP 119
24254: PUSH
24255: FOR_TO
24256: IFFALSE 24314
// if not mc_sides [ i ] in tmp then
24258: LD_EXP 119
24262: PUSH
24263: LD_VAR 0 2
24267: ARRAY
24268: PUSH
24269: LD_VAR 0 5
24273: IN
24274: NOT
24275: IFFALSE 24312
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24277: LD_ADDR_VAR 0 5
24281: PUSH
24282: LD_VAR 0 5
24286: PPUSH
24287: LD_VAR 0 5
24291: PUSH
24292: LD_INT 1
24294: PLUS
24295: PPUSH
24296: LD_EXP 119
24300: PUSH
24301: LD_VAR 0 2
24305: ARRAY
24306: PPUSH
24307: CALL_OW 2
24311: ST_TO_ADDR
24312: GO 24255
24314: POP
24315: POP
// if not tmp then
24316: LD_VAR 0 5
24320: NOT
24321: IFFALSE 24325
// exit ;
24323: GO 24430
// for j in tmp do
24325: LD_ADDR_VAR 0 3
24329: PUSH
24330: LD_VAR 0 5
24334: PUSH
24335: FOR_IN
24336: IFFALSE 24428
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24338: LD_ADDR_VAR 0 6
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_VAR 0 3
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PPUSH
24355: CALL_OW 69
24359: ST_TO_ADDR
// if not un then
24360: LD_VAR 0 6
24364: NOT
24365: IFFALSE 24369
// continue ;
24367: GO 24335
// nation := GetNation ( un [ 1 ] ) ;
24369: LD_ADDR_VAR 0 4
24373: PUSH
24374: LD_VAR 0 6
24378: PUSH
24379: LD_INT 1
24381: ARRAY
24382: PPUSH
24383: CALL_OW 248
24387: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24388: LD_ADDR_EXP 120
24392: PUSH
24393: LD_EXP 120
24397: PPUSH
24398: LD_VAR 0 3
24402: PPUSH
24403: LD_VAR 0 3
24407: PPUSH
24408: LD_VAR 0 4
24412: PPUSH
24413: LD_INT 1
24415: PPUSH
24416: CALL 51404 0 3
24420: PPUSH
24421: CALL_OW 1
24425: ST_TO_ADDR
// end ;
24426: GO 24335
24428: POP
24429: POP
// end ;
24430: LD_VAR 0 1
24434: RET
// export function MC_InitSides ( ) ; var i ; begin
24435: LD_INT 0
24437: PPUSH
24438: PPUSH
// if not mc_bases then
24439: LD_EXP 93
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24522
// for i = 1 to mc_bases do
24448: LD_ADDR_VAR 0 2
24452: PUSH
24453: DOUBLE
24454: LD_INT 1
24456: DEC
24457: ST_TO_ADDR
24458: LD_EXP 93
24462: PUSH
24463: FOR_TO
24464: IFFALSE 24520
// if mc_bases [ i ] then
24466: LD_EXP 93
24470: PUSH
24471: LD_VAR 0 2
24475: ARRAY
24476: IFFALSE 24518
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24478: LD_ADDR_EXP 119
24482: PUSH
24483: LD_EXP 119
24487: PPUSH
24488: LD_VAR 0 2
24492: PPUSH
24493: LD_EXP 93
24497: PUSH
24498: LD_VAR 0 2
24502: ARRAY
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 255
24512: PPUSH
24513: CALL_OW 1
24517: ST_TO_ADDR
24518: GO 24463
24520: POP
24521: POP
// end ;
24522: LD_VAR 0 1
24526: RET
// every 0 0$03 trigger skirmish do
24527: LD_EXP 91
24531: IFFALSE 24685
24533: GO 24535
24535: DISABLE
// begin enable ;
24536: ENABLE
// MC_CheckBuildings ( ) ;
24537: CALL 29183 0 0
// MC_CheckPeopleLife ( ) ;
24541: CALL 29344 0 0
// RaiseSailEvent ( 100 ) ;
24545: LD_INT 100
24547: PPUSH
24548: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24552: LD_INT 103
24554: PPUSH
24555: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24559: LD_INT 104
24561: PPUSH
24562: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24566: LD_INT 105
24568: PPUSH
24569: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24573: LD_INT 106
24575: PPUSH
24576: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24580: LD_INT 107
24582: PPUSH
24583: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24587: LD_INT 108
24589: PPUSH
24590: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24594: LD_INT 109
24596: PPUSH
24597: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24601: LD_INT 110
24603: PPUSH
24604: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24608: LD_INT 111
24610: PPUSH
24611: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24615: LD_INT 112
24617: PPUSH
24618: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24622: LD_INT 113
24624: PPUSH
24625: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24629: LD_INT 120
24631: PPUSH
24632: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24636: LD_INT 121
24638: PPUSH
24639: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24643: LD_INT 122
24645: PPUSH
24646: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24650: LD_INT 123
24652: PPUSH
24653: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24657: LD_INT 124
24659: PPUSH
24660: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24664: LD_INT 125
24666: PPUSH
24667: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24671: LD_INT 126
24673: PPUSH
24674: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24678: LD_INT 200
24680: PPUSH
24681: CALL_OW 427
// end ;
24685: END
// on SailEvent ( event ) do begin if event < 100 then
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 100
24693: LESS
24694: IFFALSE 24705
// CustomEvent ( event ) ;
24696: LD_VAR 0 1
24700: PPUSH
24701: CALL 10473 0 1
// if event = 100 then
24705: LD_VAR 0 1
24709: PUSH
24710: LD_INT 100
24712: EQUAL
24713: IFFALSE 24719
// MC_ClassManager ( ) ;
24715: CALL 25111 0 0
// if event = 101 then
24719: LD_VAR 0 1
24723: PUSH
24724: LD_INT 101
24726: EQUAL
24727: IFFALSE 24733
// MC_RepairBuildings ( ) ;
24729: CALL 29929 0 0
// if event = 102 then
24733: LD_VAR 0 1
24737: PUSH
24738: LD_INT 102
24740: EQUAL
24741: IFFALSE 24747
// MC_Heal ( ) ;
24743: CALL 30836 0 0
// if event = 103 then
24747: LD_VAR 0 1
24751: PUSH
24752: LD_INT 103
24754: EQUAL
24755: IFFALSE 24761
// MC_Build ( ) ;
24757: CALL 31258 0 0
// if event = 104 then
24761: LD_VAR 0 1
24765: PUSH
24766: LD_INT 104
24768: EQUAL
24769: IFFALSE 24775
// MC_TurretWeapon ( ) ;
24771: CALL 32899 0 0
// if event = 105 then
24775: LD_VAR 0 1
24779: PUSH
24780: LD_INT 105
24782: EQUAL
24783: IFFALSE 24789
// MC_BuildUpgrade ( ) ;
24785: CALL 32450 0 0
// if event = 106 then
24789: LD_VAR 0 1
24793: PUSH
24794: LD_INT 106
24796: EQUAL
24797: IFFALSE 24803
// MC_PlantMines ( ) ;
24799: CALL 33329 0 0
// if event = 107 then
24803: LD_VAR 0 1
24807: PUSH
24808: LD_INT 107
24810: EQUAL
24811: IFFALSE 24817
// MC_CollectCrates ( ) ;
24813: CALL 34120 0 0
// if event = 108 then
24817: LD_VAR 0 1
24821: PUSH
24822: LD_INT 108
24824: EQUAL
24825: IFFALSE 24831
// MC_LinkRemoteControl ( ) ;
24827: CALL 35970 0 0
// if event = 109 then
24831: LD_VAR 0 1
24835: PUSH
24836: LD_INT 109
24838: EQUAL
24839: IFFALSE 24845
// MC_ProduceVehicle ( ) ;
24841: CALL 36151 0 0
// if event = 110 then
24845: LD_VAR 0 1
24849: PUSH
24850: LD_INT 110
24852: EQUAL
24853: IFFALSE 24859
// MC_SendAttack ( ) ;
24855: CALL 36617 0 0
// if event = 111 then
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 111
24866: EQUAL
24867: IFFALSE 24873
// MC_Defend ( ) ;
24869: CALL 36725 0 0
// if event = 112 then
24873: LD_VAR 0 1
24877: PUSH
24878: LD_INT 112
24880: EQUAL
24881: IFFALSE 24887
// MC_Research ( ) ;
24883: CALL 37458 0 0
// if event = 113 then
24887: LD_VAR 0 1
24891: PUSH
24892: LD_INT 113
24894: EQUAL
24895: IFFALSE 24901
// MC_MinesTrigger ( ) ;
24897: CALL 38572 0 0
// if event = 120 then
24901: LD_VAR 0 1
24905: PUSH
24906: LD_INT 120
24908: EQUAL
24909: IFFALSE 24915
// MC_RepairVehicle ( ) ;
24911: CALL 38671 0 0
// if event = 121 then
24915: LD_VAR 0 1
24919: PUSH
24920: LD_INT 121
24922: EQUAL
24923: IFFALSE 24929
// MC_TameApe ( ) ;
24925: CALL 39412 0 0
// if event = 122 then
24929: LD_VAR 0 1
24933: PUSH
24934: LD_INT 122
24936: EQUAL
24937: IFFALSE 24943
// MC_ChangeApeClass ( ) ;
24939: CALL 40241 0 0
// if event = 123 then
24943: LD_VAR 0 1
24947: PUSH
24948: LD_INT 123
24950: EQUAL
24951: IFFALSE 24957
// MC_Bazooka ( ) ;
24953: CALL 40891 0 0
// if event = 124 then
24957: LD_VAR 0 1
24961: PUSH
24962: LD_INT 124
24964: EQUAL
24965: IFFALSE 24971
// MC_TeleportExit ( ) ;
24967: CALL 41089 0 0
// if event = 125 then
24971: LD_VAR 0 1
24975: PUSH
24976: LD_INT 125
24978: EQUAL
24979: IFFALSE 24985
// MC_Deposits ( ) ;
24981: CALL 41736 0 0
// if event = 126 then
24985: LD_VAR 0 1
24989: PUSH
24990: LD_INT 126
24992: EQUAL
24993: IFFALSE 24999
// MC_RemoteDriver ( ) ;
24995: CALL 42361 0 0
// if event = 200 then
24999: LD_VAR 0 1
25003: PUSH
25004: LD_INT 200
25006: EQUAL
25007: IFFALSE 25013
// MC_Idle ( ) ;
25009: CALL 44310 0 0
// end ;
25013: PPOPN 1
25015: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25016: LD_INT 0
25018: PPUSH
25019: PPUSH
// if not mc_bases [ base ] or not tag then
25020: LD_EXP 93
25024: PUSH
25025: LD_VAR 0 1
25029: ARRAY
25030: NOT
25031: PUSH
25032: LD_VAR 0 2
25036: NOT
25037: OR
25038: IFFALSE 25042
// exit ;
25040: GO 25106
// for i in mc_bases [ base ] union mc_ape [ base ] do
25042: LD_ADDR_VAR 0 4
25046: PUSH
25047: LD_EXP 93
25051: PUSH
25052: LD_VAR 0 1
25056: ARRAY
25057: PUSH
25058: LD_EXP 122
25062: PUSH
25063: LD_VAR 0 1
25067: ARRAY
25068: UNION
25069: PUSH
25070: FOR_IN
25071: IFFALSE 25104
// if GetTag ( i ) = tag then
25073: LD_VAR 0 4
25077: PPUSH
25078: CALL_OW 110
25082: PUSH
25083: LD_VAR 0 2
25087: EQUAL
25088: IFFALSE 25102
// SetTag ( i , 0 ) ;
25090: LD_VAR 0 4
25094: PPUSH
25095: LD_INT 0
25097: PPUSH
25098: CALL_OW 109
25102: GO 25070
25104: POP
25105: POP
// end ;
25106: LD_VAR 0 3
25110: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25111: LD_INT 0
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
// if not mc_bases then
25121: LD_EXP 93
25125: NOT
25126: IFFALSE 25130
// exit ;
25128: GO 25588
// for i = 1 to mc_bases do
25130: LD_ADDR_VAR 0 2
25134: PUSH
25135: DOUBLE
25136: LD_INT 1
25138: DEC
25139: ST_TO_ADDR
25140: LD_EXP 93
25144: PUSH
25145: FOR_TO
25146: IFFALSE 25586
// begin tmp := MC_ClassCheckReq ( i ) ;
25148: LD_ADDR_VAR 0 4
25152: PUSH
25153: LD_VAR 0 2
25157: PPUSH
25158: CALL 25593 0 1
25162: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25163: LD_ADDR_EXP 134
25167: PUSH
25168: LD_EXP 134
25172: PPUSH
25173: LD_VAR 0 2
25177: PPUSH
25178: LD_VAR 0 4
25182: PPUSH
25183: CALL_OW 1
25187: ST_TO_ADDR
// if not tmp then
25188: LD_VAR 0 4
25192: NOT
25193: IFFALSE 25197
// continue ;
25195: GO 25145
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25197: LD_ADDR_VAR 0 6
25201: PUSH
25202: LD_EXP 93
25206: PUSH
25207: LD_VAR 0 2
25211: ARRAY
25212: PPUSH
25213: LD_INT 2
25215: PUSH
25216: LD_INT 30
25218: PUSH
25219: LD_INT 4
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 30
25228: PUSH
25229: LD_INT 5
25231: PUSH
25232: EMPTY
25233: LIST
25234: LIST
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: LIST
25240: PPUSH
25241: CALL_OW 72
25245: PUSH
25246: LD_EXP 93
25250: PUSH
25251: LD_VAR 0 2
25255: ARRAY
25256: PPUSH
25257: LD_INT 2
25259: PUSH
25260: LD_INT 30
25262: PUSH
25263: LD_INT 0
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 1
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: LIST
25284: PPUSH
25285: CALL_OW 72
25289: PUSH
25290: LD_EXP 93
25294: PUSH
25295: LD_VAR 0 2
25299: ARRAY
25300: PPUSH
25301: LD_INT 30
25303: PUSH
25304: LD_INT 3
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PPUSH
25311: CALL_OW 72
25315: PUSH
25316: LD_EXP 93
25320: PUSH
25321: LD_VAR 0 2
25325: ARRAY
25326: PPUSH
25327: LD_INT 2
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 6
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 30
25342: PUSH
25343: LD_INT 7
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 30
25352: PUSH
25353: LD_INT 8
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: LIST
25365: PPUSH
25366: CALL_OW 72
25370: PUSH
25371: EMPTY
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: ST_TO_ADDR
// for j = 1 to 4 do
25377: LD_ADDR_VAR 0 3
25381: PUSH
25382: DOUBLE
25383: LD_INT 1
25385: DEC
25386: ST_TO_ADDR
25387: LD_INT 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25582
// begin if not tmp [ j ] then
25393: LD_VAR 0 4
25397: PUSH
25398: LD_VAR 0 3
25402: ARRAY
25403: NOT
25404: IFFALSE 25408
// continue ;
25406: GO 25390
// for p in tmp [ j ] do
25408: LD_ADDR_VAR 0 5
25412: PUSH
25413: LD_VAR 0 4
25417: PUSH
25418: LD_VAR 0 3
25422: ARRAY
25423: PUSH
25424: FOR_IN
25425: IFFALSE 25578
// begin if not b [ j ] then
25427: LD_VAR 0 6
25431: PUSH
25432: LD_VAR 0 3
25436: ARRAY
25437: NOT
25438: IFFALSE 25442
// break ;
25440: GO 25578
// e := 0 ;
25442: LD_ADDR_VAR 0 7
25446: PUSH
25447: LD_INT 0
25449: ST_TO_ADDR
// for k in b [ j ] do
25450: LD_ADDR_VAR 0 8
25454: PUSH
25455: LD_VAR 0 6
25459: PUSH
25460: LD_VAR 0 3
25464: ARRAY
25465: PUSH
25466: FOR_IN
25467: IFFALSE 25494
// if IsNotFull ( k ) then
25469: LD_VAR 0 8
25473: PPUSH
25474: CALL 53557 0 1
25478: IFFALSE 25492
// begin e := k ;
25480: LD_ADDR_VAR 0 7
25484: PUSH
25485: LD_VAR 0 8
25489: ST_TO_ADDR
// break ;
25490: GO 25494
// end ;
25492: GO 25466
25494: POP
25495: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25496: LD_VAR 0 7
25500: PUSH
25501: LD_VAR 0 5
25505: PPUSH
25506: LD_VAR 0 7
25510: PPUSH
25511: CALL 86721 0 2
25515: NOT
25516: AND
25517: IFFALSE 25576
// begin if IsInUnit ( p ) then
25519: LD_VAR 0 5
25523: PPUSH
25524: CALL_OW 310
25528: IFFALSE 25539
// ComExitBuilding ( p ) ;
25530: LD_VAR 0 5
25534: PPUSH
25535: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25539: LD_VAR 0 5
25543: PPUSH
25544: LD_VAR 0 7
25548: PPUSH
25549: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25553: LD_VAR 0 5
25557: PPUSH
25558: LD_VAR 0 3
25562: PPUSH
25563: CALL_OW 183
// AddComExitBuilding ( p ) ;
25567: LD_VAR 0 5
25571: PPUSH
25572: CALL_OW 182
// end ; end ;
25576: GO 25424
25578: POP
25579: POP
// end ;
25580: GO 25390
25582: POP
25583: POP
// end ;
25584: GO 25145
25586: POP
25587: POP
// end ;
25588: LD_VAR 0 1
25592: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25593: LD_INT 0
25595: PPUSH
25596: PPUSH
25597: PPUSH
25598: PPUSH
25599: PPUSH
25600: PPUSH
25601: PPUSH
25602: PPUSH
25603: PPUSH
25604: PPUSH
25605: PPUSH
25606: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25607: LD_VAR 0 1
25611: NOT
25612: PUSH
25613: LD_EXP 93
25617: PUSH
25618: LD_VAR 0 1
25622: ARRAY
25623: NOT
25624: OR
25625: PUSH
25626: LD_EXP 93
25630: PUSH
25631: LD_VAR 0 1
25635: ARRAY
25636: PPUSH
25637: LD_INT 2
25639: PUSH
25640: LD_INT 30
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 30
25652: PUSH
25653: LD_INT 1
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: LIST
25664: PPUSH
25665: CALL_OW 72
25669: NOT
25670: OR
25671: IFFALSE 25675
// exit ;
25673: GO 29178
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25675: LD_ADDR_VAR 0 4
25679: PUSH
25680: LD_EXP 93
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: LD_INT 2
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 25
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: PUSH
25714: LD_INT 25
25716: PUSH
25717: LD_INT 3
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 25
25726: PUSH
25727: LD_INT 4
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 25
25736: PUSH
25737: LD_INT 5
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 25
25746: PUSH
25747: LD_INT 8
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 25
25756: PUSH
25757: LD_INT 9
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: PPUSH
25774: CALL_OW 72
25778: ST_TO_ADDR
// if not tmp then
25779: LD_VAR 0 4
25783: NOT
25784: IFFALSE 25788
// exit ;
25786: GO 29178
// for i in tmp do
25788: LD_ADDR_VAR 0 3
25792: PUSH
25793: LD_VAR 0 4
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25830
// if GetTag ( i ) then
25801: LD_VAR 0 3
25805: PPUSH
25806: CALL_OW 110
25810: IFFALSE 25828
// tmp := tmp diff i ;
25812: LD_ADDR_VAR 0 4
25816: PUSH
25817: LD_VAR 0 4
25821: PUSH
25822: LD_VAR 0 3
25826: DIFF
25827: ST_TO_ADDR
25828: GO 25798
25830: POP
25831: POP
// if not tmp then
25832: LD_VAR 0 4
25836: NOT
25837: IFFALSE 25841
// exit ;
25839: GO 29178
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25841: LD_ADDR_VAR 0 5
25845: PUSH
25846: LD_EXP 93
25850: PUSH
25851: LD_VAR 0 1
25855: ARRAY
25856: PPUSH
25857: LD_INT 2
25859: PUSH
25860: LD_INT 25
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 25
25872: PUSH
25873: LD_INT 5
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 25
25882: PUSH
25883: LD_INT 8
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 25
25892: PUSH
25893: LD_INT 9
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: PPUSH
25907: CALL_OW 72
25911: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25912: LD_ADDR_VAR 0 6
25916: PUSH
25917: LD_EXP 93
25921: PUSH
25922: LD_VAR 0 1
25926: ARRAY
25927: PPUSH
25928: LD_INT 25
25930: PUSH
25931: LD_INT 2
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25943: LD_ADDR_VAR 0 7
25947: PUSH
25948: LD_EXP 93
25952: PUSH
25953: LD_VAR 0 1
25957: ARRAY
25958: PPUSH
25959: LD_INT 25
25961: PUSH
25962: LD_INT 3
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PPUSH
25969: CALL_OW 72
25973: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25974: LD_ADDR_VAR 0 8
25978: PUSH
25979: LD_EXP 93
25983: PUSH
25984: LD_VAR 0 1
25988: ARRAY
25989: PPUSH
25990: LD_INT 25
25992: PUSH
25993: LD_INT 4
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 24
26002: PUSH
26003: LD_INT 251
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PPUSH
26014: CALL_OW 72
26018: ST_TO_ADDR
// if mc_is_defending [ base ] then
26019: LD_EXP 136
26023: PUSH
26024: LD_VAR 0 1
26028: ARRAY
26029: IFFALSE 26490
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26031: LD_ADDR_EXP 135
26035: PUSH
26036: LD_EXP 135
26040: PPUSH
26041: LD_VAR 0 1
26045: PPUSH
26046: LD_INT 4
26048: PPUSH
26049: CALL_OW 1
26053: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26054: LD_ADDR_VAR 0 12
26058: PUSH
26059: LD_EXP 93
26063: PUSH
26064: LD_VAR 0 1
26068: ARRAY
26069: PPUSH
26070: LD_INT 2
26072: PUSH
26073: LD_INT 30
26075: PUSH
26076: LD_INT 4
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 30
26085: PUSH
26086: LD_INT 5
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: LIST
26097: PPUSH
26098: CALL_OW 72
26102: ST_TO_ADDR
// if not b then
26103: LD_VAR 0 12
26107: NOT
26108: IFFALSE 26112
// exit ;
26110: GO 29178
// p := [ ] ;
26112: LD_ADDR_VAR 0 11
26116: PUSH
26117: EMPTY
26118: ST_TO_ADDR
// if sci >= 2 then
26119: LD_VAR 0 8
26123: PUSH
26124: LD_INT 2
26126: GREATEREQUAL
26127: IFFALSE 26158
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26129: LD_ADDR_VAR 0 8
26133: PUSH
26134: LD_VAR 0 8
26138: PUSH
26139: LD_INT 1
26141: ARRAY
26142: PUSH
26143: LD_VAR 0 8
26147: PUSH
26148: LD_INT 2
26150: ARRAY
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: ST_TO_ADDR
26156: GO 26219
// if sci = 1 then
26158: LD_VAR 0 8
26162: PUSH
26163: LD_INT 1
26165: EQUAL
26166: IFFALSE 26187
// sci := [ sci [ 1 ] ] else
26168: LD_ADDR_VAR 0 8
26172: PUSH
26173: LD_VAR 0 8
26177: PUSH
26178: LD_INT 1
26180: ARRAY
26181: PUSH
26182: EMPTY
26183: LIST
26184: ST_TO_ADDR
26185: GO 26219
// if sci = 0 then
26187: LD_VAR 0 8
26191: PUSH
26192: LD_INT 0
26194: EQUAL
26195: IFFALSE 26219
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26197: LD_ADDR_VAR 0 11
26201: PUSH
26202: LD_VAR 0 4
26206: PPUSH
26207: LD_INT 4
26209: PPUSH
26210: CALL 86584 0 2
26214: PUSH
26215: LD_INT 1
26217: ARRAY
26218: ST_TO_ADDR
// if eng > 4 then
26219: LD_VAR 0 6
26223: PUSH
26224: LD_INT 4
26226: GREATER
26227: IFFALSE 26273
// for i = eng downto 4 do
26229: LD_ADDR_VAR 0 3
26233: PUSH
26234: DOUBLE
26235: LD_VAR 0 6
26239: INC
26240: ST_TO_ADDR
26241: LD_INT 4
26243: PUSH
26244: FOR_DOWNTO
26245: IFFALSE 26271
// eng := eng diff eng [ i ] ;
26247: LD_ADDR_VAR 0 6
26251: PUSH
26252: LD_VAR 0 6
26256: PUSH
26257: LD_VAR 0 6
26261: PUSH
26262: LD_VAR 0 3
26266: ARRAY
26267: DIFF
26268: ST_TO_ADDR
26269: GO 26244
26271: POP
26272: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26273: LD_ADDR_VAR 0 4
26277: PUSH
26278: LD_VAR 0 4
26282: PUSH
26283: LD_VAR 0 5
26287: PUSH
26288: LD_VAR 0 6
26292: UNION
26293: PUSH
26294: LD_VAR 0 7
26298: UNION
26299: PUSH
26300: LD_VAR 0 8
26304: UNION
26305: DIFF
26306: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26307: LD_ADDR_VAR 0 13
26311: PUSH
26312: LD_EXP 93
26316: PUSH
26317: LD_VAR 0 1
26321: ARRAY
26322: PPUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: LD_INT 32
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 30
26338: PUSH
26339: LD_INT 31
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: PUSH
26356: LD_EXP 93
26360: PUSH
26361: LD_VAR 0 1
26365: ARRAY
26366: PPUSH
26367: LD_INT 2
26369: PUSH
26370: LD_INT 30
26372: PUSH
26373: LD_INT 4
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 30
26382: PUSH
26383: LD_INT 5
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: LIST
26394: PPUSH
26395: CALL_OW 72
26399: PUSH
26400: LD_INT 6
26402: MUL
26403: PLUS
26404: ST_TO_ADDR
// if bcount < tmp then
26405: LD_VAR 0 13
26409: PUSH
26410: LD_VAR 0 4
26414: LESS
26415: IFFALSE 26461
// for i = tmp downto bcount do
26417: LD_ADDR_VAR 0 3
26421: PUSH
26422: DOUBLE
26423: LD_VAR 0 4
26427: INC
26428: ST_TO_ADDR
26429: LD_VAR 0 13
26433: PUSH
26434: FOR_DOWNTO
26435: IFFALSE 26459
// tmp := Delete ( tmp , tmp ) ;
26437: LD_ADDR_VAR 0 4
26441: PUSH
26442: LD_VAR 0 4
26446: PPUSH
26447: LD_VAR 0 4
26451: PPUSH
26452: CALL_OW 3
26456: ST_TO_ADDR
26457: GO 26434
26459: POP
26460: POP
// result := [ tmp , 0 , 0 , p ] ;
26461: LD_ADDR_VAR 0 2
26465: PUSH
26466: LD_VAR 0 4
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: LD_VAR 0 11
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: ST_TO_ADDR
// exit ;
26488: GO 29178
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26490: LD_EXP 93
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: PPUSH
26501: LD_INT 2
26503: PUSH
26504: LD_INT 30
26506: PUSH
26507: LD_INT 6
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 7
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 30
26526: PUSH
26527: LD_INT 8
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: PPUSH
26540: CALL_OW 72
26544: NOT
26545: PUSH
26546: LD_EXP 93
26550: PUSH
26551: LD_VAR 0 1
26555: ARRAY
26556: PPUSH
26557: LD_INT 30
26559: PUSH
26560: LD_INT 3
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PPUSH
26567: CALL_OW 72
26571: NOT
26572: AND
26573: IFFALSE 26645
// begin if eng = tmp then
26575: LD_VAR 0 6
26579: PUSH
26580: LD_VAR 0 4
26584: EQUAL
26585: IFFALSE 26589
// exit ;
26587: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26589: LD_ADDR_EXP 135
26593: PUSH
26594: LD_EXP 135
26598: PPUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: LD_INT 1
26606: PPUSH
26607: CALL_OW 1
26611: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26612: LD_ADDR_VAR 0 2
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: LD_VAR 0 4
26624: PUSH
26625: LD_VAR 0 6
26629: DIFF
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: LD_INT 0
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: ST_TO_ADDR
// exit ;
26643: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26645: LD_EXP 120
26649: PUSH
26650: LD_EXP 119
26654: PUSH
26655: LD_VAR 0 1
26659: ARRAY
26660: ARRAY
26661: PUSH
26662: LD_EXP 93
26666: PUSH
26667: LD_VAR 0 1
26671: ARRAY
26672: PPUSH
26673: LD_INT 2
26675: PUSH
26676: LD_INT 30
26678: PUSH
26679: LD_INT 6
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 30
26688: PUSH
26689: LD_INT 7
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 30
26698: PUSH
26699: LD_INT 8
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: LIST
26710: LIST
26711: PPUSH
26712: CALL_OW 72
26716: AND
26717: PUSH
26718: LD_EXP 93
26722: PUSH
26723: LD_VAR 0 1
26727: ARRAY
26728: PPUSH
26729: LD_INT 30
26731: PUSH
26732: LD_INT 3
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL_OW 72
26743: NOT
26744: AND
26745: IFFALSE 26959
// begin if sci >= 6 then
26747: LD_VAR 0 8
26751: PUSH
26752: LD_INT 6
26754: GREATEREQUAL
26755: IFFALSE 26759
// exit ;
26757: GO 29178
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26759: LD_ADDR_EXP 135
26763: PUSH
26764: LD_EXP 135
26768: PPUSH
26769: LD_VAR 0 1
26773: PPUSH
26774: LD_INT 2
26776: PPUSH
26777: CALL_OW 1
26781: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26782: LD_ADDR_VAR 0 9
26786: PUSH
26787: LD_VAR 0 4
26791: PUSH
26792: LD_VAR 0 8
26796: DIFF
26797: PPUSH
26798: LD_INT 4
26800: PPUSH
26801: CALL 86584 0 2
26805: ST_TO_ADDR
// p := [ ] ;
26806: LD_ADDR_VAR 0 11
26810: PUSH
26811: EMPTY
26812: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26813: LD_VAR 0 8
26817: PUSH
26818: LD_INT 6
26820: LESS
26821: PUSH
26822: LD_VAR 0 9
26826: PUSH
26827: LD_INT 6
26829: GREATER
26830: AND
26831: IFFALSE 26912
// begin for i = 1 to 6 - sci do
26833: LD_ADDR_VAR 0 3
26837: PUSH
26838: DOUBLE
26839: LD_INT 1
26841: DEC
26842: ST_TO_ADDR
26843: LD_INT 6
26845: PUSH
26846: LD_VAR 0 8
26850: MINUS
26851: PUSH
26852: FOR_TO
26853: IFFALSE 26908
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26855: LD_ADDR_VAR 0 11
26859: PUSH
26860: LD_VAR 0 11
26864: PPUSH
26865: LD_VAR 0 11
26869: PUSH
26870: LD_INT 1
26872: PLUS
26873: PPUSH
26874: LD_VAR 0 9
26878: PUSH
26879: LD_INT 1
26881: ARRAY
26882: PPUSH
26883: CALL_OW 2
26887: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26888: LD_ADDR_VAR 0 9
26892: PUSH
26893: LD_VAR 0 9
26897: PPUSH
26898: LD_INT 1
26900: PPUSH
26901: CALL_OW 3
26905: ST_TO_ADDR
// end ;
26906: GO 26852
26908: POP
26909: POP
// end else
26910: GO 26932
// if sort then
26912: LD_VAR 0 9
26916: IFFALSE 26932
// p := sort [ 1 ] ;
26918: LD_ADDR_VAR 0 11
26922: PUSH
26923: LD_VAR 0 9
26927: PUSH
26928: LD_INT 1
26930: ARRAY
26931: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26932: LD_ADDR_VAR 0 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: LD_INT 0
26945: PUSH
26946: LD_VAR 0 11
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: ST_TO_ADDR
// exit ;
26957: GO 29178
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26959: LD_EXP 120
26963: PUSH
26964: LD_EXP 119
26968: PUSH
26969: LD_VAR 0 1
26973: ARRAY
26974: ARRAY
26975: PUSH
26976: LD_EXP 93
26980: PUSH
26981: LD_VAR 0 1
26985: ARRAY
26986: PPUSH
26987: LD_INT 2
26989: PUSH
26990: LD_INT 30
26992: PUSH
26993: LD_INT 6
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 30
27002: PUSH
27003: LD_INT 7
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 30
27012: PUSH
27013: LD_INT 8
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: PPUSH
27026: CALL_OW 72
27030: AND
27031: PUSH
27032: LD_EXP 93
27036: PUSH
27037: LD_VAR 0 1
27041: ARRAY
27042: PPUSH
27043: LD_INT 30
27045: PUSH
27046: LD_INT 3
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PPUSH
27053: CALL_OW 72
27057: AND
27058: IFFALSE 27792
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27060: LD_ADDR_EXP 135
27064: PUSH
27065: LD_EXP 135
27069: PPUSH
27070: LD_VAR 0 1
27074: PPUSH
27075: LD_INT 3
27077: PPUSH
27078: CALL_OW 1
27082: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27083: LD_ADDR_VAR 0 2
27087: PUSH
27088: LD_INT 0
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 0
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: ST_TO_ADDR
// if not eng then
27106: LD_VAR 0 6
27110: NOT
27111: IFFALSE 27174
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27113: LD_ADDR_VAR 0 11
27117: PUSH
27118: LD_VAR 0 4
27122: PPUSH
27123: LD_INT 2
27125: PPUSH
27126: CALL 86584 0 2
27130: PUSH
27131: LD_INT 1
27133: ARRAY
27134: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27135: LD_ADDR_VAR 0 2
27139: PUSH
27140: LD_VAR 0 2
27144: PPUSH
27145: LD_INT 2
27147: PPUSH
27148: LD_VAR 0 11
27152: PPUSH
27153: CALL_OW 1
27157: ST_TO_ADDR
// tmp := tmp diff p ;
27158: LD_ADDR_VAR 0 4
27162: PUSH
27163: LD_VAR 0 4
27167: PUSH
27168: LD_VAR 0 11
27172: DIFF
27173: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27174: LD_VAR 0 4
27178: PUSH
27179: LD_VAR 0 8
27183: PUSH
27184: LD_INT 6
27186: LESS
27187: AND
27188: IFFALSE 27376
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27190: LD_ADDR_VAR 0 9
27194: PUSH
27195: LD_VAR 0 4
27199: PUSH
27200: LD_VAR 0 8
27204: PUSH
27205: LD_VAR 0 7
27209: UNION
27210: DIFF
27211: PPUSH
27212: LD_INT 4
27214: PPUSH
27215: CALL 86584 0 2
27219: ST_TO_ADDR
// p := [ ] ;
27220: LD_ADDR_VAR 0 11
27224: PUSH
27225: EMPTY
27226: ST_TO_ADDR
// if sort then
27227: LD_VAR 0 9
27231: IFFALSE 27347
// for i = 1 to 6 - sci do
27233: LD_ADDR_VAR 0 3
27237: PUSH
27238: DOUBLE
27239: LD_INT 1
27241: DEC
27242: ST_TO_ADDR
27243: LD_INT 6
27245: PUSH
27246: LD_VAR 0 8
27250: MINUS
27251: PUSH
27252: FOR_TO
27253: IFFALSE 27345
// begin if i = sort then
27255: LD_VAR 0 3
27259: PUSH
27260: LD_VAR 0 9
27264: EQUAL
27265: IFFALSE 27269
// break ;
27267: GO 27345
// if GetClass ( i ) = 4 then
27269: LD_VAR 0 3
27273: PPUSH
27274: CALL_OW 257
27278: PUSH
27279: LD_INT 4
27281: EQUAL
27282: IFFALSE 27286
// continue ;
27284: GO 27252
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27286: LD_ADDR_VAR 0 11
27290: PUSH
27291: LD_VAR 0 11
27295: PPUSH
27296: LD_VAR 0 11
27300: PUSH
27301: LD_INT 1
27303: PLUS
27304: PPUSH
27305: LD_VAR 0 9
27309: PUSH
27310: LD_VAR 0 3
27314: ARRAY
27315: PPUSH
27316: CALL_OW 2
27320: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27321: LD_ADDR_VAR 0 4
27325: PUSH
27326: LD_VAR 0 4
27330: PUSH
27331: LD_VAR 0 9
27335: PUSH
27336: LD_VAR 0 3
27340: ARRAY
27341: DIFF
27342: ST_TO_ADDR
// end ;
27343: GO 27252
27345: POP
27346: POP
// if p then
27347: LD_VAR 0 11
27351: IFFALSE 27376
// result := Replace ( result , 4 , p ) ;
27353: LD_ADDR_VAR 0 2
27357: PUSH
27358: LD_VAR 0 2
27362: PPUSH
27363: LD_INT 4
27365: PPUSH
27366: LD_VAR 0 11
27370: PPUSH
27371: CALL_OW 1
27375: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27376: LD_VAR 0 4
27380: PUSH
27381: LD_VAR 0 7
27385: PUSH
27386: LD_INT 6
27388: LESS
27389: AND
27390: IFFALSE 27578
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27392: LD_ADDR_VAR 0 9
27396: PUSH
27397: LD_VAR 0 4
27401: PUSH
27402: LD_VAR 0 8
27406: PUSH
27407: LD_VAR 0 7
27411: UNION
27412: DIFF
27413: PPUSH
27414: LD_INT 3
27416: PPUSH
27417: CALL 86584 0 2
27421: ST_TO_ADDR
// p := [ ] ;
27422: LD_ADDR_VAR 0 11
27426: PUSH
27427: EMPTY
27428: ST_TO_ADDR
// if sort then
27429: LD_VAR 0 9
27433: IFFALSE 27549
// for i = 1 to 6 - mech do
27435: LD_ADDR_VAR 0 3
27439: PUSH
27440: DOUBLE
27441: LD_INT 1
27443: DEC
27444: ST_TO_ADDR
27445: LD_INT 6
27447: PUSH
27448: LD_VAR 0 7
27452: MINUS
27453: PUSH
27454: FOR_TO
27455: IFFALSE 27547
// begin if i = sort then
27457: LD_VAR 0 3
27461: PUSH
27462: LD_VAR 0 9
27466: EQUAL
27467: IFFALSE 27471
// break ;
27469: GO 27547
// if GetClass ( i ) = 3 then
27471: LD_VAR 0 3
27475: PPUSH
27476: CALL_OW 257
27480: PUSH
27481: LD_INT 3
27483: EQUAL
27484: IFFALSE 27488
// continue ;
27486: GO 27454
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27488: LD_ADDR_VAR 0 11
27492: PUSH
27493: LD_VAR 0 11
27497: PPUSH
27498: LD_VAR 0 11
27502: PUSH
27503: LD_INT 1
27505: PLUS
27506: PPUSH
27507: LD_VAR 0 9
27511: PUSH
27512: LD_VAR 0 3
27516: ARRAY
27517: PPUSH
27518: CALL_OW 2
27522: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27523: LD_ADDR_VAR 0 4
27527: PUSH
27528: LD_VAR 0 4
27532: PUSH
27533: LD_VAR 0 9
27537: PUSH
27538: LD_VAR 0 3
27542: ARRAY
27543: DIFF
27544: ST_TO_ADDR
// end ;
27545: GO 27454
27547: POP
27548: POP
// if p then
27549: LD_VAR 0 11
27553: IFFALSE 27578
// result := Replace ( result , 3 , p ) ;
27555: LD_ADDR_VAR 0 2
27559: PUSH
27560: LD_VAR 0 2
27564: PPUSH
27565: LD_INT 3
27567: PPUSH
27568: LD_VAR 0 11
27572: PPUSH
27573: CALL_OW 1
27577: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27578: LD_VAR 0 4
27582: PUSH
27583: LD_INT 6
27585: GREATER
27586: PUSH
27587: LD_VAR 0 6
27591: PUSH
27592: LD_INT 6
27594: LESS
27595: AND
27596: IFFALSE 27790
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27598: LD_ADDR_VAR 0 9
27602: PUSH
27603: LD_VAR 0 4
27607: PUSH
27608: LD_VAR 0 8
27612: PUSH
27613: LD_VAR 0 7
27617: UNION
27618: PUSH
27619: LD_VAR 0 6
27623: UNION
27624: DIFF
27625: PPUSH
27626: LD_INT 2
27628: PPUSH
27629: CALL 86584 0 2
27633: ST_TO_ADDR
// p := [ ] ;
27634: LD_ADDR_VAR 0 11
27638: PUSH
27639: EMPTY
27640: ST_TO_ADDR
// if sort then
27641: LD_VAR 0 9
27645: IFFALSE 27761
// for i = 1 to 6 - eng do
27647: LD_ADDR_VAR 0 3
27651: PUSH
27652: DOUBLE
27653: LD_INT 1
27655: DEC
27656: ST_TO_ADDR
27657: LD_INT 6
27659: PUSH
27660: LD_VAR 0 6
27664: MINUS
27665: PUSH
27666: FOR_TO
27667: IFFALSE 27759
// begin if i = sort then
27669: LD_VAR 0 3
27673: PUSH
27674: LD_VAR 0 9
27678: EQUAL
27679: IFFALSE 27683
// break ;
27681: GO 27759
// if GetClass ( i ) = 2 then
27683: LD_VAR 0 3
27687: PPUSH
27688: CALL_OW 257
27692: PUSH
27693: LD_INT 2
27695: EQUAL
27696: IFFALSE 27700
// continue ;
27698: GO 27666
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27700: LD_ADDR_VAR 0 11
27704: PUSH
27705: LD_VAR 0 11
27709: PPUSH
27710: LD_VAR 0 11
27714: PUSH
27715: LD_INT 1
27717: PLUS
27718: PPUSH
27719: LD_VAR 0 9
27723: PUSH
27724: LD_VAR 0 3
27728: ARRAY
27729: PPUSH
27730: CALL_OW 2
27734: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27735: LD_ADDR_VAR 0 4
27739: PUSH
27740: LD_VAR 0 4
27744: PUSH
27745: LD_VAR 0 9
27749: PUSH
27750: LD_VAR 0 3
27754: ARRAY
27755: DIFF
27756: ST_TO_ADDR
// end ;
27757: GO 27666
27759: POP
27760: POP
// if p then
27761: LD_VAR 0 11
27765: IFFALSE 27790
// result := Replace ( result , 2 , p ) ;
27767: LD_ADDR_VAR 0 2
27771: PUSH
27772: LD_VAR 0 2
27776: PPUSH
27777: LD_INT 2
27779: PPUSH
27780: LD_VAR 0 11
27784: PPUSH
27785: CALL_OW 1
27789: ST_TO_ADDR
// end ; exit ;
27790: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27792: LD_EXP 120
27796: PUSH
27797: LD_EXP 119
27801: PUSH
27802: LD_VAR 0 1
27806: ARRAY
27807: ARRAY
27808: NOT
27809: PUSH
27810: LD_EXP 93
27814: PUSH
27815: LD_VAR 0 1
27819: ARRAY
27820: PPUSH
27821: LD_INT 30
27823: PUSH
27824: LD_INT 3
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 72
27835: AND
27836: PUSH
27837: LD_EXP 98
27841: PUSH
27842: LD_VAR 0 1
27846: ARRAY
27847: AND
27848: IFFALSE 28456
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27850: LD_ADDR_EXP 135
27854: PUSH
27855: LD_EXP 135
27859: PPUSH
27860: LD_VAR 0 1
27864: PPUSH
27865: LD_INT 5
27867: PPUSH
27868: CALL_OW 1
27872: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27873: LD_ADDR_VAR 0 2
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 0
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: ST_TO_ADDR
// if sci > 1 then
27896: LD_VAR 0 8
27900: PUSH
27901: LD_INT 1
27903: GREATER
27904: IFFALSE 27932
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27906: LD_ADDR_VAR 0 4
27910: PUSH
27911: LD_VAR 0 4
27915: PUSH
27916: LD_VAR 0 8
27920: PUSH
27921: LD_VAR 0 8
27925: PUSH
27926: LD_INT 1
27928: ARRAY
27929: DIFF
27930: DIFF
27931: ST_TO_ADDR
// if tmp and not sci then
27932: LD_VAR 0 4
27936: PUSH
27937: LD_VAR 0 8
27941: NOT
27942: AND
27943: IFFALSE 28012
// begin sort := SortBySkill ( tmp , 4 ) ;
27945: LD_ADDR_VAR 0 9
27949: PUSH
27950: LD_VAR 0 4
27954: PPUSH
27955: LD_INT 4
27957: PPUSH
27958: CALL 86584 0 2
27962: ST_TO_ADDR
// if sort then
27963: LD_VAR 0 9
27967: IFFALSE 27983
// p := sort [ 1 ] ;
27969: LD_ADDR_VAR 0 11
27973: PUSH
27974: LD_VAR 0 9
27978: PUSH
27979: LD_INT 1
27981: ARRAY
27982: ST_TO_ADDR
// if p then
27983: LD_VAR 0 11
27987: IFFALSE 28012
// result := Replace ( result , 4 , p ) ;
27989: LD_ADDR_VAR 0 2
27993: PUSH
27994: LD_VAR 0 2
27998: PPUSH
27999: LD_INT 4
28001: PPUSH
28002: LD_VAR 0 11
28006: PPUSH
28007: CALL_OW 1
28011: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28012: LD_ADDR_VAR 0 4
28016: PUSH
28017: LD_VAR 0 4
28021: PUSH
28022: LD_VAR 0 7
28026: DIFF
28027: ST_TO_ADDR
// if tmp and mech < 6 then
28028: LD_VAR 0 4
28032: PUSH
28033: LD_VAR 0 7
28037: PUSH
28038: LD_INT 6
28040: LESS
28041: AND
28042: IFFALSE 28230
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28044: LD_ADDR_VAR 0 9
28048: PUSH
28049: LD_VAR 0 4
28053: PUSH
28054: LD_VAR 0 8
28058: PUSH
28059: LD_VAR 0 7
28063: UNION
28064: DIFF
28065: PPUSH
28066: LD_INT 3
28068: PPUSH
28069: CALL 86584 0 2
28073: ST_TO_ADDR
// p := [ ] ;
28074: LD_ADDR_VAR 0 11
28078: PUSH
28079: EMPTY
28080: ST_TO_ADDR
// if sort then
28081: LD_VAR 0 9
28085: IFFALSE 28201
// for i = 1 to 6 - mech do
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: DOUBLE
28093: LD_INT 1
28095: DEC
28096: ST_TO_ADDR
28097: LD_INT 6
28099: PUSH
28100: LD_VAR 0 7
28104: MINUS
28105: PUSH
28106: FOR_TO
28107: IFFALSE 28199
// begin if i = sort then
28109: LD_VAR 0 3
28113: PUSH
28114: LD_VAR 0 9
28118: EQUAL
28119: IFFALSE 28123
// break ;
28121: GO 28199
// if GetClass ( i ) = 3 then
28123: LD_VAR 0 3
28127: PPUSH
28128: CALL_OW 257
28132: PUSH
28133: LD_INT 3
28135: EQUAL
28136: IFFALSE 28140
// continue ;
28138: GO 28106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28140: LD_ADDR_VAR 0 11
28144: PUSH
28145: LD_VAR 0 11
28149: PPUSH
28150: LD_VAR 0 11
28154: PUSH
28155: LD_INT 1
28157: PLUS
28158: PPUSH
28159: LD_VAR 0 9
28163: PUSH
28164: LD_VAR 0 3
28168: ARRAY
28169: PPUSH
28170: CALL_OW 2
28174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28175: LD_ADDR_VAR 0 4
28179: PUSH
28180: LD_VAR 0 4
28184: PUSH
28185: LD_VAR 0 9
28189: PUSH
28190: LD_VAR 0 3
28194: ARRAY
28195: DIFF
28196: ST_TO_ADDR
// end ;
28197: GO 28106
28199: POP
28200: POP
// if p then
28201: LD_VAR 0 11
28205: IFFALSE 28230
// result := Replace ( result , 3 , p ) ;
28207: LD_ADDR_VAR 0 2
28211: PUSH
28212: LD_VAR 0 2
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_VAR 0 11
28224: PPUSH
28225: CALL_OW 1
28229: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28230: LD_ADDR_VAR 0 4
28234: PUSH
28235: LD_VAR 0 4
28239: PUSH
28240: LD_VAR 0 6
28244: DIFF
28245: ST_TO_ADDR
// if tmp and eng < 6 then
28246: LD_VAR 0 4
28250: PUSH
28251: LD_VAR 0 6
28255: PUSH
28256: LD_INT 6
28258: LESS
28259: AND
28260: IFFALSE 28454
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28262: LD_ADDR_VAR 0 9
28266: PUSH
28267: LD_VAR 0 4
28271: PUSH
28272: LD_VAR 0 8
28276: PUSH
28277: LD_VAR 0 7
28281: UNION
28282: PUSH
28283: LD_VAR 0 6
28287: UNION
28288: DIFF
28289: PPUSH
28290: LD_INT 2
28292: PPUSH
28293: CALL 86584 0 2
28297: ST_TO_ADDR
// p := [ ] ;
28298: LD_ADDR_VAR 0 11
28302: PUSH
28303: EMPTY
28304: ST_TO_ADDR
// if sort then
28305: LD_VAR 0 9
28309: IFFALSE 28425
// for i = 1 to 6 - eng do
28311: LD_ADDR_VAR 0 3
28315: PUSH
28316: DOUBLE
28317: LD_INT 1
28319: DEC
28320: ST_TO_ADDR
28321: LD_INT 6
28323: PUSH
28324: LD_VAR 0 6
28328: MINUS
28329: PUSH
28330: FOR_TO
28331: IFFALSE 28423
// begin if i = sort then
28333: LD_VAR 0 3
28337: PUSH
28338: LD_VAR 0 9
28342: EQUAL
28343: IFFALSE 28347
// break ;
28345: GO 28423
// if GetClass ( i ) = 2 then
28347: LD_VAR 0 3
28351: PPUSH
28352: CALL_OW 257
28356: PUSH
28357: LD_INT 2
28359: EQUAL
28360: IFFALSE 28364
// continue ;
28362: GO 28330
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28364: LD_ADDR_VAR 0 11
28368: PUSH
28369: LD_VAR 0 11
28373: PPUSH
28374: LD_VAR 0 11
28378: PUSH
28379: LD_INT 1
28381: PLUS
28382: PPUSH
28383: LD_VAR 0 9
28387: PUSH
28388: LD_VAR 0 3
28392: ARRAY
28393: PPUSH
28394: CALL_OW 2
28398: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28399: LD_ADDR_VAR 0 4
28403: PUSH
28404: LD_VAR 0 4
28408: PUSH
28409: LD_VAR 0 9
28413: PUSH
28414: LD_VAR 0 3
28418: ARRAY
28419: DIFF
28420: ST_TO_ADDR
// end ;
28421: GO 28330
28423: POP
28424: POP
// if p then
28425: LD_VAR 0 11
28429: IFFALSE 28454
// result := Replace ( result , 2 , p ) ;
28431: LD_ADDR_VAR 0 2
28435: PUSH
28436: LD_VAR 0 2
28440: PPUSH
28441: LD_INT 2
28443: PPUSH
28444: LD_VAR 0 11
28448: PPUSH
28449: CALL_OW 1
28453: ST_TO_ADDR
// end ; exit ;
28454: GO 29178
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28456: LD_EXP 120
28460: PUSH
28461: LD_EXP 119
28465: PUSH
28466: LD_VAR 0 1
28470: ARRAY
28471: ARRAY
28472: NOT
28473: PUSH
28474: LD_EXP 93
28478: PUSH
28479: LD_VAR 0 1
28483: ARRAY
28484: PPUSH
28485: LD_INT 30
28487: PUSH
28488: LD_INT 3
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PPUSH
28495: CALL_OW 72
28499: AND
28500: PUSH
28501: LD_EXP 98
28505: PUSH
28506: LD_VAR 0 1
28510: ARRAY
28511: NOT
28512: AND
28513: IFFALSE 29178
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28515: LD_ADDR_EXP 135
28519: PUSH
28520: LD_EXP 135
28524: PPUSH
28525: LD_VAR 0 1
28529: PPUSH
28530: LD_INT 6
28532: PPUSH
28533: CALL_OW 1
28537: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28538: LD_ADDR_VAR 0 2
28542: PUSH
28543: LD_INT 0
28545: PUSH
28546: LD_INT 0
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: ST_TO_ADDR
// if sci >= 1 then
28561: LD_VAR 0 8
28565: PUSH
28566: LD_INT 1
28568: GREATEREQUAL
28569: IFFALSE 28591
// tmp := tmp diff sci [ 1 ] ;
28571: LD_ADDR_VAR 0 4
28575: PUSH
28576: LD_VAR 0 4
28580: PUSH
28581: LD_VAR 0 8
28585: PUSH
28586: LD_INT 1
28588: ARRAY
28589: DIFF
28590: ST_TO_ADDR
// if tmp and not sci then
28591: LD_VAR 0 4
28595: PUSH
28596: LD_VAR 0 8
28600: NOT
28601: AND
28602: IFFALSE 28671
// begin sort := SortBySkill ( tmp , 4 ) ;
28604: LD_ADDR_VAR 0 9
28608: PUSH
28609: LD_VAR 0 4
28613: PPUSH
28614: LD_INT 4
28616: PPUSH
28617: CALL 86584 0 2
28621: ST_TO_ADDR
// if sort then
28622: LD_VAR 0 9
28626: IFFALSE 28642
// p := sort [ 1 ] ;
28628: LD_ADDR_VAR 0 11
28632: PUSH
28633: LD_VAR 0 9
28637: PUSH
28638: LD_INT 1
28640: ARRAY
28641: ST_TO_ADDR
// if p then
28642: LD_VAR 0 11
28646: IFFALSE 28671
// result := Replace ( result , 4 , p ) ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_VAR 0 2
28657: PPUSH
28658: LD_INT 4
28660: PPUSH
28661: LD_VAR 0 11
28665: PPUSH
28666: CALL_OW 1
28670: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 4
28680: PUSH
28681: LD_VAR 0 7
28685: DIFF
28686: ST_TO_ADDR
// if tmp and mech < 6 then
28687: LD_VAR 0 4
28691: PUSH
28692: LD_VAR 0 7
28696: PUSH
28697: LD_INT 6
28699: LESS
28700: AND
28701: IFFALSE 28883
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28703: LD_ADDR_VAR 0 9
28707: PUSH
28708: LD_VAR 0 4
28712: PUSH
28713: LD_VAR 0 7
28717: DIFF
28718: PPUSH
28719: LD_INT 3
28721: PPUSH
28722: CALL 86584 0 2
28726: ST_TO_ADDR
// p := [ ] ;
28727: LD_ADDR_VAR 0 11
28731: PUSH
28732: EMPTY
28733: ST_TO_ADDR
// if sort then
28734: LD_VAR 0 9
28738: IFFALSE 28854
// for i = 1 to 6 - mech do
28740: LD_ADDR_VAR 0 3
28744: PUSH
28745: DOUBLE
28746: LD_INT 1
28748: DEC
28749: ST_TO_ADDR
28750: LD_INT 6
28752: PUSH
28753: LD_VAR 0 7
28757: MINUS
28758: PUSH
28759: FOR_TO
28760: IFFALSE 28852
// begin if i = sort then
28762: LD_VAR 0 3
28766: PUSH
28767: LD_VAR 0 9
28771: EQUAL
28772: IFFALSE 28776
// break ;
28774: GO 28852
// if GetClass ( i ) = 3 then
28776: LD_VAR 0 3
28780: PPUSH
28781: CALL_OW 257
28785: PUSH
28786: LD_INT 3
28788: EQUAL
28789: IFFALSE 28793
// continue ;
28791: GO 28759
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28793: LD_ADDR_VAR 0 11
28797: PUSH
28798: LD_VAR 0 11
28802: PPUSH
28803: LD_VAR 0 11
28807: PUSH
28808: LD_INT 1
28810: PLUS
28811: PPUSH
28812: LD_VAR 0 9
28816: PUSH
28817: LD_VAR 0 3
28821: ARRAY
28822: PPUSH
28823: CALL_OW 2
28827: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28828: LD_ADDR_VAR 0 4
28832: PUSH
28833: LD_VAR 0 4
28837: PUSH
28838: LD_VAR 0 9
28842: PUSH
28843: LD_VAR 0 3
28847: ARRAY
28848: DIFF
28849: ST_TO_ADDR
// end ;
28850: GO 28759
28852: POP
28853: POP
// if p then
28854: LD_VAR 0 11
28858: IFFALSE 28883
// result := Replace ( result , 3 , p ) ;
28860: LD_ADDR_VAR 0 2
28864: PUSH
28865: LD_VAR 0 2
28869: PPUSH
28870: LD_INT 3
28872: PPUSH
28873: LD_VAR 0 11
28877: PPUSH
28878: CALL_OW 1
28882: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28883: LD_ADDR_VAR 0 4
28887: PUSH
28888: LD_VAR 0 4
28892: PUSH
28893: LD_VAR 0 6
28897: DIFF
28898: ST_TO_ADDR
// if tmp and eng < 4 then
28899: LD_VAR 0 4
28903: PUSH
28904: LD_VAR 0 6
28908: PUSH
28909: LD_INT 4
28911: LESS
28912: AND
28913: IFFALSE 29103
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28915: LD_ADDR_VAR 0 9
28919: PUSH
28920: LD_VAR 0 4
28924: PUSH
28925: LD_VAR 0 7
28929: PUSH
28930: LD_VAR 0 6
28934: UNION
28935: DIFF
28936: PPUSH
28937: LD_INT 2
28939: PPUSH
28940: CALL 86584 0 2
28944: ST_TO_ADDR
// p := [ ] ;
28945: LD_ADDR_VAR 0 11
28949: PUSH
28950: EMPTY
28951: ST_TO_ADDR
// if sort then
28952: LD_VAR 0 9
28956: IFFALSE 29072
// for i = 1 to 4 - eng do
28958: LD_ADDR_VAR 0 3
28962: PUSH
28963: DOUBLE
28964: LD_INT 1
28966: DEC
28967: ST_TO_ADDR
28968: LD_INT 4
28970: PUSH
28971: LD_VAR 0 6
28975: MINUS
28976: PUSH
28977: FOR_TO
28978: IFFALSE 29070
// begin if i = sort then
28980: LD_VAR 0 3
28984: PUSH
28985: LD_VAR 0 9
28989: EQUAL
28990: IFFALSE 28994
// break ;
28992: GO 29070
// if GetClass ( i ) = 2 then
28994: LD_VAR 0 3
28998: PPUSH
28999: CALL_OW 257
29003: PUSH
29004: LD_INT 2
29006: EQUAL
29007: IFFALSE 29011
// continue ;
29009: GO 28977
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29011: LD_ADDR_VAR 0 11
29015: PUSH
29016: LD_VAR 0 11
29020: PPUSH
29021: LD_VAR 0 11
29025: PUSH
29026: LD_INT 1
29028: PLUS
29029: PPUSH
29030: LD_VAR 0 9
29034: PUSH
29035: LD_VAR 0 3
29039: ARRAY
29040: PPUSH
29041: CALL_OW 2
29045: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29046: LD_ADDR_VAR 0 4
29050: PUSH
29051: LD_VAR 0 4
29055: PUSH
29056: LD_VAR 0 9
29060: PUSH
29061: LD_VAR 0 3
29065: ARRAY
29066: DIFF
29067: ST_TO_ADDR
// end ;
29068: GO 28977
29070: POP
29071: POP
// if p then
29072: LD_VAR 0 11
29076: IFFALSE 29101
// result := Replace ( result , 2 , p ) ;
29078: LD_ADDR_VAR 0 2
29082: PUSH
29083: LD_VAR 0 2
29087: PPUSH
29088: LD_INT 2
29090: PPUSH
29091: LD_VAR 0 11
29095: PPUSH
29096: CALL_OW 1
29100: ST_TO_ADDR
// end else
29101: GO 29147
// for i = eng downto 5 do
29103: LD_ADDR_VAR 0 3
29107: PUSH
29108: DOUBLE
29109: LD_VAR 0 6
29113: INC
29114: ST_TO_ADDR
29115: LD_INT 5
29117: PUSH
29118: FOR_DOWNTO
29119: IFFALSE 29145
// tmp := tmp union eng [ i ] ;
29121: LD_ADDR_VAR 0 4
29125: PUSH
29126: LD_VAR 0 4
29130: PUSH
29131: LD_VAR 0 6
29135: PUSH
29136: LD_VAR 0 3
29140: ARRAY
29141: UNION
29142: ST_TO_ADDR
29143: GO 29118
29145: POP
29146: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29147: LD_ADDR_VAR 0 2
29151: PUSH
29152: LD_VAR 0 2
29156: PPUSH
29157: LD_INT 1
29159: PPUSH
29160: LD_VAR 0 4
29164: PUSH
29165: LD_VAR 0 5
29169: DIFF
29170: PPUSH
29171: CALL_OW 1
29175: ST_TO_ADDR
// exit ;
29176: GO 29178
// end ; end ;
29178: LD_VAR 0 2
29182: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29183: LD_INT 0
29185: PPUSH
29186: PPUSH
29187: PPUSH
// if not mc_bases then
29188: LD_EXP 93
29192: NOT
29193: IFFALSE 29197
// exit ;
29195: GO 29339
// for i = 1 to mc_bases do
29197: LD_ADDR_VAR 0 2
29201: PUSH
29202: DOUBLE
29203: LD_INT 1
29205: DEC
29206: ST_TO_ADDR
29207: LD_EXP 93
29211: PUSH
29212: FOR_TO
29213: IFFALSE 29330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29215: LD_ADDR_VAR 0 3
29219: PUSH
29220: LD_EXP 93
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: LD_INT 21
29233: PUSH
29234: LD_INT 3
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 3
29243: PUSH
29244: LD_INT 2
29246: PUSH
29247: LD_INT 30
29249: PUSH
29250: LD_INT 29
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 30
29259: PUSH
29260: LD_INT 30
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: LIST
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PUSH
29276: LD_INT 3
29278: PUSH
29279: LD_INT 24
29281: PUSH
29282: LD_INT 1000
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: LIST
29297: PPUSH
29298: CALL_OW 72
29302: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29303: LD_ADDR_EXP 94
29307: PUSH
29308: LD_EXP 94
29312: PPUSH
29313: LD_VAR 0 2
29317: PPUSH
29318: LD_VAR 0 3
29322: PPUSH
29323: CALL_OW 1
29327: ST_TO_ADDR
// end ;
29328: GO 29212
29330: POP
29331: POP
// RaiseSailEvent ( 101 ) ;
29332: LD_INT 101
29334: PPUSH
29335: CALL_OW 427
// end ;
29339: LD_VAR 0 1
29343: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29344: LD_INT 0
29346: PPUSH
29347: PPUSH
29348: PPUSH
29349: PPUSH
29350: PPUSH
29351: PPUSH
29352: PPUSH
// if not mc_bases then
29353: LD_EXP 93
29357: NOT
29358: IFFALSE 29362
// exit ;
29360: GO 29924
// for i = 1 to mc_bases do
29362: LD_ADDR_VAR 0 2
29366: PUSH
29367: DOUBLE
29368: LD_INT 1
29370: DEC
29371: ST_TO_ADDR
29372: LD_EXP 93
29376: PUSH
29377: FOR_TO
29378: IFFALSE 29915
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29380: LD_ADDR_VAR 0 5
29384: PUSH
29385: LD_EXP 93
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_EXP 122
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: UNION
29407: PPUSH
29408: LD_INT 21
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 1
29420: PUSH
29421: LD_INT 3
29423: PUSH
29424: LD_INT 54
29426: PUSH
29427: EMPTY
29428: LIST
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 3
29436: PUSH
29437: LD_INT 24
29439: PUSH
29440: LD_INT 1000
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: LIST
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 72
29464: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29465: LD_ADDR_VAR 0 6
29469: PUSH
29470: LD_EXP 93
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PPUSH
29481: LD_INT 21
29483: PUSH
29484: LD_INT 1
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: LD_INT 1
29493: PUSH
29494: LD_INT 3
29496: PUSH
29497: LD_INT 54
29499: PUSH
29500: EMPTY
29501: LIST
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 3
29509: PUSH
29510: LD_INT 24
29512: PUSH
29513: LD_INT 250
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: LIST
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: CALL_OW 72
29537: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29538: LD_ADDR_VAR 0 7
29542: PUSH
29543: LD_VAR 0 5
29547: PUSH
29548: LD_VAR 0 6
29552: DIFF
29553: ST_TO_ADDR
// if not need_heal_1 then
29554: LD_VAR 0 6
29558: NOT
29559: IFFALSE 29592
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29561: LD_ADDR_EXP 96
29565: PUSH
29566: LD_EXP 96
29570: PPUSH
29571: LD_VAR 0 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PPUSH
29583: EMPTY
29584: PPUSH
29585: CALL 56327 0 3
29589: ST_TO_ADDR
29590: GO 29662
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29592: LD_ADDR_EXP 96
29596: PUSH
29597: LD_EXP 96
29601: PPUSH
29602: LD_VAR 0 2
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: LD_EXP 96
29618: PUSH
29619: LD_VAR 0 2
29623: ARRAY
29624: PUSH
29625: LD_INT 1
29627: ARRAY
29628: PPUSH
29629: LD_INT 3
29631: PUSH
29632: LD_INT 24
29634: PUSH
29635: LD_INT 1000
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PPUSH
29646: CALL_OW 72
29650: PUSH
29651: LD_VAR 0 6
29655: UNION
29656: PPUSH
29657: CALL 56327 0 3
29661: ST_TO_ADDR
// if not need_heal_2 then
29662: LD_VAR 0 7
29666: NOT
29667: IFFALSE 29700
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29669: LD_ADDR_EXP 96
29673: PUSH
29674: LD_EXP 96
29678: PPUSH
29679: LD_VAR 0 2
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PPUSH
29691: EMPTY
29692: PPUSH
29693: CALL 56327 0 3
29697: ST_TO_ADDR
29698: GO 29732
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29700: LD_ADDR_EXP 96
29704: PUSH
29705: LD_EXP 96
29709: PPUSH
29710: LD_VAR 0 2
29714: PUSH
29715: LD_INT 2
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PPUSH
29722: LD_VAR 0 7
29726: PPUSH
29727: CALL 56327 0 3
29731: ST_TO_ADDR
// if need_heal_2 then
29732: LD_VAR 0 7
29736: IFFALSE 29897
// for j in need_heal_2 do
29738: LD_ADDR_VAR 0 3
29742: PUSH
29743: LD_VAR 0 7
29747: PUSH
29748: FOR_IN
29749: IFFALSE 29895
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29751: LD_ADDR_VAR 0 5
29755: PUSH
29756: LD_EXP 93
29760: PUSH
29761: LD_VAR 0 2
29765: ARRAY
29766: PPUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 30
29772: PUSH
29773: LD_INT 6
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 30
29782: PUSH
29783: LD_INT 7
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: LD_INT 8
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 30
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 30
29812: PUSH
29813: LD_INT 1
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// if tmp then
29833: LD_VAR 0 5
29837: IFFALSE 29893
// begin k := NearestUnitToUnit ( tmp , j ) ;
29839: LD_ADDR_VAR 0 4
29843: PUSH
29844: LD_VAR 0 5
29848: PPUSH
29849: LD_VAR 0 3
29853: PPUSH
29854: CALL_OW 74
29858: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29859: LD_VAR 0 3
29863: PPUSH
29864: LD_VAR 0 4
29868: PPUSH
29869: CALL_OW 296
29873: PUSH
29874: LD_INT 5
29876: GREATER
29877: IFFALSE 29893
// ComMoveToNearbyEntrance ( j , k ) ;
29879: LD_VAR 0 3
29883: PPUSH
29884: LD_VAR 0 4
29888: PPUSH
29889: CALL 88945 0 2
// end ; end ;
29893: GO 29748
29895: POP
29896: POP
// if not need_heal_1 and not need_heal_2 then
29897: LD_VAR 0 6
29901: NOT
29902: PUSH
29903: LD_VAR 0 7
29907: NOT
29908: AND
29909: IFFALSE 29913
// continue ;
29911: GO 29377
// end ;
29913: GO 29377
29915: POP
29916: POP
// RaiseSailEvent ( 102 ) ;
29917: LD_INT 102
29919: PPUSH
29920: CALL_OW 427
// end ;
29924: LD_VAR 0 1
29928: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29929: LD_INT 0
29931: PPUSH
29932: PPUSH
29933: PPUSH
29934: PPUSH
29935: PPUSH
29936: PPUSH
29937: PPUSH
29938: PPUSH
// if not mc_bases then
29939: LD_EXP 93
29943: NOT
29944: IFFALSE 29948
// exit ;
29946: GO 30831
// for i = 1 to mc_bases do
29948: LD_ADDR_VAR 0 2
29952: PUSH
29953: DOUBLE
29954: LD_INT 1
29956: DEC
29957: ST_TO_ADDR
29958: LD_EXP 93
29962: PUSH
29963: FOR_TO
29964: IFFALSE 30829
// begin if not mc_building_need_repair [ i ] then
29966: LD_EXP 94
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: NOT
29977: IFFALSE 30164
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29979: LD_ADDR_VAR 0 6
29983: PUSH
29984: LD_EXP 112
29988: PUSH
29989: LD_VAR 0 2
29993: ARRAY
29994: PPUSH
29995: LD_INT 3
29997: PUSH
29998: LD_INT 24
30000: PUSH
30001: LD_INT 1000
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 2
30014: PUSH
30015: LD_INT 34
30017: PUSH
30018: LD_INT 13
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 34
30027: PUSH
30028: LD_INT 52
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 34
30037: PUSH
30038: LD_EXP 78
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PPUSH
30057: CALL_OW 72
30061: ST_TO_ADDR
// if cranes then
30062: LD_VAR 0 6
30066: IFFALSE 30128
// for j in cranes do
30068: LD_ADDR_VAR 0 3
30072: PUSH
30073: LD_VAR 0 6
30077: PUSH
30078: FOR_IN
30079: IFFALSE 30126
// if not IsInArea ( j , mc_parking [ i ] ) then
30081: LD_VAR 0 3
30085: PPUSH
30086: LD_EXP 117
30090: PUSH
30091: LD_VAR 0 2
30095: ARRAY
30096: PPUSH
30097: CALL_OW 308
30101: NOT
30102: IFFALSE 30124
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30104: LD_VAR 0 3
30108: PPUSH
30109: LD_EXP 117
30113: PUSH
30114: LD_VAR 0 2
30118: ARRAY
30119: PPUSH
30120: CALL_OW 113
30124: GO 30078
30126: POP
30127: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30128: LD_ADDR_EXP 95
30132: PUSH
30133: LD_EXP 95
30137: PPUSH
30138: LD_VAR 0 2
30142: PPUSH
30143: EMPTY
30144: PPUSH
30145: CALL_OW 1
30149: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30150: LD_VAR 0 2
30154: PPUSH
30155: LD_INT 101
30157: PPUSH
30158: CALL 25016 0 2
// continue ;
30162: GO 29963
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30164: LD_ADDR_EXP 99
30168: PUSH
30169: LD_EXP 99
30173: PPUSH
30174: LD_VAR 0 2
30178: PPUSH
30179: EMPTY
30180: PPUSH
30181: CALL_OW 1
30185: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30186: LD_VAR 0 2
30190: PPUSH
30191: LD_INT 103
30193: PPUSH
30194: CALL 25016 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30198: LD_ADDR_VAR 0 5
30202: PUSH
30203: LD_EXP 93
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PUSH
30214: LD_EXP 122
30218: PUSH
30219: LD_VAR 0 2
30223: ARRAY
30224: UNION
30225: PPUSH
30226: LD_INT 2
30228: PUSH
30229: LD_INT 25
30231: PUSH
30232: LD_INT 2
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 25
30241: PUSH
30242: LD_INT 16
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: PPUSH
30257: CALL_OW 72
30261: ST_TO_ADDR
// if mc_need_heal [ i ] then
30262: LD_EXP 96
30266: PUSH
30267: LD_VAR 0 2
30271: ARRAY
30272: IFFALSE 30316
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30274: LD_ADDR_VAR 0 5
30278: PUSH
30279: LD_VAR 0 5
30283: PUSH
30284: LD_EXP 96
30288: PUSH
30289: LD_VAR 0 2
30293: ARRAY
30294: PUSH
30295: LD_INT 1
30297: ARRAY
30298: PUSH
30299: LD_EXP 96
30303: PUSH
30304: LD_VAR 0 2
30308: ARRAY
30309: PUSH
30310: LD_INT 2
30312: ARRAY
30313: UNION
30314: DIFF
30315: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30316: LD_ADDR_VAR 0 6
30320: PUSH
30321: LD_EXP 112
30325: PUSH
30326: LD_VAR 0 2
30330: ARRAY
30331: PPUSH
30332: LD_INT 2
30334: PUSH
30335: LD_INT 34
30337: PUSH
30338: LD_INT 13
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 34
30347: PUSH
30348: LD_INT 52
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 34
30357: PUSH
30358: LD_EXP 78
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: PPUSH
30373: CALL_OW 72
30377: ST_TO_ADDR
// if cranes then
30378: LD_VAR 0 6
30382: IFFALSE 30518
// begin for j in cranes do
30384: LD_ADDR_VAR 0 3
30388: PUSH
30389: LD_VAR 0 6
30393: PUSH
30394: FOR_IN
30395: IFFALSE 30516
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30397: LD_VAR 0 3
30401: PPUSH
30402: CALL_OW 256
30406: PUSH
30407: LD_INT 1000
30409: EQUAL
30410: PUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: CALL_OW 314
30420: NOT
30421: AND
30422: IFFALSE 30456
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30424: LD_VAR 0 3
30428: PPUSH
30429: LD_EXP 94
30433: PUSH
30434: LD_VAR 0 2
30438: ARRAY
30439: PPUSH
30440: LD_VAR 0 3
30444: PPUSH
30445: CALL_OW 74
30449: PPUSH
30450: CALL_OW 130
30454: GO 30514
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30456: LD_VAR 0 3
30460: PPUSH
30461: CALL_OW 256
30465: PUSH
30466: LD_INT 500
30468: LESS
30469: PUSH
30470: LD_VAR 0 3
30474: PPUSH
30475: LD_EXP 117
30479: PUSH
30480: LD_VAR 0 2
30484: ARRAY
30485: PPUSH
30486: CALL_OW 308
30490: NOT
30491: AND
30492: IFFALSE 30514
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30494: LD_VAR 0 3
30498: PPUSH
30499: LD_EXP 117
30503: PUSH
30504: LD_VAR 0 2
30508: ARRAY
30509: PPUSH
30510: CALL_OW 113
// end ;
30514: GO 30394
30516: POP
30517: POP
// end ; if tmp > 3 then
30518: LD_VAR 0 5
30522: PUSH
30523: LD_INT 3
30525: GREATER
30526: IFFALSE 30546
// tmp := ShrinkArray ( tmp , 4 ) ;
30528: LD_ADDR_VAR 0 5
30532: PUSH
30533: LD_VAR 0 5
30537: PPUSH
30538: LD_INT 4
30540: PPUSH
30541: CALL 88393 0 2
30545: ST_TO_ADDR
// if not tmp then
30546: LD_VAR 0 5
30550: NOT
30551: IFFALSE 30555
// continue ;
30553: GO 29963
// for j in tmp do
30555: LD_ADDR_VAR 0 3
30559: PUSH
30560: LD_VAR 0 5
30564: PUSH
30565: FOR_IN
30566: IFFALSE 30825
// begin if IsInUnit ( j ) then
30568: LD_VAR 0 3
30572: PPUSH
30573: CALL_OW 310
30577: IFFALSE 30588
// ComExitBuilding ( j ) ;
30579: LD_VAR 0 3
30583: PPUSH
30584: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30588: LD_VAR 0 3
30592: PUSH
30593: LD_EXP 95
30597: PUSH
30598: LD_VAR 0 2
30602: ARRAY
30603: IN
30604: NOT
30605: IFFALSE 30663
// begin SetTag ( j , 101 ) ;
30607: LD_VAR 0 3
30611: PPUSH
30612: LD_INT 101
30614: PPUSH
30615: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30619: LD_ADDR_EXP 95
30623: PUSH
30624: LD_EXP 95
30628: PPUSH
30629: LD_VAR 0 2
30633: PUSH
30634: LD_EXP 95
30638: PUSH
30639: LD_VAR 0 2
30643: ARRAY
30644: PUSH
30645: LD_INT 1
30647: PLUS
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PPUSH
30653: LD_VAR 0 3
30657: PPUSH
30658: CALL 56327 0 3
30662: ST_TO_ADDR
// end ; wait ( 1 ) ;
30663: LD_INT 1
30665: PPUSH
30666: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30670: LD_ADDR_VAR 0 7
30674: PUSH
30675: LD_EXP 94
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: ST_TO_ADDR
// if mc_scan [ i ] then
30686: LD_EXP 116
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: IFFALSE 30758
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30698: LD_ADDR_VAR 0 7
30702: PUSH
30703: LD_EXP 94
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PPUSH
30714: LD_INT 3
30716: PUSH
30717: LD_INT 30
30719: PUSH
30720: LD_INT 32
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 30
30729: PUSH
30730: LD_INT 33
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 30
30739: PUSH
30740: LD_INT 31
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: PPUSH
30753: CALL_OW 72
30757: ST_TO_ADDR
// if not to_repair_tmp then
30758: LD_VAR 0 7
30762: NOT
30763: IFFALSE 30767
// continue ;
30765: GO 30565
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30767: LD_ADDR_VAR 0 8
30771: PUSH
30772: LD_VAR 0 7
30776: PPUSH
30777: LD_VAR 0 3
30781: PPUSH
30782: CALL_OW 74
30786: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30787: LD_VAR 0 8
30791: PPUSH
30792: LD_INT 16
30794: PPUSH
30795: CALL 58926 0 2
30799: PUSH
30800: LD_INT 4
30802: ARRAY
30803: PUSH
30804: LD_INT 10
30806: LESS
30807: IFFALSE 30823
// ComRepairBuilding ( j , to_repair ) ;
30809: LD_VAR 0 3
30813: PPUSH
30814: LD_VAR 0 8
30818: PPUSH
30819: CALL_OW 130
// end ;
30823: GO 30565
30825: POP
30826: POP
// end ;
30827: GO 29963
30829: POP
30830: POP
// end ;
30831: LD_VAR 0 1
30835: RET
// export function MC_Heal ; var i , j , tmp ; begin
30836: LD_INT 0
30838: PPUSH
30839: PPUSH
30840: PPUSH
30841: PPUSH
// if not mc_bases then
30842: LD_EXP 93
30846: NOT
30847: IFFALSE 30851
// exit ;
30849: GO 31253
// for i = 1 to mc_bases do
30851: LD_ADDR_VAR 0 2
30855: PUSH
30856: DOUBLE
30857: LD_INT 1
30859: DEC
30860: ST_TO_ADDR
30861: LD_EXP 93
30865: PUSH
30866: FOR_TO
30867: IFFALSE 31251
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30869: LD_EXP 96
30873: PUSH
30874: LD_VAR 0 2
30878: ARRAY
30879: PUSH
30880: LD_INT 1
30882: ARRAY
30883: NOT
30884: PUSH
30885: LD_EXP 96
30889: PUSH
30890: LD_VAR 0 2
30894: ARRAY
30895: PUSH
30896: LD_INT 2
30898: ARRAY
30899: NOT
30900: AND
30901: IFFALSE 30939
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30903: LD_ADDR_EXP 97
30907: PUSH
30908: LD_EXP 97
30912: PPUSH
30913: LD_VAR 0 2
30917: PPUSH
30918: EMPTY
30919: PPUSH
30920: CALL_OW 1
30924: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30925: LD_VAR 0 2
30929: PPUSH
30930: LD_INT 102
30932: PPUSH
30933: CALL 25016 0 2
// continue ;
30937: GO 30866
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30939: LD_ADDR_VAR 0 4
30943: PUSH
30944: LD_EXP 93
30948: PUSH
30949: LD_VAR 0 2
30953: ARRAY
30954: PPUSH
30955: LD_INT 25
30957: PUSH
30958: LD_INT 4
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PPUSH
30965: CALL_OW 72
30969: ST_TO_ADDR
// if not tmp then
30970: LD_VAR 0 4
30974: NOT
30975: IFFALSE 30979
// continue ;
30977: GO 30866
// if mc_taming [ i ] then
30979: LD_EXP 124
30983: PUSH
30984: LD_VAR 0 2
30988: ARRAY
30989: IFFALSE 31013
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30991: LD_ADDR_EXP 124
30995: PUSH
30996: LD_EXP 124
31000: PPUSH
31001: LD_VAR 0 2
31005: PPUSH
31006: EMPTY
31007: PPUSH
31008: CALL_OW 1
31012: ST_TO_ADDR
// for j in tmp do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: FOR_IN
31024: IFFALSE 31247
// begin if IsInUnit ( j ) then
31026: LD_VAR 0 3
31030: PPUSH
31031: CALL_OW 310
31035: IFFALSE 31046
// ComExitBuilding ( j ) ;
31037: LD_VAR 0 3
31041: PPUSH
31042: CALL_OW 122
// if not j in mc_healers [ i ] then
31046: LD_VAR 0 3
31050: PUSH
31051: LD_EXP 97
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: IN
31062: NOT
31063: IFFALSE 31109
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31065: LD_ADDR_EXP 97
31069: PUSH
31070: LD_EXP 97
31074: PPUSH
31075: LD_VAR 0 2
31079: PUSH
31080: LD_EXP 97
31084: PUSH
31085: LD_VAR 0 2
31089: ARRAY
31090: PUSH
31091: LD_INT 1
31093: PLUS
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PPUSH
31099: LD_VAR 0 3
31103: PPUSH
31104: CALL 56327 0 3
31108: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31109: LD_VAR 0 3
31113: PPUSH
31114: CALL_OW 110
31118: PUSH
31119: LD_INT 102
31121: NONEQUAL
31122: IFFALSE 31136
// SetTag ( j , 102 ) ;
31124: LD_VAR 0 3
31128: PPUSH
31129: LD_INT 102
31131: PPUSH
31132: CALL_OW 109
// Wait ( 3 ) ;
31136: LD_INT 3
31138: PPUSH
31139: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31143: LD_EXP 96
31147: PUSH
31148: LD_VAR 0 2
31152: ARRAY
31153: PUSH
31154: LD_INT 1
31156: ARRAY
31157: IFFALSE 31189
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31159: LD_VAR 0 3
31163: PPUSH
31164: LD_EXP 96
31168: PUSH
31169: LD_VAR 0 2
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PUSH
31179: LD_INT 1
31181: ARRAY
31182: PPUSH
31183: CALL_OW 128
31187: GO 31245
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31189: LD_VAR 0 3
31193: PPUSH
31194: CALL_OW 314
31198: NOT
31199: PUSH
31200: LD_EXP 96
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: PUSH
31211: LD_INT 2
31213: ARRAY
31214: AND
31215: IFFALSE 31245
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31217: LD_VAR 0 3
31221: PPUSH
31222: LD_EXP 96
31226: PUSH
31227: LD_VAR 0 2
31231: ARRAY
31232: PUSH
31233: LD_INT 2
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: ARRAY
31240: PPUSH
31241: CALL_OW 128
// end ;
31245: GO 31023
31247: POP
31248: POP
// end ;
31249: GO 30866
31251: POP
31252: POP
// end ;
31253: LD_VAR 0 1
31257: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31258: LD_INT 0
31260: PPUSH
31261: PPUSH
31262: PPUSH
31263: PPUSH
31264: PPUSH
// if not mc_bases then
31265: LD_EXP 93
31269: NOT
31270: IFFALSE 31274
// exit ;
31272: GO 32445
// for i = 1 to mc_bases do
31274: LD_ADDR_VAR 0 2
31278: PUSH
31279: DOUBLE
31280: LD_INT 1
31282: DEC
31283: ST_TO_ADDR
31284: LD_EXP 93
31288: PUSH
31289: FOR_TO
31290: IFFALSE 32443
// begin if mc_scan [ i ] then
31292: LD_EXP 116
31296: PUSH
31297: LD_VAR 0 2
31301: ARRAY
31302: IFFALSE 31306
// continue ;
31304: GO 31289
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31306: LD_EXP 98
31310: PUSH
31311: LD_VAR 0 2
31315: ARRAY
31316: NOT
31317: PUSH
31318: LD_EXP 100
31322: PUSH
31323: LD_VAR 0 2
31327: ARRAY
31328: NOT
31329: AND
31330: PUSH
31331: LD_EXP 99
31335: PUSH
31336: LD_VAR 0 2
31340: ARRAY
31341: AND
31342: IFFALSE 31380
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31344: LD_ADDR_EXP 99
31348: PUSH
31349: LD_EXP 99
31353: PPUSH
31354: LD_VAR 0 2
31358: PPUSH
31359: EMPTY
31360: PPUSH
31361: CALL_OW 1
31365: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31366: LD_VAR 0 2
31370: PPUSH
31371: LD_INT 103
31373: PPUSH
31374: CALL 25016 0 2
// continue ;
31378: GO 31289
// end ; if mc_construct_list [ i ] then
31380: LD_EXP 100
31384: PUSH
31385: LD_VAR 0 2
31389: ARRAY
31390: IFFALSE 31610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31392: LD_ADDR_VAR 0 4
31396: PUSH
31397: LD_EXP 93
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 25
31410: PUSH
31411: LD_INT 2
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 72
31422: PUSH
31423: LD_EXP 95
31427: PUSH
31428: LD_VAR 0 2
31432: ARRAY
31433: DIFF
31434: ST_TO_ADDR
// if not tmp then
31435: LD_VAR 0 4
31439: NOT
31440: IFFALSE 31444
// continue ;
31442: GO 31289
// for j in tmp do
31444: LD_ADDR_VAR 0 3
31448: PUSH
31449: LD_VAR 0 4
31453: PUSH
31454: FOR_IN
31455: IFFALSE 31606
// begin if not mc_builders [ i ] then
31457: LD_EXP 99
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: NOT
31468: IFFALSE 31526
// begin SetTag ( j , 103 ) ;
31470: LD_VAR 0 3
31474: PPUSH
31475: LD_INT 103
31477: PPUSH
31478: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31482: LD_ADDR_EXP 99
31486: PUSH
31487: LD_EXP 99
31491: PPUSH
31492: LD_VAR 0 2
31496: PUSH
31497: LD_EXP 99
31501: PUSH
31502: LD_VAR 0 2
31506: ARRAY
31507: PUSH
31508: LD_INT 1
31510: PLUS
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PPUSH
31516: LD_VAR 0 3
31520: PPUSH
31521: CALL 56327 0 3
31525: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL_OW 310
31535: IFFALSE 31546
// ComExitBuilding ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 122
// wait ( 3 ) ;
31546: LD_INT 3
31548: PPUSH
31549: CALL_OW 67
// if not mc_construct_list [ i ] then
31553: LD_EXP 100
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: NOT
31564: IFFALSE 31568
// break ;
31566: GO 31606
// if not HasTask ( j ) then
31568: LD_VAR 0 3
31572: PPUSH
31573: CALL_OW 314
31577: NOT
31578: IFFALSE 31604
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31580: LD_VAR 0 3
31584: PPUSH
31585: LD_EXP 100
31589: PUSH
31590: LD_VAR 0 2
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: CALL 59190 0 2
// end ;
31604: GO 31454
31606: POP
31607: POP
// end else
31608: GO 32441
// if mc_build_list [ i ] then
31610: LD_EXP 98
31614: PUSH
31615: LD_VAR 0 2
31619: ARRAY
31620: IFFALSE 32441
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31622: LD_ADDR_VAR 0 5
31626: PUSH
31627: LD_EXP 93
31631: PUSH
31632: LD_VAR 0 2
31636: ARRAY
31637: PPUSH
31638: LD_INT 2
31640: PUSH
31641: LD_INT 30
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 30
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: PPUSH
31666: CALL_OW 72
31670: ST_TO_ADDR
// if depot then
31671: LD_VAR 0 5
31675: IFFALSE 31693
// depot := depot [ 1 ] else
31677: LD_ADDR_VAR 0 5
31681: PUSH
31682: LD_VAR 0 5
31686: PUSH
31687: LD_INT 1
31689: ARRAY
31690: ST_TO_ADDR
31691: GO 31701
// depot := 0 ;
31693: LD_ADDR_VAR 0 5
31697: PUSH
31698: LD_INT 0
31700: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31701: LD_EXP 98
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PUSH
31716: LD_INT 1
31718: ARRAY
31719: PPUSH
31720: CALL 59014 0 1
31724: PUSH
31725: LD_EXP 93
31729: PUSH
31730: LD_VAR 0 2
31734: ARRAY
31735: PPUSH
31736: LD_INT 2
31738: PUSH
31739: LD_INT 30
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 30
31751: PUSH
31752: LD_INT 3
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: LIST
31763: PPUSH
31764: CALL_OW 72
31768: NOT
31769: AND
31770: IFFALSE 31875
// begin for j = 1 to mc_build_list [ i ] do
31772: LD_ADDR_VAR 0 3
31776: PUSH
31777: DOUBLE
31778: LD_INT 1
31780: DEC
31781: ST_TO_ADDR
31782: LD_EXP 98
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PUSH
31793: FOR_TO
31794: IFFALSE 31873
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31796: LD_EXP 98
31800: PUSH
31801: LD_VAR 0 2
31805: ARRAY
31806: PUSH
31807: LD_VAR 0 3
31811: ARRAY
31812: PUSH
31813: LD_INT 1
31815: ARRAY
31816: PUSH
31817: LD_INT 2
31819: EQUAL
31820: IFFALSE 31871
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31822: LD_ADDR_EXP 98
31826: PUSH
31827: LD_EXP 98
31831: PPUSH
31832: LD_VAR 0 2
31836: PPUSH
31837: LD_EXP 98
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PPUSH
31848: LD_VAR 0 3
31852: PPUSH
31853: LD_INT 1
31855: PPUSH
31856: LD_INT 0
31858: PPUSH
31859: CALL 55745 0 4
31863: PPUSH
31864: CALL_OW 1
31868: ST_TO_ADDR
// break ;
31869: GO 31873
// end ;
31871: GO 31793
31873: POP
31874: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31875: LD_EXP 98
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: PUSH
31886: LD_INT 1
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: ARRAY
31893: PUSH
31894: LD_INT 0
31896: EQUAL
31897: PUSH
31898: LD_VAR 0 5
31902: PUSH
31903: LD_VAR 0 5
31907: PPUSH
31908: LD_EXP 98
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: PUSH
31919: LD_INT 1
31921: ARRAY
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_EXP 98
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: PUSH
31938: LD_INT 1
31940: ARRAY
31941: PUSH
31942: LD_INT 2
31944: ARRAY
31945: PPUSH
31946: LD_EXP 98
31950: PUSH
31951: LD_VAR 0 2
31955: ARRAY
31956: PUSH
31957: LD_INT 1
31959: ARRAY
31960: PUSH
31961: LD_INT 3
31963: ARRAY
31964: PPUSH
31965: LD_EXP 98
31969: PUSH
31970: LD_VAR 0 2
31974: ARRAY
31975: PUSH
31976: LD_INT 1
31978: ARRAY
31979: PUSH
31980: LD_INT 4
31982: ARRAY
31983: PPUSH
31984: CALL 64430 0 5
31988: AND
31989: OR
31990: IFFALSE 32271
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31992: LD_ADDR_VAR 0 4
31996: PUSH
31997: LD_EXP 93
32001: PUSH
32002: LD_VAR 0 2
32006: ARRAY
32007: PPUSH
32008: LD_INT 25
32010: PUSH
32011: LD_INT 2
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PPUSH
32018: CALL_OW 72
32022: PUSH
32023: LD_EXP 95
32027: PUSH
32028: LD_VAR 0 2
32032: ARRAY
32033: DIFF
32034: ST_TO_ADDR
// if not tmp then
32035: LD_VAR 0 4
32039: NOT
32040: IFFALSE 32044
// continue ;
32042: GO 31289
// for j in tmp do
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: FOR_IN
32055: IFFALSE 32267
// begin if not mc_builders [ i ] then
32057: LD_EXP 99
32061: PUSH
32062: LD_VAR 0 2
32066: ARRAY
32067: NOT
32068: IFFALSE 32126
// begin SetTag ( j , 103 ) ;
32070: LD_VAR 0 3
32074: PPUSH
32075: LD_INT 103
32077: PPUSH
32078: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32082: LD_ADDR_EXP 99
32086: PUSH
32087: LD_EXP 99
32091: PPUSH
32092: LD_VAR 0 2
32096: PUSH
32097: LD_EXP 99
32101: PUSH
32102: LD_VAR 0 2
32106: ARRAY
32107: PUSH
32108: LD_INT 1
32110: PLUS
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PPUSH
32116: LD_VAR 0 3
32120: PPUSH
32121: CALL 56327 0 3
32125: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 310
32135: IFFALSE 32146
// ComExitBuilding ( j ) ;
32137: LD_VAR 0 3
32141: PPUSH
32142: CALL_OW 122
// wait ( 3 ) ;
32146: LD_INT 3
32148: PPUSH
32149: CALL_OW 67
// if not mc_build_list [ i ] then
32153: LD_EXP 98
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: NOT
32164: IFFALSE 32168
// break ;
32166: GO 32267
// if not HasTask ( j ) then
32168: LD_VAR 0 3
32172: PPUSH
32173: CALL_OW 314
32177: NOT
32178: IFFALSE 32265
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32180: LD_VAR 0 3
32184: PPUSH
32185: LD_EXP 98
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PUSH
32196: LD_INT 1
32198: ARRAY
32199: PUSH
32200: LD_INT 1
32202: ARRAY
32203: PPUSH
32204: LD_EXP 98
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_INT 1
32217: ARRAY
32218: PUSH
32219: LD_INT 2
32221: ARRAY
32222: PPUSH
32223: LD_EXP 98
32227: PUSH
32228: LD_VAR 0 2
32232: ARRAY
32233: PUSH
32234: LD_INT 1
32236: ARRAY
32237: PUSH
32238: LD_INT 3
32240: ARRAY
32241: PPUSH
32242: LD_EXP 98
32246: PUSH
32247: LD_VAR 0 2
32251: ARRAY
32252: PUSH
32253: LD_INT 1
32255: ARRAY
32256: PUSH
32257: LD_INT 4
32259: ARRAY
32260: PPUSH
32261: CALL_OW 145
// end ;
32265: GO 32054
32267: POP
32268: POP
// end else
32269: GO 32441
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32271: LD_EXP 93
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: PPUSH
32282: LD_EXP 98
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: LD_INT 1
32295: ARRAY
32296: PUSH
32297: LD_INT 1
32299: ARRAY
32300: PPUSH
32301: LD_EXP 98
32305: PUSH
32306: LD_VAR 0 2
32310: ARRAY
32311: PUSH
32312: LD_INT 1
32314: ARRAY
32315: PUSH
32316: LD_INT 2
32318: ARRAY
32319: PPUSH
32320: LD_EXP 98
32324: PUSH
32325: LD_VAR 0 2
32329: ARRAY
32330: PUSH
32331: LD_INT 1
32333: ARRAY
32334: PUSH
32335: LD_INT 3
32337: ARRAY
32338: PPUSH
32339: LD_EXP 98
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_INT 1
32352: ARRAY
32353: PUSH
32354: LD_INT 4
32356: ARRAY
32357: PPUSH
32358: LD_EXP 93
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PPUSH
32369: LD_INT 21
32371: PUSH
32372: LD_INT 3
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 72
32383: PPUSH
32384: EMPTY
32385: PPUSH
32386: CALL 63180 0 7
32390: NOT
32391: IFFALSE 32441
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32393: LD_ADDR_EXP 98
32397: PUSH
32398: LD_EXP 98
32402: PPUSH
32403: LD_VAR 0 2
32407: PPUSH
32408: LD_EXP 98
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PPUSH
32419: LD_INT 1
32421: PPUSH
32422: LD_INT 1
32424: NEG
32425: PPUSH
32426: LD_INT 0
32428: PPUSH
32429: CALL 55745 0 4
32433: PPUSH
32434: CALL_OW 1
32438: ST_TO_ADDR
// continue ;
32439: GO 31289
// end ; end ; end ;
32441: GO 31289
32443: POP
32444: POP
// end ;
32445: LD_VAR 0 1
32449: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32450: LD_INT 0
32452: PPUSH
32453: PPUSH
32454: PPUSH
32455: PPUSH
32456: PPUSH
32457: PPUSH
// if not mc_bases then
32458: LD_EXP 93
32462: NOT
32463: IFFALSE 32467
// exit ;
32465: GO 32894
// for i = 1 to mc_bases do
32467: LD_ADDR_VAR 0 2
32471: PUSH
32472: DOUBLE
32473: LD_INT 1
32475: DEC
32476: ST_TO_ADDR
32477: LD_EXP 93
32481: PUSH
32482: FOR_TO
32483: IFFALSE 32892
// begin tmp := mc_build_upgrade [ i ] ;
32485: LD_ADDR_VAR 0 4
32489: PUSH
32490: LD_EXP 125
32494: PUSH
32495: LD_VAR 0 2
32499: ARRAY
32500: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32501: LD_ADDR_VAR 0 6
32505: PUSH
32506: LD_EXP 126
32510: PUSH
32511: LD_VAR 0 2
32515: ARRAY
32516: PPUSH
32517: LD_INT 2
32519: PUSH
32520: LD_INT 30
32522: PUSH
32523: LD_INT 6
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 30
32532: PUSH
32533: LD_INT 7
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: LIST
32544: PPUSH
32545: CALL_OW 72
32549: ST_TO_ADDR
// if not tmp and not lab then
32550: LD_VAR 0 4
32554: NOT
32555: PUSH
32556: LD_VAR 0 6
32560: NOT
32561: AND
32562: IFFALSE 32566
// continue ;
32564: GO 32482
// if tmp then
32566: LD_VAR 0 4
32570: IFFALSE 32690
// for j in tmp do
32572: LD_ADDR_VAR 0 3
32576: PUSH
32577: LD_VAR 0 4
32581: PUSH
32582: FOR_IN
32583: IFFALSE 32688
// begin if UpgradeCost ( j ) then
32585: LD_VAR 0 3
32589: PPUSH
32590: CALL 62840 0 1
32594: IFFALSE 32686
// begin ComUpgrade ( j ) ;
32596: LD_VAR 0 3
32600: PPUSH
32601: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32605: LD_ADDR_EXP 125
32609: PUSH
32610: LD_EXP 125
32614: PPUSH
32615: LD_VAR 0 2
32619: PPUSH
32620: LD_EXP 125
32624: PUSH
32625: LD_VAR 0 2
32629: ARRAY
32630: PUSH
32631: LD_VAR 0 3
32635: DIFF
32636: PPUSH
32637: CALL_OW 1
32641: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32642: LD_ADDR_EXP 100
32646: PUSH
32647: LD_EXP 100
32651: PPUSH
32652: LD_VAR 0 2
32656: PUSH
32657: LD_EXP 100
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PPUSH
32676: LD_VAR 0 3
32680: PPUSH
32681: CALL 56327 0 3
32685: ST_TO_ADDR
// end ; end ;
32686: GO 32582
32688: POP
32689: POP
// if not lab or not mc_lab_upgrade [ i ] then
32690: LD_VAR 0 6
32694: NOT
32695: PUSH
32696: LD_EXP 127
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: NOT
32707: OR
32708: IFFALSE 32712
// continue ;
32710: GO 32482
// for j in lab do
32712: LD_ADDR_VAR 0 3
32716: PUSH
32717: LD_VAR 0 6
32721: PUSH
32722: FOR_IN
32723: IFFALSE 32888
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32725: LD_VAR 0 3
32729: PPUSH
32730: CALL_OW 266
32734: PUSH
32735: LD_INT 6
32737: PUSH
32738: LD_INT 7
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: IN
32745: PUSH
32746: LD_VAR 0 3
32750: PPUSH
32751: CALL_OW 461
32755: PUSH
32756: LD_INT 1
32758: NONEQUAL
32759: AND
32760: IFFALSE 32886
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32762: LD_VAR 0 3
32766: PPUSH
32767: LD_EXP 127
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PUSH
32778: LD_INT 1
32780: ARRAY
32781: PPUSH
32782: CALL 63045 0 2
32786: IFFALSE 32886
// begin ComCancel ( j ) ;
32788: LD_VAR 0 3
32792: PPUSH
32793: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32797: LD_VAR 0 3
32801: PPUSH
32802: LD_EXP 127
32806: PUSH
32807: LD_VAR 0 2
32811: ARRAY
32812: PUSH
32813: LD_INT 1
32815: ARRAY
32816: PPUSH
32817: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32821: LD_VAR 0 3
32825: PUSH
32826: LD_EXP 100
32830: PUSH
32831: LD_VAR 0 2
32835: ARRAY
32836: IN
32837: NOT
32838: IFFALSE 32884
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32840: LD_ADDR_EXP 100
32844: PUSH
32845: LD_EXP 100
32849: PPUSH
32850: LD_VAR 0 2
32854: PUSH
32855: LD_EXP 100
32859: PUSH
32860: LD_VAR 0 2
32864: ARRAY
32865: PUSH
32866: LD_INT 1
32868: PLUS
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL 56327 0 3
32883: ST_TO_ADDR
// break ;
32884: GO 32888
// end ; end ; end ;
32886: GO 32722
32888: POP
32889: POP
// end ;
32890: GO 32482
32892: POP
32893: POP
// end ;
32894: LD_VAR 0 1
32898: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32899: LD_INT 0
32901: PPUSH
32902: PPUSH
32903: PPUSH
32904: PPUSH
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
// if not mc_bases then
32910: LD_EXP 93
32914: NOT
32915: IFFALSE 32919
// exit ;
32917: GO 33324
// for i = 1 to mc_bases do
32919: LD_ADDR_VAR 0 2
32923: PUSH
32924: DOUBLE
32925: LD_INT 1
32927: DEC
32928: ST_TO_ADDR
32929: LD_EXP 93
32933: PUSH
32934: FOR_TO
32935: IFFALSE 33322
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32937: LD_EXP 101
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: NOT
32948: PUSH
32949: LD_EXP 93
32953: PUSH
32954: LD_VAR 0 2
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PUSH
32963: LD_INT 3
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PPUSH
32970: CALL_OW 72
32974: NOT
32975: OR
32976: IFFALSE 32980
// continue ;
32978: GO 32934
// busy := false ;
32980: LD_ADDR_VAR 0 8
32984: PUSH
32985: LD_INT 0
32987: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32988: LD_ADDR_VAR 0 4
32992: PUSH
32993: LD_EXP 93
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: LD_INT 30
33006: PUSH
33007: LD_INT 3
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PPUSH
33014: CALL_OW 72
33018: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33019: LD_ADDR_VAR 0 6
33023: PUSH
33024: LD_EXP 101
33028: PUSH
33029: LD_VAR 0 2
33033: ARRAY
33034: PPUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 30
33040: PUSH
33041: LD_INT 32
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 30
33050: PUSH
33051: LD_INT 33
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: LIST
33062: PPUSH
33063: CALL_OW 72
33067: ST_TO_ADDR
// if not t then
33068: LD_VAR 0 6
33072: NOT
33073: IFFALSE 33077
// continue ;
33075: GO 32934
// for j in tmp do
33077: LD_ADDR_VAR 0 3
33081: PUSH
33082: LD_VAR 0 4
33086: PUSH
33087: FOR_IN
33088: IFFALSE 33118
// if not BuildingStatus ( j ) = bs_idle then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 461
33099: PUSH
33100: LD_INT 2
33102: EQUAL
33103: NOT
33104: IFFALSE 33116
// begin busy := true ;
33106: LD_ADDR_VAR 0 8
33110: PUSH
33111: LD_INT 1
33113: ST_TO_ADDR
// break ;
33114: GO 33118
// end ;
33116: GO 33087
33118: POP
33119: POP
// if busy then
33120: LD_VAR 0 8
33124: IFFALSE 33128
// continue ;
33126: GO 32934
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33128: LD_ADDR_VAR 0 7
33132: PUSH
33133: LD_VAR 0 6
33137: PPUSH
33138: LD_INT 35
33140: PUSH
33141: LD_INT 0
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PPUSH
33148: CALL_OW 72
33152: ST_TO_ADDR
// if tw then
33153: LD_VAR 0 7
33157: IFFALSE 33234
// begin tw := tw [ 1 ] ;
33159: LD_ADDR_VAR 0 7
33163: PUSH
33164: LD_VAR 0 7
33168: PUSH
33169: LD_INT 1
33171: ARRAY
33172: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33173: LD_ADDR_VAR 0 9
33177: PUSH
33178: LD_VAR 0 7
33182: PPUSH
33183: LD_EXP 118
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PPUSH
33194: CALL 61337 0 2
33198: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33199: LD_EXP 132
33203: PUSH
33204: LD_VAR 0 2
33208: ARRAY
33209: IFFALSE 33232
// if not weapon in mc_allowed_tower_weapons [ i ] then
33211: LD_VAR 0 9
33215: PUSH
33216: LD_EXP 132
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: IN
33227: NOT
33228: IFFALSE 33232
// continue ;
33230: GO 32934
// end else
33232: GO 33297
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33234: LD_ADDR_VAR 0 5
33238: PUSH
33239: LD_EXP 101
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: PPUSH
33250: LD_VAR 0 4
33254: PPUSH
33255: CALL 87626 0 2
33259: ST_TO_ADDR
// if not tmp2 then
33260: LD_VAR 0 5
33264: NOT
33265: IFFALSE 33269
// continue ;
33267: GO 32934
// tw := tmp2 [ 1 ] ;
33269: LD_ADDR_VAR 0 7
33273: PUSH
33274: LD_VAR 0 5
33278: PUSH
33279: LD_INT 1
33281: ARRAY
33282: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33283: LD_ADDR_VAR 0 9
33287: PUSH
33288: LD_VAR 0 5
33292: PUSH
33293: LD_INT 2
33295: ARRAY
33296: ST_TO_ADDR
// end ; if not weapon then
33297: LD_VAR 0 9
33301: NOT
33302: IFFALSE 33306
// continue ;
33304: GO 32934
// ComPlaceWeapon ( tw , weapon ) ;
33306: LD_VAR 0 7
33310: PPUSH
33311: LD_VAR 0 9
33315: PPUSH
33316: CALL_OW 148
// end ;
33320: GO 32934
33322: POP
33323: POP
// end ;
33324: LD_VAR 0 1
33328: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33329: LD_INT 0
33331: PPUSH
33332: PPUSH
33333: PPUSH
33334: PPUSH
33335: PPUSH
33336: PPUSH
33337: PPUSH
// if not mc_bases then
33338: LD_EXP 93
33342: NOT
33343: IFFALSE 33347
// exit ;
33345: GO 34115
// for i = 1 to mc_bases do
33347: LD_ADDR_VAR 0 2
33351: PUSH
33352: DOUBLE
33353: LD_INT 1
33355: DEC
33356: ST_TO_ADDR
33357: LD_EXP 93
33361: PUSH
33362: FOR_TO
33363: IFFALSE 34113
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33365: LD_EXP 106
33369: PUSH
33370: LD_VAR 0 2
33374: ARRAY
33375: NOT
33376: PUSH
33377: LD_EXP 106
33381: PUSH
33382: LD_VAR 0 2
33386: ARRAY
33387: PUSH
33388: LD_EXP 107
33392: PUSH
33393: LD_VAR 0 2
33397: ARRAY
33398: EQUAL
33399: OR
33400: PUSH
33401: LD_EXP 116
33405: PUSH
33406: LD_VAR 0 2
33410: ARRAY
33411: OR
33412: IFFALSE 33416
// continue ;
33414: GO 33362
// if mc_miners [ i ] then
33416: LD_EXP 107
33420: PUSH
33421: LD_VAR 0 2
33425: ARRAY
33426: IFFALSE 33800
// begin for j = mc_miners [ i ] downto 1 do
33428: LD_ADDR_VAR 0 3
33432: PUSH
33433: DOUBLE
33434: LD_EXP 107
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: INC
33445: ST_TO_ADDR
33446: LD_INT 1
33448: PUSH
33449: FOR_DOWNTO
33450: IFFALSE 33798
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33452: LD_EXP 107
33456: PUSH
33457: LD_VAR 0 2
33461: ARRAY
33462: PUSH
33463: LD_VAR 0 3
33467: ARRAY
33468: PPUSH
33469: CALL_OW 301
33473: PUSH
33474: LD_EXP 107
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: PUSH
33485: LD_VAR 0 3
33489: ARRAY
33490: PPUSH
33491: CALL_OW 257
33495: PUSH
33496: LD_INT 1
33498: NONEQUAL
33499: OR
33500: IFFALSE 33563
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_EXP 107
33511: PUSH
33512: LD_VAR 0 2
33516: ARRAY
33517: PUSH
33518: LD_EXP 107
33522: PUSH
33523: LD_VAR 0 2
33527: ARRAY
33528: PUSH
33529: LD_VAR 0 3
33533: ARRAY
33534: DIFF
33535: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33536: LD_ADDR_EXP 107
33540: PUSH
33541: LD_EXP 107
33545: PPUSH
33546: LD_VAR 0 2
33550: PPUSH
33551: LD_VAR 0 5
33555: PPUSH
33556: CALL_OW 1
33560: ST_TO_ADDR
// continue ;
33561: GO 33449
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33563: LD_EXP 107
33567: PUSH
33568: LD_VAR 0 2
33572: ARRAY
33573: PUSH
33574: LD_VAR 0 3
33578: ARRAY
33579: PPUSH
33580: CALL_OW 257
33584: PUSH
33585: LD_INT 1
33587: EQUAL
33588: PUSH
33589: LD_EXP 107
33593: PUSH
33594: LD_VAR 0 2
33598: ARRAY
33599: PUSH
33600: LD_VAR 0 3
33604: ARRAY
33605: PPUSH
33606: CALL_OW 459
33610: NOT
33611: AND
33612: PUSH
33613: LD_EXP 107
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PUSH
33624: LD_VAR 0 3
33628: ARRAY
33629: PPUSH
33630: CALL_OW 314
33634: NOT
33635: AND
33636: IFFALSE 33796
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33638: LD_EXP 107
33642: PUSH
33643: LD_VAR 0 2
33647: ARRAY
33648: PUSH
33649: LD_VAR 0 3
33653: ARRAY
33654: PPUSH
33655: CALL_OW 310
33659: IFFALSE 33682
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33661: LD_EXP 107
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_VAR 0 3
33676: ARRAY
33677: PPUSH
33678: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33682: LD_EXP 107
33686: PUSH
33687: LD_VAR 0 2
33691: ARRAY
33692: PUSH
33693: LD_VAR 0 3
33697: ARRAY
33698: PPUSH
33699: CALL_OW 314
33703: NOT
33704: IFFALSE 33796
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33706: LD_ADDR_VAR 0 7
33710: PUSH
33711: LD_INT 1
33713: PPUSH
33714: LD_EXP 106
33718: PUSH
33719: LD_VAR 0 2
33723: ARRAY
33724: PPUSH
33725: CALL_OW 12
33729: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33730: LD_EXP 107
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: PUSH
33741: LD_VAR 0 3
33745: ARRAY
33746: PPUSH
33747: LD_EXP 106
33751: PUSH
33752: LD_VAR 0 2
33756: ARRAY
33757: PUSH
33758: LD_VAR 0 7
33762: ARRAY
33763: PUSH
33764: LD_INT 1
33766: ARRAY
33767: PPUSH
33768: LD_EXP 106
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: LD_VAR 0 7
33783: ARRAY
33784: PUSH
33785: LD_INT 2
33787: ARRAY
33788: PPUSH
33789: LD_INT 0
33791: PPUSH
33792: CALL_OW 193
// end ; end ; end ;
33796: GO 33449
33798: POP
33799: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33800: LD_ADDR_VAR 0 5
33804: PUSH
33805: LD_EXP 93
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PPUSH
33816: LD_INT 2
33818: PUSH
33819: LD_INT 30
33821: PUSH
33822: LD_INT 4
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 30
33831: PUSH
33832: LD_INT 5
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 30
33841: PUSH
33842: LD_INT 32
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: PPUSH
33855: CALL_OW 72
33859: ST_TO_ADDR
// if not tmp then
33860: LD_VAR 0 5
33864: NOT
33865: IFFALSE 33869
// continue ;
33867: GO 33362
// list := [ ] ;
33869: LD_ADDR_VAR 0 6
33873: PUSH
33874: EMPTY
33875: ST_TO_ADDR
// for j in tmp do
33876: LD_ADDR_VAR 0 3
33880: PUSH
33881: LD_VAR 0 5
33885: PUSH
33886: FOR_IN
33887: IFFALSE 33956
// begin for k in UnitsInside ( j ) do
33889: LD_ADDR_VAR 0 4
33893: PUSH
33894: LD_VAR 0 3
33898: PPUSH
33899: CALL_OW 313
33903: PUSH
33904: FOR_IN
33905: IFFALSE 33952
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33907: LD_VAR 0 4
33911: PPUSH
33912: CALL_OW 257
33916: PUSH
33917: LD_INT 1
33919: EQUAL
33920: PUSH
33921: LD_VAR 0 4
33925: PPUSH
33926: CALL_OW 459
33930: NOT
33931: AND
33932: IFFALSE 33950
// list := list ^ k ;
33934: LD_ADDR_VAR 0 6
33938: PUSH
33939: LD_VAR 0 6
33943: PUSH
33944: LD_VAR 0 4
33948: ADD
33949: ST_TO_ADDR
33950: GO 33904
33952: POP
33953: POP
// end ;
33954: GO 33886
33956: POP
33957: POP
// list := list diff mc_miners [ i ] ;
33958: LD_ADDR_VAR 0 6
33962: PUSH
33963: LD_VAR 0 6
33967: PUSH
33968: LD_EXP 107
33972: PUSH
33973: LD_VAR 0 2
33977: ARRAY
33978: DIFF
33979: ST_TO_ADDR
// if not list then
33980: LD_VAR 0 6
33984: NOT
33985: IFFALSE 33989
// continue ;
33987: GO 33362
// k := mc_mines [ i ] - mc_miners [ i ] ;
33989: LD_ADDR_VAR 0 4
33993: PUSH
33994: LD_EXP 106
33998: PUSH
33999: LD_VAR 0 2
34003: ARRAY
34004: PUSH
34005: LD_EXP 107
34009: PUSH
34010: LD_VAR 0 2
34014: ARRAY
34015: MINUS
34016: ST_TO_ADDR
// if k > list then
34017: LD_VAR 0 4
34021: PUSH
34022: LD_VAR 0 6
34026: GREATER
34027: IFFALSE 34039
// k := list ;
34029: LD_ADDR_VAR 0 4
34033: PUSH
34034: LD_VAR 0 6
34038: ST_TO_ADDR
// for j = 1 to k do
34039: LD_ADDR_VAR 0 3
34043: PUSH
34044: DOUBLE
34045: LD_INT 1
34047: DEC
34048: ST_TO_ADDR
34049: LD_VAR 0 4
34053: PUSH
34054: FOR_TO
34055: IFFALSE 34109
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34057: LD_ADDR_EXP 107
34061: PUSH
34062: LD_EXP 107
34066: PPUSH
34067: LD_VAR 0 2
34071: PUSH
34072: LD_EXP 107
34076: PUSH
34077: LD_VAR 0 2
34081: ARRAY
34082: PUSH
34083: LD_INT 1
34085: PLUS
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PPUSH
34091: LD_VAR 0 6
34095: PUSH
34096: LD_VAR 0 3
34100: ARRAY
34101: PPUSH
34102: CALL 56327 0 3
34106: ST_TO_ADDR
34107: GO 34054
34109: POP
34110: POP
// end ;
34111: GO 33362
34113: POP
34114: POP
// end ;
34115: LD_VAR 0 1
34119: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34120: LD_INT 0
34122: PPUSH
34123: PPUSH
34124: PPUSH
34125: PPUSH
34126: PPUSH
34127: PPUSH
34128: PPUSH
34129: PPUSH
34130: PPUSH
34131: PPUSH
34132: PPUSH
// if not mc_bases then
34133: LD_EXP 93
34137: NOT
34138: IFFALSE 34142
// exit ;
34140: GO 35965
// for i = 1 to mc_bases do
34142: LD_ADDR_VAR 0 2
34146: PUSH
34147: DOUBLE
34148: LD_INT 1
34150: DEC
34151: ST_TO_ADDR
34152: LD_EXP 93
34156: PUSH
34157: FOR_TO
34158: IFFALSE 35963
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34160: LD_EXP 93
34164: PUSH
34165: LD_VAR 0 2
34169: ARRAY
34170: NOT
34171: PUSH
34172: LD_EXP 100
34176: PUSH
34177: LD_VAR 0 2
34181: ARRAY
34182: OR
34183: IFFALSE 34187
// continue ;
34185: GO 34157
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34187: LD_EXP 109
34191: PUSH
34192: LD_VAR 0 2
34196: ARRAY
34197: NOT
34198: PUSH
34199: LD_EXP 110
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: AND
34210: IFFALSE 34248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34212: LD_ADDR_EXP 110
34216: PUSH
34217: LD_EXP 110
34221: PPUSH
34222: LD_VAR 0 2
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34234: LD_VAR 0 2
34238: PPUSH
34239: LD_INT 107
34241: PPUSH
34242: CALL 25016 0 2
// continue ;
34246: GO 34157
// end ; target := [ ] ;
34248: LD_ADDR_VAR 0 7
34252: PUSH
34253: EMPTY
34254: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34255: LD_ADDR_VAR 0 6
34259: PUSH
34260: LD_EXP 93
34264: PUSH
34265: LD_VAR 0 2
34269: ARRAY
34270: PUSH
34271: LD_INT 1
34273: ARRAY
34274: PPUSH
34275: CALL_OW 255
34279: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34280: LD_ADDR_VAR 0 9
34284: PUSH
34285: LD_EXP 93
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PPUSH
34296: LD_INT 2
34298: PUSH
34299: LD_INT 30
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 30
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: LIST
34323: PPUSH
34324: CALL_OW 72
34328: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34329: LD_ADDR_VAR 0 3
34333: PUSH
34334: DOUBLE
34335: LD_EXP 109
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: INC
34346: ST_TO_ADDR
34347: LD_INT 1
34349: PUSH
34350: FOR_DOWNTO
34351: IFFALSE 34596
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34353: LD_EXP 109
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: PUSH
34364: LD_VAR 0 3
34368: ARRAY
34369: PUSH
34370: LD_INT 2
34372: ARRAY
34373: PPUSH
34374: LD_EXP 109
34378: PUSH
34379: LD_VAR 0 2
34383: ARRAY
34384: PUSH
34385: LD_VAR 0 3
34389: ARRAY
34390: PUSH
34391: LD_INT 3
34393: ARRAY
34394: PPUSH
34395: CALL_OW 488
34399: PUSH
34400: LD_EXP 109
34404: PUSH
34405: LD_VAR 0 2
34409: ARRAY
34410: PUSH
34411: LD_VAR 0 3
34415: ARRAY
34416: PUSH
34417: LD_INT 2
34419: ARRAY
34420: PPUSH
34421: LD_EXP 109
34425: PUSH
34426: LD_VAR 0 2
34430: ARRAY
34431: PUSH
34432: LD_VAR 0 3
34436: ARRAY
34437: PUSH
34438: LD_INT 3
34440: ARRAY
34441: PPUSH
34442: CALL_OW 284
34446: PUSH
34447: LD_INT 0
34449: EQUAL
34450: AND
34451: IFFALSE 34506
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34453: LD_ADDR_VAR 0 5
34457: PUSH
34458: LD_EXP 109
34462: PUSH
34463: LD_VAR 0 2
34467: ARRAY
34468: PPUSH
34469: LD_VAR 0 3
34473: PPUSH
34474: CALL_OW 3
34478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34479: LD_ADDR_EXP 109
34483: PUSH
34484: LD_EXP 109
34488: PPUSH
34489: LD_VAR 0 2
34493: PPUSH
34494: LD_VAR 0 5
34498: PPUSH
34499: CALL_OW 1
34503: ST_TO_ADDR
// continue ;
34504: GO 34350
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34506: LD_VAR 0 6
34510: PPUSH
34511: LD_EXP 109
34515: PUSH
34516: LD_VAR 0 2
34520: ARRAY
34521: PUSH
34522: LD_VAR 0 3
34526: ARRAY
34527: PUSH
34528: LD_INT 2
34530: ARRAY
34531: PPUSH
34532: LD_EXP 109
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_VAR 0 3
34547: ARRAY
34548: PUSH
34549: LD_INT 3
34551: ARRAY
34552: PPUSH
34553: LD_INT 30
34555: PPUSH
34556: CALL 57223 0 4
34560: PUSH
34561: LD_INT 4
34563: ARRAY
34564: PUSH
34565: LD_INT 0
34567: EQUAL
34568: IFFALSE 34594
// begin target := mc_crates [ i ] [ j ] ;
34570: LD_ADDR_VAR 0 7
34574: PUSH
34575: LD_EXP 109
34579: PUSH
34580: LD_VAR 0 2
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: ARRAY
34591: ST_TO_ADDR
// break ;
34592: GO 34596
// end ; end ;
34594: GO 34350
34596: POP
34597: POP
// if not target then
34598: LD_VAR 0 7
34602: NOT
34603: IFFALSE 34607
// continue ;
34605: GO 34157
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34607: LD_ADDR_VAR 0 8
34611: PUSH
34612: LD_EXP 112
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PPUSH
34623: LD_INT 2
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 58
34631: PUSH
34632: EMPTY
34633: LIST
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 61
34641: PUSH
34642: EMPTY
34643: LIST
34644: PUSH
34645: LD_INT 33
34647: PUSH
34648: LD_INT 5
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 33
34657: PUSH
34658: LD_INT 3
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 34
34677: PUSH
34678: LD_INT 32
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 34
34687: PUSH
34688: LD_INT 51
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 34
34697: PUSH
34698: LD_INT 12
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PPUSH
34715: CALL_OW 72
34719: ST_TO_ADDR
// if not cargo then
34720: LD_VAR 0 8
34724: NOT
34725: IFFALSE 35431
// begin if mc_crates_collector [ i ] < 5 then
34727: LD_EXP 110
34731: PUSH
34732: LD_VAR 0 2
34736: ARRAY
34737: PUSH
34738: LD_INT 5
34740: LESS
34741: IFFALSE 35107
// begin if mc_ape [ i ] then
34743: LD_EXP 122
34747: PUSH
34748: LD_VAR 0 2
34752: ARRAY
34753: IFFALSE 34800
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34755: LD_ADDR_VAR 0 5
34759: PUSH
34760: LD_EXP 122
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PPUSH
34771: LD_INT 25
34773: PUSH
34774: LD_INT 16
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 24
34783: PUSH
34784: LD_INT 750
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PPUSH
34795: CALL_OW 72
34799: ST_TO_ADDR
// if not tmp then
34800: LD_VAR 0 5
34804: NOT
34805: IFFALSE 34852
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34807: LD_ADDR_VAR 0 5
34811: PUSH
34812: LD_EXP 93
34816: PUSH
34817: LD_VAR 0 2
34821: ARRAY
34822: PPUSH
34823: LD_INT 25
34825: PUSH
34826: LD_INT 2
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 24
34835: PUSH
34836: LD_INT 750
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PPUSH
34847: CALL_OW 72
34851: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34852: LD_EXP 122
34856: PUSH
34857: LD_VAR 0 2
34861: ARRAY
34862: PUSH
34863: LD_EXP 93
34867: PUSH
34868: LD_VAR 0 2
34872: ARRAY
34873: PPUSH
34874: LD_INT 25
34876: PUSH
34877: LD_INT 2
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 24
34886: PUSH
34887: LD_INT 750
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PPUSH
34898: CALL_OW 72
34902: AND
34903: PUSH
34904: LD_VAR 0 5
34908: PUSH
34909: LD_INT 5
34911: LESS
34912: AND
34913: IFFALSE 34995
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34915: LD_ADDR_VAR 0 3
34919: PUSH
34920: LD_EXP 93
34924: PUSH
34925: LD_VAR 0 2
34929: ARRAY
34930: PPUSH
34931: LD_INT 25
34933: PUSH
34934: LD_INT 2
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 24
34943: PUSH
34944: LD_INT 750
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PPUSH
34955: CALL_OW 72
34959: PUSH
34960: FOR_IN
34961: IFFALSE 34993
// begin tmp := tmp union j ;
34963: LD_ADDR_VAR 0 5
34967: PUSH
34968: LD_VAR 0 5
34972: PUSH
34973: LD_VAR 0 3
34977: UNION
34978: ST_TO_ADDR
// if tmp >= 5 then
34979: LD_VAR 0 5
34983: PUSH
34984: LD_INT 5
34986: GREATEREQUAL
34987: IFFALSE 34991
// break ;
34989: GO 34993
// end ;
34991: GO 34960
34993: POP
34994: POP
// end ; if not tmp then
34995: LD_VAR 0 5
34999: NOT
35000: IFFALSE 35004
// continue ;
35002: GO 34157
// for j in tmp do
35004: LD_ADDR_VAR 0 3
35008: PUSH
35009: LD_VAR 0 5
35013: PUSH
35014: FOR_IN
35015: IFFALSE 35105
// if not GetTag ( j ) then
35017: LD_VAR 0 3
35021: PPUSH
35022: CALL_OW 110
35026: NOT
35027: IFFALSE 35103
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35029: LD_ADDR_EXP 110
35033: PUSH
35034: LD_EXP 110
35038: PPUSH
35039: LD_VAR 0 2
35043: PUSH
35044: LD_EXP 110
35048: PUSH
35049: LD_VAR 0 2
35053: ARRAY
35054: PUSH
35055: LD_INT 1
35057: PLUS
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PPUSH
35063: LD_VAR 0 3
35067: PPUSH
35068: CALL 56327 0 3
35072: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35073: LD_VAR 0 3
35077: PPUSH
35078: LD_INT 107
35080: PPUSH
35081: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35085: LD_EXP 110
35089: PUSH
35090: LD_VAR 0 2
35094: ARRAY
35095: PUSH
35096: LD_INT 5
35098: GREATEREQUAL
35099: IFFALSE 35103
// break ;
35101: GO 35105
// end ;
35103: GO 35014
35105: POP
35106: POP
// end ; if mc_crates_collector [ i ] and target then
35107: LD_EXP 110
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: PUSH
35118: LD_VAR 0 7
35122: AND
35123: IFFALSE 35429
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35125: LD_EXP 110
35129: PUSH
35130: LD_VAR 0 2
35134: ARRAY
35135: PUSH
35136: LD_VAR 0 7
35140: PUSH
35141: LD_INT 1
35143: ARRAY
35144: LESS
35145: IFFALSE 35165
// tmp := mc_crates_collector [ i ] else
35147: LD_ADDR_VAR 0 5
35151: PUSH
35152: LD_EXP 110
35156: PUSH
35157: LD_VAR 0 2
35161: ARRAY
35162: ST_TO_ADDR
35163: GO 35179
// tmp := target [ 1 ] ;
35165: LD_ADDR_VAR 0 5
35169: PUSH
35170: LD_VAR 0 7
35174: PUSH
35175: LD_INT 1
35177: ARRAY
35178: ST_TO_ADDR
// k := 0 ;
35179: LD_ADDR_VAR 0 4
35183: PUSH
35184: LD_INT 0
35186: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35187: LD_ADDR_VAR 0 3
35191: PUSH
35192: LD_EXP 110
35196: PUSH
35197: LD_VAR 0 2
35201: ARRAY
35202: PUSH
35203: FOR_IN
35204: IFFALSE 35427
// begin k := k + 1 ;
35206: LD_ADDR_VAR 0 4
35210: PUSH
35211: LD_VAR 0 4
35215: PUSH
35216: LD_INT 1
35218: PLUS
35219: ST_TO_ADDR
// if k > tmp then
35220: LD_VAR 0 4
35224: PUSH
35225: LD_VAR 0 5
35229: GREATER
35230: IFFALSE 35234
// break ;
35232: GO 35427
// if not GetClass ( j ) in [ 2 , 16 ] then
35234: LD_VAR 0 3
35238: PPUSH
35239: CALL_OW 257
35243: PUSH
35244: LD_INT 2
35246: PUSH
35247: LD_INT 16
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: IN
35254: NOT
35255: IFFALSE 35308
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35257: LD_ADDR_EXP 110
35261: PUSH
35262: LD_EXP 110
35266: PPUSH
35267: LD_VAR 0 2
35271: PPUSH
35272: LD_EXP 110
35276: PUSH
35277: LD_VAR 0 2
35281: ARRAY
35282: PUSH
35283: LD_VAR 0 3
35287: DIFF
35288: PPUSH
35289: CALL_OW 1
35293: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35294: LD_VAR 0 3
35298: PPUSH
35299: LD_INT 0
35301: PPUSH
35302: CALL_OW 109
// continue ;
35306: GO 35203
// end ; if IsInUnit ( j ) then
35308: LD_VAR 0 3
35312: PPUSH
35313: CALL_OW 310
35317: IFFALSE 35328
// ComExitBuilding ( j ) ;
35319: LD_VAR 0 3
35323: PPUSH
35324: CALL_OW 122
// wait ( 3 ) ;
35328: LD_INT 3
35330: PPUSH
35331: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35335: LD_VAR 0 3
35339: PPUSH
35340: CALL_OW 314
35344: PUSH
35345: LD_VAR 0 6
35349: PPUSH
35350: LD_VAR 0 7
35354: PUSH
35355: LD_INT 2
35357: ARRAY
35358: PPUSH
35359: LD_VAR 0 7
35363: PUSH
35364: LD_INT 3
35366: ARRAY
35367: PPUSH
35368: LD_INT 30
35370: PPUSH
35371: CALL 57223 0 4
35375: PUSH
35376: LD_INT 4
35378: ARRAY
35379: AND
35380: IFFALSE 35398
// ComStandNearbyBuilding ( j , depot ) else
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_VAR 0 9
35391: PPUSH
35392: CALL 52905 0 2
35396: GO 35425
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35398: LD_VAR 0 3
35402: PPUSH
35403: LD_VAR 0 7
35407: PUSH
35408: LD_INT 2
35410: ARRAY
35411: PPUSH
35412: LD_VAR 0 7
35416: PUSH
35417: LD_INT 3
35419: ARRAY
35420: PPUSH
35421: CALL_OW 117
// end ;
35425: GO 35203
35427: POP
35428: POP
// end ; end else
35429: GO 35961
// begin for j in cargo do
35431: LD_ADDR_VAR 0 3
35435: PUSH
35436: LD_VAR 0 8
35440: PUSH
35441: FOR_IN
35442: IFFALSE 35959
// begin if GetTag ( j ) <> 0 then
35444: LD_VAR 0 3
35448: PPUSH
35449: CALL_OW 110
35453: PUSH
35454: LD_INT 0
35456: NONEQUAL
35457: IFFALSE 35461
// continue ;
35459: GO 35441
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35461: LD_VAR 0 3
35465: PPUSH
35466: CALL_OW 256
35470: PUSH
35471: LD_INT 1000
35473: LESS
35474: PUSH
35475: LD_VAR 0 3
35479: PPUSH
35480: LD_EXP 117
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: PPUSH
35491: CALL_OW 308
35495: NOT
35496: AND
35497: IFFALSE 35519
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35499: LD_VAR 0 3
35503: PPUSH
35504: LD_EXP 117
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PPUSH
35515: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35519: LD_VAR 0 3
35523: PPUSH
35524: CALL_OW 256
35528: PUSH
35529: LD_INT 1000
35531: LESS
35532: PUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: LD_EXP 117
35542: PUSH
35543: LD_VAR 0 2
35547: ARRAY
35548: PPUSH
35549: CALL_OW 308
35553: AND
35554: IFFALSE 35558
// continue ;
35556: GO 35441
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35558: LD_VAR 0 3
35562: PPUSH
35563: CALL_OW 262
35567: PUSH
35568: LD_INT 2
35570: EQUAL
35571: PUSH
35572: LD_VAR 0 3
35576: PPUSH
35577: CALL_OW 261
35581: PUSH
35582: LD_INT 15
35584: LESS
35585: AND
35586: IFFALSE 35590
// continue ;
35588: GO 35441
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35590: LD_VAR 0 3
35594: PPUSH
35595: CALL_OW 262
35599: PUSH
35600: LD_INT 1
35602: EQUAL
35603: PUSH
35604: LD_VAR 0 3
35608: PPUSH
35609: CALL_OW 261
35613: PUSH
35614: LD_INT 10
35616: LESS
35617: AND
35618: IFFALSE 35898
// begin if not depot then
35620: LD_VAR 0 9
35624: NOT
35625: IFFALSE 35629
// continue ;
35627: GO 35441
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35629: LD_VAR 0 3
35633: PPUSH
35634: LD_VAR 0 9
35638: PPUSH
35639: LD_VAR 0 3
35643: PPUSH
35644: CALL_OW 74
35648: PPUSH
35649: CALL_OW 296
35653: PUSH
35654: LD_INT 6
35656: LESS
35657: IFFALSE 35673
// SetFuel ( j , 100 ) else
35659: LD_VAR 0 3
35663: PPUSH
35664: LD_INT 100
35666: PPUSH
35667: CALL_OW 240
35671: GO 35898
// if GetFuel ( j ) = 0 then
35673: LD_VAR 0 3
35677: PPUSH
35678: CALL_OW 261
35682: PUSH
35683: LD_INT 0
35685: EQUAL
35686: IFFALSE 35898
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35688: LD_ADDR_EXP 112
35692: PUSH
35693: LD_EXP 112
35697: PPUSH
35698: LD_VAR 0 2
35702: PPUSH
35703: LD_EXP 112
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_VAR 0 3
35718: DIFF
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35725: LD_VAR 0 3
35729: PPUSH
35730: CALL_OW 263
35734: PUSH
35735: LD_INT 1
35737: EQUAL
35738: IFFALSE 35754
// ComExitVehicle ( IsInUnit ( j ) ) ;
35740: LD_VAR 0 3
35744: PPUSH
35745: CALL_OW 310
35749: PPUSH
35750: CALL_OW 121
// if GetControl ( j ) = control_remote then
35754: LD_VAR 0 3
35758: PPUSH
35759: CALL_OW 263
35763: PUSH
35764: LD_INT 2
35766: EQUAL
35767: IFFALSE 35778
// ComUnlink ( j ) ;
35769: LD_VAR 0 3
35773: PPUSH
35774: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35778: LD_ADDR_VAR 0 10
35782: PUSH
35783: LD_VAR 0 2
35787: PPUSH
35788: LD_INT 3
35790: PPUSH
35791: CALL 45390 0 2
35795: ST_TO_ADDR
// if fac then
35796: LD_VAR 0 10
35800: IFFALSE 35896
// begin for k in fac do
35802: LD_ADDR_VAR 0 4
35806: PUSH
35807: LD_VAR 0 10
35811: PUSH
35812: FOR_IN
35813: IFFALSE 35894
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35815: LD_ADDR_VAR 0 11
35819: PUSH
35820: LD_VAR 0 10
35824: PPUSH
35825: LD_VAR 0 3
35829: PPUSH
35830: CALL_OW 265
35834: PPUSH
35835: LD_VAR 0 3
35839: PPUSH
35840: CALL_OW 262
35844: PPUSH
35845: LD_VAR 0 3
35849: PPUSH
35850: CALL_OW 263
35854: PPUSH
35855: LD_VAR 0 3
35859: PPUSH
35860: CALL_OW 264
35864: PPUSH
35865: CALL 53823 0 5
35869: ST_TO_ADDR
// if components then
35870: LD_VAR 0 11
35874: IFFALSE 35892
// begin MC_InsertProduceList ( i , components ) ;
35876: LD_VAR 0 2
35880: PPUSH
35881: LD_VAR 0 11
35885: PPUSH
35886: CALL 44935 0 2
// break ;
35890: GO 35894
// end ; end ;
35892: GO 35812
35894: POP
35895: POP
// end ; continue ;
35896: GO 35441
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_INT 1
35905: PPUSH
35906: CALL_OW 289
35910: PUSH
35911: LD_INT 100
35913: LESS
35914: PUSH
35915: LD_VAR 0 3
35919: PPUSH
35920: CALL_OW 314
35924: NOT
35925: AND
35926: IFFALSE 35955
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35928: LD_VAR 0 3
35932: PPUSH
35933: LD_VAR 0 7
35937: PUSH
35938: LD_INT 2
35940: ARRAY
35941: PPUSH
35942: LD_VAR 0 7
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL_OW 117
// break ;
35955: GO 35959
// end ;
35957: GO 35441
35959: POP
35960: POP
// end ; end ;
35961: GO 34157
35963: POP
35964: POP
// end ;
35965: LD_VAR 0 1
35969: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35970: LD_INT 0
35972: PPUSH
35973: PPUSH
35974: PPUSH
35975: PPUSH
// if not mc_bases then
35976: LD_EXP 93
35980: NOT
35981: IFFALSE 35985
// exit ;
35983: GO 36146
// for i = 1 to mc_bases do
35985: LD_ADDR_VAR 0 2
35989: PUSH
35990: DOUBLE
35991: LD_INT 1
35993: DEC
35994: ST_TO_ADDR
35995: LD_EXP 93
35999: PUSH
36000: FOR_TO
36001: IFFALSE 36144
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36003: LD_ADDR_VAR 0 4
36007: PUSH
36008: LD_EXP 112
36012: PUSH
36013: LD_VAR 0 2
36017: ARRAY
36018: PUSH
36019: LD_EXP 115
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: UNION
36030: PPUSH
36031: LD_INT 33
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PPUSH
36041: CALL_OW 72
36045: ST_TO_ADDR
// if tmp then
36046: LD_VAR 0 4
36050: IFFALSE 36142
// for j in tmp do
36052: LD_ADDR_VAR 0 3
36056: PUSH
36057: LD_VAR 0 4
36061: PUSH
36062: FOR_IN
36063: IFFALSE 36140
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36065: LD_VAR 0 3
36069: PPUSH
36070: CALL_OW 312
36074: NOT
36075: PUSH
36076: LD_VAR 0 3
36080: PPUSH
36081: CALL_OW 256
36085: PUSH
36086: LD_INT 250
36088: GREATEREQUAL
36089: AND
36090: IFFALSE 36103
// Connect ( j ) else
36092: LD_VAR 0 3
36096: PPUSH
36097: CALL 59298 0 1
36101: GO 36138
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL_OW 256
36112: PUSH
36113: LD_INT 250
36115: LESS
36116: PUSH
36117: LD_VAR 0 3
36121: PPUSH
36122: CALL_OW 312
36126: AND
36127: IFFALSE 36138
// ComUnlink ( j ) ;
36129: LD_VAR 0 3
36133: PPUSH
36134: CALL_OW 136
36138: GO 36062
36140: POP
36141: POP
// end ;
36142: GO 36000
36144: POP
36145: POP
// end ;
36146: LD_VAR 0 1
36150: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36151: LD_INT 0
36153: PPUSH
36154: PPUSH
36155: PPUSH
36156: PPUSH
36157: PPUSH
// if not mc_bases then
36158: LD_EXP 93
36162: NOT
36163: IFFALSE 36167
// exit ;
36165: GO 36612
// for i = 1 to mc_bases do
36167: LD_ADDR_VAR 0 2
36171: PUSH
36172: DOUBLE
36173: LD_INT 1
36175: DEC
36176: ST_TO_ADDR
36177: LD_EXP 93
36181: PUSH
36182: FOR_TO
36183: IFFALSE 36610
// begin if not mc_produce [ i ] then
36185: LD_EXP 114
36189: PUSH
36190: LD_VAR 0 2
36194: ARRAY
36195: NOT
36196: IFFALSE 36200
// continue ;
36198: GO 36182
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36200: LD_ADDR_VAR 0 5
36204: PUSH
36205: LD_EXP 93
36209: PUSH
36210: LD_VAR 0 2
36214: ARRAY
36215: PPUSH
36216: LD_INT 30
36218: PUSH
36219: LD_INT 3
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PPUSH
36226: CALL_OW 72
36230: ST_TO_ADDR
// if not fac then
36231: LD_VAR 0 5
36235: NOT
36236: IFFALSE 36240
// continue ;
36238: GO 36182
// for j in fac do
36240: LD_ADDR_VAR 0 3
36244: PUSH
36245: LD_VAR 0 5
36249: PUSH
36250: FOR_IN
36251: IFFALSE 36606
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36253: LD_VAR 0 3
36257: PPUSH
36258: CALL_OW 461
36262: PUSH
36263: LD_INT 2
36265: NONEQUAL
36266: PUSH
36267: LD_VAR 0 3
36271: PPUSH
36272: LD_INT 15
36274: PPUSH
36275: CALL 58926 0 2
36279: PUSH
36280: LD_INT 4
36282: ARRAY
36283: OR
36284: IFFALSE 36288
// continue ;
36286: GO 36250
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36288: LD_VAR 0 3
36292: PPUSH
36293: LD_EXP 114
36297: PUSH
36298: LD_VAR 0 2
36302: ARRAY
36303: PUSH
36304: LD_INT 1
36306: ARRAY
36307: PUSH
36308: LD_INT 1
36310: ARRAY
36311: PPUSH
36312: LD_EXP 114
36316: PUSH
36317: LD_VAR 0 2
36321: ARRAY
36322: PUSH
36323: LD_INT 1
36325: ARRAY
36326: PUSH
36327: LD_INT 2
36329: ARRAY
36330: PPUSH
36331: LD_EXP 114
36335: PUSH
36336: LD_VAR 0 2
36340: ARRAY
36341: PUSH
36342: LD_INT 1
36344: ARRAY
36345: PUSH
36346: LD_INT 3
36348: ARRAY
36349: PPUSH
36350: LD_EXP 114
36354: PUSH
36355: LD_VAR 0 2
36359: ARRAY
36360: PUSH
36361: LD_INT 1
36363: ARRAY
36364: PUSH
36365: LD_INT 4
36367: ARRAY
36368: PPUSH
36369: CALL_OW 448
36373: PUSH
36374: LD_VAR 0 3
36378: PPUSH
36379: LD_EXP 114
36383: PUSH
36384: LD_VAR 0 2
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: PUSH
36394: LD_INT 1
36396: ARRAY
36397: PUSH
36398: LD_EXP 114
36402: PUSH
36403: LD_VAR 0 2
36407: ARRAY
36408: PUSH
36409: LD_INT 1
36411: ARRAY
36412: PUSH
36413: LD_INT 2
36415: ARRAY
36416: PUSH
36417: LD_EXP 114
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PUSH
36428: LD_INT 1
36430: ARRAY
36431: PUSH
36432: LD_INT 3
36434: ARRAY
36435: PUSH
36436: LD_EXP 114
36440: PUSH
36441: LD_VAR 0 2
36445: ARRAY
36446: PUSH
36447: LD_INT 1
36449: ARRAY
36450: PUSH
36451: LD_INT 4
36453: ARRAY
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: PPUSH
36461: CALL 62693 0 2
36465: AND
36466: IFFALSE 36604
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36468: LD_VAR 0 3
36472: PPUSH
36473: LD_EXP 114
36477: PUSH
36478: LD_VAR 0 2
36482: ARRAY
36483: PUSH
36484: LD_INT 1
36486: ARRAY
36487: PUSH
36488: LD_INT 1
36490: ARRAY
36491: PPUSH
36492: LD_EXP 114
36496: PUSH
36497: LD_VAR 0 2
36501: ARRAY
36502: PUSH
36503: LD_INT 1
36505: ARRAY
36506: PUSH
36507: LD_INT 2
36509: ARRAY
36510: PPUSH
36511: LD_EXP 114
36515: PUSH
36516: LD_VAR 0 2
36520: ARRAY
36521: PUSH
36522: LD_INT 1
36524: ARRAY
36525: PUSH
36526: LD_INT 3
36528: ARRAY
36529: PPUSH
36530: LD_EXP 114
36534: PUSH
36535: LD_VAR 0 2
36539: ARRAY
36540: PUSH
36541: LD_INT 1
36543: ARRAY
36544: PUSH
36545: LD_INT 4
36547: ARRAY
36548: PPUSH
36549: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36553: LD_ADDR_VAR 0 4
36557: PUSH
36558: LD_EXP 114
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PPUSH
36569: LD_INT 1
36571: PPUSH
36572: CALL_OW 3
36576: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36577: LD_ADDR_EXP 114
36581: PUSH
36582: LD_EXP 114
36586: PPUSH
36587: LD_VAR 0 2
36591: PPUSH
36592: LD_VAR 0 4
36596: PPUSH
36597: CALL_OW 1
36601: ST_TO_ADDR
// break ;
36602: GO 36606
// end ; end ;
36604: GO 36250
36606: POP
36607: POP
// end ;
36608: GO 36182
36610: POP
36611: POP
// end ;
36612: LD_VAR 0 1
36616: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36617: LD_INT 0
36619: PPUSH
36620: PPUSH
36621: PPUSH
// if not mc_bases then
36622: LD_EXP 93
36626: NOT
36627: IFFALSE 36631
// exit ;
36629: GO 36720
// for i = 1 to mc_bases do
36631: LD_ADDR_VAR 0 2
36635: PUSH
36636: DOUBLE
36637: LD_INT 1
36639: DEC
36640: ST_TO_ADDR
36641: LD_EXP 93
36645: PUSH
36646: FOR_TO
36647: IFFALSE 36718
// begin if mc_attack [ i ] then
36649: LD_EXP 113
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: IFFALSE 36716
// begin tmp := mc_attack [ i ] [ 1 ] ;
36661: LD_ADDR_VAR 0 3
36665: PUSH
36666: LD_EXP 113
36670: PUSH
36671: LD_VAR 0 2
36675: ARRAY
36676: PUSH
36677: LD_INT 1
36679: ARRAY
36680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36681: LD_ADDR_EXP 113
36685: PUSH
36686: LD_EXP 113
36690: PPUSH
36691: LD_VAR 0 2
36695: PPUSH
36696: EMPTY
36697: PPUSH
36698: CALL_OW 1
36702: ST_TO_ADDR
// Attack ( tmp ) ;
36703: LD_VAR 0 3
36707: PPUSH
36708: CALL 108083 0 1
// exit ;
36712: POP
36713: POP
36714: GO 36720
// end ; end ;
36716: GO 36646
36718: POP
36719: POP
// end ;
36720: LD_VAR 0 1
36724: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36725: LD_INT 0
36727: PPUSH
36728: PPUSH
36729: PPUSH
36730: PPUSH
36731: PPUSH
36732: PPUSH
36733: PPUSH
// if not mc_bases then
36734: LD_EXP 93
36738: NOT
36739: IFFALSE 36743
// exit ;
36741: GO 37453
// for i = 1 to mc_bases do
36743: LD_ADDR_VAR 0 2
36747: PUSH
36748: DOUBLE
36749: LD_INT 1
36751: DEC
36752: ST_TO_ADDR
36753: LD_EXP 93
36757: PUSH
36758: FOR_TO
36759: IFFALSE 37451
// begin if not mc_bases [ i ] then
36761: LD_EXP 93
36765: PUSH
36766: LD_VAR 0 2
36770: ARRAY
36771: NOT
36772: IFFALSE 36776
// continue ;
36774: GO 36758
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36776: LD_ADDR_VAR 0 7
36780: PUSH
36781: LD_EXP 93
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: PUSH
36792: LD_INT 1
36794: ARRAY
36795: PPUSH
36796: CALL 53127 0 1
36800: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36801: LD_ADDR_EXP 116
36805: PUSH
36806: LD_EXP 116
36810: PPUSH
36811: LD_VAR 0 2
36815: PPUSH
36816: LD_EXP 93
36820: PUSH
36821: LD_VAR 0 2
36825: ARRAY
36826: PUSH
36827: LD_INT 1
36829: ARRAY
36830: PPUSH
36831: CALL_OW 255
36835: PPUSH
36836: LD_EXP 118
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: PPUSH
36847: CALL 53092 0 2
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// if not mc_scan [ i ] then
36857: LD_EXP 116
36861: PUSH
36862: LD_VAR 0 2
36866: ARRAY
36867: NOT
36868: IFFALSE 37046
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36870: LD_ADDR_EXP 136
36874: PUSH
36875: LD_EXP 136
36879: PPUSH
36880: LD_VAR 0 2
36884: PPUSH
36885: LD_INT 0
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36893: LD_ADDR_VAR 0 4
36897: PUSH
36898: LD_EXP 93
36902: PUSH
36903: LD_VAR 0 2
36907: ARRAY
36908: PPUSH
36909: LD_INT 2
36911: PUSH
36912: LD_INT 25
36914: PUSH
36915: LD_INT 5
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 25
36924: PUSH
36925: LD_INT 8
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 25
36934: PUSH
36935: LD_INT 9
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: PPUSH
36948: CALL_OW 72
36952: ST_TO_ADDR
// if not tmp then
36953: LD_VAR 0 4
36957: NOT
36958: IFFALSE 36962
// continue ;
36960: GO 36758
// for j in tmp do
36962: LD_ADDR_VAR 0 3
36966: PUSH
36967: LD_VAR 0 4
36971: PUSH
36972: FOR_IN
36973: IFFALSE 37044
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36975: LD_VAR 0 3
36979: PPUSH
36980: CALL_OW 310
36984: PPUSH
36985: CALL_OW 266
36989: PUSH
36990: LD_INT 5
36992: EQUAL
36993: PUSH
36994: LD_VAR 0 3
36998: PPUSH
36999: CALL_OW 257
37003: PUSH
37004: LD_INT 1
37006: EQUAL
37007: AND
37008: PUSH
37009: LD_VAR 0 3
37013: PPUSH
37014: CALL_OW 459
37018: NOT
37019: AND
37020: PUSH
37021: LD_VAR 0 7
37025: AND
37026: IFFALSE 37042
// ComChangeProfession ( j , class ) ;
37028: LD_VAR 0 3
37032: PPUSH
37033: LD_VAR 0 7
37037: PPUSH
37038: CALL_OW 123
37042: GO 36972
37044: POP
37045: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
37046: LD_EXP 116
37050: PUSH
37051: LD_VAR 0 2
37055: ARRAY
37056: PUSH
37057: LD_EXP 136
37061: PUSH
37062: LD_VAR 0 2
37066: ARRAY
37067: NOT
37068: AND
37069: PUSH
37070: LD_EXP 115
37074: PUSH
37075: LD_VAR 0 2
37079: ARRAY
37080: NOT
37081: AND
37082: IFFALSE 37333
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37084: LD_ADDR_EXP 136
37088: PUSH
37089: LD_EXP 136
37093: PPUSH
37094: LD_VAR 0 2
37098: PPUSH
37099: LD_INT 1
37101: PPUSH
37102: CALL_OW 1
37106: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37107: LD_ADDR_VAR 0 4
37111: PUSH
37112: LD_EXP 93
37116: PUSH
37117: LD_VAR 0 2
37121: ARRAY
37122: PPUSH
37123: LD_INT 2
37125: PUSH
37126: LD_INT 25
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 25
37138: PUSH
37139: LD_INT 5
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 25
37148: PUSH
37149: LD_INT 8
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 25
37158: PUSH
37159: LD_INT 9
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: PPUSH
37173: CALL_OW 72
37177: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37178: LD_ADDR_VAR 0 4
37182: PUSH
37183: LD_VAR 0 4
37187: PUSH
37188: LD_VAR 0 4
37192: PPUSH
37193: LD_INT 18
37195: PPUSH
37196: CALL 85596 0 2
37200: DIFF
37201: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37202: LD_VAR 0 4
37206: NOT
37207: PUSH
37208: LD_EXP 93
37212: PUSH
37213: LD_VAR 0 2
37217: ARRAY
37218: PPUSH
37219: LD_INT 2
37221: PUSH
37222: LD_INT 30
37224: PUSH
37225: LD_INT 4
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 30
37234: PUSH
37235: LD_INT 5
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: LIST
37246: PPUSH
37247: CALL_OW 72
37251: NOT
37252: AND
37253: IFFALSE 37315
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37255: LD_ADDR_VAR 0 4
37259: PUSH
37260: LD_EXP 93
37264: PUSH
37265: LD_VAR 0 2
37269: ARRAY
37270: PPUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 25
37276: PUSH
37277: LD_INT 2
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 25
37286: PUSH
37287: LD_INT 3
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 25
37296: PUSH
37297: LD_INT 4
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: PPUSH
37310: CALL_OW 72
37314: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37315: LD_VAR 0 2
37319: PPUSH
37320: LD_VAR 0 4
37324: PPUSH
37325: CALL 112792 0 2
// exit ;
37329: POP
37330: POP
37331: GO 37453
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37333: LD_EXP 116
37337: PUSH
37338: LD_VAR 0 2
37342: ARRAY
37343: PUSH
37344: LD_EXP 136
37348: PUSH
37349: LD_VAR 0 2
37353: ARRAY
37354: NOT
37355: AND
37356: PUSH
37357: LD_EXP 115
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: AND
37368: IFFALSE 37449
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37370: LD_ADDR_EXP 136
37374: PUSH
37375: LD_EXP 136
37379: PPUSH
37380: LD_VAR 0 2
37384: PPUSH
37385: LD_INT 1
37387: PPUSH
37388: CALL_OW 1
37392: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37393: LD_ADDR_VAR 0 4
37397: PUSH
37398: LD_EXP 115
37402: PUSH
37403: LD_VAR 0 2
37407: ARRAY
37408: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37409: LD_ADDR_EXP 115
37413: PUSH
37414: LD_EXP 115
37418: PPUSH
37419: LD_VAR 0 2
37423: PPUSH
37424: EMPTY
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// Defend ( i , tmp ) ;
37431: LD_VAR 0 2
37435: PPUSH
37436: LD_VAR 0 4
37440: PPUSH
37441: CALL 113362 0 2
// exit ;
37445: POP
37446: POP
37447: GO 37453
// end ; end ;
37449: GO 36758
37451: POP
37452: POP
// end ;
37453: LD_VAR 0 1
37457: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37458: LD_INT 0
37460: PPUSH
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
37465: PPUSH
37466: PPUSH
37467: PPUSH
37468: PPUSH
37469: PPUSH
37470: PPUSH
// if not mc_bases then
37471: LD_EXP 93
37475: NOT
37476: IFFALSE 37480
// exit ;
37478: GO 38567
// for i = 1 to mc_bases do
37480: LD_ADDR_VAR 0 2
37484: PUSH
37485: DOUBLE
37486: LD_INT 1
37488: DEC
37489: ST_TO_ADDR
37490: LD_EXP 93
37494: PUSH
37495: FOR_TO
37496: IFFALSE 38565
// begin tmp := mc_lab [ i ] ;
37498: LD_ADDR_VAR 0 6
37502: PUSH
37503: LD_EXP 126
37507: PUSH
37508: LD_VAR 0 2
37512: ARRAY
37513: ST_TO_ADDR
// if not tmp then
37514: LD_VAR 0 6
37518: NOT
37519: IFFALSE 37523
// continue ;
37521: GO 37495
// idle_lab := 0 ;
37523: LD_ADDR_VAR 0 11
37527: PUSH
37528: LD_INT 0
37530: ST_TO_ADDR
// for j in tmp do
37531: LD_ADDR_VAR 0 3
37535: PUSH
37536: LD_VAR 0 6
37540: PUSH
37541: FOR_IN
37542: IFFALSE 38561
// begin researching := false ;
37544: LD_ADDR_VAR 0 10
37548: PUSH
37549: LD_INT 0
37551: ST_TO_ADDR
// side := GetSide ( j ) ;
37552: LD_ADDR_VAR 0 4
37556: PUSH
37557: LD_VAR 0 3
37561: PPUSH
37562: CALL_OW 255
37566: ST_TO_ADDR
// if not mc_tech [ side ] then
37567: LD_EXP 120
37571: PUSH
37572: LD_VAR 0 4
37576: ARRAY
37577: NOT
37578: IFFALSE 37582
// continue ;
37580: GO 37541
// if BuildingStatus ( j ) = bs_idle then
37582: LD_VAR 0 3
37586: PPUSH
37587: CALL_OW 461
37591: PUSH
37592: LD_INT 2
37594: EQUAL
37595: IFFALSE 37783
// begin if idle_lab and UnitsInside ( j ) < 6 then
37597: LD_VAR 0 11
37601: PUSH
37602: LD_VAR 0 3
37606: PPUSH
37607: CALL_OW 313
37611: PUSH
37612: LD_INT 6
37614: LESS
37615: AND
37616: IFFALSE 37687
// begin tmp2 := UnitsInside ( idle_lab ) ;
37618: LD_ADDR_VAR 0 9
37622: PUSH
37623: LD_VAR 0 11
37627: PPUSH
37628: CALL_OW 313
37632: ST_TO_ADDR
// if tmp2 then
37633: LD_VAR 0 9
37637: IFFALSE 37679
// for x in tmp2 do
37639: LD_ADDR_VAR 0 7
37643: PUSH
37644: LD_VAR 0 9
37648: PUSH
37649: FOR_IN
37650: IFFALSE 37677
// begin ComExitBuilding ( x ) ;
37652: LD_VAR 0 7
37656: PPUSH
37657: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37661: LD_VAR 0 7
37665: PPUSH
37666: LD_VAR 0 3
37670: PPUSH
37671: CALL_OW 180
// end ;
37675: GO 37649
37677: POP
37678: POP
// idle_lab := 0 ;
37679: LD_ADDR_VAR 0 11
37683: PUSH
37684: LD_INT 0
37686: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37687: LD_ADDR_VAR 0 5
37691: PUSH
37692: LD_EXP 120
37696: PUSH
37697: LD_VAR 0 4
37701: ARRAY
37702: PUSH
37703: FOR_IN
37704: IFFALSE 37764
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37706: LD_VAR 0 3
37710: PPUSH
37711: LD_VAR 0 5
37715: PPUSH
37716: CALL_OW 430
37720: PUSH
37721: LD_VAR 0 4
37725: PPUSH
37726: LD_VAR 0 5
37730: PPUSH
37731: CALL 52197 0 2
37735: AND
37736: IFFALSE 37762
// begin researching := true ;
37738: LD_ADDR_VAR 0 10
37742: PUSH
37743: LD_INT 1
37745: ST_TO_ADDR
// ComResearch ( j , t ) ;
37746: LD_VAR 0 3
37750: PPUSH
37751: LD_VAR 0 5
37755: PPUSH
37756: CALL_OW 124
// break ;
37760: GO 37764
// end ;
37762: GO 37703
37764: POP
37765: POP
// if not researching then
37766: LD_VAR 0 10
37770: NOT
37771: IFFALSE 37783
// idle_lab := j ;
37773: LD_ADDR_VAR 0 11
37777: PUSH
37778: LD_VAR 0 3
37782: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37783: LD_VAR 0 3
37787: PPUSH
37788: CALL_OW 461
37792: PUSH
37793: LD_INT 10
37795: EQUAL
37796: IFFALSE 38384
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37798: LD_EXP 122
37802: PUSH
37803: LD_VAR 0 2
37807: ARRAY
37808: NOT
37809: PUSH
37810: LD_EXP 123
37814: PUSH
37815: LD_VAR 0 2
37819: ARRAY
37820: NOT
37821: AND
37822: PUSH
37823: LD_EXP 120
37827: PUSH
37828: LD_VAR 0 4
37832: ARRAY
37833: PUSH
37834: LD_INT 1
37836: GREATER
37837: AND
37838: IFFALSE 37969
// begin ComCancel ( j ) ;
37840: LD_VAR 0 3
37844: PPUSH
37845: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37849: LD_ADDR_EXP 120
37853: PUSH
37854: LD_EXP 120
37858: PPUSH
37859: LD_VAR 0 4
37863: PPUSH
37864: LD_EXP 120
37868: PUSH
37869: LD_VAR 0 4
37873: ARRAY
37874: PPUSH
37875: LD_EXP 120
37879: PUSH
37880: LD_VAR 0 4
37884: ARRAY
37885: PUSH
37886: LD_INT 1
37888: MINUS
37889: PPUSH
37890: LD_EXP 120
37894: PUSH
37895: LD_VAR 0 4
37899: ARRAY
37900: PPUSH
37901: LD_INT 0
37903: PPUSH
37904: CALL 55745 0 4
37908: PPUSH
37909: CALL_OW 1
37913: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37914: LD_ADDR_EXP 120
37918: PUSH
37919: LD_EXP 120
37923: PPUSH
37924: LD_VAR 0 4
37928: PPUSH
37929: LD_EXP 120
37933: PUSH
37934: LD_VAR 0 4
37938: ARRAY
37939: PPUSH
37940: LD_EXP 120
37944: PUSH
37945: LD_VAR 0 4
37949: ARRAY
37950: PPUSH
37951: LD_INT 1
37953: PPUSH
37954: LD_INT 0
37956: PPUSH
37957: CALL 55745 0 4
37961: PPUSH
37962: CALL_OW 1
37966: ST_TO_ADDR
// continue ;
37967: GO 37541
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37969: LD_EXP 122
37973: PUSH
37974: LD_VAR 0 2
37978: ARRAY
37979: PUSH
37980: LD_EXP 123
37984: PUSH
37985: LD_VAR 0 2
37989: ARRAY
37990: NOT
37991: AND
37992: IFFALSE 38119
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37994: LD_ADDR_EXP 123
37998: PUSH
37999: LD_EXP 123
38003: PPUSH
38004: LD_VAR 0 2
38008: PUSH
38009: LD_EXP 123
38013: PUSH
38014: LD_VAR 0 2
38018: ARRAY
38019: PUSH
38020: LD_INT 1
38022: PLUS
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PPUSH
38028: LD_EXP 122
38032: PUSH
38033: LD_VAR 0 2
38037: ARRAY
38038: PUSH
38039: LD_INT 1
38041: ARRAY
38042: PPUSH
38043: CALL 56327 0 3
38047: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38048: LD_EXP 122
38052: PUSH
38053: LD_VAR 0 2
38057: ARRAY
38058: PUSH
38059: LD_INT 1
38061: ARRAY
38062: PPUSH
38063: LD_INT 112
38065: PPUSH
38066: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38070: LD_ADDR_VAR 0 9
38074: PUSH
38075: LD_EXP 122
38079: PUSH
38080: LD_VAR 0 2
38084: ARRAY
38085: PPUSH
38086: LD_INT 1
38088: PPUSH
38089: CALL_OW 3
38093: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38094: LD_ADDR_EXP 122
38098: PUSH
38099: LD_EXP 122
38103: PPUSH
38104: LD_VAR 0 2
38108: PPUSH
38109: LD_VAR 0 9
38113: PPUSH
38114: CALL_OW 1
38118: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38119: LD_EXP 122
38123: PUSH
38124: LD_VAR 0 2
38128: ARRAY
38129: PUSH
38130: LD_EXP 123
38134: PUSH
38135: LD_VAR 0 2
38139: ARRAY
38140: AND
38141: PUSH
38142: LD_EXP 123
38146: PUSH
38147: LD_VAR 0 2
38151: ARRAY
38152: PUSH
38153: LD_INT 1
38155: ARRAY
38156: PPUSH
38157: CALL_OW 310
38161: NOT
38162: AND
38163: PUSH
38164: LD_VAR 0 3
38168: PPUSH
38169: CALL_OW 313
38173: PUSH
38174: LD_INT 6
38176: EQUAL
38177: AND
38178: IFFALSE 38234
// begin tmp2 := UnitsInside ( j ) ;
38180: LD_ADDR_VAR 0 9
38184: PUSH
38185: LD_VAR 0 3
38189: PPUSH
38190: CALL_OW 313
38194: ST_TO_ADDR
// if tmp2 = 6 then
38195: LD_VAR 0 9
38199: PUSH
38200: LD_INT 6
38202: EQUAL
38203: IFFALSE 38234
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38205: LD_VAR 0 9
38209: PUSH
38210: LD_INT 1
38212: ARRAY
38213: PPUSH
38214: LD_INT 112
38216: PPUSH
38217: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38221: LD_VAR 0 9
38225: PUSH
38226: LD_INT 1
38228: ARRAY
38229: PPUSH
38230: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38234: LD_EXP 123
38238: PUSH
38239: LD_VAR 0 2
38243: ARRAY
38244: PUSH
38245: LD_EXP 123
38249: PUSH
38250: LD_VAR 0 2
38254: ARRAY
38255: PUSH
38256: LD_INT 1
38258: ARRAY
38259: PPUSH
38260: CALL_OW 314
38264: NOT
38265: AND
38266: PUSH
38267: LD_EXP 123
38271: PUSH
38272: LD_VAR 0 2
38276: ARRAY
38277: PUSH
38278: LD_INT 1
38280: ARRAY
38281: PPUSH
38282: CALL_OW 310
38286: NOT
38287: AND
38288: IFFALSE 38314
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38290: LD_EXP 123
38294: PUSH
38295: LD_VAR 0 2
38299: ARRAY
38300: PUSH
38301: LD_INT 1
38303: ARRAY
38304: PPUSH
38305: LD_VAR 0 3
38309: PPUSH
38310: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38314: LD_EXP 123
38318: PUSH
38319: LD_VAR 0 2
38323: ARRAY
38324: PUSH
38325: LD_INT 1
38327: ARRAY
38328: PPUSH
38329: CALL_OW 310
38333: PUSH
38334: LD_EXP 123
38338: PUSH
38339: LD_VAR 0 2
38343: ARRAY
38344: PUSH
38345: LD_INT 1
38347: ARRAY
38348: PPUSH
38349: CALL_OW 310
38353: PPUSH
38354: CALL_OW 461
38358: PUSH
38359: LD_INT 3
38361: NONEQUAL
38362: AND
38363: IFFALSE 38384
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38365: LD_EXP 123
38369: PUSH
38370: LD_VAR 0 2
38374: ARRAY
38375: PUSH
38376: LD_INT 1
38378: ARRAY
38379: PPUSH
38380: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38384: LD_VAR 0 3
38388: PPUSH
38389: CALL_OW 461
38393: PUSH
38394: LD_INT 6
38396: EQUAL
38397: PUSH
38398: LD_VAR 0 6
38402: PUSH
38403: LD_INT 1
38405: GREATER
38406: AND
38407: IFFALSE 38559
// begin sci := [ ] ;
38409: LD_ADDR_VAR 0 8
38413: PUSH
38414: EMPTY
38415: ST_TO_ADDR
// for x in ( tmp diff j ) do
38416: LD_ADDR_VAR 0 7
38420: PUSH
38421: LD_VAR 0 6
38425: PUSH
38426: LD_VAR 0 3
38430: DIFF
38431: PUSH
38432: FOR_IN
38433: IFFALSE 38485
// begin if sci = 6 then
38435: LD_VAR 0 8
38439: PUSH
38440: LD_INT 6
38442: EQUAL
38443: IFFALSE 38447
// break ;
38445: GO 38485
// if BuildingStatus ( x ) = bs_idle then
38447: LD_VAR 0 7
38451: PPUSH
38452: CALL_OW 461
38456: PUSH
38457: LD_INT 2
38459: EQUAL
38460: IFFALSE 38483
// sci := sci ^ UnitsInside ( x ) ;
38462: LD_ADDR_VAR 0 8
38466: PUSH
38467: LD_VAR 0 8
38471: PUSH
38472: LD_VAR 0 7
38476: PPUSH
38477: CALL_OW 313
38481: ADD
38482: ST_TO_ADDR
// end ;
38483: GO 38432
38485: POP
38486: POP
// if not sci then
38487: LD_VAR 0 8
38491: NOT
38492: IFFALSE 38496
// continue ;
38494: GO 37541
// for x in sci do
38496: LD_ADDR_VAR 0 7
38500: PUSH
38501: LD_VAR 0 8
38505: PUSH
38506: FOR_IN
38507: IFFALSE 38557
// if IsInUnit ( x ) and not HasTask ( x ) then
38509: LD_VAR 0 7
38513: PPUSH
38514: CALL_OW 310
38518: PUSH
38519: LD_VAR 0 7
38523: PPUSH
38524: CALL_OW 314
38528: NOT
38529: AND
38530: IFFALSE 38555
// begin ComExitBuilding ( x ) ;
38532: LD_VAR 0 7
38536: PPUSH
38537: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38541: LD_VAR 0 7
38545: PPUSH
38546: LD_VAR 0 3
38550: PPUSH
38551: CALL_OW 180
// end ;
38555: GO 38506
38557: POP
38558: POP
// end ; end ;
38559: GO 37541
38561: POP
38562: POP
// end ;
38563: GO 37495
38565: POP
38566: POP
// end ;
38567: LD_VAR 0 1
38571: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38572: LD_INT 0
38574: PPUSH
38575: PPUSH
// if not mc_bases then
38576: LD_EXP 93
38580: NOT
38581: IFFALSE 38585
// exit ;
38583: GO 38666
// for i = 1 to mc_bases do
38585: LD_ADDR_VAR 0 2
38589: PUSH
38590: DOUBLE
38591: LD_INT 1
38593: DEC
38594: ST_TO_ADDR
38595: LD_EXP 93
38599: PUSH
38600: FOR_TO
38601: IFFALSE 38664
// if mc_mines [ i ] and mc_miners [ i ] then
38603: LD_EXP 106
38607: PUSH
38608: LD_VAR 0 2
38612: ARRAY
38613: PUSH
38614: LD_EXP 107
38618: PUSH
38619: LD_VAR 0 2
38623: ARRAY
38624: AND
38625: IFFALSE 38662
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38627: LD_EXP 107
38631: PUSH
38632: LD_VAR 0 2
38636: ARRAY
38637: PUSH
38638: LD_INT 1
38640: ARRAY
38641: PPUSH
38642: CALL_OW 255
38646: PPUSH
38647: LD_EXP 106
38651: PUSH
38652: LD_VAR 0 2
38656: ARRAY
38657: PPUSH
38658: CALL 53280 0 2
38662: GO 38600
38664: POP
38665: POP
// end ;
38666: LD_VAR 0 1
38670: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38671: LD_INT 0
38673: PPUSH
38674: PPUSH
38675: PPUSH
38676: PPUSH
38677: PPUSH
38678: PPUSH
38679: PPUSH
38680: PPUSH
// if not mc_bases or not mc_parking then
38681: LD_EXP 93
38685: NOT
38686: PUSH
38687: LD_EXP 117
38691: NOT
38692: OR
38693: IFFALSE 38697
// exit ;
38695: GO 39407
// for i = 1 to mc_bases do
38697: LD_ADDR_VAR 0 2
38701: PUSH
38702: DOUBLE
38703: LD_INT 1
38705: DEC
38706: ST_TO_ADDR
38707: LD_EXP 93
38711: PUSH
38712: FOR_TO
38713: IFFALSE 39405
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38715: LD_EXP 93
38719: PUSH
38720: LD_VAR 0 2
38724: ARRAY
38725: NOT
38726: PUSH
38727: LD_EXP 117
38731: PUSH
38732: LD_VAR 0 2
38736: ARRAY
38737: NOT
38738: OR
38739: IFFALSE 38743
// continue ;
38741: GO 38712
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38743: LD_ADDR_VAR 0 5
38747: PUSH
38748: LD_EXP 93
38752: PUSH
38753: LD_VAR 0 2
38757: ARRAY
38758: PUSH
38759: LD_INT 1
38761: ARRAY
38762: PPUSH
38763: CALL_OW 255
38767: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38768: LD_ADDR_VAR 0 6
38772: PUSH
38773: LD_EXP 93
38777: PUSH
38778: LD_VAR 0 2
38782: ARRAY
38783: PPUSH
38784: LD_INT 30
38786: PUSH
38787: LD_INT 3
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PPUSH
38794: CALL_OW 72
38798: ST_TO_ADDR
// if not fac then
38799: LD_VAR 0 6
38803: NOT
38804: IFFALSE 38855
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38806: LD_ADDR_VAR 0 6
38810: PUSH
38811: LD_EXP 93
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: PPUSH
38822: LD_INT 2
38824: PUSH
38825: LD_INT 30
38827: PUSH
38828: LD_INT 0
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 30
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: PPUSH
38850: CALL_OW 72
38854: ST_TO_ADDR
// if not fac then
38855: LD_VAR 0 6
38859: NOT
38860: IFFALSE 38864
// continue ;
38862: GO 38712
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38864: LD_ADDR_VAR 0 7
38868: PUSH
38869: LD_EXP 117
38873: PUSH
38874: LD_VAR 0 2
38878: ARRAY
38879: PPUSH
38880: LD_INT 22
38882: PUSH
38883: LD_VAR 0 5
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 21
38894: PUSH
38895: LD_INT 2
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: LD_INT 24
38907: PUSH
38908: LD_INT 1000
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: LIST
38923: PPUSH
38924: CALL_OW 70
38928: ST_TO_ADDR
// for j in fac do
38929: LD_ADDR_VAR 0 3
38933: PUSH
38934: LD_VAR 0 6
38938: PUSH
38939: FOR_IN
38940: IFFALSE 39021
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38942: LD_ADDR_VAR 0 7
38946: PUSH
38947: LD_VAR 0 7
38951: PUSH
38952: LD_INT 22
38954: PUSH
38955: LD_VAR 0 5
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 91
38966: PUSH
38967: LD_VAR 0 3
38971: PUSH
38972: LD_INT 15
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 21
38982: PUSH
38983: LD_INT 2
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: PUSH
38993: LD_INT 24
38995: PUSH
38996: LD_INT 1000
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: PPUSH
39013: CALL_OW 69
39017: UNION
39018: ST_TO_ADDR
39019: GO 38939
39021: POP
39022: POP
// if not vehs then
39023: LD_VAR 0 7
39027: NOT
39028: IFFALSE 39054
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39030: LD_ADDR_EXP 105
39034: PUSH
39035: LD_EXP 105
39039: PPUSH
39040: LD_VAR 0 2
39044: PPUSH
39045: EMPTY
39046: PPUSH
39047: CALL_OW 1
39051: ST_TO_ADDR
// continue ;
39052: GO 38712
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39054: LD_ADDR_VAR 0 8
39058: PUSH
39059: LD_EXP 93
39063: PUSH
39064: LD_VAR 0 2
39068: ARRAY
39069: PPUSH
39070: LD_INT 30
39072: PUSH
39073: LD_INT 3
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PPUSH
39080: CALL_OW 72
39084: ST_TO_ADDR
// if tmp then
39085: LD_VAR 0 8
39089: IFFALSE 39192
// begin for j in tmp do
39091: LD_ADDR_VAR 0 3
39095: PUSH
39096: LD_VAR 0 8
39100: PUSH
39101: FOR_IN
39102: IFFALSE 39190
// for k in UnitsInside ( j ) do
39104: LD_ADDR_VAR 0 4
39108: PUSH
39109: LD_VAR 0 3
39113: PPUSH
39114: CALL_OW 313
39118: PUSH
39119: FOR_IN
39120: IFFALSE 39186
// if k then
39122: LD_VAR 0 4
39126: IFFALSE 39184
// if not k in mc_repair_vehicle [ i ] then
39128: LD_VAR 0 4
39132: PUSH
39133: LD_EXP 105
39137: PUSH
39138: LD_VAR 0 2
39142: ARRAY
39143: IN
39144: NOT
39145: IFFALSE 39184
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39147: LD_ADDR_EXP 105
39151: PUSH
39152: LD_EXP 105
39156: PPUSH
39157: LD_VAR 0 2
39161: PPUSH
39162: LD_EXP 105
39166: PUSH
39167: LD_VAR 0 2
39171: ARRAY
39172: PUSH
39173: LD_VAR 0 4
39177: UNION
39178: PPUSH
39179: CALL_OW 1
39183: ST_TO_ADDR
39184: GO 39119
39186: POP
39187: POP
39188: GO 39101
39190: POP
39191: POP
// end ; if not mc_repair_vehicle [ i ] then
39192: LD_EXP 105
39196: PUSH
39197: LD_VAR 0 2
39201: ARRAY
39202: NOT
39203: IFFALSE 39207
// continue ;
39205: GO 38712
// for j in mc_repair_vehicle [ i ] do
39207: LD_ADDR_VAR 0 3
39211: PUSH
39212: LD_EXP 105
39216: PUSH
39217: LD_VAR 0 2
39221: ARRAY
39222: PUSH
39223: FOR_IN
39224: IFFALSE 39401
// begin if GetClass ( j ) <> 3 then
39226: LD_VAR 0 3
39230: PPUSH
39231: CALL_OW 257
39235: PUSH
39236: LD_INT 3
39238: NONEQUAL
39239: IFFALSE 39280
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39241: LD_ADDR_EXP 105
39245: PUSH
39246: LD_EXP 105
39250: PPUSH
39251: LD_VAR 0 2
39255: PPUSH
39256: LD_EXP 105
39260: PUSH
39261: LD_VAR 0 2
39265: ARRAY
39266: PUSH
39267: LD_VAR 0 3
39271: DIFF
39272: PPUSH
39273: CALL_OW 1
39277: ST_TO_ADDR
// continue ;
39278: GO 39223
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39280: LD_VAR 0 3
39284: PPUSH
39285: CALL_OW 311
39289: NOT
39290: PUSH
39291: LD_VAR 0 3
39295: PUSH
39296: LD_EXP 96
39300: PUSH
39301: LD_VAR 0 2
39305: ARRAY
39306: PUSH
39307: LD_INT 1
39309: ARRAY
39310: IN
39311: NOT
39312: AND
39313: PUSH
39314: LD_VAR 0 3
39318: PUSH
39319: LD_EXP 96
39323: PUSH
39324: LD_VAR 0 2
39328: ARRAY
39329: PUSH
39330: LD_INT 2
39332: ARRAY
39333: IN
39334: NOT
39335: AND
39336: IFFALSE 39399
// begin if IsInUnit ( j ) then
39338: LD_VAR 0 3
39342: PPUSH
39343: CALL_OW 310
39347: IFFALSE 39360
// ComExitBuilding ( j ) else
39349: LD_VAR 0 3
39353: PPUSH
39354: CALL_OW 122
39358: GO 39399
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39360: LD_VAR 0 3
39364: PPUSH
39365: LD_VAR 0 7
39369: PUSH
39370: LD_INT 1
39372: ARRAY
39373: PPUSH
39374: CALL 89934 0 2
39378: NOT
39379: IFFALSE 39399
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39381: LD_VAR 0 3
39385: PPUSH
39386: LD_VAR 0 7
39390: PUSH
39391: LD_INT 1
39393: ARRAY
39394: PPUSH
39395: CALL_OW 129
// end ; end ;
39399: GO 39223
39401: POP
39402: POP
// end ;
39403: GO 38712
39405: POP
39406: POP
// end ;
39407: LD_VAR 0 1
39411: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39412: LD_INT 0
39414: PPUSH
39415: PPUSH
39416: PPUSH
39417: PPUSH
39418: PPUSH
39419: PPUSH
39420: PPUSH
39421: PPUSH
39422: PPUSH
39423: PPUSH
39424: PPUSH
// if not mc_bases then
39425: LD_EXP 93
39429: NOT
39430: IFFALSE 39434
// exit ;
39432: GO 40236
// for i = 1 to mc_bases do
39434: LD_ADDR_VAR 0 2
39438: PUSH
39439: DOUBLE
39440: LD_INT 1
39442: DEC
39443: ST_TO_ADDR
39444: LD_EXP 93
39448: PUSH
39449: FOR_TO
39450: IFFALSE 40234
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39452: LD_EXP 121
39456: PUSH
39457: LD_VAR 0 2
39461: ARRAY
39462: NOT
39463: PUSH
39464: LD_EXP 96
39468: PUSH
39469: LD_VAR 0 2
39473: ARRAY
39474: PUSH
39475: LD_INT 1
39477: ARRAY
39478: OR
39479: PUSH
39480: LD_EXP 96
39484: PUSH
39485: LD_VAR 0 2
39489: ARRAY
39490: PUSH
39491: LD_INT 2
39493: ARRAY
39494: OR
39495: PUSH
39496: LD_EXP 119
39500: PUSH
39501: LD_VAR 0 2
39505: ARRAY
39506: PPUSH
39507: LD_INT 1
39509: PPUSH
39510: CALL_OW 325
39514: NOT
39515: OR
39516: PUSH
39517: LD_EXP 116
39521: PUSH
39522: LD_VAR 0 2
39526: ARRAY
39527: OR
39528: IFFALSE 39532
// continue ;
39530: GO 39449
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39532: LD_ADDR_VAR 0 8
39536: PUSH
39537: LD_EXP 93
39541: PUSH
39542: LD_VAR 0 2
39546: ARRAY
39547: PPUSH
39548: LD_INT 25
39550: PUSH
39551: LD_INT 4
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 50
39560: PUSH
39561: EMPTY
39562: LIST
39563: PUSH
39564: LD_INT 3
39566: PUSH
39567: LD_INT 60
39569: PUSH
39570: EMPTY
39571: LIST
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: LIST
39581: PPUSH
39582: CALL_OW 72
39586: PUSH
39587: LD_EXP 97
39591: PUSH
39592: LD_VAR 0 2
39596: ARRAY
39597: DIFF
39598: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39599: LD_ADDR_VAR 0 9
39603: PUSH
39604: LD_EXP 93
39608: PUSH
39609: LD_VAR 0 2
39613: ARRAY
39614: PPUSH
39615: LD_INT 2
39617: PUSH
39618: LD_INT 30
39620: PUSH
39621: LD_INT 0
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 30
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: LIST
39642: PPUSH
39643: CALL_OW 72
39647: ST_TO_ADDR
// if not tmp or not dep then
39648: LD_VAR 0 8
39652: NOT
39653: PUSH
39654: LD_VAR 0 9
39658: NOT
39659: OR
39660: IFFALSE 39664
// continue ;
39662: GO 39449
// side := GetSide ( tmp [ 1 ] ) ;
39664: LD_ADDR_VAR 0 11
39668: PUSH
39669: LD_VAR 0 8
39673: PUSH
39674: LD_INT 1
39676: ARRAY
39677: PPUSH
39678: CALL_OW 255
39682: ST_TO_ADDR
// dep := dep [ 1 ] ;
39683: LD_ADDR_VAR 0 9
39687: PUSH
39688: LD_VAR 0 9
39692: PUSH
39693: LD_INT 1
39695: ARRAY
39696: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39697: LD_ADDR_VAR 0 7
39701: PUSH
39702: LD_EXP 121
39706: PUSH
39707: LD_VAR 0 2
39711: ARRAY
39712: PPUSH
39713: LD_INT 22
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 25
39725: PUSH
39726: LD_INT 12
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PPUSH
39737: CALL_OW 70
39741: PUSH
39742: LD_INT 22
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 25
39754: PUSH
39755: LD_INT 12
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 91
39764: PUSH
39765: LD_VAR 0 9
39769: PUSH
39770: LD_INT 20
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: LIST
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: LIST
39782: PPUSH
39783: CALL_OW 69
39787: UNION
39788: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39789: LD_ADDR_VAR 0 10
39793: PUSH
39794: LD_EXP 121
39798: PUSH
39799: LD_VAR 0 2
39803: ARRAY
39804: PPUSH
39805: LD_INT 81
39807: PUSH
39808: LD_VAR 0 11
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PPUSH
39817: CALL_OW 70
39821: ST_TO_ADDR
// if not apes or danger_at_area then
39822: LD_VAR 0 7
39826: NOT
39827: PUSH
39828: LD_VAR 0 10
39832: OR
39833: IFFALSE 39883
// begin if mc_taming [ i ] then
39835: LD_EXP 124
39839: PUSH
39840: LD_VAR 0 2
39844: ARRAY
39845: IFFALSE 39881
// begin MC_Reset ( i , 121 ) ;
39847: LD_VAR 0 2
39851: PPUSH
39852: LD_INT 121
39854: PPUSH
39855: CALL 25016 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39859: LD_ADDR_EXP 124
39863: PUSH
39864: LD_EXP 124
39868: PPUSH
39869: LD_VAR 0 2
39873: PPUSH
39874: EMPTY
39875: PPUSH
39876: CALL_OW 1
39880: ST_TO_ADDR
// end ; continue ;
39881: GO 39449
// end ; for j in tmp do
39883: LD_ADDR_VAR 0 3
39887: PUSH
39888: LD_VAR 0 8
39892: PUSH
39893: FOR_IN
39894: IFFALSE 40230
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39896: LD_VAR 0 3
39900: PUSH
39901: LD_EXP 124
39905: PUSH
39906: LD_VAR 0 2
39910: ARRAY
39911: IN
39912: NOT
39913: PUSH
39914: LD_EXP 124
39918: PUSH
39919: LD_VAR 0 2
39923: ARRAY
39924: PUSH
39925: LD_INT 3
39927: LESS
39928: AND
39929: IFFALSE 39987
// begin SetTag ( j , 121 ) ;
39931: LD_VAR 0 3
39935: PPUSH
39936: LD_INT 121
39938: PPUSH
39939: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39943: LD_ADDR_EXP 124
39947: PUSH
39948: LD_EXP 124
39952: PPUSH
39953: LD_VAR 0 2
39957: PUSH
39958: LD_EXP 124
39962: PUSH
39963: LD_VAR 0 2
39967: ARRAY
39968: PUSH
39969: LD_INT 1
39971: PLUS
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PPUSH
39977: LD_VAR 0 3
39981: PPUSH
39982: CALL 56327 0 3
39986: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39987: LD_VAR 0 3
39991: PUSH
39992: LD_EXP 124
39996: PUSH
39997: LD_VAR 0 2
40001: ARRAY
40002: IN
40003: IFFALSE 40228
// begin if GetClass ( j ) <> 4 then
40005: LD_VAR 0 3
40009: PPUSH
40010: CALL_OW 257
40014: PUSH
40015: LD_INT 4
40017: NONEQUAL
40018: IFFALSE 40071
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40020: LD_ADDR_EXP 124
40024: PUSH
40025: LD_EXP 124
40029: PPUSH
40030: LD_VAR 0 2
40034: PPUSH
40035: LD_EXP 124
40039: PUSH
40040: LD_VAR 0 2
40044: ARRAY
40045: PUSH
40046: LD_VAR 0 3
40050: DIFF
40051: PPUSH
40052: CALL_OW 1
40056: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40057: LD_VAR 0 3
40061: PPUSH
40062: LD_INT 0
40064: PPUSH
40065: CALL_OW 109
// continue ;
40069: GO 39893
// end ; if IsInUnit ( j ) then
40071: LD_VAR 0 3
40075: PPUSH
40076: CALL_OW 310
40080: IFFALSE 40091
// ComExitBuilding ( j ) ;
40082: LD_VAR 0 3
40086: PPUSH
40087: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40091: LD_ADDR_VAR 0 6
40095: PUSH
40096: LD_VAR 0 7
40100: PPUSH
40101: LD_VAR 0 3
40105: PPUSH
40106: CALL_OW 74
40110: ST_TO_ADDR
// if not ape then
40111: LD_VAR 0 6
40115: NOT
40116: IFFALSE 40120
// break ;
40118: GO 40230
// x := GetX ( ape ) ;
40120: LD_ADDR_VAR 0 4
40124: PUSH
40125: LD_VAR 0 6
40129: PPUSH
40130: CALL_OW 250
40134: ST_TO_ADDR
// y := GetY ( ape ) ;
40135: LD_ADDR_VAR 0 5
40139: PUSH
40140: LD_VAR 0 6
40144: PPUSH
40145: CALL_OW 251
40149: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40150: LD_VAR 0 4
40154: PPUSH
40155: LD_VAR 0 5
40159: PPUSH
40160: CALL_OW 488
40164: NOT
40165: PUSH
40166: LD_VAR 0 11
40170: PPUSH
40171: LD_VAR 0 4
40175: PPUSH
40176: LD_VAR 0 5
40180: PPUSH
40181: LD_INT 20
40183: PPUSH
40184: CALL 57223 0 4
40188: PUSH
40189: LD_INT 4
40191: ARRAY
40192: OR
40193: IFFALSE 40197
// break ;
40195: GO 40230
// if not HasTask ( j ) then
40197: LD_VAR 0 3
40201: PPUSH
40202: CALL_OW 314
40206: NOT
40207: IFFALSE 40228
// ComTameXY ( j , x , y ) ;
40209: LD_VAR 0 3
40213: PPUSH
40214: LD_VAR 0 4
40218: PPUSH
40219: LD_VAR 0 5
40223: PPUSH
40224: CALL_OW 131
// end ; end ;
40228: GO 39893
40230: POP
40231: POP
// end ;
40232: GO 39449
40234: POP
40235: POP
// end ;
40236: LD_VAR 0 1
40240: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40241: LD_INT 0
40243: PPUSH
40244: PPUSH
40245: PPUSH
40246: PPUSH
40247: PPUSH
40248: PPUSH
40249: PPUSH
40250: PPUSH
// if not mc_bases then
40251: LD_EXP 93
40255: NOT
40256: IFFALSE 40260
// exit ;
40258: GO 40886
// for i = 1 to mc_bases do
40260: LD_ADDR_VAR 0 2
40264: PUSH
40265: DOUBLE
40266: LD_INT 1
40268: DEC
40269: ST_TO_ADDR
40270: LD_EXP 93
40274: PUSH
40275: FOR_TO
40276: IFFALSE 40884
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40278: LD_EXP 122
40282: PUSH
40283: LD_VAR 0 2
40287: ARRAY
40288: NOT
40289: PUSH
40290: LD_EXP 122
40294: PUSH
40295: LD_VAR 0 2
40299: ARRAY
40300: PPUSH
40301: LD_INT 25
40303: PUSH
40304: LD_INT 12
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PPUSH
40311: CALL_OW 72
40315: NOT
40316: OR
40317: IFFALSE 40321
// continue ;
40319: GO 40275
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40321: LD_ADDR_VAR 0 5
40325: PUSH
40326: LD_EXP 122
40330: PUSH
40331: LD_VAR 0 2
40335: ARRAY
40336: PUSH
40337: LD_INT 1
40339: ARRAY
40340: PPUSH
40341: CALL_OW 255
40345: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40346: LD_VAR 0 5
40350: PPUSH
40351: LD_INT 2
40353: PPUSH
40354: CALL_OW 325
40358: IFFALSE 40611
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40360: LD_ADDR_VAR 0 4
40364: PUSH
40365: LD_EXP 122
40369: PUSH
40370: LD_VAR 0 2
40374: ARRAY
40375: PPUSH
40376: LD_INT 25
40378: PUSH
40379: LD_INT 16
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PPUSH
40386: CALL_OW 72
40390: ST_TO_ADDR
// if tmp < 6 then
40391: LD_VAR 0 4
40395: PUSH
40396: LD_INT 6
40398: LESS
40399: IFFALSE 40611
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40401: LD_ADDR_VAR 0 6
40405: PUSH
40406: LD_EXP 93
40410: PUSH
40411: LD_VAR 0 2
40415: ARRAY
40416: PPUSH
40417: LD_INT 2
40419: PUSH
40420: LD_INT 30
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 30
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: LIST
40444: PPUSH
40445: CALL_OW 72
40449: ST_TO_ADDR
// if depot then
40450: LD_VAR 0 6
40454: IFFALSE 40611
// begin selected := 0 ;
40456: LD_ADDR_VAR 0 7
40460: PUSH
40461: LD_INT 0
40463: ST_TO_ADDR
// for j in depot do
40464: LD_ADDR_VAR 0 3
40468: PUSH
40469: LD_VAR 0 6
40473: PUSH
40474: FOR_IN
40475: IFFALSE 40506
// begin if UnitsInside ( j ) < 6 then
40477: LD_VAR 0 3
40481: PPUSH
40482: CALL_OW 313
40486: PUSH
40487: LD_INT 6
40489: LESS
40490: IFFALSE 40504
// begin selected := j ;
40492: LD_ADDR_VAR 0 7
40496: PUSH
40497: LD_VAR 0 3
40501: ST_TO_ADDR
// break ;
40502: GO 40506
// end ; end ;
40504: GO 40474
40506: POP
40507: POP
// if selected then
40508: LD_VAR 0 7
40512: IFFALSE 40611
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40514: LD_ADDR_VAR 0 3
40518: PUSH
40519: LD_EXP 122
40523: PUSH
40524: LD_VAR 0 2
40528: ARRAY
40529: PPUSH
40530: LD_INT 25
40532: PUSH
40533: LD_INT 12
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PPUSH
40540: CALL_OW 72
40544: PUSH
40545: FOR_IN
40546: IFFALSE 40609
// if not HasTask ( j ) then
40548: LD_VAR 0 3
40552: PPUSH
40553: CALL_OW 314
40557: NOT
40558: IFFALSE 40607
// begin if not IsInUnit ( j ) then
40560: LD_VAR 0 3
40564: PPUSH
40565: CALL_OW 310
40569: NOT
40570: IFFALSE 40586
// ComEnterUnit ( j , selected ) ;
40572: LD_VAR 0 3
40576: PPUSH
40577: LD_VAR 0 7
40581: PPUSH
40582: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40586: LD_VAR 0 3
40590: PPUSH
40591: LD_INT 16
40593: PPUSH
40594: CALL_OW 183
// AddComExitBuilding ( j ) ;
40598: LD_VAR 0 3
40602: PPUSH
40603: CALL_OW 182
// end ;
40607: GO 40545
40609: POP
40610: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40611: LD_VAR 0 5
40615: PPUSH
40616: LD_INT 11
40618: PPUSH
40619: CALL_OW 325
40623: IFFALSE 40882
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40625: LD_ADDR_VAR 0 4
40629: PUSH
40630: LD_EXP 122
40634: PUSH
40635: LD_VAR 0 2
40639: ARRAY
40640: PPUSH
40641: LD_INT 25
40643: PUSH
40644: LD_INT 16
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PPUSH
40651: CALL_OW 72
40655: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40656: LD_VAR 0 4
40660: PUSH
40661: LD_INT 6
40663: GREATEREQUAL
40664: PUSH
40665: LD_VAR 0 5
40669: PPUSH
40670: LD_INT 2
40672: PPUSH
40673: CALL_OW 325
40677: NOT
40678: OR
40679: IFFALSE 40882
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40681: LD_ADDR_VAR 0 8
40685: PUSH
40686: LD_EXP 93
40690: PUSH
40691: LD_VAR 0 2
40695: ARRAY
40696: PPUSH
40697: LD_INT 2
40699: PUSH
40700: LD_INT 30
40702: PUSH
40703: LD_INT 4
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 30
40712: PUSH
40713: LD_INT 5
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: LIST
40724: PPUSH
40725: CALL_OW 72
40729: ST_TO_ADDR
// if barracks then
40730: LD_VAR 0 8
40734: IFFALSE 40882
// begin selected := 0 ;
40736: LD_ADDR_VAR 0 7
40740: PUSH
40741: LD_INT 0
40743: ST_TO_ADDR
// for j in barracks do
40744: LD_ADDR_VAR 0 3
40748: PUSH
40749: LD_VAR 0 8
40753: PUSH
40754: FOR_IN
40755: IFFALSE 40786
// begin if UnitsInside ( j ) < 6 then
40757: LD_VAR 0 3
40761: PPUSH
40762: CALL_OW 313
40766: PUSH
40767: LD_INT 6
40769: LESS
40770: IFFALSE 40784
// begin selected := j ;
40772: LD_ADDR_VAR 0 7
40776: PUSH
40777: LD_VAR 0 3
40781: ST_TO_ADDR
// break ;
40782: GO 40786
// end ; end ;
40784: GO 40754
40786: POP
40787: POP
// if selected then
40788: LD_VAR 0 7
40792: IFFALSE 40882
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40794: LD_ADDR_VAR 0 3
40798: PUSH
40799: LD_EXP 122
40803: PUSH
40804: LD_VAR 0 2
40808: ARRAY
40809: PPUSH
40810: LD_INT 25
40812: PUSH
40813: LD_INT 12
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PPUSH
40820: CALL_OW 72
40824: PUSH
40825: FOR_IN
40826: IFFALSE 40880
// if not IsInUnit ( j ) and not HasTask ( j ) then
40828: LD_VAR 0 3
40832: PPUSH
40833: CALL_OW 310
40837: NOT
40838: PUSH
40839: LD_VAR 0 3
40843: PPUSH
40844: CALL_OW 314
40848: NOT
40849: AND
40850: IFFALSE 40878
// begin ComEnterUnit ( j , selected ) ;
40852: LD_VAR 0 3
40856: PPUSH
40857: LD_VAR 0 7
40861: PPUSH
40862: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40866: LD_VAR 0 3
40870: PPUSH
40871: LD_INT 15
40873: PPUSH
40874: CALL_OW 183
// end ;
40878: GO 40825
40880: POP
40881: POP
// end ; end ; end ; end ; end ;
40882: GO 40275
40884: POP
40885: POP
// end ;
40886: LD_VAR 0 1
40890: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40891: LD_INT 0
40893: PPUSH
40894: PPUSH
40895: PPUSH
40896: PPUSH
// if not mc_bases then
40897: LD_EXP 93
40901: NOT
40902: IFFALSE 40906
// exit ;
40904: GO 41084
// for i = 1 to mc_bases do
40906: LD_ADDR_VAR 0 2
40910: PUSH
40911: DOUBLE
40912: LD_INT 1
40914: DEC
40915: ST_TO_ADDR
40916: LD_EXP 93
40920: PUSH
40921: FOR_TO
40922: IFFALSE 41082
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40924: LD_ADDR_VAR 0 4
40928: PUSH
40929: LD_EXP 93
40933: PUSH
40934: LD_VAR 0 2
40938: ARRAY
40939: PPUSH
40940: LD_INT 25
40942: PUSH
40943: LD_INT 9
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PPUSH
40950: CALL_OW 72
40954: ST_TO_ADDR
// if not tmp then
40955: LD_VAR 0 4
40959: NOT
40960: IFFALSE 40964
// continue ;
40962: GO 40921
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40964: LD_EXP 119
40968: PUSH
40969: LD_VAR 0 2
40973: ARRAY
40974: PPUSH
40975: LD_INT 29
40977: PPUSH
40978: CALL_OW 325
40982: NOT
40983: PUSH
40984: LD_EXP 119
40988: PUSH
40989: LD_VAR 0 2
40993: ARRAY
40994: PPUSH
40995: LD_INT 28
40997: PPUSH
40998: CALL_OW 325
41002: NOT
41003: AND
41004: IFFALSE 41008
// continue ;
41006: GO 40921
// for j in tmp do
41008: LD_ADDR_VAR 0 3
41012: PUSH
41013: LD_VAR 0 4
41017: PUSH
41018: FOR_IN
41019: IFFALSE 41078
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41021: LD_VAR 0 3
41025: PUSH
41026: LD_EXP 96
41030: PUSH
41031: LD_VAR 0 2
41035: ARRAY
41036: PUSH
41037: LD_INT 1
41039: ARRAY
41040: IN
41041: NOT
41042: PUSH
41043: LD_VAR 0 3
41047: PUSH
41048: LD_EXP 96
41052: PUSH
41053: LD_VAR 0 2
41057: ARRAY
41058: PUSH
41059: LD_INT 2
41061: ARRAY
41062: IN
41063: NOT
41064: AND
41065: IFFALSE 41076
// ComSpaceTimeShoot ( j ) ;
41067: LD_VAR 0 3
41071: PPUSH
41072: CALL 52288 0 1
41076: GO 41018
41078: POP
41079: POP
// end ;
41080: GO 40921
41082: POP
41083: POP
// end ;
41084: LD_VAR 0 1
41088: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41089: LD_INT 0
41091: PPUSH
41092: PPUSH
41093: PPUSH
41094: PPUSH
41095: PPUSH
41096: PPUSH
41097: PPUSH
41098: PPUSH
41099: PPUSH
// if not mc_bases then
41100: LD_EXP 93
41104: NOT
41105: IFFALSE 41109
// exit ;
41107: GO 41731
// for i = 1 to mc_bases do
41109: LD_ADDR_VAR 0 2
41113: PUSH
41114: DOUBLE
41115: LD_INT 1
41117: DEC
41118: ST_TO_ADDR
41119: LD_EXP 93
41123: PUSH
41124: FOR_TO
41125: IFFALSE 41729
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41127: LD_EXP 128
41131: PUSH
41132: LD_VAR 0 2
41136: ARRAY
41137: NOT
41138: PUSH
41139: LD_INT 38
41141: PPUSH
41142: LD_EXP 119
41146: PUSH
41147: LD_VAR 0 2
41151: ARRAY
41152: PPUSH
41153: CALL_OW 321
41157: PUSH
41158: LD_INT 2
41160: NONEQUAL
41161: OR
41162: IFFALSE 41166
// continue ;
41164: GO 41124
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41166: LD_ADDR_VAR 0 8
41170: PUSH
41171: LD_EXP 93
41175: PUSH
41176: LD_VAR 0 2
41180: ARRAY
41181: PPUSH
41182: LD_INT 30
41184: PUSH
41185: LD_INT 34
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PPUSH
41192: CALL_OW 72
41196: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41197: LD_ADDR_VAR 0 9
41201: PUSH
41202: LD_EXP 93
41206: PUSH
41207: LD_VAR 0 2
41211: ARRAY
41212: PPUSH
41213: LD_INT 25
41215: PUSH
41216: LD_INT 4
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PPUSH
41223: CALL_OW 72
41227: PPUSH
41228: LD_INT 0
41230: PPUSH
41231: CALL 85596 0 2
41235: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41236: LD_VAR 0 9
41240: NOT
41241: PUSH
41242: LD_VAR 0 8
41246: NOT
41247: OR
41248: PUSH
41249: LD_EXP 93
41253: PUSH
41254: LD_VAR 0 2
41258: ARRAY
41259: PPUSH
41260: LD_INT 124
41262: PPUSH
41263: CALL 85596 0 2
41267: OR
41268: IFFALSE 41272
// continue ;
41270: GO 41124
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41272: LD_EXP 129
41276: PUSH
41277: LD_VAR 0 2
41281: ARRAY
41282: PUSH
41283: LD_EXP 128
41287: PUSH
41288: LD_VAR 0 2
41292: ARRAY
41293: LESS
41294: PUSH
41295: LD_EXP 129
41299: PUSH
41300: LD_VAR 0 2
41304: ARRAY
41305: PUSH
41306: LD_VAR 0 8
41310: LESS
41311: AND
41312: IFFALSE 41727
// begin tmp := sci [ 1 ] ;
41314: LD_ADDR_VAR 0 7
41318: PUSH
41319: LD_VAR 0 9
41323: PUSH
41324: LD_INT 1
41326: ARRAY
41327: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41328: LD_VAR 0 7
41332: PPUSH
41333: LD_INT 124
41335: PPUSH
41336: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41340: LD_ADDR_VAR 0 3
41344: PUSH
41345: DOUBLE
41346: LD_EXP 128
41350: PUSH
41351: LD_VAR 0 2
41355: ARRAY
41356: INC
41357: ST_TO_ADDR
41358: LD_EXP 128
41362: PUSH
41363: LD_VAR 0 2
41367: ARRAY
41368: PUSH
41369: FOR_DOWNTO
41370: IFFALSE 41713
// begin if IsInUnit ( tmp ) then
41372: LD_VAR 0 7
41376: PPUSH
41377: CALL_OW 310
41381: IFFALSE 41392
// ComExitBuilding ( tmp ) ;
41383: LD_VAR 0 7
41387: PPUSH
41388: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41392: LD_INT 35
41394: PPUSH
41395: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41399: LD_VAR 0 7
41403: PPUSH
41404: CALL_OW 310
41408: NOT
41409: PUSH
41410: LD_VAR 0 7
41414: PPUSH
41415: CALL_OW 314
41419: NOT
41420: AND
41421: IFFALSE 41392
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41423: LD_ADDR_VAR 0 6
41427: PUSH
41428: LD_VAR 0 7
41432: PPUSH
41433: CALL_OW 250
41437: PUSH
41438: LD_VAR 0 7
41442: PPUSH
41443: CALL_OW 251
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41452: LD_INT 35
41454: PPUSH
41455: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41459: LD_ADDR_VAR 0 4
41463: PUSH
41464: LD_EXP 128
41468: PUSH
41469: LD_VAR 0 2
41473: ARRAY
41474: PUSH
41475: LD_VAR 0 3
41479: ARRAY
41480: PUSH
41481: LD_INT 1
41483: ARRAY
41484: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41485: LD_ADDR_VAR 0 5
41489: PUSH
41490: LD_EXP 128
41494: PUSH
41495: LD_VAR 0 2
41499: ARRAY
41500: PUSH
41501: LD_VAR 0 3
41505: ARRAY
41506: PUSH
41507: LD_INT 2
41509: ARRAY
41510: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41511: LD_VAR 0 7
41515: PPUSH
41516: LD_INT 10
41518: PPUSH
41519: CALL 58926 0 2
41523: PUSH
41524: LD_INT 4
41526: ARRAY
41527: IFFALSE 41565
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41529: LD_VAR 0 7
41533: PPUSH
41534: LD_VAR 0 6
41538: PUSH
41539: LD_INT 1
41541: ARRAY
41542: PPUSH
41543: LD_VAR 0 6
41547: PUSH
41548: LD_INT 2
41550: ARRAY
41551: PPUSH
41552: CALL_OW 111
// wait ( 0 0$10 ) ;
41556: LD_INT 350
41558: PPUSH
41559: CALL_OW 67
// end else
41563: GO 41591
// begin ComMoveXY ( tmp , x , y ) ;
41565: LD_VAR 0 7
41569: PPUSH
41570: LD_VAR 0 4
41574: PPUSH
41575: LD_VAR 0 5
41579: PPUSH
41580: CALL_OW 111
// wait ( 0 0$3 ) ;
41584: LD_INT 105
41586: PPUSH
41587: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41591: LD_VAR 0 7
41595: PPUSH
41596: LD_VAR 0 4
41600: PPUSH
41601: LD_VAR 0 5
41605: PPUSH
41606: CALL_OW 307
41610: IFFALSE 41452
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41612: LD_VAR 0 7
41616: PPUSH
41617: LD_VAR 0 4
41621: PPUSH
41622: LD_VAR 0 5
41626: PPUSH
41627: LD_VAR 0 8
41631: PUSH
41632: LD_VAR 0 3
41636: ARRAY
41637: PPUSH
41638: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41642: LD_INT 35
41644: PPUSH
41645: CALL_OW 67
// until not HasTask ( tmp ) ;
41649: LD_VAR 0 7
41653: PPUSH
41654: CALL_OW 314
41658: NOT
41659: IFFALSE 41642
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41661: LD_ADDR_EXP 129
41665: PUSH
41666: LD_EXP 129
41670: PPUSH
41671: LD_VAR 0 2
41675: PUSH
41676: LD_EXP 129
41680: PUSH
41681: LD_VAR 0 2
41685: ARRAY
41686: PUSH
41687: LD_INT 1
41689: PLUS
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PPUSH
41695: LD_VAR 0 8
41699: PUSH
41700: LD_VAR 0 3
41704: ARRAY
41705: PPUSH
41706: CALL 56327 0 3
41710: ST_TO_ADDR
// end ;
41711: GO 41369
41713: POP
41714: POP
// MC_Reset ( i , 124 ) ;
41715: LD_VAR 0 2
41719: PPUSH
41720: LD_INT 124
41722: PPUSH
41723: CALL 25016 0 2
// end ; end ;
41727: GO 41124
41729: POP
41730: POP
// end ;
41731: LD_VAR 0 1
41735: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41736: LD_INT 0
41738: PPUSH
41739: PPUSH
41740: PPUSH
// if not mc_bases then
41741: LD_EXP 93
41745: NOT
41746: IFFALSE 41750
// exit ;
41748: GO 42356
// for i = 1 to mc_bases do
41750: LD_ADDR_VAR 0 2
41754: PUSH
41755: DOUBLE
41756: LD_INT 1
41758: DEC
41759: ST_TO_ADDR
41760: LD_EXP 93
41764: PUSH
41765: FOR_TO
41766: IFFALSE 42354
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41768: LD_ADDR_VAR 0 3
41772: PUSH
41773: LD_EXP 93
41777: PUSH
41778: LD_VAR 0 2
41782: ARRAY
41783: PPUSH
41784: LD_INT 25
41786: PUSH
41787: LD_INT 4
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PPUSH
41794: CALL_OW 72
41798: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41799: LD_VAR 0 3
41803: NOT
41804: PUSH
41805: LD_EXP 130
41809: PUSH
41810: LD_VAR 0 2
41814: ARRAY
41815: NOT
41816: OR
41817: PUSH
41818: LD_EXP 93
41822: PUSH
41823: LD_VAR 0 2
41827: ARRAY
41828: PPUSH
41829: LD_INT 2
41831: PUSH
41832: LD_INT 30
41834: PUSH
41835: LD_INT 0
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 30
41844: PUSH
41845: LD_INT 1
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: LIST
41856: PPUSH
41857: CALL_OW 72
41861: NOT
41862: OR
41863: IFFALSE 41913
// begin if mc_deposits_finder [ i ] then
41865: LD_EXP 131
41869: PUSH
41870: LD_VAR 0 2
41874: ARRAY
41875: IFFALSE 41911
// begin MC_Reset ( i , 125 ) ;
41877: LD_VAR 0 2
41881: PPUSH
41882: LD_INT 125
41884: PPUSH
41885: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41889: LD_ADDR_EXP 131
41893: PUSH
41894: LD_EXP 131
41898: PPUSH
41899: LD_VAR 0 2
41903: PPUSH
41904: EMPTY
41905: PPUSH
41906: CALL_OW 1
41910: ST_TO_ADDR
// end ; continue ;
41911: GO 41765
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41913: LD_EXP 130
41917: PUSH
41918: LD_VAR 0 2
41922: ARRAY
41923: PUSH
41924: LD_INT 1
41926: ARRAY
41927: PUSH
41928: LD_INT 3
41930: ARRAY
41931: PUSH
41932: LD_INT 1
41934: EQUAL
41935: PUSH
41936: LD_INT 20
41938: PPUSH
41939: LD_EXP 119
41943: PUSH
41944: LD_VAR 0 2
41948: ARRAY
41949: PPUSH
41950: CALL_OW 321
41954: PUSH
41955: LD_INT 2
41957: NONEQUAL
41958: AND
41959: IFFALSE 42009
// begin if mc_deposits_finder [ i ] then
41961: LD_EXP 131
41965: PUSH
41966: LD_VAR 0 2
41970: ARRAY
41971: IFFALSE 42007
// begin MC_Reset ( i , 125 ) ;
41973: LD_VAR 0 2
41977: PPUSH
41978: LD_INT 125
41980: PPUSH
41981: CALL 25016 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41985: LD_ADDR_EXP 131
41989: PUSH
41990: LD_EXP 131
41994: PPUSH
41995: LD_VAR 0 2
41999: PPUSH
42000: EMPTY
42001: PPUSH
42002: CALL_OW 1
42006: ST_TO_ADDR
// end ; continue ;
42007: GO 41765
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42009: LD_EXP 130
42013: PUSH
42014: LD_VAR 0 2
42018: ARRAY
42019: PUSH
42020: LD_INT 1
42022: ARRAY
42023: PUSH
42024: LD_INT 1
42026: ARRAY
42027: PPUSH
42028: LD_EXP 130
42032: PUSH
42033: LD_VAR 0 2
42037: ARRAY
42038: PUSH
42039: LD_INT 1
42041: ARRAY
42042: PUSH
42043: LD_INT 2
42045: ARRAY
42046: PPUSH
42047: LD_EXP 119
42051: PUSH
42052: LD_VAR 0 2
42056: ARRAY
42057: PPUSH
42058: CALL_OW 440
42062: IFFALSE 42105
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42064: LD_ADDR_EXP 130
42068: PUSH
42069: LD_EXP 130
42073: PPUSH
42074: LD_VAR 0 2
42078: PPUSH
42079: LD_EXP 130
42083: PUSH
42084: LD_VAR 0 2
42088: ARRAY
42089: PPUSH
42090: LD_INT 1
42092: PPUSH
42093: CALL_OW 3
42097: PPUSH
42098: CALL_OW 1
42102: ST_TO_ADDR
42103: GO 42352
// begin if not mc_deposits_finder [ i ] then
42105: LD_EXP 131
42109: PUSH
42110: LD_VAR 0 2
42114: ARRAY
42115: NOT
42116: IFFALSE 42168
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42118: LD_ADDR_EXP 131
42122: PUSH
42123: LD_EXP 131
42127: PPUSH
42128: LD_VAR 0 2
42132: PPUSH
42133: LD_VAR 0 3
42137: PUSH
42138: LD_INT 1
42140: ARRAY
42141: PUSH
42142: EMPTY
42143: LIST
42144: PPUSH
42145: CALL_OW 1
42149: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42150: LD_VAR 0 3
42154: PUSH
42155: LD_INT 1
42157: ARRAY
42158: PPUSH
42159: LD_INT 125
42161: PPUSH
42162: CALL_OW 109
// end else
42166: GO 42352
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42168: LD_EXP 131
42172: PUSH
42173: LD_VAR 0 2
42177: ARRAY
42178: PUSH
42179: LD_INT 1
42181: ARRAY
42182: PPUSH
42183: CALL_OW 310
42187: IFFALSE 42210
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42189: LD_EXP 131
42193: PUSH
42194: LD_VAR 0 2
42198: ARRAY
42199: PUSH
42200: LD_INT 1
42202: ARRAY
42203: PPUSH
42204: CALL_OW 122
42208: GO 42352
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42210: LD_EXP 131
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: PUSH
42221: LD_INT 1
42223: ARRAY
42224: PPUSH
42225: CALL_OW 314
42229: NOT
42230: PUSH
42231: LD_EXP 131
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: PUSH
42242: LD_INT 1
42244: ARRAY
42245: PPUSH
42246: LD_EXP 130
42250: PUSH
42251: LD_VAR 0 2
42255: ARRAY
42256: PUSH
42257: LD_INT 1
42259: ARRAY
42260: PUSH
42261: LD_INT 1
42263: ARRAY
42264: PPUSH
42265: LD_EXP 130
42269: PUSH
42270: LD_VAR 0 2
42274: ARRAY
42275: PUSH
42276: LD_INT 1
42278: ARRAY
42279: PUSH
42280: LD_INT 2
42282: ARRAY
42283: PPUSH
42284: CALL_OW 297
42288: PUSH
42289: LD_INT 6
42291: GREATER
42292: AND
42293: IFFALSE 42352
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42295: LD_EXP 131
42299: PUSH
42300: LD_VAR 0 2
42304: ARRAY
42305: PUSH
42306: LD_INT 1
42308: ARRAY
42309: PPUSH
42310: LD_EXP 130
42314: PUSH
42315: LD_VAR 0 2
42319: ARRAY
42320: PUSH
42321: LD_INT 1
42323: ARRAY
42324: PUSH
42325: LD_INT 1
42327: ARRAY
42328: PPUSH
42329: LD_EXP 130
42333: PUSH
42334: LD_VAR 0 2
42338: ARRAY
42339: PUSH
42340: LD_INT 1
42342: ARRAY
42343: PUSH
42344: LD_INT 2
42346: ARRAY
42347: PPUSH
42348: CALL_OW 111
// end ; end ; end ;
42352: GO 41765
42354: POP
42355: POP
// end ;
42356: LD_VAR 0 1
42360: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42361: LD_INT 0
42363: PPUSH
42364: PPUSH
42365: PPUSH
42366: PPUSH
42367: PPUSH
42368: PPUSH
42369: PPUSH
42370: PPUSH
42371: PPUSH
42372: PPUSH
42373: PPUSH
// if not mc_bases then
42374: LD_EXP 93
42378: NOT
42379: IFFALSE 42383
// exit ;
42381: GO 43323
// for i = 1 to mc_bases do
42383: LD_ADDR_VAR 0 2
42387: PUSH
42388: DOUBLE
42389: LD_INT 1
42391: DEC
42392: ST_TO_ADDR
42393: LD_EXP 93
42397: PUSH
42398: FOR_TO
42399: IFFALSE 43321
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42401: LD_EXP 93
42405: PUSH
42406: LD_VAR 0 2
42410: ARRAY
42411: NOT
42412: PUSH
42413: LD_EXP 116
42417: PUSH
42418: LD_VAR 0 2
42422: ARRAY
42423: OR
42424: IFFALSE 42428
// continue ;
42426: GO 42398
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42428: LD_ADDR_VAR 0 7
42432: PUSH
42433: LD_EXP 93
42437: PUSH
42438: LD_VAR 0 2
42442: ARRAY
42443: PUSH
42444: LD_INT 1
42446: ARRAY
42447: PPUSH
42448: CALL_OW 248
42452: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42453: LD_VAR 0 7
42457: PUSH
42458: LD_INT 3
42460: EQUAL
42461: PUSH
42462: LD_EXP 112
42466: PUSH
42467: LD_VAR 0 2
42471: ARRAY
42472: PUSH
42473: LD_EXP 115
42477: PUSH
42478: LD_VAR 0 2
42482: ARRAY
42483: UNION
42484: PPUSH
42485: LD_INT 33
42487: PUSH
42488: LD_INT 2
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PPUSH
42495: CALL_OW 72
42499: NOT
42500: OR
42501: IFFALSE 42505
// continue ;
42503: GO 42398
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42505: LD_ADDR_VAR 0 9
42509: PUSH
42510: LD_EXP 93
42514: PUSH
42515: LD_VAR 0 2
42519: ARRAY
42520: PPUSH
42521: LD_INT 30
42523: PUSH
42524: LD_INT 36
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PPUSH
42531: CALL_OW 72
42535: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42536: LD_ADDR_VAR 0 10
42540: PUSH
42541: LD_EXP 112
42545: PUSH
42546: LD_VAR 0 2
42550: ARRAY
42551: PPUSH
42552: LD_INT 34
42554: PUSH
42555: LD_INT 31
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PPUSH
42562: CALL_OW 72
42566: ST_TO_ADDR
// if not cts and not mcts then
42567: LD_VAR 0 9
42571: NOT
42572: PUSH
42573: LD_VAR 0 10
42577: NOT
42578: AND
42579: IFFALSE 42583
// continue ;
42581: GO 42398
// x := cts ;
42583: LD_ADDR_VAR 0 11
42587: PUSH
42588: LD_VAR 0 9
42592: ST_TO_ADDR
// if not x then
42593: LD_VAR 0 11
42597: NOT
42598: IFFALSE 42610
// x := mcts ;
42600: LD_ADDR_VAR 0 11
42604: PUSH
42605: LD_VAR 0 10
42609: ST_TO_ADDR
// if not x then
42610: LD_VAR 0 11
42614: NOT
42615: IFFALSE 42619
// continue ;
42617: GO 42398
// if mc_remote_driver [ i ] then
42619: LD_EXP 133
42623: PUSH
42624: LD_VAR 0 2
42628: ARRAY
42629: IFFALSE 43016
// for j in mc_remote_driver [ i ] do
42631: LD_ADDR_VAR 0 3
42635: PUSH
42636: LD_EXP 133
42640: PUSH
42641: LD_VAR 0 2
42645: ARRAY
42646: PUSH
42647: FOR_IN
42648: IFFALSE 43014
// begin if GetClass ( j ) <> 3 then
42650: LD_VAR 0 3
42654: PPUSH
42655: CALL_OW 257
42659: PUSH
42660: LD_INT 3
42662: NONEQUAL
42663: IFFALSE 42716
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42665: LD_ADDR_EXP 133
42669: PUSH
42670: LD_EXP 133
42674: PPUSH
42675: LD_VAR 0 2
42679: PPUSH
42680: LD_EXP 133
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: PUSH
42691: LD_VAR 0 3
42695: DIFF
42696: PPUSH
42697: CALL_OW 1
42701: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42702: LD_VAR 0 3
42706: PPUSH
42707: LD_INT 0
42709: PPUSH
42710: CALL_OW 109
// continue ;
42714: GO 42647
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42716: LD_EXP 112
42720: PUSH
42721: LD_VAR 0 2
42725: ARRAY
42726: PPUSH
42727: LD_INT 34
42729: PUSH
42730: LD_INT 31
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 58
42739: PUSH
42740: EMPTY
42741: LIST
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PPUSH
42747: CALL_OW 72
42751: PUSH
42752: LD_VAR 0 3
42756: PPUSH
42757: CALL 85684 0 1
42761: NOT
42762: AND
42763: IFFALSE 42834
// begin if IsInUnit ( j ) then
42765: LD_VAR 0 3
42769: PPUSH
42770: CALL_OW 310
42774: IFFALSE 42785
// ComExitBuilding ( j ) ;
42776: LD_VAR 0 3
42780: PPUSH
42781: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42785: LD_VAR 0 3
42789: PPUSH
42790: LD_EXP 112
42794: PUSH
42795: LD_VAR 0 2
42799: ARRAY
42800: PPUSH
42801: LD_INT 34
42803: PUSH
42804: LD_INT 31
42806: PUSH
42807: EMPTY
42808: LIST
42809: LIST
42810: PUSH
42811: LD_INT 58
42813: PUSH
42814: EMPTY
42815: LIST
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PPUSH
42821: CALL_OW 72
42825: PUSH
42826: LD_INT 1
42828: ARRAY
42829: PPUSH
42830: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42834: LD_VAR 0 3
42838: PPUSH
42839: CALL_OW 310
42843: NOT
42844: PUSH
42845: LD_VAR 0 3
42849: PPUSH
42850: CALL_OW 310
42854: PPUSH
42855: CALL_OW 266
42859: PUSH
42860: LD_INT 36
42862: NONEQUAL
42863: PUSH
42864: LD_VAR 0 3
42868: PPUSH
42869: CALL 85684 0 1
42873: NOT
42874: AND
42875: OR
42876: IFFALSE 43012
// begin if IsInUnit ( j ) then
42878: LD_VAR 0 3
42882: PPUSH
42883: CALL_OW 310
42887: IFFALSE 42898
// ComExitBuilding ( j ) ;
42889: LD_VAR 0 3
42893: PPUSH
42894: CALL_OW 122
// ct := 0 ;
42898: LD_ADDR_VAR 0 8
42902: PUSH
42903: LD_INT 0
42905: ST_TO_ADDR
// for k in x do
42906: LD_ADDR_VAR 0 4
42910: PUSH
42911: LD_VAR 0 11
42915: PUSH
42916: FOR_IN
42917: IFFALSE 42990
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42919: LD_VAR 0 4
42923: PPUSH
42924: CALL_OW 264
42928: PUSH
42929: LD_INT 31
42931: EQUAL
42932: PUSH
42933: LD_VAR 0 4
42937: PPUSH
42938: CALL_OW 311
42942: NOT
42943: AND
42944: PUSH
42945: LD_VAR 0 4
42949: PPUSH
42950: CALL_OW 266
42954: PUSH
42955: LD_INT 36
42957: EQUAL
42958: PUSH
42959: LD_VAR 0 4
42963: PPUSH
42964: CALL_OW 313
42968: PUSH
42969: LD_INT 3
42971: LESS
42972: AND
42973: OR
42974: IFFALSE 42988
// begin ct := k ;
42976: LD_ADDR_VAR 0 8
42980: PUSH
42981: LD_VAR 0 4
42985: ST_TO_ADDR
// break ;
42986: GO 42990
// end ;
42988: GO 42916
42990: POP
42991: POP
// if ct then
42992: LD_VAR 0 8
42996: IFFALSE 43012
// ComEnterUnit ( j , ct ) ;
42998: LD_VAR 0 3
43002: PPUSH
43003: LD_VAR 0 8
43007: PPUSH
43008: CALL_OW 120
// end ; end ;
43012: GO 42647
43014: POP
43015: POP
// places := 0 ;
43016: LD_ADDR_VAR 0 5
43020: PUSH
43021: LD_INT 0
43023: ST_TO_ADDR
// for j = 1 to x do
43024: LD_ADDR_VAR 0 3
43028: PUSH
43029: DOUBLE
43030: LD_INT 1
43032: DEC
43033: ST_TO_ADDR
43034: LD_VAR 0 11
43038: PUSH
43039: FOR_TO
43040: IFFALSE 43116
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43042: LD_VAR 0 11
43046: PUSH
43047: LD_VAR 0 3
43051: ARRAY
43052: PPUSH
43053: CALL_OW 264
43057: PUSH
43058: LD_INT 31
43060: EQUAL
43061: IFFALSE 43079
// places := places + 1 else
43063: LD_ADDR_VAR 0 5
43067: PUSH
43068: LD_VAR 0 5
43072: PUSH
43073: LD_INT 1
43075: PLUS
43076: ST_TO_ADDR
43077: GO 43114
// if GetBType ( x [ j ] ) = b_control_tower then
43079: LD_VAR 0 11
43083: PUSH
43084: LD_VAR 0 3
43088: ARRAY
43089: PPUSH
43090: CALL_OW 266
43094: PUSH
43095: LD_INT 36
43097: EQUAL
43098: IFFALSE 43114
// places := places + 3 ;
43100: LD_ADDR_VAR 0 5
43104: PUSH
43105: LD_VAR 0 5
43109: PUSH
43110: LD_INT 3
43112: PLUS
43113: ST_TO_ADDR
43114: GO 43039
43116: POP
43117: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43118: LD_VAR 0 5
43122: PUSH
43123: LD_INT 0
43125: EQUAL
43126: PUSH
43127: LD_VAR 0 5
43131: PUSH
43132: LD_EXP 133
43136: PUSH
43137: LD_VAR 0 2
43141: ARRAY
43142: LESSEQUAL
43143: OR
43144: IFFALSE 43148
// continue ;
43146: GO 42398
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43148: LD_ADDR_VAR 0 6
43152: PUSH
43153: LD_EXP 93
43157: PUSH
43158: LD_VAR 0 2
43162: ARRAY
43163: PPUSH
43164: LD_INT 25
43166: PUSH
43167: LD_INT 3
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PPUSH
43174: CALL_OW 72
43178: PUSH
43179: LD_EXP 133
43183: PUSH
43184: LD_VAR 0 2
43188: ARRAY
43189: DIFF
43190: PPUSH
43191: LD_INT 3
43193: PPUSH
43194: CALL 86584 0 2
43198: ST_TO_ADDR
// for j in tmp do
43199: LD_ADDR_VAR 0 3
43203: PUSH
43204: LD_VAR 0 6
43208: PUSH
43209: FOR_IN
43210: IFFALSE 43245
// if GetTag ( j ) > 0 then
43212: LD_VAR 0 3
43216: PPUSH
43217: CALL_OW 110
43221: PUSH
43222: LD_INT 0
43224: GREATER
43225: IFFALSE 43243
// tmp := tmp diff j ;
43227: LD_ADDR_VAR 0 6
43231: PUSH
43232: LD_VAR 0 6
43236: PUSH
43237: LD_VAR 0 3
43241: DIFF
43242: ST_TO_ADDR
43243: GO 43209
43245: POP
43246: POP
// if not tmp then
43247: LD_VAR 0 6
43251: NOT
43252: IFFALSE 43256
// continue ;
43254: GO 42398
// if places then
43256: LD_VAR 0 5
43260: IFFALSE 43319
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43262: LD_ADDR_EXP 133
43266: PUSH
43267: LD_EXP 133
43271: PPUSH
43272: LD_VAR 0 2
43276: PPUSH
43277: LD_EXP 133
43281: PUSH
43282: LD_VAR 0 2
43286: ARRAY
43287: PUSH
43288: LD_VAR 0 6
43292: PUSH
43293: LD_INT 1
43295: ARRAY
43296: UNION
43297: PPUSH
43298: CALL_OW 1
43302: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43303: LD_VAR 0 6
43307: PUSH
43308: LD_INT 1
43310: ARRAY
43311: PPUSH
43312: LD_INT 126
43314: PPUSH
43315: CALL_OW 109
// end ; end ;
43319: GO 42398
43321: POP
43322: POP
// end ;
43323: LD_VAR 0 1
43327: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43328: LD_INT 0
43330: PPUSH
43331: PPUSH
43332: PPUSH
43333: PPUSH
43334: PPUSH
43335: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43336: LD_VAR 0 1
43340: NOT
43341: PUSH
43342: LD_VAR 0 2
43346: NOT
43347: OR
43348: PUSH
43349: LD_VAR 0 3
43353: NOT
43354: OR
43355: PUSH
43356: LD_VAR 0 4
43360: PUSH
43361: LD_INT 1
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 3
43369: PUSH
43370: LD_INT 4
43372: PUSH
43373: LD_INT 5
43375: PUSH
43376: LD_INT 8
43378: PUSH
43379: LD_INT 9
43381: PUSH
43382: LD_INT 15
43384: PUSH
43385: LD_INT 16
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: IN
43399: NOT
43400: OR
43401: IFFALSE 43405
// exit ;
43403: GO 44305
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43405: LD_ADDR_VAR 0 2
43409: PUSH
43410: LD_VAR 0 2
43414: PPUSH
43415: LD_INT 21
43417: PUSH
43418: LD_INT 3
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: LD_INT 24
43427: PUSH
43428: LD_INT 250
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PPUSH
43439: CALL_OW 72
43443: ST_TO_ADDR
// case class of 1 , 15 :
43444: LD_VAR 0 4
43448: PUSH
43449: LD_INT 1
43451: DOUBLE
43452: EQUAL
43453: IFTRUE 43463
43455: LD_INT 15
43457: DOUBLE
43458: EQUAL
43459: IFTRUE 43463
43461: GO 43548
43463: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43464: LD_ADDR_VAR 0 8
43468: PUSH
43469: LD_VAR 0 2
43473: PPUSH
43474: LD_INT 2
43476: PUSH
43477: LD_INT 30
43479: PUSH
43480: LD_INT 32
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 30
43489: PUSH
43490: LD_INT 31
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: LIST
43501: PPUSH
43502: CALL_OW 72
43506: PUSH
43507: LD_VAR 0 2
43511: PPUSH
43512: LD_INT 2
43514: PUSH
43515: LD_INT 30
43517: PUSH
43518: LD_INT 4
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: LD_INT 30
43527: PUSH
43528: LD_INT 5
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: LIST
43539: PPUSH
43540: CALL_OW 72
43544: ADD
43545: ST_TO_ADDR
43546: GO 43794
43548: LD_INT 2
43550: DOUBLE
43551: EQUAL
43552: IFTRUE 43562
43554: LD_INT 16
43556: DOUBLE
43557: EQUAL
43558: IFTRUE 43562
43560: GO 43608
43562: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43563: LD_ADDR_VAR 0 8
43567: PUSH
43568: LD_VAR 0 2
43572: PPUSH
43573: LD_INT 2
43575: PUSH
43576: LD_INT 30
43578: PUSH
43579: LD_INT 0
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 30
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: LIST
43600: PPUSH
43601: CALL_OW 72
43605: ST_TO_ADDR
43606: GO 43794
43608: LD_INT 3
43610: DOUBLE
43611: EQUAL
43612: IFTRUE 43616
43614: GO 43662
43616: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43617: LD_ADDR_VAR 0 8
43621: PUSH
43622: LD_VAR 0 2
43626: PPUSH
43627: LD_INT 2
43629: PUSH
43630: LD_INT 30
43632: PUSH
43633: LD_INT 2
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 30
43642: PUSH
43643: LD_INT 3
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: LIST
43654: PPUSH
43655: CALL_OW 72
43659: ST_TO_ADDR
43660: GO 43794
43662: LD_INT 4
43664: DOUBLE
43665: EQUAL
43666: IFTRUE 43670
43668: GO 43727
43670: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43671: LD_ADDR_VAR 0 8
43675: PUSH
43676: LD_VAR 0 2
43680: PPUSH
43681: LD_INT 2
43683: PUSH
43684: LD_INT 30
43686: PUSH
43687: LD_INT 6
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 30
43696: PUSH
43697: LD_INT 7
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 30
43706: PUSH
43707: LD_INT 8
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: PPUSH
43720: CALL_OW 72
43724: ST_TO_ADDR
43725: GO 43794
43727: LD_INT 5
43729: DOUBLE
43730: EQUAL
43731: IFTRUE 43747
43733: LD_INT 8
43735: DOUBLE
43736: EQUAL
43737: IFTRUE 43747
43739: LD_INT 9
43741: DOUBLE
43742: EQUAL
43743: IFTRUE 43747
43745: GO 43793
43747: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43748: LD_ADDR_VAR 0 8
43752: PUSH
43753: LD_VAR 0 2
43757: PPUSH
43758: LD_INT 2
43760: PUSH
43761: LD_INT 30
43763: PUSH
43764: LD_INT 4
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 30
43773: PUSH
43774: LD_INT 5
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: LIST
43785: PPUSH
43786: CALL_OW 72
43790: ST_TO_ADDR
43791: GO 43794
43793: POP
// if not tmp then
43794: LD_VAR 0 8
43798: NOT
43799: IFFALSE 43803
// exit ;
43801: GO 44305
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43803: LD_VAR 0 4
43807: PUSH
43808: LD_INT 1
43810: PUSH
43811: LD_INT 15
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: IN
43818: PUSH
43819: LD_EXP 102
43823: PUSH
43824: LD_VAR 0 1
43828: ARRAY
43829: AND
43830: IFFALSE 43986
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43832: LD_ADDR_VAR 0 9
43836: PUSH
43837: LD_EXP 102
43841: PUSH
43842: LD_VAR 0 1
43846: ARRAY
43847: PUSH
43848: LD_INT 1
43850: ARRAY
43851: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43852: LD_VAR 0 9
43856: PUSH
43857: LD_EXP 103
43861: PUSH
43862: LD_VAR 0 1
43866: ARRAY
43867: IN
43868: NOT
43869: IFFALSE 43984
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43871: LD_ADDR_EXP 103
43875: PUSH
43876: LD_EXP 103
43880: PPUSH
43881: LD_VAR 0 1
43885: PUSH
43886: LD_EXP 103
43890: PUSH
43891: LD_VAR 0 1
43895: ARRAY
43896: PUSH
43897: LD_INT 1
43899: PLUS
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PPUSH
43905: LD_VAR 0 9
43909: PPUSH
43910: CALL 56327 0 3
43914: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43915: LD_ADDR_EXP 102
43919: PUSH
43920: LD_EXP 102
43924: PPUSH
43925: LD_VAR 0 1
43929: PPUSH
43930: LD_EXP 102
43934: PUSH
43935: LD_VAR 0 1
43939: ARRAY
43940: PUSH
43941: LD_VAR 0 9
43945: DIFF
43946: PPUSH
43947: CALL_OW 1
43951: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43952: LD_VAR 0 3
43956: PPUSH
43957: LD_EXP 103
43961: PUSH
43962: LD_VAR 0 1
43966: ARRAY
43967: PUSH
43968: LD_EXP 103
43972: PUSH
43973: LD_VAR 0 1
43977: ARRAY
43978: ARRAY
43979: PPUSH
43980: CALL_OW 120
// end ; exit ;
43984: GO 44305
// end ; if tmp > 1 then
43986: LD_VAR 0 8
43990: PUSH
43991: LD_INT 1
43993: GREATER
43994: IFFALSE 44098
// for i = 2 to tmp do
43996: LD_ADDR_VAR 0 6
44000: PUSH
44001: DOUBLE
44002: LD_INT 2
44004: DEC
44005: ST_TO_ADDR
44006: LD_VAR 0 8
44010: PUSH
44011: FOR_TO
44012: IFFALSE 44096
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44014: LD_VAR 0 8
44018: PUSH
44019: LD_VAR 0 6
44023: ARRAY
44024: PPUSH
44025: CALL_OW 461
44029: PUSH
44030: LD_INT 6
44032: EQUAL
44033: IFFALSE 44094
// begin x := tmp [ i ] ;
44035: LD_ADDR_VAR 0 9
44039: PUSH
44040: LD_VAR 0 8
44044: PUSH
44045: LD_VAR 0 6
44049: ARRAY
44050: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44051: LD_ADDR_VAR 0 8
44055: PUSH
44056: LD_VAR 0 8
44060: PPUSH
44061: LD_VAR 0 6
44065: PPUSH
44066: CALL_OW 3
44070: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44071: LD_ADDR_VAR 0 8
44075: PUSH
44076: LD_VAR 0 8
44080: PPUSH
44081: LD_INT 1
44083: PPUSH
44084: LD_VAR 0 9
44088: PPUSH
44089: CALL_OW 2
44093: ST_TO_ADDR
// end ;
44094: GO 44011
44096: POP
44097: POP
// for i in tmp do
44098: LD_ADDR_VAR 0 6
44102: PUSH
44103: LD_VAR 0 8
44107: PUSH
44108: FOR_IN
44109: IFFALSE 44178
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44111: LD_VAR 0 6
44115: PPUSH
44116: CALL_OW 313
44120: PUSH
44121: LD_INT 6
44123: LESS
44124: PUSH
44125: LD_VAR 0 6
44129: PPUSH
44130: CALL_OW 266
44134: PUSH
44135: LD_INT 31
44137: PUSH
44138: LD_INT 32
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: IN
44145: NOT
44146: AND
44147: PUSH
44148: LD_VAR 0 6
44152: PPUSH
44153: CALL_OW 313
44157: PUSH
44158: LD_INT 0
44160: EQUAL
44161: OR
44162: IFFALSE 44176
// begin j := i ;
44164: LD_ADDR_VAR 0 7
44168: PUSH
44169: LD_VAR 0 6
44173: ST_TO_ADDR
// break ;
44174: GO 44178
// end ; end ;
44176: GO 44108
44178: POP
44179: POP
// if j then
44180: LD_VAR 0 7
44184: IFFALSE 44202
// ComEnterUnit ( unit , j ) else
44186: LD_VAR 0 3
44190: PPUSH
44191: LD_VAR 0 7
44195: PPUSH
44196: CALL_OW 120
44200: GO 44305
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44202: LD_ADDR_VAR 0 10
44206: PUSH
44207: LD_VAR 0 2
44211: PPUSH
44212: LD_INT 2
44214: PUSH
44215: LD_INT 30
44217: PUSH
44218: LD_INT 0
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 30
44227: PUSH
44228: LD_INT 1
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: LIST
44239: PPUSH
44240: CALL_OW 72
44244: ST_TO_ADDR
// if depot then
44245: LD_VAR 0 10
44249: IFFALSE 44305
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44251: LD_ADDR_VAR 0 10
44255: PUSH
44256: LD_VAR 0 10
44260: PPUSH
44261: LD_VAR 0 3
44265: PPUSH
44266: CALL_OW 74
44270: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44271: LD_VAR 0 3
44275: PPUSH
44276: LD_VAR 0 10
44280: PPUSH
44281: CALL_OW 296
44285: PUSH
44286: LD_INT 10
44288: GREATER
44289: IFFALSE 44305
// ComStandNearbyBuilding ( unit , depot ) ;
44291: LD_VAR 0 3
44295: PPUSH
44296: LD_VAR 0 10
44300: PPUSH
44301: CALL 52905 0 2
// end ; end ; end ;
44305: LD_VAR 0 5
44309: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44310: LD_INT 0
44312: PPUSH
44313: PPUSH
44314: PPUSH
44315: PPUSH
// if not mc_bases then
44316: LD_EXP 93
44320: NOT
44321: IFFALSE 44325
// exit ;
44323: GO 44564
// for i = 1 to mc_bases do
44325: LD_ADDR_VAR 0 2
44329: PUSH
44330: DOUBLE
44331: LD_INT 1
44333: DEC
44334: ST_TO_ADDR
44335: LD_EXP 93
44339: PUSH
44340: FOR_TO
44341: IFFALSE 44562
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44343: LD_ADDR_VAR 0 4
44347: PUSH
44348: LD_EXP 93
44352: PUSH
44353: LD_VAR 0 2
44357: ARRAY
44358: PPUSH
44359: LD_INT 21
44361: PUSH
44362: LD_INT 1
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PPUSH
44369: CALL_OW 72
44373: PUSH
44374: LD_EXP 122
44378: PUSH
44379: LD_VAR 0 2
44383: ARRAY
44384: UNION
44385: ST_TO_ADDR
// if not tmp then
44386: LD_VAR 0 4
44390: NOT
44391: IFFALSE 44395
// continue ;
44393: GO 44340
// for j in tmp do
44395: LD_ADDR_VAR 0 3
44399: PUSH
44400: LD_VAR 0 4
44404: PUSH
44405: FOR_IN
44406: IFFALSE 44558
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44408: LD_VAR 0 3
44412: PPUSH
44413: CALL_OW 110
44417: NOT
44418: PUSH
44419: LD_VAR 0 3
44423: PPUSH
44424: CALL_OW 314
44428: NOT
44429: AND
44430: PUSH
44431: LD_VAR 0 3
44435: PPUSH
44436: CALL_OW 311
44440: NOT
44441: AND
44442: PUSH
44443: LD_VAR 0 3
44447: PPUSH
44448: CALL_OW 310
44452: NOT
44453: AND
44454: PUSH
44455: LD_VAR 0 3
44459: PUSH
44460: LD_EXP 96
44464: PUSH
44465: LD_VAR 0 2
44469: ARRAY
44470: PUSH
44471: LD_INT 1
44473: ARRAY
44474: IN
44475: NOT
44476: AND
44477: PUSH
44478: LD_VAR 0 3
44482: PUSH
44483: LD_EXP 96
44487: PUSH
44488: LD_VAR 0 2
44492: ARRAY
44493: PUSH
44494: LD_INT 2
44496: ARRAY
44497: IN
44498: NOT
44499: AND
44500: PUSH
44501: LD_VAR 0 3
44505: PUSH
44506: LD_EXP 105
44510: PUSH
44511: LD_VAR 0 2
44515: ARRAY
44516: IN
44517: NOT
44518: AND
44519: IFFALSE 44556
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44521: LD_VAR 0 2
44525: PPUSH
44526: LD_EXP 93
44530: PUSH
44531: LD_VAR 0 2
44535: ARRAY
44536: PPUSH
44537: LD_VAR 0 3
44541: PPUSH
44542: LD_VAR 0 3
44546: PPUSH
44547: CALL_OW 257
44551: PPUSH
44552: CALL 43328 0 4
// end ;
44556: GO 44405
44558: POP
44559: POP
// end ;
44560: GO 44340
44562: POP
44563: POP
// end ;
44564: LD_VAR 0 1
44568: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44569: LD_INT 0
44571: PPUSH
44572: PPUSH
44573: PPUSH
44574: PPUSH
44575: PPUSH
44576: PPUSH
// if not mc_bases [ base ] then
44577: LD_EXP 93
44581: PUSH
44582: LD_VAR 0 1
44586: ARRAY
44587: NOT
44588: IFFALSE 44592
// exit ;
44590: GO 44774
// tmp := [ ] ;
44592: LD_ADDR_VAR 0 6
44596: PUSH
44597: EMPTY
44598: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44599: LD_ADDR_VAR 0 7
44603: PUSH
44604: LD_VAR 0 3
44608: PPUSH
44609: LD_INT 0
44611: PPUSH
44612: CALL_OW 517
44616: ST_TO_ADDR
// if not list then
44617: LD_VAR 0 7
44621: NOT
44622: IFFALSE 44626
// exit ;
44624: GO 44774
// for i = 1 to amount do
44626: LD_ADDR_VAR 0 5
44630: PUSH
44631: DOUBLE
44632: LD_INT 1
44634: DEC
44635: ST_TO_ADDR
44636: LD_VAR 0 2
44640: PUSH
44641: FOR_TO
44642: IFFALSE 44722
// begin x := rand ( 1 , list [ 1 ] ) ;
44644: LD_ADDR_VAR 0 8
44648: PUSH
44649: LD_INT 1
44651: PPUSH
44652: LD_VAR 0 7
44656: PUSH
44657: LD_INT 1
44659: ARRAY
44660: PPUSH
44661: CALL_OW 12
44665: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44666: LD_ADDR_VAR 0 6
44670: PUSH
44671: LD_VAR 0 6
44675: PPUSH
44676: LD_VAR 0 5
44680: PPUSH
44681: LD_VAR 0 7
44685: PUSH
44686: LD_INT 1
44688: ARRAY
44689: PUSH
44690: LD_VAR 0 8
44694: ARRAY
44695: PUSH
44696: LD_VAR 0 7
44700: PUSH
44701: LD_INT 2
44703: ARRAY
44704: PUSH
44705: LD_VAR 0 8
44709: ARRAY
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PPUSH
44715: CALL_OW 1
44719: ST_TO_ADDR
// end ;
44720: GO 44641
44722: POP
44723: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44724: LD_ADDR_EXP 106
44728: PUSH
44729: LD_EXP 106
44733: PPUSH
44734: LD_VAR 0 1
44738: PPUSH
44739: LD_VAR 0 6
44743: PPUSH
44744: CALL_OW 1
44748: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44749: LD_ADDR_EXP 108
44753: PUSH
44754: LD_EXP 108
44758: PPUSH
44759: LD_VAR 0 1
44763: PPUSH
44764: LD_VAR 0 3
44768: PPUSH
44769: CALL_OW 1
44773: ST_TO_ADDR
// end ;
44774: LD_VAR 0 4
44778: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44779: LD_INT 0
44781: PPUSH
// if not mc_bases [ base ] then
44782: LD_EXP 93
44786: PUSH
44787: LD_VAR 0 1
44791: ARRAY
44792: NOT
44793: IFFALSE 44797
// exit ;
44795: GO 44822
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44797: LD_ADDR_EXP 98
44801: PUSH
44802: LD_EXP 98
44806: PPUSH
44807: LD_VAR 0 1
44811: PPUSH
44812: LD_VAR 0 2
44816: PPUSH
44817: CALL_OW 1
44821: ST_TO_ADDR
// end ;
44822: LD_VAR 0 3
44826: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44827: LD_INT 0
44829: PPUSH
// if not mc_bases [ base ] then
44830: LD_EXP 93
44834: PUSH
44835: LD_VAR 0 1
44839: ARRAY
44840: NOT
44841: IFFALSE 44845
// exit ;
44843: GO 44882
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44845: LD_ADDR_EXP 98
44849: PUSH
44850: LD_EXP 98
44854: PPUSH
44855: LD_VAR 0 1
44859: PPUSH
44860: LD_EXP 98
44864: PUSH
44865: LD_VAR 0 1
44869: ARRAY
44870: PUSH
44871: LD_VAR 0 2
44875: UNION
44876: PPUSH
44877: CALL_OW 1
44881: ST_TO_ADDR
// end ;
44882: LD_VAR 0 3
44886: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44887: LD_INT 0
44889: PPUSH
// if not mc_bases [ base ] then
44890: LD_EXP 93
44894: PUSH
44895: LD_VAR 0 1
44899: ARRAY
44900: NOT
44901: IFFALSE 44905
// exit ;
44903: GO 44930
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44905: LD_ADDR_EXP 114
44909: PUSH
44910: LD_EXP 114
44914: PPUSH
44915: LD_VAR 0 1
44919: PPUSH
44920: LD_VAR 0 2
44924: PPUSH
44925: CALL_OW 1
44929: ST_TO_ADDR
// end ;
44930: LD_VAR 0 3
44934: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44935: LD_INT 0
44937: PPUSH
// if not mc_bases [ base ] then
44938: LD_EXP 93
44942: PUSH
44943: LD_VAR 0 1
44947: ARRAY
44948: NOT
44949: IFFALSE 44953
// exit ;
44951: GO 44990
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44953: LD_ADDR_EXP 114
44957: PUSH
44958: LD_EXP 114
44962: PPUSH
44963: LD_VAR 0 1
44967: PPUSH
44968: LD_EXP 114
44972: PUSH
44973: LD_VAR 0 1
44977: ARRAY
44978: PUSH
44979: LD_VAR 0 2
44983: ADD
44984: PPUSH
44985: CALL_OW 1
44989: ST_TO_ADDR
// end ;
44990: LD_VAR 0 3
44994: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44995: LD_INT 0
44997: PPUSH
// if not mc_bases [ base ] then
44998: LD_EXP 93
45002: PUSH
45003: LD_VAR 0 1
45007: ARRAY
45008: NOT
45009: IFFALSE 45013
// exit ;
45011: GO 45067
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45013: LD_ADDR_EXP 115
45017: PUSH
45018: LD_EXP 115
45022: PPUSH
45023: LD_VAR 0 1
45027: PPUSH
45028: LD_VAR 0 2
45032: PPUSH
45033: CALL_OW 1
45037: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45038: LD_ADDR_EXP 104
45042: PUSH
45043: LD_EXP 104
45047: PPUSH
45048: LD_VAR 0 1
45052: PPUSH
45053: LD_VAR 0 2
45057: PUSH
45058: LD_INT 0
45060: PLUS
45061: PPUSH
45062: CALL_OW 1
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 3
45071: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45072: LD_INT 0
45074: PPUSH
// if not mc_bases [ base ] then
45075: LD_EXP 93
45079: PUSH
45080: LD_VAR 0 1
45084: ARRAY
45085: NOT
45086: IFFALSE 45090
// exit ;
45088: GO 45115
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45090: LD_ADDR_EXP 104
45094: PUSH
45095: LD_EXP 104
45099: PPUSH
45100: LD_VAR 0 1
45104: PPUSH
45105: LD_VAR 0 2
45109: PPUSH
45110: CALL_OW 1
45114: ST_TO_ADDR
// end ;
45115: LD_VAR 0 3
45119: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45120: LD_INT 0
45122: PPUSH
45123: PPUSH
45124: PPUSH
45125: PPUSH
// if not mc_bases [ base ] then
45126: LD_EXP 93
45130: PUSH
45131: LD_VAR 0 1
45135: ARRAY
45136: NOT
45137: IFFALSE 45141
// exit ;
45139: GO 45206
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45141: LD_ADDR_EXP 113
45145: PUSH
45146: LD_EXP 113
45150: PPUSH
45151: LD_VAR 0 1
45155: PUSH
45156: LD_EXP 113
45160: PUSH
45161: LD_VAR 0 1
45165: ARRAY
45166: PUSH
45167: LD_INT 1
45169: PLUS
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PPUSH
45175: LD_VAR 0 1
45179: PUSH
45180: LD_VAR 0 2
45184: PUSH
45185: LD_VAR 0 3
45189: PUSH
45190: LD_VAR 0 4
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: PPUSH
45201: CALL 56327 0 3
45205: ST_TO_ADDR
// end ;
45206: LD_VAR 0 5
45210: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45211: LD_INT 0
45213: PPUSH
// if not mc_bases [ base ] then
45214: LD_EXP 93
45218: PUSH
45219: LD_VAR 0 1
45223: ARRAY
45224: NOT
45225: IFFALSE 45229
// exit ;
45227: GO 45254
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45229: LD_ADDR_EXP 130
45233: PUSH
45234: LD_EXP 130
45238: PPUSH
45239: LD_VAR 0 1
45243: PPUSH
45244: LD_VAR 0 2
45248: PPUSH
45249: CALL_OW 1
45253: ST_TO_ADDR
// end ;
45254: LD_VAR 0 3
45258: RET
// export function MC_GetMinesField ( base ) ; begin
45259: LD_INT 0
45261: PPUSH
// result := mc_mines [ base ] ;
45262: LD_ADDR_VAR 0 2
45266: PUSH
45267: LD_EXP 106
45271: PUSH
45272: LD_VAR 0 1
45276: ARRAY
45277: ST_TO_ADDR
// end ;
45278: LD_VAR 0 2
45282: RET
// export function MC_GetProduceList ( base ) ; begin
45283: LD_INT 0
45285: PPUSH
// result := mc_produce [ base ] ;
45286: LD_ADDR_VAR 0 2
45290: PUSH
45291: LD_EXP 114
45295: PUSH
45296: LD_VAR 0 1
45300: ARRAY
45301: ST_TO_ADDR
// end ;
45302: LD_VAR 0 2
45306: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45307: LD_INT 0
45309: PPUSH
45310: PPUSH
// if not mc_bases then
45311: LD_EXP 93
45315: NOT
45316: IFFALSE 45320
// exit ;
45318: GO 45385
// if mc_bases [ base ] then
45320: LD_EXP 93
45324: PUSH
45325: LD_VAR 0 1
45329: ARRAY
45330: IFFALSE 45385
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45332: LD_ADDR_VAR 0 3
45336: PUSH
45337: LD_EXP 93
45341: PUSH
45342: LD_VAR 0 1
45346: ARRAY
45347: PPUSH
45348: LD_INT 30
45350: PUSH
45351: LD_VAR 0 2
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PPUSH
45360: CALL_OW 72
45364: ST_TO_ADDR
// if result then
45365: LD_VAR 0 3
45369: IFFALSE 45385
// result := result [ 1 ] ;
45371: LD_ADDR_VAR 0 3
45375: PUSH
45376: LD_VAR 0 3
45380: PUSH
45381: LD_INT 1
45383: ARRAY
45384: ST_TO_ADDR
// end ; end ;
45385: LD_VAR 0 3
45389: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45390: LD_INT 0
45392: PPUSH
45393: PPUSH
// if not mc_bases then
45394: LD_EXP 93
45398: NOT
45399: IFFALSE 45403
// exit ;
45401: GO 45448
// if mc_bases [ base ] then
45403: LD_EXP 93
45407: PUSH
45408: LD_VAR 0 1
45412: ARRAY
45413: IFFALSE 45448
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45415: LD_ADDR_VAR 0 3
45419: PUSH
45420: LD_EXP 93
45424: PUSH
45425: LD_VAR 0 1
45429: ARRAY
45430: PPUSH
45431: LD_INT 30
45433: PUSH
45434: LD_VAR 0 2
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PPUSH
45443: CALL_OW 72
45447: ST_TO_ADDR
// end ;
45448: LD_VAR 0 3
45452: RET
// export function MC_SetTame ( base , area ) ; begin
45453: LD_INT 0
45455: PPUSH
// if not mc_bases or not base then
45456: LD_EXP 93
45460: NOT
45461: PUSH
45462: LD_VAR 0 1
45466: NOT
45467: OR
45468: IFFALSE 45472
// exit ;
45470: GO 45497
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45472: LD_ADDR_EXP 121
45476: PUSH
45477: LD_EXP 121
45481: PPUSH
45482: LD_VAR 0 1
45486: PPUSH
45487: LD_VAR 0 2
45491: PPUSH
45492: CALL_OW 1
45496: ST_TO_ADDR
// end ;
45497: LD_VAR 0 3
45501: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45502: LD_INT 0
45504: PPUSH
45505: PPUSH
// if not mc_bases or not base then
45506: LD_EXP 93
45510: NOT
45511: PUSH
45512: LD_VAR 0 1
45516: NOT
45517: OR
45518: IFFALSE 45522
// exit ;
45520: GO 45624
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45522: LD_ADDR_VAR 0 4
45526: PUSH
45527: LD_EXP 93
45531: PUSH
45532: LD_VAR 0 1
45536: ARRAY
45537: PPUSH
45538: LD_INT 30
45540: PUSH
45541: LD_VAR 0 2
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PPUSH
45550: CALL_OW 72
45554: ST_TO_ADDR
// if not tmp then
45555: LD_VAR 0 4
45559: NOT
45560: IFFALSE 45564
// exit ;
45562: GO 45624
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45564: LD_ADDR_EXP 125
45568: PUSH
45569: LD_EXP 125
45573: PPUSH
45574: LD_VAR 0 1
45578: PPUSH
45579: LD_EXP 125
45583: PUSH
45584: LD_VAR 0 1
45588: ARRAY
45589: PPUSH
45590: LD_EXP 125
45594: PUSH
45595: LD_VAR 0 1
45599: ARRAY
45600: PUSH
45601: LD_INT 1
45603: PLUS
45604: PPUSH
45605: LD_VAR 0 4
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: CALL_OW 2
45618: PPUSH
45619: CALL_OW 1
45623: ST_TO_ADDR
// end ;
45624: LD_VAR 0 3
45628: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45629: LD_INT 0
45631: PPUSH
45632: PPUSH
// if not mc_bases or not base or not kinds then
45633: LD_EXP 93
45637: NOT
45638: PUSH
45639: LD_VAR 0 1
45643: NOT
45644: OR
45645: PUSH
45646: LD_VAR 0 2
45650: NOT
45651: OR
45652: IFFALSE 45656
// exit ;
45654: GO 45717
// for i in kinds do
45656: LD_ADDR_VAR 0 4
45660: PUSH
45661: LD_VAR 0 2
45665: PUSH
45666: FOR_IN
45667: IFFALSE 45715
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45669: LD_ADDR_EXP 127
45673: PUSH
45674: LD_EXP 127
45678: PPUSH
45679: LD_VAR 0 1
45683: PUSH
45684: LD_EXP 127
45688: PUSH
45689: LD_VAR 0 1
45693: ARRAY
45694: PUSH
45695: LD_INT 1
45697: PLUS
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PPUSH
45703: LD_VAR 0 4
45707: PPUSH
45708: CALL 56327 0 3
45712: ST_TO_ADDR
45713: GO 45666
45715: POP
45716: POP
// end ;
45717: LD_VAR 0 3
45721: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45722: LD_INT 0
45724: PPUSH
// if not mc_bases or not base or not areas then
45725: LD_EXP 93
45729: NOT
45730: PUSH
45731: LD_VAR 0 1
45735: NOT
45736: OR
45737: PUSH
45738: LD_VAR 0 2
45742: NOT
45743: OR
45744: IFFALSE 45748
// exit ;
45746: GO 45773
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45748: LD_ADDR_EXP 111
45752: PUSH
45753: LD_EXP 111
45757: PPUSH
45758: LD_VAR 0 1
45762: PPUSH
45763: LD_VAR 0 2
45767: PPUSH
45768: CALL_OW 1
45772: ST_TO_ADDR
// end ;
45773: LD_VAR 0 3
45777: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45778: LD_INT 0
45780: PPUSH
// if not mc_bases or not base or not teleports_exit then
45781: LD_EXP 93
45785: NOT
45786: PUSH
45787: LD_VAR 0 1
45791: NOT
45792: OR
45793: PUSH
45794: LD_VAR 0 2
45798: NOT
45799: OR
45800: IFFALSE 45804
// exit ;
45802: GO 45829
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45804: LD_ADDR_EXP 128
45808: PUSH
45809: LD_EXP 128
45813: PPUSH
45814: LD_VAR 0 1
45818: PPUSH
45819: LD_VAR 0 2
45823: PPUSH
45824: CALL_OW 1
45828: ST_TO_ADDR
// end ;
45829: LD_VAR 0 3
45833: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45834: LD_INT 0
45836: PPUSH
45837: PPUSH
45838: PPUSH
// if not mc_bases or not base or not ext_list then
45839: LD_EXP 93
45843: NOT
45844: PUSH
45845: LD_VAR 0 1
45849: NOT
45850: OR
45851: PUSH
45852: LD_VAR 0 5
45856: NOT
45857: OR
45858: IFFALSE 45862
// exit ;
45860: GO 46035
// tmp := GetFacExtXYD ( x , y , d ) ;
45862: LD_ADDR_VAR 0 8
45866: PUSH
45867: LD_VAR 0 2
45871: PPUSH
45872: LD_VAR 0 3
45876: PPUSH
45877: LD_VAR 0 4
45881: PPUSH
45882: CALL 85714 0 3
45886: ST_TO_ADDR
// if not tmp then
45887: LD_VAR 0 8
45891: NOT
45892: IFFALSE 45896
// exit ;
45894: GO 46035
// for i in tmp do
45896: LD_ADDR_VAR 0 7
45900: PUSH
45901: LD_VAR 0 8
45905: PUSH
45906: FOR_IN
45907: IFFALSE 46033
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45909: LD_ADDR_EXP 98
45913: PUSH
45914: LD_EXP 98
45918: PPUSH
45919: LD_VAR 0 1
45923: PPUSH
45924: LD_EXP 98
45928: PUSH
45929: LD_VAR 0 1
45933: ARRAY
45934: PPUSH
45935: LD_EXP 98
45939: PUSH
45940: LD_VAR 0 1
45944: ARRAY
45945: PUSH
45946: LD_INT 1
45948: PLUS
45949: PPUSH
45950: LD_VAR 0 5
45954: PUSH
45955: LD_INT 1
45957: ARRAY
45958: PUSH
45959: LD_VAR 0 7
45963: PUSH
45964: LD_INT 1
45966: ARRAY
45967: PUSH
45968: LD_VAR 0 7
45972: PUSH
45973: LD_INT 2
45975: ARRAY
45976: PUSH
45977: LD_VAR 0 7
45981: PUSH
45982: LD_INT 3
45984: ARRAY
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: PPUSH
45992: CALL_OW 2
45996: PPUSH
45997: CALL_OW 1
46001: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46002: LD_ADDR_VAR 0 5
46006: PUSH
46007: LD_VAR 0 5
46011: PPUSH
46012: LD_INT 1
46014: PPUSH
46015: CALL_OW 3
46019: ST_TO_ADDR
// if not ext_list then
46020: LD_VAR 0 5
46024: NOT
46025: IFFALSE 46031
// exit ;
46027: POP
46028: POP
46029: GO 46035
// end ;
46031: GO 45906
46033: POP
46034: POP
// end ;
46035: LD_VAR 0 6
46039: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46040: LD_INT 0
46042: PPUSH
// if not mc_bases or not base or not weapon_list then
46043: LD_EXP 93
46047: NOT
46048: PUSH
46049: LD_VAR 0 1
46053: NOT
46054: OR
46055: PUSH
46056: LD_VAR 0 2
46060: NOT
46061: OR
46062: IFFALSE 46066
// exit ;
46064: GO 46091
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46066: LD_ADDR_EXP 132
46070: PUSH
46071: LD_EXP 132
46075: PPUSH
46076: LD_VAR 0 1
46080: PPUSH
46081: LD_VAR 0 2
46085: PPUSH
46086: CALL_OW 1
46090: ST_TO_ADDR
// end ;
46091: LD_VAR 0 3
46095: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46096: LD_INT 0
46098: PPUSH
// if not mc_bases or not base or not tech_list then
46099: LD_EXP 93
46103: NOT
46104: PUSH
46105: LD_VAR 0 1
46109: NOT
46110: OR
46111: PUSH
46112: LD_VAR 0 2
46116: NOT
46117: OR
46118: IFFALSE 46122
// exit ;
46120: GO 46147
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46122: LD_ADDR_EXP 120
46126: PUSH
46127: LD_EXP 120
46131: PPUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: LD_VAR 0 2
46141: PPUSH
46142: CALL_OW 1
46146: ST_TO_ADDR
// end ;
46147: LD_VAR 0 3
46151: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46152: LD_INT 0
46154: PPUSH
// if not mc_bases or not parking_area or not base then
46155: LD_EXP 93
46159: NOT
46160: PUSH
46161: LD_VAR 0 2
46165: NOT
46166: OR
46167: PUSH
46168: LD_VAR 0 1
46172: NOT
46173: OR
46174: IFFALSE 46178
// exit ;
46176: GO 46203
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46178: LD_ADDR_EXP 117
46182: PUSH
46183: LD_EXP 117
46187: PPUSH
46188: LD_VAR 0 1
46192: PPUSH
46193: LD_VAR 0 2
46197: PPUSH
46198: CALL_OW 1
46202: ST_TO_ADDR
// end ;
46203: LD_VAR 0 3
46207: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46208: LD_INT 0
46210: PPUSH
// if not mc_bases or not base or not scan_area then
46211: LD_EXP 93
46215: NOT
46216: PUSH
46217: LD_VAR 0 1
46221: NOT
46222: OR
46223: PUSH
46224: LD_VAR 0 2
46228: NOT
46229: OR
46230: IFFALSE 46234
// exit ;
46232: GO 46259
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46234: LD_ADDR_EXP 118
46238: PUSH
46239: LD_EXP 118
46243: PPUSH
46244: LD_VAR 0 1
46248: PPUSH
46249: LD_VAR 0 2
46253: PPUSH
46254: CALL_OW 1
46258: ST_TO_ADDR
// end ;
46259: LD_VAR 0 3
46263: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46264: LD_INT 0
46266: PPUSH
46267: PPUSH
// if not mc_bases or not base then
46268: LD_EXP 93
46272: NOT
46273: PUSH
46274: LD_VAR 0 1
46278: NOT
46279: OR
46280: IFFALSE 46284
// exit ;
46282: GO 46348
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46284: LD_ADDR_VAR 0 3
46288: PUSH
46289: LD_INT 1
46291: PUSH
46292: LD_INT 2
46294: PUSH
46295: LD_INT 3
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: LD_INT 11
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46311: LD_ADDR_EXP 120
46315: PUSH
46316: LD_EXP 120
46320: PPUSH
46321: LD_VAR 0 1
46325: PPUSH
46326: LD_EXP 120
46330: PUSH
46331: LD_VAR 0 1
46335: ARRAY
46336: PUSH
46337: LD_VAR 0 3
46341: DIFF
46342: PPUSH
46343: CALL_OW 1
46347: ST_TO_ADDR
// end ;
46348: LD_VAR 0 2
46352: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46353: LD_INT 0
46355: PPUSH
// result := mc_vehicles [ base ] ;
46356: LD_ADDR_VAR 0 3
46360: PUSH
46361: LD_EXP 112
46365: PUSH
46366: LD_VAR 0 1
46370: ARRAY
46371: ST_TO_ADDR
// if onlyCombat then
46372: LD_VAR 0 2
46376: IFFALSE 46554
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46378: LD_ADDR_VAR 0 3
46382: PUSH
46383: LD_VAR 0 3
46387: PUSH
46388: LD_VAR 0 3
46392: PPUSH
46393: LD_INT 2
46395: PUSH
46396: LD_INT 34
46398: PUSH
46399: LD_INT 12
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 34
46408: PUSH
46409: LD_INT 51
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 34
46418: PUSH
46419: LD_EXP 73
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 34
46430: PUSH
46431: LD_INT 32
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 34
46440: PUSH
46441: LD_INT 13
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 34
46450: PUSH
46451: LD_INT 52
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 34
46460: PUSH
46461: LD_EXP 78
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 34
46472: PUSH
46473: LD_INT 14
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 34
46482: PUSH
46483: LD_INT 53
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: LD_INT 34
46492: PUSH
46493: LD_EXP 72
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 34
46504: PUSH
46505: LD_INT 31
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 34
46514: PUSH
46515: LD_INT 48
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PUSH
46522: LD_INT 34
46524: PUSH
46525: LD_INT 8
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: PPUSH
46548: CALL_OW 72
46552: DIFF
46553: ST_TO_ADDR
// end ; end_of_file
46554: LD_VAR 0 3
46558: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46559: LD_INT 0
46561: PPUSH
46562: PPUSH
46563: PPUSH
// if not mc_bases or not skirmish then
46564: LD_EXP 93
46568: NOT
46569: PUSH
46570: LD_EXP 91
46574: NOT
46575: OR
46576: IFFALSE 46580
// exit ;
46578: GO 46745
// for i = 1 to mc_bases do
46580: LD_ADDR_VAR 0 4
46584: PUSH
46585: DOUBLE
46586: LD_INT 1
46588: DEC
46589: ST_TO_ADDR
46590: LD_EXP 93
46594: PUSH
46595: FOR_TO
46596: IFFALSE 46743
// begin if sci in mc_bases [ i ] then
46598: LD_VAR 0 2
46602: PUSH
46603: LD_EXP 93
46607: PUSH
46608: LD_VAR 0 4
46612: ARRAY
46613: IN
46614: IFFALSE 46741
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46616: LD_ADDR_EXP 122
46620: PUSH
46621: LD_EXP 122
46625: PPUSH
46626: LD_VAR 0 4
46630: PUSH
46631: LD_EXP 122
46635: PUSH
46636: LD_VAR 0 4
46640: ARRAY
46641: PUSH
46642: LD_INT 1
46644: PLUS
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PPUSH
46650: LD_VAR 0 1
46654: PPUSH
46655: CALL 56327 0 3
46659: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46660: LD_ADDR_VAR 0 5
46664: PUSH
46665: LD_EXP 93
46669: PUSH
46670: LD_VAR 0 4
46674: ARRAY
46675: PPUSH
46676: LD_INT 2
46678: PUSH
46679: LD_INT 30
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 30
46691: PUSH
46692: LD_INT 1
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: LIST
46703: PPUSH
46704: CALL_OW 72
46708: PPUSH
46709: LD_VAR 0 1
46713: PPUSH
46714: CALL_OW 74
46718: ST_TO_ADDR
// if tmp then
46719: LD_VAR 0 5
46723: IFFALSE 46739
// ComStandNearbyBuilding ( ape , tmp ) ;
46725: LD_VAR 0 1
46729: PPUSH
46730: LD_VAR 0 5
46734: PPUSH
46735: CALL 52905 0 2
// break ;
46739: GO 46743
// end ; end ;
46741: GO 46595
46743: POP
46744: POP
// end ;
46745: LD_VAR 0 3
46749: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46750: LD_INT 0
46752: PPUSH
46753: PPUSH
46754: PPUSH
// if not mc_bases or not skirmish then
46755: LD_EXP 93
46759: NOT
46760: PUSH
46761: LD_EXP 91
46765: NOT
46766: OR
46767: IFFALSE 46771
// exit ;
46769: GO 46860
// for i = 1 to mc_bases do
46771: LD_ADDR_VAR 0 4
46775: PUSH
46776: DOUBLE
46777: LD_INT 1
46779: DEC
46780: ST_TO_ADDR
46781: LD_EXP 93
46785: PUSH
46786: FOR_TO
46787: IFFALSE 46858
// begin if building in mc_busy_turret_list [ i ] then
46789: LD_VAR 0 1
46793: PUSH
46794: LD_EXP 103
46798: PUSH
46799: LD_VAR 0 4
46803: ARRAY
46804: IN
46805: IFFALSE 46856
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46807: LD_ADDR_VAR 0 5
46811: PUSH
46812: LD_EXP 103
46816: PUSH
46817: LD_VAR 0 4
46821: ARRAY
46822: PUSH
46823: LD_VAR 0 1
46827: DIFF
46828: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46829: LD_ADDR_EXP 103
46833: PUSH
46834: LD_EXP 103
46838: PPUSH
46839: LD_VAR 0 4
46843: PPUSH
46844: LD_VAR 0 5
46848: PPUSH
46849: CALL_OW 1
46853: ST_TO_ADDR
// break ;
46854: GO 46858
// end ; end ;
46856: GO 46786
46858: POP
46859: POP
// end ;
46860: LD_VAR 0 3
46864: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46865: LD_INT 0
46867: PPUSH
46868: PPUSH
46869: PPUSH
// if not mc_bases or not skirmish then
46870: LD_EXP 93
46874: NOT
46875: PUSH
46876: LD_EXP 91
46880: NOT
46881: OR
46882: IFFALSE 46886
// exit ;
46884: GO 47085
// for i = 1 to mc_bases do
46886: LD_ADDR_VAR 0 5
46890: PUSH
46891: DOUBLE
46892: LD_INT 1
46894: DEC
46895: ST_TO_ADDR
46896: LD_EXP 93
46900: PUSH
46901: FOR_TO
46902: IFFALSE 47083
// if building in mc_bases [ i ] then
46904: LD_VAR 0 1
46908: PUSH
46909: LD_EXP 93
46913: PUSH
46914: LD_VAR 0 5
46918: ARRAY
46919: IN
46920: IFFALSE 47081
// begin tmp := mc_bases [ i ] diff building ;
46922: LD_ADDR_VAR 0 6
46926: PUSH
46927: LD_EXP 93
46931: PUSH
46932: LD_VAR 0 5
46936: ARRAY
46937: PUSH
46938: LD_VAR 0 1
46942: DIFF
46943: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46944: LD_ADDR_EXP 93
46948: PUSH
46949: LD_EXP 93
46953: PPUSH
46954: LD_VAR 0 5
46958: PPUSH
46959: LD_VAR 0 6
46963: PPUSH
46964: CALL_OW 1
46968: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46969: LD_VAR 0 1
46973: PUSH
46974: LD_EXP 101
46978: PUSH
46979: LD_VAR 0 5
46983: ARRAY
46984: IN
46985: IFFALSE 47024
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46987: LD_ADDR_EXP 101
46991: PUSH
46992: LD_EXP 101
46996: PPUSH
46997: LD_VAR 0 5
47001: PPUSH
47002: LD_EXP 101
47006: PUSH
47007: LD_VAR 0 5
47011: ARRAY
47012: PUSH
47013: LD_VAR 0 1
47017: DIFF
47018: PPUSH
47019: CALL_OW 1
47023: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47024: LD_VAR 0 1
47028: PUSH
47029: LD_EXP 102
47033: PUSH
47034: LD_VAR 0 5
47038: ARRAY
47039: IN
47040: IFFALSE 47079
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47042: LD_ADDR_EXP 102
47046: PUSH
47047: LD_EXP 102
47051: PPUSH
47052: LD_VAR 0 5
47056: PPUSH
47057: LD_EXP 102
47061: PUSH
47062: LD_VAR 0 5
47066: ARRAY
47067: PUSH
47068: LD_VAR 0 1
47072: DIFF
47073: PPUSH
47074: CALL_OW 1
47078: ST_TO_ADDR
// break ;
47079: GO 47083
// end ;
47081: GO 46901
47083: POP
47084: POP
// end ;
47085: LD_VAR 0 4
47089: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47090: LD_INT 0
47092: PPUSH
47093: PPUSH
47094: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47095: LD_EXP 93
47099: NOT
47100: PUSH
47101: LD_EXP 91
47105: NOT
47106: OR
47107: PUSH
47108: LD_VAR 0 3
47112: PUSH
47113: LD_EXP 119
47117: IN
47118: NOT
47119: OR
47120: IFFALSE 47124
// exit ;
47122: GO 47247
// for i = 1 to mc_vehicles do
47124: LD_ADDR_VAR 0 6
47128: PUSH
47129: DOUBLE
47130: LD_INT 1
47132: DEC
47133: ST_TO_ADDR
47134: LD_EXP 112
47138: PUSH
47139: FOR_TO
47140: IFFALSE 47245
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47142: LD_VAR 0 2
47146: PUSH
47147: LD_EXP 112
47151: PUSH
47152: LD_VAR 0 6
47156: ARRAY
47157: IN
47158: PUSH
47159: LD_VAR 0 1
47163: PUSH
47164: LD_EXP 112
47168: PUSH
47169: LD_VAR 0 6
47173: ARRAY
47174: IN
47175: OR
47176: IFFALSE 47243
// begin tmp := mc_vehicles [ i ] diff old ;
47178: LD_ADDR_VAR 0 7
47182: PUSH
47183: LD_EXP 112
47187: PUSH
47188: LD_VAR 0 6
47192: ARRAY
47193: PUSH
47194: LD_VAR 0 2
47198: DIFF
47199: ST_TO_ADDR
// tmp := tmp diff new ;
47200: LD_ADDR_VAR 0 7
47204: PUSH
47205: LD_VAR 0 7
47209: PUSH
47210: LD_VAR 0 1
47214: DIFF
47215: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47216: LD_ADDR_EXP 112
47220: PUSH
47221: LD_EXP 112
47225: PPUSH
47226: LD_VAR 0 6
47230: PPUSH
47231: LD_VAR 0 7
47235: PPUSH
47236: CALL_OW 1
47240: ST_TO_ADDR
// break ;
47241: GO 47245
// end ;
47243: GO 47139
47245: POP
47246: POP
// end ;
47247: LD_VAR 0 5
47251: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47252: LD_INT 0
47254: PPUSH
47255: PPUSH
47256: PPUSH
47257: PPUSH
// if not mc_bases or not skirmish then
47258: LD_EXP 93
47262: NOT
47263: PUSH
47264: LD_EXP 91
47268: NOT
47269: OR
47270: IFFALSE 47274
// exit ;
47272: GO 47666
// side := GetSide ( vehicle ) ;
47274: LD_ADDR_VAR 0 5
47278: PUSH
47279: LD_VAR 0 1
47283: PPUSH
47284: CALL_OW 255
47288: ST_TO_ADDR
// for i = 1 to mc_bases do
47289: LD_ADDR_VAR 0 4
47293: PUSH
47294: DOUBLE
47295: LD_INT 1
47297: DEC
47298: ST_TO_ADDR
47299: LD_EXP 93
47303: PUSH
47304: FOR_TO
47305: IFFALSE 47664
// begin if factory in mc_bases [ i ] then
47307: LD_VAR 0 2
47311: PUSH
47312: LD_EXP 93
47316: PUSH
47317: LD_VAR 0 4
47321: ARRAY
47322: IN
47323: IFFALSE 47662
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47325: LD_EXP 115
47329: PUSH
47330: LD_VAR 0 4
47334: ARRAY
47335: PUSH
47336: LD_EXP 104
47340: PUSH
47341: LD_VAR 0 4
47345: ARRAY
47346: LESS
47347: PUSH
47348: LD_VAR 0 1
47352: PPUSH
47353: CALL_OW 264
47357: PUSH
47358: LD_INT 31
47360: PUSH
47361: LD_INT 32
47363: PUSH
47364: LD_INT 51
47366: PUSH
47367: LD_EXP 73
47371: PUSH
47372: LD_INT 12
47374: PUSH
47375: LD_INT 30
47377: PUSH
47378: LD_EXP 72
47382: PUSH
47383: LD_INT 11
47385: PUSH
47386: LD_INT 53
47388: PUSH
47389: LD_INT 14
47391: PUSH
47392: LD_EXP 76
47396: PUSH
47397: LD_INT 29
47399: PUSH
47400: LD_EXP 74
47404: PUSH
47405: LD_INT 13
47407: PUSH
47408: LD_INT 52
47410: PUSH
47411: LD_EXP 78
47415: PUSH
47416: LD_INT 48
47418: PUSH
47419: LD_INT 8
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: IN
47442: NOT
47443: AND
47444: IFFALSE 47492
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47446: LD_ADDR_EXP 115
47450: PUSH
47451: LD_EXP 115
47455: PPUSH
47456: LD_VAR 0 4
47460: PUSH
47461: LD_EXP 115
47465: PUSH
47466: LD_VAR 0 4
47470: ARRAY
47471: PUSH
47472: LD_INT 1
47474: PLUS
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PPUSH
47480: LD_VAR 0 1
47484: PPUSH
47485: CALL 56327 0 3
47489: ST_TO_ADDR
47490: GO 47536
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47492: LD_ADDR_EXP 112
47496: PUSH
47497: LD_EXP 112
47501: PPUSH
47502: LD_VAR 0 4
47506: PUSH
47507: LD_EXP 112
47511: PUSH
47512: LD_VAR 0 4
47516: ARRAY
47517: PUSH
47518: LD_INT 1
47520: PLUS
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: PPUSH
47526: LD_VAR 0 1
47530: PPUSH
47531: CALL 56327 0 3
47535: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47536: LD_VAR 0 1
47540: PPUSH
47541: CALL_OW 263
47545: PUSH
47546: LD_INT 2
47548: EQUAL
47549: IFFALSE 47578
// begin repeat wait ( 0 0$3 ) ;
47551: LD_INT 105
47553: PPUSH
47554: CALL_OW 67
// Connect ( vehicle ) ;
47558: LD_VAR 0 1
47562: PPUSH
47563: CALL 59298 0 1
// until IsControledBy ( vehicle ) ;
47567: LD_VAR 0 1
47571: PPUSH
47572: CALL_OW 312
47576: IFFALSE 47551
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47578: LD_VAR 0 1
47582: PPUSH
47583: LD_EXP 117
47587: PUSH
47588: LD_VAR 0 4
47592: ARRAY
47593: PPUSH
47594: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47598: LD_VAR 0 1
47602: PPUSH
47603: CALL_OW 263
47607: PUSH
47608: LD_INT 1
47610: NONEQUAL
47611: IFFALSE 47615
// break ;
47613: GO 47664
// repeat wait ( 0 0$1 ) ;
47615: LD_INT 35
47617: PPUSH
47618: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47622: LD_VAR 0 1
47626: PPUSH
47627: LD_EXP 117
47631: PUSH
47632: LD_VAR 0 4
47636: ARRAY
47637: PPUSH
47638: CALL_OW 308
47642: IFFALSE 47615
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47644: LD_VAR 0 1
47648: PPUSH
47649: CALL_OW 311
47653: PPUSH
47654: CALL_OW 121
// exit ;
47658: POP
47659: POP
47660: GO 47666
// end ; end ;
47662: GO 47304
47664: POP
47665: POP
// end ;
47666: LD_VAR 0 3
47670: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47671: LD_INT 0
47673: PPUSH
47674: PPUSH
47675: PPUSH
47676: PPUSH
// if not mc_bases or not skirmish then
47677: LD_EXP 93
47681: NOT
47682: PUSH
47683: LD_EXP 91
47687: NOT
47688: OR
47689: IFFALSE 47693
// exit ;
47691: GO 48046
// repeat wait ( 0 0$1 ) ;
47693: LD_INT 35
47695: PPUSH
47696: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47700: LD_VAR 0 2
47704: PPUSH
47705: LD_VAR 0 3
47709: PPUSH
47710: CALL_OW 284
47714: IFFALSE 47693
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47716: LD_VAR 0 2
47720: PPUSH
47721: LD_VAR 0 3
47725: PPUSH
47726: CALL_OW 283
47730: PUSH
47731: LD_INT 4
47733: EQUAL
47734: IFFALSE 47738
// exit ;
47736: GO 48046
// for i = 1 to mc_bases do
47738: LD_ADDR_VAR 0 7
47742: PUSH
47743: DOUBLE
47744: LD_INT 1
47746: DEC
47747: ST_TO_ADDR
47748: LD_EXP 93
47752: PUSH
47753: FOR_TO
47754: IFFALSE 48044
// begin if mc_crates_area [ i ] then
47756: LD_EXP 111
47760: PUSH
47761: LD_VAR 0 7
47765: ARRAY
47766: IFFALSE 47877
// for j in mc_crates_area [ i ] do
47768: LD_ADDR_VAR 0 8
47772: PUSH
47773: LD_EXP 111
47777: PUSH
47778: LD_VAR 0 7
47782: ARRAY
47783: PUSH
47784: FOR_IN
47785: IFFALSE 47875
// if InArea ( x , y , j ) then
47787: LD_VAR 0 2
47791: PPUSH
47792: LD_VAR 0 3
47796: PPUSH
47797: LD_VAR 0 8
47801: PPUSH
47802: CALL_OW 309
47806: IFFALSE 47873
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47808: LD_ADDR_EXP 109
47812: PUSH
47813: LD_EXP 109
47817: PPUSH
47818: LD_VAR 0 7
47822: PUSH
47823: LD_EXP 109
47827: PUSH
47828: LD_VAR 0 7
47832: ARRAY
47833: PUSH
47834: LD_INT 1
47836: PLUS
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PPUSH
47842: LD_VAR 0 4
47846: PUSH
47847: LD_VAR 0 2
47851: PUSH
47852: LD_VAR 0 3
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: LIST
47861: PPUSH
47862: CALL 56327 0 3
47866: ST_TO_ADDR
// exit ;
47867: POP
47868: POP
47869: POP
47870: POP
47871: GO 48046
// end ;
47873: GO 47784
47875: POP
47876: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47877: LD_ADDR_VAR 0 9
47881: PUSH
47882: LD_EXP 93
47886: PUSH
47887: LD_VAR 0 7
47891: ARRAY
47892: PPUSH
47893: LD_INT 2
47895: PUSH
47896: LD_INT 30
47898: PUSH
47899: LD_INT 0
47901: PUSH
47902: EMPTY
47903: LIST
47904: LIST
47905: PUSH
47906: LD_INT 30
47908: PUSH
47909: LD_INT 1
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: LIST
47920: PPUSH
47921: CALL_OW 72
47925: ST_TO_ADDR
// if not depot then
47926: LD_VAR 0 9
47930: NOT
47931: IFFALSE 47935
// continue ;
47933: GO 47753
// for j in depot do
47935: LD_ADDR_VAR 0 8
47939: PUSH
47940: LD_VAR 0 9
47944: PUSH
47945: FOR_IN
47946: IFFALSE 48040
// if GetDistUnitXY ( j , x , y ) < 30 then
47948: LD_VAR 0 8
47952: PPUSH
47953: LD_VAR 0 2
47957: PPUSH
47958: LD_VAR 0 3
47962: PPUSH
47963: CALL_OW 297
47967: PUSH
47968: LD_INT 30
47970: LESS
47971: IFFALSE 48038
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47973: LD_ADDR_EXP 109
47977: PUSH
47978: LD_EXP 109
47982: PPUSH
47983: LD_VAR 0 7
47987: PUSH
47988: LD_EXP 109
47992: PUSH
47993: LD_VAR 0 7
47997: ARRAY
47998: PUSH
47999: LD_INT 1
48001: PLUS
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PPUSH
48007: LD_VAR 0 4
48011: PUSH
48012: LD_VAR 0 2
48016: PUSH
48017: LD_VAR 0 3
48021: PUSH
48022: EMPTY
48023: LIST
48024: LIST
48025: LIST
48026: PPUSH
48027: CALL 56327 0 3
48031: ST_TO_ADDR
// exit ;
48032: POP
48033: POP
48034: POP
48035: POP
48036: GO 48046
// end ;
48038: GO 47945
48040: POP
48041: POP
// end ;
48042: GO 47753
48044: POP
48045: POP
// end ;
48046: LD_VAR 0 6
48050: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48051: LD_INT 0
48053: PPUSH
48054: PPUSH
48055: PPUSH
48056: PPUSH
// if not mc_bases or not skirmish then
48057: LD_EXP 93
48061: NOT
48062: PUSH
48063: LD_EXP 91
48067: NOT
48068: OR
48069: IFFALSE 48073
// exit ;
48071: GO 48350
// side := GetSide ( lab ) ;
48073: LD_ADDR_VAR 0 4
48077: PUSH
48078: LD_VAR 0 2
48082: PPUSH
48083: CALL_OW 255
48087: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48088: LD_VAR 0 4
48092: PUSH
48093: LD_EXP 119
48097: IN
48098: NOT
48099: PUSH
48100: LD_EXP 120
48104: NOT
48105: OR
48106: PUSH
48107: LD_EXP 93
48111: NOT
48112: OR
48113: IFFALSE 48117
// exit ;
48115: GO 48350
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48117: LD_ADDR_EXP 120
48121: PUSH
48122: LD_EXP 120
48126: PPUSH
48127: LD_VAR 0 4
48131: PPUSH
48132: LD_EXP 120
48136: PUSH
48137: LD_VAR 0 4
48141: ARRAY
48142: PUSH
48143: LD_VAR 0 1
48147: DIFF
48148: PPUSH
48149: CALL_OW 1
48153: ST_TO_ADDR
// for i = 1 to mc_bases do
48154: LD_ADDR_VAR 0 5
48158: PUSH
48159: DOUBLE
48160: LD_INT 1
48162: DEC
48163: ST_TO_ADDR
48164: LD_EXP 93
48168: PUSH
48169: FOR_TO
48170: IFFALSE 48348
// begin if lab in mc_bases [ i ] then
48172: LD_VAR 0 2
48176: PUSH
48177: LD_EXP 93
48181: PUSH
48182: LD_VAR 0 5
48186: ARRAY
48187: IN
48188: IFFALSE 48346
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48190: LD_VAR 0 1
48194: PUSH
48195: LD_INT 11
48197: PUSH
48198: LD_INT 4
48200: PUSH
48201: LD_INT 3
48203: PUSH
48204: LD_INT 2
48206: PUSH
48207: EMPTY
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: IN
48213: PUSH
48214: LD_EXP 123
48218: PUSH
48219: LD_VAR 0 5
48223: ARRAY
48224: AND
48225: IFFALSE 48346
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48227: LD_ADDR_VAR 0 6
48231: PUSH
48232: LD_EXP 123
48236: PUSH
48237: LD_VAR 0 5
48241: ARRAY
48242: PUSH
48243: LD_INT 1
48245: ARRAY
48246: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48247: LD_ADDR_EXP 123
48251: PUSH
48252: LD_EXP 123
48256: PPUSH
48257: LD_VAR 0 5
48261: PPUSH
48262: EMPTY
48263: PPUSH
48264: CALL_OW 1
48268: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48269: LD_VAR 0 6
48273: PPUSH
48274: LD_INT 0
48276: PPUSH
48277: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48281: LD_VAR 0 6
48285: PPUSH
48286: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48290: LD_ADDR_EXP 122
48294: PUSH
48295: LD_EXP 122
48299: PPUSH
48300: LD_VAR 0 5
48304: PPUSH
48305: LD_EXP 122
48309: PUSH
48310: LD_VAR 0 5
48314: ARRAY
48315: PPUSH
48316: LD_INT 1
48318: PPUSH
48319: LD_VAR 0 6
48323: PPUSH
48324: CALL_OW 2
48328: PPUSH
48329: CALL_OW 1
48333: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48334: LD_VAR 0 5
48338: PPUSH
48339: LD_INT 112
48341: PPUSH
48342: CALL 25016 0 2
// end ; end ; end ;
48346: GO 48169
48348: POP
48349: POP
// end ;
48350: LD_VAR 0 3
48354: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48355: LD_INT 0
48357: PPUSH
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
48362: PPUSH
48363: PPUSH
48364: PPUSH
// if not mc_bases or not skirmish then
48365: LD_EXP 93
48369: NOT
48370: PUSH
48371: LD_EXP 91
48375: NOT
48376: OR
48377: IFFALSE 48381
// exit ;
48379: GO 49752
// for i = 1 to mc_bases do
48381: LD_ADDR_VAR 0 3
48385: PUSH
48386: DOUBLE
48387: LD_INT 1
48389: DEC
48390: ST_TO_ADDR
48391: LD_EXP 93
48395: PUSH
48396: FOR_TO
48397: IFFALSE 49750
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48399: LD_VAR 0 1
48403: PUSH
48404: LD_EXP 93
48408: PUSH
48409: LD_VAR 0 3
48413: ARRAY
48414: IN
48415: PUSH
48416: LD_VAR 0 1
48420: PUSH
48421: LD_EXP 100
48425: PUSH
48426: LD_VAR 0 3
48430: ARRAY
48431: IN
48432: OR
48433: PUSH
48434: LD_VAR 0 1
48438: PUSH
48439: LD_EXP 115
48443: PUSH
48444: LD_VAR 0 3
48448: ARRAY
48449: IN
48450: OR
48451: PUSH
48452: LD_VAR 0 1
48456: PUSH
48457: LD_EXP 112
48461: PUSH
48462: LD_VAR 0 3
48466: ARRAY
48467: IN
48468: OR
48469: PUSH
48470: LD_VAR 0 1
48474: PUSH
48475: LD_EXP 122
48479: PUSH
48480: LD_VAR 0 3
48484: ARRAY
48485: IN
48486: OR
48487: PUSH
48488: LD_VAR 0 1
48492: PUSH
48493: LD_EXP 123
48497: PUSH
48498: LD_VAR 0 3
48502: ARRAY
48503: IN
48504: OR
48505: IFFALSE 49748
// begin if un in mc_ape [ i ] then
48507: LD_VAR 0 1
48511: PUSH
48512: LD_EXP 122
48516: PUSH
48517: LD_VAR 0 3
48521: ARRAY
48522: IN
48523: IFFALSE 48562
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48525: LD_ADDR_EXP 122
48529: PUSH
48530: LD_EXP 122
48534: PPUSH
48535: LD_VAR 0 3
48539: PPUSH
48540: LD_EXP 122
48544: PUSH
48545: LD_VAR 0 3
48549: ARRAY
48550: PUSH
48551: LD_VAR 0 1
48555: DIFF
48556: PPUSH
48557: CALL_OW 1
48561: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48562: LD_VAR 0 1
48566: PUSH
48567: LD_EXP 123
48571: PUSH
48572: LD_VAR 0 3
48576: ARRAY
48577: IN
48578: IFFALSE 48602
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48580: LD_ADDR_EXP 123
48584: PUSH
48585: LD_EXP 123
48589: PPUSH
48590: LD_VAR 0 3
48594: PPUSH
48595: EMPTY
48596: PPUSH
48597: CALL_OW 1
48601: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48602: LD_VAR 0 1
48606: PPUSH
48607: CALL_OW 247
48611: PUSH
48612: LD_INT 2
48614: EQUAL
48615: PUSH
48616: LD_VAR 0 1
48620: PPUSH
48621: CALL_OW 110
48625: PUSH
48626: LD_INT 20
48628: EQUAL
48629: PUSH
48630: LD_VAR 0 1
48634: PUSH
48635: LD_EXP 115
48639: PUSH
48640: LD_VAR 0 3
48644: ARRAY
48645: IN
48646: OR
48647: PUSH
48648: LD_VAR 0 1
48652: PPUSH
48653: CALL_OW 264
48657: PUSH
48658: LD_INT 12
48660: PUSH
48661: LD_INT 51
48663: PUSH
48664: LD_EXP 73
48668: PUSH
48669: LD_INT 32
48671: PUSH
48672: LD_INT 13
48674: PUSH
48675: LD_INT 52
48677: PUSH
48678: LD_INT 31
48680: PUSH
48681: EMPTY
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: IN
48690: OR
48691: AND
48692: IFFALSE 49000
// begin if un in mc_defender [ i ] then
48694: LD_VAR 0 1
48698: PUSH
48699: LD_EXP 115
48703: PUSH
48704: LD_VAR 0 3
48708: ARRAY
48709: IN
48710: IFFALSE 48749
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48712: LD_ADDR_EXP 115
48716: PUSH
48717: LD_EXP 115
48721: PPUSH
48722: LD_VAR 0 3
48726: PPUSH
48727: LD_EXP 115
48731: PUSH
48732: LD_VAR 0 3
48736: ARRAY
48737: PUSH
48738: LD_VAR 0 1
48742: DIFF
48743: PPUSH
48744: CALL_OW 1
48748: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48749: LD_ADDR_VAR 0 8
48753: PUSH
48754: LD_VAR 0 3
48758: PPUSH
48759: LD_INT 3
48761: PPUSH
48762: CALL 45390 0 2
48766: ST_TO_ADDR
// if fac then
48767: LD_VAR 0 8
48771: IFFALSE 49000
// begin for j in fac do
48773: LD_ADDR_VAR 0 4
48777: PUSH
48778: LD_VAR 0 8
48782: PUSH
48783: FOR_IN
48784: IFFALSE 48998
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48786: LD_ADDR_VAR 0 9
48790: PUSH
48791: LD_VAR 0 8
48795: PPUSH
48796: LD_VAR 0 1
48800: PPUSH
48801: CALL_OW 265
48805: PPUSH
48806: LD_VAR 0 1
48810: PPUSH
48811: CALL_OW 262
48815: PPUSH
48816: LD_VAR 0 1
48820: PPUSH
48821: CALL_OW 263
48825: PPUSH
48826: LD_VAR 0 1
48830: PPUSH
48831: CALL_OW 264
48835: PPUSH
48836: CALL 53823 0 5
48840: ST_TO_ADDR
// if components then
48841: LD_VAR 0 9
48845: IFFALSE 48996
// begin if GetWeapon ( un ) = ar_control_tower then
48847: LD_VAR 0 1
48851: PPUSH
48852: CALL_OW 264
48856: PUSH
48857: LD_INT 31
48859: EQUAL
48860: IFFALSE 48977
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48862: LD_VAR 0 1
48866: PPUSH
48867: CALL_OW 311
48871: PPUSH
48872: LD_INT 0
48874: PPUSH
48875: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48879: LD_ADDR_EXP 133
48883: PUSH
48884: LD_EXP 133
48888: PPUSH
48889: LD_VAR 0 3
48893: PPUSH
48894: LD_EXP 133
48898: PUSH
48899: LD_VAR 0 3
48903: ARRAY
48904: PUSH
48905: LD_VAR 0 1
48909: PPUSH
48910: CALL_OW 311
48914: DIFF
48915: PPUSH
48916: CALL_OW 1
48920: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48921: LD_ADDR_VAR 0 7
48925: PUSH
48926: LD_EXP 114
48930: PUSH
48931: LD_VAR 0 3
48935: ARRAY
48936: PPUSH
48937: LD_INT 1
48939: PPUSH
48940: LD_VAR 0 9
48944: PPUSH
48945: CALL_OW 2
48949: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48950: LD_ADDR_EXP 114
48954: PUSH
48955: LD_EXP 114
48959: PPUSH
48960: LD_VAR 0 3
48964: PPUSH
48965: LD_VAR 0 7
48969: PPUSH
48970: CALL_OW 1
48974: ST_TO_ADDR
// end else
48975: GO 48994
// MC_InsertProduceList ( i , [ components ] ) ;
48977: LD_VAR 0 3
48981: PPUSH
48982: LD_VAR 0 9
48986: PUSH
48987: EMPTY
48988: LIST
48989: PPUSH
48990: CALL 44935 0 2
// break ;
48994: GO 48998
// end ; end ;
48996: GO 48783
48998: POP
48999: POP
// end ; end ; if GetType ( un ) = unit_building then
49000: LD_VAR 0 1
49004: PPUSH
49005: CALL_OW 247
49009: PUSH
49010: LD_INT 3
49012: EQUAL
49013: IFFALSE 49416
// begin btype := GetBType ( un ) ;
49015: LD_ADDR_VAR 0 5
49019: PUSH
49020: LD_VAR 0 1
49024: PPUSH
49025: CALL_OW 266
49029: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49030: LD_VAR 0 5
49034: PUSH
49035: LD_INT 29
49037: PUSH
49038: LD_INT 30
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: IN
49045: IFFALSE 49118
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49047: LD_VAR 0 1
49051: PPUSH
49052: CALL_OW 250
49056: PPUSH
49057: LD_VAR 0 1
49061: PPUSH
49062: CALL_OW 251
49066: PPUSH
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL_OW 255
49076: PPUSH
49077: CALL_OW 440
49081: NOT
49082: IFFALSE 49118
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49084: LD_VAR 0 1
49088: PPUSH
49089: CALL_OW 250
49093: PPUSH
49094: LD_VAR 0 1
49098: PPUSH
49099: CALL_OW 251
49103: PPUSH
49104: LD_VAR 0 1
49108: PPUSH
49109: CALL_OW 255
49113: PPUSH
49114: CALL_OW 441
// end ; if btype = b_warehouse then
49118: LD_VAR 0 5
49122: PUSH
49123: LD_INT 1
49125: EQUAL
49126: IFFALSE 49144
// begin btype := b_depot ;
49128: LD_ADDR_VAR 0 5
49132: PUSH
49133: LD_INT 0
49135: ST_TO_ADDR
// pos := 1 ;
49136: LD_ADDR_VAR 0 6
49140: PUSH
49141: LD_INT 1
49143: ST_TO_ADDR
// end ; if btype = b_factory then
49144: LD_VAR 0 5
49148: PUSH
49149: LD_INT 3
49151: EQUAL
49152: IFFALSE 49170
// begin btype := b_workshop ;
49154: LD_ADDR_VAR 0 5
49158: PUSH
49159: LD_INT 2
49161: ST_TO_ADDR
// pos := 1 ;
49162: LD_ADDR_VAR 0 6
49166: PUSH
49167: LD_INT 1
49169: ST_TO_ADDR
// end ; if btype = b_barracks then
49170: LD_VAR 0 5
49174: PUSH
49175: LD_INT 5
49177: EQUAL
49178: IFFALSE 49188
// btype := b_armoury ;
49180: LD_ADDR_VAR 0 5
49184: PUSH
49185: LD_INT 4
49187: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49188: LD_VAR 0 5
49192: PUSH
49193: LD_INT 7
49195: PUSH
49196: LD_INT 8
49198: PUSH
49199: EMPTY
49200: LIST
49201: LIST
49202: IN
49203: IFFALSE 49213
// btype := b_lab ;
49205: LD_ADDR_VAR 0 5
49209: PUSH
49210: LD_INT 6
49212: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49213: LD_ADDR_EXP 98
49217: PUSH
49218: LD_EXP 98
49222: PPUSH
49223: LD_VAR 0 3
49227: PUSH
49228: LD_EXP 98
49232: PUSH
49233: LD_VAR 0 3
49237: ARRAY
49238: PUSH
49239: LD_INT 1
49241: PLUS
49242: PUSH
49243: EMPTY
49244: LIST
49245: LIST
49246: PPUSH
49247: LD_VAR 0 5
49251: PUSH
49252: LD_VAR 0 1
49256: PPUSH
49257: CALL_OW 250
49261: PUSH
49262: LD_VAR 0 1
49266: PPUSH
49267: CALL_OW 251
49271: PUSH
49272: LD_VAR 0 1
49276: PPUSH
49277: CALL_OW 254
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: PPUSH
49288: CALL 56327 0 3
49292: ST_TO_ADDR
// if pos = 1 then
49293: LD_VAR 0 6
49297: PUSH
49298: LD_INT 1
49300: EQUAL
49301: IFFALSE 49416
// begin tmp := mc_build_list [ i ] ;
49303: LD_ADDR_VAR 0 7
49307: PUSH
49308: LD_EXP 98
49312: PUSH
49313: LD_VAR 0 3
49317: ARRAY
49318: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49319: LD_VAR 0 7
49323: PPUSH
49324: LD_INT 2
49326: PUSH
49327: LD_INT 30
49329: PUSH
49330: LD_INT 0
49332: PUSH
49333: EMPTY
49334: LIST
49335: LIST
49336: PUSH
49337: LD_INT 30
49339: PUSH
49340: LD_INT 1
49342: PUSH
49343: EMPTY
49344: LIST
49345: LIST
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: LIST
49351: PPUSH
49352: CALL_OW 72
49356: IFFALSE 49366
// pos := 2 ;
49358: LD_ADDR_VAR 0 6
49362: PUSH
49363: LD_INT 2
49365: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49366: LD_ADDR_VAR 0 7
49370: PUSH
49371: LD_VAR 0 7
49375: PPUSH
49376: LD_VAR 0 6
49380: PPUSH
49381: LD_VAR 0 7
49385: PPUSH
49386: CALL 56653 0 3
49390: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49391: LD_ADDR_EXP 98
49395: PUSH
49396: LD_EXP 98
49400: PPUSH
49401: LD_VAR 0 3
49405: PPUSH
49406: LD_VAR 0 7
49410: PPUSH
49411: CALL_OW 1
49415: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49416: LD_VAR 0 1
49420: PUSH
49421: LD_EXP 93
49425: PUSH
49426: LD_VAR 0 3
49430: ARRAY
49431: IN
49432: IFFALSE 49471
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49434: LD_ADDR_EXP 93
49438: PUSH
49439: LD_EXP 93
49443: PPUSH
49444: LD_VAR 0 3
49448: PPUSH
49449: LD_EXP 93
49453: PUSH
49454: LD_VAR 0 3
49458: ARRAY
49459: PUSH
49460: LD_VAR 0 1
49464: DIFF
49465: PPUSH
49466: CALL_OW 1
49470: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49471: LD_VAR 0 1
49475: PUSH
49476: LD_EXP 100
49480: PUSH
49481: LD_VAR 0 3
49485: ARRAY
49486: IN
49487: IFFALSE 49526
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49489: LD_ADDR_EXP 100
49493: PUSH
49494: LD_EXP 100
49498: PPUSH
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_EXP 100
49508: PUSH
49509: LD_VAR 0 3
49513: ARRAY
49514: PUSH
49515: LD_VAR 0 1
49519: DIFF
49520: PPUSH
49521: CALL_OW 1
49525: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49526: LD_VAR 0 1
49530: PUSH
49531: LD_EXP 112
49535: PUSH
49536: LD_VAR 0 3
49540: ARRAY
49541: IN
49542: IFFALSE 49581
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49544: LD_ADDR_EXP 112
49548: PUSH
49549: LD_EXP 112
49553: PPUSH
49554: LD_VAR 0 3
49558: PPUSH
49559: LD_EXP 112
49563: PUSH
49564: LD_VAR 0 3
49568: ARRAY
49569: PUSH
49570: LD_VAR 0 1
49574: DIFF
49575: PPUSH
49576: CALL_OW 1
49580: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49581: LD_VAR 0 1
49585: PUSH
49586: LD_EXP 115
49590: PUSH
49591: LD_VAR 0 3
49595: ARRAY
49596: IN
49597: IFFALSE 49636
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49599: LD_ADDR_EXP 115
49603: PUSH
49604: LD_EXP 115
49608: PPUSH
49609: LD_VAR 0 3
49613: PPUSH
49614: LD_EXP 115
49618: PUSH
49619: LD_VAR 0 3
49623: ARRAY
49624: PUSH
49625: LD_VAR 0 1
49629: DIFF
49630: PPUSH
49631: CALL_OW 1
49635: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49636: LD_VAR 0 1
49640: PUSH
49641: LD_EXP 102
49645: PUSH
49646: LD_VAR 0 3
49650: ARRAY
49651: IN
49652: IFFALSE 49691
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49654: LD_ADDR_EXP 102
49658: PUSH
49659: LD_EXP 102
49663: PPUSH
49664: LD_VAR 0 3
49668: PPUSH
49669: LD_EXP 102
49673: PUSH
49674: LD_VAR 0 3
49678: ARRAY
49679: PUSH
49680: LD_VAR 0 1
49684: DIFF
49685: PPUSH
49686: CALL_OW 1
49690: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49691: LD_VAR 0 1
49695: PUSH
49696: LD_EXP 101
49700: PUSH
49701: LD_VAR 0 3
49705: ARRAY
49706: IN
49707: IFFALSE 49746
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49709: LD_ADDR_EXP 101
49713: PUSH
49714: LD_EXP 101
49718: PPUSH
49719: LD_VAR 0 3
49723: PPUSH
49724: LD_EXP 101
49728: PUSH
49729: LD_VAR 0 3
49733: ARRAY
49734: PUSH
49735: LD_VAR 0 1
49739: DIFF
49740: PPUSH
49741: CALL_OW 1
49745: ST_TO_ADDR
// end ; break ;
49746: GO 49750
// end ;
49748: GO 48396
49750: POP
49751: POP
// end ;
49752: LD_VAR 0 2
49756: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49757: LD_INT 0
49759: PPUSH
49760: PPUSH
49761: PPUSH
// if not mc_bases or not skirmish then
49762: LD_EXP 93
49766: NOT
49767: PUSH
49768: LD_EXP 91
49772: NOT
49773: OR
49774: IFFALSE 49778
// exit ;
49776: GO 49993
// for i = 1 to mc_bases do
49778: LD_ADDR_VAR 0 3
49782: PUSH
49783: DOUBLE
49784: LD_INT 1
49786: DEC
49787: ST_TO_ADDR
49788: LD_EXP 93
49792: PUSH
49793: FOR_TO
49794: IFFALSE 49991
// begin if building in mc_construct_list [ i ] then
49796: LD_VAR 0 1
49800: PUSH
49801: LD_EXP 100
49805: PUSH
49806: LD_VAR 0 3
49810: ARRAY
49811: IN
49812: IFFALSE 49989
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49814: LD_ADDR_EXP 100
49818: PUSH
49819: LD_EXP 100
49823: PPUSH
49824: LD_VAR 0 3
49828: PPUSH
49829: LD_EXP 100
49833: PUSH
49834: LD_VAR 0 3
49838: ARRAY
49839: PUSH
49840: LD_VAR 0 1
49844: DIFF
49845: PPUSH
49846: CALL_OW 1
49850: ST_TO_ADDR
// if building in mc_lab [ i ] then
49851: LD_VAR 0 1
49855: PUSH
49856: LD_EXP 126
49860: PUSH
49861: LD_VAR 0 3
49865: ARRAY
49866: IN
49867: IFFALSE 49922
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49869: LD_ADDR_EXP 127
49873: PUSH
49874: LD_EXP 127
49878: PPUSH
49879: LD_VAR 0 3
49883: PPUSH
49884: LD_EXP 127
49888: PUSH
49889: LD_VAR 0 3
49893: ARRAY
49894: PPUSH
49895: LD_INT 1
49897: PPUSH
49898: LD_EXP 127
49902: PUSH
49903: LD_VAR 0 3
49907: ARRAY
49908: PPUSH
49909: LD_INT 0
49911: PPUSH
49912: CALL 55745 0 4
49916: PPUSH
49917: CALL_OW 1
49921: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49922: LD_VAR 0 1
49926: PUSH
49927: LD_EXP 93
49931: PUSH
49932: LD_VAR 0 3
49936: ARRAY
49937: IN
49938: NOT
49939: IFFALSE 49985
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49941: LD_ADDR_EXP 93
49945: PUSH
49946: LD_EXP 93
49950: PPUSH
49951: LD_VAR 0 3
49955: PUSH
49956: LD_EXP 93
49960: PUSH
49961: LD_VAR 0 3
49965: ARRAY
49966: PUSH
49967: LD_INT 1
49969: PLUS
49970: PUSH
49971: EMPTY
49972: LIST
49973: LIST
49974: PPUSH
49975: LD_VAR 0 1
49979: PPUSH
49980: CALL 56327 0 3
49984: ST_TO_ADDR
// exit ;
49985: POP
49986: POP
49987: GO 49993
// end ; end ;
49989: GO 49793
49991: POP
49992: POP
// end ;
49993: LD_VAR 0 2
49997: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49998: LD_INT 0
50000: PPUSH
50001: PPUSH
50002: PPUSH
50003: PPUSH
50004: PPUSH
50005: PPUSH
50006: PPUSH
// if not mc_bases or not skirmish then
50007: LD_EXP 93
50011: NOT
50012: PUSH
50013: LD_EXP 91
50017: NOT
50018: OR
50019: IFFALSE 50023
// exit ;
50021: GO 50684
// for i = 1 to mc_bases do
50023: LD_ADDR_VAR 0 3
50027: PUSH
50028: DOUBLE
50029: LD_INT 1
50031: DEC
50032: ST_TO_ADDR
50033: LD_EXP 93
50037: PUSH
50038: FOR_TO
50039: IFFALSE 50682
// begin if building in mc_construct_list [ i ] then
50041: LD_VAR 0 1
50045: PUSH
50046: LD_EXP 100
50050: PUSH
50051: LD_VAR 0 3
50055: ARRAY
50056: IN
50057: IFFALSE 50680
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50059: LD_ADDR_EXP 100
50063: PUSH
50064: LD_EXP 100
50068: PPUSH
50069: LD_VAR 0 3
50073: PPUSH
50074: LD_EXP 100
50078: PUSH
50079: LD_VAR 0 3
50083: ARRAY
50084: PUSH
50085: LD_VAR 0 1
50089: DIFF
50090: PPUSH
50091: CALL_OW 1
50095: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50096: LD_ADDR_EXP 93
50100: PUSH
50101: LD_EXP 93
50105: PPUSH
50106: LD_VAR 0 3
50110: PUSH
50111: LD_EXP 93
50115: PUSH
50116: LD_VAR 0 3
50120: ARRAY
50121: PUSH
50122: LD_INT 1
50124: PLUS
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: PPUSH
50130: LD_VAR 0 1
50134: PPUSH
50135: CALL 56327 0 3
50139: ST_TO_ADDR
// btype := GetBType ( building ) ;
50140: LD_ADDR_VAR 0 5
50144: PUSH
50145: LD_VAR 0 1
50149: PPUSH
50150: CALL_OW 266
50154: ST_TO_ADDR
// side := GetSide ( building ) ;
50155: LD_ADDR_VAR 0 8
50159: PUSH
50160: LD_VAR 0 1
50164: PPUSH
50165: CALL_OW 255
50169: ST_TO_ADDR
// if btype = b_lab then
50170: LD_VAR 0 5
50174: PUSH
50175: LD_INT 6
50177: EQUAL
50178: IFFALSE 50228
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50180: LD_ADDR_EXP 126
50184: PUSH
50185: LD_EXP 126
50189: PPUSH
50190: LD_VAR 0 3
50194: PUSH
50195: LD_EXP 126
50199: PUSH
50200: LD_VAR 0 3
50204: ARRAY
50205: PUSH
50206: LD_INT 1
50208: PLUS
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PPUSH
50214: LD_VAR 0 1
50218: PPUSH
50219: CALL 56327 0 3
50223: ST_TO_ADDR
// exit ;
50224: POP
50225: POP
50226: GO 50684
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50228: LD_VAR 0 5
50232: PUSH
50233: LD_INT 0
50235: PUSH
50236: LD_INT 2
50238: PUSH
50239: LD_INT 4
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: LIST
50246: IN
50247: IFFALSE 50371
// begin if btype = b_armoury then
50249: LD_VAR 0 5
50253: PUSH
50254: LD_INT 4
50256: EQUAL
50257: IFFALSE 50267
// btype := b_barracks ;
50259: LD_ADDR_VAR 0 5
50263: PUSH
50264: LD_INT 5
50266: ST_TO_ADDR
// if btype = b_depot then
50267: LD_VAR 0 5
50271: PUSH
50272: LD_INT 0
50274: EQUAL
50275: IFFALSE 50285
// btype := b_warehouse ;
50277: LD_ADDR_VAR 0 5
50281: PUSH
50282: LD_INT 1
50284: ST_TO_ADDR
// if btype = b_workshop then
50285: LD_VAR 0 5
50289: PUSH
50290: LD_INT 2
50292: EQUAL
50293: IFFALSE 50303
// btype := b_factory ;
50295: LD_ADDR_VAR 0 5
50299: PUSH
50300: LD_INT 3
50302: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50303: LD_VAR 0 5
50307: PPUSH
50308: LD_VAR 0 8
50312: PPUSH
50313: CALL_OW 323
50317: PUSH
50318: LD_INT 1
50320: EQUAL
50321: IFFALSE 50367
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50323: LD_ADDR_EXP 125
50327: PUSH
50328: LD_EXP 125
50332: PPUSH
50333: LD_VAR 0 3
50337: PUSH
50338: LD_EXP 125
50342: PUSH
50343: LD_VAR 0 3
50347: ARRAY
50348: PUSH
50349: LD_INT 1
50351: PLUS
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: PPUSH
50357: LD_VAR 0 1
50361: PPUSH
50362: CALL 56327 0 3
50366: ST_TO_ADDR
// exit ;
50367: POP
50368: POP
50369: GO 50684
// end ; if btype in [ b_bunker , b_turret ] then
50371: LD_VAR 0 5
50375: PUSH
50376: LD_INT 32
50378: PUSH
50379: LD_INT 33
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: IN
50386: IFFALSE 50676
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50388: LD_ADDR_EXP 101
50392: PUSH
50393: LD_EXP 101
50397: PPUSH
50398: LD_VAR 0 3
50402: PUSH
50403: LD_EXP 101
50407: PUSH
50408: LD_VAR 0 3
50412: ARRAY
50413: PUSH
50414: LD_INT 1
50416: PLUS
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: PPUSH
50422: LD_VAR 0 1
50426: PPUSH
50427: CALL 56327 0 3
50431: ST_TO_ADDR
// if btype = b_bunker then
50432: LD_VAR 0 5
50436: PUSH
50437: LD_INT 32
50439: EQUAL
50440: IFFALSE 50676
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50442: LD_ADDR_EXP 102
50446: PUSH
50447: LD_EXP 102
50451: PPUSH
50452: LD_VAR 0 3
50456: PUSH
50457: LD_EXP 102
50461: PUSH
50462: LD_VAR 0 3
50466: ARRAY
50467: PUSH
50468: LD_INT 1
50470: PLUS
50471: PUSH
50472: EMPTY
50473: LIST
50474: LIST
50475: PPUSH
50476: LD_VAR 0 1
50480: PPUSH
50481: CALL 56327 0 3
50485: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50486: LD_ADDR_VAR 0 6
50490: PUSH
50491: LD_EXP 93
50495: PUSH
50496: LD_VAR 0 3
50500: ARRAY
50501: PPUSH
50502: LD_INT 25
50504: PUSH
50505: LD_INT 1
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: PUSH
50512: LD_INT 3
50514: PUSH
50515: LD_INT 54
50517: PUSH
50518: EMPTY
50519: LIST
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: EMPTY
50526: LIST
50527: LIST
50528: PPUSH
50529: CALL_OW 72
50533: ST_TO_ADDR
// if tmp then
50534: LD_VAR 0 6
50538: IFFALSE 50544
// exit ;
50540: POP
50541: POP
50542: GO 50684
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50544: LD_ADDR_VAR 0 6
50548: PUSH
50549: LD_EXP 93
50553: PUSH
50554: LD_VAR 0 3
50558: ARRAY
50559: PPUSH
50560: LD_INT 2
50562: PUSH
50563: LD_INT 30
50565: PUSH
50566: LD_INT 4
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: LD_INT 30
50575: PUSH
50576: LD_INT 5
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: LIST
50587: PPUSH
50588: CALL_OW 72
50592: ST_TO_ADDR
// if not tmp then
50593: LD_VAR 0 6
50597: NOT
50598: IFFALSE 50604
// exit ;
50600: POP
50601: POP
50602: GO 50684
// for j in tmp do
50604: LD_ADDR_VAR 0 4
50608: PUSH
50609: LD_VAR 0 6
50613: PUSH
50614: FOR_IN
50615: IFFALSE 50674
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50617: LD_ADDR_VAR 0 7
50621: PUSH
50622: LD_VAR 0 4
50626: PPUSH
50627: CALL_OW 313
50631: PPUSH
50632: LD_INT 25
50634: PUSH
50635: LD_INT 1
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PPUSH
50642: CALL_OW 72
50646: ST_TO_ADDR
// if units then
50647: LD_VAR 0 7
50651: IFFALSE 50672
// begin ComExitBuilding ( units [ 1 ] ) ;
50653: LD_VAR 0 7
50657: PUSH
50658: LD_INT 1
50660: ARRAY
50661: PPUSH
50662: CALL_OW 122
// exit ;
50666: POP
50667: POP
50668: POP
50669: POP
50670: GO 50684
// end ; end ;
50672: GO 50614
50674: POP
50675: POP
// end ; end ; exit ;
50676: POP
50677: POP
50678: GO 50684
// end ; end ;
50680: GO 50038
50682: POP
50683: POP
// end ;
50684: LD_VAR 0 2
50688: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50689: LD_INT 0
50691: PPUSH
50692: PPUSH
50693: PPUSH
50694: PPUSH
50695: PPUSH
50696: PPUSH
50697: PPUSH
// if not mc_bases or not skirmish then
50698: LD_EXP 93
50702: NOT
50703: PUSH
50704: LD_EXP 91
50708: NOT
50709: OR
50710: IFFALSE 50714
// exit ;
50712: GO 50979
// btype := GetBType ( building ) ;
50714: LD_ADDR_VAR 0 6
50718: PUSH
50719: LD_VAR 0 1
50723: PPUSH
50724: CALL_OW 266
50728: ST_TO_ADDR
// x := GetX ( building ) ;
50729: LD_ADDR_VAR 0 7
50733: PUSH
50734: LD_VAR 0 1
50738: PPUSH
50739: CALL_OW 250
50743: ST_TO_ADDR
// y := GetY ( building ) ;
50744: LD_ADDR_VAR 0 8
50748: PUSH
50749: LD_VAR 0 1
50753: PPUSH
50754: CALL_OW 251
50758: ST_TO_ADDR
// d := GetDir ( building ) ;
50759: LD_ADDR_VAR 0 9
50763: PUSH
50764: LD_VAR 0 1
50768: PPUSH
50769: CALL_OW 254
50773: ST_TO_ADDR
// for i = 1 to mc_bases do
50774: LD_ADDR_VAR 0 4
50778: PUSH
50779: DOUBLE
50780: LD_INT 1
50782: DEC
50783: ST_TO_ADDR
50784: LD_EXP 93
50788: PUSH
50789: FOR_TO
50790: IFFALSE 50977
// begin if not mc_build_list [ i ] then
50792: LD_EXP 98
50796: PUSH
50797: LD_VAR 0 4
50801: ARRAY
50802: NOT
50803: IFFALSE 50807
// continue ;
50805: GO 50789
// for j := 1 to mc_build_list [ i ] do
50807: LD_ADDR_VAR 0 5
50811: PUSH
50812: DOUBLE
50813: LD_INT 1
50815: DEC
50816: ST_TO_ADDR
50817: LD_EXP 98
50821: PUSH
50822: LD_VAR 0 4
50826: ARRAY
50827: PUSH
50828: FOR_TO
50829: IFFALSE 50973
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50831: LD_VAR 0 6
50835: PUSH
50836: LD_VAR 0 7
50840: PUSH
50841: LD_VAR 0 8
50845: PUSH
50846: LD_VAR 0 9
50850: PUSH
50851: EMPTY
50852: LIST
50853: LIST
50854: LIST
50855: LIST
50856: PPUSH
50857: LD_EXP 98
50861: PUSH
50862: LD_VAR 0 4
50866: ARRAY
50867: PUSH
50868: LD_VAR 0 5
50872: ARRAY
50873: PPUSH
50874: CALL 62509 0 2
50878: IFFALSE 50971
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
50880: LD_ADDR_EXP 98
50884: PUSH
50885: LD_EXP 98
50889: PPUSH
50890: LD_VAR 0 4
50894: PPUSH
50895: LD_EXP 98
50899: PUSH
50900: LD_VAR 0 4
50904: ARRAY
50905: PPUSH
50906: LD_VAR 0 5
50910: PPUSH
50911: CALL_OW 3
50915: PPUSH
50916: CALL_OW 1
50920: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50921: LD_ADDR_EXP 100
50925: PUSH
50926: LD_EXP 100
50930: PPUSH
50931: LD_VAR 0 4
50935: PUSH
50936: LD_EXP 100
50940: PUSH
50941: LD_VAR 0 4
50945: ARRAY
50946: PUSH
50947: LD_INT 1
50949: PLUS
50950: PUSH
50951: EMPTY
50952: LIST
50953: LIST
50954: PPUSH
50955: LD_VAR 0 1
50959: PPUSH
50960: CALL 56327 0 3
50964: ST_TO_ADDR
// exit ;
50965: POP
50966: POP
50967: POP
50968: POP
50969: GO 50979
// end ;
50971: GO 50828
50973: POP
50974: POP
// end ;
50975: GO 50789
50977: POP
50978: POP
// end ;
50979: LD_VAR 0 3
50983: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50984: LD_INT 0
50986: PPUSH
50987: PPUSH
50988: PPUSH
// if not mc_bases or not skirmish then
50989: LD_EXP 93
50993: NOT
50994: PUSH
50995: LD_EXP 91
50999: NOT
51000: OR
51001: IFFALSE 51005
// exit ;
51003: GO 51195
// for i = 1 to mc_bases do
51005: LD_ADDR_VAR 0 4
51009: PUSH
51010: DOUBLE
51011: LD_INT 1
51013: DEC
51014: ST_TO_ADDR
51015: LD_EXP 93
51019: PUSH
51020: FOR_TO
51021: IFFALSE 51108
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51023: LD_VAR 0 1
51027: PUSH
51028: LD_EXP 101
51032: PUSH
51033: LD_VAR 0 4
51037: ARRAY
51038: IN
51039: PUSH
51040: LD_VAR 0 1
51044: PUSH
51045: LD_EXP 102
51049: PUSH
51050: LD_VAR 0 4
51054: ARRAY
51055: IN
51056: NOT
51057: AND
51058: IFFALSE 51106
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51060: LD_ADDR_EXP 102
51064: PUSH
51065: LD_EXP 102
51069: PPUSH
51070: LD_VAR 0 4
51074: PUSH
51075: LD_EXP 102
51079: PUSH
51080: LD_VAR 0 4
51084: ARRAY
51085: PUSH
51086: LD_INT 1
51088: PLUS
51089: PUSH
51090: EMPTY
51091: LIST
51092: LIST
51093: PPUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL 56327 0 3
51103: ST_TO_ADDR
// break ;
51104: GO 51108
// end ; end ;
51106: GO 51020
51108: POP
51109: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51110: LD_VAR 0 1
51114: PPUSH
51115: CALL_OW 257
51119: PUSH
51120: LD_EXP 119
51124: IN
51125: PUSH
51126: LD_VAR 0 1
51130: PPUSH
51131: CALL_OW 266
51135: PUSH
51136: LD_INT 5
51138: EQUAL
51139: AND
51140: PUSH
51141: LD_VAR 0 2
51145: PPUSH
51146: CALL_OW 110
51150: PUSH
51151: LD_INT 18
51153: NONEQUAL
51154: AND
51155: IFFALSE 51195
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51157: LD_VAR 0 2
51161: PPUSH
51162: CALL_OW 257
51166: PUSH
51167: LD_INT 5
51169: PUSH
51170: LD_INT 8
51172: PUSH
51173: LD_INT 9
51175: PUSH
51176: EMPTY
51177: LIST
51178: LIST
51179: LIST
51180: IN
51181: IFFALSE 51195
// SetClass ( unit , 1 ) ;
51183: LD_VAR 0 2
51187: PPUSH
51188: LD_INT 1
51190: PPUSH
51191: CALL_OW 336
// end ;
51195: LD_VAR 0 3
51199: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51200: LD_INT 0
51202: PPUSH
51203: PPUSH
// if not mc_bases or not skirmish then
51204: LD_EXP 93
51208: NOT
51209: PUSH
51210: LD_EXP 91
51214: NOT
51215: OR
51216: IFFALSE 51220
// exit ;
51218: GO 51336
// if GetLives ( abandoned_vehicle ) > 250 then
51220: LD_VAR 0 2
51224: PPUSH
51225: CALL_OW 256
51229: PUSH
51230: LD_INT 250
51232: GREATER
51233: IFFALSE 51237
// exit ;
51235: GO 51336
// for i = 1 to mc_bases do
51237: LD_ADDR_VAR 0 6
51241: PUSH
51242: DOUBLE
51243: LD_INT 1
51245: DEC
51246: ST_TO_ADDR
51247: LD_EXP 93
51251: PUSH
51252: FOR_TO
51253: IFFALSE 51334
// begin if driver in mc_bases [ i ] then
51255: LD_VAR 0 1
51259: PUSH
51260: LD_EXP 93
51264: PUSH
51265: LD_VAR 0 6
51269: ARRAY
51270: IN
51271: IFFALSE 51332
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51273: LD_VAR 0 1
51277: PPUSH
51278: LD_EXP 93
51282: PUSH
51283: LD_VAR 0 6
51287: ARRAY
51288: PPUSH
51289: LD_INT 2
51291: PUSH
51292: LD_INT 30
51294: PUSH
51295: LD_INT 0
51297: PUSH
51298: EMPTY
51299: LIST
51300: LIST
51301: PUSH
51302: LD_INT 30
51304: PUSH
51305: LD_INT 1
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: PUSH
51312: EMPTY
51313: LIST
51314: LIST
51315: LIST
51316: PPUSH
51317: CALL_OW 72
51321: PUSH
51322: LD_INT 1
51324: ARRAY
51325: PPUSH
51326: CALL 88945 0 2
// break ;
51330: GO 51334
// end ; end ;
51332: GO 51252
51334: POP
51335: POP
// end ; end_of_file
51336: LD_VAR 0 5
51340: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51341: LD_INT 0
51343: PPUSH
51344: PPUSH
// if exist_mode then
51345: LD_VAR 0 2
51349: IFFALSE 51374
// unit := CreateCharacter ( prefix & ident ) else
51351: LD_ADDR_VAR 0 5
51355: PUSH
51356: LD_VAR 0 3
51360: PUSH
51361: LD_VAR 0 1
51365: STR
51366: PPUSH
51367: CALL_OW 34
51371: ST_TO_ADDR
51372: GO 51389
// unit := NewCharacter ( ident ) ;
51374: LD_ADDR_VAR 0 5
51378: PUSH
51379: LD_VAR 0 1
51383: PPUSH
51384: CALL_OW 25
51388: ST_TO_ADDR
// result := unit ;
51389: LD_ADDR_VAR 0 4
51393: PUSH
51394: LD_VAR 0 5
51398: ST_TO_ADDR
// end ;
51399: LD_VAR 0 4
51403: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51404: LD_INT 0
51406: PPUSH
51407: PPUSH
// if not side or not nation then
51408: LD_VAR 0 1
51412: NOT
51413: PUSH
51414: LD_VAR 0 2
51418: NOT
51419: OR
51420: IFFALSE 51424
// exit ;
51422: GO 52192
// case nation of nation_american :
51424: LD_VAR 0 2
51428: PUSH
51429: LD_INT 1
51431: DOUBLE
51432: EQUAL
51433: IFTRUE 51437
51435: GO 51651
51437: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51438: LD_ADDR_VAR 0 4
51442: PUSH
51443: LD_INT 35
51445: PUSH
51446: LD_INT 45
51448: PUSH
51449: LD_INT 46
51451: PUSH
51452: LD_INT 47
51454: PUSH
51455: LD_INT 82
51457: PUSH
51458: LD_INT 83
51460: PUSH
51461: LD_INT 84
51463: PUSH
51464: LD_INT 85
51466: PUSH
51467: LD_INT 86
51469: PUSH
51470: LD_INT 1
51472: PUSH
51473: LD_INT 2
51475: PUSH
51476: LD_INT 6
51478: PUSH
51479: LD_INT 15
51481: PUSH
51482: LD_INT 16
51484: PUSH
51485: LD_INT 7
51487: PUSH
51488: LD_INT 12
51490: PUSH
51491: LD_INT 13
51493: PUSH
51494: LD_INT 10
51496: PUSH
51497: LD_INT 14
51499: PUSH
51500: LD_INT 20
51502: PUSH
51503: LD_INT 21
51505: PUSH
51506: LD_INT 22
51508: PUSH
51509: LD_INT 25
51511: PUSH
51512: LD_INT 32
51514: PUSH
51515: LD_INT 27
51517: PUSH
51518: LD_INT 36
51520: PUSH
51521: LD_INT 69
51523: PUSH
51524: LD_INT 39
51526: PUSH
51527: LD_INT 34
51529: PUSH
51530: LD_INT 40
51532: PUSH
51533: LD_INT 48
51535: PUSH
51536: LD_INT 49
51538: PUSH
51539: LD_INT 50
51541: PUSH
51542: LD_INT 51
51544: PUSH
51545: LD_INT 52
51547: PUSH
51548: LD_INT 53
51550: PUSH
51551: LD_INT 54
51553: PUSH
51554: LD_INT 55
51556: PUSH
51557: LD_INT 56
51559: PUSH
51560: LD_INT 57
51562: PUSH
51563: LD_INT 58
51565: PUSH
51566: LD_INT 59
51568: PUSH
51569: LD_INT 60
51571: PUSH
51572: LD_INT 61
51574: PUSH
51575: LD_INT 62
51577: PUSH
51578: LD_INT 80
51580: PUSH
51581: LD_INT 82
51583: PUSH
51584: LD_INT 83
51586: PUSH
51587: LD_INT 84
51589: PUSH
51590: LD_INT 85
51592: PUSH
51593: LD_INT 86
51595: PUSH
51596: EMPTY
51597: LIST
51598: LIST
51599: LIST
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: ST_TO_ADDR
51649: GO 52116
51651: LD_INT 2
51653: DOUBLE
51654: EQUAL
51655: IFTRUE 51659
51657: GO 51885
51659: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51660: LD_ADDR_VAR 0 4
51664: PUSH
51665: LD_INT 35
51667: PUSH
51668: LD_INT 45
51670: PUSH
51671: LD_INT 46
51673: PUSH
51674: LD_INT 47
51676: PUSH
51677: LD_INT 82
51679: PUSH
51680: LD_INT 83
51682: PUSH
51683: LD_INT 84
51685: PUSH
51686: LD_INT 85
51688: PUSH
51689: LD_INT 87
51691: PUSH
51692: LD_INT 70
51694: PUSH
51695: LD_INT 1
51697: PUSH
51698: LD_INT 11
51700: PUSH
51701: LD_INT 3
51703: PUSH
51704: LD_INT 4
51706: PUSH
51707: LD_INT 5
51709: PUSH
51710: LD_INT 6
51712: PUSH
51713: LD_INT 15
51715: PUSH
51716: LD_INT 18
51718: PUSH
51719: LD_INT 7
51721: PUSH
51722: LD_INT 17
51724: PUSH
51725: LD_INT 8
51727: PUSH
51728: LD_INT 20
51730: PUSH
51731: LD_INT 21
51733: PUSH
51734: LD_INT 22
51736: PUSH
51737: LD_INT 72
51739: PUSH
51740: LD_INT 26
51742: PUSH
51743: LD_INT 69
51745: PUSH
51746: LD_INT 39
51748: PUSH
51749: LD_INT 40
51751: PUSH
51752: LD_INT 41
51754: PUSH
51755: LD_INT 42
51757: PUSH
51758: LD_INT 43
51760: PUSH
51761: LD_INT 48
51763: PUSH
51764: LD_INT 49
51766: PUSH
51767: LD_INT 50
51769: PUSH
51770: LD_INT 51
51772: PUSH
51773: LD_INT 52
51775: PUSH
51776: LD_INT 53
51778: PUSH
51779: LD_INT 54
51781: PUSH
51782: LD_INT 55
51784: PUSH
51785: LD_INT 56
51787: PUSH
51788: LD_INT 60
51790: PUSH
51791: LD_INT 61
51793: PUSH
51794: LD_INT 62
51796: PUSH
51797: LD_INT 66
51799: PUSH
51800: LD_INT 67
51802: PUSH
51803: LD_INT 68
51805: PUSH
51806: LD_INT 81
51808: PUSH
51809: LD_INT 82
51811: PUSH
51812: LD_INT 83
51814: PUSH
51815: LD_INT 84
51817: PUSH
51818: LD_INT 85
51820: PUSH
51821: LD_INT 87
51823: PUSH
51824: LD_INT 88
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: LIST
51831: LIST
51832: LIST
51833: LIST
51834: LIST
51835: LIST
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: LIST
51850: LIST
51851: LIST
51852: LIST
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: LIST
51860: LIST
51861: LIST
51862: LIST
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: LIST
51873: LIST
51874: LIST
51875: LIST
51876: LIST
51877: LIST
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: ST_TO_ADDR
51883: GO 52116
51885: LD_INT 3
51887: DOUBLE
51888: EQUAL
51889: IFTRUE 51893
51891: GO 52115
51893: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51894: LD_ADDR_VAR 0 4
51898: PUSH
51899: LD_INT 46
51901: PUSH
51902: LD_INT 47
51904: PUSH
51905: LD_INT 1
51907: PUSH
51908: LD_INT 2
51910: PUSH
51911: LD_INT 82
51913: PUSH
51914: LD_INT 83
51916: PUSH
51917: LD_INT 84
51919: PUSH
51920: LD_INT 85
51922: PUSH
51923: LD_INT 86
51925: PUSH
51926: LD_INT 11
51928: PUSH
51929: LD_INT 9
51931: PUSH
51932: LD_INT 20
51934: PUSH
51935: LD_INT 19
51937: PUSH
51938: LD_INT 21
51940: PUSH
51941: LD_INT 24
51943: PUSH
51944: LD_INT 22
51946: PUSH
51947: LD_INT 25
51949: PUSH
51950: LD_INT 28
51952: PUSH
51953: LD_INT 29
51955: PUSH
51956: LD_INT 30
51958: PUSH
51959: LD_INT 31
51961: PUSH
51962: LD_INT 37
51964: PUSH
51965: LD_INT 38
51967: PUSH
51968: LD_INT 32
51970: PUSH
51971: LD_INT 27
51973: PUSH
51974: LD_INT 33
51976: PUSH
51977: LD_INT 69
51979: PUSH
51980: LD_INT 39
51982: PUSH
51983: LD_INT 34
51985: PUSH
51986: LD_INT 40
51988: PUSH
51989: LD_INT 71
51991: PUSH
51992: LD_INT 23
51994: PUSH
51995: LD_INT 44
51997: PUSH
51998: LD_INT 48
52000: PUSH
52001: LD_INT 49
52003: PUSH
52004: LD_INT 50
52006: PUSH
52007: LD_INT 51
52009: PUSH
52010: LD_INT 52
52012: PUSH
52013: LD_INT 53
52015: PUSH
52016: LD_INT 54
52018: PUSH
52019: LD_INT 55
52021: PUSH
52022: LD_INT 56
52024: PUSH
52025: LD_INT 57
52027: PUSH
52028: LD_INT 58
52030: PUSH
52031: LD_INT 59
52033: PUSH
52034: LD_INT 63
52036: PUSH
52037: LD_INT 64
52039: PUSH
52040: LD_INT 65
52042: PUSH
52043: LD_INT 82
52045: PUSH
52046: LD_INT 83
52048: PUSH
52049: LD_INT 84
52051: PUSH
52052: LD_INT 85
52054: PUSH
52055: LD_INT 86
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: LIST
52066: LIST
52067: LIST
52068: LIST
52069: LIST
52070: LIST
52071: LIST
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: LIST
52077: LIST
52078: LIST
52079: LIST
52080: LIST
52081: LIST
52082: LIST
52083: LIST
52084: LIST
52085: LIST
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: LIST
52091: LIST
52092: LIST
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: LIST
52098: LIST
52099: LIST
52100: LIST
52101: LIST
52102: LIST
52103: LIST
52104: LIST
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: LIST
52111: LIST
52112: ST_TO_ADDR
52113: GO 52116
52115: POP
// if state > - 1 and state < 3 then
52116: LD_VAR 0 3
52120: PUSH
52121: LD_INT 1
52123: NEG
52124: GREATER
52125: PUSH
52126: LD_VAR 0 3
52130: PUSH
52131: LD_INT 3
52133: LESS
52134: AND
52135: IFFALSE 52192
// for i in result do
52137: LD_ADDR_VAR 0 5
52141: PUSH
52142: LD_VAR 0 4
52146: PUSH
52147: FOR_IN
52148: IFFALSE 52190
// if GetTech ( i , side ) <> state then
52150: LD_VAR 0 5
52154: PPUSH
52155: LD_VAR 0 1
52159: PPUSH
52160: CALL_OW 321
52164: PUSH
52165: LD_VAR 0 3
52169: NONEQUAL
52170: IFFALSE 52188
// result := result diff i ;
52172: LD_ADDR_VAR 0 4
52176: PUSH
52177: LD_VAR 0 4
52181: PUSH
52182: LD_VAR 0 5
52186: DIFF
52187: ST_TO_ADDR
52188: GO 52147
52190: POP
52191: POP
// end ;
52192: LD_VAR 0 4
52196: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52197: LD_INT 0
52199: PPUSH
52200: PPUSH
52201: PPUSH
// result := true ;
52202: LD_ADDR_VAR 0 3
52206: PUSH
52207: LD_INT 1
52209: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52210: LD_ADDR_VAR 0 5
52214: PUSH
52215: LD_VAR 0 2
52219: PPUSH
52220: CALL_OW 480
52224: ST_TO_ADDR
// if not tmp then
52225: LD_VAR 0 5
52229: NOT
52230: IFFALSE 52234
// exit ;
52232: GO 52283
// for i in tmp do
52234: LD_ADDR_VAR 0 4
52238: PUSH
52239: LD_VAR 0 5
52243: PUSH
52244: FOR_IN
52245: IFFALSE 52281
// if GetTech ( i , side ) <> state_researched then
52247: LD_VAR 0 4
52251: PPUSH
52252: LD_VAR 0 1
52256: PPUSH
52257: CALL_OW 321
52261: PUSH
52262: LD_INT 2
52264: NONEQUAL
52265: IFFALSE 52279
// begin result := false ;
52267: LD_ADDR_VAR 0 3
52271: PUSH
52272: LD_INT 0
52274: ST_TO_ADDR
// exit ;
52275: POP
52276: POP
52277: GO 52283
// end ;
52279: GO 52244
52281: POP
52282: POP
// end ;
52283: LD_VAR 0 3
52287: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52288: LD_INT 0
52290: PPUSH
52291: PPUSH
52292: PPUSH
52293: PPUSH
52294: PPUSH
52295: PPUSH
52296: PPUSH
52297: PPUSH
52298: PPUSH
52299: PPUSH
52300: PPUSH
52301: PPUSH
52302: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52303: LD_VAR 0 1
52307: NOT
52308: PUSH
52309: LD_VAR 0 1
52313: PPUSH
52314: CALL_OW 257
52318: PUSH
52319: LD_INT 9
52321: NONEQUAL
52322: OR
52323: IFFALSE 52327
// exit ;
52325: GO 52900
// side := GetSide ( unit ) ;
52327: LD_ADDR_VAR 0 9
52331: PUSH
52332: LD_VAR 0 1
52336: PPUSH
52337: CALL_OW 255
52341: ST_TO_ADDR
// tech_space := tech_spacanom ;
52342: LD_ADDR_VAR 0 12
52346: PUSH
52347: LD_INT 29
52349: ST_TO_ADDR
// tech_time := tech_taurad ;
52350: LD_ADDR_VAR 0 13
52354: PUSH
52355: LD_INT 28
52357: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52358: LD_ADDR_VAR 0 11
52362: PUSH
52363: LD_VAR 0 1
52367: PPUSH
52368: CALL_OW 310
52372: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52373: LD_VAR 0 11
52377: PPUSH
52378: CALL_OW 247
52382: PUSH
52383: LD_INT 2
52385: EQUAL
52386: IFFALSE 52390
// exit ;
52388: GO 52900
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52390: LD_ADDR_VAR 0 8
52394: PUSH
52395: LD_INT 81
52397: PUSH
52398: LD_VAR 0 9
52402: PUSH
52403: EMPTY
52404: LIST
52405: LIST
52406: PUSH
52407: LD_INT 3
52409: PUSH
52410: LD_INT 21
52412: PUSH
52413: LD_INT 3
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: PUSH
52424: EMPTY
52425: LIST
52426: LIST
52427: PPUSH
52428: CALL_OW 69
52432: ST_TO_ADDR
// if not tmp then
52433: LD_VAR 0 8
52437: NOT
52438: IFFALSE 52442
// exit ;
52440: GO 52900
// if in_unit then
52442: LD_VAR 0 11
52446: IFFALSE 52470
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52448: LD_ADDR_VAR 0 10
52452: PUSH
52453: LD_VAR 0 8
52457: PPUSH
52458: LD_VAR 0 11
52462: PPUSH
52463: CALL_OW 74
52467: ST_TO_ADDR
52468: GO 52490
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52470: LD_ADDR_VAR 0 10
52474: PUSH
52475: LD_VAR 0 8
52479: PPUSH
52480: LD_VAR 0 1
52484: PPUSH
52485: CALL_OW 74
52489: ST_TO_ADDR
// if not enemy then
52490: LD_VAR 0 10
52494: NOT
52495: IFFALSE 52499
// exit ;
52497: GO 52900
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52499: LD_VAR 0 11
52503: PUSH
52504: LD_VAR 0 11
52508: PPUSH
52509: LD_VAR 0 10
52513: PPUSH
52514: CALL_OW 296
52518: PUSH
52519: LD_INT 13
52521: GREATER
52522: AND
52523: PUSH
52524: LD_VAR 0 1
52528: PPUSH
52529: LD_VAR 0 10
52533: PPUSH
52534: CALL_OW 296
52538: PUSH
52539: LD_INT 12
52541: GREATER
52542: OR
52543: IFFALSE 52547
// exit ;
52545: GO 52900
// missile := [ 1 ] ;
52547: LD_ADDR_VAR 0 14
52551: PUSH
52552: LD_INT 1
52554: PUSH
52555: EMPTY
52556: LIST
52557: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52558: LD_VAR 0 9
52562: PPUSH
52563: LD_VAR 0 12
52567: PPUSH
52568: CALL_OW 325
52572: IFFALSE 52601
// missile := Insert ( missile , missile + 1 , 2 ) ;
52574: LD_ADDR_VAR 0 14
52578: PUSH
52579: LD_VAR 0 14
52583: PPUSH
52584: LD_VAR 0 14
52588: PUSH
52589: LD_INT 1
52591: PLUS
52592: PPUSH
52593: LD_INT 2
52595: PPUSH
52596: CALL_OW 2
52600: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52601: LD_VAR 0 9
52605: PPUSH
52606: LD_VAR 0 13
52610: PPUSH
52611: CALL_OW 325
52615: PUSH
52616: LD_VAR 0 10
52620: PPUSH
52621: CALL_OW 255
52625: PPUSH
52626: LD_VAR 0 13
52630: PPUSH
52631: CALL_OW 325
52635: NOT
52636: AND
52637: IFFALSE 52666
// missile := Insert ( missile , missile + 1 , 3 ) ;
52639: LD_ADDR_VAR 0 14
52643: PUSH
52644: LD_VAR 0 14
52648: PPUSH
52649: LD_VAR 0 14
52653: PUSH
52654: LD_INT 1
52656: PLUS
52657: PPUSH
52658: LD_INT 3
52660: PPUSH
52661: CALL_OW 2
52665: ST_TO_ADDR
// if missile < 2 then
52666: LD_VAR 0 14
52670: PUSH
52671: LD_INT 2
52673: LESS
52674: IFFALSE 52678
// exit ;
52676: GO 52900
// x := GetX ( enemy ) ;
52678: LD_ADDR_VAR 0 4
52682: PUSH
52683: LD_VAR 0 10
52687: PPUSH
52688: CALL_OW 250
52692: ST_TO_ADDR
// y := GetY ( enemy ) ;
52693: LD_ADDR_VAR 0 5
52697: PUSH
52698: LD_VAR 0 10
52702: PPUSH
52703: CALL_OW 251
52707: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52708: LD_ADDR_VAR 0 6
52712: PUSH
52713: LD_VAR 0 4
52717: PUSH
52718: LD_INT 1
52720: NEG
52721: PPUSH
52722: LD_INT 1
52724: PPUSH
52725: CALL_OW 12
52729: PLUS
52730: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52731: LD_ADDR_VAR 0 7
52735: PUSH
52736: LD_VAR 0 5
52740: PUSH
52741: LD_INT 1
52743: NEG
52744: PPUSH
52745: LD_INT 1
52747: PPUSH
52748: CALL_OW 12
52752: PLUS
52753: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52754: LD_VAR 0 6
52758: PPUSH
52759: LD_VAR 0 7
52763: PPUSH
52764: CALL_OW 488
52768: NOT
52769: IFFALSE 52791
// begin _x := x ;
52771: LD_ADDR_VAR 0 6
52775: PUSH
52776: LD_VAR 0 4
52780: ST_TO_ADDR
// _y := y ;
52781: LD_ADDR_VAR 0 7
52785: PUSH
52786: LD_VAR 0 5
52790: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52791: LD_ADDR_VAR 0 3
52795: PUSH
52796: LD_INT 1
52798: PPUSH
52799: LD_VAR 0 14
52803: PPUSH
52804: CALL_OW 12
52808: ST_TO_ADDR
// case i of 1 :
52809: LD_VAR 0 3
52813: PUSH
52814: LD_INT 1
52816: DOUBLE
52817: EQUAL
52818: IFTRUE 52822
52820: GO 52839
52822: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52823: LD_VAR 0 1
52827: PPUSH
52828: LD_VAR 0 10
52832: PPUSH
52833: CALL_OW 115
52837: GO 52900
52839: LD_INT 2
52841: DOUBLE
52842: EQUAL
52843: IFTRUE 52847
52845: GO 52869
52847: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52848: LD_VAR 0 1
52852: PPUSH
52853: LD_VAR 0 6
52857: PPUSH
52858: LD_VAR 0 7
52862: PPUSH
52863: CALL_OW 153
52867: GO 52900
52869: LD_INT 3
52871: DOUBLE
52872: EQUAL
52873: IFTRUE 52877
52875: GO 52899
52877: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52878: LD_VAR 0 1
52882: PPUSH
52883: LD_VAR 0 6
52887: PPUSH
52888: LD_VAR 0 7
52892: PPUSH
52893: CALL_OW 154
52897: GO 52900
52899: POP
// end ;
52900: LD_VAR 0 2
52904: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52905: LD_INT 0
52907: PPUSH
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
52912: PPUSH
// if not unit or not building then
52913: LD_VAR 0 1
52917: NOT
52918: PUSH
52919: LD_VAR 0 2
52923: NOT
52924: OR
52925: IFFALSE 52929
// exit ;
52927: GO 53087
// x := GetX ( building ) ;
52929: LD_ADDR_VAR 0 5
52933: PUSH
52934: LD_VAR 0 2
52938: PPUSH
52939: CALL_OW 250
52943: ST_TO_ADDR
// y := GetY ( building ) ;
52944: LD_ADDR_VAR 0 6
52948: PUSH
52949: LD_VAR 0 2
52953: PPUSH
52954: CALL_OW 251
52958: ST_TO_ADDR
// for i = 0 to 5 do
52959: LD_ADDR_VAR 0 4
52963: PUSH
52964: DOUBLE
52965: LD_INT 0
52967: DEC
52968: ST_TO_ADDR
52969: LD_INT 5
52971: PUSH
52972: FOR_TO
52973: IFFALSE 53085
// begin _x := ShiftX ( x , i , 3 ) ;
52975: LD_ADDR_VAR 0 7
52979: PUSH
52980: LD_VAR 0 5
52984: PPUSH
52985: LD_VAR 0 4
52989: PPUSH
52990: LD_INT 3
52992: PPUSH
52993: CALL_OW 272
52997: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52998: LD_ADDR_VAR 0 8
53002: PUSH
53003: LD_VAR 0 6
53007: PPUSH
53008: LD_VAR 0 4
53012: PPUSH
53013: LD_INT 3
53015: PPUSH
53016: CALL_OW 273
53020: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53021: LD_VAR 0 7
53025: PPUSH
53026: LD_VAR 0 8
53030: PPUSH
53031: CALL_OW 488
53035: NOT
53036: IFFALSE 53040
// continue ;
53038: GO 52972
// if HexInfo ( _x , _y ) = 0 then
53040: LD_VAR 0 7
53044: PPUSH
53045: LD_VAR 0 8
53049: PPUSH
53050: CALL_OW 428
53054: PUSH
53055: LD_INT 0
53057: EQUAL
53058: IFFALSE 53083
// begin ComMoveXY ( unit , _x , _y ) ;
53060: LD_VAR 0 1
53064: PPUSH
53065: LD_VAR 0 7
53069: PPUSH
53070: LD_VAR 0 8
53074: PPUSH
53075: CALL_OW 111
// exit ;
53079: POP
53080: POP
53081: GO 53087
// end ; end ;
53083: GO 52972
53085: POP
53086: POP
// end ;
53087: LD_VAR 0 3
53091: RET
// export function ScanBase ( side , base_area ) ; begin
53092: LD_INT 0
53094: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53095: LD_ADDR_VAR 0 3
53099: PUSH
53100: LD_VAR 0 2
53104: PPUSH
53105: LD_INT 81
53107: PUSH
53108: LD_VAR 0 1
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: PPUSH
53117: CALL_OW 70
53121: ST_TO_ADDR
// end ;
53122: LD_VAR 0 3
53126: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53127: LD_INT 0
53129: PPUSH
53130: PPUSH
53131: PPUSH
53132: PPUSH
// result := false ;
53133: LD_ADDR_VAR 0 2
53137: PUSH
53138: LD_INT 0
53140: ST_TO_ADDR
// side := GetSide ( unit ) ;
53141: LD_ADDR_VAR 0 3
53145: PUSH
53146: LD_VAR 0 1
53150: PPUSH
53151: CALL_OW 255
53155: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53156: LD_ADDR_VAR 0 4
53160: PUSH
53161: LD_VAR 0 1
53165: PPUSH
53166: CALL_OW 248
53170: ST_TO_ADDR
// case nat of 1 :
53171: LD_VAR 0 4
53175: PUSH
53176: LD_INT 1
53178: DOUBLE
53179: EQUAL
53180: IFTRUE 53184
53182: GO 53195
53184: POP
// tech := tech_lassight ; 2 :
53185: LD_ADDR_VAR 0 5
53189: PUSH
53190: LD_INT 12
53192: ST_TO_ADDR
53193: GO 53234
53195: LD_INT 2
53197: DOUBLE
53198: EQUAL
53199: IFTRUE 53203
53201: GO 53214
53203: POP
// tech := tech_mortar ; 3 :
53204: LD_ADDR_VAR 0 5
53208: PUSH
53209: LD_INT 41
53211: ST_TO_ADDR
53212: GO 53234
53214: LD_INT 3
53216: DOUBLE
53217: EQUAL
53218: IFTRUE 53222
53220: GO 53233
53222: POP
// tech := tech_bazooka ; end ;
53223: LD_ADDR_VAR 0 5
53227: PUSH
53228: LD_INT 44
53230: ST_TO_ADDR
53231: GO 53234
53233: POP
// if Researched ( side , tech ) then
53234: LD_VAR 0 3
53238: PPUSH
53239: LD_VAR 0 5
53243: PPUSH
53244: CALL_OW 325
53248: IFFALSE 53275
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53250: LD_ADDR_VAR 0 2
53254: PUSH
53255: LD_INT 5
53257: PUSH
53258: LD_INT 8
53260: PUSH
53261: LD_INT 9
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: LIST
53268: PUSH
53269: LD_VAR 0 4
53273: ARRAY
53274: ST_TO_ADDR
// end ;
53275: LD_VAR 0 2
53279: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53280: LD_INT 0
53282: PPUSH
53283: PPUSH
53284: PPUSH
// if not mines then
53285: LD_VAR 0 2
53289: NOT
53290: IFFALSE 53294
// exit ;
53292: GO 53438
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53294: LD_ADDR_VAR 0 5
53298: PUSH
53299: LD_INT 81
53301: PUSH
53302: LD_VAR 0 1
53306: PUSH
53307: EMPTY
53308: LIST
53309: LIST
53310: PUSH
53311: LD_INT 3
53313: PUSH
53314: LD_INT 21
53316: PUSH
53317: LD_INT 3
53319: PUSH
53320: EMPTY
53321: LIST
53322: LIST
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: PPUSH
53332: CALL_OW 69
53336: ST_TO_ADDR
// for i in mines do
53337: LD_ADDR_VAR 0 4
53341: PUSH
53342: LD_VAR 0 2
53346: PUSH
53347: FOR_IN
53348: IFFALSE 53436
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53350: LD_VAR 0 4
53354: PUSH
53355: LD_INT 1
53357: ARRAY
53358: PPUSH
53359: LD_VAR 0 4
53363: PUSH
53364: LD_INT 2
53366: ARRAY
53367: PPUSH
53368: CALL_OW 458
53372: NOT
53373: IFFALSE 53377
// continue ;
53375: GO 53347
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53377: LD_VAR 0 4
53381: PUSH
53382: LD_INT 1
53384: ARRAY
53385: PPUSH
53386: LD_VAR 0 4
53390: PUSH
53391: LD_INT 2
53393: ARRAY
53394: PPUSH
53395: CALL_OW 428
53399: PUSH
53400: LD_VAR 0 5
53404: IN
53405: IFFALSE 53434
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53407: LD_VAR 0 4
53411: PUSH
53412: LD_INT 1
53414: ARRAY
53415: PPUSH
53416: LD_VAR 0 4
53420: PUSH
53421: LD_INT 2
53423: ARRAY
53424: PPUSH
53425: LD_VAR 0 1
53429: PPUSH
53430: CALL_OW 456
// end ;
53434: GO 53347
53436: POP
53437: POP
// end ;
53438: LD_VAR 0 3
53442: RET
// export function Count ( array ) ; var i ; begin
53443: LD_INT 0
53445: PPUSH
53446: PPUSH
// result := 0 ;
53447: LD_ADDR_VAR 0 2
53451: PUSH
53452: LD_INT 0
53454: ST_TO_ADDR
// for i in array do
53455: LD_ADDR_VAR 0 3
53459: PUSH
53460: LD_VAR 0 1
53464: PUSH
53465: FOR_IN
53466: IFFALSE 53490
// if i then
53468: LD_VAR 0 3
53472: IFFALSE 53488
// result := result + 1 ;
53474: LD_ADDR_VAR 0 2
53478: PUSH
53479: LD_VAR 0 2
53483: PUSH
53484: LD_INT 1
53486: PLUS
53487: ST_TO_ADDR
53488: GO 53465
53490: POP
53491: POP
// end ;
53492: LD_VAR 0 2
53496: RET
// export function IsEmpty ( building ) ; begin
53497: LD_INT 0
53499: PPUSH
// if not building then
53500: LD_VAR 0 1
53504: NOT
53505: IFFALSE 53509
// exit ;
53507: GO 53552
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53509: LD_ADDR_VAR 0 2
53513: PUSH
53514: LD_VAR 0 1
53518: PUSH
53519: LD_INT 22
53521: PUSH
53522: LD_VAR 0 1
53526: PPUSH
53527: CALL_OW 255
53531: PUSH
53532: EMPTY
53533: LIST
53534: LIST
53535: PUSH
53536: LD_INT 58
53538: PUSH
53539: EMPTY
53540: LIST
53541: PUSH
53542: EMPTY
53543: LIST
53544: LIST
53545: PPUSH
53546: CALL_OW 69
53550: IN
53551: ST_TO_ADDR
// end ;
53552: LD_VAR 0 2
53556: RET
// export function IsNotFull ( building ) ; begin
53557: LD_INT 0
53559: PPUSH
// if not building then
53560: LD_VAR 0 1
53564: NOT
53565: IFFALSE 53569
// exit ;
53567: GO 53588
// result := UnitsInside ( building ) < 6 ;
53569: LD_ADDR_VAR 0 2
53573: PUSH
53574: LD_VAR 0 1
53578: PPUSH
53579: CALL_OW 313
53583: PUSH
53584: LD_INT 6
53586: LESS
53587: ST_TO_ADDR
// end ;
53588: LD_VAR 0 2
53592: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53593: LD_INT 0
53595: PPUSH
53596: PPUSH
53597: PPUSH
53598: PPUSH
// tmp := [ ] ;
53599: LD_ADDR_VAR 0 3
53603: PUSH
53604: EMPTY
53605: ST_TO_ADDR
// list := [ ] ;
53606: LD_ADDR_VAR 0 5
53610: PUSH
53611: EMPTY
53612: ST_TO_ADDR
// for i = 16 to 25 do
53613: LD_ADDR_VAR 0 4
53617: PUSH
53618: DOUBLE
53619: LD_INT 16
53621: DEC
53622: ST_TO_ADDR
53623: LD_INT 25
53625: PUSH
53626: FOR_TO
53627: IFFALSE 53700
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53629: LD_ADDR_VAR 0 3
53633: PUSH
53634: LD_VAR 0 3
53638: PUSH
53639: LD_INT 22
53641: PUSH
53642: LD_VAR 0 1
53646: PPUSH
53647: CALL_OW 255
53651: PUSH
53652: EMPTY
53653: LIST
53654: LIST
53655: PUSH
53656: LD_INT 91
53658: PUSH
53659: LD_VAR 0 1
53663: PUSH
53664: LD_INT 6
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: LIST
53671: PUSH
53672: LD_INT 30
53674: PUSH
53675: LD_VAR 0 4
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: LIST
53688: PUSH
53689: EMPTY
53690: LIST
53691: PPUSH
53692: CALL_OW 69
53696: ADD
53697: ST_TO_ADDR
53698: GO 53626
53700: POP
53701: POP
// for i = 1 to tmp do
53702: LD_ADDR_VAR 0 4
53706: PUSH
53707: DOUBLE
53708: LD_INT 1
53710: DEC
53711: ST_TO_ADDR
53712: LD_VAR 0 3
53716: PUSH
53717: FOR_TO
53718: IFFALSE 53806
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53720: LD_ADDR_VAR 0 5
53724: PUSH
53725: LD_VAR 0 5
53729: PUSH
53730: LD_VAR 0 3
53734: PUSH
53735: LD_VAR 0 4
53739: ARRAY
53740: PPUSH
53741: CALL_OW 266
53745: PUSH
53746: LD_VAR 0 3
53750: PUSH
53751: LD_VAR 0 4
53755: ARRAY
53756: PPUSH
53757: CALL_OW 250
53761: PUSH
53762: LD_VAR 0 3
53766: PUSH
53767: LD_VAR 0 4
53771: ARRAY
53772: PPUSH
53773: CALL_OW 251
53777: PUSH
53778: LD_VAR 0 3
53782: PUSH
53783: LD_VAR 0 4
53787: ARRAY
53788: PPUSH
53789: CALL_OW 254
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: LIST
53798: LIST
53799: PUSH
53800: EMPTY
53801: LIST
53802: ADD
53803: ST_TO_ADDR
53804: GO 53717
53806: POP
53807: POP
// result := list ;
53808: LD_ADDR_VAR 0 2
53812: PUSH
53813: LD_VAR 0 5
53817: ST_TO_ADDR
// end ;
53818: LD_VAR 0 2
53822: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53823: LD_INT 0
53825: PPUSH
53826: PPUSH
53827: PPUSH
53828: PPUSH
53829: PPUSH
53830: PPUSH
53831: PPUSH
// if not factory then
53832: LD_VAR 0 1
53836: NOT
53837: IFFALSE 53841
// exit ;
53839: GO 54434
// if control = control_apeman then
53841: LD_VAR 0 4
53845: PUSH
53846: LD_INT 5
53848: EQUAL
53849: IFFALSE 53958
// begin tmp := UnitsInside ( factory ) ;
53851: LD_ADDR_VAR 0 8
53855: PUSH
53856: LD_VAR 0 1
53860: PPUSH
53861: CALL_OW 313
53865: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53866: LD_VAR 0 8
53870: PPUSH
53871: LD_INT 25
53873: PUSH
53874: LD_INT 12
53876: PUSH
53877: EMPTY
53878: LIST
53879: LIST
53880: PPUSH
53881: CALL_OW 72
53885: NOT
53886: IFFALSE 53896
// control := control_manual ;
53888: LD_ADDR_VAR 0 4
53892: PUSH
53893: LD_INT 1
53895: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53896: LD_ADDR_VAR 0 8
53900: PUSH
53901: LD_VAR 0 1
53905: PPUSH
53906: CALL 53593 0 1
53910: ST_TO_ADDR
// if tmp then
53911: LD_VAR 0 8
53915: IFFALSE 53958
// begin for i in tmp do
53917: LD_ADDR_VAR 0 7
53921: PUSH
53922: LD_VAR 0 8
53926: PUSH
53927: FOR_IN
53928: IFFALSE 53956
// if i [ 1 ] = b_ext_radio then
53930: LD_VAR 0 7
53934: PUSH
53935: LD_INT 1
53937: ARRAY
53938: PUSH
53939: LD_INT 22
53941: EQUAL
53942: IFFALSE 53954
// begin control := control_remote ;
53944: LD_ADDR_VAR 0 4
53948: PUSH
53949: LD_INT 2
53951: ST_TO_ADDR
// break ;
53952: GO 53956
// end ;
53954: GO 53927
53956: POP
53957: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53958: LD_VAR 0 1
53962: PPUSH
53963: LD_VAR 0 2
53967: PPUSH
53968: LD_VAR 0 3
53972: PPUSH
53973: LD_VAR 0 4
53977: PPUSH
53978: LD_VAR 0 5
53982: PPUSH
53983: CALL_OW 448
53987: IFFALSE 54022
// begin result := [ chassis , engine , control , weapon ] ;
53989: LD_ADDR_VAR 0 6
53993: PUSH
53994: LD_VAR 0 2
53998: PUSH
53999: LD_VAR 0 3
54003: PUSH
54004: LD_VAR 0 4
54008: PUSH
54009: LD_VAR 0 5
54013: PUSH
54014: EMPTY
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: ST_TO_ADDR
// exit ;
54020: GO 54434
// end ; _chassis := AvailableChassisList ( factory ) ;
54022: LD_ADDR_VAR 0 9
54026: PUSH
54027: LD_VAR 0 1
54031: PPUSH
54032: CALL_OW 475
54036: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54037: LD_ADDR_VAR 0 11
54041: PUSH
54042: LD_VAR 0 1
54046: PPUSH
54047: CALL_OW 476
54051: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54052: LD_ADDR_VAR 0 12
54056: PUSH
54057: LD_VAR 0 1
54061: PPUSH
54062: CALL_OW 477
54066: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54067: LD_ADDR_VAR 0 10
54071: PUSH
54072: LD_VAR 0 1
54076: PPUSH
54077: CALL_OW 478
54081: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54082: LD_VAR 0 9
54086: NOT
54087: PUSH
54088: LD_VAR 0 11
54092: NOT
54093: OR
54094: PUSH
54095: LD_VAR 0 12
54099: NOT
54100: OR
54101: PUSH
54102: LD_VAR 0 10
54106: NOT
54107: OR
54108: IFFALSE 54143
// begin result := [ chassis , engine , control , weapon ] ;
54110: LD_ADDR_VAR 0 6
54114: PUSH
54115: LD_VAR 0 2
54119: PUSH
54120: LD_VAR 0 3
54124: PUSH
54125: LD_VAR 0 4
54129: PUSH
54130: LD_VAR 0 5
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: LIST
54139: LIST
54140: ST_TO_ADDR
// exit ;
54141: GO 54434
// end ; if not chassis in _chassis then
54143: LD_VAR 0 2
54147: PUSH
54148: LD_VAR 0 9
54152: IN
54153: NOT
54154: IFFALSE 54180
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54156: LD_ADDR_VAR 0 2
54160: PUSH
54161: LD_VAR 0 9
54165: PUSH
54166: LD_INT 1
54168: PPUSH
54169: LD_VAR 0 9
54173: PPUSH
54174: CALL_OW 12
54178: ARRAY
54179: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54180: LD_VAR 0 2
54184: PPUSH
54185: LD_VAR 0 3
54189: PPUSH
54190: CALL 54439 0 2
54194: NOT
54195: IFFALSE 54254
// repeat engine := _engine [ 1 ] ;
54197: LD_ADDR_VAR 0 3
54201: PUSH
54202: LD_VAR 0 11
54206: PUSH
54207: LD_INT 1
54209: ARRAY
54210: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54211: LD_ADDR_VAR 0 11
54215: PUSH
54216: LD_VAR 0 11
54220: PPUSH
54221: LD_INT 1
54223: PPUSH
54224: CALL_OW 3
54228: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54229: LD_VAR 0 2
54233: PPUSH
54234: LD_VAR 0 3
54238: PPUSH
54239: CALL 54439 0 2
54243: PUSH
54244: LD_VAR 0 11
54248: PUSH
54249: EMPTY
54250: EQUAL
54251: OR
54252: IFFALSE 54197
// if not control in _control then
54254: LD_VAR 0 4
54258: PUSH
54259: LD_VAR 0 12
54263: IN
54264: NOT
54265: IFFALSE 54291
// control := _control [ rand ( 1 , _control ) ] ;
54267: LD_ADDR_VAR 0 4
54271: PUSH
54272: LD_VAR 0 12
54276: PUSH
54277: LD_INT 1
54279: PPUSH
54280: LD_VAR 0 12
54284: PPUSH
54285: CALL_OW 12
54289: ARRAY
54290: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54291: LD_VAR 0 2
54295: PPUSH
54296: LD_VAR 0 5
54300: PPUSH
54301: CALL 54659 0 2
54305: NOT
54306: IFFALSE 54365
// repeat weapon := _weapon [ 1 ] ;
54308: LD_ADDR_VAR 0 5
54312: PUSH
54313: LD_VAR 0 10
54317: PUSH
54318: LD_INT 1
54320: ARRAY
54321: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54322: LD_ADDR_VAR 0 10
54326: PUSH
54327: LD_VAR 0 10
54331: PPUSH
54332: LD_INT 1
54334: PPUSH
54335: CALL_OW 3
54339: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54340: LD_VAR 0 2
54344: PPUSH
54345: LD_VAR 0 5
54349: PPUSH
54350: CALL 54659 0 2
54354: PUSH
54355: LD_VAR 0 10
54359: PUSH
54360: EMPTY
54361: EQUAL
54362: OR
54363: IFFALSE 54308
// result := [ ] ;
54365: LD_ADDR_VAR 0 6
54369: PUSH
54370: EMPTY
54371: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54372: LD_VAR 0 1
54376: PPUSH
54377: LD_VAR 0 2
54381: PPUSH
54382: LD_VAR 0 3
54386: PPUSH
54387: LD_VAR 0 4
54391: PPUSH
54392: LD_VAR 0 5
54396: PPUSH
54397: CALL_OW 448
54401: IFFALSE 54434
// result := [ chassis , engine , control , weapon ] ;
54403: LD_ADDR_VAR 0 6
54407: PUSH
54408: LD_VAR 0 2
54412: PUSH
54413: LD_VAR 0 3
54417: PUSH
54418: LD_VAR 0 4
54422: PUSH
54423: LD_VAR 0 5
54427: PUSH
54428: EMPTY
54429: LIST
54430: LIST
54431: LIST
54432: LIST
54433: ST_TO_ADDR
// end ;
54434: LD_VAR 0 6
54438: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54439: LD_INT 0
54441: PPUSH
// if not chassis or not engine then
54442: LD_VAR 0 1
54446: NOT
54447: PUSH
54448: LD_VAR 0 2
54452: NOT
54453: OR
54454: IFFALSE 54458
// exit ;
54456: GO 54654
// case engine of engine_solar :
54458: LD_VAR 0 2
54462: PUSH
54463: LD_INT 2
54465: DOUBLE
54466: EQUAL
54467: IFTRUE 54471
54469: GO 54509
54471: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54472: LD_ADDR_VAR 0 3
54476: PUSH
54477: LD_INT 11
54479: PUSH
54480: LD_INT 12
54482: PUSH
54483: LD_INT 13
54485: PUSH
54486: LD_INT 14
54488: PUSH
54489: LD_INT 1
54491: PUSH
54492: LD_INT 2
54494: PUSH
54495: LD_INT 3
54497: PUSH
54498: EMPTY
54499: LIST
54500: LIST
54501: LIST
54502: LIST
54503: LIST
54504: LIST
54505: LIST
54506: ST_TO_ADDR
54507: GO 54638
54509: LD_INT 1
54511: DOUBLE
54512: EQUAL
54513: IFTRUE 54517
54515: GO 54579
54517: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54518: LD_ADDR_VAR 0 3
54522: PUSH
54523: LD_INT 11
54525: PUSH
54526: LD_INT 12
54528: PUSH
54529: LD_INT 13
54531: PUSH
54532: LD_INT 14
54534: PUSH
54535: LD_INT 1
54537: PUSH
54538: LD_INT 2
54540: PUSH
54541: LD_INT 3
54543: PUSH
54544: LD_INT 4
54546: PUSH
54547: LD_INT 5
54549: PUSH
54550: LD_INT 21
54552: PUSH
54553: LD_INT 23
54555: PUSH
54556: LD_INT 22
54558: PUSH
54559: LD_INT 24
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: LIST
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: LIST
54571: LIST
54572: LIST
54573: LIST
54574: LIST
54575: LIST
54576: ST_TO_ADDR
54577: GO 54638
54579: LD_INT 3
54581: DOUBLE
54582: EQUAL
54583: IFTRUE 54587
54585: GO 54637
54587: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54588: LD_ADDR_VAR 0 3
54592: PUSH
54593: LD_INT 13
54595: PUSH
54596: LD_INT 14
54598: PUSH
54599: LD_INT 2
54601: PUSH
54602: LD_INT 3
54604: PUSH
54605: LD_INT 4
54607: PUSH
54608: LD_INT 5
54610: PUSH
54611: LD_INT 21
54613: PUSH
54614: LD_INT 22
54616: PUSH
54617: LD_INT 23
54619: PUSH
54620: LD_INT 24
54622: PUSH
54623: EMPTY
54624: LIST
54625: LIST
54626: LIST
54627: LIST
54628: LIST
54629: LIST
54630: LIST
54631: LIST
54632: LIST
54633: LIST
54634: ST_TO_ADDR
54635: GO 54638
54637: POP
// result := ( chassis in result ) ;
54638: LD_ADDR_VAR 0 3
54642: PUSH
54643: LD_VAR 0 1
54647: PUSH
54648: LD_VAR 0 3
54652: IN
54653: ST_TO_ADDR
// end ;
54654: LD_VAR 0 3
54658: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54659: LD_INT 0
54661: PPUSH
// if not chassis or not weapon then
54662: LD_VAR 0 1
54666: NOT
54667: PUSH
54668: LD_VAR 0 2
54672: NOT
54673: OR
54674: IFFALSE 54678
// exit ;
54676: GO 55740
// case weapon of us_machine_gun :
54678: LD_VAR 0 2
54682: PUSH
54683: LD_INT 2
54685: DOUBLE
54686: EQUAL
54687: IFTRUE 54691
54689: GO 54721
54691: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54692: LD_ADDR_VAR 0 3
54696: PUSH
54697: LD_INT 1
54699: PUSH
54700: LD_INT 2
54702: PUSH
54703: LD_INT 3
54705: PUSH
54706: LD_INT 4
54708: PUSH
54709: LD_INT 5
54711: PUSH
54712: EMPTY
54713: LIST
54714: LIST
54715: LIST
54716: LIST
54717: LIST
54718: ST_TO_ADDR
54719: GO 55724
54721: LD_INT 3
54723: DOUBLE
54724: EQUAL
54725: IFTRUE 54729
54727: GO 54759
54729: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54730: LD_ADDR_VAR 0 3
54734: PUSH
54735: LD_INT 1
54737: PUSH
54738: LD_INT 2
54740: PUSH
54741: LD_INT 3
54743: PUSH
54744: LD_INT 4
54746: PUSH
54747: LD_INT 5
54749: PUSH
54750: EMPTY
54751: LIST
54752: LIST
54753: LIST
54754: LIST
54755: LIST
54756: ST_TO_ADDR
54757: GO 55724
54759: LD_INT 11
54761: DOUBLE
54762: EQUAL
54763: IFTRUE 54767
54765: GO 54797
54767: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54768: LD_ADDR_VAR 0 3
54772: PUSH
54773: LD_INT 1
54775: PUSH
54776: LD_INT 2
54778: PUSH
54779: LD_INT 3
54781: PUSH
54782: LD_INT 4
54784: PUSH
54785: LD_INT 5
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: LIST
54792: LIST
54793: LIST
54794: ST_TO_ADDR
54795: GO 55724
54797: LD_INT 4
54799: DOUBLE
54800: EQUAL
54801: IFTRUE 54805
54803: GO 54831
54805: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54806: LD_ADDR_VAR 0 3
54810: PUSH
54811: LD_INT 2
54813: PUSH
54814: LD_INT 3
54816: PUSH
54817: LD_INT 4
54819: PUSH
54820: LD_INT 5
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: LIST
54828: ST_TO_ADDR
54829: GO 55724
54831: LD_INT 5
54833: DOUBLE
54834: EQUAL
54835: IFTRUE 54839
54837: GO 54865
54839: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54840: LD_ADDR_VAR 0 3
54844: PUSH
54845: LD_INT 2
54847: PUSH
54848: LD_INT 3
54850: PUSH
54851: LD_INT 4
54853: PUSH
54854: LD_INT 5
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: LIST
54861: LIST
54862: ST_TO_ADDR
54863: GO 55724
54865: LD_INT 9
54867: DOUBLE
54868: EQUAL
54869: IFTRUE 54873
54871: GO 54899
54873: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54874: LD_ADDR_VAR 0 3
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: LD_INT 3
54884: PUSH
54885: LD_INT 4
54887: PUSH
54888: LD_INT 5
54890: PUSH
54891: EMPTY
54892: LIST
54893: LIST
54894: LIST
54895: LIST
54896: ST_TO_ADDR
54897: GO 55724
54899: LD_INT 7
54901: DOUBLE
54902: EQUAL
54903: IFTRUE 54907
54905: GO 54933
54907: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54908: LD_ADDR_VAR 0 3
54912: PUSH
54913: LD_INT 2
54915: PUSH
54916: LD_INT 3
54918: PUSH
54919: LD_INT 4
54921: PUSH
54922: LD_INT 5
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: LIST
54929: LIST
54930: ST_TO_ADDR
54931: GO 55724
54933: LD_INT 12
54935: DOUBLE
54936: EQUAL
54937: IFTRUE 54941
54939: GO 54967
54941: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54942: LD_ADDR_VAR 0 3
54946: PUSH
54947: LD_INT 2
54949: PUSH
54950: LD_INT 3
54952: PUSH
54953: LD_INT 4
54955: PUSH
54956: LD_INT 5
54958: PUSH
54959: EMPTY
54960: LIST
54961: LIST
54962: LIST
54963: LIST
54964: ST_TO_ADDR
54965: GO 55724
54967: LD_INT 13
54969: DOUBLE
54970: EQUAL
54971: IFTRUE 54975
54973: GO 55001
54975: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54976: LD_ADDR_VAR 0 3
54980: PUSH
54981: LD_INT 2
54983: PUSH
54984: LD_INT 3
54986: PUSH
54987: LD_INT 4
54989: PUSH
54990: LD_INT 5
54992: PUSH
54993: EMPTY
54994: LIST
54995: LIST
54996: LIST
54997: LIST
54998: ST_TO_ADDR
54999: GO 55724
55001: LD_INT 14
55003: DOUBLE
55004: EQUAL
55005: IFTRUE 55009
55007: GO 55027
55009: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55010: LD_ADDR_VAR 0 3
55014: PUSH
55015: LD_INT 4
55017: PUSH
55018: LD_INT 5
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: ST_TO_ADDR
55025: GO 55724
55027: LD_INT 6
55029: DOUBLE
55030: EQUAL
55031: IFTRUE 55035
55033: GO 55053
55035: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55036: LD_ADDR_VAR 0 3
55040: PUSH
55041: LD_INT 4
55043: PUSH
55044: LD_INT 5
55046: PUSH
55047: EMPTY
55048: LIST
55049: LIST
55050: ST_TO_ADDR
55051: GO 55724
55053: LD_INT 10
55055: DOUBLE
55056: EQUAL
55057: IFTRUE 55061
55059: GO 55079
55061: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55062: LD_ADDR_VAR 0 3
55066: PUSH
55067: LD_INT 4
55069: PUSH
55070: LD_INT 5
55072: PUSH
55073: EMPTY
55074: LIST
55075: LIST
55076: ST_TO_ADDR
55077: GO 55724
55079: LD_INT 22
55081: DOUBLE
55082: EQUAL
55083: IFTRUE 55087
55085: GO 55113
55087: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55088: LD_ADDR_VAR 0 3
55092: PUSH
55093: LD_INT 11
55095: PUSH
55096: LD_INT 12
55098: PUSH
55099: LD_INT 13
55101: PUSH
55102: LD_INT 14
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: LIST
55109: LIST
55110: ST_TO_ADDR
55111: GO 55724
55113: LD_INT 23
55115: DOUBLE
55116: EQUAL
55117: IFTRUE 55121
55119: GO 55147
55121: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55122: LD_ADDR_VAR 0 3
55126: PUSH
55127: LD_INT 11
55129: PUSH
55130: LD_INT 12
55132: PUSH
55133: LD_INT 13
55135: PUSH
55136: LD_INT 14
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: LIST
55144: ST_TO_ADDR
55145: GO 55724
55147: LD_INT 24
55149: DOUBLE
55150: EQUAL
55151: IFTRUE 55155
55153: GO 55181
55155: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55156: LD_ADDR_VAR 0 3
55160: PUSH
55161: LD_INT 11
55163: PUSH
55164: LD_INT 12
55166: PUSH
55167: LD_INT 13
55169: PUSH
55170: LD_INT 14
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: LIST
55177: LIST
55178: ST_TO_ADDR
55179: GO 55724
55181: LD_INT 30
55183: DOUBLE
55184: EQUAL
55185: IFTRUE 55189
55187: GO 55215
55189: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55190: LD_ADDR_VAR 0 3
55194: PUSH
55195: LD_INT 11
55197: PUSH
55198: LD_INT 12
55200: PUSH
55201: LD_INT 13
55203: PUSH
55204: LD_INT 14
55206: PUSH
55207: EMPTY
55208: LIST
55209: LIST
55210: LIST
55211: LIST
55212: ST_TO_ADDR
55213: GO 55724
55215: LD_INT 25
55217: DOUBLE
55218: EQUAL
55219: IFTRUE 55223
55221: GO 55241
55223: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55224: LD_ADDR_VAR 0 3
55228: PUSH
55229: LD_INT 13
55231: PUSH
55232: LD_INT 14
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: ST_TO_ADDR
55239: GO 55724
55241: LD_INT 27
55243: DOUBLE
55244: EQUAL
55245: IFTRUE 55249
55247: GO 55267
55249: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55250: LD_ADDR_VAR 0 3
55254: PUSH
55255: LD_INT 13
55257: PUSH
55258: LD_INT 14
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: ST_TO_ADDR
55265: GO 55724
55267: LD_EXP 77
55271: DOUBLE
55272: EQUAL
55273: IFTRUE 55277
55275: GO 55303
55277: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55278: LD_ADDR_VAR 0 3
55282: PUSH
55283: LD_INT 11
55285: PUSH
55286: LD_INT 12
55288: PUSH
55289: LD_INT 13
55291: PUSH
55292: LD_INT 14
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: LIST
55299: LIST
55300: ST_TO_ADDR
55301: GO 55724
55303: LD_INT 28
55305: DOUBLE
55306: EQUAL
55307: IFTRUE 55311
55309: GO 55329
55311: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55312: LD_ADDR_VAR 0 3
55316: PUSH
55317: LD_INT 13
55319: PUSH
55320: LD_INT 14
55322: PUSH
55323: EMPTY
55324: LIST
55325: LIST
55326: ST_TO_ADDR
55327: GO 55724
55329: LD_INT 29
55331: DOUBLE
55332: EQUAL
55333: IFTRUE 55337
55335: GO 55355
55337: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55338: LD_ADDR_VAR 0 3
55342: PUSH
55343: LD_INT 13
55345: PUSH
55346: LD_INT 14
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: ST_TO_ADDR
55353: GO 55724
55355: LD_INT 31
55357: DOUBLE
55358: EQUAL
55359: IFTRUE 55363
55361: GO 55381
55363: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55364: LD_ADDR_VAR 0 3
55368: PUSH
55369: LD_INT 13
55371: PUSH
55372: LD_INT 14
55374: PUSH
55375: EMPTY
55376: LIST
55377: LIST
55378: ST_TO_ADDR
55379: GO 55724
55381: LD_INT 26
55383: DOUBLE
55384: EQUAL
55385: IFTRUE 55389
55387: GO 55407
55389: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55390: LD_ADDR_VAR 0 3
55394: PUSH
55395: LD_INT 13
55397: PUSH
55398: LD_INT 14
55400: PUSH
55401: EMPTY
55402: LIST
55403: LIST
55404: ST_TO_ADDR
55405: GO 55724
55407: LD_INT 42
55409: DOUBLE
55410: EQUAL
55411: IFTRUE 55415
55413: GO 55441
55415: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55416: LD_ADDR_VAR 0 3
55420: PUSH
55421: LD_INT 21
55423: PUSH
55424: LD_INT 22
55426: PUSH
55427: LD_INT 23
55429: PUSH
55430: LD_INT 24
55432: PUSH
55433: EMPTY
55434: LIST
55435: LIST
55436: LIST
55437: LIST
55438: ST_TO_ADDR
55439: GO 55724
55441: LD_INT 43
55443: DOUBLE
55444: EQUAL
55445: IFTRUE 55449
55447: GO 55475
55449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55450: LD_ADDR_VAR 0 3
55454: PUSH
55455: LD_INT 21
55457: PUSH
55458: LD_INT 22
55460: PUSH
55461: LD_INT 23
55463: PUSH
55464: LD_INT 24
55466: PUSH
55467: EMPTY
55468: LIST
55469: LIST
55470: LIST
55471: LIST
55472: ST_TO_ADDR
55473: GO 55724
55475: LD_INT 44
55477: DOUBLE
55478: EQUAL
55479: IFTRUE 55483
55481: GO 55509
55483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55484: LD_ADDR_VAR 0 3
55488: PUSH
55489: LD_INT 21
55491: PUSH
55492: LD_INT 22
55494: PUSH
55495: LD_INT 23
55497: PUSH
55498: LD_INT 24
55500: PUSH
55501: EMPTY
55502: LIST
55503: LIST
55504: LIST
55505: LIST
55506: ST_TO_ADDR
55507: GO 55724
55509: LD_INT 45
55511: DOUBLE
55512: EQUAL
55513: IFTRUE 55517
55515: GO 55543
55517: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55518: LD_ADDR_VAR 0 3
55522: PUSH
55523: LD_INT 21
55525: PUSH
55526: LD_INT 22
55528: PUSH
55529: LD_INT 23
55531: PUSH
55532: LD_INT 24
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: LIST
55539: LIST
55540: ST_TO_ADDR
55541: GO 55724
55543: LD_INT 49
55545: DOUBLE
55546: EQUAL
55547: IFTRUE 55551
55549: GO 55577
55551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55552: LD_ADDR_VAR 0 3
55556: PUSH
55557: LD_INT 21
55559: PUSH
55560: LD_INT 22
55562: PUSH
55563: LD_INT 23
55565: PUSH
55566: LD_INT 24
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: LIST
55573: LIST
55574: ST_TO_ADDR
55575: GO 55724
55577: LD_INT 51
55579: DOUBLE
55580: EQUAL
55581: IFTRUE 55585
55583: GO 55611
55585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55586: LD_ADDR_VAR 0 3
55590: PUSH
55591: LD_INT 21
55593: PUSH
55594: LD_INT 22
55596: PUSH
55597: LD_INT 23
55599: PUSH
55600: LD_INT 24
55602: PUSH
55603: EMPTY
55604: LIST
55605: LIST
55606: LIST
55607: LIST
55608: ST_TO_ADDR
55609: GO 55724
55611: LD_INT 52
55613: DOUBLE
55614: EQUAL
55615: IFTRUE 55619
55617: GO 55645
55619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55620: LD_ADDR_VAR 0 3
55624: PUSH
55625: LD_INT 21
55627: PUSH
55628: LD_INT 22
55630: PUSH
55631: LD_INT 23
55633: PUSH
55634: LD_INT 24
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: LIST
55641: LIST
55642: ST_TO_ADDR
55643: GO 55724
55645: LD_INT 53
55647: DOUBLE
55648: EQUAL
55649: IFTRUE 55653
55651: GO 55671
55653: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55654: LD_ADDR_VAR 0 3
55658: PUSH
55659: LD_INT 23
55661: PUSH
55662: LD_INT 24
55664: PUSH
55665: EMPTY
55666: LIST
55667: LIST
55668: ST_TO_ADDR
55669: GO 55724
55671: LD_INT 46
55673: DOUBLE
55674: EQUAL
55675: IFTRUE 55679
55677: GO 55697
55679: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55680: LD_ADDR_VAR 0 3
55684: PUSH
55685: LD_INT 23
55687: PUSH
55688: LD_INT 24
55690: PUSH
55691: EMPTY
55692: LIST
55693: LIST
55694: ST_TO_ADDR
55695: GO 55724
55697: LD_INT 47
55699: DOUBLE
55700: EQUAL
55701: IFTRUE 55705
55703: GO 55723
55705: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55706: LD_ADDR_VAR 0 3
55710: PUSH
55711: LD_INT 23
55713: PUSH
55714: LD_INT 24
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: ST_TO_ADDR
55721: GO 55724
55723: POP
// result := ( chassis in result ) ;
55724: LD_ADDR_VAR 0 3
55728: PUSH
55729: LD_VAR 0 1
55733: PUSH
55734: LD_VAR 0 3
55738: IN
55739: ST_TO_ADDR
// end ;
55740: LD_VAR 0 3
55744: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55745: LD_INT 0
55747: PPUSH
55748: PPUSH
55749: PPUSH
55750: PPUSH
55751: PPUSH
55752: PPUSH
55753: PPUSH
// result := array ;
55754: LD_ADDR_VAR 0 5
55758: PUSH
55759: LD_VAR 0 1
55763: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55764: LD_VAR 0 1
55768: NOT
55769: PUSH
55770: LD_VAR 0 2
55774: NOT
55775: OR
55776: PUSH
55777: LD_VAR 0 3
55781: NOT
55782: OR
55783: PUSH
55784: LD_VAR 0 2
55788: PUSH
55789: LD_VAR 0 1
55793: GREATER
55794: OR
55795: PUSH
55796: LD_VAR 0 3
55800: PUSH
55801: LD_VAR 0 1
55805: GREATER
55806: OR
55807: IFFALSE 55811
// exit ;
55809: GO 56107
// if direction then
55811: LD_VAR 0 4
55815: IFFALSE 55879
// begin d := 1 ;
55817: LD_ADDR_VAR 0 9
55821: PUSH
55822: LD_INT 1
55824: ST_TO_ADDR
// if i_from > i_to then
55825: LD_VAR 0 2
55829: PUSH
55830: LD_VAR 0 3
55834: GREATER
55835: IFFALSE 55861
// length := ( array - i_from ) + i_to else
55837: LD_ADDR_VAR 0 11
55841: PUSH
55842: LD_VAR 0 1
55846: PUSH
55847: LD_VAR 0 2
55851: MINUS
55852: PUSH
55853: LD_VAR 0 3
55857: PLUS
55858: ST_TO_ADDR
55859: GO 55877
// length := i_to - i_from ;
55861: LD_ADDR_VAR 0 11
55865: PUSH
55866: LD_VAR 0 3
55870: PUSH
55871: LD_VAR 0 2
55875: MINUS
55876: ST_TO_ADDR
// end else
55877: GO 55940
// begin d := - 1 ;
55879: LD_ADDR_VAR 0 9
55883: PUSH
55884: LD_INT 1
55886: NEG
55887: ST_TO_ADDR
// if i_from > i_to then
55888: LD_VAR 0 2
55892: PUSH
55893: LD_VAR 0 3
55897: GREATER
55898: IFFALSE 55918
// length := i_from - i_to else
55900: LD_ADDR_VAR 0 11
55904: PUSH
55905: LD_VAR 0 2
55909: PUSH
55910: LD_VAR 0 3
55914: MINUS
55915: ST_TO_ADDR
55916: GO 55940
// length := ( array - i_to ) + i_from ;
55918: LD_ADDR_VAR 0 11
55922: PUSH
55923: LD_VAR 0 1
55927: PUSH
55928: LD_VAR 0 3
55932: MINUS
55933: PUSH
55934: LD_VAR 0 2
55938: PLUS
55939: ST_TO_ADDR
// end ; if not length then
55940: LD_VAR 0 11
55944: NOT
55945: IFFALSE 55949
// exit ;
55947: GO 56107
// tmp := array ;
55949: LD_ADDR_VAR 0 10
55953: PUSH
55954: LD_VAR 0 1
55958: ST_TO_ADDR
// for i = 1 to length do
55959: LD_ADDR_VAR 0 6
55963: PUSH
55964: DOUBLE
55965: LD_INT 1
55967: DEC
55968: ST_TO_ADDR
55969: LD_VAR 0 11
55973: PUSH
55974: FOR_TO
55975: IFFALSE 56095
// begin for j = 1 to array do
55977: LD_ADDR_VAR 0 7
55981: PUSH
55982: DOUBLE
55983: LD_INT 1
55985: DEC
55986: ST_TO_ADDR
55987: LD_VAR 0 1
55991: PUSH
55992: FOR_TO
55993: IFFALSE 56081
// begin k := j + d ;
55995: LD_ADDR_VAR 0 8
55999: PUSH
56000: LD_VAR 0 7
56004: PUSH
56005: LD_VAR 0 9
56009: PLUS
56010: ST_TO_ADDR
// if k > array then
56011: LD_VAR 0 8
56015: PUSH
56016: LD_VAR 0 1
56020: GREATER
56021: IFFALSE 56031
// k := 1 ;
56023: LD_ADDR_VAR 0 8
56027: PUSH
56028: LD_INT 1
56030: ST_TO_ADDR
// if not k then
56031: LD_VAR 0 8
56035: NOT
56036: IFFALSE 56048
// k := array ;
56038: LD_ADDR_VAR 0 8
56042: PUSH
56043: LD_VAR 0 1
56047: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56048: LD_ADDR_VAR 0 10
56052: PUSH
56053: LD_VAR 0 10
56057: PPUSH
56058: LD_VAR 0 8
56062: PPUSH
56063: LD_VAR 0 1
56067: PUSH
56068: LD_VAR 0 7
56072: ARRAY
56073: PPUSH
56074: CALL_OW 1
56078: ST_TO_ADDR
// end ;
56079: GO 55992
56081: POP
56082: POP
// array := tmp ;
56083: LD_ADDR_VAR 0 1
56087: PUSH
56088: LD_VAR 0 10
56092: ST_TO_ADDR
// end ;
56093: GO 55974
56095: POP
56096: POP
// result := array ;
56097: LD_ADDR_VAR 0 5
56101: PUSH
56102: LD_VAR 0 1
56106: ST_TO_ADDR
// end ;
56107: LD_VAR 0 5
56111: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56112: LD_INT 0
56114: PPUSH
56115: PPUSH
// result := 0 ;
56116: LD_ADDR_VAR 0 3
56120: PUSH
56121: LD_INT 0
56123: ST_TO_ADDR
// if not array or not value in array then
56124: LD_VAR 0 1
56128: NOT
56129: PUSH
56130: LD_VAR 0 2
56134: PUSH
56135: LD_VAR 0 1
56139: IN
56140: NOT
56141: OR
56142: IFFALSE 56146
// exit ;
56144: GO 56200
// for i = 1 to array do
56146: LD_ADDR_VAR 0 4
56150: PUSH
56151: DOUBLE
56152: LD_INT 1
56154: DEC
56155: ST_TO_ADDR
56156: LD_VAR 0 1
56160: PUSH
56161: FOR_TO
56162: IFFALSE 56198
// if value = array [ i ] then
56164: LD_VAR 0 2
56168: PUSH
56169: LD_VAR 0 1
56173: PUSH
56174: LD_VAR 0 4
56178: ARRAY
56179: EQUAL
56180: IFFALSE 56196
// begin result := i ;
56182: LD_ADDR_VAR 0 3
56186: PUSH
56187: LD_VAR 0 4
56191: ST_TO_ADDR
// exit ;
56192: POP
56193: POP
56194: GO 56200
// end ;
56196: GO 56161
56198: POP
56199: POP
// end ;
56200: LD_VAR 0 3
56204: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56205: LD_INT 0
56207: PPUSH
// vc_chassis := chassis ;
56208: LD_ADDR_OWVAR 37
56212: PUSH
56213: LD_VAR 0 1
56217: ST_TO_ADDR
// vc_engine := engine ;
56218: LD_ADDR_OWVAR 39
56222: PUSH
56223: LD_VAR 0 2
56227: ST_TO_ADDR
// vc_control := control ;
56228: LD_ADDR_OWVAR 38
56232: PUSH
56233: LD_VAR 0 3
56237: ST_TO_ADDR
// vc_weapon := weapon ;
56238: LD_ADDR_OWVAR 40
56242: PUSH
56243: LD_VAR 0 4
56247: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56248: LD_ADDR_OWVAR 41
56252: PUSH
56253: LD_VAR 0 5
56257: ST_TO_ADDR
// end ;
56258: LD_VAR 0 6
56262: RET
// export function WantPlant ( unit ) ; var task ; begin
56263: LD_INT 0
56265: PPUSH
56266: PPUSH
// result := false ;
56267: LD_ADDR_VAR 0 2
56271: PUSH
56272: LD_INT 0
56274: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56275: LD_ADDR_VAR 0 3
56279: PUSH
56280: LD_VAR 0 1
56284: PPUSH
56285: CALL_OW 437
56289: ST_TO_ADDR
// if task then
56290: LD_VAR 0 3
56294: IFFALSE 56322
// if task [ 1 ] [ 1 ] = p then
56296: LD_VAR 0 3
56300: PUSH
56301: LD_INT 1
56303: ARRAY
56304: PUSH
56305: LD_INT 1
56307: ARRAY
56308: PUSH
56309: LD_STRING p
56311: EQUAL
56312: IFFALSE 56322
// result := true ;
56314: LD_ADDR_VAR 0 2
56318: PUSH
56319: LD_INT 1
56321: ST_TO_ADDR
// end ;
56322: LD_VAR 0 2
56326: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56327: LD_INT 0
56329: PPUSH
56330: PPUSH
56331: PPUSH
56332: PPUSH
// if pos < 1 then
56333: LD_VAR 0 2
56337: PUSH
56338: LD_INT 1
56340: LESS
56341: IFFALSE 56345
// exit ;
56343: GO 56648
// if pos = 1 then
56345: LD_VAR 0 2
56349: PUSH
56350: LD_INT 1
56352: EQUAL
56353: IFFALSE 56386
// result := Replace ( arr , pos [ 1 ] , value ) else
56355: LD_ADDR_VAR 0 4
56359: PUSH
56360: LD_VAR 0 1
56364: PPUSH
56365: LD_VAR 0 2
56369: PUSH
56370: LD_INT 1
56372: ARRAY
56373: PPUSH
56374: LD_VAR 0 3
56378: PPUSH
56379: CALL_OW 1
56383: ST_TO_ADDR
56384: GO 56648
// begin tmp := arr ;
56386: LD_ADDR_VAR 0 6
56390: PUSH
56391: LD_VAR 0 1
56395: ST_TO_ADDR
// s_arr := [ tmp ] ;
56396: LD_ADDR_VAR 0 7
56400: PUSH
56401: LD_VAR 0 6
56405: PUSH
56406: EMPTY
56407: LIST
56408: ST_TO_ADDR
// for i = 1 to pos - 1 do
56409: LD_ADDR_VAR 0 5
56413: PUSH
56414: DOUBLE
56415: LD_INT 1
56417: DEC
56418: ST_TO_ADDR
56419: LD_VAR 0 2
56423: PUSH
56424: LD_INT 1
56426: MINUS
56427: PUSH
56428: FOR_TO
56429: IFFALSE 56474
// begin tmp := tmp [ pos [ i ] ] ;
56431: LD_ADDR_VAR 0 6
56435: PUSH
56436: LD_VAR 0 6
56440: PUSH
56441: LD_VAR 0 2
56445: PUSH
56446: LD_VAR 0 5
56450: ARRAY
56451: ARRAY
56452: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56453: LD_ADDR_VAR 0 7
56457: PUSH
56458: LD_VAR 0 7
56462: PUSH
56463: LD_VAR 0 6
56467: PUSH
56468: EMPTY
56469: LIST
56470: ADD
56471: ST_TO_ADDR
// end ;
56472: GO 56428
56474: POP
56475: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56476: LD_ADDR_VAR 0 6
56480: PUSH
56481: LD_VAR 0 6
56485: PPUSH
56486: LD_VAR 0 2
56490: PUSH
56491: LD_VAR 0 2
56495: ARRAY
56496: PPUSH
56497: LD_VAR 0 3
56501: PPUSH
56502: CALL_OW 1
56506: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56507: LD_ADDR_VAR 0 7
56511: PUSH
56512: LD_VAR 0 7
56516: PPUSH
56517: LD_VAR 0 7
56521: PPUSH
56522: LD_VAR 0 6
56526: PPUSH
56527: CALL_OW 1
56531: ST_TO_ADDR
// for i = s_arr downto 2 do
56532: LD_ADDR_VAR 0 5
56536: PUSH
56537: DOUBLE
56538: LD_VAR 0 7
56542: INC
56543: ST_TO_ADDR
56544: LD_INT 2
56546: PUSH
56547: FOR_DOWNTO
56548: IFFALSE 56632
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56550: LD_ADDR_VAR 0 6
56554: PUSH
56555: LD_VAR 0 7
56559: PUSH
56560: LD_VAR 0 5
56564: PUSH
56565: LD_INT 1
56567: MINUS
56568: ARRAY
56569: PPUSH
56570: LD_VAR 0 2
56574: PUSH
56575: LD_VAR 0 5
56579: PUSH
56580: LD_INT 1
56582: MINUS
56583: ARRAY
56584: PPUSH
56585: LD_VAR 0 7
56589: PUSH
56590: LD_VAR 0 5
56594: ARRAY
56595: PPUSH
56596: CALL_OW 1
56600: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56601: LD_ADDR_VAR 0 7
56605: PUSH
56606: LD_VAR 0 7
56610: PPUSH
56611: LD_VAR 0 5
56615: PUSH
56616: LD_INT 1
56618: MINUS
56619: PPUSH
56620: LD_VAR 0 6
56624: PPUSH
56625: CALL_OW 1
56629: ST_TO_ADDR
// end ;
56630: GO 56547
56632: POP
56633: POP
// result := s_arr [ 1 ] ;
56634: LD_ADDR_VAR 0 4
56638: PUSH
56639: LD_VAR 0 7
56643: PUSH
56644: LD_INT 1
56646: ARRAY
56647: ST_TO_ADDR
// end ; end ;
56648: LD_VAR 0 4
56652: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56653: LD_INT 0
56655: PPUSH
56656: PPUSH
// if not list then
56657: LD_VAR 0 1
56661: NOT
56662: IFFALSE 56666
// exit ;
56664: GO 56757
// i := list [ pos1 ] ;
56666: LD_ADDR_VAR 0 5
56670: PUSH
56671: LD_VAR 0 1
56675: PUSH
56676: LD_VAR 0 2
56680: ARRAY
56681: ST_TO_ADDR
// if not i then
56682: LD_VAR 0 5
56686: NOT
56687: IFFALSE 56691
// exit ;
56689: GO 56757
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56691: LD_ADDR_VAR 0 1
56695: PUSH
56696: LD_VAR 0 1
56700: PPUSH
56701: LD_VAR 0 2
56705: PPUSH
56706: LD_VAR 0 1
56710: PUSH
56711: LD_VAR 0 3
56715: ARRAY
56716: PPUSH
56717: CALL_OW 1
56721: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56722: LD_ADDR_VAR 0 1
56726: PUSH
56727: LD_VAR 0 1
56731: PPUSH
56732: LD_VAR 0 3
56736: PPUSH
56737: LD_VAR 0 5
56741: PPUSH
56742: CALL_OW 1
56746: ST_TO_ADDR
// result := list ;
56747: LD_ADDR_VAR 0 4
56751: PUSH
56752: LD_VAR 0 1
56756: ST_TO_ADDR
// end ;
56757: LD_VAR 0 4
56761: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56762: LD_INT 0
56764: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56765: LD_ADDR_VAR 0 5
56769: PUSH
56770: LD_VAR 0 1
56774: PPUSH
56775: CALL_OW 250
56779: PPUSH
56780: LD_VAR 0 1
56784: PPUSH
56785: CALL_OW 251
56789: PPUSH
56790: LD_VAR 0 2
56794: PPUSH
56795: LD_VAR 0 3
56799: PPUSH
56800: LD_VAR 0 4
56804: PPUSH
56805: CALL 56815 0 5
56809: ST_TO_ADDR
// end ;
56810: LD_VAR 0 5
56814: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56815: LD_INT 0
56817: PPUSH
56818: PPUSH
56819: PPUSH
56820: PPUSH
// if not list then
56821: LD_VAR 0 3
56825: NOT
56826: IFFALSE 56830
// exit ;
56828: GO 57218
// result := [ ] ;
56830: LD_ADDR_VAR 0 6
56834: PUSH
56835: EMPTY
56836: ST_TO_ADDR
// for i in list do
56837: LD_ADDR_VAR 0 7
56841: PUSH
56842: LD_VAR 0 3
56846: PUSH
56847: FOR_IN
56848: IFFALSE 57050
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56850: LD_ADDR_VAR 0 9
56854: PUSH
56855: LD_VAR 0 7
56859: PPUSH
56860: LD_VAR 0 1
56864: PPUSH
56865: LD_VAR 0 2
56869: PPUSH
56870: CALL_OW 297
56874: ST_TO_ADDR
// if not result then
56875: LD_VAR 0 6
56879: NOT
56880: IFFALSE 56906
// result := [ [ i , tmp ] ] else
56882: LD_ADDR_VAR 0 6
56886: PUSH
56887: LD_VAR 0 7
56891: PUSH
56892: LD_VAR 0 9
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: PUSH
56901: EMPTY
56902: LIST
56903: ST_TO_ADDR
56904: GO 57048
// begin if result [ result ] [ 2 ] < tmp then
56906: LD_VAR 0 6
56910: PUSH
56911: LD_VAR 0 6
56915: ARRAY
56916: PUSH
56917: LD_INT 2
56919: ARRAY
56920: PUSH
56921: LD_VAR 0 9
56925: LESS
56926: IFFALSE 56968
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56928: LD_ADDR_VAR 0 6
56932: PUSH
56933: LD_VAR 0 6
56937: PPUSH
56938: LD_VAR 0 6
56942: PUSH
56943: LD_INT 1
56945: PLUS
56946: PPUSH
56947: LD_VAR 0 7
56951: PUSH
56952: LD_VAR 0 9
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PPUSH
56961: CALL_OW 2
56965: ST_TO_ADDR
56966: GO 57048
// for j = 1 to result do
56968: LD_ADDR_VAR 0 8
56972: PUSH
56973: DOUBLE
56974: LD_INT 1
56976: DEC
56977: ST_TO_ADDR
56978: LD_VAR 0 6
56982: PUSH
56983: FOR_TO
56984: IFFALSE 57046
// begin if tmp < result [ j ] [ 2 ] then
56986: LD_VAR 0 9
56990: PUSH
56991: LD_VAR 0 6
56995: PUSH
56996: LD_VAR 0 8
57000: ARRAY
57001: PUSH
57002: LD_INT 2
57004: ARRAY
57005: LESS
57006: IFFALSE 57044
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57008: LD_ADDR_VAR 0 6
57012: PUSH
57013: LD_VAR 0 6
57017: PPUSH
57018: LD_VAR 0 8
57022: PPUSH
57023: LD_VAR 0 7
57027: PUSH
57028: LD_VAR 0 9
57032: PUSH
57033: EMPTY
57034: LIST
57035: LIST
57036: PPUSH
57037: CALL_OW 2
57041: ST_TO_ADDR
// break ;
57042: GO 57046
// end ; end ;
57044: GO 56983
57046: POP
57047: POP
// end ; end ;
57048: GO 56847
57050: POP
57051: POP
// if result and not asc then
57052: LD_VAR 0 6
57056: PUSH
57057: LD_VAR 0 4
57061: NOT
57062: AND
57063: IFFALSE 57138
// begin tmp := result ;
57065: LD_ADDR_VAR 0 9
57069: PUSH
57070: LD_VAR 0 6
57074: ST_TO_ADDR
// for i = tmp downto 1 do
57075: LD_ADDR_VAR 0 7
57079: PUSH
57080: DOUBLE
57081: LD_VAR 0 9
57085: INC
57086: ST_TO_ADDR
57087: LD_INT 1
57089: PUSH
57090: FOR_DOWNTO
57091: IFFALSE 57136
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57093: LD_ADDR_VAR 0 6
57097: PUSH
57098: LD_VAR 0 6
57102: PPUSH
57103: LD_VAR 0 9
57107: PUSH
57108: LD_VAR 0 7
57112: MINUS
57113: PUSH
57114: LD_INT 1
57116: PLUS
57117: PPUSH
57118: LD_VAR 0 9
57122: PUSH
57123: LD_VAR 0 7
57127: ARRAY
57128: PPUSH
57129: CALL_OW 1
57133: ST_TO_ADDR
57134: GO 57090
57136: POP
57137: POP
// end ; tmp := [ ] ;
57138: LD_ADDR_VAR 0 9
57142: PUSH
57143: EMPTY
57144: ST_TO_ADDR
// if mode then
57145: LD_VAR 0 5
57149: IFFALSE 57218
// begin for i = 1 to result do
57151: LD_ADDR_VAR 0 7
57155: PUSH
57156: DOUBLE
57157: LD_INT 1
57159: DEC
57160: ST_TO_ADDR
57161: LD_VAR 0 6
57165: PUSH
57166: FOR_TO
57167: IFFALSE 57206
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57169: LD_ADDR_VAR 0 9
57173: PUSH
57174: LD_VAR 0 9
57178: PPUSH
57179: LD_VAR 0 7
57183: PPUSH
57184: LD_VAR 0 6
57188: PUSH
57189: LD_VAR 0 7
57193: ARRAY
57194: PUSH
57195: LD_INT 1
57197: ARRAY
57198: PPUSH
57199: CALL_OW 1
57203: ST_TO_ADDR
57204: GO 57166
57206: POP
57207: POP
// result := tmp ;
57208: LD_ADDR_VAR 0 6
57212: PUSH
57213: LD_VAR 0 9
57217: ST_TO_ADDR
// end ; end ;
57218: LD_VAR 0 6
57222: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57223: LD_INT 0
57225: PPUSH
57226: PPUSH
57227: PPUSH
57228: PPUSH
57229: PPUSH
57230: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57231: LD_ADDR_VAR 0 5
57235: PUSH
57236: LD_INT 0
57238: PUSH
57239: LD_INT 0
57241: PUSH
57242: LD_INT 0
57244: PUSH
57245: EMPTY
57246: PUSH
57247: EMPTY
57248: LIST
57249: LIST
57250: LIST
57251: LIST
57252: ST_TO_ADDR
// if not x or not y then
57253: LD_VAR 0 2
57257: NOT
57258: PUSH
57259: LD_VAR 0 3
57263: NOT
57264: OR
57265: IFFALSE 57269
// exit ;
57267: GO 58921
// if not range then
57269: LD_VAR 0 4
57273: NOT
57274: IFFALSE 57284
// range := 10 ;
57276: LD_ADDR_VAR 0 4
57280: PUSH
57281: LD_INT 10
57283: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57284: LD_ADDR_VAR 0 8
57288: PUSH
57289: LD_INT 81
57291: PUSH
57292: LD_VAR 0 1
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: PUSH
57301: LD_INT 92
57303: PUSH
57304: LD_VAR 0 2
57308: PUSH
57309: LD_VAR 0 3
57313: PUSH
57314: LD_VAR 0 4
57318: PUSH
57319: EMPTY
57320: LIST
57321: LIST
57322: LIST
57323: LIST
57324: PUSH
57325: LD_INT 3
57327: PUSH
57328: LD_INT 21
57330: PUSH
57331: LD_INT 3
57333: PUSH
57334: EMPTY
57335: LIST
57336: LIST
57337: PUSH
57338: EMPTY
57339: LIST
57340: LIST
57341: PUSH
57342: EMPTY
57343: LIST
57344: LIST
57345: LIST
57346: PPUSH
57347: CALL_OW 69
57351: ST_TO_ADDR
// if not tmp then
57352: LD_VAR 0 8
57356: NOT
57357: IFFALSE 57361
// exit ;
57359: GO 58921
// for i in tmp do
57361: LD_ADDR_VAR 0 6
57365: PUSH
57366: LD_VAR 0 8
57370: PUSH
57371: FOR_IN
57372: IFFALSE 58896
// begin points := [ 0 , 0 , 0 ] ;
57374: LD_ADDR_VAR 0 9
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: LD_INT 0
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: EMPTY
57389: LIST
57390: LIST
57391: LIST
57392: ST_TO_ADDR
// bpoints := 1 ;
57393: LD_ADDR_VAR 0 10
57397: PUSH
57398: LD_INT 1
57400: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57401: LD_VAR 0 6
57405: PPUSH
57406: CALL_OW 247
57410: PUSH
57411: LD_INT 1
57413: DOUBLE
57414: EQUAL
57415: IFTRUE 57419
57417: GO 57997
57419: POP
// begin if GetClass ( i ) = 1 then
57420: LD_VAR 0 6
57424: PPUSH
57425: CALL_OW 257
57429: PUSH
57430: LD_INT 1
57432: EQUAL
57433: IFFALSE 57454
// points := [ 10 , 5 , 3 ] ;
57435: LD_ADDR_VAR 0 9
57439: PUSH
57440: LD_INT 10
57442: PUSH
57443: LD_INT 5
57445: PUSH
57446: LD_INT 3
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: LIST
57453: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57454: LD_VAR 0 6
57458: PPUSH
57459: CALL_OW 257
57463: PUSH
57464: LD_INT 2
57466: PUSH
57467: LD_INT 3
57469: PUSH
57470: LD_INT 4
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: LIST
57477: IN
57478: IFFALSE 57499
// points := [ 3 , 2 , 1 ] ;
57480: LD_ADDR_VAR 0 9
57484: PUSH
57485: LD_INT 3
57487: PUSH
57488: LD_INT 2
57490: PUSH
57491: LD_INT 1
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: LIST
57498: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57499: LD_VAR 0 6
57503: PPUSH
57504: CALL_OW 257
57508: PUSH
57509: LD_INT 5
57511: EQUAL
57512: IFFALSE 57533
// points := [ 130 , 5 , 2 ] ;
57514: LD_ADDR_VAR 0 9
57518: PUSH
57519: LD_INT 130
57521: PUSH
57522: LD_INT 5
57524: PUSH
57525: LD_INT 2
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: LIST
57532: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57533: LD_VAR 0 6
57537: PPUSH
57538: CALL_OW 257
57542: PUSH
57543: LD_INT 8
57545: EQUAL
57546: IFFALSE 57567
// points := [ 35 , 35 , 30 ] ;
57548: LD_ADDR_VAR 0 9
57552: PUSH
57553: LD_INT 35
57555: PUSH
57556: LD_INT 35
57558: PUSH
57559: LD_INT 30
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: LIST
57566: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57567: LD_VAR 0 6
57571: PPUSH
57572: CALL_OW 257
57576: PUSH
57577: LD_INT 9
57579: EQUAL
57580: IFFALSE 57601
// points := [ 20 , 55 , 40 ] ;
57582: LD_ADDR_VAR 0 9
57586: PUSH
57587: LD_INT 20
57589: PUSH
57590: LD_INT 55
57592: PUSH
57593: LD_INT 40
57595: PUSH
57596: EMPTY
57597: LIST
57598: LIST
57599: LIST
57600: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57601: LD_VAR 0 6
57605: PPUSH
57606: CALL_OW 257
57610: PUSH
57611: LD_INT 12
57613: PUSH
57614: LD_INT 16
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: IN
57621: IFFALSE 57642
// points := [ 5 , 3 , 2 ] ;
57623: LD_ADDR_VAR 0 9
57627: PUSH
57628: LD_INT 5
57630: PUSH
57631: LD_INT 3
57633: PUSH
57634: LD_INT 2
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: LIST
57641: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57642: LD_VAR 0 6
57646: PPUSH
57647: CALL_OW 257
57651: PUSH
57652: LD_INT 17
57654: EQUAL
57655: IFFALSE 57676
// points := [ 100 , 50 , 75 ] ;
57657: LD_ADDR_VAR 0 9
57661: PUSH
57662: LD_INT 100
57664: PUSH
57665: LD_INT 50
57667: PUSH
57668: LD_INT 75
57670: PUSH
57671: EMPTY
57672: LIST
57673: LIST
57674: LIST
57675: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57676: LD_VAR 0 6
57680: PPUSH
57681: CALL_OW 257
57685: PUSH
57686: LD_INT 15
57688: EQUAL
57689: IFFALSE 57710
// points := [ 10 , 5 , 3 ] ;
57691: LD_ADDR_VAR 0 9
57695: PUSH
57696: LD_INT 10
57698: PUSH
57699: LD_INT 5
57701: PUSH
57702: LD_INT 3
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: LIST
57709: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57710: LD_VAR 0 6
57714: PPUSH
57715: CALL_OW 257
57719: PUSH
57720: LD_INT 14
57722: EQUAL
57723: IFFALSE 57744
// points := [ 10 , 0 , 0 ] ;
57725: LD_ADDR_VAR 0 9
57729: PUSH
57730: LD_INT 10
57732: PUSH
57733: LD_INT 0
57735: PUSH
57736: LD_INT 0
57738: PUSH
57739: EMPTY
57740: LIST
57741: LIST
57742: LIST
57743: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57744: LD_VAR 0 6
57748: PPUSH
57749: CALL_OW 257
57753: PUSH
57754: LD_INT 11
57756: EQUAL
57757: IFFALSE 57778
// points := [ 30 , 10 , 5 ] ;
57759: LD_ADDR_VAR 0 9
57763: PUSH
57764: LD_INT 30
57766: PUSH
57767: LD_INT 10
57769: PUSH
57770: LD_INT 5
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: LIST
57777: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57778: LD_VAR 0 1
57782: PPUSH
57783: LD_INT 5
57785: PPUSH
57786: CALL_OW 321
57790: PUSH
57791: LD_INT 2
57793: EQUAL
57794: IFFALSE 57811
// bpoints := bpoints * 1.8 ;
57796: LD_ADDR_VAR 0 10
57800: PUSH
57801: LD_VAR 0 10
57805: PUSH
57806: LD_REAL  1.80000000000000E+0000
57809: MUL
57810: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57811: LD_VAR 0 6
57815: PPUSH
57816: CALL_OW 257
57820: PUSH
57821: LD_INT 1
57823: PUSH
57824: LD_INT 2
57826: PUSH
57827: LD_INT 3
57829: PUSH
57830: LD_INT 4
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: LIST
57837: LIST
57838: IN
57839: PUSH
57840: LD_VAR 0 1
57844: PPUSH
57845: LD_INT 51
57847: PPUSH
57848: CALL_OW 321
57852: PUSH
57853: LD_INT 2
57855: EQUAL
57856: AND
57857: IFFALSE 57874
// bpoints := bpoints * 1.2 ;
57859: LD_ADDR_VAR 0 10
57863: PUSH
57864: LD_VAR 0 10
57868: PUSH
57869: LD_REAL  1.20000000000000E+0000
57872: MUL
57873: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57874: LD_VAR 0 6
57878: PPUSH
57879: CALL_OW 257
57883: PUSH
57884: LD_INT 5
57886: PUSH
57887: LD_INT 7
57889: PUSH
57890: LD_INT 9
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: LIST
57897: IN
57898: PUSH
57899: LD_VAR 0 1
57903: PPUSH
57904: LD_INT 52
57906: PPUSH
57907: CALL_OW 321
57911: PUSH
57912: LD_INT 2
57914: EQUAL
57915: AND
57916: IFFALSE 57933
// bpoints := bpoints * 1.5 ;
57918: LD_ADDR_VAR 0 10
57922: PUSH
57923: LD_VAR 0 10
57927: PUSH
57928: LD_REAL  1.50000000000000E+0000
57931: MUL
57932: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57933: LD_VAR 0 1
57937: PPUSH
57938: LD_INT 66
57940: PPUSH
57941: CALL_OW 321
57945: PUSH
57946: LD_INT 2
57948: EQUAL
57949: IFFALSE 57966
// bpoints := bpoints * 1.1 ;
57951: LD_ADDR_VAR 0 10
57955: PUSH
57956: LD_VAR 0 10
57960: PUSH
57961: LD_REAL  1.10000000000000E+0000
57964: MUL
57965: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57966: LD_ADDR_VAR 0 10
57970: PUSH
57971: LD_VAR 0 10
57975: PUSH
57976: LD_VAR 0 6
57980: PPUSH
57981: LD_INT 1
57983: PPUSH
57984: CALL_OW 259
57988: PUSH
57989: LD_REAL  1.15000000000000E+0000
57992: MUL
57993: MUL
57994: ST_TO_ADDR
// end ; unit_vehicle :
57995: GO 58825
57997: LD_INT 2
57999: DOUBLE
58000: EQUAL
58001: IFTRUE 58005
58003: GO 58813
58005: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58006: LD_VAR 0 6
58010: PPUSH
58011: CALL_OW 264
58015: PUSH
58016: LD_INT 2
58018: PUSH
58019: LD_INT 42
58021: PUSH
58022: LD_INT 24
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: LIST
58029: IN
58030: IFFALSE 58051
// points := [ 25 , 5 , 3 ] ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_INT 25
58039: PUSH
58040: LD_INT 5
58042: PUSH
58043: LD_INT 3
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: LIST
58050: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58051: LD_VAR 0 6
58055: PPUSH
58056: CALL_OW 264
58060: PUSH
58061: LD_INT 4
58063: PUSH
58064: LD_INT 43
58066: PUSH
58067: LD_INT 25
58069: PUSH
58070: EMPTY
58071: LIST
58072: LIST
58073: LIST
58074: IN
58075: IFFALSE 58096
// points := [ 40 , 15 , 5 ] ;
58077: LD_ADDR_VAR 0 9
58081: PUSH
58082: LD_INT 40
58084: PUSH
58085: LD_INT 15
58087: PUSH
58088: LD_INT 5
58090: PUSH
58091: EMPTY
58092: LIST
58093: LIST
58094: LIST
58095: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58096: LD_VAR 0 6
58100: PPUSH
58101: CALL_OW 264
58105: PUSH
58106: LD_INT 3
58108: PUSH
58109: LD_INT 23
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: IN
58116: IFFALSE 58137
// points := [ 7 , 25 , 8 ] ;
58118: LD_ADDR_VAR 0 9
58122: PUSH
58123: LD_INT 7
58125: PUSH
58126: LD_INT 25
58128: PUSH
58129: LD_INT 8
58131: PUSH
58132: EMPTY
58133: LIST
58134: LIST
58135: LIST
58136: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58137: LD_VAR 0 6
58141: PPUSH
58142: CALL_OW 264
58146: PUSH
58147: LD_INT 5
58149: PUSH
58150: LD_INT 27
58152: PUSH
58153: LD_INT 44
58155: PUSH
58156: EMPTY
58157: LIST
58158: LIST
58159: LIST
58160: IN
58161: IFFALSE 58182
// points := [ 14 , 50 , 16 ] ;
58163: LD_ADDR_VAR 0 9
58167: PUSH
58168: LD_INT 14
58170: PUSH
58171: LD_INT 50
58173: PUSH
58174: LD_INT 16
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: LIST
58181: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58182: LD_VAR 0 6
58186: PPUSH
58187: CALL_OW 264
58191: PUSH
58192: LD_INT 6
58194: PUSH
58195: LD_INT 46
58197: PUSH
58198: EMPTY
58199: LIST
58200: LIST
58201: IN
58202: IFFALSE 58223
// points := [ 32 , 120 , 70 ] ;
58204: LD_ADDR_VAR 0 9
58208: PUSH
58209: LD_INT 32
58211: PUSH
58212: LD_INT 120
58214: PUSH
58215: LD_INT 70
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: LIST
58222: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58223: LD_VAR 0 6
58227: PPUSH
58228: CALL_OW 264
58232: PUSH
58233: LD_INT 7
58235: PUSH
58236: LD_INT 28
58238: PUSH
58239: LD_INT 45
58241: PUSH
58242: LD_EXP 77
58246: PUSH
58247: EMPTY
58248: LIST
58249: LIST
58250: LIST
58251: LIST
58252: IN
58253: IFFALSE 58274
// points := [ 35 , 20 , 45 ] ;
58255: LD_ADDR_VAR 0 9
58259: PUSH
58260: LD_INT 35
58262: PUSH
58263: LD_INT 20
58265: PUSH
58266: LD_INT 45
58268: PUSH
58269: EMPTY
58270: LIST
58271: LIST
58272: LIST
58273: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58274: LD_VAR 0 6
58278: PPUSH
58279: CALL_OW 264
58283: PUSH
58284: LD_INT 47
58286: PUSH
58287: EMPTY
58288: LIST
58289: IN
58290: IFFALSE 58311
// points := [ 67 , 45 , 75 ] ;
58292: LD_ADDR_VAR 0 9
58296: PUSH
58297: LD_INT 67
58299: PUSH
58300: LD_INT 45
58302: PUSH
58303: LD_INT 75
58305: PUSH
58306: EMPTY
58307: LIST
58308: LIST
58309: LIST
58310: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58311: LD_VAR 0 6
58315: PPUSH
58316: CALL_OW 264
58320: PUSH
58321: LD_INT 26
58323: PUSH
58324: EMPTY
58325: LIST
58326: IN
58327: IFFALSE 58348
// points := [ 120 , 30 , 80 ] ;
58329: LD_ADDR_VAR 0 9
58333: PUSH
58334: LD_INT 120
58336: PUSH
58337: LD_INT 30
58339: PUSH
58340: LD_INT 80
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: LIST
58347: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58348: LD_VAR 0 6
58352: PPUSH
58353: CALL_OW 264
58357: PUSH
58358: LD_INT 22
58360: PUSH
58361: EMPTY
58362: LIST
58363: IN
58364: IFFALSE 58385
// points := [ 40 , 1 , 1 ] ;
58366: LD_ADDR_VAR 0 9
58370: PUSH
58371: LD_INT 40
58373: PUSH
58374: LD_INT 1
58376: PUSH
58377: LD_INT 1
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: LIST
58384: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58385: LD_VAR 0 6
58389: PPUSH
58390: CALL_OW 264
58394: PUSH
58395: LD_INT 29
58397: PUSH
58398: EMPTY
58399: LIST
58400: IN
58401: IFFALSE 58422
// points := [ 70 , 200 , 400 ] ;
58403: LD_ADDR_VAR 0 9
58407: PUSH
58408: LD_INT 70
58410: PUSH
58411: LD_INT 200
58413: PUSH
58414: LD_INT 400
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: LIST
58421: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58422: LD_VAR 0 6
58426: PPUSH
58427: CALL_OW 264
58431: PUSH
58432: LD_INT 14
58434: PUSH
58435: LD_INT 53
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: IN
58442: IFFALSE 58463
// points := [ 40 , 10 , 20 ] ;
58444: LD_ADDR_VAR 0 9
58448: PUSH
58449: LD_INT 40
58451: PUSH
58452: LD_INT 10
58454: PUSH
58455: LD_INT 20
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: LIST
58462: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58463: LD_VAR 0 6
58467: PPUSH
58468: CALL_OW 264
58472: PUSH
58473: LD_INT 9
58475: PUSH
58476: EMPTY
58477: LIST
58478: IN
58479: IFFALSE 58500
// points := [ 5 , 70 , 20 ] ;
58481: LD_ADDR_VAR 0 9
58485: PUSH
58486: LD_INT 5
58488: PUSH
58489: LD_INT 70
58491: PUSH
58492: LD_INT 20
58494: PUSH
58495: EMPTY
58496: LIST
58497: LIST
58498: LIST
58499: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58500: LD_VAR 0 6
58504: PPUSH
58505: CALL_OW 264
58509: PUSH
58510: LD_INT 10
58512: PUSH
58513: EMPTY
58514: LIST
58515: IN
58516: IFFALSE 58537
// points := [ 35 , 110 , 70 ] ;
58518: LD_ADDR_VAR 0 9
58522: PUSH
58523: LD_INT 35
58525: PUSH
58526: LD_INT 110
58528: PUSH
58529: LD_INT 70
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: LIST
58536: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58537: LD_VAR 0 6
58541: PPUSH
58542: CALL_OW 265
58546: PUSH
58547: LD_INT 25
58549: EQUAL
58550: IFFALSE 58571
// points := [ 80 , 65 , 100 ] ;
58552: LD_ADDR_VAR 0 9
58556: PUSH
58557: LD_INT 80
58559: PUSH
58560: LD_INT 65
58562: PUSH
58563: LD_INT 100
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: LIST
58570: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58571: LD_VAR 0 6
58575: PPUSH
58576: CALL_OW 263
58580: PUSH
58581: LD_INT 1
58583: EQUAL
58584: IFFALSE 58619
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58586: LD_ADDR_VAR 0 10
58590: PUSH
58591: LD_VAR 0 10
58595: PUSH
58596: LD_VAR 0 6
58600: PPUSH
58601: CALL_OW 311
58605: PPUSH
58606: LD_INT 3
58608: PPUSH
58609: CALL_OW 259
58613: PUSH
58614: LD_INT 4
58616: MUL
58617: MUL
58618: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58619: LD_VAR 0 6
58623: PPUSH
58624: CALL_OW 263
58628: PUSH
58629: LD_INT 2
58631: EQUAL
58632: IFFALSE 58683
// begin j := IsControledBy ( i ) ;
58634: LD_ADDR_VAR 0 7
58638: PUSH
58639: LD_VAR 0 6
58643: PPUSH
58644: CALL_OW 312
58648: ST_TO_ADDR
// if j then
58649: LD_VAR 0 7
58653: IFFALSE 58683
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58655: LD_ADDR_VAR 0 10
58659: PUSH
58660: LD_VAR 0 10
58664: PUSH
58665: LD_VAR 0 7
58669: PPUSH
58670: LD_INT 3
58672: PPUSH
58673: CALL_OW 259
58677: PUSH
58678: LD_INT 3
58680: MUL
58681: MUL
58682: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58683: LD_VAR 0 6
58687: PPUSH
58688: CALL_OW 264
58692: PUSH
58693: LD_INT 5
58695: PUSH
58696: LD_INT 6
58698: PUSH
58699: LD_INT 46
58701: PUSH
58702: LD_INT 44
58704: PUSH
58705: LD_INT 47
58707: PUSH
58708: LD_INT 45
58710: PUSH
58711: LD_INT 28
58713: PUSH
58714: LD_INT 7
58716: PUSH
58717: LD_INT 27
58719: PUSH
58720: LD_INT 29
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: LIST
58727: LIST
58728: LIST
58729: LIST
58730: LIST
58731: LIST
58732: LIST
58733: LIST
58734: IN
58735: PUSH
58736: LD_VAR 0 1
58740: PPUSH
58741: LD_INT 52
58743: PPUSH
58744: CALL_OW 321
58748: PUSH
58749: LD_INT 2
58751: EQUAL
58752: AND
58753: IFFALSE 58770
// bpoints := bpoints * 1.2 ;
58755: LD_ADDR_VAR 0 10
58759: PUSH
58760: LD_VAR 0 10
58764: PUSH
58765: LD_REAL  1.20000000000000E+0000
58768: MUL
58769: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58770: LD_VAR 0 6
58774: PPUSH
58775: CALL_OW 264
58779: PUSH
58780: LD_INT 6
58782: PUSH
58783: LD_INT 46
58785: PUSH
58786: LD_INT 47
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: LIST
58793: IN
58794: IFFALSE 58811
// bpoints := bpoints * 1.2 ;
58796: LD_ADDR_VAR 0 10
58800: PUSH
58801: LD_VAR 0 10
58805: PUSH
58806: LD_REAL  1.20000000000000E+0000
58809: MUL
58810: ST_TO_ADDR
// end ; unit_building :
58811: GO 58825
58813: LD_INT 3
58815: DOUBLE
58816: EQUAL
58817: IFTRUE 58821
58819: GO 58824
58821: POP
// ; end ;
58822: GO 58825
58824: POP
// for j = 1 to 3 do
58825: LD_ADDR_VAR 0 7
58829: PUSH
58830: DOUBLE
58831: LD_INT 1
58833: DEC
58834: ST_TO_ADDR
58835: LD_INT 3
58837: PUSH
58838: FOR_TO
58839: IFFALSE 58892
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58841: LD_ADDR_VAR 0 5
58845: PUSH
58846: LD_VAR 0 5
58850: PPUSH
58851: LD_VAR 0 7
58855: PPUSH
58856: LD_VAR 0 5
58860: PUSH
58861: LD_VAR 0 7
58865: ARRAY
58866: PUSH
58867: LD_VAR 0 9
58871: PUSH
58872: LD_VAR 0 7
58876: ARRAY
58877: PUSH
58878: LD_VAR 0 10
58882: MUL
58883: PLUS
58884: PPUSH
58885: CALL_OW 1
58889: ST_TO_ADDR
58890: GO 58838
58892: POP
58893: POP
// end ;
58894: GO 57371
58896: POP
58897: POP
// result := Replace ( result , 4 , tmp ) ;
58898: LD_ADDR_VAR 0 5
58902: PUSH
58903: LD_VAR 0 5
58907: PPUSH
58908: LD_INT 4
58910: PPUSH
58911: LD_VAR 0 8
58915: PPUSH
58916: CALL_OW 1
58920: ST_TO_ADDR
// end ;
58921: LD_VAR 0 5
58925: RET
// export function DangerAtRange ( unit , range ) ; begin
58926: LD_INT 0
58928: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58929: LD_ADDR_VAR 0 3
58933: PUSH
58934: LD_VAR 0 1
58938: PPUSH
58939: CALL_OW 255
58943: PPUSH
58944: LD_VAR 0 1
58948: PPUSH
58949: CALL_OW 250
58953: PPUSH
58954: LD_VAR 0 1
58958: PPUSH
58959: CALL_OW 251
58963: PPUSH
58964: LD_VAR 0 2
58968: PPUSH
58969: CALL 57223 0 4
58973: ST_TO_ADDR
// end ;
58974: LD_VAR 0 3
58978: RET
// export function DangerInArea ( side , area ) ; begin
58979: LD_INT 0
58981: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58982: LD_ADDR_VAR 0 3
58986: PUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: LD_INT 81
58994: PUSH
58995: LD_VAR 0 1
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: PPUSH
59004: CALL_OW 70
59008: ST_TO_ADDR
// end ;
59009: LD_VAR 0 3
59013: RET
// export function IsExtension ( b ) ; begin
59014: LD_INT 0
59016: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59017: LD_ADDR_VAR 0 2
59021: PUSH
59022: LD_VAR 0 1
59026: PUSH
59027: LD_INT 23
59029: PUSH
59030: LD_INT 20
59032: PUSH
59033: LD_INT 22
59035: PUSH
59036: LD_INT 17
59038: PUSH
59039: LD_INT 24
59041: PUSH
59042: LD_INT 21
59044: PUSH
59045: LD_INT 19
59047: PUSH
59048: LD_INT 16
59050: PUSH
59051: LD_INT 25
59053: PUSH
59054: LD_INT 18
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: LIST
59061: LIST
59062: LIST
59063: LIST
59064: LIST
59065: LIST
59066: LIST
59067: LIST
59068: IN
59069: ST_TO_ADDR
// end ;
59070: LD_VAR 0 2
59074: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59075: LD_INT 0
59077: PPUSH
59078: PPUSH
59079: PPUSH
// result := [ ] ;
59080: LD_ADDR_VAR 0 4
59084: PUSH
59085: EMPTY
59086: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59087: LD_ADDR_VAR 0 5
59091: PUSH
59092: LD_VAR 0 2
59096: PPUSH
59097: LD_INT 21
59099: PUSH
59100: LD_INT 3
59102: PUSH
59103: EMPTY
59104: LIST
59105: LIST
59106: PPUSH
59107: CALL_OW 70
59111: ST_TO_ADDR
// if not tmp then
59112: LD_VAR 0 5
59116: NOT
59117: IFFALSE 59121
// exit ;
59119: GO 59185
// if checkLink then
59121: LD_VAR 0 3
59125: IFFALSE 59175
// begin for i in tmp do
59127: LD_ADDR_VAR 0 6
59131: PUSH
59132: LD_VAR 0 5
59136: PUSH
59137: FOR_IN
59138: IFFALSE 59173
// if GetBase ( i ) <> base then
59140: LD_VAR 0 6
59144: PPUSH
59145: CALL_OW 274
59149: PUSH
59150: LD_VAR 0 1
59154: NONEQUAL
59155: IFFALSE 59171
// ComLinkToBase ( base , i ) ;
59157: LD_VAR 0 1
59161: PPUSH
59162: LD_VAR 0 6
59166: PPUSH
59167: CALL_OW 169
59171: GO 59137
59173: POP
59174: POP
// end ; result := tmp ;
59175: LD_ADDR_VAR 0 4
59179: PUSH
59180: LD_VAR 0 5
59184: ST_TO_ADDR
// end ;
59185: LD_VAR 0 4
59189: RET
// export function ComComplete ( units , b ) ; var i ; begin
59190: LD_INT 0
59192: PPUSH
59193: PPUSH
// if not units then
59194: LD_VAR 0 1
59198: NOT
59199: IFFALSE 59203
// exit ;
59201: GO 59293
// for i in units do
59203: LD_ADDR_VAR 0 4
59207: PUSH
59208: LD_VAR 0 1
59212: PUSH
59213: FOR_IN
59214: IFFALSE 59291
// if BuildingStatus ( b ) = bs_build then
59216: LD_VAR 0 2
59220: PPUSH
59221: CALL_OW 461
59225: PUSH
59226: LD_INT 1
59228: EQUAL
59229: IFFALSE 59289
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59231: LD_VAR 0 4
59235: PPUSH
59236: LD_STRING h
59238: PUSH
59239: LD_VAR 0 2
59243: PPUSH
59244: CALL_OW 250
59248: PUSH
59249: LD_VAR 0 2
59253: PPUSH
59254: CALL_OW 251
59258: PUSH
59259: LD_VAR 0 2
59263: PUSH
59264: LD_INT 0
59266: PUSH
59267: LD_INT 0
59269: PUSH
59270: LD_INT 0
59272: PUSH
59273: EMPTY
59274: LIST
59275: LIST
59276: LIST
59277: LIST
59278: LIST
59279: LIST
59280: LIST
59281: PUSH
59282: EMPTY
59283: LIST
59284: PPUSH
59285: CALL_OW 446
59289: GO 59213
59291: POP
59292: POP
// end ;
59293: LD_VAR 0 3
59297: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59298: LD_INT 0
59300: PPUSH
59301: PPUSH
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59306: LD_VAR 0 1
59310: NOT
59311: PUSH
59312: LD_VAR 0 1
59316: PPUSH
59317: CALL_OW 263
59321: PUSH
59322: LD_INT 2
59324: NONEQUAL
59325: OR
59326: IFFALSE 59330
// exit ;
59328: GO 59646
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59330: LD_ADDR_VAR 0 6
59334: PUSH
59335: LD_INT 22
59337: PUSH
59338: LD_VAR 0 1
59342: PPUSH
59343: CALL_OW 255
59347: PUSH
59348: EMPTY
59349: LIST
59350: LIST
59351: PUSH
59352: LD_INT 2
59354: PUSH
59355: LD_INT 30
59357: PUSH
59358: LD_INT 36
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 34
59367: PUSH
59368: LD_INT 31
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: LIST
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: PPUSH
59384: CALL_OW 69
59388: ST_TO_ADDR
// if not tmp then
59389: LD_VAR 0 6
59393: NOT
59394: IFFALSE 59398
// exit ;
59396: GO 59646
// result := [ ] ;
59398: LD_ADDR_VAR 0 2
59402: PUSH
59403: EMPTY
59404: ST_TO_ADDR
// for i in tmp do
59405: LD_ADDR_VAR 0 3
59409: PUSH
59410: LD_VAR 0 6
59414: PUSH
59415: FOR_IN
59416: IFFALSE 59487
// begin t := UnitsInside ( i ) ;
59418: LD_ADDR_VAR 0 4
59422: PUSH
59423: LD_VAR 0 3
59427: PPUSH
59428: CALL_OW 313
59432: ST_TO_ADDR
// if t then
59433: LD_VAR 0 4
59437: IFFALSE 59485
// for j in t do
59439: LD_ADDR_VAR 0 7
59443: PUSH
59444: LD_VAR 0 4
59448: PUSH
59449: FOR_IN
59450: IFFALSE 59483
// result := Replace ( result , result + 1 , j ) ;
59452: LD_ADDR_VAR 0 2
59456: PUSH
59457: LD_VAR 0 2
59461: PPUSH
59462: LD_VAR 0 2
59466: PUSH
59467: LD_INT 1
59469: PLUS
59470: PPUSH
59471: LD_VAR 0 7
59475: PPUSH
59476: CALL_OW 1
59480: ST_TO_ADDR
59481: GO 59449
59483: POP
59484: POP
// end ;
59485: GO 59415
59487: POP
59488: POP
// if not result then
59489: LD_VAR 0 2
59493: NOT
59494: IFFALSE 59498
// exit ;
59496: GO 59646
// mech := result [ 1 ] ;
59498: LD_ADDR_VAR 0 5
59502: PUSH
59503: LD_VAR 0 2
59507: PUSH
59508: LD_INT 1
59510: ARRAY
59511: ST_TO_ADDR
// if result > 1 then
59512: LD_VAR 0 2
59516: PUSH
59517: LD_INT 1
59519: GREATER
59520: IFFALSE 59632
// begin for i = 2 to result do
59522: LD_ADDR_VAR 0 3
59526: PUSH
59527: DOUBLE
59528: LD_INT 2
59530: DEC
59531: ST_TO_ADDR
59532: LD_VAR 0 2
59536: PUSH
59537: FOR_TO
59538: IFFALSE 59630
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59540: LD_ADDR_VAR 0 4
59544: PUSH
59545: LD_VAR 0 2
59549: PUSH
59550: LD_VAR 0 3
59554: ARRAY
59555: PPUSH
59556: LD_INT 3
59558: PPUSH
59559: CALL_OW 259
59563: PUSH
59564: LD_VAR 0 2
59568: PUSH
59569: LD_VAR 0 3
59573: ARRAY
59574: PPUSH
59575: CALL_OW 432
59579: MINUS
59580: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59581: LD_VAR 0 4
59585: PUSH
59586: LD_VAR 0 5
59590: PPUSH
59591: LD_INT 3
59593: PPUSH
59594: CALL_OW 259
59598: PUSH
59599: LD_VAR 0 5
59603: PPUSH
59604: CALL_OW 432
59608: MINUS
59609: GREATEREQUAL
59610: IFFALSE 59628
// mech := result [ i ] ;
59612: LD_ADDR_VAR 0 5
59616: PUSH
59617: LD_VAR 0 2
59621: PUSH
59622: LD_VAR 0 3
59626: ARRAY
59627: ST_TO_ADDR
// end ;
59628: GO 59537
59630: POP
59631: POP
// end ; ComLinkTo ( vehicle , mech ) ;
59632: LD_VAR 0 1
59636: PPUSH
59637: LD_VAR 0 5
59641: PPUSH
59642: CALL_OW 135
// end ;
59646: LD_VAR 0 2
59650: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59651: LD_INT 0
59653: PPUSH
59654: PPUSH
59655: PPUSH
59656: PPUSH
59657: PPUSH
59658: PPUSH
59659: PPUSH
59660: PPUSH
59661: PPUSH
59662: PPUSH
59663: PPUSH
59664: PPUSH
59665: PPUSH
// result := [ ] ;
59666: LD_ADDR_VAR 0 7
59670: PUSH
59671: EMPTY
59672: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59673: LD_VAR 0 1
59677: PPUSH
59678: CALL_OW 266
59682: PUSH
59683: LD_INT 0
59685: PUSH
59686: LD_INT 1
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: IN
59693: NOT
59694: IFFALSE 59698
// exit ;
59696: GO 61332
// if name then
59698: LD_VAR 0 3
59702: IFFALSE 59718
// SetBName ( base_dep , name ) ;
59704: LD_VAR 0 1
59708: PPUSH
59709: LD_VAR 0 3
59713: PPUSH
59714: CALL_OW 500
// base := GetBase ( base_dep ) ;
59718: LD_ADDR_VAR 0 15
59722: PUSH
59723: LD_VAR 0 1
59727: PPUSH
59728: CALL_OW 274
59732: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59733: LD_ADDR_VAR 0 16
59737: PUSH
59738: LD_VAR 0 1
59742: PPUSH
59743: CALL_OW 255
59747: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59748: LD_ADDR_VAR 0 17
59752: PUSH
59753: LD_VAR 0 1
59757: PPUSH
59758: CALL_OW 248
59762: ST_TO_ADDR
// if sources then
59763: LD_VAR 0 5
59767: IFFALSE 59814
// for i = 1 to 3 do
59769: LD_ADDR_VAR 0 8
59773: PUSH
59774: DOUBLE
59775: LD_INT 1
59777: DEC
59778: ST_TO_ADDR
59779: LD_INT 3
59781: PUSH
59782: FOR_TO
59783: IFFALSE 59812
// AddResourceType ( base , i , sources [ i ] ) ;
59785: LD_VAR 0 15
59789: PPUSH
59790: LD_VAR 0 8
59794: PPUSH
59795: LD_VAR 0 5
59799: PUSH
59800: LD_VAR 0 8
59804: ARRAY
59805: PPUSH
59806: CALL_OW 276
59810: GO 59782
59812: POP
59813: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59814: LD_ADDR_VAR 0 18
59818: PUSH
59819: LD_VAR 0 15
59823: PPUSH
59824: LD_VAR 0 2
59828: PPUSH
59829: LD_INT 1
59831: PPUSH
59832: CALL 59075 0 3
59836: ST_TO_ADDR
// InitHc ;
59837: CALL_OW 19
// InitUc ;
59841: CALL_OW 18
// uc_side := side ;
59845: LD_ADDR_OWVAR 20
59849: PUSH
59850: LD_VAR 0 16
59854: ST_TO_ADDR
// uc_nation := nation ;
59855: LD_ADDR_OWVAR 21
59859: PUSH
59860: LD_VAR 0 17
59864: ST_TO_ADDR
// if buildings then
59865: LD_VAR 0 18
59869: IFFALSE 61191
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59871: LD_ADDR_VAR 0 19
59875: PUSH
59876: LD_VAR 0 18
59880: PPUSH
59881: LD_INT 2
59883: PUSH
59884: LD_INT 30
59886: PUSH
59887: LD_INT 29
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: PUSH
59894: LD_INT 30
59896: PUSH
59897: LD_INT 30
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: LIST
59908: PPUSH
59909: CALL_OW 72
59913: ST_TO_ADDR
// if tmp then
59914: LD_VAR 0 19
59918: IFFALSE 59966
// for i in tmp do
59920: LD_ADDR_VAR 0 8
59924: PUSH
59925: LD_VAR 0 19
59929: PUSH
59930: FOR_IN
59931: IFFALSE 59964
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59933: LD_VAR 0 8
59937: PPUSH
59938: CALL_OW 250
59942: PPUSH
59943: LD_VAR 0 8
59947: PPUSH
59948: CALL_OW 251
59952: PPUSH
59953: LD_VAR 0 16
59957: PPUSH
59958: CALL_OW 441
59962: GO 59930
59964: POP
59965: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59966: LD_VAR 0 18
59970: PPUSH
59971: LD_INT 2
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 32
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: LD_INT 30
59986: PUSH
59987: LD_INT 33
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: LIST
59998: PPUSH
59999: CALL_OW 72
60003: IFFALSE 60091
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60005: LD_ADDR_VAR 0 8
60009: PUSH
60010: LD_VAR 0 18
60014: PPUSH
60015: LD_INT 2
60017: PUSH
60018: LD_INT 30
60020: PUSH
60021: LD_INT 32
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: PUSH
60028: LD_INT 30
60030: PUSH
60031: LD_INT 33
60033: PUSH
60034: EMPTY
60035: LIST
60036: LIST
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: LIST
60042: PPUSH
60043: CALL_OW 72
60047: PUSH
60048: FOR_IN
60049: IFFALSE 60089
// begin if not GetBWeapon ( i ) then
60051: LD_VAR 0 8
60055: PPUSH
60056: CALL_OW 269
60060: NOT
60061: IFFALSE 60087
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60063: LD_VAR 0 8
60067: PPUSH
60068: LD_VAR 0 8
60072: PPUSH
60073: LD_VAR 0 2
60077: PPUSH
60078: CALL 61337 0 2
60082: PPUSH
60083: CALL_OW 431
// end ;
60087: GO 60048
60089: POP
60090: POP
// end ; for i = 1 to personel do
60091: LD_ADDR_VAR 0 8
60095: PUSH
60096: DOUBLE
60097: LD_INT 1
60099: DEC
60100: ST_TO_ADDR
60101: LD_VAR 0 6
60105: PUSH
60106: FOR_TO
60107: IFFALSE 61171
// begin if i > 4 then
60109: LD_VAR 0 8
60113: PUSH
60114: LD_INT 4
60116: GREATER
60117: IFFALSE 60121
// break ;
60119: GO 61171
// case i of 1 :
60121: LD_VAR 0 8
60125: PUSH
60126: LD_INT 1
60128: DOUBLE
60129: EQUAL
60130: IFTRUE 60134
60132: GO 60214
60134: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60135: LD_ADDR_VAR 0 12
60139: PUSH
60140: LD_VAR 0 18
60144: PPUSH
60145: LD_INT 22
60147: PUSH
60148: LD_VAR 0 16
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PUSH
60157: LD_INT 58
60159: PUSH
60160: EMPTY
60161: LIST
60162: PUSH
60163: LD_INT 2
60165: PUSH
60166: LD_INT 30
60168: PUSH
60169: LD_INT 32
60171: PUSH
60172: EMPTY
60173: LIST
60174: LIST
60175: PUSH
60176: LD_INT 30
60178: PUSH
60179: LD_INT 4
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: LD_INT 30
60188: PUSH
60189: LD_INT 5
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: LIST
60206: PPUSH
60207: CALL_OW 72
60211: ST_TO_ADDR
60212: GO 60436
60214: LD_INT 2
60216: DOUBLE
60217: EQUAL
60218: IFTRUE 60222
60220: GO 60284
60222: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60223: LD_ADDR_VAR 0 12
60227: PUSH
60228: LD_VAR 0 18
60232: PPUSH
60233: LD_INT 22
60235: PUSH
60236: LD_VAR 0 16
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: LD_INT 2
60247: PUSH
60248: LD_INT 30
60250: PUSH
60251: LD_INT 0
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: PUSH
60258: LD_INT 30
60260: PUSH
60261: LD_INT 1
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PUSH
60268: EMPTY
60269: LIST
60270: LIST
60271: LIST
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PPUSH
60277: CALL_OW 72
60281: ST_TO_ADDR
60282: GO 60436
60284: LD_INT 3
60286: DOUBLE
60287: EQUAL
60288: IFTRUE 60292
60290: GO 60354
60292: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60293: LD_ADDR_VAR 0 12
60297: PUSH
60298: LD_VAR 0 18
60302: PPUSH
60303: LD_INT 22
60305: PUSH
60306: LD_VAR 0 16
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PUSH
60315: LD_INT 2
60317: PUSH
60318: LD_INT 30
60320: PUSH
60321: LD_INT 2
60323: PUSH
60324: EMPTY
60325: LIST
60326: LIST
60327: PUSH
60328: LD_INT 30
60330: PUSH
60331: LD_INT 3
60333: PUSH
60334: EMPTY
60335: LIST
60336: LIST
60337: PUSH
60338: EMPTY
60339: LIST
60340: LIST
60341: LIST
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: PPUSH
60347: CALL_OW 72
60351: ST_TO_ADDR
60352: GO 60436
60354: LD_INT 4
60356: DOUBLE
60357: EQUAL
60358: IFTRUE 60362
60360: GO 60435
60362: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60363: LD_ADDR_VAR 0 12
60367: PUSH
60368: LD_VAR 0 18
60372: PPUSH
60373: LD_INT 22
60375: PUSH
60376: LD_VAR 0 16
60380: PUSH
60381: EMPTY
60382: LIST
60383: LIST
60384: PUSH
60385: LD_INT 2
60387: PUSH
60388: LD_INT 30
60390: PUSH
60391: LD_INT 6
60393: PUSH
60394: EMPTY
60395: LIST
60396: LIST
60397: PUSH
60398: LD_INT 30
60400: PUSH
60401: LD_INT 7
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: PUSH
60408: LD_INT 30
60410: PUSH
60411: LD_INT 8
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PUSH
60418: EMPTY
60419: LIST
60420: LIST
60421: LIST
60422: LIST
60423: PUSH
60424: EMPTY
60425: LIST
60426: LIST
60427: PPUSH
60428: CALL_OW 72
60432: ST_TO_ADDR
60433: GO 60436
60435: POP
// if i = 1 then
60436: LD_VAR 0 8
60440: PUSH
60441: LD_INT 1
60443: EQUAL
60444: IFFALSE 60555
// begin tmp := [ ] ;
60446: LD_ADDR_VAR 0 19
60450: PUSH
60451: EMPTY
60452: ST_TO_ADDR
// for j in f do
60453: LD_ADDR_VAR 0 9
60457: PUSH
60458: LD_VAR 0 12
60462: PUSH
60463: FOR_IN
60464: IFFALSE 60537
// if GetBType ( j ) = b_bunker then
60466: LD_VAR 0 9
60470: PPUSH
60471: CALL_OW 266
60475: PUSH
60476: LD_INT 32
60478: EQUAL
60479: IFFALSE 60506
// tmp := Insert ( tmp , 1 , j ) else
60481: LD_ADDR_VAR 0 19
60485: PUSH
60486: LD_VAR 0 19
60490: PPUSH
60491: LD_INT 1
60493: PPUSH
60494: LD_VAR 0 9
60498: PPUSH
60499: CALL_OW 2
60503: ST_TO_ADDR
60504: GO 60535
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60506: LD_ADDR_VAR 0 19
60510: PUSH
60511: LD_VAR 0 19
60515: PPUSH
60516: LD_VAR 0 19
60520: PUSH
60521: LD_INT 1
60523: PLUS
60524: PPUSH
60525: LD_VAR 0 9
60529: PPUSH
60530: CALL_OW 2
60534: ST_TO_ADDR
60535: GO 60463
60537: POP
60538: POP
// if tmp then
60539: LD_VAR 0 19
60543: IFFALSE 60555
// f := tmp ;
60545: LD_ADDR_VAR 0 12
60549: PUSH
60550: LD_VAR 0 19
60554: ST_TO_ADDR
// end ; x := personel [ i ] ;
60555: LD_ADDR_VAR 0 13
60559: PUSH
60560: LD_VAR 0 6
60564: PUSH
60565: LD_VAR 0 8
60569: ARRAY
60570: ST_TO_ADDR
// if x = - 1 then
60571: LD_VAR 0 13
60575: PUSH
60576: LD_INT 1
60578: NEG
60579: EQUAL
60580: IFFALSE 60789
// begin for j in f do
60582: LD_ADDR_VAR 0 9
60586: PUSH
60587: LD_VAR 0 12
60591: PUSH
60592: FOR_IN
60593: IFFALSE 60785
// repeat InitHc ;
60595: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60599: LD_VAR 0 9
60603: PPUSH
60604: CALL_OW 266
60608: PUSH
60609: LD_INT 5
60611: EQUAL
60612: IFFALSE 60682
// begin if UnitsInside ( j ) < 3 then
60614: LD_VAR 0 9
60618: PPUSH
60619: CALL_OW 313
60623: PUSH
60624: LD_INT 3
60626: LESS
60627: IFFALSE 60663
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60629: LD_INT 0
60631: PPUSH
60632: LD_INT 5
60634: PUSH
60635: LD_INT 8
60637: PUSH
60638: LD_INT 9
60640: PUSH
60641: EMPTY
60642: LIST
60643: LIST
60644: LIST
60645: PUSH
60646: LD_VAR 0 17
60650: ARRAY
60651: PPUSH
60652: LD_VAR 0 4
60656: PPUSH
60657: CALL_OW 380
60661: GO 60680
// PrepareHuman ( false , i , skill ) ;
60663: LD_INT 0
60665: PPUSH
60666: LD_VAR 0 8
60670: PPUSH
60671: LD_VAR 0 4
60675: PPUSH
60676: CALL_OW 380
// end else
60680: GO 60699
// PrepareHuman ( false , i , skill ) ;
60682: LD_INT 0
60684: PPUSH
60685: LD_VAR 0 8
60689: PPUSH
60690: LD_VAR 0 4
60694: PPUSH
60695: CALL_OW 380
// un := CreateHuman ;
60699: LD_ADDR_VAR 0 14
60703: PUSH
60704: CALL_OW 44
60708: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60709: LD_ADDR_VAR 0 7
60713: PUSH
60714: LD_VAR 0 7
60718: PPUSH
60719: LD_INT 1
60721: PPUSH
60722: LD_VAR 0 14
60726: PPUSH
60727: CALL_OW 2
60731: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60732: LD_VAR 0 14
60736: PPUSH
60737: LD_VAR 0 9
60741: PPUSH
60742: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60746: LD_VAR 0 9
60750: PPUSH
60751: CALL_OW 313
60755: PUSH
60756: LD_INT 6
60758: EQUAL
60759: PUSH
60760: LD_VAR 0 9
60764: PPUSH
60765: CALL_OW 266
60769: PUSH
60770: LD_INT 32
60772: PUSH
60773: LD_INT 31
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: IN
60780: OR
60781: IFFALSE 60595
60783: GO 60592
60785: POP
60786: POP
// end else
60787: GO 61169
// for j = 1 to x do
60789: LD_ADDR_VAR 0 9
60793: PUSH
60794: DOUBLE
60795: LD_INT 1
60797: DEC
60798: ST_TO_ADDR
60799: LD_VAR 0 13
60803: PUSH
60804: FOR_TO
60805: IFFALSE 61167
// begin InitHc ;
60807: CALL_OW 19
// if not f then
60811: LD_VAR 0 12
60815: NOT
60816: IFFALSE 60905
// begin PrepareHuman ( false , i , skill ) ;
60818: LD_INT 0
60820: PPUSH
60821: LD_VAR 0 8
60825: PPUSH
60826: LD_VAR 0 4
60830: PPUSH
60831: CALL_OW 380
// un := CreateHuman ;
60835: LD_ADDR_VAR 0 14
60839: PUSH
60840: CALL_OW 44
60844: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60845: LD_ADDR_VAR 0 7
60849: PUSH
60850: LD_VAR 0 7
60854: PPUSH
60855: LD_INT 1
60857: PPUSH
60858: LD_VAR 0 14
60862: PPUSH
60863: CALL_OW 2
60867: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60868: LD_VAR 0 14
60872: PPUSH
60873: LD_VAR 0 1
60877: PPUSH
60878: CALL_OW 250
60882: PPUSH
60883: LD_VAR 0 1
60887: PPUSH
60888: CALL_OW 251
60892: PPUSH
60893: LD_INT 10
60895: PPUSH
60896: LD_INT 0
60898: PPUSH
60899: CALL_OW 50
// continue ;
60903: GO 60804
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60905: LD_VAR 0 12
60909: PUSH
60910: LD_INT 1
60912: ARRAY
60913: PPUSH
60914: CALL_OW 313
60918: PUSH
60919: LD_VAR 0 12
60923: PUSH
60924: LD_INT 1
60926: ARRAY
60927: PPUSH
60928: CALL_OW 266
60932: PUSH
60933: LD_INT 32
60935: PUSH
60936: LD_INT 31
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: IN
60943: AND
60944: PUSH
60945: LD_VAR 0 12
60949: PUSH
60950: LD_INT 1
60952: ARRAY
60953: PPUSH
60954: CALL_OW 313
60958: PUSH
60959: LD_INT 6
60961: EQUAL
60962: OR
60963: IFFALSE 60983
// f := Delete ( f , 1 ) ;
60965: LD_ADDR_VAR 0 12
60969: PUSH
60970: LD_VAR 0 12
60974: PPUSH
60975: LD_INT 1
60977: PPUSH
60978: CALL_OW 3
60982: ST_TO_ADDR
// if not f then
60983: LD_VAR 0 12
60987: NOT
60988: IFFALSE 61006
// begin x := x + 2 ;
60990: LD_ADDR_VAR 0 13
60994: PUSH
60995: LD_VAR 0 13
60999: PUSH
61000: LD_INT 2
61002: PLUS
61003: ST_TO_ADDR
// continue ;
61004: GO 60804
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61006: LD_VAR 0 12
61010: PUSH
61011: LD_INT 1
61013: ARRAY
61014: PPUSH
61015: CALL_OW 266
61019: PUSH
61020: LD_INT 5
61022: EQUAL
61023: IFFALSE 61097
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61025: LD_VAR 0 12
61029: PUSH
61030: LD_INT 1
61032: ARRAY
61033: PPUSH
61034: CALL_OW 313
61038: PUSH
61039: LD_INT 3
61041: LESS
61042: IFFALSE 61078
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61044: LD_INT 0
61046: PPUSH
61047: LD_INT 5
61049: PUSH
61050: LD_INT 8
61052: PUSH
61053: LD_INT 9
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: LIST
61060: PUSH
61061: LD_VAR 0 17
61065: ARRAY
61066: PPUSH
61067: LD_VAR 0 4
61071: PPUSH
61072: CALL_OW 380
61076: GO 61095
// PrepareHuman ( false , i , skill ) ;
61078: LD_INT 0
61080: PPUSH
61081: LD_VAR 0 8
61085: PPUSH
61086: LD_VAR 0 4
61090: PPUSH
61091: CALL_OW 380
// end else
61095: GO 61114
// PrepareHuman ( false , i , skill ) ;
61097: LD_INT 0
61099: PPUSH
61100: LD_VAR 0 8
61104: PPUSH
61105: LD_VAR 0 4
61109: PPUSH
61110: CALL_OW 380
// un := CreateHuman ;
61114: LD_ADDR_VAR 0 14
61118: PUSH
61119: CALL_OW 44
61123: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61124: LD_ADDR_VAR 0 7
61128: PUSH
61129: LD_VAR 0 7
61133: PPUSH
61134: LD_INT 1
61136: PPUSH
61137: LD_VAR 0 14
61141: PPUSH
61142: CALL_OW 2
61146: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61147: LD_VAR 0 14
61151: PPUSH
61152: LD_VAR 0 12
61156: PUSH
61157: LD_INT 1
61159: ARRAY
61160: PPUSH
61161: CALL_OW 52
// end ;
61165: GO 60804
61167: POP
61168: POP
// end ;
61169: GO 60106
61171: POP
61172: POP
// result := result ^ buildings ;
61173: LD_ADDR_VAR 0 7
61177: PUSH
61178: LD_VAR 0 7
61182: PUSH
61183: LD_VAR 0 18
61187: ADD
61188: ST_TO_ADDR
// end else
61189: GO 61332
// begin for i = 1 to personel do
61191: LD_ADDR_VAR 0 8
61195: PUSH
61196: DOUBLE
61197: LD_INT 1
61199: DEC
61200: ST_TO_ADDR
61201: LD_VAR 0 6
61205: PUSH
61206: FOR_TO
61207: IFFALSE 61330
// begin if i > 4 then
61209: LD_VAR 0 8
61213: PUSH
61214: LD_INT 4
61216: GREATER
61217: IFFALSE 61221
// break ;
61219: GO 61330
// x := personel [ i ] ;
61221: LD_ADDR_VAR 0 13
61225: PUSH
61226: LD_VAR 0 6
61230: PUSH
61231: LD_VAR 0 8
61235: ARRAY
61236: ST_TO_ADDR
// if x = - 1 then
61237: LD_VAR 0 13
61241: PUSH
61242: LD_INT 1
61244: NEG
61245: EQUAL
61246: IFFALSE 61250
// continue ;
61248: GO 61206
// PrepareHuman ( false , i , skill ) ;
61250: LD_INT 0
61252: PPUSH
61253: LD_VAR 0 8
61257: PPUSH
61258: LD_VAR 0 4
61262: PPUSH
61263: CALL_OW 380
// un := CreateHuman ;
61267: LD_ADDR_VAR 0 14
61271: PUSH
61272: CALL_OW 44
61276: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61277: LD_VAR 0 14
61281: PPUSH
61282: LD_VAR 0 1
61286: PPUSH
61287: CALL_OW 250
61291: PPUSH
61292: LD_VAR 0 1
61296: PPUSH
61297: CALL_OW 251
61301: PPUSH
61302: LD_INT 10
61304: PPUSH
61305: LD_INT 0
61307: PPUSH
61308: CALL_OW 50
// result := result ^ un ;
61312: LD_ADDR_VAR 0 7
61316: PUSH
61317: LD_VAR 0 7
61321: PUSH
61322: LD_VAR 0 14
61326: ADD
61327: ST_TO_ADDR
// end ;
61328: GO 61206
61330: POP
61331: POP
// end ; end ;
61332: LD_VAR 0 7
61336: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61337: LD_INT 0
61339: PPUSH
61340: PPUSH
61341: PPUSH
61342: PPUSH
61343: PPUSH
61344: PPUSH
61345: PPUSH
61346: PPUSH
61347: PPUSH
61348: PPUSH
61349: PPUSH
61350: PPUSH
61351: PPUSH
61352: PPUSH
61353: PPUSH
61354: PPUSH
// result := false ;
61355: LD_ADDR_VAR 0 3
61359: PUSH
61360: LD_INT 0
61362: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61363: LD_VAR 0 1
61367: NOT
61368: PUSH
61369: LD_VAR 0 1
61373: PPUSH
61374: CALL_OW 266
61378: PUSH
61379: LD_INT 32
61381: PUSH
61382: LD_INT 33
61384: PUSH
61385: EMPTY
61386: LIST
61387: LIST
61388: IN
61389: NOT
61390: OR
61391: IFFALSE 61395
// exit ;
61393: GO 62504
// nat := GetNation ( tower ) ;
61395: LD_ADDR_VAR 0 12
61399: PUSH
61400: LD_VAR 0 1
61404: PPUSH
61405: CALL_OW 248
61409: ST_TO_ADDR
// side := GetSide ( tower ) ;
61410: LD_ADDR_VAR 0 16
61414: PUSH
61415: LD_VAR 0 1
61419: PPUSH
61420: CALL_OW 255
61424: ST_TO_ADDR
// x := GetX ( tower ) ;
61425: LD_ADDR_VAR 0 10
61429: PUSH
61430: LD_VAR 0 1
61434: PPUSH
61435: CALL_OW 250
61439: ST_TO_ADDR
// y := GetY ( tower ) ;
61440: LD_ADDR_VAR 0 11
61444: PUSH
61445: LD_VAR 0 1
61449: PPUSH
61450: CALL_OW 251
61454: ST_TO_ADDR
// if not x or not y then
61455: LD_VAR 0 10
61459: NOT
61460: PUSH
61461: LD_VAR 0 11
61465: NOT
61466: OR
61467: IFFALSE 61471
// exit ;
61469: GO 62504
// weapon := 0 ;
61471: LD_ADDR_VAR 0 18
61475: PUSH
61476: LD_INT 0
61478: ST_TO_ADDR
// fac_list := [ ] ;
61479: LD_ADDR_VAR 0 17
61483: PUSH
61484: EMPTY
61485: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61486: LD_ADDR_VAR 0 6
61490: PUSH
61491: LD_VAR 0 1
61495: PPUSH
61496: CALL_OW 274
61500: PPUSH
61501: LD_VAR 0 2
61505: PPUSH
61506: LD_INT 0
61508: PPUSH
61509: CALL 59075 0 3
61513: PPUSH
61514: LD_INT 30
61516: PUSH
61517: LD_INT 3
61519: PUSH
61520: EMPTY
61521: LIST
61522: LIST
61523: PPUSH
61524: CALL_OW 72
61528: ST_TO_ADDR
// if not factories then
61529: LD_VAR 0 6
61533: NOT
61534: IFFALSE 61538
// exit ;
61536: GO 62504
// for i in factories do
61538: LD_ADDR_VAR 0 8
61542: PUSH
61543: LD_VAR 0 6
61547: PUSH
61548: FOR_IN
61549: IFFALSE 61574
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61551: LD_ADDR_VAR 0 17
61555: PUSH
61556: LD_VAR 0 17
61560: PUSH
61561: LD_VAR 0 8
61565: PPUSH
61566: CALL_OW 478
61570: UNION
61571: ST_TO_ADDR
61572: GO 61548
61574: POP
61575: POP
// if not fac_list then
61576: LD_VAR 0 17
61580: NOT
61581: IFFALSE 61585
// exit ;
61583: GO 62504
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61585: LD_ADDR_VAR 0 5
61589: PUSH
61590: LD_INT 4
61592: PUSH
61593: LD_INT 5
61595: PUSH
61596: LD_INT 9
61598: PUSH
61599: LD_INT 10
61601: PUSH
61602: LD_INT 6
61604: PUSH
61605: LD_INT 7
61607: PUSH
61608: LD_INT 11
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: LIST
61615: LIST
61616: LIST
61617: LIST
61618: LIST
61619: PUSH
61620: LD_INT 27
61622: PUSH
61623: LD_INT 28
61625: PUSH
61626: LD_INT 26
61628: PUSH
61629: LD_INT 30
61631: PUSH
61632: EMPTY
61633: LIST
61634: LIST
61635: LIST
61636: LIST
61637: PUSH
61638: LD_INT 43
61640: PUSH
61641: LD_INT 44
61643: PUSH
61644: LD_INT 46
61646: PUSH
61647: LD_INT 45
61649: PUSH
61650: LD_INT 47
61652: PUSH
61653: LD_INT 49
61655: PUSH
61656: EMPTY
61657: LIST
61658: LIST
61659: LIST
61660: LIST
61661: LIST
61662: LIST
61663: PUSH
61664: EMPTY
61665: LIST
61666: LIST
61667: LIST
61668: PUSH
61669: LD_VAR 0 12
61673: ARRAY
61674: ST_TO_ADDR
// list := list isect fac_list ;
61675: LD_ADDR_VAR 0 5
61679: PUSH
61680: LD_VAR 0 5
61684: PUSH
61685: LD_VAR 0 17
61689: ISECT
61690: ST_TO_ADDR
// if not list then
61691: LD_VAR 0 5
61695: NOT
61696: IFFALSE 61700
// exit ;
61698: GO 62504
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61700: LD_VAR 0 12
61704: PUSH
61705: LD_INT 3
61707: EQUAL
61708: PUSH
61709: LD_INT 49
61711: PUSH
61712: LD_VAR 0 5
61716: IN
61717: AND
61718: PUSH
61719: LD_INT 31
61721: PPUSH
61722: LD_VAR 0 16
61726: PPUSH
61727: CALL_OW 321
61731: PUSH
61732: LD_INT 2
61734: EQUAL
61735: AND
61736: IFFALSE 61796
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61738: LD_INT 22
61740: PUSH
61741: LD_VAR 0 16
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: LD_INT 35
61752: PUSH
61753: LD_INT 49
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: LD_INT 91
61762: PUSH
61763: LD_VAR 0 1
61767: PUSH
61768: LD_INT 10
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: LIST
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: LIST
61780: PPUSH
61781: CALL_OW 69
61785: NOT
61786: IFFALSE 61796
// weapon := ru_time_lapser ;
61788: LD_ADDR_VAR 0 18
61792: PUSH
61793: LD_INT 49
61795: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61796: LD_VAR 0 12
61800: PUSH
61801: LD_INT 1
61803: PUSH
61804: LD_INT 2
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: IN
61811: PUSH
61812: LD_INT 11
61814: PUSH
61815: LD_VAR 0 5
61819: IN
61820: PUSH
61821: LD_INT 30
61823: PUSH
61824: LD_VAR 0 5
61828: IN
61829: OR
61830: AND
61831: PUSH
61832: LD_INT 6
61834: PPUSH
61835: LD_VAR 0 16
61839: PPUSH
61840: CALL_OW 321
61844: PUSH
61845: LD_INT 2
61847: EQUAL
61848: AND
61849: IFFALSE 62014
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61851: LD_INT 22
61853: PUSH
61854: LD_VAR 0 16
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: PUSH
61863: LD_INT 2
61865: PUSH
61866: LD_INT 35
61868: PUSH
61869: LD_INT 11
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: PUSH
61876: LD_INT 35
61878: PUSH
61879: LD_INT 30
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: LIST
61890: PUSH
61891: LD_INT 91
61893: PUSH
61894: LD_VAR 0 1
61898: PUSH
61899: LD_INT 18
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: LIST
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: LIST
61911: PPUSH
61912: CALL_OW 69
61916: NOT
61917: PUSH
61918: LD_INT 22
61920: PUSH
61921: LD_VAR 0 16
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: PUSH
61930: LD_INT 2
61932: PUSH
61933: LD_INT 30
61935: PUSH
61936: LD_INT 32
61938: PUSH
61939: EMPTY
61940: LIST
61941: LIST
61942: PUSH
61943: LD_INT 30
61945: PUSH
61946: LD_INT 33
61948: PUSH
61949: EMPTY
61950: LIST
61951: LIST
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: LIST
61957: PUSH
61958: LD_INT 91
61960: PUSH
61961: LD_VAR 0 1
61965: PUSH
61966: LD_INT 12
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: LIST
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: LIST
61978: PUSH
61979: EMPTY
61980: LIST
61981: PPUSH
61982: CALL_OW 69
61986: PUSH
61987: LD_INT 2
61989: GREATER
61990: AND
61991: IFFALSE 62014
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61993: LD_ADDR_VAR 0 18
61997: PUSH
61998: LD_INT 11
62000: PUSH
62001: LD_INT 30
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_VAR 0 12
62012: ARRAY
62013: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62014: LD_VAR 0 18
62018: NOT
62019: PUSH
62020: LD_INT 40
62022: PPUSH
62023: LD_VAR 0 16
62027: PPUSH
62028: CALL_OW 321
62032: PUSH
62033: LD_INT 2
62035: EQUAL
62036: AND
62037: PUSH
62038: LD_INT 7
62040: PUSH
62041: LD_VAR 0 5
62045: IN
62046: PUSH
62047: LD_INT 28
62049: PUSH
62050: LD_VAR 0 5
62054: IN
62055: OR
62056: PUSH
62057: LD_INT 45
62059: PUSH
62060: LD_VAR 0 5
62064: IN
62065: OR
62066: AND
62067: IFFALSE 62321
// begin hex := GetHexInfo ( x , y ) ;
62069: LD_ADDR_VAR 0 4
62073: PUSH
62074: LD_VAR 0 10
62078: PPUSH
62079: LD_VAR 0 11
62083: PPUSH
62084: CALL_OW 546
62088: ST_TO_ADDR
// if hex [ 1 ] then
62089: LD_VAR 0 4
62093: PUSH
62094: LD_INT 1
62096: ARRAY
62097: IFFALSE 62101
// exit ;
62099: GO 62504
// height := hex [ 2 ] ;
62101: LD_ADDR_VAR 0 15
62105: PUSH
62106: LD_VAR 0 4
62110: PUSH
62111: LD_INT 2
62113: ARRAY
62114: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62115: LD_ADDR_VAR 0 14
62119: PUSH
62120: LD_INT 0
62122: PUSH
62123: LD_INT 2
62125: PUSH
62126: LD_INT 3
62128: PUSH
62129: LD_INT 5
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: LIST
62136: LIST
62137: ST_TO_ADDR
// for i in tmp do
62138: LD_ADDR_VAR 0 8
62142: PUSH
62143: LD_VAR 0 14
62147: PUSH
62148: FOR_IN
62149: IFFALSE 62319
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62151: LD_ADDR_VAR 0 9
62155: PUSH
62156: LD_VAR 0 10
62160: PPUSH
62161: LD_VAR 0 8
62165: PPUSH
62166: LD_INT 5
62168: PPUSH
62169: CALL_OW 272
62173: PUSH
62174: LD_VAR 0 11
62178: PPUSH
62179: LD_VAR 0 8
62183: PPUSH
62184: LD_INT 5
62186: PPUSH
62187: CALL_OW 273
62191: PUSH
62192: EMPTY
62193: LIST
62194: LIST
62195: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62196: LD_VAR 0 9
62200: PUSH
62201: LD_INT 1
62203: ARRAY
62204: PPUSH
62205: LD_VAR 0 9
62209: PUSH
62210: LD_INT 2
62212: ARRAY
62213: PPUSH
62214: CALL_OW 488
62218: IFFALSE 62317
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62220: LD_ADDR_VAR 0 4
62224: PUSH
62225: LD_VAR 0 9
62229: PUSH
62230: LD_INT 1
62232: ARRAY
62233: PPUSH
62234: LD_VAR 0 9
62238: PUSH
62239: LD_INT 2
62241: ARRAY
62242: PPUSH
62243: CALL_OW 546
62247: ST_TO_ADDR
// if hex [ 1 ] then
62248: LD_VAR 0 4
62252: PUSH
62253: LD_INT 1
62255: ARRAY
62256: IFFALSE 62260
// continue ;
62258: GO 62148
// h := hex [ 2 ] ;
62260: LD_ADDR_VAR 0 13
62264: PUSH
62265: LD_VAR 0 4
62269: PUSH
62270: LD_INT 2
62272: ARRAY
62273: ST_TO_ADDR
// if h + 7 < height then
62274: LD_VAR 0 13
62278: PUSH
62279: LD_INT 7
62281: PLUS
62282: PUSH
62283: LD_VAR 0 15
62287: LESS
62288: IFFALSE 62317
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62290: LD_ADDR_VAR 0 18
62294: PUSH
62295: LD_INT 7
62297: PUSH
62298: LD_INT 28
62300: PUSH
62301: LD_INT 45
62303: PUSH
62304: EMPTY
62305: LIST
62306: LIST
62307: LIST
62308: PUSH
62309: LD_VAR 0 12
62313: ARRAY
62314: ST_TO_ADDR
// break ;
62315: GO 62319
// end ; end ; end ;
62317: GO 62148
62319: POP
62320: POP
// end ; if not weapon then
62321: LD_VAR 0 18
62325: NOT
62326: IFFALSE 62386
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62328: LD_ADDR_VAR 0 5
62332: PUSH
62333: LD_VAR 0 5
62337: PUSH
62338: LD_INT 11
62340: PUSH
62341: LD_INT 30
62343: PUSH
62344: LD_INT 49
62346: PUSH
62347: EMPTY
62348: LIST
62349: LIST
62350: LIST
62351: DIFF
62352: ST_TO_ADDR
// if not list then
62353: LD_VAR 0 5
62357: NOT
62358: IFFALSE 62362
// exit ;
62360: GO 62504
// weapon := list [ rand ( 1 , list ) ] ;
62362: LD_ADDR_VAR 0 18
62366: PUSH
62367: LD_VAR 0 5
62371: PUSH
62372: LD_INT 1
62374: PPUSH
62375: LD_VAR 0 5
62379: PPUSH
62380: CALL_OW 12
62384: ARRAY
62385: ST_TO_ADDR
// end ; if weapon then
62386: LD_VAR 0 18
62390: IFFALSE 62504
// begin tmp := CostOfWeapon ( weapon ) ;
62392: LD_ADDR_VAR 0 14
62396: PUSH
62397: LD_VAR 0 18
62401: PPUSH
62402: CALL_OW 451
62406: ST_TO_ADDR
// j := GetBase ( tower ) ;
62407: LD_ADDR_VAR 0 9
62411: PUSH
62412: LD_VAR 0 1
62416: PPUSH
62417: CALL_OW 274
62421: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62422: LD_VAR 0 9
62426: PPUSH
62427: LD_INT 1
62429: PPUSH
62430: CALL_OW 275
62434: PUSH
62435: LD_VAR 0 14
62439: PUSH
62440: LD_INT 1
62442: ARRAY
62443: GREATEREQUAL
62444: PUSH
62445: LD_VAR 0 9
62449: PPUSH
62450: LD_INT 2
62452: PPUSH
62453: CALL_OW 275
62457: PUSH
62458: LD_VAR 0 14
62462: PUSH
62463: LD_INT 2
62465: ARRAY
62466: GREATEREQUAL
62467: AND
62468: PUSH
62469: LD_VAR 0 9
62473: PPUSH
62474: LD_INT 3
62476: PPUSH
62477: CALL_OW 275
62481: PUSH
62482: LD_VAR 0 14
62486: PUSH
62487: LD_INT 3
62489: ARRAY
62490: GREATEREQUAL
62491: AND
62492: IFFALSE 62504
// result := weapon ;
62494: LD_ADDR_VAR 0 3
62498: PUSH
62499: LD_VAR 0 18
62503: ST_TO_ADDR
// end ; end ;
62504: LD_VAR 0 3
62508: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62509: LD_INT 0
62511: PPUSH
62512: PPUSH
// result := true ;
62513: LD_ADDR_VAR 0 3
62517: PUSH
62518: LD_INT 1
62520: ST_TO_ADDR
// if array1 = array2 then
62521: LD_VAR 0 1
62525: PUSH
62526: LD_VAR 0 2
62530: EQUAL
62531: IFFALSE 62591
// begin for i = 1 to array1 do
62533: LD_ADDR_VAR 0 4
62537: PUSH
62538: DOUBLE
62539: LD_INT 1
62541: DEC
62542: ST_TO_ADDR
62543: LD_VAR 0 1
62547: PUSH
62548: FOR_TO
62549: IFFALSE 62587
// if array1 [ i ] <> array2 [ i ] then
62551: LD_VAR 0 1
62555: PUSH
62556: LD_VAR 0 4
62560: ARRAY
62561: PUSH
62562: LD_VAR 0 2
62566: PUSH
62567: LD_VAR 0 4
62571: ARRAY
62572: NONEQUAL
62573: IFFALSE 62585
// begin result := false ;
62575: LD_ADDR_VAR 0 3
62579: PUSH
62580: LD_INT 0
62582: ST_TO_ADDR
// break ;
62583: GO 62587
// end ;
62585: GO 62548
62587: POP
62588: POP
// end else
62589: GO 62599
// result := false ;
62591: LD_ADDR_VAR 0 3
62595: PUSH
62596: LD_INT 0
62598: ST_TO_ADDR
// end ;
62599: LD_VAR 0 3
62603: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62604: LD_INT 0
62606: PPUSH
62607: PPUSH
// if not array1 or not array2 then
62608: LD_VAR 0 1
62612: NOT
62613: PUSH
62614: LD_VAR 0 2
62618: NOT
62619: OR
62620: IFFALSE 62624
// exit ;
62622: GO 62688
// result := true ;
62624: LD_ADDR_VAR 0 3
62628: PUSH
62629: LD_INT 1
62631: ST_TO_ADDR
// for i = 1 to array1 do
62632: LD_ADDR_VAR 0 4
62636: PUSH
62637: DOUBLE
62638: LD_INT 1
62640: DEC
62641: ST_TO_ADDR
62642: LD_VAR 0 1
62646: PUSH
62647: FOR_TO
62648: IFFALSE 62686
// if array1 [ i ] <> array2 [ i ] then
62650: LD_VAR 0 1
62654: PUSH
62655: LD_VAR 0 4
62659: ARRAY
62660: PUSH
62661: LD_VAR 0 2
62665: PUSH
62666: LD_VAR 0 4
62670: ARRAY
62671: NONEQUAL
62672: IFFALSE 62684
// begin result := false ;
62674: LD_ADDR_VAR 0 3
62678: PUSH
62679: LD_INT 0
62681: ST_TO_ADDR
// break ;
62682: GO 62686
// end ;
62684: GO 62647
62686: POP
62687: POP
// end ;
62688: LD_VAR 0 3
62692: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62693: LD_INT 0
62695: PPUSH
62696: PPUSH
62697: PPUSH
// pom := GetBase ( fac ) ;
62698: LD_ADDR_VAR 0 5
62702: PUSH
62703: LD_VAR 0 1
62707: PPUSH
62708: CALL_OW 274
62712: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62713: LD_ADDR_VAR 0 4
62717: PUSH
62718: LD_VAR 0 2
62722: PUSH
62723: LD_INT 1
62725: ARRAY
62726: PPUSH
62727: LD_VAR 0 2
62731: PUSH
62732: LD_INT 2
62734: ARRAY
62735: PPUSH
62736: LD_VAR 0 2
62740: PUSH
62741: LD_INT 3
62743: ARRAY
62744: PPUSH
62745: LD_VAR 0 2
62749: PUSH
62750: LD_INT 4
62752: ARRAY
62753: PPUSH
62754: CALL_OW 449
62758: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62759: LD_ADDR_VAR 0 3
62763: PUSH
62764: LD_VAR 0 5
62768: PPUSH
62769: LD_INT 1
62771: PPUSH
62772: CALL_OW 275
62776: PUSH
62777: LD_VAR 0 4
62781: PUSH
62782: LD_INT 1
62784: ARRAY
62785: GREATEREQUAL
62786: PUSH
62787: LD_VAR 0 5
62791: PPUSH
62792: LD_INT 2
62794: PPUSH
62795: CALL_OW 275
62799: PUSH
62800: LD_VAR 0 4
62804: PUSH
62805: LD_INT 2
62807: ARRAY
62808: GREATEREQUAL
62809: AND
62810: PUSH
62811: LD_VAR 0 5
62815: PPUSH
62816: LD_INT 3
62818: PPUSH
62819: CALL_OW 275
62823: PUSH
62824: LD_VAR 0 4
62828: PUSH
62829: LD_INT 3
62831: ARRAY
62832: GREATEREQUAL
62833: AND
62834: ST_TO_ADDR
// end ;
62835: LD_VAR 0 3
62839: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62840: LD_INT 0
62842: PPUSH
62843: PPUSH
62844: PPUSH
62845: PPUSH
// pom := GetBase ( building ) ;
62846: LD_ADDR_VAR 0 3
62850: PUSH
62851: LD_VAR 0 1
62855: PPUSH
62856: CALL_OW 274
62860: ST_TO_ADDR
// if not pom then
62861: LD_VAR 0 3
62865: NOT
62866: IFFALSE 62870
// exit ;
62868: GO 63040
// btype := GetBType ( building ) ;
62870: LD_ADDR_VAR 0 5
62874: PUSH
62875: LD_VAR 0 1
62879: PPUSH
62880: CALL_OW 266
62884: ST_TO_ADDR
// if btype = b_armoury then
62885: LD_VAR 0 5
62889: PUSH
62890: LD_INT 4
62892: EQUAL
62893: IFFALSE 62903
// btype := b_barracks ;
62895: LD_ADDR_VAR 0 5
62899: PUSH
62900: LD_INT 5
62902: ST_TO_ADDR
// if btype = b_depot then
62903: LD_VAR 0 5
62907: PUSH
62908: LD_INT 0
62910: EQUAL
62911: IFFALSE 62921
// btype := b_warehouse ;
62913: LD_ADDR_VAR 0 5
62917: PUSH
62918: LD_INT 1
62920: ST_TO_ADDR
// if btype = b_workshop then
62921: LD_VAR 0 5
62925: PUSH
62926: LD_INT 2
62928: EQUAL
62929: IFFALSE 62939
// btype := b_factory ;
62931: LD_ADDR_VAR 0 5
62935: PUSH
62936: LD_INT 3
62938: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62939: LD_ADDR_VAR 0 4
62943: PUSH
62944: LD_VAR 0 5
62948: PPUSH
62949: LD_VAR 0 1
62953: PPUSH
62954: CALL_OW 248
62958: PPUSH
62959: CALL_OW 450
62963: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62964: LD_ADDR_VAR 0 2
62968: PUSH
62969: LD_VAR 0 3
62973: PPUSH
62974: LD_INT 1
62976: PPUSH
62977: CALL_OW 275
62981: PUSH
62982: LD_VAR 0 4
62986: PUSH
62987: LD_INT 1
62989: ARRAY
62990: GREATEREQUAL
62991: PUSH
62992: LD_VAR 0 3
62996: PPUSH
62997: LD_INT 2
62999: PPUSH
63000: CALL_OW 275
63004: PUSH
63005: LD_VAR 0 4
63009: PUSH
63010: LD_INT 2
63012: ARRAY
63013: GREATEREQUAL
63014: AND
63015: PUSH
63016: LD_VAR 0 3
63020: PPUSH
63021: LD_INT 3
63023: PPUSH
63024: CALL_OW 275
63028: PUSH
63029: LD_VAR 0 4
63033: PUSH
63034: LD_INT 3
63036: ARRAY
63037: GREATEREQUAL
63038: AND
63039: ST_TO_ADDR
// end ;
63040: LD_VAR 0 2
63044: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63045: LD_INT 0
63047: PPUSH
63048: PPUSH
63049: PPUSH
// pom := GetBase ( building ) ;
63050: LD_ADDR_VAR 0 4
63054: PUSH
63055: LD_VAR 0 1
63059: PPUSH
63060: CALL_OW 274
63064: ST_TO_ADDR
// if not pom then
63065: LD_VAR 0 4
63069: NOT
63070: IFFALSE 63074
// exit ;
63072: GO 63175
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63074: LD_ADDR_VAR 0 5
63078: PUSH
63079: LD_VAR 0 2
63083: PPUSH
63084: LD_VAR 0 1
63088: PPUSH
63089: CALL_OW 248
63093: PPUSH
63094: CALL_OW 450
63098: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63099: LD_ADDR_VAR 0 3
63103: PUSH
63104: LD_VAR 0 4
63108: PPUSH
63109: LD_INT 1
63111: PPUSH
63112: CALL_OW 275
63116: PUSH
63117: LD_VAR 0 5
63121: PUSH
63122: LD_INT 1
63124: ARRAY
63125: GREATEREQUAL
63126: PUSH
63127: LD_VAR 0 4
63131: PPUSH
63132: LD_INT 2
63134: PPUSH
63135: CALL_OW 275
63139: PUSH
63140: LD_VAR 0 5
63144: PUSH
63145: LD_INT 2
63147: ARRAY
63148: GREATEREQUAL
63149: AND
63150: PUSH
63151: LD_VAR 0 4
63155: PPUSH
63156: LD_INT 3
63158: PPUSH
63159: CALL_OW 275
63163: PUSH
63164: LD_VAR 0 5
63168: PUSH
63169: LD_INT 3
63171: ARRAY
63172: GREATEREQUAL
63173: AND
63174: ST_TO_ADDR
// end ;
63175: LD_VAR 0 3
63179: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63180: LD_INT 0
63182: PPUSH
63183: PPUSH
63184: PPUSH
63185: PPUSH
63186: PPUSH
63187: PPUSH
63188: PPUSH
63189: PPUSH
63190: PPUSH
63191: PPUSH
63192: PPUSH
// result := false ;
63193: LD_ADDR_VAR 0 8
63197: PUSH
63198: LD_INT 0
63200: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63201: LD_VAR 0 5
63205: NOT
63206: PUSH
63207: LD_VAR 0 1
63211: NOT
63212: OR
63213: PUSH
63214: LD_VAR 0 2
63218: NOT
63219: OR
63220: PUSH
63221: LD_VAR 0 3
63225: NOT
63226: OR
63227: IFFALSE 63231
// exit ;
63229: GO 64045
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63231: LD_ADDR_VAR 0 14
63235: PUSH
63236: LD_VAR 0 1
63240: PPUSH
63241: LD_VAR 0 2
63245: PPUSH
63246: LD_VAR 0 3
63250: PPUSH
63251: LD_VAR 0 4
63255: PPUSH
63256: LD_VAR 0 5
63260: PUSH
63261: LD_INT 1
63263: ARRAY
63264: PPUSH
63265: CALL_OW 248
63269: PPUSH
63270: LD_INT 0
63272: PPUSH
63273: CALL 65282 0 6
63277: ST_TO_ADDR
// if not hexes then
63278: LD_VAR 0 14
63282: NOT
63283: IFFALSE 63287
// exit ;
63285: GO 64045
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63287: LD_ADDR_VAR 0 17
63291: PUSH
63292: LD_VAR 0 5
63296: PPUSH
63297: LD_INT 22
63299: PUSH
63300: LD_VAR 0 13
63304: PPUSH
63305: CALL_OW 255
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 2
63316: PUSH
63317: LD_INT 30
63319: PUSH
63320: LD_INT 0
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 30
63329: PUSH
63330: LD_INT 1
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: LIST
63341: PUSH
63342: EMPTY
63343: LIST
63344: LIST
63345: PPUSH
63346: CALL_OW 72
63350: ST_TO_ADDR
// for i = 1 to hexes do
63351: LD_ADDR_VAR 0 9
63355: PUSH
63356: DOUBLE
63357: LD_INT 1
63359: DEC
63360: ST_TO_ADDR
63361: LD_VAR 0 14
63365: PUSH
63366: FOR_TO
63367: IFFALSE 64043
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63369: LD_ADDR_VAR 0 13
63373: PUSH
63374: LD_VAR 0 14
63378: PUSH
63379: LD_VAR 0 9
63383: ARRAY
63384: PUSH
63385: LD_INT 1
63387: ARRAY
63388: PPUSH
63389: LD_VAR 0 14
63393: PUSH
63394: LD_VAR 0 9
63398: ARRAY
63399: PUSH
63400: LD_INT 2
63402: ARRAY
63403: PPUSH
63404: CALL_OW 428
63408: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63409: LD_VAR 0 14
63413: PUSH
63414: LD_VAR 0 9
63418: ARRAY
63419: PUSH
63420: LD_INT 1
63422: ARRAY
63423: PPUSH
63424: LD_VAR 0 14
63428: PUSH
63429: LD_VAR 0 9
63433: ARRAY
63434: PUSH
63435: LD_INT 2
63437: ARRAY
63438: PPUSH
63439: CALL_OW 351
63443: PUSH
63444: LD_VAR 0 14
63448: PUSH
63449: LD_VAR 0 9
63453: ARRAY
63454: PUSH
63455: LD_INT 1
63457: ARRAY
63458: PPUSH
63459: LD_VAR 0 14
63463: PUSH
63464: LD_VAR 0 9
63468: ARRAY
63469: PUSH
63470: LD_INT 2
63472: ARRAY
63473: PPUSH
63474: CALL_OW 488
63478: NOT
63479: OR
63480: PUSH
63481: LD_VAR 0 13
63485: PPUSH
63486: CALL_OW 247
63490: PUSH
63491: LD_INT 3
63493: EQUAL
63494: OR
63495: IFFALSE 63501
// exit ;
63497: POP
63498: POP
63499: GO 64045
// if not tmp then
63501: LD_VAR 0 13
63505: NOT
63506: IFFALSE 63510
// continue ;
63508: GO 63366
// result := true ;
63510: LD_ADDR_VAR 0 8
63514: PUSH
63515: LD_INT 1
63517: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63518: LD_VAR 0 6
63522: PUSH
63523: LD_VAR 0 13
63527: PPUSH
63528: CALL_OW 247
63532: PUSH
63533: LD_INT 2
63535: EQUAL
63536: AND
63537: PUSH
63538: LD_VAR 0 13
63542: PPUSH
63543: CALL_OW 263
63547: PUSH
63548: LD_INT 1
63550: EQUAL
63551: AND
63552: IFFALSE 63716
// begin if IsDrivenBy ( tmp ) then
63554: LD_VAR 0 13
63558: PPUSH
63559: CALL_OW 311
63563: IFFALSE 63567
// continue ;
63565: GO 63366
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63567: LD_VAR 0 6
63571: PPUSH
63572: LD_INT 3
63574: PUSH
63575: LD_INT 60
63577: PUSH
63578: EMPTY
63579: LIST
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: PUSH
63585: LD_INT 3
63587: PUSH
63588: LD_INT 55
63590: PUSH
63591: EMPTY
63592: LIST
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PPUSH
63602: CALL_OW 72
63606: IFFALSE 63714
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63608: LD_ADDR_VAR 0 18
63612: PUSH
63613: LD_VAR 0 6
63617: PPUSH
63618: LD_INT 3
63620: PUSH
63621: LD_INT 60
63623: PUSH
63624: EMPTY
63625: LIST
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PUSH
63631: LD_INT 3
63633: PUSH
63634: LD_INT 55
63636: PUSH
63637: EMPTY
63638: LIST
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PPUSH
63648: CALL_OW 72
63652: PUSH
63653: LD_INT 1
63655: ARRAY
63656: ST_TO_ADDR
// if IsInUnit ( driver ) then
63657: LD_VAR 0 18
63661: PPUSH
63662: CALL_OW 310
63666: IFFALSE 63677
// ComExit ( driver ) ;
63668: LD_VAR 0 18
63672: PPUSH
63673: CALL 88466 0 1
// AddComEnterUnit ( driver , tmp ) ;
63677: LD_VAR 0 18
63681: PPUSH
63682: LD_VAR 0 13
63686: PPUSH
63687: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63691: LD_VAR 0 18
63695: PPUSH
63696: LD_VAR 0 7
63700: PPUSH
63701: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63705: LD_VAR 0 18
63709: PPUSH
63710: CALL_OW 181
// end ; continue ;
63714: GO 63366
// end ; if not cleaners or not tmp in cleaners then
63716: LD_VAR 0 6
63720: NOT
63721: PUSH
63722: LD_VAR 0 13
63726: PUSH
63727: LD_VAR 0 6
63731: IN
63732: NOT
63733: OR
63734: IFFALSE 64041
// begin if dep then
63736: LD_VAR 0 17
63740: IFFALSE 63876
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63742: LD_ADDR_VAR 0 16
63746: PUSH
63747: LD_VAR 0 17
63751: PUSH
63752: LD_INT 1
63754: ARRAY
63755: PPUSH
63756: CALL_OW 250
63760: PPUSH
63761: LD_VAR 0 17
63765: PUSH
63766: LD_INT 1
63768: ARRAY
63769: PPUSH
63770: CALL_OW 254
63774: PPUSH
63775: LD_INT 5
63777: PPUSH
63778: CALL_OW 272
63782: PUSH
63783: LD_VAR 0 17
63787: PUSH
63788: LD_INT 1
63790: ARRAY
63791: PPUSH
63792: CALL_OW 251
63796: PPUSH
63797: LD_VAR 0 17
63801: PUSH
63802: LD_INT 1
63804: ARRAY
63805: PPUSH
63806: CALL_OW 254
63810: PPUSH
63811: LD_INT 5
63813: PPUSH
63814: CALL_OW 273
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63823: LD_VAR 0 16
63827: PUSH
63828: LD_INT 1
63830: ARRAY
63831: PPUSH
63832: LD_VAR 0 16
63836: PUSH
63837: LD_INT 2
63839: ARRAY
63840: PPUSH
63841: CALL_OW 488
63845: IFFALSE 63876
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63847: LD_VAR 0 13
63851: PPUSH
63852: LD_VAR 0 16
63856: PUSH
63857: LD_INT 1
63859: ARRAY
63860: PPUSH
63861: LD_VAR 0 16
63865: PUSH
63866: LD_INT 2
63868: ARRAY
63869: PPUSH
63870: CALL_OW 111
// continue ;
63874: GO 63366
// end ; end ; r := GetDir ( tmp ) ;
63876: LD_ADDR_VAR 0 15
63880: PUSH
63881: LD_VAR 0 13
63885: PPUSH
63886: CALL_OW 254
63890: ST_TO_ADDR
// if r = 5 then
63891: LD_VAR 0 15
63895: PUSH
63896: LD_INT 5
63898: EQUAL
63899: IFFALSE 63909
// r := 0 ;
63901: LD_ADDR_VAR 0 15
63905: PUSH
63906: LD_INT 0
63908: ST_TO_ADDR
// for j = r to 5 do
63909: LD_ADDR_VAR 0 10
63913: PUSH
63914: DOUBLE
63915: LD_VAR 0 15
63919: DEC
63920: ST_TO_ADDR
63921: LD_INT 5
63923: PUSH
63924: FOR_TO
63925: IFFALSE 64039
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63927: LD_ADDR_VAR 0 11
63931: PUSH
63932: LD_VAR 0 13
63936: PPUSH
63937: CALL_OW 250
63941: PPUSH
63942: LD_VAR 0 10
63946: PPUSH
63947: LD_INT 2
63949: PPUSH
63950: CALL_OW 272
63954: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63955: LD_ADDR_VAR 0 12
63959: PUSH
63960: LD_VAR 0 13
63964: PPUSH
63965: CALL_OW 251
63969: PPUSH
63970: LD_VAR 0 10
63974: PPUSH
63975: LD_INT 2
63977: PPUSH
63978: CALL_OW 273
63982: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63983: LD_VAR 0 11
63987: PPUSH
63988: LD_VAR 0 12
63992: PPUSH
63993: CALL_OW 488
63997: PUSH
63998: LD_VAR 0 11
64002: PPUSH
64003: LD_VAR 0 12
64007: PPUSH
64008: CALL_OW 428
64012: NOT
64013: AND
64014: IFFALSE 64037
// begin ComMoveXY ( tmp , _x , _y ) ;
64016: LD_VAR 0 13
64020: PPUSH
64021: LD_VAR 0 11
64025: PPUSH
64026: LD_VAR 0 12
64030: PPUSH
64031: CALL_OW 111
// break ;
64035: GO 64039
// end ; end ;
64037: GO 63924
64039: POP
64040: POP
// end ; end ;
64041: GO 63366
64043: POP
64044: POP
// end ;
64045: LD_VAR 0 8
64049: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64050: LD_INT 0
64052: PPUSH
// result := true ;
64053: LD_ADDR_VAR 0 3
64057: PUSH
64058: LD_INT 1
64060: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64061: LD_VAR 0 2
64065: PUSH
64066: LD_INT 24
64068: DOUBLE
64069: EQUAL
64070: IFTRUE 64080
64072: LD_INT 33
64074: DOUBLE
64075: EQUAL
64076: IFTRUE 64080
64078: GO 64105
64080: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64081: LD_ADDR_VAR 0 3
64085: PUSH
64086: LD_INT 32
64088: PPUSH
64089: LD_VAR 0 1
64093: PPUSH
64094: CALL_OW 321
64098: PUSH
64099: LD_INT 2
64101: EQUAL
64102: ST_TO_ADDR
64103: GO 64425
64105: LD_INT 20
64107: DOUBLE
64108: EQUAL
64109: IFTRUE 64113
64111: GO 64138
64113: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64114: LD_ADDR_VAR 0 3
64118: PUSH
64119: LD_INT 6
64121: PPUSH
64122: LD_VAR 0 1
64126: PPUSH
64127: CALL_OW 321
64131: PUSH
64132: LD_INT 2
64134: EQUAL
64135: ST_TO_ADDR
64136: GO 64425
64138: LD_INT 22
64140: DOUBLE
64141: EQUAL
64142: IFTRUE 64152
64144: LD_INT 36
64146: DOUBLE
64147: EQUAL
64148: IFTRUE 64152
64150: GO 64177
64152: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64153: LD_ADDR_VAR 0 3
64157: PUSH
64158: LD_INT 15
64160: PPUSH
64161: LD_VAR 0 1
64165: PPUSH
64166: CALL_OW 321
64170: PUSH
64171: LD_INT 2
64173: EQUAL
64174: ST_TO_ADDR
64175: GO 64425
64177: LD_INT 30
64179: DOUBLE
64180: EQUAL
64181: IFTRUE 64185
64183: GO 64210
64185: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64186: LD_ADDR_VAR 0 3
64190: PUSH
64191: LD_INT 20
64193: PPUSH
64194: LD_VAR 0 1
64198: PPUSH
64199: CALL_OW 321
64203: PUSH
64204: LD_INT 2
64206: EQUAL
64207: ST_TO_ADDR
64208: GO 64425
64210: LD_INT 28
64212: DOUBLE
64213: EQUAL
64214: IFTRUE 64224
64216: LD_INT 21
64218: DOUBLE
64219: EQUAL
64220: IFTRUE 64224
64222: GO 64249
64224: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64225: LD_ADDR_VAR 0 3
64229: PUSH
64230: LD_INT 21
64232: PPUSH
64233: LD_VAR 0 1
64237: PPUSH
64238: CALL_OW 321
64242: PUSH
64243: LD_INT 2
64245: EQUAL
64246: ST_TO_ADDR
64247: GO 64425
64249: LD_INT 16
64251: DOUBLE
64252: EQUAL
64253: IFTRUE 64257
64255: GO 64284
64257: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64258: LD_ADDR_VAR 0 3
64262: PUSH
64263: LD_EXP 84
64267: PPUSH
64268: LD_VAR 0 1
64272: PPUSH
64273: CALL_OW 321
64277: PUSH
64278: LD_INT 2
64280: EQUAL
64281: ST_TO_ADDR
64282: GO 64425
64284: LD_INT 19
64286: DOUBLE
64287: EQUAL
64288: IFTRUE 64298
64290: LD_INT 23
64292: DOUBLE
64293: EQUAL
64294: IFTRUE 64298
64296: GO 64325
64298: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64299: LD_ADDR_VAR 0 3
64303: PUSH
64304: LD_EXP 83
64308: PPUSH
64309: LD_VAR 0 1
64313: PPUSH
64314: CALL_OW 321
64318: PUSH
64319: LD_INT 2
64321: EQUAL
64322: ST_TO_ADDR
64323: GO 64425
64325: LD_INT 17
64327: DOUBLE
64328: EQUAL
64329: IFTRUE 64333
64331: GO 64358
64333: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64334: LD_ADDR_VAR 0 3
64338: PUSH
64339: LD_INT 39
64341: PPUSH
64342: LD_VAR 0 1
64346: PPUSH
64347: CALL_OW 321
64351: PUSH
64352: LD_INT 2
64354: EQUAL
64355: ST_TO_ADDR
64356: GO 64425
64358: LD_INT 18
64360: DOUBLE
64361: EQUAL
64362: IFTRUE 64366
64364: GO 64391
64366: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64367: LD_ADDR_VAR 0 3
64371: PUSH
64372: LD_INT 40
64374: PPUSH
64375: LD_VAR 0 1
64379: PPUSH
64380: CALL_OW 321
64384: PUSH
64385: LD_INT 2
64387: EQUAL
64388: ST_TO_ADDR
64389: GO 64425
64391: LD_INT 27
64393: DOUBLE
64394: EQUAL
64395: IFTRUE 64399
64397: GO 64424
64399: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64400: LD_ADDR_VAR 0 3
64404: PUSH
64405: LD_INT 35
64407: PPUSH
64408: LD_VAR 0 1
64412: PPUSH
64413: CALL_OW 321
64417: PUSH
64418: LD_INT 2
64420: EQUAL
64421: ST_TO_ADDR
64422: GO 64425
64424: POP
// end ;
64425: LD_VAR 0 3
64429: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64430: LD_INT 0
64432: PPUSH
64433: PPUSH
64434: PPUSH
64435: PPUSH
64436: PPUSH
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
64441: PPUSH
64442: PPUSH
// result := false ;
64443: LD_ADDR_VAR 0 6
64447: PUSH
64448: LD_INT 0
64450: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64451: LD_VAR 0 1
64455: NOT
64456: PUSH
64457: LD_VAR 0 1
64461: PPUSH
64462: CALL_OW 266
64466: PUSH
64467: LD_INT 0
64469: PUSH
64470: LD_INT 1
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: IN
64477: NOT
64478: OR
64479: PUSH
64480: LD_VAR 0 2
64484: NOT
64485: OR
64486: PUSH
64487: LD_VAR 0 5
64491: PUSH
64492: LD_INT 0
64494: PUSH
64495: LD_INT 1
64497: PUSH
64498: LD_INT 2
64500: PUSH
64501: LD_INT 3
64503: PUSH
64504: LD_INT 4
64506: PUSH
64507: LD_INT 5
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: IN
64518: NOT
64519: OR
64520: PUSH
64521: LD_VAR 0 3
64525: PPUSH
64526: LD_VAR 0 4
64530: PPUSH
64531: CALL_OW 488
64535: NOT
64536: OR
64537: IFFALSE 64541
// exit ;
64539: GO 65277
// side := GetSide ( depot ) ;
64541: LD_ADDR_VAR 0 9
64545: PUSH
64546: LD_VAR 0 1
64550: PPUSH
64551: CALL_OW 255
64555: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64556: LD_VAR 0 9
64560: PPUSH
64561: LD_VAR 0 2
64565: PPUSH
64566: CALL 64050 0 2
64570: NOT
64571: IFFALSE 64575
// exit ;
64573: GO 65277
// pom := GetBase ( depot ) ;
64575: LD_ADDR_VAR 0 10
64579: PUSH
64580: LD_VAR 0 1
64584: PPUSH
64585: CALL_OW 274
64589: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64590: LD_ADDR_VAR 0 11
64594: PUSH
64595: LD_VAR 0 2
64599: PPUSH
64600: LD_VAR 0 1
64604: PPUSH
64605: CALL_OW 248
64609: PPUSH
64610: CALL_OW 450
64614: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64615: LD_VAR 0 10
64619: PPUSH
64620: LD_INT 1
64622: PPUSH
64623: CALL_OW 275
64627: PUSH
64628: LD_VAR 0 11
64632: PUSH
64633: LD_INT 1
64635: ARRAY
64636: GREATEREQUAL
64637: PUSH
64638: LD_VAR 0 10
64642: PPUSH
64643: LD_INT 2
64645: PPUSH
64646: CALL_OW 275
64650: PUSH
64651: LD_VAR 0 11
64655: PUSH
64656: LD_INT 2
64658: ARRAY
64659: GREATEREQUAL
64660: AND
64661: PUSH
64662: LD_VAR 0 10
64666: PPUSH
64667: LD_INT 3
64669: PPUSH
64670: CALL_OW 275
64674: PUSH
64675: LD_VAR 0 11
64679: PUSH
64680: LD_INT 3
64682: ARRAY
64683: GREATEREQUAL
64684: AND
64685: NOT
64686: IFFALSE 64690
// exit ;
64688: GO 65277
// if GetBType ( depot ) = b_depot then
64690: LD_VAR 0 1
64694: PPUSH
64695: CALL_OW 266
64699: PUSH
64700: LD_INT 0
64702: EQUAL
64703: IFFALSE 64715
// dist := 28 else
64705: LD_ADDR_VAR 0 14
64709: PUSH
64710: LD_INT 28
64712: ST_TO_ADDR
64713: GO 64723
// dist := 36 ;
64715: LD_ADDR_VAR 0 14
64719: PUSH
64720: LD_INT 36
64722: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64723: LD_VAR 0 1
64727: PPUSH
64728: LD_VAR 0 3
64732: PPUSH
64733: LD_VAR 0 4
64737: PPUSH
64738: CALL_OW 297
64742: PUSH
64743: LD_VAR 0 14
64747: GREATER
64748: IFFALSE 64752
// exit ;
64750: GO 65277
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64752: LD_ADDR_VAR 0 12
64756: PUSH
64757: LD_VAR 0 2
64761: PPUSH
64762: LD_VAR 0 3
64766: PPUSH
64767: LD_VAR 0 4
64771: PPUSH
64772: LD_VAR 0 5
64776: PPUSH
64777: LD_VAR 0 1
64781: PPUSH
64782: CALL_OW 248
64786: PPUSH
64787: LD_INT 0
64789: PPUSH
64790: CALL 65282 0 6
64794: ST_TO_ADDR
// if not hexes then
64795: LD_VAR 0 12
64799: NOT
64800: IFFALSE 64804
// exit ;
64802: GO 65277
// hex := GetHexInfo ( x , y ) ;
64804: LD_ADDR_VAR 0 15
64808: PUSH
64809: LD_VAR 0 3
64813: PPUSH
64814: LD_VAR 0 4
64818: PPUSH
64819: CALL_OW 546
64823: ST_TO_ADDR
// if hex [ 1 ] then
64824: LD_VAR 0 15
64828: PUSH
64829: LD_INT 1
64831: ARRAY
64832: IFFALSE 64836
// exit ;
64834: GO 65277
// height := hex [ 2 ] ;
64836: LD_ADDR_VAR 0 13
64840: PUSH
64841: LD_VAR 0 15
64845: PUSH
64846: LD_INT 2
64848: ARRAY
64849: ST_TO_ADDR
// for i = 1 to hexes do
64850: LD_ADDR_VAR 0 7
64854: PUSH
64855: DOUBLE
64856: LD_INT 1
64858: DEC
64859: ST_TO_ADDR
64860: LD_VAR 0 12
64864: PUSH
64865: FOR_TO
64866: IFFALSE 65196
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64868: LD_VAR 0 12
64872: PUSH
64873: LD_VAR 0 7
64877: ARRAY
64878: PUSH
64879: LD_INT 1
64881: ARRAY
64882: PPUSH
64883: LD_VAR 0 12
64887: PUSH
64888: LD_VAR 0 7
64892: ARRAY
64893: PUSH
64894: LD_INT 2
64896: ARRAY
64897: PPUSH
64898: CALL_OW 488
64902: NOT
64903: PUSH
64904: LD_VAR 0 12
64908: PUSH
64909: LD_VAR 0 7
64913: ARRAY
64914: PUSH
64915: LD_INT 1
64917: ARRAY
64918: PPUSH
64919: LD_VAR 0 12
64923: PUSH
64924: LD_VAR 0 7
64928: ARRAY
64929: PUSH
64930: LD_INT 2
64932: ARRAY
64933: PPUSH
64934: CALL_OW 428
64938: PUSH
64939: LD_INT 0
64941: GREATER
64942: OR
64943: PUSH
64944: LD_VAR 0 12
64948: PUSH
64949: LD_VAR 0 7
64953: ARRAY
64954: PUSH
64955: LD_INT 1
64957: ARRAY
64958: PPUSH
64959: LD_VAR 0 12
64963: PUSH
64964: LD_VAR 0 7
64968: ARRAY
64969: PUSH
64970: LD_INT 2
64972: ARRAY
64973: PPUSH
64974: CALL_OW 351
64978: OR
64979: IFFALSE 64985
// exit ;
64981: POP
64982: POP
64983: GO 65277
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64985: LD_ADDR_VAR 0 8
64989: PUSH
64990: LD_VAR 0 12
64994: PUSH
64995: LD_VAR 0 7
64999: ARRAY
65000: PUSH
65001: LD_INT 1
65003: ARRAY
65004: PPUSH
65005: LD_VAR 0 12
65009: PUSH
65010: LD_VAR 0 7
65014: ARRAY
65015: PUSH
65016: LD_INT 2
65018: ARRAY
65019: PPUSH
65020: CALL_OW 546
65024: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65025: LD_VAR 0 8
65029: PUSH
65030: LD_INT 1
65032: ARRAY
65033: PUSH
65034: LD_VAR 0 8
65038: PUSH
65039: LD_INT 2
65041: ARRAY
65042: PUSH
65043: LD_VAR 0 13
65047: PUSH
65048: LD_INT 2
65050: PLUS
65051: GREATER
65052: OR
65053: PUSH
65054: LD_VAR 0 8
65058: PUSH
65059: LD_INT 2
65061: ARRAY
65062: PUSH
65063: LD_VAR 0 13
65067: PUSH
65068: LD_INT 2
65070: MINUS
65071: LESS
65072: OR
65073: PUSH
65074: LD_VAR 0 8
65078: PUSH
65079: LD_INT 3
65081: ARRAY
65082: PUSH
65083: LD_INT 0
65085: PUSH
65086: LD_INT 8
65088: PUSH
65089: LD_INT 9
65091: PUSH
65092: LD_INT 10
65094: PUSH
65095: LD_INT 11
65097: PUSH
65098: LD_INT 12
65100: PUSH
65101: LD_INT 13
65103: PUSH
65104: LD_INT 16
65106: PUSH
65107: LD_INT 17
65109: PUSH
65110: LD_INT 18
65112: PUSH
65113: LD_INT 19
65115: PUSH
65116: LD_INT 20
65118: PUSH
65119: LD_INT 21
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: LIST
65126: LIST
65127: LIST
65128: LIST
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: IN
65137: NOT
65138: OR
65139: PUSH
65140: LD_VAR 0 8
65144: PUSH
65145: LD_INT 5
65147: ARRAY
65148: NOT
65149: OR
65150: PUSH
65151: LD_VAR 0 8
65155: PUSH
65156: LD_INT 6
65158: ARRAY
65159: PUSH
65160: LD_INT 1
65162: PUSH
65163: LD_INT 2
65165: PUSH
65166: LD_INT 7
65168: PUSH
65169: LD_INT 9
65171: PUSH
65172: LD_INT 10
65174: PUSH
65175: LD_INT 11
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: LIST
65185: IN
65186: NOT
65187: OR
65188: IFFALSE 65194
// exit ;
65190: POP
65191: POP
65192: GO 65277
// end ;
65194: GO 64865
65196: POP
65197: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65198: LD_VAR 0 9
65202: PPUSH
65203: LD_VAR 0 3
65207: PPUSH
65208: LD_VAR 0 4
65212: PPUSH
65213: LD_INT 20
65215: PPUSH
65216: CALL 57223 0 4
65220: PUSH
65221: LD_INT 4
65223: ARRAY
65224: IFFALSE 65228
// exit ;
65226: GO 65277
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65228: LD_VAR 0 2
65232: PUSH
65233: LD_INT 29
65235: PUSH
65236: LD_INT 30
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: IN
65243: PUSH
65244: LD_VAR 0 3
65248: PPUSH
65249: LD_VAR 0 4
65253: PPUSH
65254: LD_VAR 0 9
65258: PPUSH
65259: CALL_OW 440
65263: NOT
65264: AND
65265: IFFALSE 65269
// exit ;
65267: GO 65277
// result := true ;
65269: LD_ADDR_VAR 0 6
65273: PUSH
65274: LD_INT 1
65276: ST_TO_ADDR
// end ;
65277: LD_VAR 0 6
65281: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65282: LD_INT 0
65284: PPUSH
65285: PPUSH
65286: PPUSH
65287: PPUSH
65288: PPUSH
65289: PPUSH
65290: PPUSH
65291: PPUSH
65292: PPUSH
65293: PPUSH
65294: PPUSH
65295: PPUSH
65296: PPUSH
65297: PPUSH
65298: PPUSH
65299: PPUSH
65300: PPUSH
65301: PPUSH
65302: PPUSH
65303: PPUSH
65304: PPUSH
65305: PPUSH
65306: PPUSH
65307: PPUSH
65308: PPUSH
65309: PPUSH
65310: PPUSH
65311: PPUSH
65312: PPUSH
65313: PPUSH
65314: PPUSH
65315: PPUSH
65316: PPUSH
65317: PPUSH
65318: PPUSH
65319: PPUSH
65320: PPUSH
65321: PPUSH
65322: PPUSH
65323: PPUSH
65324: PPUSH
65325: PPUSH
65326: PPUSH
65327: PPUSH
65328: PPUSH
65329: PPUSH
65330: PPUSH
65331: PPUSH
65332: PPUSH
65333: PPUSH
65334: PPUSH
65335: PPUSH
65336: PPUSH
65337: PPUSH
65338: PPUSH
65339: PPUSH
65340: PPUSH
65341: PPUSH
// result = [ ] ;
65342: LD_ADDR_VAR 0 7
65346: PUSH
65347: EMPTY
65348: ST_TO_ADDR
// temp_list = [ ] ;
65349: LD_ADDR_VAR 0 9
65353: PUSH
65354: EMPTY
65355: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65356: LD_VAR 0 4
65360: PUSH
65361: LD_INT 0
65363: PUSH
65364: LD_INT 1
65366: PUSH
65367: LD_INT 2
65369: PUSH
65370: LD_INT 3
65372: PUSH
65373: LD_INT 4
65375: PUSH
65376: LD_INT 5
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: IN
65387: NOT
65388: PUSH
65389: LD_VAR 0 1
65393: PUSH
65394: LD_INT 0
65396: PUSH
65397: LD_INT 1
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: IN
65404: PUSH
65405: LD_VAR 0 5
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: LD_INT 2
65415: PUSH
65416: LD_INT 3
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: LIST
65423: IN
65424: NOT
65425: AND
65426: OR
65427: IFFALSE 65431
// exit ;
65429: GO 83822
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65431: LD_VAR 0 1
65435: PUSH
65436: LD_INT 6
65438: PUSH
65439: LD_INT 7
65441: PUSH
65442: LD_INT 8
65444: PUSH
65445: LD_INT 13
65447: PUSH
65448: LD_INT 12
65450: PUSH
65451: LD_INT 15
65453: PUSH
65454: LD_INT 11
65456: PUSH
65457: LD_INT 14
65459: PUSH
65460: LD_INT 10
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: IN
65474: IFFALSE 65484
// btype = b_lab ;
65476: LD_ADDR_VAR 0 1
65480: PUSH
65481: LD_INT 6
65483: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65484: LD_VAR 0 6
65488: PUSH
65489: LD_INT 0
65491: PUSH
65492: LD_INT 1
65494: PUSH
65495: LD_INT 2
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: LIST
65502: IN
65503: NOT
65504: PUSH
65505: LD_VAR 0 1
65509: PUSH
65510: LD_INT 0
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 2
65518: PUSH
65519: LD_INT 3
65521: PUSH
65522: LD_INT 6
65524: PUSH
65525: LD_INT 36
65527: PUSH
65528: LD_INT 4
65530: PUSH
65531: LD_INT 5
65533: PUSH
65534: LD_INT 31
65536: PUSH
65537: LD_INT 32
65539: PUSH
65540: LD_INT 33
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: LIST
65549: LIST
65550: LIST
65551: LIST
65552: LIST
65553: LIST
65554: LIST
65555: IN
65556: NOT
65557: PUSH
65558: LD_VAR 0 6
65562: PUSH
65563: LD_INT 1
65565: EQUAL
65566: AND
65567: OR
65568: PUSH
65569: LD_VAR 0 1
65573: PUSH
65574: LD_INT 2
65576: PUSH
65577: LD_INT 3
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: IN
65584: NOT
65585: PUSH
65586: LD_VAR 0 6
65590: PUSH
65591: LD_INT 2
65593: EQUAL
65594: AND
65595: OR
65596: IFFALSE 65606
// mode = 0 ;
65598: LD_ADDR_VAR 0 6
65602: PUSH
65603: LD_INT 0
65605: ST_TO_ADDR
// case mode of 0 :
65606: LD_VAR 0 6
65610: PUSH
65611: LD_INT 0
65613: DOUBLE
65614: EQUAL
65615: IFTRUE 65619
65617: GO 77072
65619: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65620: LD_ADDR_VAR 0 11
65624: PUSH
65625: LD_INT 0
65627: PUSH
65628: LD_INT 0
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: LD_INT 0
65637: PUSH
65638: LD_INT 1
65640: NEG
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: LD_INT 0
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 1
65658: PUSH
65659: LD_INT 1
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: PUSH
65666: LD_INT 0
65668: PUSH
65669: LD_INT 1
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 1
65678: NEG
65679: PUSH
65680: LD_INT 0
65682: PUSH
65683: EMPTY
65684: LIST
65685: LIST
65686: PUSH
65687: LD_INT 1
65689: NEG
65690: PUSH
65691: LD_INT 1
65693: NEG
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: LD_INT 1
65701: NEG
65702: PUSH
65703: LD_INT 2
65705: NEG
65706: PUSH
65707: EMPTY
65708: LIST
65709: LIST
65710: PUSH
65711: LD_INT 0
65713: PUSH
65714: LD_INT 2
65716: NEG
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: LD_INT 1
65727: NEG
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: LD_INT 1
65735: PUSH
65736: LD_INT 2
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 0
65745: PUSH
65746: LD_INT 2
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 1
65755: NEG
65756: PUSH
65757: LD_INT 1
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 1
65766: PUSH
65767: LD_INT 3
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: LD_INT 0
65776: PUSH
65777: LD_INT 3
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: LD_INT 1
65786: NEG
65787: PUSH
65788: LD_INT 2
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: LIST
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65813: LD_ADDR_VAR 0 12
65817: PUSH
65818: LD_INT 0
65820: PUSH
65821: LD_INT 0
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: PUSH
65828: LD_INT 0
65830: PUSH
65831: LD_INT 1
65833: NEG
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 1
65841: PUSH
65842: LD_INT 0
65844: PUSH
65845: EMPTY
65846: LIST
65847: LIST
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: LD_INT 1
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 0
65861: PUSH
65862: LD_INT 1
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 1
65871: NEG
65872: PUSH
65873: LD_INT 0
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PUSH
65880: LD_INT 1
65882: NEG
65883: PUSH
65884: LD_INT 1
65886: NEG
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 1
65894: PUSH
65895: LD_INT 1
65897: NEG
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 2
65905: PUSH
65906: LD_INT 0
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: PUSH
65913: LD_INT 2
65915: PUSH
65916: LD_INT 1
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 1
65925: NEG
65926: PUSH
65927: LD_INT 1
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 2
65936: NEG
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 2
65947: NEG
65948: PUSH
65949: LD_INT 1
65951: NEG
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 2
65959: NEG
65960: PUSH
65961: LD_INT 1
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 3
65970: NEG
65971: PUSH
65972: LD_INT 0
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 3
65981: NEG
65982: PUSH
65983: LD_INT 1
65985: NEG
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66009: LD_ADDR_VAR 0 13
66013: PUSH
66014: LD_INT 0
66016: PUSH
66017: LD_INT 0
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: LD_INT 1
66029: NEG
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: LD_INT 0
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: LD_INT 1
66047: PUSH
66048: LD_INT 1
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 0
66057: PUSH
66058: LD_INT 1
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 1
66067: NEG
66068: PUSH
66069: LD_INT 0
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 1
66078: NEG
66079: PUSH
66080: LD_INT 1
66082: NEG
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 1
66090: NEG
66091: PUSH
66092: LD_INT 2
66094: NEG
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 2
66102: PUSH
66103: LD_INT 1
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PUSH
66110: LD_INT 2
66112: PUSH
66113: LD_INT 2
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 1
66122: PUSH
66123: LD_INT 2
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 2
66132: NEG
66133: PUSH
66134: LD_INT 1
66136: NEG
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 2
66144: NEG
66145: PUSH
66146: LD_INT 2
66148: NEG
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 2
66156: NEG
66157: PUSH
66158: LD_INT 3
66160: NEG
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 3
66168: NEG
66169: PUSH
66170: LD_INT 2
66172: NEG
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 3
66180: NEG
66181: PUSH
66182: LD_INT 3
66184: NEG
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66208: LD_ADDR_VAR 0 14
66212: PUSH
66213: LD_INT 0
66215: PUSH
66216: LD_INT 0
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: LD_INT 0
66225: PUSH
66226: LD_INT 1
66228: NEG
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 1
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: LD_INT 1
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 1
66277: NEG
66278: PUSH
66279: LD_INT 1
66281: NEG
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 1
66289: NEG
66290: PUSH
66291: LD_INT 2
66293: NEG
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: LD_INT 0
66301: PUSH
66302: LD_INT 2
66304: NEG
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: PUSH
66313: LD_INT 1
66315: NEG
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: LD_INT 2
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 0
66333: PUSH
66334: LD_INT 2
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: NEG
66344: PUSH
66345: LD_INT 1
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 1
66354: NEG
66355: PUSH
66356: LD_INT 3
66358: NEG
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 0
66366: PUSH
66367: LD_INT 3
66369: NEG
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 1
66377: PUSH
66378: LD_INT 2
66380: NEG
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66404: LD_ADDR_VAR 0 15
66408: PUSH
66409: LD_INT 0
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 0
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: LD_INT 0
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 1
66442: PUSH
66443: LD_INT 1
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 0
66452: PUSH
66453: LD_INT 1
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: LD_INT 0
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 1
66473: NEG
66474: PUSH
66475: LD_INT 1
66477: NEG
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: LD_INT 1
66488: NEG
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: LD_INT 1
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 1
66516: NEG
66517: PUSH
66518: LD_INT 1
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 2
66527: NEG
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 2
66538: NEG
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 2
66550: PUSH
66551: LD_INT 1
66553: NEG
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 3
66561: PUSH
66562: LD_INT 0
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 3
66571: PUSH
66572: LD_INT 1
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66597: LD_ADDR_VAR 0 16
66601: PUSH
66602: LD_INT 0
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 0
66614: PUSH
66615: LD_INT 1
66617: NEG
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: LD_INT 0
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 1
66635: PUSH
66636: LD_INT 1
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: LD_INT 0
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 1
66666: NEG
66667: PUSH
66668: LD_INT 1
66670: NEG
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 1
66678: NEG
66679: PUSH
66680: LD_INT 2
66682: NEG
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 2
66690: PUSH
66691: LD_INT 1
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 2
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 2
66720: NEG
66721: PUSH
66722: LD_INT 1
66724: NEG
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 2
66732: NEG
66733: PUSH
66734: LD_INT 2
66736: NEG
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 3
66744: PUSH
66745: LD_INT 2
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 3
66754: PUSH
66755: LD_INT 3
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 2
66764: PUSH
66765: LD_INT 3
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66790: LD_ADDR_VAR 0 17
66794: PUSH
66795: LD_INT 0
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 0
66807: PUSH
66808: LD_INT 1
66810: NEG
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: LD_INT 0
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 0
66838: PUSH
66839: LD_INT 1
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 0
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 1
66859: NEG
66860: PUSH
66861: LD_INT 1
66863: NEG
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 1
66871: NEG
66872: PUSH
66873: LD_INT 2
66875: NEG
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 0
66883: PUSH
66884: LD_INT 2
66886: NEG
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 1
66894: PUSH
66895: LD_INT 1
66897: NEG
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 2
66915: PUSH
66916: LD_INT 1
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 2
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 1
66935: PUSH
66936: LD_INT 2
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: LD_INT 0
66945: PUSH
66946: LD_INT 2
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PUSH
66957: LD_INT 1
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 2
66966: NEG
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 2
66977: NEG
66978: PUSH
66979: LD_INT 1
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: LD_INT 2
66993: NEG
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67020: LD_ADDR_VAR 0 18
67024: PUSH
67025: LD_INT 0
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 0
67037: PUSH
67038: LD_INT 1
67040: NEG
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: NEG
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: LD_INT 2
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 0
67113: PUSH
67114: LD_INT 2
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 1
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: PUSH
67133: LD_INT 2
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 2
67145: PUSH
67146: LD_INT 1
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 2
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 1
67165: PUSH
67166: LD_INT 2
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 0
67175: PUSH
67176: LD_INT 2
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 2
67196: NEG
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 2
67207: NEG
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 2
67219: NEG
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67250: LD_ADDR_VAR 0 19
67254: PUSH
67255: LD_INT 0
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 0
67267: PUSH
67268: LD_INT 1
67270: NEG
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 1
67278: PUSH
67279: LD_INT 0
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 1
67288: PUSH
67289: LD_INT 1
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 0
67298: PUSH
67299: LD_INT 1
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 1
67308: NEG
67309: PUSH
67310: LD_INT 0
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 1
67319: NEG
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: LD_INT 1
67331: NEG
67332: PUSH
67333: LD_INT 2
67335: NEG
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: LD_INT 2
67346: NEG
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: LD_INT 1
67357: NEG
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PUSH
67363: LD_INT 2
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 2
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: LD_INT 2
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: LD_INT 2
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 0
67405: PUSH
67406: LD_INT 2
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: PUSH
67413: LD_INT 1
67415: NEG
67416: PUSH
67417: LD_INT 1
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 2
67426: NEG
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 2
67437: NEG
67438: PUSH
67439: LD_INT 1
67441: NEG
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 2
67449: NEG
67450: PUSH
67451: LD_INT 2
67453: NEG
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67480: LD_ADDR_VAR 0 20
67484: PUSH
67485: LD_INT 0
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 0
67497: PUSH
67498: LD_INT 1
67500: NEG
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 1
67508: PUSH
67509: LD_INT 0
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 1
67518: PUSH
67519: LD_INT 1
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 0
67528: PUSH
67529: LD_INT 1
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: NEG
67539: PUSH
67540: LD_INT 0
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 1
67561: NEG
67562: PUSH
67563: LD_INT 2
67565: NEG
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 0
67573: PUSH
67574: LD_INT 2
67576: NEG
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 1
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: LD_INT 0
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: LD_INT 1
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: LD_INT 2
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: LD_INT 2
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: LD_INT 2
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 1
67645: NEG
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 2
67656: NEG
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 2
67667: NEG
67668: PUSH
67669: LD_INT 1
67671: NEG
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 2
67679: NEG
67680: PUSH
67681: LD_INT 2
67683: NEG
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67710: LD_ADDR_VAR 0 21
67714: PUSH
67715: LD_INT 0
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 0
67727: PUSH
67728: LD_INT 1
67730: NEG
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 1
67738: PUSH
67739: LD_INT 0
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: PUSH
67749: LD_INT 1
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 0
67758: PUSH
67759: LD_INT 1
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: NEG
67769: PUSH
67770: LD_INT 0
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 1
67779: NEG
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: NEG
67792: PUSH
67793: LD_INT 2
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 0
67803: PUSH
67804: LD_INT 2
67806: NEG
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: LD_INT 1
67817: NEG
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: LD_INT 0
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 2
67835: PUSH
67836: LD_INT 1
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: LD_INT 2
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: LD_INT 2
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 2
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 1
67875: NEG
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 2
67886: NEG
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 2
67897: NEG
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 2
67909: NEG
67910: PUSH
67911: LD_INT 2
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67940: LD_ADDR_VAR 0 22
67944: PUSH
67945: LD_INT 0
67947: PUSH
67948: LD_INT 0
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 0
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: LD_INT 0
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: LD_INT 1
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 1
67998: NEG
67999: PUSH
68000: LD_INT 0
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PUSH
68007: LD_INT 1
68009: NEG
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 1
68021: NEG
68022: PUSH
68023: LD_INT 2
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: LD_INT 2
68036: NEG
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 1
68044: PUSH
68045: LD_INT 1
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 2
68055: PUSH
68056: LD_INT 0
68058: PUSH
68059: EMPTY
68060: LIST
68061: LIST
68062: PUSH
68063: LD_INT 2
68065: PUSH
68066: LD_INT 1
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 2
68075: PUSH
68076: LD_INT 2
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: PUSH
68086: LD_INT 2
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: NEG
68117: PUSH
68118: LD_INT 0
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 2
68127: NEG
68128: PUSH
68129: LD_INT 1
68131: NEG
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 2
68139: NEG
68140: PUSH
68141: LD_INT 2
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68170: LD_ADDR_VAR 0 23
68174: PUSH
68175: LD_INT 0
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 0
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: PUSH
68199: LD_INT 0
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 1
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 0
68218: PUSH
68219: LD_INT 1
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 1
68228: NEG
68229: PUSH
68230: LD_INT 0
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 2
68255: NEG
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 0
68263: PUSH
68264: LD_INT 2
68266: NEG
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 1
68274: PUSH
68275: LD_INT 1
68277: NEG
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: LD_INT 0
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: LD_INT 1
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 2
68305: PUSH
68306: LD_INT 2
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 1
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 0
68325: PUSH
68326: LD_INT 2
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: LD_INT 2
68346: NEG
68347: PUSH
68348: LD_INT 0
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 2
68357: NEG
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 2
68369: NEG
68370: PUSH
68371: LD_INT 2
68373: NEG
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 2
68381: NEG
68382: PUSH
68383: LD_INT 3
68385: NEG
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: LD_INT 3
68397: NEG
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 1
68405: PUSH
68406: LD_INT 2
68408: NEG
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 2
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68450: LD_ADDR_VAR 0 24
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: LD_INT 0
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: LD_INT 1
68470: NEG
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: LD_INT 0
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: PUSH
68489: LD_INT 1
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: LD_INT 1
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: PUSH
68506: LD_INT 1
68508: NEG
68509: PUSH
68510: LD_INT 0
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 1
68519: NEG
68520: PUSH
68521: LD_INT 1
68523: NEG
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 1
68531: NEG
68532: PUSH
68533: LD_INT 2
68535: NEG
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 0
68543: PUSH
68544: LD_INT 2
68546: NEG
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 1
68557: NEG
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 2
68565: PUSH
68566: LD_INT 0
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 2
68575: PUSH
68576: LD_INT 1
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: LD_INT 2
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: PUSH
68596: LD_INT 2
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: LD_INT 2
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 2
68626: NEG
68627: PUSH
68628: LD_INT 0
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 2
68637: NEG
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 2
68649: NEG
68650: PUSH
68651: LD_INT 2
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: LD_INT 2
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 2
68672: PUSH
68673: LD_INT 1
68675: NEG
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 3
68683: PUSH
68684: LD_INT 1
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 3
68693: PUSH
68694: LD_INT 2
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68726: LD_ADDR_VAR 0 25
68730: PUSH
68731: LD_INT 0
68733: PUSH
68734: LD_INT 0
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 1
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 1
68764: PUSH
68765: LD_INT 1
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 0
68774: PUSH
68775: LD_INT 1
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 1
68784: NEG
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: LD_INT 1
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: NEG
68808: PUSH
68809: LD_INT 2
68811: NEG
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 0
68819: PUSH
68820: LD_INT 2
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 1
68830: PUSH
68831: LD_INT 1
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 2
68841: PUSH
68842: LD_INT 0
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 2
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 2
68861: PUSH
68862: LD_INT 2
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 1
68871: PUSH
68872: LD_INT 2
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: LD_INT 2
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: LD_INT 1
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 2
68902: NEG
68903: PUSH
68904: LD_INT 0
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 2
68913: NEG
68914: PUSH
68915: LD_INT 1
68917: NEG
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 2
68925: NEG
68926: PUSH
68927: LD_INT 2
68929: NEG
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 3
68937: PUSH
68938: LD_INT 1
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 3
68947: PUSH
68948: LD_INT 2
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 2
68957: PUSH
68958: LD_INT 3
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 1
68967: PUSH
68968: LD_INT 3
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69000: LD_ADDR_VAR 0 26
69004: PUSH
69005: LD_INT 0
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 1
69028: PUSH
69029: LD_INT 0
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 0
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: NEG
69059: PUSH
69060: LD_INT 0
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 1
69069: NEG
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: LD_INT 2
69085: NEG
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 2
69096: NEG
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 1
69104: PUSH
69105: LD_INT 1
69107: NEG
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 2
69115: PUSH
69116: LD_INT 0
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 2
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 2
69135: PUSH
69136: LD_INT 2
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 1
69145: PUSH
69146: LD_INT 2
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: LD_INT 2
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: NEG
69166: PUSH
69167: LD_INT 1
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 2
69176: NEG
69177: PUSH
69178: LD_INT 0
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: LD_INT 1
69191: NEG
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 2
69199: NEG
69200: PUSH
69201: LD_INT 2
69203: NEG
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 2
69211: PUSH
69212: LD_INT 3
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: PUSH
69222: LD_INT 3
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: LD_INT 2
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: LD_INT 2
69242: NEG
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69276: LD_ADDR_VAR 0 27
69280: PUSH
69281: LD_INT 0
69283: PUSH
69284: LD_INT 0
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 0
69293: PUSH
69294: LD_INT 1
69296: NEG
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: LD_INT 0
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 1
69314: PUSH
69315: LD_INT 1
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 0
69324: PUSH
69325: LD_INT 1
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 1
69334: NEG
69335: PUSH
69336: LD_INT 0
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 1
69345: NEG
69346: PUSH
69347: LD_INT 1
69349: NEG
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 1
69357: NEG
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 0
69369: PUSH
69370: LD_INT 2
69372: NEG
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 1
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 2
69391: PUSH
69392: LD_INT 0
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 2
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: LD_INT 2
69411: PUSH
69412: LD_INT 2
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: LD_INT 2
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: LD_INT 2
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 1
69441: NEG
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 2
69452: NEG
69453: PUSH
69454: LD_INT 0
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 2
69463: NEG
69464: PUSH
69465: LD_INT 1
69467: NEG
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 2
69475: NEG
69476: PUSH
69477: LD_INT 2
69479: NEG
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 1
69487: NEG
69488: PUSH
69489: LD_INT 2
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 2
69498: NEG
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 3
69509: NEG
69510: PUSH
69511: LD_INT 1
69513: NEG
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 3
69521: NEG
69522: PUSH
69523: LD_INT 2
69525: NEG
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69556: LD_ADDR_VAR 0 28
69560: PUSH
69561: LD_INT 0
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: LD_INT 1
69576: NEG
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: PUSH
69585: LD_INT 0
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: LD_INT 1
69594: PUSH
69595: LD_INT 1
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 0
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: NEG
69615: PUSH
69616: LD_INT 0
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: NEG
69638: PUSH
69639: LD_INT 2
69641: NEG
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 0
69649: PUSH
69650: LD_INT 2
69652: NEG
69653: PUSH
69654: EMPTY
69655: LIST
69656: LIST
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 2
69671: PUSH
69672: LD_INT 0
69674: PUSH
69675: EMPTY
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 2
69681: PUSH
69682: LD_INT 1
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 2
69691: PUSH
69692: LD_INT 2
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: LD_INT 1
69701: PUSH
69702: LD_INT 2
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 0
69711: PUSH
69712: LD_INT 2
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 1
69721: NEG
69722: PUSH
69723: LD_INT 1
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 2
69732: NEG
69733: PUSH
69734: LD_INT 0
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 2
69743: NEG
69744: PUSH
69745: LD_INT 1
69747: NEG
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 2
69755: NEG
69756: PUSH
69757: LD_INT 2
69759: NEG
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 2
69767: NEG
69768: PUSH
69769: LD_INT 3
69771: NEG
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 3
69783: NEG
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 3
69791: NEG
69792: PUSH
69793: LD_INT 1
69795: NEG
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 3
69803: NEG
69804: PUSH
69805: LD_INT 2
69807: NEG
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: EMPTY
69814: LIST
69815: LIST
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69838: LD_ADDR_VAR 0 29
69842: PUSH
69843: LD_INT 0
69845: PUSH
69846: LD_INT 0
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 0
69855: PUSH
69856: LD_INT 1
69858: NEG
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 1
69866: PUSH
69867: LD_INT 0
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 1
69876: PUSH
69877: LD_INT 1
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: LD_INT 1
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 1
69907: NEG
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: LD_INT 2
69923: NEG
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: LD_INT 2
69934: NEG
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PUSH
69940: LD_INT 1
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 2
69953: PUSH
69954: LD_INT 0
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: LD_INT 2
69963: PUSH
69964: LD_INT 1
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 2
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: LD_INT 2
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 1
69993: NEG
69994: PUSH
69995: LD_INT 1
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 2
70004: NEG
70005: PUSH
70006: LD_INT 1
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 2
70016: NEG
70017: PUSH
70018: LD_INT 2
70020: NEG
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 2
70028: NEG
70029: PUSH
70030: LD_INT 3
70032: NEG
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 2
70040: PUSH
70041: LD_INT 1
70043: NEG
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 3
70051: PUSH
70052: LD_INT 1
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 1
70061: PUSH
70062: LD_INT 3
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 1
70071: NEG
70072: PUSH
70073: LD_INT 2
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 3
70082: NEG
70083: PUSH
70084: LD_INT 2
70086: NEG
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70117: LD_ADDR_VAR 0 30
70121: PUSH
70122: LD_INT 0
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 0
70134: PUSH
70135: LD_INT 1
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 1
70145: PUSH
70146: LD_INT 0
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 1
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 0
70165: PUSH
70166: LD_INT 1
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 1
70186: NEG
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: LD_INT 2
70202: NEG
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 0
70210: PUSH
70211: LD_INT 2
70213: NEG
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 1
70221: PUSH
70222: LD_INT 1
70224: NEG
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 2
70242: PUSH
70243: LD_INT 1
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 2
70252: PUSH
70253: LD_INT 2
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 2
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 1
70272: NEG
70273: PUSH
70274: LD_INT 1
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 2
70283: NEG
70284: PUSH
70285: LD_INT 0
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 2
70294: NEG
70295: PUSH
70296: LD_INT 1
70298: NEG
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 1
70306: NEG
70307: PUSH
70308: LD_INT 3
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 2
70321: NEG
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 3
70329: PUSH
70330: LD_INT 2
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 2
70339: PUSH
70340: LD_INT 3
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 2
70349: NEG
70350: PUSH
70351: LD_INT 1
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PUSH
70358: LD_INT 3
70360: NEG
70361: PUSH
70362: LD_INT 1
70364: NEG
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70395: LD_ADDR_VAR 0 31
70399: PUSH
70400: LD_INT 0
70402: PUSH
70403: LD_INT 0
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 1
70423: PUSH
70424: LD_INT 0
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 1
70433: PUSH
70434: LD_INT 1
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: LD_INT 1
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: LD_INT 0
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: LD_INT 1
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 1
70476: NEG
70477: PUSH
70478: LD_INT 2
70480: NEG
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 1
70488: PUSH
70489: LD_INT 1
70491: NEG
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 2
70499: PUSH
70500: LD_INT 0
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 2
70509: PUSH
70510: LD_INT 1
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 2
70519: PUSH
70520: LD_INT 2
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: LD_INT 2
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: LD_INT 2
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 1
70549: NEG
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 2
70560: NEG
70561: PUSH
70562: LD_INT 1
70564: NEG
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 2
70572: NEG
70573: PUSH
70574: LD_INT 2
70576: NEG
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 2
70584: NEG
70585: PUSH
70586: LD_INT 3
70588: NEG
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 2
70596: PUSH
70597: LD_INT 1
70599: NEG
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: LD_INT 3
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 1
70617: PUSH
70618: LD_INT 3
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: LD_INT 2
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 3
70638: NEG
70639: PUSH
70640: LD_INT 2
70642: NEG
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70673: LD_ADDR_VAR 0 32
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: LD_INT 0
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 0
70690: PUSH
70691: LD_INT 1
70693: NEG
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 0
70721: PUSH
70722: LD_INT 1
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 1
70731: NEG
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 1
70742: NEG
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 1
70754: NEG
70755: PUSH
70756: LD_INT 2
70758: NEG
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: LD_INT 2
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 1
70777: PUSH
70778: LD_INT 1
70780: NEG
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 2
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 2
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 2
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 0
70818: PUSH
70819: LD_INT 2
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 2
70839: NEG
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 2
70850: NEG
70851: PUSH
70852: LD_INT 1
70854: NEG
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 1
70862: NEG
70863: PUSH
70864: LD_INT 3
70866: NEG
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 1
70874: PUSH
70875: LD_INT 2
70877: NEG
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 3
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 2
70895: PUSH
70896: LD_INT 3
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 3
70916: NEG
70917: PUSH
70918: LD_INT 1
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70951: LD_ADDR_VAR 0 33
70955: PUSH
70956: LD_INT 0
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: LD_INT 1
70971: NEG
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: LD_INT 0
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 1
70989: PUSH
70990: LD_INT 1
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: LD_INT 1
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: NEG
71010: PUSH
71011: LD_INT 0
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 1
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 1
71032: NEG
71033: PUSH
71034: LD_INT 2
71036: NEG
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 1
71044: PUSH
71045: LD_INT 1
71047: NEG
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 2
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 2
71065: PUSH
71066: LD_INT 1
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: PUSH
71076: LD_INT 2
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 0
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 1
71095: NEG
71096: PUSH
71097: LD_INT 1
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 2
71106: NEG
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: LD_INT 1
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: LD_INT 2
71133: NEG
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 2
71141: NEG
71142: PUSH
71143: LD_INT 3
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 2
71153: PUSH
71154: LD_INT 1
71156: NEG
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 3
71164: PUSH
71165: LD_INT 1
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 1
71174: PUSH
71175: LD_INT 3
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: NEG
71185: PUSH
71186: LD_INT 2
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 3
71195: NEG
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71230: LD_ADDR_VAR 0 34
71234: PUSH
71235: LD_INT 0
71237: PUSH
71238: LD_INT 0
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: LD_INT 1
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 1
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 1
71268: PUSH
71269: LD_INT 1
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: LD_INT 1
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 1
71288: NEG
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 1
71311: NEG
71312: PUSH
71313: LD_INT 2
71315: NEG
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: LD_INT 2
71326: NEG
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 1
71334: PUSH
71335: LD_INT 1
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 2
71345: PUSH
71346: LD_INT 1
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 2
71355: PUSH
71356: LD_INT 2
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: PUSH
71366: LD_INT 2
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 1
71375: NEG
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 2
71386: NEG
71387: PUSH
71388: LD_INT 0
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 2
71397: NEG
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 2
71409: NEG
71410: PUSH
71411: LD_INT 2
71413: NEG
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 1
71421: NEG
71422: PUSH
71423: LD_INT 3
71425: NEG
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: LD_INT 2
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 3
71444: PUSH
71445: LD_INT 2
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: LD_INT 3
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: NEG
71465: PUSH
71466: LD_INT 1
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 3
71475: NEG
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71510: LD_ADDR_VAR 0 35
71514: PUSH
71515: LD_INT 0
71517: PUSH
71518: LD_INT 0
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 0
71527: PUSH
71528: LD_INT 1
71530: NEG
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 1
71538: PUSH
71539: LD_INT 0
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 1
71548: PUSH
71549: LD_INT 1
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 0
71558: PUSH
71559: LD_INT 1
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: NEG
71569: PUSH
71570: LD_INT 0
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 1
71579: NEG
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 2
71591: PUSH
71592: LD_INT 1
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71622: LD_ADDR_VAR 0 36
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 0
71639: PUSH
71640: LD_INT 1
71642: NEG
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 1
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 1
71660: PUSH
71661: LD_INT 1
71663: PUSH
71664: EMPTY
71665: LIST
71666: LIST
71667: PUSH
71668: LD_INT 0
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 1
71680: NEG
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 1
71691: NEG
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 1
71703: NEG
71704: PUSH
71705: LD_INT 2
71707: NEG
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 1
71715: PUSH
71716: LD_INT 2
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71734: LD_ADDR_VAR 0 37
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: LD_INT 1
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: LD_INT 0
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: LD_INT 1
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 0
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 1
71826: NEG
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71846: LD_ADDR_VAR 0 38
71850: PUSH
71851: LD_INT 0
71853: PUSH
71854: LD_INT 0
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: PUSH
71861: LD_INT 0
71863: PUSH
71864: LD_INT 1
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 1
71874: PUSH
71875: LD_INT 0
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 1
71884: PUSH
71885: LD_INT 1
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 0
71894: PUSH
71895: LD_INT 1
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 1
71904: NEG
71905: PUSH
71906: LD_INT 0
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 1
71915: NEG
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 2
71927: PUSH
71928: LD_INT 1
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 2
71937: NEG
71938: PUSH
71939: LD_INT 1
71941: NEG
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71958: LD_ADDR_VAR 0 39
71962: PUSH
71963: LD_INT 0
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 0
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 1
71986: PUSH
71987: LD_INT 0
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: PUSH
71997: LD_INT 1
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 0
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: NEG
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 1
72039: NEG
72040: PUSH
72041: LD_INT 2
72043: NEG
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 1
72051: PUSH
72052: LD_INT 2
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72070: LD_ADDR_VAR 0 40
72074: PUSH
72075: LD_INT 0
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 0
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 1
72098: PUSH
72099: LD_INT 0
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 1
72108: PUSH
72109: LD_INT 1
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 0
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 1
72128: NEG
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 1
72139: NEG
72140: PUSH
72141: LD_INT 1
72143: NEG
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: LD_INT 1
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 1
72162: NEG
72163: PUSH
72164: LD_INT 1
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72182: LD_ADDR_VAR 0 41
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: LD_INT 0
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 0
72199: PUSH
72200: LD_INT 1
72202: NEG
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 1
72210: PUSH
72211: LD_INT 0
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: LD_INT 1
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 0
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 1
72240: NEG
72241: PUSH
72242: LD_INT 0
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: LD_INT 1
72255: NEG
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: LD_INT 1
72263: NEG
72264: PUSH
72265: LD_INT 2
72267: NEG
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 1
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 2
72286: PUSH
72287: LD_INT 0
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 2
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 2
72306: PUSH
72307: LD_INT 2
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: LD_INT 2
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 1
72326: NEG
72327: PUSH
72328: LD_INT 1
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 2
72337: NEG
72338: PUSH
72339: LD_INT 0
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 2
72348: NEG
72349: PUSH
72350: LD_INT 1
72352: NEG
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 2
72360: NEG
72361: PUSH
72362: LD_INT 2
72364: NEG
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 2
72372: NEG
72373: PUSH
72374: LD_INT 3
72376: NEG
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: PUSH
72382: LD_INT 2
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: LD_INT 3
72395: PUSH
72396: LD_INT 0
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 3
72405: PUSH
72406: LD_INT 1
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 3
72415: PUSH
72416: LD_INT 2
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 3
72425: PUSH
72426: LD_INT 3
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 2
72435: PUSH
72436: LD_INT 3
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 2
72445: NEG
72446: PUSH
72447: LD_INT 1
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 3
72456: NEG
72457: PUSH
72458: LD_INT 0
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 3
72467: NEG
72468: PUSH
72469: LD_INT 1
72471: NEG
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 3
72479: NEG
72480: PUSH
72481: LD_INT 2
72483: NEG
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 3
72491: NEG
72492: PUSH
72493: LD_INT 3
72495: NEG
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: LIST
72515: LIST
72516: LIST
72517: LIST
72518: LIST
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: LIST
72531: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72532: LD_ADDR_VAR 0 42
72536: PUSH
72537: LD_INT 0
72539: PUSH
72540: LD_INT 0
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 0
72549: PUSH
72550: LD_INT 1
72552: NEG
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 1
72560: PUSH
72561: LD_INT 0
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: LD_INT 1
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: LD_INT 1
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 1
72590: NEG
72591: PUSH
72592: LD_INT 0
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: LD_INT 1
72601: NEG
72602: PUSH
72603: LD_INT 1
72605: NEG
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 1
72613: NEG
72614: PUSH
72615: LD_INT 2
72617: NEG
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 0
72625: PUSH
72626: LD_INT 2
72628: NEG
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 1
72636: PUSH
72637: LD_INT 1
72639: NEG
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 2
72647: PUSH
72648: LD_INT 1
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 2
72657: PUSH
72658: LD_INT 2
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 1
72667: PUSH
72668: LD_INT 2
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 0
72677: PUSH
72678: LD_INT 2
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 1
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 2
72698: NEG
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 2
72710: NEG
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 2
72722: NEG
72723: PUSH
72724: LD_INT 3
72726: NEG
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: NEG
72735: PUSH
72736: LD_INT 3
72738: NEG
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 0
72746: PUSH
72747: LD_INT 3
72749: NEG
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 1
72757: PUSH
72758: LD_INT 2
72760: NEG
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 3
72768: PUSH
72769: LD_INT 2
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 3
72778: PUSH
72779: LD_INT 3
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 2
72788: PUSH
72789: LD_INT 3
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: LD_INT 3
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: LD_INT 3
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 3
72829: NEG
72830: PUSH
72831: LD_INT 2
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 3
72841: NEG
72842: PUSH
72843: LD_INT 3
72845: NEG
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: LIST
72867: LIST
72868: LIST
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72882: LD_ADDR_VAR 0 43
72886: PUSH
72887: LD_INT 0
72889: PUSH
72890: LD_INT 0
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 0
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: PUSH
72921: LD_INT 1
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: LD_INT 1
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: NEG
72941: PUSH
72942: LD_INT 0
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PUSH
72949: LD_INT 1
72951: NEG
72952: PUSH
72953: LD_INT 1
72955: NEG
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: LD_INT 2
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 0
72975: PUSH
72976: LD_INT 2
72978: NEG
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 1
72986: PUSH
72987: LD_INT 1
72989: NEG
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 2
72997: PUSH
72998: LD_INT 0
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 2
73007: PUSH
73008: LD_INT 1
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: LD_INT 2
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 0
73027: PUSH
73028: LD_INT 2
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 1
73037: NEG
73038: PUSH
73039: LD_INT 1
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 2
73048: NEG
73049: PUSH
73050: LD_INT 0
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: LD_INT 1
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: NEG
73072: PUSH
73073: LD_INT 3
73075: NEG
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: LD_INT 3
73086: NEG
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: LD_INT 2
73097: NEG
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 2
73105: PUSH
73106: LD_INT 1
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 3
73116: PUSH
73117: LD_INT 0
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 3
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: LD_INT 3
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 0
73146: PUSH
73147: LD_INT 3
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: LD_INT 2
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 2
73167: NEG
73168: PUSH
73169: LD_INT 1
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 3
73178: NEG
73179: PUSH
73180: LD_INT 0
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 3
73189: NEG
73190: PUSH
73191: LD_INT 1
73193: NEG
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73230: LD_ADDR_VAR 0 44
73234: PUSH
73235: LD_INT 0
73237: PUSH
73238: LD_INT 0
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 0
73247: PUSH
73248: LD_INT 1
73250: NEG
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 0
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: NEG
73289: PUSH
73290: LD_INT 0
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PUSH
73297: LD_INT 1
73299: NEG
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 1
73311: NEG
73312: PUSH
73313: LD_INT 2
73315: NEG
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 1
73323: PUSH
73324: LD_INT 1
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 2
73334: PUSH
73335: LD_INT 0
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 2
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: PUSH
73355: LD_INT 2
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 1
73364: PUSH
73365: LD_INT 2
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 2
73385: NEG
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 2
73396: NEG
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: LD_INT 2
73408: NEG
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 2
73420: NEG
73421: PUSH
73422: LD_INT 3
73424: NEG
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 2
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 3
73443: PUSH
73444: LD_INT 0
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: LD_INT 1
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: LD_INT 2
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 3
73473: PUSH
73474: LD_INT 3
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 2
73483: PUSH
73484: LD_INT 3
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 2
73493: NEG
73494: PUSH
73495: LD_INT 1
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 3
73504: NEG
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 3
73515: NEG
73516: PUSH
73517: LD_INT 1
73519: NEG
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 3
73527: NEG
73528: PUSH
73529: LD_INT 2
73531: NEG
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 3
73539: NEG
73540: PUSH
73541: LD_INT 3
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73580: LD_ADDR_VAR 0 45
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: LD_INT 0
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 1
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: NEG
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 1
73649: NEG
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: NEG
73662: PUSH
73663: LD_INT 2
73665: NEG
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 0
73673: PUSH
73674: LD_INT 2
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: PUSH
73685: LD_INT 1
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: LD_INT 2
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 0
73725: PUSH
73726: LD_INT 2
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 1
73735: NEG
73736: PUSH
73737: LD_INT 1
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: LD_INT 2
73746: NEG
73747: PUSH
73748: LD_INT 1
73750: NEG
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PUSH
73756: LD_INT 2
73758: NEG
73759: PUSH
73760: LD_INT 2
73762: NEG
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 2
73770: NEG
73771: PUSH
73772: LD_INT 3
73774: NEG
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 1
73782: NEG
73783: PUSH
73784: LD_INT 3
73786: NEG
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 0
73794: PUSH
73795: LD_INT 3
73797: NEG
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: PUSH
73803: LD_INT 1
73805: PUSH
73806: LD_INT 2
73808: NEG
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 3
73816: PUSH
73817: LD_INT 2
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 3
73826: PUSH
73827: LD_INT 3
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 2
73836: PUSH
73837: LD_INT 3
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 1
73846: PUSH
73847: LD_INT 3
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 0
73856: PUSH
73857: LD_INT 3
73859: PUSH
73860: EMPTY
73861: LIST
73862: LIST
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: PUSH
73868: LD_INT 2
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: PUSH
73875: LD_INT 3
73877: NEG
73878: PUSH
73879: LD_INT 2
73881: NEG
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 3
73889: NEG
73890: PUSH
73891: LD_INT 3
73893: NEG
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73930: LD_ADDR_VAR 0 46
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: LD_INT 0
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: LD_INT 1
73950: NEG
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 0
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 1
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 0
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 1
73988: NEG
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: NEG
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: LD_INT 2
74015: NEG
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: LD_INT 2
74026: NEG
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 1
74034: PUSH
74035: LD_INT 1
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 2
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 2
74055: PUSH
74056: LD_INT 1
74058: PUSH
74059: EMPTY
74060: LIST
74061: LIST
74062: PUSH
74063: LD_INT 1
74065: PUSH
74066: LD_INT 2
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: LD_INT 1
74085: NEG
74086: PUSH
74087: LD_INT 1
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 2
74096: NEG
74097: PUSH
74098: LD_INT 0
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 2
74107: NEG
74108: PUSH
74109: LD_INT 1
74111: NEG
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: NEG
74120: PUSH
74121: LD_INT 3
74123: NEG
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: PUSH
74129: LD_INT 0
74131: PUSH
74132: LD_INT 3
74134: NEG
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 1
74142: PUSH
74143: LD_INT 2
74145: NEG
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 2
74153: PUSH
74154: LD_INT 1
74156: NEG
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: LD_INT 3
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 3
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 1
74184: PUSH
74185: LD_INT 3
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 0
74194: PUSH
74195: LD_INT 3
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 1
74204: NEG
74205: PUSH
74206: LD_INT 2
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 2
74215: NEG
74216: PUSH
74217: LD_INT 1
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 3
74226: NEG
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 3
74237: NEG
74238: PUSH
74239: LD_INT 1
74241: NEG
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74278: LD_ADDR_VAR 0 47
74282: PUSH
74283: LD_INT 0
74285: PUSH
74286: LD_INT 0
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: PUSH
74293: LD_INT 0
74295: PUSH
74296: LD_INT 1
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: LD_INT 0
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 1
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 0
74326: PUSH
74327: LD_INT 1
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: NEG
74337: PUSH
74338: LD_INT 0
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 1
74347: NEG
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 1
74359: NEG
74360: PUSH
74361: LD_INT 2
74363: NEG
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: LD_INT 2
74374: NEG
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: LD_INT 1
74385: NEG
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 2
74393: NEG
74394: PUSH
74395: LD_INT 1
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 2
74405: NEG
74406: PUSH
74407: LD_INT 2
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74429: LD_ADDR_VAR 0 48
74433: PUSH
74434: LD_INT 0
74436: PUSH
74437: LD_INT 0
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 0
74446: PUSH
74447: LD_INT 1
74449: NEG
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: PUSH
74468: LD_INT 1
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: LD_INT 1
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 1
74498: NEG
74499: PUSH
74500: LD_INT 1
74502: NEG
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 1
74510: NEG
74511: PUSH
74512: LD_INT 2
74514: NEG
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: LD_INT 2
74525: NEG
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: LD_INT 1
74536: NEG
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 2
74544: PUSH
74545: LD_INT 0
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 2
74554: PUSH
74555: LD_INT 1
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74576: LD_ADDR_VAR 0 49
74580: PUSH
74581: LD_INT 0
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: LD_INT 1
74596: NEG
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: PUSH
74605: LD_INT 0
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 1
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 0
74624: PUSH
74625: LD_INT 1
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: LD_INT 0
74638: PUSH
74639: EMPTY
74640: LIST
74641: LIST
74642: PUSH
74643: LD_INT 1
74645: NEG
74646: PUSH
74647: LD_INT 1
74649: NEG
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: PUSH
74658: LD_INT 1
74660: NEG
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 2
74668: PUSH
74669: LD_INT 0
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 2
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 2
74688: PUSH
74689: LD_INT 2
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: LD_INT 2
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: LIST
74710: LIST
74711: LIST
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: LIST
74717: LIST
74718: LIST
74719: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74720: LD_ADDR_VAR 0 50
74724: PUSH
74725: LD_INT 0
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 0
74737: PUSH
74738: LD_INT 1
74740: NEG
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 1
74748: PUSH
74749: LD_INT 0
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 1
74758: PUSH
74759: LD_INT 1
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: LD_INT 1
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 1
74778: NEG
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: NEG
74790: PUSH
74791: LD_INT 1
74793: NEG
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 2
74801: PUSH
74802: LD_INT 1
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 2
74811: PUSH
74812: LD_INT 2
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 1
74821: PUSH
74822: LD_INT 2
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 0
74831: PUSH
74832: LD_INT 2
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 1
74841: NEG
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74864: LD_ADDR_VAR 0 51
74868: PUSH
74869: LD_INT 0
74871: PUSH
74872: LD_INT 0
74874: PUSH
74875: EMPTY
74876: LIST
74877: LIST
74878: PUSH
74879: LD_INT 0
74881: PUSH
74882: LD_INT 1
74884: NEG
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 1
74892: PUSH
74893: LD_INT 0
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: PUSH
74900: LD_INT 1
74902: PUSH
74903: LD_INT 1
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 0
74912: PUSH
74913: LD_INT 1
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 1
74922: NEG
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 1
74933: NEG
74934: PUSH
74935: LD_INT 1
74937: NEG
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 1
74945: PUSH
74946: LD_INT 2
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 0
74955: PUSH
74956: LD_INT 2
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 1
74965: NEG
74966: PUSH
74967: LD_INT 1
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 2
74976: NEG
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 2
74987: NEG
74988: PUSH
74989: LD_INT 1
74991: NEG
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75011: LD_ADDR_VAR 0 52
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: LD_INT 0
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 1
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: LD_INT 1
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: LD_INT 1
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 1
75069: NEG
75070: PUSH
75071: LD_INT 0
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 1
75080: NEG
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 1
75092: NEG
75093: PUSH
75094: LD_INT 2
75096: NEG
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: NEG
75105: PUSH
75106: LD_INT 1
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 2
75115: NEG
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 2
75126: NEG
75127: PUSH
75128: LD_INT 1
75130: NEG
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 2
75138: NEG
75139: PUSH
75140: LD_INT 2
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75162: LD_ADDR_VAR 0 53
75166: PUSH
75167: LD_INT 0
75169: PUSH
75170: LD_INT 0
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 0
75179: PUSH
75180: LD_INT 1
75182: NEG
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 1
75190: PUSH
75191: LD_INT 0
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: LD_INT 1
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: LD_INT 1
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 1
75220: NEG
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 1
75231: NEG
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 1
75243: NEG
75244: PUSH
75245: LD_INT 2
75247: NEG
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: LD_INT 2
75258: NEG
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 1
75266: PUSH
75267: LD_INT 1
75269: NEG
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 2
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 2
75287: PUSH
75288: LD_INT 1
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: LD_INT 2
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: LD_INT 2
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 0
75317: PUSH
75318: LD_INT 2
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 1
75327: NEG
75328: PUSH
75329: LD_INT 1
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 2
75338: NEG
75339: PUSH
75340: LD_INT 0
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 2
75349: NEG
75350: PUSH
75351: LD_INT 1
75353: NEG
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 2
75361: NEG
75362: PUSH
75363: LD_INT 2
75365: NEG
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75392: LD_ADDR_VAR 0 54
75396: PUSH
75397: LD_INT 0
75399: PUSH
75400: LD_INT 0
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: LD_INT 1
75412: NEG
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 1
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 0
75440: PUSH
75441: LD_INT 1
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: PUSH
75448: LD_INT 1
75450: NEG
75451: PUSH
75452: LD_INT 0
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 1
75461: NEG
75462: PUSH
75463: LD_INT 1
75465: NEG
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 1
75473: NEG
75474: PUSH
75475: LD_INT 2
75477: NEG
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: LD_INT 2
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 1
75496: PUSH
75497: LD_INT 1
75499: NEG
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: PUSH
75505: LD_INT 2
75507: PUSH
75508: LD_INT 0
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 2
75517: PUSH
75518: LD_INT 1
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 2
75527: PUSH
75528: LD_INT 2
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: PUSH
75538: LD_INT 2
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: LD_INT 2
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PUSH
75555: LD_INT 1
75557: NEG
75558: PUSH
75559: LD_INT 1
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 2
75568: NEG
75569: PUSH
75570: LD_INT 0
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 2
75579: NEG
75580: PUSH
75581: LD_INT 1
75583: NEG
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: LD_INT 2
75591: NEG
75592: PUSH
75593: LD_INT 2
75595: NEG
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: LIST
75620: LIST
75621: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75622: LD_ADDR_VAR 0 55
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: LD_INT 0
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 0
75639: PUSH
75640: LD_INT 1
75642: NEG
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: LD_INT 0
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 1
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 1
75680: NEG
75681: PUSH
75682: LD_INT 0
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: NEG
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 1
75703: NEG
75704: PUSH
75705: LD_INT 2
75707: NEG
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 0
75715: PUSH
75716: LD_INT 2
75718: NEG
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: LD_INT 1
75726: PUSH
75727: LD_INT 1
75729: NEG
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: PUSH
75735: LD_INT 2
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 2
75747: PUSH
75748: LD_INT 1
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 2
75757: PUSH
75758: LD_INT 2
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 1
75767: PUSH
75768: LD_INT 2
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 0
75777: PUSH
75778: LD_INT 2
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: NEG
75788: PUSH
75789: LD_INT 1
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 2
75798: NEG
75799: PUSH
75800: LD_INT 0
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: LD_INT 2
75809: NEG
75810: PUSH
75811: LD_INT 1
75813: NEG
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 2
75821: NEG
75822: PUSH
75823: LD_INT 2
75825: NEG
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75852: LD_ADDR_VAR 0 56
75856: PUSH
75857: LD_INT 0
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: LD_INT 1
75872: NEG
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: LD_INT 0
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 1
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 0
75900: PUSH
75901: LD_INT 1
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 1
75910: NEG
75911: PUSH
75912: LD_INT 0
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: LD_INT 2
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 0
75945: PUSH
75946: LD_INT 2
75948: NEG
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 1
75956: PUSH
75957: LD_INT 1
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 2
75967: PUSH
75968: LD_INT 0
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 2
75977: PUSH
75978: LD_INT 1
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 2
75987: PUSH
75988: LD_INT 2
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 1
75997: PUSH
75998: LD_INT 2
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: LD_INT 2
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 1
76017: NEG
76018: PUSH
76019: LD_INT 1
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 2
76028: NEG
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 2
76039: NEG
76040: PUSH
76041: LD_INT 1
76043: NEG
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 2
76051: NEG
76052: PUSH
76053: LD_INT 2
76055: NEG
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76082: LD_ADDR_VAR 0 57
76086: PUSH
76087: LD_INT 0
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: LD_INT 1
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 1
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 1
76120: PUSH
76121: LD_INT 1
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: LD_INT 1
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 1
76140: NEG
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 1
76151: NEG
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: LD_INT 2
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 0
76175: PUSH
76176: LD_INT 2
76178: NEG
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 1
76186: PUSH
76187: LD_INT 1
76189: NEG
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 2
76197: PUSH
76198: LD_INT 0
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 2
76207: PUSH
76208: LD_INT 1
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 2
76217: PUSH
76218: LD_INT 2
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 1
76227: PUSH
76228: LD_INT 2
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: LD_INT 2
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 1
76247: NEG
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 2
76258: NEG
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 2
76269: NEG
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 2
76281: NEG
76282: PUSH
76283: LD_INT 2
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76312: LD_ADDR_VAR 0 58
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: LD_INT 1
76332: NEG
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 1
76340: PUSH
76341: LD_INT 0
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: LD_INT 1
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 0
76360: PUSH
76361: LD_INT 1
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 1
76370: NEG
76371: PUSH
76372: LD_INT 0
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 1
76381: NEG
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: LD_INT 2
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 0
76405: PUSH
76406: LD_INT 2
76408: NEG
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 1
76416: PUSH
76417: LD_INT 1
76419: NEG
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 2
76427: PUSH
76428: LD_INT 0
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 2
76437: PUSH
76438: LD_INT 1
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 2
76447: PUSH
76448: LD_INT 2
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 1
76457: PUSH
76458: LD_INT 2
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: LD_INT 2
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: LD_INT 1
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 2
76515: NEG
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76542: LD_ADDR_VAR 0 59
76546: PUSH
76547: LD_INT 0
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: LD_INT 1
76562: NEG
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: LD_INT 1
76570: PUSH
76571: LD_INT 0
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 1
76580: PUSH
76581: LD_INT 1
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 0
76590: PUSH
76591: LD_INT 1
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 0
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 1
76611: NEG
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76630: LD_ADDR_VAR 0 60
76634: PUSH
76635: LD_INT 0
76637: PUSH
76638: LD_INT 0
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 1
76658: PUSH
76659: LD_INT 0
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: LD_INT 1
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 0
76678: PUSH
76679: LD_INT 1
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 1
76688: NEG
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 1
76699: NEG
76700: PUSH
76701: LD_INT 1
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76718: LD_ADDR_VAR 0 61
76722: PUSH
76723: LD_INT 0
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 0
76735: PUSH
76736: LD_INT 1
76738: NEG
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: LD_INT 0
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 1
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 0
76766: PUSH
76767: LD_INT 1
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 1
76776: NEG
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: LD_INT 1
76791: NEG
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: LIST
76801: LIST
76802: LIST
76803: LIST
76804: LIST
76805: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76806: LD_ADDR_VAR 0 62
76810: PUSH
76811: LD_INT 0
76813: PUSH
76814: LD_INT 0
76816: PUSH
76817: EMPTY
76818: LIST
76819: LIST
76820: PUSH
76821: LD_INT 0
76823: PUSH
76824: LD_INT 1
76826: NEG
76827: PUSH
76828: EMPTY
76829: LIST
76830: LIST
76831: PUSH
76832: LD_INT 1
76834: PUSH
76835: LD_INT 0
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 1
76844: PUSH
76845: LD_INT 1
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 1
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 1
76864: NEG
76865: PUSH
76866: LD_INT 0
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 1
76875: NEG
76876: PUSH
76877: LD_INT 1
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76894: LD_ADDR_VAR 0 63
76898: PUSH
76899: LD_INT 0
76901: PUSH
76902: LD_INT 0
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 0
76911: PUSH
76912: LD_INT 1
76914: NEG
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: LD_INT 0
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 1
76932: PUSH
76933: LD_INT 1
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 0
76942: PUSH
76943: LD_INT 1
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 1
76952: NEG
76953: PUSH
76954: LD_INT 0
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: LD_INT 1
76967: NEG
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: LIST
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76982: LD_ADDR_VAR 0 64
76986: PUSH
76987: LD_INT 0
76989: PUSH
76990: LD_INT 0
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: LD_INT 0
76999: PUSH
77000: LD_INT 1
77002: NEG
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: PUSH
77008: LD_INT 1
77010: PUSH
77011: LD_INT 0
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: LD_INT 1
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 0
77030: PUSH
77031: LD_INT 1
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 1
77040: NEG
77041: PUSH
77042: LD_INT 0
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 1
77051: NEG
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: ST_TO_ADDR
// end ; 1 :
77070: GO 82967
77072: LD_INT 1
77074: DOUBLE
77075: EQUAL
77076: IFTRUE 77080
77078: GO 79703
77080: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77081: LD_ADDR_VAR 0 11
77085: PUSH
77086: LD_INT 1
77088: NEG
77089: PUSH
77090: LD_INT 3
77092: NEG
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 0
77100: PUSH
77101: LD_INT 3
77103: NEG
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 1
77111: PUSH
77112: LD_INT 2
77114: NEG
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: LIST
77124: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77125: LD_ADDR_VAR 0 12
77129: PUSH
77130: LD_INT 2
77132: PUSH
77133: LD_INT 1
77135: NEG
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 3
77143: PUSH
77144: LD_INT 0
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 3
77153: PUSH
77154: LD_INT 1
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: LIST
77165: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77166: LD_ADDR_VAR 0 13
77170: PUSH
77171: LD_INT 3
77173: PUSH
77174: LD_INT 2
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 3
77183: PUSH
77184: LD_INT 3
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 2
77193: PUSH
77194: LD_INT 3
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: LIST
77205: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77206: LD_ADDR_VAR 0 14
77210: PUSH
77211: LD_INT 1
77213: PUSH
77214: LD_INT 3
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 0
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 1
77233: NEG
77234: PUSH
77235: LD_INT 2
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: LIST
77246: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77247: LD_ADDR_VAR 0 15
77251: PUSH
77252: LD_INT 2
77254: NEG
77255: PUSH
77256: LD_INT 1
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 3
77265: NEG
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 3
77276: NEG
77277: PUSH
77278: LD_INT 1
77280: NEG
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: LIST
77290: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77291: LD_ADDR_VAR 0 16
77295: PUSH
77296: LD_INT 2
77298: NEG
77299: PUSH
77300: LD_INT 3
77302: NEG
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 3
77310: NEG
77311: PUSH
77312: LD_INT 2
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 3
77322: NEG
77323: PUSH
77324: LD_INT 3
77326: NEG
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: LIST
77336: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77337: LD_ADDR_VAR 0 17
77341: PUSH
77342: LD_INT 1
77344: NEG
77345: PUSH
77346: LD_INT 3
77348: NEG
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 0
77356: PUSH
77357: LD_INT 3
77359: NEG
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 1
77367: PUSH
77368: LD_INT 2
77370: NEG
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: LIST
77380: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77381: LD_ADDR_VAR 0 18
77385: PUSH
77386: LD_INT 2
77388: PUSH
77389: LD_INT 1
77391: NEG
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 3
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 3
77409: PUSH
77410: LD_INT 1
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77422: LD_ADDR_VAR 0 19
77426: PUSH
77427: LD_INT 3
77429: PUSH
77430: LD_INT 2
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 3
77439: PUSH
77440: LD_INT 3
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 2
77449: PUSH
77450: LD_INT 3
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: LIST
77461: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77462: LD_ADDR_VAR 0 20
77466: PUSH
77467: LD_INT 1
77469: PUSH
77470: LD_INT 3
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 0
77479: PUSH
77480: LD_INT 3
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: LD_INT 1
77489: NEG
77490: PUSH
77491: LD_INT 2
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: LIST
77502: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77503: LD_ADDR_VAR 0 21
77507: PUSH
77508: LD_INT 2
77510: NEG
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 3
77521: NEG
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 3
77532: NEG
77533: PUSH
77534: LD_INT 1
77536: NEG
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: LIST
77546: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77547: LD_ADDR_VAR 0 22
77551: PUSH
77552: LD_INT 2
77554: NEG
77555: PUSH
77556: LD_INT 3
77558: NEG
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 3
77566: NEG
77567: PUSH
77568: LD_INT 2
77570: NEG
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 3
77578: NEG
77579: PUSH
77580: LD_INT 3
77582: NEG
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: LIST
77592: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77593: LD_ADDR_VAR 0 23
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 3
77603: NEG
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 1
77611: NEG
77612: PUSH
77613: LD_INT 4
77615: NEG
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 1
77623: PUSH
77624: LD_INT 3
77626: NEG
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: LIST
77636: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77637: LD_ADDR_VAR 0 24
77641: PUSH
77642: LD_INT 3
77644: PUSH
77645: LD_INT 0
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 3
77654: PUSH
77655: LD_INT 1
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 4
77665: PUSH
77666: LD_INT 1
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: LIST
77677: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77678: LD_ADDR_VAR 0 25
77682: PUSH
77683: LD_INT 3
77685: PUSH
77686: LD_INT 3
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 4
77695: PUSH
77696: LD_INT 3
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 3
77705: PUSH
77706: LD_INT 4
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: LIST
77717: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77718: LD_ADDR_VAR 0 26
77722: PUSH
77723: LD_INT 0
77725: PUSH
77726: LD_INT 3
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 1
77735: PUSH
77736: LD_INT 4
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 1
77745: NEG
77746: PUSH
77747: LD_INT 3
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: LIST
77758: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77759: LD_ADDR_VAR 0 27
77763: PUSH
77764: LD_INT 3
77766: NEG
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 3
77777: NEG
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 4
77788: NEG
77789: PUSH
77790: LD_INT 1
77792: NEG
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: LIST
77802: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77803: LD_ADDR_VAR 0 28
77807: PUSH
77808: LD_INT 3
77810: NEG
77811: PUSH
77812: LD_INT 3
77814: NEG
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: LD_INT 3
77822: NEG
77823: PUSH
77824: LD_INT 4
77826: NEG
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 4
77834: NEG
77835: PUSH
77836: LD_INT 3
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: EMPTY
77845: LIST
77846: LIST
77847: LIST
77848: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77849: LD_ADDR_VAR 0 29
77853: PUSH
77854: LD_INT 1
77856: NEG
77857: PUSH
77858: LD_INT 3
77860: NEG
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 0
77868: PUSH
77869: LD_INT 3
77871: NEG
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: PUSH
77877: LD_INT 1
77879: PUSH
77880: LD_INT 2
77882: NEG
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 1
77890: NEG
77891: PUSH
77892: LD_INT 4
77894: NEG
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: LD_INT 0
77902: PUSH
77903: LD_INT 4
77905: NEG
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 1
77913: PUSH
77914: LD_INT 3
77916: NEG
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 1
77924: NEG
77925: PUSH
77926: LD_INT 5
77928: NEG
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 0
77936: PUSH
77937: LD_INT 5
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 1
77947: PUSH
77948: LD_INT 4
77950: NEG
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 1
77958: NEG
77959: PUSH
77960: LD_INT 6
77962: NEG
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: LD_INT 0
77970: PUSH
77971: LD_INT 6
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 1
77981: PUSH
77982: LD_INT 5
77984: NEG
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78004: LD_ADDR_VAR 0 30
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: LD_INT 1
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: PUSH
78023: LD_INT 0
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 3
78032: PUSH
78033: LD_INT 1
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 3
78042: PUSH
78043: LD_INT 1
78045: NEG
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 4
78053: PUSH
78054: LD_INT 0
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 4
78063: PUSH
78064: LD_INT 1
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 5
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 5
78094: PUSH
78095: LD_INT 1
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 5
78104: PUSH
78105: LD_INT 1
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 6
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 6
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78147: LD_ADDR_VAR 0 31
78151: PUSH
78152: LD_INT 3
78154: PUSH
78155: LD_INT 2
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 3
78164: PUSH
78165: LD_INT 3
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 2
78174: PUSH
78175: LD_INT 3
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 4
78184: PUSH
78185: LD_INT 3
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 4
78194: PUSH
78195: LD_INT 4
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 3
78204: PUSH
78205: LD_INT 4
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 5
78214: PUSH
78215: LD_INT 4
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 5
78224: PUSH
78225: LD_INT 5
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: LD_INT 4
78234: PUSH
78235: LD_INT 5
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 6
78244: PUSH
78245: LD_INT 5
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: LD_INT 6
78254: PUSH
78255: LD_INT 6
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 5
78264: PUSH
78265: LD_INT 6
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78286: LD_ADDR_VAR 0 32
78290: PUSH
78291: LD_INT 1
78293: PUSH
78294: LD_INT 3
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 0
78303: PUSH
78304: LD_INT 3
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 1
78313: NEG
78314: PUSH
78315: LD_INT 2
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 1
78324: PUSH
78325: LD_INT 4
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 4
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: NEG
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: PUSH
78356: LD_INT 5
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 0
78365: PUSH
78366: LD_INT 5
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: LD_INT 1
78375: NEG
78376: PUSH
78377: LD_INT 4
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 1
78386: PUSH
78387: LD_INT 6
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 0
78396: PUSH
78397: LD_INT 6
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 1
78406: NEG
78407: PUSH
78408: LD_INT 5
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78429: LD_ADDR_VAR 0 33
78433: PUSH
78434: LD_INT 2
78436: NEG
78437: PUSH
78438: LD_INT 1
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 3
78447: NEG
78448: PUSH
78449: LD_INT 0
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 3
78458: NEG
78459: PUSH
78460: LD_INT 1
78462: NEG
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 3
78470: NEG
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 4
78481: NEG
78482: PUSH
78483: LD_INT 0
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 4
78492: NEG
78493: PUSH
78494: LD_INT 1
78496: NEG
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 4
78504: NEG
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 5
78515: NEG
78516: PUSH
78517: LD_INT 0
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 5
78526: NEG
78527: PUSH
78528: LD_INT 1
78530: NEG
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 5
78538: NEG
78539: PUSH
78540: LD_INT 1
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 6
78549: NEG
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 6
78560: NEG
78561: PUSH
78562: LD_INT 1
78564: NEG
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78584: LD_ADDR_VAR 0 34
78588: PUSH
78589: LD_INT 2
78591: NEG
78592: PUSH
78593: LD_INT 3
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 3
78603: NEG
78604: PUSH
78605: LD_INT 2
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 3
78615: NEG
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 3
78627: NEG
78628: PUSH
78629: LD_INT 4
78631: NEG
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 4
78639: NEG
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 4
78651: NEG
78652: PUSH
78653: LD_INT 4
78655: NEG
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 4
78663: NEG
78664: PUSH
78665: LD_INT 5
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 5
78675: NEG
78676: PUSH
78677: LD_INT 4
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 5
78687: NEG
78688: PUSH
78689: LD_INT 5
78691: NEG
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 5
78699: NEG
78700: PUSH
78701: LD_INT 6
78703: NEG
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 6
78711: NEG
78712: PUSH
78713: LD_INT 5
78715: NEG
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 6
78723: NEG
78724: PUSH
78725: LD_INT 6
78727: NEG
78728: PUSH
78729: EMPTY
78730: LIST
78731: LIST
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78747: LD_ADDR_VAR 0 41
78751: PUSH
78752: LD_INT 0
78754: PUSH
78755: LD_INT 2
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 1
78765: NEG
78766: PUSH
78767: LD_INT 3
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 1
78777: PUSH
78778: LD_INT 2
78780: NEG
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: LIST
78790: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78791: LD_ADDR_VAR 0 42
78795: PUSH
78796: LD_INT 2
78798: PUSH
78799: LD_INT 0
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 2
78808: PUSH
78809: LD_INT 1
78811: NEG
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 3
78819: PUSH
78820: LD_INT 1
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: LIST
78831: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78832: LD_ADDR_VAR 0 43
78836: PUSH
78837: LD_INT 2
78839: PUSH
78840: LD_INT 2
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 3
78849: PUSH
78850: LD_INT 2
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 2
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: LIST
78871: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78872: LD_ADDR_VAR 0 44
78876: PUSH
78877: LD_INT 0
78879: PUSH
78880: LD_INT 2
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 1
78889: PUSH
78890: LD_INT 3
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 1
78899: NEG
78900: PUSH
78901: LD_INT 2
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: LIST
78912: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78913: LD_ADDR_VAR 0 45
78917: PUSH
78918: LD_INT 2
78920: NEG
78921: PUSH
78922: LD_INT 0
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: NEG
78932: PUSH
78933: LD_INT 1
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 3
78942: NEG
78943: PUSH
78944: LD_INT 1
78946: NEG
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: LIST
78956: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78957: LD_ADDR_VAR 0 46
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: LD_INT 2
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 2
78976: NEG
78977: PUSH
78978: LD_INT 3
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: LD_INT 2
78992: NEG
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: LIST
79002: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79003: LD_ADDR_VAR 0 47
79007: PUSH
79008: LD_INT 2
79010: NEG
79011: PUSH
79012: LD_INT 3
79014: NEG
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: LD_INT 3
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79036: LD_ADDR_VAR 0 48
79040: PUSH
79041: LD_INT 1
79043: PUSH
79044: LD_INT 2
79046: NEG
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 2
79054: PUSH
79055: LD_INT 1
79057: NEG
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79067: LD_ADDR_VAR 0 49
79071: PUSH
79072: LD_INT 3
79074: PUSH
79075: LD_INT 1
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 3
79084: PUSH
79085: LD_INT 2
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79096: LD_ADDR_VAR 0 50
79100: PUSH
79101: LD_INT 2
79103: PUSH
79104: LD_INT 3
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 1
79113: PUSH
79114: LD_INT 3
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79125: LD_ADDR_VAR 0 51
79129: PUSH
79130: LD_INT 1
79132: NEG
79133: PUSH
79134: LD_INT 2
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 2
79143: NEG
79144: PUSH
79145: LD_INT 1
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79156: LD_ADDR_VAR 0 52
79160: PUSH
79161: LD_INT 3
79163: NEG
79164: PUSH
79165: LD_INT 1
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 3
79175: NEG
79176: PUSH
79177: LD_INT 2
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79189: LD_ADDR_VAR 0 53
79193: PUSH
79194: LD_INT 1
79196: NEG
79197: PUSH
79198: LD_INT 3
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 0
79208: PUSH
79209: LD_INT 3
79211: NEG
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 1
79219: PUSH
79220: LD_INT 2
79222: NEG
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: LIST
79232: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79233: LD_ADDR_VAR 0 54
79237: PUSH
79238: LD_INT 2
79240: PUSH
79241: LD_INT 1
79243: NEG
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 3
79251: PUSH
79252: LD_INT 0
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 3
79261: PUSH
79262: LD_INT 1
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: LIST
79273: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79274: LD_ADDR_VAR 0 55
79278: PUSH
79279: LD_INT 3
79281: PUSH
79282: LD_INT 2
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 3
79291: PUSH
79292: LD_INT 3
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 2
79301: PUSH
79302: LD_INT 3
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: LIST
79313: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79314: LD_ADDR_VAR 0 56
79318: PUSH
79319: LD_INT 1
79321: PUSH
79322: LD_INT 3
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 0
79331: PUSH
79332: LD_INT 3
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: LD_INT 2
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: LIST
79354: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79355: LD_ADDR_VAR 0 57
79359: PUSH
79360: LD_INT 2
79362: NEG
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 3
79373: NEG
79374: PUSH
79375: LD_INT 0
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 3
79384: NEG
79385: PUSH
79386: LD_INT 1
79388: NEG
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: LIST
79398: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79399: LD_ADDR_VAR 0 58
79403: PUSH
79404: LD_INT 2
79406: NEG
79407: PUSH
79408: LD_INT 3
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 3
79418: NEG
79419: PUSH
79420: LD_INT 2
79422: NEG
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 3
79430: NEG
79431: PUSH
79432: LD_INT 3
79434: NEG
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: LIST
79444: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79445: LD_ADDR_VAR 0 59
79449: PUSH
79450: LD_INT 1
79452: NEG
79453: PUSH
79454: LD_INT 2
79456: NEG
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: LD_INT 0
79464: PUSH
79465: LD_INT 2
79467: NEG
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 1
79475: PUSH
79476: LD_INT 1
79478: NEG
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: LIST
79488: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79489: LD_ADDR_VAR 0 60
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: LD_INT 1
79499: NEG
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 2
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 2
79517: PUSH
79518: LD_INT 1
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: LIST
79529: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79530: LD_ADDR_VAR 0 61
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: LD_INT 2
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: LIST
79569: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79570: LD_ADDR_VAR 0 62
79574: PUSH
79575: LD_INT 1
79577: PUSH
79578: LD_INT 2
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: LD_INT 2
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 1
79597: NEG
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: LIST
79610: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79611: LD_ADDR_VAR 0 63
79615: PUSH
79616: LD_INT 1
79618: NEG
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 2
79629: NEG
79630: PUSH
79631: LD_INT 0
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 2
79640: NEG
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: LIST
79654: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79655: LD_ADDR_VAR 0 64
79659: PUSH
79660: LD_INT 1
79662: NEG
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 2
79674: NEG
79675: PUSH
79676: LD_INT 1
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 2
79686: NEG
79687: PUSH
79688: LD_INT 2
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: LIST
79700: ST_TO_ADDR
// end ; 2 :
79701: GO 82967
79703: LD_INT 2
79705: DOUBLE
79706: EQUAL
79707: IFTRUE 79711
79709: GO 82966
79711: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79712: LD_ADDR_VAR 0 29
79716: PUSH
79717: LD_INT 4
79719: PUSH
79720: LD_INT 0
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 4
79729: PUSH
79730: LD_INT 1
79732: NEG
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 5
79740: PUSH
79741: LD_INT 0
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 5
79750: PUSH
79751: LD_INT 1
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 4
79760: PUSH
79761: LD_INT 1
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 3
79780: PUSH
79781: LD_INT 1
79783: NEG
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 3
79791: PUSH
79792: LD_INT 2
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 5
79802: PUSH
79803: LD_INT 2
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 3
79812: PUSH
79813: LD_INT 3
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 3
79822: PUSH
79823: LD_INT 2
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 4
79832: PUSH
79833: LD_INT 3
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 4
79842: PUSH
79843: LD_INT 4
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 3
79852: PUSH
79853: LD_INT 4
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: LD_INT 3
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 2
79872: PUSH
79873: LD_INT 2
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 4
79882: PUSH
79883: LD_INT 2
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 4
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 0
79902: PUSH
79903: LD_INT 4
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: LD_INT 3
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 1
79922: PUSH
79923: LD_INT 4
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 1
79932: PUSH
79933: LD_INT 5
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 0
79942: PUSH
79943: LD_INT 5
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: NEG
79953: PUSH
79954: LD_INT 4
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 1
79963: NEG
79964: PUSH
79965: LD_INT 3
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 2
79974: PUSH
79975: LD_INT 5
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 2
79984: NEG
79985: PUSH
79986: LD_INT 3
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: LD_INT 3
79995: NEG
79996: PUSH
79997: LD_INT 0
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: LD_INT 3
80006: NEG
80007: PUSH
80008: LD_INT 1
80010: NEG
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 2
80018: NEG
80019: PUSH
80020: LD_INT 0
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 2
80029: NEG
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 3
80040: NEG
80041: PUSH
80042: LD_INT 1
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 4
80051: NEG
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: LD_INT 4
80062: NEG
80063: PUSH
80064: LD_INT 1
80066: NEG
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 4
80074: NEG
80075: PUSH
80076: LD_INT 2
80078: NEG
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 2
80086: NEG
80087: PUSH
80088: LD_INT 2
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 4
80097: NEG
80098: PUSH
80099: LD_INT 4
80101: NEG
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 4
80109: NEG
80110: PUSH
80111: LD_INT 5
80113: NEG
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 3
80121: NEG
80122: PUSH
80123: LD_INT 4
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 3
80133: NEG
80134: PUSH
80135: LD_INT 3
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 4
80145: NEG
80146: PUSH
80147: LD_INT 3
80149: NEG
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: LD_INT 5
80157: NEG
80158: PUSH
80159: LD_INT 4
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 5
80169: NEG
80170: PUSH
80171: LD_INT 5
80173: NEG
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 3
80181: NEG
80182: PUSH
80183: LD_INT 5
80185: NEG
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 5
80193: NEG
80194: PUSH
80195: LD_INT 3
80197: NEG
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: LIST
80207: LIST
80208: LIST
80209: LIST
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: LIST
80219: LIST
80220: LIST
80221: LIST
80222: LIST
80223: LIST
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: LIST
80232: LIST
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80250: LD_ADDR_VAR 0 30
80254: PUSH
80255: LD_INT 4
80257: PUSH
80258: LD_INT 4
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 4
80267: PUSH
80268: LD_INT 3
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 5
80277: PUSH
80278: LD_INT 4
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 5
80287: PUSH
80288: LD_INT 5
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 4
80297: PUSH
80298: LD_INT 5
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 3
80307: PUSH
80308: LD_INT 4
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 3
80317: PUSH
80318: LD_INT 3
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: LD_INT 5
80327: PUSH
80328: LD_INT 3
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 3
80337: PUSH
80338: LD_INT 5
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: LD_INT 3
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 0
80357: PUSH
80358: LD_INT 2
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: LD_INT 1
80367: PUSH
80368: LD_INT 3
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: LD_INT 4
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 0
80387: PUSH
80388: LD_INT 4
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 1
80397: NEG
80398: PUSH
80399: LD_INT 3
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 1
80408: NEG
80409: PUSH
80410: LD_INT 2
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 2
80419: PUSH
80420: LD_INT 4
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 2
80429: NEG
80430: PUSH
80431: LD_INT 2
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 4
80440: NEG
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 4
80451: NEG
80452: PUSH
80453: LD_INT 1
80455: NEG
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 3
80463: NEG
80464: PUSH
80465: LD_INT 0
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 3
80474: NEG
80475: PUSH
80476: LD_INT 1
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 4
80485: NEG
80486: PUSH
80487: LD_INT 1
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 5
80496: NEG
80497: PUSH
80498: LD_INT 0
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 5
80507: NEG
80508: PUSH
80509: LD_INT 1
80511: NEG
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 5
80519: NEG
80520: PUSH
80521: LD_INT 2
80523: NEG
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 3
80531: NEG
80532: PUSH
80533: LD_INT 2
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 3
80542: NEG
80543: PUSH
80544: LD_INT 3
80546: NEG
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 3
80554: NEG
80555: PUSH
80556: LD_INT 4
80558: NEG
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: NEG
80567: PUSH
80568: LD_INT 3
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 2
80578: NEG
80579: PUSH
80580: LD_INT 2
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 3
80590: NEG
80591: PUSH
80592: LD_INT 2
80594: NEG
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 4
80602: NEG
80603: PUSH
80604: LD_INT 3
80606: NEG
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 4
80614: NEG
80615: PUSH
80616: LD_INT 4
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 2
80626: NEG
80627: PUSH
80628: LD_INT 4
80630: NEG
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 4
80638: NEG
80639: PUSH
80640: LD_INT 2
80642: NEG
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 4
80653: NEG
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 5
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 4
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 1
80683: PUSH
80684: LD_INT 3
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 0
80694: PUSH
80695: LD_INT 3
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 1
80705: NEG
80706: PUSH
80707: LD_INT 4
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: LD_INT 5
80721: NEG
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: PUSH
80730: LD_INT 3
80732: NEG
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 2
80740: NEG
80741: PUSH
80742: LD_INT 5
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80797: LD_ADDR_VAR 0 31
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: LD_INT 4
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: LD_INT 3
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 1
80824: PUSH
80825: LD_INT 4
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: LD_INT 5
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: LD_INT 5
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 1
80854: NEG
80855: PUSH
80856: LD_INT 4
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 1
80865: NEG
80866: PUSH
80867: LD_INT 3
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 2
80876: PUSH
80877: LD_INT 5
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 2
80886: NEG
80887: PUSH
80888: LD_INT 3
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 3
80897: NEG
80898: PUSH
80899: LD_INT 0
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 3
80908: NEG
80909: PUSH
80910: LD_INT 1
80912: NEG
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 2
80920: NEG
80921: PUSH
80922: LD_INT 0
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 2
80931: NEG
80932: PUSH
80933: LD_INT 1
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 3
80942: NEG
80943: PUSH
80944: LD_INT 1
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 4
80953: NEG
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 4
80964: NEG
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 4
80976: NEG
80977: PUSH
80978: LD_INT 2
80980: NEG
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 2
80988: NEG
80989: PUSH
80990: LD_INT 2
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 4
80999: NEG
81000: PUSH
81001: LD_INT 4
81003: NEG
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 4
81011: NEG
81012: PUSH
81013: LD_INT 5
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 3
81023: NEG
81024: PUSH
81025: LD_INT 4
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 3
81035: NEG
81036: PUSH
81037: LD_INT 3
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 4
81047: NEG
81048: PUSH
81049: LD_INT 3
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 5
81059: NEG
81060: PUSH
81061: LD_INT 4
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 5
81071: NEG
81072: PUSH
81073: LD_INT 5
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 3
81083: NEG
81084: PUSH
81085: LD_INT 5
81087: NEG
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 5
81095: NEG
81096: PUSH
81097: LD_INT 3
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: LD_INT 3
81110: NEG
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 0
81118: PUSH
81119: LD_INT 4
81121: NEG
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 1
81129: PUSH
81130: LD_INT 3
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 1
81140: PUSH
81141: LD_INT 2
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: LD_INT 2
81154: NEG
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: LD_INT 3
81166: NEG
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 1
81174: NEG
81175: PUSH
81176: LD_INT 4
81178: NEG
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 2
81186: PUSH
81187: LD_INT 2
81189: NEG
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 2
81197: NEG
81198: PUSH
81199: LD_INT 4
81201: NEG
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 4
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 4
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 5
81230: PUSH
81231: LD_INT 0
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 5
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 4
81250: PUSH
81251: LD_INT 1
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 3
81260: PUSH
81261: LD_INT 0
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 3
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 3
81281: PUSH
81282: LD_INT 2
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 5
81292: PUSH
81293: LD_INT 2
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: LIST
81306: LIST
81307: LIST
81308: LIST
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: LIST
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81347: LD_ADDR_VAR 0 32
81351: PUSH
81352: LD_INT 4
81354: NEG
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: PUSH
81363: LD_INT 4
81365: NEG
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 3
81377: NEG
81378: PUSH
81379: LD_INT 0
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 3
81388: NEG
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 4
81399: NEG
81400: PUSH
81401: LD_INT 1
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 5
81410: NEG
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 5
81421: NEG
81422: PUSH
81423: LD_INT 1
81425: NEG
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 5
81433: NEG
81434: PUSH
81435: LD_INT 2
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 3
81445: NEG
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 3
81456: NEG
81457: PUSH
81458: LD_INT 3
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 3
81468: NEG
81469: PUSH
81470: LD_INT 4
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: NEG
81481: PUSH
81482: LD_INT 3
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: LD_INT 2
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 3
81504: NEG
81505: PUSH
81506: LD_INT 2
81508: NEG
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 4
81516: NEG
81517: PUSH
81518: LD_INT 3
81520: NEG
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 4
81528: NEG
81529: PUSH
81530: LD_INT 4
81532: NEG
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 2
81540: NEG
81541: PUSH
81542: LD_INT 4
81544: NEG
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 4
81552: NEG
81553: PUSH
81554: LD_INT 2
81556: NEG
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 0
81564: PUSH
81565: LD_INT 4
81567: NEG
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: LD_INT 5
81578: NEG
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 1
81586: PUSH
81587: LD_INT 4
81589: NEG
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: LD_INT 3
81600: NEG
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: LD_INT 3
81611: NEG
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 1
81619: NEG
81620: PUSH
81621: LD_INT 4
81623: NEG
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 1
81631: NEG
81632: PUSH
81633: LD_INT 5
81635: NEG
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 2
81643: PUSH
81644: LD_INT 3
81646: NEG
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 2
81654: NEG
81655: PUSH
81656: LD_INT 5
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 3
81666: PUSH
81667: LD_INT 0
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 3
81676: PUSH
81677: LD_INT 1
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 4
81687: PUSH
81688: LD_INT 0
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 4
81697: PUSH
81698: LD_INT 1
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 3
81707: PUSH
81708: LD_INT 1
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: LD_INT 1
81730: NEG
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 2
81738: PUSH
81739: LD_INT 2
81741: NEG
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 4
81749: PUSH
81750: LD_INT 2
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 4
81759: PUSH
81760: LD_INT 4
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 4
81769: PUSH
81770: LD_INT 3
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 5
81779: PUSH
81780: LD_INT 4
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 5
81789: PUSH
81790: LD_INT 5
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 4
81799: PUSH
81800: LD_INT 5
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 3
81809: PUSH
81810: LD_INT 4
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 3
81819: PUSH
81820: LD_INT 3
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 5
81829: PUSH
81830: LD_INT 3
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 3
81839: PUSH
81840: LD_INT 5
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81894: LD_ADDR_VAR 0 33
81898: PUSH
81899: LD_INT 4
81901: NEG
81902: PUSH
81903: LD_INT 4
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 4
81913: NEG
81914: PUSH
81915: LD_INT 5
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 3
81925: NEG
81926: PUSH
81927: LD_INT 4
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 3
81937: NEG
81938: PUSH
81939: LD_INT 3
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 4
81949: NEG
81950: PUSH
81951: LD_INT 3
81953: NEG
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 5
81961: NEG
81962: PUSH
81963: LD_INT 4
81965: NEG
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 5
81973: NEG
81974: PUSH
81975: LD_INT 5
81977: NEG
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 3
81985: NEG
81986: PUSH
81987: LD_INT 5
81989: NEG
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 5
81997: NEG
81998: PUSH
81999: LD_INT 3
82001: NEG
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 0
82009: PUSH
82010: LD_INT 3
82012: NEG
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 0
82020: PUSH
82021: LD_INT 4
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 1
82031: PUSH
82032: LD_INT 3
82034: NEG
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 1
82042: PUSH
82043: LD_INT 2
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: LD_INT 2
82056: NEG
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: LD_INT 3
82068: NEG
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: LD_INT 4
82080: NEG
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 2
82088: PUSH
82089: LD_INT 2
82091: NEG
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 2
82099: NEG
82100: PUSH
82101: LD_INT 4
82103: NEG
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 4
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 4
82121: PUSH
82122: LD_INT 1
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 5
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 5
82142: PUSH
82143: LD_INT 1
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 4
82152: PUSH
82153: LD_INT 1
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 3
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 3
82172: PUSH
82173: LD_INT 1
82175: NEG
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: PUSH
82181: LD_INT 3
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 5
82194: PUSH
82195: LD_INT 2
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 3
82204: PUSH
82205: LD_INT 3
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 3
82214: PUSH
82215: LD_INT 2
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 4
82224: PUSH
82225: LD_INT 3
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 4
82234: PUSH
82235: LD_INT 4
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 3
82244: PUSH
82245: LD_INT 4
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: LD_INT 3
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: LD_INT 2
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 4
82274: PUSH
82275: LD_INT 2
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 2
82284: PUSH
82285: LD_INT 4
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: LD_INT 4
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 0
82304: PUSH
82305: LD_INT 3
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 1
82314: PUSH
82315: LD_INT 4
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 1
82324: PUSH
82325: LD_INT 5
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: LD_INT 5
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: LD_INT 4
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 1
82355: NEG
82356: PUSH
82357: LD_INT 3
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 2
82366: PUSH
82367: LD_INT 5
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 2
82376: NEG
82377: PUSH
82378: LD_INT 3
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82432: LD_ADDR_VAR 0 34
82436: PUSH
82437: LD_INT 0
82439: PUSH
82440: LD_INT 4
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 0
82450: PUSH
82451: LD_INT 5
82453: NEG
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: PUSH
82462: LD_INT 4
82464: NEG
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: PUSH
82473: LD_INT 3
82475: NEG
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: LD_INT 3
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 1
82494: NEG
82495: PUSH
82496: LD_INT 4
82498: NEG
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 1
82506: NEG
82507: PUSH
82508: LD_INT 5
82510: NEG
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 2
82518: PUSH
82519: LD_INT 3
82521: NEG
82522: PUSH
82523: EMPTY
82524: LIST
82525: LIST
82526: PUSH
82527: LD_INT 2
82529: NEG
82530: PUSH
82531: LD_INT 5
82533: NEG
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 3
82541: PUSH
82542: LD_INT 0
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 3
82551: PUSH
82552: LD_INT 1
82554: NEG
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 4
82562: PUSH
82563: LD_INT 0
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 4
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 3
82582: PUSH
82583: LD_INT 1
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 2
82592: PUSH
82593: LD_INT 0
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 2
82602: PUSH
82603: LD_INT 1
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 2
82613: PUSH
82614: LD_INT 2
82616: NEG
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 4
82624: PUSH
82625: LD_INT 2
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 4
82634: PUSH
82635: LD_INT 4
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 4
82644: PUSH
82645: LD_INT 3
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 5
82654: PUSH
82655: LD_INT 4
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 5
82664: PUSH
82665: LD_INT 5
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 4
82674: PUSH
82675: LD_INT 5
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 3
82684: PUSH
82685: LD_INT 4
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 3
82694: PUSH
82695: LD_INT 3
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 5
82704: PUSH
82705: LD_INT 3
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 3
82714: PUSH
82715: LD_INT 5
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 0
82724: PUSH
82725: LD_INT 3
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: LD_INT 2
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: PUSH
82745: LD_INT 3
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 1
82754: PUSH
82755: LD_INT 4
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: LD_INT 4
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 1
82774: NEG
82775: PUSH
82776: LD_INT 3
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: PUSH
82783: LD_INT 1
82785: NEG
82786: PUSH
82787: LD_INT 2
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: LD_INT 4
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 2
82806: NEG
82807: PUSH
82808: LD_INT 2
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 4
82817: NEG
82818: PUSH
82819: LD_INT 0
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 4
82828: NEG
82829: PUSH
82830: LD_INT 1
82832: NEG
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 3
82840: NEG
82841: PUSH
82842: LD_INT 0
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 3
82851: NEG
82852: PUSH
82853: LD_INT 1
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 4
82862: NEG
82863: PUSH
82864: LD_INT 1
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 5
82873: NEG
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 5
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 5
82896: NEG
82897: PUSH
82898: LD_INT 2
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 3
82908: NEG
82909: PUSH
82910: LD_INT 2
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: LIST
82953: LIST
82954: LIST
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: LIST
82962: LIST
82963: ST_TO_ADDR
// end ; end ;
82964: GO 82967
82966: POP
// case btype of b_depot , b_warehouse :
82967: LD_VAR 0 1
82971: PUSH
82972: LD_INT 0
82974: DOUBLE
82975: EQUAL
82976: IFTRUE 82986
82978: LD_INT 1
82980: DOUBLE
82981: EQUAL
82982: IFTRUE 82986
82984: GO 83187
82986: POP
// case nation of nation_american :
82987: LD_VAR 0 5
82991: PUSH
82992: LD_INT 1
82994: DOUBLE
82995: EQUAL
82996: IFTRUE 83000
82998: GO 83056
83000: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83001: LD_ADDR_VAR 0 9
83005: PUSH
83006: LD_VAR 0 11
83010: PUSH
83011: LD_VAR 0 12
83015: PUSH
83016: LD_VAR 0 13
83020: PUSH
83021: LD_VAR 0 14
83025: PUSH
83026: LD_VAR 0 15
83030: PUSH
83031: LD_VAR 0 16
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: PUSH
83044: LD_VAR 0 4
83048: PUSH
83049: LD_INT 1
83051: PLUS
83052: ARRAY
83053: ST_TO_ADDR
83054: GO 83185
83056: LD_INT 2
83058: DOUBLE
83059: EQUAL
83060: IFTRUE 83064
83062: GO 83120
83064: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83065: LD_ADDR_VAR 0 9
83069: PUSH
83070: LD_VAR 0 17
83074: PUSH
83075: LD_VAR 0 18
83079: PUSH
83080: LD_VAR 0 19
83084: PUSH
83085: LD_VAR 0 20
83089: PUSH
83090: LD_VAR 0 21
83094: PUSH
83095: LD_VAR 0 22
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: PUSH
83108: LD_VAR 0 4
83112: PUSH
83113: LD_INT 1
83115: PLUS
83116: ARRAY
83117: ST_TO_ADDR
83118: GO 83185
83120: LD_INT 3
83122: DOUBLE
83123: EQUAL
83124: IFTRUE 83128
83126: GO 83184
83128: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83129: LD_ADDR_VAR 0 9
83133: PUSH
83134: LD_VAR 0 23
83138: PUSH
83139: LD_VAR 0 24
83143: PUSH
83144: LD_VAR 0 25
83148: PUSH
83149: LD_VAR 0 26
83153: PUSH
83154: LD_VAR 0 27
83158: PUSH
83159: LD_VAR 0 28
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: PUSH
83172: LD_VAR 0 4
83176: PUSH
83177: LD_INT 1
83179: PLUS
83180: ARRAY
83181: ST_TO_ADDR
83182: GO 83185
83184: POP
83185: GO 83740
83187: LD_INT 2
83189: DOUBLE
83190: EQUAL
83191: IFTRUE 83201
83193: LD_INT 3
83195: DOUBLE
83196: EQUAL
83197: IFTRUE 83201
83199: GO 83257
83201: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83202: LD_ADDR_VAR 0 9
83206: PUSH
83207: LD_VAR 0 29
83211: PUSH
83212: LD_VAR 0 30
83216: PUSH
83217: LD_VAR 0 31
83221: PUSH
83222: LD_VAR 0 32
83226: PUSH
83227: LD_VAR 0 33
83231: PUSH
83232: LD_VAR 0 34
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: PUSH
83245: LD_VAR 0 4
83249: PUSH
83250: LD_INT 1
83252: PLUS
83253: ARRAY
83254: ST_TO_ADDR
83255: GO 83740
83257: LD_INT 16
83259: DOUBLE
83260: EQUAL
83261: IFTRUE 83319
83263: LD_INT 17
83265: DOUBLE
83266: EQUAL
83267: IFTRUE 83319
83269: LD_INT 18
83271: DOUBLE
83272: EQUAL
83273: IFTRUE 83319
83275: LD_INT 19
83277: DOUBLE
83278: EQUAL
83279: IFTRUE 83319
83281: LD_INT 22
83283: DOUBLE
83284: EQUAL
83285: IFTRUE 83319
83287: LD_INT 20
83289: DOUBLE
83290: EQUAL
83291: IFTRUE 83319
83293: LD_INT 21
83295: DOUBLE
83296: EQUAL
83297: IFTRUE 83319
83299: LD_INT 23
83301: DOUBLE
83302: EQUAL
83303: IFTRUE 83319
83305: LD_INT 24
83307: DOUBLE
83308: EQUAL
83309: IFTRUE 83319
83311: LD_INT 25
83313: DOUBLE
83314: EQUAL
83315: IFTRUE 83319
83317: GO 83375
83319: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83320: LD_ADDR_VAR 0 9
83324: PUSH
83325: LD_VAR 0 35
83329: PUSH
83330: LD_VAR 0 36
83334: PUSH
83335: LD_VAR 0 37
83339: PUSH
83340: LD_VAR 0 38
83344: PUSH
83345: LD_VAR 0 39
83349: PUSH
83350: LD_VAR 0 40
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: PUSH
83363: LD_VAR 0 4
83367: PUSH
83368: LD_INT 1
83370: PLUS
83371: ARRAY
83372: ST_TO_ADDR
83373: GO 83740
83375: LD_INT 6
83377: DOUBLE
83378: EQUAL
83379: IFTRUE 83431
83381: LD_INT 7
83383: DOUBLE
83384: EQUAL
83385: IFTRUE 83431
83387: LD_INT 8
83389: DOUBLE
83390: EQUAL
83391: IFTRUE 83431
83393: LD_INT 13
83395: DOUBLE
83396: EQUAL
83397: IFTRUE 83431
83399: LD_INT 12
83401: DOUBLE
83402: EQUAL
83403: IFTRUE 83431
83405: LD_INT 15
83407: DOUBLE
83408: EQUAL
83409: IFTRUE 83431
83411: LD_INT 11
83413: DOUBLE
83414: EQUAL
83415: IFTRUE 83431
83417: LD_INT 14
83419: DOUBLE
83420: EQUAL
83421: IFTRUE 83431
83423: LD_INT 10
83425: DOUBLE
83426: EQUAL
83427: IFTRUE 83431
83429: GO 83487
83431: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83432: LD_ADDR_VAR 0 9
83436: PUSH
83437: LD_VAR 0 41
83441: PUSH
83442: LD_VAR 0 42
83446: PUSH
83447: LD_VAR 0 43
83451: PUSH
83452: LD_VAR 0 44
83456: PUSH
83457: LD_VAR 0 45
83461: PUSH
83462: LD_VAR 0 46
83466: PUSH
83467: EMPTY
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: PUSH
83475: LD_VAR 0 4
83479: PUSH
83480: LD_INT 1
83482: PLUS
83483: ARRAY
83484: ST_TO_ADDR
83485: GO 83740
83487: LD_INT 36
83489: DOUBLE
83490: EQUAL
83491: IFTRUE 83495
83493: GO 83551
83495: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83496: LD_ADDR_VAR 0 9
83500: PUSH
83501: LD_VAR 0 47
83505: PUSH
83506: LD_VAR 0 48
83510: PUSH
83511: LD_VAR 0 49
83515: PUSH
83516: LD_VAR 0 50
83520: PUSH
83521: LD_VAR 0 51
83525: PUSH
83526: LD_VAR 0 52
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: PUSH
83539: LD_VAR 0 4
83543: PUSH
83544: LD_INT 1
83546: PLUS
83547: ARRAY
83548: ST_TO_ADDR
83549: GO 83740
83551: LD_INT 4
83553: DOUBLE
83554: EQUAL
83555: IFTRUE 83577
83557: LD_INT 5
83559: DOUBLE
83560: EQUAL
83561: IFTRUE 83577
83563: LD_INT 34
83565: DOUBLE
83566: EQUAL
83567: IFTRUE 83577
83569: LD_INT 37
83571: DOUBLE
83572: EQUAL
83573: IFTRUE 83577
83575: GO 83633
83577: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83578: LD_ADDR_VAR 0 9
83582: PUSH
83583: LD_VAR 0 53
83587: PUSH
83588: LD_VAR 0 54
83592: PUSH
83593: LD_VAR 0 55
83597: PUSH
83598: LD_VAR 0 56
83602: PUSH
83603: LD_VAR 0 57
83607: PUSH
83608: LD_VAR 0 58
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: PUSH
83621: LD_VAR 0 4
83625: PUSH
83626: LD_INT 1
83628: PLUS
83629: ARRAY
83630: ST_TO_ADDR
83631: GO 83740
83633: LD_INT 31
83635: DOUBLE
83636: EQUAL
83637: IFTRUE 83683
83639: LD_INT 32
83641: DOUBLE
83642: EQUAL
83643: IFTRUE 83683
83645: LD_INT 33
83647: DOUBLE
83648: EQUAL
83649: IFTRUE 83683
83651: LD_INT 27
83653: DOUBLE
83654: EQUAL
83655: IFTRUE 83683
83657: LD_INT 26
83659: DOUBLE
83660: EQUAL
83661: IFTRUE 83683
83663: LD_INT 28
83665: DOUBLE
83666: EQUAL
83667: IFTRUE 83683
83669: LD_INT 29
83671: DOUBLE
83672: EQUAL
83673: IFTRUE 83683
83675: LD_INT 30
83677: DOUBLE
83678: EQUAL
83679: IFTRUE 83683
83681: GO 83739
83683: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83684: LD_ADDR_VAR 0 9
83688: PUSH
83689: LD_VAR 0 59
83693: PUSH
83694: LD_VAR 0 60
83698: PUSH
83699: LD_VAR 0 61
83703: PUSH
83704: LD_VAR 0 62
83708: PUSH
83709: LD_VAR 0 63
83713: PUSH
83714: LD_VAR 0 64
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: PUSH
83727: LD_VAR 0 4
83731: PUSH
83732: LD_INT 1
83734: PLUS
83735: ARRAY
83736: ST_TO_ADDR
83737: GO 83740
83739: POP
// temp_list2 = [ ] ;
83740: LD_ADDR_VAR 0 10
83744: PUSH
83745: EMPTY
83746: ST_TO_ADDR
// for i in temp_list do
83747: LD_ADDR_VAR 0 8
83751: PUSH
83752: LD_VAR 0 9
83756: PUSH
83757: FOR_IN
83758: IFFALSE 83810
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83760: LD_ADDR_VAR 0 10
83764: PUSH
83765: LD_VAR 0 10
83769: PUSH
83770: LD_VAR 0 8
83774: PUSH
83775: LD_INT 1
83777: ARRAY
83778: PUSH
83779: LD_VAR 0 2
83783: PLUS
83784: PUSH
83785: LD_VAR 0 8
83789: PUSH
83790: LD_INT 2
83792: ARRAY
83793: PUSH
83794: LD_VAR 0 3
83798: PLUS
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: EMPTY
83805: LIST
83806: ADD
83807: ST_TO_ADDR
83808: GO 83757
83810: POP
83811: POP
// result = temp_list2 ;
83812: LD_ADDR_VAR 0 7
83816: PUSH
83817: LD_VAR 0 10
83821: ST_TO_ADDR
// end ;
83822: LD_VAR 0 7
83826: RET
// export function EnemyInRange ( unit , dist ) ; begin
83827: LD_INT 0
83829: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83830: LD_ADDR_VAR 0 3
83834: PUSH
83835: LD_VAR 0 1
83839: PPUSH
83840: CALL_OW 255
83844: PPUSH
83845: LD_VAR 0 1
83849: PPUSH
83850: CALL_OW 250
83854: PPUSH
83855: LD_VAR 0 1
83859: PPUSH
83860: CALL_OW 251
83864: PPUSH
83865: LD_VAR 0 2
83869: PPUSH
83870: CALL 57223 0 4
83874: PUSH
83875: LD_INT 4
83877: ARRAY
83878: ST_TO_ADDR
// end ;
83879: LD_VAR 0 3
83883: RET
// export function PlayerSeeMe ( unit ) ; begin
83884: LD_INT 0
83886: PPUSH
// result := See ( your_side , unit ) ;
83887: LD_ADDR_VAR 0 2
83891: PUSH
83892: LD_OWVAR 2
83896: PPUSH
83897: LD_VAR 0 1
83901: PPUSH
83902: CALL_OW 292
83906: ST_TO_ADDR
// end ;
83907: LD_VAR 0 2
83911: RET
// export function ReverseDir ( unit ) ; begin
83912: LD_INT 0
83914: PPUSH
// if not unit then
83915: LD_VAR 0 1
83919: NOT
83920: IFFALSE 83924
// exit ;
83922: GO 83947
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83924: LD_ADDR_VAR 0 2
83928: PUSH
83929: LD_VAR 0 1
83933: PPUSH
83934: CALL_OW 254
83938: PUSH
83939: LD_INT 3
83941: PLUS
83942: PUSH
83943: LD_INT 6
83945: MOD
83946: ST_TO_ADDR
// end ;
83947: LD_VAR 0 2
83951: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83952: LD_INT 0
83954: PPUSH
83955: PPUSH
83956: PPUSH
83957: PPUSH
83958: PPUSH
// if not hexes then
83959: LD_VAR 0 2
83963: NOT
83964: IFFALSE 83968
// exit ;
83966: GO 84116
// dist := 9999 ;
83968: LD_ADDR_VAR 0 5
83972: PUSH
83973: LD_INT 9999
83975: ST_TO_ADDR
// for i = 1 to hexes do
83976: LD_ADDR_VAR 0 4
83980: PUSH
83981: DOUBLE
83982: LD_INT 1
83984: DEC
83985: ST_TO_ADDR
83986: LD_VAR 0 2
83990: PUSH
83991: FOR_TO
83992: IFFALSE 84104
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83994: LD_VAR 0 1
83998: PPUSH
83999: LD_VAR 0 2
84003: PUSH
84004: LD_VAR 0 4
84008: ARRAY
84009: PUSH
84010: LD_INT 1
84012: ARRAY
84013: PPUSH
84014: LD_VAR 0 2
84018: PUSH
84019: LD_VAR 0 4
84023: ARRAY
84024: PUSH
84025: LD_INT 2
84027: ARRAY
84028: PPUSH
84029: CALL_OW 297
84033: PUSH
84034: LD_VAR 0 5
84038: LESS
84039: IFFALSE 84102
// begin hex := hexes [ i ] ;
84041: LD_ADDR_VAR 0 7
84045: PUSH
84046: LD_VAR 0 2
84050: PUSH
84051: LD_VAR 0 4
84055: ARRAY
84056: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84057: LD_ADDR_VAR 0 5
84061: PUSH
84062: LD_VAR 0 1
84066: PPUSH
84067: LD_VAR 0 2
84071: PUSH
84072: LD_VAR 0 4
84076: ARRAY
84077: PUSH
84078: LD_INT 1
84080: ARRAY
84081: PPUSH
84082: LD_VAR 0 2
84086: PUSH
84087: LD_VAR 0 4
84091: ARRAY
84092: PUSH
84093: LD_INT 2
84095: ARRAY
84096: PPUSH
84097: CALL_OW 297
84101: ST_TO_ADDR
// end ; end ;
84102: GO 83991
84104: POP
84105: POP
// result := hex ;
84106: LD_ADDR_VAR 0 3
84110: PUSH
84111: LD_VAR 0 7
84115: ST_TO_ADDR
// end ;
84116: LD_VAR 0 3
84120: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84121: LD_INT 0
84123: PPUSH
84124: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84125: LD_VAR 0 1
84129: NOT
84130: PUSH
84131: LD_VAR 0 1
84135: PUSH
84136: LD_INT 21
84138: PUSH
84139: LD_INT 2
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 23
84148: PUSH
84149: LD_INT 2
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PPUSH
84160: CALL_OW 69
84164: IN
84165: NOT
84166: OR
84167: IFFALSE 84171
// exit ;
84169: GO 84218
// for i = 1 to 3 do
84171: LD_ADDR_VAR 0 3
84175: PUSH
84176: DOUBLE
84177: LD_INT 1
84179: DEC
84180: ST_TO_ADDR
84181: LD_INT 3
84183: PUSH
84184: FOR_TO
84185: IFFALSE 84216
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84187: LD_VAR 0 1
84191: PPUSH
84192: CALL_OW 250
84196: PPUSH
84197: LD_VAR 0 1
84201: PPUSH
84202: CALL_OW 251
84206: PPUSH
84207: LD_INT 1
84209: PPUSH
84210: CALL_OW 453
84214: GO 84184
84216: POP
84217: POP
// end ;
84218: LD_VAR 0 2
84222: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84223: LD_INT 0
84225: PPUSH
84226: PPUSH
84227: PPUSH
84228: PPUSH
84229: PPUSH
84230: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84231: LD_VAR 0 1
84235: NOT
84236: PUSH
84237: LD_VAR 0 2
84241: NOT
84242: OR
84243: PUSH
84244: LD_VAR 0 1
84248: PPUSH
84249: CALL_OW 314
84253: OR
84254: IFFALSE 84258
// exit ;
84256: GO 84699
// x := GetX ( enemy_unit ) ;
84258: LD_ADDR_VAR 0 7
84262: PUSH
84263: LD_VAR 0 2
84267: PPUSH
84268: CALL_OW 250
84272: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84273: LD_ADDR_VAR 0 8
84277: PUSH
84278: LD_VAR 0 2
84282: PPUSH
84283: CALL_OW 251
84287: ST_TO_ADDR
// if not x or not y then
84288: LD_VAR 0 7
84292: NOT
84293: PUSH
84294: LD_VAR 0 8
84298: NOT
84299: OR
84300: IFFALSE 84304
// exit ;
84302: GO 84699
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84304: LD_ADDR_VAR 0 6
84308: PUSH
84309: LD_VAR 0 7
84313: PPUSH
84314: LD_INT 0
84316: PPUSH
84317: LD_INT 4
84319: PPUSH
84320: CALL_OW 272
84324: PUSH
84325: LD_VAR 0 8
84329: PPUSH
84330: LD_INT 0
84332: PPUSH
84333: LD_INT 4
84335: PPUSH
84336: CALL_OW 273
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_VAR 0 7
84349: PPUSH
84350: LD_INT 1
84352: PPUSH
84353: LD_INT 4
84355: PPUSH
84356: CALL_OW 272
84360: PUSH
84361: LD_VAR 0 8
84365: PPUSH
84366: LD_INT 1
84368: PPUSH
84369: LD_INT 4
84371: PPUSH
84372: CALL_OW 273
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_VAR 0 7
84385: PPUSH
84386: LD_INT 2
84388: PPUSH
84389: LD_INT 4
84391: PPUSH
84392: CALL_OW 272
84396: PUSH
84397: LD_VAR 0 8
84401: PPUSH
84402: LD_INT 2
84404: PPUSH
84405: LD_INT 4
84407: PPUSH
84408: CALL_OW 273
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_VAR 0 7
84421: PPUSH
84422: LD_INT 3
84424: PPUSH
84425: LD_INT 4
84427: PPUSH
84428: CALL_OW 272
84432: PUSH
84433: LD_VAR 0 8
84437: PPUSH
84438: LD_INT 3
84440: PPUSH
84441: LD_INT 4
84443: PPUSH
84444: CALL_OW 273
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_VAR 0 7
84457: PPUSH
84458: LD_INT 4
84460: PPUSH
84461: LD_INT 4
84463: PPUSH
84464: CALL_OW 272
84468: PUSH
84469: LD_VAR 0 8
84473: PPUSH
84474: LD_INT 4
84476: PPUSH
84477: LD_INT 4
84479: PPUSH
84480: CALL_OW 273
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_VAR 0 7
84493: PPUSH
84494: LD_INT 5
84496: PPUSH
84497: LD_INT 4
84499: PPUSH
84500: CALL_OW 272
84504: PUSH
84505: LD_VAR 0 8
84509: PPUSH
84510: LD_INT 5
84512: PPUSH
84513: LD_INT 4
84515: PPUSH
84516: CALL_OW 273
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: ST_TO_ADDR
// for i = tmp downto 1 do
84533: LD_ADDR_VAR 0 4
84537: PUSH
84538: DOUBLE
84539: LD_VAR 0 6
84543: INC
84544: ST_TO_ADDR
84545: LD_INT 1
84547: PUSH
84548: FOR_DOWNTO
84549: IFFALSE 84650
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84551: LD_VAR 0 6
84555: PUSH
84556: LD_VAR 0 4
84560: ARRAY
84561: PUSH
84562: LD_INT 1
84564: ARRAY
84565: PPUSH
84566: LD_VAR 0 6
84570: PUSH
84571: LD_VAR 0 4
84575: ARRAY
84576: PUSH
84577: LD_INT 2
84579: ARRAY
84580: PPUSH
84581: CALL_OW 488
84585: NOT
84586: PUSH
84587: LD_VAR 0 6
84591: PUSH
84592: LD_VAR 0 4
84596: ARRAY
84597: PUSH
84598: LD_INT 1
84600: ARRAY
84601: PPUSH
84602: LD_VAR 0 6
84606: PUSH
84607: LD_VAR 0 4
84611: ARRAY
84612: PUSH
84613: LD_INT 2
84615: ARRAY
84616: PPUSH
84617: CALL_OW 428
84621: PUSH
84622: LD_INT 0
84624: NONEQUAL
84625: OR
84626: IFFALSE 84648
// tmp := Delete ( tmp , i ) ;
84628: LD_ADDR_VAR 0 6
84632: PUSH
84633: LD_VAR 0 6
84637: PPUSH
84638: LD_VAR 0 4
84642: PPUSH
84643: CALL_OW 3
84647: ST_TO_ADDR
84648: GO 84548
84650: POP
84651: POP
// j := GetClosestHex ( unit , tmp ) ;
84652: LD_ADDR_VAR 0 5
84656: PUSH
84657: LD_VAR 0 1
84661: PPUSH
84662: LD_VAR 0 6
84666: PPUSH
84667: CALL 83952 0 2
84671: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84672: LD_VAR 0 1
84676: PPUSH
84677: LD_VAR 0 5
84681: PUSH
84682: LD_INT 1
84684: ARRAY
84685: PPUSH
84686: LD_VAR 0 5
84690: PUSH
84691: LD_INT 2
84693: ARRAY
84694: PPUSH
84695: CALL_OW 111
// end ;
84699: LD_VAR 0 3
84703: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84704: LD_INT 0
84706: PPUSH
84707: PPUSH
84708: PPUSH
// uc_side = 0 ;
84709: LD_ADDR_OWVAR 20
84713: PUSH
84714: LD_INT 0
84716: ST_TO_ADDR
// uc_nation = 0 ;
84717: LD_ADDR_OWVAR 21
84721: PUSH
84722: LD_INT 0
84724: ST_TO_ADDR
// InitHc_All ( ) ;
84725: CALL_OW 584
// InitVc ;
84729: CALL_OW 20
// if mastodonts then
84733: LD_VAR 0 6
84737: IFFALSE 84804
// for i = 1 to mastodonts do
84739: LD_ADDR_VAR 0 11
84743: PUSH
84744: DOUBLE
84745: LD_INT 1
84747: DEC
84748: ST_TO_ADDR
84749: LD_VAR 0 6
84753: PUSH
84754: FOR_TO
84755: IFFALSE 84802
// begin vc_chassis := 31 ;
84757: LD_ADDR_OWVAR 37
84761: PUSH
84762: LD_INT 31
84764: ST_TO_ADDR
// vc_control := control_rider ;
84765: LD_ADDR_OWVAR 38
84769: PUSH
84770: LD_INT 4
84772: ST_TO_ADDR
// animal := CreateVehicle ;
84773: LD_ADDR_VAR 0 12
84777: PUSH
84778: CALL_OW 45
84782: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84783: LD_VAR 0 12
84787: PPUSH
84788: LD_VAR 0 8
84792: PPUSH
84793: LD_INT 0
84795: PPUSH
84796: CALL 86992 0 3
// end ;
84800: GO 84754
84802: POP
84803: POP
// if horses then
84804: LD_VAR 0 5
84808: IFFALSE 84875
// for i = 1 to horses do
84810: LD_ADDR_VAR 0 11
84814: PUSH
84815: DOUBLE
84816: LD_INT 1
84818: DEC
84819: ST_TO_ADDR
84820: LD_VAR 0 5
84824: PUSH
84825: FOR_TO
84826: IFFALSE 84873
// begin hc_class := 21 ;
84828: LD_ADDR_OWVAR 28
84832: PUSH
84833: LD_INT 21
84835: ST_TO_ADDR
// hc_gallery :=  ;
84836: LD_ADDR_OWVAR 33
84840: PUSH
84841: LD_STRING 
84843: ST_TO_ADDR
// animal := CreateHuman ;
84844: LD_ADDR_VAR 0 12
84848: PUSH
84849: CALL_OW 44
84853: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84854: LD_VAR 0 12
84858: PPUSH
84859: LD_VAR 0 8
84863: PPUSH
84864: LD_INT 0
84866: PPUSH
84867: CALL 86992 0 3
// end ;
84871: GO 84825
84873: POP
84874: POP
// if birds then
84875: LD_VAR 0 1
84879: IFFALSE 84946
// for i = 1 to birds do
84881: LD_ADDR_VAR 0 11
84885: PUSH
84886: DOUBLE
84887: LD_INT 1
84889: DEC
84890: ST_TO_ADDR
84891: LD_VAR 0 1
84895: PUSH
84896: FOR_TO
84897: IFFALSE 84944
// begin hc_class = 18 ;
84899: LD_ADDR_OWVAR 28
84903: PUSH
84904: LD_INT 18
84906: ST_TO_ADDR
// hc_gallery =  ;
84907: LD_ADDR_OWVAR 33
84911: PUSH
84912: LD_STRING 
84914: ST_TO_ADDR
// animal := CreateHuman ;
84915: LD_ADDR_VAR 0 12
84919: PUSH
84920: CALL_OW 44
84924: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84925: LD_VAR 0 12
84929: PPUSH
84930: LD_VAR 0 8
84934: PPUSH
84935: LD_INT 0
84937: PPUSH
84938: CALL 86992 0 3
// end ;
84942: GO 84896
84944: POP
84945: POP
// if tigers then
84946: LD_VAR 0 2
84950: IFFALSE 85034
// for i = 1 to tigers do
84952: LD_ADDR_VAR 0 11
84956: PUSH
84957: DOUBLE
84958: LD_INT 1
84960: DEC
84961: ST_TO_ADDR
84962: LD_VAR 0 2
84966: PUSH
84967: FOR_TO
84968: IFFALSE 85032
// begin hc_class = class_tiger ;
84970: LD_ADDR_OWVAR 28
84974: PUSH
84975: LD_INT 14
84977: ST_TO_ADDR
// hc_gallery =  ;
84978: LD_ADDR_OWVAR 33
84982: PUSH
84983: LD_STRING 
84985: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84986: LD_ADDR_OWVAR 35
84990: PUSH
84991: LD_INT 7
84993: NEG
84994: PPUSH
84995: LD_INT 7
84997: PPUSH
84998: CALL_OW 12
85002: ST_TO_ADDR
// animal := CreateHuman ;
85003: LD_ADDR_VAR 0 12
85007: PUSH
85008: CALL_OW 44
85012: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85013: LD_VAR 0 12
85017: PPUSH
85018: LD_VAR 0 8
85022: PPUSH
85023: LD_INT 0
85025: PPUSH
85026: CALL 86992 0 3
// end ;
85030: GO 84967
85032: POP
85033: POP
// if apemans then
85034: LD_VAR 0 3
85038: IFFALSE 85161
// for i = 1 to apemans do
85040: LD_ADDR_VAR 0 11
85044: PUSH
85045: DOUBLE
85046: LD_INT 1
85048: DEC
85049: ST_TO_ADDR
85050: LD_VAR 0 3
85054: PUSH
85055: FOR_TO
85056: IFFALSE 85159
// begin hc_class = class_apeman ;
85058: LD_ADDR_OWVAR 28
85062: PUSH
85063: LD_INT 12
85065: ST_TO_ADDR
// hc_gallery =  ;
85066: LD_ADDR_OWVAR 33
85070: PUSH
85071: LD_STRING 
85073: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85074: LD_ADDR_OWVAR 35
85078: PUSH
85079: LD_INT 2
85081: NEG
85082: PPUSH
85083: LD_INT 2
85085: PPUSH
85086: CALL_OW 12
85090: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85091: LD_ADDR_OWVAR 31
85095: PUSH
85096: LD_INT 1
85098: PPUSH
85099: LD_INT 3
85101: PPUSH
85102: CALL_OW 12
85106: PUSH
85107: LD_INT 1
85109: PPUSH
85110: LD_INT 3
85112: PPUSH
85113: CALL_OW 12
85117: PUSH
85118: LD_INT 0
85120: PUSH
85121: LD_INT 0
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: ST_TO_ADDR
// animal := CreateHuman ;
85130: LD_ADDR_VAR 0 12
85134: PUSH
85135: CALL_OW 44
85139: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85140: LD_VAR 0 12
85144: PPUSH
85145: LD_VAR 0 8
85149: PPUSH
85150: LD_INT 0
85152: PPUSH
85153: CALL 86992 0 3
// end ;
85157: GO 85055
85159: POP
85160: POP
// if enchidnas then
85161: LD_VAR 0 4
85165: IFFALSE 85232
// for i = 1 to enchidnas do
85167: LD_ADDR_VAR 0 11
85171: PUSH
85172: DOUBLE
85173: LD_INT 1
85175: DEC
85176: ST_TO_ADDR
85177: LD_VAR 0 4
85181: PUSH
85182: FOR_TO
85183: IFFALSE 85230
// begin hc_class = 13 ;
85185: LD_ADDR_OWVAR 28
85189: PUSH
85190: LD_INT 13
85192: ST_TO_ADDR
// hc_gallery =  ;
85193: LD_ADDR_OWVAR 33
85197: PUSH
85198: LD_STRING 
85200: ST_TO_ADDR
// animal := CreateHuman ;
85201: LD_ADDR_VAR 0 12
85205: PUSH
85206: CALL_OW 44
85210: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85211: LD_VAR 0 12
85215: PPUSH
85216: LD_VAR 0 8
85220: PPUSH
85221: LD_INT 0
85223: PPUSH
85224: CALL 86992 0 3
// end ;
85228: GO 85182
85230: POP
85231: POP
// if fishes then
85232: LD_VAR 0 7
85236: IFFALSE 85303
// for i = 1 to fishes do
85238: LD_ADDR_VAR 0 11
85242: PUSH
85243: DOUBLE
85244: LD_INT 1
85246: DEC
85247: ST_TO_ADDR
85248: LD_VAR 0 7
85252: PUSH
85253: FOR_TO
85254: IFFALSE 85301
// begin hc_class = 20 ;
85256: LD_ADDR_OWVAR 28
85260: PUSH
85261: LD_INT 20
85263: ST_TO_ADDR
// hc_gallery =  ;
85264: LD_ADDR_OWVAR 33
85268: PUSH
85269: LD_STRING 
85271: ST_TO_ADDR
// animal := CreateHuman ;
85272: LD_ADDR_VAR 0 12
85276: PUSH
85277: CALL_OW 44
85281: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85282: LD_VAR 0 12
85286: PPUSH
85287: LD_VAR 0 9
85291: PPUSH
85292: LD_INT 0
85294: PPUSH
85295: CALL 86992 0 3
// end ;
85299: GO 85253
85301: POP
85302: POP
// end ;
85303: LD_VAR 0 10
85307: RET
// export function WantHeal ( sci , unit ) ; begin
85308: LD_INT 0
85310: PPUSH
// if GetTaskList ( sci ) > 0 then
85311: LD_VAR 0 1
85315: PPUSH
85316: CALL_OW 437
85320: PUSH
85321: LD_INT 0
85323: GREATER
85324: IFFALSE 85394
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85326: LD_VAR 0 1
85330: PPUSH
85331: CALL_OW 437
85335: PUSH
85336: LD_INT 1
85338: ARRAY
85339: PUSH
85340: LD_INT 1
85342: ARRAY
85343: PUSH
85344: LD_STRING l
85346: EQUAL
85347: PUSH
85348: LD_VAR 0 1
85352: PPUSH
85353: CALL_OW 437
85357: PUSH
85358: LD_INT 1
85360: ARRAY
85361: PUSH
85362: LD_INT 4
85364: ARRAY
85365: PUSH
85366: LD_VAR 0 2
85370: EQUAL
85371: AND
85372: IFFALSE 85384
// result := true else
85374: LD_ADDR_VAR 0 3
85378: PUSH
85379: LD_INT 1
85381: ST_TO_ADDR
85382: GO 85392
// result := false ;
85384: LD_ADDR_VAR 0 3
85388: PUSH
85389: LD_INT 0
85391: ST_TO_ADDR
// end else
85392: GO 85402
// result := false ;
85394: LD_ADDR_VAR 0 3
85398: PUSH
85399: LD_INT 0
85401: ST_TO_ADDR
// end ;
85402: LD_VAR 0 3
85406: RET
// export function HealTarget ( sci ) ; begin
85407: LD_INT 0
85409: PPUSH
// if not sci then
85410: LD_VAR 0 1
85414: NOT
85415: IFFALSE 85419
// exit ;
85417: GO 85484
// result := 0 ;
85419: LD_ADDR_VAR 0 2
85423: PUSH
85424: LD_INT 0
85426: ST_TO_ADDR
// if GetTaskList ( sci ) then
85427: LD_VAR 0 1
85431: PPUSH
85432: CALL_OW 437
85436: IFFALSE 85484
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85438: LD_VAR 0 1
85442: PPUSH
85443: CALL_OW 437
85447: PUSH
85448: LD_INT 1
85450: ARRAY
85451: PUSH
85452: LD_INT 1
85454: ARRAY
85455: PUSH
85456: LD_STRING l
85458: EQUAL
85459: IFFALSE 85484
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85461: LD_ADDR_VAR 0 2
85465: PUSH
85466: LD_VAR 0 1
85470: PPUSH
85471: CALL_OW 437
85475: PUSH
85476: LD_INT 1
85478: ARRAY
85479: PUSH
85480: LD_INT 4
85482: ARRAY
85483: ST_TO_ADDR
// end ;
85484: LD_VAR 0 2
85488: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85489: LD_INT 0
85491: PPUSH
85492: PPUSH
85493: PPUSH
85494: PPUSH
// if not base_units then
85495: LD_VAR 0 1
85499: NOT
85500: IFFALSE 85504
// exit ;
85502: GO 85591
// result := false ;
85504: LD_ADDR_VAR 0 2
85508: PUSH
85509: LD_INT 0
85511: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85512: LD_ADDR_VAR 0 5
85516: PUSH
85517: LD_VAR 0 1
85521: PPUSH
85522: LD_INT 21
85524: PUSH
85525: LD_INT 3
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PPUSH
85532: CALL_OW 72
85536: ST_TO_ADDR
// if not tmp then
85537: LD_VAR 0 5
85541: NOT
85542: IFFALSE 85546
// exit ;
85544: GO 85591
// for i in tmp do
85546: LD_ADDR_VAR 0 3
85550: PUSH
85551: LD_VAR 0 5
85555: PUSH
85556: FOR_IN
85557: IFFALSE 85589
// begin result := EnemyInRange ( i , 22 ) ;
85559: LD_ADDR_VAR 0 2
85563: PUSH
85564: LD_VAR 0 3
85568: PPUSH
85569: LD_INT 22
85571: PPUSH
85572: CALL 83827 0 2
85576: ST_TO_ADDR
// if result then
85577: LD_VAR 0 2
85581: IFFALSE 85587
// exit ;
85583: POP
85584: POP
85585: GO 85591
// end ;
85587: GO 85556
85589: POP
85590: POP
// end ;
85591: LD_VAR 0 2
85595: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85596: LD_INT 0
85598: PPUSH
85599: PPUSH
// if not units then
85600: LD_VAR 0 1
85604: NOT
85605: IFFALSE 85609
// exit ;
85607: GO 85679
// result := [ ] ;
85609: LD_ADDR_VAR 0 3
85613: PUSH
85614: EMPTY
85615: ST_TO_ADDR
// for i in units do
85616: LD_ADDR_VAR 0 4
85620: PUSH
85621: LD_VAR 0 1
85625: PUSH
85626: FOR_IN
85627: IFFALSE 85677
// if GetTag ( i ) = tag then
85629: LD_VAR 0 4
85633: PPUSH
85634: CALL_OW 110
85638: PUSH
85639: LD_VAR 0 2
85643: EQUAL
85644: IFFALSE 85675
// result := Replace ( result , result + 1 , i ) ;
85646: LD_ADDR_VAR 0 3
85650: PUSH
85651: LD_VAR 0 3
85655: PPUSH
85656: LD_VAR 0 3
85660: PUSH
85661: LD_INT 1
85663: PLUS
85664: PPUSH
85665: LD_VAR 0 4
85669: PPUSH
85670: CALL_OW 1
85674: ST_TO_ADDR
85675: GO 85626
85677: POP
85678: POP
// end ;
85679: LD_VAR 0 3
85683: RET
// export function IsDriver ( un ) ; begin
85684: LD_INT 0
85686: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85687: LD_ADDR_VAR 0 2
85691: PUSH
85692: LD_VAR 0 1
85696: PUSH
85697: LD_INT 55
85699: PUSH
85700: EMPTY
85701: LIST
85702: PPUSH
85703: CALL_OW 69
85707: IN
85708: ST_TO_ADDR
// end ;
85709: LD_VAR 0 2
85713: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85714: LD_INT 0
85716: PPUSH
85717: PPUSH
// list := [ ] ;
85718: LD_ADDR_VAR 0 5
85722: PUSH
85723: EMPTY
85724: ST_TO_ADDR
// case d of 0 :
85725: LD_VAR 0 3
85729: PUSH
85730: LD_INT 0
85732: DOUBLE
85733: EQUAL
85734: IFTRUE 85738
85736: GO 85871
85738: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85739: LD_ADDR_VAR 0 5
85743: PUSH
85744: LD_VAR 0 1
85748: PUSH
85749: LD_INT 4
85751: MINUS
85752: PUSH
85753: LD_VAR 0 2
85757: PUSH
85758: LD_INT 4
85760: MINUS
85761: PUSH
85762: LD_INT 2
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: LIST
85769: PUSH
85770: LD_VAR 0 1
85774: PUSH
85775: LD_INT 3
85777: MINUS
85778: PUSH
85779: LD_VAR 0 2
85783: PUSH
85784: LD_INT 1
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: LIST
85791: PUSH
85792: LD_VAR 0 1
85796: PUSH
85797: LD_INT 4
85799: PLUS
85800: PUSH
85801: LD_VAR 0 2
85805: PUSH
85806: LD_INT 4
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: LIST
85813: PUSH
85814: LD_VAR 0 1
85818: PUSH
85819: LD_INT 3
85821: PLUS
85822: PUSH
85823: LD_VAR 0 2
85827: PUSH
85828: LD_INT 3
85830: PLUS
85831: PUSH
85832: LD_INT 5
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: LIST
85839: PUSH
85840: LD_VAR 0 1
85844: PUSH
85845: LD_VAR 0 2
85849: PUSH
85850: LD_INT 4
85852: PLUS
85853: PUSH
85854: LD_INT 0
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: LIST
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: ST_TO_ADDR
// end ; 1 :
85869: GO 86569
85871: LD_INT 1
85873: DOUBLE
85874: EQUAL
85875: IFTRUE 85879
85877: GO 86012
85879: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85880: LD_ADDR_VAR 0 5
85884: PUSH
85885: LD_VAR 0 1
85889: PUSH
85890: LD_VAR 0 2
85894: PUSH
85895: LD_INT 4
85897: MINUS
85898: PUSH
85899: LD_INT 3
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: LIST
85906: PUSH
85907: LD_VAR 0 1
85911: PUSH
85912: LD_INT 3
85914: MINUS
85915: PUSH
85916: LD_VAR 0 2
85920: PUSH
85921: LD_INT 3
85923: MINUS
85924: PUSH
85925: LD_INT 2
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: LIST
85932: PUSH
85933: LD_VAR 0 1
85937: PUSH
85938: LD_INT 4
85940: MINUS
85941: PUSH
85942: LD_VAR 0 2
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: LIST
85954: PUSH
85955: LD_VAR 0 1
85959: PUSH
85960: LD_VAR 0 2
85964: PUSH
85965: LD_INT 3
85967: PLUS
85968: PUSH
85969: LD_INT 0
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: LIST
85976: PUSH
85977: LD_VAR 0 1
85981: PUSH
85982: LD_INT 4
85984: PLUS
85985: PUSH
85986: LD_VAR 0 2
85990: PUSH
85991: LD_INT 4
85993: PLUS
85994: PUSH
85995: LD_INT 5
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: LIST
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: ST_TO_ADDR
// end ; 2 :
86010: GO 86569
86012: LD_INT 2
86014: DOUBLE
86015: EQUAL
86016: IFTRUE 86020
86018: GO 86149
86020: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86021: LD_ADDR_VAR 0 5
86025: PUSH
86026: LD_VAR 0 1
86030: PUSH
86031: LD_VAR 0 2
86035: PUSH
86036: LD_INT 3
86038: MINUS
86039: PUSH
86040: LD_INT 3
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: LIST
86047: PUSH
86048: LD_VAR 0 1
86052: PUSH
86053: LD_INT 4
86055: PLUS
86056: PUSH
86057: LD_VAR 0 2
86061: PUSH
86062: LD_INT 4
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: LIST
86069: PUSH
86070: LD_VAR 0 1
86074: PUSH
86075: LD_VAR 0 2
86079: PUSH
86080: LD_INT 4
86082: PLUS
86083: PUSH
86084: LD_INT 0
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: LIST
86091: PUSH
86092: LD_VAR 0 1
86096: PUSH
86097: LD_INT 3
86099: MINUS
86100: PUSH
86101: LD_VAR 0 2
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: LIST
86113: PUSH
86114: LD_VAR 0 1
86118: PUSH
86119: LD_INT 4
86121: MINUS
86122: PUSH
86123: LD_VAR 0 2
86127: PUSH
86128: LD_INT 4
86130: MINUS
86131: PUSH
86132: LD_INT 2
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: LIST
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: ST_TO_ADDR
// end ; 3 :
86147: GO 86569
86149: LD_INT 3
86151: DOUBLE
86152: EQUAL
86153: IFTRUE 86157
86155: GO 86290
86157: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86158: LD_ADDR_VAR 0 5
86162: PUSH
86163: LD_VAR 0 1
86167: PUSH
86168: LD_INT 3
86170: PLUS
86171: PUSH
86172: LD_VAR 0 2
86176: PUSH
86177: LD_INT 4
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: LIST
86184: PUSH
86185: LD_VAR 0 1
86189: PUSH
86190: LD_INT 4
86192: PLUS
86193: PUSH
86194: LD_VAR 0 2
86198: PUSH
86199: LD_INT 4
86201: PLUS
86202: PUSH
86203: LD_INT 5
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: LIST
86210: PUSH
86211: LD_VAR 0 1
86215: PUSH
86216: LD_INT 4
86218: MINUS
86219: PUSH
86220: LD_VAR 0 2
86224: PUSH
86225: LD_INT 1
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: LIST
86232: PUSH
86233: LD_VAR 0 1
86237: PUSH
86238: LD_VAR 0 2
86242: PUSH
86243: LD_INT 4
86245: MINUS
86246: PUSH
86247: LD_INT 3
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: LIST
86254: PUSH
86255: LD_VAR 0 1
86259: PUSH
86260: LD_INT 3
86262: MINUS
86263: PUSH
86264: LD_VAR 0 2
86268: PUSH
86269: LD_INT 3
86271: MINUS
86272: PUSH
86273: LD_INT 2
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: LIST
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: LIST
86285: LIST
86286: LIST
86287: ST_TO_ADDR
// end ; 4 :
86288: GO 86569
86290: LD_INT 4
86292: DOUBLE
86293: EQUAL
86294: IFTRUE 86298
86296: GO 86431
86298: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86299: LD_ADDR_VAR 0 5
86303: PUSH
86304: LD_VAR 0 1
86308: PUSH
86309: LD_VAR 0 2
86313: PUSH
86314: LD_INT 4
86316: PLUS
86317: PUSH
86318: LD_INT 0
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: LIST
86325: PUSH
86326: LD_VAR 0 1
86330: PUSH
86331: LD_INT 3
86333: PLUS
86334: PUSH
86335: LD_VAR 0 2
86339: PUSH
86340: LD_INT 3
86342: PLUS
86343: PUSH
86344: LD_INT 5
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: LIST
86351: PUSH
86352: LD_VAR 0 1
86356: PUSH
86357: LD_INT 4
86359: PLUS
86360: PUSH
86361: LD_VAR 0 2
86365: PUSH
86366: LD_INT 4
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: PUSH
86374: LD_VAR 0 1
86378: PUSH
86379: LD_VAR 0 2
86383: PUSH
86384: LD_INT 3
86386: MINUS
86387: PUSH
86388: LD_INT 3
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: LIST
86395: PUSH
86396: LD_VAR 0 1
86400: PUSH
86401: LD_INT 4
86403: MINUS
86404: PUSH
86405: LD_VAR 0 2
86409: PUSH
86410: LD_INT 4
86412: MINUS
86413: PUSH
86414: LD_INT 2
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: LIST
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: ST_TO_ADDR
// end ; 5 :
86429: GO 86569
86431: LD_INT 5
86433: DOUBLE
86434: EQUAL
86435: IFTRUE 86439
86437: GO 86568
86439: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86440: LD_ADDR_VAR 0 5
86444: PUSH
86445: LD_VAR 0 1
86449: PUSH
86450: LD_INT 4
86452: MINUS
86453: PUSH
86454: LD_VAR 0 2
86458: PUSH
86459: LD_INT 1
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: LIST
86466: PUSH
86467: LD_VAR 0 1
86471: PUSH
86472: LD_VAR 0 2
86476: PUSH
86477: LD_INT 4
86479: MINUS
86480: PUSH
86481: LD_INT 3
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: LIST
86488: PUSH
86489: LD_VAR 0 1
86493: PUSH
86494: LD_INT 4
86496: PLUS
86497: PUSH
86498: LD_VAR 0 2
86502: PUSH
86503: LD_INT 4
86505: PLUS
86506: PUSH
86507: LD_INT 5
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: LIST
86514: PUSH
86515: LD_VAR 0 1
86519: PUSH
86520: LD_INT 3
86522: PLUS
86523: PUSH
86524: LD_VAR 0 2
86528: PUSH
86529: LD_INT 4
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: LIST
86536: PUSH
86537: LD_VAR 0 1
86541: PUSH
86542: LD_VAR 0 2
86546: PUSH
86547: LD_INT 3
86549: PLUS
86550: PUSH
86551: LD_INT 0
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: LIST
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: ST_TO_ADDR
// end ; end ;
86566: GO 86569
86568: POP
// result := list ;
86569: LD_ADDR_VAR 0 4
86573: PUSH
86574: LD_VAR 0 5
86578: ST_TO_ADDR
// end ;
86579: LD_VAR 0 4
86583: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86584: LD_INT 0
86586: PPUSH
86587: PPUSH
86588: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86589: LD_VAR 0 1
86593: NOT
86594: PUSH
86595: LD_VAR 0 2
86599: PUSH
86600: LD_INT 1
86602: PUSH
86603: LD_INT 2
86605: PUSH
86606: LD_INT 3
86608: PUSH
86609: LD_INT 4
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: IN
86618: NOT
86619: OR
86620: IFFALSE 86624
// exit ;
86622: GO 86716
// tmp := [ ] ;
86624: LD_ADDR_VAR 0 5
86628: PUSH
86629: EMPTY
86630: ST_TO_ADDR
// for i in units do
86631: LD_ADDR_VAR 0 4
86635: PUSH
86636: LD_VAR 0 1
86640: PUSH
86641: FOR_IN
86642: IFFALSE 86685
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86644: LD_ADDR_VAR 0 5
86648: PUSH
86649: LD_VAR 0 5
86653: PPUSH
86654: LD_VAR 0 5
86658: PUSH
86659: LD_INT 1
86661: PLUS
86662: PPUSH
86663: LD_VAR 0 4
86667: PPUSH
86668: LD_VAR 0 2
86672: PPUSH
86673: CALL_OW 259
86677: PPUSH
86678: CALL_OW 2
86682: ST_TO_ADDR
86683: GO 86641
86685: POP
86686: POP
// if not tmp then
86687: LD_VAR 0 5
86691: NOT
86692: IFFALSE 86696
// exit ;
86694: GO 86716
// result := SortListByListDesc ( units , tmp ) ;
86696: LD_ADDR_VAR 0 3
86700: PUSH
86701: LD_VAR 0 1
86705: PPUSH
86706: LD_VAR 0 5
86710: PPUSH
86711: CALL_OW 77
86715: ST_TO_ADDR
// end ;
86716: LD_VAR 0 3
86720: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86721: LD_INT 0
86723: PPUSH
86724: PPUSH
86725: PPUSH
// result := false ;
86726: LD_ADDR_VAR 0 3
86730: PUSH
86731: LD_INT 0
86733: ST_TO_ADDR
// x := GetX ( building ) ;
86734: LD_ADDR_VAR 0 4
86738: PUSH
86739: LD_VAR 0 2
86743: PPUSH
86744: CALL_OW 250
86748: ST_TO_ADDR
// y := GetY ( building ) ;
86749: LD_ADDR_VAR 0 5
86753: PUSH
86754: LD_VAR 0 2
86758: PPUSH
86759: CALL_OW 251
86763: ST_TO_ADDR
// if not building or not x or not y then
86764: LD_VAR 0 2
86768: NOT
86769: PUSH
86770: LD_VAR 0 4
86774: NOT
86775: OR
86776: PUSH
86777: LD_VAR 0 5
86781: NOT
86782: OR
86783: IFFALSE 86787
// exit ;
86785: GO 86879
// if GetTaskList ( unit ) then
86787: LD_VAR 0 1
86791: PPUSH
86792: CALL_OW 437
86796: IFFALSE 86879
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86798: LD_STRING e
86800: PUSH
86801: LD_VAR 0 1
86805: PPUSH
86806: CALL_OW 437
86810: PUSH
86811: LD_INT 1
86813: ARRAY
86814: PUSH
86815: LD_INT 1
86817: ARRAY
86818: EQUAL
86819: PUSH
86820: LD_VAR 0 4
86824: PUSH
86825: LD_VAR 0 1
86829: PPUSH
86830: CALL_OW 437
86834: PUSH
86835: LD_INT 1
86837: ARRAY
86838: PUSH
86839: LD_INT 2
86841: ARRAY
86842: EQUAL
86843: AND
86844: PUSH
86845: LD_VAR 0 5
86849: PUSH
86850: LD_VAR 0 1
86854: PPUSH
86855: CALL_OW 437
86859: PUSH
86860: LD_INT 1
86862: ARRAY
86863: PUSH
86864: LD_INT 3
86866: ARRAY
86867: EQUAL
86868: AND
86869: IFFALSE 86879
// result := true end ;
86871: LD_ADDR_VAR 0 3
86875: PUSH
86876: LD_INT 1
86878: ST_TO_ADDR
// end ;
86879: LD_VAR 0 3
86883: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86884: LD_INT 0
86886: PPUSH
// result := false ;
86887: LD_ADDR_VAR 0 4
86891: PUSH
86892: LD_INT 0
86894: ST_TO_ADDR
// if GetTaskList ( unit ) then
86895: LD_VAR 0 1
86899: PPUSH
86900: CALL_OW 437
86904: IFFALSE 86987
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86906: LD_STRING M
86908: PUSH
86909: LD_VAR 0 1
86913: PPUSH
86914: CALL_OW 437
86918: PUSH
86919: LD_INT 1
86921: ARRAY
86922: PUSH
86923: LD_INT 1
86925: ARRAY
86926: EQUAL
86927: PUSH
86928: LD_VAR 0 2
86932: PUSH
86933: LD_VAR 0 1
86937: PPUSH
86938: CALL_OW 437
86942: PUSH
86943: LD_INT 1
86945: ARRAY
86946: PUSH
86947: LD_INT 2
86949: ARRAY
86950: EQUAL
86951: AND
86952: PUSH
86953: LD_VAR 0 3
86957: PUSH
86958: LD_VAR 0 1
86962: PPUSH
86963: CALL_OW 437
86967: PUSH
86968: LD_INT 1
86970: ARRAY
86971: PUSH
86972: LD_INT 3
86974: ARRAY
86975: EQUAL
86976: AND
86977: IFFALSE 86987
// result := true ;
86979: LD_ADDR_VAR 0 4
86983: PUSH
86984: LD_INT 1
86986: ST_TO_ADDR
// end ; end ;
86987: LD_VAR 0 4
86991: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86992: LD_INT 0
86994: PPUSH
86995: PPUSH
86996: PPUSH
86997: PPUSH
// if not unit or not area then
86998: LD_VAR 0 1
87002: NOT
87003: PUSH
87004: LD_VAR 0 2
87008: NOT
87009: OR
87010: IFFALSE 87014
// exit ;
87012: GO 87178
// tmp := AreaToList ( area , i ) ;
87014: LD_ADDR_VAR 0 6
87018: PUSH
87019: LD_VAR 0 2
87023: PPUSH
87024: LD_VAR 0 5
87028: PPUSH
87029: CALL_OW 517
87033: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87034: LD_ADDR_VAR 0 5
87038: PUSH
87039: DOUBLE
87040: LD_INT 1
87042: DEC
87043: ST_TO_ADDR
87044: LD_VAR 0 6
87048: PUSH
87049: LD_INT 1
87051: ARRAY
87052: PUSH
87053: FOR_TO
87054: IFFALSE 87176
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87056: LD_ADDR_VAR 0 7
87060: PUSH
87061: LD_VAR 0 6
87065: PUSH
87066: LD_INT 1
87068: ARRAY
87069: PUSH
87070: LD_VAR 0 5
87074: ARRAY
87075: PUSH
87076: LD_VAR 0 6
87080: PUSH
87081: LD_INT 2
87083: ARRAY
87084: PUSH
87085: LD_VAR 0 5
87089: ARRAY
87090: PUSH
87091: EMPTY
87092: LIST
87093: LIST
87094: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87095: LD_VAR 0 7
87099: PUSH
87100: LD_INT 1
87102: ARRAY
87103: PPUSH
87104: LD_VAR 0 7
87108: PUSH
87109: LD_INT 2
87111: ARRAY
87112: PPUSH
87113: CALL_OW 428
87117: PUSH
87118: LD_INT 0
87120: EQUAL
87121: IFFALSE 87174
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87123: LD_VAR 0 1
87127: PPUSH
87128: LD_VAR 0 7
87132: PUSH
87133: LD_INT 1
87135: ARRAY
87136: PPUSH
87137: LD_VAR 0 7
87141: PUSH
87142: LD_INT 2
87144: ARRAY
87145: PPUSH
87146: LD_VAR 0 3
87150: PPUSH
87151: CALL_OW 48
// result := IsPlaced ( unit ) ;
87155: LD_ADDR_VAR 0 4
87159: PUSH
87160: LD_VAR 0 1
87164: PPUSH
87165: CALL_OW 305
87169: ST_TO_ADDR
// exit ;
87170: POP
87171: POP
87172: GO 87178
// end ; end ;
87174: GO 87053
87176: POP
87177: POP
// end ;
87178: LD_VAR 0 4
87182: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87183: LD_INT 0
87185: PPUSH
87186: PPUSH
87187: PPUSH
// if not side or side > 8 then
87188: LD_VAR 0 1
87192: NOT
87193: PUSH
87194: LD_VAR 0 1
87198: PUSH
87199: LD_INT 8
87201: GREATER
87202: OR
87203: IFFALSE 87207
// exit ;
87205: GO 87394
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87207: LD_ADDR_VAR 0 4
87211: PUSH
87212: LD_INT 22
87214: PUSH
87215: LD_VAR 0 1
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 21
87226: PUSH
87227: LD_INT 3
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: PPUSH
87238: CALL_OW 69
87242: ST_TO_ADDR
// if not tmp then
87243: LD_VAR 0 4
87247: NOT
87248: IFFALSE 87252
// exit ;
87250: GO 87394
// enable_addtolog := true ;
87252: LD_ADDR_OWVAR 81
87256: PUSH
87257: LD_INT 1
87259: ST_TO_ADDR
// AddToLog ( [ ) ;
87260: LD_STRING [
87262: PPUSH
87263: CALL_OW 561
// for i in tmp do
87267: LD_ADDR_VAR 0 3
87271: PUSH
87272: LD_VAR 0 4
87276: PUSH
87277: FOR_IN
87278: IFFALSE 87385
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87280: LD_STRING [
87282: PUSH
87283: LD_VAR 0 3
87287: PPUSH
87288: CALL_OW 266
87292: STR
87293: PUSH
87294: LD_STRING , 
87296: STR
87297: PUSH
87298: LD_VAR 0 3
87302: PPUSH
87303: CALL_OW 250
87307: STR
87308: PUSH
87309: LD_STRING , 
87311: STR
87312: PUSH
87313: LD_VAR 0 3
87317: PPUSH
87318: CALL_OW 251
87322: STR
87323: PUSH
87324: LD_STRING , 
87326: STR
87327: PUSH
87328: LD_VAR 0 3
87332: PPUSH
87333: CALL_OW 254
87337: STR
87338: PUSH
87339: LD_STRING , 
87341: STR
87342: PUSH
87343: LD_VAR 0 3
87347: PPUSH
87348: LD_INT 1
87350: PPUSH
87351: CALL_OW 268
87355: STR
87356: PUSH
87357: LD_STRING , 
87359: STR
87360: PUSH
87361: LD_VAR 0 3
87365: PPUSH
87366: LD_INT 2
87368: PPUSH
87369: CALL_OW 268
87373: STR
87374: PUSH
87375: LD_STRING ],
87377: STR
87378: PPUSH
87379: CALL_OW 561
// end ;
87383: GO 87277
87385: POP
87386: POP
// AddToLog ( ]; ) ;
87387: LD_STRING ];
87389: PPUSH
87390: CALL_OW 561
// end ;
87394: LD_VAR 0 2
87398: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87399: LD_INT 0
87401: PPUSH
87402: PPUSH
87403: PPUSH
87404: PPUSH
87405: PPUSH
// if not area or not rate or not max then
87406: LD_VAR 0 1
87410: NOT
87411: PUSH
87412: LD_VAR 0 2
87416: NOT
87417: OR
87418: PUSH
87419: LD_VAR 0 4
87423: NOT
87424: OR
87425: IFFALSE 87429
// exit ;
87427: GO 87621
// while 1 do
87429: LD_INT 1
87431: IFFALSE 87621
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87433: LD_ADDR_VAR 0 9
87437: PUSH
87438: LD_VAR 0 1
87442: PPUSH
87443: LD_INT 1
87445: PPUSH
87446: CALL_OW 287
87450: PUSH
87451: LD_INT 10
87453: MUL
87454: ST_TO_ADDR
// r := rate / 10 ;
87455: LD_ADDR_VAR 0 7
87459: PUSH
87460: LD_VAR 0 2
87464: PUSH
87465: LD_INT 10
87467: DIVREAL
87468: ST_TO_ADDR
// time := 1 1$00 ;
87469: LD_ADDR_VAR 0 8
87473: PUSH
87474: LD_INT 2100
87476: ST_TO_ADDR
// if amount < min then
87477: LD_VAR 0 9
87481: PUSH
87482: LD_VAR 0 3
87486: LESS
87487: IFFALSE 87505
// r := r * 2 else
87489: LD_ADDR_VAR 0 7
87493: PUSH
87494: LD_VAR 0 7
87498: PUSH
87499: LD_INT 2
87501: MUL
87502: ST_TO_ADDR
87503: GO 87531
// if amount > max then
87505: LD_VAR 0 9
87509: PUSH
87510: LD_VAR 0 4
87514: GREATER
87515: IFFALSE 87531
// r := r / 2 ;
87517: LD_ADDR_VAR 0 7
87521: PUSH
87522: LD_VAR 0 7
87526: PUSH
87527: LD_INT 2
87529: DIVREAL
87530: ST_TO_ADDR
// time := time / r ;
87531: LD_ADDR_VAR 0 8
87535: PUSH
87536: LD_VAR 0 8
87540: PUSH
87541: LD_VAR 0 7
87545: DIVREAL
87546: ST_TO_ADDR
// if time < 0 then
87547: LD_VAR 0 8
87551: PUSH
87552: LD_INT 0
87554: LESS
87555: IFFALSE 87572
// time := time * - 1 ;
87557: LD_ADDR_VAR 0 8
87561: PUSH
87562: LD_VAR 0 8
87566: PUSH
87567: LD_INT 1
87569: NEG
87570: MUL
87571: ST_TO_ADDR
// wait ( time ) ;
87572: LD_VAR 0 8
87576: PPUSH
87577: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87581: LD_INT 35
87583: PPUSH
87584: LD_INT 875
87586: PPUSH
87587: CALL_OW 12
87591: PPUSH
87592: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87596: LD_INT 1
87598: PPUSH
87599: LD_INT 5
87601: PPUSH
87602: CALL_OW 12
87606: PPUSH
87607: LD_VAR 0 1
87611: PPUSH
87612: LD_INT 1
87614: PPUSH
87615: CALL_OW 55
// end ;
87619: GO 87429
// end ;
87621: LD_VAR 0 5
87625: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87626: LD_INT 0
87628: PPUSH
87629: PPUSH
87630: PPUSH
87631: PPUSH
87632: PPUSH
87633: PPUSH
87634: PPUSH
87635: PPUSH
// if not turrets or not factories then
87636: LD_VAR 0 1
87640: NOT
87641: PUSH
87642: LD_VAR 0 2
87646: NOT
87647: OR
87648: IFFALSE 87652
// exit ;
87650: GO 87959
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87652: LD_ADDR_VAR 0 10
87656: PUSH
87657: LD_INT 5
87659: PUSH
87660: LD_INT 6
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 2
87669: PUSH
87670: LD_INT 4
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 3
87679: PUSH
87680: LD_INT 5
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 24
87694: PUSH
87695: LD_INT 25
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 23
87704: PUSH
87705: LD_INT 27
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 42
87718: PUSH
87719: LD_INT 43
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 44
87728: PUSH
87729: LD_INT 46
87731: PUSH
87732: EMPTY
87733: LIST
87734: LIST
87735: PUSH
87736: LD_INT 45
87738: PUSH
87739: LD_INT 47
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: LIST
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: LIST
87755: ST_TO_ADDR
// result := [ ] ;
87756: LD_ADDR_VAR 0 3
87760: PUSH
87761: EMPTY
87762: ST_TO_ADDR
// for i in turrets do
87763: LD_ADDR_VAR 0 4
87767: PUSH
87768: LD_VAR 0 1
87772: PUSH
87773: FOR_IN
87774: IFFALSE 87957
// begin nat := GetNation ( i ) ;
87776: LD_ADDR_VAR 0 7
87780: PUSH
87781: LD_VAR 0 4
87785: PPUSH
87786: CALL_OW 248
87790: ST_TO_ADDR
// weapon := 0 ;
87791: LD_ADDR_VAR 0 8
87795: PUSH
87796: LD_INT 0
87798: ST_TO_ADDR
// if not nat then
87799: LD_VAR 0 7
87803: NOT
87804: IFFALSE 87808
// continue ;
87806: GO 87773
// for j in list [ nat ] do
87808: LD_ADDR_VAR 0 5
87812: PUSH
87813: LD_VAR 0 10
87817: PUSH
87818: LD_VAR 0 7
87822: ARRAY
87823: PUSH
87824: FOR_IN
87825: IFFALSE 87866
// if GetBWeapon ( i ) = j [ 1 ] then
87827: LD_VAR 0 4
87831: PPUSH
87832: CALL_OW 269
87836: PUSH
87837: LD_VAR 0 5
87841: PUSH
87842: LD_INT 1
87844: ARRAY
87845: EQUAL
87846: IFFALSE 87864
// begin weapon := j [ 2 ] ;
87848: LD_ADDR_VAR 0 8
87852: PUSH
87853: LD_VAR 0 5
87857: PUSH
87858: LD_INT 2
87860: ARRAY
87861: ST_TO_ADDR
// break ;
87862: GO 87866
// end ;
87864: GO 87824
87866: POP
87867: POP
// if not weapon then
87868: LD_VAR 0 8
87872: NOT
87873: IFFALSE 87877
// continue ;
87875: GO 87773
// for k in factories do
87877: LD_ADDR_VAR 0 6
87881: PUSH
87882: LD_VAR 0 2
87886: PUSH
87887: FOR_IN
87888: IFFALSE 87953
// begin weapons := AvailableWeaponList ( k ) ;
87890: LD_ADDR_VAR 0 9
87894: PUSH
87895: LD_VAR 0 6
87899: PPUSH
87900: CALL_OW 478
87904: ST_TO_ADDR
// if not weapons then
87905: LD_VAR 0 9
87909: NOT
87910: IFFALSE 87914
// continue ;
87912: GO 87887
// if weapon in weapons then
87914: LD_VAR 0 8
87918: PUSH
87919: LD_VAR 0 9
87923: IN
87924: IFFALSE 87951
// begin result := [ i , weapon ] ;
87926: LD_ADDR_VAR 0 3
87930: PUSH
87931: LD_VAR 0 4
87935: PUSH
87936: LD_VAR 0 8
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: ST_TO_ADDR
// exit ;
87945: POP
87946: POP
87947: POP
87948: POP
87949: GO 87959
// end ; end ;
87951: GO 87887
87953: POP
87954: POP
// end ;
87955: GO 87773
87957: POP
87958: POP
// end ;
87959: LD_VAR 0 3
87963: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87964: LD_INT 0
87966: PPUSH
// if not side or side > 8 then
87967: LD_VAR 0 3
87971: NOT
87972: PUSH
87973: LD_VAR 0 3
87977: PUSH
87978: LD_INT 8
87980: GREATER
87981: OR
87982: IFFALSE 87986
// exit ;
87984: GO 88045
// if not range then
87986: LD_VAR 0 4
87990: NOT
87991: IFFALSE 88002
// range := - 12 ;
87993: LD_ADDR_VAR 0 4
87997: PUSH
87998: LD_INT 12
88000: NEG
88001: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88002: LD_VAR 0 1
88006: PPUSH
88007: LD_VAR 0 2
88011: PPUSH
88012: LD_VAR 0 3
88016: PPUSH
88017: LD_VAR 0 4
88021: PPUSH
88022: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88026: LD_VAR 0 1
88030: PPUSH
88031: LD_VAR 0 2
88035: PPUSH
88036: LD_VAR 0 3
88040: PPUSH
88041: CALL_OW 331
// end ;
88045: LD_VAR 0 5
88049: RET
// export function Video ( mode ) ; begin
88050: LD_INT 0
88052: PPUSH
// ingame_video = mode ;
88053: LD_ADDR_OWVAR 52
88057: PUSH
88058: LD_VAR 0 1
88062: ST_TO_ADDR
// interface_hidden = mode ;
88063: LD_ADDR_OWVAR 54
88067: PUSH
88068: LD_VAR 0 1
88072: ST_TO_ADDR
// end ;
88073: LD_VAR 0 2
88077: RET
// export function Join ( array , element ) ; begin
88078: LD_INT 0
88080: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88081: LD_ADDR_VAR 0 3
88085: PUSH
88086: LD_VAR 0 1
88090: PPUSH
88091: LD_VAR 0 1
88095: PUSH
88096: LD_INT 1
88098: PLUS
88099: PPUSH
88100: LD_VAR 0 2
88104: PPUSH
88105: CALL_OW 1
88109: ST_TO_ADDR
// end ;
88110: LD_VAR 0 3
88114: RET
// export function JoinUnion ( array , element ) ; begin
88115: LD_INT 0
88117: PPUSH
// result := array union element ;
88118: LD_ADDR_VAR 0 3
88122: PUSH
88123: LD_VAR 0 1
88127: PUSH
88128: LD_VAR 0 2
88132: UNION
88133: ST_TO_ADDR
// end ;
88134: LD_VAR 0 3
88138: RET
// export function GetBehemoths ( side ) ; begin
88139: LD_INT 0
88141: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88142: LD_ADDR_VAR 0 2
88146: PUSH
88147: LD_INT 22
88149: PUSH
88150: LD_VAR 0 1
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 31
88161: PUSH
88162: LD_INT 25
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PPUSH
88173: CALL_OW 69
88177: ST_TO_ADDR
// end ;
88178: LD_VAR 0 2
88182: RET
// export function Shuffle ( array ) ; var i , index ; begin
88183: LD_INT 0
88185: PPUSH
88186: PPUSH
88187: PPUSH
// result := [ ] ;
88188: LD_ADDR_VAR 0 2
88192: PUSH
88193: EMPTY
88194: ST_TO_ADDR
// if not array then
88195: LD_VAR 0 1
88199: NOT
88200: IFFALSE 88204
// exit ;
88202: GO 88303
// Randomize ;
88204: CALL_OW 10
// for i = array downto 1 do
88208: LD_ADDR_VAR 0 3
88212: PUSH
88213: DOUBLE
88214: LD_VAR 0 1
88218: INC
88219: ST_TO_ADDR
88220: LD_INT 1
88222: PUSH
88223: FOR_DOWNTO
88224: IFFALSE 88301
// begin index := rand ( 1 , array ) ;
88226: LD_ADDR_VAR 0 4
88230: PUSH
88231: LD_INT 1
88233: PPUSH
88234: LD_VAR 0 1
88238: PPUSH
88239: CALL_OW 12
88243: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88244: LD_ADDR_VAR 0 2
88248: PUSH
88249: LD_VAR 0 2
88253: PPUSH
88254: LD_VAR 0 2
88258: PUSH
88259: LD_INT 1
88261: PLUS
88262: PPUSH
88263: LD_VAR 0 1
88267: PUSH
88268: LD_VAR 0 4
88272: ARRAY
88273: PPUSH
88274: CALL_OW 2
88278: ST_TO_ADDR
// array := Delete ( array , index ) ;
88279: LD_ADDR_VAR 0 1
88283: PUSH
88284: LD_VAR 0 1
88288: PPUSH
88289: LD_VAR 0 4
88293: PPUSH
88294: CALL_OW 3
88298: ST_TO_ADDR
// end ;
88299: GO 88223
88301: POP
88302: POP
// end ;
88303: LD_VAR 0 2
88307: RET
// export function GetBaseMaterials ( base ) ; begin
88308: LD_INT 0
88310: PPUSH
// result := [ 0 , 0 , 0 ] ;
88311: LD_ADDR_VAR 0 2
88315: PUSH
88316: LD_INT 0
88318: PUSH
88319: LD_INT 0
88321: PUSH
88322: LD_INT 0
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: LIST
88329: ST_TO_ADDR
// if not base then
88330: LD_VAR 0 1
88334: NOT
88335: IFFALSE 88339
// exit ;
88337: GO 88388
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88339: LD_ADDR_VAR 0 2
88343: PUSH
88344: LD_VAR 0 1
88348: PPUSH
88349: LD_INT 1
88351: PPUSH
88352: CALL_OW 275
88356: PUSH
88357: LD_VAR 0 1
88361: PPUSH
88362: LD_INT 2
88364: PPUSH
88365: CALL_OW 275
88369: PUSH
88370: LD_VAR 0 1
88374: PPUSH
88375: LD_INT 3
88377: PPUSH
88378: CALL_OW 275
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: LIST
88387: ST_TO_ADDR
// end ;
88388: LD_VAR 0 2
88392: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88393: LD_INT 0
88395: PPUSH
88396: PPUSH
// result := array ;
88397: LD_ADDR_VAR 0 3
88401: PUSH
88402: LD_VAR 0 1
88406: ST_TO_ADDR
// if size > 0 then
88407: LD_VAR 0 2
88411: PUSH
88412: LD_INT 0
88414: GREATER
88415: IFFALSE 88461
// for i := array downto size do
88417: LD_ADDR_VAR 0 4
88421: PUSH
88422: DOUBLE
88423: LD_VAR 0 1
88427: INC
88428: ST_TO_ADDR
88429: LD_VAR 0 2
88433: PUSH
88434: FOR_DOWNTO
88435: IFFALSE 88459
// result := Delete ( result , result ) ;
88437: LD_ADDR_VAR 0 3
88441: PUSH
88442: LD_VAR 0 3
88446: PPUSH
88447: LD_VAR 0 3
88451: PPUSH
88452: CALL_OW 3
88456: ST_TO_ADDR
88457: GO 88434
88459: POP
88460: POP
// end ;
88461: LD_VAR 0 3
88465: RET
// export function ComExit ( unit ) ; var tmp ; begin
88466: LD_INT 0
88468: PPUSH
88469: PPUSH
// if not IsInUnit ( unit ) then
88470: LD_VAR 0 1
88474: PPUSH
88475: CALL_OW 310
88479: NOT
88480: IFFALSE 88484
// exit ;
88482: GO 88544
// tmp := IsInUnit ( unit ) ;
88484: LD_ADDR_VAR 0 3
88488: PUSH
88489: LD_VAR 0 1
88493: PPUSH
88494: CALL_OW 310
88498: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88499: LD_VAR 0 3
88503: PPUSH
88504: CALL_OW 247
88508: PUSH
88509: LD_INT 2
88511: EQUAL
88512: IFFALSE 88525
// ComExitVehicle ( unit ) else
88514: LD_VAR 0 1
88518: PPUSH
88519: CALL_OW 121
88523: GO 88534
// ComExitBuilding ( unit ) ;
88525: LD_VAR 0 1
88529: PPUSH
88530: CALL_OW 122
// result := tmp ;
88534: LD_ADDR_VAR 0 2
88538: PUSH
88539: LD_VAR 0 3
88543: ST_TO_ADDR
// end ;
88544: LD_VAR 0 2
88548: RET
// export function ComExitAll ( units ) ; var i ; begin
88549: LD_INT 0
88551: PPUSH
88552: PPUSH
// if not units then
88553: LD_VAR 0 1
88557: NOT
88558: IFFALSE 88562
// exit ;
88560: GO 88588
// for i in units do
88562: LD_ADDR_VAR 0 3
88566: PUSH
88567: LD_VAR 0 1
88571: PUSH
88572: FOR_IN
88573: IFFALSE 88586
// ComExit ( i ) ;
88575: LD_VAR 0 3
88579: PPUSH
88580: CALL 88466 0 1
88584: GO 88572
88586: POP
88587: POP
// end ;
88588: LD_VAR 0 2
88592: RET
// export function ResetHc ; begin
88593: LD_INT 0
88595: PPUSH
// InitHc ;
88596: CALL_OW 19
// hc_importance := 0 ;
88600: LD_ADDR_OWVAR 32
88604: PUSH
88605: LD_INT 0
88607: ST_TO_ADDR
// end ;
88608: LD_VAR 0 1
88612: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88613: LD_INT 0
88615: PPUSH
88616: PPUSH
88617: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88618: LD_ADDR_VAR 0 6
88622: PUSH
88623: LD_VAR 0 1
88627: PUSH
88628: LD_VAR 0 3
88632: PLUS
88633: PUSH
88634: LD_INT 2
88636: DIV
88637: ST_TO_ADDR
// if _x < 0 then
88638: LD_VAR 0 6
88642: PUSH
88643: LD_INT 0
88645: LESS
88646: IFFALSE 88663
// _x := _x * - 1 ;
88648: LD_ADDR_VAR 0 6
88652: PUSH
88653: LD_VAR 0 6
88657: PUSH
88658: LD_INT 1
88660: NEG
88661: MUL
88662: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88663: LD_ADDR_VAR 0 7
88667: PUSH
88668: LD_VAR 0 2
88672: PUSH
88673: LD_VAR 0 4
88677: PLUS
88678: PUSH
88679: LD_INT 2
88681: DIV
88682: ST_TO_ADDR
// if _y < 0 then
88683: LD_VAR 0 7
88687: PUSH
88688: LD_INT 0
88690: LESS
88691: IFFALSE 88708
// _y := _y * - 1 ;
88693: LD_ADDR_VAR 0 7
88697: PUSH
88698: LD_VAR 0 7
88702: PUSH
88703: LD_INT 1
88705: NEG
88706: MUL
88707: ST_TO_ADDR
// result := [ _x , _y ] ;
88708: LD_ADDR_VAR 0 5
88712: PUSH
88713: LD_VAR 0 6
88717: PUSH
88718: LD_VAR 0 7
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: ST_TO_ADDR
// end ;
88727: LD_VAR 0 5
88731: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88732: LD_INT 0
88734: PPUSH
88735: PPUSH
88736: PPUSH
88737: PPUSH
// task := GetTaskList ( unit ) ;
88738: LD_ADDR_VAR 0 7
88742: PUSH
88743: LD_VAR 0 1
88747: PPUSH
88748: CALL_OW 437
88752: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88753: LD_VAR 0 7
88757: NOT
88758: PUSH
88759: LD_VAR 0 1
88763: PPUSH
88764: LD_VAR 0 2
88768: PPUSH
88769: CALL_OW 308
88773: NOT
88774: AND
88775: IFFALSE 88779
// exit ;
88777: GO 88897
// if IsInArea ( unit , area ) then
88779: LD_VAR 0 1
88783: PPUSH
88784: LD_VAR 0 2
88788: PPUSH
88789: CALL_OW 308
88793: IFFALSE 88811
// begin ComMoveToArea ( unit , goAway ) ;
88795: LD_VAR 0 1
88799: PPUSH
88800: LD_VAR 0 3
88804: PPUSH
88805: CALL_OW 113
// exit ;
88809: GO 88897
// end ; if task [ 1 ] [ 1 ] <> M then
88811: LD_VAR 0 7
88815: PUSH
88816: LD_INT 1
88818: ARRAY
88819: PUSH
88820: LD_INT 1
88822: ARRAY
88823: PUSH
88824: LD_STRING M
88826: NONEQUAL
88827: IFFALSE 88831
// exit ;
88829: GO 88897
// x := task [ 1 ] [ 2 ] ;
88831: LD_ADDR_VAR 0 5
88835: PUSH
88836: LD_VAR 0 7
88840: PUSH
88841: LD_INT 1
88843: ARRAY
88844: PUSH
88845: LD_INT 2
88847: ARRAY
88848: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88849: LD_ADDR_VAR 0 6
88853: PUSH
88854: LD_VAR 0 7
88858: PUSH
88859: LD_INT 1
88861: ARRAY
88862: PUSH
88863: LD_INT 3
88865: ARRAY
88866: ST_TO_ADDR
// if InArea ( x , y , area ) then
88867: LD_VAR 0 5
88871: PPUSH
88872: LD_VAR 0 6
88876: PPUSH
88877: LD_VAR 0 2
88881: PPUSH
88882: CALL_OW 309
88886: IFFALSE 88897
// ComStop ( unit ) ;
88888: LD_VAR 0 1
88892: PPUSH
88893: CALL_OW 141
// end ;
88897: LD_VAR 0 4
88901: RET
// export function Abs ( value ) ; begin
88902: LD_INT 0
88904: PPUSH
// result := value ;
88905: LD_ADDR_VAR 0 2
88909: PUSH
88910: LD_VAR 0 1
88914: ST_TO_ADDR
// if value < 0 then
88915: LD_VAR 0 1
88919: PUSH
88920: LD_INT 0
88922: LESS
88923: IFFALSE 88940
// result := value * - 1 ;
88925: LD_ADDR_VAR 0 2
88929: PUSH
88930: LD_VAR 0 1
88934: PUSH
88935: LD_INT 1
88937: NEG
88938: MUL
88939: ST_TO_ADDR
// end ;
88940: LD_VAR 0 2
88944: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88945: LD_INT 0
88947: PPUSH
88948: PPUSH
88949: PPUSH
88950: PPUSH
88951: PPUSH
88952: PPUSH
88953: PPUSH
88954: PPUSH
// if not unit or not building then
88955: LD_VAR 0 1
88959: NOT
88960: PUSH
88961: LD_VAR 0 2
88965: NOT
88966: OR
88967: IFFALSE 88971
// exit ;
88969: GO 89197
// x := GetX ( building ) ;
88971: LD_ADDR_VAR 0 4
88975: PUSH
88976: LD_VAR 0 2
88980: PPUSH
88981: CALL_OW 250
88985: ST_TO_ADDR
// y := GetY ( building ) ;
88986: LD_ADDR_VAR 0 6
88990: PUSH
88991: LD_VAR 0 2
88995: PPUSH
88996: CALL_OW 251
89000: ST_TO_ADDR
// d := GetDir ( building ) ;
89001: LD_ADDR_VAR 0 8
89005: PUSH
89006: LD_VAR 0 2
89010: PPUSH
89011: CALL_OW 254
89015: ST_TO_ADDR
// r := 4 ;
89016: LD_ADDR_VAR 0 9
89020: PUSH
89021: LD_INT 4
89023: ST_TO_ADDR
// for i := 1 to 5 do
89024: LD_ADDR_VAR 0 10
89028: PUSH
89029: DOUBLE
89030: LD_INT 1
89032: DEC
89033: ST_TO_ADDR
89034: LD_INT 5
89036: PUSH
89037: FOR_TO
89038: IFFALSE 89195
// begin _x := ShiftX ( x , d , r + i ) ;
89040: LD_ADDR_VAR 0 5
89044: PUSH
89045: LD_VAR 0 4
89049: PPUSH
89050: LD_VAR 0 8
89054: PPUSH
89055: LD_VAR 0 9
89059: PUSH
89060: LD_VAR 0 10
89064: PLUS
89065: PPUSH
89066: CALL_OW 272
89070: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89071: LD_ADDR_VAR 0 7
89075: PUSH
89076: LD_VAR 0 6
89080: PPUSH
89081: LD_VAR 0 8
89085: PPUSH
89086: LD_VAR 0 9
89090: PUSH
89091: LD_VAR 0 10
89095: PLUS
89096: PPUSH
89097: CALL_OW 273
89101: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89102: LD_VAR 0 5
89106: PPUSH
89107: LD_VAR 0 7
89111: PPUSH
89112: CALL_OW 488
89116: PUSH
89117: LD_VAR 0 5
89121: PPUSH
89122: LD_VAR 0 7
89126: PPUSH
89127: CALL_OW 428
89131: PPUSH
89132: CALL_OW 247
89136: PUSH
89137: LD_INT 3
89139: PUSH
89140: LD_INT 2
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: IN
89147: NOT
89148: AND
89149: IFFALSE 89193
// begin ComMoveXY ( unit , _x , _y ) ;
89151: LD_VAR 0 1
89155: PPUSH
89156: LD_VAR 0 5
89160: PPUSH
89161: LD_VAR 0 7
89165: PPUSH
89166: CALL_OW 111
// result := [ _x , _y ] ;
89170: LD_ADDR_VAR 0 3
89174: PUSH
89175: LD_VAR 0 5
89179: PUSH
89180: LD_VAR 0 7
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: ST_TO_ADDR
// exit ;
89189: POP
89190: POP
89191: GO 89197
// end ; end ;
89193: GO 89037
89195: POP
89196: POP
// end ;
89197: LD_VAR 0 3
89201: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89202: LD_INT 0
89204: PPUSH
89205: PPUSH
89206: PPUSH
// result := 0 ;
89207: LD_ADDR_VAR 0 3
89211: PUSH
89212: LD_INT 0
89214: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89215: LD_VAR 0 1
89219: PUSH
89220: LD_INT 0
89222: LESS
89223: PUSH
89224: LD_VAR 0 1
89228: PUSH
89229: LD_INT 8
89231: GREATER
89232: OR
89233: PUSH
89234: LD_VAR 0 2
89238: PUSH
89239: LD_INT 0
89241: LESS
89242: OR
89243: PUSH
89244: LD_VAR 0 2
89248: PUSH
89249: LD_INT 8
89251: GREATER
89252: OR
89253: IFFALSE 89257
// exit ;
89255: GO 89332
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89257: LD_ADDR_VAR 0 4
89261: PUSH
89262: LD_INT 22
89264: PUSH
89265: LD_VAR 0 2
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PPUSH
89274: CALL_OW 69
89278: PUSH
89279: FOR_IN
89280: IFFALSE 89330
// begin un := UnitShoot ( i ) ;
89282: LD_ADDR_VAR 0 5
89286: PUSH
89287: LD_VAR 0 4
89291: PPUSH
89292: CALL_OW 504
89296: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89297: LD_VAR 0 5
89301: PPUSH
89302: CALL_OW 255
89306: PUSH
89307: LD_VAR 0 1
89311: EQUAL
89312: IFFALSE 89328
// begin result := un ;
89314: LD_ADDR_VAR 0 3
89318: PUSH
89319: LD_VAR 0 5
89323: ST_TO_ADDR
// exit ;
89324: POP
89325: POP
89326: GO 89332
// end ; end ;
89328: GO 89279
89330: POP
89331: POP
// end ;
89332: LD_VAR 0 3
89336: RET
// export function GetCargoBay ( units ) ; begin
89337: LD_INT 0
89339: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89340: LD_ADDR_VAR 0 2
89344: PUSH
89345: LD_VAR 0 1
89349: PPUSH
89350: LD_INT 2
89352: PUSH
89353: LD_INT 34
89355: PUSH
89356: LD_INT 12
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 34
89365: PUSH
89366: LD_INT 51
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 34
89375: PUSH
89376: LD_INT 32
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 34
89385: PUSH
89386: LD_EXP 73
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: PPUSH
89402: CALL_OW 72
89406: ST_TO_ADDR
// end ;
89407: LD_VAR 0 2
89411: RET
// export function Negate ( value ) ; begin
89412: LD_INT 0
89414: PPUSH
// result := not value ;
89415: LD_ADDR_VAR 0 2
89419: PUSH
89420: LD_VAR 0 1
89424: NOT
89425: ST_TO_ADDR
// end ;
89426: LD_VAR 0 2
89430: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89431: LD_INT 0
89433: PPUSH
// if x1 = x2 then
89434: LD_VAR 0 1
89438: PUSH
89439: LD_VAR 0 3
89443: EQUAL
89444: IFFALSE 89478
// begin if y1 > y2 then
89446: LD_VAR 0 2
89450: PUSH
89451: LD_VAR 0 4
89455: GREATER
89456: IFFALSE 89468
// result := 0 else
89458: LD_ADDR_VAR 0 5
89462: PUSH
89463: LD_INT 0
89465: ST_TO_ADDR
89466: GO 89476
// result := 3 ;
89468: LD_ADDR_VAR 0 5
89472: PUSH
89473: LD_INT 3
89475: ST_TO_ADDR
// exit ;
89476: GO 89564
// end ; if y1 = y2 then
89478: LD_VAR 0 2
89482: PUSH
89483: LD_VAR 0 4
89487: EQUAL
89488: IFFALSE 89522
// begin if x1 > x2 then
89490: LD_VAR 0 1
89494: PUSH
89495: LD_VAR 0 3
89499: GREATER
89500: IFFALSE 89512
// result := 1 else
89502: LD_ADDR_VAR 0 5
89506: PUSH
89507: LD_INT 1
89509: ST_TO_ADDR
89510: GO 89520
// result := 4 ;
89512: LD_ADDR_VAR 0 5
89516: PUSH
89517: LD_INT 4
89519: ST_TO_ADDR
// exit ;
89520: GO 89564
// end ; if x1 > x2 and y1 > y2 then
89522: LD_VAR 0 1
89526: PUSH
89527: LD_VAR 0 3
89531: GREATER
89532: PUSH
89533: LD_VAR 0 2
89537: PUSH
89538: LD_VAR 0 4
89542: GREATER
89543: AND
89544: IFFALSE 89556
// result := 2 else
89546: LD_ADDR_VAR 0 5
89550: PUSH
89551: LD_INT 2
89553: ST_TO_ADDR
89554: GO 89564
// result := 5 ;
89556: LD_ADDR_VAR 0 5
89560: PUSH
89561: LD_INT 5
89563: ST_TO_ADDR
// end ;
89564: LD_VAR 0 5
89568: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89569: LD_INT 0
89571: PPUSH
89572: PPUSH
// if not driver or not IsInUnit ( driver ) then
89573: LD_VAR 0 1
89577: NOT
89578: PUSH
89579: LD_VAR 0 1
89583: PPUSH
89584: CALL_OW 310
89588: NOT
89589: OR
89590: IFFALSE 89594
// exit ;
89592: GO 89684
// vehicle := IsInUnit ( driver ) ;
89594: LD_ADDR_VAR 0 3
89598: PUSH
89599: LD_VAR 0 1
89603: PPUSH
89604: CALL_OW 310
89608: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89609: LD_VAR 0 1
89613: PPUSH
89614: LD_STRING \
89616: PUSH
89617: LD_INT 0
89619: PUSH
89620: LD_INT 0
89622: PUSH
89623: LD_INT 0
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: LD_INT 0
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: PUSH
89644: LD_STRING E
89646: PUSH
89647: LD_INT 0
89649: PUSH
89650: LD_INT 0
89652: PUSH
89653: LD_VAR 0 3
89657: PUSH
89658: LD_INT 0
89660: PUSH
89661: LD_INT 0
89663: PUSH
89664: LD_INT 0
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PPUSH
89680: CALL_OW 446
// end ;
89684: LD_VAR 0 2
89688: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89689: LD_INT 0
89691: PPUSH
89692: PPUSH
// if not driver or not IsInUnit ( driver ) then
89693: LD_VAR 0 1
89697: NOT
89698: PUSH
89699: LD_VAR 0 1
89703: PPUSH
89704: CALL_OW 310
89708: NOT
89709: OR
89710: IFFALSE 89714
// exit ;
89712: GO 89804
// vehicle := IsInUnit ( driver ) ;
89714: LD_ADDR_VAR 0 3
89718: PUSH
89719: LD_VAR 0 1
89723: PPUSH
89724: CALL_OW 310
89728: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89729: LD_VAR 0 1
89733: PPUSH
89734: LD_STRING \
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: LD_INT 0
89742: PUSH
89743: LD_INT 0
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: PUSH
89764: LD_STRING E
89766: PUSH
89767: LD_INT 0
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: LD_VAR 0 3
89777: PUSH
89778: LD_INT 0
89780: PUSH
89781: LD_INT 0
89783: PUSH
89784: LD_INT 0
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PPUSH
89800: CALL_OW 447
// end ;
89804: LD_VAR 0 2
89808: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89809: LD_INT 0
89811: PPUSH
89812: PPUSH
89813: PPUSH
// tmp := [ ] ;
89814: LD_ADDR_VAR 0 5
89818: PUSH
89819: EMPTY
89820: ST_TO_ADDR
// for i in units do
89821: LD_ADDR_VAR 0 4
89825: PUSH
89826: LD_VAR 0 1
89830: PUSH
89831: FOR_IN
89832: IFFALSE 89870
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89834: LD_ADDR_VAR 0 5
89838: PUSH
89839: LD_VAR 0 5
89843: PPUSH
89844: LD_VAR 0 5
89848: PUSH
89849: LD_INT 1
89851: PLUS
89852: PPUSH
89853: LD_VAR 0 4
89857: PPUSH
89858: CALL_OW 256
89862: PPUSH
89863: CALL_OW 2
89867: ST_TO_ADDR
89868: GO 89831
89870: POP
89871: POP
// if not tmp then
89872: LD_VAR 0 5
89876: NOT
89877: IFFALSE 89881
// exit ;
89879: GO 89929
// if asc then
89881: LD_VAR 0 2
89885: IFFALSE 89909
// result := SortListByListAsc ( units , tmp ) else
89887: LD_ADDR_VAR 0 3
89891: PUSH
89892: LD_VAR 0 1
89896: PPUSH
89897: LD_VAR 0 5
89901: PPUSH
89902: CALL_OW 76
89906: ST_TO_ADDR
89907: GO 89929
// result := SortListByListDesc ( units , tmp ) ;
89909: LD_ADDR_VAR 0 3
89913: PUSH
89914: LD_VAR 0 1
89918: PPUSH
89919: LD_VAR 0 5
89923: PPUSH
89924: CALL_OW 77
89928: ST_TO_ADDR
// end ;
89929: LD_VAR 0 3
89933: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
89934: LD_INT 0
89936: PPUSH
89937: PPUSH
// task := GetTaskList ( mech ) ;
89938: LD_ADDR_VAR 0 4
89942: PUSH
89943: LD_VAR 0 1
89947: PPUSH
89948: CALL_OW 437
89952: ST_TO_ADDR
// if not task then
89953: LD_VAR 0 4
89957: NOT
89958: IFFALSE 89962
// exit ;
89960: GO 90004
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
89962: LD_ADDR_VAR 0 3
89966: PUSH
89967: LD_VAR 0 4
89971: PUSH
89972: LD_INT 1
89974: ARRAY
89975: PUSH
89976: LD_INT 1
89978: ARRAY
89979: PUSH
89980: LD_STRING r
89982: EQUAL
89983: PUSH
89984: LD_VAR 0 4
89988: PUSH
89989: LD_INT 1
89991: ARRAY
89992: PUSH
89993: LD_INT 4
89995: ARRAY
89996: PUSH
89997: LD_VAR 0 2
90001: EQUAL
90002: AND
90003: ST_TO_ADDR
// end ;
90004: LD_VAR 0 3
90008: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90009: LD_INT 0
90011: PPUSH
// SetDir ( unit , d ) ;
90012: LD_VAR 0 1
90016: PPUSH
90017: LD_VAR 0 4
90021: PPUSH
90022: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90026: LD_VAR 0 1
90030: PPUSH
90031: LD_VAR 0 2
90035: PPUSH
90036: LD_VAR 0 3
90040: PPUSH
90041: LD_VAR 0 5
90045: PPUSH
90046: CALL_OW 48
// end ;
90050: LD_VAR 0 6
90054: RET
// export function ToNaturalNumber ( number ) ; begin
90055: LD_INT 0
90057: PPUSH
// result := number div 1 ;
90058: LD_ADDR_VAR 0 2
90062: PUSH
90063: LD_VAR 0 1
90067: PUSH
90068: LD_INT 1
90070: DIV
90071: ST_TO_ADDR
// if number < 0 then
90072: LD_VAR 0 1
90076: PUSH
90077: LD_INT 0
90079: LESS
90080: IFFALSE 90090
// result := 0 ;
90082: LD_ADDR_VAR 0 2
90086: PUSH
90087: LD_INT 0
90089: ST_TO_ADDR
// end ;
90090: LD_VAR 0 2
90094: RET
// export function SortByClass ( units , class ) ; var un ; begin
90095: LD_INT 0
90097: PPUSH
90098: PPUSH
// if not units or not class then
90099: LD_VAR 0 1
90103: NOT
90104: PUSH
90105: LD_VAR 0 2
90109: NOT
90110: OR
90111: IFFALSE 90115
// exit ;
90113: GO 90210
// result := [ ] ;
90115: LD_ADDR_VAR 0 3
90119: PUSH
90120: EMPTY
90121: ST_TO_ADDR
// for un in units do
90122: LD_ADDR_VAR 0 4
90126: PUSH
90127: LD_VAR 0 1
90131: PUSH
90132: FOR_IN
90133: IFFALSE 90208
// if GetClass ( un ) = class then
90135: LD_VAR 0 4
90139: PPUSH
90140: CALL_OW 257
90144: PUSH
90145: LD_VAR 0 2
90149: EQUAL
90150: IFFALSE 90177
// result := Insert ( result , 1 , un ) else
90152: LD_ADDR_VAR 0 3
90156: PUSH
90157: LD_VAR 0 3
90161: PPUSH
90162: LD_INT 1
90164: PPUSH
90165: LD_VAR 0 4
90169: PPUSH
90170: CALL_OW 2
90174: ST_TO_ADDR
90175: GO 90206
// result := Replace ( result , result + 1 , un ) ;
90177: LD_ADDR_VAR 0 3
90181: PUSH
90182: LD_VAR 0 3
90186: PPUSH
90187: LD_VAR 0 3
90191: PUSH
90192: LD_INT 1
90194: PLUS
90195: PPUSH
90196: LD_VAR 0 4
90200: PPUSH
90201: CALL_OW 1
90205: ST_TO_ADDR
90206: GO 90132
90208: POP
90209: POP
// end ;
90210: LD_VAR 0 3
90214: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
90215: LD_INT 0
90217: PPUSH
90218: PPUSH
90219: PPUSH
90220: PPUSH
90221: PPUSH
90222: PPUSH
90223: PPUSH
// result := [ ] ;
90224: LD_ADDR_VAR 0 4
90228: PUSH
90229: EMPTY
90230: ST_TO_ADDR
// if x - r < 0 then
90231: LD_VAR 0 1
90235: PUSH
90236: LD_VAR 0 3
90240: MINUS
90241: PUSH
90242: LD_INT 0
90244: LESS
90245: IFFALSE 90257
// min_x := 0 else
90247: LD_ADDR_VAR 0 8
90251: PUSH
90252: LD_INT 0
90254: ST_TO_ADDR
90255: GO 90273
// min_x := x - r ;
90257: LD_ADDR_VAR 0 8
90261: PUSH
90262: LD_VAR 0 1
90266: PUSH
90267: LD_VAR 0 3
90271: MINUS
90272: ST_TO_ADDR
// if y - r < 0 then
90273: LD_VAR 0 2
90277: PUSH
90278: LD_VAR 0 3
90282: MINUS
90283: PUSH
90284: LD_INT 0
90286: LESS
90287: IFFALSE 90299
// min_y := 0 else
90289: LD_ADDR_VAR 0 7
90293: PUSH
90294: LD_INT 0
90296: ST_TO_ADDR
90297: GO 90315
// min_y := y - r ;
90299: LD_ADDR_VAR 0 7
90303: PUSH
90304: LD_VAR 0 2
90308: PUSH
90309: LD_VAR 0 3
90313: MINUS
90314: ST_TO_ADDR
// max_x := x + r ;
90315: LD_ADDR_VAR 0 9
90319: PUSH
90320: LD_VAR 0 1
90324: PUSH
90325: LD_VAR 0 3
90329: PLUS
90330: ST_TO_ADDR
// max_y := y + r ;
90331: LD_ADDR_VAR 0 10
90335: PUSH
90336: LD_VAR 0 2
90340: PUSH
90341: LD_VAR 0 3
90345: PLUS
90346: ST_TO_ADDR
// for _x = min_x to max_x do
90347: LD_ADDR_VAR 0 5
90351: PUSH
90352: DOUBLE
90353: LD_VAR 0 8
90357: DEC
90358: ST_TO_ADDR
90359: LD_VAR 0 9
90363: PUSH
90364: FOR_TO
90365: IFFALSE 90466
// for _y = min_y to max_y do
90367: LD_ADDR_VAR 0 6
90371: PUSH
90372: DOUBLE
90373: LD_VAR 0 7
90377: DEC
90378: ST_TO_ADDR
90379: LD_VAR 0 10
90383: PUSH
90384: FOR_TO
90385: IFFALSE 90462
// begin if not ValidHex ( _x , _y ) then
90387: LD_VAR 0 5
90391: PPUSH
90392: LD_VAR 0 6
90396: PPUSH
90397: CALL_OW 488
90401: NOT
90402: IFFALSE 90406
// continue ;
90404: GO 90384
// if GetResourceTypeXY ( _x , _y ) then
90406: LD_VAR 0 5
90410: PPUSH
90411: LD_VAR 0 6
90415: PPUSH
90416: CALL_OW 283
90420: IFFALSE 90460
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
90422: LD_ADDR_VAR 0 4
90426: PUSH
90427: LD_VAR 0 4
90431: PPUSH
90432: LD_VAR 0 4
90436: PUSH
90437: LD_INT 1
90439: PLUS
90440: PPUSH
90441: LD_VAR 0 5
90445: PUSH
90446: LD_VAR 0 6
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PPUSH
90455: CALL_OW 1
90459: ST_TO_ADDR
// end ;
90460: GO 90384
90462: POP
90463: POP
90464: GO 90364
90466: POP
90467: POP
// end ;
90468: LD_VAR 0 4
90472: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
90473: LD_INT 0
90475: PPUSH
90476: PPUSH
90477: PPUSH
90478: PPUSH
90479: PPUSH
90480: PPUSH
// if not units then
90481: LD_VAR 0 1
90485: NOT
90486: IFFALSE 90490
// exit ;
90488: GO 90891
// result := UnitFilter ( units , [ f_ok ] ) ;
90490: LD_ADDR_VAR 0 3
90494: PUSH
90495: LD_VAR 0 1
90499: PPUSH
90500: LD_INT 50
90502: PUSH
90503: EMPTY
90504: LIST
90505: PPUSH
90506: CALL_OW 72
90510: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
90511: LD_ADDR_VAR 0 7
90515: PUSH
90516: LD_VAR 0 1
90520: PUSH
90521: LD_INT 1
90523: ARRAY
90524: PPUSH
90525: CALL_OW 255
90529: ST_TO_ADDR
// if not result then
90530: LD_VAR 0 3
90534: NOT
90535: IFFALSE 90539
// exit ;
90537: GO 90891
// for i in result do
90539: LD_ADDR_VAR 0 4
90543: PUSH
90544: LD_VAR 0 3
90548: PUSH
90549: FOR_IN
90550: IFFALSE 90889
// begin tag := GetTag ( i ) + 1 ;
90552: LD_ADDR_VAR 0 8
90556: PUSH
90557: LD_VAR 0 4
90561: PPUSH
90562: CALL_OW 110
90566: PUSH
90567: LD_INT 1
90569: PLUS
90570: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
90571: LD_ADDR_VAR 0 6
90575: PUSH
90576: LD_VAR 0 4
90580: PPUSH
90581: CALL_OW 250
90585: PPUSH
90586: LD_VAR 0 4
90590: PPUSH
90591: CALL_OW 251
90595: PPUSH
90596: LD_INT 6
90598: PPUSH
90599: CALL 90215 0 3
90603: ST_TO_ADDR
// if cr then
90604: LD_VAR 0 6
90608: IFFALSE 90647
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
90610: LD_VAR 0 4
90614: PPUSH
90615: LD_VAR 0 6
90619: PUSH
90620: LD_INT 1
90622: ARRAY
90623: PUSH
90624: LD_INT 1
90626: ARRAY
90627: PPUSH
90628: LD_VAR 0 6
90632: PUSH
90633: LD_INT 1
90635: ARRAY
90636: PUSH
90637: LD_INT 2
90639: ARRAY
90640: PPUSH
90641: CALL_OW 116
90645: GO 90887
// if path > tag then
90647: LD_VAR 0 2
90651: PUSH
90652: LD_VAR 0 8
90656: GREATER
90657: IFFALSE 90835
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
90659: LD_ADDR_VAR 0 5
90663: PUSH
90664: LD_INT 81
90666: PUSH
90667: LD_VAR 0 7
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: LD_INT 91
90678: PUSH
90679: LD_VAR 0 4
90683: PUSH
90684: LD_INT 12
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: LIST
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PPUSH
90696: CALL_OW 69
90700: ST_TO_ADDR
// if enemy then
90701: LD_VAR 0 5
90705: IFFALSE 90733
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
90707: LD_VAR 0 4
90711: PPUSH
90712: LD_VAR 0 5
90716: PPUSH
90717: LD_VAR 0 4
90721: PPUSH
90722: CALL_OW 74
90726: PPUSH
90727: CALL_OW 115
90731: GO 90833
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
90733: LD_VAR 0 4
90737: PPUSH
90738: LD_VAR 0 2
90742: PUSH
90743: LD_VAR 0 8
90747: ARRAY
90748: PUSH
90749: LD_INT 1
90751: ARRAY
90752: PPUSH
90753: LD_VAR 0 2
90757: PUSH
90758: LD_VAR 0 8
90762: ARRAY
90763: PUSH
90764: LD_INT 2
90766: ARRAY
90767: PPUSH
90768: CALL_OW 297
90772: PUSH
90773: LD_INT 6
90775: GREATER
90776: IFFALSE 90819
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
90778: LD_VAR 0 4
90782: PPUSH
90783: LD_VAR 0 2
90787: PUSH
90788: LD_VAR 0 8
90792: ARRAY
90793: PUSH
90794: LD_INT 1
90796: ARRAY
90797: PPUSH
90798: LD_VAR 0 2
90802: PUSH
90803: LD_VAR 0 8
90807: ARRAY
90808: PUSH
90809: LD_INT 2
90811: ARRAY
90812: PPUSH
90813: CALL_OW 114
90817: GO 90833
// SetTag ( i , tag ) ;
90819: LD_VAR 0 4
90823: PPUSH
90824: LD_VAR 0 8
90828: PPUSH
90829: CALL_OW 109
// end else
90833: GO 90887
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
90835: LD_ADDR_VAR 0 5
90839: PUSH
90840: LD_INT 81
90842: PUSH
90843: LD_VAR 0 7
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PPUSH
90852: CALL_OW 69
90856: ST_TO_ADDR
// if enemy then
90857: LD_VAR 0 5
90861: IFFALSE 90887
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
90863: LD_VAR 0 4
90867: PPUSH
90868: LD_VAR 0 5
90872: PPUSH
90873: LD_VAR 0 4
90877: PPUSH
90878: CALL_OW 74
90882: PPUSH
90883: CALL_OW 115
// end ; end ;
90887: GO 90549
90889: POP
90890: POP
// end ; end_of_file end_of_file
90891: LD_VAR 0 3
90895: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90896: LD_INT 0
90898: PPUSH
// if p2 = 100 then
90899: LD_VAR 0 2
90903: PUSH
90904: LD_INT 100
90906: EQUAL
90907: IFFALSE 91856
// begin if not StreamModeActive then
90909: LD_EXP 137
90913: NOT
90914: IFFALSE 90924
// StreamModeActive := true ;
90916: LD_ADDR_EXP 137
90920: PUSH
90921: LD_INT 1
90923: ST_TO_ADDR
// if p3 = 0 then
90924: LD_VAR 0 3
90928: PUSH
90929: LD_INT 0
90931: EQUAL
90932: IFFALSE 90938
// InitStreamMode ;
90934: CALL 92016 0 0
// if p3 = 1 then
90938: LD_VAR 0 3
90942: PUSH
90943: LD_INT 1
90945: EQUAL
90946: IFFALSE 90956
// sRocket := true ;
90948: LD_ADDR_EXP 142
90952: PUSH
90953: LD_INT 1
90955: ST_TO_ADDR
// if p3 = 2 then
90956: LD_VAR 0 3
90960: PUSH
90961: LD_INT 2
90963: EQUAL
90964: IFFALSE 90974
// sSpeed := true ;
90966: LD_ADDR_EXP 141
90970: PUSH
90971: LD_INT 1
90973: ST_TO_ADDR
// if p3 = 3 then
90974: LD_VAR 0 3
90978: PUSH
90979: LD_INT 3
90981: EQUAL
90982: IFFALSE 90992
// sEngine := true ;
90984: LD_ADDR_EXP 143
90988: PUSH
90989: LD_INT 1
90991: ST_TO_ADDR
// if p3 = 4 then
90992: LD_VAR 0 3
90996: PUSH
90997: LD_INT 4
90999: EQUAL
91000: IFFALSE 91010
// sSpec := true ;
91002: LD_ADDR_EXP 140
91006: PUSH
91007: LD_INT 1
91009: ST_TO_ADDR
// if p3 = 5 then
91010: LD_VAR 0 3
91014: PUSH
91015: LD_INT 5
91017: EQUAL
91018: IFFALSE 91028
// sLevel := true ;
91020: LD_ADDR_EXP 144
91024: PUSH
91025: LD_INT 1
91027: ST_TO_ADDR
// if p3 = 6 then
91028: LD_VAR 0 3
91032: PUSH
91033: LD_INT 6
91035: EQUAL
91036: IFFALSE 91046
// sArmoury := true ;
91038: LD_ADDR_EXP 145
91042: PUSH
91043: LD_INT 1
91045: ST_TO_ADDR
// if p3 = 7 then
91046: LD_VAR 0 3
91050: PUSH
91051: LD_INT 7
91053: EQUAL
91054: IFFALSE 91064
// sRadar := true ;
91056: LD_ADDR_EXP 146
91060: PUSH
91061: LD_INT 1
91063: ST_TO_ADDR
// if p3 = 8 then
91064: LD_VAR 0 3
91068: PUSH
91069: LD_INT 8
91071: EQUAL
91072: IFFALSE 91082
// sBunker := true ;
91074: LD_ADDR_EXP 147
91078: PUSH
91079: LD_INT 1
91081: ST_TO_ADDR
// if p3 = 9 then
91082: LD_VAR 0 3
91086: PUSH
91087: LD_INT 9
91089: EQUAL
91090: IFFALSE 91100
// sHack := true ;
91092: LD_ADDR_EXP 148
91096: PUSH
91097: LD_INT 1
91099: ST_TO_ADDR
// if p3 = 10 then
91100: LD_VAR 0 3
91104: PUSH
91105: LD_INT 10
91107: EQUAL
91108: IFFALSE 91118
// sFire := true ;
91110: LD_ADDR_EXP 149
91114: PUSH
91115: LD_INT 1
91117: ST_TO_ADDR
// if p3 = 11 then
91118: LD_VAR 0 3
91122: PUSH
91123: LD_INT 11
91125: EQUAL
91126: IFFALSE 91136
// sRefresh := true ;
91128: LD_ADDR_EXP 150
91132: PUSH
91133: LD_INT 1
91135: ST_TO_ADDR
// if p3 = 12 then
91136: LD_VAR 0 3
91140: PUSH
91141: LD_INT 12
91143: EQUAL
91144: IFFALSE 91154
// sExp := true ;
91146: LD_ADDR_EXP 151
91150: PUSH
91151: LD_INT 1
91153: ST_TO_ADDR
// if p3 = 13 then
91154: LD_VAR 0 3
91158: PUSH
91159: LD_INT 13
91161: EQUAL
91162: IFFALSE 91172
// sDepot := true ;
91164: LD_ADDR_EXP 152
91168: PUSH
91169: LD_INT 1
91171: ST_TO_ADDR
// if p3 = 14 then
91172: LD_VAR 0 3
91176: PUSH
91177: LD_INT 14
91179: EQUAL
91180: IFFALSE 91190
// sFlag := true ;
91182: LD_ADDR_EXP 153
91186: PUSH
91187: LD_INT 1
91189: ST_TO_ADDR
// if p3 = 15 then
91190: LD_VAR 0 3
91194: PUSH
91195: LD_INT 15
91197: EQUAL
91198: IFFALSE 91208
// sKamikadze := true ;
91200: LD_ADDR_EXP 161
91204: PUSH
91205: LD_INT 1
91207: ST_TO_ADDR
// if p3 = 16 then
91208: LD_VAR 0 3
91212: PUSH
91213: LD_INT 16
91215: EQUAL
91216: IFFALSE 91226
// sTroll := true ;
91218: LD_ADDR_EXP 162
91222: PUSH
91223: LD_INT 1
91225: ST_TO_ADDR
// if p3 = 17 then
91226: LD_VAR 0 3
91230: PUSH
91231: LD_INT 17
91233: EQUAL
91234: IFFALSE 91244
// sSlow := true ;
91236: LD_ADDR_EXP 163
91240: PUSH
91241: LD_INT 1
91243: ST_TO_ADDR
// if p3 = 18 then
91244: LD_VAR 0 3
91248: PUSH
91249: LD_INT 18
91251: EQUAL
91252: IFFALSE 91262
// sLack := true ;
91254: LD_ADDR_EXP 164
91258: PUSH
91259: LD_INT 1
91261: ST_TO_ADDR
// if p3 = 19 then
91262: LD_VAR 0 3
91266: PUSH
91267: LD_INT 19
91269: EQUAL
91270: IFFALSE 91280
// sTank := true ;
91272: LD_ADDR_EXP 166
91276: PUSH
91277: LD_INT 1
91279: ST_TO_ADDR
// if p3 = 20 then
91280: LD_VAR 0 3
91284: PUSH
91285: LD_INT 20
91287: EQUAL
91288: IFFALSE 91298
// sRemote := true ;
91290: LD_ADDR_EXP 167
91294: PUSH
91295: LD_INT 1
91297: ST_TO_ADDR
// if p3 = 21 then
91298: LD_VAR 0 3
91302: PUSH
91303: LD_INT 21
91305: EQUAL
91306: IFFALSE 91316
// sPowell := true ;
91308: LD_ADDR_EXP 168
91312: PUSH
91313: LD_INT 1
91315: ST_TO_ADDR
// if p3 = 22 then
91316: LD_VAR 0 3
91320: PUSH
91321: LD_INT 22
91323: EQUAL
91324: IFFALSE 91334
// sTeleport := true ;
91326: LD_ADDR_EXP 171
91330: PUSH
91331: LD_INT 1
91333: ST_TO_ADDR
// if p3 = 23 then
91334: LD_VAR 0 3
91338: PUSH
91339: LD_INT 23
91341: EQUAL
91342: IFFALSE 91352
// sOilTower := true ;
91344: LD_ADDR_EXP 173
91348: PUSH
91349: LD_INT 1
91351: ST_TO_ADDR
// if p3 = 24 then
91352: LD_VAR 0 3
91356: PUSH
91357: LD_INT 24
91359: EQUAL
91360: IFFALSE 91370
// sShovel := true ;
91362: LD_ADDR_EXP 174
91366: PUSH
91367: LD_INT 1
91369: ST_TO_ADDR
// if p3 = 25 then
91370: LD_VAR 0 3
91374: PUSH
91375: LD_INT 25
91377: EQUAL
91378: IFFALSE 91388
// sSheik := true ;
91380: LD_ADDR_EXP 175
91384: PUSH
91385: LD_INT 1
91387: ST_TO_ADDR
// if p3 = 26 then
91388: LD_VAR 0 3
91392: PUSH
91393: LD_INT 26
91395: EQUAL
91396: IFFALSE 91406
// sEarthquake := true ;
91398: LD_ADDR_EXP 177
91402: PUSH
91403: LD_INT 1
91405: ST_TO_ADDR
// if p3 = 27 then
91406: LD_VAR 0 3
91410: PUSH
91411: LD_INT 27
91413: EQUAL
91414: IFFALSE 91424
// sAI := true ;
91416: LD_ADDR_EXP 178
91420: PUSH
91421: LD_INT 1
91423: ST_TO_ADDR
// if p3 = 28 then
91424: LD_VAR 0 3
91428: PUSH
91429: LD_INT 28
91431: EQUAL
91432: IFFALSE 91442
// sCargo := true ;
91434: LD_ADDR_EXP 181
91438: PUSH
91439: LD_INT 1
91441: ST_TO_ADDR
// if p3 = 29 then
91442: LD_VAR 0 3
91446: PUSH
91447: LD_INT 29
91449: EQUAL
91450: IFFALSE 91460
// sDLaser := true ;
91452: LD_ADDR_EXP 182
91456: PUSH
91457: LD_INT 1
91459: ST_TO_ADDR
// if p3 = 30 then
91460: LD_VAR 0 3
91464: PUSH
91465: LD_INT 30
91467: EQUAL
91468: IFFALSE 91478
// sExchange := true ;
91470: LD_ADDR_EXP 183
91474: PUSH
91475: LD_INT 1
91477: ST_TO_ADDR
// if p3 = 31 then
91478: LD_VAR 0 3
91482: PUSH
91483: LD_INT 31
91485: EQUAL
91486: IFFALSE 91496
// sFac := true ;
91488: LD_ADDR_EXP 184
91492: PUSH
91493: LD_INT 1
91495: ST_TO_ADDR
// if p3 = 32 then
91496: LD_VAR 0 3
91500: PUSH
91501: LD_INT 32
91503: EQUAL
91504: IFFALSE 91514
// sPower := true ;
91506: LD_ADDR_EXP 185
91510: PUSH
91511: LD_INT 1
91513: ST_TO_ADDR
// if p3 = 33 then
91514: LD_VAR 0 3
91518: PUSH
91519: LD_INT 33
91521: EQUAL
91522: IFFALSE 91532
// sRandom := true ;
91524: LD_ADDR_EXP 186
91528: PUSH
91529: LD_INT 1
91531: ST_TO_ADDR
// if p3 = 34 then
91532: LD_VAR 0 3
91536: PUSH
91537: LD_INT 34
91539: EQUAL
91540: IFFALSE 91550
// sShield := true ;
91542: LD_ADDR_EXP 187
91546: PUSH
91547: LD_INT 1
91549: ST_TO_ADDR
// if p3 = 35 then
91550: LD_VAR 0 3
91554: PUSH
91555: LD_INT 35
91557: EQUAL
91558: IFFALSE 91568
// sTime := true ;
91560: LD_ADDR_EXP 188
91564: PUSH
91565: LD_INT 1
91567: ST_TO_ADDR
// if p3 = 36 then
91568: LD_VAR 0 3
91572: PUSH
91573: LD_INT 36
91575: EQUAL
91576: IFFALSE 91586
// sTools := true ;
91578: LD_ADDR_EXP 189
91582: PUSH
91583: LD_INT 1
91585: ST_TO_ADDR
// if p3 = 101 then
91586: LD_VAR 0 3
91590: PUSH
91591: LD_INT 101
91593: EQUAL
91594: IFFALSE 91604
// sSold := true ;
91596: LD_ADDR_EXP 154
91600: PUSH
91601: LD_INT 1
91603: ST_TO_ADDR
// if p3 = 102 then
91604: LD_VAR 0 3
91608: PUSH
91609: LD_INT 102
91611: EQUAL
91612: IFFALSE 91622
// sDiff := true ;
91614: LD_ADDR_EXP 155
91618: PUSH
91619: LD_INT 1
91621: ST_TO_ADDR
// if p3 = 103 then
91622: LD_VAR 0 3
91626: PUSH
91627: LD_INT 103
91629: EQUAL
91630: IFFALSE 91640
// sFog := true ;
91632: LD_ADDR_EXP 158
91636: PUSH
91637: LD_INT 1
91639: ST_TO_ADDR
// if p3 = 104 then
91640: LD_VAR 0 3
91644: PUSH
91645: LD_INT 104
91647: EQUAL
91648: IFFALSE 91658
// sReset := true ;
91650: LD_ADDR_EXP 159
91654: PUSH
91655: LD_INT 1
91657: ST_TO_ADDR
// if p3 = 105 then
91658: LD_VAR 0 3
91662: PUSH
91663: LD_INT 105
91665: EQUAL
91666: IFFALSE 91676
// sSun := true ;
91668: LD_ADDR_EXP 160
91672: PUSH
91673: LD_INT 1
91675: ST_TO_ADDR
// if p3 = 106 then
91676: LD_VAR 0 3
91680: PUSH
91681: LD_INT 106
91683: EQUAL
91684: IFFALSE 91694
// sTiger := true ;
91686: LD_ADDR_EXP 156
91690: PUSH
91691: LD_INT 1
91693: ST_TO_ADDR
// if p3 = 107 then
91694: LD_VAR 0 3
91698: PUSH
91699: LD_INT 107
91701: EQUAL
91702: IFFALSE 91712
// sBomb := true ;
91704: LD_ADDR_EXP 157
91708: PUSH
91709: LD_INT 1
91711: ST_TO_ADDR
// if p3 = 108 then
91712: LD_VAR 0 3
91716: PUSH
91717: LD_INT 108
91719: EQUAL
91720: IFFALSE 91730
// sWound := true ;
91722: LD_ADDR_EXP 165
91726: PUSH
91727: LD_INT 1
91729: ST_TO_ADDR
// if p3 = 109 then
91730: LD_VAR 0 3
91734: PUSH
91735: LD_INT 109
91737: EQUAL
91738: IFFALSE 91748
// sBetray := true ;
91740: LD_ADDR_EXP 169
91744: PUSH
91745: LD_INT 1
91747: ST_TO_ADDR
// if p3 = 110 then
91748: LD_VAR 0 3
91752: PUSH
91753: LD_INT 110
91755: EQUAL
91756: IFFALSE 91766
// sContamin := true ;
91758: LD_ADDR_EXP 170
91762: PUSH
91763: LD_INT 1
91765: ST_TO_ADDR
// if p3 = 111 then
91766: LD_VAR 0 3
91770: PUSH
91771: LD_INT 111
91773: EQUAL
91774: IFFALSE 91784
// sOil := true ;
91776: LD_ADDR_EXP 172
91780: PUSH
91781: LD_INT 1
91783: ST_TO_ADDR
// if p3 = 112 then
91784: LD_VAR 0 3
91788: PUSH
91789: LD_INT 112
91791: EQUAL
91792: IFFALSE 91802
// sStu := true ;
91794: LD_ADDR_EXP 176
91798: PUSH
91799: LD_INT 1
91801: ST_TO_ADDR
// if p3 = 113 then
91802: LD_VAR 0 3
91806: PUSH
91807: LD_INT 113
91809: EQUAL
91810: IFFALSE 91820
// sBazooka := true ;
91812: LD_ADDR_EXP 179
91816: PUSH
91817: LD_INT 1
91819: ST_TO_ADDR
// if p3 = 114 then
91820: LD_VAR 0 3
91824: PUSH
91825: LD_INT 114
91827: EQUAL
91828: IFFALSE 91838
// sMortar := true ;
91830: LD_ADDR_EXP 180
91834: PUSH
91835: LD_INT 1
91837: ST_TO_ADDR
// if p3 = 115 then
91838: LD_VAR 0 3
91842: PUSH
91843: LD_INT 115
91845: EQUAL
91846: IFFALSE 91856
// sRanger := true ;
91848: LD_ADDR_EXP 190
91852: PUSH
91853: LD_INT 1
91855: ST_TO_ADDR
// end ; if p2 = 101 then
91856: LD_VAR 0 2
91860: PUSH
91861: LD_INT 101
91863: EQUAL
91864: IFFALSE 91992
// begin case p3 of 1 :
91866: LD_VAR 0 3
91870: PUSH
91871: LD_INT 1
91873: DOUBLE
91874: EQUAL
91875: IFTRUE 91879
91877: GO 91886
91879: POP
// hHackUnlimitedResources ; 2 :
91880: CALL 103029 0 0
91884: GO 91992
91886: LD_INT 2
91888: DOUBLE
91889: EQUAL
91890: IFTRUE 91894
91892: GO 91901
91894: POP
// hHackSetLevel10 ; 3 :
91895: CALL 103162 0 0
91899: GO 91992
91901: LD_INT 3
91903: DOUBLE
91904: EQUAL
91905: IFTRUE 91909
91907: GO 91916
91909: POP
// hHackSetLevel10YourUnits ; 4 :
91910: CALL 103247 0 0
91914: GO 91992
91916: LD_INT 4
91918: DOUBLE
91919: EQUAL
91920: IFTRUE 91924
91922: GO 91931
91924: POP
// hHackInvincible ; 5 :
91925: CALL 103695 0 0
91929: GO 91992
91931: LD_INT 5
91933: DOUBLE
91934: EQUAL
91935: IFTRUE 91939
91937: GO 91946
91939: POP
// hHackInvisible ; 6 :
91940: CALL 103806 0 0
91944: GO 91992
91946: LD_INT 6
91948: DOUBLE
91949: EQUAL
91950: IFTRUE 91954
91952: GO 91961
91954: POP
// hHackChangeYourSide ; 7 :
91955: CALL 103863 0 0
91959: GO 91992
91961: LD_INT 7
91963: DOUBLE
91964: EQUAL
91965: IFTRUE 91969
91967: GO 91976
91969: POP
// hHackChangeUnitSide ; 8 :
91970: CALL 103905 0 0
91974: GO 91992
91976: LD_INT 8
91978: DOUBLE
91979: EQUAL
91980: IFTRUE 91984
91982: GO 91991
91984: POP
// hHackFog ; end ;
91985: CALL 104006 0 0
91989: GO 91992
91991: POP
// end ; end ;
91992: LD_VAR 0 7
91996: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
91997: GO 91999
91999: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92000: LD_STRING initStreamRollete();
92002: PPUSH
92003: CALL_OW 559
// InitStreamMode ;
92007: CALL 92016 0 0
// DefineStreamItems ( ) ;
92011: CALL 92456 0 0
// end ;
92015: END
// function InitStreamMode ; begin
92016: LD_INT 0
92018: PPUSH
// streamModeActive := false ;
92019: LD_ADDR_EXP 137
92023: PUSH
92024: LD_INT 0
92026: ST_TO_ADDR
// normalCounter := 36 ;
92027: LD_ADDR_EXP 138
92031: PUSH
92032: LD_INT 36
92034: ST_TO_ADDR
// hardcoreCounter := 16 ;
92035: LD_ADDR_EXP 139
92039: PUSH
92040: LD_INT 16
92042: ST_TO_ADDR
// sRocket := false ;
92043: LD_ADDR_EXP 142
92047: PUSH
92048: LD_INT 0
92050: ST_TO_ADDR
// sSpeed := false ;
92051: LD_ADDR_EXP 141
92055: PUSH
92056: LD_INT 0
92058: ST_TO_ADDR
// sEngine := false ;
92059: LD_ADDR_EXP 143
92063: PUSH
92064: LD_INT 0
92066: ST_TO_ADDR
// sSpec := false ;
92067: LD_ADDR_EXP 140
92071: PUSH
92072: LD_INT 0
92074: ST_TO_ADDR
// sLevel := false ;
92075: LD_ADDR_EXP 144
92079: PUSH
92080: LD_INT 0
92082: ST_TO_ADDR
// sArmoury := false ;
92083: LD_ADDR_EXP 145
92087: PUSH
92088: LD_INT 0
92090: ST_TO_ADDR
// sRadar := false ;
92091: LD_ADDR_EXP 146
92095: PUSH
92096: LD_INT 0
92098: ST_TO_ADDR
// sBunker := false ;
92099: LD_ADDR_EXP 147
92103: PUSH
92104: LD_INT 0
92106: ST_TO_ADDR
// sHack := false ;
92107: LD_ADDR_EXP 148
92111: PUSH
92112: LD_INT 0
92114: ST_TO_ADDR
// sFire := false ;
92115: LD_ADDR_EXP 149
92119: PUSH
92120: LD_INT 0
92122: ST_TO_ADDR
// sRefresh := false ;
92123: LD_ADDR_EXP 150
92127: PUSH
92128: LD_INT 0
92130: ST_TO_ADDR
// sExp := false ;
92131: LD_ADDR_EXP 151
92135: PUSH
92136: LD_INT 0
92138: ST_TO_ADDR
// sDepot := false ;
92139: LD_ADDR_EXP 152
92143: PUSH
92144: LD_INT 0
92146: ST_TO_ADDR
// sFlag := false ;
92147: LD_ADDR_EXP 153
92151: PUSH
92152: LD_INT 0
92154: ST_TO_ADDR
// sKamikadze := false ;
92155: LD_ADDR_EXP 161
92159: PUSH
92160: LD_INT 0
92162: ST_TO_ADDR
// sTroll := false ;
92163: LD_ADDR_EXP 162
92167: PUSH
92168: LD_INT 0
92170: ST_TO_ADDR
// sSlow := false ;
92171: LD_ADDR_EXP 163
92175: PUSH
92176: LD_INT 0
92178: ST_TO_ADDR
// sLack := false ;
92179: LD_ADDR_EXP 164
92183: PUSH
92184: LD_INT 0
92186: ST_TO_ADDR
// sTank := false ;
92187: LD_ADDR_EXP 166
92191: PUSH
92192: LD_INT 0
92194: ST_TO_ADDR
// sRemote := false ;
92195: LD_ADDR_EXP 167
92199: PUSH
92200: LD_INT 0
92202: ST_TO_ADDR
// sPowell := false ;
92203: LD_ADDR_EXP 168
92207: PUSH
92208: LD_INT 0
92210: ST_TO_ADDR
// sTeleport := false ;
92211: LD_ADDR_EXP 171
92215: PUSH
92216: LD_INT 0
92218: ST_TO_ADDR
// sOilTower := false ;
92219: LD_ADDR_EXP 173
92223: PUSH
92224: LD_INT 0
92226: ST_TO_ADDR
// sShovel := false ;
92227: LD_ADDR_EXP 174
92231: PUSH
92232: LD_INT 0
92234: ST_TO_ADDR
// sSheik := false ;
92235: LD_ADDR_EXP 175
92239: PUSH
92240: LD_INT 0
92242: ST_TO_ADDR
// sEarthquake := false ;
92243: LD_ADDR_EXP 177
92247: PUSH
92248: LD_INT 0
92250: ST_TO_ADDR
// sAI := false ;
92251: LD_ADDR_EXP 178
92255: PUSH
92256: LD_INT 0
92258: ST_TO_ADDR
// sCargo := false ;
92259: LD_ADDR_EXP 181
92263: PUSH
92264: LD_INT 0
92266: ST_TO_ADDR
// sDLaser := false ;
92267: LD_ADDR_EXP 182
92271: PUSH
92272: LD_INT 0
92274: ST_TO_ADDR
// sExchange := false ;
92275: LD_ADDR_EXP 183
92279: PUSH
92280: LD_INT 0
92282: ST_TO_ADDR
// sFac := false ;
92283: LD_ADDR_EXP 184
92287: PUSH
92288: LD_INT 0
92290: ST_TO_ADDR
// sPower := false ;
92291: LD_ADDR_EXP 185
92295: PUSH
92296: LD_INT 0
92298: ST_TO_ADDR
// sRandom := false ;
92299: LD_ADDR_EXP 186
92303: PUSH
92304: LD_INT 0
92306: ST_TO_ADDR
// sShield := false ;
92307: LD_ADDR_EXP 187
92311: PUSH
92312: LD_INT 0
92314: ST_TO_ADDR
// sTime := false ;
92315: LD_ADDR_EXP 188
92319: PUSH
92320: LD_INT 0
92322: ST_TO_ADDR
// sTools := false ;
92323: LD_ADDR_EXP 189
92327: PUSH
92328: LD_INT 0
92330: ST_TO_ADDR
// sSold := false ;
92331: LD_ADDR_EXP 154
92335: PUSH
92336: LD_INT 0
92338: ST_TO_ADDR
// sDiff := false ;
92339: LD_ADDR_EXP 155
92343: PUSH
92344: LD_INT 0
92346: ST_TO_ADDR
// sFog := false ;
92347: LD_ADDR_EXP 158
92351: PUSH
92352: LD_INT 0
92354: ST_TO_ADDR
// sReset := false ;
92355: LD_ADDR_EXP 159
92359: PUSH
92360: LD_INT 0
92362: ST_TO_ADDR
// sSun := false ;
92363: LD_ADDR_EXP 160
92367: PUSH
92368: LD_INT 0
92370: ST_TO_ADDR
// sTiger := false ;
92371: LD_ADDR_EXP 156
92375: PUSH
92376: LD_INT 0
92378: ST_TO_ADDR
// sBomb := false ;
92379: LD_ADDR_EXP 157
92383: PUSH
92384: LD_INT 0
92386: ST_TO_ADDR
// sWound := false ;
92387: LD_ADDR_EXP 165
92391: PUSH
92392: LD_INT 0
92394: ST_TO_ADDR
// sBetray := false ;
92395: LD_ADDR_EXP 169
92399: PUSH
92400: LD_INT 0
92402: ST_TO_ADDR
// sContamin := false ;
92403: LD_ADDR_EXP 170
92407: PUSH
92408: LD_INT 0
92410: ST_TO_ADDR
// sOil := false ;
92411: LD_ADDR_EXP 172
92415: PUSH
92416: LD_INT 0
92418: ST_TO_ADDR
// sStu := false ;
92419: LD_ADDR_EXP 176
92423: PUSH
92424: LD_INT 0
92426: ST_TO_ADDR
// sBazooka := false ;
92427: LD_ADDR_EXP 179
92431: PUSH
92432: LD_INT 0
92434: ST_TO_ADDR
// sMortar := false ;
92435: LD_ADDR_EXP 180
92439: PUSH
92440: LD_INT 0
92442: ST_TO_ADDR
// sRanger := false ;
92443: LD_ADDR_EXP 190
92447: PUSH
92448: LD_INT 0
92450: ST_TO_ADDR
// end ;
92451: LD_VAR 0 1
92455: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
92456: LD_INT 0
92458: PPUSH
92459: PPUSH
92460: PPUSH
92461: PPUSH
92462: PPUSH
// result := [ ] ;
92463: LD_ADDR_VAR 0 1
92467: PUSH
92468: EMPTY
92469: ST_TO_ADDR
// if campaign_id = 1 then
92470: LD_OWVAR 69
92474: PUSH
92475: LD_INT 1
92477: EQUAL
92478: IFFALSE 95416
// begin case mission_number of 1 :
92480: LD_OWVAR 70
92484: PUSH
92485: LD_INT 1
92487: DOUBLE
92488: EQUAL
92489: IFTRUE 92493
92491: GO 92557
92493: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
92494: LD_ADDR_VAR 0 1
92498: PUSH
92499: LD_INT 2
92501: PUSH
92502: LD_INT 4
92504: PUSH
92505: LD_INT 11
92507: PUSH
92508: LD_INT 12
92510: PUSH
92511: LD_INT 15
92513: PUSH
92514: LD_INT 16
92516: PUSH
92517: LD_INT 22
92519: PUSH
92520: LD_INT 23
92522: PUSH
92523: LD_INT 26
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 101
92539: PUSH
92540: LD_INT 102
92542: PUSH
92543: LD_INT 106
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: LIST
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: ST_TO_ADDR
92555: GO 95414
92557: LD_INT 2
92559: DOUBLE
92560: EQUAL
92561: IFTRUE 92565
92563: GO 92637
92565: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
92566: LD_ADDR_VAR 0 1
92570: PUSH
92571: LD_INT 2
92573: PUSH
92574: LD_INT 4
92576: PUSH
92577: LD_INT 11
92579: PUSH
92580: LD_INT 12
92582: PUSH
92583: LD_INT 15
92585: PUSH
92586: LD_INT 16
92588: PUSH
92589: LD_INT 22
92591: PUSH
92592: LD_INT 23
92594: PUSH
92595: LD_INT 26
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 101
92611: PUSH
92612: LD_INT 102
92614: PUSH
92615: LD_INT 105
92617: PUSH
92618: LD_INT 106
92620: PUSH
92621: LD_INT 108
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: ST_TO_ADDR
92635: GO 95414
92637: LD_INT 3
92639: DOUBLE
92640: EQUAL
92641: IFTRUE 92645
92643: GO 92721
92645: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
92646: LD_ADDR_VAR 0 1
92650: PUSH
92651: LD_INT 2
92653: PUSH
92654: LD_INT 4
92656: PUSH
92657: LD_INT 5
92659: PUSH
92660: LD_INT 11
92662: PUSH
92663: LD_INT 12
92665: PUSH
92666: LD_INT 15
92668: PUSH
92669: LD_INT 16
92671: PUSH
92672: LD_INT 22
92674: PUSH
92675: LD_INT 26
92677: PUSH
92678: LD_INT 36
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: PUSH
92693: LD_INT 101
92695: PUSH
92696: LD_INT 102
92698: PUSH
92699: LD_INT 105
92701: PUSH
92702: LD_INT 106
92704: PUSH
92705: LD_INT 108
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: ST_TO_ADDR
92719: GO 95414
92721: LD_INT 4
92723: DOUBLE
92724: EQUAL
92725: IFTRUE 92729
92727: GO 92813
92729: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
92730: LD_ADDR_VAR 0 1
92734: PUSH
92735: LD_INT 2
92737: PUSH
92738: LD_INT 4
92740: PUSH
92741: LD_INT 5
92743: PUSH
92744: LD_INT 8
92746: PUSH
92747: LD_INT 11
92749: PUSH
92750: LD_INT 12
92752: PUSH
92753: LD_INT 15
92755: PUSH
92756: LD_INT 16
92758: PUSH
92759: LD_INT 22
92761: PUSH
92762: LD_INT 23
92764: PUSH
92765: LD_INT 26
92767: PUSH
92768: LD_INT 36
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 101
92787: PUSH
92788: LD_INT 102
92790: PUSH
92791: LD_INT 105
92793: PUSH
92794: LD_INT 106
92796: PUSH
92797: LD_INT 108
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: ST_TO_ADDR
92811: GO 95414
92813: LD_INT 5
92815: DOUBLE
92816: EQUAL
92817: IFTRUE 92821
92819: GO 92921
92821: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
92822: LD_ADDR_VAR 0 1
92826: PUSH
92827: LD_INT 2
92829: PUSH
92830: LD_INT 4
92832: PUSH
92833: LD_INT 5
92835: PUSH
92836: LD_INT 6
92838: PUSH
92839: LD_INT 8
92841: PUSH
92842: LD_INT 11
92844: PUSH
92845: LD_INT 12
92847: PUSH
92848: LD_INT 15
92850: PUSH
92851: LD_INT 16
92853: PUSH
92854: LD_INT 22
92856: PUSH
92857: LD_INT 23
92859: PUSH
92860: LD_INT 25
92862: PUSH
92863: LD_INT 26
92865: PUSH
92866: LD_INT 36
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 101
92887: PUSH
92888: LD_INT 102
92890: PUSH
92891: LD_INT 105
92893: PUSH
92894: LD_INT 106
92896: PUSH
92897: LD_INT 108
92899: PUSH
92900: LD_INT 109
92902: PUSH
92903: LD_INT 112
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: ST_TO_ADDR
92919: GO 95414
92921: LD_INT 6
92923: DOUBLE
92924: EQUAL
92925: IFTRUE 92929
92927: GO 93049
92929: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
92930: LD_ADDR_VAR 0 1
92934: PUSH
92935: LD_INT 2
92937: PUSH
92938: LD_INT 4
92940: PUSH
92941: LD_INT 5
92943: PUSH
92944: LD_INT 6
92946: PUSH
92947: LD_INT 8
92949: PUSH
92950: LD_INT 11
92952: PUSH
92953: LD_INT 12
92955: PUSH
92956: LD_INT 15
92958: PUSH
92959: LD_INT 16
92961: PUSH
92962: LD_INT 20
92964: PUSH
92965: LD_INT 21
92967: PUSH
92968: LD_INT 22
92970: PUSH
92971: LD_INT 23
92973: PUSH
92974: LD_INT 25
92976: PUSH
92977: LD_INT 26
92979: PUSH
92980: LD_INT 30
92982: PUSH
92983: LD_INT 31
92985: PUSH
92986: LD_INT 32
92988: PUSH
92989: LD_INT 36
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 101
93015: PUSH
93016: LD_INT 102
93018: PUSH
93019: LD_INT 105
93021: PUSH
93022: LD_INT 106
93024: PUSH
93025: LD_INT 108
93027: PUSH
93028: LD_INT 109
93030: PUSH
93031: LD_INT 112
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: ST_TO_ADDR
93047: GO 95414
93049: LD_INT 7
93051: DOUBLE
93052: EQUAL
93053: IFTRUE 93057
93055: GO 93157
93057: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
93058: LD_ADDR_VAR 0 1
93062: PUSH
93063: LD_INT 2
93065: PUSH
93066: LD_INT 4
93068: PUSH
93069: LD_INT 5
93071: PUSH
93072: LD_INT 7
93074: PUSH
93075: LD_INT 11
93077: PUSH
93078: LD_INT 12
93080: PUSH
93081: LD_INT 15
93083: PUSH
93084: LD_INT 16
93086: PUSH
93087: LD_INT 20
93089: PUSH
93090: LD_INT 21
93092: PUSH
93093: LD_INT 22
93095: PUSH
93096: LD_INT 23
93098: PUSH
93099: LD_INT 25
93101: PUSH
93102: LD_INT 26
93104: PUSH
93105: EMPTY
93106: LIST
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: PUSH
93121: LD_INT 101
93123: PUSH
93124: LD_INT 102
93126: PUSH
93127: LD_INT 103
93129: PUSH
93130: LD_INT 105
93132: PUSH
93133: LD_INT 106
93135: PUSH
93136: LD_INT 108
93138: PUSH
93139: LD_INT 112
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: ST_TO_ADDR
93155: GO 95414
93157: LD_INT 8
93159: DOUBLE
93160: EQUAL
93161: IFTRUE 93165
93163: GO 93293
93165: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
93166: LD_ADDR_VAR 0 1
93170: PUSH
93171: LD_INT 2
93173: PUSH
93174: LD_INT 4
93176: PUSH
93177: LD_INT 5
93179: PUSH
93180: LD_INT 6
93182: PUSH
93183: LD_INT 7
93185: PUSH
93186: LD_INT 8
93188: PUSH
93189: LD_INT 11
93191: PUSH
93192: LD_INT 12
93194: PUSH
93195: LD_INT 15
93197: PUSH
93198: LD_INT 16
93200: PUSH
93201: LD_INT 20
93203: PUSH
93204: LD_INT 21
93206: PUSH
93207: LD_INT 22
93209: PUSH
93210: LD_INT 23
93212: PUSH
93213: LD_INT 25
93215: PUSH
93216: LD_INT 26
93218: PUSH
93219: LD_INT 30
93221: PUSH
93222: LD_INT 31
93224: PUSH
93225: LD_INT 32
93227: PUSH
93228: LD_INT 36
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 101
93255: PUSH
93256: LD_INT 102
93258: PUSH
93259: LD_INT 103
93261: PUSH
93262: LD_INT 105
93264: PUSH
93265: LD_INT 106
93267: PUSH
93268: LD_INT 108
93270: PUSH
93271: LD_INT 109
93273: PUSH
93274: LD_INT 112
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: ST_TO_ADDR
93291: GO 95414
93293: LD_INT 9
93295: DOUBLE
93296: EQUAL
93297: IFTRUE 93301
93299: GO 93437
93301: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
93302: LD_ADDR_VAR 0 1
93306: PUSH
93307: LD_INT 2
93309: PUSH
93310: LD_INT 4
93312: PUSH
93313: LD_INT 5
93315: PUSH
93316: LD_INT 6
93318: PUSH
93319: LD_INT 7
93321: PUSH
93322: LD_INT 8
93324: PUSH
93325: LD_INT 11
93327: PUSH
93328: LD_INT 12
93330: PUSH
93331: LD_INT 15
93333: PUSH
93334: LD_INT 16
93336: PUSH
93337: LD_INT 20
93339: PUSH
93340: LD_INT 21
93342: PUSH
93343: LD_INT 22
93345: PUSH
93346: LD_INT 23
93348: PUSH
93349: LD_INT 25
93351: PUSH
93352: LD_INT 26
93354: PUSH
93355: LD_INT 28
93357: PUSH
93358: LD_INT 30
93360: PUSH
93361: LD_INT 31
93363: PUSH
93364: LD_INT 32
93366: PUSH
93367: LD_INT 36
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 101
93395: PUSH
93396: LD_INT 102
93398: PUSH
93399: LD_INT 103
93401: PUSH
93402: LD_INT 105
93404: PUSH
93405: LD_INT 106
93407: PUSH
93408: LD_INT 108
93410: PUSH
93411: LD_INT 109
93413: PUSH
93414: LD_INT 112
93416: PUSH
93417: LD_INT 114
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: ST_TO_ADDR
93435: GO 95414
93437: LD_INT 10
93439: DOUBLE
93440: EQUAL
93441: IFTRUE 93445
93443: GO 93629
93445: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
93446: LD_ADDR_VAR 0 1
93450: PUSH
93451: LD_INT 2
93453: PUSH
93454: LD_INT 4
93456: PUSH
93457: LD_INT 5
93459: PUSH
93460: LD_INT 6
93462: PUSH
93463: LD_INT 7
93465: PUSH
93466: LD_INT 8
93468: PUSH
93469: LD_INT 9
93471: PUSH
93472: LD_INT 10
93474: PUSH
93475: LD_INT 11
93477: PUSH
93478: LD_INT 12
93480: PUSH
93481: LD_INT 13
93483: PUSH
93484: LD_INT 14
93486: PUSH
93487: LD_INT 15
93489: PUSH
93490: LD_INT 16
93492: PUSH
93493: LD_INT 17
93495: PUSH
93496: LD_INT 18
93498: PUSH
93499: LD_INT 19
93501: PUSH
93502: LD_INT 20
93504: PUSH
93505: LD_INT 21
93507: PUSH
93508: LD_INT 22
93510: PUSH
93511: LD_INT 23
93513: PUSH
93514: LD_INT 24
93516: PUSH
93517: LD_INT 25
93519: PUSH
93520: LD_INT 26
93522: PUSH
93523: LD_INT 28
93525: PUSH
93526: LD_INT 30
93528: PUSH
93529: LD_INT 31
93531: PUSH
93532: LD_INT 32
93534: PUSH
93535: LD_INT 36
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: PUSH
93569: LD_INT 101
93571: PUSH
93572: LD_INT 102
93574: PUSH
93575: LD_INT 103
93577: PUSH
93578: LD_INT 104
93580: PUSH
93581: LD_INT 105
93583: PUSH
93584: LD_INT 106
93586: PUSH
93587: LD_INT 107
93589: PUSH
93590: LD_INT 108
93592: PUSH
93593: LD_INT 109
93595: PUSH
93596: LD_INT 110
93598: PUSH
93599: LD_INT 111
93601: PUSH
93602: LD_INT 112
93604: PUSH
93605: LD_INT 114
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: ST_TO_ADDR
93627: GO 95414
93629: LD_INT 11
93631: DOUBLE
93632: EQUAL
93633: IFTRUE 93637
93635: GO 93829
93637: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
93638: LD_ADDR_VAR 0 1
93642: PUSH
93643: LD_INT 2
93645: PUSH
93646: LD_INT 3
93648: PUSH
93649: LD_INT 4
93651: PUSH
93652: LD_INT 5
93654: PUSH
93655: LD_INT 6
93657: PUSH
93658: LD_INT 7
93660: PUSH
93661: LD_INT 8
93663: PUSH
93664: LD_INT 9
93666: PUSH
93667: LD_INT 10
93669: PUSH
93670: LD_INT 11
93672: PUSH
93673: LD_INT 12
93675: PUSH
93676: LD_INT 13
93678: PUSH
93679: LD_INT 14
93681: PUSH
93682: LD_INT 15
93684: PUSH
93685: LD_INT 16
93687: PUSH
93688: LD_INT 17
93690: PUSH
93691: LD_INT 18
93693: PUSH
93694: LD_INT 19
93696: PUSH
93697: LD_INT 20
93699: PUSH
93700: LD_INT 21
93702: PUSH
93703: LD_INT 22
93705: PUSH
93706: LD_INT 23
93708: PUSH
93709: LD_INT 24
93711: PUSH
93712: LD_INT 25
93714: PUSH
93715: LD_INT 26
93717: PUSH
93718: LD_INT 28
93720: PUSH
93721: LD_INT 30
93723: PUSH
93724: LD_INT 31
93726: PUSH
93727: LD_INT 32
93729: PUSH
93730: LD_INT 34
93732: PUSH
93733: LD_INT 36
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 101
93771: PUSH
93772: LD_INT 102
93774: PUSH
93775: LD_INT 103
93777: PUSH
93778: LD_INT 104
93780: PUSH
93781: LD_INT 105
93783: PUSH
93784: LD_INT 106
93786: PUSH
93787: LD_INT 107
93789: PUSH
93790: LD_INT 108
93792: PUSH
93793: LD_INT 109
93795: PUSH
93796: LD_INT 110
93798: PUSH
93799: LD_INT 111
93801: PUSH
93802: LD_INT 112
93804: PUSH
93805: LD_INT 114
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: ST_TO_ADDR
93827: GO 95414
93829: LD_INT 12
93831: DOUBLE
93832: EQUAL
93833: IFTRUE 93837
93835: GO 94045
93837: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
93838: LD_ADDR_VAR 0 1
93842: PUSH
93843: LD_INT 1
93845: PUSH
93846: LD_INT 2
93848: PUSH
93849: LD_INT 3
93851: PUSH
93852: LD_INT 4
93854: PUSH
93855: LD_INT 5
93857: PUSH
93858: LD_INT 6
93860: PUSH
93861: LD_INT 7
93863: PUSH
93864: LD_INT 8
93866: PUSH
93867: LD_INT 9
93869: PUSH
93870: LD_INT 10
93872: PUSH
93873: LD_INT 11
93875: PUSH
93876: LD_INT 12
93878: PUSH
93879: LD_INT 13
93881: PUSH
93882: LD_INT 14
93884: PUSH
93885: LD_INT 15
93887: PUSH
93888: LD_INT 16
93890: PUSH
93891: LD_INT 17
93893: PUSH
93894: LD_INT 18
93896: PUSH
93897: LD_INT 19
93899: PUSH
93900: LD_INT 20
93902: PUSH
93903: LD_INT 21
93905: PUSH
93906: LD_INT 22
93908: PUSH
93909: LD_INT 23
93911: PUSH
93912: LD_INT 24
93914: PUSH
93915: LD_INT 25
93917: PUSH
93918: LD_INT 26
93920: PUSH
93921: LD_INT 27
93923: PUSH
93924: LD_INT 28
93926: PUSH
93927: LD_INT 30
93929: PUSH
93930: LD_INT 31
93932: PUSH
93933: LD_INT 32
93935: PUSH
93936: LD_INT 33
93938: PUSH
93939: LD_INT 34
93941: PUSH
93942: LD_INT 36
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 101
93983: PUSH
93984: LD_INT 102
93986: PUSH
93987: LD_INT 103
93989: PUSH
93990: LD_INT 104
93992: PUSH
93993: LD_INT 105
93995: PUSH
93996: LD_INT 106
93998: PUSH
93999: LD_INT 107
94001: PUSH
94002: LD_INT 108
94004: PUSH
94005: LD_INT 109
94007: PUSH
94008: LD_INT 110
94010: PUSH
94011: LD_INT 111
94013: PUSH
94014: LD_INT 112
94016: PUSH
94017: LD_INT 113
94019: PUSH
94020: LD_INT 114
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: ST_TO_ADDR
94043: GO 95414
94045: LD_INT 13
94047: DOUBLE
94048: EQUAL
94049: IFTRUE 94053
94051: GO 94249
94053: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
94054: LD_ADDR_VAR 0 1
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: LD_INT 2
94064: PUSH
94065: LD_INT 3
94067: PUSH
94068: LD_INT 4
94070: PUSH
94071: LD_INT 5
94073: PUSH
94074: LD_INT 8
94076: PUSH
94077: LD_INT 9
94079: PUSH
94080: LD_INT 10
94082: PUSH
94083: LD_INT 11
94085: PUSH
94086: LD_INT 12
94088: PUSH
94089: LD_INT 14
94091: PUSH
94092: LD_INT 15
94094: PUSH
94095: LD_INT 16
94097: PUSH
94098: LD_INT 17
94100: PUSH
94101: LD_INT 18
94103: PUSH
94104: LD_INT 19
94106: PUSH
94107: LD_INT 20
94109: PUSH
94110: LD_INT 21
94112: PUSH
94113: LD_INT 22
94115: PUSH
94116: LD_INT 23
94118: PUSH
94119: LD_INT 24
94121: PUSH
94122: LD_INT 25
94124: PUSH
94125: LD_INT 26
94127: PUSH
94128: LD_INT 27
94130: PUSH
94131: LD_INT 28
94133: PUSH
94134: LD_INT 30
94136: PUSH
94137: LD_INT 31
94139: PUSH
94140: LD_INT 32
94142: PUSH
94143: LD_INT 33
94145: PUSH
94146: LD_INT 34
94148: PUSH
94149: LD_INT 36
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 101
94187: PUSH
94188: LD_INT 102
94190: PUSH
94191: LD_INT 103
94193: PUSH
94194: LD_INT 104
94196: PUSH
94197: LD_INT 105
94199: PUSH
94200: LD_INT 106
94202: PUSH
94203: LD_INT 107
94205: PUSH
94206: LD_INT 108
94208: PUSH
94209: LD_INT 109
94211: PUSH
94212: LD_INT 110
94214: PUSH
94215: LD_INT 111
94217: PUSH
94218: LD_INT 112
94220: PUSH
94221: LD_INT 113
94223: PUSH
94224: LD_INT 114
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: ST_TO_ADDR
94247: GO 95414
94249: LD_INT 14
94251: DOUBLE
94252: EQUAL
94253: IFTRUE 94257
94255: GO 94469
94257: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
94258: LD_ADDR_VAR 0 1
94262: PUSH
94263: LD_INT 1
94265: PUSH
94266: LD_INT 2
94268: PUSH
94269: LD_INT 3
94271: PUSH
94272: LD_INT 4
94274: PUSH
94275: LD_INT 5
94277: PUSH
94278: LD_INT 6
94280: PUSH
94281: LD_INT 7
94283: PUSH
94284: LD_INT 8
94286: PUSH
94287: LD_INT 9
94289: PUSH
94290: LD_INT 10
94292: PUSH
94293: LD_INT 11
94295: PUSH
94296: LD_INT 12
94298: PUSH
94299: LD_INT 13
94301: PUSH
94302: LD_INT 14
94304: PUSH
94305: LD_INT 15
94307: PUSH
94308: LD_INT 16
94310: PUSH
94311: LD_INT 17
94313: PUSH
94314: LD_INT 18
94316: PUSH
94317: LD_INT 19
94319: PUSH
94320: LD_INT 20
94322: PUSH
94323: LD_INT 21
94325: PUSH
94326: LD_INT 22
94328: PUSH
94329: LD_INT 23
94331: PUSH
94332: LD_INT 24
94334: PUSH
94335: LD_INT 25
94337: PUSH
94338: LD_INT 26
94340: PUSH
94341: LD_INT 27
94343: PUSH
94344: LD_INT 28
94346: PUSH
94347: LD_INT 29
94349: PUSH
94350: LD_INT 30
94352: PUSH
94353: LD_INT 31
94355: PUSH
94356: LD_INT 32
94358: PUSH
94359: LD_INT 33
94361: PUSH
94362: LD_INT 34
94364: PUSH
94365: LD_INT 36
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 101
94407: PUSH
94408: LD_INT 102
94410: PUSH
94411: LD_INT 103
94413: PUSH
94414: LD_INT 104
94416: PUSH
94417: LD_INT 105
94419: PUSH
94420: LD_INT 106
94422: PUSH
94423: LD_INT 107
94425: PUSH
94426: LD_INT 108
94428: PUSH
94429: LD_INT 109
94431: PUSH
94432: LD_INT 110
94434: PUSH
94435: LD_INT 111
94437: PUSH
94438: LD_INT 112
94440: PUSH
94441: LD_INT 113
94443: PUSH
94444: LD_INT 114
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: ST_TO_ADDR
94467: GO 95414
94469: LD_INT 15
94471: DOUBLE
94472: EQUAL
94473: IFTRUE 94477
94475: GO 94689
94477: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
94478: LD_ADDR_VAR 0 1
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: LD_INT 2
94488: PUSH
94489: LD_INT 3
94491: PUSH
94492: LD_INT 4
94494: PUSH
94495: LD_INT 5
94497: PUSH
94498: LD_INT 6
94500: PUSH
94501: LD_INT 7
94503: PUSH
94504: LD_INT 8
94506: PUSH
94507: LD_INT 9
94509: PUSH
94510: LD_INT 10
94512: PUSH
94513: LD_INT 11
94515: PUSH
94516: LD_INT 12
94518: PUSH
94519: LD_INT 13
94521: PUSH
94522: LD_INT 14
94524: PUSH
94525: LD_INT 15
94527: PUSH
94528: LD_INT 16
94530: PUSH
94531: LD_INT 17
94533: PUSH
94534: LD_INT 18
94536: PUSH
94537: LD_INT 19
94539: PUSH
94540: LD_INT 20
94542: PUSH
94543: LD_INT 21
94545: PUSH
94546: LD_INT 22
94548: PUSH
94549: LD_INT 23
94551: PUSH
94552: LD_INT 24
94554: PUSH
94555: LD_INT 25
94557: PUSH
94558: LD_INT 26
94560: PUSH
94561: LD_INT 27
94563: PUSH
94564: LD_INT 28
94566: PUSH
94567: LD_INT 29
94569: PUSH
94570: LD_INT 30
94572: PUSH
94573: LD_INT 31
94575: PUSH
94576: LD_INT 32
94578: PUSH
94579: LD_INT 33
94581: PUSH
94582: LD_INT 34
94584: PUSH
94585: LD_INT 36
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 101
94627: PUSH
94628: LD_INT 102
94630: PUSH
94631: LD_INT 103
94633: PUSH
94634: LD_INT 104
94636: PUSH
94637: LD_INT 105
94639: PUSH
94640: LD_INT 106
94642: PUSH
94643: LD_INT 107
94645: PUSH
94646: LD_INT 108
94648: PUSH
94649: LD_INT 109
94651: PUSH
94652: LD_INT 110
94654: PUSH
94655: LD_INT 111
94657: PUSH
94658: LD_INT 112
94660: PUSH
94661: LD_INT 113
94663: PUSH
94664: LD_INT 114
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: ST_TO_ADDR
94687: GO 95414
94689: LD_INT 16
94691: DOUBLE
94692: EQUAL
94693: IFTRUE 94697
94695: GO 94821
94697: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
94698: LD_ADDR_VAR 0 1
94702: PUSH
94703: LD_INT 2
94705: PUSH
94706: LD_INT 4
94708: PUSH
94709: LD_INT 5
94711: PUSH
94712: LD_INT 7
94714: PUSH
94715: LD_INT 11
94717: PUSH
94718: LD_INT 12
94720: PUSH
94721: LD_INT 15
94723: PUSH
94724: LD_INT 16
94726: PUSH
94727: LD_INT 20
94729: PUSH
94730: LD_INT 21
94732: PUSH
94733: LD_INT 22
94735: PUSH
94736: LD_INT 23
94738: PUSH
94739: LD_INT 25
94741: PUSH
94742: LD_INT 26
94744: PUSH
94745: LD_INT 30
94747: PUSH
94748: LD_INT 31
94750: PUSH
94751: LD_INT 32
94753: PUSH
94754: LD_INT 33
94756: PUSH
94757: LD_INT 34
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: PUSH
94781: LD_INT 101
94783: PUSH
94784: LD_INT 102
94786: PUSH
94787: LD_INT 103
94789: PUSH
94790: LD_INT 106
94792: PUSH
94793: LD_INT 108
94795: PUSH
94796: LD_INT 112
94798: PUSH
94799: LD_INT 113
94801: PUSH
94802: LD_INT 114
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: ST_TO_ADDR
94819: GO 95414
94821: LD_INT 17
94823: DOUBLE
94824: EQUAL
94825: IFTRUE 94829
94827: GO 95041
94829: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
94830: LD_ADDR_VAR 0 1
94834: PUSH
94835: LD_INT 1
94837: PUSH
94838: LD_INT 2
94840: PUSH
94841: LD_INT 3
94843: PUSH
94844: LD_INT 4
94846: PUSH
94847: LD_INT 5
94849: PUSH
94850: LD_INT 6
94852: PUSH
94853: LD_INT 7
94855: PUSH
94856: LD_INT 8
94858: PUSH
94859: LD_INT 9
94861: PUSH
94862: LD_INT 10
94864: PUSH
94865: LD_INT 11
94867: PUSH
94868: LD_INT 12
94870: PUSH
94871: LD_INT 13
94873: PUSH
94874: LD_INT 14
94876: PUSH
94877: LD_INT 15
94879: PUSH
94880: LD_INT 16
94882: PUSH
94883: LD_INT 17
94885: PUSH
94886: LD_INT 18
94888: PUSH
94889: LD_INT 19
94891: PUSH
94892: LD_INT 20
94894: PUSH
94895: LD_INT 21
94897: PUSH
94898: LD_INT 22
94900: PUSH
94901: LD_INT 23
94903: PUSH
94904: LD_INT 24
94906: PUSH
94907: LD_INT 25
94909: PUSH
94910: LD_INT 26
94912: PUSH
94913: LD_INT 27
94915: PUSH
94916: LD_INT 28
94918: PUSH
94919: LD_INT 29
94921: PUSH
94922: LD_INT 30
94924: PUSH
94925: LD_INT 31
94927: PUSH
94928: LD_INT 32
94930: PUSH
94931: LD_INT 33
94933: PUSH
94934: LD_INT 34
94936: PUSH
94937: LD_INT 36
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 101
94979: PUSH
94980: LD_INT 102
94982: PUSH
94983: LD_INT 103
94985: PUSH
94986: LD_INT 104
94988: PUSH
94989: LD_INT 105
94991: PUSH
94992: LD_INT 106
94994: PUSH
94995: LD_INT 107
94997: PUSH
94998: LD_INT 108
95000: PUSH
95001: LD_INT 109
95003: PUSH
95004: LD_INT 110
95006: PUSH
95007: LD_INT 111
95009: PUSH
95010: LD_INT 112
95012: PUSH
95013: LD_INT 113
95015: PUSH
95016: LD_INT 114
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: ST_TO_ADDR
95039: GO 95414
95041: LD_INT 18
95043: DOUBLE
95044: EQUAL
95045: IFTRUE 95049
95047: GO 95185
95049: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
95050: LD_ADDR_VAR 0 1
95054: PUSH
95055: LD_INT 2
95057: PUSH
95058: LD_INT 4
95060: PUSH
95061: LD_INT 5
95063: PUSH
95064: LD_INT 7
95066: PUSH
95067: LD_INT 11
95069: PUSH
95070: LD_INT 12
95072: PUSH
95073: LD_INT 15
95075: PUSH
95076: LD_INT 16
95078: PUSH
95079: LD_INT 20
95081: PUSH
95082: LD_INT 21
95084: PUSH
95085: LD_INT 22
95087: PUSH
95088: LD_INT 23
95090: PUSH
95091: LD_INT 25
95093: PUSH
95094: LD_INT 26
95096: PUSH
95097: LD_INT 30
95099: PUSH
95100: LD_INT 31
95102: PUSH
95103: LD_INT 32
95105: PUSH
95106: LD_INT 33
95108: PUSH
95109: LD_INT 34
95111: PUSH
95112: LD_INT 35
95114: PUSH
95115: LD_INT 36
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 101
95143: PUSH
95144: LD_INT 102
95146: PUSH
95147: LD_INT 103
95149: PUSH
95150: LD_INT 106
95152: PUSH
95153: LD_INT 108
95155: PUSH
95156: LD_INT 112
95158: PUSH
95159: LD_INT 113
95161: PUSH
95162: LD_INT 114
95164: PUSH
95165: LD_INT 115
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: ST_TO_ADDR
95183: GO 95414
95185: LD_INT 19
95187: DOUBLE
95188: EQUAL
95189: IFTRUE 95193
95191: GO 95413
95193: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
95194: LD_ADDR_VAR 0 1
95198: PUSH
95199: LD_INT 1
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: LD_INT 3
95207: PUSH
95208: LD_INT 4
95210: PUSH
95211: LD_INT 5
95213: PUSH
95214: LD_INT 6
95216: PUSH
95217: LD_INT 7
95219: PUSH
95220: LD_INT 8
95222: PUSH
95223: LD_INT 9
95225: PUSH
95226: LD_INT 10
95228: PUSH
95229: LD_INT 11
95231: PUSH
95232: LD_INT 12
95234: PUSH
95235: LD_INT 13
95237: PUSH
95238: LD_INT 14
95240: PUSH
95241: LD_INT 15
95243: PUSH
95244: LD_INT 16
95246: PUSH
95247: LD_INT 17
95249: PUSH
95250: LD_INT 18
95252: PUSH
95253: LD_INT 19
95255: PUSH
95256: LD_INT 20
95258: PUSH
95259: LD_INT 21
95261: PUSH
95262: LD_INT 22
95264: PUSH
95265: LD_INT 23
95267: PUSH
95268: LD_INT 24
95270: PUSH
95271: LD_INT 25
95273: PUSH
95274: LD_INT 26
95276: PUSH
95277: LD_INT 27
95279: PUSH
95280: LD_INT 28
95282: PUSH
95283: LD_INT 29
95285: PUSH
95286: LD_INT 30
95288: PUSH
95289: LD_INT 31
95291: PUSH
95292: LD_INT 32
95294: PUSH
95295: LD_INT 33
95297: PUSH
95298: LD_INT 34
95300: PUSH
95301: LD_INT 35
95303: PUSH
95304: LD_INT 36
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 101
95347: PUSH
95348: LD_INT 102
95350: PUSH
95351: LD_INT 103
95353: PUSH
95354: LD_INT 104
95356: PUSH
95357: LD_INT 105
95359: PUSH
95360: LD_INT 106
95362: PUSH
95363: LD_INT 107
95365: PUSH
95366: LD_INT 108
95368: PUSH
95369: LD_INT 109
95371: PUSH
95372: LD_INT 110
95374: PUSH
95375: LD_INT 111
95377: PUSH
95378: LD_INT 112
95380: PUSH
95381: LD_INT 113
95383: PUSH
95384: LD_INT 114
95386: PUSH
95387: LD_INT 115
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: ST_TO_ADDR
95411: GO 95414
95413: POP
// end else
95414: GO 95633
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
95416: LD_ADDR_VAR 0 1
95420: PUSH
95421: LD_INT 1
95423: PUSH
95424: LD_INT 2
95426: PUSH
95427: LD_INT 3
95429: PUSH
95430: LD_INT 4
95432: PUSH
95433: LD_INT 5
95435: PUSH
95436: LD_INT 6
95438: PUSH
95439: LD_INT 7
95441: PUSH
95442: LD_INT 8
95444: PUSH
95445: LD_INT 9
95447: PUSH
95448: LD_INT 10
95450: PUSH
95451: LD_INT 11
95453: PUSH
95454: LD_INT 12
95456: PUSH
95457: LD_INT 13
95459: PUSH
95460: LD_INT 14
95462: PUSH
95463: LD_INT 15
95465: PUSH
95466: LD_INT 16
95468: PUSH
95469: LD_INT 17
95471: PUSH
95472: LD_INT 18
95474: PUSH
95475: LD_INT 19
95477: PUSH
95478: LD_INT 20
95480: PUSH
95481: LD_INT 21
95483: PUSH
95484: LD_INT 22
95486: PUSH
95487: LD_INT 23
95489: PUSH
95490: LD_INT 24
95492: PUSH
95493: LD_INT 25
95495: PUSH
95496: LD_INT 26
95498: PUSH
95499: LD_INT 27
95501: PUSH
95502: LD_INT 28
95504: PUSH
95505: LD_INT 29
95507: PUSH
95508: LD_INT 30
95510: PUSH
95511: LD_INT 31
95513: PUSH
95514: LD_INT 32
95516: PUSH
95517: LD_INT 33
95519: PUSH
95520: LD_INT 34
95522: PUSH
95523: LD_INT 35
95525: PUSH
95526: LD_INT 36
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 101
95569: PUSH
95570: LD_INT 102
95572: PUSH
95573: LD_INT 103
95575: PUSH
95576: LD_INT 104
95578: PUSH
95579: LD_INT 105
95581: PUSH
95582: LD_INT 106
95584: PUSH
95585: LD_INT 107
95587: PUSH
95588: LD_INT 108
95590: PUSH
95591: LD_INT 109
95593: PUSH
95594: LD_INT 110
95596: PUSH
95597: LD_INT 111
95599: PUSH
95600: LD_INT 112
95602: PUSH
95603: LD_INT 113
95605: PUSH
95606: LD_INT 114
95608: PUSH
95609: LD_INT 115
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: ST_TO_ADDR
// if result then
95633: LD_VAR 0 1
95637: IFFALSE 95926
// begin normal :=  ;
95639: LD_ADDR_VAR 0 3
95643: PUSH
95644: LD_STRING 
95646: ST_TO_ADDR
// hardcore :=  ;
95647: LD_ADDR_VAR 0 4
95651: PUSH
95652: LD_STRING 
95654: ST_TO_ADDR
// for i = 1 to normalCounter do
95655: LD_ADDR_VAR 0 5
95659: PUSH
95660: DOUBLE
95661: LD_INT 1
95663: DEC
95664: ST_TO_ADDR
95665: LD_EXP 138
95669: PUSH
95670: FOR_TO
95671: IFFALSE 95772
// begin tmp := 0 ;
95673: LD_ADDR_VAR 0 2
95677: PUSH
95678: LD_STRING 0
95680: ST_TO_ADDR
// if result [ 1 ] then
95681: LD_VAR 0 1
95685: PUSH
95686: LD_INT 1
95688: ARRAY
95689: IFFALSE 95754
// if result [ 1 ] [ 1 ] = i then
95691: LD_VAR 0 1
95695: PUSH
95696: LD_INT 1
95698: ARRAY
95699: PUSH
95700: LD_INT 1
95702: ARRAY
95703: PUSH
95704: LD_VAR 0 5
95708: EQUAL
95709: IFFALSE 95754
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95711: LD_ADDR_VAR 0 1
95715: PUSH
95716: LD_VAR 0 1
95720: PPUSH
95721: LD_INT 1
95723: PPUSH
95724: LD_VAR 0 1
95728: PUSH
95729: LD_INT 1
95731: ARRAY
95732: PPUSH
95733: LD_INT 1
95735: PPUSH
95736: CALL_OW 3
95740: PPUSH
95741: CALL_OW 1
95745: ST_TO_ADDR
// tmp := 1 ;
95746: LD_ADDR_VAR 0 2
95750: PUSH
95751: LD_STRING 1
95753: ST_TO_ADDR
// end ; normal := normal & tmp ;
95754: LD_ADDR_VAR 0 3
95758: PUSH
95759: LD_VAR 0 3
95763: PUSH
95764: LD_VAR 0 2
95768: STR
95769: ST_TO_ADDR
// end ;
95770: GO 95670
95772: POP
95773: POP
// for i = 1 to hardcoreCounter do
95774: LD_ADDR_VAR 0 5
95778: PUSH
95779: DOUBLE
95780: LD_INT 1
95782: DEC
95783: ST_TO_ADDR
95784: LD_EXP 139
95788: PUSH
95789: FOR_TO
95790: IFFALSE 95895
// begin tmp := 0 ;
95792: LD_ADDR_VAR 0 2
95796: PUSH
95797: LD_STRING 0
95799: ST_TO_ADDR
// if result [ 2 ] then
95800: LD_VAR 0 1
95804: PUSH
95805: LD_INT 2
95807: ARRAY
95808: IFFALSE 95877
// if result [ 2 ] [ 1 ] = 100 + i then
95810: LD_VAR 0 1
95814: PUSH
95815: LD_INT 2
95817: ARRAY
95818: PUSH
95819: LD_INT 1
95821: ARRAY
95822: PUSH
95823: LD_INT 100
95825: PUSH
95826: LD_VAR 0 5
95830: PLUS
95831: EQUAL
95832: IFFALSE 95877
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95834: LD_ADDR_VAR 0 1
95838: PUSH
95839: LD_VAR 0 1
95843: PPUSH
95844: LD_INT 2
95846: PPUSH
95847: LD_VAR 0 1
95851: PUSH
95852: LD_INT 2
95854: ARRAY
95855: PPUSH
95856: LD_INT 1
95858: PPUSH
95859: CALL_OW 3
95863: PPUSH
95864: CALL_OW 1
95868: ST_TO_ADDR
// tmp := 1 ;
95869: LD_ADDR_VAR 0 2
95873: PUSH
95874: LD_STRING 1
95876: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95877: LD_ADDR_VAR 0 4
95881: PUSH
95882: LD_VAR 0 4
95886: PUSH
95887: LD_VAR 0 2
95891: STR
95892: ST_TO_ADDR
// end ;
95893: GO 95789
95895: POP
95896: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
95897: LD_STRING getStreamItemsFromMission("
95899: PUSH
95900: LD_VAR 0 3
95904: STR
95905: PUSH
95906: LD_STRING ","
95908: STR
95909: PUSH
95910: LD_VAR 0 4
95914: STR
95915: PUSH
95916: LD_STRING ")
95918: STR
95919: PPUSH
95920: CALL_OW 559
// end else
95924: GO 95933
// ToLua ( getStreamItemsFromMission("","") ) ;
95926: LD_STRING getStreamItemsFromMission("","")
95928: PPUSH
95929: CALL_OW 559
// end ;
95933: LD_VAR 0 1
95937: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95938: LD_EXP 137
95942: PUSH
95943: LD_EXP 142
95947: AND
95948: IFFALSE 96072
95950: GO 95952
95952: DISABLE
95953: LD_INT 0
95955: PPUSH
95956: PPUSH
// begin enable ;
95957: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95958: LD_ADDR_VAR 0 2
95962: PUSH
95963: LD_INT 22
95965: PUSH
95966: LD_OWVAR 2
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 2
95977: PUSH
95978: LD_INT 34
95980: PUSH
95981: LD_INT 7
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 34
95990: PUSH
95991: LD_INT 45
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 34
96000: PUSH
96001: LD_INT 28
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 34
96010: PUSH
96011: LD_INT 47
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PPUSH
96029: CALL_OW 69
96033: ST_TO_ADDR
// if not tmp then
96034: LD_VAR 0 2
96038: NOT
96039: IFFALSE 96043
// exit ;
96041: GO 96072
// for i in tmp do
96043: LD_ADDR_VAR 0 1
96047: PUSH
96048: LD_VAR 0 2
96052: PUSH
96053: FOR_IN
96054: IFFALSE 96070
// begin SetLives ( i , 0 ) ;
96056: LD_VAR 0 1
96060: PPUSH
96061: LD_INT 0
96063: PPUSH
96064: CALL_OW 234
// end ;
96068: GO 96053
96070: POP
96071: POP
// end ;
96072: PPOPN 2
96074: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96075: LD_EXP 137
96079: PUSH
96080: LD_EXP 143
96084: AND
96085: IFFALSE 96169
96087: GO 96089
96089: DISABLE
96090: LD_INT 0
96092: PPUSH
96093: PPUSH
// begin enable ;
96094: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96095: LD_ADDR_VAR 0 2
96099: PUSH
96100: LD_INT 22
96102: PUSH
96103: LD_OWVAR 2
96107: PUSH
96108: EMPTY
96109: LIST
96110: LIST
96111: PUSH
96112: LD_INT 32
96114: PUSH
96115: LD_INT 3
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PPUSH
96126: CALL_OW 69
96130: ST_TO_ADDR
// if not tmp then
96131: LD_VAR 0 2
96135: NOT
96136: IFFALSE 96140
// exit ;
96138: GO 96169
// for i in tmp do
96140: LD_ADDR_VAR 0 1
96144: PUSH
96145: LD_VAR 0 2
96149: PUSH
96150: FOR_IN
96151: IFFALSE 96167
// begin SetLives ( i , 0 ) ;
96153: LD_VAR 0 1
96157: PPUSH
96158: LD_INT 0
96160: PPUSH
96161: CALL_OW 234
// end ;
96165: GO 96150
96167: POP
96168: POP
// end ;
96169: PPOPN 2
96171: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96172: LD_EXP 137
96176: PUSH
96177: LD_EXP 140
96181: AND
96182: IFFALSE 96275
96184: GO 96186
96186: DISABLE
96187: LD_INT 0
96189: PPUSH
// begin enable ;
96190: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96191: LD_ADDR_VAR 0 1
96195: PUSH
96196: LD_INT 22
96198: PUSH
96199: LD_OWVAR 2
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: LD_INT 25
96213: PUSH
96214: LD_INT 5
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 25
96223: PUSH
96224: LD_INT 9
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 25
96233: PUSH
96234: LD_INT 8
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PPUSH
96251: CALL_OW 69
96255: PUSH
96256: FOR_IN
96257: IFFALSE 96273
// begin SetClass ( i , 1 ) ;
96259: LD_VAR 0 1
96263: PPUSH
96264: LD_INT 1
96266: PPUSH
96267: CALL_OW 336
// end ;
96271: GO 96256
96273: POP
96274: POP
// end ;
96275: PPOPN 1
96277: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96278: LD_EXP 137
96282: PUSH
96283: LD_EXP 141
96287: AND
96288: PUSH
96289: LD_OWVAR 65
96293: PUSH
96294: LD_INT 7
96296: LESS
96297: AND
96298: IFFALSE 96312
96300: GO 96302
96302: DISABLE
// begin enable ;
96303: ENABLE
// game_speed := 7 ;
96304: LD_ADDR_OWVAR 65
96308: PUSH
96309: LD_INT 7
96311: ST_TO_ADDR
// end ;
96312: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96313: LD_EXP 137
96317: PUSH
96318: LD_EXP 144
96322: AND
96323: IFFALSE 96525
96325: GO 96327
96327: DISABLE
96328: LD_INT 0
96330: PPUSH
96331: PPUSH
96332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96333: LD_ADDR_VAR 0 3
96337: PUSH
96338: LD_INT 81
96340: PUSH
96341: LD_OWVAR 2
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: PUSH
96350: LD_INT 21
96352: PUSH
96353: LD_INT 1
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PPUSH
96364: CALL_OW 69
96368: ST_TO_ADDR
// if not tmp then
96369: LD_VAR 0 3
96373: NOT
96374: IFFALSE 96378
// exit ;
96376: GO 96525
// if tmp > 5 then
96378: LD_VAR 0 3
96382: PUSH
96383: LD_INT 5
96385: GREATER
96386: IFFALSE 96398
// k := 5 else
96388: LD_ADDR_VAR 0 2
96392: PUSH
96393: LD_INT 5
96395: ST_TO_ADDR
96396: GO 96408
// k := tmp ;
96398: LD_ADDR_VAR 0 2
96402: PUSH
96403: LD_VAR 0 3
96407: ST_TO_ADDR
// for i := 1 to k do
96408: LD_ADDR_VAR 0 1
96412: PUSH
96413: DOUBLE
96414: LD_INT 1
96416: DEC
96417: ST_TO_ADDR
96418: LD_VAR 0 2
96422: PUSH
96423: FOR_TO
96424: IFFALSE 96523
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96426: LD_VAR 0 3
96430: PUSH
96431: LD_VAR 0 1
96435: ARRAY
96436: PPUSH
96437: LD_VAR 0 1
96441: PUSH
96442: LD_INT 4
96444: MOD
96445: PUSH
96446: LD_INT 1
96448: PLUS
96449: PPUSH
96450: CALL_OW 259
96454: PUSH
96455: LD_INT 10
96457: LESS
96458: IFFALSE 96521
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96460: LD_VAR 0 3
96464: PUSH
96465: LD_VAR 0 1
96469: ARRAY
96470: PPUSH
96471: LD_VAR 0 1
96475: PUSH
96476: LD_INT 4
96478: MOD
96479: PUSH
96480: LD_INT 1
96482: PLUS
96483: PPUSH
96484: LD_VAR 0 3
96488: PUSH
96489: LD_VAR 0 1
96493: ARRAY
96494: PPUSH
96495: LD_VAR 0 1
96499: PUSH
96500: LD_INT 4
96502: MOD
96503: PUSH
96504: LD_INT 1
96506: PLUS
96507: PPUSH
96508: CALL_OW 259
96512: PUSH
96513: LD_INT 1
96515: PLUS
96516: PPUSH
96517: CALL_OW 237
96521: GO 96423
96523: POP
96524: POP
// end ;
96525: PPOPN 3
96527: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96528: LD_EXP 137
96532: PUSH
96533: LD_EXP 145
96537: AND
96538: IFFALSE 96558
96540: GO 96542
96542: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96543: LD_INT 4
96545: PPUSH
96546: LD_OWVAR 2
96550: PPUSH
96551: LD_INT 0
96553: PPUSH
96554: CALL_OW 324
96558: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96559: LD_EXP 137
96563: PUSH
96564: LD_EXP 174
96568: AND
96569: IFFALSE 96589
96571: GO 96573
96573: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96574: LD_INT 19
96576: PPUSH
96577: LD_OWVAR 2
96581: PPUSH
96582: LD_INT 0
96584: PPUSH
96585: CALL_OW 324
96589: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96590: LD_EXP 137
96594: PUSH
96595: LD_EXP 146
96599: AND
96600: IFFALSE 96702
96602: GO 96604
96604: DISABLE
96605: LD_INT 0
96607: PPUSH
96608: PPUSH
// begin enable ;
96609: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96610: LD_ADDR_VAR 0 2
96614: PUSH
96615: LD_INT 22
96617: PUSH
96618: LD_OWVAR 2
96622: PUSH
96623: EMPTY
96624: LIST
96625: LIST
96626: PUSH
96627: LD_INT 2
96629: PUSH
96630: LD_INT 34
96632: PUSH
96633: LD_INT 11
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 34
96642: PUSH
96643: LD_INT 30
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: LIST
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: PPUSH
96659: CALL_OW 69
96663: ST_TO_ADDR
// if not tmp then
96664: LD_VAR 0 2
96668: NOT
96669: IFFALSE 96673
// exit ;
96671: GO 96702
// for i in tmp do
96673: LD_ADDR_VAR 0 1
96677: PUSH
96678: LD_VAR 0 2
96682: PUSH
96683: FOR_IN
96684: IFFALSE 96700
// begin SetLives ( i , 0 ) ;
96686: LD_VAR 0 1
96690: PPUSH
96691: LD_INT 0
96693: PPUSH
96694: CALL_OW 234
// end ;
96698: GO 96683
96700: POP
96701: POP
// end ;
96702: PPOPN 2
96704: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96705: LD_EXP 137
96709: PUSH
96710: LD_EXP 147
96714: AND
96715: IFFALSE 96735
96717: GO 96719
96719: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96720: LD_INT 32
96722: PPUSH
96723: LD_OWVAR 2
96727: PPUSH
96728: LD_INT 0
96730: PPUSH
96731: CALL_OW 324
96735: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96736: LD_EXP 137
96740: PUSH
96741: LD_EXP 148
96745: AND
96746: IFFALSE 96927
96748: GO 96750
96750: DISABLE
96751: LD_INT 0
96753: PPUSH
96754: PPUSH
96755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96756: LD_ADDR_VAR 0 2
96760: PUSH
96761: LD_INT 22
96763: PUSH
96764: LD_OWVAR 2
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 33
96775: PUSH
96776: LD_INT 3
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PPUSH
96787: CALL_OW 69
96791: ST_TO_ADDR
// if not tmp then
96792: LD_VAR 0 2
96796: NOT
96797: IFFALSE 96801
// exit ;
96799: GO 96927
// side := 0 ;
96801: LD_ADDR_VAR 0 3
96805: PUSH
96806: LD_INT 0
96808: ST_TO_ADDR
// for i := 1 to 8 do
96809: LD_ADDR_VAR 0 1
96813: PUSH
96814: DOUBLE
96815: LD_INT 1
96817: DEC
96818: ST_TO_ADDR
96819: LD_INT 8
96821: PUSH
96822: FOR_TO
96823: IFFALSE 96871
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96825: LD_OWVAR 2
96829: PUSH
96830: LD_VAR 0 1
96834: NONEQUAL
96835: PUSH
96836: LD_OWVAR 2
96840: PPUSH
96841: LD_VAR 0 1
96845: PPUSH
96846: CALL_OW 81
96850: PUSH
96851: LD_INT 2
96853: EQUAL
96854: AND
96855: IFFALSE 96869
// begin side := i ;
96857: LD_ADDR_VAR 0 3
96861: PUSH
96862: LD_VAR 0 1
96866: ST_TO_ADDR
// break ;
96867: GO 96871
// end ;
96869: GO 96822
96871: POP
96872: POP
// if not side then
96873: LD_VAR 0 3
96877: NOT
96878: IFFALSE 96882
// exit ;
96880: GO 96927
// for i := 1 to tmp do
96882: LD_ADDR_VAR 0 1
96886: PUSH
96887: DOUBLE
96888: LD_INT 1
96890: DEC
96891: ST_TO_ADDR
96892: LD_VAR 0 2
96896: PUSH
96897: FOR_TO
96898: IFFALSE 96925
// if Prob ( 60 ) then
96900: LD_INT 60
96902: PPUSH
96903: CALL_OW 13
96907: IFFALSE 96923
// SetSide ( i , side ) ;
96909: LD_VAR 0 1
96913: PPUSH
96914: LD_VAR 0 3
96918: PPUSH
96919: CALL_OW 235
96923: GO 96897
96925: POP
96926: POP
// end ;
96927: PPOPN 3
96929: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96930: LD_EXP 137
96934: PUSH
96935: LD_EXP 150
96939: AND
96940: IFFALSE 97059
96942: GO 96944
96944: DISABLE
96945: LD_INT 0
96947: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96948: LD_ADDR_VAR 0 1
96952: PUSH
96953: LD_INT 22
96955: PUSH
96956: LD_OWVAR 2
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 21
96967: PUSH
96968: LD_INT 1
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 3
96977: PUSH
96978: LD_INT 23
96980: PUSH
96981: LD_INT 0
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: LIST
96996: PPUSH
96997: CALL_OW 69
97001: PUSH
97002: FOR_IN
97003: IFFALSE 97057
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97005: LD_VAR 0 1
97009: PPUSH
97010: CALL_OW 257
97014: PUSH
97015: LD_INT 1
97017: PUSH
97018: LD_INT 2
97020: PUSH
97021: LD_INT 3
97023: PUSH
97024: LD_INT 4
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: IN
97033: IFFALSE 97055
// SetClass ( un , rand ( 1 , 4 ) ) ;
97035: LD_VAR 0 1
97039: PPUSH
97040: LD_INT 1
97042: PPUSH
97043: LD_INT 4
97045: PPUSH
97046: CALL_OW 12
97050: PPUSH
97051: CALL_OW 336
97055: GO 97002
97057: POP
97058: POP
// end ;
97059: PPOPN 1
97061: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97062: LD_EXP 137
97066: PUSH
97067: LD_EXP 149
97071: AND
97072: IFFALSE 97151
97074: GO 97076
97076: DISABLE
97077: LD_INT 0
97079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97080: LD_ADDR_VAR 0 1
97084: PUSH
97085: LD_INT 22
97087: PUSH
97088: LD_OWVAR 2
97092: PUSH
97093: EMPTY
97094: LIST
97095: LIST
97096: PUSH
97097: LD_INT 21
97099: PUSH
97100: LD_INT 3
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PPUSH
97111: CALL_OW 69
97115: ST_TO_ADDR
// if not tmp then
97116: LD_VAR 0 1
97120: NOT
97121: IFFALSE 97125
// exit ;
97123: GO 97151
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97125: LD_VAR 0 1
97129: PUSH
97130: LD_INT 1
97132: PPUSH
97133: LD_VAR 0 1
97137: PPUSH
97138: CALL_OW 12
97142: ARRAY
97143: PPUSH
97144: LD_INT 100
97146: PPUSH
97147: CALL_OW 234
// end ;
97151: PPOPN 1
97153: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97154: LD_EXP 137
97158: PUSH
97159: LD_EXP 151
97163: AND
97164: IFFALSE 97262
97166: GO 97168
97168: DISABLE
97169: LD_INT 0
97171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97172: LD_ADDR_VAR 0 1
97176: PUSH
97177: LD_INT 22
97179: PUSH
97180: LD_OWVAR 2
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PUSH
97189: LD_INT 21
97191: PUSH
97192: LD_INT 1
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PPUSH
97203: CALL_OW 69
97207: ST_TO_ADDR
// if not tmp then
97208: LD_VAR 0 1
97212: NOT
97213: IFFALSE 97217
// exit ;
97215: GO 97262
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97217: LD_VAR 0 1
97221: PUSH
97222: LD_INT 1
97224: PPUSH
97225: LD_VAR 0 1
97229: PPUSH
97230: CALL_OW 12
97234: ARRAY
97235: PPUSH
97236: LD_INT 1
97238: PPUSH
97239: LD_INT 4
97241: PPUSH
97242: CALL_OW 12
97246: PPUSH
97247: LD_INT 3000
97249: PPUSH
97250: LD_INT 9000
97252: PPUSH
97253: CALL_OW 12
97257: PPUSH
97258: CALL_OW 492
// end ;
97262: PPOPN 1
97264: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97265: LD_EXP 137
97269: PUSH
97270: LD_EXP 152
97274: AND
97275: IFFALSE 97295
97277: GO 97279
97279: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97280: LD_INT 1
97282: PPUSH
97283: LD_OWVAR 2
97287: PPUSH
97288: LD_INT 0
97290: PPUSH
97291: CALL_OW 324
97295: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97296: LD_EXP 137
97300: PUSH
97301: LD_EXP 153
97305: AND
97306: IFFALSE 97389
97308: GO 97310
97310: DISABLE
97311: LD_INT 0
97313: PPUSH
97314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97315: LD_ADDR_VAR 0 2
97319: PUSH
97320: LD_INT 22
97322: PUSH
97323: LD_OWVAR 2
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: PUSH
97332: LD_INT 21
97334: PUSH
97335: LD_INT 3
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PPUSH
97346: CALL_OW 69
97350: ST_TO_ADDR
// if not tmp then
97351: LD_VAR 0 2
97355: NOT
97356: IFFALSE 97360
// exit ;
97358: GO 97389
// for i in tmp do
97360: LD_ADDR_VAR 0 1
97364: PUSH
97365: LD_VAR 0 2
97369: PUSH
97370: FOR_IN
97371: IFFALSE 97387
// SetBLevel ( i , 10 ) ;
97373: LD_VAR 0 1
97377: PPUSH
97378: LD_INT 10
97380: PPUSH
97381: CALL_OW 241
97385: GO 97370
97387: POP
97388: POP
// end ;
97389: PPOPN 2
97391: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97392: LD_EXP 137
97396: PUSH
97397: LD_EXP 154
97401: AND
97402: IFFALSE 97513
97404: GO 97406
97406: DISABLE
97407: LD_INT 0
97409: PPUSH
97410: PPUSH
97411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97412: LD_ADDR_VAR 0 3
97416: PUSH
97417: LD_INT 22
97419: PUSH
97420: LD_OWVAR 2
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: PUSH
97429: LD_INT 25
97431: PUSH
97432: LD_INT 1
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: PPUSH
97443: CALL_OW 69
97447: ST_TO_ADDR
// if not tmp then
97448: LD_VAR 0 3
97452: NOT
97453: IFFALSE 97457
// exit ;
97455: GO 97513
// un := tmp [ rand ( 1 , tmp ) ] ;
97457: LD_ADDR_VAR 0 2
97461: PUSH
97462: LD_VAR 0 3
97466: PUSH
97467: LD_INT 1
97469: PPUSH
97470: LD_VAR 0 3
97474: PPUSH
97475: CALL_OW 12
97479: ARRAY
97480: ST_TO_ADDR
// if Crawls ( un ) then
97481: LD_VAR 0 2
97485: PPUSH
97486: CALL_OW 318
97490: IFFALSE 97501
// ComWalk ( un ) ;
97492: LD_VAR 0 2
97496: PPUSH
97497: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97501: LD_VAR 0 2
97505: PPUSH
97506: LD_INT 5
97508: PPUSH
97509: CALL_OW 336
// end ;
97513: PPOPN 3
97515: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
97516: LD_EXP 137
97520: PUSH
97521: LD_EXP 155
97525: AND
97526: PUSH
97527: LD_OWVAR 67
97531: PUSH
97532: LD_INT 3
97534: LESS
97535: AND
97536: IFFALSE 97555
97538: GO 97540
97540: DISABLE
// Difficulty := Difficulty + 1 ;
97541: LD_ADDR_OWVAR 67
97545: PUSH
97546: LD_OWVAR 67
97550: PUSH
97551: LD_INT 1
97553: PLUS
97554: ST_TO_ADDR
97555: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97556: LD_EXP 137
97560: PUSH
97561: LD_EXP 156
97565: AND
97566: IFFALSE 97669
97568: GO 97570
97570: DISABLE
97571: LD_INT 0
97573: PPUSH
// begin for i := 1 to 5 do
97574: LD_ADDR_VAR 0 1
97578: PUSH
97579: DOUBLE
97580: LD_INT 1
97582: DEC
97583: ST_TO_ADDR
97584: LD_INT 5
97586: PUSH
97587: FOR_TO
97588: IFFALSE 97667
// begin uc_nation := nation_nature ;
97590: LD_ADDR_OWVAR 21
97594: PUSH
97595: LD_INT 0
97597: ST_TO_ADDR
// uc_side := 0 ;
97598: LD_ADDR_OWVAR 20
97602: PUSH
97603: LD_INT 0
97605: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97606: LD_ADDR_OWVAR 29
97610: PUSH
97611: LD_INT 12
97613: PUSH
97614: LD_INT 12
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: ST_TO_ADDR
// hc_agressivity := 20 ;
97621: LD_ADDR_OWVAR 35
97625: PUSH
97626: LD_INT 20
97628: ST_TO_ADDR
// hc_class := class_tiger ;
97629: LD_ADDR_OWVAR 28
97633: PUSH
97634: LD_INT 14
97636: ST_TO_ADDR
// hc_gallery :=  ;
97637: LD_ADDR_OWVAR 33
97641: PUSH
97642: LD_STRING 
97644: ST_TO_ADDR
// hc_name :=  ;
97645: LD_ADDR_OWVAR 26
97649: PUSH
97650: LD_STRING 
97652: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97653: CALL_OW 44
97657: PPUSH
97658: LD_INT 0
97660: PPUSH
97661: CALL_OW 51
// end ;
97665: GO 97587
97667: POP
97668: POP
// end ;
97669: PPOPN 1
97671: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97672: LD_EXP 137
97676: PUSH
97677: LD_EXP 157
97681: AND
97682: IFFALSE 97691
97684: GO 97686
97686: DISABLE
// StreamSibBomb ;
97687: CALL 97692 0 0
97691: END
// export function StreamSibBomb ; var i , x , y ; begin
97692: LD_INT 0
97694: PPUSH
97695: PPUSH
97696: PPUSH
97697: PPUSH
// result := false ;
97698: LD_ADDR_VAR 0 1
97702: PUSH
97703: LD_INT 0
97705: ST_TO_ADDR
// for i := 1 to 16 do
97706: LD_ADDR_VAR 0 2
97710: PUSH
97711: DOUBLE
97712: LD_INT 1
97714: DEC
97715: ST_TO_ADDR
97716: LD_INT 16
97718: PUSH
97719: FOR_TO
97720: IFFALSE 97919
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97722: LD_ADDR_VAR 0 3
97726: PUSH
97727: LD_INT 10
97729: PUSH
97730: LD_INT 20
97732: PUSH
97733: LD_INT 30
97735: PUSH
97736: LD_INT 40
97738: PUSH
97739: LD_INT 50
97741: PUSH
97742: LD_INT 60
97744: PUSH
97745: LD_INT 70
97747: PUSH
97748: LD_INT 80
97750: PUSH
97751: LD_INT 90
97753: PUSH
97754: LD_INT 100
97756: PUSH
97757: LD_INT 110
97759: PUSH
97760: LD_INT 120
97762: PUSH
97763: LD_INT 130
97765: PUSH
97766: LD_INT 140
97768: PUSH
97769: LD_INT 150
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 1
97791: PPUSH
97792: LD_INT 15
97794: PPUSH
97795: CALL_OW 12
97799: ARRAY
97800: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97801: LD_ADDR_VAR 0 4
97805: PUSH
97806: LD_INT 10
97808: PUSH
97809: LD_INT 20
97811: PUSH
97812: LD_INT 30
97814: PUSH
97815: LD_INT 40
97817: PUSH
97818: LD_INT 50
97820: PUSH
97821: LD_INT 60
97823: PUSH
97824: LD_INT 70
97826: PUSH
97827: LD_INT 80
97829: PUSH
97830: LD_INT 90
97832: PUSH
97833: LD_INT 100
97835: PUSH
97836: LD_INT 110
97838: PUSH
97839: LD_INT 120
97841: PUSH
97842: LD_INT 130
97844: PUSH
97845: LD_INT 140
97847: PUSH
97848: LD_INT 150
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: PUSH
97868: LD_INT 1
97870: PPUSH
97871: LD_INT 15
97873: PPUSH
97874: CALL_OW 12
97878: ARRAY
97879: ST_TO_ADDR
// if ValidHex ( x , y ) then
97880: LD_VAR 0 3
97884: PPUSH
97885: LD_VAR 0 4
97889: PPUSH
97890: CALL_OW 488
97894: IFFALSE 97917
// begin result := [ x , y ] ;
97896: LD_ADDR_VAR 0 1
97900: PUSH
97901: LD_VAR 0 3
97905: PUSH
97906: LD_VAR 0 4
97910: PUSH
97911: EMPTY
97912: LIST
97913: LIST
97914: ST_TO_ADDR
// break ;
97915: GO 97919
// end ; end ;
97917: GO 97719
97919: POP
97920: POP
// if result then
97921: LD_VAR 0 1
97925: IFFALSE 97985
// begin ToLua ( playSibBomb() ) ;
97927: LD_STRING playSibBomb()
97929: PPUSH
97930: CALL_OW 559
// wait ( 0 0$14 ) ;
97934: LD_INT 490
97936: PPUSH
97937: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97941: LD_VAR 0 1
97945: PUSH
97946: LD_INT 1
97948: ARRAY
97949: PPUSH
97950: LD_VAR 0 1
97954: PUSH
97955: LD_INT 2
97957: ARRAY
97958: PPUSH
97959: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97963: LD_VAR 0 1
97967: PUSH
97968: LD_INT 1
97970: ARRAY
97971: PPUSH
97972: LD_VAR 0 1
97976: PUSH
97977: LD_INT 2
97979: ARRAY
97980: PPUSH
97981: CALL_OW 429
// end ; end ;
97985: LD_VAR 0 1
97989: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97990: LD_EXP 137
97994: PUSH
97995: LD_EXP 159
97999: AND
98000: IFFALSE 98012
98002: GO 98004
98004: DISABLE
// YouLost (  ) ;
98005: LD_STRING 
98007: PPUSH
98008: CALL_OW 104
98012: END
// every 0 0$1 trigger StreamModeActive and sFog do
98013: LD_EXP 137
98017: PUSH
98018: LD_EXP 158
98022: AND
98023: IFFALSE 98037
98025: GO 98027
98027: DISABLE
// FogOff ( your_side ) ;
98028: LD_OWVAR 2
98032: PPUSH
98033: CALL_OW 344
98037: END
// every 0 0$1 trigger StreamModeActive and sSun do
98038: LD_EXP 137
98042: PUSH
98043: LD_EXP 160
98047: AND
98048: IFFALSE 98076
98050: GO 98052
98052: DISABLE
// begin solar_recharge_percent := 0 ;
98053: LD_ADDR_OWVAR 79
98057: PUSH
98058: LD_INT 0
98060: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98061: LD_INT 10500
98063: PPUSH
98064: CALL_OW 67
// solar_recharge_percent := 100 ;
98068: LD_ADDR_OWVAR 79
98072: PUSH
98073: LD_INT 100
98075: ST_TO_ADDR
// end ;
98076: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98077: LD_EXP 137
98081: PUSH
98082: LD_EXP 161
98086: AND
98087: IFFALSE 98326
98089: GO 98091
98091: DISABLE
98092: LD_INT 0
98094: PPUSH
98095: PPUSH
98096: PPUSH
// begin tmp := [ ] ;
98097: LD_ADDR_VAR 0 3
98101: PUSH
98102: EMPTY
98103: ST_TO_ADDR
// for i := 1 to 6 do
98104: LD_ADDR_VAR 0 1
98108: PUSH
98109: DOUBLE
98110: LD_INT 1
98112: DEC
98113: ST_TO_ADDR
98114: LD_INT 6
98116: PUSH
98117: FOR_TO
98118: IFFALSE 98223
// begin uc_nation := nation_nature ;
98120: LD_ADDR_OWVAR 21
98124: PUSH
98125: LD_INT 0
98127: ST_TO_ADDR
// uc_side := 0 ;
98128: LD_ADDR_OWVAR 20
98132: PUSH
98133: LD_INT 0
98135: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98136: LD_ADDR_OWVAR 29
98140: PUSH
98141: LD_INT 12
98143: PUSH
98144: LD_INT 12
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: ST_TO_ADDR
// hc_agressivity := 20 ;
98151: LD_ADDR_OWVAR 35
98155: PUSH
98156: LD_INT 20
98158: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98159: LD_ADDR_OWVAR 28
98163: PUSH
98164: LD_INT 17
98166: ST_TO_ADDR
// hc_gallery :=  ;
98167: LD_ADDR_OWVAR 33
98171: PUSH
98172: LD_STRING 
98174: ST_TO_ADDR
// hc_name :=  ;
98175: LD_ADDR_OWVAR 26
98179: PUSH
98180: LD_STRING 
98182: ST_TO_ADDR
// un := CreateHuman ;
98183: LD_ADDR_VAR 0 2
98187: PUSH
98188: CALL_OW 44
98192: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98193: LD_VAR 0 2
98197: PPUSH
98198: LD_INT 1
98200: PPUSH
98201: CALL_OW 51
// tmp := tmp ^ un ;
98205: LD_ADDR_VAR 0 3
98209: PUSH
98210: LD_VAR 0 3
98214: PUSH
98215: LD_VAR 0 2
98219: ADD
98220: ST_TO_ADDR
// end ;
98221: GO 98117
98223: POP
98224: POP
// repeat wait ( 0 0$1 ) ;
98225: LD_INT 35
98227: PPUSH
98228: CALL_OW 67
// for un in tmp do
98232: LD_ADDR_VAR 0 2
98236: PUSH
98237: LD_VAR 0 3
98241: PUSH
98242: FOR_IN
98243: IFFALSE 98317
// begin if IsDead ( un ) then
98245: LD_VAR 0 2
98249: PPUSH
98250: CALL_OW 301
98254: IFFALSE 98274
// begin tmp := tmp diff un ;
98256: LD_ADDR_VAR 0 3
98260: PUSH
98261: LD_VAR 0 3
98265: PUSH
98266: LD_VAR 0 2
98270: DIFF
98271: ST_TO_ADDR
// continue ;
98272: GO 98242
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98274: LD_VAR 0 2
98278: PPUSH
98279: LD_INT 3
98281: PUSH
98282: LD_INT 22
98284: PUSH
98285: LD_INT 0
98287: PUSH
98288: EMPTY
98289: LIST
98290: LIST
98291: PUSH
98292: EMPTY
98293: LIST
98294: LIST
98295: PPUSH
98296: CALL_OW 69
98300: PPUSH
98301: LD_VAR 0 2
98305: PPUSH
98306: CALL_OW 74
98310: PPUSH
98311: CALL_OW 115
// end ;
98315: GO 98242
98317: POP
98318: POP
// until not tmp ;
98319: LD_VAR 0 3
98323: NOT
98324: IFFALSE 98225
// end ;
98326: PPOPN 3
98328: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98329: LD_EXP 137
98333: PUSH
98334: LD_EXP 162
98338: AND
98339: IFFALSE 98393
98341: GO 98343
98343: DISABLE
// begin ToLua ( displayTroll(); ) ;
98344: LD_STRING displayTroll();
98346: PPUSH
98347: CALL_OW 559
// wait ( 3 3$00 ) ;
98351: LD_INT 6300
98353: PPUSH
98354: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98358: LD_STRING hideTroll();
98360: PPUSH
98361: CALL_OW 559
// wait ( 1 1$00 ) ;
98365: LD_INT 2100
98367: PPUSH
98368: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98372: LD_STRING displayTroll();
98374: PPUSH
98375: CALL_OW 559
// wait ( 1 1$00 ) ;
98379: LD_INT 2100
98381: PPUSH
98382: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98386: LD_STRING hideTroll();
98388: PPUSH
98389: CALL_OW 559
// end ;
98393: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98394: LD_EXP 137
98398: PUSH
98399: LD_EXP 163
98403: AND
98404: IFFALSE 98467
98406: GO 98408
98408: DISABLE
98409: LD_INT 0
98411: PPUSH
// begin p := 0 ;
98412: LD_ADDR_VAR 0 1
98416: PUSH
98417: LD_INT 0
98419: ST_TO_ADDR
// repeat game_speed := 1 ;
98420: LD_ADDR_OWVAR 65
98424: PUSH
98425: LD_INT 1
98427: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98428: LD_INT 35
98430: PPUSH
98431: CALL_OW 67
// p := p + 1 ;
98435: LD_ADDR_VAR 0 1
98439: PUSH
98440: LD_VAR 0 1
98444: PUSH
98445: LD_INT 1
98447: PLUS
98448: ST_TO_ADDR
// until p >= 60 ;
98449: LD_VAR 0 1
98453: PUSH
98454: LD_INT 60
98456: GREATEREQUAL
98457: IFFALSE 98420
// game_speed := 4 ;
98459: LD_ADDR_OWVAR 65
98463: PUSH
98464: LD_INT 4
98466: ST_TO_ADDR
// end ;
98467: PPOPN 1
98469: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98470: LD_EXP 137
98474: PUSH
98475: LD_EXP 164
98479: AND
98480: IFFALSE 98626
98482: GO 98484
98484: DISABLE
98485: LD_INT 0
98487: PPUSH
98488: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98489: LD_ADDR_VAR 0 1
98493: PUSH
98494: LD_INT 22
98496: PUSH
98497: LD_OWVAR 2
98501: PUSH
98502: EMPTY
98503: LIST
98504: LIST
98505: PUSH
98506: LD_INT 2
98508: PUSH
98509: LD_INT 30
98511: PUSH
98512: LD_INT 0
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 30
98521: PUSH
98522: LD_INT 1
98524: PUSH
98525: EMPTY
98526: LIST
98527: LIST
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: LIST
98533: PUSH
98534: EMPTY
98535: LIST
98536: LIST
98537: PPUSH
98538: CALL_OW 69
98542: ST_TO_ADDR
// if not depot then
98543: LD_VAR 0 1
98547: NOT
98548: IFFALSE 98552
// exit ;
98550: GO 98626
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98552: LD_ADDR_VAR 0 2
98556: PUSH
98557: LD_VAR 0 1
98561: PUSH
98562: LD_INT 1
98564: PPUSH
98565: LD_VAR 0 1
98569: PPUSH
98570: CALL_OW 12
98574: ARRAY
98575: PPUSH
98576: CALL_OW 274
98580: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98581: LD_VAR 0 2
98585: PPUSH
98586: LD_INT 1
98588: PPUSH
98589: LD_INT 0
98591: PPUSH
98592: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98596: LD_VAR 0 2
98600: PPUSH
98601: LD_INT 2
98603: PPUSH
98604: LD_INT 0
98606: PPUSH
98607: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98611: LD_VAR 0 2
98615: PPUSH
98616: LD_INT 3
98618: PPUSH
98619: LD_INT 0
98621: PPUSH
98622: CALL_OW 277
// end ;
98626: PPOPN 2
98628: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98629: LD_EXP 137
98633: PUSH
98634: LD_EXP 165
98638: AND
98639: IFFALSE 98736
98641: GO 98643
98643: DISABLE
98644: LD_INT 0
98646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98647: LD_ADDR_VAR 0 1
98651: PUSH
98652: LD_INT 22
98654: PUSH
98655: LD_OWVAR 2
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 21
98666: PUSH
98667: LD_INT 1
98669: PUSH
98670: EMPTY
98671: LIST
98672: LIST
98673: PUSH
98674: LD_INT 3
98676: PUSH
98677: LD_INT 23
98679: PUSH
98680: LD_INT 0
98682: PUSH
98683: EMPTY
98684: LIST
98685: LIST
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: PUSH
98691: EMPTY
98692: LIST
98693: LIST
98694: LIST
98695: PPUSH
98696: CALL_OW 69
98700: ST_TO_ADDR
// if not tmp then
98701: LD_VAR 0 1
98705: NOT
98706: IFFALSE 98710
// exit ;
98708: GO 98736
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98710: LD_VAR 0 1
98714: PUSH
98715: LD_INT 1
98717: PPUSH
98718: LD_VAR 0 1
98722: PPUSH
98723: CALL_OW 12
98727: ARRAY
98728: PPUSH
98729: LD_INT 200
98731: PPUSH
98732: CALL_OW 234
// end ;
98736: PPOPN 1
98738: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98739: LD_EXP 137
98743: PUSH
98744: LD_EXP 166
98748: AND
98749: IFFALSE 98828
98751: GO 98753
98753: DISABLE
98754: LD_INT 0
98756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98757: LD_ADDR_VAR 0 1
98761: PUSH
98762: LD_INT 22
98764: PUSH
98765: LD_OWVAR 2
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PUSH
98774: LD_INT 21
98776: PUSH
98777: LD_INT 2
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PPUSH
98788: CALL_OW 69
98792: ST_TO_ADDR
// if not tmp then
98793: LD_VAR 0 1
98797: NOT
98798: IFFALSE 98802
// exit ;
98800: GO 98828
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98802: LD_VAR 0 1
98806: PUSH
98807: LD_INT 1
98809: PPUSH
98810: LD_VAR 0 1
98814: PPUSH
98815: CALL_OW 12
98819: ARRAY
98820: PPUSH
98821: LD_INT 60
98823: PPUSH
98824: CALL_OW 234
// end ;
98828: PPOPN 1
98830: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98831: LD_EXP 137
98835: PUSH
98836: LD_EXP 167
98840: AND
98841: IFFALSE 98940
98843: GO 98845
98845: DISABLE
98846: LD_INT 0
98848: PPUSH
98849: PPUSH
// begin enable ;
98850: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98851: LD_ADDR_VAR 0 1
98855: PUSH
98856: LD_INT 22
98858: PUSH
98859: LD_OWVAR 2
98863: PUSH
98864: EMPTY
98865: LIST
98866: LIST
98867: PUSH
98868: LD_INT 61
98870: PUSH
98871: EMPTY
98872: LIST
98873: PUSH
98874: LD_INT 33
98876: PUSH
98877: LD_INT 2
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: PUSH
98884: EMPTY
98885: LIST
98886: LIST
98887: LIST
98888: PPUSH
98889: CALL_OW 69
98893: ST_TO_ADDR
// if not tmp then
98894: LD_VAR 0 1
98898: NOT
98899: IFFALSE 98903
// exit ;
98901: GO 98940
// for i in tmp do
98903: LD_ADDR_VAR 0 2
98907: PUSH
98908: LD_VAR 0 1
98912: PUSH
98913: FOR_IN
98914: IFFALSE 98938
// if IsControledBy ( i ) then
98916: LD_VAR 0 2
98920: PPUSH
98921: CALL_OW 312
98925: IFFALSE 98936
// ComUnlink ( i ) ;
98927: LD_VAR 0 2
98931: PPUSH
98932: CALL_OW 136
98936: GO 98913
98938: POP
98939: POP
// end ;
98940: PPOPN 2
98942: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98943: LD_EXP 137
98947: PUSH
98948: LD_EXP 168
98952: AND
98953: IFFALSE 99093
98955: GO 98957
98957: DISABLE
98958: LD_INT 0
98960: PPUSH
98961: PPUSH
// begin ToLua ( displayPowell(); ) ;
98962: LD_STRING displayPowell();
98964: PPUSH
98965: CALL_OW 559
// uc_side := 0 ;
98969: LD_ADDR_OWVAR 20
98973: PUSH
98974: LD_INT 0
98976: ST_TO_ADDR
// uc_nation := 2 ;
98977: LD_ADDR_OWVAR 21
98981: PUSH
98982: LD_INT 2
98984: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98985: LD_ADDR_OWVAR 37
98989: PUSH
98990: LD_INT 14
98992: ST_TO_ADDR
// vc_engine := engine_siberite ;
98993: LD_ADDR_OWVAR 39
98997: PUSH
98998: LD_INT 3
99000: ST_TO_ADDR
// vc_control := control_apeman ;
99001: LD_ADDR_OWVAR 38
99005: PUSH
99006: LD_INT 5
99008: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99009: LD_ADDR_OWVAR 40
99013: PUSH
99014: LD_INT 29
99016: ST_TO_ADDR
// un := CreateVehicle ;
99017: LD_ADDR_VAR 0 2
99021: PUSH
99022: CALL_OW 45
99026: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99027: LD_VAR 0 2
99031: PPUSH
99032: LD_INT 1
99034: PPUSH
99035: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99039: LD_INT 35
99041: PPUSH
99042: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99046: LD_VAR 0 2
99050: PPUSH
99051: LD_INT 22
99053: PUSH
99054: LD_OWVAR 2
99058: PUSH
99059: EMPTY
99060: LIST
99061: LIST
99062: PPUSH
99063: CALL_OW 69
99067: PPUSH
99068: LD_VAR 0 2
99072: PPUSH
99073: CALL_OW 74
99077: PPUSH
99078: CALL_OW 115
// until IsDead ( un ) ;
99082: LD_VAR 0 2
99086: PPUSH
99087: CALL_OW 301
99091: IFFALSE 99039
// end ;
99093: PPOPN 2
99095: END
// every 0 0$1 trigger StreamModeActive and sStu do
99096: LD_EXP 137
99100: PUSH
99101: LD_EXP 176
99105: AND
99106: IFFALSE 99122
99108: GO 99110
99110: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99111: LD_STRING displayStucuk();
99113: PPUSH
99114: CALL_OW 559
// ResetFog ;
99118: CALL_OW 335
// end ;
99122: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99123: LD_EXP 137
99127: PUSH
99128: LD_EXP 169
99132: AND
99133: IFFALSE 99274
99135: GO 99137
99137: DISABLE
99138: LD_INT 0
99140: PPUSH
99141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99142: LD_ADDR_VAR 0 2
99146: PUSH
99147: LD_INT 22
99149: PUSH
99150: LD_OWVAR 2
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: LD_INT 21
99161: PUSH
99162: LD_INT 1
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PPUSH
99173: CALL_OW 69
99177: ST_TO_ADDR
// if not tmp then
99178: LD_VAR 0 2
99182: NOT
99183: IFFALSE 99187
// exit ;
99185: GO 99274
// un := tmp [ rand ( 1 , tmp ) ] ;
99187: LD_ADDR_VAR 0 1
99191: PUSH
99192: LD_VAR 0 2
99196: PUSH
99197: LD_INT 1
99199: PPUSH
99200: LD_VAR 0 2
99204: PPUSH
99205: CALL_OW 12
99209: ARRAY
99210: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99211: LD_VAR 0 1
99215: PPUSH
99216: LD_INT 0
99218: PPUSH
99219: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99223: LD_VAR 0 1
99227: PPUSH
99228: LD_OWVAR 3
99232: PUSH
99233: LD_VAR 0 1
99237: DIFF
99238: PPUSH
99239: LD_VAR 0 1
99243: PPUSH
99244: CALL_OW 74
99248: PPUSH
99249: CALL_OW 115
// wait ( 0 0$20 ) ;
99253: LD_INT 700
99255: PPUSH
99256: CALL_OW 67
// SetSide ( un , your_side ) ;
99260: LD_VAR 0 1
99264: PPUSH
99265: LD_OWVAR 2
99269: PPUSH
99270: CALL_OW 235
// end ;
99274: PPOPN 2
99276: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99277: LD_EXP 137
99281: PUSH
99282: LD_EXP 170
99286: AND
99287: IFFALSE 99393
99289: GO 99291
99291: DISABLE
99292: LD_INT 0
99294: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99295: LD_ADDR_VAR 0 1
99299: PUSH
99300: LD_INT 22
99302: PUSH
99303: LD_OWVAR 2
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 2
99314: PUSH
99315: LD_INT 30
99317: PUSH
99318: LD_INT 0
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: LD_INT 30
99327: PUSH
99328: LD_INT 1
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PUSH
99335: EMPTY
99336: LIST
99337: LIST
99338: LIST
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PPUSH
99344: CALL_OW 69
99348: ST_TO_ADDR
// if not depot then
99349: LD_VAR 0 1
99353: NOT
99354: IFFALSE 99358
// exit ;
99356: GO 99393
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99358: LD_VAR 0 1
99362: PUSH
99363: LD_INT 1
99365: ARRAY
99366: PPUSH
99367: CALL_OW 250
99371: PPUSH
99372: LD_VAR 0 1
99376: PUSH
99377: LD_INT 1
99379: ARRAY
99380: PPUSH
99381: CALL_OW 251
99385: PPUSH
99386: LD_INT 70
99388: PPUSH
99389: CALL_OW 495
// end ;
99393: PPOPN 1
99395: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99396: LD_EXP 137
99400: PUSH
99401: LD_EXP 171
99405: AND
99406: IFFALSE 99617
99408: GO 99410
99410: DISABLE
99411: LD_INT 0
99413: PPUSH
99414: PPUSH
99415: PPUSH
99416: PPUSH
99417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99418: LD_ADDR_VAR 0 5
99422: PUSH
99423: LD_INT 22
99425: PUSH
99426: LD_OWVAR 2
99430: PUSH
99431: EMPTY
99432: LIST
99433: LIST
99434: PUSH
99435: LD_INT 21
99437: PUSH
99438: LD_INT 1
99440: PUSH
99441: EMPTY
99442: LIST
99443: LIST
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: PPUSH
99449: CALL_OW 69
99453: ST_TO_ADDR
// if not tmp then
99454: LD_VAR 0 5
99458: NOT
99459: IFFALSE 99463
// exit ;
99461: GO 99617
// for i in tmp do
99463: LD_ADDR_VAR 0 1
99467: PUSH
99468: LD_VAR 0 5
99472: PUSH
99473: FOR_IN
99474: IFFALSE 99615
// begin d := rand ( 0 , 5 ) ;
99476: LD_ADDR_VAR 0 4
99480: PUSH
99481: LD_INT 0
99483: PPUSH
99484: LD_INT 5
99486: PPUSH
99487: CALL_OW 12
99491: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99492: LD_ADDR_VAR 0 2
99496: PUSH
99497: LD_VAR 0 1
99501: PPUSH
99502: CALL_OW 250
99506: PPUSH
99507: LD_VAR 0 4
99511: PPUSH
99512: LD_INT 3
99514: PPUSH
99515: LD_INT 12
99517: PPUSH
99518: CALL_OW 12
99522: PPUSH
99523: CALL_OW 272
99527: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99528: LD_ADDR_VAR 0 3
99532: PUSH
99533: LD_VAR 0 1
99537: PPUSH
99538: CALL_OW 251
99542: PPUSH
99543: LD_VAR 0 4
99547: PPUSH
99548: LD_INT 3
99550: PPUSH
99551: LD_INT 12
99553: PPUSH
99554: CALL_OW 12
99558: PPUSH
99559: CALL_OW 273
99563: ST_TO_ADDR
// if ValidHex ( x , y ) then
99564: LD_VAR 0 2
99568: PPUSH
99569: LD_VAR 0 3
99573: PPUSH
99574: CALL_OW 488
99578: IFFALSE 99613
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99580: LD_VAR 0 1
99584: PPUSH
99585: LD_VAR 0 2
99589: PPUSH
99590: LD_VAR 0 3
99594: PPUSH
99595: LD_INT 3
99597: PPUSH
99598: LD_INT 6
99600: PPUSH
99601: CALL_OW 12
99605: PPUSH
99606: LD_INT 1
99608: PPUSH
99609: CALL_OW 483
// end ;
99613: GO 99473
99615: POP
99616: POP
// end ;
99617: PPOPN 5
99619: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99620: LD_EXP 137
99624: PUSH
99625: LD_EXP 172
99629: AND
99630: IFFALSE 99724
99632: GO 99634
99634: DISABLE
99635: LD_INT 0
99637: PPUSH
99638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99639: LD_ADDR_VAR 0 2
99643: PUSH
99644: LD_INT 22
99646: PUSH
99647: LD_OWVAR 2
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PUSH
99656: LD_INT 32
99658: PUSH
99659: LD_INT 1
99661: PUSH
99662: EMPTY
99663: LIST
99664: LIST
99665: PUSH
99666: LD_INT 21
99668: PUSH
99669: LD_INT 2
99671: PUSH
99672: EMPTY
99673: LIST
99674: LIST
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: LIST
99680: PPUSH
99681: CALL_OW 69
99685: ST_TO_ADDR
// if not tmp then
99686: LD_VAR 0 2
99690: NOT
99691: IFFALSE 99695
// exit ;
99693: GO 99724
// for i in tmp do
99695: LD_ADDR_VAR 0 1
99699: PUSH
99700: LD_VAR 0 2
99704: PUSH
99705: FOR_IN
99706: IFFALSE 99722
// SetFuel ( i , 0 ) ;
99708: LD_VAR 0 1
99712: PPUSH
99713: LD_INT 0
99715: PPUSH
99716: CALL_OW 240
99720: GO 99705
99722: POP
99723: POP
// end ;
99724: PPOPN 2
99726: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99727: LD_EXP 137
99731: PUSH
99732: LD_EXP 173
99736: AND
99737: IFFALSE 99803
99739: GO 99741
99741: DISABLE
99742: LD_INT 0
99744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99745: LD_ADDR_VAR 0 1
99749: PUSH
99750: LD_INT 22
99752: PUSH
99753: LD_OWVAR 2
99757: PUSH
99758: EMPTY
99759: LIST
99760: LIST
99761: PUSH
99762: LD_INT 30
99764: PUSH
99765: LD_INT 29
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: PUSH
99772: EMPTY
99773: LIST
99774: LIST
99775: PPUSH
99776: CALL_OW 69
99780: ST_TO_ADDR
// if not tmp then
99781: LD_VAR 0 1
99785: NOT
99786: IFFALSE 99790
// exit ;
99788: GO 99803
// DestroyUnit ( tmp [ 1 ] ) ;
99790: LD_VAR 0 1
99794: PUSH
99795: LD_INT 1
99797: ARRAY
99798: PPUSH
99799: CALL_OW 65
// end ;
99803: PPOPN 1
99805: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99806: LD_EXP 137
99810: PUSH
99811: LD_EXP 175
99815: AND
99816: IFFALSE 99945
99818: GO 99820
99820: DISABLE
99821: LD_INT 0
99823: PPUSH
// begin uc_side := 0 ;
99824: LD_ADDR_OWVAR 20
99828: PUSH
99829: LD_INT 0
99831: ST_TO_ADDR
// uc_nation := nation_arabian ;
99832: LD_ADDR_OWVAR 21
99836: PUSH
99837: LD_INT 2
99839: ST_TO_ADDR
// hc_gallery :=  ;
99840: LD_ADDR_OWVAR 33
99844: PUSH
99845: LD_STRING 
99847: ST_TO_ADDR
// hc_name :=  ;
99848: LD_ADDR_OWVAR 26
99852: PUSH
99853: LD_STRING 
99855: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99856: LD_INT 1
99858: PPUSH
99859: LD_INT 11
99861: PPUSH
99862: LD_INT 10
99864: PPUSH
99865: CALL_OW 380
// un := CreateHuman ;
99869: LD_ADDR_VAR 0 1
99873: PUSH
99874: CALL_OW 44
99878: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99879: LD_VAR 0 1
99883: PPUSH
99884: LD_INT 1
99886: PPUSH
99887: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99891: LD_INT 35
99893: PPUSH
99894: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99898: LD_VAR 0 1
99902: PPUSH
99903: LD_INT 22
99905: PUSH
99906: LD_OWVAR 2
99910: PUSH
99911: EMPTY
99912: LIST
99913: LIST
99914: PPUSH
99915: CALL_OW 69
99919: PPUSH
99920: LD_VAR 0 1
99924: PPUSH
99925: CALL_OW 74
99929: PPUSH
99930: CALL_OW 115
// until IsDead ( un ) ;
99934: LD_VAR 0 1
99938: PPUSH
99939: CALL_OW 301
99943: IFFALSE 99891
// end ;
99945: PPOPN 1
99947: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99948: LD_EXP 137
99952: PUSH
99953: LD_EXP 177
99957: AND
99958: IFFALSE 99970
99960: GO 99962
99962: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99963: LD_STRING earthquake(getX(game), 0, 32)
99965: PPUSH
99966: CALL_OW 559
99970: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99971: LD_EXP 137
99975: PUSH
99976: LD_EXP 178
99980: AND
99981: IFFALSE 100072
99983: GO 99985
99985: DISABLE
99986: LD_INT 0
99988: PPUSH
// begin enable ;
99989: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99990: LD_ADDR_VAR 0 1
99994: PUSH
99995: LD_INT 22
99997: PUSH
99998: LD_OWVAR 2
100002: PUSH
100003: EMPTY
100004: LIST
100005: LIST
100006: PUSH
100007: LD_INT 21
100009: PUSH
100010: LD_INT 2
100012: PUSH
100013: EMPTY
100014: LIST
100015: LIST
100016: PUSH
100017: LD_INT 33
100019: PUSH
100020: LD_INT 3
100022: PUSH
100023: EMPTY
100024: LIST
100025: LIST
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: LIST
100031: PPUSH
100032: CALL_OW 69
100036: ST_TO_ADDR
// if not tmp then
100037: LD_VAR 0 1
100041: NOT
100042: IFFALSE 100046
// exit ;
100044: GO 100072
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100046: LD_VAR 0 1
100050: PUSH
100051: LD_INT 1
100053: PPUSH
100054: LD_VAR 0 1
100058: PPUSH
100059: CALL_OW 12
100063: ARRAY
100064: PPUSH
100065: LD_INT 1
100067: PPUSH
100068: CALL_OW 234
// end ;
100072: PPOPN 1
100074: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100075: LD_EXP 137
100079: PUSH
100080: LD_EXP 179
100084: AND
100085: IFFALSE 100226
100087: GO 100089
100089: DISABLE
100090: LD_INT 0
100092: PPUSH
100093: PPUSH
100094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100095: LD_ADDR_VAR 0 3
100099: PUSH
100100: LD_INT 22
100102: PUSH
100103: LD_OWVAR 2
100107: PUSH
100108: EMPTY
100109: LIST
100110: LIST
100111: PUSH
100112: LD_INT 25
100114: PUSH
100115: LD_INT 1
100117: PUSH
100118: EMPTY
100119: LIST
100120: LIST
100121: PUSH
100122: EMPTY
100123: LIST
100124: LIST
100125: PPUSH
100126: CALL_OW 69
100130: ST_TO_ADDR
// if not tmp then
100131: LD_VAR 0 3
100135: NOT
100136: IFFALSE 100140
// exit ;
100138: GO 100226
// un := tmp [ rand ( 1 , tmp ) ] ;
100140: LD_ADDR_VAR 0 2
100144: PUSH
100145: LD_VAR 0 3
100149: PUSH
100150: LD_INT 1
100152: PPUSH
100153: LD_VAR 0 3
100157: PPUSH
100158: CALL_OW 12
100162: ARRAY
100163: ST_TO_ADDR
// if Crawls ( un ) then
100164: LD_VAR 0 2
100168: PPUSH
100169: CALL_OW 318
100173: IFFALSE 100184
// ComWalk ( un ) ;
100175: LD_VAR 0 2
100179: PPUSH
100180: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100184: LD_VAR 0 2
100188: PPUSH
100189: LD_INT 9
100191: PPUSH
100192: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100196: LD_INT 28
100198: PPUSH
100199: LD_OWVAR 2
100203: PPUSH
100204: LD_INT 2
100206: PPUSH
100207: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100211: LD_INT 29
100213: PPUSH
100214: LD_OWVAR 2
100218: PPUSH
100219: LD_INT 2
100221: PPUSH
100222: CALL_OW 322
// end ;
100226: PPOPN 3
100228: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100229: LD_EXP 137
100233: PUSH
100234: LD_EXP 180
100238: AND
100239: IFFALSE 100350
100241: GO 100243
100243: DISABLE
100244: LD_INT 0
100246: PPUSH
100247: PPUSH
100248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100249: LD_ADDR_VAR 0 3
100253: PUSH
100254: LD_INT 22
100256: PUSH
100257: LD_OWVAR 2
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: PUSH
100266: LD_INT 25
100268: PUSH
100269: LD_INT 1
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: PUSH
100276: EMPTY
100277: LIST
100278: LIST
100279: PPUSH
100280: CALL_OW 69
100284: ST_TO_ADDR
// if not tmp then
100285: LD_VAR 0 3
100289: NOT
100290: IFFALSE 100294
// exit ;
100292: GO 100350
// un := tmp [ rand ( 1 , tmp ) ] ;
100294: LD_ADDR_VAR 0 2
100298: PUSH
100299: LD_VAR 0 3
100303: PUSH
100304: LD_INT 1
100306: PPUSH
100307: LD_VAR 0 3
100311: PPUSH
100312: CALL_OW 12
100316: ARRAY
100317: ST_TO_ADDR
// if Crawls ( un ) then
100318: LD_VAR 0 2
100322: PPUSH
100323: CALL_OW 318
100327: IFFALSE 100338
// ComWalk ( un ) ;
100329: LD_VAR 0 2
100333: PPUSH
100334: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100338: LD_VAR 0 2
100342: PPUSH
100343: LD_INT 8
100345: PPUSH
100346: CALL_OW 336
// end ;
100350: PPOPN 3
100352: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100353: LD_EXP 137
100357: PUSH
100358: LD_EXP 181
100362: AND
100363: IFFALSE 100507
100365: GO 100367
100367: DISABLE
100368: LD_INT 0
100370: PPUSH
100371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100372: LD_ADDR_VAR 0 2
100376: PUSH
100377: LD_INT 22
100379: PUSH
100380: LD_OWVAR 2
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 21
100391: PUSH
100392: LD_INT 2
100394: PUSH
100395: EMPTY
100396: LIST
100397: LIST
100398: PUSH
100399: LD_INT 2
100401: PUSH
100402: LD_INT 34
100404: PUSH
100405: LD_INT 12
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: PUSH
100412: LD_INT 34
100414: PUSH
100415: LD_INT 51
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: PUSH
100422: LD_INT 34
100424: PUSH
100425: LD_INT 32
100427: PUSH
100428: EMPTY
100429: LIST
100430: LIST
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: PUSH
100438: EMPTY
100439: LIST
100440: LIST
100441: LIST
100442: PPUSH
100443: CALL_OW 69
100447: ST_TO_ADDR
// if not tmp then
100448: LD_VAR 0 2
100452: NOT
100453: IFFALSE 100457
// exit ;
100455: GO 100507
// for i in tmp do
100457: LD_ADDR_VAR 0 1
100461: PUSH
100462: LD_VAR 0 2
100466: PUSH
100467: FOR_IN
100468: IFFALSE 100505
// if GetCargo ( i , mat_artifact ) = 0 then
100470: LD_VAR 0 1
100474: PPUSH
100475: LD_INT 4
100477: PPUSH
100478: CALL_OW 289
100482: PUSH
100483: LD_INT 0
100485: EQUAL
100486: IFFALSE 100503
// SetCargo ( i , mat_siberit , 100 ) ;
100488: LD_VAR 0 1
100492: PPUSH
100493: LD_INT 3
100495: PPUSH
100496: LD_INT 100
100498: PPUSH
100499: CALL_OW 290
100503: GO 100467
100505: POP
100506: POP
// end ;
100507: PPOPN 2
100509: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100510: LD_EXP 137
100514: PUSH
100515: LD_EXP 182
100519: AND
100520: IFFALSE 100703
100522: GO 100524
100524: DISABLE
100525: LD_INT 0
100527: PPUSH
100528: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100529: LD_ADDR_VAR 0 2
100533: PUSH
100534: LD_INT 22
100536: PUSH
100537: LD_OWVAR 2
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: PPUSH
100546: CALL_OW 69
100550: ST_TO_ADDR
// if not tmp then
100551: LD_VAR 0 2
100555: NOT
100556: IFFALSE 100560
// exit ;
100558: GO 100703
// for i := 1 to 2 do
100560: LD_ADDR_VAR 0 1
100564: PUSH
100565: DOUBLE
100566: LD_INT 1
100568: DEC
100569: ST_TO_ADDR
100570: LD_INT 2
100572: PUSH
100573: FOR_TO
100574: IFFALSE 100701
// begin uc_side := your_side ;
100576: LD_ADDR_OWVAR 20
100580: PUSH
100581: LD_OWVAR 2
100585: ST_TO_ADDR
// uc_nation := nation_american ;
100586: LD_ADDR_OWVAR 21
100590: PUSH
100591: LD_INT 1
100593: ST_TO_ADDR
// vc_chassis := us_morphling ;
100594: LD_ADDR_OWVAR 37
100598: PUSH
100599: LD_INT 5
100601: ST_TO_ADDR
// vc_engine := engine_siberite ;
100602: LD_ADDR_OWVAR 39
100606: PUSH
100607: LD_INT 3
100609: ST_TO_ADDR
// vc_control := control_computer ;
100610: LD_ADDR_OWVAR 38
100614: PUSH
100615: LD_INT 3
100617: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100618: LD_ADDR_OWVAR 40
100622: PUSH
100623: LD_INT 10
100625: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100626: LD_VAR 0 2
100630: PUSH
100631: LD_INT 1
100633: ARRAY
100634: PPUSH
100635: CALL_OW 310
100639: NOT
100640: IFFALSE 100687
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100642: CALL_OW 45
100646: PPUSH
100647: LD_VAR 0 2
100651: PUSH
100652: LD_INT 1
100654: ARRAY
100655: PPUSH
100656: CALL_OW 250
100660: PPUSH
100661: LD_VAR 0 2
100665: PUSH
100666: LD_INT 1
100668: ARRAY
100669: PPUSH
100670: CALL_OW 251
100674: PPUSH
100675: LD_INT 12
100677: PPUSH
100678: LD_INT 1
100680: PPUSH
100681: CALL_OW 50
100685: GO 100699
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100687: CALL_OW 45
100691: PPUSH
100692: LD_INT 1
100694: PPUSH
100695: CALL_OW 51
// end ;
100699: GO 100573
100701: POP
100702: POP
// end ;
100703: PPOPN 2
100705: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100706: LD_EXP 137
100710: PUSH
100711: LD_EXP 183
100715: AND
100716: IFFALSE 100938
100718: GO 100720
100720: DISABLE
100721: LD_INT 0
100723: PPUSH
100724: PPUSH
100725: PPUSH
100726: PPUSH
100727: PPUSH
100728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100729: LD_ADDR_VAR 0 6
100733: PUSH
100734: LD_INT 22
100736: PUSH
100737: LD_OWVAR 2
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: PUSH
100746: LD_INT 21
100748: PUSH
100749: LD_INT 1
100751: PUSH
100752: EMPTY
100753: LIST
100754: LIST
100755: PUSH
100756: LD_INT 3
100758: PUSH
100759: LD_INT 23
100761: PUSH
100762: LD_INT 0
100764: PUSH
100765: EMPTY
100766: LIST
100767: LIST
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: LIST
100777: PPUSH
100778: CALL_OW 69
100782: ST_TO_ADDR
// if not tmp then
100783: LD_VAR 0 6
100787: NOT
100788: IFFALSE 100792
// exit ;
100790: GO 100938
// s1 := rand ( 1 , 4 ) ;
100792: LD_ADDR_VAR 0 2
100796: PUSH
100797: LD_INT 1
100799: PPUSH
100800: LD_INT 4
100802: PPUSH
100803: CALL_OW 12
100807: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100808: LD_ADDR_VAR 0 4
100812: PUSH
100813: LD_VAR 0 6
100817: PUSH
100818: LD_INT 1
100820: ARRAY
100821: PPUSH
100822: LD_VAR 0 2
100826: PPUSH
100827: CALL_OW 259
100831: ST_TO_ADDR
// if s1 = 1 then
100832: LD_VAR 0 2
100836: PUSH
100837: LD_INT 1
100839: EQUAL
100840: IFFALSE 100860
// s2 := rand ( 2 , 4 ) else
100842: LD_ADDR_VAR 0 3
100846: PUSH
100847: LD_INT 2
100849: PPUSH
100850: LD_INT 4
100852: PPUSH
100853: CALL_OW 12
100857: ST_TO_ADDR
100858: GO 100868
// s2 := 1 ;
100860: LD_ADDR_VAR 0 3
100864: PUSH
100865: LD_INT 1
100867: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100868: LD_ADDR_VAR 0 5
100872: PUSH
100873: LD_VAR 0 6
100877: PUSH
100878: LD_INT 1
100880: ARRAY
100881: PPUSH
100882: LD_VAR 0 3
100886: PPUSH
100887: CALL_OW 259
100891: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100892: LD_VAR 0 6
100896: PUSH
100897: LD_INT 1
100899: ARRAY
100900: PPUSH
100901: LD_VAR 0 2
100905: PPUSH
100906: LD_VAR 0 5
100910: PPUSH
100911: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100915: LD_VAR 0 6
100919: PUSH
100920: LD_INT 1
100922: ARRAY
100923: PPUSH
100924: LD_VAR 0 3
100928: PPUSH
100929: LD_VAR 0 4
100933: PPUSH
100934: CALL_OW 237
// end ;
100938: PPOPN 6
100940: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100941: LD_EXP 137
100945: PUSH
100946: LD_EXP 184
100950: AND
100951: IFFALSE 101030
100953: GO 100955
100955: DISABLE
100956: LD_INT 0
100958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100959: LD_ADDR_VAR 0 1
100963: PUSH
100964: LD_INT 22
100966: PUSH
100967: LD_OWVAR 2
100971: PUSH
100972: EMPTY
100973: LIST
100974: LIST
100975: PUSH
100976: LD_INT 30
100978: PUSH
100979: LD_INT 3
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PPUSH
100990: CALL_OW 69
100994: ST_TO_ADDR
// if not tmp then
100995: LD_VAR 0 1
100999: NOT
101000: IFFALSE 101004
// exit ;
101002: GO 101030
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101004: LD_VAR 0 1
101008: PUSH
101009: LD_INT 1
101011: PPUSH
101012: LD_VAR 0 1
101016: PPUSH
101017: CALL_OW 12
101021: ARRAY
101022: PPUSH
101023: LD_INT 1
101025: PPUSH
101026: CALL_OW 234
// end ;
101030: PPOPN 1
101032: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101033: LD_EXP 137
101037: PUSH
101038: LD_EXP 185
101042: AND
101043: IFFALSE 101155
101045: GO 101047
101047: DISABLE
101048: LD_INT 0
101050: PPUSH
101051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101052: LD_ADDR_VAR 0 2
101056: PUSH
101057: LD_INT 22
101059: PUSH
101060: LD_OWVAR 2
101064: PUSH
101065: EMPTY
101066: LIST
101067: LIST
101068: PUSH
101069: LD_INT 2
101071: PUSH
101072: LD_INT 30
101074: PUSH
101075: LD_INT 27
101077: PUSH
101078: EMPTY
101079: LIST
101080: LIST
101081: PUSH
101082: LD_INT 30
101084: PUSH
101085: LD_INT 26
101087: PUSH
101088: EMPTY
101089: LIST
101090: LIST
101091: PUSH
101092: LD_INT 30
101094: PUSH
101095: LD_INT 28
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: LIST
101106: LIST
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: PPUSH
101112: CALL_OW 69
101116: ST_TO_ADDR
// if not tmp then
101117: LD_VAR 0 2
101121: NOT
101122: IFFALSE 101126
// exit ;
101124: GO 101155
// for i in tmp do
101126: LD_ADDR_VAR 0 1
101130: PUSH
101131: LD_VAR 0 2
101135: PUSH
101136: FOR_IN
101137: IFFALSE 101153
// SetLives ( i , 1 ) ;
101139: LD_VAR 0 1
101143: PPUSH
101144: LD_INT 1
101146: PPUSH
101147: CALL_OW 234
101151: GO 101136
101153: POP
101154: POP
// end ;
101155: PPOPN 2
101157: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101158: LD_EXP 137
101162: PUSH
101163: LD_EXP 186
101167: AND
101168: IFFALSE 101442
101170: GO 101172
101172: DISABLE
101173: LD_INT 0
101175: PPUSH
101176: PPUSH
101177: PPUSH
// begin i := rand ( 1 , 7 ) ;
101178: LD_ADDR_VAR 0 1
101182: PUSH
101183: LD_INT 1
101185: PPUSH
101186: LD_INT 7
101188: PPUSH
101189: CALL_OW 12
101193: ST_TO_ADDR
// case i of 1 :
101194: LD_VAR 0 1
101198: PUSH
101199: LD_INT 1
101201: DOUBLE
101202: EQUAL
101203: IFTRUE 101207
101205: GO 101217
101207: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101208: LD_STRING earthquake(getX(game), 0, 32)
101210: PPUSH
101211: CALL_OW 559
101215: GO 101442
101217: LD_INT 2
101219: DOUBLE
101220: EQUAL
101221: IFTRUE 101225
101223: GO 101239
101225: POP
// begin ToLua ( displayStucuk(); ) ;
101226: LD_STRING displayStucuk();
101228: PPUSH
101229: CALL_OW 559
// ResetFog ;
101233: CALL_OW 335
// end ; 3 :
101237: GO 101442
101239: LD_INT 3
101241: DOUBLE
101242: EQUAL
101243: IFTRUE 101247
101245: GO 101351
101247: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101248: LD_ADDR_VAR 0 2
101252: PUSH
101253: LD_INT 22
101255: PUSH
101256: LD_OWVAR 2
101260: PUSH
101261: EMPTY
101262: LIST
101263: LIST
101264: PUSH
101265: LD_INT 25
101267: PUSH
101268: LD_INT 1
101270: PUSH
101271: EMPTY
101272: LIST
101273: LIST
101274: PUSH
101275: EMPTY
101276: LIST
101277: LIST
101278: PPUSH
101279: CALL_OW 69
101283: ST_TO_ADDR
// if not tmp then
101284: LD_VAR 0 2
101288: NOT
101289: IFFALSE 101293
// exit ;
101291: GO 101442
// un := tmp [ rand ( 1 , tmp ) ] ;
101293: LD_ADDR_VAR 0 3
101297: PUSH
101298: LD_VAR 0 2
101302: PUSH
101303: LD_INT 1
101305: PPUSH
101306: LD_VAR 0 2
101310: PPUSH
101311: CALL_OW 12
101315: ARRAY
101316: ST_TO_ADDR
// if Crawls ( un ) then
101317: LD_VAR 0 3
101321: PPUSH
101322: CALL_OW 318
101326: IFFALSE 101337
// ComWalk ( un ) ;
101328: LD_VAR 0 3
101332: PPUSH
101333: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101337: LD_VAR 0 3
101341: PPUSH
101342: LD_INT 8
101344: PPUSH
101345: CALL_OW 336
// end ; 4 :
101349: GO 101442
101351: LD_INT 4
101353: DOUBLE
101354: EQUAL
101355: IFTRUE 101359
101357: GO 101420
101359: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101360: LD_ADDR_VAR 0 2
101364: PUSH
101365: LD_INT 22
101367: PUSH
101368: LD_OWVAR 2
101372: PUSH
101373: EMPTY
101374: LIST
101375: LIST
101376: PUSH
101377: LD_INT 30
101379: PUSH
101380: LD_INT 29
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: EMPTY
101388: LIST
101389: LIST
101390: PPUSH
101391: CALL_OW 69
101395: ST_TO_ADDR
// if not tmp then
101396: LD_VAR 0 2
101400: NOT
101401: IFFALSE 101405
// exit ;
101403: GO 101442
// DestroyUnit ( tmp [ 1 ] ) ;
101405: LD_VAR 0 2
101409: PUSH
101410: LD_INT 1
101412: ARRAY
101413: PPUSH
101414: CALL_OW 65
// end ; 5 .. 7 :
101418: GO 101442
101420: LD_INT 5
101422: DOUBLE
101423: GREATEREQUAL
101424: IFFALSE 101432
101426: LD_INT 7
101428: DOUBLE
101429: LESSEQUAL
101430: IFTRUE 101434
101432: GO 101441
101434: POP
// StreamSibBomb ; end ;
101435: CALL 97692 0 0
101439: GO 101442
101441: POP
// end ;
101442: PPOPN 3
101444: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101445: LD_EXP 137
101449: PUSH
101450: LD_EXP 187
101454: AND
101455: IFFALSE 101611
101457: GO 101459
101459: DISABLE
101460: LD_INT 0
101462: PPUSH
101463: PPUSH
101464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101465: LD_ADDR_VAR 0 2
101469: PUSH
101470: LD_INT 81
101472: PUSH
101473: LD_OWVAR 2
101477: PUSH
101478: EMPTY
101479: LIST
101480: LIST
101481: PUSH
101482: LD_INT 2
101484: PUSH
101485: LD_INT 21
101487: PUSH
101488: LD_INT 1
101490: PUSH
101491: EMPTY
101492: LIST
101493: LIST
101494: PUSH
101495: LD_INT 21
101497: PUSH
101498: LD_INT 2
101500: PUSH
101501: EMPTY
101502: LIST
101503: LIST
101504: PUSH
101505: EMPTY
101506: LIST
101507: LIST
101508: LIST
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PPUSH
101514: CALL_OW 69
101518: ST_TO_ADDR
// if not tmp then
101519: LD_VAR 0 2
101523: NOT
101524: IFFALSE 101528
// exit ;
101526: GO 101611
// p := 0 ;
101528: LD_ADDR_VAR 0 3
101532: PUSH
101533: LD_INT 0
101535: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101536: LD_INT 35
101538: PPUSH
101539: CALL_OW 67
// p := p + 1 ;
101543: LD_ADDR_VAR 0 3
101547: PUSH
101548: LD_VAR 0 3
101552: PUSH
101553: LD_INT 1
101555: PLUS
101556: ST_TO_ADDR
// for i in tmp do
101557: LD_ADDR_VAR 0 1
101561: PUSH
101562: LD_VAR 0 2
101566: PUSH
101567: FOR_IN
101568: IFFALSE 101599
// if GetLives ( i ) < 1000 then
101570: LD_VAR 0 1
101574: PPUSH
101575: CALL_OW 256
101579: PUSH
101580: LD_INT 1000
101582: LESS
101583: IFFALSE 101597
// SetLives ( i , 1000 ) ;
101585: LD_VAR 0 1
101589: PPUSH
101590: LD_INT 1000
101592: PPUSH
101593: CALL_OW 234
101597: GO 101567
101599: POP
101600: POP
// until p > 20 ;
101601: LD_VAR 0 3
101605: PUSH
101606: LD_INT 20
101608: GREATER
101609: IFFALSE 101536
// end ;
101611: PPOPN 3
101613: END
// every 0 0$1 trigger StreamModeActive and sTime do
101614: LD_EXP 137
101618: PUSH
101619: LD_EXP 188
101623: AND
101624: IFFALSE 101659
101626: GO 101628
101628: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101629: LD_INT 28
101631: PPUSH
101632: LD_OWVAR 2
101636: PPUSH
101637: LD_INT 2
101639: PPUSH
101640: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101644: LD_INT 30
101646: PPUSH
101647: LD_OWVAR 2
101651: PPUSH
101652: LD_INT 2
101654: PPUSH
101655: CALL_OW 322
// end ;
101659: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101660: LD_EXP 137
101664: PUSH
101665: LD_EXP 189
101669: AND
101670: IFFALSE 101791
101672: GO 101674
101674: DISABLE
101675: LD_INT 0
101677: PPUSH
101678: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101679: LD_ADDR_VAR 0 2
101683: PUSH
101684: LD_INT 22
101686: PUSH
101687: LD_OWVAR 2
101691: PUSH
101692: EMPTY
101693: LIST
101694: LIST
101695: PUSH
101696: LD_INT 21
101698: PUSH
101699: LD_INT 1
101701: PUSH
101702: EMPTY
101703: LIST
101704: LIST
101705: PUSH
101706: LD_INT 3
101708: PUSH
101709: LD_INT 23
101711: PUSH
101712: LD_INT 0
101714: PUSH
101715: EMPTY
101716: LIST
101717: LIST
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: PUSH
101723: EMPTY
101724: LIST
101725: LIST
101726: LIST
101727: PPUSH
101728: CALL_OW 69
101732: ST_TO_ADDR
// if not tmp then
101733: LD_VAR 0 2
101737: NOT
101738: IFFALSE 101742
// exit ;
101740: GO 101791
// for i in tmp do
101742: LD_ADDR_VAR 0 1
101746: PUSH
101747: LD_VAR 0 2
101751: PUSH
101752: FOR_IN
101753: IFFALSE 101789
// begin if Crawls ( i ) then
101755: LD_VAR 0 1
101759: PPUSH
101760: CALL_OW 318
101764: IFFALSE 101775
// ComWalk ( i ) ;
101766: LD_VAR 0 1
101770: PPUSH
101771: CALL_OW 138
// SetClass ( i , 2 ) ;
101775: LD_VAR 0 1
101779: PPUSH
101780: LD_INT 2
101782: PPUSH
101783: CALL_OW 336
// end ;
101787: GO 101752
101789: POP
101790: POP
// end ;
101791: PPOPN 2
101793: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101794: LD_EXP 137
101798: PUSH
101799: LD_EXP 190
101803: AND
101804: IFFALSE 102085
101806: GO 101808
101808: DISABLE
101809: LD_INT 0
101811: PPUSH
101812: PPUSH
101813: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101814: LD_OWVAR 2
101818: PPUSH
101819: LD_INT 9
101821: PPUSH
101822: LD_INT 1
101824: PPUSH
101825: LD_INT 1
101827: PPUSH
101828: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101832: LD_INT 9
101834: PPUSH
101835: LD_OWVAR 2
101839: PPUSH
101840: CALL_OW 343
// uc_side := 9 ;
101844: LD_ADDR_OWVAR 20
101848: PUSH
101849: LD_INT 9
101851: ST_TO_ADDR
// uc_nation := 2 ;
101852: LD_ADDR_OWVAR 21
101856: PUSH
101857: LD_INT 2
101859: ST_TO_ADDR
// hc_name := Dark Warrior ;
101860: LD_ADDR_OWVAR 26
101864: PUSH
101865: LD_STRING Dark Warrior
101867: ST_TO_ADDR
// hc_gallery :=  ;
101868: LD_ADDR_OWVAR 33
101872: PUSH
101873: LD_STRING 
101875: ST_TO_ADDR
// hc_noskilllimit := true ;
101876: LD_ADDR_OWVAR 76
101880: PUSH
101881: LD_INT 1
101883: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101884: LD_ADDR_OWVAR 31
101888: PUSH
101889: LD_INT 30
101891: PUSH
101892: LD_INT 30
101894: PUSH
101895: LD_INT 30
101897: PUSH
101898: LD_INT 30
101900: PUSH
101901: EMPTY
101902: LIST
101903: LIST
101904: LIST
101905: LIST
101906: ST_TO_ADDR
// un := CreateHuman ;
101907: LD_ADDR_VAR 0 3
101911: PUSH
101912: CALL_OW 44
101916: ST_TO_ADDR
// hc_noskilllimit := false ;
101917: LD_ADDR_OWVAR 76
101921: PUSH
101922: LD_INT 0
101924: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101925: LD_VAR 0 3
101929: PPUSH
101930: LD_INT 1
101932: PPUSH
101933: CALL_OW 51
// p := 0 ;
101937: LD_ADDR_VAR 0 2
101941: PUSH
101942: LD_INT 0
101944: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101945: LD_INT 35
101947: PPUSH
101948: CALL_OW 67
// p := p + 1 ;
101952: LD_ADDR_VAR 0 2
101956: PUSH
101957: LD_VAR 0 2
101961: PUSH
101962: LD_INT 1
101964: PLUS
101965: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101966: LD_VAR 0 3
101970: PPUSH
101971: CALL_OW 256
101975: PUSH
101976: LD_INT 1000
101978: LESS
101979: IFFALSE 101993
// SetLives ( un , 1000 ) ;
101981: LD_VAR 0 3
101985: PPUSH
101986: LD_INT 1000
101988: PPUSH
101989: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101993: LD_VAR 0 3
101997: PPUSH
101998: LD_INT 81
102000: PUSH
102001: LD_OWVAR 2
102005: PUSH
102006: EMPTY
102007: LIST
102008: LIST
102009: PUSH
102010: LD_INT 91
102012: PUSH
102013: LD_VAR 0 3
102017: PUSH
102018: LD_INT 30
102020: PUSH
102021: EMPTY
102022: LIST
102023: LIST
102024: LIST
102025: PUSH
102026: EMPTY
102027: LIST
102028: LIST
102029: PPUSH
102030: CALL_OW 69
102034: PPUSH
102035: LD_VAR 0 3
102039: PPUSH
102040: CALL_OW 74
102044: PPUSH
102045: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
102049: LD_VAR 0 2
102053: PUSH
102054: LD_INT 60
102056: GREATER
102057: PUSH
102058: LD_VAR 0 3
102062: PPUSH
102063: CALL_OW 301
102067: OR
102068: IFFALSE 101945
// if un then
102070: LD_VAR 0 3
102074: IFFALSE 102085
// RemoveUnit ( un ) ;
102076: LD_VAR 0 3
102080: PPUSH
102081: CALL_OW 64
// end ;
102085: PPOPN 3
102087: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102088: LD_INT 0
102090: PPUSH
// case cmd of 301 :
102091: LD_VAR 0 1
102095: PUSH
102096: LD_INT 301
102098: DOUBLE
102099: EQUAL
102100: IFTRUE 102104
102102: GO 102136
102104: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102105: LD_VAR 0 6
102109: PPUSH
102110: LD_VAR 0 7
102114: PPUSH
102115: LD_VAR 0 8
102119: PPUSH
102120: LD_VAR 0 4
102124: PPUSH
102125: LD_VAR 0 5
102129: PPUSH
102130: CALL 103337 0 5
102134: GO 102257
102136: LD_INT 302
102138: DOUBLE
102139: EQUAL
102140: IFTRUE 102144
102142: GO 102181
102144: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102145: LD_VAR 0 6
102149: PPUSH
102150: LD_VAR 0 7
102154: PPUSH
102155: LD_VAR 0 8
102159: PPUSH
102160: LD_VAR 0 9
102164: PPUSH
102165: LD_VAR 0 4
102169: PPUSH
102170: LD_VAR 0 5
102174: PPUSH
102175: CALL 103428 0 6
102179: GO 102257
102181: LD_INT 303
102183: DOUBLE
102184: EQUAL
102185: IFTRUE 102189
102187: GO 102226
102189: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102190: LD_VAR 0 6
102194: PPUSH
102195: LD_VAR 0 7
102199: PPUSH
102200: LD_VAR 0 8
102204: PPUSH
102205: LD_VAR 0 9
102209: PPUSH
102210: LD_VAR 0 4
102214: PPUSH
102215: LD_VAR 0 5
102219: PPUSH
102220: CALL 102262 0 6
102224: GO 102257
102226: LD_INT 304
102228: DOUBLE
102229: EQUAL
102230: IFTRUE 102234
102232: GO 102256
102234: POP
// hHackTeleport ( unit , x , y ) ; end ;
102235: LD_VAR 0 2
102239: PPUSH
102240: LD_VAR 0 4
102244: PPUSH
102245: LD_VAR 0 5
102249: PPUSH
102250: CALL 104021 0 3
102254: GO 102257
102256: POP
// end ;
102257: LD_VAR 0 12
102261: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102262: LD_INT 0
102264: PPUSH
102265: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102266: LD_VAR 0 1
102270: PUSH
102271: LD_INT 1
102273: LESS
102274: PUSH
102275: LD_VAR 0 1
102279: PUSH
102280: LD_INT 3
102282: GREATER
102283: OR
102284: PUSH
102285: LD_VAR 0 5
102289: PPUSH
102290: LD_VAR 0 6
102294: PPUSH
102295: CALL_OW 428
102299: OR
102300: IFFALSE 102304
// exit ;
102302: GO 103024
// uc_side := your_side ;
102304: LD_ADDR_OWVAR 20
102308: PUSH
102309: LD_OWVAR 2
102313: ST_TO_ADDR
// uc_nation := nation ;
102314: LD_ADDR_OWVAR 21
102318: PUSH
102319: LD_VAR 0 1
102323: ST_TO_ADDR
// bc_level = 1 ;
102324: LD_ADDR_OWVAR 43
102328: PUSH
102329: LD_INT 1
102331: ST_TO_ADDR
// case btype of 1 :
102332: LD_VAR 0 2
102336: PUSH
102337: LD_INT 1
102339: DOUBLE
102340: EQUAL
102341: IFTRUE 102345
102343: GO 102356
102345: POP
// bc_type := b_depot ; 2 :
102346: LD_ADDR_OWVAR 42
102350: PUSH
102351: LD_INT 0
102353: ST_TO_ADDR
102354: GO 102968
102356: LD_INT 2
102358: DOUBLE
102359: EQUAL
102360: IFTRUE 102364
102362: GO 102375
102364: POP
// bc_type := b_warehouse ; 3 :
102365: LD_ADDR_OWVAR 42
102369: PUSH
102370: LD_INT 1
102372: ST_TO_ADDR
102373: GO 102968
102375: LD_INT 3
102377: DOUBLE
102378: EQUAL
102379: IFTRUE 102383
102381: GO 102394
102383: POP
// bc_type := b_lab ; 4 .. 9 :
102384: LD_ADDR_OWVAR 42
102388: PUSH
102389: LD_INT 6
102391: ST_TO_ADDR
102392: GO 102968
102394: LD_INT 4
102396: DOUBLE
102397: GREATEREQUAL
102398: IFFALSE 102406
102400: LD_INT 9
102402: DOUBLE
102403: LESSEQUAL
102404: IFTRUE 102408
102406: GO 102460
102408: POP
// begin bc_type := b_lab_half ;
102409: LD_ADDR_OWVAR 42
102413: PUSH
102414: LD_INT 7
102416: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102417: LD_ADDR_OWVAR 44
102421: PUSH
102422: LD_INT 10
102424: PUSH
102425: LD_INT 11
102427: PUSH
102428: LD_INT 12
102430: PUSH
102431: LD_INT 15
102433: PUSH
102434: LD_INT 14
102436: PUSH
102437: LD_INT 13
102439: PUSH
102440: EMPTY
102441: LIST
102442: LIST
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: PUSH
102448: LD_VAR 0 2
102452: PUSH
102453: LD_INT 3
102455: MINUS
102456: ARRAY
102457: ST_TO_ADDR
// end ; 10 .. 13 :
102458: GO 102968
102460: LD_INT 10
102462: DOUBLE
102463: GREATEREQUAL
102464: IFFALSE 102472
102466: LD_INT 13
102468: DOUBLE
102469: LESSEQUAL
102470: IFTRUE 102474
102472: GO 102551
102474: POP
// begin bc_type := b_lab_full ;
102475: LD_ADDR_OWVAR 42
102479: PUSH
102480: LD_INT 8
102482: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102483: LD_ADDR_OWVAR 44
102487: PUSH
102488: LD_INT 10
102490: PUSH
102491: LD_INT 12
102493: PUSH
102494: LD_INT 14
102496: PUSH
102497: LD_INT 13
102499: PUSH
102500: EMPTY
102501: LIST
102502: LIST
102503: LIST
102504: LIST
102505: PUSH
102506: LD_VAR 0 2
102510: PUSH
102511: LD_INT 9
102513: MINUS
102514: ARRAY
102515: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102516: LD_ADDR_OWVAR 45
102520: PUSH
102521: LD_INT 11
102523: PUSH
102524: LD_INT 15
102526: PUSH
102527: LD_INT 12
102529: PUSH
102530: LD_INT 15
102532: PUSH
102533: EMPTY
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: PUSH
102539: LD_VAR 0 2
102543: PUSH
102544: LD_INT 9
102546: MINUS
102547: ARRAY
102548: ST_TO_ADDR
// end ; 14 :
102549: GO 102968
102551: LD_INT 14
102553: DOUBLE
102554: EQUAL
102555: IFTRUE 102559
102557: GO 102570
102559: POP
// bc_type := b_workshop ; 15 :
102560: LD_ADDR_OWVAR 42
102564: PUSH
102565: LD_INT 2
102567: ST_TO_ADDR
102568: GO 102968
102570: LD_INT 15
102572: DOUBLE
102573: EQUAL
102574: IFTRUE 102578
102576: GO 102589
102578: POP
// bc_type := b_factory ; 16 :
102579: LD_ADDR_OWVAR 42
102583: PUSH
102584: LD_INT 3
102586: ST_TO_ADDR
102587: GO 102968
102589: LD_INT 16
102591: DOUBLE
102592: EQUAL
102593: IFTRUE 102597
102595: GO 102608
102597: POP
// bc_type := b_ext_gun ; 17 :
102598: LD_ADDR_OWVAR 42
102602: PUSH
102603: LD_INT 17
102605: ST_TO_ADDR
102606: GO 102968
102608: LD_INT 17
102610: DOUBLE
102611: EQUAL
102612: IFTRUE 102616
102614: GO 102644
102616: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102617: LD_ADDR_OWVAR 42
102621: PUSH
102622: LD_INT 19
102624: PUSH
102625: LD_INT 23
102627: PUSH
102628: LD_INT 19
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: LIST
102635: PUSH
102636: LD_VAR 0 1
102640: ARRAY
102641: ST_TO_ADDR
102642: GO 102968
102644: LD_INT 18
102646: DOUBLE
102647: EQUAL
102648: IFTRUE 102652
102650: GO 102663
102652: POP
// bc_type := b_ext_radar ; 19 :
102653: LD_ADDR_OWVAR 42
102657: PUSH
102658: LD_INT 20
102660: ST_TO_ADDR
102661: GO 102968
102663: LD_INT 19
102665: DOUBLE
102666: EQUAL
102667: IFTRUE 102671
102669: GO 102682
102671: POP
// bc_type := b_ext_radio ; 20 :
102672: LD_ADDR_OWVAR 42
102676: PUSH
102677: LD_INT 22
102679: ST_TO_ADDR
102680: GO 102968
102682: LD_INT 20
102684: DOUBLE
102685: EQUAL
102686: IFTRUE 102690
102688: GO 102701
102690: POP
// bc_type := b_ext_siberium ; 21 :
102691: LD_ADDR_OWVAR 42
102695: PUSH
102696: LD_INT 21
102698: ST_TO_ADDR
102699: GO 102968
102701: LD_INT 21
102703: DOUBLE
102704: EQUAL
102705: IFTRUE 102709
102707: GO 102720
102709: POP
// bc_type := b_ext_computer ; 22 :
102710: LD_ADDR_OWVAR 42
102714: PUSH
102715: LD_INT 24
102717: ST_TO_ADDR
102718: GO 102968
102720: LD_INT 22
102722: DOUBLE
102723: EQUAL
102724: IFTRUE 102728
102726: GO 102739
102728: POP
// bc_type := b_ext_track ; 23 :
102729: LD_ADDR_OWVAR 42
102733: PUSH
102734: LD_INT 16
102736: ST_TO_ADDR
102737: GO 102968
102739: LD_INT 23
102741: DOUBLE
102742: EQUAL
102743: IFTRUE 102747
102745: GO 102758
102747: POP
// bc_type := b_ext_laser ; 24 :
102748: LD_ADDR_OWVAR 42
102752: PUSH
102753: LD_INT 25
102755: ST_TO_ADDR
102756: GO 102968
102758: LD_INT 24
102760: DOUBLE
102761: EQUAL
102762: IFTRUE 102766
102764: GO 102777
102766: POP
// bc_type := b_control_tower ; 25 :
102767: LD_ADDR_OWVAR 42
102771: PUSH
102772: LD_INT 36
102774: ST_TO_ADDR
102775: GO 102968
102777: LD_INT 25
102779: DOUBLE
102780: EQUAL
102781: IFTRUE 102785
102783: GO 102796
102785: POP
// bc_type := b_breastwork ; 26 :
102786: LD_ADDR_OWVAR 42
102790: PUSH
102791: LD_INT 31
102793: ST_TO_ADDR
102794: GO 102968
102796: LD_INT 26
102798: DOUBLE
102799: EQUAL
102800: IFTRUE 102804
102802: GO 102815
102804: POP
// bc_type := b_bunker ; 27 :
102805: LD_ADDR_OWVAR 42
102809: PUSH
102810: LD_INT 32
102812: ST_TO_ADDR
102813: GO 102968
102815: LD_INT 27
102817: DOUBLE
102818: EQUAL
102819: IFTRUE 102823
102821: GO 102834
102823: POP
// bc_type := b_turret ; 28 :
102824: LD_ADDR_OWVAR 42
102828: PUSH
102829: LD_INT 33
102831: ST_TO_ADDR
102832: GO 102968
102834: LD_INT 28
102836: DOUBLE
102837: EQUAL
102838: IFTRUE 102842
102840: GO 102853
102842: POP
// bc_type := b_armoury ; 29 :
102843: LD_ADDR_OWVAR 42
102847: PUSH
102848: LD_INT 4
102850: ST_TO_ADDR
102851: GO 102968
102853: LD_INT 29
102855: DOUBLE
102856: EQUAL
102857: IFTRUE 102861
102859: GO 102872
102861: POP
// bc_type := b_barracks ; 30 :
102862: LD_ADDR_OWVAR 42
102866: PUSH
102867: LD_INT 5
102869: ST_TO_ADDR
102870: GO 102968
102872: LD_INT 30
102874: DOUBLE
102875: EQUAL
102876: IFTRUE 102880
102878: GO 102891
102880: POP
// bc_type := b_solar_power ; 31 :
102881: LD_ADDR_OWVAR 42
102885: PUSH
102886: LD_INT 27
102888: ST_TO_ADDR
102889: GO 102968
102891: LD_INT 31
102893: DOUBLE
102894: EQUAL
102895: IFTRUE 102899
102897: GO 102910
102899: POP
// bc_type := b_oil_power ; 32 :
102900: LD_ADDR_OWVAR 42
102904: PUSH
102905: LD_INT 26
102907: ST_TO_ADDR
102908: GO 102968
102910: LD_INT 32
102912: DOUBLE
102913: EQUAL
102914: IFTRUE 102918
102916: GO 102929
102918: POP
// bc_type := b_siberite_power ; 33 :
102919: LD_ADDR_OWVAR 42
102923: PUSH
102924: LD_INT 28
102926: ST_TO_ADDR
102927: GO 102968
102929: LD_INT 33
102931: DOUBLE
102932: EQUAL
102933: IFTRUE 102937
102935: GO 102948
102937: POP
// bc_type := b_oil_mine ; 34 :
102938: LD_ADDR_OWVAR 42
102942: PUSH
102943: LD_INT 29
102945: ST_TO_ADDR
102946: GO 102968
102948: LD_INT 34
102950: DOUBLE
102951: EQUAL
102952: IFTRUE 102956
102954: GO 102967
102956: POP
// bc_type := b_siberite_mine ; end ;
102957: LD_ADDR_OWVAR 42
102961: PUSH
102962: LD_INT 30
102964: ST_TO_ADDR
102965: GO 102968
102967: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102968: LD_ADDR_VAR 0 8
102972: PUSH
102973: LD_VAR 0 5
102977: PPUSH
102978: LD_VAR 0 6
102982: PPUSH
102983: LD_VAR 0 3
102987: PPUSH
102988: CALL_OW 47
102992: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102993: LD_OWVAR 42
102997: PUSH
102998: LD_INT 32
103000: PUSH
103001: LD_INT 33
103003: PUSH
103004: EMPTY
103005: LIST
103006: LIST
103007: IN
103008: IFFALSE 103024
// PlaceWeaponTurret ( b , weapon ) ;
103010: LD_VAR 0 8
103014: PPUSH
103015: LD_VAR 0 4
103019: PPUSH
103020: CALL_OW 431
// end ;
103024: LD_VAR 0 7
103028: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103029: LD_INT 0
103031: PPUSH
103032: PPUSH
103033: PPUSH
103034: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103035: LD_ADDR_VAR 0 4
103039: PUSH
103040: LD_INT 22
103042: PUSH
103043: LD_OWVAR 2
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PUSH
103052: LD_INT 2
103054: PUSH
103055: LD_INT 30
103057: PUSH
103058: LD_INT 0
103060: PUSH
103061: EMPTY
103062: LIST
103063: LIST
103064: PUSH
103065: LD_INT 30
103067: PUSH
103068: LD_INT 1
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: PUSH
103075: EMPTY
103076: LIST
103077: LIST
103078: LIST
103079: PUSH
103080: EMPTY
103081: LIST
103082: LIST
103083: PPUSH
103084: CALL_OW 69
103088: ST_TO_ADDR
// if not tmp then
103089: LD_VAR 0 4
103093: NOT
103094: IFFALSE 103098
// exit ;
103096: GO 103157
// for i in tmp do
103098: LD_ADDR_VAR 0 2
103102: PUSH
103103: LD_VAR 0 4
103107: PUSH
103108: FOR_IN
103109: IFFALSE 103155
// for j = 1 to 3 do
103111: LD_ADDR_VAR 0 3
103115: PUSH
103116: DOUBLE
103117: LD_INT 1
103119: DEC
103120: ST_TO_ADDR
103121: LD_INT 3
103123: PUSH
103124: FOR_TO
103125: IFFALSE 103151
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103127: LD_VAR 0 2
103131: PPUSH
103132: CALL_OW 274
103136: PPUSH
103137: LD_VAR 0 3
103141: PPUSH
103142: LD_INT 99999
103144: PPUSH
103145: CALL_OW 277
103149: GO 103124
103151: POP
103152: POP
103153: GO 103108
103155: POP
103156: POP
// end ;
103157: LD_VAR 0 1
103161: RET
// export function hHackSetLevel10 ; var i , j ; begin
103162: LD_INT 0
103164: PPUSH
103165: PPUSH
103166: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103167: LD_ADDR_VAR 0 2
103171: PUSH
103172: LD_INT 21
103174: PUSH
103175: LD_INT 1
103177: PUSH
103178: EMPTY
103179: LIST
103180: LIST
103181: PPUSH
103182: CALL_OW 69
103186: PUSH
103187: FOR_IN
103188: IFFALSE 103240
// if IsSelected ( i ) then
103190: LD_VAR 0 2
103194: PPUSH
103195: CALL_OW 306
103199: IFFALSE 103238
// begin for j := 1 to 4 do
103201: LD_ADDR_VAR 0 3
103205: PUSH
103206: DOUBLE
103207: LD_INT 1
103209: DEC
103210: ST_TO_ADDR
103211: LD_INT 4
103213: PUSH
103214: FOR_TO
103215: IFFALSE 103236
// SetSkill ( i , j , 10 ) ;
103217: LD_VAR 0 2
103221: PPUSH
103222: LD_VAR 0 3
103226: PPUSH
103227: LD_INT 10
103229: PPUSH
103230: CALL_OW 237
103234: GO 103214
103236: POP
103237: POP
// end ;
103238: GO 103187
103240: POP
103241: POP
// end ;
103242: LD_VAR 0 1
103246: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103247: LD_INT 0
103249: PPUSH
103250: PPUSH
103251: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103252: LD_ADDR_VAR 0 2
103256: PUSH
103257: LD_INT 22
103259: PUSH
103260: LD_OWVAR 2
103264: PUSH
103265: EMPTY
103266: LIST
103267: LIST
103268: PUSH
103269: LD_INT 21
103271: PUSH
103272: LD_INT 1
103274: PUSH
103275: EMPTY
103276: LIST
103277: LIST
103278: PUSH
103279: EMPTY
103280: LIST
103281: LIST
103282: PPUSH
103283: CALL_OW 69
103287: PUSH
103288: FOR_IN
103289: IFFALSE 103330
// begin for j := 1 to 4 do
103291: LD_ADDR_VAR 0 3
103295: PUSH
103296: DOUBLE
103297: LD_INT 1
103299: DEC
103300: ST_TO_ADDR
103301: LD_INT 4
103303: PUSH
103304: FOR_TO
103305: IFFALSE 103326
// SetSkill ( i , j , 10 ) ;
103307: LD_VAR 0 2
103311: PPUSH
103312: LD_VAR 0 3
103316: PPUSH
103317: LD_INT 10
103319: PPUSH
103320: CALL_OW 237
103324: GO 103304
103326: POP
103327: POP
// end ;
103328: GO 103288
103330: POP
103331: POP
// end ;
103332: LD_VAR 0 1
103336: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103337: LD_INT 0
103339: PPUSH
// uc_side := your_side ;
103340: LD_ADDR_OWVAR 20
103344: PUSH
103345: LD_OWVAR 2
103349: ST_TO_ADDR
// uc_nation := nation ;
103350: LD_ADDR_OWVAR 21
103354: PUSH
103355: LD_VAR 0 1
103359: ST_TO_ADDR
// InitHc ;
103360: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103364: LD_INT 0
103366: PPUSH
103367: LD_VAR 0 2
103371: PPUSH
103372: LD_VAR 0 3
103376: PPUSH
103377: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103381: LD_VAR 0 4
103385: PPUSH
103386: LD_VAR 0 5
103390: PPUSH
103391: CALL_OW 428
103395: PUSH
103396: LD_INT 0
103398: EQUAL
103399: IFFALSE 103423
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103401: CALL_OW 44
103405: PPUSH
103406: LD_VAR 0 4
103410: PPUSH
103411: LD_VAR 0 5
103415: PPUSH
103416: LD_INT 1
103418: PPUSH
103419: CALL_OW 48
// end ;
103423: LD_VAR 0 6
103427: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103428: LD_INT 0
103430: PPUSH
103431: PPUSH
// uc_side := your_side ;
103432: LD_ADDR_OWVAR 20
103436: PUSH
103437: LD_OWVAR 2
103441: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103442: LD_VAR 0 1
103446: PUSH
103447: LD_INT 1
103449: PUSH
103450: LD_INT 2
103452: PUSH
103453: LD_INT 3
103455: PUSH
103456: LD_INT 4
103458: PUSH
103459: LD_INT 5
103461: PUSH
103462: EMPTY
103463: LIST
103464: LIST
103465: LIST
103466: LIST
103467: LIST
103468: IN
103469: IFFALSE 103481
// uc_nation := nation_american else
103471: LD_ADDR_OWVAR 21
103475: PUSH
103476: LD_INT 1
103478: ST_TO_ADDR
103479: GO 103524
// if chassis in [ 11 , 12 , 13 , 14 ] then
103481: LD_VAR 0 1
103485: PUSH
103486: LD_INT 11
103488: PUSH
103489: LD_INT 12
103491: PUSH
103492: LD_INT 13
103494: PUSH
103495: LD_INT 14
103497: PUSH
103498: EMPTY
103499: LIST
103500: LIST
103501: LIST
103502: LIST
103503: IN
103504: IFFALSE 103516
// uc_nation := nation_arabian else
103506: LD_ADDR_OWVAR 21
103510: PUSH
103511: LD_INT 2
103513: ST_TO_ADDR
103514: GO 103524
// uc_nation := nation_russian ;
103516: LD_ADDR_OWVAR 21
103520: PUSH
103521: LD_INT 3
103523: ST_TO_ADDR
// vc_chassis := chassis ;
103524: LD_ADDR_OWVAR 37
103528: PUSH
103529: LD_VAR 0 1
103533: ST_TO_ADDR
// vc_engine := engine ;
103534: LD_ADDR_OWVAR 39
103538: PUSH
103539: LD_VAR 0 2
103543: ST_TO_ADDR
// vc_control := control ;
103544: LD_ADDR_OWVAR 38
103548: PUSH
103549: LD_VAR 0 3
103553: ST_TO_ADDR
// vc_weapon := weapon ;
103554: LD_ADDR_OWVAR 40
103558: PUSH
103559: LD_VAR 0 4
103563: ST_TO_ADDR
// un := CreateVehicle ;
103564: LD_ADDR_VAR 0 8
103568: PUSH
103569: CALL_OW 45
103573: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103574: LD_VAR 0 8
103578: PPUSH
103579: LD_INT 0
103581: PPUSH
103582: LD_INT 5
103584: PPUSH
103585: CALL_OW 12
103589: PPUSH
103590: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103594: LD_VAR 0 8
103598: PPUSH
103599: LD_VAR 0 5
103603: PPUSH
103604: LD_VAR 0 6
103608: PPUSH
103609: LD_INT 1
103611: PPUSH
103612: CALL_OW 48
// end ;
103616: LD_VAR 0 7
103620: RET
// export hInvincible ; every 1 do
103621: GO 103623
103623: DISABLE
// hInvincible := [ ] ;
103624: LD_ADDR_EXP 191
103628: PUSH
103629: EMPTY
103630: ST_TO_ADDR
103631: END
// every 10 do var i ;
103632: GO 103634
103634: DISABLE
103635: LD_INT 0
103637: PPUSH
// begin enable ;
103638: ENABLE
// if not hInvincible then
103639: LD_EXP 191
103643: NOT
103644: IFFALSE 103648
// exit ;
103646: GO 103692
// for i in hInvincible do
103648: LD_ADDR_VAR 0 1
103652: PUSH
103653: LD_EXP 191
103657: PUSH
103658: FOR_IN
103659: IFFALSE 103690
// if GetLives ( i ) < 1000 then
103661: LD_VAR 0 1
103665: PPUSH
103666: CALL_OW 256
103670: PUSH
103671: LD_INT 1000
103673: LESS
103674: IFFALSE 103688
// SetLives ( i , 1000 ) ;
103676: LD_VAR 0 1
103680: PPUSH
103681: LD_INT 1000
103683: PPUSH
103684: CALL_OW 234
103688: GO 103658
103690: POP
103691: POP
// end ;
103692: PPOPN 1
103694: END
// export function hHackInvincible ; var i ; begin
103695: LD_INT 0
103697: PPUSH
103698: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103699: LD_ADDR_VAR 0 2
103703: PUSH
103704: LD_INT 2
103706: PUSH
103707: LD_INT 21
103709: PUSH
103710: LD_INT 1
103712: PUSH
103713: EMPTY
103714: LIST
103715: LIST
103716: PUSH
103717: LD_INT 21
103719: PUSH
103720: LD_INT 2
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: LIST
103731: PPUSH
103732: CALL_OW 69
103736: PUSH
103737: FOR_IN
103738: IFFALSE 103799
// if IsSelected ( i ) then
103740: LD_VAR 0 2
103744: PPUSH
103745: CALL_OW 306
103749: IFFALSE 103797
// begin if i in hInvincible then
103751: LD_VAR 0 2
103755: PUSH
103756: LD_EXP 191
103760: IN
103761: IFFALSE 103781
// hInvincible := hInvincible diff i else
103763: LD_ADDR_EXP 191
103767: PUSH
103768: LD_EXP 191
103772: PUSH
103773: LD_VAR 0 2
103777: DIFF
103778: ST_TO_ADDR
103779: GO 103797
// hInvincible := hInvincible union i ;
103781: LD_ADDR_EXP 191
103785: PUSH
103786: LD_EXP 191
103790: PUSH
103791: LD_VAR 0 2
103795: UNION
103796: ST_TO_ADDR
// end ;
103797: GO 103737
103799: POP
103800: POP
// end ;
103801: LD_VAR 0 1
103805: RET
// export function hHackInvisible ; var i , j ; begin
103806: LD_INT 0
103808: PPUSH
103809: PPUSH
103810: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103811: LD_ADDR_VAR 0 2
103815: PUSH
103816: LD_INT 21
103818: PUSH
103819: LD_INT 1
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: PPUSH
103826: CALL_OW 69
103830: PUSH
103831: FOR_IN
103832: IFFALSE 103856
// if IsSelected ( i ) then
103834: LD_VAR 0 2
103838: PPUSH
103839: CALL_OW 306
103843: IFFALSE 103854
// ComForceInvisible ( i ) ;
103845: LD_VAR 0 2
103849: PPUSH
103850: CALL_OW 496
103854: GO 103831
103856: POP
103857: POP
// end ;
103858: LD_VAR 0 1
103862: RET
// export function hHackChangeYourSide ; begin
103863: LD_INT 0
103865: PPUSH
// if your_side = 8 then
103866: LD_OWVAR 2
103870: PUSH
103871: LD_INT 8
103873: EQUAL
103874: IFFALSE 103886
// your_side := 0 else
103876: LD_ADDR_OWVAR 2
103880: PUSH
103881: LD_INT 0
103883: ST_TO_ADDR
103884: GO 103900
// your_side := your_side + 1 ;
103886: LD_ADDR_OWVAR 2
103890: PUSH
103891: LD_OWVAR 2
103895: PUSH
103896: LD_INT 1
103898: PLUS
103899: ST_TO_ADDR
// end ;
103900: LD_VAR 0 1
103904: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103905: LD_INT 0
103907: PPUSH
103908: PPUSH
103909: PPUSH
// for i in all_units do
103910: LD_ADDR_VAR 0 2
103914: PUSH
103915: LD_OWVAR 3
103919: PUSH
103920: FOR_IN
103921: IFFALSE 103999
// if IsSelected ( i ) then
103923: LD_VAR 0 2
103927: PPUSH
103928: CALL_OW 306
103932: IFFALSE 103997
// begin j := GetSide ( i ) ;
103934: LD_ADDR_VAR 0 3
103938: PUSH
103939: LD_VAR 0 2
103943: PPUSH
103944: CALL_OW 255
103948: ST_TO_ADDR
// if j = 8 then
103949: LD_VAR 0 3
103953: PUSH
103954: LD_INT 8
103956: EQUAL
103957: IFFALSE 103969
// j := 0 else
103959: LD_ADDR_VAR 0 3
103963: PUSH
103964: LD_INT 0
103966: ST_TO_ADDR
103967: GO 103983
// j := j + 1 ;
103969: LD_ADDR_VAR 0 3
103973: PUSH
103974: LD_VAR 0 3
103978: PUSH
103979: LD_INT 1
103981: PLUS
103982: ST_TO_ADDR
// SetSide ( i , j ) ;
103983: LD_VAR 0 2
103987: PPUSH
103988: LD_VAR 0 3
103992: PPUSH
103993: CALL_OW 235
// end ;
103997: GO 103920
103999: POP
104000: POP
// end ;
104001: LD_VAR 0 1
104005: RET
// export function hHackFog ; begin
104006: LD_INT 0
104008: PPUSH
// FogOff ( true ) ;
104009: LD_INT 1
104011: PPUSH
104012: CALL_OW 344
// end ;
104016: LD_VAR 0 1
104020: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104021: LD_INT 0
104023: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104024: LD_VAR 0 1
104028: PPUSH
104029: LD_VAR 0 2
104033: PPUSH
104034: LD_VAR 0 3
104038: PPUSH
104039: LD_INT 1
104041: PPUSH
104042: LD_INT 1
104044: PPUSH
104045: CALL_OW 483
// CenterOnXY ( x , y ) ;
104049: LD_VAR 0 2
104053: PPUSH
104054: LD_VAR 0 3
104058: PPUSH
104059: CALL_OW 84
// end ; end_of_file
104063: LD_VAR 0 4
104067: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
104068: LD_INT 0
104070: PPUSH
104071: PPUSH
104072: PPUSH
104073: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104074: LD_VAR 0 1
104078: PPUSH
104079: CALL_OW 264
104083: PUSH
104084: LD_EXP 76
104088: EQUAL
104089: IFFALSE 104161
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104091: LD_INT 68
104093: PPUSH
104094: LD_VAR 0 1
104098: PPUSH
104099: CALL_OW 255
104103: PPUSH
104104: CALL_OW 321
104108: PUSH
104109: LD_INT 2
104111: EQUAL
104112: IFFALSE 104124
// eff := 70 else
104114: LD_ADDR_VAR 0 4
104118: PUSH
104119: LD_INT 70
104121: ST_TO_ADDR
104122: GO 104132
// eff := 30 ;
104124: LD_ADDR_VAR 0 4
104128: PUSH
104129: LD_INT 30
104131: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104132: LD_VAR 0 1
104136: PPUSH
104137: CALL_OW 250
104141: PPUSH
104142: LD_VAR 0 1
104146: PPUSH
104147: CALL_OW 251
104151: PPUSH
104152: LD_VAR 0 4
104156: PPUSH
104157: CALL_OW 495
// end ; end ;
104161: LD_VAR 0 2
104165: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104166: LD_INT 0
104168: PPUSH
// end ;
104169: LD_VAR 0 4
104173: RET
// export function SOS_Command ( cmd ) ; begin
104174: LD_INT 0
104176: PPUSH
// end ;
104177: LD_VAR 0 2
104181: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
104182: LD_INT 0
104184: PPUSH
// if cmd = 121 then
104185: LD_VAR 0 1
104189: PUSH
104190: LD_INT 121
104192: EQUAL
104193: IFFALSE 104195
// end ;
104195: LD_VAR 0 6
104199: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
104200: LD_INT 0
104202: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
104203: LD_VAR 0 1
104207: PUSH
104208: LD_INT 250
104210: EQUAL
104211: PUSH
104212: LD_VAR 0 2
104216: PPUSH
104217: CALL_OW 264
104221: PUSH
104222: LD_EXP 79
104226: EQUAL
104227: AND
104228: IFFALSE 104249
// MinerPlaceMine ( unit , x , y ) ;
104230: LD_VAR 0 2
104234: PPUSH
104235: LD_VAR 0 4
104239: PPUSH
104240: LD_VAR 0 5
104244: PPUSH
104245: CALL 106598 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
104249: LD_VAR 0 1
104253: PUSH
104254: LD_INT 251
104256: EQUAL
104257: PUSH
104258: LD_VAR 0 2
104262: PPUSH
104263: CALL_OW 264
104267: PUSH
104268: LD_EXP 79
104272: EQUAL
104273: AND
104274: IFFALSE 104295
// MinerDetonateMine ( unit , x , y ) ;
104276: LD_VAR 0 2
104280: PPUSH
104281: LD_VAR 0 4
104285: PPUSH
104286: LD_VAR 0 5
104290: PPUSH
104291: CALL 106875 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
104295: LD_VAR 0 1
104299: PUSH
104300: LD_INT 252
104302: EQUAL
104303: PUSH
104304: LD_VAR 0 2
104308: PPUSH
104309: CALL_OW 264
104313: PUSH
104314: LD_EXP 79
104318: EQUAL
104319: AND
104320: IFFALSE 104341
// MinerCreateMinefield ( unit , x , y ) ;
104322: LD_VAR 0 2
104326: PPUSH
104327: LD_VAR 0 4
104331: PPUSH
104332: LD_VAR 0 5
104336: PPUSH
104337: CALL 107292 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104341: LD_VAR 0 1
104345: PUSH
104346: LD_INT 253
104348: EQUAL
104349: PUSH
104350: LD_VAR 0 2
104354: PPUSH
104355: CALL_OW 257
104359: PUSH
104360: LD_INT 5
104362: EQUAL
104363: AND
104364: IFFALSE 104385
// ComBinocular ( unit , x , y ) ;
104366: LD_VAR 0 2
104370: PPUSH
104371: LD_VAR 0 4
104375: PPUSH
104376: LD_VAR 0 5
104380: PPUSH
104381: CALL 107663 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104385: LD_VAR 0 1
104389: PUSH
104390: LD_INT 254
104392: EQUAL
104393: PUSH
104394: LD_VAR 0 2
104398: PPUSH
104399: CALL_OW 264
104403: PUSH
104404: LD_EXP 74
104408: EQUAL
104409: AND
104410: PUSH
104411: LD_VAR 0 3
104415: PPUSH
104416: CALL_OW 263
104420: PUSH
104421: LD_INT 3
104423: EQUAL
104424: AND
104425: IFFALSE 104441
// HackDestroyVehicle ( unit , selectedUnit ) ;
104427: LD_VAR 0 2
104431: PPUSH
104432: LD_VAR 0 3
104436: PPUSH
104437: CALL 105958 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104441: LD_VAR 0 1
104445: PUSH
104446: LD_INT 255
104448: EQUAL
104449: PUSH
104450: LD_VAR 0 2
104454: PPUSH
104455: CALL_OW 264
104459: PUSH
104460: LD_INT 14
104462: PUSH
104463: LD_INT 53
104465: PUSH
104466: EMPTY
104467: LIST
104468: LIST
104469: IN
104470: AND
104471: PUSH
104472: LD_VAR 0 4
104476: PPUSH
104477: LD_VAR 0 5
104481: PPUSH
104482: CALL_OW 488
104486: AND
104487: IFFALSE 104511
// CutTreeXYR ( unit , x , y , 12 ) ;
104489: LD_VAR 0 2
104493: PPUSH
104494: LD_VAR 0 4
104498: PPUSH
104499: LD_VAR 0 5
104503: PPUSH
104504: LD_INT 12
104506: PPUSH
104507: CALL 104524 0 4
// end ;
104511: LD_VAR 0 6
104515: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
104516: LD_INT 0
104518: PPUSH
// end ;
104519: LD_VAR 0 4
104523: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104524: LD_INT 0
104526: PPUSH
104527: PPUSH
104528: PPUSH
104529: PPUSH
104530: PPUSH
104531: PPUSH
104532: PPUSH
104533: PPUSH
104534: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104535: LD_VAR 0 1
104539: NOT
104540: PUSH
104541: LD_VAR 0 2
104545: PPUSH
104546: LD_VAR 0 3
104550: PPUSH
104551: CALL_OW 488
104555: NOT
104556: OR
104557: PUSH
104558: LD_VAR 0 4
104562: NOT
104563: OR
104564: IFFALSE 104568
// exit ;
104566: GO 104908
// list := [ ] ;
104568: LD_ADDR_VAR 0 13
104572: PUSH
104573: EMPTY
104574: ST_TO_ADDR
// if x - r < 0 then
104575: LD_VAR 0 2
104579: PUSH
104580: LD_VAR 0 4
104584: MINUS
104585: PUSH
104586: LD_INT 0
104588: LESS
104589: IFFALSE 104601
// min_x := 0 else
104591: LD_ADDR_VAR 0 7
104595: PUSH
104596: LD_INT 0
104598: ST_TO_ADDR
104599: GO 104617
// min_x := x - r ;
104601: LD_ADDR_VAR 0 7
104605: PUSH
104606: LD_VAR 0 2
104610: PUSH
104611: LD_VAR 0 4
104615: MINUS
104616: ST_TO_ADDR
// if y - r < 0 then
104617: LD_VAR 0 3
104621: PUSH
104622: LD_VAR 0 4
104626: MINUS
104627: PUSH
104628: LD_INT 0
104630: LESS
104631: IFFALSE 104643
// min_y := 0 else
104633: LD_ADDR_VAR 0 8
104637: PUSH
104638: LD_INT 0
104640: ST_TO_ADDR
104641: GO 104659
// min_y := y - r ;
104643: LD_ADDR_VAR 0 8
104647: PUSH
104648: LD_VAR 0 3
104652: PUSH
104653: LD_VAR 0 4
104657: MINUS
104658: ST_TO_ADDR
// max_x := x + r ;
104659: LD_ADDR_VAR 0 9
104663: PUSH
104664: LD_VAR 0 2
104668: PUSH
104669: LD_VAR 0 4
104673: PLUS
104674: ST_TO_ADDR
// max_y := y + r ;
104675: LD_ADDR_VAR 0 10
104679: PUSH
104680: LD_VAR 0 3
104684: PUSH
104685: LD_VAR 0 4
104689: PLUS
104690: ST_TO_ADDR
// for _x = min_x to max_x do
104691: LD_ADDR_VAR 0 11
104695: PUSH
104696: DOUBLE
104697: LD_VAR 0 7
104701: DEC
104702: ST_TO_ADDR
104703: LD_VAR 0 9
104707: PUSH
104708: FOR_TO
104709: IFFALSE 104826
// for _y = min_y to max_y do
104711: LD_ADDR_VAR 0 12
104715: PUSH
104716: DOUBLE
104717: LD_VAR 0 8
104721: DEC
104722: ST_TO_ADDR
104723: LD_VAR 0 10
104727: PUSH
104728: FOR_TO
104729: IFFALSE 104822
// begin if not ValidHex ( _x , _y ) then
104731: LD_VAR 0 11
104735: PPUSH
104736: LD_VAR 0 12
104740: PPUSH
104741: CALL_OW 488
104745: NOT
104746: IFFALSE 104750
// continue ;
104748: GO 104728
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104750: LD_VAR 0 11
104754: PPUSH
104755: LD_VAR 0 12
104759: PPUSH
104760: CALL_OW 351
104764: PUSH
104765: LD_VAR 0 11
104769: PPUSH
104770: LD_VAR 0 12
104774: PPUSH
104775: CALL_OW 554
104779: AND
104780: IFFALSE 104820
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104782: LD_ADDR_VAR 0 13
104786: PUSH
104787: LD_VAR 0 13
104791: PPUSH
104792: LD_VAR 0 13
104796: PUSH
104797: LD_INT 1
104799: PLUS
104800: PPUSH
104801: LD_VAR 0 11
104805: PUSH
104806: LD_VAR 0 12
104810: PUSH
104811: EMPTY
104812: LIST
104813: LIST
104814: PPUSH
104815: CALL_OW 2
104819: ST_TO_ADDR
// end ;
104820: GO 104728
104822: POP
104823: POP
104824: GO 104708
104826: POP
104827: POP
// if not list then
104828: LD_VAR 0 13
104832: NOT
104833: IFFALSE 104837
// exit ;
104835: GO 104908
// for i in list do
104837: LD_ADDR_VAR 0 6
104841: PUSH
104842: LD_VAR 0 13
104846: PUSH
104847: FOR_IN
104848: IFFALSE 104906
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104850: LD_VAR 0 1
104854: PPUSH
104855: LD_STRING M
104857: PUSH
104858: LD_VAR 0 6
104862: PUSH
104863: LD_INT 1
104865: ARRAY
104866: PUSH
104867: LD_VAR 0 6
104871: PUSH
104872: LD_INT 2
104874: ARRAY
104875: PUSH
104876: LD_INT 0
104878: PUSH
104879: LD_INT 0
104881: PUSH
104882: LD_INT 0
104884: PUSH
104885: LD_INT 0
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: LIST
104892: LIST
104893: LIST
104894: LIST
104895: LIST
104896: PUSH
104897: EMPTY
104898: LIST
104899: PPUSH
104900: CALL_OW 447
104904: GO 104847
104906: POP
104907: POP
// end ;
104908: LD_VAR 0 5
104912: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104913: LD_EXP 194
104917: NOT
104918: IFFALSE 104968
104920: GO 104922
104922: DISABLE
// begin initHack := true ;
104923: LD_ADDR_EXP 194
104927: PUSH
104928: LD_INT 1
104930: ST_TO_ADDR
// hackTanks := [ ] ;
104931: LD_ADDR_EXP 195
104935: PUSH
104936: EMPTY
104937: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104938: LD_ADDR_EXP 196
104942: PUSH
104943: EMPTY
104944: ST_TO_ADDR
// hackLimit := 3 ;
104945: LD_ADDR_EXP 197
104949: PUSH
104950: LD_INT 3
104952: ST_TO_ADDR
// hackDist := 12 ;
104953: LD_ADDR_EXP 198
104957: PUSH
104958: LD_INT 12
104960: ST_TO_ADDR
// hackCounter := [ ] ;
104961: LD_ADDR_EXP 199
104965: PUSH
104966: EMPTY
104967: ST_TO_ADDR
// end ;
104968: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104969: LD_EXP 194
104973: PUSH
104974: LD_INT 34
104976: PUSH
104977: LD_EXP 74
104981: PUSH
104982: EMPTY
104983: LIST
104984: LIST
104985: PPUSH
104986: CALL_OW 69
104990: AND
104991: IFFALSE 105246
104993: GO 104995
104995: DISABLE
104996: LD_INT 0
104998: PPUSH
104999: PPUSH
// begin enable ;
105000: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
105001: LD_ADDR_VAR 0 1
105005: PUSH
105006: LD_INT 34
105008: PUSH
105009: LD_EXP 74
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PPUSH
105018: CALL_OW 69
105022: PUSH
105023: FOR_IN
105024: IFFALSE 105244
// begin if not i in hackTanks then
105026: LD_VAR 0 1
105030: PUSH
105031: LD_EXP 195
105035: IN
105036: NOT
105037: IFFALSE 105120
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
105039: LD_ADDR_EXP 195
105043: PUSH
105044: LD_EXP 195
105048: PPUSH
105049: LD_EXP 195
105053: PUSH
105054: LD_INT 1
105056: PLUS
105057: PPUSH
105058: LD_VAR 0 1
105062: PPUSH
105063: CALL_OW 1
105067: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
105068: LD_ADDR_EXP 196
105072: PUSH
105073: LD_EXP 196
105077: PPUSH
105078: LD_EXP 196
105082: PUSH
105083: LD_INT 1
105085: PLUS
105086: PPUSH
105087: EMPTY
105088: PPUSH
105089: CALL_OW 1
105093: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
105094: LD_ADDR_EXP 199
105098: PUSH
105099: LD_EXP 199
105103: PPUSH
105104: LD_EXP 199
105108: PUSH
105109: LD_INT 1
105111: PLUS
105112: PPUSH
105113: EMPTY
105114: PPUSH
105115: CALL_OW 1
105119: ST_TO_ADDR
// end ; if not IsOk ( i ) then
105120: LD_VAR 0 1
105124: PPUSH
105125: CALL_OW 302
105129: NOT
105130: IFFALSE 105143
// begin HackUnlinkAll ( i ) ;
105132: LD_VAR 0 1
105136: PPUSH
105137: CALL 105249 0 1
// continue ;
105141: GO 105023
// end ; HackCheckCapturedStatus ( i ) ;
105143: LD_VAR 0 1
105147: PPUSH
105148: CALL 105692 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
105152: LD_ADDR_VAR 0 2
105156: PUSH
105157: LD_INT 81
105159: PUSH
105160: LD_VAR 0 1
105164: PPUSH
105165: CALL_OW 255
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PUSH
105174: LD_INT 33
105176: PUSH
105177: LD_INT 3
105179: PUSH
105180: EMPTY
105181: LIST
105182: LIST
105183: PUSH
105184: LD_INT 91
105186: PUSH
105187: LD_VAR 0 1
105191: PUSH
105192: LD_EXP 198
105196: PUSH
105197: EMPTY
105198: LIST
105199: LIST
105200: LIST
105201: PUSH
105202: LD_INT 50
105204: PUSH
105205: EMPTY
105206: LIST
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: LIST
105212: LIST
105213: PPUSH
105214: CALL_OW 69
105218: ST_TO_ADDR
// if not tmp then
105219: LD_VAR 0 2
105223: NOT
105224: IFFALSE 105228
// continue ;
105226: GO 105023
// HackLink ( i , tmp ) ;
105228: LD_VAR 0 1
105232: PPUSH
105233: LD_VAR 0 2
105237: PPUSH
105238: CALL 105385 0 2
// end ;
105242: GO 105023
105244: POP
105245: POP
// end ;
105246: PPOPN 2
105248: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105249: LD_INT 0
105251: PPUSH
105252: PPUSH
105253: PPUSH
// if not hack in hackTanks then
105254: LD_VAR 0 1
105258: PUSH
105259: LD_EXP 195
105263: IN
105264: NOT
105265: IFFALSE 105269
// exit ;
105267: GO 105380
// index := GetElementIndex ( hackTanks , hack ) ;
105269: LD_ADDR_VAR 0 4
105273: PUSH
105274: LD_EXP 195
105278: PPUSH
105279: LD_VAR 0 1
105283: PPUSH
105284: CALL 56112 0 2
105288: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105289: LD_EXP 196
105293: PUSH
105294: LD_VAR 0 4
105298: ARRAY
105299: IFFALSE 105380
// begin for i in hackTanksCaptured [ index ] do
105301: LD_ADDR_VAR 0 3
105305: PUSH
105306: LD_EXP 196
105310: PUSH
105311: LD_VAR 0 4
105315: ARRAY
105316: PUSH
105317: FOR_IN
105318: IFFALSE 105344
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105320: LD_VAR 0 3
105324: PUSH
105325: LD_INT 1
105327: ARRAY
105328: PPUSH
105329: LD_VAR 0 3
105333: PUSH
105334: LD_INT 2
105336: ARRAY
105337: PPUSH
105338: CALL_OW 235
105342: GO 105317
105344: POP
105345: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105346: LD_ADDR_EXP 196
105350: PUSH
105351: LD_EXP 196
105355: PPUSH
105356: LD_VAR 0 4
105360: PPUSH
105361: EMPTY
105362: PPUSH
105363: CALL_OW 1
105367: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105368: LD_VAR 0 1
105372: PPUSH
105373: LD_INT 0
105375: PPUSH
105376: CALL_OW 505
// end ; end ;
105380: LD_VAR 0 2
105384: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105385: LD_INT 0
105387: PPUSH
105388: PPUSH
105389: PPUSH
// if not hack in hackTanks or not vehicles then
105390: LD_VAR 0 1
105394: PUSH
105395: LD_EXP 195
105399: IN
105400: NOT
105401: PUSH
105402: LD_VAR 0 2
105406: NOT
105407: OR
105408: IFFALSE 105412
// exit ;
105410: GO 105687
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105412: LD_ADDR_VAR 0 2
105416: PUSH
105417: LD_VAR 0 1
105421: PPUSH
105422: LD_VAR 0 2
105426: PPUSH
105427: LD_INT 1
105429: PPUSH
105430: LD_INT 1
105432: PPUSH
105433: CALL 56762 0 4
105437: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105438: LD_ADDR_VAR 0 5
105442: PUSH
105443: LD_EXP 195
105447: PPUSH
105448: LD_VAR 0 1
105452: PPUSH
105453: CALL 56112 0 2
105457: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105458: LD_EXP 196
105462: PUSH
105463: LD_VAR 0 5
105467: ARRAY
105468: PUSH
105469: LD_EXP 197
105473: LESS
105474: IFFALSE 105663
// begin for i := 1 to vehicles do
105476: LD_ADDR_VAR 0 4
105480: PUSH
105481: DOUBLE
105482: LD_INT 1
105484: DEC
105485: ST_TO_ADDR
105486: LD_VAR 0 2
105490: PUSH
105491: FOR_TO
105492: IFFALSE 105661
// begin if hackTanksCaptured [ index ] = hackLimit then
105494: LD_EXP 196
105498: PUSH
105499: LD_VAR 0 5
105503: ARRAY
105504: PUSH
105505: LD_EXP 197
105509: EQUAL
105510: IFFALSE 105514
// break ;
105512: GO 105661
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105514: LD_ADDR_EXP 199
105518: PUSH
105519: LD_EXP 199
105523: PPUSH
105524: LD_VAR 0 5
105528: PPUSH
105529: LD_EXP 199
105533: PUSH
105534: LD_VAR 0 5
105538: ARRAY
105539: PUSH
105540: LD_INT 1
105542: PLUS
105543: PPUSH
105544: CALL_OW 1
105548: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105549: LD_ADDR_EXP 196
105553: PUSH
105554: LD_EXP 196
105558: PPUSH
105559: LD_VAR 0 5
105563: PUSH
105564: LD_EXP 196
105568: PUSH
105569: LD_VAR 0 5
105573: ARRAY
105574: PUSH
105575: LD_INT 1
105577: PLUS
105578: PUSH
105579: EMPTY
105580: LIST
105581: LIST
105582: PPUSH
105583: LD_VAR 0 2
105587: PUSH
105588: LD_VAR 0 4
105592: ARRAY
105593: PUSH
105594: LD_VAR 0 2
105598: PUSH
105599: LD_VAR 0 4
105603: ARRAY
105604: PPUSH
105605: CALL_OW 255
105609: PUSH
105610: EMPTY
105611: LIST
105612: LIST
105613: PPUSH
105614: CALL 56327 0 3
105618: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105619: LD_VAR 0 2
105623: PUSH
105624: LD_VAR 0 4
105628: ARRAY
105629: PPUSH
105630: LD_VAR 0 1
105634: PPUSH
105635: CALL_OW 255
105639: PPUSH
105640: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105644: LD_VAR 0 2
105648: PUSH
105649: LD_VAR 0 4
105653: ARRAY
105654: PPUSH
105655: CALL_OW 141
// end ;
105659: GO 105491
105661: POP
105662: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105663: LD_VAR 0 1
105667: PPUSH
105668: LD_EXP 196
105672: PUSH
105673: LD_VAR 0 5
105677: ARRAY
105678: PUSH
105679: LD_INT 0
105681: PLUS
105682: PPUSH
105683: CALL_OW 505
// end ;
105687: LD_VAR 0 3
105691: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105692: LD_INT 0
105694: PPUSH
105695: PPUSH
105696: PPUSH
105697: PPUSH
// if not hack in hackTanks then
105698: LD_VAR 0 1
105702: PUSH
105703: LD_EXP 195
105707: IN
105708: NOT
105709: IFFALSE 105713
// exit ;
105711: GO 105953
// index := GetElementIndex ( hackTanks , hack ) ;
105713: LD_ADDR_VAR 0 4
105717: PUSH
105718: LD_EXP 195
105722: PPUSH
105723: LD_VAR 0 1
105727: PPUSH
105728: CALL 56112 0 2
105732: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105733: LD_ADDR_VAR 0 3
105737: PUSH
105738: DOUBLE
105739: LD_EXP 196
105743: PUSH
105744: LD_VAR 0 4
105748: ARRAY
105749: INC
105750: ST_TO_ADDR
105751: LD_INT 1
105753: PUSH
105754: FOR_DOWNTO
105755: IFFALSE 105927
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105757: LD_ADDR_VAR 0 5
105761: PUSH
105762: LD_EXP 196
105766: PUSH
105767: LD_VAR 0 4
105771: ARRAY
105772: PUSH
105773: LD_VAR 0 3
105777: ARRAY
105778: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105779: LD_VAR 0 5
105783: PUSH
105784: LD_INT 1
105786: ARRAY
105787: PPUSH
105788: CALL_OW 302
105792: NOT
105793: PUSH
105794: LD_VAR 0 5
105798: PUSH
105799: LD_INT 1
105801: ARRAY
105802: PPUSH
105803: CALL_OW 255
105807: PUSH
105808: LD_VAR 0 1
105812: PPUSH
105813: CALL_OW 255
105817: NONEQUAL
105818: OR
105819: IFFALSE 105925
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105821: LD_VAR 0 5
105825: PUSH
105826: LD_INT 1
105828: ARRAY
105829: PPUSH
105830: CALL_OW 305
105834: PUSH
105835: LD_VAR 0 5
105839: PUSH
105840: LD_INT 1
105842: ARRAY
105843: PPUSH
105844: CALL_OW 255
105848: PUSH
105849: LD_VAR 0 1
105853: PPUSH
105854: CALL_OW 255
105858: EQUAL
105859: AND
105860: IFFALSE 105884
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105862: LD_VAR 0 5
105866: PUSH
105867: LD_INT 1
105869: ARRAY
105870: PPUSH
105871: LD_VAR 0 5
105875: PUSH
105876: LD_INT 2
105878: ARRAY
105879: PPUSH
105880: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105884: LD_ADDR_EXP 196
105888: PUSH
105889: LD_EXP 196
105893: PPUSH
105894: LD_VAR 0 4
105898: PPUSH
105899: LD_EXP 196
105903: PUSH
105904: LD_VAR 0 4
105908: ARRAY
105909: PPUSH
105910: LD_VAR 0 3
105914: PPUSH
105915: CALL_OW 3
105919: PPUSH
105920: CALL_OW 1
105924: ST_TO_ADDR
// end ; end ;
105925: GO 105754
105927: POP
105928: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105929: LD_VAR 0 1
105933: PPUSH
105934: LD_EXP 196
105938: PUSH
105939: LD_VAR 0 4
105943: ARRAY
105944: PUSH
105945: LD_INT 0
105947: PLUS
105948: PPUSH
105949: CALL_OW 505
// end ;
105953: LD_VAR 0 2
105957: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105958: LD_INT 0
105960: PPUSH
105961: PPUSH
105962: PPUSH
105963: PPUSH
// if not hack in hackTanks then
105964: LD_VAR 0 1
105968: PUSH
105969: LD_EXP 195
105973: IN
105974: NOT
105975: IFFALSE 105979
// exit ;
105977: GO 106064
// index := GetElementIndex ( hackTanks , hack ) ;
105979: LD_ADDR_VAR 0 5
105983: PUSH
105984: LD_EXP 195
105988: PPUSH
105989: LD_VAR 0 1
105993: PPUSH
105994: CALL 56112 0 2
105998: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105999: LD_ADDR_VAR 0 4
106003: PUSH
106004: DOUBLE
106005: LD_INT 1
106007: DEC
106008: ST_TO_ADDR
106009: LD_EXP 196
106013: PUSH
106014: LD_VAR 0 5
106018: ARRAY
106019: PUSH
106020: FOR_TO
106021: IFFALSE 106062
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
106023: LD_EXP 196
106027: PUSH
106028: LD_VAR 0 5
106032: ARRAY
106033: PUSH
106034: LD_VAR 0 4
106038: ARRAY
106039: PUSH
106040: LD_INT 1
106042: ARRAY
106043: PUSH
106044: LD_VAR 0 2
106048: EQUAL
106049: IFFALSE 106060
// KillUnit ( vehicle ) ;
106051: LD_VAR 0 2
106055: PPUSH
106056: CALL_OW 66
106060: GO 106020
106062: POP
106063: POP
// end ;
106064: LD_VAR 0 3
106068: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
106069: LD_EXP 200
106073: NOT
106074: IFFALSE 106109
106076: GO 106078
106078: DISABLE
// begin initMiner := true ;
106079: LD_ADDR_EXP 200
106083: PUSH
106084: LD_INT 1
106086: ST_TO_ADDR
// minersList := [ ] ;
106087: LD_ADDR_EXP 201
106091: PUSH
106092: EMPTY
106093: ST_TO_ADDR
// minerMinesList := [ ] ;
106094: LD_ADDR_EXP 202
106098: PUSH
106099: EMPTY
106100: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
106101: LD_ADDR_EXP 203
106105: PUSH
106106: LD_INT 5
106108: ST_TO_ADDR
// end ;
106109: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
106110: LD_EXP 200
106114: PUSH
106115: LD_INT 34
106117: PUSH
106118: LD_EXP 79
106122: PUSH
106123: EMPTY
106124: LIST
106125: LIST
106126: PPUSH
106127: CALL_OW 69
106131: AND
106132: IFFALSE 106595
106134: GO 106136
106136: DISABLE
106137: LD_INT 0
106139: PPUSH
106140: PPUSH
106141: PPUSH
106142: PPUSH
// begin enable ;
106143: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
106144: LD_ADDR_VAR 0 1
106148: PUSH
106149: LD_INT 34
106151: PUSH
106152: LD_EXP 79
106156: PUSH
106157: EMPTY
106158: LIST
106159: LIST
106160: PPUSH
106161: CALL_OW 69
106165: PUSH
106166: FOR_IN
106167: IFFALSE 106239
// begin if not i in minersList then
106169: LD_VAR 0 1
106173: PUSH
106174: LD_EXP 201
106178: IN
106179: NOT
106180: IFFALSE 106237
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
106182: LD_ADDR_EXP 201
106186: PUSH
106187: LD_EXP 201
106191: PPUSH
106192: LD_EXP 201
106196: PUSH
106197: LD_INT 1
106199: PLUS
106200: PPUSH
106201: LD_VAR 0 1
106205: PPUSH
106206: CALL_OW 1
106210: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
106211: LD_ADDR_EXP 202
106215: PUSH
106216: LD_EXP 202
106220: PPUSH
106221: LD_EXP 202
106225: PUSH
106226: LD_INT 1
106228: PLUS
106229: PPUSH
106230: EMPTY
106231: PPUSH
106232: CALL_OW 1
106236: ST_TO_ADDR
// end end ;
106237: GO 106166
106239: POP
106240: POP
// for i := minerMinesList downto 1 do
106241: LD_ADDR_VAR 0 1
106245: PUSH
106246: DOUBLE
106247: LD_EXP 202
106251: INC
106252: ST_TO_ADDR
106253: LD_INT 1
106255: PUSH
106256: FOR_DOWNTO
106257: IFFALSE 106593
// begin if IsLive ( minersList [ i ] ) then
106259: LD_EXP 201
106263: PUSH
106264: LD_VAR 0 1
106268: ARRAY
106269: PPUSH
106270: CALL_OW 300
106274: IFFALSE 106302
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106276: LD_EXP 201
106280: PUSH
106281: LD_VAR 0 1
106285: ARRAY
106286: PPUSH
106287: LD_EXP 202
106291: PUSH
106292: LD_VAR 0 1
106296: ARRAY
106297: PPUSH
106298: CALL_OW 505
// if not minerMinesList [ i ] then
106302: LD_EXP 202
106306: PUSH
106307: LD_VAR 0 1
106311: ARRAY
106312: NOT
106313: IFFALSE 106317
// continue ;
106315: GO 106256
// for j := minerMinesList [ i ] downto 1 do
106317: LD_ADDR_VAR 0 2
106321: PUSH
106322: DOUBLE
106323: LD_EXP 202
106327: PUSH
106328: LD_VAR 0 1
106332: ARRAY
106333: INC
106334: ST_TO_ADDR
106335: LD_INT 1
106337: PUSH
106338: FOR_DOWNTO
106339: IFFALSE 106589
// begin side := GetSide ( minersList [ i ] ) ;
106341: LD_ADDR_VAR 0 3
106345: PUSH
106346: LD_EXP 201
106350: PUSH
106351: LD_VAR 0 1
106355: ARRAY
106356: PPUSH
106357: CALL_OW 255
106361: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106362: LD_ADDR_VAR 0 4
106366: PUSH
106367: LD_EXP 202
106371: PUSH
106372: LD_VAR 0 1
106376: ARRAY
106377: PUSH
106378: LD_VAR 0 2
106382: ARRAY
106383: PUSH
106384: LD_INT 1
106386: ARRAY
106387: PPUSH
106388: LD_EXP 202
106392: PUSH
106393: LD_VAR 0 1
106397: ARRAY
106398: PUSH
106399: LD_VAR 0 2
106403: ARRAY
106404: PUSH
106405: LD_INT 2
106407: ARRAY
106408: PPUSH
106409: CALL_OW 428
106413: ST_TO_ADDR
// if not tmp then
106414: LD_VAR 0 4
106418: NOT
106419: IFFALSE 106423
// continue ;
106421: GO 106338
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106423: LD_VAR 0 4
106427: PUSH
106428: LD_INT 81
106430: PUSH
106431: LD_VAR 0 3
106435: PUSH
106436: EMPTY
106437: LIST
106438: LIST
106439: PPUSH
106440: CALL_OW 69
106444: IN
106445: PUSH
106446: LD_EXP 202
106450: PUSH
106451: LD_VAR 0 1
106455: ARRAY
106456: PUSH
106457: LD_VAR 0 2
106461: ARRAY
106462: PUSH
106463: LD_INT 1
106465: ARRAY
106466: PPUSH
106467: LD_EXP 202
106471: PUSH
106472: LD_VAR 0 1
106476: ARRAY
106477: PUSH
106478: LD_VAR 0 2
106482: ARRAY
106483: PUSH
106484: LD_INT 2
106486: ARRAY
106487: PPUSH
106488: CALL_OW 458
106492: AND
106493: IFFALSE 106587
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106495: LD_EXP 202
106499: PUSH
106500: LD_VAR 0 1
106504: ARRAY
106505: PUSH
106506: LD_VAR 0 2
106510: ARRAY
106511: PUSH
106512: LD_INT 1
106514: ARRAY
106515: PPUSH
106516: LD_EXP 202
106520: PUSH
106521: LD_VAR 0 1
106525: ARRAY
106526: PUSH
106527: LD_VAR 0 2
106531: ARRAY
106532: PUSH
106533: LD_INT 2
106535: ARRAY
106536: PPUSH
106537: LD_VAR 0 3
106541: PPUSH
106542: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106546: LD_ADDR_EXP 202
106550: PUSH
106551: LD_EXP 202
106555: PPUSH
106556: LD_VAR 0 1
106560: PPUSH
106561: LD_EXP 202
106565: PUSH
106566: LD_VAR 0 1
106570: ARRAY
106571: PPUSH
106572: LD_VAR 0 2
106576: PPUSH
106577: CALL_OW 3
106581: PPUSH
106582: CALL_OW 1
106586: ST_TO_ADDR
// end ; end ;
106587: GO 106338
106589: POP
106590: POP
// end ;
106591: GO 106256
106593: POP
106594: POP
// end ;
106595: PPOPN 4
106597: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106598: LD_INT 0
106600: PPUSH
106601: PPUSH
// result := false ;
106602: LD_ADDR_VAR 0 4
106606: PUSH
106607: LD_INT 0
106609: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106610: LD_VAR 0 1
106614: PPUSH
106615: CALL_OW 264
106619: PUSH
106620: LD_EXP 79
106624: EQUAL
106625: NOT
106626: IFFALSE 106630
// exit ;
106628: GO 106870
// index := GetElementIndex ( minersList , unit ) ;
106630: LD_ADDR_VAR 0 5
106634: PUSH
106635: LD_EXP 201
106639: PPUSH
106640: LD_VAR 0 1
106644: PPUSH
106645: CALL 56112 0 2
106649: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106650: LD_EXP 202
106654: PUSH
106655: LD_VAR 0 5
106659: ARRAY
106660: PUSH
106661: LD_EXP 203
106665: GREATEREQUAL
106666: IFFALSE 106670
// exit ;
106668: GO 106870
// ComMoveXY ( unit , x , y ) ;
106670: LD_VAR 0 1
106674: PPUSH
106675: LD_VAR 0 2
106679: PPUSH
106680: LD_VAR 0 3
106684: PPUSH
106685: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106689: LD_INT 35
106691: PPUSH
106692: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106696: LD_VAR 0 1
106700: PPUSH
106701: LD_VAR 0 2
106705: PPUSH
106706: LD_VAR 0 3
106710: PPUSH
106711: CALL 86884 0 3
106715: NOT
106716: PUSH
106717: LD_VAR 0 1
106721: PPUSH
106722: CALL_OW 314
106726: AND
106727: IFFALSE 106731
// exit ;
106729: GO 106870
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106731: LD_VAR 0 2
106735: PPUSH
106736: LD_VAR 0 3
106740: PPUSH
106741: CALL_OW 428
106745: PUSH
106746: LD_VAR 0 1
106750: EQUAL
106751: PUSH
106752: LD_VAR 0 1
106756: PPUSH
106757: CALL_OW 314
106761: NOT
106762: AND
106763: IFFALSE 106689
// PlaySoundXY ( x , y , PlantMine ) ;
106765: LD_VAR 0 2
106769: PPUSH
106770: LD_VAR 0 3
106774: PPUSH
106775: LD_STRING PlantMine
106777: PPUSH
106778: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106782: LD_VAR 0 2
106786: PPUSH
106787: LD_VAR 0 3
106791: PPUSH
106792: LD_VAR 0 1
106796: PPUSH
106797: CALL_OW 255
106801: PPUSH
106802: LD_INT 0
106804: PPUSH
106805: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106809: LD_ADDR_EXP 202
106813: PUSH
106814: LD_EXP 202
106818: PPUSH
106819: LD_VAR 0 5
106823: PUSH
106824: LD_EXP 202
106828: PUSH
106829: LD_VAR 0 5
106833: ARRAY
106834: PUSH
106835: LD_INT 1
106837: PLUS
106838: PUSH
106839: EMPTY
106840: LIST
106841: LIST
106842: PPUSH
106843: LD_VAR 0 2
106847: PUSH
106848: LD_VAR 0 3
106852: PUSH
106853: EMPTY
106854: LIST
106855: LIST
106856: PPUSH
106857: CALL 56327 0 3
106861: ST_TO_ADDR
// result := true ;
106862: LD_ADDR_VAR 0 4
106866: PUSH
106867: LD_INT 1
106869: ST_TO_ADDR
// end ;
106870: LD_VAR 0 4
106874: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106875: LD_INT 0
106877: PPUSH
106878: PPUSH
106879: PPUSH
// if not unit in minersList then
106880: LD_VAR 0 1
106884: PUSH
106885: LD_EXP 201
106889: IN
106890: NOT
106891: IFFALSE 106895
// exit ;
106893: GO 107287
// index := GetElementIndex ( minersList , unit ) ;
106895: LD_ADDR_VAR 0 6
106899: PUSH
106900: LD_EXP 201
106904: PPUSH
106905: LD_VAR 0 1
106909: PPUSH
106910: CALL 56112 0 2
106914: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106915: LD_ADDR_VAR 0 5
106919: PUSH
106920: DOUBLE
106921: LD_EXP 202
106925: PUSH
106926: LD_VAR 0 6
106930: ARRAY
106931: INC
106932: ST_TO_ADDR
106933: LD_INT 1
106935: PUSH
106936: FOR_DOWNTO
106937: IFFALSE 107098
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106939: LD_EXP 202
106943: PUSH
106944: LD_VAR 0 6
106948: ARRAY
106949: PUSH
106950: LD_VAR 0 5
106954: ARRAY
106955: PUSH
106956: LD_INT 1
106958: ARRAY
106959: PUSH
106960: LD_VAR 0 2
106964: EQUAL
106965: PUSH
106966: LD_EXP 202
106970: PUSH
106971: LD_VAR 0 6
106975: ARRAY
106976: PUSH
106977: LD_VAR 0 5
106981: ARRAY
106982: PUSH
106983: LD_INT 2
106985: ARRAY
106986: PUSH
106987: LD_VAR 0 3
106991: EQUAL
106992: AND
106993: IFFALSE 107096
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106995: LD_EXP 202
106999: PUSH
107000: LD_VAR 0 6
107004: ARRAY
107005: PUSH
107006: LD_VAR 0 5
107010: ARRAY
107011: PUSH
107012: LD_INT 1
107014: ARRAY
107015: PPUSH
107016: LD_EXP 202
107020: PUSH
107021: LD_VAR 0 6
107025: ARRAY
107026: PUSH
107027: LD_VAR 0 5
107031: ARRAY
107032: PUSH
107033: LD_INT 2
107035: ARRAY
107036: PPUSH
107037: LD_VAR 0 1
107041: PPUSH
107042: CALL_OW 255
107046: PPUSH
107047: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107051: LD_ADDR_EXP 202
107055: PUSH
107056: LD_EXP 202
107060: PPUSH
107061: LD_VAR 0 6
107065: PPUSH
107066: LD_EXP 202
107070: PUSH
107071: LD_VAR 0 6
107075: ARRAY
107076: PPUSH
107077: LD_VAR 0 5
107081: PPUSH
107082: CALL_OW 3
107086: PPUSH
107087: CALL_OW 1
107091: ST_TO_ADDR
// exit ;
107092: POP
107093: POP
107094: GO 107287
// end ; end ;
107096: GO 106936
107098: POP
107099: POP
// for i := minerMinesList [ index ] downto 1 do
107100: LD_ADDR_VAR 0 5
107104: PUSH
107105: DOUBLE
107106: LD_EXP 202
107110: PUSH
107111: LD_VAR 0 6
107115: ARRAY
107116: INC
107117: ST_TO_ADDR
107118: LD_INT 1
107120: PUSH
107121: FOR_DOWNTO
107122: IFFALSE 107285
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
107124: LD_EXP 202
107128: PUSH
107129: LD_VAR 0 6
107133: ARRAY
107134: PUSH
107135: LD_VAR 0 5
107139: ARRAY
107140: PUSH
107141: LD_INT 1
107143: ARRAY
107144: PPUSH
107145: LD_EXP 202
107149: PUSH
107150: LD_VAR 0 6
107154: ARRAY
107155: PUSH
107156: LD_VAR 0 5
107160: ARRAY
107161: PUSH
107162: LD_INT 2
107164: ARRAY
107165: PPUSH
107166: LD_VAR 0 2
107170: PPUSH
107171: LD_VAR 0 3
107175: PPUSH
107176: CALL_OW 298
107180: PUSH
107181: LD_INT 6
107183: LESS
107184: IFFALSE 107283
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107186: LD_EXP 202
107190: PUSH
107191: LD_VAR 0 6
107195: ARRAY
107196: PUSH
107197: LD_VAR 0 5
107201: ARRAY
107202: PUSH
107203: LD_INT 1
107205: ARRAY
107206: PPUSH
107207: LD_EXP 202
107211: PUSH
107212: LD_VAR 0 6
107216: ARRAY
107217: PUSH
107218: LD_VAR 0 5
107222: ARRAY
107223: PUSH
107224: LD_INT 2
107226: ARRAY
107227: PPUSH
107228: LD_VAR 0 1
107232: PPUSH
107233: CALL_OW 255
107237: PPUSH
107238: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107242: LD_ADDR_EXP 202
107246: PUSH
107247: LD_EXP 202
107251: PPUSH
107252: LD_VAR 0 6
107256: PPUSH
107257: LD_EXP 202
107261: PUSH
107262: LD_VAR 0 6
107266: ARRAY
107267: PPUSH
107268: LD_VAR 0 5
107272: PPUSH
107273: CALL_OW 3
107277: PPUSH
107278: CALL_OW 1
107282: ST_TO_ADDR
// end ; end ;
107283: GO 107121
107285: POP
107286: POP
// end ;
107287: LD_VAR 0 4
107291: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107292: LD_INT 0
107294: PPUSH
107295: PPUSH
107296: PPUSH
107297: PPUSH
107298: PPUSH
107299: PPUSH
107300: PPUSH
107301: PPUSH
107302: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107303: LD_VAR 0 1
107307: PPUSH
107308: CALL_OW 264
107312: PUSH
107313: LD_EXP 79
107317: EQUAL
107318: NOT
107319: PUSH
107320: LD_VAR 0 1
107324: PUSH
107325: LD_EXP 201
107329: IN
107330: NOT
107331: OR
107332: IFFALSE 107336
// exit ;
107334: GO 107658
// index := GetElementIndex ( minersList , unit ) ;
107336: LD_ADDR_VAR 0 6
107340: PUSH
107341: LD_EXP 201
107345: PPUSH
107346: LD_VAR 0 1
107350: PPUSH
107351: CALL 56112 0 2
107355: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107356: LD_ADDR_VAR 0 8
107360: PUSH
107361: LD_EXP 203
107365: PUSH
107366: LD_EXP 202
107370: PUSH
107371: LD_VAR 0 6
107375: ARRAY
107376: MINUS
107377: ST_TO_ADDR
// if not minesFreeAmount then
107378: LD_VAR 0 8
107382: NOT
107383: IFFALSE 107387
// exit ;
107385: GO 107658
// tmp := [ ] ;
107387: LD_ADDR_VAR 0 7
107391: PUSH
107392: EMPTY
107393: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107394: LD_ADDR_VAR 0 5
107398: PUSH
107399: DOUBLE
107400: LD_INT 1
107402: DEC
107403: ST_TO_ADDR
107404: LD_VAR 0 8
107408: PUSH
107409: FOR_TO
107410: IFFALSE 107605
// begin _d := rand ( 0 , 5 ) ;
107412: LD_ADDR_VAR 0 11
107416: PUSH
107417: LD_INT 0
107419: PPUSH
107420: LD_INT 5
107422: PPUSH
107423: CALL_OW 12
107427: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107428: LD_ADDR_VAR 0 12
107432: PUSH
107433: LD_INT 2
107435: PPUSH
107436: LD_INT 6
107438: PPUSH
107439: CALL_OW 12
107443: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107444: LD_ADDR_VAR 0 9
107448: PUSH
107449: LD_VAR 0 2
107453: PPUSH
107454: LD_VAR 0 11
107458: PPUSH
107459: LD_VAR 0 12
107463: PPUSH
107464: CALL_OW 272
107468: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107469: LD_ADDR_VAR 0 10
107473: PUSH
107474: LD_VAR 0 3
107478: PPUSH
107479: LD_VAR 0 11
107483: PPUSH
107484: LD_VAR 0 12
107488: PPUSH
107489: CALL_OW 273
107493: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107494: LD_VAR 0 9
107498: PPUSH
107499: LD_VAR 0 10
107503: PPUSH
107504: CALL_OW 488
107508: PUSH
107509: LD_VAR 0 9
107513: PUSH
107514: LD_VAR 0 10
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: PUSH
107523: LD_VAR 0 7
107527: IN
107528: NOT
107529: AND
107530: PUSH
107531: LD_VAR 0 9
107535: PPUSH
107536: LD_VAR 0 10
107540: PPUSH
107541: CALL_OW 458
107545: NOT
107546: AND
107547: IFFALSE 107589
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107549: LD_ADDR_VAR 0 7
107553: PUSH
107554: LD_VAR 0 7
107558: PPUSH
107559: LD_VAR 0 7
107563: PUSH
107564: LD_INT 1
107566: PLUS
107567: PPUSH
107568: LD_VAR 0 9
107572: PUSH
107573: LD_VAR 0 10
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PPUSH
107582: CALL_OW 1
107586: ST_TO_ADDR
107587: GO 107603
// i := i - 1 ;
107589: LD_ADDR_VAR 0 5
107593: PUSH
107594: LD_VAR 0 5
107598: PUSH
107599: LD_INT 1
107601: MINUS
107602: ST_TO_ADDR
// end ;
107603: GO 107409
107605: POP
107606: POP
// for i in tmp do
107607: LD_ADDR_VAR 0 5
107611: PUSH
107612: LD_VAR 0 7
107616: PUSH
107617: FOR_IN
107618: IFFALSE 107656
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107620: LD_VAR 0 1
107624: PPUSH
107625: LD_VAR 0 5
107629: PUSH
107630: LD_INT 1
107632: ARRAY
107633: PPUSH
107634: LD_VAR 0 5
107638: PUSH
107639: LD_INT 2
107641: ARRAY
107642: PPUSH
107643: CALL 106598 0 3
107647: NOT
107648: IFFALSE 107654
// exit ;
107650: POP
107651: POP
107652: GO 107658
107654: GO 107617
107656: POP
107657: POP
// end ;
107658: LD_VAR 0 4
107662: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107663: LD_INT 0
107665: PPUSH
107666: PPUSH
107667: PPUSH
107668: PPUSH
107669: PPUSH
107670: PPUSH
107671: PPUSH
// if not GetClass ( unit ) = class_sniper then
107672: LD_VAR 0 1
107676: PPUSH
107677: CALL_OW 257
107681: PUSH
107682: LD_INT 5
107684: EQUAL
107685: NOT
107686: IFFALSE 107690
// exit ;
107688: GO 108078
// dist := 8 ;
107690: LD_ADDR_VAR 0 5
107694: PUSH
107695: LD_INT 8
107697: ST_TO_ADDR
// viewRange := 12 ;
107698: LD_ADDR_VAR 0 7
107702: PUSH
107703: LD_INT 12
107705: ST_TO_ADDR
// side := GetSide ( unit ) ;
107706: LD_ADDR_VAR 0 6
107710: PUSH
107711: LD_VAR 0 1
107715: PPUSH
107716: CALL_OW 255
107720: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107721: LD_INT 61
107723: PPUSH
107724: LD_VAR 0 6
107728: PPUSH
107729: CALL_OW 321
107733: PUSH
107734: LD_INT 2
107736: EQUAL
107737: IFFALSE 107747
// viewRange := 16 ;
107739: LD_ADDR_VAR 0 7
107743: PUSH
107744: LD_INT 16
107746: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107747: LD_VAR 0 1
107751: PPUSH
107752: LD_VAR 0 2
107756: PPUSH
107757: LD_VAR 0 3
107761: PPUSH
107762: CALL_OW 297
107766: PUSH
107767: LD_VAR 0 5
107771: GREATER
107772: IFFALSE 107851
// begin ComMoveXY ( unit , x , y ) ;
107774: LD_VAR 0 1
107778: PPUSH
107779: LD_VAR 0 2
107783: PPUSH
107784: LD_VAR 0 3
107788: PPUSH
107789: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107793: LD_INT 35
107795: PPUSH
107796: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107800: LD_VAR 0 1
107804: PPUSH
107805: LD_VAR 0 2
107809: PPUSH
107810: LD_VAR 0 3
107814: PPUSH
107815: CALL 86884 0 3
107819: NOT
107820: IFFALSE 107824
// exit ;
107822: GO 108078
// until GetDistUnitXY ( unit , x , y ) < dist ;
107824: LD_VAR 0 1
107828: PPUSH
107829: LD_VAR 0 2
107833: PPUSH
107834: LD_VAR 0 3
107838: PPUSH
107839: CALL_OW 297
107843: PUSH
107844: LD_VAR 0 5
107848: LESS
107849: IFFALSE 107793
// end ; ComTurnXY ( unit , x , y ) ;
107851: LD_VAR 0 1
107855: PPUSH
107856: LD_VAR 0 2
107860: PPUSH
107861: LD_VAR 0 3
107865: PPUSH
107866: CALL_OW 118
// wait ( 5 ) ;
107870: LD_INT 5
107872: PPUSH
107873: CALL_OW 67
// _d := GetDir ( unit ) ;
107877: LD_ADDR_VAR 0 10
107881: PUSH
107882: LD_VAR 0 1
107886: PPUSH
107887: CALL_OW 254
107891: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107892: LD_ADDR_VAR 0 8
107896: PUSH
107897: LD_VAR 0 1
107901: PPUSH
107902: CALL_OW 250
107906: PPUSH
107907: LD_VAR 0 10
107911: PPUSH
107912: LD_VAR 0 5
107916: PPUSH
107917: CALL_OW 272
107921: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107922: LD_ADDR_VAR 0 9
107926: PUSH
107927: LD_VAR 0 1
107931: PPUSH
107932: CALL_OW 251
107936: PPUSH
107937: LD_VAR 0 10
107941: PPUSH
107942: LD_VAR 0 5
107946: PPUSH
107947: CALL_OW 273
107951: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107952: LD_VAR 0 8
107956: PPUSH
107957: LD_VAR 0 9
107961: PPUSH
107962: CALL_OW 488
107966: NOT
107967: IFFALSE 107971
// exit ;
107969: GO 108078
// ComAnimCustom ( unit , 1 ) ;
107971: LD_VAR 0 1
107975: PPUSH
107976: LD_INT 1
107978: PPUSH
107979: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107983: LD_VAR 0 8
107987: PPUSH
107988: LD_VAR 0 9
107992: PPUSH
107993: LD_VAR 0 6
107997: PPUSH
107998: LD_VAR 0 7
108002: PPUSH
108003: CALL_OW 330
// repeat wait ( 1 ) ;
108007: LD_INT 1
108009: PPUSH
108010: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
108014: LD_VAR 0 1
108018: PPUSH
108019: CALL_OW 316
108023: PUSH
108024: LD_VAR 0 1
108028: PPUSH
108029: CALL_OW 314
108033: OR
108034: PUSH
108035: LD_VAR 0 1
108039: PPUSH
108040: CALL_OW 302
108044: NOT
108045: OR
108046: PUSH
108047: LD_VAR 0 1
108051: PPUSH
108052: CALL_OW 301
108056: OR
108057: IFFALSE 108007
// RemoveSeeing ( _x , _y , side ) ;
108059: LD_VAR 0 8
108063: PPUSH
108064: LD_VAR 0 9
108068: PPUSH
108069: LD_VAR 0 6
108073: PPUSH
108074: CALL_OW 331
// end ; end_of_file
108078: LD_VAR 0 4
108082: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
108083: LD_INT 0
108085: PPUSH
108086: PPUSH
108087: PPUSH
108088: PPUSH
108089: PPUSH
108090: PPUSH
108091: PPUSH
108092: PPUSH
108093: PPUSH
108094: PPUSH
108095: PPUSH
108096: PPUSH
108097: PPUSH
108098: PPUSH
108099: PPUSH
108100: PPUSH
108101: PPUSH
108102: PPUSH
108103: PPUSH
108104: PPUSH
108105: PPUSH
108106: PPUSH
108107: PPUSH
108108: PPUSH
108109: PPUSH
108110: PPUSH
108111: PPUSH
108112: PPUSH
108113: PPUSH
108114: PPUSH
108115: PPUSH
108116: PPUSH
108117: PPUSH
108118: PPUSH
// if not list then
108119: LD_VAR 0 1
108123: NOT
108124: IFFALSE 108128
// exit ;
108126: GO 112787
// base := list [ 1 ] ;
108128: LD_ADDR_VAR 0 3
108132: PUSH
108133: LD_VAR 0 1
108137: PUSH
108138: LD_INT 1
108140: ARRAY
108141: ST_TO_ADDR
// group := list [ 2 ] ;
108142: LD_ADDR_VAR 0 4
108146: PUSH
108147: LD_VAR 0 1
108151: PUSH
108152: LD_INT 2
108154: ARRAY
108155: ST_TO_ADDR
// path := list [ 3 ] ;
108156: LD_ADDR_VAR 0 5
108160: PUSH
108161: LD_VAR 0 1
108165: PUSH
108166: LD_INT 3
108168: ARRAY
108169: ST_TO_ADDR
// flags := list [ 4 ] ;
108170: LD_ADDR_VAR 0 6
108174: PUSH
108175: LD_VAR 0 1
108179: PUSH
108180: LD_INT 4
108182: ARRAY
108183: ST_TO_ADDR
// mined := [ ] ;
108184: LD_ADDR_VAR 0 27
108188: PUSH
108189: EMPTY
108190: ST_TO_ADDR
// bombed := [ ] ;
108191: LD_ADDR_VAR 0 28
108195: PUSH
108196: EMPTY
108197: ST_TO_ADDR
// healers := [ ] ;
108198: LD_ADDR_VAR 0 31
108202: PUSH
108203: EMPTY
108204: ST_TO_ADDR
// to_heal := [ ] ;
108205: LD_ADDR_VAR 0 30
108209: PUSH
108210: EMPTY
108211: ST_TO_ADDR
// repairs := [ ] ;
108212: LD_ADDR_VAR 0 33
108216: PUSH
108217: EMPTY
108218: ST_TO_ADDR
// to_repair := [ ] ;
108219: LD_ADDR_VAR 0 32
108223: PUSH
108224: EMPTY
108225: ST_TO_ADDR
// if not group or not path then
108226: LD_VAR 0 4
108230: NOT
108231: PUSH
108232: LD_VAR 0 5
108236: NOT
108237: OR
108238: IFFALSE 108242
// exit ;
108240: GO 112787
// side := GetSide ( group [ 1 ] ) ;
108242: LD_ADDR_VAR 0 35
108246: PUSH
108247: LD_VAR 0 4
108251: PUSH
108252: LD_INT 1
108254: ARRAY
108255: PPUSH
108256: CALL_OW 255
108260: ST_TO_ADDR
// if flags then
108261: LD_VAR 0 6
108265: IFFALSE 108409
// begin f_ignore_area := flags [ 1 ] ;
108267: LD_ADDR_VAR 0 17
108271: PUSH
108272: LD_VAR 0 6
108276: PUSH
108277: LD_INT 1
108279: ARRAY
108280: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108281: LD_ADDR_VAR 0 18
108285: PUSH
108286: LD_VAR 0 6
108290: PUSH
108291: LD_INT 2
108293: ARRAY
108294: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108295: LD_ADDR_VAR 0 19
108299: PUSH
108300: LD_VAR 0 6
108304: PUSH
108305: LD_INT 3
108307: ARRAY
108308: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108309: LD_ADDR_VAR 0 20
108313: PUSH
108314: LD_VAR 0 6
108318: PUSH
108319: LD_INT 4
108321: ARRAY
108322: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108323: LD_ADDR_VAR 0 21
108327: PUSH
108328: LD_VAR 0 6
108332: PUSH
108333: LD_INT 5
108335: ARRAY
108336: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108337: LD_ADDR_VAR 0 22
108341: PUSH
108342: LD_VAR 0 6
108346: PUSH
108347: LD_INT 6
108349: ARRAY
108350: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108351: LD_ADDR_VAR 0 23
108355: PUSH
108356: LD_VAR 0 6
108360: PUSH
108361: LD_INT 7
108363: ARRAY
108364: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108365: LD_ADDR_VAR 0 24
108369: PUSH
108370: LD_VAR 0 6
108374: PUSH
108375: LD_INT 8
108377: ARRAY
108378: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108379: LD_ADDR_VAR 0 25
108383: PUSH
108384: LD_VAR 0 6
108388: PUSH
108389: LD_INT 9
108391: ARRAY
108392: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108393: LD_ADDR_VAR 0 26
108397: PUSH
108398: LD_VAR 0 6
108402: PUSH
108403: LD_INT 10
108405: ARRAY
108406: ST_TO_ADDR
// end else
108407: GO 108489
// begin f_ignore_area := false ;
108409: LD_ADDR_VAR 0 17
108413: PUSH
108414: LD_INT 0
108416: ST_TO_ADDR
// f_capture := false ;
108417: LD_ADDR_VAR 0 18
108421: PUSH
108422: LD_INT 0
108424: ST_TO_ADDR
// f_ignore_civ := false ;
108425: LD_ADDR_VAR 0 19
108429: PUSH
108430: LD_INT 0
108432: ST_TO_ADDR
// f_murder := false ;
108433: LD_ADDR_VAR 0 20
108437: PUSH
108438: LD_INT 0
108440: ST_TO_ADDR
// f_mines := false ;
108441: LD_ADDR_VAR 0 21
108445: PUSH
108446: LD_INT 0
108448: ST_TO_ADDR
// f_repair := false ;
108449: LD_ADDR_VAR 0 22
108453: PUSH
108454: LD_INT 0
108456: ST_TO_ADDR
// f_heal := false ;
108457: LD_ADDR_VAR 0 23
108461: PUSH
108462: LD_INT 0
108464: ST_TO_ADDR
// f_spacetime := false ;
108465: LD_ADDR_VAR 0 24
108469: PUSH
108470: LD_INT 0
108472: ST_TO_ADDR
// f_attack_depot := false ;
108473: LD_ADDR_VAR 0 25
108477: PUSH
108478: LD_INT 0
108480: ST_TO_ADDR
// f_crawl := false ;
108481: LD_ADDR_VAR 0 26
108485: PUSH
108486: LD_INT 0
108488: ST_TO_ADDR
// end ; if f_heal then
108489: LD_VAR 0 23
108493: IFFALSE 108520
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108495: LD_ADDR_VAR 0 31
108499: PUSH
108500: LD_VAR 0 4
108504: PPUSH
108505: LD_INT 25
108507: PUSH
108508: LD_INT 4
108510: PUSH
108511: EMPTY
108512: LIST
108513: LIST
108514: PPUSH
108515: CALL_OW 72
108519: ST_TO_ADDR
// if f_repair then
108520: LD_VAR 0 22
108524: IFFALSE 108551
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108526: LD_ADDR_VAR 0 33
108530: PUSH
108531: LD_VAR 0 4
108535: PPUSH
108536: LD_INT 25
108538: PUSH
108539: LD_INT 3
108541: PUSH
108542: EMPTY
108543: LIST
108544: LIST
108545: PPUSH
108546: CALL_OW 72
108550: ST_TO_ADDR
// units_path := [ ] ;
108551: LD_ADDR_VAR 0 16
108555: PUSH
108556: EMPTY
108557: ST_TO_ADDR
// for i = 1 to group do
108558: LD_ADDR_VAR 0 7
108562: PUSH
108563: DOUBLE
108564: LD_INT 1
108566: DEC
108567: ST_TO_ADDR
108568: LD_VAR 0 4
108572: PUSH
108573: FOR_TO
108574: IFFALSE 108603
// units_path := Replace ( units_path , i , path ) ;
108576: LD_ADDR_VAR 0 16
108580: PUSH
108581: LD_VAR 0 16
108585: PPUSH
108586: LD_VAR 0 7
108590: PPUSH
108591: LD_VAR 0 5
108595: PPUSH
108596: CALL_OW 1
108600: ST_TO_ADDR
108601: GO 108573
108603: POP
108604: POP
// repeat for i = group downto 1 do
108605: LD_ADDR_VAR 0 7
108609: PUSH
108610: DOUBLE
108611: LD_VAR 0 4
108615: INC
108616: ST_TO_ADDR
108617: LD_INT 1
108619: PUSH
108620: FOR_DOWNTO
108621: IFFALSE 112743
// begin wait ( 5 ) ;
108623: LD_INT 5
108625: PPUSH
108626: CALL_OW 67
// tmp := [ ] ;
108630: LD_ADDR_VAR 0 14
108634: PUSH
108635: EMPTY
108636: ST_TO_ADDR
// attacking := false ;
108637: LD_ADDR_VAR 0 29
108641: PUSH
108642: LD_INT 0
108644: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108645: LD_VAR 0 4
108649: PUSH
108650: LD_VAR 0 7
108654: ARRAY
108655: PPUSH
108656: CALL_OW 301
108660: PUSH
108661: LD_VAR 0 4
108665: PUSH
108666: LD_VAR 0 7
108670: ARRAY
108671: NOT
108672: OR
108673: IFFALSE 108782
// begin if GetType ( group [ i ] ) = unit_human then
108675: LD_VAR 0 4
108679: PUSH
108680: LD_VAR 0 7
108684: ARRAY
108685: PPUSH
108686: CALL_OW 247
108690: PUSH
108691: LD_INT 1
108693: EQUAL
108694: IFFALSE 108740
// begin to_heal := to_heal diff group [ i ] ;
108696: LD_ADDR_VAR 0 30
108700: PUSH
108701: LD_VAR 0 30
108705: PUSH
108706: LD_VAR 0 4
108710: PUSH
108711: LD_VAR 0 7
108715: ARRAY
108716: DIFF
108717: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108718: LD_ADDR_VAR 0 31
108722: PUSH
108723: LD_VAR 0 31
108727: PUSH
108728: LD_VAR 0 4
108732: PUSH
108733: LD_VAR 0 7
108737: ARRAY
108738: DIFF
108739: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108740: LD_ADDR_VAR 0 4
108744: PUSH
108745: LD_VAR 0 4
108749: PPUSH
108750: LD_VAR 0 7
108754: PPUSH
108755: CALL_OW 3
108759: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108760: LD_ADDR_VAR 0 16
108764: PUSH
108765: LD_VAR 0 16
108769: PPUSH
108770: LD_VAR 0 7
108774: PPUSH
108775: CALL_OW 3
108779: ST_TO_ADDR
// continue ;
108780: GO 108620
// end ; if f_repair then
108782: LD_VAR 0 22
108786: IFFALSE 109275
// begin if GetType ( group [ i ] ) = unit_vehicle then
108788: LD_VAR 0 4
108792: PUSH
108793: LD_VAR 0 7
108797: ARRAY
108798: PPUSH
108799: CALL_OW 247
108803: PUSH
108804: LD_INT 2
108806: EQUAL
108807: IFFALSE 108997
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108809: LD_VAR 0 4
108813: PUSH
108814: LD_VAR 0 7
108818: ARRAY
108819: PPUSH
108820: CALL_OW 256
108824: PUSH
108825: LD_INT 700
108827: LESS
108828: PUSH
108829: LD_VAR 0 4
108833: PUSH
108834: LD_VAR 0 7
108838: ARRAY
108839: PUSH
108840: LD_VAR 0 32
108844: IN
108845: NOT
108846: AND
108847: IFFALSE 108871
// to_repair := to_repair union group [ i ] ;
108849: LD_ADDR_VAR 0 32
108853: PUSH
108854: LD_VAR 0 32
108858: PUSH
108859: LD_VAR 0 4
108863: PUSH
108864: LD_VAR 0 7
108868: ARRAY
108869: UNION
108870: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108871: LD_VAR 0 4
108875: PUSH
108876: LD_VAR 0 7
108880: ARRAY
108881: PPUSH
108882: CALL_OW 256
108886: PUSH
108887: LD_INT 1000
108889: EQUAL
108890: PUSH
108891: LD_VAR 0 4
108895: PUSH
108896: LD_VAR 0 7
108900: ARRAY
108901: PUSH
108902: LD_VAR 0 32
108906: IN
108907: AND
108908: IFFALSE 108932
// to_repair := to_repair diff group [ i ] ;
108910: LD_ADDR_VAR 0 32
108914: PUSH
108915: LD_VAR 0 32
108919: PUSH
108920: LD_VAR 0 4
108924: PUSH
108925: LD_VAR 0 7
108929: ARRAY
108930: DIFF
108931: ST_TO_ADDR
// if group [ i ] in to_repair then
108932: LD_VAR 0 4
108936: PUSH
108937: LD_VAR 0 7
108941: ARRAY
108942: PUSH
108943: LD_VAR 0 32
108947: IN
108948: IFFALSE 108995
// begin if not IsInArea ( group [ i ] , f_repair ) then
108950: LD_VAR 0 4
108954: PUSH
108955: LD_VAR 0 7
108959: ARRAY
108960: PPUSH
108961: LD_VAR 0 22
108965: PPUSH
108966: CALL_OW 308
108970: NOT
108971: IFFALSE 108993
// ComMoveToArea ( group [ i ] , f_repair ) ;
108973: LD_VAR 0 4
108977: PUSH
108978: LD_VAR 0 7
108982: ARRAY
108983: PPUSH
108984: LD_VAR 0 22
108988: PPUSH
108989: CALL_OW 113
// continue ;
108993: GO 108620
// end ; end else
108995: GO 109275
// if group [ i ] in repairs then
108997: LD_VAR 0 4
109001: PUSH
109002: LD_VAR 0 7
109006: ARRAY
109007: PUSH
109008: LD_VAR 0 33
109012: IN
109013: IFFALSE 109275
// begin if IsInUnit ( group [ i ] ) then
109015: LD_VAR 0 4
109019: PUSH
109020: LD_VAR 0 7
109024: ARRAY
109025: PPUSH
109026: CALL_OW 310
109030: IFFALSE 109098
// begin z := IsInUnit ( group [ i ] ) ;
109032: LD_ADDR_VAR 0 13
109036: PUSH
109037: LD_VAR 0 4
109041: PUSH
109042: LD_VAR 0 7
109046: ARRAY
109047: PPUSH
109048: CALL_OW 310
109052: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
109053: LD_VAR 0 13
109057: PUSH
109058: LD_VAR 0 32
109062: IN
109063: PUSH
109064: LD_VAR 0 13
109068: PPUSH
109069: LD_VAR 0 22
109073: PPUSH
109074: CALL_OW 308
109078: AND
109079: IFFALSE 109096
// ComExitVehicle ( group [ i ] ) ;
109081: LD_VAR 0 4
109085: PUSH
109086: LD_VAR 0 7
109090: ARRAY
109091: PPUSH
109092: CALL_OW 121
// end else
109096: GO 109275
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
109098: LD_ADDR_VAR 0 13
109102: PUSH
109103: LD_VAR 0 4
109107: PPUSH
109108: LD_INT 95
109110: PUSH
109111: LD_VAR 0 22
109115: PUSH
109116: EMPTY
109117: LIST
109118: LIST
109119: PUSH
109120: LD_INT 58
109122: PUSH
109123: EMPTY
109124: LIST
109125: PUSH
109126: EMPTY
109127: LIST
109128: LIST
109129: PPUSH
109130: CALL_OW 72
109134: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
109135: LD_VAR 0 4
109139: PUSH
109140: LD_VAR 0 7
109144: ARRAY
109145: PPUSH
109146: CALL_OW 314
109150: NOT
109151: IFFALSE 109273
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
109153: LD_ADDR_VAR 0 10
109157: PUSH
109158: LD_VAR 0 13
109162: PPUSH
109163: LD_VAR 0 4
109167: PUSH
109168: LD_VAR 0 7
109172: ARRAY
109173: PPUSH
109174: CALL_OW 74
109178: ST_TO_ADDR
// if not x then
109179: LD_VAR 0 10
109183: NOT
109184: IFFALSE 109188
// continue ;
109186: GO 108620
// if GetLives ( x ) < 1000 then
109188: LD_VAR 0 10
109192: PPUSH
109193: CALL_OW 256
109197: PUSH
109198: LD_INT 1000
109200: LESS
109201: IFFALSE 109225
// ComRepairVehicle ( group [ i ] , x ) else
109203: LD_VAR 0 4
109207: PUSH
109208: LD_VAR 0 7
109212: ARRAY
109213: PPUSH
109214: LD_VAR 0 10
109218: PPUSH
109219: CALL_OW 129
109223: GO 109273
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
109225: LD_VAR 0 23
109229: PUSH
109230: LD_VAR 0 4
109234: PUSH
109235: LD_VAR 0 7
109239: ARRAY
109240: PPUSH
109241: CALL_OW 256
109245: PUSH
109246: LD_INT 1000
109248: LESS
109249: AND
109250: NOT
109251: IFFALSE 109273
// ComEnterUnit ( group [ i ] , x ) ;
109253: LD_VAR 0 4
109257: PUSH
109258: LD_VAR 0 7
109262: ARRAY
109263: PPUSH
109264: LD_VAR 0 10
109268: PPUSH
109269: CALL_OW 120
// end ; continue ;
109273: GO 108620
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109275: LD_VAR 0 23
109279: PUSH
109280: LD_VAR 0 4
109284: PUSH
109285: LD_VAR 0 7
109289: ARRAY
109290: PPUSH
109291: CALL_OW 247
109295: PUSH
109296: LD_INT 1
109298: EQUAL
109299: AND
109300: IFFALSE 109778
// begin if group [ i ] in healers then
109302: LD_VAR 0 4
109306: PUSH
109307: LD_VAR 0 7
109311: ARRAY
109312: PUSH
109313: LD_VAR 0 31
109317: IN
109318: IFFALSE 109591
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109320: LD_VAR 0 4
109324: PUSH
109325: LD_VAR 0 7
109329: ARRAY
109330: PPUSH
109331: LD_VAR 0 23
109335: PPUSH
109336: CALL_OW 308
109340: NOT
109341: PUSH
109342: LD_VAR 0 4
109346: PUSH
109347: LD_VAR 0 7
109351: ARRAY
109352: PPUSH
109353: CALL_OW 314
109357: NOT
109358: AND
109359: IFFALSE 109383
// ComMoveToArea ( group [ i ] , f_heal ) else
109361: LD_VAR 0 4
109365: PUSH
109366: LD_VAR 0 7
109370: ARRAY
109371: PPUSH
109372: LD_VAR 0 23
109376: PPUSH
109377: CALL_OW 113
109381: GO 109589
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109383: LD_VAR 0 4
109387: PUSH
109388: LD_VAR 0 7
109392: ARRAY
109393: PPUSH
109394: CALL 85407 0 1
109398: PPUSH
109399: CALL_OW 256
109403: PUSH
109404: LD_INT 1000
109406: EQUAL
109407: IFFALSE 109426
// ComStop ( group [ i ] ) else
109409: LD_VAR 0 4
109413: PUSH
109414: LD_VAR 0 7
109418: ARRAY
109419: PPUSH
109420: CALL_OW 141
109424: GO 109589
// if not HasTask ( group [ i ] ) and to_heal then
109426: LD_VAR 0 4
109430: PUSH
109431: LD_VAR 0 7
109435: ARRAY
109436: PPUSH
109437: CALL_OW 314
109441: NOT
109442: PUSH
109443: LD_VAR 0 30
109447: AND
109448: IFFALSE 109589
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109450: LD_ADDR_VAR 0 13
109454: PUSH
109455: LD_VAR 0 30
109459: PPUSH
109460: LD_INT 3
109462: PUSH
109463: LD_INT 54
109465: PUSH
109466: EMPTY
109467: LIST
109468: PUSH
109469: EMPTY
109470: LIST
109471: LIST
109472: PPUSH
109473: CALL_OW 72
109477: PPUSH
109478: LD_VAR 0 4
109482: PUSH
109483: LD_VAR 0 7
109487: ARRAY
109488: PPUSH
109489: CALL_OW 74
109493: ST_TO_ADDR
// if z then
109494: LD_VAR 0 13
109498: IFFALSE 109589
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109500: LD_INT 91
109502: PUSH
109503: LD_VAR 0 13
109507: PUSH
109508: LD_INT 10
109510: PUSH
109511: EMPTY
109512: LIST
109513: LIST
109514: LIST
109515: PUSH
109516: LD_INT 81
109518: PUSH
109519: LD_VAR 0 13
109523: PPUSH
109524: CALL_OW 255
109528: PUSH
109529: EMPTY
109530: LIST
109531: LIST
109532: PUSH
109533: EMPTY
109534: LIST
109535: LIST
109536: PPUSH
109537: CALL_OW 69
109541: PUSH
109542: LD_INT 0
109544: EQUAL
109545: IFFALSE 109569
// ComHeal ( group [ i ] , z ) else
109547: LD_VAR 0 4
109551: PUSH
109552: LD_VAR 0 7
109556: ARRAY
109557: PPUSH
109558: LD_VAR 0 13
109562: PPUSH
109563: CALL_OW 128
109567: GO 109589
// ComMoveToArea ( group [ i ] , f_heal ) ;
109569: LD_VAR 0 4
109573: PUSH
109574: LD_VAR 0 7
109578: ARRAY
109579: PPUSH
109580: LD_VAR 0 23
109584: PPUSH
109585: CALL_OW 113
// end ; continue ;
109589: GO 108620
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109591: LD_VAR 0 4
109595: PUSH
109596: LD_VAR 0 7
109600: ARRAY
109601: PPUSH
109602: CALL_OW 256
109606: PUSH
109607: LD_INT 700
109609: LESS
109610: PUSH
109611: LD_VAR 0 4
109615: PUSH
109616: LD_VAR 0 7
109620: ARRAY
109621: PUSH
109622: LD_VAR 0 30
109626: IN
109627: NOT
109628: AND
109629: IFFALSE 109653
// to_heal := to_heal union group [ i ] ;
109631: LD_ADDR_VAR 0 30
109635: PUSH
109636: LD_VAR 0 30
109640: PUSH
109641: LD_VAR 0 4
109645: PUSH
109646: LD_VAR 0 7
109650: ARRAY
109651: UNION
109652: ST_TO_ADDR
// if group [ i ] in to_heal then
109653: LD_VAR 0 4
109657: PUSH
109658: LD_VAR 0 7
109662: ARRAY
109663: PUSH
109664: LD_VAR 0 30
109668: IN
109669: IFFALSE 109778
// begin if GetLives ( group [ i ] ) = 1000 then
109671: LD_VAR 0 4
109675: PUSH
109676: LD_VAR 0 7
109680: ARRAY
109681: PPUSH
109682: CALL_OW 256
109686: PUSH
109687: LD_INT 1000
109689: EQUAL
109690: IFFALSE 109716
// to_heal := to_heal diff group [ i ] else
109692: LD_ADDR_VAR 0 30
109696: PUSH
109697: LD_VAR 0 30
109701: PUSH
109702: LD_VAR 0 4
109706: PUSH
109707: LD_VAR 0 7
109711: ARRAY
109712: DIFF
109713: ST_TO_ADDR
109714: GO 109778
// begin if not IsInArea ( group [ i ] , to_heal ) then
109716: LD_VAR 0 4
109720: PUSH
109721: LD_VAR 0 7
109725: ARRAY
109726: PPUSH
109727: LD_VAR 0 30
109731: PPUSH
109732: CALL_OW 308
109736: NOT
109737: IFFALSE 109761
// ComMoveToArea ( group [ i ] , f_heal ) else
109739: LD_VAR 0 4
109743: PUSH
109744: LD_VAR 0 7
109748: ARRAY
109749: PPUSH
109750: LD_VAR 0 23
109754: PPUSH
109755: CALL_OW 113
109759: GO 109776
// ComHold ( group [ i ] ) ;
109761: LD_VAR 0 4
109765: PUSH
109766: LD_VAR 0 7
109770: ARRAY
109771: PPUSH
109772: CALL_OW 140
// continue ;
109776: GO 108620
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109778: LD_VAR 0 4
109782: PUSH
109783: LD_VAR 0 7
109787: ARRAY
109788: PPUSH
109789: LD_INT 10
109791: PPUSH
109792: CALL 83827 0 2
109796: NOT
109797: PUSH
109798: LD_VAR 0 16
109802: PUSH
109803: LD_VAR 0 7
109807: ARRAY
109808: PUSH
109809: EMPTY
109810: EQUAL
109811: NOT
109812: AND
109813: IFFALSE 110079
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109815: LD_VAR 0 4
109819: PUSH
109820: LD_VAR 0 7
109824: ARRAY
109825: PPUSH
109826: CALL_OW 262
109830: PUSH
109831: LD_INT 1
109833: PUSH
109834: LD_INT 2
109836: PUSH
109837: EMPTY
109838: LIST
109839: LIST
109840: IN
109841: IFFALSE 109882
// if GetFuel ( group [ i ] ) < 10 then
109843: LD_VAR 0 4
109847: PUSH
109848: LD_VAR 0 7
109852: ARRAY
109853: PPUSH
109854: CALL_OW 261
109858: PUSH
109859: LD_INT 10
109861: LESS
109862: IFFALSE 109882
// SetFuel ( group [ i ] , 12 ) ;
109864: LD_VAR 0 4
109868: PUSH
109869: LD_VAR 0 7
109873: ARRAY
109874: PPUSH
109875: LD_INT 12
109877: PPUSH
109878: CALL_OW 240
// if units_path [ i ] then
109882: LD_VAR 0 16
109886: PUSH
109887: LD_VAR 0 7
109891: ARRAY
109892: IFFALSE 110077
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109894: LD_VAR 0 4
109898: PUSH
109899: LD_VAR 0 7
109903: ARRAY
109904: PPUSH
109905: LD_VAR 0 16
109909: PUSH
109910: LD_VAR 0 7
109914: ARRAY
109915: PUSH
109916: LD_INT 1
109918: ARRAY
109919: PUSH
109920: LD_INT 1
109922: ARRAY
109923: PPUSH
109924: LD_VAR 0 16
109928: PUSH
109929: LD_VAR 0 7
109933: ARRAY
109934: PUSH
109935: LD_INT 1
109937: ARRAY
109938: PUSH
109939: LD_INT 2
109941: ARRAY
109942: PPUSH
109943: CALL_OW 297
109947: PUSH
109948: LD_INT 6
109950: GREATER
109951: IFFALSE 110026
// begin if not HasTask ( group [ i ] ) then
109953: LD_VAR 0 4
109957: PUSH
109958: LD_VAR 0 7
109962: ARRAY
109963: PPUSH
109964: CALL_OW 314
109968: NOT
109969: IFFALSE 110024
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109971: LD_VAR 0 4
109975: PUSH
109976: LD_VAR 0 7
109980: ARRAY
109981: PPUSH
109982: LD_VAR 0 16
109986: PUSH
109987: LD_VAR 0 7
109991: ARRAY
109992: PUSH
109993: LD_INT 1
109995: ARRAY
109996: PUSH
109997: LD_INT 1
109999: ARRAY
110000: PPUSH
110001: LD_VAR 0 16
110005: PUSH
110006: LD_VAR 0 7
110010: ARRAY
110011: PUSH
110012: LD_INT 1
110014: ARRAY
110015: PUSH
110016: LD_INT 2
110018: ARRAY
110019: PPUSH
110020: CALL_OW 114
// end else
110024: GO 110077
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
110026: LD_ADDR_VAR 0 15
110030: PUSH
110031: LD_VAR 0 16
110035: PUSH
110036: LD_VAR 0 7
110040: ARRAY
110041: PPUSH
110042: LD_INT 1
110044: PPUSH
110045: CALL_OW 3
110049: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
110050: LD_ADDR_VAR 0 16
110054: PUSH
110055: LD_VAR 0 16
110059: PPUSH
110060: LD_VAR 0 7
110064: PPUSH
110065: LD_VAR 0 15
110069: PPUSH
110070: CALL_OW 1
110074: ST_TO_ADDR
// continue ;
110075: GO 108620
// end ; end ; end else
110077: GO 112741
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
110079: LD_ADDR_VAR 0 14
110083: PUSH
110084: LD_INT 81
110086: PUSH
110087: LD_VAR 0 4
110091: PUSH
110092: LD_VAR 0 7
110096: ARRAY
110097: PPUSH
110098: CALL_OW 255
110102: PUSH
110103: EMPTY
110104: LIST
110105: LIST
110106: PPUSH
110107: CALL_OW 69
110111: ST_TO_ADDR
// if not tmp then
110112: LD_VAR 0 14
110116: NOT
110117: IFFALSE 110121
// continue ;
110119: GO 108620
// if f_ignore_area then
110121: LD_VAR 0 17
110125: IFFALSE 110213
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
110127: LD_ADDR_VAR 0 15
110131: PUSH
110132: LD_VAR 0 14
110136: PPUSH
110137: LD_INT 3
110139: PUSH
110140: LD_INT 92
110142: PUSH
110143: LD_VAR 0 17
110147: PUSH
110148: LD_INT 1
110150: ARRAY
110151: PUSH
110152: LD_VAR 0 17
110156: PUSH
110157: LD_INT 2
110159: ARRAY
110160: PUSH
110161: LD_VAR 0 17
110165: PUSH
110166: LD_INT 3
110168: ARRAY
110169: PUSH
110170: EMPTY
110171: LIST
110172: LIST
110173: LIST
110174: LIST
110175: PUSH
110176: EMPTY
110177: LIST
110178: LIST
110179: PPUSH
110180: CALL_OW 72
110184: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110185: LD_VAR 0 14
110189: PUSH
110190: LD_VAR 0 15
110194: DIFF
110195: IFFALSE 110213
// tmp := tmp diff tmp2 ;
110197: LD_ADDR_VAR 0 14
110201: PUSH
110202: LD_VAR 0 14
110206: PUSH
110207: LD_VAR 0 15
110211: DIFF
110212: ST_TO_ADDR
// end ; if not f_murder then
110213: LD_VAR 0 20
110217: NOT
110218: IFFALSE 110276
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
110220: LD_ADDR_VAR 0 15
110224: PUSH
110225: LD_VAR 0 14
110229: PPUSH
110230: LD_INT 3
110232: PUSH
110233: LD_INT 50
110235: PUSH
110236: EMPTY
110237: LIST
110238: PUSH
110239: EMPTY
110240: LIST
110241: LIST
110242: PPUSH
110243: CALL_OW 72
110247: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110248: LD_VAR 0 14
110252: PUSH
110253: LD_VAR 0 15
110257: DIFF
110258: IFFALSE 110276
// tmp := tmp diff tmp2 ;
110260: LD_ADDR_VAR 0 14
110264: PUSH
110265: LD_VAR 0 14
110269: PUSH
110270: LD_VAR 0 15
110274: DIFF
110275: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110276: LD_ADDR_VAR 0 14
110280: PUSH
110281: LD_VAR 0 4
110285: PUSH
110286: LD_VAR 0 7
110290: ARRAY
110291: PPUSH
110292: LD_VAR 0 14
110296: PPUSH
110297: LD_INT 1
110299: PPUSH
110300: LD_INT 1
110302: PPUSH
110303: CALL 56762 0 4
110307: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110308: LD_VAR 0 4
110312: PUSH
110313: LD_VAR 0 7
110317: ARRAY
110318: PPUSH
110319: CALL_OW 257
110323: PUSH
110324: LD_INT 1
110326: EQUAL
110327: IFFALSE 110775
// begin if WantPlant ( group [ i ] ) then
110329: LD_VAR 0 4
110333: PUSH
110334: LD_VAR 0 7
110338: ARRAY
110339: PPUSH
110340: CALL 56263 0 1
110344: IFFALSE 110348
// continue ;
110346: GO 108620
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110348: LD_VAR 0 18
110352: PUSH
110353: LD_VAR 0 4
110357: PUSH
110358: LD_VAR 0 7
110362: ARRAY
110363: PPUSH
110364: CALL_OW 310
110368: NOT
110369: AND
110370: PUSH
110371: LD_VAR 0 14
110375: PUSH
110376: LD_INT 1
110378: ARRAY
110379: PUSH
110380: LD_VAR 0 14
110384: PPUSH
110385: LD_INT 21
110387: PUSH
110388: LD_INT 2
110390: PUSH
110391: EMPTY
110392: LIST
110393: LIST
110394: PUSH
110395: LD_INT 58
110397: PUSH
110398: EMPTY
110399: LIST
110400: PUSH
110401: EMPTY
110402: LIST
110403: LIST
110404: PPUSH
110405: CALL_OW 72
110409: IN
110410: AND
110411: IFFALSE 110447
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110413: LD_VAR 0 4
110417: PUSH
110418: LD_VAR 0 7
110422: ARRAY
110423: PPUSH
110424: LD_VAR 0 14
110428: PUSH
110429: LD_INT 1
110431: ARRAY
110432: PPUSH
110433: CALL_OW 120
// attacking := true ;
110437: LD_ADDR_VAR 0 29
110441: PUSH
110442: LD_INT 1
110444: ST_TO_ADDR
// continue ;
110445: GO 108620
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110447: LD_VAR 0 26
110451: PUSH
110452: LD_VAR 0 4
110456: PUSH
110457: LD_VAR 0 7
110461: ARRAY
110462: PPUSH
110463: CALL_OW 257
110467: PUSH
110468: LD_INT 1
110470: EQUAL
110471: AND
110472: PUSH
110473: LD_VAR 0 4
110477: PUSH
110478: LD_VAR 0 7
110482: ARRAY
110483: PPUSH
110484: CALL_OW 256
110488: PUSH
110489: LD_INT 800
110491: LESS
110492: AND
110493: PUSH
110494: LD_VAR 0 4
110498: PUSH
110499: LD_VAR 0 7
110503: ARRAY
110504: PPUSH
110505: CALL_OW 318
110509: NOT
110510: AND
110511: IFFALSE 110528
// ComCrawl ( group [ i ] ) ;
110513: LD_VAR 0 4
110517: PUSH
110518: LD_VAR 0 7
110522: ARRAY
110523: PPUSH
110524: CALL_OW 137
// if f_mines then
110528: LD_VAR 0 21
110532: IFFALSE 110775
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110534: LD_VAR 0 14
110538: PUSH
110539: LD_INT 1
110541: ARRAY
110542: PPUSH
110543: CALL_OW 247
110547: PUSH
110548: LD_INT 3
110550: EQUAL
110551: PUSH
110552: LD_VAR 0 14
110556: PUSH
110557: LD_INT 1
110559: ARRAY
110560: PUSH
110561: LD_VAR 0 27
110565: IN
110566: NOT
110567: AND
110568: IFFALSE 110775
// begin x := GetX ( tmp [ 1 ] ) ;
110570: LD_ADDR_VAR 0 10
110574: PUSH
110575: LD_VAR 0 14
110579: PUSH
110580: LD_INT 1
110582: ARRAY
110583: PPUSH
110584: CALL_OW 250
110588: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110589: LD_ADDR_VAR 0 11
110593: PUSH
110594: LD_VAR 0 14
110598: PUSH
110599: LD_INT 1
110601: ARRAY
110602: PPUSH
110603: CALL_OW 251
110607: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110608: LD_ADDR_VAR 0 12
110612: PUSH
110613: LD_VAR 0 4
110617: PUSH
110618: LD_VAR 0 7
110622: ARRAY
110623: PPUSH
110624: CALL 83912 0 1
110628: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110629: LD_VAR 0 4
110633: PUSH
110634: LD_VAR 0 7
110638: ARRAY
110639: PPUSH
110640: LD_VAR 0 10
110644: PPUSH
110645: LD_VAR 0 11
110649: PPUSH
110650: LD_VAR 0 14
110654: PUSH
110655: LD_INT 1
110657: ARRAY
110658: PPUSH
110659: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110663: LD_VAR 0 4
110667: PUSH
110668: LD_VAR 0 7
110672: ARRAY
110673: PPUSH
110674: LD_VAR 0 10
110678: PPUSH
110679: LD_VAR 0 12
110683: PPUSH
110684: LD_INT 7
110686: PPUSH
110687: CALL_OW 272
110691: PPUSH
110692: LD_VAR 0 11
110696: PPUSH
110697: LD_VAR 0 12
110701: PPUSH
110702: LD_INT 7
110704: PPUSH
110705: CALL_OW 273
110709: PPUSH
110710: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110714: LD_VAR 0 4
110718: PUSH
110719: LD_VAR 0 7
110723: ARRAY
110724: PPUSH
110725: LD_INT 71
110727: PPUSH
110728: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110732: LD_ADDR_VAR 0 27
110736: PUSH
110737: LD_VAR 0 27
110741: PPUSH
110742: LD_VAR 0 27
110746: PUSH
110747: LD_INT 1
110749: PLUS
110750: PPUSH
110751: LD_VAR 0 14
110755: PUSH
110756: LD_INT 1
110758: ARRAY
110759: PPUSH
110760: CALL_OW 1
110764: ST_TO_ADDR
// attacking := true ;
110765: LD_ADDR_VAR 0 29
110769: PUSH
110770: LD_INT 1
110772: ST_TO_ADDR
// continue ;
110773: GO 108620
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110775: LD_VAR 0 4
110779: PUSH
110780: LD_VAR 0 7
110784: ARRAY
110785: PPUSH
110786: CALL_OW 257
110790: PUSH
110791: LD_INT 17
110793: EQUAL
110794: PUSH
110795: LD_VAR 0 4
110799: PUSH
110800: LD_VAR 0 7
110804: ARRAY
110805: PPUSH
110806: CALL_OW 110
110810: PUSH
110811: LD_INT 71
110813: EQUAL
110814: NOT
110815: AND
110816: IFFALSE 110962
// begin attacking := false ;
110818: LD_ADDR_VAR 0 29
110822: PUSH
110823: LD_INT 0
110825: ST_TO_ADDR
// k := 5 ;
110826: LD_ADDR_VAR 0 9
110830: PUSH
110831: LD_INT 5
110833: ST_TO_ADDR
// if tmp < k then
110834: LD_VAR 0 14
110838: PUSH
110839: LD_VAR 0 9
110843: LESS
110844: IFFALSE 110856
// k := tmp ;
110846: LD_ADDR_VAR 0 9
110850: PUSH
110851: LD_VAR 0 14
110855: ST_TO_ADDR
// for j = 1 to k do
110856: LD_ADDR_VAR 0 8
110860: PUSH
110861: DOUBLE
110862: LD_INT 1
110864: DEC
110865: ST_TO_ADDR
110866: LD_VAR 0 9
110870: PUSH
110871: FOR_TO
110872: IFFALSE 110960
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110874: LD_VAR 0 14
110878: PUSH
110879: LD_VAR 0 8
110883: ARRAY
110884: PUSH
110885: LD_VAR 0 14
110889: PPUSH
110890: LD_INT 58
110892: PUSH
110893: EMPTY
110894: LIST
110895: PPUSH
110896: CALL_OW 72
110900: IN
110901: NOT
110902: IFFALSE 110958
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110904: LD_VAR 0 4
110908: PUSH
110909: LD_VAR 0 7
110913: ARRAY
110914: PPUSH
110915: LD_VAR 0 14
110919: PUSH
110920: LD_VAR 0 8
110924: ARRAY
110925: PPUSH
110926: CALL_OW 115
// attacking := true ;
110930: LD_ADDR_VAR 0 29
110934: PUSH
110935: LD_INT 1
110937: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110938: LD_VAR 0 4
110942: PUSH
110943: LD_VAR 0 7
110947: ARRAY
110948: PPUSH
110949: LD_INT 71
110951: PPUSH
110952: CALL_OW 109
// continue ;
110956: GO 110871
// end ; end ;
110958: GO 110871
110960: POP
110961: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110962: LD_VAR 0 4
110966: PUSH
110967: LD_VAR 0 7
110971: ARRAY
110972: PPUSH
110973: CALL_OW 257
110977: PUSH
110978: LD_INT 8
110980: EQUAL
110981: PUSH
110982: LD_VAR 0 4
110986: PUSH
110987: LD_VAR 0 7
110991: ARRAY
110992: PPUSH
110993: CALL_OW 264
110997: PUSH
110998: LD_INT 28
111000: PUSH
111001: LD_INT 45
111003: PUSH
111004: LD_INT 7
111006: PUSH
111007: LD_INT 47
111009: PUSH
111010: EMPTY
111011: LIST
111012: LIST
111013: LIST
111014: LIST
111015: IN
111016: OR
111017: IFFALSE 111273
// begin attacking := false ;
111019: LD_ADDR_VAR 0 29
111023: PUSH
111024: LD_INT 0
111026: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
111027: LD_VAR 0 14
111031: PUSH
111032: LD_INT 1
111034: ARRAY
111035: PPUSH
111036: CALL_OW 266
111040: PUSH
111041: LD_INT 32
111043: PUSH
111044: LD_INT 31
111046: PUSH
111047: LD_INT 33
111049: PUSH
111050: LD_INT 4
111052: PUSH
111053: LD_INT 5
111055: PUSH
111056: EMPTY
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: LIST
111062: IN
111063: IFFALSE 111249
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
111065: LD_ADDR_VAR 0 9
111069: PUSH
111070: LD_VAR 0 14
111074: PUSH
111075: LD_INT 1
111077: ARRAY
111078: PPUSH
111079: CALL_OW 266
111083: PPUSH
111084: LD_VAR 0 14
111088: PUSH
111089: LD_INT 1
111091: ARRAY
111092: PPUSH
111093: CALL_OW 250
111097: PPUSH
111098: LD_VAR 0 14
111102: PUSH
111103: LD_INT 1
111105: ARRAY
111106: PPUSH
111107: CALL_OW 251
111111: PPUSH
111112: LD_VAR 0 14
111116: PUSH
111117: LD_INT 1
111119: ARRAY
111120: PPUSH
111121: CALL_OW 254
111125: PPUSH
111126: LD_VAR 0 14
111130: PUSH
111131: LD_INT 1
111133: ARRAY
111134: PPUSH
111135: CALL_OW 248
111139: PPUSH
111140: LD_INT 0
111142: PPUSH
111143: CALL 65282 0 6
111147: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
111148: LD_ADDR_VAR 0 8
111152: PUSH
111153: LD_VAR 0 4
111157: PUSH
111158: LD_VAR 0 7
111162: ARRAY
111163: PPUSH
111164: LD_VAR 0 9
111168: PPUSH
111169: CALL 83952 0 2
111173: ST_TO_ADDR
// if j then
111174: LD_VAR 0 8
111178: IFFALSE 111247
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
111180: LD_VAR 0 8
111184: PUSH
111185: LD_INT 1
111187: ARRAY
111188: PPUSH
111189: LD_VAR 0 8
111193: PUSH
111194: LD_INT 2
111196: ARRAY
111197: PPUSH
111198: CALL_OW 488
111202: IFFALSE 111247
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
111204: LD_VAR 0 4
111208: PUSH
111209: LD_VAR 0 7
111213: ARRAY
111214: PPUSH
111215: LD_VAR 0 8
111219: PUSH
111220: LD_INT 1
111222: ARRAY
111223: PPUSH
111224: LD_VAR 0 8
111228: PUSH
111229: LD_INT 2
111231: ARRAY
111232: PPUSH
111233: CALL_OW 116
// attacking := true ;
111237: LD_ADDR_VAR 0 29
111241: PUSH
111242: LD_INT 1
111244: ST_TO_ADDR
// continue ;
111245: GO 108620
// end ; end else
111247: GO 111273
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111249: LD_VAR 0 4
111253: PUSH
111254: LD_VAR 0 7
111258: ARRAY
111259: PPUSH
111260: LD_VAR 0 14
111264: PUSH
111265: LD_INT 1
111267: ARRAY
111268: PPUSH
111269: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111273: LD_VAR 0 4
111277: PUSH
111278: LD_VAR 0 7
111282: ARRAY
111283: PPUSH
111284: CALL_OW 265
111288: PUSH
111289: LD_INT 11
111291: EQUAL
111292: IFFALSE 111570
// begin k := 10 ;
111294: LD_ADDR_VAR 0 9
111298: PUSH
111299: LD_INT 10
111301: ST_TO_ADDR
// x := 0 ;
111302: LD_ADDR_VAR 0 10
111306: PUSH
111307: LD_INT 0
111309: ST_TO_ADDR
// if tmp < k then
111310: LD_VAR 0 14
111314: PUSH
111315: LD_VAR 0 9
111319: LESS
111320: IFFALSE 111332
// k := tmp ;
111322: LD_ADDR_VAR 0 9
111326: PUSH
111327: LD_VAR 0 14
111331: ST_TO_ADDR
// for j = k downto 1 do
111332: LD_ADDR_VAR 0 8
111336: PUSH
111337: DOUBLE
111338: LD_VAR 0 9
111342: INC
111343: ST_TO_ADDR
111344: LD_INT 1
111346: PUSH
111347: FOR_DOWNTO
111348: IFFALSE 111423
// begin if GetType ( tmp [ j ] ) = unit_human then
111350: LD_VAR 0 14
111354: PUSH
111355: LD_VAR 0 8
111359: ARRAY
111360: PPUSH
111361: CALL_OW 247
111365: PUSH
111366: LD_INT 1
111368: EQUAL
111369: IFFALSE 111421
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111371: LD_VAR 0 4
111375: PUSH
111376: LD_VAR 0 7
111380: ARRAY
111381: PPUSH
111382: LD_VAR 0 14
111386: PUSH
111387: LD_VAR 0 8
111391: ARRAY
111392: PPUSH
111393: CALL 84223 0 2
// x := tmp [ j ] ;
111397: LD_ADDR_VAR 0 10
111401: PUSH
111402: LD_VAR 0 14
111406: PUSH
111407: LD_VAR 0 8
111411: ARRAY
111412: ST_TO_ADDR
// attacking := true ;
111413: LD_ADDR_VAR 0 29
111417: PUSH
111418: LD_INT 1
111420: ST_TO_ADDR
// end ; end ;
111421: GO 111347
111423: POP
111424: POP
// if not x then
111425: LD_VAR 0 10
111429: NOT
111430: IFFALSE 111570
// begin attacking := true ;
111432: LD_ADDR_VAR 0 29
111436: PUSH
111437: LD_INT 1
111439: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111440: LD_VAR 0 4
111444: PUSH
111445: LD_VAR 0 7
111449: ARRAY
111450: PPUSH
111451: CALL_OW 250
111455: PPUSH
111456: LD_VAR 0 4
111460: PUSH
111461: LD_VAR 0 7
111465: ARRAY
111466: PPUSH
111467: CALL_OW 251
111471: PPUSH
111472: CALL_OW 546
111476: PUSH
111477: LD_INT 2
111479: ARRAY
111480: PUSH
111481: LD_VAR 0 14
111485: PUSH
111486: LD_INT 1
111488: ARRAY
111489: PPUSH
111490: CALL_OW 250
111494: PPUSH
111495: LD_VAR 0 14
111499: PUSH
111500: LD_INT 1
111502: ARRAY
111503: PPUSH
111504: CALL_OW 251
111508: PPUSH
111509: CALL_OW 546
111513: PUSH
111514: LD_INT 2
111516: ARRAY
111517: EQUAL
111518: IFFALSE 111546
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111520: LD_VAR 0 4
111524: PUSH
111525: LD_VAR 0 7
111529: ARRAY
111530: PPUSH
111531: LD_VAR 0 14
111535: PUSH
111536: LD_INT 1
111538: ARRAY
111539: PPUSH
111540: CALL 84223 0 2
111544: GO 111570
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111546: LD_VAR 0 4
111550: PUSH
111551: LD_VAR 0 7
111555: ARRAY
111556: PPUSH
111557: LD_VAR 0 14
111561: PUSH
111562: LD_INT 1
111564: ARRAY
111565: PPUSH
111566: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111570: LD_VAR 0 4
111574: PUSH
111575: LD_VAR 0 7
111579: ARRAY
111580: PPUSH
111581: CALL_OW 264
111585: PUSH
111586: LD_INT 29
111588: EQUAL
111589: IFFALSE 111955
// begin if WantsToAttack ( group [ i ] ) in bombed then
111591: LD_VAR 0 4
111595: PUSH
111596: LD_VAR 0 7
111600: ARRAY
111601: PPUSH
111602: CALL_OW 319
111606: PUSH
111607: LD_VAR 0 28
111611: IN
111612: IFFALSE 111616
// continue ;
111614: GO 108620
// k := 8 ;
111616: LD_ADDR_VAR 0 9
111620: PUSH
111621: LD_INT 8
111623: ST_TO_ADDR
// x := 0 ;
111624: LD_ADDR_VAR 0 10
111628: PUSH
111629: LD_INT 0
111631: ST_TO_ADDR
// if tmp < k then
111632: LD_VAR 0 14
111636: PUSH
111637: LD_VAR 0 9
111641: LESS
111642: IFFALSE 111654
// k := tmp ;
111644: LD_ADDR_VAR 0 9
111648: PUSH
111649: LD_VAR 0 14
111653: ST_TO_ADDR
// for j = 1 to k do
111654: LD_ADDR_VAR 0 8
111658: PUSH
111659: DOUBLE
111660: LD_INT 1
111662: DEC
111663: ST_TO_ADDR
111664: LD_VAR 0 9
111668: PUSH
111669: FOR_TO
111670: IFFALSE 111802
// begin if GetType ( tmp [ j ] ) = unit_building then
111672: LD_VAR 0 14
111676: PUSH
111677: LD_VAR 0 8
111681: ARRAY
111682: PPUSH
111683: CALL_OW 247
111687: PUSH
111688: LD_INT 3
111690: EQUAL
111691: IFFALSE 111800
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111693: LD_VAR 0 14
111697: PUSH
111698: LD_VAR 0 8
111702: ARRAY
111703: PUSH
111704: LD_VAR 0 28
111708: IN
111709: NOT
111710: PUSH
111711: LD_VAR 0 14
111715: PUSH
111716: LD_VAR 0 8
111720: ARRAY
111721: PPUSH
111722: CALL_OW 313
111726: AND
111727: IFFALSE 111800
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111729: LD_VAR 0 4
111733: PUSH
111734: LD_VAR 0 7
111738: ARRAY
111739: PPUSH
111740: LD_VAR 0 14
111744: PUSH
111745: LD_VAR 0 8
111749: ARRAY
111750: PPUSH
111751: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111755: LD_ADDR_VAR 0 28
111759: PUSH
111760: LD_VAR 0 28
111764: PPUSH
111765: LD_VAR 0 28
111769: PUSH
111770: LD_INT 1
111772: PLUS
111773: PPUSH
111774: LD_VAR 0 14
111778: PUSH
111779: LD_VAR 0 8
111783: ARRAY
111784: PPUSH
111785: CALL_OW 1
111789: ST_TO_ADDR
// attacking := true ;
111790: LD_ADDR_VAR 0 29
111794: PUSH
111795: LD_INT 1
111797: ST_TO_ADDR
// break ;
111798: GO 111802
// end ; end ;
111800: GO 111669
111802: POP
111803: POP
// if not attacking and f_attack_depot then
111804: LD_VAR 0 29
111808: NOT
111809: PUSH
111810: LD_VAR 0 25
111814: AND
111815: IFFALSE 111910
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111817: LD_ADDR_VAR 0 13
111821: PUSH
111822: LD_VAR 0 14
111826: PPUSH
111827: LD_INT 2
111829: PUSH
111830: LD_INT 30
111832: PUSH
111833: LD_INT 0
111835: PUSH
111836: EMPTY
111837: LIST
111838: LIST
111839: PUSH
111840: LD_INT 30
111842: PUSH
111843: LD_INT 1
111845: PUSH
111846: EMPTY
111847: LIST
111848: LIST
111849: PUSH
111850: EMPTY
111851: LIST
111852: LIST
111853: LIST
111854: PPUSH
111855: CALL_OW 72
111859: ST_TO_ADDR
// if z then
111860: LD_VAR 0 13
111864: IFFALSE 111910
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111866: LD_VAR 0 4
111870: PUSH
111871: LD_VAR 0 7
111875: ARRAY
111876: PPUSH
111877: LD_VAR 0 13
111881: PPUSH
111882: LD_VAR 0 4
111886: PUSH
111887: LD_VAR 0 7
111891: ARRAY
111892: PPUSH
111893: CALL_OW 74
111897: PPUSH
111898: CALL_OW 115
// attacking := true ;
111902: LD_ADDR_VAR 0 29
111906: PUSH
111907: LD_INT 1
111909: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111910: LD_VAR 0 4
111914: PUSH
111915: LD_VAR 0 7
111919: ARRAY
111920: PPUSH
111921: CALL_OW 256
111925: PUSH
111926: LD_INT 500
111928: LESS
111929: IFFALSE 111955
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111931: LD_VAR 0 4
111935: PUSH
111936: LD_VAR 0 7
111940: ARRAY
111941: PPUSH
111942: LD_VAR 0 14
111946: PUSH
111947: LD_INT 1
111949: ARRAY
111950: PPUSH
111951: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111955: LD_VAR 0 4
111959: PUSH
111960: LD_VAR 0 7
111964: ARRAY
111965: PPUSH
111966: CALL_OW 264
111970: PUSH
111971: LD_INT 49
111973: EQUAL
111974: IFFALSE 112095
// begin if not HasTask ( group [ i ] ) then
111976: LD_VAR 0 4
111980: PUSH
111981: LD_VAR 0 7
111985: ARRAY
111986: PPUSH
111987: CALL_OW 314
111991: NOT
111992: IFFALSE 112095
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111994: LD_ADDR_VAR 0 9
111998: PUSH
111999: LD_INT 81
112001: PUSH
112002: LD_VAR 0 4
112006: PUSH
112007: LD_VAR 0 7
112011: ARRAY
112012: PPUSH
112013: CALL_OW 255
112017: PUSH
112018: EMPTY
112019: LIST
112020: LIST
112021: PPUSH
112022: CALL_OW 69
112026: PPUSH
112027: LD_VAR 0 4
112031: PUSH
112032: LD_VAR 0 7
112036: ARRAY
112037: PPUSH
112038: CALL_OW 74
112042: ST_TO_ADDR
// if k then
112043: LD_VAR 0 9
112047: IFFALSE 112095
// if GetDistUnits ( group [ i ] , k ) > 10 then
112049: LD_VAR 0 4
112053: PUSH
112054: LD_VAR 0 7
112058: ARRAY
112059: PPUSH
112060: LD_VAR 0 9
112064: PPUSH
112065: CALL_OW 296
112069: PUSH
112070: LD_INT 10
112072: GREATER
112073: IFFALSE 112095
// ComMoveUnit ( group [ i ] , k ) ;
112075: LD_VAR 0 4
112079: PUSH
112080: LD_VAR 0 7
112084: ARRAY
112085: PPUSH
112086: LD_VAR 0 9
112090: PPUSH
112091: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
112095: LD_VAR 0 4
112099: PUSH
112100: LD_VAR 0 7
112104: ARRAY
112105: PPUSH
112106: CALL_OW 256
112110: PUSH
112111: LD_INT 250
112113: LESS
112114: PUSH
112115: LD_VAR 0 4
112119: PUSH
112120: LD_VAR 0 7
112124: ARRAY
112125: PUSH
112126: LD_INT 21
112128: PUSH
112129: LD_INT 2
112131: PUSH
112132: EMPTY
112133: LIST
112134: LIST
112135: PUSH
112136: LD_INT 23
112138: PUSH
112139: LD_INT 2
112141: PUSH
112142: EMPTY
112143: LIST
112144: LIST
112145: PUSH
112146: EMPTY
112147: LIST
112148: LIST
112149: PPUSH
112150: CALL_OW 69
112154: IN
112155: AND
112156: IFFALSE 112281
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
112158: LD_ADDR_VAR 0 9
112162: PUSH
112163: LD_OWVAR 3
112167: PUSH
112168: LD_VAR 0 4
112172: PUSH
112173: LD_VAR 0 7
112177: ARRAY
112178: DIFF
112179: PPUSH
112180: LD_VAR 0 4
112184: PUSH
112185: LD_VAR 0 7
112189: ARRAY
112190: PPUSH
112191: CALL_OW 74
112195: ST_TO_ADDR
// if not k then
112196: LD_VAR 0 9
112200: NOT
112201: IFFALSE 112205
// continue ;
112203: GO 108620
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
112205: LD_VAR 0 9
112209: PUSH
112210: LD_INT 81
112212: PUSH
112213: LD_VAR 0 4
112217: PUSH
112218: LD_VAR 0 7
112222: ARRAY
112223: PPUSH
112224: CALL_OW 255
112228: PUSH
112229: EMPTY
112230: LIST
112231: LIST
112232: PPUSH
112233: CALL_OW 69
112237: IN
112238: PUSH
112239: LD_VAR 0 9
112243: PPUSH
112244: LD_VAR 0 4
112248: PUSH
112249: LD_VAR 0 7
112253: ARRAY
112254: PPUSH
112255: CALL_OW 296
112259: PUSH
112260: LD_INT 5
112262: LESS
112263: AND
112264: IFFALSE 112281
// ComAutodestruct ( group [ i ] ) ;
112266: LD_VAR 0 4
112270: PUSH
112271: LD_VAR 0 7
112275: ARRAY
112276: PPUSH
112277: CALL 84121 0 1
// end ; if f_attack_depot then
112281: LD_VAR 0 25
112285: IFFALSE 112397
// begin k := 6 ;
112287: LD_ADDR_VAR 0 9
112291: PUSH
112292: LD_INT 6
112294: ST_TO_ADDR
// if tmp < k then
112295: LD_VAR 0 14
112299: PUSH
112300: LD_VAR 0 9
112304: LESS
112305: IFFALSE 112317
// k := tmp ;
112307: LD_ADDR_VAR 0 9
112311: PUSH
112312: LD_VAR 0 14
112316: ST_TO_ADDR
// for j = 1 to k do
112317: LD_ADDR_VAR 0 8
112321: PUSH
112322: DOUBLE
112323: LD_INT 1
112325: DEC
112326: ST_TO_ADDR
112327: LD_VAR 0 9
112331: PUSH
112332: FOR_TO
112333: IFFALSE 112395
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112335: LD_VAR 0 8
112339: PPUSH
112340: CALL_OW 266
112344: PUSH
112345: LD_INT 0
112347: PUSH
112348: LD_INT 1
112350: PUSH
112351: EMPTY
112352: LIST
112353: LIST
112354: IN
112355: IFFALSE 112393
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112357: LD_VAR 0 4
112361: PUSH
112362: LD_VAR 0 7
112366: ARRAY
112367: PPUSH
112368: LD_VAR 0 14
112372: PUSH
112373: LD_VAR 0 8
112377: ARRAY
112378: PPUSH
112379: CALL_OW 115
// attacking := true ;
112383: LD_ADDR_VAR 0 29
112387: PUSH
112388: LD_INT 1
112390: ST_TO_ADDR
// break ;
112391: GO 112395
// end ;
112393: GO 112332
112395: POP
112396: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112397: LD_VAR 0 4
112401: PUSH
112402: LD_VAR 0 7
112406: ARRAY
112407: PPUSH
112408: CALL_OW 302
112412: PUSH
112413: LD_VAR 0 29
112417: NOT
112418: AND
112419: IFFALSE 112741
// begin if GetTag ( group [ i ] ) = 71 then
112421: LD_VAR 0 4
112425: PUSH
112426: LD_VAR 0 7
112430: ARRAY
112431: PPUSH
112432: CALL_OW 110
112436: PUSH
112437: LD_INT 71
112439: EQUAL
112440: IFFALSE 112481
// begin if HasTask ( group [ i ] ) then
112442: LD_VAR 0 4
112446: PUSH
112447: LD_VAR 0 7
112451: ARRAY
112452: PPUSH
112453: CALL_OW 314
112457: IFFALSE 112463
// continue else
112459: GO 108620
112461: GO 112481
// SetTag ( group [ i ] , 0 ) ;
112463: LD_VAR 0 4
112467: PUSH
112468: LD_VAR 0 7
112472: ARRAY
112473: PPUSH
112474: LD_INT 0
112476: PPUSH
112477: CALL_OW 109
// end ; k := 8 ;
112481: LD_ADDR_VAR 0 9
112485: PUSH
112486: LD_INT 8
112488: ST_TO_ADDR
// x := 0 ;
112489: LD_ADDR_VAR 0 10
112493: PUSH
112494: LD_INT 0
112496: ST_TO_ADDR
// if tmp < k then
112497: LD_VAR 0 14
112501: PUSH
112502: LD_VAR 0 9
112506: LESS
112507: IFFALSE 112519
// k := tmp ;
112509: LD_ADDR_VAR 0 9
112513: PUSH
112514: LD_VAR 0 14
112518: ST_TO_ADDR
// for j = 1 to k do
112519: LD_ADDR_VAR 0 8
112523: PUSH
112524: DOUBLE
112525: LD_INT 1
112527: DEC
112528: ST_TO_ADDR
112529: LD_VAR 0 9
112533: PUSH
112534: FOR_TO
112535: IFFALSE 112633
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112537: LD_VAR 0 14
112541: PUSH
112542: LD_VAR 0 8
112546: ARRAY
112547: PPUSH
112548: CALL_OW 247
112552: PUSH
112553: LD_INT 1
112555: EQUAL
112556: PUSH
112557: LD_VAR 0 14
112561: PUSH
112562: LD_VAR 0 8
112566: ARRAY
112567: PPUSH
112568: CALL_OW 256
112572: PUSH
112573: LD_INT 250
112575: LESS
112576: PUSH
112577: LD_VAR 0 20
112581: AND
112582: PUSH
112583: LD_VAR 0 20
112587: NOT
112588: PUSH
112589: LD_VAR 0 14
112593: PUSH
112594: LD_VAR 0 8
112598: ARRAY
112599: PPUSH
112600: CALL_OW 256
112604: PUSH
112605: LD_INT 250
112607: GREATEREQUAL
112608: AND
112609: OR
112610: AND
112611: IFFALSE 112631
// begin x := tmp [ j ] ;
112613: LD_ADDR_VAR 0 10
112617: PUSH
112618: LD_VAR 0 14
112622: PUSH
112623: LD_VAR 0 8
112627: ARRAY
112628: ST_TO_ADDR
// break ;
112629: GO 112633
// end ;
112631: GO 112534
112633: POP
112634: POP
// if x then
112635: LD_VAR 0 10
112639: IFFALSE 112663
// ComAttackUnit ( group [ i ] , x ) else
112641: LD_VAR 0 4
112645: PUSH
112646: LD_VAR 0 7
112650: ARRAY
112651: PPUSH
112652: LD_VAR 0 10
112656: PPUSH
112657: CALL_OW 115
112661: GO 112687
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112663: LD_VAR 0 4
112667: PUSH
112668: LD_VAR 0 7
112672: ARRAY
112673: PPUSH
112674: LD_VAR 0 14
112678: PUSH
112679: LD_INT 1
112681: ARRAY
112682: PPUSH
112683: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112687: LD_VAR 0 4
112691: PUSH
112692: LD_VAR 0 7
112696: ARRAY
112697: PPUSH
112698: CALL_OW 314
112702: NOT
112703: IFFALSE 112741
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112705: LD_VAR 0 4
112709: PUSH
112710: LD_VAR 0 7
112714: ARRAY
112715: PPUSH
112716: LD_VAR 0 14
112720: PPUSH
112721: LD_VAR 0 4
112725: PUSH
112726: LD_VAR 0 7
112730: ARRAY
112731: PPUSH
112732: CALL_OW 74
112736: PPUSH
112737: CALL_OW 115
// end ; end ; end ;
112741: GO 108620
112743: POP
112744: POP
// wait ( 0 0$2 ) ;
112745: LD_INT 70
112747: PPUSH
112748: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112752: LD_VAR 0 4
112756: NOT
112757: PUSH
112758: LD_VAR 0 4
112762: PUSH
112763: EMPTY
112764: EQUAL
112765: OR
112766: PUSH
112767: LD_INT 81
112769: PUSH
112770: LD_VAR 0 35
112774: PUSH
112775: EMPTY
112776: LIST
112777: LIST
112778: PPUSH
112779: CALL_OW 69
112783: NOT
112784: OR
112785: IFFALSE 108605
// end ;
112787: LD_VAR 0 2
112791: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
112792: LD_INT 0
112794: PPUSH
112795: PPUSH
112796: PPUSH
112797: PPUSH
112798: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112799: LD_VAR 0 1
112803: NOT
112804: PUSH
112805: LD_EXP 93
112809: PUSH
112810: LD_VAR 0 1
112814: ARRAY
112815: NOT
112816: OR
112817: PUSH
112818: LD_VAR 0 2
112822: NOT
112823: OR
112824: IFFALSE 112828
// exit ;
112826: GO 113357
// side := mc_sides [ base ] ;
112828: LD_ADDR_VAR 0 5
112832: PUSH
112833: LD_EXP 119
112837: PUSH
112838: LD_VAR 0 1
112842: ARRAY
112843: ST_TO_ADDR
// if not side then
112844: LD_VAR 0 5
112848: NOT
112849: IFFALSE 112853
// exit ;
112851: GO 113357
// for i in solds do
112853: LD_ADDR_VAR 0 6
112857: PUSH
112858: LD_VAR 0 2
112862: PUSH
112863: FOR_IN
112864: IFFALSE 112925
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112866: LD_VAR 0 6
112870: PPUSH
112871: CALL_OW 310
112875: PPUSH
112876: CALL_OW 266
112880: PUSH
112881: LD_INT 32
112883: PUSH
112884: LD_INT 31
112886: PUSH
112887: EMPTY
112888: LIST
112889: LIST
112890: IN
112891: IFFALSE 112911
// solds := solds diff i else
112893: LD_ADDR_VAR 0 2
112897: PUSH
112898: LD_VAR 0 2
112902: PUSH
112903: LD_VAR 0 6
112907: DIFF
112908: ST_TO_ADDR
112909: GO 112923
// SetTag ( i , 18 ) ;
112911: LD_VAR 0 6
112915: PPUSH
112916: LD_INT 18
112918: PPUSH
112919: CALL_OW 109
112923: GO 112863
112925: POP
112926: POP
// if not solds then
112927: LD_VAR 0 2
112931: NOT
112932: IFFALSE 112936
// exit ;
112934: GO 113357
// repeat wait ( 0 0$2 ) ;
112936: LD_INT 70
112938: PPUSH
112939: CALL_OW 67
// enemy := mc_scan [ base ] ;
112943: LD_ADDR_VAR 0 4
112947: PUSH
112948: LD_EXP 116
112952: PUSH
112953: LD_VAR 0 1
112957: ARRAY
112958: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112959: LD_EXP 93
112963: PUSH
112964: LD_VAR 0 1
112968: ARRAY
112969: NOT
112970: PUSH
112971: LD_EXP 93
112975: PUSH
112976: LD_VAR 0 1
112980: ARRAY
112981: PUSH
112982: EMPTY
112983: EQUAL
112984: OR
112985: IFFALSE 113022
// begin for i in solds do
112987: LD_ADDR_VAR 0 6
112991: PUSH
112992: LD_VAR 0 2
112996: PUSH
112997: FOR_IN
112998: IFFALSE 113011
// ComStop ( i ) ;
113000: LD_VAR 0 6
113004: PPUSH
113005: CALL_OW 141
113009: GO 112997
113011: POP
113012: POP
// solds := [ ] ;
113013: LD_ADDR_VAR 0 2
113017: PUSH
113018: EMPTY
113019: ST_TO_ADDR
// exit ;
113020: GO 113357
// end ; for i in solds do
113022: LD_ADDR_VAR 0 6
113026: PUSH
113027: LD_VAR 0 2
113031: PUSH
113032: FOR_IN
113033: IFFALSE 113329
// begin if IsInUnit ( i ) then
113035: LD_VAR 0 6
113039: PPUSH
113040: CALL_OW 310
113044: IFFALSE 113055
// ComExitBuilding ( i ) ;
113046: LD_VAR 0 6
113050: PPUSH
113051: CALL_OW 122
// if GetLives ( i ) > 333 then
113055: LD_VAR 0 6
113059: PPUSH
113060: CALL_OW 256
113064: PUSH
113065: LD_INT 333
113067: GREATER
113068: IFFALSE 113096
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
113070: LD_VAR 0 6
113074: PPUSH
113075: LD_VAR 0 4
113079: PPUSH
113080: LD_VAR 0 6
113084: PPUSH
113085: CALL_OW 74
113089: PPUSH
113090: CALL_OW 115
113094: GO 113327
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
113096: LD_VAR 0 6
113100: PPUSH
113101: LD_EXP 93
113105: PUSH
113106: LD_VAR 0 1
113110: ARRAY
113111: PPUSH
113112: LD_INT 2
113114: PUSH
113115: LD_INT 30
113117: PUSH
113118: LD_INT 0
113120: PUSH
113121: EMPTY
113122: LIST
113123: LIST
113124: PUSH
113125: LD_INT 30
113127: PUSH
113128: LD_INT 1
113130: PUSH
113131: EMPTY
113132: LIST
113133: LIST
113134: PUSH
113135: LD_INT 30
113137: PUSH
113138: LD_INT 6
113140: PUSH
113141: EMPTY
113142: LIST
113143: LIST
113144: PUSH
113145: EMPTY
113146: LIST
113147: LIST
113148: LIST
113149: LIST
113150: PPUSH
113151: CALL_OW 72
113155: PPUSH
113156: LD_VAR 0 6
113160: PPUSH
113161: CALL_OW 74
113165: PPUSH
113166: CALL_OW 296
113170: PUSH
113171: LD_INT 10
113173: GREATER
113174: IFFALSE 113327
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
113176: LD_ADDR_VAR 0 7
113180: PUSH
113181: LD_EXP 93
113185: PUSH
113186: LD_VAR 0 1
113190: ARRAY
113191: PPUSH
113192: LD_INT 2
113194: PUSH
113195: LD_INT 30
113197: PUSH
113198: LD_INT 0
113200: PUSH
113201: EMPTY
113202: LIST
113203: LIST
113204: PUSH
113205: LD_INT 30
113207: PUSH
113208: LD_INT 1
113210: PUSH
113211: EMPTY
113212: LIST
113213: LIST
113214: PUSH
113215: LD_INT 30
113217: PUSH
113218: LD_INT 6
113220: PUSH
113221: EMPTY
113222: LIST
113223: LIST
113224: PUSH
113225: EMPTY
113226: LIST
113227: LIST
113228: LIST
113229: LIST
113230: PPUSH
113231: CALL_OW 72
113235: PPUSH
113236: LD_VAR 0 6
113240: PPUSH
113241: CALL_OW 74
113245: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113246: LD_VAR 0 6
113250: PPUSH
113251: LD_VAR 0 7
113255: PPUSH
113256: CALL_OW 250
113260: PPUSH
113261: LD_INT 3
113263: PPUSH
113264: LD_INT 5
113266: PPUSH
113267: CALL_OW 272
113271: PPUSH
113272: LD_VAR 0 7
113276: PPUSH
113277: CALL_OW 251
113281: PPUSH
113282: LD_INT 3
113284: PPUSH
113285: LD_INT 5
113287: PPUSH
113288: CALL_OW 273
113292: PPUSH
113293: CALL_OW 111
// SetTag ( i , 0 ) ;
113297: LD_VAR 0 6
113301: PPUSH
113302: LD_INT 0
113304: PPUSH
113305: CALL_OW 109
// solds := solds diff i ;
113309: LD_ADDR_VAR 0 2
113313: PUSH
113314: LD_VAR 0 2
113318: PUSH
113319: LD_VAR 0 6
113323: DIFF
113324: ST_TO_ADDR
// continue ;
113325: GO 113032
// end ; end ;
113327: GO 113032
113329: POP
113330: POP
// until not solds or not enemy ;
113331: LD_VAR 0 2
113335: NOT
113336: PUSH
113337: LD_VAR 0 4
113341: NOT
113342: OR
113343: IFFALSE 112936
// MC_Reset ( base , 18 ) ;
113345: LD_VAR 0 1
113349: PPUSH
113350: LD_INT 18
113352: PPUSH
113353: CALL 25016 0 2
// end ;
113357: LD_VAR 0 3
113361: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113362: LD_INT 0
113364: PPUSH
113365: PPUSH
113366: PPUSH
113367: PPUSH
113368: PPUSH
113369: PPUSH
113370: PPUSH
113371: PPUSH
113372: PPUSH
113373: PPUSH
113374: PPUSH
113375: PPUSH
113376: PPUSH
113377: PPUSH
113378: PPUSH
113379: PPUSH
113380: PPUSH
113381: PPUSH
113382: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113383: LD_ADDR_VAR 0 12
113387: PUSH
113388: LD_EXP 93
113392: PUSH
113393: LD_VAR 0 1
113397: ARRAY
113398: PPUSH
113399: LD_INT 25
113401: PUSH
113402: LD_INT 3
113404: PUSH
113405: EMPTY
113406: LIST
113407: LIST
113408: PPUSH
113409: CALL_OW 72
113413: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113414: LD_EXP 133
113418: PUSH
113419: LD_VAR 0 1
113423: ARRAY
113424: IFFALSE 113448
// mechs := mechs diff mc_remote_driver [ base ] ;
113426: LD_ADDR_VAR 0 12
113430: PUSH
113431: LD_VAR 0 12
113435: PUSH
113436: LD_EXP 133
113440: PUSH
113441: LD_VAR 0 1
113445: ARRAY
113446: DIFF
113447: ST_TO_ADDR
// for i in mechs do
113448: LD_ADDR_VAR 0 4
113452: PUSH
113453: LD_VAR 0 12
113457: PUSH
113458: FOR_IN
113459: IFFALSE 113494
// if GetTag ( i ) > 0 then
113461: LD_VAR 0 4
113465: PPUSH
113466: CALL_OW 110
113470: PUSH
113471: LD_INT 0
113473: GREATER
113474: IFFALSE 113492
// mechs := mechs diff i ;
113476: LD_ADDR_VAR 0 12
113480: PUSH
113481: LD_VAR 0 12
113485: PUSH
113486: LD_VAR 0 4
113490: DIFF
113491: ST_TO_ADDR
113492: GO 113458
113494: POP
113495: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113496: LD_ADDR_VAR 0 8
113500: PUSH
113501: LD_EXP 93
113505: PUSH
113506: LD_VAR 0 1
113510: ARRAY
113511: PPUSH
113512: LD_INT 2
113514: PUSH
113515: LD_INT 25
113517: PUSH
113518: LD_INT 1
113520: PUSH
113521: EMPTY
113522: LIST
113523: LIST
113524: PUSH
113525: LD_INT 25
113527: PUSH
113528: LD_INT 5
113530: PUSH
113531: EMPTY
113532: LIST
113533: LIST
113534: PUSH
113535: LD_INT 25
113537: PUSH
113538: LD_INT 8
113540: PUSH
113541: EMPTY
113542: LIST
113543: LIST
113544: PUSH
113545: LD_INT 25
113547: PUSH
113548: LD_INT 9
113550: PUSH
113551: EMPTY
113552: LIST
113553: LIST
113554: PUSH
113555: EMPTY
113556: LIST
113557: LIST
113558: LIST
113559: LIST
113560: LIST
113561: PPUSH
113562: CALL_OW 72
113566: ST_TO_ADDR
// if not defenders and not solds then
113567: LD_VAR 0 2
113571: NOT
113572: PUSH
113573: LD_VAR 0 8
113577: NOT
113578: AND
113579: IFFALSE 113583
// exit ;
113581: GO 115353
// depot_under_attack := false ;
113583: LD_ADDR_VAR 0 16
113587: PUSH
113588: LD_INT 0
113590: ST_TO_ADDR
// sold_defenders := [ ] ;
113591: LD_ADDR_VAR 0 17
113595: PUSH
113596: EMPTY
113597: ST_TO_ADDR
// if mechs then
113598: LD_VAR 0 12
113602: IFFALSE 113755
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113604: LD_ADDR_VAR 0 4
113608: PUSH
113609: LD_VAR 0 2
113613: PPUSH
113614: LD_INT 21
113616: PUSH
113617: LD_INT 2
113619: PUSH
113620: EMPTY
113621: LIST
113622: LIST
113623: PPUSH
113624: CALL_OW 72
113628: PUSH
113629: FOR_IN
113630: IFFALSE 113753
// begin if GetTag ( i ) <> 20 then
113632: LD_VAR 0 4
113636: PPUSH
113637: CALL_OW 110
113641: PUSH
113642: LD_INT 20
113644: NONEQUAL
113645: IFFALSE 113659
// SetTag ( i , 20 ) ;
113647: LD_VAR 0 4
113651: PPUSH
113652: LD_INT 20
113654: PPUSH
113655: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113659: LD_VAR 0 4
113663: PPUSH
113664: CALL_OW 263
113668: PUSH
113669: LD_INT 1
113671: EQUAL
113672: PUSH
113673: LD_VAR 0 4
113677: PPUSH
113678: CALL_OW 311
113682: NOT
113683: AND
113684: IFFALSE 113751
// begin un := mechs [ 1 ] ;
113686: LD_ADDR_VAR 0 10
113690: PUSH
113691: LD_VAR 0 12
113695: PUSH
113696: LD_INT 1
113698: ARRAY
113699: ST_TO_ADDR
// ComExit ( un ) ;
113700: LD_VAR 0 10
113704: PPUSH
113705: CALL 88466 0 1
// AddComEnterUnit ( un , i ) ;
113709: LD_VAR 0 10
113713: PPUSH
113714: LD_VAR 0 4
113718: PPUSH
113719: CALL_OW 180
// SetTag ( un , 19 ) ;
113723: LD_VAR 0 10
113727: PPUSH
113728: LD_INT 19
113730: PPUSH
113731: CALL_OW 109
// mechs := mechs diff un ;
113735: LD_ADDR_VAR 0 12
113739: PUSH
113740: LD_VAR 0 12
113744: PUSH
113745: LD_VAR 0 10
113749: DIFF
113750: ST_TO_ADDR
// end ; end ;
113751: GO 113629
113753: POP
113754: POP
// if solds then
113755: LD_VAR 0 8
113759: IFFALSE 113818
// for i in solds do
113761: LD_ADDR_VAR 0 4
113765: PUSH
113766: LD_VAR 0 8
113770: PUSH
113771: FOR_IN
113772: IFFALSE 113816
// if not GetTag ( i ) then
113774: LD_VAR 0 4
113778: PPUSH
113779: CALL_OW 110
113783: NOT
113784: IFFALSE 113814
// begin defenders := defenders union i ;
113786: LD_ADDR_VAR 0 2
113790: PUSH
113791: LD_VAR 0 2
113795: PUSH
113796: LD_VAR 0 4
113800: UNION
113801: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113802: LD_VAR 0 4
113806: PPUSH
113807: LD_INT 18
113809: PPUSH
113810: CALL_OW 109
// end ;
113814: GO 113771
113816: POP
113817: POP
// repeat wait ( 0 0$2 ) ;
113818: LD_INT 70
113820: PPUSH
113821: CALL_OW 67
// enemy := mc_scan [ base ] ;
113825: LD_ADDR_VAR 0 21
113829: PUSH
113830: LD_EXP 116
113834: PUSH
113835: LD_VAR 0 1
113839: ARRAY
113840: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113841: LD_EXP 93
113845: PUSH
113846: LD_VAR 0 1
113850: ARRAY
113851: NOT
113852: PUSH
113853: LD_EXP 93
113857: PUSH
113858: LD_VAR 0 1
113862: ARRAY
113863: PUSH
113864: EMPTY
113865: EQUAL
113866: OR
113867: IFFALSE 113904
// begin for i in defenders do
113869: LD_ADDR_VAR 0 4
113873: PUSH
113874: LD_VAR 0 2
113878: PUSH
113879: FOR_IN
113880: IFFALSE 113893
// ComStop ( i ) ;
113882: LD_VAR 0 4
113886: PPUSH
113887: CALL_OW 141
113891: GO 113879
113893: POP
113894: POP
// defenders := [ ] ;
113895: LD_ADDR_VAR 0 2
113899: PUSH
113900: EMPTY
113901: ST_TO_ADDR
// exit ;
113902: GO 115353
// end ; for i in defenders do
113904: LD_ADDR_VAR 0 4
113908: PUSH
113909: LD_VAR 0 2
113913: PUSH
113914: FOR_IN
113915: IFFALSE 114813
// begin e := NearestUnitToUnit ( enemy , i ) ;
113917: LD_ADDR_VAR 0 13
113921: PUSH
113922: LD_VAR 0 21
113926: PPUSH
113927: LD_VAR 0 4
113931: PPUSH
113932: CALL_OW 74
113936: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113937: LD_ADDR_VAR 0 7
113941: PUSH
113942: LD_EXP 93
113946: PUSH
113947: LD_VAR 0 1
113951: ARRAY
113952: PPUSH
113953: LD_INT 2
113955: PUSH
113956: LD_INT 30
113958: PUSH
113959: LD_INT 0
113961: PUSH
113962: EMPTY
113963: LIST
113964: LIST
113965: PUSH
113966: LD_INT 30
113968: PUSH
113969: LD_INT 1
113971: PUSH
113972: EMPTY
113973: LIST
113974: LIST
113975: PUSH
113976: EMPTY
113977: LIST
113978: LIST
113979: LIST
113980: PPUSH
113981: CALL_OW 72
113985: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113986: LD_ADDR_VAR 0 16
113990: PUSH
113991: LD_VAR 0 7
113995: NOT
113996: PUSH
113997: LD_VAR 0 7
114001: PPUSH
114002: LD_INT 3
114004: PUSH
114005: LD_INT 24
114007: PUSH
114008: LD_INT 600
114010: PUSH
114011: EMPTY
114012: LIST
114013: LIST
114014: PUSH
114015: EMPTY
114016: LIST
114017: LIST
114018: PPUSH
114019: CALL_OW 72
114023: OR
114024: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
114025: LD_VAR 0 4
114029: PPUSH
114030: CALL_OW 247
114034: PUSH
114035: LD_INT 2
114037: DOUBLE
114038: EQUAL
114039: IFTRUE 114043
114041: GO 114439
114043: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
114044: LD_VAR 0 4
114048: PPUSH
114049: CALL_OW 256
114053: PUSH
114054: LD_INT 1000
114056: EQUAL
114057: PUSH
114058: LD_VAR 0 4
114062: PPUSH
114063: LD_VAR 0 13
114067: PPUSH
114068: CALL_OW 296
114072: PUSH
114073: LD_INT 40
114075: LESS
114076: PUSH
114077: LD_VAR 0 13
114081: PPUSH
114082: LD_EXP 118
114086: PUSH
114087: LD_VAR 0 1
114091: ARRAY
114092: PPUSH
114093: CALL_OW 308
114097: OR
114098: AND
114099: IFFALSE 114221
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
114101: LD_VAR 0 4
114105: PPUSH
114106: CALL_OW 262
114110: PUSH
114111: LD_INT 1
114113: EQUAL
114114: PUSH
114115: LD_VAR 0 4
114119: PPUSH
114120: CALL_OW 261
114124: PUSH
114125: LD_INT 30
114127: LESS
114128: AND
114129: PUSH
114130: LD_VAR 0 7
114134: AND
114135: IFFALSE 114205
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
114137: LD_VAR 0 4
114141: PPUSH
114142: LD_VAR 0 7
114146: PPUSH
114147: LD_VAR 0 4
114151: PPUSH
114152: CALL_OW 74
114156: PPUSH
114157: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
114161: LD_VAR 0 4
114165: PPUSH
114166: LD_VAR 0 7
114170: PPUSH
114171: LD_VAR 0 4
114175: PPUSH
114176: CALL_OW 74
114180: PPUSH
114181: CALL_OW 296
114185: PUSH
114186: LD_INT 6
114188: LESS
114189: IFFALSE 114203
// SetFuel ( i , 100 ) ;
114191: LD_VAR 0 4
114195: PPUSH
114196: LD_INT 100
114198: PPUSH
114199: CALL_OW 240
// end else
114203: GO 114219
// ComAttackUnit ( i , e ) ;
114205: LD_VAR 0 4
114209: PPUSH
114210: LD_VAR 0 13
114214: PPUSH
114215: CALL_OW 115
// end else
114219: GO 114322
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114221: LD_VAR 0 13
114225: PPUSH
114226: LD_EXP 118
114230: PUSH
114231: LD_VAR 0 1
114235: ARRAY
114236: PPUSH
114237: CALL_OW 308
114241: NOT
114242: PUSH
114243: LD_VAR 0 4
114247: PPUSH
114248: LD_VAR 0 13
114252: PPUSH
114253: CALL_OW 296
114257: PUSH
114258: LD_INT 40
114260: GREATEREQUAL
114261: AND
114262: PUSH
114263: LD_VAR 0 4
114267: PPUSH
114268: CALL_OW 256
114272: PUSH
114273: LD_INT 650
114275: LESSEQUAL
114276: OR
114277: PUSH
114278: LD_VAR 0 4
114282: PPUSH
114283: LD_EXP 117
114287: PUSH
114288: LD_VAR 0 1
114292: ARRAY
114293: PPUSH
114294: CALL_OW 308
114298: NOT
114299: AND
114300: IFFALSE 114322
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114302: LD_VAR 0 4
114306: PPUSH
114307: LD_EXP 117
114311: PUSH
114312: LD_VAR 0 1
114316: ARRAY
114317: PPUSH
114318: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114322: LD_VAR 0 4
114326: PPUSH
114327: CALL_OW 256
114331: PUSH
114332: LD_INT 1000
114334: LESS
114335: PUSH
114336: LD_VAR 0 4
114340: PPUSH
114341: CALL_OW 263
114345: PUSH
114346: LD_INT 1
114348: EQUAL
114349: AND
114350: PUSH
114351: LD_VAR 0 4
114355: PPUSH
114356: CALL_OW 311
114360: AND
114361: PUSH
114362: LD_VAR 0 4
114366: PPUSH
114367: LD_EXP 117
114371: PUSH
114372: LD_VAR 0 1
114376: ARRAY
114377: PPUSH
114378: CALL_OW 308
114382: AND
114383: IFFALSE 114437
// begin mech := IsDrivenBy ( i ) ;
114385: LD_ADDR_VAR 0 9
114389: PUSH
114390: LD_VAR 0 4
114394: PPUSH
114395: CALL_OW 311
114399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114400: LD_VAR 0 9
114404: PPUSH
114405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114409: LD_VAR 0 9
114413: PPUSH
114414: LD_VAR 0 4
114418: PPUSH
114419: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114423: LD_VAR 0 9
114427: PPUSH
114428: LD_VAR 0 4
114432: PPUSH
114433: CALL_OW 180
// end ; end ; unit_human :
114437: GO 114784
114439: LD_INT 1
114441: DOUBLE
114442: EQUAL
114443: IFTRUE 114447
114445: GO 114783
114447: POP
// begin b := IsInUnit ( i ) ;
114448: LD_ADDR_VAR 0 18
114452: PUSH
114453: LD_VAR 0 4
114457: PPUSH
114458: CALL_OW 310
114462: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114463: LD_ADDR_VAR 0 19
114467: PUSH
114468: LD_VAR 0 18
114472: NOT
114473: PUSH
114474: LD_VAR 0 18
114478: PPUSH
114479: CALL_OW 266
114483: PUSH
114484: LD_INT 32
114486: PUSH
114487: LD_INT 31
114489: PUSH
114490: EMPTY
114491: LIST
114492: LIST
114493: IN
114494: OR
114495: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114496: LD_VAR 0 18
114500: PPUSH
114501: CALL_OW 266
114505: PUSH
114506: LD_INT 5
114508: EQUAL
114509: PUSH
114510: LD_VAR 0 4
114514: PPUSH
114515: CALL_OW 257
114519: PUSH
114520: LD_INT 1
114522: PUSH
114523: LD_INT 2
114525: PUSH
114526: LD_INT 3
114528: PUSH
114529: LD_INT 4
114531: PUSH
114532: EMPTY
114533: LIST
114534: LIST
114535: LIST
114536: LIST
114537: IN
114538: AND
114539: IFFALSE 114576
// begin class := AllowSpecClass ( i ) ;
114541: LD_ADDR_VAR 0 20
114545: PUSH
114546: LD_VAR 0 4
114550: PPUSH
114551: CALL 53127 0 1
114555: ST_TO_ADDR
// if class then
114556: LD_VAR 0 20
114560: IFFALSE 114576
// ComChangeProfession ( i , class ) ;
114562: LD_VAR 0 4
114566: PPUSH
114567: LD_VAR 0 20
114571: PPUSH
114572: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114576: LD_VAR 0 16
114580: PUSH
114581: LD_VAR 0 2
114585: PPUSH
114586: LD_INT 21
114588: PUSH
114589: LD_INT 2
114591: PUSH
114592: EMPTY
114593: LIST
114594: LIST
114595: PPUSH
114596: CALL_OW 72
114600: PUSH
114601: LD_INT 1
114603: LESSEQUAL
114604: OR
114605: PUSH
114606: LD_VAR 0 19
114610: AND
114611: PUSH
114612: LD_VAR 0 4
114616: PUSH
114617: LD_VAR 0 17
114621: IN
114622: NOT
114623: AND
114624: IFFALSE 114717
// begin if b then
114626: LD_VAR 0 18
114630: IFFALSE 114679
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114632: LD_VAR 0 18
114636: PPUSH
114637: LD_VAR 0 21
114641: PPUSH
114642: LD_VAR 0 18
114646: PPUSH
114647: CALL_OW 74
114651: PPUSH
114652: CALL_OW 296
114656: PUSH
114657: LD_INT 10
114659: LESS
114660: PUSH
114661: LD_VAR 0 18
114665: PPUSH
114666: CALL_OW 461
114670: PUSH
114671: LD_INT 7
114673: NONEQUAL
114674: AND
114675: IFFALSE 114679
// continue ;
114677: GO 113914
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114679: LD_ADDR_VAR 0 17
114683: PUSH
114684: LD_VAR 0 17
114688: PPUSH
114689: LD_VAR 0 17
114693: PUSH
114694: LD_INT 1
114696: PLUS
114697: PPUSH
114698: LD_VAR 0 4
114702: PPUSH
114703: CALL_OW 1
114707: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114708: LD_VAR 0 4
114712: PPUSH
114713: CALL_OW 122
// end ; if sold_defenders then
114717: LD_VAR 0 17
114721: IFFALSE 114781
// if i in sold_defenders then
114723: LD_VAR 0 4
114727: PUSH
114728: LD_VAR 0 17
114732: IN
114733: IFFALSE 114781
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114735: LD_VAR 0 4
114739: PPUSH
114740: CALL_OW 314
114744: NOT
114745: PUSH
114746: LD_VAR 0 4
114750: PPUSH
114751: LD_VAR 0 13
114755: PPUSH
114756: CALL_OW 296
114760: PUSH
114761: LD_INT 30
114763: LESS
114764: AND
114765: IFFALSE 114781
// ComAttackUnit ( i , e ) ;
114767: LD_VAR 0 4
114771: PPUSH
114772: LD_VAR 0 13
114776: PPUSH
114777: CALL_OW 115
// end ; end ; end ;
114781: GO 114784
114783: POP
// if IsDead ( i ) then
114784: LD_VAR 0 4
114788: PPUSH
114789: CALL_OW 301
114793: IFFALSE 114811
// defenders := defenders diff i ;
114795: LD_ADDR_VAR 0 2
114799: PUSH
114800: LD_VAR 0 2
114804: PUSH
114805: LD_VAR 0 4
114809: DIFF
114810: ST_TO_ADDR
// end ;
114811: GO 113914
114813: POP
114814: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114815: LD_VAR 0 21
114819: NOT
114820: PUSH
114821: LD_VAR 0 2
114825: NOT
114826: OR
114827: PUSH
114828: LD_EXP 93
114832: PUSH
114833: LD_VAR 0 1
114837: ARRAY
114838: NOT
114839: OR
114840: IFFALSE 113818
// MC_Reset ( base , 18 ) ;
114842: LD_VAR 0 1
114846: PPUSH
114847: LD_INT 18
114849: PPUSH
114850: CALL 25016 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114854: LD_ADDR_VAR 0 2
114858: PUSH
114859: LD_VAR 0 2
114863: PUSH
114864: LD_VAR 0 2
114868: PPUSH
114869: LD_INT 2
114871: PUSH
114872: LD_INT 25
114874: PUSH
114875: LD_INT 1
114877: PUSH
114878: EMPTY
114879: LIST
114880: LIST
114881: PUSH
114882: LD_INT 25
114884: PUSH
114885: LD_INT 5
114887: PUSH
114888: EMPTY
114889: LIST
114890: LIST
114891: PUSH
114892: LD_INT 25
114894: PUSH
114895: LD_INT 8
114897: PUSH
114898: EMPTY
114899: LIST
114900: LIST
114901: PUSH
114902: LD_INT 25
114904: PUSH
114905: LD_INT 9
114907: PUSH
114908: EMPTY
114909: LIST
114910: LIST
114911: PUSH
114912: EMPTY
114913: LIST
114914: LIST
114915: LIST
114916: LIST
114917: LIST
114918: PPUSH
114919: CALL_OW 72
114923: DIFF
114924: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114925: LD_VAR 0 21
114929: NOT
114930: PUSH
114931: LD_VAR 0 2
114935: PPUSH
114936: LD_INT 21
114938: PUSH
114939: LD_INT 2
114941: PUSH
114942: EMPTY
114943: LIST
114944: LIST
114945: PPUSH
114946: CALL_OW 72
114950: AND
114951: IFFALSE 115289
// begin tmp := FilterByTag ( defenders , 19 ) ;
114953: LD_ADDR_VAR 0 11
114957: PUSH
114958: LD_VAR 0 2
114962: PPUSH
114963: LD_INT 19
114965: PPUSH
114966: CALL 85596 0 2
114970: ST_TO_ADDR
// if tmp then
114971: LD_VAR 0 11
114975: IFFALSE 115045
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114977: LD_ADDR_VAR 0 11
114981: PUSH
114982: LD_VAR 0 11
114986: PPUSH
114987: LD_INT 25
114989: PUSH
114990: LD_INT 3
114992: PUSH
114993: EMPTY
114994: LIST
114995: LIST
114996: PPUSH
114997: CALL_OW 72
115001: ST_TO_ADDR
// if tmp then
115002: LD_VAR 0 11
115006: IFFALSE 115045
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
115008: LD_ADDR_EXP 105
115012: PUSH
115013: LD_EXP 105
115017: PPUSH
115018: LD_VAR 0 1
115022: PPUSH
115023: LD_EXP 105
115027: PUSH
115028: LD_VAR 0 1
115032: ARRAY
115033: PUSH
115034: LD_VAR 0 11
115038: UNION
115039: PPUSH
115040: CALL_OW 1
115044: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
115045: LD_VAR 0 1
115049: PPUSH
115050: LD_INT 19
115052: PPUSH
115053: CALL 25016 0 2
// repeat wait ( 0 0$1 ) ;
115057: LD_INT 35
115059: PPUSH
115060: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115064: LD_EXP 93
115068: PUSH
115069: LD_VAR 0 1
115073: ARRAY
115074: NOT
115075: PUSH
115076: LD_EXP 93
115080: PUSH
115081: LD_VAR 0 1
115085: ARRAY
115086: PUSH
115087: EMPTY
115088: EQUAL
115089: OR
115090: IFFALSE 115127
// begin for i in defenders do
115092: LD_ADDR_VAR 0 4
115096: PUSH
115097: LD_VAR 0 2
115101: PUSH
115102: FOR_IN
115103: IFFALSE 115116
// ComStop ( i ) ;
115105: LD_VAR 0 4
115109: PPUSH
115110: CALL_OW 141
115114: GO 115102
115116: POP
115117: POP
// defenders := [ ] ;
115118: LD_ADDR_VAR 0 2
115122: PUSH
115123: EMPTY
115124: ST_TO_ADDR
// exit ;
115125: GO 115353
// end ; for i in defenders do
115127: LD_ADDR_VAR 0 4
115131: PUSH
115132: LD_VAR 0 2
115136: PUSH
115137: FOR_IN
115138: IFFALSE 115227
// begin if not IsInArea ( i , mc_parking [ base ] ) then
115140: LD_VAR 0 4
115144: PPUSH
115145: LD_EXP 117
115149: PUSH
115150: LD_VAR 0 1
115154: ARRAY
115155: PPUSH
115156: CALL_OW 308
115160: NOT
115161: IFFALSE 115185
// ComMoveToArea ( i , mc_parking [ base ] ) else
115163: LD_VAR 0 4
115167: PPUSH
115168: LD_EXP 117
115172: PUSH
115173: LD_VAR 0 1
115177: ARRAY
115178: PPUSH
115179: CALL_OW 113
115183: GO 115225
// if GetControl ( i ) = control_manual then
115185: LD_VAR 0 4
115189: PPUSH
115190: CALL_OW 263
115194: PUSH
115195: LD_INT 1
115197: EQUAL
115198: IFFALSE 115225
// if IsDrivenBy ( i ) then
115200: LD_VAR 0 4
115204: PPUSH
115205: CALL_OW 311
115209: IFFALSE 115225
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
115211: LD_VAR 0 4
115215: PPUSH
115216: CALL_OW 311
115220: PPUSH
115221: CALL_OW 121
// end ;
115225: GO 115137
115227: POP
115228: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
115229: LD_VAR 0 2
115233: PPUSH
115234: LD_INT 95
115236: PUSH
115237: LD_EXP 117
115241: PUSH
115242: LD_VAR 0 1
115246: ARRAY
115247: PUSH
115248: EMPTY
115249: LIST
115250: LIST
115251: PPUSH
115252: CALL_OW 72
115256: PUSH
115257: LD_VAR 0 2
115261: EQUAL
115262: PUSH
115263: LD_EXP 116
115267: PUSH
115268: LD_VAR 0 1
115272: ARRAY
115273: OR
115274: PUSH
115275: LD_EXP 93
115279: PUSH
115280: LD_VAR 0 1
115284: ARRAY
115285: NOT
115286: OR
115287: IFFALSE 115057
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115289: LD_ADDR_EXP 115
115293: PUSH
115294: LD_EXP 115
115298: PPUSH
115299: LD_VAR 0 1
115303: PPUSH
115304: LD_VAR 0 2
115308: PPUSH
115309: LD_INT 21
115311: PUSH
115312: LD_INT 2
115314: PUSH
115315: EMPTY
115316: LIST
115317: LIST
115318: PPUSH
115319: CALL_OW 72
115323: PPUSH
115324: CALL_OW 1
115328: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115329: LD_VAR 0 1
115333: PPUSH
115334: LD_INT 19
115336: PPUSH
115337: CALL 25016 0 2
// MC_Reset ( base , 20 ) ;
115341: LD_VAR 0 1
115345: PPUSH
115346: LD_INT 20
115348: PPUSH
115349: CALL 25016 0 2
// end ; end_of_file
115353: LD_VAR 0 3
115357: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115358: LD_VAR 0 1
115362: PUSH
115363: LD_INT 200
115365: DOUBLE
115366: GREATEREQUAL
115367: IFFALSE 115375
115369: LD_INT 299
115371: DOUBLE
115372: LESSEQUAL
115373: IFTRUE 115377
115375: GO 115409
115377: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115378: LD_VAR 0 1
115382: PPUSH
115383: LD_VAR 0 2
115387: PPUSH
115388: LD_VAR 0 3
115392: PPUSH
115393: LD_VAR 0 4
115397: PPUSH
115398: LD_VAR 0 5
115402: PPUSH
115403: CALL 104200 0 5
115407: GO 115486
115409: LD_INT 300
115411: DOUBLE
115412: GREATEREQUAL
115413: IFFALSE 115421
115415: LD_INT 399
115417: DOUBLE
115418: LESSEQUAL
115419: IFTRUE 115423
115421: GO 115485
115423: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115424: LD_VAR 0 1
115428: PPUSH
115429: LD_VAR 0 2
115433: PPUSH
115434: LD_VAR 0 3
115438: PPUSH
115439: LD_VAR 0 4
115443: PPUSH
115444: LD_VAR 0 5
115448: PPUSH
115449: LD_VAR 0 6
115453: PPUSH
115454: LD_VAR 0 7
115458: PPUSH
115459: LD_VAR 0 8
115463: PPUSH
115464: LD_VAR 0 9
115468: PPUSH
115469: LD_VAR 0 10
115473: PPUSH
115474: LD_VAR 0 11
115478: PPUSH
115479: CALL 102088 0 11
115483: GO 115486
115485: POP
// end ;
115486: PPOPN 11
115488: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115489: LD_VAR 0 1
115493: PPUSH
115494: LD_VAR 0 2
115498: PPUSH
115499: LD_VAR 0 3
115503: PPUSH
115504: LD_VAR 0 4
115508: PPUSH
115509: LD_VAR 0 5
115513: PPUSH
115514: CALL 104182 0 5
// end ; end_of_file
115518: PPOPN 5
115520: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115521: LD_VAR 0 1
115525: PPUSH
115526: LD_VAR 0 2
115530: PPUSH
115531: LD_VAR 0 3
115535: PPUSH
115536: LD_VAR 0 4
115540: PPUSH
115541: LD_VAR 0 5
115545: PPUSH
115546: LD_VAR 0 6
115550: PPUSH
115551: CALL 90896 0 6
// end ;
115555: PPOPN 6
115557: END
