// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20778 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22890 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 114
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 115
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44117 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45177 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45270 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 119
 338: PUSH
 339: LD_EXP 119
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44435 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44620 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45177 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45270 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44435 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44620 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45050 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44117 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45177 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45270 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 119
 826: PUSH
 827: LD_EXP 119
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44435 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44620 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45177 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45270 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45588 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45382 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44435 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44620 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45001 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 50846 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 50846 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 50846 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 50846 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 50846 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 50846 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 50846 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 50846 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 50846 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 50846 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 50846 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 50846 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 50846 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 50846 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 50846 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 50846 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 50846 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 50846 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 50846 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 50846 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 50846 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 50846 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 50846 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 50846 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 50846 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 50846 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 50846 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 50846 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 50846 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 50846 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 50846 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 50846 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 50846 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 50846 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 55670 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 55670 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 55670 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 55670 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 55670 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 55670 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 55670 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 55670 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 55670 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 55670 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 55670 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 55670 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 55670 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 267
4442: PPUSH
4443: LD_INT 226
4445: PPUSH
4446: LD_INT 5
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 55670 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 55670 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 50846 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 50846 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 50846 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 50846 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 50846 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 50846 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 50846 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 50846 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 50846 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 50846 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 90
5426: PUSH
5427: LD_EXP 90
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 45901 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44483 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44483 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 45901 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 45901 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 109
5909: PUSH
5910: LD_EXP 109
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 109
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44483 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59079 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 90
6683: PUSH
6684: LD_EXP 90
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 50846 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59079 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 90
7213: PUSH
7214: LD_EXP 90
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 45901 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44483 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44483 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 45901 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 45901 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 109
7862: PUSH
7863: LD_EXP 109
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 109
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59079 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 90
8824: PUSH
8825: LD_EXP 90
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 86835 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 86896 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 86896 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 45901 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44483 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44483 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44483 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 45901 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 45901 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 109
9864: PUSH
9865: LD_EXP 109
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 109
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44483 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 47894 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50228 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49296 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 58643 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49537 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47590 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47210 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 46800 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46638 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46413 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46298 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50489 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 50705 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46107 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 101188 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21013 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21013 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21013 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21013 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 83461 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 83461 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 83461 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 83461 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$50 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1750
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 87065 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 87065 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 87065 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// end ;
20765: LD_VAR 0 1
20769: RET
// every 1 do
20770: GO 20772
20772: DISABLE
// InitGlobalVariables ; end_of_file
20773: CALL 20634 0 0
20777: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20778: LD_INT 0
20780: PPUSH
20781: PPUSH
// skirmish := false ;
20782: LD_ADDR_EXP 88
20786: PUSH
20787: LD_INT 0
20789: ST_TO_ADDR
// debug_mc := false ;
20790: LD_ADDR_EXP 89
20794: PUSH
20795: LD_INT 0
20797: ST_TO_ADDR
// mc_bases := [ ] ;
20798: LD_ADDR_EXP 90
20802: PUSH
20803: EMPTY
20804: ST_TO_ADDR
// mc_sides := [ ] ;
20805: LD_ADDR_EXP 116
20809: PUSH
20810: EMPTY
20811: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20812: LD_ADDR_EXP 91
20816: PUSH
20817: EMPTY
20818: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20819: LD_ADDR_EXP 92
20823: PUSH
20824: EMPTY
20825: ST_TO_ADDR
// mc_need_heal := [ ] ;
20826: LD_ADDR_EXP 93
20830: PUSH
20831: EMPTY
20832: ST_TO_ADDR
// mc_healers := [ ] ;
20833: LD_ADDR_EXP 94
20837: PUSH
20838: EMPTY
20839: ST_TO_ADDR
// mc_build_list := [ ] ;
20840: LD_ADDR_EXP 95
20844: PUSH
20845: EMPTY
20846: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20847: LD_ADDR_EXP 122
20851: PUSH
20852: EMPTY
20853: ST_TO_ADDR
// mc_builders := [ ] ;
20854: LD_ADDR_EXP 96
20858: PUSH
20859: EMPTY
20860: ST_TO_ADDR
// mc_construct_list := [ ] ;
20861: LD_ADDR_EXP 97
20865: PUSH
20866: EMPTY
20867: ST_TO_ADDR
// mc_turret_list := [ ] ;
20868: LD_ADDR_EXP 98
20872: PUSH
20873: EMPTY
20874: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20875: LD_ADDR_EXP 99
20879: PUSH
20880: EMPTY
20881: ST_TO_ADDR
// mc_miners := [ ] ;
20882: LD_ADDR_EXP 104
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_mines := [ ] ;
20889: LD_ADDR_EXP 103
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_minefields := [ ] ;
20896: LD_ADDR_EXP 105
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_crates := [ ] ;
20903: LD_ADDR_EXP 106
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20910: LD_ADDR_EXP 107
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_crates_area := [ ] ;
20917: LD_ADDR_EXP 108
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_vehicles := [ ] ;
20924: LD_ADDR_EXP 109
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_attack := [ ] ;
20931: LD_ADDR_EXP 110
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_produce := [ ] ;
20938: LD_ADDR_EXP 111
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_defender := [ ] ;
20945: LD_ADDR_EXP 112
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_parking := [ ] ;
20952: LD_ADDR_EXP 114
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20959: LD_ADDR_EXP 100
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20966: LD_ADDR_EXP 102
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_scan := [ ] ;
20973: LD_ADDR_EXP 113
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_scan_area := [ ] ;
20980: LD_ADDR_EXP 115
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_tech := [ ] ;
20987: LD_ADDR_EXP 117
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_class := [ ] ;
20994: LD_ADDR_EXP 131
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21001: LD_ADDR_EXP 132
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// end ;
21008: LD_VAR 0 1
21012: RET
// export function MC_Kill ( base ) ; begin
21013: LD_INT 0
21015: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21016: LD_ADDR_EXP 90
21020: PUSH
21021: LD_EXP 90
21025: PPUSH
21026: LD_VAR 0 1
21030: PPUSH
21031: EMPTY
21032: PPUSH
21033: CALL_OW 1
21037: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21038: LD_ADDR_EXP 91
21042: PUSH
21043: LD_EXP 91
21047: PPUSH
21048: LD_VAR 0 1
21052: PPUSH
21053: EMPTY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21060: LD_ADDR_EXP 92
21064: PUSH
21065: LD_EXP 92
21069: PPUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: EMPTY
21076: PPUSH
21077: CALL_OW 1
21081: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21082: LD_ADDR_EXP 93
21086: PUSH
21087: LD_EXP 93
21091: PPUSH
21092: LD_VAR 0 1
21096: PPUSH
21097: EMPTY
21098: PPUSH
21099: CALL_OW 1
21103: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21104: LD_ADDR_EXP 94
21108: PUSH
21109: LD_EXP 94
21113: PPUSH
21114: LD_VAR 0 1
21118: PPUSH
21119: EMPTY
21120: PPUSH
21121: CALL_OW 1
21125: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21126: LD_ADDR_EXP 95
21130: PUSH
21131: LD_EXP 95
21135: PPUSH
21136: LD_VAR 0 1
21140: PPUSH
21141: EMPTY
21142: PPUSH
21143: CALL_OW 1
21147: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21148: LD_ADDR_EXP 96
21152: PUSH
21153: LD_EXP 96
21157: PPUSH
21158: LD_VAR 0 1
21162: PPUSH
21163: EMPTY
21164: PPUSH
21165: CALL_OW 1
21169: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21170: LD_ADDR_EXP 97
21174: PUSH
21175: LD_EXP 97
21179: PPUSH
21180: LD_VAR 0 1
21184: PPUSH
21185: EMPTY
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21192: LD_ADDR_EXP 98
21196: PUSH
21197: LD_EXP 98
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: EMPTY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21214: LD_ADDR_EXP 99
21218: PUSH
21219: LD_EXP 99
21223: PPUSH
21224: LD_VAR 0 1
21228: PPUSH
21229: EMPTY
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21236: LD_ADDR_EXP 100
21240: PUSH
21241: LD_EXP 100
21245: PPUSH
21246: LD_VAR 0 1
21250: PPUSH
21251: EMPTY
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21258: LD_ADDR_EXP 101
21262: PUSH
21263: LD_EXP 101
21267: PPUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: LD_INT 0
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21281: LD_ADDR_EXP 102
21285: PUSH
21286: LD_EXP 102
21290: PPUSH
21291: LD_VAR 0 1
21295: PPUSH
21296: EMPTY
21297: PPUSH
21298: CALL_OW 1
21302: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21303: LD_ADDR_EXP 103
21307: PUSH
21308: LD_EXP 103
21312: PPUSH
21313: LD_VAR 0 1
21317: PPUSH
21318: EMPTY
21319: PPUSH
21320: CALL_OW 1
21324: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21325: LD_ADDR_EXP 104
21329: PUSH
21330: LD_EXP 104
21334: PPUSH
21335: LD_VAR 0 1
21339: PPUSH
21340: EMPTY
21341: PPUSH
21342: CALL_OW 1
21346: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21347: LD_ADDR_EXP 105
21351: PUSH
21352: LD_EXP 105
21356: PPUSH
21357: LD_VAR 0 1
21361: PPUSH
21362: EMPTY
21363: PPUSH
21364: CALL_OW 1
21368: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21369: LD_ADDR_EXP 106
21373: PUSH
21374: LD_EXP 106
21378: PPUSH
21379: LD_VAR 0 1
21383: PPUSH
21384: EMPTY
21385: PPUSH
21386: CALL_OW 1
21390: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21391: LD_ADDR_EXP 107
21395: PUSH
21396: LD_EXP 107
21400: PPUSH
21401: LD_VAR 0 1
21405: PPUSH
21406: EMPTY
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21413: LD_ADDR_EXP 108
21417: PUSH
21418: LD_EXP 108
21422: PPUSH
21423: LD_VAR 0 1
21427: PPUSH
21428: EMPTY
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21435: LD_ADDR_EXP 109
21439: PUSH
21440: LD_EXP 109
21444: PPUSH
21445: LD_VAR 0 1
21449: PPUSH
21450: EMPTY
21451: PPUSH
21452: CALL_OW 1
21456: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21457: LD_ADDR_EXP 110
21461: PUSH
21462: LD_EXP 110
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: EMPTY
21473: PPUSH
21474: CALL_OW 1
21478: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21479: LD_ADDR_EXP 111
21483: PUSH
21484: LD_EXP 111
21488: PPUSH
21489: LD_VAR 0 1
21493: PPUSH
21494: EMPTY
21495: PPUSH
21496: CALL_OW 1
21500: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21501: LD_ADDR_EXP 112
21505: PUSH
21506: LD_EXP 112
21510: PPUSH
21511: LD_VAR 0 1
21515: PPUSH
21516: EMPTY
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21523: LD_ADDR_EXP 113
21527: PUSH
21528: LD_EXP 113
21532: PPUSH
21533: LD_VAR 0 1
21537: PPUSH
21538: EMPTY
21539: PPUSH
21540: CALL_OW 1
21544: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21545: LD_ADDR_EXP 114
21549: PUSH
21550: LD_EXP 114
21554: PPUSH
21555: LD_VAR 0 1
21559: PPUSH
21560: EMPTY
21561: PPUSH
21562: CALL_OW 1
21566: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21567: LD_ADDR_EXP 115
21571: PUSH
21572: LD_EXP 115
21576: PPUSH
21577: LD_VAR 0 1
21581: PPUSH
21582: EMPTY
21583: PPUSH
21584: CALL_OW 1
21588: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21589: LD_ADDR_EXP 117
21593: PUSH
21594: LD_EXP 117
21598: PPUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: EMPTY
21605: PPUSH
21606: CALL_OW 1
21610: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21611: LD_ADDR_EXP 119
21615: PUSH
21616: LD_EXP 119
21620: PPUSH
21621: LD_VAR 0 1
21625: PPUSH
21626: EMPTY
21627: PPUSH
21628: CALL_OW 1
21632: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21633: LD_ADDR_EXP 120
21637: PUSH
21638: LD_EXP 120
21642: PPUSH
21643: LD_VAR 0 1
21647: PPUSH
21648: EMPTY
21649: PPUSH
21650: CALL_OW 1
21654: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21655: LD_ADDR_EXP 121
21659: PUSH
21660: LD_EXP 121
21664: PPUSH
21665: LD_VAR 0 1
21669: PPUSH
21670: EMPTY
21671: PPUSH
21672: CALL_OW 1
21676: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21677: LD_ADDR_EXP 122
21681: PUSH
21682: LD_EXP 122
21686: PPUSH
21687: LD_VAR 0 1
21691: PPUSH
21692: EMPTY
21693: PPUSH
21694: CALL_OW 1
21698: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21699: LD_ADDR_EXP 123
21703: PUSH
21704: LD_EXP 123
21708: PPUSH
21709: LD_VAR 0 1
21713: PPUSH
21714: EMPTY
21715: PPUSH
21716: CALL_OW 1
21720: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21721: LD_ADDR_EXP 124
21725: PUSH
21726: LD_EXP 124
21730: PPUSH
21731: LD_VAR 0 1
21735: PPUSH
21736: EMPTY
21737: PPUSH
21738: CALL_OW 1
21742: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21743: LD_ADDR_EXP 125
21747: PUSH
21748: LD_EXP 125
21752: PPUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: EMPTY
21759: PPUSH
21760: CALL_OW 1
21764: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21765: LD_ADDR_EXP 126
21769: PUSH
21770: LD_EXP 126
21774: PPUSH
21775: LD_VAR 0 1
21779: PPUSH
21780: EMPTY
21781: PPUSH
21782: CALL_OW 1
21786: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21787: LD_ADDR_EXP 127
21791: PUSH
21792: LD_EXP 127
21796: PPUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: EMPTY
21803: PPUSH
21804: CALL_OW 1
21808: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21809: LD_ADDR_EXP 128
21813: PUSH
21814: LD_EXP 128
21818: PPUSH
21819: LD_VAR 0 1
21823: PPUSH
21824: EMPTY
21825: PPUSH
21826: CALL_OW 1
21830: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21831: LD_ADDR_EXP 129
21835: PUSH
21836: LD_EXP 129
21840: PPUSH
21841: LD_VAR 0 1
21845: PPUSH
21846: EMPTY
21847: PPUSH
21848: CALL_OW 1
21852: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21853: LD_ADDR_EXP 130
21857: PUSH
21858: LD_EXP 130
21862: PPUSH
21863: LD_VAR 0 1
21867: PPUSH
21868: EMPTY
21869: PPUSH
21870: CALL_OW 1
21874: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21875: LD_ADDR_EXP 131
21879: PUSH
21880: LD_EXP 131
21884: PPUSH
21885: LD_VAR 0 1
21889: PPUSH
21890: EMPTY
21891: PPUSH
21892: CALL_OW 1
21896: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21897: LD_ADDR_EXP 132
21901: PUSH
21902: LD_EXP 132
21906: PPUSH
21907: LD_VAR 0 1
21911: PPUSH
21912: LD_INT 0
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// end ;
21920: LD_VAR 0 2
21924: RET
// export function MC_Add ( side , units ) ; var base ; begin
21925: LD_INT 0
21927: PPUSH
21928: PPUSH
// base := mc_bases + 1 ;
21929: LD_ADDR_VAR 0 4
21933: PUSH
21934: LD_EXP 90
21938: PUSH
21939: LD_INT 1
21941: PLUS
21942: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21943: LD_ADDR_EXP 116
21947: PUSH
21948: LD_EXP 116
21952: PPUSH
21953: LD_VAR 0 4
21957: PPUSH
21958: LD_VAR 0 1
21962: PPUSH
21963: CALL_OW 1
21967: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21968: LD_ADDR_EXP 90
21972: PUSH
21973: LD_EXP 90
21977: PPUSH
21978: LD_VAR 0 4
21982: PPUSH
21983: LD_VAR 0 2
21987: PPUSH
21988: CALL_OW 1
21992: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21993: LD_ADDR_EXP 91
21997: PUSH
21998: LD_EXP 91
22002: PPUSH
22003: LD_VAR 0 4
22007: PPUSH
22008: EMPTY
22009: PPUSH
22010: CALL_OW 1
22014: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22015: LD_ADDR_EXP 92
22019: PUSH
22020: LD_EXP 92
22024: PPUSH
22025: LD_VAR 0 4
22029: PPUSH
22030: EMPTY
22031: PPUSH
22032: CALL_OW 1
22036: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22037: LD_ADDR_EXP 93
22041: PUSH
22042: LD_EXP 93
22046: PPUSH
22047: LD_VAR 0 4
22051: PPUSH
22052: EMPTY
22053: PPUSH
22054: CALL_OW 1
22058: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22059: LD_ADDR_EXP 94
22063: PUSH
22064: LD_EXP 94
22068: PPUSH
22069: LD_VAR 0 4
22073: PPUSH
22074: EMPTY
22075: PPUSH
22076: CALL_OW 1
22080: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22081: LD_ADDR_EXP 95
22085: PUSH
22086: LD_EXP 95
22090: PPUSH
22091: LD_VAR 0 4
22095: PPUSH
22096: EMPTY
22097: PPUSH
22098: CALL_OW 1
22102: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22103: LD_ADDR_EXP 96
22107: PUSH
22108: LD_EXP 96
22112: PPUSH
22113: LD_VAR 0 4
22117: PPUSH
22118: EMPTY
22119: PPUSH
22120: CALL_OW 1
22124: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22125: LD_ADDR_EXP 97
22129: PUSH
22130: LD_EXP 97
22134: PPUSH
22135: LD_VAR 0 4
22139: PPUSH
22140: EMPTY
22141: PPUSH
22142: CALL_OW 1
22146: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22147: LD_ADDR_EXP 98
22151: PUSH
22152: LD_EXP 98
22156: PPUSH
22157: LD_VAR 0 4
22161: PPUSH
22162: EMPTY
22163: PPUSH
22164: CALL_OW 1
22168: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22169: LD_ADDR_EXP 99
22173: PUSH
22174: LD_EXP 99
22178: PPUSH
22179: LD_VAR 0 4
22183: PPUSH
22184: EMPTY
22185: PPUSH
22186: CALL_OW 1
22190: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22191: LD_ADDR_EXP 100
22195: PUSH
22196: LD_EXP 100
22200: PPUSH
22201: LD_VAR 0 4
22205: PPUSH
22206: EMPTY
22207: PPUSH
22208: CALL_OW 1
22212: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22213: LD_ADDR_EXP 101
22217: PUSH
22218: LD_EXP 101
22222: PPUSH
22223: LD_VAR 0 4
22227: PPUSH
22228: LD_INT 0
22230: PPUSH
22231: CALL_OW 1
22235: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22236: LD_ADDR_EXP 102
22240: PUSH
22241: LD_EXP 102
22245: PPUSH
22246: LD_VAR 0 4
22250: PPUSH
22251: EMPTY
22252: PPUSH
22253: CALL_OW 1
22257: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22258: LD_ADDR_EXP 103
22262: PUSH
22263: LD_EXP 103
22267: PPUSH
22268: LD_VAR 0 4
22272: PPUSH
22273: EMPTY
22274: PPUSH
22275: CALL_OW 1
22279: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22280: LD_ADDR_EXP 104
22284: PUSH
22285: LD_EXP 104
22289: PPUSH
22290: LD_VAR 0 4
22294: PPUSH
22295: EMPTY
22296: PPUSH
22297: CALL_OW 1
22301: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22302: LD_ADDR_EXP 105
22306: PUSH
22307: LD_EXP 105
22311: PPUSH
22312: LD_VAR 0 4
22316: PPUSH
22317: EMPTY
22318: PPUSH
22319: CALL_OW 1
22323: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22324: LD_ADDR_EXP 106
22328: PUSH
22329: LD_EXP 106
22333: PPUSH
22334: LD_VAR 0 4
22338: PPUSH
22339: EMPTY
22340: PPUSH
22341: CALL_OW 1
22345: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22346: LD_ADDR_EXP 107
22350: PUSH
22351: LD_EXP 107
22355: PPUSH
22356: LD_VAR 0 4
22360: PPUSH
22361: EMPTY
22362: PPUSH
22363: CALL_OW 1
22367: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22368: LD_ADDR_EXP 108
22372: PUSH
22373: LD_EXP 108
22377: PPUSH
22378: LD_VAR 0 4
22382: PPUSH
22383: EMPTY
22384: PPUSH
22385: CALL_OW 1
22389: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22390: LD_ADDR_EXP 109
22394: PUSH
22395: LD_EXP 109
22399: PPUSH
22400: LD_VAR 0 4
22404: PPUSH
22405: EMPTY
22406: PPUSH
22407: CALL_OW 1
22411: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22412: LD_ADDR_EXP 110
22416: PUSH
22417: LD_EXP 110
22421: PPUSH
22422: LD_VAR 0 4
22426: PPUSH
22427: EMPTY
22428: PPUSH
22429: CALL_OW 1
22433: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22434: LD_ADDR_EXP 111
22438: PUSH
22439: LD_EXP 111
22443: PPUSH
22444: LD_VAR 0 4
22448: PPUSH
22449: EMPTY
22450: PPUSH
22451: CALL_OW 1
22455: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22456: LD_ADDR_EXP 112
22460: PUSH
22461: LD_EXP 112
22465: PPUSH
22466: LD_VAR 0 4
22470: PPUSH
22471: EMPTY
22472: PPUSH
22473: CALL_OW 1
22477: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22478: LD_ADDR_EXP 113
22482: PUSH
22483: LD_EXP 113
22487: PPUSH
22488: LD_VAR 0 4
22492: PPUSH
22493: EMPTY
22494: PPUSH
22495: CALL_OW 1
22499: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22500: LD_ADDR_EXP 114
22504: PUSH
22505: LD_EXP 114
22509: PPUSH
22510: LD_VAR 0 4
22514: PPUSH
22515: EMPTY
22516: PPUSH
22517: CALL_OW 1
22521: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22522: LD_ADDR_EXP 115
22526: PUSH
22527: LD_EXP 115
22531: PPUSH
22532: LD_VAR 0 4
22536: PPUSH
22537: EMPTY
22538: PPUSH
22539: CALL_OW 1
22543: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22544: LD_ADDR_EXP 117
22548: PUSH
22549: LD_EXP 117
22553: PPUSH
22554: LD_VAR 0 4
22558: PPUSH
22559: EMPTY
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22566: LD_ADDR_EXP 119
22570: PUSH
22571: LD_EXP 119
22575: PPUSH
22576: LD_VAR 0 4
22580: PPUSH
22581: EMPTY
22582: PPUSH
22583: CALL_OW 1
22587: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22588: LD_ADDR_EXP 120
22592: PUSH
22593: LD_EXP 120
22597: PPUSH
22598: LD_VAR 0 4
22602: PPUSH
22603: EMPTY
22604: PPUSH
22605: CALL_OW 1
22609: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22610: LD_ADDR_EXP 121
22614: PUSH
22615: LD_EXP 121
22619: PPUSH
22620: LD_VAR 0 4
22624: PPUSH
22625: EMPTY
22626: PPUSH
22627: CALL_OW 1
22631: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22632: LD_ADDR_EXP 122
22636: PUSH
22637: LD_EXP 122
22641: PPUSH
22642: LD_VAR 0 4
22646: PPUSH
22647: EMPTY
22648: PPUSH
22649: CALL_OW 1
22653: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22654: LD_ADDR_EXP 123
22658: PUSH
22659: LD_EXP 123
22663: PPUSH
22664: LD_VAR 0 4
22668: PPUSH
22669: EMPTY
22670: PPUSH
22671: CALL_OW 1
22675: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22676: LD_ADDR_EXP 124
22680: PUSH
22681: LD_EXP 124
22685: PPUSH
22686: LD_VAR 0 4
22690: PPUSH
22691: EMPTY
22692: PPUSH
22693: CALL_OW 1
22697: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22698: LD_ADDR_EXP 125
22702: PUSH
22703: LD_EXP 125
22707: PPUSH
22708: LD_VAR 0 4
22712: PPUSH
22713: EMPTY
22714: PPUSH
22715: CALL_OW 1
22719: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22720: LD_ADDR_EXP 126
22724: PUSH
22725: LD_EXP 126
22729: PPUSH
22730: LD_VAR 0 4
22734: PPUSH
22735: EMPTY
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22742: LD_ADDR_EXP 127
22746: PUSH
22747: LD_EXP 127
22751: PPUSH
22752: LD_VAR 0 4
22756: PPUSH
22757: EMPTY
22758: PPUSH
22759: CALL_OW 1
22763: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22764: LD_ADDR_EXP 128
22768: PUSH
22769: LD_EXP 128
22773: PPUSH
22774: LD_VAR 0 4
22778: PPUSH
22779: EMPTY
22780: PPUSH
22781: CALL_OW 1
22785: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22786: LD_ADDR_EXP 129
22790: PUSH
22791: LD_EXP 129
22795: PPUSH
22796: LD_VAR 0 4
22800: PPUSH
22801: EMPTY
22802: PPUSH
22803: CALL_OW 1
22807: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22808: LD_ADDR_EXP 130
22812: PUSH
22813: LD_EXP 130
22817: PPUSH
22818: LD_VAR 0 4
22822: PPUSH
22823: EMPTY
22824: PPUSH
22825: CALL_OW 1
22829: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22830: LD_ADDR_EXP 131
22834: PUSH
22835: LD_EXP 131
22839: PPUSH
22840: LD_VAR 0 4
22844: PPUSH
22845: EMPTY
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22852: LD_ADDR_EXP 132
22856: PUSH
22857: LD_EXP 132
22861: PPUSH
22862: LD_VAR 0 4
22866: PPUSH
22867: LD_INT 0
22869: PPUSH
22870: CALL_OW 1
22874: ST_TO_ADDR
// result := base ;
22875: LD_ADDR_VAR 0 3
22879: PUSH
22880: LD_VAR 0 4
22884: ST_TO_ADDR
// end ;
22885: LD_VAR 0 3
22889: RET
// export function MC_Start ( ) ; var i ; begin
22890: LD_INT 0
22892: PPUSH
22893: PPUSH
// for i = 1 to mc_bases do
22894: LD_ADDR_VAR 0 2
22898: PUSH
22899: DOUBLE
22900: LD_INT 1
22902: DEC
22903: ST_TO_ADDR
22904: LD_EXP 90
22908: PUSH
22909: FOR_TO
22910: IFFALSE 23987
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22912: LD_ADDR_EXP 90
22916: PUSH
22917: LD_EXP 90
22921: PPUSH
22922: LD_VAR 0 2
22926: PPUSH
22927: LD_EXP 90
22931: PUSH
22932: LD_VAR 0 2
22936: ARRAY
22937: PUSH
22938: LD_INT 0
22940: DIFF
22941: PPUSH
22942: CALL_OW 1
22946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22947: LD_ADDR_EXP 91
22951: PUSH
22952: LD_EXP 91
22956: PPUSH
22957: LD_VAR 0 2
22961: PPUSH
22962: EMPTY
22963: PPUSH
22964: CALL_OW 1
22968: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22969: LD_ADDR_EXP 92
22973: PUSH
22974: LD_EXP 92
22978: PPUSH
22979: LD_VAR 0 2
22983: PPUSH
22984: EMPTY
22985: PPUSH
22986: CALL_OW 1
22990: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22991: LD_ADDR_EXP 93
22995: PUSH
22996: LD_EXP 93
23000: PPUSH
23001: LD_VAR 0 2
23005: PPUSH
23006: EMPTY
23007: PPUSH
23008: CALL_OW 1
23012: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23013: LD_ADDR_EXP 94
23017: PUSH
23018: LD_EXP 94
23022: PPUSH
23023: LD_VAR 0 2
23027: PPUSH
23028: EMPTY
23029: PUSH
23030: EMPTY
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 1
23040: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23041: LD_ADDR_EXP 95
23045: PUSH
23046: LD_EXP 95
23050: PPUSH
23051: LD_VAR 0 2
23055: PPUSH
23056: EMPTY
23057: PPUSH
23058: CALL_OW 1
23062: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23063: LD_ADDR_EXP 122
23067: PUSH
23068: LD_EXP 122
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: EMPTY
23079: PPUSH
23080: CALL_OW 1
23084: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23085: LD_ADDR_EXP 96
23089: PUSH
23090: LD_EXP 96
23094: PPUSH
23095: LD_VAR 0 2
23099: PPUSH
23100: EMPTY
23101: PPUSH
23102: CALL_OW 1
23106: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23107: LD_ADDR_EXP 97
23111: PUSH
23112: LD_EXP 97
23116: PPUSH
23117: LD_VAR 0 2
23121: PPUSH
23122: EMPTY
23123: PPUSH
23124: CALL_OW 1
23128: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23129: LD_ADDR_EXP 98
23133: PUSH
23134: LD_EXP 98
23138: PPUSH
23139: LD_VAR 0 2
23143: PPUSH
23144: LD_EXP 90
23148: PUSH
23149: LD_VAR 0 2
23153: ARRAY
23154: PPUSH
23155: LD_INT 2
23157: PUSH
23158: LD_INT 30
23160: PUSH
23161: LD_INT 32
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: LD_INT 30
23170: PUSH
23171: LD_INT 33
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: PPUSH
23183: CALL_OW 72
23187: PPUSH
23188: CALL_OW 1
23192: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23193: LD_ADDR_EXP 99
23197: PUSH
23198: LD_EXP 99
23202: PPUSH
23203: LD_VAR 0 2
23207: PPUSH
23208: LD_EXP 90
23212: PUSH
23213: LD_VAR 0 2
23217: ARRAY
23218: PPUSH
23219: LD_INT 2
23221: PUSH
23222: LD_INT 30
23224: PUSH
23225: LD_INT 32
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: LD_INT 30
23234: PUSH
23235: LD_INT 31
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 58
23249: PUSH
23250: EMPTY
23251: LIST
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 72
23261: PPUSH
23262: CALL_OW 1
23266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23267: LD_ADDR_EXP 100
23271: PUSH
23272: LD_EXP 100
23276: PPUSH
23277: LD_VAR 0 2
23281: PPUSH
23282: EMPTY
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23289: LD_ADDR_EXP 104
23293: PUSH
23294: LD_EXP 104
23298: PPUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23311: LD_ADDR_EXP 103
23315: PUSH
23316: LD_EXP 103
23320: PPUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: EMPTY
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23333: LD_ADDR_EXP 105
23337: PUSH
23338: LD_EXP 105
23342: PPUSH
23343: LD_VAR 0 2
23347: PPUSH
23348: EMPTY
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23355: LD_ADDR_EXP 106
23359: PUSH
23360: LD_EXP 106
23364: PPUSH
23365: LD_VAR 0 2
23369: PPUSH
23370: EMPTY
23371: PPUSH
23372: CALL_OW 1
23376: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23377: LD_ADDR_EXP 107
23381: PUSH
23382: LD_EXP 107
23386: PPUSH
23387: LD_VAR 0 2
23391: PPUSH
23392: EMPTY
23393: PPUSH
23394: CALL_OW 1
23398: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23399: LD_ADDR_EXP 108
23403: PUSH
23404: LD_EXP 108
23408: PPUSH
23409: LD_VAR 0 2
23413: PPUSH
23414: EMPTY
23415: PPUSH
23416: CALL_OW 1
23420: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23421: LD_ADDR_EXP 109
23425: PUSH
23426: LD_EXP 109
23430: PPUSH
23431: LD_VAR 0 2
23435: PPUSH
23436: EMPTY
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23443: LD_ADDR_EXP 110
23447: PUSH
23448: LD_EXP 110
23452: PPUSH
23453: LD_VAR 0 2
23457: PPUSH
23458: EMPTY
23459: PPUSH
23460: CALL_OW 1
23464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23465: LD_ADDR_EXP 111
23469: PUSH
23470: LD_EXP 111
23474: PPUSH
23475: LD_VAR 0 2
23479: PPUSH
23480: EMPTY
23481: PPUSH
23482: CALL_OW 1
23486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23487: LD_ADDR_EXP 112
23491: PUSH
23492: LD_EXP 112
23496: PPUSH
23497: LD_VAR 0 2
23501: PPUSH
23502: EMPTY
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23509: LD_ADDR_EXP 101
23513: PUSH
23514: LD_EXP 101
23518: PPUSH
23519: LD_VAR 0 2
23523: PPUSH
23524: LD_INT 0
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23532: LD_ADDR_EXP 114
23536: PUSH
23537: LD_EXP 114
23541: PPUSH
23542: LD_VAR 0 2
23546: PPUSH
23547: LD_INT 0
23549: PPUSH
23550: CALL_OW 1
23554: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23555: LD_ADDR_EXP 102
23559: PUSH
23560: LD_EXP 102
23564: PPUSH
23565: LD_VAR 0 2
23569: PPUSH
23570: EMPTY
23571: PPUSH
23572: CALL_OW 1
23576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23577: LD_ADDR_EXP 113
23581: PUSH
23582: LD_EXP 113
23586: PPUSH
23587: LD_VAR 0 2
23591: PPUSH
23592: LD_INT 0
23594: PPUSH
23595: CALL_OW 1
23599: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23600: LD_ADDR_EXP 115
23604: PUSH
23605: LD_EXP 115
23609: PPUSH
23610: LD_VAR 0 2
23614: PPUSH
23615: EMPTY
23616: PPUSH
23617: CALL_OW 1
23621: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23622: LD_ADDR_EXP 118
23626: PUSH
23627: LD_EXP 118
23631: PPUSH
23632: LD_VAR 0 2
23636: PPUSH
23637: LD_INT 0
23639: PPUSH
23640: CALL_OW 1
23644: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23645: LD_ADDR_EXP 119
23649: PUSH
23650: LD_EXP 119
23654: PPUSH
23655: LD_VAR 0 2
23659: PPUSH
23660: EMPTY
23661: PPUSH
23662: CALL_OW 1
23666: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23667: LD_ADDR_EXP 120
23671: PUSH
23672: LD_EXP 120
23676: PPUSH
23677: LD_VAR 0 2
23681: PPUSH
23682: EMPTY
23683: PPUSH
23684: CALL_OW 1
23688: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23689: LD_ADDR_EXP 121
23693: PUSH
23694: LD_EXP 121
23698: PPUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: EMPTY
23705: PPUSH
23706: CALL_OW 1
23710: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23711: LD_ADDR_EXP 123
23715: PUSH
23716: LD_EXP 123
23720: PPUSH
23721: LD_VAR 0 2
23725: PPUSH
23726: LD_EXP 90
23730: PUSH
23731: LD_VAR 0 2
23735: ARRAY
23736: PPUSH
23737: LD_INT 2
23739: PUSH
23740: LD_INT 30
23742: PUSH
23743: LD_INT 6
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: LD_INT 30
23752: PUSH
23753: LD_INT 7
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: LD_INT 30
23762: PUSH
23763: LD_INT 8
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: PPUSH
23776: CALL_OW 72
23780: PPUSH
23781: CALL_OW 1
23785: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23786: LD_ADDR_EXP 124
23790: PUSH
23791: LD_EXP 124
23795: PPUSH
23796: LD_VAR 0 2
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23808: LD_ADDR_EXP 125
23812: PUSH
23813: LD_EXP 125
23817: PPUSH
23818: LD_VAR 0 2
23822: PPUSH
23823: EMPTY
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23830: LD_ADDR_EXP 126
23834: PUSH
23835: LD_EXP 126
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23852: LD_ADDR_EXP 127
23856: PUSH
23857: LD_EXP 127
23861: PPUSH
23862: LD_VAR 0 2
23866: PPUSH
23867: EMPTY
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23874: LD_ADDR_EXP 128
23878: PUSH
23879: LD_EXP 128
23883: PPUSH
23884: LD_VAR 0 2
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23896: LD_ADDR_EXP 129
23900: PUSH
23901: LD_EXP 129
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23918: LD_ADDR_EXP 130
23922: PUSH
23923: LD_EXP 130
23927: PPUSH
23928: LD_VAR 0 2
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23940: LD_ADDR_EXP 131
23944: PUSH
23945: LD_EXP 131
23949: PPUSH
23950: LD_VAR 0 2
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23962: LD_ADDR_EXP 132
23966: PUSH
23967: LD_EXP 132
23971: PPUSH
23972: LD_VAR 0 2
23976: PPUSH
23977: LD_INT 0
23979: PPUSH
23980: CALL_OW 1
23984: ST_TO_ADDR
// end ;
23985: GO 22909
23987: POP
23988: POP
// MC_InitSides ( ) ;
23989: CALL 24275 0 0
// MC_InitResearch ( ) ;
23993: CALL 24014 0 0
// CustomInitMacro ( ) ;
23997: CALL 217 0 0
// skirmish := true ;
24001: LD_ADDR_EXP 88
24005: PUSH
24006: LD_INT 1
24008: ST_TO_ADDR
// end ;
24009: LD_VAR 0 1
24013: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24014: LD_INT 0
24016: PPUSH
24017: PPUSH
24018: PPUSH
24019: PPUSH
24020: PPUSH
24021: PPUSH
// if not mc_bases then
24022: LD_EXP 90
24026: NOT
24027: IFFALSE 24031
// exit ;
24029: GO 24270
// for i = 1 to 8 do
24031: LD_ADDR_VAR 0 2
24035: PUSH
24036: DOUBLE
24037: LD_INT 1
24039: DEC
24040: ST_TO_ADDR
24041: LD_INT 8
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24071
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24047: LD_ADDR_EXP 117
24051: PUSH
24052: LD_EXP 117
24056: PPUSH
24057: LD_VAR 0 2
24061: PPUSH
24062: EMPTY
24063: PPUSH
24064: CALL_OW 1
24068: ST_TO_ADDR
24069: GO 24044
24071: POP
24072: POP
// tmp := [ ] ;
24073: LD_ADDR_VAR 0 5
24077: PUSH
24078: EMPTY
24079: ST_TO_ADDR
// for i = 1 to mc_sides do
24080: LD_ADDR_VAR 0 2
24084: PUSH
24085: DOUBLE
24086: LD_INT 1
24088: DEC
24089: ST_TO_ADDR
24090: LD_EXP 116
24094: PUSH
24095: FOR_TO
24096: IFFALSE 24154
// if not mc_sides [ i ] in tmp then
24098: LD_EXP 116
24102: PUSH
24103: LD_VAR 0 2
24107: ARRAY
24108: PUSH
24109: LD_VAR 0 5
24113: IN
24114: NOT
24115: IFFALSE 24152
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24117: LD_ADDR_VAR 0 5
24121: PUSH
24122: LD_VAR 0 5
24126: PPUSH
24127: LD_VAR 0 5
24131: PUSH
24132: LD_INT 1
24134: PLUS
24135: PPUSH
24136: LD_EXP 116
24140: PUSH
24141: LD_VAR 0 2
24145: ARRAY
24146: PPUSH
24147: CALL_OW 2
24151: ST_TO_ADDR
24152: GO 24095
24154: POP
24155: POP
// if not tmp then
24156: LD_VAR 0 5
24160: NOT
24161: IFFALSE 24165
// exit ;
24163: GO 24270
// for j in tmp do
24165: LD_ADDR_VAR 0 3
24169: PUSH
24170: LD_VAR 0 5
24174: PUSH
24175: FOR_IN
24176: IFFALSE 24268
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24178: LD_ADDR_VAR 0 6
24182: PUSH
24183: LD_INT 22
24185: PUSH
24186: LD_VAR 0 3
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PPUSH
24195: CALL_OW 69
24199: ST_TO_ADDR
// if not un then
24200: LD_VAR 0 6
24204: NOT
24205: IFFALSE 24209
// continue ;
24207: GO 24175
// nation := GetNation ( un [ 1 ] ) ;
24209: LD_ADDR_VAR 0 4
24213: PUSH
24214: LD_VAR 0 6
24218: PUSH
24219: LD_INT 1
24221: ARRAY
24222: PPUSH
24223: CALL_OW 248
24227: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24228: LD_ADDR_EXP 117
24232: PUSH
24233: LD_EXP 117
24237: PPUSH
24238: LD_VAR 0 3
24242: PPUSH
24243: LD_VAR 0 3
24247: PPUSH
24248: LD_VAR 0 4
24252: PPUSH
24253: LD_INT 1
24255: PPUSH
24256: CALL 50909 0 3
24260: PPUSH
24261: CALL_OW 1
24265: ST_TO_ADDR
// end ;
24266: GO 24175
24268: POP
24269: POP
// end ;
24270: LD_VAR 0 1
24274: RET
// export function MC_InitSides ( ) ; var i ; begin
24275: LD_INT 0
24277: PPUSH
24278: PPUSH
// if not mc_bases then
24279: LD_EXP 90
24283: NOT
24284: IFFALSE 24288
// exit ;
24286: GO 24362
// for i = 1 to mc_bases do
24288: LD_ADDR_VAR 0 2
24292: PUSH
24293: DOUBLE
24294: LD_INT 1
24296: DEC
24297: ST_TO_ADDR
24298: LD_EXP 90
24302: PUSH
24303: FOR_TO
24304: IFFALSE 24360
// if mc_bases [ i ] then
24306: LD_EXP 90
24310: PUSH
24311: LD_VAR 0 2
24315: ARRAY
24316: IFFALSE 24358
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24318: LD_ADDR_EXP 116
24322: PUSH
24323: LD_EXP 116
24327: PPUSH
24328: LD_VAR 0 2
24332: PPUSH
24333: LD_EXP 90
24337: PUSH
24338: LD_VAR 0 2
24342: ARRAY
24343: PUSH
24344: LD_INT 1
24346: ARRAY
24347: PPUSH
24348: CALL_OW 255
24352: PPUSH
24353: CALL_OW 1
24357: ST_TO_ADDR
24358: GO 24303
24360: POP
24361: POP
// end ;
24362: LD_VAR 0 1
24366: RET
// every 0 0$01 trigger skirmish do
24367: LD_EXP 88
24371: IFFALSE 24525
24373: GO 24375
24375: DISABLE
// begin enable ;
24376: ENABLE
// MC_CheckBuildings ( ) ;
24377: CALL 29023 0 0
// MC_CheckPeopleLife ( ) ;
24381: CALL 29148 0 0
// RaiseSailEvent ( 100 ) ;
24385: LD_INT 100
24387: PPUSH
24388: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24392: LD_INT 103
24394: PPUSH
24395: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24399: LD_INT 104
24401: PPUSH
24402: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24406: LD_INT 105
24408: PPUSH
24409: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24413: LD_INT 106
24415: PPUSH
24416: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24420: LD_INT 107
24422: PPUSH
24423: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24427: LD_INT 108
24429: PPUSH
24430: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24434: LD_INT 109
24436: PPUSH
24437: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24441: LD_INT 110
24443: PPUSH
24444: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24448: LD_INT 111
24450: PPUSH
24451: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24455: LD_INT 112
24457: PPUSH
24458: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24462: LD_INT 113
24464: PPUSH
24465: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24469: LD_INT 120
24471: PPUSH
24472: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24476: LD_INT 121
24478: PPUSH
24479: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24483: LD_INT 122
24485: PPUSH
24486: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24490: LD_INT 123
24492: PPUSH
24493: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24497: LD_INT 124
24499: PPUSH
24500: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24504: LD_INT 125
24506: PPUSH
24507: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24511: LD_INT 126
24513: PPUSH
24514: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24518: LD_INT 200
24520: PPUSH
24521: CALL_OW 427
// end ;
24525: END
// on SailEvent ( event ) do begin if event < 100 then
24526: LD_VAR 0 1
24530: PUSH
24531: LD_INT 100
24533: LESS
24534: IFFALSE 24545
// CustomEvent ( event ) ;
24536: LD_VAR 0 1
24540: PPUSH
24541: CALL 10417 0 1
// if event = 100 then
24545: LD_VAR 0 1
24549: PUSH
24550: LD_INT 100
24552: EQUAL
24553: IFFALSE 24559
// MC_ClassManager ( ) ;
24555: CALL 24951 0 0
// if event = 101 then
24559: LD_VAR 0 1
24563: PUSH
24564: LD_INT 101
24566: EQUAL
24567: IFFALSE 24573
// MC_RepairBuildings ( ) ;
24569: CALL 29733 0 0
// if event = 102 then
24573: LD_VAR 0 1
24577: PUSH
24578: LD_INT 102
24580: EQUAL
24581: IFFALSE 24587
// MC_Heal ( ) ;
24583: CALL 30618 0 0
// if event = 103 then
24587: LD_VAR 0 1
24591: PUSH
24592: LD_INT 103
24594: EQUAL
24595: IFFALSE 24601
// MC_Build ( ) ;
24597: CALL 31040 0 0
// if event = 104 then
24601: LD_VAR 0 1
24605: PUSH
24606: LD_INT 104
24608: EQUAL
24609: IFFALSE 24615
// MC_TurretWeapon ( ) ;
24611: CALL 32653 0 0
// if event = 105 then
24615: LD_VAR 0 1
24619: PUSH
24620: LD_INT 105
24622: EQUAL
24623: IFFALSE 24629
// MC_BuildUpgrade ( ) ;
24625: CALL 32204 0 0
// if event = 106 then
24629: LD_VAR 0 1
24633: PUSH
24634: LD_INT 106
24636: EQUAL
24637: IFFALSE 24643
// MC_PlantMines ( ) ;
24639: CALL 33083 0 0
// if event = 107 then
24643: LD_VAR 0 1
24647: PUSH
24648: LD_INT 107
24650: EQUAL
24651: IFFALSE 24657
// MC_CollectCrates ( ) ;
24653: CALL 33881 0 0
// if event = 108 then
24657: LD_VAR 0 1
24661: PUSH
24662: LD_INT 108
24664: EQUAL
24665: IFFALSE 24671
// MC_LinkRemoteControl ( ) ;
24667: CALL 35657 0 0
// if event = 109 then
24671: LD_VAR 0 1
24675: PUSH
24676: LD_INT 109
24678: EQUAL
24679: IFFALSE 24685
// MC_ProduceVehicle ( ) ;
24681: CALL 35838 0 0
// if event = 110 then
24685: LD_VAR 0 1
24689: PUSH
24690: LD_INT 110
24692: EQUAL
24693: IFFALSE 24699
// MC_SendAttack ( ) ;
24695: CALL 36304 0 0
// if event = 111 then
24699: LD_VAR 0 1
24703: PUSH
24704: LD_INT 111
24706: EQUAL
24707: IFFALSE 24713
// MC_Defend ( ) ;
24709: CALL 36412 0 0
// if event = 112 then
24713: LD_VAR 0 1
24717: PUSH
24718: LD_INT 112
24720: EQUAL
24721: IFFALSE 24727
// MC_Research ( ) ;
24723: CALL 37017 0 0
// if event = 113 then
24727: LD_VAR 0 1
24731: PUSH
24732: LD_INT 113
24734: EQUAL
24735: IFFALSE 24741
// MC_MinesTrigger ( ) ;
24737: CALL 38131 0 0
// if event = 120 then
24741: LD_VAR 0 1
24745: PUSH
24746: LD_INT 120
24748: EQUAL
24749: IFFALSE 24755
// MC_RepairVehicle ( ) ;
24751: CALL 38230 0 0
// if event = 121 then
24755: LD_VAR 0 1
24759: PUSH
24760: LD_INT 121
24762: EQUAL
24763: IFFALSE 24769
// MC_TameApe ( ) ;
24765: CALL 38960 0 0
// if event = 122 then
24769: LD_VAR 0 1
24773: PUSH
24774: LD_INT 122
24776: EQUAL
24777: IFFALSE 24783
// MC_ChangeApeClass ( ) ;
24779: CALL 39789 0 0
// if event = 123 then
24783: LD_VAR 0 1
24787: PUSH
24788: LD_INT 123
24790: EQUAL
24791: IFFALSE 24797
// MC_Bazooka ( ) ;
24793: CALL 40439 0 0
// if event = 124 then
24797: LD_VAR 0 1
24801: PUSH
24802: LD_INT 124
24804: EQUAL
24805: IFFALSE 24811
// MC_TeleportExit ( ) ;
24807: CALL 40637 0 0
// if event = 125 then
24811: LD_VAR 0 1
24815: PUSH
24816: LD_INT 125
24818: EQUAL
24819: IFFALSE 24825
// MC_Deposits ( ) ;
24821: CALL 41284 0 0
// if event = 126 then
24825: LD_VAR 0 1
24829: PUSH
24830: LD_INT 126
24832: EQUAL
24833: IFFALSE 24839
// MC_RemoteDriver ( ) ;
24835: CALL 41909 0 0
// if event = 200 then
24839: LD_VAR 0 1
24843: PUSH
24844: LD_INT 200
24846: EQUAL
24847: IFFALSE 24853
// MC_Idle ( ) ;
24849: CALL 43858 0 0
// end ;
24853: PPOPN 1
24855: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24856: LD_INT 0
24858: PPUSH
24859: PPUSH
// if not mc_bases [ base ] or not tag then
24860: LD_EXP 90
24864: PUSH
24865: LD_VAR 0 1
24869: ARRAY
24870: NOT
24871: PUSH
24872: LD_VAR 0 2
24876: NOT
24877: OR
24878: IFFALSE 24882
// exit ;
24880: GO 24946
// for i in mc_bases [ base ] union mc_ape [ base ] do
24882: LD_ADDR_VAR 0 4
24886: PUSH
24887: LD_EXP 90
24891: PUSH
24892: LD_VAR 0 1
24896: ARRAY
24897: PUSH
24898: LD_EXP 119
24902: PUSH
24903: LD_VAR 0 1
24907: ARRAY
24908: UNION
24909: PUSH
24910: FOR_IN
24911: IFFALSE 24944
// if GetTag ( i ) = tag then
24913: LD_VAR 0 4
24917: PPUSH
24918: CALL_OW 110
24922: PUSH
24923: LD_VAR 0 2
24927: EQUAL
24928: IFFALSE 24942
// SetTag ( i , 0 ) ;
24930: LD_VAR 0 4
24934: PPUSH
24935: LD_INT 0
24937: PPUSH
24938: CALL_OW 109
24942: GO 24910
24944: POP
24945: POP
// end ;
24946: LD_VAR 0 3
24950: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24951: LD_INT 0
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
// if not mc_bases then
24961: LD_EXP 90
24965: NOT
24966: IFFALSE 24970
// exit ;
24968: GO 25428
// for i = 1 to mc_bases do
24970: LD_ADDR_VAR 0 2
24974: PUSH
24975: DOUBLE
24976: LD_INT 1
24978: DEC
24979: ST_TO_ADDR
24980: LD_EXP 90
24984: PUSH
24985: FOR_TO
24986: IFFALSE 25426
// begin tmp := MC_ClassCheckReq ( i ) ;
24988: LD_ADDR_VAR 0 4
24992: PUSH
24993: LD_VAR 0 2
24997: PPUSH
24998: CALL 25433 0 1
25002: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25003: LD_ADDR_EXP 131
25007: PUSH
25008: LD_EXP 131
25012: PPUSH
25013: LD_VAR 0 2
25017: PPUSH
25018: LD_VAR 0 4
25022: PPUSH
25023: CALL_OW 1
25027: ST_TO_ADDR
// if not tmp then
25028: LD_VAR 0 4
25032: NOT
25033: IFFALSE 25037
// continue ;
25035: GO 24985
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25037: LD_ADDR_VAR 0 6
25041: PUSH
25042: LD_EXP 90
25046: PUSH
25047: LD_VAR 0 2
25051: ARRAY
25052: PPUSH
25053: LD_INT 2
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 4
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: LD_INT 30
25068: PUSH
25069: LD_INT 5
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: EMPTY
25077: LIST
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: PUSH
25086: LD_EXP 90
25090: PUSH
25091: LD_VAR 0 2
25095: ARRAY
25096: PPUSH
25097: LD_INT 2
25099: PUSH
25100: LD_INT 30
25102: PUSH
25103: LD_INT 0
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 30
25112: PUSH
25113: LD_INT 1
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: LIST
25124: PPUSH
25125: CALL_OW 72
25129: PUSH
25130: LD_EXP 90
25134: PUSH
25135: LD_VAR 0 2
25139: ARRAY
25140: PPUSH
25141: LD_INT 30
25143: PUSH
25144: LD_INT 3
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PPUSH
25151: CALL_OW 72
25155: PUSH
25156: LD_EXP 90
25160: PUSH
25161: LD_VAR 0 2
25165: ARRAY
25166: PPUSH
25167: LD_INT 2
25169: PUSH
25170: LD_INT 30
25172: PUSH
25173: LD_INT 6
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 30
25182: PUSH
25183: LD_INT 7
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: PPUSH
25206: CALL_OW 72
25210: PUSH
25211: EMPTY
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: ST_TO_ADDR
// for j = 1 to 4 do
25217: LD_ADDR_VAR 0 3
25221: PUSH
25222: DOUBLE
25223: LD_INT 1
25225: DEC
25226: ST_TO_ADDR
25227: LD_INT 4
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25422
// begin if not tmp [ j ] then
25233: LD_VAR 0 4
25237: PUSH
25238: LD_VAR 0 3
25242: ARRAY
25243: NOT
25244: IFFALSE 25248
// continue ;
25246: GO 25230
// for p in tmp [ j ] do
25248: LD_ADDR_VAR 0 5
25252: PUSH
25253: LD_VAR 0 4
25257: PUSH
25258: LD_VAR 0 3
25262: ARRAY
25263: PUSH
25264: FOR_IN
25265: IFFALSE 25418
// begin if not b [ j ] then
25267: LD_VAR 0 6
25271: PUSH
25272: LD_VAR 0 3
25276: ARRAY
25277: NOT
25278: IFFALSE 25282
// break ;
25280: GO 25418
// e := 0 ;
25282: LD_ADDR_VAR 0 7
25286: PUSH
25287: LD_INT 0
25289: ST_TO_ADDR
// for k in b [ j ] do
25290: LD_ADDR_VAR 0 8
25294: PUSH
25295: LD_VAR 0 6
25299: PUSH
25300: LD_VAR 0 3
25304: ARRAY
25305: PUSH
25306: FOR_IN
25307: IFFALSE 25334
// if IsNotFull ( k ) then
25309: LD_VAR 0 8
25313: PPUSH
25314: CALL 53058 0 1
25318: IFFALSE 25332
// begin e := k ;
25320: LD_ADDR_VAR 0 7
25324: PUSH
25325: LD_VAR 0 8
25329: ST_TO_ADDR
// break ;
25330: GO 25334
// end ;
25332: GO 25306
25334: POP
25335: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25336: LD_VAR 0 7
25340: PUSH
25341: LD_VAR 0 5
25345: PPUSH
25346: LD_VAR 0 7
25350: PPUSH
25351: CALL 85478 0 2
25355: NOT
25356: AND
25357: IFFALSE 25416
// begin if IsInUnit ( p ) then
25359: LD_VAR 0 5
25363: PPUSH
25364: CALL_OW 310
25368: IFFALSE 25379
// ComExitBuilding ( p ) ;
25370: LD_VAR 0 5
25374: PPUSH
25375: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25379: LD_VAR 0 5
25383: PPUSH
25384: LD_VAR 0 7
25388: PPUSH
25389: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25393: LD_VAR 0 5
25397: PPUSH
25398: LD_VAR 0 3
25402: PPUSH
25403: CALL_OW 183
// AddComExitBuilding ( p ) ;
25407: LD_VAR 0 5
25411: PPUSH
25412: CALL_OW 182
// end ; end ;
25416: GO 25264
25418: POP
25419: POP
// end ;
25420: GO 25230
25422: POP
25423: POP
// end ;
25424: GO 24985
25426: POP
25427: POP
// end ;
25428: LD_VAR 0 1
25432: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25433: LD_INT 0
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25447: LD_VAR 0 1
25451: NOT
25452: PUSH
25453: LD_EXP 90
25457: PUSH
25458: LD_VAR 0 1
25462: ARRAY
25463: NOT
25464: OR
25465: PUSH
25466: LD_EXP 90
25470: PUSH
25471: LD_VAR 0 1
25475: ARRAY
25476: PPUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 0
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 30
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PPUSH
25505: CALL_OW 72
25509: NOT
25510: OR
25511: IFFALSE 25515
// exit ;
25513: GO 29018
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25515: LD_ADDR_VAR 0 4
25519: PUSH
25520: LD_EXP 90
25524: PUSH
25525: LD_VAR 0 1
25529: ARRAY
25530: PPUSH
25531: LD_INT 2
25533: PUSH
25534: LD_INT 25
25536: PUSH
25537: LD_INT 1
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 25
25546: PUSH
25547: LD_INT 2
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 25
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 25
25566: PUSH
25567: LD_INT 4
25569: PUSH
25570: EMPTY
25571: LIST
25572: LIST
25573: PUSH
25574: LD_INT 25
25576: PUSH
25577: LD_INT 5
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: PUSH
25584: LD_INT 25
25586: PUSH
25587: LD_INT 8
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: PUSH
25594: LD_INT 25
25596: PUSH
25597: LD_INT 9
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: PPUSH
25614: CALL_OW 72
25618: ST_TO_ADDR
// if not tmp then
25619: LD_VAR 0 4
25623: NOT
25624: IFFALSE 25628
// exit ;
25626: GO 29018
// for i in tmp do
25628: LD_ADDR_VAR 0 3
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: FOR_IN
25639: IFFALSE 25670
// if GetTag ( i ) then
25641: LD_VAR 0 3
25645: PPUSH
25646: CALL_OW 110
25650: IFFALSE 25668
// tmp := tmp diff i ;
25652: LD_ADDR_VAR 0 4
25656: PUSH
25657: LD_VAR 0 4
25661: PUSH
25662: LD_VAR 0 3
25666: DIFF
25667: ST_TO_ADDR
25668: GO 25638
25670: POP
25671: POP
// if not tmp then
25672: LD_VAR 0 4
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 29018
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25681: LD_ADDR_VAR 0 5
25685: PUSH
25686: LD_EXP 90
25690: PUSH
25691: LD_VAR 0 1
25695: ARRAY
25696: PPUSH
25697: LD_INT 2
25699: PUSH
25700: LD_INT 25
25702: PUSH
25703: LD_INT 1
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 25
25712: PUSH
25713: LD_INT 5
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 25
25722: PUSH
25723: LD_INT 8
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 25
25732: PUSH
25733: LD_INT 9
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: PPUSH
25747: CALL_OW 72
25751: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25752: LD_ADDR_VAR 0 6
25756: PUSH
25757: LD_EXP 90
25761: PUSH
25762: LD_VAR 0 1
25766: ARRAY
25767: PPUSH
25768: LD_INT 25
25770: PUSH
25771: LD_INT 2
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PPUSH
25778: CALL_OW 72
25782: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25783: LD_ADDR_VAR 0 7
25787: PUSH
25788: LD_EXP 90
25792: PUSH
25793: LD_VAR 0 1
25797: ARRAY
25798: PPUSH
25799: LD_INT 25
25801: PUSH
25802: LD_INT 3
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PPUSH
25809: CALL_OW 72
25813: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25814: LD_ADDR_VAR 0 8
25818: PUSH
25819: LD_EXP 90
25823: PUSH
25824: LD_VAR 0 1
25828: ARRAY
25829: PPUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 4
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 24
25842: PUSH
25843: LD_INT 251
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PPUSH
25854: CALL_OW 72
25858: ST_TO_ADDR
// if mc_scan [ base ] then
25859: LD_EXP 113
25863: PUSH
25864: LD_VAR 0 1
25868: ARRAY
25869: IFFALSE 26330
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25871: LD_ADDR_EXP 132
25875: PUSH
25876: LD_EXP 132
25880: PPUSH
25881: LD_VAR 0 1
25885: PPUSH
25886: LD_INT 4
25888: PPUSH
25889: CALL_OW 1
25893: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25894: LD_ADDR_VAR 0 12
25898: PUSH
25899: LD_EXP 90
25903: PUSH
25904: LD_VAR 0 1
25908: ARRAY
25909: PPUSH
25910: LD_INT 2
25912: PUSH
25913: LD_INT 30
25915: PUSH
25916: LD_INT 4
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 30
25925: PUSH
25926: LD_INT 5
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// if not b then
25943: LD_VAR 0 12
25947: NOT
25948: IFFALSE 25952
// exit ;
25950: GO 29018
// p := [ ] ;
25952: LD_ADDR_VAR 0 11
25956: PUSH
25957: EMPTY
25958: ST_TO_ADDR
// if sci >= 2 then
25959: LD_VAR 0 8
25963: PUSH
25964: LD_INT 2
25966: GREATEREQUAL
25967: IFFALSE 25998
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25969: LD_ADDR_VAR 0 8
25973: PUSH
25974: LD_VAR 0 8
25978: PUSH
25979: LD_INT 1
25981: ARRAY
25982: PUSH
25983: LD_VAR 0 8
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: ST_TO_ADDR
25996: GO 26059
// if sci = 1 then
25998: LD_VAR 0 8
26002: PUSH
26003: LD_INT 1
26005: EQUAL
26006: IFFALSE 26027
// sci := [ sci [ 1 ] ] else
26008: LD_ADDR_VAR 0 8
26012: PUSH
26013: LD_VAR 0 8
26017: PUSH
26018: LD_INT 1
26020: ARRAY
26021: PUSH
26022: EMPTY
26023: LIST
26024: ST_TO_ADDR
26025: GO 26059
// if sci = 0 then
26027: LD_VAR 0 8
26031: PUSH
26032: LD_INT 0
26034: EQUAL
26035: IFFALSE 26059
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26037: LD_ADDR_VAR 0 11
26041: PUSH
26042: LD_VAR 0 4
26046: PPUSH
26047: LD_INT 4
26049: PPUSH
26050: CALL 85341 0 2
26054: PUSH
26055: LD_INT 1
26057: ARRAY
26058: ST_TO_ADDR
// if eng > 4 then
26059: LD_VAR 0 6
26063: PUSH
26064: LD_INT 4
26066: GREATER
26067: IFFALSE 26113
// for i = eng downto 4 do
26069: LD_ADDR_VAR 0 3
26073: PUSH
26074: DOUBLE
26075: LD_VAR 0 6
26079: INC
26080: ST_TO_ADDR
26081: LD_INT 4
26083: PUSH
26084: FOR_DOWNTO
26085: IFFALSE 26111
// eng := eng diff eng [ i ] ;
26087: LD_ADDR_VAR 0 6
26091: PUSH
26092: LD_VAR 0 6
26096: PUSH
26097: LD_VAR 0 6
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: DIFF
26108: ST_TO_ADDR
26109: GO 26084
26111: POP
26112: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 5
26127: PUSH
26128: LD_VAR 0 6
26132: UNION
26133: PUSH
26134: LD_VAR 0 7
26138: UNION
26139: PUSH
26140: LD_VAR 0 8
26144: UNION
26145: DIFF
26146: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26147: LD_ADDR_VAR 0 13
26151: PUSH
26152: LD_EXP 90
26156: PUSH
26157: LD_VAR 0 1
26161: ARRAY
26162: PPUSH
26163: LD_INT 2
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 32
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 30
26178: PUSH
26179: LD_INT 31
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL_OW 72
26195: PUSH
26196: LD_EXP 90
26200: PUSH
26201: LD_VAR 0 1
26205: ARRAY
26206: PPUSH
26207: LD_INT 2
26209: PUSH
26210: LD_INT 30
26212: PUSH
26213: LD_INT 4
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 5
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: LIST
26234: PPUSH
26235: CALL_OW 72
26239: PUSH
26240: LD_INT 6
26242: MUL
26243: PLUS
26244: ST_TO_ADDR
// if bcount < tmp then
26245: LD_VAR 0 13
26249: PUSH
26250: LD_VAR 0 4
26254: LESS
26255: IFFALSE 26301
// for i = tmp downto bcount do
26257: LD_ADDR_VAR 0 3
26261: PUSH
26262: DOUBLE
26263: LD_VAR 0 4
26267: INC
26268: ST_TO_ADDR
26269: LD_VAR 0 13
26273: PUSH
26274: FOR_DOWNTO
26275: IFFALSE 26299
// tmp := Delete ( tmp , tmp ) ;
26277: LD_ADDR_VAR 0 4
26281: PUSH
26282: LD_VAR 0 4
26286: PPUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: CALL_OW 3
26296: ST_TO_ADDR
26297: GO 26274
26299: POP
26300: POP
// result := [ tmp , 0 , 0 , p ] ;
26301: LD_ADDR_VAR 0 2
26305: PUSH
26306: LD_VAR 0 4
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: LD_VAR 0 11
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: LIST
26326: LIST
26327: ST_TO_ADDR
// exit ;
26328: GO 29018
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26330: LD_EXP 90
26334: PUSH
26335: LD_VAR 0 1
26339: ARRAY
26340: PPUSH
26341: LD_INT 2
26343: PUSH
26344: LD_INT 30
26346: PUSH
26347: LD_INT 6
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 30
26356: PUSH
26357: LD_INT 7
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 30
26366: PUSH
26367: LD_INT 8
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: LIST
26378: LIST
26379: PPUSH
26380: CALL_OW 72
26384: NOT
26385: PUSH
26386: LD_EXP 90
26390: PUSH
26391: LD_VAR 0 1
26395: ARRAY
26396: PPUSH
26397: LD_INT 30
26399: PUSH
26400: LD_INT 3
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PPUSH
26407: CALL_OW 72
26411: NOT
26412: AND
26413: IFFALSE 26485
// begin if eng = tmp then
26415: LD_VAR 0 6
26419: PUSH
26420: LD_VAR 0 4
26424: EQUAL
26425: IFFALSE 26429
// exit ;
26427: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26429: LD_ADDR_EXP 132
26433: PUSH
26434: LD_EXP 132
26438: PPUSH
26439: LD_VAR 0 1
26443: PPUSH
26444: LD_INT 1
26446: PPUSH
26447: CALL_OW 1
26451: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26452: LD_ADDR_VAR 0 2
26456: PUSH
26457: LD_INT 0
26459: PUSH
26460: LD_VAR 0 4
26464: PUSH
26465: LD_VAR 0 6
26469: DIFF
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: ST_TO_ADDR
// exit ;
26483: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26485: LD_EXP 117
26489: PUSH
26490: LD_EXP 116
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: ARRAY
26501: PUSH
26502: LD_EXP 90
26506: PUSH
26507: LD_VAR 0 1
26511: ARRAY
26512: PPUSH
26513: LD_INT 2
26515: PUSH
26516: LD_INT 30
26518: PUSH
26519: LD_INT 6
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 30
26528: PUSH
26529: LD_INT 7
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 30
26538: PUSH
26539: LD_INT 8
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL_OW 72
26556: AND
26557: PUSH
26558: LD_EXP 90
26562: PUSH
26563: LD_VAR 0 1
26567: ARRAY
26568: PPUSH
26569: LD_INT 30
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PPUSH
26579: CALL_OW 72
26583: NOT
26584: AND
26585: IFFALSE 26799
// begin if sci >= 6 then
26587: LD_VAR 0 8
26591: PUSH
26592: LD_INT 6
26594: GREATEREQUAL
26595: IFFALSE 26599
// exit ;
26597: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26599: LD_ADDR_EXP 132
26603: PUSH
26604: LD_EXP 132
26608: PPUSH
26609: LD_VAR 0 1
26613: PPUSH
26614: LD_INT 2
26616: PPUSH
26617: CALL_OW 1
26621: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26622: LD_ADDR_VAR 0 9
26626: PUSH
26627: LD_VAR 0 4
26631: PUSH
26632: LD_VAR 0 8
26636: DIFF
26637: PPUSH
26638: LD_INT 4
26640: PPUSH
26641: CALL 85341 0 2
26645: ST_TO_ADDR
// p := [ ] ;
26646: LD_ADDR_VAR 0 11
26650: PUSH
26651: EMPTY
26652: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26653: LD_VAR 0 8
26657: PUSH
26658: LD_INT 6
26660: LESS
26661: PUSH
26662: LD_VAR 0 9
26666: PUSH
26667: LD_INT 6
26669: GREATER
26670: AND
26671: IFFALSE 26752
// begin for i = 1 to 6 - sci do
26673: LD_ADDR_VAR 0 3
26677: PUSH
26678: DOUBLE
26679: LD_INT 1
26681: DEC
26682: ST_TO_ADDR
26683: LD_INT 6
26685: PUSH
26686: LD_VAR 0 8
26690: MINUS
26691: PUSH
26692: FOR_TO
26693: IFFALSE 26748
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26695: LD_ADDR_VAR 0 11
26699: PUSH
26700: LD_VAR 0 11
26704: PPUSH
26705: LD_VAR 0 11
26709: PUSH
26710: LD_INT 1
26712: PLUS
26713: PPUSH
26714: LD_VAR 0 9
26718: PUSH
26719: LD_INT 1
26721: ARRAY
26722: PPUSH
26723: CALL_OW 2
26727: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26728: LD_ADDR_VAR 0 9
26732: PUSH
26733: LD_VAR 0 9
26737: PPUSH
26738: LD_INT 1
26740: PPUSH
26741: CALL_OW 3
26745: ST_TO_ADDR
// end ;
26746: GO 26692
26748: POP
26749: POP
// end else
26750: GO 26772
// if sort then
26752: LD_VAR 0 9
26756: IFFALSE 26772
// p := sort [ 1 ] ;
26758: LD_ADDR_VAR 0 11
26762: PUSH
26763: LD_VAR 0 9
26767: PUSH
26768: LD_INT 1
26770: ARRAY
26771: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26772: LD_ADDR_VAR 0 2
26776: PUSH
26777: LD_INT 0
26779: PUSH
26780: LD_INT 0
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: LD_VAR 0 11
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: ST_TO_ADDR
// exit ;
26797: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26799: LD_EXP 117
26803: PUSH
26804: LD_EXP 116
26808: PUSH
26809: LD_VAR 0 1
26813: ARRAY
26814: ARRAY
26815: PUSH
26816: LD_EXP 90
26820: PUSH
26821: LD_VAR 0 1
26825: ARRAY
26826: PPUSH
26827: LD_INT 2
26829: PUSH
26830: LD_INT 30
26832: PUSH
26833: LD_INT 6
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 30
26842: PUSH
26843: LD_INT 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 30
26852: PUSH
26853: LD_INT 8
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: LIST
26865: PPUSH
26866: CALL_OW 72
26870: AND
26871: PUSH
26872: LD_EXP 90
26876: PUSH
26877: LD_VAR 0 1
26881: ARRAY
26882: PPUSH
26883: LD_INT 30
26885: PUSH
26886: LD_INT 3
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PPUSH
26893: CALL_OW 72
26897: AND
26898: IFFALSE 27632
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26900: LD_ADDR_EXP 132
26904: PUSH
26905: LD_EXP 132
26909: PPUSH
26910: LD_VAR 0 1
26914: PPUSH
26915: LD_INT 3
26917: PPUSH
26918: CALL_OW 1
26922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26923: LD_ADDR_VAR 0 2
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: LD_INT 0
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: ST_TO_ADDR
// if not eng then
26946: LD_VAR 0 6
26950: NOT
26951: IFFALSE 27014
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26953: LD_ADDR_VAR 0 11
26957: PUSH
26958: LD_VAR 0 4
26962: PPUSH
26963: LD_INT 2
26965: PPUSH
26966: CALL 85341 0 2
26970: PUSH
26971: LD_INT 1
26973: ARRAY
26974: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26975: LD_ADDR_VAR 0 2
26979: PUSH
26980: LD_VAR 0 2
26984: PPUSH
26985: LD_INT 2
26987: PPUSH
26988: LD_VAR 0 11
26992: PPUSH
26993: CALL_OW 1
26997: ST_TO_ADDR
// tmp := tmp diff p ;
26998: LD_ADDR_VAR 0 4
27002: PUSH
27003: LD_VAR 0 4
27007: PUSH
27008: LD_VAR 0 11
27012: DIFF
27013: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27014: LD_VAR 0 4
27018: PUSH
27019: LD_VAR 0 8
27023: PUSH
27024: LD_INT 6
27026: LESS
27027: AND
27028: IFFALSE 27216
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27030: LD_ADDR_VAR 0 9
27034: PUSH
27035: LD_VAR 0 4
27039: PUSH
27040: LD_VAR 0 8
27044: PUSH
27045: LD_VAR 0 7
27049: UNION
27050: DIFF
27051: PPUSH
27052: LD_INT 4
27054: PPUSH
27055: CALL 85341 0 2
27059: ST_TO_ADDR
// p := [ ] ;
27060: LD_ADDR_VAR 0 11
27064: PUSH
27065: EMPTY
27066: ST_TO_ADDR
// if sort then
27067: LD_VAR 0 9
27071: IFFALSE 27187
// for i = 1 to 6 - sci do
27073: LD_ADDR_VAR 0 3
27077: PUSH
27078: DOUBLE
27079: LD_INT 1
27081: DEC
27082: ST_TO_ADDR
27083: LD_INT 6
27085: PUSH
27086: LD_VAR 0 8
27090: MINUS
27091: PUSH
27092: FOR_TO
27093: IFFALSE 27185
// begin if i = sort then
27095: LD_VAR 0 3
27099: PUSH
27100: LD_VAR 0 9
27104: EQUAL
27105: IFFALSE 27109
// break ;
27107: GO 27185
// if GetClass ( i ) = 4 then
27109: LD_VAR 0 3
27113: PPUSH
27114: CALL_OW 257
27118: PUSH
27119: LD_INT 4
27121: EQUAL
27122: IFFALSE 27126
// continue ;
27124: GO 27092
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27126: LD_ADDR_VAR 0 11
27130: PUSH
27131: LD_VAR 0 11
27135: PPUSH
27136: LD_VAR 0 11
27140: PUSH
27141: LD_INT 1
27143: PLUS
27144: PPUSH
27145: LD_VAR 0 9
27149: PUSH
27150: LD_VAR 0 3
27154: ARRAY
27155: PPUSH
27156: CALL_OW 2
27160: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27161: LD_ADDR_VAR 0 4
27165: PUSH
27166: LD_VAR 0 4
27170: PUSH
27171: LD_VAR 0 9
27175: PUSH
27176: LD_VAR 0 3
27180: ARRAY
27181: DIFF
27182: ST_TO_ADDR
// end ;
27183: GO 27092
27185: POP
27186: POP
// if p then
27187: LD_VAR 0 11
27191: IFFALSE 27216
// result := Replace ( result , 4 , p ) ;
27193: LD_ADDR_VAR 0 2
27197: PUSH
27198: LD_VAR 0 2
27202: PPUSH
27203: LD_INT 4
27205: PPUSH
27206: LD_VAR 0 11
27210: PPUSH
27211: CALL_OW 1
27215: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27216: LD_VAR 0 4
27220: PUSH
27221: LD_VAR 0 7
27225: PUSH
27226: LD_INT 6
27228: LESS
27229: AND
27230: IFFALSE 27418
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27232: LD_ADDR_VAR 0 9
27236: PUSH
27237: LD_VAR 0 4
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_VAR 0 7
27251: UNION
27252: DIFF
27253: PPUSH
27254: LD_INT 3
27256: PPUSH
27257: CALL 85341 0 2
27261: ST_TO_ADDR
// p := [ ] ;
27262: LD_ADDR_VAR 0 11
27266: PUSH
27267: EMPTY
27268: ST_TO_ADDR
// if sort then
27269: LD_VAR 0 9
27273: IFFALSE 27389
// for i = 1 to 6 - mech do
27275: LD_ADDR_VAR 0 3
27279: PUSH
27280: DOUBLE
27281: LD_INT 1
27283: DEC
27284: ST_TO_ADDR
27285: LD_INT 6
27287: PUSH
27288: LD_VAR 0 7
27292: MINUS
27293: PUSH
27294: FOR_TO
27295: IFFALSE 27387
// begin if i = sort then
27297: LD_VAR 0 3
27301: PUSH
27302: LD_VAR 0 9
27306: EQUAL
27307: IFFALSE 27311
// break ;
27309: GO 27387
// if GetClass ( i ) = 3 then
27311: LD_VAR 0 3
27315: PPUSH
27316: CALL_OW 257
27320: PUSH
27321: LD_INT 3
27323: EQUAL
27324: IFFALSE 27328
// continue ;
27326: GO 27294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27328: LD_ADDR_VAR 0 11
27332: PUSH
27333: LD_VAR 0 11
27337: PPUSH
27338: LD_VAR 0 11
27342: PUSH
27343: LD_INT 1
27345: PLUS
27346: PPUSH
27347: LD_VAR 0 9
27351: PUSH
27352: LD_VAR 0 3
27356: ARRAY
27357: PPUSH
27358: CALL_OW 2
27362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27363: LD_ADDR_VAR 0 4
27367: PUSH
27368: LD_VAR 0 4
27372: PUSH
27373: LD_VAR 0 9
27377: PUSH
27378: LD_VAR 0 3
27382: ARRAY
27383: DIFF
27384: ST_TO_ADDR
// end ;
27385: GO 27294
27387: POP
27388: POP
// if p then
27389: LD_VAR 0 11
27393: IFFALSE 27418
// result := Replace ( result , 3 , p ) ;
27395: LD_ADDR_VAR 0 2
27399: PUSH
27400: LD_VAR 0 2
27404: PPUSH
27405: LD_INT 3
27407: PPUSH
27408: LD_VAR 0 11
27412: PPUSH
27413: CALL_OW 1
27417: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27418: LD_VAR 0 4
27422: PUSH
27423: LD_INT 6
27425: GREATER
27426: PUSH
27427: LD_VAR 0 6
27431: PUSH
27432: LD_INT 6
27434: LESS
27435: AND
27436: IFFALSE 27630
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27438: LD_ADDR_VAR 0 9
27442: PUSH
27443: LD_VAR 0 4
27447: PUSH
27448: LD_VAR 0 8
27452: PUSH
27453: LD_VAR 0 7
27457: UNION
27458: PUSH
27459: LD_VAR 0 6
27463: UNION
27464: DIFF
27465: PPUSH
27466: LD_INT 2
27468: PPUSH
27469: CALL 85341 0 2
27473: ST_TO_ADDR
// p := [ ] ;
27474: LD_ADDR_VAR 0 11
27478: PUSH
27479: EMPTY
27480: ST_TO_ADDR
// if sort then
27481: LD_VAR 0 9
27485: IFFALSE 27601
// for i = 1 to 6 - eng do
27487: LD_ADDR_VAR 0 3
27491: PUSH
27492: DOUBLE
27493: LD_INT 1
27495: DEC
27496: ST_TO_ADDR
27497: LD_INT 6
27499: PUSH
27500: LD_VAR 0 6
27504: MINUS
27505: PUSH
27506: FOR_TO
27507: IFFALSE 27599
// begin if i = sort then
27509: LD_VAR 0 3
27513: PUSH
27514: LD_VAR 0 9
27518: EQUAL
27519: IFFALSE 27523
// break ;
27521: GO 27599
// if GetClass ( i ) = 2 then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 257
27532: PUSH
27533: LD_INT 2
27535: EQUAL
27536: IFFALSE 27540
// continue ;
27538: GO 27506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 11
27549: PPUSH
27550: LD_VAR 0 11
27554: PUSH
27555: LD_INT 1
27557: PLUS
27558: PPUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 3
27568: ARRAY
27569: PPUSH
27570: CALL_OW 2
27574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27575: LD_ADDR_VAR 0 4
27579: PUSH
27580: LD_VAR 0 4
27584: PUSH
27585: LD_VAR 0 9
27589: PUSH
27590: LD_VAR 0 3
27594: ARRAY
27595: DIFF
27596: ST_TO_ADDR
// end ;
27597: GO 27506
27599: POP
27600: POP
// if p then
27601: LD_VAR 0 11
27605: IFFALSE 27630
// result := Replace ( result , 2 , p ) ;
27607: LD_ADDR_VAR 0 2
27611: PUSH
27612: LD_VAR 0 2
27616: PPUSH
27617: LD_INT 2
27619: PPUSH
27620: LD_VAR 0 11
27624: PPUSH
27625: CALL_OW 1
27629: ST_TO_ADDR
// end ; exit ;
27630: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27632: LD_EXP 117
27636: PUSH
27637: LD_EXP 116
27641: PUSH
27642: LD_VAR 0 1
27646: ARRAY
27647: ARRAY
27648: NOT
27649: PUSH
27650: LD_EXP 90
27654: PUSH
27655: LD_VAR 0 1
27659: ARRAY
27660: PPUSH
27661: LD_INT 30
27663: PUSH
27664: LD_INT 3
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PPUSH
27671: CALL_OW 72
27675: AND
27676: PUSH
27677: LD_EXP 95
27681: PUSH
27682: LD_VAR 0 1
27686: ARRAY
27687: AND
27688: IFFALSE 28296
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27690: LD_ADDR_EXP 132
27694: PUSH
27695: LD_EXP 132
27699: PPUSH
27700: LD_VAR 0 1
27704: PPUSH
27705: LD_INT 5
27707: PPUSH
27708: CALL_OW 1
27712: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27713: LD_ADDR_VAR 0 2
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: LD_INT 0
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: ST_TO_ADDR
// if sci > 1 then
27736: LD_VAR 0 8
27740: PUSH
27741: LD_INT 1
27743: GREATER
27744: IFFALSE 27772
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27746: LD_ADDR_VAR 0 4
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_VAR 0 8
27760: PUSH
27761: LD_VAR 0 8
27765: PUSH
27766: LD_INT 1
27768: ARRAY
27769: DIFF
27770: DIFF
27771: ST_TO_ADDR
// if tmp and not sci then
27772: LD_VAR 0 4
27776: PUSH
27777: LD_VAR 0 8
27781: NOT
27782: AND
27783: IFFALSE 27852
// begin sort := SortBySkill ( tmp , 4 ) ;
27785: LD_ADDR_VAR 0 9
27789: PUSH
27790: LD_VAR 0 4
27794: PPUSH
27795: LD_INT 4
27797: PPUSH
27798: CALL 85341 0 2
27802: ST_TO_ADDR
// if sort then
27803: LD_VAR 0 9
27807: IFFALSE 27823
// p := sort [ 1 ] ;
27809: LD_ADDR_VAR 0 11
27813: PUSH
27814: LD_VAR 0 9
27818: PUSH
27819: LD_INT 1
27821: ARRAY
27822: ST_TO_ADDR
// if p then
27823: LD_VAR 0 11
27827: IFFALSE 27852
// result := Replace ( result , 4 , p ) ;
27829: LD_ADDR_VAR 0 2
27833: PUSH
27834: LD_VAR 0 2
27838: PPUSH
27839: LD_INT 4
27841: PPUSH
27842: LD_VAR 0 11
27846: PPUSH
27847: CALL_OW 1
27851: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27852: LD_ADDR_VAR 0 4
27856: PUSH
27857: LD_VAR 0 4
27861: PUSH
27862: LD_VAR 0 7
27866: DIFF
27867: ST_TO_ADDR
// if tmp and mech < 6 then
27868: LD_VAR 0 4
27872: PUSH
27873: LD_VAR 0 7
27877: PUSH
27878: LD_INT 6
27880: LESS
27881: AND
27882: IFFALSE 28070
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27884: LD_ADDR_VAR 0 9
27888: PUSH
27889: LD_VAR 0 4
27893: PUSH
27894: LD_VAR 0 8
27898: PUSH
27899: LD_VAR 0 7
27903: UNION
27904: DIFF
27905: PPUSH
27906: LD_INT 3
27908: PPUSH
27909: CALL 85341 0 2
27913: ST_TO_ADDR
// p := [ ] ;
27914: LD_ADDR_VAR 0 11
27918: PUSH
27919: EMPTY
27920: ST_TO_ADDR
// if sort then
27921: LD_VAR 0 9
27925: IFFALSE 28041
// for i = 1 to 6 - mech do
27927: LD_ADDR_VAR 0 3
27931: PUSH
27932: DOUBLE
27933: LD_INT 1
27935: DEC
27936: ST_TO_ADDR
27937: LD_INT 6
27939: PUSH
27940: LD_VAR 0 7
27944: MINUS
27945: PUSH
27946: FOR_TO
27947: IFFALSE 28039
// begin if i = sort then
27949: LD_VAR 0 3
27953: PUSH
27954: LD_VAR 0 9
27958: EQUAL
27959: IFFALSE 27963
// break ;
27961: GO 28039
// if GetClass ( i ) = 3 then
27963: LD_VAR 0 3
27967: PPUSH
27968: CALL_OW 257
27972: PUSH
27973: LD_INT 3
27975: EQUAL
27976: IFFALSE 27980
// continue ;
27978: GO 27946
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27980: LD_ADDR_VAR 0 11
27984: PUSH
27985: LD_VAR 0 11
27989: PPUSH
27990: LD_VAR 0 11
27994: PUSH
27995: LD_INT 1
27997: PLUS
27998: PPUSH
27999: LD_VAR 0 9
28003: PUSH
28004: LD_VAR 0 3
28008: ARRAY
28009: PPUSH
28010: CALL_OW 2
28014: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28015: LD_ADDR_VAR 0 4
28019: PUSH
28020: LD_VAR 0 4
28024: PUSH
28025: LD_VAR 0 9
28029: PUSH
28030: LD_VAR 0 3
28034: ARRAY
28035: DIFF
28036: ST_TO_ADDR
// end ;
28037: GO 27946
28039: POP
28040: POP
// if p then
28041: LD_VAR 0 11
28045: IFFALSE 28070
// result := Replace ( result , 3 , p ) ;
28047: LD_ADDR_VAR 0 2
28051: PUSH
28052: LD_VAR 0 2
28056: PPUSH
28057: LD_INT 3
28059: PPUSH
28060: LD_VAR 0 11
28064: PPUSH
28065: CALL_OW 1
28069: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28070: LD_ADDR_VAR 0 4
28074: PUSH
28075: LD_VAR 0 4
28079: PUSH
28080: LD_VAR 0 6
28084: DIFF
28085: ST_TO_ADDR
// if tmp and eng < 6 then
28086: LD_VAR 0 4
28090: PUSH
28091: LD_VAR 0 6
28095: PUSH
28096: LD_INT 6
28098: LESS
28099: AND
28100: IFFALSE 28294
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28102: LD_ADDR_VAR 0 9
28106: PUSH
28107: LD_VAR 0 4
28111: PUSH
28112: LD_VAR 0 8
28116: PUSH
28117: LD_VAR 0 7
28121: UNION
28122: PUSH
28123: LD_VAR 0 6
28127: UNION
28128: DIFF
28129: PPUSH
28130: LD_INT 2
28132: PPUSH
28133: CALL 85341 0 2
28137: ST_TO_ADDR
// p := [ ] ;
28138: LD_ADDR_VAR 0 11
28142: PUSH
28143: EMPTY
28144: ST_TO_ADDR
// if sort then
28145: LD_VAR 0 9
28149: IFFALSE 28265
// for i = 1 to 6 - eng do
28151: LD_ADDR_VAR 0 3
28155: PUSH
28156: DOUBLE
28157: LD_INT 1
28159: DEC
28160: ST_TO_ADDR
28161: LD_INT 6
28163: PUSH
28164: LD_VAR 0 6
28168: MINUS
28169: PUSH
28170: FOR_TO
28171: IFFALSE 28263
// begin if i = sort then
28173: LD_VAR 0 3
28177: PUSH
28178: LD_VAR 0 9
28182: EQUAL
28183: IFFALSE 28187
// break ;
28185: GO 28263
// if GetClass ( i ) = 2 then
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL_OW 257
28196: PUSH
28197: LD_INT 2
28199: EQUAL
28200: IFFALSE 28204
// continue ;
28202: GO 28170
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28204: LD_ADDR_VAR 0 11
28208: PUSH
28209: LD_VAR 0 11
28213: PPUSH
28214: LD_VAR 0 11
28218: PUSH
28219: LD_INT 1
28221: PLUS
28222: PPUSH
28223: LD_VAR 0 9
28227: PUSH
28228: LD_VAR 0 3
28232: ARRAY
28233: PPUSH
28234: CALL_OW 2
28238: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28239: LD_ADDR_VAR 0 4
28243: PUSH
28244: LD_VAR 0 4
28248: PUSH
28249: LD_VAR 0 9
28253: PUSH
28254: LD_VAR 0 3
28258: ARRAY
28259: DIFF
28260: ST_TO_ADDR
// end ;
28261: GO 28170
28263: POP
28264: POP
// if p then
28265: LD_VAR 0 11
28269: IFFALSE 28294
// result := Replace ( result , 2 , p ) ;
28271: LD_ADDR_VAR 0 2
28275: PUSH
28276: LD_VAR 0 2
28280: PPUSH
28281: LD_INT 2
28283: PPUSH
28284: LD_VAR 0 11
28288: PPUSH
28289: CALL_OW 1
28293: ST_TO_ADDR
// end ; exit ;
28294: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28296: LD_EXP 117
28300: PUSH
28301: LD_EXP 116
28305: PUSH
28306: LD_VAR 0 1
28310: ARRAY
28311: ARRAY
28312: NOT
28313: PUSH
28314: LD_EXP 90
28318: PUSH
28319: LD_VAR 0 1
28323: ARRAY
28324: PPUSH
28325: LD_INT 30
28327: PUSH
28328: LD_INT 3
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PPUSH
28335: CALL_OW 72
28339: AND
28340: PUSH
28341: LD_EXP 95
28345: PUSH
28346: LD_VAR 0 1
28350: ARRAY
28351: NOT
28352: AND
28353: IFFALSE 29018
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28355: LD_ADDR_EXP 132
28359: PUSH
28360: LD_EXP 132
28364: PPUSH
28365: LD_VAR 0 1
28369: PPUSH
28370: LD_INT 6
28372: PPUSH
28373: CALL_OW 1
28377: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_INT 0
28385: PUSH
28386: LD_INT 0
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: ST_TO_ADDR
// if sci >= 1 then
28401: LD_VAR 0 8
28405: PUSH
28406: LD_INT 1
28408: GREATEREQUAL
28409: IFFALSE 28431
// tmp := tmp diff sci [ 1 ] ;
28411: LD_ADDR_VAR 0 4
28415: PUSH
28416: LD_VAR 0 4
28420: PUSH
28421: LD_VAR 0 8
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: DIFF
28430: ST_TO_ADDR
// if tmp and not sci then
28431: LD_VAR 0 4
28435: PUSH
28436: LD_VAR 0 8
28440: NOT
28441: AND
28442: IFFALSE 28511
// begin sort := SortBySkill ( tmp , 4 ) ;
28444: LD_ADDR_VAR 0 9
28448: PUSH
28449: LD_VAR 0 4
28453: PPUSH
28454: LD_INT 4
28456: PPUSH
28457: CALL 85341 0 2
28461: ST_TO_ADDR
// if sort then
28462: LD_VAR 0 9
28466: IFFALSE 28482
// p := sort [ 1 ] ;
28468: LD_ADDR_VAR 0 11
28472: PUSH
28473: LD_VAR 0 9
28477: PUSH
28478: LD_INT 1
28480: ARRAY
28481: ST_TO_ADDR
// if p then
28482: LD_VAR 0 11
28486: IFFALSE 28511
// result := Replace ( result , 4 , p ) ;
28488: LD_ADDR_VAR 0 2
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: LD_INT 4
28500: PPUSH
28501: LD_VAR 0 11
28505: PPUSH
28506: CALL_OW 1
28510: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 7
28525: DIFF
28526: ST_TO_ADDR
// if tmp and mech < 6 then
28527: LD_VAR 0 4
28531: PUSH
28532: LD_VAR 0 7
28536: PUSH
28537: LD_INT 6
28539: LESS
28540: AND
28541: IFFALSE 28723
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28543: LD_ADDR_VAR 0 9
28547: PUSH
28548: LD_VAR 0 4
28552: PUSH
28553: LD_VAR 0 7
28557: DIFF
28558: PPUSH
28559: LD_INT 3
28561: PPUSH
28562: CALL 85341 0 2
28566: ST_TO_ADDR
// p := [ ] ;
28567: LD_ADDR_VAR 0 11
28571: PUSH
28572: EMPTY
28573: ST_TO_ADDR
// if sort then
28574: LD_VAR 0 9
28578: IFFALSE 28694
// for i = 1 to 6 - mech do
28580: LD_ADDR_VAR 0 3
28584: PUSH
28585: DOUBLE
28586: LD_INT 1
28588: DEC
28589: ST_TO_ADDR
28590: LD_INT 6
28592: PUSH
28593: LD_VAR 0 7
28597: MINUS
28598: PUSH
28599: FOR_TO
28600: IFFALSE 28692
// begin if i = sort then
28602: LD_VAR 0 3
28606: PUSH
28607: LD_VAR 0 9
28611: EQUAL
28612: IFFALSE 28616
// break ;
28614: GO 28692
// if GetClass ( i ) = 3 then
28616: LD_VAR 0 3
28620: PPUSH
28621: CALL_OW 257
28625: PUSH
28626: LD_INT 3
28628: EQUAL
28629: IFFALSE 28633
// continue ;
28631: GO 28599
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28633: LD_ADDR_VAR 0 11
28637: PUSH
28638: LD_VAR 0 11
28642: PPUSH
28643: LD_VAR 0 11
28647: PUSH
28648: LD_INT 1
28650: PLUS
28651: PPUSH
28652: LD_VAR 0 9
28656: PUSH
28657: LD_VAR 0 3
28661: ARRAY
28662: PPUSH
28663: CALL_OW 2
28667: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28668: LD_ADDR_VAR 0 4
28672: PUSH
28673: LD_VAR 0 4
28677: PUSH
28678: LD_VAR 0 9
28682: PUSH
28683: LD_VAR 0 3
28687: ARRAY
28688: DIFF
28689: ST_TO_ADDR
// end ;
28690: GO 28599
28692: POP
28693: POP
// if p then
28694: LD_VAR 0 11
28698: IFFALSE 28723
// result := Replace ( result , 3 , p ) ;
28700: LD_ADDR_VAR 0 2
28704: PUSH
28705: LD_VAR 0 2
28709: PPUSH
28710: LD_INT 3
28712: PPUSH
28713: LD_VAR 0 11
28717: PPUSH
28718: CALL_OW 1
28722: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28723: LD_ADDR_VAR 0 4
28727: PUSH
28728: LD_VAR 0 4
28732: PUSH
28733: LD_VAR 0 6
28737: DIFF
28738: ST_TO_ADDR
// if tmp and eng < 4 then
28739: LD_VAR 0 4
28743: PUSH
28744: LD_VAR 0 6
28748: PUSH
28749: LD_INT 4
28751: LESS
28752: AND
28753: IFFALSE 28943
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28755: LD_ADDR_VAR 0 9
28759: PUSH
28760: LD_VAR 0 4
28764: PUSH
28765: LD_VAR 0 7
28769: PUSH
28770: LD_VAR 0 6
28774: UNION
28775: DIFF
28776: PPUSH
28777: LD_INT 2
28779: PPUSH
28780: CALL 85341 0 2
28784: ST_TO_ADDR
// p := [ ] ;
28785: LD_ADDR_VAR 0 11
28789: PUSH
28790: EMPTY
28791: ST_TO_ADDR
// if sort then
28792: LD_VAR 0 9
28796: IFFALSE 28912
// for i = 1 to 4 - eng do
28798: LD_ADDR_VAR 0 3
28802: PUSH
28803: DOUBLE
28804: LD_INT 1
28806: DEC
28807: ST_TO_ADDR
28808: LD_INT 4
28810: PUSH
28811: LD_VAR 0 6
28815: MINUS
28816: PUSH
28817: FOR_TO
28818: IFFALSE 28910
// begin if i = sort then
28820: LD_VAR 0 3
28824: PUSH
28825: LD_VAR 0 9
28829: EQUAL
28830: IFFALSE 28834
// break ;
28832: GO 28910
// if GetClass ( i ) = 2 then
28834: LD_VAR 0 3
28838: PPUSH
28839: CALL_OW 257
28843: PUSH
28844: LD_INT 2
28846: EQUAL
28847: IFFALSE 28851
// continue ;
28849: GO 28817
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28851: LD_ADDR_VAR 0 11
28855: PUSH
28856: LD_VAR 0 11
28860: PPUSH
28861: LD_VAR 0 11
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 9
28874: PUSH
28875: LD_VAR 0 3
28879: ARRAY
28880: PPUSH
28881: CALL_OW 2
28885: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28886: LD_ADDR_VAR 0 4
28890: PUSH
28891: LD_VAR 0 4
28895: PUSH
28896: LD_VAR 0 9
28900: PUSH
28901: LD_VAR 0 3
28905: ARRAY
28906: DIFF
28907: ST_TO_ADDR
// end ;
28908: GO 28817
28910: POP
28911: POP
// if p then
28912: LD_VAR 0 11
28916: IFFALSE 28941
// result := Replace ( result , 2 , p ) ;
28918: LD_ADDR_VAR 0 2
28922: PUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_INT 2
28930: PPUSH
28931: LD_VAR 0 11
28935: PPUSH
28936: CALL_OW 1
28940: ST_TO_ADDR
// end else
28941: GO 28987
// for i = eng downto 5 do
28943: LD_ADDR_VAR 0 3
28947: PUSH
28948: DOUBLE
28949: LD_VAR 0 6
28953: INC
28954: ST_TO_ADDR
28955: LD_INT 5
28957: PUSH
28958: FOR_DOWNTO
28959: IFFALSE 28985
// tmp := tmp union eng [ i ] ;
28961: LD_ADDR_VAR 0 4
28965: PUSH
28966: LD_VAR 0 4
28970: PUSH
28971: LD_VAR 0 6
28975: PUSH
28976: LD_VAR 0 3
28980: ARRAY
28981: UNION
28982: ST_TO_ADDR
28983: GO 28958
28985: POP
28986: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28987: LD_ADDR_VAR 0 2
28991: PUSH
28992: LD_VAR 0 2
28996: PPUSH
28997: LD_INT 1
28999: PPUSH
29000: LD_VAR 0 4
29004: PUSH
29005: LD_VAR 0 5
29009: DIFF
29010: PPUSH
29011: CALL_OW 1
29015: ST_TO_ADDR
// exit ;
29016: GO 29018
// end ; end ;
29018: LD_VAR 0 2
29022: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29023: LD_INT 0
29025: PPUSH
29026: PPUSH
29027: PPUSH
// if not mc_bases then
29028: LD_EXP 90
29032: NOT
29033: IFFALSE 29037
// exit ;
29035: GO 29143
// for i = 1 to mc_bases do
29037: LD_ADDR_VAR 0 2
29041: PUSH
29042: DOUBLE
29043: LD_INT 1
29045: DEC
29046: ST_TO_ADDR
29047: LD_EXP 90
29051: PUSH
29052: FOR_TO
29053: IFFALSE 29134
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29055: LD_ADDR_VAR 0 3
29059: PUSH
29060: LD_EXP 90
29064: PUSH
29065: LD_VAR 0 2
29069: ARRAY
29070: PPUSH
29071: LD_INT 21
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: LD_INT 3
29083: PUSH
29084: LD_INT 24
29086: PUSH
29087: LD_INT 1000
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PPUSH
29102: CALL_OW 72
29106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29107: LD_ADDR_EXP 91
29111: PUSH
29112: LD_EXP 91
29116: PPUSH
29117: LD_VAR 0 2
29121: PPUSH
29122: LD_VAR 0 3
29126: PPUSH
29127: CALL_OW 1
29131: ST_TO_ADDR
// end ;
29132: GO 29052
29134: POP
29135: POP
// RaiseSailEvent ( 101 ) ;
29136: LD_INT 101
29138: PPUSH
29139: CALL_OW 427
// end ;
29143: LD_VAR 0 1
29147: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29148: LD_INT 0
29150: PPUSH
29151: PPUSH
29152: PPUSH
29153: PPUSH
29154: PPUSH
29155: PPUSH
29156: PPUSH
// if not mc_bases then
29157: LD_EXP 90
29161: NOT
29162: IFFALSE 29166
// exit ;
29164: GO 29728
// for i = 1 to mc_bases do
29166: LD_ADDR_VAR 0 2
29170: PUSH
29171: DOUBLE
29172: LD_INT 1
29174: DEC
29175: ST_TO_ADDR
29176: LD_EXP 90
29180: PUSH
29181: FOR_TO
29182: IFFALSE 29719
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29184: LD_ADDR_VAR 0 5
29188: PUSH
29189: LD_EXP 90
29193: PUSH
29194: LD_VAR 0 2
29198: ARRAY
29199: PUSH
29200: LD_EXP 119
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: UNION
29211: PPUSH
29212: LD_INT 21
29214: PUSH
29215: LD_INT 1
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: LD_INT 3
29227: PUSH
29228: LD_INT 54
29230: PUSH
29231: EMPTY
29232: LIST
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 3
29240: PUSH
29241: LD_INT 24
29243: PUSH
29244: LD_INT 800
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PPUSH
29264: CALL_OW 72
29268: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29269: LD_ADDR_VAR 0 6
29273: PUSH
29274: LD_EXP 90
29278: PUSH
29279: LD_VAR 0 2
29283: ARRAY
29284: PPUSH
29285: LD_INT 21
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: PUSH
29298: LD_INT 3
29300: PUSH
29301: LD_INT 54
29303: PUSH
29304: EMPTY
29305: LIST
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 3
29313: PUSH
29314: LD_INT 24
29316: PUSH
29317: LD_INT 250
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: LIST
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29342: LD_ADDR_VAR 0 7
29346: PUSH
29347: LD_VAR 0 5
29351: PUSH
29352: LD_VAR 0 6
29356: DIFF
29357: ST_TO_ADDR
// if not need_heal_1 then
29358: LD_VAR 0 6
29362: NOT
29363: IFFALSE 29396
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29365: LD_ADDR_EXP 93
29369: PUSH
29370: LD_EXP 93
29374: PPUSH
29375: LD_VAR 0 2
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PPUSH
29387: EMPTY
29388: PPUSH
29389: CALL 55792 0 3
29393: ST_TO_ADDR
29394: GO 29466
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29396: LD_ADDR_EXP 93
29400: PUSH
29401: LD_EXP 93
29405: PPUSH
29406: LD_VAR 0 2
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PPUSH
29418: LD_EXP 93
29422: PUSH
29423: LD_VAR 0 2
29427: ARRAY
29428: PUSH
29429: LD_INT 1
29431: ARRAY
29432: PPUSH
29433: LD_INT 3
29435: PUSH
29436: LD_INT 24
29438: PUSH
29439: LD_INT 1000
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PPUSH
29450: CALL_OW 72
29454: PUSH
29455: LD_VAR 0 6
29459: UNION
29460: PPUSH
29461: CALL 55792 0 3
29465: ST_TO_ADDR
// if not need_heal_2 then
29466: LD_VAR 0 7
29470: NOT
29471: IFFALSE 29504
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29473: LD_ADDR_EXP 93
29477: PUSH
29478: LD_EXP 93
29482: PPUSH
29483: LD_VAR 0 2
29487: PUSH
29488: LD_INT 2
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PPUSH
29495: EMPTY
29496: PPUSH
29497: CALL 55792 0 3
29501: ST_TO_ADDR
29502: GO 29536
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29504: LD_ADDR_EXP 93
29508: PUSH
29509: LD_EXP 93
29513: PPUSH
29514: LD_VAR 0 2
29518: PUSH
29519: LD_INT 2
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PPUSH
29526: LD_VAR 0 7
29530: PPUSH
29531: CALL 55792 0 3
29535: ST_TO_ADDR
// if need_heal_2 then
29536: LD_VAR 0 7
29540: IFFALSE 29701
// for j in need_heal_2 do
29542: LD_ADDR_VAR 0 3
29546: PUSH
29547: LD_VAR 0 7
29551: PUSH
29552: FOR_IN
29553: IFFALSE 29699
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29555: LD_ADDR_VAR 0 5
29559: PUSH
29560: LD_EXP 90
29564: PUSH
29565: LD_VAR 0 2
29569: ARRAY
29570: PPUSH
29571: LD_INT 2
29573: PUSH
29574: LD_INT 30
29576: PUSH
29577: LD_INT 6
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 7
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 30
29596: PUSH
29597: LD_INT 8
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 0
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 30
29616: PUSH
29617: LD_INT 1
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: LIST
29628: LIST
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 72
29636: ST_TO_ADDR
// if tmp then
29637: LD_VAR 0 5
29641: IFFALSE 29697
// begin k := NearestUnitToUnit ( tmp , j ) ;
29643: LD_ADDR_VAR 0 4
29647: PUSH
29648: LD_VAR 0 5
29652: PPUSH
29653: LD_VAR 0 3
29657: PPUSH
29658: CALL_OW 74
29662: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29663: LD_VAR 0 3
29667: PPUSH
29668: LD_VAR 0 4
29672: PPUSH
29673: CALL_OW 296
29677: PUSH
29678: LD_INT 5
29680: GREATER
29681: IFFALSE 29697
// ComMoveToNearbyEntrance ( j , k ) ;
29683: LD_VAR 0 3
29687: PPUSH
29688: LD_VAR 0 4
29692: PPUSH
29693: CALL 87658 0 2
// end ; end ;
29697: GO 29552
29699: POP
29700: POP
// if not need_heal_1 and not need_heal_2 then
29701: LD_VAR 0 6
29705: NOT
29706: PUSH
29707: LD_VAR 0 7
29711: NOT
29712: AND
29713: IFFALSE 29717
// continue ;
29715: GO 29181
// end ;
29717: GO 29181
29719: POP
29720: POP
// RaiseSailEvent ( 102 ) ;
29721: LD_INT 102
29723: PPUSH
29724: CALL_OW 427
// end ;
29728: LD_VAR 0 1
29732: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29733: LD_INT 0
29735: PPUSH
29736: PPUSH
29737: PPUSH
29738: PPUSH
29739: PPUSH
29740: PPUSH
29741: PPUSH
29742: PPUSH
// if not mc_bases then
29743: LD_EXP 90
29747: NOT
29748: IFFALSE 29752
// exit ;
29750: GO 30613
// for i = 1 to mc_bases do
29752: LD_ADDR_VAR 0 2
29756: PUSH
29757: DOUBLE
29758: LD_INT 1
29760: DEC
29761: ST_TO_ADDR
29762: LD_EXP 90
29766: PUSH
29767: FOR_TO
29768: IFFALSE 30611
// begin if not mc_building_need_repair [ i ] then
29770: LD_EXP 91
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: NOT
29781: IFFALSE 29968
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29783: LD_ADDR_VAR 0 6
29787: PUSH
29788: LD_EXP 109
29792: PUSH
29793: LD_VAR 0 2
29797: ARRAY
29798: PPUSH
29799: LD_INT 3
29801: PUSH
29802: LD_INT 24
29804: PUSH
29805: LD_INT 1000
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 34
29821: PUSH
29822: LD_INT 13
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 34
29831: PUSH
29832: LD_INT 52
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 34
29841: PUSH
29842: LD_EXP 78
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PPUSH
29861: CALL_OW 72
29865: ST_TO_ADDR
// if cranes then
29866: LD_VAR 0 6
29870: IFFALSE 29932
// for j in cranes do
29872: LD_ADDR_VAR 0 3
29876: PUSH
29877: LD_VAR 0 6
29881: PUSH
29882: FOR_IN
29883: IFFALSE 29930
// if not IsInArea ( j , mc_parking [ i ] ) then
29885: LD_VAR 0 3
29889: PPUSH
29890: LD_EXP 114
29894: PUSH
29895: LD_VAR 0 2
29899: ARRAY
29900: PPUSH
29901: CALL_OW 308
29905: NOT
29906: IFFALSE 29928
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29908: LD_VAR 0 3
29912: PPUSH
29913: LD_EXP 114
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: PPUSH
29924: CALL_OW 113
29928: GO 29882
29930: POP
29931: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29932: LD_ADDR_EXP 92
29936: PUSH
29937: LD_EXP 92
29941: PPUSH
29942: LD_VAR 0 2
29946: PPUSH
29947: EMPTY
29948: PPUSH
29949: CALL_OW 1
29953: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29954: LD_VAR 0 2
29958: PPUSH
29959: LD_INT 101
29961: PPUSH
29962: CALL 24856 0 2
// continue ;
29966: GO 29767
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29968: LD_ADDR_EXP 96
29972: PUSH
29973: LD_EXP 96
29977: PPUSH
29978: LD_VAR 0 2
29982: PPUSH
29983: EMPTY
29984: PPUSH
29985: CALL_OW 1
29989: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29990: LD_VAR 0 2
29994: PPUSH
29995: LD_INT 103
29997: PPUSH
29998: CALL 24856 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30002: LD_ADDR_VAR 0 5
30006: PUSH
30007: LD_EXP 90
30011: PUSH
30012: LD_VAR 0 2
30016: ARRAY
30017: PUSH
30018: LD_EXP 119
30022: PUSH
30023: LD_VAR 0 2
30027: ARRAY
30028: UNION
30029: PPUSH
30030: LD_INT 2
30032: PUSH
30033: LD_INT 25
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 25
30045: PUSH
30046: LD_INT 16
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: LIST
30057: PUSH
30058: EMPTY
30059: LIST
30060: PPUSH
30061: CALL_OW 72
30065: PUSH
30066: LD_EXP 93
30070: PUSH
30071: LD_VAR 0 2
30075: ARRAY
30076: PUSH
30077: LD_INT 1
30079: ARRAY
30080: PUSH
30081: LD_EXP 93
30085: PUSH
30086: LD_VAR 0 2
30090: ARRAY
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: UNION
30096: DIFF
30097: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30098: LD_ADDR_VAR 0 6
30102: PUSH
30103: LD_EXP 109
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PPUSH
30114: LD_INT 2
30116: PUSH
30117: LD_INT 34
30119: PUSH
30120: LD_INT 13
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 34
30129: PUSH
30130: LD_INT 52
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 34
30139: PUSH
30140: LD_EXP 78
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: PPUSH
30155: CALL_OW 72
30159: ST_TO_ADDR
// if cranes then
30160: LD_VAR 0 6
30164: IFFALSE 30300
// begin for j in cranes do
30166: LD_ADDR_VAR 0 3
30170: PUSH
30171: LD_VAR 0 6
30175: PUSH
30176: FOR_IN
30177: IFFALSE 30298
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30179: LD_VAR 0 3
30183: PPUSH
30184: CALL_OW 256
30188: PUSH
30189: LD_INT 1000
30191: EQUAL
30192: PUSH
30193: LD_VAR 0 3
30197: PPUSH
30198: CALL_OW 314
30202: NOT
30203: AND
30204: IFFALSE 30238
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30206: LD_VAR 0 3
30210: PPUSH
30211: LD_EXP 91
30215: PUSH
30216: LD_VAR 0 2
30220: ARRAY
30221: PPUSH
30222: LD_VAR 0 3
30226: PPUSH
30227: CALL_OW 74
30231: PPUSH
30232: CALL_OW 130
30236: GO 30296
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30238: LD_VAR 0 3
30242: PPUSH
30243: CALL_OW 256
30247: PUSH
30248: LD_INT 500
30250: LESS
30251: PUSH
30252: LD_VAR 0 3
30256: PPUSH
30257: LD_EXP 114
30261: PUSH
30262: LD_VAR 0 2
30266: ARRAY
30267: PPUSH
30268: CALL_OW 308
30272: NOT
30273: AND
30274: IFFALSE 30296
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30276: LD_VAR 0 3
30280: PPUSH
30281: LD_EXP 114
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: PPUSH
30292: CALL_OW 113
// end ;
30296: GO 30176
30298: POP
30299: POP
// end ; if tmp > 3 then
30300: LD_VAR 0 5
30304: PUSH
30305: LD_INT 3
30307: GREATER
30308: IFFALSE 30328
// tmp := ShrinkArray ( tmp , 4 ) ;
30310: LD_ADDR_VAR 0 5
30314: PUSH
30315: LD_VAR 0 5
30319: PPUSH
30320: LD_INT 4
30322: PPUSH
30323: CALL 87150 0 2
30327: ST_TO_ADDR
// if not tmp then
30328: LD_VAR 0 5
30332: NOT
30333: IFFALSE 30337
// continue ;
30335: GO 29767
// for j in tmp do
30337: LD_ADDR_VAR 0 3
30341: PUSH
30342: LD_VAR 0 5
30346: PUSH
30347: FOR_IN
30348: IFFALSE 30607
// begin if IsInUnit ( j ) then
30350: LD_VAR 0 3
30354: PPUSH
30355: CALL_OW 310
30359: IFFALSE 30370
// ComExitBuilding ( j ) ;
30361: LD_VAR 0 3
30365: PPUSH
30366: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30370: LD_VAR 0 3
30374: PUSH
30375: LD_EXP 92
30379: PUSH
30380: LD_VAR 0 2
30384: ARRAY
30385: IN
30386: NOT
30387: IFFALSE 30445
// begin SetTag ( j , 101 ) ;
30389: LD_VAR 0 3
30393: PPUSH
30394: LD_INT 101
30396: PPUSH
30397: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30401: LD_ADDR_EXP 92
30405: PUSH
30406: LD_EXP 92
30410: PPUSH
30411: LD_VAR 0 2
30415: PUSH
30416: LD_EXP 92
30420: PUSH
30421: LD_VAR 0 2
30425: ARRAY
30426: PUSH
30427: LD_INT 1
30429: PLUS
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PPUSH
30435: LD_VAR 0 3
30439: PPUSH
30440: CALL 55792 0 3
30444: ST_TO_ADDR
// end ; wait ( 1 ) ;
30445: LD_INT 1
30447: PPUSH
30448: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30452: LD_ADDR_VAR 0 7
30456: PUSH
30457: LD_EXP 91
30461: PUSH
30462: LD_VAR 0 2
30466: ARRAY
30467: ST_TO_ADDR
// if mc_scan [ i ] then
30468: LD_EXP 113
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: IFFALSE 30540
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30480: LD_ADDR_VAR 0 7
30484: PUSH
30485: LD_EXP 91
30489: PUSH
30490: LD_VAR 0 2
30494: ARRAY
30495: PPUSH
30496: LD_INT 3
30498: PUSH
30499: LD_INT 30
30501: PUSH
30502: LD_INT 32
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 30
30511: PUSH
30512: LD_INT 33
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 30
30521: PUSH
30522: LD_INT 31
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: PPUSH
30535: CALL_OW 72
30539: ST_TO_ADDR
// if not to_repair_tmp then
30540: LD_VAR 0 7
30544: NOT
30545: IFFALSE 30549
// continue ;
30547: GO 30347
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30549: LD_ADDR_VAR 0 8
30553: PUSH
30554: LD_VAR 0 7
30558: PPUSH
30559: LD_VAR 0 3
30563: PPUSH
30564: CALL_OW 74
30568: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30569: LD_VAR 0 8
30573: PPUSH
30574: LD_INT 16
30576: PPUSH
30577: CALL 58385 0 2
30581: PUSH
30582: LD_INT 4
30584: ARRAY
30585: PUSH
30586: LD_INT 10
30588: LESS
30589: IFFALSE 30605
// ComRepairBuilding ( j , to_repair ) ;
30591: LD_VAR 0 3
30595: PPUSH
30596: LD_VAR 0 8
30600: PPUSH
30601: CALL_OW 130
// end ;
30605: GO 30347
30607: POP
30608: POP
// end ;
30609: GO 29767
30611: POP
30612: POP
// end ;
30613: LD_VAR 0 1
30617: RET
// export function MC_Heal ; var i , j , tmp ; begin
30618: LD_INT 0
30620: PPUSH
30621: PPUSH
30622: PPUSH
30623: PPUSH
// if not mc_bases then
30624: LD_EXP 90
30628: NOT
30629: IFFALSE 30633
// exit ;
30631: GO 31035
// for i = 1 to mc_bases do
30633: LD_ADDR_VAR 0 2
30637: PUSH
30638: DOUBLE
30639: LD_INT 1
30641: DEC
30642: ST_TO_ADDR
30643: LD_EXP 90
30647: PUSH
30648: FOR_TO
30649: IFFALSE 31033
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30651: LD_EXP 93
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: PUSH
30662: LD_INT 1
30664: ARRAY
30665: NOT
30666: PUSH
30667: LD_EXP 93
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: PUSH
30678: LD_INT 2
30680: ARRAY
30681: NOT
30682: AND
30683: IFFALSE 30721
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30685: LD_ADDR_EXP 94
30689: PUSH
30690: LD_EXP 94
30694: PPUSH
30695: LD_VAR 0 2
30699: PPUSH
30700: EMPTY
30701: PPUSH
30702: CALL_OW 1
30706: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30707: LD_VAR 0 2
30711: PPUSH
30712: LD_INT 102
30714: PPUSH
30715: CALL 24856 0 2
// continue ;
30719: GO 30648
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30721: LD_ADDR_VAR 0 4
30725: PUSH
30726: LD_EXP 90
30730: PUSH
30731: LD_VAR 0 2
30735: ARRAY
30736: PPUSH
30737: LD_INT 25
30739: PUSH
30740: LD_INT 4
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PPUSH
30747: CALL_OW 72
30751: ST_TO_ADDR
// if not tmp then
30752: LD_VAR 0 4
30756: NOT
30757: IFFALSE 30761
// continue ;
30759: GO 30648
// if mc_taming [ i ] then
30761: LD_EXP 121
30765: PUSH
30766: LD_VAR 0 2
30770: ARRAY
30771: IFFALSE 30795
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30773: LD_ADDR_EXP 121
30777: PUSH
30778: LD_EXP 121
30782: PPUSH
30783: LD_VAR 0 2
30787: PPUSH
30788: EMPTY
30789: PPUSH
30790: CALL_OW 1
30794: ST_TO_ADDR
// for j in tmp do
30795: LD_ADDR_VAR 0 3
30799: PUSH
30800: LD_VAR 0 4
30804: PUSH
30805: FOR_IN
30806: IFFALSE 31029
// begin if IsInUnit ( j ) then
30808: LD_VAR 0 3
30812: PPUSH
30813: CALL_OW 310
30817: IFFALSE 30828
// ComExitBuilding ( j ) ;
30819: LD_VAR 0 3
30823: PPUSH
30824: CALL_OW 122
// if not j in mc_healers [ i ] then
30828: LD_VAR 0 3
30832: PUSH
30833: LD_EXP 94
30837: PUSH
30838: LD_VAR 0 2
30842: ARRAY
30843: IN
30844: NOT
30845: IFFALSE 30891
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30847: LD_ADDR_EXP 94
30851: PUSH
30852: LD_EXP 94
30856: PPUSH
30857: LD_VAR 0 2
30861: PUSH
30862: LD_EXP 94
30866: PUSH
30867: LD_VAR 0 2
30871: ARRAY
30872: PUSH
30873: LD_INT 1
30875: PLUS
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PPUSH
30881: LD_VAR 0 3
30885: PPUSH
30886: CALL 55792 0 3
30890: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30891: LD_VAR 0 3
30895: PPUSH
30896: CALL_OW 110
30900: PUSH
30901: LD_INT 102
30903: NONEQUAL
30904: IFFALSE 30918
// SetTag ( j , 102 ) ;
30906: LD_VAR 0 3
30910: PPUSH
30911: LD_INT 102
30913: PPUSH
30914: CALL_OW 109
// Wait ( 3 ) ;
30918: LD_INT 3
30920: PPUSH
30921: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30925: LD_EXP 93
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PUSH
30936: LD_INT 1
30938: ARRAY
30939: IFFALSE 30971
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30941: LD_VAR 0 3
30945: PPUSH
30946: LD_EXP 93
30950: PUSH
30951: LD_VAR 0 2
30955: ARRAY
30956: PUSH
30957: LD_INT 1
30959: ARRAY
30960: PUSH
30961: LD_INT 1
30963: ARRAY
30964: PPUSH
30965: CALL_OW 128
30969: GO 31027
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30971: LD_VAR 0 3
30975: PPUSH
30976: CALL_OW 314
30980: NOT
30981: PUSH
30982: LD_EXP 93
30986: PUSH
30987: LD_VAR 0 2
30991: ARRAY
30992: PUSH
30993: LD_INT 2
30995: ARRAY
30996: AND
30997: IFFALSE 31027
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30999: LD_VAR 0 3
31003: PPUSH
31004: LD_EXP 93
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PUSH
31015: LD_INT 2
31017: ARRAY
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: PPUSH
31023: CALL_OW 128
// end ;
31027: GO 30805
31029: POP
31030: POP
// end ;
31031: GO 30648
31033: POP
31034: POP
// end ;
31035: LD_VAR 0 1
31039: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31040: LD_INT 0
31042: PPUSH
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
// if not mc_bases then
31047: LD_EXP 90
31051: NOT
31052: IFFALSE 31056
// exit ;
31054: GO 32199
// for i = 1 to mc_bases do
31056: LD_ADDR_VAR 0 2
31060: PUSH
31061: DOUBLE
31062: LD_INT 1
31064: DEC
31065: ST_TO_ADDR
31066: LD_EXP 90
31070: PUSH
31071: FOR_TO
31072: IFFALSE 32197
// begin if mc_scan [ i ] then
31074: LD_EXP 113
31078: PUSH
31079: LD_VAR 0 2
31083: ARRAY
31084: IFFALSE 31088
// continue ;
31086: GO 31071
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31088: LD_EXP 95
31092: PUSH
31093: LD_VAR 0 2
31097: ARRAY
31098: NOT
31099: PUSH
31100: LD_EXP 97
31104: PUSH
31105: LD_VAR 0 2
31109: ARRAY
31110: NOT
31111: AND
31112: PUSH
31113: LD_EXP 96
31117: PUSH
31118: LD_VAR 0 2
31122: ARRAY
31123: AND
31124: IFFALSE 31162
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31126: LD_ADDR_EXP 96
31130: PUSH
31131: LD_EXP 96
31135: PPUSH
31136: LD_VAR 0 2
31140: PPUSH
31141: EMPTY
31142: PPUSH
31143: CALL_OW 1
31147: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31148: LD_VAR 0 2
31152: PPUSH
31153: LD_INT 103
31155: PPUSH
31156: CALL 24856 0 2
// continue ;
31160: GO 31071
// end ; if mc_construct_list [ i ] then
31162: LD_EXP 97
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: IFFALSE 31392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31174: LD_ADDR_VAR 0 4
31178: PUSH
31179: LD_EXP 90
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PPUSH
31190: LD_INT 25
31192: PUSH
31193: LD_INT 2
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PPUSH
31200: CALL_OW 72
31204: PUSH
31205: LD_EXP 92
31209: PUSH
31210: LD_VAR 0 2
31214: ARRAY
31215: DIFF
31216: ST_TO_ADDR
// if not tmp then
31217: LD_VAR 0 4
31221: NOT
31222: IFFALSE 31226
// continue ;
31224: GO 31071
// for j in tmp do
31226: LD_ADDR_VAR 0 3
31230: PUSH
31231: LD_VAR 0 4
31235: PUSH
31236: FOR_IN
31237: IFFALSE 31388
// begin if not mc_builders [ i ] then
31239: LD_EXP 96
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: NOT
31250: IFFALSE 31308
// begin SetTag ( j , 103 ) ;
31252: LD_VAR 0 3
31256: PPUSH
31257: LD_INT 103
31259: PPUSH
31260: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31264: LD_ADDR_EXP 96
31268: PUSH
31269: LD_EXP 96
31273: PPUSH
31274: LD_VAR 0 2
31278: PUSH
31279: LD_EXP 96
31283: PUSH
31284: LD_VAR 0 2
31288: ARRAY
31289: PUSH
31290: LD_INT 1
31292: PLUS
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PPUSH
31298: LD_VAR 0 3
31302: PPUSH
31303: CALL 55792 0 3
31307: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31308: LD_VAR 0 3
31312: PPUSH
31313: CALL_OW 310
31317: IFFALSE 31328
// ComExitBuilding ( j ) ;
31319: LD_VAR 0 3
31323: PPUSH
31324: CALL_OW 122
// wait ( 3 ) ;
31328: LD_INT 3
31330: PPUSH
31331: CALL_OW 67
// if not mc_construct_list [ i ] then
31335: LD_EXP 97
31339: PUSH
31340: LD_VAR 0 2
31344: ARRAY
31345: NOT
31346: IFFALSE 31350
// break ;
31348: GO 31388
// if not HasTask ( j ) then
31350: LD_VAR 0 3
31354: PPUSH
31355: CALL_OW 314
31359: NOT
31360: IFFALSE 31386
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31362: LD_VAR 0 3
31366: PPUSH
31367: LD_EXP 97
31371: PUSH
31372: LD_VAR 0 2
31376: ARRAY
31377: PUSH
31378: LD_INT 1
31380: ARRAY
31381: PPUSH
31382: CALL 58643 0 2
// end ;
31386: GO 31236
31388: POP
31389: POP
// end else
31390: GO 32195
// if mc_build_list [ i ] then
31392: LD_EXP 95
31396: PUSH
31397: LD_VAR 0 2
31401: ARRAY
31402: IFFALSE 32195
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31404: LD_ADDR_VAR 0 5
31408: PUSH
31409: LD_EXP 90
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PPUSH
31420: LD_INT 2
31422: PUSH
31423: LD_INT 30
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 30
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: LIST
31447: PPUSH
31448: CALL_OW 72
31452: ST_TO_ADDR
// if depot then
31453: LD_VAR 0 5
31457: IFFALSE 31475
// depot := depot [ 1 ] else
31459: LD_ADDR_VAR 0 5
31463: PUSH
31464: LD_VAR 0 5
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: ST_TO_ADDR
31473: GO 31483
// depot := 0 ;
31475: LD_ADDR_VAR 0 5
31479: PUSH
31480: LD_INT 0
31482: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31483: LD_EXP 95
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: PUSH
31494: LD_INT 1
31496: ARRAY
31497: PUSH
31498: LD_INT 1
31500: ARRAY
31501: PPUSH
31502: CALL 58473 0 1
31506: PUSH
31507: LD_EXP 90
31511: PUSH
31512: LD_VAR 0 2
31516: ARRAY
31517: PPUSH
31518: LD_INT 2
31520: PUSH
31521: LD_INT 30
31523: PUSH
31524: LD_INT 2
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 30
31533: PUSH
31534: LD_INT 3
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: LIST
31545: PPUSH
31546: CALL_OW 72
31550: NOT
31551: AND
31552: IFFALSE 31657
// begin for j = 1 to mc_build_list [ i ] do
31554: LD_ADDR_VAR 0 3
31558: PUSH
31559: DOUBLE
31560: LD_INT 1
31562: DEC
31563: ST_TO_ADDR
31564: LD_EXP 95
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: FOR_TO
31576: IFFALSE 31655
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31578: LD_EXP 95
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 1
31597: ARRAY
31598: PUSH
31599: LD_INT 2
31601: EQUAL
31602: IFFALSE 31653
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31604: LD_ADDR_EXP 95
31608: PUSH
31609: LD_EXP 95
31613: PPUSH
31614: LD_VAR 0 2
31618: PPUSH
31619: LD_EXP 95
31623: PUSH
31624: LD_VAR 0 2
31628: ARRAY
31629: PPUSH
31630: LD_VAR 0 3
31634: PPUSH
31635: LD_INT 1
31637: PPUSH
31638: LD_INT 0
31640: PPUSH
31641: CALL 55210 0 4
31645: PPUSH
31646: CALL_OW 1
31650: ST_TO_ADDR
// break ;
31651: GO 31655
// end ;
31653: GO 31575
31655: POP
31656: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31657: LD_EXP 95
31661: PUSH
31662: LD_VAR 0 2
31666: ARRAY
31667: PUSH
31668: LD_INT 1
31670: ARRAY
31671: PUSH
31672: LD_INT 1
31674: ARRAY
31675: PUSH
31676: LD_INT 0
31678: EQUAL
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_VAR 0 5
31689: PPUSH
31690: LD_EXP 95
31694: PUSH
31695: LD_VAR 0 2
31699: ARRAY
31700: PUSH
31701: LD_INT 1
31703: ARRAY
31704: PUSH
31705: LD_INT 1
31707: ARRAY
31708: PPUSH
31709: LD_EXP 95
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: PUSH
31720: LD_INT 1
31722: ARRAY
31723: PUSH
31724: LD_INT 2
31726: ARRAY
31727: PPUSH
31728: LD_EXP 95
31732: PUSH
31733: LD_VAR 0 2
31737: ARRAY
31738: PUSH
31739: LD_INT 1
31741: ARRAY
31742: PUSH
31743: LD_INT 3
31745: ARRAY
31746: PPUSH
31747: LD_EXP 95
31751: PUSH
31752: LD_VAR 0 2
31756: ARRAY
31757: PUSH
31758: LD_INT 1
31760: ARRAY
31761: PUSH
31762: LD_INT 4
31764: ARRAY
31765: PPUSH
31766: CALL 63207 0 5
31770: AND
31771: OR
31772: IFFALSE 32053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31774: LD_ADDR_VAR 0 4
31778: PUSH
31779: LD_EXP 90
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: PPUSH
31790: LD_INT 25
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PPUSH
31800: CALL_OW 72
31804: PUSH
31805: LD_EXP 92
31809: PUSH
31810: LD_VAR 0 2
31814: ARRAY
31815: DIFF
31816: ST_TO_ADDR
// if not tmp then
31817: LD_VAR 0 4
31821: NOT
31822: IFFALSE 31826
// continue ;
31824: GO 31071
// for j in tmp do
31826: LD_ADDR_VAR 0 3
31830: PUSH
31831: LD_VAR 0 4
31835: PUSH
31836: FOR_IN
31837: IFFALSE 32049
// begin if not mc_builders [ i ] then
31839: LD_EXP 96
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: NOT
31850: IFFALSE 31908
// begin SetTag ( j , 103 ) ;
31852: LD_VAR 0 3
31856: PPUSH
31857: LD_INT 103
31859: PPUSH
31860: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31864: LD_ADDR_EXP 96
31868: PUSH
31869: LD_EXP 96
31873: PPUSH
31874: LD_VAR 0 2
31878: PUSH
31879: LD_EXP 96
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: PLUS
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PPUSH
31898: LD_VAR 0 3
31902: PPUSH
31903: CALL 55792 0 3
31907: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31908: LD_VAR 0 3
31912: PPUSH
31913: CALL_OW 310
31917: IFFALSE 31928
// ComExitBuilding ( j ) ;
31919: LD_VAR 0 3
31923: PPUSH
31924: CALL_OW 122
// wait ( 3 ) ;
31928: LD_INT 3
31930: PPUSH
31931: CALL_OW 67
// if not mc_build_list [ i ] then
31935: LD_EXP 95
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: NOT
31946: IFFALSE 31950
// break ;
31948: GO 32049
// if not HasTask ( j ) then
31950: LD_VAR 0 3
31954: PPUSH
31955: CALL_OW 314
31959: NOT
31960: IFFALSE 32047
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31962: LD_VAR 0 3
31966: PPUSH
31967: LD_EXP 95
31971: PUSH
31972: LD_VAR 0 2
31976: ARRAY
31977: PUSH
31978: LD_INT 1
31980: ARRAY
31981: PUSH
31982: LD_INT 1
31984: ARRAY
31985: PPUSH
31986: LD_EXP 95
31990: PUSH
31991: LD_VAR 0 2
31995: ARRAY
31996: PUSH
31997: LD_INT 1
31999: ARRAY
32000: PUSH
32001: LD_INT 2
32003: ARRAY
32004: PPUSH
32005: LD_EXP 95
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: PUSH
32016: LD_INT 1
32018: ARRAY
32019: PUSH
32020: LD_INT 3
32022: ARRAY
32023: PPUSH
32024: LD_EXP 95
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: PUSH
32035: LD_INT 1
32037: ARRAY
32038: PUSH
32039: LD_INT 4
32041: ARRAY
32042: PPUSH
32043: CALL_OW 145
// end ;
32047: GO 31836
32049: POP
32050: POP
// end else
32051: GO 32195
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32053: LD_EXP 90
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: PPUSH
32064: LD_EXP 95
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PUSH
32075: LD_INT 1
32077: ARRAY
32078: PUSH
32079: LD_INT 1
32081: ARRAY
32082: PPUSH
32083: LD_EXP 95
32087: PUSH
32088: LD_VAR 0 2
32092: ARRAY
32093: PUSH
32094: LD_INT 1
32096: ARRAY
32097: PUSH
32098: LD_INT 2
32100: ARRAY
32101: PPUSH
32102: LD_EXP 95
32106: PUSH
32107: LD_VAR 0 2
32111: ARRAY
32112: PUSH
32113: LD_INT 1
32115: ARRAY
32116: PUSH
32117: LD_INT 3
32119: ARRAY
32120: PPUSH
32121: LD_EXP 95
32125: PUSH
32126: LD_VAR 0 2
32130: ARRAY
32131: PUSH
32132: LD_INT 1
32134: ARRAY
32135: PUSH
32136: LD_INT 4
32138: ARRAY
32139: PPUSH
32140: CALL 62543 0 5
32144: NOT
32145: IFFALSE 32195
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32147: LD_ADDR_EXP 95
32151: PUSH
32152: LD_EXP 95
32156: PPUSH
32157: LD_VAR 0 2
32161: PPUSH
32162: LD_EXP 95
32166: PUSH
32167: LD_VAR 0 2
32171: ARRAY
32172: PPUSH
32173: LD_INT 1
32175: PPUSH
32176: LD_INT 1
32178: NEG
32179: PPUSH
32180: LD_INT 0
32182: PPUSH
32183: CALL 55210 0 4
32187: PPUSH
32188: CALL_OW 1
32192: ST_TO_ADDR
// continue ;
32193: GO 31071
// end ; end ; end ;
32195: GO 31071
32197: POP
32198: POP
// end ;
32199: LD_VAR 0 1
32203: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
32211: PPUSH
// if not mc_bases then
32212: LD_EXP 90
32216: NOT
32217: IFFALSE 32221
// exit ;
32219: GO 32648
// for i = 1 to mc_bases do
32221: LD_ADDR_VAR 0 2
32225: PUSH
32226: DOUBLE
32227: LD_INT 1
32229: DEC
32230: ST_TO_ADDR
32231: LD_EXP 90
32235: PUSH
32236: FOR_TO
32237: IFFALSE 32646
// begin tmp := mc_build_upgrade [ i ] ;
32239: LD_ADDR_VAR 0 4
32243: PUSH
32244: LD_EXP 122
32248: PUSH
32249: LD_VAR 0 2
32253: ARRAY
32254: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32255: LD_ADDR_VAR 0 6
32259: PUSH
32260: LD_EXP 123
32264: PUSH
32265: LD_VAR 0 2
32269: ARRAY
32270: PPUSH
32271: LD_INT 2
32273: PUSH
32274: LD_INT 30
32276: PUSH
32277: LD_INT 6
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 30
32286: PUSH
32287: LD_INT 7
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: LIST
32298: PPUSH
32299: CALL_OW 72
32303: ST_TO_ADDR
// if not tmp and not lab then
32304: LD_VAR 0 4
32308: NOT
32309: PUSH
32310: LD_VAR 0 6
32314: NOT
32315: AND
32316: IFFALSE 32320
// continue ;
32318: GO 32236
// if tmp then
32320: LD_VAR 0 4
32324: IFFALSE 32444
// for j in tmp do
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 4
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32442
// begin if UpgradeCost ( j ) then
32339: LD_VAR 0 3
32343: PPUSH
32344: CALL 62203 0 1
32348: IFFALSE 32440
// begin ComUpgrade ( j ) ;
32350: LD_VAR 0 3
32354: PPUSH
32355: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32359: LD_ADDR_EXP 122
32363: PUSH
32364: LD_EXP 122
32368: PPUSH
32369: LD_VAR 0 2
32373: PPUSH
32374: LD_EXP 122
32378: PUSH
32379: LD_VAR 0 2
32383: ARRAY
32384: PUSH
32385: LD_VAR 0 3
32389: DIFF
32390: PPUSH
32391: CALL_OW 1
32395: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32396: LD_ADDR_EXP 97
32400: PUSH
32401: LD_EXP 97
32405: PPUSH
32406: LD_VAR 0 2
32410: PUSH
32411: LD_EXP 97
32415: PUSH
32416: LD_VAR 0 2
32420: ARRAY
32421: PUSH
32422: LD_INT 1
32424: PLUS
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PPUSH
32430: LD_VAR 0 3
32434: PPUSH
32435: CALL 55792 0 3
32439: ST_TO_ADDR
// end ; end ;
32440: GO 32336
32442: POP
32443: POP
// if not lab or not mc_lab_upgrade [ i ] then
32444: LD_VAR 0 6
32448: NOT
32449: PUSH
32450: LD_EXP 124
32454: PUSH
32455: LD_VAR 0 2
32459: ARRAY
32460: NOT
32461: OR
32462: IFFALSE 32466
// continue ;
32464: GO 32236
// for j in lab do
32466: LD_ADDR_VAR 0 3
32470: PUSH
32471: LD_VAR 0 6
32475: PUSH
32476: FOR_IN
32477: IFFALSE 32642
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32479: LD_VAR 0 3
32483: PPUSH
32484: CALL_OW 266
32488: PUSH
32489: LD_INT 6
32491: PUSH
32492: LD_INT 7
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: IN
32499: PUSH
32500: LD_VAR 0 3
32504: PPUSH
32505: CALL_OW 461
32509: PUSH
32510: LD_INT 1
32512: NONEQUAL
32513: AND
32514: IFFALSE 32640
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32516: LD_VAR 0 3
32520: PPUSH
32521: LD_EXP 124
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PUSH
32532: LD_INT 1
32534: ARRAY
32535: PPUSH
32536: CALL 62408 0 2
32540: IFFALSE 32640
// begin ComCancel ( j ) ;
32542: LD_VAR 0 3
32546: PPUSH
32547: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32551: LD_VAR 0 3
32555: PPUSH
32556: LD_EXP 124
32560: PUSH
32561: LD_VAR 0 2
32565: ARRAY
32566: PUSH
32567: LD_INT 1
32569: ARRAY
32570: PPUSH
32571: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32575: LD_VAR 0 3
32579: PUSH
32580: LD_EXP 97
32584: PUSH
32585: LD_VAR 0 2
32589: ARRAY
32590: IN
32591: NOT
32592: IFFALSE 32638
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32594: LD_ADDR_EXP 97
32598: PUSH
32599: LD_EXP 97
32603: PPUSH
32604: LD_VAR 0 2
32608: PUSH
32609: LD_EXP 97
32613: PUSH
32614: LD_VAR 0 2
32618: ARRAY
32619: PUSH
32620: LD_INT 1
32622: PLUS
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: LD_VAR 0 3
32632: PPUSH
32633: CALL 55792 0 3
32637: ST_TO_ADDR
// break ;
32638: GO 32642
// end ; end ; end ;
32640: GO 32476
32642: POP
32643: POP
// end ;
32644: GO 32236
32646: POP
32647: POP
// end ;
32648: LD_VAR 0 1
32652: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32653: LD_INT 0
32655: PPUSH
32656: PPUSH
32657: PPUSH
32658: PPUSH
32659: PPUSH
32660: PPUSH
32661: PPUSH
32662: PPUSH
32663: PPUSH
// if not mc_bases then
32664: LD_EXP 90
32668: NOT
32669: IFFALSE 32673
// exit ;
32671: GO 33078
// for i = 1 to mc_bases do
32673: LD_ADDR_VAR 0 2
32677: PUSH
32678: DOUBLE
32679: LD_INT 1
32681: DEC
32682: ST_TO_ADDR
32683: LD_EXP 90
32687: PUSH
32688: FOR_TO
32689: IFFALSE 33076
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32691: LD_EXP 98
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: NOT
32702: PUSH
32703: LD_EXP 90
32707: PUSH
32708: LD_VAR 0 2
32712: ARRAY
32713: PPUSH
32714: LD_INT 30
32716: PUSH
32717: LD_INT 3
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PPUSH
32724: CALL_OW 72
32728: NOT
32729: OR
32730: IFFALSE 32734
// continue ;
32732: GO 32688
// busy := false ;
32734: LD_ADDR_VAR 0 8
32738: PUSH
32739: LD_INT 0
32741: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32742: LD_ADDR_VAR 0 4
32746: PUSH
32747: LD_EXP 90
32751: PUSH
32752: LD_VAR 0 2
32756: ARRAY
32757: PPUSH
32758: LD_INT 30
32760: PUSH
32761: LD_INT 3
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PPUSH
32768: CALL_OW 72
32772: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32773: LD_ADDR_VAR 0 6
32777: PUSH
32778: LD_EXP 98
32782: PUSH
32783: LD_VAR 0 2
32787: ARRAY
32788: PPUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 30
32794: PUSH
32795: LD_INT 32
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 30
32804: PUSH
32805: LD_INT 33
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: LIST
32816: PPUSH
32817: CALL_OW 72
32821: ST_TO_ADDR
// if not t then
32822: LD_VAR 0 6
32826: NOT
32827: IFFALSE 32831
// continue ;
32829: GO 32688
// for j in tmp do
32831: LD_ADDR_VAR 0 3
32835: PUSH
32836: LD_VAR 0 4
32840: PUSH
32841: FOR_IN
32842: IFFALSE 32872
// if not BuildingStatus ( j ) = bs_idle then
32844: LD_VAR 0 3
32848: PPUSH
32849: CALL_OW 461
32853: PUSH
32854: LD_INT 2
32856: EQUAL
32857: NOT
32858: IFFALSE 32870
// begin busy := true ;
32860: LD_ADDR_VAR 0 8
32864: PUSH
32865: LD_INT 1
32867: ST_TO_ADDR
// break ;
32868: GO 32872
// end ;
32870: GO 32841
32872: POP
32873: POP
// if busy then
32874: LD_VAR 0 8
32878: IFFALSE 32882
// continue ;
32880: GO 32688
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32882: LD_ADDR_VAR 0 7
32886: PUSH
32887: LD_VAR 0 6
32891: PPUSH
32892: LD_INT 35
32894: PUSH
32895: LD_INT 0
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PPUSH
32902: CALL_OW 72
32906: ST_TO_ADDR
// if tw then
32907: LD_VAR 0 7
32911: IFFALSE 32988
// begin tw := tw [ 1 ] ;
32913: LD_ADDR_VAR 0 7
32917: PUSH
32918: LD_VAR 0 7
32922: PUSH
32923: LD_INT 1
32925: ARRAY
32926: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32927: LD_ADDR_VAR 0 9
32931: PUSH
32932: LD_VAR 0 7
32936: PPUSH
32937: LD_EXP 115
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: PPUSH
32948: CALL 60762 0 2
32952: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32953: LD_EXP 129
32957: PUSH
32958: LD_VAR 0 2
32962: ARRAY
32963: IFFALSE 32986
// if not weapon in mc_allowed_tower_weapons [ i ] then
32965: LD_VAR 0 9
32969: PUSH
32970: LD_EXP 129
32974: PUSH
32975: LD_VAR 0 2
32979: ARRAY
32980: IN
32981: NOT
32982: IFFALSE 32986
// continue ;
32984: GO 32688
// end else
32986: GO 33051
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32988: LD_ADDR_VAR 0 5
32992: PUSH
32993: LD_EXP 98
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 4
33008: PPUSH
33009: CALL 86383 0 2
33013: ST_TO_ADDR
// if not tmp2 then
33014: LD_VAR 0 5
33018: NOT
33019: IFFALSE 33023
// continue ;
33021: GO 32688
// tw := tmp2 [ 1 ] ;
33023: LD_ADDR_VAR 0 7
33027: PUSH
33028: LD_VAR 0 5
33032: PUSH
33033: LD_INT 1
33035: ARRAY
33036: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33037: LD_ADDR_VAR 0 9
33041: PUSH
33042: LD_VAR 0 5
33046: PUSH
33047: LD_INT 2
33049: ARRAY
33050: ST_TO_ADDR
// end ; if not weapon then
33051: LD_VAR 0 9
33055: NOT
33056: IFFALSE 33060
// continue ;
33058: GO 32688
// ComPlaceWeapon ( tw , weapon ) ;
33060: LD_VAR 0 7
33064: PPUSH
33065: LD_VAR 0 9
33069: PPUSH
33070: CALL_OW 148
// end ;
33074: GO 32688
33076: POP
33077: POP
// end ;
33078: LD_VAR 0 1
33082: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
33083: LD_INT 0
33085: PPUSH
33086: PPUSH
33087: PPUSH
33088: PPUSH
33089: PPUSH
33090: PPUSH
// if not mc_bases then
33091: LD_EXP 90
33095: NOT
33096: IFFALSE 33100
// exit ;
33098: GO 33876
// for i = 1 to mc_bases do
33100: LD_ADDR_VAR 0 2
33104: PUSH
33105: DOUBLE
33106: LD_INT 1
33108: DEC
33109: ST_TO_ADDR
33110: LD_EXP 90
33114: PUSH
33115: FOR_TO
33116: IFFALSE 33874
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33118: LD_EXP 103
33122: PUSH
33123: LD_VAR 0 2
33127: ARRAY
33128: NOT
33129: PUSH
33130: LD_EXP 103
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PUSH
33141: LD_EXP 104
33145: PUSH
33146: LD_VAR 0 2
33150: ARRAY
33151: EQUAL
33152: OR
33153: PUSH
33154: LD_EXP 113
33158: PUSH
33159: LD_VAR 0 2
33163: ARRAY
33164: OR
33165: IFFALSE 33169
// continue ;
33167: GO 33115
// if mc_miners [ i ] then
33169: LD_EXP 104
33173: PUSH
33174: LD_VAR 0 2
33178: ARRAY
33179: IFFALSE 33561
// begin for j = mc_miners [ i ] downto 1 do
33181: LD_ADDR_VAR 0 3
33185: PUSH
33186: DOUBLE
33187: LD_EXP 104
33191: PUSH
33192: LD_VAR 0 2
33196: ARRAY
33197: INC
33198: ST_TO_ADDR
33199: LD_INT 1
33201: PUSH
33202: FOR_DOWNTO
33203: IFFALSE 33559
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33205: LD_EXP 104
33209: PUSH
33210: LD_VAR 0 2
33214: ARRAY
33215: PUSH
33216: LD_VAR 0 3
33220: ARRAY
33221: PPUSH
33222: CALL_OW 301
33226: PUSH
33227: LD_EXP 104
33231: PUSH
33232: LD_VAR 0 2
33236: ARRAY
33237: PUSH
33238: LD_VAR 0 3
33242: ARRAY
33243: PPUSH
33244: CALL_OW 257
33248: PUSH
33249: LD_INT 1
33251: NONEQUAL
33252: OR
33253: IFFALSE 33316
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33255: LD_ADDR_VAR 0 5
33259: PUSH
33260: LD_EXP 104
33264: PUSH
33265: LD_VAR 0 2
33269: ARRAY
33270: PUSH
33271: LD_EXP 104
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PUSH
33282: LD_VAR 0 3
33286: ARRAY
33287: DIFF
33288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33289: LD_ADDR_EXP 104
33293: PUSH
33294: LD_EXP 104
33298: PPUSH
33299: LD_VAR 0 2
33303: PPUSH
33304: LD_VAR 0 5
33308: PPUSH
33309: CALL_OW 1
33313: ST_TO_ADDR
// continue ;
33314: GO 33202
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33316: LD_EXP 104
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: PUSH
33327: LD_VAR 0 3
33331: ARRAY
33332: PPUSH
33333: CALL_OW 257
33337: PUSH
33338: LD_INT 1
33340: EQUAL
33341: PUSH
33342: LD_EXP 104
33346: PUSH
33347: LD_VAR 0 2
33351: ARRAY
33352: PUSH
33353: LD_VAR 0 3
33357: ARRAY
33358: PPUSH
33359: CALL_OW 459
33363: NOT
33364: AND
33365: PUSH
33366: LD_EXP 104
33370: PUSH
33371: LD_VAR 0 2
33375: ARRAY
33376: PUSH
33377: LD_VAR 0 3
33381: ARRAY
33382: PPUSH
33383: CALL_OW 314
33387: NOT
33388: AND
33389: IFFALSE 33557
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33391: LD_EXP 104
33395: PUSH
33396: LD_VAR 0 2
33400: ARRAY
33401: PUSH
33402: LD_VAR 0 3
33406: ARRAY
33407: PPUSH
33408: CALL_OW 310
33412: IFFALSE 33435
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33414: LD_EXP 104
33418: PUSH
33419: LD_VAR 0 2
33423: ARRAY
33424: PUSH
33425: LD_VAR 0 3
33429: ARRAY
33430: PPUSH
33431: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33435: LD_EXP 104
33439: PUSH
33440: LD_VAR 0 2
33444: ARRAY
33445: PUSH
33446: LD_VAR 0 3
33450: ARRAY
33451: PPUSH
33452: CALL_OW 314
33456: NOT
33457: IFFALSE 33557
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33459: LD_EXP 104
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: PUSH
33470: LD_VAR 0 3
33474: ARRAY
33475: PPUSH
33476: LD_EXP 103
33480: PUSH
33481: LD_VAR 0 2
33485: ARRAY
33486: PUSH
33487: LD_VAR 0 3
33491: PUSH
33492: LD_EXP 103
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: MOD
33503: PUSH
33504: LD_INT 1
33506: PLUS
33507: ARRAY
33508: PUSH
33509: LD_INT 1
33511: ARRAY
33512: PPUSH
33513: LD_EXP 103
33517: PUSH
33518: LD_VAR 0 2
33522: ARRAY
33523: PUSH
33524: LD_VAR 0 3
33528: PUSH
33529: LD_EXP 103
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: MOD
33540: PUSH
33541: LD_INT 1
33543: PLUS
33544: ARRAY
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PPUSH
33550: LD_INT 0
33552: PPUSH
33553: CALL_OW 193
// end ; end ;
33557: GO 33202
33559: POP
33560: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33561: LD_ADDR_VAR 0 5
33565: PUSH
33566: LD_EXP 90
33570: PUSH
33571: LD_VAR 0 2
33575: ARRAY
33576: PPUSH
33577: LD_INT 2
33579: PUSH
33580: LD_INT 30
33582: PUSH
33583: LD_INT 4
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 30
33592: PUSH
33593: LD_INT 5
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 30
33602: PUSH
33603: LD_INT 32
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 72
33620: ST_TO_ADDR
// if not tmp then
33621: LD_VAR 0 5
33625: NOT
33626: IFFALSE 33630
// continue ;
33628: GO 33115
// list := [ ] ;
33630: LD_ADDR_VAR 0 6
33634: PUSH
33635: EMPTY
33636: ST_TO_ADDR
// for j in tmp do
33637: LD_ADDR_VAR 0 3
33641: PUSH
33642: LD_VAR 0 5
33646: PUSH
33647: FOR_IN
33648: IFFALSE 33717
// begin for k in UnitsInside ( j ) do
33650: LD_ADDR_VAR 0 4
33654: PUSH
33655: LD_VAR 0 3
33659: PPUSH
33660: CALL_OW 313
33664: PUSH
33665: FOR_IN
33666: IFFALSE 33713
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33668: LD_VAR 0 4
33672: PPUSH
33673: CALL_OW 257
33677: PUSH
33678: LD_INT 1
33680: EQUAL
33681: PUSH
33682: LD_VAR 0 4
33686: PPUSH
33687: CALL_OW 459
33691: NOT
33692: AND
33693: IFFALSE 33711
// list := list ^ k ;
33695: LD_ADDR_VAR 0 6
33699: PUSH
33700: LD_VAR 0 6
33704: PUSH
33705: LD_VAR 0 4
33709: ADD
33710: ST_TO_ADDR
33711: GO 33665
33713: POP
33714: POP
// end ;
33715: GO 33647
33717: POP
33718: POP
// list := list diff mc_miners [ i ] ;
33719: LD_ADDR_VAR 0 6
33723: PUSH
33724: LD_VAR 0 6
33728: PUSH
33729: LD_EXP 104
33733: PUSH
33734: LD_VAR 0 2
33738: ARRAY
33739: DIFF
33740: ST_TO_ADDR
// if not list then
33741: LD_VAR 0 6
33745: NOT
33746: IFFALSE 33750
// continue ;
33748: GO 33115
// k := mc_mines [ i ] - mc_miners [ i ] ;
33750: LD_ADDR_VAR 0 4
33754: PUSH
33755: LD_EXP 103
33759: PUSH
33760: LD_VAR 0 2
33764: ARRAY
33765: PUSH
33766: LD_EXP 104
33770: PUSH
33771: LD_VAR 0 2
33775: ARRAY
33776: MINUS
33777: ST_TO_ADDR
// if k > list then
33778: LD_VAR 0 4
33782: PUSH
33783: LD_VAR 0 6
33787: GREATER
33788: IFFALSE 33800
// k := list ;
33790: LD_ADDR_VAR 0 4
33794: PUSH
33795: LD_VAR 0 6
33799: ST_TO_ADDR
// for j = 1 to k do
33800: LD_ADDR_VAR 0 3
33804: PUSH
33805: DOUBLE
33806: LD_INT 1
33808: DEC
33809: ST_TO_ADDR
33810: LD_VAR 0 4
33814: PUSH
33815: FOR_TO
33816: IFFALSE 33870
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33818: LD_ADDR_EXP 104
33822: PUSH
33823: LD_EXP 104
33827: PPUSH
33828: LD_VAR 0 2
33832: PUSH
33833: LD_EXP 104
33837: PUSH
33838: LD_VAR 0 2
33842: ARRAY
33843: PUSH
33844: LD_INT 1
33846: PLUS
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PPUSH
33852: LD_VAR 0 6
33856: PUSH
33857: LD_VAR 0 3
33861: ARRAY
33862: PPUSH
33863: CALL 55792 0 3
33867: ST_TO_ADDR
33868: GO 33815
33870: POP
33871: POP
// end ;
33872: GO 33115
33874: POP
33875: POP
// end ;
33876: LD_VAR 0 1
33880: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33881: LD_INT 0
33883: PPUSH
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
33888: PPUSH
33889: PPUSH
33890: PPUSH
33891: PPUSH
33892: PPUSH
// if not mc_bases then
33893: LD_EXP 90
33897: NOT
33898: IFFALSE 33902
// exit ;
33900: GO 35652
// for i = 1 to mc_bases do
33902: LD_ADDR_VAR 0 2
33906: PUSH
33907: DOUBLE
33908: LD_INT 1
33910: DEC
33911: ST_TO_ADDR
33912: LD_EXP 90
33916: PUSH
33917: FOR_TO
33918: IFFALSE 35650
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33920: LD_EXP 90
33924: PUSH
33925: LD_VAR 0 2
33929: ARRAY
33930: NOT
33931: PUSH
33932: LD_EXP 97
33936: PUSH
33937: LD_VAR 0 2
33941: ARRAY
33942: OR
33943: IFFALSE 33947
// continue ;
33945: GO 33917
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33947: LD_EXP 106
33951: PUSH
33952: LD_VAR 0 2
33956: ARRAY
33957: NOT
33958: PUSH
33959: LD_EXP 107
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: AND
33970: IFFALSE 34008
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33972: LD_ADDR_EXP 107
33976: PUSH
33977: LD_EXP 107
33981: PPUSH
33982: LD_VAR 0 2
33986: PPUSH
33987: EMPTY
33988: PPUSH
33989: CALL_OW 1
33993: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33994: LD_VAR 0 2
33998: PPUSH
33999: LD_INT 107
34001: PPUSH
34002: CALL 24856 0 2
// continue ;
34006: GO 33917
// end ; target := [ ] ;
34008: LD_ADDR_VAR 0 6
34012: PUSH
34013: EMPTY
34014: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34015: LD_ADDR_VAR 0 3
34019: PUSH
34020: DOUBLE
34021: LD_EXP 106
34025: PUSH
34026: LD_VAR 0 2
34030: ARRAY
34031: INC
34032: ST_TO_ADDR
34033: LD_INT 1
34035: PUSH
34036: FOR_DOWNTO
34037: IFFALSE 34297
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34039: LD_EXP 106
34043: PUSH
34044: LD_VAR 0 2
34048: ARRAY
34049: PUSH
34050: LD_VAR 0 3
34054: ARRAY
34055: PUSH
34056: LD_INT 2
34058: ARRAY
34059: PPUSH
34060: LD_EXP 106
34064: PUSH
34065: LD_VAR 0 2
34069: ARRAY
34070: PUSH
34071: LD_VAR 0 3
34075: ARRAY
34076: PUSH
34077: LD_INT 3
34079: ARRAY
34080: PPUSH
34081: CALL_OW 488
34085: PUSH
34086: LD_EXP 106
34090: PUSH
34091: LD_VAR 0 2
34095: ARRAY
34096: PUSH
34097: LD_VAR 0 3
34101: ARRAY
34102: PUSH
34103: LD_INT 2
34105: ARRAY
34106: PPUSH
34107: LD_EXP 106
34111: PUSH
34112: LD_VAR 0 2
34116: ARRAY
34117: PUSH
34118: LD_VAR 0 3
34122: ARRAY
34123: PUSH
34124: LD_INT 3
34126: ARRAY
34127: PPUSH
34128: CALL_OW 284
34132: PUSH
34133: LD_INT 0
34135: EQUAL
34136: AND
34137: IFFALSE 34192
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34139: LD_ADDR_VAR 0 5
34143: PUSH
34144: LD_EXP 106
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PPUSH
34155: LD_VAR 0 3
34159: PPUSH
34160: CALL_OW 3
34164: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34165: LD_ADDR_EXP 106
34169: PUSH
34170: LD_EXP 106
34174: PPUSH
34175: LD_VAR 0 2
34179: PPUSH
34180: LD_VAR 0 5
34184: PPUSH
34185: CALL_OW 1
34189: ST_TO_ADDR
// continue ;
34190: GO 34036
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34192: LD_EXP 90
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PUSH
34203: LD_INT 1
34205: ARRAY
34206: PPUSH
34207: CALL_OW 255
34211: PPUSH
34212: LD_EXP 106
34216: PUSH
34217: LD_VAR 0 2
34221: ARRAY
34222: PUSH
34223: LD_VAR 0 3
34227: ARRAY
34228: PUSH
34229: LD_INT 2
34231: ARRAY
34232: PPUSH
34233: LD_EXP 106
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PUSH
34244: LD_VAR 0 3
34248: ARRAY
34249: PUSH
34250: LD_INT 3
34252: ARRAY
34253: PPUSH
34254: LD_INT 30
34256: PPUSH
34257: CALL 56688 0 4
34261: PUSH
34262: LD_INT 4
34264: ARRAY
34265: PUSH
34266: LD_INT 0
34268: EQUAL
34269: IFFALSE 34295
// begin target := mc_crates [ i ] [ j ] ;
34271: LD_ADDR_VAR 0 6
34275: PUSH
34276: LD_EXP 106
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_VAR 0 3
34291: ARRAY
34292: ST_TO_ADDR
// break ;
34293: GO 34297
// end ; end ;
34295: GO 34036
34297: POP
34298: POP
// if not target then
34299: LD_VAR 0 6
34303: NOT
34304: IFFALSE 34308
// continue ;
34306: GO 33917
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34308: LD_ADDR_VAR 0 7
34312: PUSH
34313: LD_EXP 109
34317: PUSH
34318: LD_VAR 0 2
34322: ARRAY
34323: PPUSH
34324: LD_INT 2
34326: PUSH
34327: LD_INT 3
34329: PUSH
34330: LD_INT 58
34332: PUSH
34333: EMPTY
34334: LIST
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 61
34342: PUSH
34343: EMPTY
34344: LIST
34345: PUSH
34346: LD_INT 33
34348: PUSH
34349: LD_INT 5
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 33
34358: PUSH
34359: LD_INT 3
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 2
34375: PUSH
34376: LD_INT 34
34378: PUSH
34379: LD_INT 32
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 34
34388: PUSH
34389: LD_INT 51
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 34
34398: PUSH
34399: LD_INT 12
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PPUSH
34416: CALL_OW 72
34420: ST_TO_ADDR
// if not cargo then
34421: LD_VAR 0 7
34425: NOT
34426: IFFALSE 35069
// begin if mc_crates_collector [ i ] < 5 then
34428: LD_EXP 107
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PUSH
34439: LD_INT 5
34441: LESS
34442: IFFALSE 34808
// begin if mc_ape [ i ] then
34444: LD_EXP 119
34448: PUSH
34449: LD_VAR 0 2
34453: ARRAY
34454: IFFALSE 34501
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34456: LD_ADDR_VAR 0 5
34460: PUSH
34461: LD_EXP 119
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PPUSH
34472: LD_INT 25
34474: PUSH
34475: LD_INT 16
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 24
34484: PUSH
34485: LD_INT 750
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PPUSH
34496: CALL_OW 72
34500: ST_TO_ADDR
// if not tmp then
34501: LD_VAR 0 5
34505: NOT
34506: IFFALSE 34553
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34508: LD_ADDR_VAR 0 5
34512: PUSH
34513: LD_EXP 90
34517: PUSH
34518: LD_VAR 0 2
34522: ARRAY
34523: PPUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 2
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 24
34536: PUSH
34537: LD_INT 750
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34553: LD_EXP 119
34557: PUSH
34558: LD_VAR 0 2
34562: ARRAY
34563: PUSH
34564: LD_EXP 90
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: PPUSH
34575: LD_INT 25
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 24
34587: PUSH
34588: LD_INT 750
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PPUSH
34599: CALL_OW 72
34603: AND
34604: PUSH
34605: LD_VAR 0 5
34609: PUSH
34610: LD_INT 5
34612: LESS
34613: AND
34614: IFFALSE 34696
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34616: LD_ADDR_VAR 0 3
34620: PUSH
34621: LD_EXP 90
34625: PUSH
34626: LD_VAR 0 2
34630: ARRAY
34631: PPUSH
34632: LD_INT 25
34634: PUSH
34635: LD_INT 2
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 24
34644: PUSH
34645: LD_INT 750
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PPUSH
34656: CALL_OW 72
34660: PUSH
34661: FOR_IN
34662: IFFALSE 34694
// begin tmp := tmp union j ;
34664: LD_ADDR_VAR 0 5
34668: PUSH
34669: LD_VAR 0 5
34673: PUSH
34674: LD_VAR 0 3
34678: UNION
34679: ST_TO_ADDR
// if tmp >= 5 then
34680: LD_VAR 0 5
34684: PUSH
34685: LD_INT 5
34687: GREATEREQUAL
34688: IFFALSE 34692
// break ;
34690: GO 34694
// end ;
34692: GO 34661
34694: POP
34695: POP
// end ; if not tmp then
34696: LD_VAR 0 5
34700: NOT
34701: IFFALSE 34705
// continue ;
34703: GO 33917
// for j in tmp do
34705: LD_ADDR_VAR 0 3
34709: PUSH
34710: LD_VAR 0 5
34714: PUSH
34715: FOR_IN
34716: IFFALSE 34806
// if not GetTag ( j ) then
34718: LD_VAR 0 3
34722: PPUSH
34723: CALL_OW 110
34727: NOT
34728: IFFALSE 34804
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34730: LD_ADDR_EXP 107
34734: PUSH
34735: LD_EXP 107
34739: PPUSH
34740: LD_VAR 0 2
34744: PUSH
34745: LD_EXP 107
34749: PUSH
34750: LD_VAR 0 2
34754: ARRAY
34755: PUSH
34756: LD_INT 1
34758: PLUS
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PPUSH
34764: LD_VAR 0 3
34768: PPUSH
34769: CALL 55792 0 3
34773: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 107
34781: PPUSH
34782: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34786: LD_EXP 107
34790: PUSH
34791: LD_VAR 0 2
34795: ARRAY
34796: PUSH
34797: LD_INT 5
34799: GREATEREQUAL
34800: IFFALSE 34804
// break ;
34802: GO 34806
// end ;
34804: GO 34715
34806: POP
34807: POP
// end ; if mc_crates_collector [ i ] and target then
34808: LD_EXP 107
34812: PUSH
34813: LD_VAR 0 2
34817: ARRAY
34818: PUSH
34819: LD_VAR 0 6
34823: AND
34824: IFFALSE 35067
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34826: LD_EXP 107
34830: PUSH
34831: LD_VAR 0 2
34835: ARRAY
34836: PUSH
34837: LD_VAR 0 6
34841: PUSH
34842: LD_INT 1
34844: ARRAY
34845: LESS
34846: IFFALSE 34866
// tmp := mc_crates_collector [ i ] else
34848: LD_ADDR_VAR 0 5
34852: PUSH
34853: LD_EXP 107
34857: PUSH
34858: LD_VAR 0 2
34862: ARRAY
34863: ST_TO_ADDR
34864: GO 34880
// tmp := target [ 1 ] ;
34866: LD_ADDR_VAR 0 5
34870: PUSH
34871: LD_VAR 0 6
34875: PUSH
34876: LD_INT 1
34878: ARRAY
34879: ST_TO_ADDR
// k := 0 ;
34880: LD_ADDR_VAR 0 4
34884: PUSH
34885: LD_INT 0
34887: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34888: LD_ADDR_VAR 0 3
34892: PUSH
34893: LD_EXP 107
34897: PUSH
34898: LD_VAR 0 2
34902: ARRAY
34903: PUSH
34904: FOR_IN
34905: IFFALSE 35065
// begin k := k + 1 ;
34907: LD_ADDR_VAR 0 4
34911: PUSH
34912: LD_VAR 0 4
34916: PUSH
34917: LD_INT 1
34919: PLUS
34920: ST_TO_ADDR
// if k > tmp then
34921: LD_VAR 0 4
34925: PUSH
34926: LD_VAR 0 5
34930: GREATER
34931: IFFALSE 34935
// break ;
34933: GO 35065
// if not GetClass ( j ) in [ 2 , 16 ] then
34935: LD_VAR 0 3
34939: PPUSH
34940: CALL_OW 257
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 16
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: IN
34955: NOT
34956: IFFALSE 35009
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34958: LD_ADDR_EXP 107
34962: PUSH
34963: LD_EXP 107
34967: PPUSH
34968: LD_VAR 0 2
34972: PPUSH
34973: LD_EXP 107
34977: PUSH
34978: LD_VAR 0 2
34982: ARRAY
34983: PUSH
34984: LD_VAR 0 3
34988: DIFF
34989: PPUSH
34990: CALL_OW 1
34994: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34995: LD_VAR 0 3
34999: PPUSH
35000: LD_INT 0
35002: PPUSH
35003: CALL_OW 109
// continue ;
35007: GO 34904
// end ; if IsInUnit ( j ) then
35009: LD_VAR 0 3
35013: PPUSH
35014: CALL_OW 310
35018: IFFALSE 35029
// ComExitBuilding ( j ) ;
35020: LD_VAR 0 3
35024: PPUSH
35025: CALL_OW 122
// wait ( 3 ) ;
35029: LD_INT 3
35031: PPUSH
35032: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35036: LD_VAR 0 3
35040: PPUSH
35041: LD_VAR 0 6
35045: PUSH
35046: LD_INT 2
35048: ARRAY
35049: PPUSH
35050: LD_VAR 0 6
35054: PUSH
35055: LD_INT 3
35057: ARRAY
35058: PPUSH
35059: CALL_OW 117
// end ;
35063: GO 34904
35065: POP
35066: POP
// end ; end else
35067: GO 35648
// begin for j in cargo do
35069: LD_ADDR_VAR 0 3
35073: PUSH
35074: LD_VAR 0 7
35078: PUSH
35079: FOR_IN
35080: IFFALSE 35646
// begin if GetTag ( j ) <> 0 then
35082: LD_VAR 0 3
35086: PPUSH
35087: CALL_OW 110
35091: PUSH
35092: LD_INT 0
35094: NONEQUAL
35095: IFFALSE 35099
// continue ;
35097: GO 35079
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35099: LD_VAR 0 3
35103: PPUSH
35104: CALL_OW 256
35108: PUSH
35109: LD_INT 1000
35111: LESS
35112: PUSH
35113: LD_VAR 0 3
35117: PPUSH
35118: LD_EXP 114
35122: PUSH
35123: LD_VAR 0 2
35127: ARRAY
35128: PPUSH
35129: CALL_OW 308
35133: NOT
35134: AND
35135: IFFALSE 35157
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35137: LD_VAR 0 3
35141: PPUSH
35142: LD_EXP 114
35146: PUSH
35147: LD_VAR 0 2
35151: ARRAY
35152: PPUSH
35153: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35157: LD_VAR 0 3
35161: PPUSH
35162: CALL_OW 256
35166: PUSH
35167: LD_INT 1000
35169: LESS
35170: PUSH
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_EXP 114
35180: PUSH
35181: LD_VAR 0 2
35185: ARRAY
35186: PPUSH
35187: CALL_OW 308
35191: AND
35192: IFFALSE 35196
// continue ;
35194: GO 35079
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35196: LD_VAR 0 3
35200: PPUSH
35201: CALL_OW 262
35205: PUSH
35206: LD_INT 2
35208: EQUAL
35209: PUSH
35210: LD_VAR 0 3
35214: PPUSH
35215: CALL_OW 261
35219: PUSH
35220: LD_INT 15
35222: LESS
35223: AND
35224: IFFALSE 35228
// continue ;
35226: GO 35079
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35228: LD_VAR 0 3
35232: PPUSH
35233: CALL_OW 262
35237: PUSH
35238: LD_INT 1
35240: EQUAL
35241: PUSH
35242: LD_VAR 0 3
35246: PPUSH
35247: CALL_OW 261
35251: PUSH
35252: LD_INT 10
35254: LESS
35255: AND
35256: IFFALSE 35585
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35258: LD_ADDR_VAR 0 8
35262: PUSH
35263: LD_EXP 90
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PPUSH
35274: LD_INT 2
35276: PUSH
35277: LD_INT 30
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 30
35289: PUSH
35290: LD_INT 1
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: LIST
35301: PPUSH
35302: CALL_OW 72
35306: ST_TO_ADDR
// if not depot then
35307: LD_VAR 0 8
35311: NOT
35312: IFFALSE 35316
// continue ;
35314: GO 35079
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35316: LD_VAR 0 3
35320: PPUSH
35321: LD_VAR 0 8
35325: PPUSH
35326: LD_VAR 0 3
35330: PPUSH
35331: CALL_OW 74
35335: PPUSH
35336: CALL_OW 296
35340: PUSH
35341: LD_INT 6
35343: LESS
35344: IFFALSE 35360
// SetFuel ( j , 100 ) else
35346: LD_VAR 0 3
35350: PPUSH
35351: LD_INT 100
35353: PPUSH
35354: CALL_OW 240
35358: GO 35585
// if GetFuel ( j ) = 0 then
35360: LD_VAR 0 3
35364: PPUSH
35365: CALL_OW 261
35369: PUSH
35370: LD_INT 0
35372: EQUAL
35373: IFFALSE 35585
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35375: LD_ADDR_EXP 109
35379: PUSH
35380: LD_EXP 109
35384: PPUSH
35385: LD_VAR 0 2
35389: PPUSH
35390: LD_EXP 109
35394: PUSH
35395: LD_VAR 0 2
35399: ARRAY
35400: PUSH
35401: LD_VAR 0 3
35405: DIFF
35406: PPUSH
35407: CALL_OW 1
35411: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35412: LD_VAR 0 3
35416: PPUSH
35417: CALL_OW 263
35421: PUSH
35422: LD_INT 1
35424: EQUAL
35425: IFFALSE 35441
// ComExitVehicle ( IsInUnit ( j ) ) ;
35427: LD_VAR 0 3
35431: PPUSH
35432: CALL_OW 310
35436: PPUSH
35437: CALL_OW 121
// if GetControl ( j ) = control_remote then
35441: LD_VAR 0 3
35445: PPUSH
35446: CALL_OW 263
35450: PUSH
35451: LD_INT 2
35453: EQUAL
35454: IFFALSE 35465
// ComUnlink ( j ) ;
35456: LD_VAR 0 3
35460: PPUSH
35461: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35465: LD_ADDR_VAR 0 9
35469: PUSH
35470: LD_VAR 0 2
35474: PPUSH
35475: LD_INT 3
35477: PPUSH
35478: CALL 44938 0 2
35482: ST_TO_ADDR
// if fac then
35483: LD_VAR 0 9
35487: IFFALSE 35583
// begin for k in fac do
35489: LD_ADDR_VAR 0 4
35493: PUSH
35494: LD_VAR 0 9
35498: PUSH
35499: FOR_IN
35500: IFFALSE 35581
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35502: LD_ADDR_VAR 0 10
35506: PUSH
35507: LD_VAR 0 9
35511: PPUSH
35512: LD_VAR 0 3
35516: PPUSH
35517: CALL_OW 265
35521: PPUSH
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 262
35531: PPUSH
35532: LD_VAR 0 3
35536: PPUSH
35537: CALL_OW 263
35541: PPUSH
35542: LD_VAR 0 3
35546: PPUSH
35547: CALL_OW 264
35551: PPUSH
35552: CALL 53324 0 5
35556: ST_TO_ADDR
// if components then
35557: LD_VAR 0 10
35561: IFFALSE 35579
// begin MC_InsertProduceList ( i , components ) ;
35563: LD_VAR 0 2
35567: PPUSH
35568: LD_VAR 0 10
35572: PPUSH
35573: CALL 44483 0 2
// break ;
35577: GO 35581
// end ; end ;
35579: GO 35499
35581: POP
35582: POP
// end ; continue ;
35583: GO 35079
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35585: LD_VAR 0 3
35589: PPUSH
35590: LD_INT 1
35592: PPUSH
35593: CALL_OW 289
35597: PUSH
35598: LD_INT 100
35600: LESS
35601: PUSH
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 314
35611: NOT
35612: AND
35613: IFFALSE 35642
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35615: LD_VAR 0 3
35619: PPUSH
35620: LD_VAR 0 6
35624: PUSH
35625: LD_INT 2
35627: ARRAY
35628: PPUSH
35629: LD_VAR 0 6
35633: PUSH
35634: LD_INT 3
35636: ARRAY
35637: PPUSH
35638: CALL_OW 117
// break ;
35642: GO 35646
// end ;
35644: GO 35079
35646: POP
35647: POP
// end ; end ;
35648: GO 33917
35650: POP
35651: POP
// end ;
35652: LD_VAR 0 1
35656: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35657: LD_INT 0
35659: PPUSH
35660: PPUSH
35661: PPUSH
35662: PPUSH
// if not mc_bases then
35663: LD_EXP 90
35667: NOT
35668: IFFALSE 35672
// exit ;
35670: GO 35833
// for i = 1 to mc_bases do
35672: LD_ADDR_VAR 0 2
35676: PUSH
35677: DOUBLE
35678: LD_INT 1
35680: DEC
35681: ST_TO_ADDR
35682: LD_EXP 90
35686: PUSH
35687: FOR_TO
35688: IFFALSE 35831
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35690: LD_ADDR_VAR 0 4
35694: PUSH
35695: LD_EXP 109
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_EXP 112
35710: PUSH
35711: LD_VAR 0 2
35715: ARRAY
35716: UNION
35717: PPUSH
35718: LD_INT 33
35720: PUSH
35721: LD_INT 2
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PPUSH
35728: CALL_OW 72
35732: ST_TO_ADDR
// if tmp then
35733: LD_VAR 0 4
35737: IFFALSE 35829
// for j in tmp do
35739: LD_ADDR_VAR 0 3
35743: PUSH
35744: LD_VAR 0 4
35748: PUSH
35749: FOR_IN
35750: IFFALSE 35827
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35752: LD_VAR 0 3
35756: PPUSH
35757: CALL_OW 312
35761: NOT
35762: PUSH
35763: LD_VAR 0 3
35767: PPUSH
35768: CALL_OW 256
35772: PUSH
35773: LD_INT 250
35775: GREATEREQUAL
35776: AND
35777: IFFALSE 35790
// Connect ( j ) else
35779: LD_VAR 0 3
35783: PPUSH
35784: CALL 58725 0 1
35788: GO 35825
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35790: LD_VAR 0 3
35794: PPUSH
35795: CALL_OW 256
35799: PUSH
35800: LD_INT 250
35802: LESS
35803: PUSH
35804: LD_VAR 0 3
35808: PPUSH
35809: CALL_OW 312
35813: AND
35814: IFFALSE 35825
// ComUnlink ( j ) ;
35816: LD_VAR 0 3
35820: PPUSH
35821: CALL_OW 136
35825: GO 35749
35827: POP
35828: POP
// end ;
35829: GO 35687
35831: POP
35832: POP
// end ;
35833: LD_VAR 0 1
35837: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35838: LD_INT 0
35840: PPUSH
35841: PPUSH
35842: PPUSH
35843: PPUSH
35844: PPUSH
// if not mc_bases then
35845: LD_EXP 90
35849: NOT
35850: IFFALSE 35854
// exit ;
35852: GO 36299
// for i = 1 to mc_bases do
35854: LD_ADDR_VAR 0 2
35858: PUSH
35859: DOUBLE
35860: LD_INT 1
35862: DEC
35863: ST_TO_ADDR
35864: LD_EXP 90
35868: PUSH
35869: FOR_TO
35870: IFFALSE 36297
// begin if not mc_produce [ i ] then
35872: LD_EXP 111
35876: PUSH
35877: LD_VAR 0 2
35881: ARRAY
35882: NOT
35883: IFFALSE 35887
// continue ;
35885: GO 35869
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35887: LD_ADDR_VAR 0 5
35891: PUSH
35892: LD_EXP 90
35896: PUSH
35897: LD_VAR 0 2
35901: ARRAY
35902: PPUSH
35903: LD_INT 30
35905: PUSH
35906: LD_INT 3
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PPUSH
35913: CALL_OW 72
35917: ST_TO_ADDR
// if not fac then
35918: LD_VAR 0 5
35922: NOT
35923: IFFALSE 35927
// continue ;
35925: GO 35869
// for j in fac do
35927: LD_ADDR_VAR 0 3
35931: PUSH
35932: LD_VAR 0 5
35936: PUSH
35937: FOR_IN
35938: IFFALSE 36293
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35940: LD_VAR 0 3
35944: PPUSH
35945: CALL_OW 461
35949: PUSH
35950: LD_INT 2
35952: NONEQUAL
35953: PUSH
35954: LD_VAR 0 3
35958: PPUSH
35959: LD_INT 15
35961: PPUSH
35962: CALL 58385 0 2
35966: PUSH
35967: LD_INT 4
35969: ARRAY
35970: OR
35971: IFFALSE 35975
// continue ;
35973: GO 35937
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35975: LD_VAR 0 3
35979: PPUSH
35980: LD_EXP 111
35984: PUSH
35985: LD_VAR 0 2
35989: ARRAY
35990: PUSH
35991: LD_INT 1
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: LD_EXP 111
36003: PUSH
36004: LD_VAR 0 2
36008: ARRAY
36009: PUSH
36010: LD_INT 1
36012: ARRAY
36013: PUSH
36014: LD_INT 2
36016: ARRAY
36017: PPUSH
36018: LD_EXP 111
36022: PUSH
36023: LD_VAR 0 2
36027: ARRAY
36028: PUSH
36029: LD_INT 1
36031: ARRAY
36032: PUSH
36033: LD_INT 3
36035: ARRAY
36036: PPUSH
36037: LD_EXP 111
36041: PUSH
36042: LD_VAR 0 2
36046: ARRAY
36047: PUSH
36048: LD_INT 1
36050: ARRAY
36051: PUSH
36052: LD_INT 4
36054: ARRAY
36055: PPUSH
36056: CALL_OW 448
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: LD_EXP 111
36070: PUSH
36071: LD_VAR 0 2
36075: ARRAY
36076: PUSH
36077: LD_INT 1
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: PUSH
36085: LD_EXP 111
36089: PUSH
36090: LD_VAR 0 2
36094: ARRAY
36095: PUSH
36096: LD_INT 1
36098: ARRAY
36099: PUSH
36100: LD_INT 2
36102: ARRAY
36103: PUSH
36104: LD_EXP 111
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PUSH
36119: LD_INT 3
36121: ARRAY
36122: PUSH
36123: LD_EXP 111
36127: PUSH
36128: LD_VAR 0 2
36132: ARRAY
36133: PUSH
36134: LD_INT 1
36136: ARRAY
36137: PUSH
36138: LD_INT 4
36140: ARRAY
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: PPUSH
36148: CALL 62056 0 2
36152: AND
36153: IFFALSE 36291
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36155: LD_VAR 0 3
36159: PPUSH
36160: LD_EXP 111
36164: PUSH
36165: LD_VAR 0 2
36169: ARRAY
36170: PUSH
36171: LD_INT 1
36173: ARRAY
36174: PUSH
36175: LD_INT 1
36177: ARRAY
36178: PPUSH
36179: LD_EXP 111
36183: PUSH
36184: LD_VAR 0 2
36188: ARRAY
36189: PUSH
36190: LD_INT 1
36192: ARRAY
36193: PUSH
36194: LD_INT 2
36196: ARRAY
36197: PPUSH
36198: LD_EXP 111
36202: PUSH
36203: LD_VAR 0 2
36207: ARRAY
36208: PUSH
36209: LD_INT 1
36211: ARRAY
36212: PUSH
36213: LD_INT 3
36215: ARRAY
36216: PPUSH
36217: LD_EXP 111
36221: PUSH
36222: LD_VAR 0 2
36226: ARRAY
36227: PUSH
36228: LD_INT 1
36230: ARRAY
36231: PUSH
36232: LD_INT 4
36234: ARRAY
36235: PPUSH
36236: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36240: LD_ADDR_VAR 0 4
36244: PUSH
36245: LD_EXP 111
36249: PUSH
36250: LD_VAR 0 2
36254: ARRAY
36255: PPUSH
36256: LD_INT 1
36258: PPUSH
36259: CALL_OW 3
36263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36264: LD_ADDR_EXP 111
36268: PUSH
36269: LD_EXP 111
36273: PPUSH
36274: LD_VAR 0 2
36278: PPUSH
36279: LD_VAR 0 4
36283: PPUSH
36284: CALL_OW 1
36288: ST_TO_ADDR
// break ;
36289: GO 36293
// end ; end ;
36291: GO 35937
36293: POP
36294: POP
// end ;
36295: GO 35869
36297: POP
36298: POP
// end ;
36299: LD_VAR 0 1
36303: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36304: LD_INT 0
36306: PPUSH
36307: PPUSH
36308: PPUSH
// if not mc_bases then
36309: LD_EXP 90
36313: NOT
36314: IFFALSE 36318
// exit ;
36316: GO 36407
// for i = 1 to mc_bases do
36318: LD_ADDR_VAR 0 2
36322: PUSH
36323: DOUBLE
36324: LD_INT 1
36326: DEC
36327: ST_TO_ADDR
36328: LD_EXP 90
36332: PUSH
36333: FOR_TO
36334: IFFALSE 36405
// begin if mc_attack [ i ] then
36336: LD_EXP 110
36340: PUSH
36341: LD_VAR 0 2
36345: ARRAY
36346: IFFALSE 36403
// begin tmp := mc_attack [ i ] [ 1 ] ;
36348: LD_ADDR_VAR 0 3
36352: PUSH
36353: LD_EXP 110
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36368: LD_ADDR_EXP 110
36372: PUSH
36373: LD_EXP 110
36377: PPUSH
36378: LD_VAR 0 2
36382: PPUSH
36383: EMPTY
36384: PPUSH
36385: CALL_OW 1
36389: ST_TO_ADDR
// Attack ( tmp ) ;
36390: LD_VAR 0 3
36394: PPUSH
36395: CALL 105071 0 1
// exit ;
36399: POP
36400: POP
36401: GO 36407
// end ; end ;
36403: GO 36333
36405: POP
36406: POP
// end ;
36407: LD_VAR 0 1
36411: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36412: LD_INT 0
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
36420: PPUSH
// if not mc_bases then
36421: LD_EXP 90
36425: NOT
36426: IFFALSE 36430
// exit ;
36428: GO 37012
// for i = 1 to mc_bases do
36430: LD_ADDR_VAR 0 2
36434: PUSH
36435: DOUBLE
36436: LD_INT 1
36438: DEC
36439: ST_TO_ADDR
36440: LD_EXP 90
36444: PUSH
36445: FOR_TO
36446: IFFALSE 37010
// begin if not mc_bases [ i ] then
36448: LD_EXP 90
36452: PUSH
36453: LD_VAR 0 2
36457: ARRAY
36458: NOT
36459: IFFALSE 36463
// continue ;
36461: GO 36445
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36463: LD_ADDR_VAR 0 7
36467: PUSH
36468: LD_EXP 90
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: PUSH
36479: LD_INT 1
36481: ARRAY
36482: PPUSH
36483: CALL 52628 0 1
36487: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36488: LD_ADDR_EXP 113
36492: PUSH
36493: LD_EXP 113
36497: PPUSH
36498: LD_VAR 0 2
36502: PPUSH
36503: LD_EXP 90
36507: PUSH
36508: LD_VAR 0 2
36512: ARRAY
36513: PUSH
36514: LD_INT 1
36516: ARRAY
36517: PPUSH
36518: CALL_OW 255
36522: PPUSH
36523: LD_EXP 115
36527: PUSH
36528: LD_VAR 0 2
36532: ARRAY
36533: PPUSH
36534: CALL 52593 0 2
36538: PPUSH
36539: CALL_OW 1
36543: ST_TO_ADDR
// if not mc_scan [ i ] then
36544: LD_EXP 113
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: NOT
36555: IFFALSE 36710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36557: LD_ADDR_VAR 0 4
36561: PUSH
36562: LD_EXP 90
36566: PUSH
36567: LD_VAR 0 2
36571: ARRAY
36572: PPUSH
36573: LD_INT 2
36575: PUSH
36576: LD_INT 25
36578: PUSH
36579: LD_INT 5
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 25
36588: PUSH
36589: LD_INT 8
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 25
36598: PUSH
36599: LD_INT 9
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: PPUSH
36612: CALL_OW 72
36616: ST_TO_ADDR
// if not tmp then
36617: LD_VAR 0 4
36621: NOT
36622: IFFALSE 36626
// continue ;
36624: GO 36445
// for j in tmp do
36626: LD_ADDR_VAR 0 3
36630: PUSH
36631: LD_VAR 0 4
36635: PUSH
36636: FOR_IN
36637: IFFALSE 36708
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36639: LD_VAR 0 3
36643: PPUSH
36644: CALL_OW 310
36648: PPUSH
36649: CALL_OW 266
36653: PUSH
36654: LD_INT 5
36656: EQUAL
36657: PUSH
36658: LD_VAR 0 3
36662: PPUSH
36663: CALL_OW 257
36667: PUSH
36668: LD_INT 1
36670: EQUAL
36671: AND
36672: PUSH
36673: LD_VAR 0 3
36677: PPUSH
36678: CALL_OW 459
36682: NOT
36683: AND
36684: PUSH
36685: LD_VAR 0 7
36689: AND
36690: IFFALSE 36706
// ComChangeProfession ( j , class ) ;
36692: LD_VAR 0 3
36696: PPUSH
36697: LD_VAR 0 7
36701: PPUSH
36702: CALL_OW 123
36706: GO 36636
36708: POP
36709: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36710: LD_EXP 113
36714: PUSH
36715: LD_VAR 0 2
36719: ARRAY
36720: PUSH
36721: LD_EXP 112
36725: PUSH
36726: LD_VAR 0 2
36730: ARRAY
36731: NOT
36732: AND
36733: PUSH
36734: LD_EXP 90
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: PPUSH
36745: LD_INT 30
36747: PUSH
36748: LD_INT 32
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PPUSH
36755: CALL_OW 72
36759: NOT
36760: AND
36761: PUSH
36762: LD_EXP 90
36766: PUSH
36767: LD_VAR 0 2
36771: ARRAY
36772: PPUSH
36773: LD_INT 2
36775: PUSH
36776: LD_INT 30
36778: PUSH
36779: LD_INT 4
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 30
36788: PUSH
36789: LD_INT 5
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: PPUSH
36801: CALL_OW 72
36805: NOT
36806: AND
36807: IFFALSE 36939
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36809: LD_ADDR_VAR 0 4
36813: PUSH
36814: LD_EXP 90
36818: PUSH
36819: LD_VAR 0 2
36823: ARRAY
36824: PPUSH
36825: LD_INT 2
36827: PUSH
36828: LD_INT 25
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 25
36840: PUSH
36841: LD_INT 5
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 25
36850: PUSH
36851: LD_INT 8
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 25
36860: PUSH
36861: LD_INT 9
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: PPUSH
36875: CALL_OW 72
36879: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36880: LD_ADDR_VAR 0 4
36884: PUSH
36885: LD_VAR 0 4
36889: PUSH
36890: LD_VAR 0 4
36894: PPUSH
36895: LD_INT 18
36897: PPUSH
36898: CALL 84353 0 2
36902: DIFF
36903: ST_TO_ADDR
// if tmp then
36904: LD_VAR 0 4
36908: IFFALSE 36939
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36910: LD_VAR 0 2
36914: PPUSH
36915: LD_VAR 0 4
36919: PPUSH
36920: LD_EXP 115
36924: PUSH
36925: LD_VAR 0 2
36929: ARRAY
36930: PPUSH
36931: CALL 109780 0 3
// exit ;
36935: POP
36936: POP
36937: GO 37012
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36939: LD_EXP 113
36943: PUSH
36944: LD_VAR 0 2
36948: ARRAY
36949: PUSH
36950: LD_EXP 112
36954: PUSH
36955: LD_VAR 0 2
36959: ARRAY
36960: AND
36961: IFFALSE 37008
// begin tmp := mc_defender [ i ] ;
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_EXP 112
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36979: LD_VAR 0 2
36983: PPUSH
36984: LD_VAR 0 4
36988: PPUSH
36989: LD_EXP 113
36993: PUSH
36994: LD_VAR 0 2
36998: ARRAY
36999: PPUSH
37000: CALL 110341 0 3
// exit ;
37004: POP
37005: POP
37006: GO 37012
// end ; end ;
37008: GO 36445
37010: POP
37011: POP
// end ;
37012: LD_VAR 0 1
37016: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37017: LD_INT 0
37019: PPUSH
37020: PPUSH
37021: PPUSH
37022: PPUSH
37023: PPUSH
37024: PPUSH
37025: PPUSH
37026: PPUSH
37027: PPUSH
37028: PPUSH
37029: PPUSH
// if not mc_bases then
37030: LD_EXP 90
37034: NOT
37035: IFFALSE 37039
// exit ;
37037: GO 38126
// for i = 1 to mc_bases do
37039: LD_ADDR_VAR 0 2
37043: PUSH
37044: DOUBLE
37045: LD_INT 1
37047: DEC
37048: ST_TO_ADDR
37049: LD_EXP 90
37053: PUSH
37054: FOR_TO
37055: IFFALSE 38124
// begin tmp := mc_lab [ i ] ;
37057: LD_ADDR_VAR 0 6
37061: PUSH
37062: LD_EXP 123
37066: PUSH
37067: LD_VAR 0 2
37071: ARRAY
37072: ST_TO_ADDR
// if not tmp then
37073: LD_VAR 0 6
37077: NOT
37078: IFFALSE 37082
// continue ;
37080: GO 37054
// idle_lab := 0 ;
37082: LD_ADDR_VAR 0 11
37086: PUSH
37087: LD_INT 0
37089: ST_TO_ADDR
// for j in tmp do
37090: LD_ADDR_VAR 0 3
37094: PUSH
37095: LD_VAR 0 6
37099: PUSH
37100: FOR_IN
37101: IFFALSE 38120
// begin researching := false ;
37103: LD_ADDR_VAR 0 10
37107: PUSH
37108: LD_INT 0
37110: ST_TO_ADDR
// side := GetSide ( j ) ;
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 255
37125: ST_TO_ADDR
// if not mc_tech [ side ] then
37126: LD_EXP 117
37130: PUSH
37131: LD_VAR 0 4
37135: ARRAY
37136: NOT
37137: IFFALSE 37141
// continue ;
37139: GO 37100
// if BuildingStatus ( j ) = bs_idle then
37141: LD_VAR 0 3
37145: PPUSH
37146: CALL_OW 461
37150: PUSH
37151: LD_INT 2
37153: EQUAL
37154: IFFALSE 37342
// begin if idle_lab and UnitsInside ( j ) < 6 then
37156: LD_VAR 0 11
37160: PUSH
37161: LD_VAR 0 3
37165: PPUSH
37166: CALL_OW 313
37170: PUSH
37171: LD_INT 6
37173: LESS
37174: AND
37175: IFFALSE 37246
// begin tmp2 := UnitsInside ( idle_lab ) ;
37177: LD_ADDR_VAR 0 9
37181: PUSH
37182: LD_VAR 0 11
37186: PPUSH
37187: CALL_OW 313
37191: ST_TO_ADDR
// if tmp2 then
37192: LD_VAR 0 9
37196: IFFALSE 37238
// for x in tmp2 do
37198: LD_ADDR_VAR 0 7
37202: PUSH
37203: LD_VAR 0 9
37207: PUSH
37208: FOR_IN
37209: IFFALSE 37236
// begin ComExitBuilding ( x ) ;
37211: LD_VAR 0 7
37215: PPUSH
37216: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37220: LD_VAR 0 7
37224: PPUSH
37225: LD_VAR 0 3
37229: PPUSH
37230: CALL_OW 180
// end ;
37234: GO 37208
37236: POP
37237: POP
// idle_lab := 0 ;
37238: LD_ADDR_VAR 0 11
37242: PUSH
37243: LD_INT 0
37245: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37246: LD_ADDR_VAR 0 5
37250: PUSH
37251: LD_EXP 117
37255: PUSH
37256: LD_VAR 0 4
37260: ARRAY
37261: PUSH
37262: FOR_IN
37263: IFFALSE 37323
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37265: LD_VAR 0 3
37269: PPUSH
37270: LD_VAR 0 5
37274: PPUSH
37275: CALL_OW 430
37279: PUSH
37280: LD_VAR 0 4
37284: PPUSH
37285: LD_VAR 0 5
37289: PPUSH
37290: CALL 51698 0 2
37294: AND
37295: IFFALSE 37321
// begin researching := true ;
37297: LD_ADDR_VAR 0 10
37301: PUSH
37302: LD_INT 1
37304: ST_TO_ADDR
// ComResearch ( j , t ) ;
37305: LD_VAR 0 3
37309: PPUSH
37310: LD_VAR 0 5
37314: PPUSH
37315: CALL_OW 124
// break ;
37319: GO 37323
// end ;
37321: GO 37262
37323: POP
37324: POP
// if not researching then
37325: LD_VAR 0 10
37329: NOT
37330: IFFALSE 37342
// idle_lab := j ;
37332: LD_ADDR_VAR 0 11
37336: PUSH
37337: LD_VAR 0 3
37341: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37342: LD_VAR 0 3
37346: PPUSH
37347: CALL_OW 461
37351: PUSH
37352: LD_INT 10
37354: EQUAL
37355: IFFALSE 37943
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37357: LD_EXP 119
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: NOT
37368: PUSH
37369: LD_EXP 120
37373: PUSH
37374: LD_VAR 0 2
37378: ARRAY
37379: NOT
37380: AND
37381: PUSH
37382: LD_EXP 117
37386: PUSH
37387: LD_VAR 0 4
37391: ARRAY
37392: PUSH
37393: LD_INT 1
37395: GREATER
37396: AND
37397: IFFALSE 37528
// begin ComCancel ( j ) ;
37399: LD_VAR 0 3
37403: PPUSH
37404: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37408: LD_ADDR_EXP 117
37412: PUSH
37413: LD_EXP 117
37417: PPUSH
37418: LD_VAR 0 4
37422: PPUSH
37423: LD_EXP 117
37427: PUSH
37428: LD_VAR 0 4
37432: ARRAY
37433: PPUSH
37434: LD_EXP 117
37438: PUSH
37439: LD_VAR 0 4
37443: ARRAY
37444: PUSH
37445: LD_INT 1
37447: MINUS
37448: PPUSH
37449: LD_EXP 117
37453: PUSH
37454: LD_VAR 0 4
37458: ARRAY
37459: PPUSH
37460: LD_INT 0
37462: PPUSH
37463: CALL 55210 0 4
37467: PPUSH
37468: CALL_OW 1
37472: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37473: LD_ADDR_EXP 117
37477: PUSH
37478: LD_EXP 117
37482: PPUSH
37483: LD_VAR 0 4
37487: PPUSH
37488: LD_EXP 117
37492: PUSH
37493: LD_VAR 0 4
37497: ARRAY
37498: PPUSH
37499: LD_EXP 117
37503: PUSH
37504: LD_VAR 0 4
37508: ARRAY
37509: PPUSH
37510: LD_INT 1
37512: PPUSH
37513: LD_INT 0
37515: PPUSH
37516: CALL 55210 0 4
37520: PPUSH
37521: CALL_OW 1
37525: ST_TO_ADDR
// continue ;
37526: GO 37100
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37528: LD_EXP 119
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: PUSH
37539: LD_EXP 120
37543: PUSH
37544: LD_VAR 0 2
37548: ARRAY
37549: NOT
37550: AND
37551: IFFALSE 37678
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37553: LD_ADDR_EXP 120
37557: PUSH
37558: LD_EXP 120
37562: PPUSH
37563: LD_VAR 0 2
37567: PUSH
37568: LD_EXP 120
37572: PUSH
37573: LD_VAR 0 2
37577: ARRAY
37578: PUSH
37579: LD_INT 1
37581: PLUS
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PPUSH
37587: LD_EXP 119
37591: PUSH
37592: LD_VAR 0 2
37596: ARRAY
37597: PUSH
37598: LD_INT 1
37600: ARRAY
37601: PPUSH
37602: CALL 55792 0 3
37606: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37607: LD_EXP 119
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: PUSH
37618: LD_INT 1
37620: ARRAY
37621: PPUSH
37622: LD_INT 112
37624: PPUSH
37625: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37629: LD_ADDR_VAR 0 9
37633: PUSH
37634: LD_EXP 119
37638: PUSH
37639: LD_VAR 0 2
37643: ARRAY
37644: PPUSH
37645: LD_INT 1
37647: PPUSH
37648: CALL_OW 3
37652: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37653: LD_ADDR_EXP 119
37657: PUSH
37658: LD_EXP 119
37662: PPUSH
37663: LD_VAR 0 2
37667: PPUSH
37668: LD_VAR 0 9
37672: PPUSH
37673: CALL_OW 1
37677: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37678: LD_EXP 119
37682: PUSH
37683: LD_VAR 0 2
37687: ARRAY
37688: PUSH
37689: LD_EXP 120
37693: PUSH
37694: LD_VAR 0 2
37698: ARRAY
37699: AND
37700: PUSH
37701: LD_EXP 120
37705: PUSH
37706: LD_VAR 0 2
37710: ARRAY
37711: PUSH
37712: LD_INT 1
37714: ARRAY
37715: PPUSH
37716: CALL_OW 310
37720: NOT
37721: AND
37722: PUSH
37723: LD_VAR 0 3
37727: PPUSH
37728: CALL_OW 313
37732: PUSH
37733: LD_INT 6
37735: EQUAL
37736: AND
37737: IFFALSE 37793
// begin tmp2 := UnitsInside ( j ) ;
37739: LD_ADDR_VAR 0 9
37743: PUSH
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL_OW 313
37753: ST_TO_ADDR
// if tmp2 = 6 then
37754: LD_VAR 0 9
37758: PUSH
37759: LD_INT 6
37761: EQUAL
37762: IFFALSE 37793
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37764: LD_VAR 0 9
37768: PUSH
37769: LD_INT 1
37771: ARRAY
37772: PPUSH
37773: LD_INT 112
37775: PPUSH
37776: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37780: LD_VAR 0 9
37784: PUSH
37785: LD_INT 1
37787: ARRAY
37788: PPUSH
37789: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37793: LD_EXP 120
37797: PUSH
37798: LD_VAR 0 2
37802: ARRAY
37803: PUSH
37804: LD_EXP 120
37808: PUSH
37809: LD_VAR 0 2
37813: ARRAY
37814: PUSH
37815: LD_INT 1
37817: ARRAY
37818: PPUSH
37819: CALL_OW 314
37823: NOT
37824: AND
37825: PUSH
37826: LD_EXP 120
37830: PUSH
37831: LD_VAR 0 2
37835: ARRAY
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: PPUSH
37841: CALL_OW 310
37845: NOT
37846: AND
37847: IFFALSE 37873
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37849: LD_EXP 120
37853: PUSH
37854: LD_VAR 0 2
37858: ARRAY
37859: PUSH
37860: LD_INT 1
37862: ARRAY
37863: PPUSH
37864: LD_VAR 0 3
37868: PPUSH
37869: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37873: LD_EXP 120
37877: PUSH
37878: LD_VAR 0 2
37882: ARRAY
37883: PUSH
37884: LD_INT 1
37886: ARRAY
37887: PPUSH
37888: CALL_OW 310
37892: PUSH
37893: LD_EXP 120
37897: PUSH
37898: LD_VAR 0 2
37902: ARRAY
37903: PUSH
37904: LD_INT 1
37906: ARRAY
37907: PPUSH
37908: CALL_OW 310
37912: PPUSH
37913: CALL_OW 461
37917: PUSH
37918: LD_INT 3
37920: NONEQUAL
37921: AND
37922: IFFALSE 37943
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37924: LD_EXP 120
37928: PUSH
37929: LD_VAR 0 2
37933: ARRAY
37934: PUSH
37935: LD_INT 1
37937: ARRAY
37938: PPUSH
37939: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37943: LD_VAR 0 3
37947: PPUSH
37948: CALL_OW 461
37952: PUSH
37953: LD_INT 6
37955: EQUAL
37956: PUSH
37957: LD_VAR 0 6
37961: PUSH
37962: LD_INT 1
37964: GREATER
37965: AND
37966: IFFALSE 38118
// begin sci := [ ] ;
37968: LD_ADDR_VAR 0 8
37972: PUSH
37973: EMPTY
37974: ST_TO_ADDR
// for x in ( tmp diff j ) do
37975: LD_ADDR_VAR 0 7
37979: PUSH
37980: LD_VAR 0 6
37984: PUSH
37985: LD_VAR 0 3
37989: DIFF
37990: PUSH
37991: FOR_IN
37992: IFFALSE 38044
// begin if sci = 6 then
37994: LD_VAR 0 8
37998: PUSH
37999: LD_INT 6
38001: EQUAL
38002: IFFALSE 38006
// break ;
38004: GO 38044
// if BuildingStatus ( x ) = bs_idle then
38006: LD_VAR 0 7
38010: PPUSH
38011: CALL_OW 461
38015: PUSH
38016: LD_INT 2
38018: EQUAL
38019: IFFALSE 38042
// sci := sci ^ UnitsInside ( x ) ;
38021: LD_ADDR_VAR 0 8
38025: PUSH
38026: LD_VAR 0 8
38030: PUSH
38031: LD_VAR 0 7
38035: PPUSH
38036: CALL_OW 313
38040: ADD
38041: ST_TO_ADDR
// end ;
38042: GO 37991
38044: POP
38045: POP
// if not sci then
38046: LD_VAR 0 8
38050: NOT
38051: IFFALSE 38055
// continue ;
38053: GO 37100
// for x in sci do
38055: LD_ADDR_VAR 0 7
38059: PUSH
38060: LD_VAR 0 8
38064: PUSH
38065: FOR_IN
38066: IFFALSE 38116
// if IsInUnit ( x ) and not HasTask ( x ) then
38068: LD_VAR 0 7
38072: PPUSH
38073: CALL_OW 310
38077: PUSH
38078: LD_VAR 0 7
38082: PPUSH
38083: CALL_OW 314
38087: NOT
38088: AND
38089: IFFALSE 38114
// begin ComExitBuilding ( x ) ;
38091: LD_VAR 0 7
38095: PPUSH
38096: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38100: LD_VAR 0 7
38104: PPUSH
38105: LD_VAR 0 3
38109: PPUSH
38110: CALL_OW 180
// end ;
38114: GO 38065
38116: POP
38117: POP
// end ; end ;
38118: GO 37100
38120: POP
38121: POP
// end ;
38122: GO 37054
38124: POP
38125: POP
// end ;
38126: LD_VAR 0 1
38130: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38131: LD_INT 0
38133: PPUSH
38134: PPUSH
// if not mc_bases then
38135: LD_EXP 90
38139: NOT
38140: IFFALSE 38144
// exit ;
38142: GO 38225
// for i = 1 to mc_bases do
38144: LD_ADDR_VAR 0 2
38148: PUSH
38149: DOUBLE
38150: LD_INT 1
38152: DEC
38153: ST_TO_ADDR
38154: LD_EXP 90
38158: PUSH
38159: FOR_TO
38160: IFFALSE 38223
// if mc_mines [ i ] and mc_miners [ i ] then
38162: LD_EXP 103
38166: PUSH
38167: LD_VAR 0 2
38171: ARRAY
38172: PUSH
38173: LD_EXP 104
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: AND
38184: IFFALSE 38221
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38186: LD_EXP 104
38190: PUSH
38191: LD_VAR 0 2
38195: ARRAY
38196: PUSH
38197: LD_INT 1
38199: ARRAY
38200: PPUSH
38201: CALL_OW 255
38205: PPUSH
38206: LD_EXP 103
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: PPUSH
38217: CALL 52781 0 2
38221: GO 38159
38223: POP
38224: POP
// end ;
38225: LD_VAR 0 1
38229: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38230: LD_INT 0
38232: PPUSH
38233: PPUSH
38234: PPUSH
38235: PPUSH
38236: PPUSH
38237: PPUSH
38238: PPUSH
38239: PPUSH
// if not mc_bases or not mc_parking then
38240: LD_EXP 90
38244: NOT
38245: PUSH
38246: LD_EXP 114
38250: NOT
38251: OR
38252: IFFALSE 38256
// exit ;
38254: GO 38955
// for i = 1 to mc_bases do
38256: LD_ADDR_VAR 0 2
38260: PUSH
38261: DOUBLE
38262: LD_INT 1
38264: DEC
38265: ST_TO_ADDR
38266: LD_EXP 90
38270: PUSH
38271: FOR_TO
38272: IFFALSE 38953
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38274: LD_EXP 90
38278: PUSH
38279: LD_VAR 0 2
38283: ARRAY
38284: NOT
38285: PUSH
38286: LD_EXP 114
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: NOT
38297: OR
38298: IFFALSE 38302
// continue ;
38300: GO 38271
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38302: LD_ADDR_VAR 0 5
38306: PUSH
38307: LD_EXP 90
38311: PUSH
38312: LD_VAR 0 2
38316: ARRAY
38317: PUSH
38318: LD_INT 1
38320: ARRAY
38321: PPUSH
38322: CALL_OW 255
38326: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38327: LD_ADDR_VAR 0 6
38331: PUSH
38332: LD_EXP 90
38336: PUSH
38337: LD_VAR 0 2
38341: ARRAY
38342: PPUSH
38343: LD_INT 30
38345: PUSH
38346: LD_INT 3
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PPUSH
38353: CALL_OW 72
38357: ST_TO_ADDR
// if not fac then
38358: LD_VAR 0 6
38362: NOT
38363: IFFALSE 38414
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38365: LD_ADDR_VAR 0 6
38369: PUSH
38370: LD_EXP 90
38374: PUSH
38375: LD_VAR 0 2
38379: ARRAY
38380: PPUSH
38381: LD_INT 2
38383: PUSH
38384: LD_INT 30
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 30
38396: PUSH
38397: LD_INT 1
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: LIST
38408: PPUSH
38409: CALL_OW 72
38413: ST_TO_ADDR
// if not fac then
38414: LD_VAR 0 6
38418: NOT
38419: IFFALSE 38423
// continue ;
38421: GO 38271
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38423: LD_ADDR_VAR 0 7
38427: PUSH
38428: LD_EXP 114
38432: PUSH
38433: LD_VAR 0 2
38437: ARRAY
38438: PPUSH
38439: LD_INT 22
38441: PUSH
38442: LD_VAR 0 5
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 21
38453: PUSH
38454: LD_INT 2
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 3
38463: PUSH
38464: LD_INT 24
38466: PUSH
38467: LD_INT 1000
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: LIST
38482: PPUSH
38483: CALL_OW 70
38487: ST_TO_ADDR
// for j in fac do
38488: LD_ADDR_VAR 0 3
38492: PUSH
38493: LD_VAR 0 6
38497: PUSH
38498: FOR_IN
38499: IFFALSE 38580
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38501: LD_ADDR_VAR 0 7
38505: PUSH
38506: LD_VAR 0 7
38510: PUSH
38511: LD_INT 22
38513: PUSH
38514: LD_VAR 0 5
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 91
38525: PUSH
38526: LD_VAR 0 3
38530: PUSH
38531: LD_INT 15
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 21
38541: PUSH
38542: LD_INT 2
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 3
38551: PUSH
38552: LD_INT 24
38554: PUSH
38555: LD_INT 1000
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: PPUSH
38572: CALL_OW 69
38576: UNION
38577: ST_TO_ADDR
38578: GO 38498
38580: POP
38581: POP
// if not vehs then
38582: LD_VAR 0 7
38586: NOT
38587: IFFALSE 38613
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38589: LD_ADDR_EXP 102
38593: PUSH
38594: LD_EXP 102
38598: PPUSH
38599: LD_VAR 0 2
38603: PPUSH
38604: EMPTY
38605: PPUSH
38606: CALL_OW 1
38610: ST_TO_ADDR
// continue ;
38611: GO 38271
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38613: LD_ADDR_VAR 0 8
38617: PUSH
38618: LD_EXP 90
38622: PUSH
38623: LD_VAR 0 2
38627: ARRAY
38628: PPUSH
38629: LD_INT 30
38631: PUSH
38632: LD_INT 3
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PPUSH
38639: CALL_OW 72
38643: ST_TO_ADDR
// if tmp then
38644: LD_VAR 0 8
38648: IFFALSE 38751
// begin for j in tmp do
38650: LD_ADDR_VAR 0 3
38654: PUSH
38655: LD_VAR 0 8
38659: PUSH
38660: FOR_IN
38661: IFFALSE 38749
// for k in UnitsInside ( j ) do
38663: LD_ADDR_VAR 0 4
38667: PUSH
38668: LD_VAR 0 3
38672: PPUSH
38673: CALL_OW 313
38677: PUSH
38678: FOR_IN
38679: IFFALSE 38745
// if k then
38681: LD_VAR 0 4
38685: IFFALSE 38743
// if not k in mc_repair_vehicle [ i ] then
38687: LD_VAR 0 4
38691: PUSH
38692: LD_EXP 102
38696: PUSH
38697: LD_VAR 0 2
38701: ARRAY
38702: IN
38703: NOT
38704: IFFALSE 38743
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38706: LD_ADDR_EXP 102
38710: PUSH
38711: LD_EXP 102
38715: PPUSH
38716: LD_VAR 0 2
38720: PPUSH
38721: LD_EXP 102
38725: PUSH
38726: LD_VAR 0 2
38730: ARRAY
38731: PUSH
38732: LD_VAR 0 4
38736: UNION
38737: PPUSH
38738: CALL_OW 1
38742: ST_TO_ADDR
38743: GO 38678
38745: POP
38746: POP
38747: GO 38660
38749: POP
38750: POP
// end ; if not mc_repair_vehicle [ i ] then
38751: LD_EXP 102
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: NOT
38762: IFFALSE 38766
// continue ;
38764: GO 38271
// for j in mc_repair_vehicle [ i ] do
38766: LD_ADDR_VAR 0 3
38770: PUSH
38771: LD_EXP 102
38775: PUSH
38776: LD_VAR 0 2
38780: ARRAY
38781: PUSH
38782: FOR_IN
38783: IFFALSE 38949
// begin if GetClass ( j ) <> 3 then
38785: LD_VAR 0 3
38789: PPUSH
38790: CALL_OW 257
38794: PUSH
38795: LD_INT 3
38797: NONEQUAL
38798: IFFALSE 38839
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38800: LD_ADDR_EXP 102
38804: PUSH
38805: LD_EXP 102
38809: PPUSH
38810: LD_VAR 0 2
38814: PPUSH
38815: LD_EXP 102
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_VAR 0 3
38830: DIFF
38831: PPUSH
38832: CALL_OW 1
38836: ST_TO_ADDR
// continue ;
38837: GO 38782
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38839: LD_VAR 0 3
38843: PPUSH
38844: CALL_OW 311
38848: NOT
38849: PUSH
38850: LD_VAR 0 3
38854: PUSH
38855: LD_EXP 93
38859: PUSH
38860: LD_VAR 0 2
38864: ARRAY
38865: PUSH
38866: LD_INT 1
38868: ARRAY
38869: IN
38870: NOT
38871: AND
38872: PUSH
38873: LD_VAR 0 3
38877: PUSH
38878: LD_EXP 93
38882: PUSH
38883: LD_VAR 0 2
38887: ARRAY
38888: PUSH
38889: LD_INT 2
38891: ARRAY
38892: IN
38893: NOT
38894: AND
38895: IFFALSE 38947
// begin if IsInUnit ( j ) then
38897: LD_VAR 0 3
38901: PPUSH
38902: CALL_OW 310
38906: IFFALSE 38917
// ComExitBuilding ( j ) ;
38908: LD_VAR 0 3
38912: PPUSH
38913: CALL_OW 122
// if not HasTask ( j ) then
38917: LD_VAR 0 3
38921: PPUSH
38922: CALL_OW 314
38926: NOT
38927: IFFALSE 38947
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38929: LD_VAR 0 3
38933: PPUSH
38934: LD_VAR 0 7
38938: PUSH
38939: LD_INT 1
38941: ARRAY
38942: PPUSH
38943: CALL_OW 189
// end ; end ;
38947: GO 38782
38949: POP
38950: POP
// end ;
38951: GO 38271
38953: POP
38954: POP
// end ;
38955: LD_VAR 0 1
38959: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38960: LD_INT 0
38962: PPUSH
38963: PPUSH
38964: PPUSH
38965: PPUSH
38966: PPUSH
38967: PPUSH
38968: PPUSH
38969: PPUSH
38970: PPUSH
38971: PPUSH
38972: PPUSH
// if not mc_bases then
38973: LD_EXP 90
38977: NOT
38978: IFFALSE 38982
// exit ;
38980: GO 39784
// for i = 1 to mc_bases do
38982: LD_ADDR_VAR 0 2
38986: PUSH
38987: DOUBLE
38988: LD_INT 1
38990: DEC
38991: ST_TO_ADDR
38992: LD_EXP 90
38996: PUSH
38997: FOR_TO
38998: IFFALSE 39782
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39000: LD_EXP 118
39004: PUSH
39005: LD_VAR 0 2
39009: ARRAY
39010: NOT
39011: PUSH
39012: LD_EXP 93
39016: PUSH
39017: LD_VAR 0 2
39021: ARRAY
39022: PUSH
39023: LD_INT 1
39025: ARRAY
39026: OR
39027: PUSH
39028: LD_EXP 93
39032: PUSH
39033: LD_VAR 0 2
39037: ARRAY
39038: PUSH
39039: LD_INT 2
39041: ARRAY
39042: OR
39043: PUSH
39044: LD_EXP 116
39048: PUSH
39049: LD_VAR 0 2
39053: ARRAY
39054: PPUSH
39055: LD_INT 1
39057: PPUSH
39058: CALL_OW 325
39062: NOT
39063: OR
39064: PUSH
39065: LD_EXP 113
39069: PUSH
39070: LD_VAR 0 2
39074: ARRAY
39075: OR
39076: IFFALSE 39080
// continue ;
39078: GO 38997
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39080: LD_ADDR_VAR 0 8
39084: PUSH
39085: LD_EXP 90
39089: PUSH
39090: LD_VAR 0 2
39094: ARRAY
39095: PPUSH
39096: LD_INT 25
39098: PUSH
39099: LD_INT 4
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 50
39108: PUSH
39109: EMPTY
39110: LIST
39111: PUSH
39112: LD_INT 3
39114: PUSH
39115: LD_INT 60
39117: PUSH
39118: EMPTY
39119: LIST
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL_OW 72
39134: PUSH
39135: LD_EXP 94
39139: PUSH
39140: LD_VAR 0 2
39144: ARRAY
39145: DIFF
39146: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39147: LD_ADDR_VAR 0 9
39151: PUSH
39152: LD_EXP 90
39156: PUSH
39157: LD_VAR 0 2
39161: ARRAY
39162: PPUSH
39163: LD_INT 2
39165: PUSH
39166: LD_INT 30
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 30
39178: PUSH
39179: LD_INT 1
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: LIST
39190: PPUSH
39191: CALL_OW 72
39195: ST_TO_ADDR
// if not tmp or not dep then
39196: LD_VAR 0 8
39200: NOT
39201: PUSH
39202: LD_VAR 0 9
39206: NOT
39207: OR
39208: IFFALSE 39212
// continue ;
39210: GO 38997
// side := GetSide ( tmp [ 1 ] ) ;
39212: LD_ADDR_VAR 0 11
39216: PUSH
39217: LD_VAR 0 8
39221: PUSH
39222: LD_INT 1
39224: ARRAY
39225: PPUSH
39226: CALL_OW 255
39230: ST_TO_ADDR
// dep := dep [ 1 ] ;
39231: LD_ADDR_VAR 0 9
39235: PUSH
39236: LD_VAR 0 9
39240: PUSH
39241: LD_INT 1
39243: ARRAY
39244: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39245: LD_ADDR_VAR 0 7
39249: PUSH
39250: LD_EXP 118
39254: PUSH
39255: LD_VAR 0 2
39259: ARRAY
39260: PPUSH
39261: LD_INT 22
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 25
39273: PUSH
39274: LD_INT 12
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PPUSH
39285: CALL_OW 70
39289: PUSH
39290: LD_INT 22
39292: PUSH
39293: LD_INT 0
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 25
39302: PUSH
39303: LD_INT 12
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 91
39312: PUSH
39313: LD_VAR 0 9
39317: PUSH
39318: LD_INT 20
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: LIST
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: LIST
39330: PPUSH
39331: CALL_OW 69
39335: UNION
39336: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39337: LD_ADDR_VAR 0 10
39341: PUSH
39342: LD_EXP 118
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PPUSH
39353: LD_INT 81
39355: PUSH
39356: LD_VAR 0 11
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PPUSH
39365: CALL_OW 70
39369: ST_TO_ADDR
// if not apes or danger_at_area then
39370: LD_VAR 0 7
39374: NOT
39375: PUSH
39376: LD_VAR 0 10
39380: OR
39381: IFFALSE 39431
// begin if mc_taming [ i ] then
39383: LD_EXP 121
39387: PUSH
39388: LD_VAR 0 2
39392: ARRAY
39393: IFFALSE 39429
// begin MC_Reset ( i , 121 ) ;
39395: LD_VAR 0 2
39399: PPUSH
39400: LD_INT 121
39402: PPUSH
39403: CALL 24856 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39407: LD_ADDR_EXP 121
39411: PUSH
39412: LD_EXP 121
39416: PPUSH
39417: LD_VAR 0 2
39421: PPUSH
39422: EMPTY
39423: PPUSH
39424: CALL_OW 1
39428: ST_TO_ADDR
// end ; continue ;
39429: GO 38997
// end ; for j in tmp do
39431: LD_ADDR_VAR 0 3
39435: PUSH
39436: LD_VAR 0 8
39440: PUSH
39441: FOR_IN
39442: IFFALSE 39778
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39444: LD_VAR 0 3
39448: PUSH
39449: LD_EXP 121
39453: PUSH
39454: LD_VAR 0 2
39458: ARRAY
39459: IN
39460: NOT
39461: PUSH
39462: LD_EXP 121
39466: PUSH
39467: LD_VAR 0 2
39471: ARRAY
39472: PUSH
39473: LD_INT 3
39475: LESS
39476: AND
39477: IFFALSE 39535
// begin SetTag ( j , 121 ) ;
39479: LD_VAR 0 3
39483: PPUSH
39484: LD_INT 121
39486: PPUSH
39487: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39491: LD_ADDR_EXP 121
39495: PUSH
39496: LD_EXP 121
39500: PPUSH
39501: LD_VAR 0 2
39505: PUSH
39506: LD_EXP 121
39510: PUSH
39511: LD_VAR 0 2
39515: ARRAY
39516: PUSH
39517: LD_INT 1
39519: PLUS
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PPUSH
39525: LD_VAR 0 3
39529: PPUSH
39530: CALL 55792 0 3
39534: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39535: LD_VAR 0 3
39539: PUSH
39540: LD_EXP 121
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: IN
39551: IFFALSE 39776
// begin if GetClass ( j ) <> 4 then
39553: LD_VAR 0 3
39557: PPUSH
39558: CALL_OW 257
39562: PUSH
39563: LD_INT 4
39565: NONEQUAL
39566: IFFALSE 39619
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39568: LD_ADDR_EXP 121
39572: PUSH
39573: LD_EXP 121
39577: PPUSH
39578: LD_VAR 0 2
39582: PPUSH
39583: LD_EXP 121
39587: PUSH
39588: LD_VAR 0 2
39592: ARRAY
39593: PUSH
39594: LD_VAR 0 3
39598: DIFF
39599: PPUSH
39600: CALL_OW 1
39604: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39605: LD_VAR 0 3
39609: PPUSH
39610: LD_INT 0
39612: PPUSH
39613: CALL_OW 109
// continue ;
39617: GO 39441
// end ; if IsInUnit ( j ) then
39619: LD_VAR 0 3
39623: PPUSH
39624: CALL_OW 310
39628: IFFALSE 39639
// ComExitBuilding ( j ) ;
39630: LD_VAR 0 3
39634: PPUSH
39635: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39639: LD_ADDR_VAR 0 6
39643: PUSH
39644: LD_VAR 0 7
39648: PPUSH
39649: LD_VAR 0 3
39653: PPUSH
39654: CALL_OW 74
39658: ST_TO_ADDR
// if not ape then
39659: LD_VAR 0 6
39663: NOT
39664: IFFALSE 39668
// break ;
39666: GO 39778
// x := GetX ( ape ) ;
39668: LD_ADDR_VAR 0 4
39672: PUSH
39673: LD_VAR 0 6
39677: PPUSH
39678: CALL_OW 250
39682: ST_TO_ADDR
// y := GetY ( ape ) ;
39683: LD_ADDR_VAR 0 5
39687: PUSH
39688: LD_VAR 0 6
39692: PPUSH
39693: CALL_OW 251
39697: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39698: LD_VAR 0 4
39702: PPUSH
39703: LD_VAR 0 5
39707: PPUSH
39708: CALL_OW 488
39712: NOT
39713: PUSH
39714: LD_VAR 0 11
39718: PPUSH
39719: LD_VAR 0 4
39723: PPUSH
39724: LD_VAR 0 5
39728: PPUSH
39729: LD_INT 20
39731: PPUSH
39732: CALL 56688 0 4
39736: PUSH
39737: LD_INT 4
39739: ARRAY
39740: OR
39741: IFFALSE 39745
// break ;
39743: GO 39778
// if not HasTask ( j ) then
39745: LD_VAR 0 3
39749: PPUSH
39750: CALL_OW 314
39754: NOT
39755: IFFALSE 39776
// ComTameXY ( j , x , y ) ;
39757: LD_VAR 0 3
39761: PPUSH
39762: LD_VAR 0 4
39766: PPUSH
39767: LD_VAR 0 5
39771: PPUSH
39772: CALL_OW 131
// end ; end ;
39776: GO 39441
39778: POP
39779: POP
// end ;
39780: GO 38997
39782: POP
39783: POP
// end ;
39784: LD_VAR 0 1
39788: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39789: LD_INT 0
39791: PPUSH
39792: PPUSH
39793: PPUSH
39794: PPUSH
39795: PPUSH
39796: PPUSH
39797: PPUSH
39798: PPUSH
// if not mc_bases then
39799: LD_EXP 90
39803: NOT
39804: IFFALSE 39808
// exit ;
39806: GO 40434
// for i = 1 to mc_bases do
39808: LD_ADDR_VAR 0 2
39812: PUSH
39813: DOUBLE
39814: LD_INT 1
39816: DEC
39817: ST_TO_ADDR
39818: LD_EXP 90
39822: PUSH
39823: FOR_TO
39824: IFFALSE 40432
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39826: LD_EXP 119
39830: PUSH
39831: LD_VAR 0 2
39835: ARRAY
39836: NOT
39837: PUSH
39838: LD_EXP 119
39842: PUSH
39843: LD_VAR 0 2
39847: ARRAY
39848: PPUSH
39849: LD_INT 25
39851: PUSH
39852: LD_INT 12
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PPUSH
39859: CALL_OW 72
39863: NOT
39864: OR
39865: IFFALSE 39869
// continue ;
39867: GO 39823
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39869: LD_ADDR_VAR 0 5
39873: PUSH
39874: LD_EXP 119
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PUSH
39885: LD_INT 1
39887: ARRAY
39888: PPUSH
39889: CALL_OW 255
39893: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39894: LD_VAR 0 5
39898: PPUSH
39899: LD_INT 2
39901: PPUSH
39902: CALL_OW 325
39906: IFFALSE 40159
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39908: LD_ADDR_VAR 0 4
39912: PUSH
39913: LD_EXP 119
39917: PUSH
39918: LD_VAR 0 2
39922: ARRAY
39923: PPUSH
39924: LD_INT 25
39926: PUSH
39927: LD_INT 16
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PPUSH
39934: CALL_OW 72
39938: ST_TO_ADDR
// if tmp < 6 then
39939: LD_VAR 0 4
39943: PUSH
39944: LD_INT 6
39946: LESS
39947: IFFALSE 40159
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39949: LD_ADDR_VAR 0 6
39953: PUSH
39954: LD_EXP 90
39958: PUSH
39959: LD_VAR 0 2
39963: ARRAY
39964: PPUSH
39965: LD_INT 2
39967: PUSH
39968: LD_INT 30
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 30
39980: PUSH
39981: LD_INT 1
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: LIST
39992: PPUSH
39993: CALL_OW 72
39997: ST_TO_ADDR
// if depot then
39998: LD_VAR 0 6
40002: IFFALSE 40159
// begin selected := 0 ;
40004: LD_ADDR_VAR 0 7
40008: PUSH
40009: LD_INT 0
40011: ST_TO_ADDR
// for j in depot do
40012: LD_ADDR_VAR 0 3
40016: PUSH
40017: LD_VAR 0 6
40021: PUSH
40022: FOR_IN
40023: IFFALSE 40054
// begin if UnitsInside ( j ) < 6 then
40025: LD_VAR 0 3
40029: PPUSH
40030: CALL_OW 313
40034: PUSH
40035: LD_INT 6
40037: LESS
40038: IFFALSE 40052
// begin selected := j ;
40040: LD_ADDR_VAR 0 7
40044: PUSH
40045: LD_VAR 0 3
40049: ST_TO_ADDR
// break ;
40050: GO 40054
// end ; end ;
40052: GO 40022
40054: POP
40055: POP
// if selected then
40056: LD_VAR 0 7
40060: IFFALSE 40159
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40062: LD_ADDR_VAR 0 3
40066: PUSH
40067: LD_EXP 119
40071: PUSH
40072: LD_VAR 0 2
40076: ARRAY
40077: PPUSH
40078: LD_INT 25
40080: PUSH
40081: LD_INT 12
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PPUSH
40088: CALL_OW 72
40092: PUSH
40093: FOR_IN
40094: IFFALSE 40157
// if not HasTask ( j ) then
40096: LD_VAR 0 3
40100: PPUSH
40101: CALL_OW 314
40105: NOT
40106: IFFALSE 40155
// begin if not IsInUnit ( j ) then
40108: LD_VAR 0 3
40112: PPUSH
40113: CALL_OW 310
40117: NOT
40118: IFFALSE 40134
// ComEnterUnit ( j , selected ) ;
40120: LD_VAR 0 3
40124: PPUSH
40125: LD_VAR 0 7
40129: PPUSH
40130: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40134: LD_VAR 0 3
40138: PPUSH
40139: LD_INT 16
40141: PPUSH
40142: CALL_OW 183
// AddComExitBuilding ( j ) ;
40146: LD_VAR 0 3
40150: PPUSH
40151: CALL_OW 182
// end ;
40155: GO 40093
40157: POP
40158: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40159: LD_VAR 0 5
40163: PPUSH
40164: LD_INT 11
40166: PPUSH
40167: CALL_OW 325
40171: IFFALSE 40430
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40173: LD_ADDR_VAR 0 4
40177: PUSH
40178: LD_EXP 119
40182: PUSH
40183: LD_VAR 0 2
40187: ARRAY
40188: PPUSH
40189: LD_INT 25
40191: PUSH
40192: LD_INT 16
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PPUSH
40199: CALL_OW 72
40203: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40204: LD_VAR 0 4
40208: PUSH
40209: LD_INT 6
40211: GREATEREQUAL
40212: PUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: LD_INT 2
40220: PPUSH
40221: CALL_OW 325
40225: NOT
40226: OR
40227: IFFALSE 40430
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40229: LD_ADDR_VAR 0 8
40233: PUSH
40234: LD_EXP 90
40238: PUSH
40239: LD_VAR 0 2
40243: ARRAY
40244: PPUSH
40245: LD_INT 2
40247: PUSH
40248: LD_INT 30
40250: PUSH
40251: LD_INT 4
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 30
40260: PUSH
40261: LD_INT 5
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: LIST
40272: PPUSH
40273: CALL_OW 72
40277: ST_TO_ADDR
// if barracks then
40278: LD_VAR 0 8
40282: IFFALSE 40430
// begin selected := 0 ;
40284: LD_ADDR_VAR 0 7
40288: PUSH
40289: LD_INT 0
40291: ST_TO_ADDR
// for j in barracks do
40292: LD_ADDR_VAR 0 3
40296: PUSH
40297: LD_VAR 0 8
40301: PUSH
40302: FOR_IN
40303: IFFALSE 40334
// begin if UnitsInside ( j ) < 6 then
40305: LD_VAR 0 3
40309: PPUSH
40310: CALL_OW 313
40314: PUSH
40315: LD_INT 6
40317: LESS
40318: IFFALSE 40332
// begin selected := j ;
40320: LD_ADDR_VAR 0 7
40324: PUSH
40325: LD_VAR 0 3
40329: ST_TO_ADDR
// break ;
40330: GO 40334
// end ; end ;
40332: GO 40302
40334: POP
40335: POP
// if selected then
40336: LD_VAR 0 7
40340: IFFALSE 40430
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40342: LD_ADDR_VAR 0 3
40346: PUSH
40347: LD_EXP 119
40351: PUSH
40352: LD_VAR 0 2
40356: ARRAY
40357: PPUSH
40358: LD_INT 25
40360: PUSH
40361: LD_INT 12
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PPUSH
40368: CALL_OW 72
40372: PUSH
40373: FOR_IN
40374: IFFALSE 40428
// if not IsInUnit ( j ) and not HasTask ( j ) then
40376: LD_VAR 0 3
40380: PPUSH
40381: CALL_OW 310
40385: NOT
40386: PUSH
40387: LD_VAR 0 3
40391: PPUSH
40392: CALL_OW 314
40396: NOT
40397: AND
40398: IFFALSE 40426
// begin ComEnterUnit ( j , selected ) ;
40400: LD_VAR 0 3
40404: PPUSH
40405: LD_VAR 0 7
40409: PPUSH
40410: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40414: LD_VAR 0 3
40418: PPUSH
40419: LD_INT 15
40421: PPUSH
40422: CALL_OW 183
// end ;
40426: GO 40373
40428: POP
40429: POP
// end ; end ; end ; end ; end ;
40430: GO 39823
40432: POP
40433: POP
// end ;
40434: LD_VAR 0 1
40438: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40439: LD_INT 0
40441: PPUSH
40442: PPUSH
40443: PPUSH
40444: PPUSH
// if not mc_bases then
40445: LD_EXP 90
40449: NOT
40450: IFFALSE 40454
// exit ;
40452: GO 40632
// for i = 1 to mc_bases do
40454: LD_ADDR_VAR 0 2
40458: PUSH
40459: DOUBLE
40460: LD_INT 1
40462: DEC
40463: ST_TO_ADDR
40464: LD_EXP 90
40468: PUSH
40469: FOR_TO
40470: IFFALSE 40630
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40472: LD_ADDR_VAR 0 4
40476: PUSH
40477: LD_EXP 90
40481: PUSH
40482: LD_VAR 0 2
40486: ARRAY
40487: PPUSH
40488: LD_INT 25
40490: PUSH
40491: LD_INT 9
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PPUSH
40498: CALL_OW 72
40502: ST_TO_ADDR
// if not tmp then
40503: LD_VAR 0 4
40507: NOT
40508: IFFALSE 40512
// continue ;
40510: GO 40469
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40512: LD_EXP 116
40516: PUSH
40517: LD_VAR 0 2
40521: ARRAY
40522: PPUSH
40523: LD_INT 29
40525: PPUSH
40526: CALL_OW 325
40530: NOT
40531: PUSH
40532: LD_EXP 116
40536: PUSH
40537: LD_VAR 0 2
40541: ARRAY
40542: PPUSH
40543: LD_INT 28
40545: PPUSH
40546: CALL_OW 325
40550: NOT
40551: AND
40552: IFFALSE 40556
// continue ;
40554: GO 40469
// for j in tmp do
40556: LD_ADDR_VAR 0 3
40560: PUSH
40561: LD_VAR 0 4
40565: PUSH
40566: FOR_IN
40567: IFFALSE 40626
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40569: LD_VAR 0 3
40573: PUSH
40574: LD_EXP 93
40578: PUSH
40579: LD_VAR 0 2
40583: ARRAY
40584: PUSH
40585: LD_INT 1
40587: ARRAY
40588: IN
40589: NOT
40590: PUSH
40591: LD_VAR 0 3
40595: PUSH
40596: LD_EXP 93
40600: PUSH
40601: LD_VAR 0 2
40605: ARRAY
40606: PUSH
40607: LD_INT 2
40609: ARRAY
40610: IN
40611: NOT
40612: AND
40613: IFFALSE 40624
// ComSpaceTimeShoot ( j ) ;
40615: LD_VAR 0 3
40619: PPUSH
40620: CALL 51789 0 1
40624: GO 40566
40626: POP
40627: POP
// end ;
40628: GO 40469
40630: POP
40631: POP
// end ;
40632: LD_VAR 0 1
40636: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40637: LD_INT 0
40639: PPUSH
40640: PPUSH
40641: PPUSH
40642: PPUSH
40643: PPUSH
40644: PPUSH
40645: PPUSH
40646: PPUSH
40647: PPUSH
// if not mc_bases then
40648: LD_EXP 90
40652: NOT
40653: IFFALSE 40657
// exit ;
40655: GO 41279
// for i = 1 to mc_bases do
40657: LD_ADDR_VAR 0 2
40661: PUSH
40662: DOUBLE
40663: LD_INT 1
40665: DEC
40666: ST_TO_ADDR
40667: LD_EXP 90
40671: PUSH
40672: FOR_TO
40673: IFFALSE 41277
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40675: LD_EXP 125
40679: PUSH
40680: LD_VAR 0 2
40684: ARRAY
40685: NOT
40686: PUSH
40687: LD_INT 38
40689: PPUSH
40690: LD_EXP 116
40694: PUSH
40695: LD_VAR 0 2
40699: ARRAY
40700: PPUSH
40701: CALL_OW 321
40705: PUSH
40706: LD_INT 2
40708: NONEQUAL
40709: OR
40710: IFFALSE 40714
// continue ;
40712: GO 40672
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40714: LD_ADDR_VAR 0 8
40718: PUSH
40719: LD_EXP 90
40723: PUSH
40724: LD_VAR 0 2
40728: ARRAY
40729: PPUSH
40730: LD_INT 30
40732: PUSH
40733: LD_INT 34
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PPUSH
40740: CALL_OW 72
40744: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40745: LD_ADDR_VAR 0 9
40749: PUSH
40750: LD_EXP 90
40754: PUSH
40755: LD_VAR 0 2
40759: ARRAY
40760: PPUSH
40761: LD_INT 25
40763: PUSH
40764: LD_INT 4
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PPUSH
40771: CALL_OW 72
40775: PPUSH
40776: LD_INT 0
40778: PPUSH
40779: CALL 84353 0 2
40783: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40784: LD_VAR 0 9
40788: NOT
40789: PUSH
40790: LD_VAR 0 8
40794: NOT
40795: OR
40796: PUSH
40797: LD_EXP 90
40801: PUSH
40802: LD_VAR 0 2
40806: ARRAY
40807: PPUSH
40808: LD_INT 124
40810: PPUSH
40811: CALL 84353 0 2
40815: OR
40816: IFFALSE 40820
// continue ;
40818: GO 40672
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40820: LD_EXP 126
40824: PUSH
40825: LD_VAR 0 2
40829: ARRAY
40830: PUSH
40831: LD_EXP 125
40835: PUSH
40836: LD_VAR 0 2
40840: ARRAY
40841: LESS
40842: PUSH
40843: LD_EXP 126
40847: PUSH
40848: LD_VAR 0 2
40852: ARRAY
40853: PUSH
40854: LD_VAR 0 8
40858: LESS
40859: AND
40860: IFFALSE 41275
// begin tmp := sci [ 1 ] ;
40862: LD_ADDR_VAR 0 7
40866: PUSH
40867: LD_VAR 0 9
40871: PUSH
40872: LD_INT 1
40874: ARRAY
40875: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40876: LD_VAR 0 7
40880: PPUSH
40881: LD_INT 124
40883: PPUSH
40884: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40888: LD_ADDR_VAR 0 3
40892: PUSH
40893: DOUBLE
40894: LD_EXP 125
40898: PUSH
40899: LD_VAR 0 2
40903: ARRAY
40904: INC
40905: ST_TO_ADDR
40906: LD_EXP 125
40910: PUSH
40911: LD_VAR 0 2
40915: ARRAY
40916: PUSH
40917: FOR_DOWNTO
40918: IFFALSE 41261
// begin if IsInUnit ( tmp ) then
40920: LD_VAR 0 7
40924: PPUSH
40925: CALL_OW 310
40929: IFFALSE 40940
// ComExitBuilding ( tmp ) ;
40931: LD_VAR 0 7
40935: PPUSH
40936: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40940: LD_INT 35
40942: PPUSH
40943: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40947: LD_VAR 0 7
40951: PPUSH
40952: CALL_OW 310
40956: NOT
40957: PUSH
40958: LD_VAR 0 7
40962: PPUSH
40963: CALL_OW 314
40967: NOT
40968: AND
40969: IFFALSE 40940
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40971: LD_ADDR_VAR 0 6
40975: PUSH
40976: LD_VAR 0 7
40980: PPUSH
40981: CALL_OW 250
40985: PUSH
40986: LD_VAR 0 7
40990: PPUSH
40991: CALL_OW 251
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41000: LD_INT 35
41002: PPUSH
41003: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41007: LD_ADDR_VAR 0 4
41011: PUSH
41012: LD_EXP 125
41016: PUSH
41017: LD_VAR 0 2
41021: ARRAY
41022: PUSH
41023: LD_VAR 0 3
41027: ARRAY
41028: PUSH
41029: LD_INT 1
41031: ARRAY
41032: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41033: LD_ADDR_VAR 0 5
41037: PUSH
41038: LD_EXP 125
41042: PUSH
41043: LD_VAR 0 2
41047: ARRAY
41048: PUSH
41049: LD_VAR 0 3
41053: ARRAY
41054: PUSH
41055: LD_INT 2
41057: ARRAY
41058: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41059: LD_VAR 0 7
41063: PPUSH
41064: LD_INT 10
41066: PPUSH
41067: CALL 58385 0 2
41071: PUSH
41072: LD_INT 4
41074: ARRAY
41075: IFFALSE 41113
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41077: LD_VAR 0 7
41081: PPUSH
41082: LD_VAR 0 6
41086: PUSH
41087: LD_INT 1
41089: ARRAY
41090: PPUSH
41091: LD_VAR 0 6
41095: PUSH
41096: LD_INT 2
41098: ARRAY
41099: PPUSH
41100: CALL_OW 111
// wait ( 0 0$10 ) ;
41104: LD_INT 350
41106: PPUSH
41107: CALL_OW 67
// end else
41111: GO 41139
// begin ComMoveXY ( tmp , x , y ) ;
41113: LD_VAR 0 7
41117: PPUSH
41118: LD_VAR 0 4
41122: PPUSH
41123: LD_VAR 0 5
41127: PPUSH
41128: CALL_OW 111
// wait ( 0 0$3 ) ;
41132: LD_INT 105
41134: PPUSH
41135: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41139: LD_VAR 0 7
41143: PPUSH
41144: LD_VAR 0 4
41148: PPUSH
41149: LD_VAR 0 5
41153: PPUSH
41154: CALL_OW 307
41158: IFFALSE 41000
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41160: LD_VAR 0 7
41164: PPUSH
41165: LD_VAR 0 4
41169: PPUSH
41170: LD_VAR 0 5
41174: PPUSH
41175: LD_VAR 0 8
41179: PUSH
41180: LD_VAR 0 3
41184: ARRAY
41185: PPUSH
41186: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41190: LD_INT 35
41192: PPUSH
41193: CALL_OW 67
// until not HasTask ( tmp ) ;
41197: LD_VAR 0 7
41201: PPUSH
41202: CALL_OW 314
41206: NOT
41207: IFFALSE 41190
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41209: LD_ADDR_EXP 126
41213: PUSH
41214: LD_EXP 126
41218: PPUSH
41219: LD_VAR 0 2
41223: PUSH
41224: LD_EXP 126
41228: PUSH
41229: LD_VAR 0 2
41233: ARRAY
41234: PUSH
41235: LD_INT 1
41237: PLUS
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PPUSH
41243: LD_VAR 0 8
41247: PUSH
41248: LD_VAR 0 3
41252: ARRAY
41253: PPUSH
41254: CALL 55792 0 3
41258: ST_TO_ADDR
// end ;
41259: GO 40917
41261: POP
41262: POP
// MC_Reset ( i , 124 ) ;
41263: LD_VAR 0 2
41267: PPUSH
41268: LD_INT 124
41270: PPUSH
41271: CALL 24856 0 2
// end ; end ;
41275: GO 40672
41277: POP
41278: POP
// end ;
41279: LD_VAR 0 1
41283: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41284: LD_INT 0
41286: PPUSH
41287: PPUSH
41288: PPUSH
// if not mc_bases then
41289: LD_EXP 90
41293: NOT
41294: IFFALSE 41298
// exit ;
41296: GO 41904
// for i = 1 to mc_bases do
41298: LD_ADDR_VAR 0 2
41302: PUSH
41303: DOUBLE
41304: LD_INT 1
41306: DEC
41307: ST_TO_ADDR
41308: LD_EXP 90
41312: PUSH
41313: FOR_TO
41314: IFFALSE 41902
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41316: LD_ADDR_VAR 0 3
41320: PUSH
41321: LD_EXP 90
41325: PUSH
41326: LD_VAR 0 2
41330: ARRAY
41331: PPUSH
41332: LD_INT 25
41334: PUSH
41335: LD_INT 4
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL_OW 72
41346: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41347: LD_VAR 0 3
41351: NOT
41352: PUSH
41353: LD_EXP 127
41357: PUSH
41358: LD_VAR 0 2
41362: ARRAY
41363: NOT
41364: OR
41365: PUSH
41366: LD_EXP 90
41370: PUSH
41371: LD_VAR 0 2
41375: ARRAY
41376: PPUSH
41377: LD_INT 2
41379: PUSH
41380: LD_INT 30
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 30
41392: PUSH
41393: LD_INT 1
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: LIST
41404: PPUSH
41405: CALL_OW 72
41409: NOT
41410: OR
41411: IFFALSE 41461
// begin if mc_deposits_finder [ i ] then
41413: LD_EXP 128
41417: PUSH
41418: LD_VAR 0 2
41422: ARRAY
41423: IFFALSE 41459
// begin MC_Reset ( i , 125 ) ;
41425: LD_VAR 0 2
41429: PPUSH
41430: LD_INT 125
41432: PPUSH
41433: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41437: LD_ADDR_EXP 128
41441: PUSH
41442: LD_EXP 128
41446: PPUSH
41447: LD_VAR 0 2
41451: PPUSH
41452: EMPTY
41453: PPUSH
41454: CALL_OW 1
41458: ST_TO_ADDR
// end ; continue ;
41459: GO 41313
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41461: LD_EXP 127
41465: PUSH
41466: LD_VAR 0 2
41470: ARRAY
41471: PUSH
41472: LD_INT 1
41474: ARRAY
41475: PUSH
41476: LD_INT 3
41478: ARRAY
41479: PUSH
41480: LD_INT 1
41482: EQUAL
41483: PUSH
41484: LD_INT 20
41486: PPUSH
41487: LD_EXP 116
41491: PUSH
41492: LD_VAR 0 2
41496: ARRAY
41497: PPUSH
41498: CALL_OW 321
41502: PUSH
41503: LD_INT 2
41505: NONEQUAL
41506: AND
41507: IFFALSE 41557
// begin if mc_deposits_finder [ i ] then
41509: LD_EXP 128
41513: PUSH
41514: LD_VAR 0 2
41518: ARRAY
41519: IFFALSE 41555
// begin MC_Reset ( i , 125 ) ;
41521: LD_VAR 0 2
41525: PPUSH
41526: LD_INT 125
41528: PPUSH
41529: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41533: LD_ADDR_EXP 128
41537: PUSH
41538: LD_EXP 128
41542: PPUSH
41543: LD_VAR 0 2
41547: PPUSH
41548: EMPTY
41549: PPUSH
41550: CALL_OW 1
41554: ST_TO_ADDR
// end ; continue ;
41555: GO 41313
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41557: LD_EXP 127
41561: PUSH
41562: LD_VAR 0 2
41566: ARRAY
41567: PUSH
41568: LD_INT 1
41570: ARRAY
41571: PUSH
41572: LD_INT 1
41574: ARRAY
41575: PPUSH
41576: LD_EXP 127
41580: PUSH
41581: LD_VAR 0 2
41585: ARRAY
41586: PUSH
41587: LD_INT 1
41589: ARRAY
41590: PUSH
41591: LD_INT 2
41593: ARRAY
41594: PPUSH
41595: LD_EXP 116
41599: PUSH
41600: LD_VAR 0 2
41604: ARRAY
41605: PPUSH
41606: CALL_OW 440
41610: IFFALSE 41653
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41612: LD_ADDR_EXP 127
41616: PUSH
41617: LD_EXP 127
41621: PPUSH
41622: LD_VAR 0 2
41626: PPUSH
41627: LD_EXP 127
41631: PUSH
41632: LD_VAR 0 2
41636: ARRAY
41637: PPUSH
41638: LD_INT 1
41640: PPUSH
41641: CALL_OW 3
41645: PPUSH
41646: CALL_OW 1
41650: ST_TO_ADDR
41651: GO 41900
// begin if not mc_deposits_finder [ i ] then
41653: LD_EXP 128
41657: PUSH
41658: LD_VAR 0 2
41662: ARRAY
41663: NOT
41664: IFFALSE 41716
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41666: LD_ADDR_EXP 128
41670: PUSH
41671: LD_EXP 128
41675: PPUSH
41676: LD_VAR 0 2
41680: PPUSH
41681: LD_VAR 0 3
41685: PUSH
41686: LD_INT 1
41688: ARRAY
41689: PUSH
41690: EMPTY
41691: LIST
41692: PPUSH
41693: CALL_OW 1
41697: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41698: LD_VAR 0 3
41702: PUSH
41703: LD_INT 1
41705: ARRAY
41706: PPUSH
41707: LD_INT 125
41709: PPUSH
41710: CALL_OW 109
// end else
41714: GO 41900
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41716: LD_EXP 128
41720: PUSH
41721: LD_VAR 0 2
41725: ARRAY
41726: PUSH
41727: LD_INT 1
41729: ARRAY
41730: PPUSH
41731: CALL_OW 310
41735: IFFALSE 41758
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41737: LD_EXP 128
41741: PUSH
41742: LD_VAR 0 2
41746: ARRAY
41747: PUSH
41748: LD_INT 1
41750: ARRAY
41751: PPUSH
41752: CALL_OW 122
41756: GO 41900
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41758: LD_EXP 128
41762: PUSH
41763: LD_VAR 0 2
41767: ARRAY
41768: PUSH
41769: LD_INT 1
41771: ARRAY
41772: PPUSH
41773: CALL_OW 314
41777: NOT
41778: PUSH
41779: LD_EXP 128
41783: PUSH
41784: LD_VAR 0 2
41788: ARRAY
41789: PUSH
41790: LD_INT 1
41792: ARRAY
41793: PPUSH
41794: LD_EXP 127
41798: PUSH
41799: LD_VAR 0 2
41803: ARRAY
41804: PUSH
41805: LD_INT 1
41807: ARRAY
41808: PUSH
41809: LD_INT 1
41811: ARRAY
41812: PPUSH
41813: LD_EXP 127
41817: PUSH
41818: LD_VAR 0 2
41822: ARRAY
41823: PUSH
41824: LD_INT 1
41826: ARRAY
41827: PUSH
41828: LD_INT 2
41830: ARRAY
41831: PPUSH
41832: CALL_OW 297
41836: PUSH
41837: LD_INT 6
41839: GREATER
41840: AND
41841: IFFALSE 41900
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41843: LD_EXP 128
41847: PUSH
41848: LD_VAR 0 2
41852: ARRAY
41853: PUSH
41854: LD_INT 1
41856: ARRAY
41857: PPUSH
41858: LD_EXP 127
41862: PUSH
41863: LD_VAR 0 2
41867: ARRAY
41868: PUSH
41869: LD_INT 1
41871: ARRAY
41872: PUSH
41873: LD_INT 1
41875: ARRAY
41876: PPUSH
41877: LD_EXP 127
41881: PUSH
41882: LD_VAR 0 2
41886: ARRAY
41887: PUSH
41888: LD_INT 1
41890: ARRAY
41891: PUSH
41892: LD_INT 2
41894: ARRAY
41895: PPUSH
41896: CALL_OW 111
// end ; end ; end ;
41900: GO 41313
41902: POP
41903: POP
// end ;
41904: LD_VAR 0 1
41908: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41909: LD_INT 0
41911: PPUSH
41912: PPUSH
41913: PPUSH
41914: PPUSH
41915: PPUSH
41916: PPUSH
41917: PPUSH
41918: PPUSH
41919: PPUSH
41920: PPUSH
41921: PPUSH
// if not mc_bases then
41922: LD_EXP 90
41926: NOT
41927: IFFALSE 41931
// exit ;
41929: GO 42871
// for i = 1 to mc_bases do
41931: LD_ADDR_VAR 0 2
41935: PUSH
41936: DOUBLE
41937: LD_INT 1
41939: DEC
41940: ST_TO_ADDR
41941: LD_EXP 90
41945: PUSH
41946: FOR_TO
41947: IFFALSE 42869
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41949: LD_EXP 90
41953: PUSH
41954: LD_VAR 0 2
41958: ARRAY
41959: NOT
41960: PUSH
41961: LD_EXP 113
41965: PUSH
41966: LD_VAR 0 2
41970: ARRAY
41971: OR
41972: IFFALSE 41976
// continue ;
41974: GO 41946
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41976: LD_ADDR_VAR 0 7
41980: PUSH
41981: LD_EXP 90
41985: PUSH
41986: LD_VAR 0 2
41990: ARRAY
41991: PUSH
41992: LD_INT 1
41994: ARRAY
41995: PPUSH
41996: CALL_OW 248
42000: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42001: LD_VAR 0 7
42005: PUSH
42006: LD_INT 3
42008: EQUAL
42009: PUSH
42010: LD_EXP 109
42014: PUSH
42015: LD_VAR 0 2
42019: ARRAY
42020: PUSH
42021: LD_EXP 112
42025: PUSH
42026: LD_VAR 0 2
42030: ARRAY
42031: UNION
42032: PPUSH
42033: LD_INT 33
42035: PUSH
42036: LD_INT 2
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PPUSH
42043: CALL_OW 72
42047: NOT
42048: OR
42049: IFFALSE 42053
// continue ;
42051: GO 41946
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42053: LD_ADDR_VAR 0 9
42057: PUSH
42058: LD_EXP 90
42062: PUSH
42063: LD_VAR 0 2
42067: ARRAY
42068: PPUSH
42069: LD_INT 30
42071: PUSH
42072: LD_INT 36
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PPUSH
42079: CALL_OW 72
42083: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42084: LD_ADDR_VAR 0 10
42088: PUSH
42089: LD_EXP 109
42093: PUSH
42094: LD_VAR 0 2
42098: ARRAY
42099: PPUSH
42100: LD_INT 34
42102: PUSH
42103: LD_INT 31
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PPUSH
42110: CALL_OW 72
42114: ST_TO_ADDR
// if not cts and not mcts then
42115: LD_VAR 0 9
42119: NOT
42120: PUSH
42121: LD_VAR 0 10
42125: NOT
42126: AND
42127: IFFALSE 42131
// continue ;
42129: GO 41946
// x := cts ;
42131: LD_ADDR_VAR 0 11
42135: PUSH
42136: LD_VAR 0 9
42140: ST_TO_ADDR
// if not x then
42141: LD_VAR 0 11
42145: NOT
42146: IFFALSE 42158
// x := mcts ;
42148: LD_ADDR_VAR 0 11
42152: PUSH
42153: LD_VAR 0 10
42157: ST_TO_ADDR
// if not x then
42158: LD_VAR 0 11
42162: NOT
42163: IFFALSE 42167
// continue ;
42165: GO 41946
// if mc_remote_driver [ i ] then
42167: LD_EXP 130
42171: PUSH
42172: LD_VAR 0 2
42176: ARRAY
42177: IFFALSE 42564
// for j in mc_remote_driver [ i ] do
42179: LD_ADDR_VAR 0 3
42183: PUSH
42184: LD_EXP 130
42188: PUSH
42189: LD_VAR 0 2
42193: ARRAY
42194: PUSH
42195: FOR_IN
42196: IFFALSE 42562
// begin if GetClass ( j ) <> 3 then
42198: LD_VAR 0 3
42202: PPUSH
42203: CALL_OW 257
42207: PUSH
42208: LD_INT 3
42210: NONEQUAL
42211: IFFALSE 42264
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42213: LD_ADDR_EXP 130
42217: PUSH
42218: LD_EXP 130
42222: PPUSH
42223: LD_VAR 0 2
42227: PPUSH
42228: LD_EXP 130
42232: PUSH
42233: LD_VAR 0 2
42237: ARRAY
42238: PUSH
42239: LD_VAR 0 3
42243: DIFF
42244: PPUSH
42245: CALL_OW 1
42249: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42250: LD_VAR 0 3
42254: PPUSH
42255: LD_INT 0
42257: PPUSH
42258: CALL_OW 109
// continue ;
42262: GO 42195
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42264: LD_EXP 109
42268: PUSH
42269: LD_VAR 0 2
42273: ARRAY
42274: PPUSH
42275: LD_INT 34
42277: PUSH
42278: LD_INT 31
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 58
42287: PUSH
42288: EMPTY
42289: LIST
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PPUSH
42295: CALL_OW 72
42299: PUSH
42300: LD_VAR 0 3
42304: PPUSH
42305: CALL 84441 0 1
42309: NOT
42310: AND
42311: IFFALSE 42382
// begin if IsInUnit ( j ) then
42313: LD_VAR 0 3
42317: PPUSH
42318: CALL_OW 310
42322: IFFALSE 42333
// ComExitBuilding ( j ) ;
42324: LD_VAR 0 3
42328: PPUSH
42329: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42333: LD_VAR 0 3
42337: PPUSH
42338: LD_EXP 109
42342: PUSH
42343: LD_VAR 0 2
42347: ARRAY
42348: PPUSH
42349: LD_INT 34
42351: PUSH
42352: LD_INT 31
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 58
42361: PUSH
42362: EMPTY
42363: LIST
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PPUSH
42369: CALL_OW 72
42373: PUSH
42374: LD_INT 1
42376: ARRAY
42377: PPUSH
42378: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42382: LD_VAR 0 3
42386: PPUSH
42387: CALL_OW 310
42391: NOT
42392: PUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: CALL_OW 310
42402: PPUSH
42403: CALL_OW 266
42407: PUSH
42408: LD_INT 36
42410: NONEQUAL
42411: PUSH
42412: LD_VAR 0 3
42416: PPUSH
42417: CALL 84441 0 1
42421: NOT
42422: AND
42423: OR
42424: IFFALSE 42560
// begin if IsInUnit ( j ) then
42426: LD_VAR 0 3
42430: PPUSH
42431: CALL_OW 310
42435: IFFALSE 42446
// ComExitBuilding ( j ) ;
42437: LD_VAR 0 3
42441: PPUSH
42442: CALL_OW 122
// ct := 0 ;
42446: LD_ADDR_VAR 0 8
42450: PUSH
42451: LD_INT 0
42453: ST_TO_ADDR
// for k in x do
42454: LD_ADDR_VAR 0 4
42458: PUSH
42459: LD_VAR 0 11
42463: PUSH
42464: FOR_IN
42465: IFFALSE 42538
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42467: LD_VAR 0 4
42471: PPUSH
42472: CALL_OW 264
42476: PUSH
42477: LD_INT 31
42479: EQUAL
42480: PUSH
42481: LD_VAR 0 4
42485: PPUSH
42486: CALL_OW 311
42490: NOT
42491: AND
42492: PUSH
42493: LD_VAR 0 4
42497: PPUSH
42498: CALL_OW 266
42502: PUSH
42503: LD_INT 36
42505: EQUAL
42506: PUSH
42507: LD_VAR 0 4
42511: PPUSH
42512: CALL_OW 313
42516: PUSH
42517: LD_INT 3
42519: LESS
42520: AND
42521: OR
42522: IFFALSE 42536
// begin ct := k ;
42524: LD_ADDR_VAR 0 8
42528: PUSH
42529: LD_VAR 0 4
42533: ST_TO_ADDR
// break ;
42534: GO 42538
// end ;
42536: GO 42464
42538: POP
42539: POP
// if ct then
42540: LD_VAR 0 8
42544: IFFALSE 42560
// ComEnterUnit ( j , ct ) ;
42546: LD_VAR 0 3
42550: PPUSH
42551: LD_VAR 0 8
42555: PPUSH
42556: CALL_OW 120
// end ; end ;
42560: GO 42195
42562: POP
42563: POP
// places := 0 ;
42564: LD_ADDR_VAR 0 5
42568: PUSH
42569: LD_INT 0
42571: ST_TO_ADDR
// for j = 1 to x do
42572: LD_ADDR_VAR 0 3
42576: PUSH
42577: DOUBLE
42578: LD_INT 1
42580: DEC
42581: ST_TO_ADDR
42582: LD_VAR 0 11
42586: PUSH
42587: FOR_TO
42588: IFFALSE 42664
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42590: LD_VAR 0 11
42594: PUSH
42595: LD_VAR 0 3
42599: ARRAY
42600: PPUSH
42601: CALL_OW 264
42605: PUSH
42606: LD_INT 31
42608: EQUAL
42609: IFFALSE 42627
// places := places + 1 else
42611: LD_ADDR_VAR 0 5
42615: PUSH
42616: LD_VAR 0 5
42620: PUSH
42621: LD_INT 1
42623: PLUS
42624: ST_TO_ADDR
42625: GO 42662
// if GetBType ( x [ j ] ) = b_control_tower then
42627: LD_VAR 0 11
42631: PUSH
42632: LD_VAR 0 3
42636: ARRAY
42637: PPUSH
42638: CALL_OW 266
42642: PUSH
42643: LD_INT 36
42645: EQUAL
42646: IFFALSE 42662
// places := places + 3 ;
42648: LD_ADDR_VAR 0 5
42652: PUSH
42653: LD_VAR 0 5
42657: PUSH
42658: LD_INT 3
42660: PLUS
42661: ST_TO_ADDR
42662: GO 42587
42664: POP
42665: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42666: LD_VAR 0 5
42670: PUSH
42671: LD_INT 0
42673: EQUAL
42674: PUSH
42675: LD_VAR 0 5
42679: PUSH
42680: LD_EXP 130
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: LESSEQUAL
42691: OR
42692: IFFALSE 42696
// continue ;
42694: GO 41946
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42696: LD_ADDR_VAR 0 6
42700: PUSH
42701: LD_EXP 90
42705: PUSH
42706: LD_VAR 0 2
42710: ARRAY
42711: PPUSH
42712: LD_INT 25
42714: PUSH
42715: LD_INT 3
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PPUSH
42722: CALL_OW 72
42726: PUSH
42727: LD_EXP 130
42731: PUSH
42732: LD_VAR 0 2
42736: ARRAY
42737: DIFF
42738: PPUSH
42739: LD_INT 3
42741: PPUSH
42742: CALL 85341 0 2
42746: ST_TO_ADDR
// for j in tmp do
42747: LD_ADDR_VAR 0 3
42751: PUSH
42752: LD_VAR 0 6
42756: PUSH
42757: FOR_IN
42758: IFFALSE 42793
// if GetTag ( j ) > 0 then
42760: LD_VAR 0 3
42764: PPUSH
42765: CALL_OW 110
42769: PUSH
42770: LD_INT 0
42772: GREATER
42773: IFFALSE 42791
// tmp := tmp diff j ;
42775: LD_ADDR_VAR 0 6
42779: PUSH
42780: LD_VAR 0 6
42784: PUSH
42785: LD_VAR 0 3
42789: DIFF
42790: ST_TO_ADDR
42791: GO 42757
42793: POP
42794: POP
// if not tmp then
42795: LD_VAR 0 6
42799: NOT
42800: IFFALSE 42804
// continue ;
42802: GO 41946
// if places then
42804: LD_VAR 0 5
42808: IFFALSE 42867
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42810: LD_ADDR_EXP 130
42814: PUSH
42815: LD_EXP 130
42819: PPUSH
42820: LD_VAR 0 2
42824: PPUSH
42825: LD_EXP 130
42829: PUSH
42830: LD_VAR 0 2
42834: ARRAY
42835: PUSH
42836: LD_VAR 0 6
42840: PUSH
42841: LD_INT 1
42843: ARRAY
42844: UNION
42845: PPUSH
42846: CALL_OW 1
42850: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42851: LD_VAR 0 6
42855: PUSH
42856: LD_INT 1
42858: ARRAY
42859: PPUSH
42860: LD_INT 126
42862: PPUSH
42863: CALL_OW 109
// end ; end ;
42867: GO 41946
42869: POP
42870: POP
// end ;
42871: LD_VAR 0 1
42875: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42876: LD_INT 0
42878: PPUSH
42879: PPUSH
42880: PPUSH
42881: PPUSH
42882: PPUSH
42883: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42884: LD_VAR 0 1
42888: NOT
42889: PUSH
42890: LD_VAR 0 2
42894: NOT
42895: OR
42896: PUSH
42897: LD_VAR 0 3
42901: NOT
42902: OR
42903: PUSH
42904: LD_VAR 0 4
42908: PUSH
42909: LD_INT 1
42911: PUSH
42912: LD_INT 2
42914: PUSH
42915: LD_INT 3
42917: PUSH
42918: LD_INT 4
42920: PUSH
42921: LD_INT 5
42923: PUSH
42924: LD_INT 8
42926: PUSH
42927: LD_INT 9
42929: PUSH
42930: LD_INT 15
42932: PUSH
42933: LD_INT 16
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: IN
42947: NOT
42948: OR
42949: IFFALSE 42953
// exit ;
42951: GO 43853
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42953: LD_ADDR_VAR 0 2
42957: PUSH
42958: LD_VAR 0 2
42962: PPUSH
42963: LD_INT 21
42965: PUSH
42966: LD_INT 3
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 24
42975: PUSH
42976: LD_INT 250
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PPUSH
42987: CALL_OW 72
42991: ST_TO_ADDR
// case class of 1 , 15 :
42992: LD_VAR 0 4
42996: PUSH
42997: LD_INT 1
42999: DOUBLE
43000: EQUAL
43001: IFTRUE 43011
43003: LD_INT 15
43005: DOUBLE
43006: EQUAL
43007: IFTRUE 43011
43009: GO 43096
43011: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43012: LD_ADDR_VAR 0 8
43016: PUSH
43017: LD_VAR 0 2
43021: PPUSH
43022: LD_INT 2
43024: PUSH
43025: LD_INT 30
43027: PUSH
43028: LD_INT 32
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 30
43037: PUSH
43038: LD_INT 31
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: LIST
43049: PPUSH
43050: CALL_OW 72
43054: PUSH
43055: LD_VAR 0 2
43059: PPUSH
43060: LD_INT 2
43062: PUSH
43063: LD_INT 30
43065: PUSH
43066: LD_INT 4
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 30
43075: PUSH
43076: LD_INT 5
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: LIST
43087: PPUSH
43088: CALL_OW 72
43092: ADD
43093: ST_TO_ADDR
43094: GO 43342
43096: LD_INT 2
43098: DOUBLE
43099: EQUAL
43100: IFTRUE 43110
43102: LD_INT 16
43104: DOUBLE
43105: EQUAL
43106: IFTRUE 43110
43108: GO 43156
43110: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43111: LD_ADDR_VAR 0 8
43115: PUSH
43116: LD_VAR 0 2
43120: PPUSH
43121: LD_INT 2
43123: PUSH
43124: LD_INT 30
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 30
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: PPUSH
43149: CALL_OW 72
43153: ST_TO_ADDR
43154: GO 43342
43156: LD_INT 3
43158: DOUBLE
43159: EQUAL
43160: IFTRUE 43164
43162: GO 43210
43164: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43165: LD_ADDR_VAR 0 8
43169: PUSH
43170: LD_VAR 0 2
43174: PPUSH
43175: LD_INT 2
43177: PUSH
43178: LD_INT 30
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 30
43190: PUSH
43191: LD_INT 3
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: LIST
43202: PPUSH
43203: CALL_OW 72
43207: ST_TO_ADDR
43208: GO 43342
43210: LD_INT 4
43212: DOUBLE
43213: EQUAL
43214: IFTRUE 43218
43216: GO 43275
43218: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43219: LD_ADDR_VAR 0 8
43223: PUSH
43224: LD_VAR 0 2
43228: PPUSH
43229: LD_INT 2
43231: PUSH
43232: LD_INT 30
43234: PUSH
43235: LD_INT 6
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 30
43244: PUSH
43245: LD_INT 7
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 30
43254: PUSH
43255: LD_INT 8
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: PPUSH
43268: CALL_OW 72
43272: ST_TO_ADDR
43273: GO 43342
43275: LD_INT 5
43277: DOUBLE
43278: EQUAL
43279: IFTRUE 43295
43281: LD_INT 8
43283: DOUBLE
43284: EQUAL
43285: IFTRUE 43295
43287: LD_INT 9
43289: DOUBLE
43290: EQUAL
43291: IFTRUE 43295
43293: GO 43341
43295: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43296: LD_ADDR_VAR 0 8
43300: PUSH
43301: LD_VAR 0 2
43305: PPUSH
43306: LD_INT 2
43308: PUSH
43309: LD_INT 30
43311: PUSH
43312: LD_INT 4
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 30
43321: PUSH
43322: LD_INT 5
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: LIST
43333: PPUSH
43334: CALL_OW 72
43338: ST_TO_ADDR
43339: GO 43342
43341: POP
// if not tmp then
43342: LD_VAR 0 8
43346: NOT
43347: IFFALSE 43351
// exit ;
43349: GO 43853
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43351: LD_VAR 0 4
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: LD_INT 15
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: IN
43366: PUSH
43367: LD_EXP 99
43371: PUSH
43372: LD_VAR 0 1
43376: ARRAY
43377: AND
43378: IFFALSE 43534
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43380: LD_ADDR_VAR 0 9
43384: PUSH
43385: LD_EXP 99
43389: PUSH
43390: LD_VAR 0 1
43394: ARRAY
43395: PUSH
43396: LD_INT 1
43398: ARRAY
43399: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43400: LD_VAR 0 9
43404: PUSH
43405: LD_EXP 100
43409: PUSH
43410: LD_VAR 0 1
43414: ARRAY
43415: IN
43416: NOT
43417: IFFALSE 43532
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43419: LD_ADDR_EXP 100
43423: PUSH
43424: LD_EXP 100
43428: PPUSH
43429: LD_VAR 0 1
43433: PUSH
43434: LD_EXP 100
43438: PUSH
43439: LD_VAR 0 1
43443: ARRAY
43444: PUSH
43445: LD_INT 1
43447: PLUS
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PPUSH
43453: LD_VAR 0 9
43457: PPUSH
43458: CALL 55792 0 3
43462: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43463: LD_ADDR_EXP 99
43467: PUSH
43468: LD_EXP 99
43472: PPUSH
43473: LD_VAR 0 1
43477: PPUSH
43478: LD_EXP 99
43482: PUSH
43483: LD_VAR 0 1
43487: ARRAY
43488: PUSH
43489: LD_VAR 0 9
43493: DIFF
43494: PPUSH
43495: CALL_OW 1
43499: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43500: LD_VAR 0 3
43504: PPUSH
43505: LD_EXP 100
43509: PUSH
43510: LD_VAR 0 1
43514: ARRAY
43515: PUSH
43516: LD_EXP 100
43520: PUSH
43521: LD_VAR 0 1
43525: ARRAY
43526: ARRAY
43527: PPUSH
43528: CALL_OW 120
// end ; exit ;
43532: GO 43853
// end ; if tmp > 1 then
43534: LD_VAR 0 8
43538: PUSH
43539: LD_INT 1
43541: GREATER
43542: IFFALSE 43646
// for i = 2 to tmp do
43544: LD_ADDR_VAR 0 6
43548: PUSH
43549: DOUBLE
43550: LD_INT 2
43552: DEC
43553: ST_TO_ADDR
43554: LD_VAR 0 8
43558: PUSH
43559: FOR_TO
43560: IFFALSE 43644
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43562: LD_VAR 0 8
43566: PUSH
43567: LD_VAR 0 6
43571: ARRAY
43572: PPUSH
43573: CALL_OW 461
43577: PUSH
43578: LD_INT 6
43580: EQUAL
43581: IFFALSE 43642
// begin x := tmp [ i ] ;
43583: LD_ADDR_VAR 0 9
43587: PUSH
43588: LD_VAR 0 8
43592: PUSH
43593: LD_VAR 0 6
43597: ARRAY
43598: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43599: LD_ADDR_VAR 0 8
43603: PUSH
43604: LD_VAR 0 8
43608: PPUSH
43609: LD_VAR 0 6
43613: PPUSH
43614: CALL_OW 3
43618: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43619: LD_ADDR_VAR 0 8
43623: PUSH
43624: LD_VAR 0 8
43628: PPUSH
43629: LD_INT 1
43631: PPUSH
43632: LD_VAR 0 9
43636: PPUSH
43637: CALL_OW 2
43641: ST_TO_ADDR
// end ;
43642: GO 43559
43644: POP
43645: POP
// for i in tmp do
43646: LD_ADDR_VAR 0 6
43650: PUSH
43651: LD_VAR 0 8
43655: PUSH
43656: FOR_IN
43657: IFFALSE 43726
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43659: LD_VAR 0 6
43663: PPUSH
43664: CALL_OW 313
43668: PUSH
43669: LD_INT 6
43671: LESS
43672: PUSH
43673: LD_VAR 0 6
43677: PPUSH
43678: CALL_OW 266
43682: PUSH
43683: LD_INT 31
43685: PUSH
43686: LD_INT 32
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: IN
43693: NOT
43694: AND
43695: PUSH
43696: LD_VAR 0 6
43700: PPUSH
43701: CALL_OW 313
43705: PUSH
43706: LD_INT 0
43708: EQUAL
43709: OR
43710: IFFALSE 43724
// begin j := i ;
43712: LD_ADDR_VAR 0 7
43716: PUSH
43717: LD_VAR 0 6
43721: ST_TO_ADDR
// break ;
43722: GO 43726
// end ; end ;
43724: GO 43656
43726: POP
43727: POP
// if j then
43728: LD_VAR 0 7
43732: IFFALSE 43750
// ComEnterUnit ( unit , j ) else
43734: LD_VAR 0 3
43738: PPUSH
43739: LD_VAR 0 7
43743: PPUSH
43744: CALL_OW 120
43748: GO 43853
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43750: LD_ADDR_VAR 0 10
43754: PUSH
43755: LD_VAR 0 2
43759: PPUSH
43760: LD_INT 2
43762: PUSH
43763: LD_INT 30
43765: PUSH
43766: LD_INT 0
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 30
43775: PUSH
43776: LD_INT 1
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: LIST
43787: PPUSH
43788: CALL_OW 72
43792: ST_TO_ADDR
// if depot then
43793: LD_VAR 0 10
43797: IFFALSE 43853
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43799: LD_ADDR_VAR 0 10
43803: PUSH
43804: LD_VAR 0 10
43808: PPUSH
43809: LD_VAR 0 3
43813: PPUSH
43814: CALL_OW 74
43818: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43819: LD_VAR 0 3
43823: PPUSH
43824: LD_VAR 0 10
43828: PPUSH
43829: CALL_OW 296
43833: PUSH
43834: LD_INT 10
43836: GREATER
43837: IFFALSE 43853
// ComStandNearbyBuilding ( unit , depot ) ;
43839: LD_VAR 0 3
43843: PPUSH
43844: LD_VAR 0 10
43848: PPUSH
43849: CALL 52406 0 2
// end ; end ; end ;
43853: LD_VAR 0 5
43857: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43858: LD_INT 0
43860: PPUSH
43861: PPUSH
43862: PPUSH
43863: PPUSH
// if not mc_bases then
43864: LD_EXP 90
43868: NOT
43869: IFFALSE 43873
// exit ;
43871: GO 44112
// for i = 1 to mc_bases do
43873: LD_ADDR_VAR 0 2
43877: PUSH
43878: DOUBLE
43879: LD_INT 1
43881: DEC
43882: ST_TO_ADDR
43883: LD_EXP 90
43887: PUSH
43888: FOR_TO
43889: IFFALSE 44110
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43891: LD_ADDR_VAR 0 4
43895: PUSH
43896: LD_EXP 90
43900: PUSH
43901: LD_VAR 0 2
43905: ARRAY
43906: PPUSH
43907: LD_INT 21
43909: PUSH
43910: LD_INT 1
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PPUSH
43917: CALL_OW 72
43921: PUSH
43922: LD_EXP 119
43926: PUSH
43927: LD_VAR 0 2
43931: ARRAY
43932: UNION
43933: ST_TO_ADDR
// if not tmp then
43934: LD_VAR 0 4
43938: NOT
43939: IFFALSE 43943
// continue ;
43941: GO 43888
// for j in tmp do
43943: LD_ADDR_VAR 0 3
43947: PUSH
43948: LD_VAR 0 4
43952: PUSH
43953: FOR_IN
43954: IFFALSE 44106
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43956: LD_VAR 0 3
43960: PPUSH
43961: CALL_OW 110
43965: NOT
43966: PUSH
43967: LD_VAR 0 3
43971: PPUSH
43972: CALL_OW 314
43976: NOT
43977: AND
43978: PUSH
43979: LD_VAR 0 3
43983: PPUSH
43984: CALL_OW 311
43988: NOT
43989: AND
43990: PUSH
43991: LD_VAR 0 3
43995: PPUSH
43996: CALL_OW 310
44000: NOT
44001: AND
44002: PUSH
44003: LD_VAR 0 3
44007: PUSH
44008: LD_EXP 93
44012: PUSH
44013: LD_VAR 0 2
44017: ARRAY
44018: PUSH
44019: LD_INT 1
44021: ARRAY
44022: IN
44023: NOT
44024: AND
44025: PUSH
44026: LD_VAR 0 3
44030: PUSH
44031: LD_EXP 93
44035: PUSH
44036: LD_VAR 0 2
44040: ARRAY
44041: PUSH
44042: LD_INT 2
44044: ARRAY
44045: IN
44046: NOT
44047: AND
44048: PUSH
44049: LD_VAR 0 3
44053: PUSH
44054: LD_EXP 102
44058: PUSH
44059: LD_VAR 0 2
44063: ARRAY
44064: IN
44065: NOT
44066: AND
44067: IFFALSE 44104
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44069: LD_VAR 0 2
44073: PPUSH
44074: LD_EXP 90
44078: PUSH
44079: LD_VAR 0 2
44083: ARRAY
44084: PPUSH
44085: LD_VAR 0 3
44089: PPUSH
44090: LD_VAR 0 3
44094: PPUSH
44095: CALL_OW 257
44099: PPUSH
44100: CALL 42876 0 4
// end ;
44104: GO 43953
44106: POP
44107: POP
// end ;
44108: GO 43888
44110: POP
44111: POP
// end ;
44112: LD_VAR 0 1
44116: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44117: LD_INT 0
44119: PPUSH
44120: PPUSH
44121: PPUSH
44122: PPUSH
44123: PPUSH
44124: PPUSH
// if not mc_bases [ base ] then
44125: LD_EXP 90
44129: PUSH
44130: LD_VAR 0 1
44134: ARRAY
44135: NOT
44136: IFFALSE 44140
// exit ;
44138: GO 44322
// tmp := [ ] ;
44140: LD_ADDR_VAR 0 6
44144: PUSH
44145: EMPTY
44146: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44147: LD_ADDR_VAR 0 7
44151: PUSH
44152: LD_VAR 0 3
44156: PPUSH
44157: LD_INT 0
44159: PPUSH
44160: CALL_OW 517
44164: ST_TO_ADDR
// if not list then
44165: LD_VAR 0 7
44169: NOT
44170: IFFALSE 44174
// exit ;
44172: GO 44322
// for i = 1 to amount do
44174: LD_ADDR_VAR 0 5
44178: PUSH
44179: DOUBLE
44180: LD_INT 1
44182: DEC
44183: ST_TO_ADDR
44184: LD_VAR 0 2
44188: PUSH
44189: FOR_TO
44190: IFFALSE 44270
// begin x := rand ( 1 , list [ 1 ] ) ;
44192: LD_ADDR_VAR 0 8
44196: PUSH
44197: LD_INT 1
44199: PPUSH
44200: LD_VAR 0 7
44204: PUSH
44205: LD_INT 1
44207: ARRAY
44208: PPUSH
44209: CALL_OW 12
44213: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44214: LD_ADDR_VAR 0 6
44218: PUSH
44219: LD_VAR 0 6
44223: PPUSH
44224: LD_VAR 0 5
44228: PPUSH
44229: LD_VAR 0 7
44233: PUSH
44234: LD_INT 1
44236: ARRAY
44237: PUSH
44238: LD_VAR 0 8
44242: ARRAY
44243: PUSH
44244: LD_VAR 0 7
44248: PUSH
44249: LD_INT 2
44251: ARRAY
44252: PUSH
44253: LD_VAR 0 8
44257: ARRAY
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PPUSH
44263: CALL_OW 1
44267: ST_TO_ADDR
// end ;
44268: GO 44189
44270: POP
44271: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44272: LD_ADDR_EXP 103
44276: PUSH
44277: LD_EXP 103
44281: PPUSH
44282: LD_VAR 0 1
44286: PPUSH
44287: LD_VAR 0 6
44291: PPUSH
44292: CALL_OW 1
44296: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44297: LD_ADDR_EXP 105
44301: PUSH
44302: LD_EXP 105
44306: PPUSH
44307: LD_VAR 0 1
44311: PPUSH
44312: LD_VAR 0 3
44316: PPUSH
44317: CALL_OW 1
44321: ST_TO_ADDR
// end ;
44322: LD_VAR 0 4
44326: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44327: LD_INT 0
44329: PPUSH
// if not mc_bases [ base ] then
44330: LD_EXP 90
44334: PUSH
44335: LD_VAR 0 1
44339: ARRAY
44340: NOT
44341: IFFALSE 44345
// exit ;
44343: GO 44370
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44345: LD_ADDR_EXP 95
44349: PUSH
44350: LD_EXP 95
44354: PPUSH
44355: LD_VAR 0 1
44359: PPUSH
44360: LD_VAR 0 2
44364: PPUSH
44365: CALL_OW 1
44369: ST_TO_ADDR
// end ;
44370: LD_VAR 0 3
44374: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44375: LD_INT 0
44377: PPUSH
// if not mc_bases [ base ] then
44378: LD_EXP 90
44382: PUSH
44383: LD_VAR 0 1
44387: ARRAY
44388: NOT
44389: IFFALSE 44393
// exit ;
44391: GO 44430
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44393: LD_ADDR_EXP 95
44397: PUSH
44398: LD_EXP 95
44402: PPUSH
44403: LD_VAR 0 1
44407: PPUSH
44408: LD_EXP 95
44412: PUSH
44413: LD_VAR 0 1
44417: ARRAY
44418: PUSH
44419: LD_VAR 0 2
44423: UNION
44424: PPUSH
44425: CALL_OW 1
44429: ST_TO_ADDR
// end ;
44430: LD_VAR 0 3
44434: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44435: LD_INT 0
44437: PPUSH
// if not mc_bases [ base ] then
44438: LD_EXP 90
44442: PUSH
44443: LD_VAR 0 1
44447: ARRAY
44448: NOT
44449: IFFALSE 44453
// exit ;
44451: GO 44478
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44453: LD_ADDR_EXP 111
44457: PUSH
44458: LD_EXP 111
44462: PPUSH
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 2
44472: PPUSH
44473: CALL_OW 1
44477: ST_TO_ADDR
// end ;
44478: LD_VAR 0 3
44482: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44483: LD_INT 0
44485: PPUSH
// if not mc_bases [ base ] then
44486: LD_EXP 90
44490: PUSH
44491: LD_VAR 0 1
44495: ARRAY
44496: NOT
44497: IFFALSE 44501
// exit ;
44499: GO 44538
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44501: LD_ADDR_EXP 111
44505: PUSH
44506: LD_EXP 111
44510: PPUSH
44511: LD_VAR 0 1
44515: PPUSH
44516: LD_EXP 111
44520: PUSH
44521: LD_VAR 0 1
44525: ARRAY
44526: PUSH
44527: LD_VAR 0 2
44531: ADD
44532: PPUSH
44533: CALL_OW 1
44537: ST_TO_ADDR
// end ;
44538: LD_VAR 0 3
44542: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44543: LD_INT 0
44545: PPUSH
// if not mc_bases [ base ] then
44546: LD_EXP 90
44550: PUSH
44551: LD_VAR 0 1
44555: ARRAY
44556: NOT
44557: IFFALSE 44561
// exit ;
44559: GO 44615
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44561: LD_ADDR_EXP 112
44565: PUSH
44566: LD_EXP 112
44570: PPUSH
44571: LD_VAR 0 1
44575: PPUSH
44576: LD_VAR 0 2
44580: PPUSH
44581: CALL_OW 1
44585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44586: LD_ADDR_EXP 101
44590: PUSH
44591: LD_EXP 101
44595: PPUSH
44596: LD_VAR 0 1
44600: PPUSH
44601: LD_VAR 0 2
44605: PUSH
44606: LD_INT 0
44608: PLUS
44609: PPUSH
44610: CALL_OW 1
44614: ST_TO_ADDR
// end ;
44615: LD_VAR 0 3
44619: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44620: LD_INT 0
44622: PPUSH
// if not mc_bases [ base ] then
44623: LD_EXP 90
44627: PUSH
44628: LD_VAR 0 1
44632: ARRAY
44633: NOT
44634: IFFALSE 44638
// exit ;
44636: GO 44663
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44638: LD_ADDR_EXP 101
44642: PUSH
44643: LD_EXP 101
44647: PPUSH
44648: LD_VAR 0 1
44652: PPUSH
44653: LD_VAR 0 2
44657: PPUSH
44658: CALL_OW 1
44662: ST_TO_ADDR
// end ;
44663: LD_VAR 0 3
44667: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44668: LD_INT 0
44670: PPUSH
44671: PPUSH
44672: PPUSH
44673: PPUSH
// if not mc_bases [ base ] then
44674: LD_EXP 90
44678: PUSH
44679: LD_VAR 0 1
44683: ARRAY
44684: NOT
44685: IFFALSE 44689
// exit ;
44687: GO 44754
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44689: LD_ADDR_EXP 110
44693: PUSH
44694: LD_EXP 110
44698: PPUSH
44699: LD_VAR 0 1
44703: PUSH
44704: LD_EXP 110
44708: PUSH
44709: LD_VAR 0 1
44713: ARRAY
44714: PUSH
44715: LD_INT 1
44717: PLUS
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PPUSH
44723: LD_VAR 0 1
44727: PUSH
44728: LD_VAR 0 2
44732: PUSH
44733: LD_VAR 0 3
44737: PUSH
44738: LD_VAR 0 4
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: PPUSH
44749: CALL 55792 0 3
44753: ST_TO_ADDR
// end ;
44754: LD_VAR 0 5
44758: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44759: LD_INT 0
44761: PPUSH
// if not mc_bases [ base ] then
44762: LD_EXP 90
44766: PUSH
44767: LD_VAR 0 1
44771: ARRAY
44772: NOT
44773: IFFALSE 44777
// exit ;
44775: GO 44802
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44777: LD_ADDR_EXP 127
44781: PUSH
44782: LD_EXP 127
44786: PPUSH
44787: LD_VAR 0 1
44791: PPUSH
44792: LD_VAR 0 2
44796: PPUSH
44797: CALL_OW 1
44801: ST_TO_ADDR
// end ;
44802: LD_VAR 0 3
44806: RET
// export function MC_GetMinesField ( base ) ; begin
44807: LD_INT 0
44809: PPUSH
// result := mc_mines [ base ] ;
44810: LD_ADDR_VAR 0 2
44814: PUSH
44815: LD_EXP 103
44819: PUSH
44820: LD_VAR 0 1
44824: ARRAY
44825: ST_TO_ADDR
// end ;
44826: LD_VAR 0 2
44830: RET
// export function MC_GetProduceList ( base ) ; begin
44831: LD_INT 0
44833: PPUSH
// result := mc_produce [ base ] ;
44834: LD_ADDR_VAR 0 2
44838: PUSH
44839: LD_EXP 111
44843: PUSH
44844: LD_VAR 0 1
44848: ARRAY
44849: ST_TO_ADDR
// end ;
44850: LD_VAR 0 2
44854: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44855: LD_INT 0
44857: PPUSH
44858: PPUSH
// if not mc_bases then
44859: LD_EXP 90
44863: NOT
44864: IFFALSE 44868
// exit ;
44866: GO 44933
// if mc_bases [ base ] then
44868: LD_EXP 90
44872: PUSH
44873: LD_VAR 0 1
44877: ARRAY
44878: IFFALSE 44933
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44880: LD_ADDR_VAR 0 3
44884: PUSH
44885: LD_EXP 90
44889: PUSH
44890: LD_VAR 0 1
44894: ARRAY
44895: PPUSH
44896: LD_INT 30
44898: PUSH
44899: LD_VAR 0 2
44903: PUSH
44904: EMPTY
44905: LIST
44906: LIST
44907: PPUSH
44908: CALL_OW 72
44912: ST_TO_ADDR
// if result then
44913: LD_VAR 0 3
44917: IFFALSE 44933
// result := result [ 1 ] ;
44919: LD_ADDR_VAR 0 3
44923: PUSH
44924: LD_VAR 0 3
44928: PUSH
44929: LD_INT 1
44931: ARRAY
44932: ST_TO_ADDR
// end ; end ;
44933: LD_VAR 0 3
44937: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44938: LD_INT 0
44940: PPUSH
44941: PPUSH
// if not mc_bases then
44942: LD_EXP 90
44946: NOT
44947: IFFALSE 44951
// exit ;
44949: GO 44996
// if mc_bases [ base ] then
44951: LD_EXP 90
44955: PUSH
44956: LD_VAR 0 1
44960: ARRAY
44961: IFFALSE 44996
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44963: LD_ADDR_VAR 0 3
44967: PUSH
44968: LD_EXP 90
44972: PUSH
44973: LD_VAR 0 1
44977: ARRAY
44978: PPUSH
44979: LD_INT 30
44981: PUSH
44982: LD_VAR 0 2
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PPUSH
44991: CALL_OW 72
44995: ST_TO_ADDR
// end ;
44996: LD_VAR 0 3
45000: RET
// export function MC_SetTame ( base , area ) ; begin
45001: LD_INT 0
45003: PPUSH
// if not mc_bases or not base then
45004: LD_EXP 90
45008: NOT
45009: PUSH
45010: LD_VAR 0 1
45014: NOT
45015: OR
45016: IFFALSE 45020
// exit ;
45018: GO 45045
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45020: LD_ADDR_EXP 118
45024: PUSH
45025: LD_EXP 118
45029: PPUSH
45030: LD_VAR 0 1
45034: PPUSH
45035: LD_VAR 0 2
45039: PPUSH
45040: CALL_OW 1
45044: ST_TO_ADDR
// end ;
45045: LD_VAR 0 3
45049: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45050: LD_INT 0
45052: PPUSH
45053: PPUSH
// if not mc_bases or not base then
45054: LD_EXP 90
45058: NOT
45059: PUSH
45060: LD_VAR 0 1
45064: NOT
45065: OR
45066: IFFALSE 45070
// exit ;
45068: GO 45172
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45070: LD_ADDR_VAR 0 4
45074: PUSH
45075: LD_EXP 90
45079: PUSH
45080: LD_VAR 0 1
45084: ARRAY
45085: PPUSH
45086: LD_INT 30
45088: PUSH
45089: LD_VAR 0 2
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: PPUSH
45098: CALL_OW 72
45102: ST_TO_ADDR
// if not tmp then
45103: LD_VAR 0 4
45107: NOT
45108: IFFALSE 45112
// exit ;
45110: GO 45172
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45112: LD_ADDR_EXP 122
45116: PUSH
45117: LD_EXP 122
45121: PPUSH
45122: LD_VAR 0 1
45126: PPUSH
45127: LD_EXP 122
45131: PUSH
45132: LD_VAR 0 1
45136: ARRAY
45137: PPUSH
45138: LD_EXP 122
45142: PUSH
45143: LD_VAR 0 1
45147: ARRAY
45148: PUSH
45149: LD_INT 1
45151: PLUS
45152: PPUSH
45153: LD_VAR 0 4
45157: PUSH
45158: LD_INT 1
45160: ARRAY
45161: PPUSH
45162: CALL_OW 2
45166: PPUSH
45167: CALL_OW 1
45171: ST_TO_ADDR
// end ;
45172: LD_VAR 0 3
45176: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45177: LD_INT 0
45179: PPUSH
45180: PPUSH
// if not mc_bases or not base or not kinds then
45181: LD_EXP 90
45185: NOT
45186: PUSH
45187: LD_VAR 0 1
45191: NOT
45192: OR
45193: PUSH
45194: LD_VAR 0 2
45198: NOT
45199: OR
45200: IFFALSE 45204
// exit ;
45202: GO 45265
// for i in kinds do
45204: LD_ADDR_VAR 0 4
45208: PUSH
45209: LD_VAR 0 2
45213: PUSH
45214: FOR_IN
45215: IFFALSE 45263
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45217: LD_ADDR_EXP 124
45221: PUSH
45222: LD_EXP 124
45226: PPUSH
45227: LD_VAR 0 1
45231: PUSH
45232: LD_EXP 124
45236: PUSH
45237: LD_VAR 0 1
45241: ARRAY
45242: PUSH
45243: LD_INT 1
45245: PLUS
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PPUSH
45251: LD_VAR 0 4
45255: PPUSH
45256: CALL 55792 0 3
45260: ST_TO_ADDR
45261: GO 45214
45263: POP
45264: POP
// end ;
45265: LD_VAR 0 3
45269: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45270: LD_INT 0
45272: PPUSH
// if not mc_bases or not base or not areas then
45273: LD_EXP 90
45277: NOT
45278: PUSH
45279: LD_VAR 0 1
45283: NOT
45284: OR
45285: PUSH
45286: LD_VAR 0 2
45290: NOT
45291: OR
45292: IFFALSE 45296
// exit ;
45294: GO 45321
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45296: LD_ADDR_EXP 108
45300: PUSH
45301: LD_EXP 108
45305: PPUSH
45306: LD_VAR 0 1
45310: PPUSH
45311: LD_VAR 0 2
45315: PPUSH
45316: CALL_OW 1
45320: ST_TO_ADDR
// end ;
45321: LD_VAR 0 3
45325: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45326: LD_INT 0
45328: PPUSH
// if not mc_bases or not base or not teleports_exit then
45329: LD_EXP 90
45333: NOT
45334: PUSH
45335: LD_VAR 0 1
45339: NOT
45340: OR
45341: PUSH
45342: LD_VAR 0 2
45346: NOT
45347: OR
45348: IFFALSE 45352
// exit ;
45350: GO 45377
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45352: LD_ADDR_EXP 125
45356: PUSH
45357: LD_EXP 125
45361: PPUSH
45362: LD_VAR 0 1
45366: PPUSH
45367: LD_VAR 0 2
45371: PPUSH
45372: CALL_OW 1
45376: ST_TO_ADDR
// end ;
45377: LD_VAR 0 3
45381: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45382: LD_INT 0
45384: PPUSH
45385: PPUSH
45386: PPUSH
// if not mc_bases or not base or not ext_list then
45387: LD_EXP 90
45391: NOT
45392: PUSH
45393: LD_VAR 0 1
45397: NOT
45398: OR
45399: PUSH
45400: LD_VAR 0 5
45404: NOT
45405: OR
45406: IFFALSE 45410
// exit ;
45408: GO 45583
// tmp := GetFacExtXYD ( x , y , d ) ;
45410: LD_ADDR_VAR 0 8
45414: PUSH
45415: LD_VAR 0 2
45419: PPUSH
45420: LD_VAR 0 3
45424: PPUSH
45425: LD_VAR 0 4
45429: PPUSH
45430: CALL 84471 0 3
45434: ST_TO_ADDR
// if not tmp then
45435: LD_VAR 0 8
45439: NOT
45440: IFFALSE 45444
// exit ;
45442: GO 45583
// for i in tmp do
45444: LD_ADDR_VAR 0 7
45448: PUSH
45449: LD_VAR 0 8
45453: PUSH
45454: FOR_IN
45455: IFFALSE 45581
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45457: LD_ADDR_EXP 95
45461: PUSH
45462: LD_EXP 95
45466: PPUSH
45467: LD_VAR 0 1
45471: PPUSH
45472: LD_EXP 95
45476: PUSH
45477: LD_VAR 0 1
45481: ARRAY
45482: PPUSH
45483: LD_EXP 95
45487: PUSH
45488: LD_VAR 0 1
45492: ARRAY
45493: PUSH
45494: LD_INT 1
45496: PLUS
45497: PPUSH
45498: LD_VAR 0 5
45502: PUSH
45503: LD_INT 1
45505: ARRAY
45506: PUSH
45507: LD_VAR 0 7
45511: PUSH
45512: LD_INT 1
45514: ARRAY
45515: PUSH
45516: LD_VAR 0 7
45520: PUSH
45521: LD_INT 2
45523: ARRAY
45524: PUSH
45525: LD_VAR 0 7
45529: PUSH
45530: LD_INT 3
45532: ARRAY
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: PPUSH
45540: CALL_OW 2
45544: PPUSH
45545: CALL_OW 1
45549: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45550: LD_ADDR_VAR 0 5
45554: PUSH
45555: LD_VAR 0 5
45559: PPUSH
45560: LD_INT 1
45562: PPUSH
45563: CALL_OW 3
45567: ST_TO_ADDR
// if not ext_list then
45568: LD_VAR 0 5
45572: NOT
45573: IFFALSE 45579
// exit ;
45575: POP
45576: POP
45577: GO 45583
// end ;
45579: GO 45454
45581: POP
45582: POP
// end ;
45583: LD_VAR 0 6
45587: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45588: LD_INT 0
45590: PPUSH
// if not mc_bases or not base or not weapon_list then
45591: LD_EXP 90
45595: NOT
45596: PUSH
45597: LD_VAR 0 1
45601: NOT
45602: OR
45603: PUSH
45604: LD_VAR 0 2
45608: NOT
45609: OR
45610: IFFALSE 45614
// exit ;
45612: GO 45639
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45614: LD_ADDR_EXP 129
45618: PUSH
45619: LD_EXP 129
45623: PPUSH
45624: LD_VAR 0 1
45628: PPUSH
45629: LD_VAR 0 2
45633: PPUSH
45634: CALL_OW 1
45638: ST_TO_ADDR
// end ;
45639: LD_VAR 0 3
45643: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45644: LD_INT 0
45646: PPUSH
// if not mc_bases or not base or not tech_list then
45647: LD_EXP 90
45651: NOT
45652: PUSH
45653: LD_VAR 0 1
45657: NOT
45658: OR
45659: PUSH
45660: LD_VAR 0 2
45664: NOT
45665: OR
45666: IFFALSE 45670
// exit ;
45668: GO 45695
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45670: LD_ADDR_EXP 117
45674: PUSH
45675: LD_EXP 117
45679: PPUSH
45680: LD_VAR 0 1
45684: PPUSH
45685: LD_VAR 0 2
45689: PPUSH
45690: CALL_OW 1
45694: ST_TO_ADDR
// end ;
45695: LD_VAR 0 3
45699: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45700: LD_INT 0
45702: PPUSH
// if not mc_bases or not parking_area or not base then
45703: LD_EXP 90
45707: NOT
45708: PUSH
45709: LD_VAR 0 2
45713: NOT
45714: OR
45715: PUSH
45716: LD_VAR 0 1
45720: NOT
45721: OR
45722: IFFALSE 45726
// exit ;
45724: GO 45751
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45726: LD_ADDR_EXP 114
45730: PUSH
45731: LD_EXP 114
45735: PPUSH
45736: LD_VAR 0 1
45740: PPUSH
45741: LD_VAR 0 2
45745: PPUSH
45746: CALL_OW 1
45750: ST_TO_ADDR
// end ;
45751: LD_VAR 0 3
45755: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45756: LD_INT 0
45758: PPUSH
// if not mc_bases or not base or not scan_area then
45759: LD_EXP 90
45763: NOT
45764: PUSH
45765: LD_VAR 0 1
45769: NOT
45770: OR
45771: PUSH
45772: LD_VAR 0 2
45776: NOT
45777: OR
45778: IFFALSE 45782
// exit ;
45780: GO 45807
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45782: LD_ADDR_EXP 115
45786: PUSH
45787: LD_EXP 115
45791: PPUSH
45792: LD_VAR 0 1
45796: PPUSH
45797: LD_VAR 0 2
45801: PPUSH
45802: CALL_OW 1
45806: ST_TO_ADDR
// end ;
45807: LD_VAR 0 3
45811: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45812: LD_INT 0
45814: PPUSH
45815: PPUSH
// if not mc_bases or not base then
45816: LD_EXP 90
45820: NOT
45821: PUSH
45822: LD_VAR 0 1
45826: NOT
45827: OR
45828: IFFALSE 45832
// exit ;
45830: GO 45896
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45832: LD_ADDR_VAR 0 3
45836: PUSH
45837: LD_INT 1
45839: PUSH
45840: LD_INT 2
45842: PUSH
45843: LD_INT 3
45845: PUSH
45846: LD_INT 4
45848: PUSH
45849: LD_INT 11
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45859: LD_ADDR_EXP 117
45863: PUSH
45864: LD_EXP 117
45868: PPUSH
45869: LD_VAR 0 1
45873: PPUSH
45874: LD_EXP 117
45878: PUSH
45879: LD_VAR 0 1
45883: ARRAY
45884: PUSH
45885: LD_VAR 0 3
45889: DIFF
45890: PPUSH
45891: CALL_OW 1
45895: ST_TO_ADDR
// end ;
45896: LD_VAR 0 2
45900: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45901: LD_INT 0
45903: PPUSH
// result := mc_vehicles [ base ] ;
45904: LD_ADDR_VAR 0 3
45908: PUSH
45909: LD_EXP 109
45913: PUSH
45914: LD_VAR 0 1
45918: ARRAY
45919: ST_TO_ADDR
// if onlyCombat then
45920: LD_VAR 0 2
45924: IFFALSE 46102
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45926: LD_ADDR_VAR 0 3
45930: PUSH
45931: LD_VAR 0 3
45935: PUSH
45936: LD_VAR 0 3
45940: PPUSH
45941: LD_INT 2
45943: PUSH
45944: LD_INT 34
45946: PUSH
45947: LD_INT 12
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 34
45956: PUSH
45957: LD_INT 51
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 34
45966: PUSH
45967: LD_EXP 73
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 34
45978: PUSH
45979: LD_INT 32
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 34
45988: PUSH
45989: LD_INT 13
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 34
45998: PUSH
45999: LD_INT 52
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 34
46008: PUSH
46009: LD_EXP 78
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 34
46020: PUSH
46021: LD_INT 14
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: PUSH
46028: LD_INT 34
46030: PUSH
46031: LD_INT 53
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: PUSH
46038: LD_INT 34
46040: PUSH
46041: LD_EXP 72
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 34
46052: PUSH
46053: LD_INT 31
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 34
46062: PUSH
46063: LD_INT 48
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 34
46072: PUSH
46073: LD_INT 8
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: PPUSH
46096: CALL_OW 72
46100: DIFF
46101: ST_TO_ADDR
// end ; end_of_file
46102: LD_VAR 0 3
46106: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46107: LD_INT 0
46109: PPUSH
46110: PPUSH
46111: PPUSH
// if not mc_bases or not skirmish then
46112: LD_EXP 90
46116: NOT
46117: PUSH
46118: LD_EXP 88
46122: NOT
46123: OR
46124: IFFALSE 46128
// exit ;
46126: GO 46293
// for i = 1 to mc_bases do
46128: LD_ADDR_VAR 0 4
46132: PUSH
46133: DOUBLE
46134: LD_INT 1
46136: DEC
46137: ST_TO_ADDR
46138: LD_EXP 90
46142: PUSH
46143: FOR_TO
46144: IFFALSE 46291
// begin if sci in mc_bases [ i ] then
46146: LD_VAR 0 2
46150: PUSH
46151: LD_EXP 90
46155: PUSH
46156: LD_VAR 0 4
46160: ARRAY
46161: IN
46162: IFFALSE 46289
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46164: LD_ADDR_EXP 119
46168: PUSH
46169: LD_EXP 119
46173: PPUSH
46174: LD_VAR 0 4
46178: PUSH
46179: LD_EXP 119
46183: PUSH
46184: LD_VAR 0 4
46188: ARRAY
46189: PUSH
46190: LD_INT 1
46192: PLUS
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PPUSH
46198: LD_VAR 0 1
46202: PPUSH
46203: CALL 55792 0 3
46207: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46208: LD_ADDR_VAR 0 5
46212: PUSH
46213: LD_EXP 90
46217: PUSH
46218: LD_VAR 0 4
46222: ARRAY
46223: PPUSH
46224: LD_INT 2
46226: PUSH
46227: LD_INT 30
46229: PUSH
46230: LD_INT 0
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: PUSH
46237: LD_INT 30
46239: PUSH
46240: LD_INT 1
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: LIST
46251: PPUSH
46252: CALL_OW 72
46256: PPUSH
46257: LD_VAR 0 1
46261: PPUSH
46262: CALL_OW 74
46266: ST_TO_ADDR
// if tmp then
46267: LD_VAR 0 5
46271: IFFALSE 46287
// ComStandNearbyBuilding ( ape , tmp ) ;
46273: LD_VAR 0 1
46277: PPUSH
46278: LD_VAR 0 5
46282: PPUSH
46283: CALL 52406 0 2
// break ;
46287: GO 46291
// end ; end ;
46289: GO 46143
46291: POP
46292: POP
// end ;
46293: LD_VAR 0 3
46297: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46298: LD_INT 0
46300: PPUSH
46301: PPUSH
46302: PPUSH
// if not mc_bases or not skirmish then
46303: LD_EXP 90
46307: NOT
46308: PUSH
46309: LD_EXP 88
46313: NOT
46314: OR
46315: IFFALSE 46319
// exit ;
46317: GO 46408
// for i = 1 to mc_bases do
46319: LD_ADDR_VAR 0 4
46323: PUSH
46324: DOUBLE
46325: LD_INT 1
46327: DEC
46328: ST_TO_ADDR
46329: LD_EXP 90
46333: PUSH
46334: FOR_TO
46335: IFFALSE 46406
// begin if building in mc_busy_turret_list [ i ] then
46337: LD_VAR 0 1
46341: PUSH
46342: LD_EXP 100
46346: PUSH
46347: LD_VAR 0 4
46351: ARRAY
46352: IN
46353: IFFALSE 46404
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46355: LD_ADDR_VAR 0 5
46359: PUSH
46360: LD_EXP 100
46364: PUSH
46365: LD_VAR 0 4
46369: ARRAY
46370: PUSH
46371: LD_VAR 0 1
46375: DIFF
46376: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46377: LD_ADDR_EXP 100
46381: PUSH
46382: LD_EXP 100
46386: PPUSH
46387: LD_VAR 0 4
46391: PPUSH
46392: LD_VAR 0 5
46396: PPUSH
46397: CALL_OW 1
46401: ST_TO_ADDR
// break ;
46402: GO 46406
// end ; end ;
46404: GO 46334
46406: POP
46407: POP
// end ;
46408: LD_VAR 0 3
46412: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46413: LD_INT 0
46415: PPUSH
46416: PPUSH
46417: PPUSH
// if not mc_bases or not skirmish then
46418: LD_EXP 90
46422: NOT
46423: PUSH
46424: LD_EXP 88
46428: NOT
46429: OR
46430: IFFALSE 46434
// exit ;
46432: GO 46633
// for i = 1 to mc_bases do
46434: LD_ADDR_VAR 0 5
46438: PUSH
46439: DOUBLE
46440: LD_INT 1
46442: DEC
46443: ST_TO_ADDR
46444: LD_EXP 90
46448: PUSH
46449: FOR_TO
46450: IFFALSE 46631
// if building in mc_bases [ i ] then
46452: LD_VAR 0 1
46456: PUSH
46457: LD_EXP 90
46461: PUSH
46462: LD_VAR 0 5
46466: ARRAY
46467: IN
46468: IFFALSE 46629
// begin tmp := mc_bases [ i ] diff building ;
46470: LD_ADDR_VAR 0 6
46474: PUSH
46475: LD_EXP 90
46479: PUSH
46480: LD_VAR 0 5
46484: ARRAY
46485: PUSH
46486: LD_VAR 0 1
46490: DIFF
46491: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46492: LD_ADDR_EXP 90
46496: PUSH
46497: LD_EXP 90
46501: PPUSH
46502: LD_VAR 0 5
46506: PPUSH
46507: LD_VAR 0 6
46511: PPUSH
46512: CALL_OW 1
46516: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46517: LD_VAR 0 1
46521: PUSH
46522: LD_EXP 98
46526: PUSH
46527: LD_VAR 0 5
46531: ARRAY
46532: IN
46533: IFFALSE 46572
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46535: LD_ADDR_EXP 98
46539: PUSH
46540: LD_EXP 98
46544: PPUSH
46545: LD_VAR 0 5
46549: PPUSH
46550: LD_EXP 98
46554: PUSH
46555: LD_VAR 0 5
46559: ARRAY
46560: PUSH
46561: LD_VAR 0 1
46565: DIFF
46566: PPUSH
46567: CALL_OW 1
46571: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46572: LD_VAR 0 1
46576: PUSH
46577: LD_EXP 99
46581: PUSH
46582: LD_VAR 0 5
46586: ARRAY
46587: IN
46588: IFFALSE 46627
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46590: LD_ADDR_EXP 99
46594: PUSH
46595: LD_EXP 99
46599: PPUSH
46600: LD_VAR 0 5
46604: PPUSH
46605: LD_EXP 99
46609: PUSH
46610: LD_VAR 0 5
46614: ARRAY
46615: PUSH
46616: LD_VAR 0 1
46620: DIFF
46621: PPUSH
46622: CALL_OW 1
46626: ST_TO_ADDR
// break ;
46627: GO 46631
// end ;
46629: GO 46449
46631: POP
46632: POP
// end ;
46633: LD_VAR 0 4
46637: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46638: LD_INT 0
46640: PPUSH
46641: PPUSH
46642: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46643: LD_EXP 90
46647: NOT
46648: PUSH
46649: LD_EXP 88
46653: NOT
46654: OR
46655: PUSH
46656: LD_VAR 0 3
46660: PUSH
46661: LD_EXP 116
46665: IN
46666: NOT
46667: OR
46668: IFFALSE 46672
// exit ;
46670: GO 46795
// for i = 1 to mc_vehicles do
46672: LD_ADDR_VAR 0 6
46676: PUSH
46677: DOUBLE
46678: LD_INT 1
46680: DEC
46681: ST_TO_ADDR
46682: LD_EXP 109
46686: PUSH
46687: FOR_TO
46688: IFFALSE 46793
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46690: LD_VAR 0 2
46694: PUSH
46695: LD_EXP 109
46699: PUSH
46700: LD_VAR 0 6
46704: ARRAY
46705: IN
46706: PUSH
46707: LD_VAR 0 1
46711: PUSH
46712: LD_EXP 109
46716: PUSH
46717: LD_VAR 0 6
46721: ARRAY
46722: IN
46723: OR
46724: IFFALSE 46791
// begin tmp := mc_vehicles [ i ] diff old ;
46726: LD_ADDR_VAR 0 7
46730: PUSH
46731: LD_EXP 109
46735: PUSH
46736: LD_VAR 0 6
46740: ARRAY
46741: PUSH
46742: LD_VAR 0 2
46746: DIFF
46747: ST_TO_ADDR
// tmp := tmp diff new ;
46748: LD_ADDR_VAR 0 7
46752: PUSH
46753: LD_VAR 0 7
46757: PUSH
46758: LD_VAR 0 1
46762: DIFF
46763: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46764: LD_ADDR_EXP 109
46768: PUSH
46769: LD_EXP 109
46773: PPUSH
46774: LD_VAR 0 6
46778: PPUSH
46779: LD_VAR 0 7
46783: PPUSH
46784: CALL_OW 1
46788: ST_TO_ADDR
// break ;
46789: GO 46793
// end ;
46791: GO 46687
46793: POP
46794: POP
// end ;
46795: LD_VAR 0 5
46799: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46800: LD_INT 0
46802: PPUSH
46803: PPUSH
46804: PPUSH
46805: PPUSH
// if not mc_bases or not skirmish then
46806: LD_EXP 90
46810: NOT
46811: PUSH
46812: LD_EXP 88
46816: NOT
46817: OR
46818: IFFALSE 46822
// exit ;
46820: GO 47205
// side := GetSide ( vehicle ) ;
46822: LD_ADDR_VAR 0 5
46826: PUSH
46827: LD_VAR 0 1
46831: PPUSH
46832: CALL_OW 255
46836: ST_TO_ADDR
// for i = 1 to mc_bases do
46837: LD_ADDR_VAR 0 4
46841: PUSH
46842: DOUBLE
46843: LD_INT 1
46845: DEC
46846: ST_TO_ADDR
46847: LD_EXP 90
46851: PUSH
46852: FOR_TO
46853: IFFALSE 47203
// begin if factory in mc_bases [ i ] then
46855: LD_VAR 0 2
46859: PUSH
46860: LD_EXP 90
46864: PUSH
46865: LD_VAR 0 4
46869: ARRAY
46870: IN
46871: IFFALSE 47201
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
46873: LD_EXP 112
46877: PUSH
46878: LD_VAR 0 4
46882: ARRAY
46883: PUSH
46884: LD_EXP 101
46888: PUSH
46889: LD_VAR 0 4
46893: ARRAY
46894: LESS
46895: PUSH
46896: LD_VAR 0 1
46900: PPUSH
46901: CALL_OW 264
46905: PUSH
46906: LD_INT 31
46908: PUSH
46909: LD_INT 32
46911: PUSH
46912: LD_INT 51
46914: PUSH
46915: LD_EXP 73
46919: PUSH
46920: LD_INT 12
46922: PUSH
46923: LD_INT 30
46925: PUSH
46926: LD_EXP 72
46930: PUSH
46931: LD_INT 11
46933: PUSH
46934: LD_INT 53
46936: PUSH
46937: LD_INT 14
46939: PUSH
46940: LD_EXP 76
46944: PUSH
46945: LD_INT 29
46947: PUSH
46948: LD_EXP 74
46952: PUSH
46953: LD_INT 13
46955: PUSH
46956: LD_INT 52
46958: PUSH
46959: LD_EXP 78
46963: PUSH
46964: LD_INT 48
46966: PUSH
46967: LD_INT 8
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: IN
46990: NOT
46991: AND
46992: IFFALSE 47040
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46994: LD_ADDR_EXP 112
46998: PUSH
46999: LD_EXP 112
47003: PPUSH
47004: LD_VAR 0 4
47008: PUSH
47009: LD_EXP 112
47013: PUSH
47014: LD_VAR 0 4
47018: ARRAY
47019: PUSH
47020: LD_INT 1
47022: PLUS
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PPUSH
47028: LD_VAR 0 1
47032: PPUSH
47033: CALL 55792 0 3
47037: ST_TO_ADDR
47038: GO 47084
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47040: LD_ADDR_EXP 109
47044: PUSH
47045: LD_EXP 109
47049: PPUSH
47050: LD_VAR 0 4
47054: PUSH
47055: LD_EXP 109
47059: PUSH
47060: LD_VAR 0 4
47064: ARRAY
47065: PUSH
47066: LD_INT 1
47068: PLUS
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PPUSH
47074: LD_VAR 0 1
47078: PPUSH
47079: CALL 55792 0 3
47083: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47084: LD_VAR 0 1
47088: PPUSH
47089: CALL_OW 263
47093: PUSH
47094: LD_INT 2
47096: EQUAL
47097: IFFALSE 47117
// begin repeat wait ( 0 0$1 ) ;
47099: LD_INT 35
47101: PPUSH
47102: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47106: LD_VAR 0 1
47110: PPUSH
47111: CALL_OW 312
47115: IFFALSE 47099
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47117: LD_VAR 0 1
47121: PPUSH
47122: LD_EXP 114
47126: PUSH
47127: LD_VAR 0 4
47131: ARRAY
47132: PPUSH
47133: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47137: LD_VAR 0 1
47141: PPUSH
47142: CALL_OW 263
47146: PUSH
47147: LD_INT 1
47149: NONEQUAL
47150: IFFALSE 47154
// break ;
47152: GO 47203
// repeat wait ( 0 0$1 ) ;
47154: LD_INT 35
47156: PPUSH
47157: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47161: LD_VAR 0 1
47165: PPUSH
47166: LD_EXP 114
47170: PUSH
47171: LD_VAR 0 4
47175: ARRAY
47176: PPUSH
47177: CALL_OW 308
47181: IFFALSE 47154
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47183: LD_VAR 0 1
47187: PPUSH
47188: CALL_OW 311
47192: PPUSH
47193: CALL_OW 121
// exit ;
47197: POP
47198: POP
47199: GO 47205
// end ; end ;
47201: GO 46852
47203: POP
47204: POP
// end ;
47205: LD_VAR 0 3
47209: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47210: LD_INT 0
47212: PPUSH
47213: PPUSH
47214: PPUSH
47215: PPUSH
// if not mc_bases or not skirmish then
47216: LD_EXP 90
47220: NOT
47221: PUSH
47222: LD_EXP 88
47226: NOT
47227: OR
47228: IFFALSE 47232
// exit ;
47230: GO 47585
// repeat wait ( 0 0$1 ) ;
47232: LD_INT 35
47234: PPUSH
47235: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47239: LD_VAR 0 2
47243: PPUSH
47244: LD_VAR 0 3
47248: PPUSH
47249: CALL_OW 284
47253: IFFALSE 47232
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47255: LD_VAR 0 2
47259: PPUSH
47260: LD_VAR 0 3
47264: PPUSH
47265: CALL_OW 283
47269: PUSH
47270: LD_INT 4
47272: EQUAL
47273: IFFALSE 47277
// exit ;
47275: GO 47585
// for i = 1 to mc_bases do
47277: LD_ADDR_VAR 0 7
47281: PUSH
47282: DOUBLE
47283: LD_INT 1
47285: DEC
47286: ST_TO_ADDR
47287: LD_EXP 90
47291: PUSH
47292: FOR_TO
47293: IFFALSE 47583
// begin if mc_crates_area [ i ] then
47295: LD_EXP 108
47299: PUSH
47300: LD_VAR 0 7
47304: ARRAY
47305: IFFALSE 47416
// for j in mc_crates_area [ i ] do
47307: LD_ADDR_VAR 0 8
47311: PUSH
47312: LD_EXP 108
47316: PUSH
47317: LD_VAR 0 7
47321: ARRAY
47322: PUSH
47323: FOR_IN
47324: IFFALSE 47414
// if InArea ( x , y , j ) then
47326: LD_VAR 0 2
47330: PPUSH
47331: LD_VAR 0 3
47335: PPUSH
47336: LD_VAR 0 8
47340: PPUSH
47341: CALL_OW 309
47345: IFFALSE 47412
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47347: LD_ADDR_EXP 106
47351: PUSH
47352: LD_EXP 106
47356: PPUSH
47357: LD_VAR 0 7
47361: PUSH
47362: LD_EXP 106
47366: PUSH
47367: LD_VAR 0 7
47371: ARRAY
47372: PUSH
47373: LD_INT 1
47375: PLUS
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: PPUSH
47381: LD_VAR 0 4
47385: PUSH
47386: LD_VAR 0 2
47390: PUSH
47391: LD_VAR 0 3
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: LIST
47400: PPUSH
47401: CALL 55792 0 3
47405: ST_TO_ADDR
// exit ;
47406: POP
47407: POP
47408: POP
47409: POP
47410: GO 47585
// end ;
47412: GO 47323
47414: POP
47415: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47416: LD_ADDR_VAR 0 9
47420: PUSH
47421: LD_EXP 90
47425: PUSH
47426: LD_VAR 0 7
47430: ARRAY
47431: PPUSH
47432: LD_INT 2
47434: PUSH
47435: LD_INT 30
47437: PUSH
47438: LD_INT 0
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: PUSH
47445: LD_INT 30
47447: PUSH
47448: LD_INT 1
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: EMPTY
47456: LIST
47457: LIST
47458: LIST
47459: PPUSH
47460: CALL_OW 72
47464: ST_TO_ADDR
// if not depot then
47465: LD_VAR 0 9
47469: NOT
47470: IFFALSE 47474
// continue ;
47472: GO 47292
// for j in depot do
47474: LD_ADDR_VAR 0 8
47478: PUSH
47479: LD_VAR 0 9
47483: PUSH
47484: FOR_IN
47485: IFFALSE 47579
// if GetDistUnitXY ( j , x , y ) < 30 then
47487: LD_VAR 0 8
47491: PPUSH
47492: LD_VAR 0 2
47496: PPUSH
47497: LD_VAR 0 3
47501: PPUSH
47502: CALL_OW 297
47506: PUSH
47507: LD_INT 30
47509: LESS
47510: IFFALSE 47577
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47512: LD_ADDR_EXP 106
47516: PUSH
47517: LD_EXP 106
47521: PPUSH
47522: LD_VAR 0 7
47526: PUSH
47527: LD_EXP 106
47531: PUSH
47532: LD_VAR 0 7
47536: ARRAY
47537: PUSH
47538: LD_INT 1
47540: PLUS
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PPUSH
47546: LD_VAR 0 4
47550: PUSH
47551: LD_VAR 0 2
47555: PUSH
47556: LD_VAR 0 3
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: LIST
47565: PPUSH
47566: CALL 55792 0 3
47570: ST_TO_ADDR
// exit ;
47571: POP
47572: POP
47573: POP
47574: POP
47575: GO 47585
// end ;
47577: GO 47484
47579: POP
47580: POP
// end ;
47581: GO 47292
47583: POP
47584: POP
// end ;
47585: LD_VAR 0 6
47589: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47590: LD_INT 0
47592: PPUSH
47593: PPUSH
47594: PPUSH
47595: PPUSH
// if not mc_bases or not skirmish then
47596: LD_EXP 90
47600: NOT
47601: PUSH
47602: LD_EXP 88
47606: NOT
47607: OR
47608: IFFALSE 47612
// exit ;
47610: GO 47889
// side := GetSide ( lab ) ;
47612: LD_ADDR_VAR 0 4
47616: PUSH
47617: LD_VAR 0 2
47621: PPUSH
47622: CALL_OW 255
47626: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47627: LD_VAR 0 4
47631: PUSH
47632: LD_EXP 116
47636: IN
47637: NOT
47638: PUSH
47639: LD_EXP 117
47643: NOT
47644: OR
47645: PUSH
47646: LD_EXP 90
47650: NOT
47651: OR
47652: IFFALSE 47656
// exit ;
47654: GO 47889
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47656: LD_ADDR_EXP 117
47660: PUSH
47661: LD_EXP 117
47665: PPUSH
47666: LD_VAR 0 4
47670: PPUSH
47671: LD_EXP 117
47675: PUSH
47676: LD_VAR 0 4
47680: ARRAY
47681: PUSH
47682: LD_VAR 0 1
47686: DIFF
47687: PPUSH
47688: CALL_OW 1
47692: ST_TO_ADDR
// for i = 1 to mc_bases do
47693: LD_ADDR_VAR 0 5
47697: PUSH
47698: DOUBLE
47699: LD_INT 1
47701: DEC
47702: ST_TO_ADDR
47703: LD_EXP 90
47707: PUSH
47708: FOR_TO
47709: IFFALSE 47887
// begin if lab in mc_bases [ i ] then
47711: LD_VAR 0 2
47715: PUSH
47716: LD_EXP 90
47720: PUSH
47721: LD_VAR 0 5
47725: ARRAY
47726: IN
47727: IFFALSE 47885
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47729: LD_VAR 0 1
47733: PUSH
47734: LD_INT 11
47736: PUSH
47737: LD_INT 4
47739: PUSH
47740: LD_INT 3
47742: PUSH
47743: LD_INT 2
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: IN
47752: PUSH
47753: LD_EXP 120
47757: PUSH
47758: LD_VAR 0 5
47762: ARRAY
47763: AND
47764: IFFALSE 47885
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47766: LD_ADDR_VAR 0 6
47770: PUSH
47771: LD_EXP 120
47775: PUSH
47776: LD_VAR 0 5
47780: ARRAY
47781: PUSH
47782: LD_INT 1
47784: ARRAY
47785: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47786: LD_ADDR_EXP 120
47790: PUSH
47791: LD_EXP 120
47795: PPUSH
47796: LD_VAR 0 5
47800: PPUSH
47801: EMPTY
47802: PPUSH
47803: CALL_OW 1
47807: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47808: LD_VAR 0 6
47812: PPUSH
47813: LD_INT 0
47815: PPUSH
47816: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47820: LD_VAR 0 6
47824: PPUSH
47825: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47829: LD_ADDR_EXP 119
47833: PUSH
47834: LD_EXP 119
47838: PPUSH
47839: LD_VAR 0 5
47843: PPUSH
47844: LD_EXP 119
47848: PUSH
47849: LD_VAR 0 5
47853: ARRAY
47854: PPUSH
47855: LD_INT 1
47857: PPUSH
47858: LD_VAR 0 6
47862: PPUSH
47863: CALL_OW 2
47867: PPUSH
47868: CALL_OW 1
47872: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47873: LD_VAR 0 5
47877: PPUSH
47878: LD_INT 112
47880: PPUSH
47881: CALL 24856 0 2
// end ; end ; end ;
47885: GO 47708
47887: POP
47888: POP
// end ;
47889: LD_VAR 0 3
47893: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47894: LD_INT 0
47896: PPUSH
47897: PPUSH
47898: PPUSH
47899: PPUSH
47900: PPUSH
47901: PPUSH
47902: PPUSH
47903: PPUSH
// if not mc_bases or not skirmish then
47904: LD_EXP 90
47908: NOT
47909: PUSH
47910: LD_EXP 88
47914: NOT
47915: OR
47916: IFFALSE 47920
// exit ;
47918: GO 49291
// for i = 1 to mc_bases do
47920: LD_ADDR_VAR 0 3
47924: PUSH
47925: DOUBLE
47926: LD_INT 1
47928: DEC
47929: ST_TO_ADDR
47930: LD_EXP 90
47934: PUSH
47935: FOR_TO
47936: IFFALSE 49289
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47938: LD_VAR 0 1
47942: PUSH
47943: LD_EXP 90
47947: PUSH
47948: LD_VAR 0 3
47952: ARRAY
47953: IN
47954: PUSH
47955: LD_VAR 0 1
47959: PUSH
47960: LD_EXP 97
47964: PUSH
47965: LD_VAR 0 3
47969: ARRAY
47970: IN
47971: OR
47972: PUSH
47973: LD_VAR 0 1
47977: PUSH
47978: LD_EXP 112
47982: PUSH
47983: LD_VAR 0 3
47987: ARRAY
47988: IN
47989: OR
47990: PUSH
47991: LD_VAR 0 1
47995: PUSH
47996: LD_EXP 109
48000: PUSH
48001: LD_VAR 0 3
48005: ARRAY
48006: IN
48007: OR
48008: PUSH
48009: LD_VAR 0 1
48013: PUSH
48014: LD_EXP 119
48018: PUSH
48019: LD_VAR 0 3
48023: ARRAY
48024: IN
48025: OR
48026: PUSH
48027: LD_VAR 0 1
48031: PUSH
48032: LD_EXP 120
48036: PUSH
48037: LD_VAR 0 3
48041: ARRAY
48042: IN
48043: OR
48044: IFFALSE 49287
// begin if un in mc_ape [ i ] then
48046: LD_VAR 0 1
48050: PUSH
48051: LD_EXP 119
48055: PUSH
48056: LD_VAR 0 3
48060: ARRAY
48061: IN
48062: IFFALSE 48101
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48064: LD_ADDR_EXP 119
48068: PUSH
48069: LD_EXP 119
48073: PPUSH
48074: LD_VAR 0 3
48078: PPUSH
48079: LD_EXP 119
48083: PUSH
48084: LD_VAR 0 3
48088: ARRAY
48089: PUSH
48090: LD_VAR 0 1
48094: DIFF
48095: PPUSH
48096: CALL_OW 1
48100: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48101: LD_VAR 0 1
48105: PUSH
48106: LD_EXP 120
48110: PUSH
48111: LD_VAR 0 3
48115: ARRAY
48116: IN
48117: IFFALSE 48141
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48119: LD_ADDR_EXP 120
48123: PUSH
48124: LD_EXP 120
48128: PPUSH
48129: LD_VAR 0 3
48133: PPUSH
48134: EMPTY
48135: PPUSH
48136: CALL_OW 1
48140: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48141: LD_VAR 0 1
48145: PPUSH
48146: CALL_OW 247
48150: PUSH
48151: LD_INT 2
48153: EQUAL
48154: PUSH
48155: LD_VAR 0 1
48159: PPUSH
48160: CALL_OW 110
48164: PUSH
48165: LD_INT 20
48167: EQUAL
48168: PUSH
48169: LD_VAR 0 1
48173: PUSH
48174: LD_EXP 112
48178: PUSH
48179: LD_VAR 0 3
48183: ARRAY
48184: IN
48185: OR
48186: PUSH
48187: LD_VAR 0 1
48191: PPUSH
48192: CALL_OW 264
48196: PUSH
48197: LD_INT 12
48199: PUSH
48200: LD_INT 51
48202: PUSH
48203: LD_EXP 73
48207: PUSH
48208: LD_INT 32
48210: PUSH
48211: LD_INT 13
48213: PUSH
48214: LD_INT 52
48216: PUSH
48217: LD_INT 31
48219: PUSH
48220: EMPTY
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: IN
48229: OR
48230: AND
48231: IFFALSE 48539
// begin if un in mc_defender [ i ] then
48233: LD_VAR 0 1
48237: PUSH
48238: LD_EXP 112
48242: PUSH
48243: LD_VAR 0 3
48247: ARRAY
48248: IN
48249: IFFALSE 48288
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48251: LD_ADDR_EXP 112
48255: PUSH
48256: LD_EXP 112
48260: PPUSH
48261: LD_VAR 0 3
48265: PPUSH
48266: LD_EXP 112
48270: PUSH
48271: LD_VAR 0 3
48275: ARRAY
48276: PUSH
48277: LD_VAR 0 1
48281: DIFF
48282: PPUSH
48283: CALL_OW 1
48287: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48288: LD_ADDR_VAR 0 8
48292: PUSH
48293: LD_VAR 0 3
48297: PPUSH
48298: LD_INT 3
48300: PPUSH
48301: CALL 44938 0 2
48305: ST_TO_ADDR
// if fac then
48306: LD_VAR 0 8
48310: IFFALSE 48539
// begin for j in fac do
48312: LD_ADDR_VAR 0 4
48316: PUSH
48317: LD_VAR 0 8
48321: PUSH
48322: FOR_IN
48323: IFFALSE 48537
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48325: LD_ADDR_VAR 0 9
48329: PUSH
48330: LD_VAR 0 8
48334: PPUSH
48335: LD_VAR 0 1
48339: PPUSH
48340: CALL_OW 265
48344: PPUSH
48345: LD_VAR 0 1
48349: PPUSH
48350: CALL_OW 262
48354: PPUSH
48355: LD_VAR 0 1
48359: PPUSH
48360: CALL_OW 263
48364: PPUSH
48365: LD_VAR 0 1
48369: PPUSH
48370: CALL_OW 264
48374: PPUSH
48375: CALL 53324 0 5
48379: ST_TO_ADDR
// if components then
48380: LD_VAR 0 9
48384: IFFALSE 48535
// begin if GetWeapon ( un ) = ar_control_tower then
48386: LD_VAR 0 1
48390: PPUSH
48391: CALL_OW 264
48395: PUSH
48396: LD_INT 31
48398: EQUAL
48399: IFFALSE 48516
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48401: LD_VAR 0 1
48405: PPUSH
48406: CALL_OW 311
48410: PPUSH
48411: LD_INT 0
48413: PPUSH
48414: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48418: LD_ADDR_EXP 130
48422: PUSH
48423: LD_EXP 130
48427: PPUSH
48428: LD_VAR 0 3
48432: PPUSH
48433: LD_EXP 130
48437: PUSH
48438: LD_VAR 0 3
48442: ARRAY
48443: PUSH
48444: LD_VAR 0 1
48448: PPUSH
48449: CALL_OW 311
48453: DIFF
48454: PPUSH
48455: CALL_OW 1
48459: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48460: LD_ADDR_VAR 0 7
48464: PUSH
48465: LD_EXP 111
48469: PUSH
48470: LD_VAR 0 3
48474: ARRAY
48475: PPUSH
48476: LD_INT 1
48478: PPUSH
48479: LD_VAR 0 9
48483: PPUSH
48484: CALL_OW 2
48488: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48489: LD_ADDR_EXP 111
48493: PUSH
48494: LD_EXP 111
48498: PPUSH
48499: LD_VAR 0 3
48503: PPUSH
48504: LD_VAR 0 7
48508: PPUSH
48509: CALL_OW 1
48513: ST_TO_ADDR
// end else
48514: GO 48533
// MC_InsertProduceList ( i , [ components ] ) ;
48516: LD_VAR 0 3
48520: PPUSH
48521: LD_VAR 0 9
48525: PUSH
48526: EMPTY
48527: LIST
48528: PPUSH
48529: CALL 44483 0 2
// break ;
48533: GO 48537
// end ; end ;
48535: GO 48322
48537: POP
48538: POP
// end ; end ; if GetType ( un ) = unit_building then
48539: LD_VAR 0 1
48543: PPUSH
48544: CALL_OW 247
48548: PUSH
48549: LD_INT 3
48551: EQUAL
48552: IFFALSE 48955
// begin btype := GetBType ( un ) ;
48554: LD_ADDR_VAR 0 5
48558: PUSH
48559: LD_VAR 0 1
48563: PPUSH
48564: CALL_OW 266
48568: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48569: LD_VAR 0 5
48573: PUSH
48574: LD_INT 29
48576: PUSH
48577: LD_INT 30
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: IN
48584: IFFALSE 48657
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48586: LD_VAR 0 1
48590: PPUSH
48591: CALL_OW 250
48595: PPUSH
48596: LD_VAR 0 1
48600: PPUSH
48601: CALL_OW 251
48605: PPUSH
48606: LD_VAR 0 1
48610: PPUSH
48611: CALL_OW 255
48615: PPUSH
48616: CALL_OW 440
48620: NOT
48621: IFFALSE 48657
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48623: LD_VAR 0 1
48627: PPUSH
48628: CALL_OW 250
48632: PPUSH
48633: LD_VAR 0 1
48637: PPUSH
48638: CALL_OW 251
48642: PPUSH
48643: LD_VAR 0 1
48647: PPUSH
48648: CALL_OW 255
48652: PPUSH
48653: CALL_OW 441
// end ; if btype = b_warehouse then
48657: LD_VAR 0 5
48661: PUSH
48662: LD_INT 1
48664: EQUAL
48665: IFFALSE 48683
// begin btype := b_depot ;
48667: LD_ADDR_VAR 0 5
48671: PUSH
48672: LD_INT 0
48674: ST_TO_ADDR
// pos := 1 ;
48675: LD_ADDR_VAR 0 6
48679: PUSH
48680: LD_INT 1
48682: ST_TO_ADDR
// end ; if btype = b_factory then
48683: LD_VAR 0 5
48687: PUSH
48688: LD_INT 3
48690: EQUAL
48691: IFFALSE 48709
// begin btype := b_workshop ;
48693: LD_ADDR_VAR 0 5
48697: PUSH
48698: LD_INT 2
48700: ST_TO_ADDR
// pos := 1 ;
48701: LD_ADDR_VAR 0 6
48705: PUSH
48706: LD_INT 1
48708: ST_TO_ADDR
// end ; if btype = b_barracks then
48709: LD_VAR 0 5
48713: PUSH
48714: LD_INT 5
48716: EQUAL
48717: IFFALSE 48727
// btype := b_armoury ;
48719: LD_ADDR_VAR 0 5
48723: PUSH
48724: LD_INT 4
48726: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48727: LD_VAR 0 5
48731: PUSH
48732: LD_INT 7
48734: PUSH
48735: LD_INT 8
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: IN
48742: IFFALSE 48752
// btype := b_lab ;
48744: LD_ADDR_VAR 0 5
48748: PUSH
48749: LD_INT 6
48751: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48752: LD_ADDR_EXP 95
48756: PUSH
48757: LD_EXP 95
48761: PPUSH
48762: LD_VAR 0 3
48766: PUSH
48767: LD_EXP 95
48771: PUSH
48772: LD_VAR 0 3
48776: ARRAY
48777: PUSH
48778: LD_INT 1
48780: PLUS
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: PPUSH
48786: LD_VAR 0 5
48790: PUSH
48791: LD_VAR 0 1
48795: PPUSH
48796: CALL_OW 250
48800: PUSH
48801: LD_VAR 0 1
48805: PPUSH
48806: CALL_OW 251
48810: PUSH
48811: LD_VAR 0 1
48815: PPUSH
48816: CALL_OW 254
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: PPUSH
48827: CALL 55792 0 3
48831: ST_TO_ADDR
// if pos = 1 then
48832: LD_VAR 0 6
48836: PUSH
48837: LD_INT 1
48839: EQUAL
48840: IFFALSE 48955
// begin tmp := mc_build_list [ i ] ;
48842: LD_ADDR_VAR 0 7
48846: PUSH
48847: LD_EXP 95
48851: PUSH
48852: LD_VAR 0 3
48856: ARRAY
48857: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48858: LD_VAR 0 7
48862: PPUSH
48863: LD_INT 2
48865: PUSH
48866: LD_INT 30
48868: PUSH
48869: LD_INT 0
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: PUSH
48876: LD_INT 30
48878: PUSH
48879: LD_INT 1
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: LIST
48890: PPUSH
48891: CALL_OW 72
48895: IFFALSE 48905
// pos := 2 ;
48897: LD_ADDR_VAR 0 6
48901: PUSH
48902: LD_INT 2
48904: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48905: LD_ADDR_VAR 0 7
48909: PUSH
48910: LD_VAR 0 7
48914: PPUSH
48915: LD_VAR 0 6
48919: PPUSH
48920: LD_VAR 0 7
48924: PPUSH
48925: CALL 56118 0 3
48929: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48930: LD_ADDR_EXP 95
48934: PUSH
48935: LD_EXP 95
48939: PPUSH
48940: LD_VAR 0 3
48944: PPUSH
48945: LD_VAR 0 7
48949: PPUSH
48950: CALL_OW 1
48954: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48955: LD_VAR 0 1
48959: PUSH
48960: LD_EXP 90
48964: PUSH
48965: LD_VAR 0 3
48969: ARRAY
48970: IN
48971: IFFALSE 49010
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48973: LD_ADDR_EXP 90
48977: PUSH
48978: LD_EXP 90
48982: PPUSH
48983: LD_VAR 0 3
48987: PPUSH
48988: LD_EXP 90
48992: PUSH
48993: LD_VAR 0 3
48997: ARRAY
48998: PUSH
48999: LD_VAR 0 1
49003: DIFF
49004: PPUSH
49005: CALL_OW 1
49009: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49010: LD_VAR 0 1
49014: PUSH
49015: LD_EXP 97
49019: PUSH
49020: LD_VAR 0 3
49024: ARRAY
49025: IN
49026: IFFALSE 49065
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49028: LD_ADDR_EXP 97
49032: PUSH
49033: LD_EXP 97
49037: PPUSH
49038: LD_VAR 0 3
49042: PPUSH
49043: LD_EXP 97
49047: PUSH
49048: LD_VAR 0 3
49052: ARRAY
49053: PUSH
49054: LD_VAR 0 1
49058: DIFF
49059: PPUSH
49060: CALL_OW 1
49064: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49065: LD_VAR 0 1
49069: PUSH
49070: LD_EXP 109
49074: PUSH
49075: LD_VAR 0 3
49079: ARRAY
49080: IN
49081: IFFALSE 49120
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49083: LD_ADDR_EXP 109
49087: PUSH
49088: LD_EXP 109
49092: PPUSH
49093: LD_VAR 0 3
49097: PPUSH
49098: LD_EXP 109
49102: PUSH
49103: LD_VAR 0 3
49107: ARRAY
49108: PUSH
49109: LD_VAR 0 1
49113: DIFF
49114: PPUSH
49115: CALL_OW 1
49119: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49120: LD_VAR 0 1
49124: PUSH
49125: LD_EXP 112
49129: PUSH
49130: LD_VAR 0 3
49134: ARRAY
49135: IN
49136: IFFALSE 49175
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49138: LD_ADDR_EXP 112
49142: PUSH
49143: LD_EXP 112
49147: PPUSH
49148: LD_VAR 0 3
49152: PPUSH
49153: LD_EXP 112
49157: PUSH
49158: LD_VAR 0 3
49162: ARRAY
49163: PUSH
49164: LD_VAR 0 1
49168: DIFF
49169: PPUSH
49170: CALL_OW 1
49174: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49175: LD_VAR 0 1
49179: PUSH
49180: LD_EXP 99
49184: PUSH
49185: LD_VAR 0 3
49189: ARRAY
49190: IN
49191: IFFALSE 49230
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49193: LD_ADDR_EXP 99
49197: PUSH
49198: LD_EXP 99
49202: PPUSH
49203: LD_VAR 0 3
49207: PPUSH
49208: LD_EXP 99
49212: PUSH
49213: LD_VAR 0 3
49217: ARRAY
49218: PUSH
49219: LD_VAR 0 1
49223: DIFF
49224: PPUSH
49225: CALL_OW 1
49229: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49230: LD_VAR 0 1
49234: PUSH
49235: LD_EXP 98
49239: PUSH
49240: LD_VAR 0 3
49244: ARRAY
49245: IN
49246: IFFALSE 49285
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49248: LD_ADDR_EXP 98
49252: PUSH
49253: LD_EXP 98
49257: PPUSH
49258: LD_VAR 0 3
49262: PPUSH
49263: LD_EXP 98
49267: PUSH
49268: LD_VAR 0 3
49272: ARRAY
49273: PUSH
49274: LD_VAR 0 1
49278: DIFF
49279: PPUSH
49280: CALL_OW 1
49284: ST_TO_ADDR
// end ; break ;
49285: GO 49289
// end ;
49287: GO 47935
49289: POP
49290: POP
// end ;
49291: LD_VAR 0 2
49295: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49296: LD_INT 0
49298: PPUSH
49299: PPUSH
49300: PPUSH
// if not mc_bases or not skirmish then
49301: LD_EXP 90
49305: NOT
49306: PUSH
49307: LD_EXP 88
49311: NOT
49312: OR
49313: IFFALSE 49317
// exit ;
49315: GO 49532
// for i = 1 to mc_bases do
49317: LD_ADDR_VAR 0 3
49321: PUSH
49322: DOUBLE
49323: LD_INT 1
49325: DEC
49326: ST_TO_ADDR
49327: LD_EXP 90
49331: PUSH
49332: FOR_TO
49333: IFFALSE 49530
// begin if building in mc_construct_list [ i ] then
49335: LD_VAR 0 1
49339: PUSH
49340: LD_EXP 97
49344: PUSH
49345: LD_VAR 0 3
49349: ARRAY
49350: IN
49351: IFFALSE 49528
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49353: LD_ADDR_EXP 97
49357: PUSH
49358: LD_EXP 97
49362: PPUSH
49363: LD_VAR 0 3
49367: PPUSH
49368: LD_EXP 97
49372: PUSH
49373: LD_VAR 0 3
49377: ARRAY
49378: PUSH
49379: LD_VAR 0 1
49383: DIFF
49384: PPUSH
49385: CALL_OW 1
49389: ST_TO_ADDR
// if building in mc_lab [ i ] then
49390: LD_VAR 0 1
49394: PUSH
49395: LD_EXP 123
49399: PUSH
49400: LD_VAR 0 3
49404: ARRAY
49405: IN
49406: IFFALSE 49461
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49408: LD_ADDR_EXP 124
49412: PUSH
49413: LD_EXP 124
49417: PPUSH
49418: LD_VAR 0 3
49422: PPUSH
49423: LD_EXP 124
49427: PUSH
49428: LD_VAR 0 3
49432: ARRAY
49433: PPUSH
49434: LD_INT 1
49436: PPUSH
49437: LD_EXP 124
49441: PUSH
49442: LD_VAR 0 3
49446: ARRAY
49447: PPUSH
49448: LD_INT 0
49450: PPUSH
49451: CALL 55210 0 4
49455: PPUSH
49456: CALL_OW 1
49460: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49461: LD_VAR 0 1
49465: PUSH
49466: LD_EXP 90
49470: PUSH
49471: LD_VAR 0 3
49475: ARRAY
49476: IN
49477: NOT
49478: IFFALSE 49524
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49480: LD_ADDR_EXP 90
49484: PUSH
49485: LD_EXP 90
49489: PPUSH
49490: LD_VAR 0 3
49494: PUSH
49495: LD_EXP 90
49499: PUSH
49500: LD_VAR 0 3
49504: ARRAY
49505: PUSH
49506: LD_INT 1
49508: PLUS
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PPUSH
49514: LD_VAR 0 1
49518: PPUSH
49519: CALL 55792 0 3
49523: ST_TO_ADDR
// exit ;
49524: POP
49525: POP
49526: GO 49532
// end ; end ;
49528: GO 49332
49530: POP
49531: POP
// end ;
49532: LD_VAR 0 2
49536: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49537: LD_INT 0
49539: PPUSH
49540: PPUSH
49541: PPUSH
49542: PPUSH
49543: PPUSH
49544: PPUSH
49545: PPUSH
// if not mc_bases or not skirmish then
49546: LD_EXP 90
49550: NOT
49551: PUSH
49552: LD_EXP 88
49556: NOT
49557: OR
49558: IFFALSE 49562
// exit ;
49560: GO 50223
// for i = 1 to mc_bases do
49562: LD_ADDR_VAR 0 3
49566: PUSH
49567: DOUBLE
49568: LD_INT 1
49570: DEC
49571: ST_TO_ADDR
49572: LD_EXP 90
49576: PUSH
49577: FOR_TO
49578: IFFALSE 50221
// begin if building in mc_construct_list [ i ] then
49580: LD_VAR 0 1
49584: PUSH
49585: LD_EXP 97
49589: PUSH
49590: LD_VAR 0 3
49594: ARRAY
49595: IN
49596: IFFALSE 50219
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49598: LD_ADDR_EXP 97
49602: PUSH
49603: LD_EXP 97
49607: PPUSH
49608: LD_VAR 0 3
49612: PPUSH
49613: LD_EXP 97
49617: PUSH
49618: LD_VAR 0 3
49622: ARRAY
49623: PUSH
49624: LD_VAR 0 1
49628: DIFF
49629: PPUSH
49630: CALL_OW 1
49634: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49635: LD_ADDR_EXP 90
49639: PUSH
49640: LD_EXP 90
49644: PPUSH
49645: LD_VAR 0 3
49649: PUSH
49650: LD_EXP 90
49654: PUSH
49655: LD_VAR 0 3
49659: ARRAY
49660: PUSH
49661: LD_INT 1
49663: PLUS
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: PPUSH
49669: LD_VAR 0 1
49673: PPUSH
49674: CALL 55792 0 3
49678: ST_TO_ADDR
// btype := GetBType ( building ) ;
49679: LD_ADDR_VAR 0 5
49683: PUSH
49684: LD_VAR 0 1
49688: PPUSH
49689: CALL_OW 266
49693: ST_TO_ADDR
// side := GetSide ( building ) ;
49694: LD_ADDR_VAR 0 8
49698: PUSH
49699: LD_VAR 0 1
49703: PPUSH
49704: CALL_OW 255
49708: ST_TO_ADDR
// if btype = b_lab then
49709: LD_VAR 0 5
49713: PUSH
49714: LD_INT 6
49716: EQUAL
49717: IFFALSE 49767
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49719: LD_ADDR_EXP 123
49723: PUSH
49724: LD_EXP 123
49728: PPUSH
49729: LD_VAR 0 3
49733: PUSH
49734: LD_EXP 123
49738: PUSH
49739: LD_VAR 0 3
49743: ARRAY
49744: PUSH
49745: LD_INT 1
49747: PLUS
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PPUSH
49753: LD_VAR 0 1
49757: PPUSH
49758: CALL 55792 0 3
49762: ST_TO_ADDR
// exit ;
49763: POP
49764: POP
49765: GO 50223
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49767: LD_VAR 0 5
49771: PUSH
49772: LD_INT 0
49774: PUSH
49775: LD_INT 2
49777: PUSH
49778: LD_INT 4
49780: PUSH
49781: EMPTY
49782: LIST
49783: LIST
49784: LIST
49785: IN
49786: IFFALSE 49910
// begin if btype = b_armoury then
49788: LD_VAR 0 5
49792: PUSH
49793: LD_INT 4
49795: EQUAL
49796: IFFALSE 49806
// btype := b_barracks ;
49798: LD_ADDR_VAR 0 5
49802: PUSH
49803: LD_INT 5
49805: ST_TO_ADDR
// if btype = b_depot then
49806: LD_VAR 0 5
49810: PUSH
49811: LD_INT 0
49813: EQUAL
49814: IFFALSE 49824
// btype := b_warehouse ;
49816: LD_ADDR_VAR 0 5
49820: PUSH
49821: LD_INT 1
49823: ST_TO_ADDR
// if btype = b_workshop then
49824: LD_VAR 0 5
49828: PUSH
49829: LD_INT 2
49831: EQUAL
49832: IFFALSE 49842
// btype := b_factory ;
49834: LD_ADDR_VAR 0 5
49838: PUSH
49839: LD_INT 3
49841: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49842: LD_VAR 0 5
49846: PPUSH
49847: LD_VAR 0 8
49851: PPUSH
49852: CALL_OW 323
49856: PUSH
49857: LD_INT 1
49859: EQUAL
49860: IFFALSE 49906
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49862: LD_ADDR_EXP 122
49866: PUSH
49867: LD_EXP 122
49871: PPUSH
49872: LD_VAR 0 3
49876: PUSH
49877: LD_EXP 122
49881: PUSH
49882: LD_VAR 0 3
49886: ARRAY
49887: PUSH
49888: LD_INT 1
49890: PLUS
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: PPUSH
49896: LD_VAR 0 1
49900: PPUSH
49901: CALL 55792 0 3
49905: ST_TO_ADDR
// exit ;
49906: POP
49907: POP
49908: GO 50223
// end ; if btype in [ b_bunker , b_turret ] then
49910: LD_VAR 0 5
49914: PUSH
49915: LD_INT 32
49917: PUSH
49918: LD_INT 33
49920: PUSH
49921: EMPTY
49922: LIST
49923: LIST
49924: IN
49925: IFFALSE 50215
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49927: LD_ADDR_EXP 98
49931: PUSH
49932: LD_EXP 98
49936: PPUSH
49937: LD_VAR 0 3
49941: PUSH
49942: LD_EXP 98
49946: PUSH
49947: LD_VAR 0 3
49951: ARRAY
49952: PUSH
49953: LD_INT 1
49955: PLUS
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: PPUSH
49961: LD_VAR 0 1
49965: PPUSH
49966: CALL 55792 0 3
49970: ST_TO_ADDR
// if btype = b_bunker then
49971: LD_VAR 0 5
49975: PUSH
49976: LD_INT 32
49978: EQUAL
49979: IFFALSE 50215
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49981: LD_ADDR_EXP 99
49985: PUSH
49986: LD_EXP 99
49990: PPUSH
49991: LD_VAR 0 3
49995: PUSH
49996: LD_EXP 99
50000: PUSH
50001: LD_VAR 0 3
50005: ARRAY
50006: PUSH
50007: LD_INT 1
50009: PLUS
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: PPUSH
50015: LD_VAR 0 1
50019: PPUSH
50020: CALL 55792 0 3
50024: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50025: LD_ADDR_VAR 0 6
50029: PUSH
50030: LD_EXP 90
50034: PUSH
50035: LD_VAR 0 3
50039: ARRAY
50040: PPUSH
50041: LD_INT 25
50043: PUSH
50044: LD_INT 1
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: LD_INT 3
50053: PUSH
50054: LD_INT 54
50056: PUSH
50057: EMPTY
50058: LIST
50059: PUSH
50060: EMPTY
50061: LIST
50062: LIST
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PPUSH
50068: CALL_OW 72
50072: ST_TO_ADDR
// if tmp then
50073: LD_VAR 0 6
50077: IFFALSE 50083
// exit ;
50079: POP
50080: POP
50081: GO 50223
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50083: LD_ADDR_VAR 0 6
50087: PUSH
50088: LD_EXP 90
50092: PUSH
50093: LD_VAR 0 3
50097: ARRAY
50098: PPUSH
50099: LD_INT 2
50101: PUSH
50102: LD_INT 30
50104: PUSH
50105: LD_INT 4
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: PUSH
50112: LD_INT 30
50114: PUSH
50115: LD_INT 5
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: LIST
50126: PPUSH
50127: CALL_OW 72
50131: ST_TO_ADDR
// if not tmp then
50132: LD_VAR 0 6
50136: NOT
50137: IFFALSE 50143
// exit ;
50139: POP
50140: POP
50141: GO 50223
// for j in tmp do
50143: LD_ADDR_VAR 0 4
50147: PUSH
50148: LD_VAR 0 6
50152: PUSH
50153: FOR_IN
50154: IFFALSE 50213
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50156: LD_ADDR_VAR 0 7
50160: PUSH
50161: LD_VAR 0 4
50165: PPUSH
50166: CALL_OW 313
50170: PPUSH
50171: LD_INT 25
50173: PUSH
50174: LD_INT 1
50176: PUSH
50177: EMPTY
50178: LIST
50179: LIST
50180: PPUSH
50181: CALL_OW 72
50185: ST_TO_ADDR
// if units then
50186: LD_VAR 0 7
50190: IFFALSE 50211
// begin ComExitBuilding ( units [ 1 ] ) ;
50192: LD_VAR 0 7
50196: PUSH
50197: LD_INT 1
50199: ARRAY
50200: PPUSH
50201: CALL_OW 122
// exit ;
50205: POP
50206: POP
50207: POP
50208: POP
50209: GO 50223
// end ; end ;
50211: GO 50153
50213: POP
50214: POP
// end ; end ; exit ;
50215: POP
50216: POP
50217: GO 50223
// end ; end ;
50219: GO 49577
50221: POP
50222: POP
// end ;
50223: LD_VAR 0 2
50227: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50228: LD_INT 0
50230: PPUSH
50231: PPUSH
50232: PPUSH
50233: PPUSH
50234: PPUSH
50235: PPUSH
50236: PPUSH
// if not mc_bases or not skirmish then
50237: LD_EXP 90
50241: NOT
50242: PUSH
50243: LD_EXP 88
50247: NOT
50248: OR
50249: IFFALSE 50253
// exit ;
50251: GO 50484
// btype := GetBType ( building ) ;
50253: LD_ADDR_VAR 0 6
50257: PUSH
50258: LD_VAR 0 1
50262: PPUSH
50263: CALL_OW 266
50267: ST_TO_ADDR
// x := GetX ( building ) ;
50268: LD_ADDR_VAR 0 7
50272: PUSH
50273: LD_VAR 0 1
50277: PPUSH
50278: CALL_OW 250
50282: ST_TO_ADDR
// y := GetY ( building ) ;
50283: LD_ADDR_VAR 0 8
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: CALL_OW 251
50297: ST_TO_ADDR
// d := GetDir ( building ) ;
50298: LD_ADDR_VAR 0 9
50302: PUSH
50303: LD_VAR 0 1
50307: PPUSH
50308: CALL_OW 254
50312: ST_TO_ADDR
// for i = 1 to mc_bases do
50313: LD_ADDR_VAR 0 4
50317: PUSH
50318: DOUBLE
50319: LD_INT 1
50321: DEC
50322: ST_TO_ADDR
50323: LD_EXP 90
50327: PUSH
50328: FOR_TO
50329: IFFALSE 50482
// begin if not mc_build_list [ i ] then
50331: LD_EXP 95
50335: PUSH
50336: LD_VAR 0 4
50340: ARRAY
50341: NOT
50342: IFFALSE 50346
// continue ;
50344: GO 50328
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50346: LD_VAR 0 6
50350: PUSH
50351: LD_VAR 0 7
50355: PUSH
50356: LD_VAR 0 8
50360: PUSH
50361: LD_VAR 0 9
50365: PUSH
50366: EMPTY
50367: LIST
50368: LIST
50369: LIST
50370: LIST
50371: PPUSH
50372: LD_EXP 95
50376: PUSH
50377: LD_VAR 0 4
50381: ARRAY
50382: PUSH
50383: LD_INT 1
50385: ARRAY
50386: PPUSH
50387: CALL 61961 0 2
50391: IFFALSE 50480
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50393: LD_ADDR_EXP 95
50397: PUSH
50398: LD_EXP 95
50402: PPUSH
50403: LD_VAR 0 4
50407: PPUSH
50408: LD_EXP 95
50412: PUSH
50413: LD_VAR 0 4
50417: ARRAY
50418: PPUSH
50419: LD_INT 1
50421: PPUSH
50422: CALL_OW 3
50426: PPUSH
50427: CALL_OW 1
50431: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50432: LD_ADDR_EXP 97
50436: PUSH
50437: LD_EXP 97
50441: PPUSH
50442: LD_VAR 0 4
50446: PUSH
50447: LD_EXP 97
50451: PUSH
50452: LD_VAR 0 4
50456: ARRAY
50457: PUSH
50458: LD_INT 1
50460: PLUS
50461: PUSH
50462: EMPTY
50463: LIST
50464: LIST
50465: PPUSH
50466: LD_VAR 0 1
50470: PPUSH
50471: CALL 55792 0 3
50475: ST_TO_ADDR
// exit ;
50476: POP
50477: POP
50478: GO 50484
// end ; end ;
50480: GO 50328
50482: POP
50483: POP
// end ;
50484: LD_VAR 0 3
50488: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50489: LD_INT 0
50491: PPUSH
50492: PPUSH
50493: PPUSH
// if not mc_bases or not skirmish then
50494: LD_EXP 90
50498: NOT
50499: PUSH
50500: LD_EXP 88
50504: NOT
50505: OR
50506: IFFALSE 50510
// exit ;
50508: GO 50700
// for i = 1 to mc_bases do
50510: LD_ADDR_VAR 0 4
50514: PUSH
50515: DOUBLE
50516: LD_INT 1
50518: DEC
50519: ST_TO_ADDR
50520: LD_EXP 90
50524: PUSH
50525: FOR_TO
50526: IFFALSE 50613
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50528: LD_VAR 0 1
50532: PUSH
50533: LD_EXP 98
50537: PUSH
50538: LD_VAR 0 4
50542: ARRAY
50543: IN
50544: PUSH
50545: LD_VAR 0 1
50549: PUSH
50550: LD_EXP 99
50554: PUSH
50555: LD_VAR 0 4
50559: ARRAY
50560: IN
50561: NOT
50562: AND
50563: IFFALSE 50611
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50565: LD_ADDR_EXP 99
50569: PUSH
50570: LD_EXP 99
50574: PPUSH
50575: LD_VAR 0 4
50579: PUSH
50580: LD_EXP 99
50584: PUSH
50585: LD_VAR 0 4
50589: ARRAY
50590: PUSH
50591: LD_INT 1
50593: PLUS
50594: PUSH
50595: EMPTY
50596: LIST
50597: LIST
50598: PPUSH
50599: LD_VAR 0 1
50603: PPUSH
50604: CALL 55792 0 3
50608: ST_TO_ADDR
// break ;
50609: GO 50613
// end ; end ;
50611: GO 50525
50613: POP
50614: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50615: LD_VAR 0 1
50619: PPUSH
50620: CALL_OW 257
50624: PUSH
50625: LD_EXP 116
50629: IN
50630: PUSH
50631: LD_VAR 0 1
50635: PPUSH
50636: CALL_OW 266
50640: PUSH
50641: LD_INT 5
50643: EQUAL
50644: AND
50645: PUSH
50646: LD_VAR 0 2
50650: PPUSH
50651: CALL_OW 110
50655: PUSH
50656: LD_INT 18
50658: NONEQUAL
50659: AND
50660: IFFALSE 50700
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50662: LD_VAR 0 2
50666: PPUSH
50667: CALL_OW 257
50671: PUSH
50672: LD_INT 5
50674: PUSH
50675: LD_INT 8
50677: PUSH
50678: LD_INT 9
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: LIST
50685: IN
50686: IFFALSE 50700
// SetClass ( unit , 1 ) ;
50688: LD_VAR 0 2
50692: PPUSH
50693: LD_INT 1
50695: PPUSH
50696: CALL_OW 336
// end ;
50700: LD_VAR 0 3
50704: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50705: LD_INT 0
50707: PPUSH
50708: PPUSH
// if not mc_bases or not skirmish then
50709: LD_EXP 90
50713: NOT
50714: PUSH
50715: LD_EXP 88
50719: NOT
50720: OR
50721: IFFALSE 50725
// exit ;
50723: GO 50841
// if GetLives ( abandoned_vehicle ) > 250 then
50725: LD_VAR 0 2
50729: PPUSH
50730: CALL_OW 256
50734: PUSH
50735: LD_INT 250
50737: GREATER
50738: IFFALSE 50742
// exit ;
50740: GO 50841
// for i = 1 to mc_bases do
50742: LD_ADDR_VAR 0 6
50746: PUSH
50747: DOUBLE
50748: LD_INT 1
50750: DEC
50751: ST_TO_ADDR
50752: LD_EXP 90
50756: PUSH
50757: FOR_TO
50758: IFFALSE 50839
// begin if driver in mc_bases [ i ] then
50760: LD_VAR 0 1
50764: PUSH
50765: LD_EXP 90
50769: PUSH
50770: LD_VAR 0 6
50774: ARRAY
50775: IN
50776: IFFALSE 50837
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50778: LD_VAR 0 1
50782: PPUSH
50783: LD_EXP 90
50787: PUSH
50788: LD_VAR 0 6
50792: ARRAY
50793: PPUSH
50794: LD_INT 2
50796: PUSH
50797: LD_INT 30
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 30
50809: PUSH
50810: LD_INT 1
50812: PUSH
50813: EMPTY
50814: LIST
50815: LIST
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: LIST
50821: PPUSH
50822: CALL_OW 72
50826: PUSH
50827: LD_INT 1
50829: ARRAY
50830: PPUSH
50831: CALL 87658 0 2
// break ;
50835: GO 50839
// end ; end ;
50837: GO 50757
50839: POP
50840: POP
// end ; end_of_file
50841: LD_VAR 0 5
50845: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50846: LD_INT 0
50848: PPUSH
50849: PPUSH
// if exist_mode then
50850: LD_VAR 0 2
50854: IFFALSE 50879
// unit := CreateCharacter ( prefix & ident ) else
50856: LD_ADDR_VAR 0 5
50860: PUSH
50861: LD_VAR 0 3
50865: PUSH
50866: LD_VAR 0 1
50870: STR
50871: PPUSH
50872: CALL_OW 34
50876: ST_TO_ADDR
50877: GO 50894
// unit := NewCharacter ( ident ) ;
50879: LD_ADDR_VAR 0 5
50883: PUSH
50884: LD_VAR 0 1
50888: PPUSH
50889: CALL_OW 25
50893: ST_TO_ADDR
// result := unit ;
50894: LD_ADDR_VAR 0 4
50898: PUSH
50899: LD_VAR 0 5
50903: ST_TO_ADDR
// end ;
50904: LD_VAR 0 4
50908: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50909: LD_INT 0
50911: PPUSH
50912: PPUSH
// if not side or not nation then
50913: LD_VAR 0 1
50917: NOT
50918: PUSH
50919: LD_VAR 0 2
50923: NOT
50924: OR
50925: IFFALSE 50929
// exit ;
50927: GO 51693
// case nation of nation_american :
50929: LD_VAR 0 2
50933: PUSH
50934: LD_INT 1
50936: DOUBLE
50937: EQUAL
50938: IFTRUE 50942
50940: GO 51156
50942: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50943: LD_ADDR_VAR 0 4
50947: PUSH
50948: LD_INT 35
50950: PUSH
50951: LD_INT 45
50953: PUSH
50954: LD_INT 46
50956: PUSH
50957: LD_INT 47
50959: PUSH
50960: LD_INT 82
50962: PUSH
50963: LD_INT 83
50965: PUSH
50966: LD_INT 84
50968: PUSH
50969: LD_INT 85
50971: PUSH
50972: LD_INT 86
50974: PUSH
50975: LD_INT 1
50977: PUSH
50978: LD_INT 2
50980: PUSH
50981: LD_INT 6
50983: PUSH
50984: LD_INT 15
50986: PUSH
50987: LD_INT 16
50989: PUSH
50990: LD_INT 7
50992: PUSH
50993: LD_INT 12
50995: PUSH
50996: LD_INT 13
50998: PUSH
50999: LD_INT 10
51001: PUSH
51002: LD_INT 14
51004: PUSH
51005: LD_INT 20
51007: PUSH
51008: LD_INT 21
51010: PUSH
51011: LD_INT 22
51013: PUSH
51014: LD_INT 25
51016: PUSH
51017: LD_INT 32
51019: PUSH
51020: LD_INT 27
51022: PUSH
51023: LD_INT 36
51025: PUSH
51026: LD_INT 69
51028: PUSH
51029: LD_INT 39
51031: PUSH
51032: LD_INT 34
51034: PUSH
51035: LD_INT 40
51037: PUSH
51038: LD_INT 48
51040: PUSH
51041: LD_INT 49
51043: PUSH
51044: LD_INT 50
51046: PUSH
51047: LD_INT 51
51049: PUSH
51050: LD_INT 52
51052: PUSH
51053: LD_INT 53
51055: PUSH
51056: LD_INT 54
51058: PUSH
51059: LD_INT 55
51061: PUSH
51062: LD_INT 56
51064: PUSH
51065: LD_INT 57
51067: PUSH
51068: LD_INT 58
51070: PUSH
51071: LD_INT 59
51073: PUSH
51074: LD_INT 60
51076: PUSH
51077: LD_INT 61
51079: PUSH
51080: LD_INT 62
51082: PUSH
51083: LD_INT 80
51085: PUSH
51086: LD_INT 82
51088: PUSH
51089: LD_INT 83
51091: PUSH
51092: LD_INT 84
51094: PUSH
51095: LD_INT 85
51097: PUSH
51098: LD_INT 86
51100: PUSH
51101: EMPTY
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: ST_TO_ADDR
51154: GO 51617
51156: LD_INT 2
51158: DOUBLE
51159: EQUAL
51160: IFTRUE 51164
51162: GO 51386
51164: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51165: LD_ADDR_VAR 0 4
51169: PUSH
51170: LD_INT 35
51172: PUSH
51173: LD_INT 45
51175: PUSH
51176: LD_INT 46
51178: PUSH
51179: LD_INT 47
51181: PUSH
51182: LD_INT 82
51184: PUSH
51185: LD_INT 83
51187: PUSH
51188: LD_INT 84
51190: PUSH
51191: LD_INT 85
51193: PUSH
51194: LD_INT 87
51196: PUSH
51197: LD_INT 70
51199: PUSH
51200: LD_INT 1
51202: PUSH
51203: LD_INT 11
51205: PUSH
51206: LD_INT 3
51208: PUSH
51209: LD_INT 4
51211: PUSH
51212: LD_INT 5
51214: PUSH
51215: LD_INT 6
51217: PUSH
51218: LD_INT 15
51220: PUSH
51221: LD_INT 18
51223: PUSH
51224: LD_INT 7
51226: PUSH
51227: LD_INT 17
51229: PUSH
51230: LD_INT 8
51232: PUSH
51233: LD_INT 20
51235: PUSH
51236: LD_INT 21
51238: PUSH
51239: LD_INT 22
51241: PUSH
51242: LD_INT 72
51244: PUSH
51245: LD_INT 26
51247: PUSH
51248: LD_INT 69
51250: PUSH
51251: LD_INT 39
51253: PUSH
51254: LD_INT 40
51256: PUSH
51257: LD_INT 41
51259: PUSH
51260: LD_INT 42
51262: PUSH
51263: LD_INT 43
51265: PUSH
51266: LD_INT 48
51268: PUSH
51269: LD_INT 49
51271: PUSH
51272: LD_INT 50
51274: PUSH
51275: LD_INT 51
51277: PUSH
51278: LD_INT 52
51280: PUSH
51281: LD_INT 53
51283: PUSH
51284: LD_INT 54
51286: PUSH
51287: LD_INT 55
51289: PUSH
51290: LD_INT 56
51292: PUSH
51293: LD_INT 60
51295: PUSH
51296: LD_INT 61
51298: PUSH
51299: LD_INT 62
51301: PUSH
51302: LD_INT 66
51304: PUSH
51305: LD_INT 67
51307: PUSH
51308: LD_INT 68
51310: PUSH
51311: LD_INT 81
51313: PUSH
51314: LD_INT 82
51316: PUSH
51317: LD_INT 83
51319: PUSH
51320: LD_INT 84
51322: PUSH
51323: LD_INT 85
51325: PUSH
51326: LD_INT 87
51328: PUSH
51329: EMPTY
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: LIST
51348: LIST
51349: LIST
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: LIST
51358: LIST
51359: LIST
51360: LIST
51361: LIST
51362: LIST
51363: LIST
51364: LIST
51365: LIST
51366: LIST
51367: LIST
51368: LIST
51369: LIST
51370: LIST
51371: LIST
51372: LIST
51373: LIST
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: ST_TO_ADDR
51384: GO 51617
51386: LD_INT 3
51388: DOUBLE
51389: EQUAL
51390: IFTRUE 51394
51392: GO 51616
51394: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51395: LD_ADDR_VAR 0 4
51399: PUSH
51400: LD_INT 46
51402: PUSH
51403: LD_INT 47
51405: PUSH
51406: LD_INT 1
51408: PUSH
51409: LD_INT 2
51411: PUSH
51412: LD_INT 82
51414: PUSH
51415: LD_INT 83
51417: PUSH
51418: LD_INT 84
51420: PUSH
51421: LD_INT 85
51423: PUSH
51424: LD_INT 86
51426: PUSH
51427: LD_INT 11
51429: PUSH
51430: LD_INT 9
51432: PUSH
51433: LD_INT 20
51435: PUSH
51436: LD_INT 19
51438: PUSH
51439: LD_INT 21
51441: PUSH
51442: LD_INT 24
51444: PUSH
51445: LD_INT 22
51447: PUSH
51448: LD_INT 25
51450: PUSH
51451: LD_INT 28
51453: PUSH
51454: LD_INT 29
51456: PUSH
51457: LD_INT 30
51459: PUSH
51460: LD_INT 31
51462: PUSH
51463: LD_INT 37
51465: PUSH
51466: LD_INT 38
51468: PUSH
51469: LD_INT 32
51471: PUSH
51472: LD_INT 27
51474: PUSH
51475: LD_INT 33
51477: PUSH
51478: LD_INT 69
51480: PUSH
51481: LD_INT 39
51483: PUSH
51484: LD_INT 34
51486: PUSH
51487: LD_INT 40
51489: PUSH
51490: LD_INT 71
51492: PUSH
51493: LD_INT 23
51495: PUSH
51496: LD_INT 44
51498: PUSH
51499: LD_INT 48
51501: PUSH
51502: LD_INT 49
51504: PUSH
51505: LD_INT 50
51507: PUSH
51508: LD_INT 51
51510: PUSH
51511: LD_INT 52
51513: PUSH
51514: LD_INT 53
51516: PUSH
51517: LD_INT 54
51519: PUSH
51520: LD_INT 55
51522: PUSH
51523: LD_INT 56
51525: PUSH
51526: LD_INT 57
51528: PUSH
51529: LD_INT 58
51531: PUSH
51532: LD_INT 59
51534: PUSH
51535: LD_INT 63
51537: PUSH
51538: LD_INT 64
51540: PUSH
51541: LD_INT 65
51543: PUSH
51544: LD_INT 82
51546: PUSH
51547: LD_INT 83
51549: PUSH
51550: LD_INT 84
51552: PUSH
51553: LD_INT 85
51555: PUSH
51556: LD_INT 86
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: LIST
51567: LIST
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: LIST
51575: LIST
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: LIST
51582: LIST
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: LIST
51589: LIST
51590: LIST
51591: LIST
51592: LIST
51593: LIST
51594: LIST
51595: LIST
51596: LIST
51597: LIST
51598: LIST
51599: LIST
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: ST_TO_ADDR
51614: GO 51617
51616: POP
// if state > - 1 and state < 3 then
51617: LD_VAR 0 3
51621: PUSH
51622: LD_INT 1
51624: NEG
51625: GREATER
51626: PUSH
51627: LD_VAR 0 3
51631: PUSH
51632: LD_INT 3
51634: LESS
51635: AND
51636: IFFALSE 51693
// for i in result do
51638: LD_ADDR_VAR 0 5
51642: PUSH
51643: LD_VAR 0 4
51647: PUSH
51648: FOR_IN
51649: IFFALSE 51691
// if GetTech ( i , side ) <> state then
51651: LD_VAR 0 5
51655: PPUSH
51656: LD_VAR 0 1
51660: PPUSH
51661: CALL_OW 321
51665: PUSH
51666: LD_VAR 0 3
51670: NONEQUAL
51671: IFFALSE 51689
// result := result diff i ;
51673: LD_ADDR_VAR 0 4
51677: PUSH
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 5
51687: DIFF
51688: ST_TO_ADDR
51689: GO 51648
51691: POP
51692: POP
// end ;
51693: LD_VAR 0 4
51697: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51698: LD_INT 0
51700: PPUSH
51701: PPUSH
51702: PPUSH
// result := true ;
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_INT 1
51710: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51711: LD_ADDR_VAR 0 5
51715: PUSH
51716: LD_VAR 0 2
51720: PPUSH
51721: CALL_OW 480
51725: ST_TO_ADDR
// if not tmp then
51726: LD_VAR 0 5
51730: NOT
51731: IFFALSE 51735
// exit ;
51733: GO 51784
// for i in tmp do
51735: LD_ADDR_VAR 0 4
51739: PUSH
51740: LD_VAR 0 5
51744: PUSH
51745: FOR_IN
51746: IFFALSE 51782
// if GetTech ( i , side ) <> state_researched then
51748: LD_VAR 0 4
51752: PPUSH
51753: LD_VAR 0 1
51757: PPUSH
51758: CALL_OW 321
51762: PUSH
51763: LD_INT 2
51765: NONEQUAL
51766: IFFALSE 51780
// begin result := false ;
51768: LD_ADDR_VAR 0 3
51772: PUSH
51773: LD_INT 0
51775: ST_TO_ADDR
// exit ;
51776: POP
51777: POP
51778: GO 51784
// end ;
51780: GO 51745
51782: POP
51783: POP
// end ;
51784: LD_VAR 0 3
51788: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51789: LD_INT 0
51791: PPUSH
51792: PPUSH
51793: PPUSH
51794: PPUSH
51795: PPUSH
51796: PPUSH
51797: PPUSH
51798: PPUSH
51799: PPUSH
51800: PPUSH
51801: PPUSH
51802: PPUSH
51803: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51804: LD_VAR 0 1
51808: NOT
51809: PUSH
51810: LD_VAR 0 1
51814: PPUSH
51815: CALL_OW 257
51819: PUSH
51820: LD_INT 9
51822: NONEQUAL
51823: OR
51824: IFFALSE 51828
// exit ;
51826: GO 52401
// side := GetSide ( unit ) ;
51828: LD_ADDR_VAR 0 9
51832: PUSH
51833: LD_VAR 0 1
51837: PPUSH
51838: CALL_OW 255
51842: ST_TO_ADDR
// tech_space := tech_spacanom ;
51843: LD_ADDR_VAR 0 12
51847: PUSH
51848: LD_INT 29
51850: ST_TO_ADDR
// tech_time := tech_taurad ;
51851: LD_ADDR_VAR 0 13
51855: PUSH
51856: LD_INT 28
51858: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51859: LD_ADDR_VAR 0 11
51863: PUSH
51864: LD_VAR 0 1
51868: PPUSH
51869: CALL_OW 310
51873: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51874: LD_VAR 0 11
51878: PPUSH
51879: CALL_OW 247
51883: PUSH
51884: LD_INT 2
51886: EQUAL
51887: IFFALSE 51891
// exit ;
51889: GO 52401
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51891: LD_ADDR_VAR 0 8
51895: PUSH
51896: LD_INT 81
51898: PUSH
51899: LD_VAR 0 9
51903: PUSH
51904: EMPTY
51905: LIST
51906: LIST
51907: PUSH
51908: LD_INT 3
51910: PUSH
51911: LD_INT 21
51913: PUSH
51914: LD_INT 3
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: EMPTY
51922: LIST
51923: LIST
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: PPUSH
51929: CALL_OW 69
51933: ST_TO_ADDR
// if not tmp then
51934: LD_VAR 0 8
51938: NOT
51939: IFFALSE 51943
// exit ;
51941: GO 52401
// if in_unit then
51943: LD_VAR 0 11
51947: IFFALSE 51971
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51949: LD_ADDR_VAR 0 10
51953: PUSH
51954: LD_VAR 0 8
51958: PPUSH
51959: LD_VAR 0 11
51963: PPUSH
51964: CALL_OW 74
51968: ST_TO_ADDR
51969: GO 51991
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51971: LD_ADDR_VAR 0 10
51975: PUSH
51976: LD_VAR 0 8
51980: PPUSH
51981: LD_VAR 0 1
51985: PPUSH
51986: CALL_OW 74
51990: ST_TO_ADDR
// if not enemy then
51991: LD_VAR 0 10
51995: NOT
51996: IFFALSE 52000
// exit ;
51998: GO 52401
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52000: LD_VAR 0 11
52004: PUSH
52005: LD_VAR 0 11
52009: PPUSH
52010: LD_VAR 0 10
52014: PPUSH
52015: CALL_OW 296
52019: PUSH
52020: LD_INT 13
52022: GREATER
52023: AND
52024: PUSH
52025: LD_VAR 0 1
52029: PPUSH
52030: LD_VAR 0 10
52034: PPUSH
52035: CALL_OW 296
52039: PUSH
52040: LD_INT 12
52042: GREATER
52043: OR
52044: IFFALSE 52048
// exit ;
52046: GO 52401
// missile := [ 1 ] ;
52048: LD_ADDR_VAR 0 14
52052: PUSH
52053: LD_INT 1
52055: PUSH
52056: EMPTY
52057: LIST
52058: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52059: LD_VAR 0 9
52063: PPUSH
52064: LD_VAR 0 12
52068: PPUSH
52069: CALL_OW 325
52073: IFFALSE 52102
// missile := Insert ( missile , missile + 1 , 2 ) ;
52075: LD_ADDR_VAR 0 14
52079: PUSH
52080: LD_VAR 0 14
52084: PPUSH
52085: LD_VAR 0 14
52089: PUSH
52090: LD_INT 1
52092: PLUS
52093: PPUSH
52094: LD_INT 2
52096: PPUSH
52097: CALL_OW 2
52101: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52102: LD_VAR 0 9
52106: PPUSH
52107: LD_VAR 0 13
52111: PPUSH
52112: CALL_OW 325
52116: PUSH
52117: LD_VAR 0 10
52121: PPUSH
52122: CALL_OW 255
52126: PPUSH
52127: LD_VAR 0 13
52131: PPUSH
52132: CALL_OW 325
52136: NOT
52137: AND
52138: IFFALSE 52167
// missile := Insert ( missile , missile + 1 , 3 ) ;
52140: LD_ADDR_VAR 0 14
52144: PUSH
52145: LD_VAR 0 14
52149: PPUSH
52150: LD_VAR 0 14
52154: PUSH
52155: LD_INT 1
52157: PLUS
52158: PPUSH
52159: LD_INT 3
52161: PPUSH
52162: CALL_OW 2
52166: ST_TO_ADDR
// if missile < 2 then
52167: LD_VAR 0 14
52171: PUSH
52172: LD_INT 2
52174: LESS
52175: IFFALSE 52179
// exit ;
52177: GO 52401
// x := GetX ( enemy ) ;
52179: LD_ADDR_VAR 0 4
52183: PUSH
52184: LD_VAR 0 10
52188: PPUSH
52189: CALL_OW 250
52193: ST_TO_ADDR
// y := GetY ( enemy ) ;
52194: LD_ADDR_VAR 0 5
52198: PUSH
52199: LD_VAR 0 10
52203: PPUSH
52204: CALL_OW 251
52208: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52209: LD_ADDR_VAR 0 6
52213: PUSH
52214: LD_VAR 0 4
52218: PUSH
52219: LD_INT 1
52221: NEG
52222: PPUSH
52223: LD_INT 1
52225: PPUSH
52226: CALL_OW 12
52230: PLUS
52231: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52232: LD_ADDR_VAR 0 7
52236: PUSH
52237: LD_VAR 0 5
52241: PUSH
52242: LD_INT 1
52244: NEG
52245: PPUSH
52246: LD_INT 1
52248: PPUSH
52249: CALL_OW 12
52253: PLUS
52254: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52255: LD_VAR 0 6
52259: PPUSH
52260: LD_VAR 0 7
52264: PPUSH
52265: CALL_OW 488
52269: NOT
52270: IFFALSE 52292
// begin _x := x ;
52272: LD_ADDR_VAR 0 6
52276: PUSH
52277: LD_VAR 0 4
52281: ST_TO_ADDR
// _y := y ;
52282: LD_ADDR_VAR 0 7
52286: PUSH
52287: LD_VAR 0 5
52291: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52292: LD_ADDR_VAR 0 3
52296: PUSH
52297: LD_INT 1
52299: PPUSH
52300: LD_VAR 0 14
52304: PPUSH
52305: CALL_OW 12
52309: ST_TO_ADDR
// case i of 1 :
52310: LD_VAR 0 3
52314: PUSH
52315: LD_INT 1
52317: DOUBLE
52318: EQUAL
52319: IFTRUE 52323
52321: GO 52340
52323: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52324: LD_VAR 0 1
52328: PPUSH
52329: LD_VAR 0 10
52333: PPUSH
52334: CALL_OW 115
52338: GO 52401
52340: LD_INT 2
52342: DOUBLE
52343: EQUAL
52344: IFTRUE 52348
52346: GO 52370
52348: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52349: LD_VAR 0 1
52353: PPUSH
52354: LD_VAR 0 6
52358: PPUSH
52359: LD_VAR 0 7
52363: PPUSH
52364: CALL_OW 153
52368: GO 52401
52370: LD_INT 3
52372: DOUBLE
52373: EQUAL
52374: IFTRUE 52378
52376: GO 52400
52378: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52379: LD_VAR 0 1
52383: PPUSH
52384: LD_VAR 0 6
52388: PPUSH
52389: LD_VAR 0 7
52393: PPUSH
52394: CALL_OW 154
52398: GO 52401
52400: POP
// end ;
52401: LD_VAR 0 2
52405: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52406: LD_INT 0
52408: PPUSH
52409: PPUSH
52410: PPUSH
52411: PPUSH
52412: PPUSH
52413: PPUSH
// if not unit or not building then
52414: LD_VAR 0 1
52418: NOT
52419: PUSH
52420: LD_VAR 0 2
52424: NOT
52425: OR
52426: IFFALSE 52430
// exit ;
52428: GO 52588
// x := GetX ( building ) ;
52430: LD_ADDR_VAR 0 5
52434: PUSH
52435: LD_VAR 0 2
52439: PPUSH
52440: CALL_OW 250
52444: ST_TO_ADDR
// y := GetY ( building ) ;
52445: LD_ADDR_VAR 0 6
52449: PUSH
52450: LD_VAR 0 2
52454: PPUSH
52455: CALL_OW 251
52459: ST_TO_ADDR
// for i = 0 to 5 do
52460: LD_ADDR_VAR 0 4
52464: PUSH
52465: DOUBLE
52466: LD_INT 0
52468: DEC
52469: ST_TO_ADDR
52470: LD_INT 5
52472: PUSH
52473: FOR_TO
52474: IFFALSE 52586
// begin _x := ShiftX ( x , i , 3 ) ;
52476: LD_ADDR_VAR 0 7
52480: PUSH
52481: LD_VAR 0 5
52485: PPUSH
52486: LD_VAR 0 4
52490: PPUSH
52491: LD_INT 3
52493: PPUSH
52494: CALL_OW 272
52498: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52499: LD_ADDR_VAR 0 8
52503: PUSH
52504: LD_VAR 0 6
52508: PPUSH
52509: LD_VAR 0 4
52513: PPUSH
52514: LD_INT 3
52516: PPUSH
52517: CALL_OW 273
52521: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52522: LD_VAR 0 7
52526: PPUSH
52527: LD_VAR 0 8
52531: PPUSH
52532: CALL_OW 488
52536: NOT
52537: IFFALSE 52541
// continue ;
52539: GO 52473
// if HexInfo ( _x , _y ) = 0 then
52541: LD_VAR 0 7
52545: PPUSH
52546: LD_VAR 0 8
52550: PPUSH
52551: CALL_OW 428
52555: PUSH
52556: LD_INT 0
52558: EQUAL
52559: IFFALSE 52584
// begin ComMoveXY ( unit , _x , _y ) ;
52561: LD_VAR 0 1
52565: PPUSH
52566: LD_VAR 0 7
52570: PPUSH
52571: LD_VAR 0 8
52575: PPUSH
52576: CALL_OW 111
// exit ;
52580: POP
52581: POP
52582: GO 52588
// end ; end ;
52584: GO 52473
52586: POP
52587: POP
// end ;
52588: LD_VAR 0 3
52592: RET
// export function ScanBase ( side , base_area ) ; begin
52593: LD_INT 0
52595: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52596: LD_ADDR_VAR 0 3
52600: PUSH
52601: LD_VAR 0 2
52605: PPUSH
52606: LD_INT 81
52608: PUSH
52609: LD_VAR 0 1
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: PPUSH
52618: CALL_OW 70
52622: ST_TO_ADDR
// end ;
52623: LD_VAR 0 3
52627: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52628: LD_INT 0
52630: PPUSH
52631: PPUSH
52632: PPUSH
52633: PPUSH
// result := false ;
52634: LD_ADDR_VAR 0 2
52638: PUSH
52639: LD_INT 0
52641: ST_TO_ADDR
// side := GetSide ( unit ) ;
52642: LD_ADDR_VAR 0 3
52646: PUSH
52647: LD_VAR 0 1
52651: PPUSH
52652: CALL_OW 255
52656: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52657: LD_ADDR_VAR 0 4
52661: PUSH
52662: LD_VAR 0 1
52666: PPUSH
52667: CALL_OW 248
52671: ST_TO_ADDR
// case nat of 1 :
52672: LD_VAR 0 4
52676: PUSH
52677: LD_INT 1
52679: DOUBLE
52680: EQUAL
52681: IFTRUE 52685
52683: GO 52696
52685: POP
// tech := tech_lassight ; 2 :
52686: LD_ADDR_VAR 0 5
52690: PUSH
52691: LD_INT 12
52693: ST_TO_ADDR
52694: GO 52735
52696: LD_INT 2
52698: DOUBLE
52699: EQUAL
52700: IFTRUE 52704
52702: GO 52715
52704: POP
// tech := tech_mortar ; 3 :
52705: LD_ADDR_VAR 0 5
52709: PUSH
52710: LD_INT 41
52712: ST_TO_ADDR
52713: GO 52735
52715: LD_INT 3
52717: DOUBLE
52718: EQUAL
52719: IFTRUE 52723
52721: GO 52734
52723: POP
// tech := tech_bazooka ; end ;
52724: LD_ADDR_VAR 0 5
52728: PUSH
52729: LD_INT 44
52731: ST_TO_ADDR
52732: GO 52735
52734: POP
// if Researched ( side , tech ) then
52735: LD_VAR 0 3
52739: PPUSH
52740: LD_VAR 0 5
52744: PPUSH
52745: CALL_OW 325
52749: IFFALSE 52776
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52751: LD_ADDR_VAR 0 2
52755: PUSH
52756: LD_INT 5
52758: PUSH
52759: LD_INT 8
52761: PUSH
52762: LD_INT 9
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: LIST
52769: PUSH
52770: LD_VAR 0 4
52774: ARRAY
52775: ST_TO_ADDR
// end ;
52776: LD_VAR 0 2
52780: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52781: LD_INT 0
52783: PPUSH
52784: PPUSH
52785: PPUSH
// if not mines then
52786: LD_VAR 0 2
52790: NOT
52791: IFFALSE 52795
// exit ;
52793: GO 52939
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52795: LD_ADDR_VAR 0 5
52799: PUSH
52800: LD_INT 81
52802: PUSH
52803: LD_VAR 0 1
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: PUSH
52812: LD_INT 3
52814: PUSH
52815: LD_INT 21
52817: PUSH
52818: LD_INT 3
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PPUSH
52833: CALL_OW 69
52837: ST_TO_ADDR
// for i in mines do
52838: LD_ADDR_VAR 0 4
52842: PUSH
52843: LD_VAR 0 2
52847: PUSH
52848: FOR_IN
52849: IFFALSE 52937
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52851: LD_VAR 0 4
52855: PUSH
52856: LD_INT 1
52858: ARRAY
52859: PPUSH
52860: LD_VAR 0 4
52864: PUSH
52865: LD_INT 2
52867: ARRAY
52868: PPUSH
52869: CALL_OW 458
52873: NOT
52874: IFFALSE 52878
// continue ;
52876: GO 52848
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52878: LD_VAR 0 4
52882: PUSH
52883: LD_INT 1
52885: ARRAY
52886: PPUSH
52887: LD_VAR 0 4
52891: PUSH
52892: LD_INT 2
52894: ARRAY
52895: PPUSH
52896: CALL_OW 428
52900: PUSH
52901: LD_VAR 0 5
52905: IN
52906: IFFALSE 52935
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52908: LD_VAR 0 4
52912: PUSH
52913: LD_INT 1
52915: ARRAY
52916: PPUSH
52917: LD_VAR 0 4
52921: PUSH
52922: LD_INT 2
52924: ARRAY
52925: PPUSH
52926: LD_VAR 0 1
52930: PPUSH
52931: CALL_OW 456
// end ;
52935: GO 52848
52937: POP
52938: POP
// end ;
52939: LD_VAR 0 3
52943: RET
// export function Count ( array ) ; var i ; begin
52944: LD_INT 0
52946: PPUSH
52947: PPUSH
// result := 0 ;
52948: LD_ADDR_VAR 0 2
52952: PUSH
52953: LD_INT 0
52955: ST_TO_ADDR
// for i in array do
52956: LD_ADDR_VAR 0 3
52960: PUSH
52961: LD_VAR 0 1
52965: PUSH
52966: FOR_IN
52967: IFFALSE 52991
// if i then
52969: LD_VAR 0 3
52973: IFFALSE 52989
// result := result + 1 ;
52975: LD_ADDR_VAR 0 2
52979: PUSH
52980: LD_VAR 0 2
52984: PUSH
52985: LD_INT 1
52987: PLUS
52988: ST_TO_ADDR
52989: GO 52966
52991: POP
52992: POP
// end ;
52993: LD_VAR 0 2
52997: RET
// export function IsEmpty ( building ) ; begin
52998: LD_INT 0
53000: PPUSH
// if not building then
53001: LD_VAR 0 1
53005: NOT
53006: IFFALSE 53010
// exit ;
53008: GO 53053
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53010: LD_ADDR_VAR 0 2
53014: PUSH
53015: LD_VAR 0 1
53019: PUSH
53020: LD_INT 22
53022: PUSH
53023: LD_VAR 0 1
53027: PPUSH
53028: CALL_OW 255
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PUSH
53037: LD_INT 58
53039: PUSH
53040: EMPTY
53041: LIST
53042: PUSH
53043: EMPTY
53044: LIST
53045: LIST
53046: PPUSH
53047: CALL_OW 69
53051: IN
53052: ST_TO_ADDR
// end ;
53053: LD_VAR 0 2
53057: RET
// export function IsNotFull ( building ) ; begin
53058: LD_INT 0
53060: PPUSH
// if not building then
53061: LD_VAR 0 1
53065: NOT
53066: IFFALSE 53070
// exit ;
53068: GO 53089
// result := UnitsInside ( building ) < 6 ;
53070: LD_ADDR_VAR 0 2
53074: PUSH
53075: LD_VAR 0 1
53079: PPUSH
53080: CALL_OW 313
53084: PUSH
53085: LD_INT 6
53087: LESS
53088: ST_TO_ADDR
// end ;
53089: LD_VAR 0 2
53093: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53094: LD_INT 0
53096: PPUSH
53097: PPUSH
53098: PPUSH
53099: PPUSH
// tmp := [ ] ;
53100: LD_ADDR_VAR 0 3
53104: PUSH
53105: EMPTY
53106: ST_TO_ADDR
// list := [ ] ;
53107: LD_ADDR_VAR 0 5
53111: PUSH
53112: EMPTY
53113: ST_TO_ADDR
// for i = 16 to 25 do
53114: LD_ADDR_VAR 0 4
53118: PUSH
53119: DOUBLE
53120: LD_INT 16
53122: DEC
53123: ST_TO_ADDR
53124: LD_INT 25
53126: PUSH
53127: FOR_TO
53128: IFFALSE 53201
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_VAR 0 3
53139: PUSH
53140: LD_INT 22
53142: PUSH
53143: LD_VAR 0 1
53147: PPUSH
53148: CALL_OW 255
53152: PUSH
53153: EMPTY
53154: LIST
53155: LIST
53156: PUSH
53157: LD_INT 91
53159: PUSH
53160: LD_VAR 0 1
53164: PUSH
53165: LD_INT 6
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: LIST
53172: PUSH
53173: LD_INT 30
53175: PUSH
53176: LD_VAR 0 4
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: PUSH
53185: EMPTY
53186: LIST
53187: LIST
53188: LIST
53189: PUSH
53190: EMPTY
53191: LIST
53192: PPUSH
53193: CALL_OW 69
53197: ADD
53198: ST_TO_ADDR
53199: GO 53127
53201: POP
53202: POP
// for i = 1 to tmp do
53203: LD_ADDR_VAR 0 4
53207: PUSH
53208: DOUBLE
53209: LD_INT 1
53211: DEC
53212: ST_TO_ADDR
53213: LD_VAR 0 3
53217: PUSH
53218: FOR_TO
53219: IFFALSE 53307
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53221: LD_ADDR_VAR 0 5
53225: PUSH
53226: LD_VAR 0 5
53230: PUSH
53231: LD_VAR 0 3
53235: PUSH
53236: LD_VAR 0 4
53240: ARRAY
53241: PPUSH
53242: CALL_OW 266
53246: PUSH
53247: LD_VAR 0 3
53251: PUSH
53252: LD_VAR 0 4
53256: ARRAY
53257: PPUSH
53258: CALL_OW 250
53262: PUSH
53263: LD_VAR 0 3
53267: PUSH
53268: LD_VAR 0 4
53272: ARRAY
53273: PPUSH
53274: CALL_OW 251
53278: PUSH
53279: LD_VAR 0 3
53283: PUSH
53284: LD_VAR 0 4
53288: ARRAY
53289: PPUSH
53290: CALL_OW 254
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: LIST
53300: PUSH
53301: EMPTY
53302: LIST
53303: ADD
53304: ST_TO_ADDR
53305: GO 53218
53307: POP
53308: POP
// result := list ;
53309: LD_ADDR_VAR 0 2
53313: PUSH
53314: LD_VAR 0 5
53318: ST_TO_ADDR
// end ;
53319: LD_VAR 0 2
53323: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53324: LD_INT 0
53326: PPUSH
53327: PPUSH
53328: PPUSH
53329: PPUSH
53330: PPUSH
53331: PPUSH
53332: PPUSH
// if not factory then
53333: LD_VAR 0 1
53337: NOT
53338: IFFALSE 53342
// exit ;
53340: GO 53935
// if control = control_apeman then
53342: LD_VAR 0 4
53346: PUSH
53347: LD_INT 5
53349: EQUAL
53350: IFFALSE 53459
// begin tmp := UnitsInside ( factory ) ;
53352: LD_ADDR_VAR 0 8
53356: PUSH
53357: LD_VAR 0 1
53361: PPUSH
53362: CALL_OW 313
53366: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53367: LD_VAR 0 8
53371: PPUSH
53372: LD_INT 25
53374: PUSH
53375: LD_INT 12
53377: PUSH
53378: EMPTY
53379: LIST
53380: LIST
53381: PPUSH
53382: CALL_OW 72
53386: NOT
53387: IFFALSE 53397
// control := control_manual ;
53389: LD_ADDR_VAR 0 4
53393: PUSH
53394: LD_INT 1
53396: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53397: LD_ADDR_VAR 0 8
53401: PUSH
53402: LD_VAR 0 1
53406: PPUSH
53407: CALL 53094 0 1
53411: ST_TO_ADDR
// if tmp then
53412: LD_VAR 0 8
53416: IFFALSE 53459
// begin for i in tmp do
53418: LD_ADDR_VAR 0 7
53422: PUSH
53423: LD_VAR 0 8
53427: PUSH
53428: FOR_IN
53429: IFFALSE 53457
// if i [ 1 ] = b_ext_radio then
53431: LD_VAR 0 7
53435: PUSH
53436: LD_INT 1
53438: ARRAY
53439: PUSH
53440: LD_INT 22
53442: EQUAL
53443: IFFALSE 53455
// begin control := control_remote ;
53445: LD_ADDR_VAR 0 4
53449: PUSH
53450: LD_INT 2
53452: ST_TO_ADDR
// break ;
53453: GO 53457
// end ;
53455: GO 53428
53457: POP
53458: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53459: LD_VAR 0 1
53463: PPUSH
53464: LD_VAR 0 2
53468: PPUSH
53469: LD_VAR 0 3
53473: PPUSH
53474: LD_VAR 0 4
53478: PPUSH
53479: LD_VAR 0 5
53483: PPUSH
53484: CALL_OW 448
53488: IFFALSE 53523
// begin result := [ chassis , engine , control , weapon ] ;
53490: LD_ADDR_VAR 0 6
53494: PUSH
53495: LD_VAR 0 2
53499: PUSH
53500: LD_VAR 0 3
53504: PUSH
53505: LD_VAR 0 4
53509: PUSH
53510: LD_VAR 0 5
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: LIST
53519: LIST
53520: ST_TO_ADDR
// exit ;
53521: GO 53935
// end ; _chassis := AvailableChassisList ( factory ) ;
53523: LD_ADDR_VAR 0 9
53527: PUSH
53528: LD_VAR 0 1
53532: PPUSH
53533: CALL_OW 475
53537: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53538: LD_ADDR_VAR 0 11
53542: PUSH
53543: LD_VAR 0 1
53547: PPUSH
53548: CALL_OW 476
53552: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53553: LD_ADDR_VAR 0 12
53557: PUSH
53558: LD_VAR 0 1
53562: PPUSH
53563: CALL_OW 477
53567: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53568: LD_ADDR_VAR 0 10
53572: PUSH
53573: LD_VAR 0 1
53577: PPUSH
53578: CALL_OW 478
53582: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53583: LD_VAR 0 9
53587: NOT
53588: PUSH
53589: LD_VAR 0 11
53593: NOT
53594: OR
53595: PUSH
53596: LD_VAR 0 12
53600: NOT
53601: OR
53602: PUSH
53603: LD_VAR 0 10
53607: NOT
53608: OR
53609: IFFALSE 53644
// begin result := [ chassis , engine , control , weapon ] ;
53611: LD_ADDR_VAR 0 6
53615: PUSH
53616: LD_VAR 0 2
53620: PUSH
53621: LD_VAR 0 3
53625: PUSH
53626: LD_VAR 0 4
53630: PUSH
53631: LD_VAR 0 5
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: LIST
53640: LIST
53641: ST_TO_ADDR
// exit ;
53642: GO 53935
// end ; if not chassis in _chassis then
53644: LD_VAR 0 2
53648: PUSH
53649: LD_VAR 0 9
53653: IN
53654: NOT
53655: IFFALSE 53681
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53657: LD_ADDR_VAR 0 2
53661: PUSH
53662: LD_VAR 0 9
53666: PUSH
53667: LD_INT 1
53669: PPUSH
53670: LD_VAR 0 9
53674: PPUSH
53675: CALL_OW 12
53679: ARRAY
53680: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53681: LD_VAR 0 2
53685: PPUSH
53686: LD_VAR 0 3
53690: PPUSH
53691: CALL 53940 0 2
53695: NOT
53696: IFFALSE 53755
// repeat engine := _engine [ 1 ] ;
53698: LD_ADDR_VAR 0 3
53702: PUSH
53703: LD_VAR 0 11
53707: PUSH
53708: LD_INT 1
53710: ARRAY
53711: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53712: LD_ADDR_VAR 0 11
53716: PUSH
53717: LD_VAR 0 11
53721: PPUSH
53722: LD_INT 1
53724: PPUSH
53725: CALL_OW 3
53729: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53730: LD_VAR 0 2
53734: PPUSH
53735: LD_VAR 0 3
53739: PPUSH
53740: CALL 53940 0 2
53744: PUSH
53745: LD_VAR 0 11
53749: PUSH
53750: EMPTY
53751: EQUAL
53752: OR
53753: IFFALSE 53698
// if not control in _control then
53755: LD_VAR 0 4
53759: PUSH
53760: LD_VAR 0 12
53764: IN
53765: NOT
53766: IFFALSE 53792
// control := _control [ rand ( 1 , _control ) ] ;
53768: LD_ADDR_VAR 0 4
53772: PUSH
53773: LD_VAR 0 12
53777: PUSH
53778: LD_INT 1
53780: PPUSH
53781: LD_VAR 0 12
53785: PPUSH
53786: CALL_OW 12
53790: ARRAY
53791: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53792: LD_VAR 0 2
53796: PPUSH
53797: LD_VAR 0 5
53801: PPUSH
53802: CALL 54160 0 2
53806: NOT
53807: IFFALSE 53866
// repeat weapon := _weapon [ 1 ] ;
53809: LD_ADDR_VAR 0 5
53813: PUSH
53814: LD_VAR 0 10
53818: PUSH
53819: LD_INT 1
53821: ARRAY
53822: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53823: LD_ADDR_VAR 0 10
53827: PUSH
53828: LD_VAR 0 10
53832: PPUSH
53833: LD_INT 1
53835: PPUSH
53836: CALL_OW 3
53840: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53841: LD_VAR 0 2
53845: PPUSH
53846: LD_VAR 0 5
53850: PPUSH
53851: CALL 54160 0 2
53855: PUSH
53856: LD_VAR 0 10
53860: PUSH
53861: EMPTY
53862: EQUAL
53863: OR
53864: IFFALSE 53809
// result := [ ] ;
53866: LD_ADDR_VAR 0 6
53870: PUSH
53871: EMPTY
53872: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53873: LD_VAR 0 1
53877: PPUSH
53878: LD_VAR 0 2
53882: PPUSH
53883: LD_VAR 0 3
53887: PPUSH
53888: LD_VAR 0 4
53892: PPUSH
53893: LD_VAR 0 5
53897: PPUSH
53898: CALL_OW 448
53902: IFFALSE 53935
// result := [ chassis , engine , control , weapon ] ;
53904: LD_ADDR_VAR 0 6
53908: PUSH
53909: LD_VAR 0 2
53913: PUSH
53914: LD_VAR 0 3
53918: PUSH
53919: LD_VAR 0 4
53923: PUSH
53924: LD_VAR 0 5
53928: PUSH
53929: EMPTY
53930: LIST
53931: LIST
53932: LIST
53933: LIST
53934: ST_TO_ADDR
// end ;
53935: LD_VAR 0 6
53939: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53940: LD_INT 0
53942: PPUSH
// if not chassis or not engine then
53943: LD_VAR 0 1
53947: NOT
53948: PUSH
53949: LD_VAR 0 2
53953: NOT
53954: OR
53955: IFFALSE 53959
// exit ;
53957: GO 54155
// case engine of engine_solar :
53959: LD_VAR 0 2
53963: PUSH
53964: LD_INT 2
53966: DOUBLE
53967: EQUAL
53968: IFTRUE 53972
53970: GO 54010
53972: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53973: LD_ADDR_VAR 0 3
53977: PUSH
53978: LD_INT 11
53980: PUSH
53981: LD_INT 12
53983: PUSH
53984: LD_INT 13
53986: PUSH
53987: LD_INT 14
53989: PUSH
53990: LD_INT 1
53992: PUSH
53993: LD_INT 2
53995: PUSH
53996: LD_INT 3
53998: PUSH
53999: EMPTY
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: LIST
54006: LIST
54007: ST_TO_ADDR
54008: GO 54139
54010: LD_INT 1
54012: DOUBLE
54013: EQUAL
54014: IFTRUE 54018
54016: GO 54080
54018: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54019: LD_ADDR_VAR 0 3
54023: PUSH
54024: LD_INT 11
54026: PUSH
54027: LD_INT 12
54029: PUSH
54030: LD_INT 13
54032: PUSH
54033: LD_INT 14
54035: PUSH
54036: LD_INT 1
54038: PUSH
54039: LD_INT 2
54041: PUSH
54042: LD_INT 3
54044: PUSH
54045: LD_INT 4
54047: PUSH
54048: LD_INT 5
54050: PUSH
54051: LD_INT 21
54053: PUSH
54054: LD_INT 23
54056: PUSH
54057: LD_INT 22
54059: PUSH
54060: LD_INT 24
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: LIST
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: LIST
54077: ST_TO_ADDR
54078: GO 54139
54080: LD_INT 3
54082: DOUBLE
54083: EQUAL
54084: IFTRUE 54088
54086: GO 54138
54088: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54089: LD_ADDR_VAR 0 3
54093: PUSH
54094: LD_INT 13
54096: PUSH
54097: LD_INT 14
54099: PUSH
54100: LD_INT 2
54102: PUSH
54103: LD_INT 3
54105: PUSH
54106: LD_INT 4
54108: PUSH
54109: LD_INT 5
54111: PUSH
54112: LD_INT 21
54114: PUSH
54115: LD_INT 22
54117: PUSH
54118: LD_INT 23
54120: PUSH
54121: LD_INT 24
54123: PUSH
54124: EMPTY
54125: LIST
54126: LIST
54127: LIST
54128: LIST
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: LIST
54135: ST_TO_ADDR
54136: GO 54139
54138: POP
// result := ( chassis in result ) ;
54139: LD_ADDR_VAR 0 3
54143: PUSH
54144: LD_VAR 0 1
54148: PUSH
54149: LD_VAR 0 3
54153: IN
54154: ST_TO_ADDR
// end ;
54155: LD_VAR 0 3
54159: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54160: LD_INT 0
54162: PPUSH
// if not chassis or not weapon then
54163: LD_VAR 0 1
54167: NOT
54168: PUSH
54169: LD_VAR 0 2
54173: NOT
54174: OR
54175: IFFALSE 54179
// exit ;
54177: GO 55205
// case weapon of us_machine_gun :
54179: LD_VAR 0 2
54183: PUSH
54184: LD_INT 2
54186: DOUBLE
54187: EQUAL
54188: IFTRUE 54192
54190: GO 54222
54192: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54193: LD_ADDR_VAR 0 3
54197: PUSH
54198: LD_INT 1
54200: PUSH
54201: LD_INT 2
54203: PUSH
54204: LD_INT 3
54206: PUSH
54207: LD_INT 4
54209: PUSH
54210: LD_INT 5
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: LIST
54217: LIST
54218: LIST
54219: ST_TO_ADDR
54220: GO 55189
54222: LD_INT 3
54224: DOUBLE
54225: EQUAL
54226: IFTRUE 54230
54228: GO 54260
54230: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54231: LD_ADDR_VAR 0 3
54235: PUSH
54236: LD_INT 1
54238: PUSH
54239: LD_INT 2
54241: PUSH
54242: LD_INT 3
54244: PUSH
54245: LD_INT 4
54247: PUSH
54248: LD_INT 5
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: LIST
54255: LIST
54256: LIST
54257: ST_TO_ADDR
54258: GO 55189
54260: LD_INT 11
54262: DOUBLE
54263: EQUAL
54264: IFTRUE 54268
54266: GO 54298
54268: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54269: LD_ADDR_VAR 0 3
54273: PUSH
54274: LD_INT 1
54276: PUSH
54277: LD_INT 2
54279: PUSH
54280: LD_INT 3
54282: PUSH
54283: LD_INT 4
54285: PUSH
54286: LD_INT 5
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: LIST
54293: LIST
54294: LIST
54295: ST_TO_ADDR
54296: GO 55189
54298: LD_INT 4
54300: DOUBLE
54301: EQUAL
54302: IFTRUE 54306
54304: GO 54332
54306: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54307: LD_ADDR_VAR 0 3
54311: PUSH
54312: LD_INT 2
54314: PUSH
54315: LD_INT 3
54317: PUSH
54318: LD_INT 4
54320: PUSH
54321: LD_INT 5
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: LIST
54328: LIST
54329: ST_TO_ADDR
54330: GO 55189
54332: LD_INT 5
54334: DOUBLE
54335: EQUAL
54336: IFTRUE 54340
54338: GO 54366
54340: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54341: LD_ADDR_VAR 0 3
54345: PUSH
54346: LD_INT 2
54348: PUSH
54349: LD_INT 3
54351: PUSH
54352: LD_INT 4
54354: PUSH
54355: LD_INT 5
54357: PUSH
54358: EMPTY
54359: LIST
54360: LIST
54361: LIST
54362: LIST
54363: ST_TO_ADDR
54364: GO 55189
54366: LD_INT 9
54368: DOUBLE
54369: EQUAL
54370: IFTRUE 54374
54372: GO 54400
54374: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54375: LD_ADDR_VAR 0 3
54379: PUSH
54380: LD_INT 2
54382: PUSH
54383: LD_INT 3
54385: PUSH
54386: LD_INT 4
54388: PUSH
54389: LD_INT 5
54391: PUSH
54392: EMPTY
54393: LIST
54394: LIST
54395: LIST
54396: LIST
54397: ST_TO_ADDR
54398: GO 55189
54400: LD_INT 7
54402: DOUBLE
54403: EQUAL
54404: IFTRUE 54408
54406: GO 54434
54408: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54409: LD_ADDR_VAR 0 3
54413: PUSH
54414: LD_INT 2
54416: PUSH
54417: LD_INT 3
54419: PUSH
54420: LD_INT 4
54422: PUSH
54423: LD_INT 5
54425: PUSH
54426: EMPTY
54427: LIST
54428: LIST
54429: LIST
54430: LIST
54431: ST_TO_ADDR
54432: GO 55189
54434: LD_INT 12
54436: DOUBLE
54437: EQUAL
54438: IFTRUE 54442
54440: GO 54468
54442: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54443: LD_ADDR_VAR 0 3
54447: PUSH
54448: LD_INT 2
54450: PUSH
54451: LD_INT 3
54453: PUSH
54454: LD_INT 4
54456: PUSH
54457: LD_INT 5
54459: PUSH
54460: EMPTY
54461: LIST
54462: LIST
54463: LIST
54464: LIST
54465: ST_TO_ADDR
54466: GO 55189
54468: LD_INT 13
54470: DOUBLE
54471: EQUAL
54472: IFTRUE 54476
54474: GO 54502
54476: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54477: LD_ADDR_VAR 0 3
54481: PUSH
54482: LD_INT 2
54484: PUSH
54485: LD_INT 3
54487: PUSH
54488: LD_INT 4
54490: PUSH
54491: LD_INT 5
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: LIST
54498: LIST
54499: ST_TO_ADDR
54500: GO 55189
54502: LD_INT 14
54504: DOUBLE
54505: EQUAL
54506: IFTRUE 54510
54508: GO 54528
54510: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54511: LD_ADDR_VAR 0 3
54515: PUSH
54516: LD_INT 4
54518: PUSH
54519: LD_INT 5
54521: PUSH
54522: EMPTY
54523: LIST
54524: LIST
54525: ST_TO_ADDR
54526: GO 55189
54528: LD_INT 6
54530: DOUBLE
54531: EQUAL
54532: IFTRUE 54536
54534: GO 54554
54536: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54537: LD_ADDR_VAR 0 3
54541: PUSH
54542: LD_INT 4
54544: PUSH
54545: LD_INT 5
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: ST_TO_ADDR
54552: GO 55189
54554: LD_INT 10
54556: DOUBLE
54557: EQUAL
54558: IFTRUE 54562
54560: GO 54580
54562: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54563: LD_ADDR_VAR 0 3
54567: PUSH
54568: LD_INT 4
54570: PUSH
54571: LD_INT 5
54573: PUSH
54574: EMPTY
54575: LIST
54576: LIST
54577: ST_TO_ADDR
54578: GO 55189
54580: LD_INT 22
54582: DOUBLE
54583: EQUAL
54584: IFTRUE 54588
54586: GO 54614
54588: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54589: LD_ADDR_VAR 0 3
54593: PUSH
54594: LD_INT 11
54596: PUSH
54597: LD_INT 12
54599: PUSH
54600: LD_INT 13
54602: PUSH
54603: LD_INT 14
54605: PUSH
54606: EMPTY
54607: LIST
54608: LIST
54609: LIST
54610: LIST
54611: ST_TO_ADDR
54612: GO 55189
54614: LD_INT 23
54616: DOUBLE
54617: EQUAL
54618: IFTRUE 54622
54620: GO 54648
54622: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54623: LD_ADDR_VAR 0 3
54627: PUSH
54628: LD_INT 11
54630: PUSH
54631: LD_INT 12
54633: PUSH
54634: LD_INT 13
54636: PUSH
54637: LD_INT 14
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: LIST
54645: ST_TO_ADDR
54646: GO 55189
54648: LD_INT 24
54650: DOUBLE
54651: EQUAL
54652: IFTRUE 54656
54654: GO 54682
54656: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54657: LD_ADDR_VAR 0 3
54661: PUSH
54662: LD_INT 11
54664: PUSH
54665: LD_INT 12
54667: PUSH
54668: LD_INT 13
54670: PUSH
54671: LD_INT 14
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: LIST
54678: LIST
54679: ST_TO_ADDR
54680: GO 55189
54682: LD_INT 30
54684: DOUBLE
54685: EQUAL
54686: IFTRUE 54690
54688: GO 54716
54690: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54691: LD_ADDR_VAR 0 3
54695: PUSH
54696: LD_INT 11
54698: PUSH
54699: LD_INT 12
54701: PUSH
54702: LD_INT 13
54704: PUSH
54705: LD_INT 14
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: LIST
54712: LIST
54713: ST_TO_ADDR
54714: GO 55189
54716: LD_INT 25
54718: DOUBLE
54719: EQUAL
54720: IFTRUE 54724
54722: GO 54742
54724: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54725: LD_ADDR_VAR 0 3
54729: PUSH
54730: LD_INT 13
54732: PUSH
54733: LD_INT 14
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: ST_TO_ADDR
54740: GO 55189
54742: LD_INT 27
54744: DOUBLE
54745: EQUAL
54746: IFTRUE 54750
54748: GO 54768
54750: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54751: LD_ADDR_VAR 0 3
54755: PUSH
54756: LD_INT 13
54758: PUSH
54759: LD_INT 14
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: ST_TO_ADDR
54766: GO 55189
54768: LD_INT 28
54770: DOUBLE
54771: EQUAL
54772: IFTRUE 54776
54774: GO 54794
54776: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54777: LD_ADDR_VAR 0 3
54781: PUSH
54782: LD_INT 13
54784: PUSH
54785: LD_INT 14
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: ST_TO_ADDR
54792: GO 55189
54794: LD_INT 29
54796: DOUBLE
54797: EQUAL
54798: IFTRUE 54802
54800: GO 54820
54802: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54803: LD_ADDR_VAR 0 3
54807: PUSH
54808: LD_INT 13
54810: PUSH
54811: LD_INT 14
54813: PUSH
54814: EMPTY
54815: LIST
54816: LIST
54817: ST_TO_ADDR
54818: GO 55189
54820: LD_INT 31
54822: DOUBLE
54823: EQUAL
54824: IFTRUE 54828
54826: GO 54846
54828: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54829: LD_ADDR_VAR 0 3
54833: PUSH
54834: LD_INT 13
54836: PUSH
54837: LD_INT 14
54839: PUSH
54840: EMPTY
54841: LIST
54842: LIST
54843: ST_TO_ADDR
54844: GO 55189
54846: LD_INT 26
54848: DOUBLE
54849: EQUAL
54850: IFTRUE 54854
54852: GO 54872
54854: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54855: LD_ADDR_VAR 0 3
54859: PUSH
54860: LD_INT 13
54862: PUSH
54863: LD_INT 14
54865: PUSH
54866: EMPTY
54867: LIST
54868: LIST
54869: ST_TO_ADDR
54870: GO 55189
54872: LD_INT 42
54874: DOUBLE
54875: EQUAL
54876: IFTRUE 54880
54878: GO 54906
54880: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54881: LD_ADDR_VAR 0 3
54885: PUSH
54886: LD_INT 21
54888: PUSH
54889: LD_INT 22
54891: PUSH
54892: LD_INT 23
54894: PUSH
54895: LD_INT 24
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: LIST
54902: LIST
54903: ST_TO_ADDR
54904: GO 55189
54906: LD_INT 43
54908: DOUBLE
54909: EQUAL
54910: IFTRUE 54914
54912: GO 54940
54914: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54915: LD_ADDR_VAR 0 3
54919: PUSH
54920: LD_INT 21
54922: PUSH
54923: LD_INT 22
54925: PUSH
54926: LD_INT 23
54928: PUSH
54929: LD_INT 24
54931: PUSH
54932: EMPTY
54933: LIST
54934: LIST
54935: LIST
54936: LIST
54937: ST_TO_ADDR
54938: GO 55189
54940: LD_INT 44
54942: DOUBLE
54943: EQUAL
54944: IFTRUE 54948
54946: GO 54974
54948: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54949: LD_ADDR_VAR 0 3
54953: PUSH
54954: LD_INT 21
54956: PUSH
54957: LD_INT 22
54959: PUSH
54960: LD_INT 23
54962: PUSH
54963: LD_INT 24
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: LIST
54970: LIST
54971: ST_TO_ADDR
54972: GO 55189
54974: LD_INT 45
54976: DOUBLE
54977: EQUAL
54978: IFTRUE 54982
54980: GO 55008
54982: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54983: LD_ADDR_VAR 0 3
54987: PUSH
54988: LD_INT 21
54990: PUSH
54991: LD_INT 22
54993: PUSH
54994: LD_INT 23
54996: PUSH
54997: LD_INT 24
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: LIST
55004: LIST
55005: ST_TO_ADDR
55006: GO 55189
55008: LD_INT 49
55010: DOUBLE
55011: EQUAL
55012: IFTRUE 55016
55014: GO 55042
55016: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55017: LD_ADDR_VAR 0 3
55021: PUSH
55022: LD_INT 21
55024: PUSH
55025: LD_INT 22
55027: PUSH
55028: LD_INT 23
55030: PUSH
55031: LD_INT 24
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: LIST
55038: LIST
55039: ST_TO_ADDR
55040: GO 55189
55042: LD_INT 51
55044: DOUBLE
55045: EQUAL
55046: IFTRUE 55050
55048: GO 55076
55050: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55051: LD_ADDR_VAR 0 3
55055: PUSH
55056: LD_INT 21
55058: PUSH
55059: LD_INT 22
55061: PUSH
55062: LD_INT 23
55064: PUSH
55065: LD_INT 24
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: LIST
55072: LIST
55073: ST_TO_ADDR
55074: GO 55189
55076: LD_INT 52
55078: DOUBLE
55079: EQUAL
55080: IFTRUE 55084
55082: GO 55110
55084: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55085: LD_ADDR_VAR 0 3
55089: PUSH
55090: LD_INT 21
55092: PUSH
55093: LD_INT 22
55095: PUSH
55096: LD_INT 23
55098: PUSH
55099: LD_INT 24
55101: PUSH
55102: EMPTY
55103: LIST
55104: LIST
55105: LIST
55106: LIST
55107: ST_TO_ADDR
55108: GO 55189
55110: LD_INT 53
55112: DOUBLE
55113: EQUAL
55114: IFTRUE 55118
55116: GO 55136
55118: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55119: LD_ADDR_VAR 0 3
55123: PUSH
55124: LD_INT 23
55126: PUSH
55127: LD_INT 24
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: ST_TO_ADDR
55134: GO 55189
55136: LD_INT 46
55138: DOUBLE
55139: EQUAL
55140: IFTRUE 55144
55142: GO 55162
55144: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55145: LD_ADDR_VAR 0 3
55149: PUSH
55150: LD_INT 23
55152: PUSH
55153: LD_INT 24
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: ST_TO_ADDR
55160: GO 55189
55162: LD_INT 47
55164: DOUBLE
55165: EQUAL
55166: IFTRUE 55170
55168: GO 55188
55170: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55171: LD_ADDR_VAR 0 3
55175: PUSH
55176: LD_INT 23
55178: PUSH
55179: LD_INT 24
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: ST_TO_ADDR
55186: GO 55189
55188: POP
// result := ( chassis in result ) ;
55189: LD_ADDR_VAR 0 3
55193: PUSH
55194: LD_VAR 0 1
55198: PUSH
55199: LD_VAR 0 3
55203: IN
55204: ST_TO_ADDR
// end ;
55205: LD_VAR 0 3
55209: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55210: LD_INT 0
55212: PPUSH
55213: PPUSH
55214: PPUSH
55215: PPUSH
55216: PPUSH
55217: PPUSH
55218: PPUSH
// result := array ;
55219: LD_ADDR_VAR 0 5
55223: PUSH
55224: LD_VAR 0 1
55228: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55229: LD_VAR 0 1
55233: NOT
55234: PUSH
55235: LD_VAR 0 2
55239: NOT
55240: OR
55241: PUSH
55242: LD_VAR 0 3
55246: NOT
55247: OR
55248: PUSH
55249: LD_VAR 0 2
55253: PUSH
55254: LD_VAR 0 1
55258: GREATER
55259: OR
55260: PUSH
55261: LD_VAR 0 3
55265: PUSH
55266: LD_VAR 0 1
55270: GREATER
55271: OR
55272: IFFALSE 55276
// exit ;
55274: GO 55572
// if direction then
55276: LD_VAR 0 4
55280: IFFALSE 55344
// begin d := 1 ;
55282: LD_ADDR_VAR 0 9
55286: PUSH
55287: LD_INT 1
55289: ST_TO_ADDR
// if i_from > i_to then
55290: LD_VAR 0 2
55294: PUSH
55295: LD_VAR 0 3
55299: GREATER
55300: IFFALSE 55326
// length := ( array - i_from ) + i_to else
55302: LD_ADDR_VAR 0 11
55306: PUSH
55307: LD_VAR 0 1
55311: PUSH
55312: LD_VAR 0 2
55316: MINUS
55317: PUSH
55318: LD_VAR 0 3
55322: PLUS
55323: ST_TO_ADDR
55324: GO 55342
// length := i_to - i_from ;
55326: LD_ADDR_VAR 0 11
55330: PUSH
55331: LD_VAR 0 3
55335: PUSH
55336: LD_VAR 0 2
55340: MINUS
55341: ST_TO_ADDR
// end else
55342: GO 55405
// begin d := - 1 ;
55344: LD_ADDR_VAR 0 9
55348: PUSH
55349: LD_INT 1
55351: NEG
55352: ST_TO_ADDR
// if i_from > i_to then
55353: LD_VAR 0 2
55357: PUSH
55358: LD_VAR 0 3
55362: GREATER
55363: IFFALSE 55383
// length := i_from - i_to else
55365: LD_ADDR_VAR 0 11
55369: PUSH
55370: LD_VAR 0 2
55374: PUSH
55375: LD_VAR 0 3
55379: MINUS
55380: ST_TO_ADDR
55381: GO 55405
// length := ( array - i_to ) + i_from ;
55383: LD_ADDR_VAR 0 11
55387: PUSH
55388: LD_VAR 0 1
55392: PUSH
55393: LD_VAR 0 3
55397: MINUS
55398: PUSH
55399: LD_VAR 0 2
55403: PLUS
55404: ST_TO_ADDR
// end ; if not length then
55405: LD_VAR 0 11
55409: NOT
55410: IFFALSE 55414
// exit ;
55412: GO 55572
// tmp := array ;
55414: LD_ADDR_VAR 0 10
55418: PUSH
55419: LD_VAR 0 1
55423: ST_TO_ADDR
// for i = 1 to length do
55424: LD_ADDR_VAR 0 6
55428: PUSH
55429: DOUBLE
55430: LD_INT 1
55432: DEC
55433: ST_TO_ADDR
55434: LD_VAR 0 11
55438: PUSH
55439: FOR_TO
55440: IFFALSE 55560
// begin for j = 1 to array do
55442: LD_ADDR_VAR 0 7
55446: PUSH
55447: DOUBLE
55448: LD_INT 1
55450: DEC
55451: ST_TO_ADDR
55452: LD_VAR 0 1
55456: PUSH
55457: FOR_TO
55458: IFFALSE 55546
// begin k := j + d ;
55460: LD_ADDR_VAR 0 8
55464: PUSH
55465: LD_VAR 0 7
55469: PUSH
55470: LD_VAR 0 9
55474: PLUS
55475: ST_TO_ADDR
// if k > array then
55476: LD_VAR 0 8
55480: PUSH
55481: LD_VAR 0 1
55485: GREATER
55486: IFFALSE 55496
// k := 1 ;
55488: LD_ADDR_VAR 0 8
55492: PUSH
55493: LD_INT 1
55495: ST_TO_ADDR
// if not k then
55496: LD_VAR 0 8
55500: NOT
55501: IFFALSE 55513
// k := array ;
55503: LD_ADDR_VAR 0 8
55507: PUSH
55508: LD_VAR 0 1
55512: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55513: LD_ADDR_VAR 0 10
55517: PUSH
55518: LD_VAR 0 10
55522: PPUSH
55523: LD_VAR 0 8
55527: PPUSH
55528: LD_VAR 0 1
55532: PUSH
55533: LD_VAR 0 7
55537: ARRAY
55538: PPUSH
55539: CALL_OW 1
55543: ST_TO_ADDR
// end ;
55544: GO 55457
55546: POP
55547: POP
// array := tmp ;
55548: LD_ADDR_VAR 0 1
55552: PUSH
55553: LD_VAR 0 10
55557: ST_TO_ADDR
// end ;
55558: GO 55439
55560: POP
55561: POP
// result := array ;
55562: LD_ADDR_VAR 0 5
55566: PUSH
55567: LD_VAR 0 1
55571: ST_TO_ADDR
// end ;
55572: LD_VAR 0 5
55576: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55577: LD_INT 0
55579: PPUSH
55580: PPUSH
// result := 0 ;
55581: LD_ADDR_VAR 0 3
55585: PUSH
55586: LD_INT 0
55588: ST_TO_ADDR
// if not array or not value in array then
55589: LD_VAR 0 1
55593: NOT
55594: PUSH
55595: LD_VAR 0 2
55599: PUSH
55600: LD_VAR 0 1
55604: IN
55605: NOT
55606: OR
55607: IFFALSE 55611
// exit ;
55609: GO 55665
// for i = 1 to array do
55611: LD_ADDR_VAR 0 4
55615: PUSH
55616: DOUBLE
55617: LD_INT 1
55619: DEC
55620: ST_TO_ADDR
55621: LD_VAR 0 1
55625: PUSH
55626: FOR_TO
55627: IFFALSE 55663
// if value = array [ i ] then
55629: LD_VAR 0 2
55633: PUSH
55634: LD_VAR 0 1
55638: PUSH
55639: LD_VAR 0 4
55643: ARRAY
55644: EQUAL
55645: IFFALSE 55661
// begin result := i ;
55647: LD_ADDR_VAR 0 3
55651: PUSH
55652: LD_VAR 0 4
55656: ST_TO_ADDR
// exit ;
55657: POP
55658: POP
55659: GO 55665
// end ;
55661: GO 55626
55663: POP
55664: POP
// end ;
55665: LD_VAR 0 3
55669: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55670: LD_INT 0
55672: PPUSH
// vc_chassis := chassis ;
55673: LD_ADDR_OWVAR 37
55677: PUSH
55678: LD_VAR 0 1
55682: ST_TO_ADDR
// vc_engine := engine ;
55683: LD_ADDR_OWVAR 39
55687: PUSH
55688: LD_VAR 0 2
55692: ST_TO_ADDR
// vc_control := control ;
55693: LD_ADDR_OWVAR 38
55697: PUSH
55698: LD_VAR 0 3
55702: ST_TO_ADDR
// vc_weapon := weapon ;
55703: LD_ADDR_OWVAR 40
55707: PUSH
55708: LD_VAR 0 4
55712: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55713: LD_ADDR_OWVAR 41
55717: PUSH
55718: LD_VAR 0 5
55722: ST_TO_ADDR
// end ;
55723: LD_VAR 0 6
55727: RET
// export function WantPlant ( unit ) ; var task ; begin
55728: LD_INT 0
55730: PPUSH
55731: PPUSH
// result := false ;
55732: LD_ADDR_VAR 0 2
55736: PUSH
55737: LD_INT 0
55739: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55740: LD_ADDR_VAR 0 3
55744: PUSH
55745: LD_VAR 0 1
55749: PPUSH
55750: CALL_OW 437
55754: ST_TO_ADDR
// if task then
55755: LD_VAR 0 3
55759: IFFALSE 55787
// if task [ 1 ] [ 1 ] = p then
55761: LD_VAR 0 3
55765: PUSH
55766: LD_INT 1
55768: ARRAY
55769: PUSH
55770: LD_INT 1
55772: ARRAY
55773: PUSH
55774: LD_STRING p
55776: EQUAL
55777: IFFALSE 55787
// result := true ;
55779: LD_ADDR_VAR 0 2
55783: PUSH
55784: LD_INT 1
55786: ST_TO_ADDR
// end ;
55787: LD_VAR 0 2
55791: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55792: LD_INT 0
55794: PPUSH
55795: PPUSH
55796: PPUSH
55797: PPUSH
// if pos < 1 then
55798: LD_VAR 0 2
55802: PUSH
55803: LD_INT 1
55805: LESS
55806: IFFALSE 55810
// exit ;
55808: GO 56113
// if pos = 1 then
55810: LD_VAR 0 2
55814: PUSH
55815: LD_INT 1
55817: EQUAL
55818: IFFALSE 55851
// result := Replace ( arr , pos [ 1 ] , value ) else
55820: LD_ADDR_VAR 0 4
55824: PUSH
55825: LD_VAR 0 1
55829: PPUSH
55830: LD_VAR 0 2
55834: PUSH
55835: LD_INT 1
55837: ARRAY
55838: PPUSH
55839: LD_VAR 0 3
55843: PPUSH
55844: CALL_OW 1
55848: ST_TO_ADDR
55849: GO 56113
// begin tmp := arr ;
55851: LD_ADDR_VAR 0 6
55855: PUSH
55856: LD_VAR 0 1
55860: ST_TO_ADDR
// s_arr := [ tmp ] ;
55861: LD_ADDR_VAR 0 7
55865: PUSH
55866: LD_VAR 0 6
55870: PUSH
55871: EMPTY
55872: LIST
55873: ST_TO_ADDR
// for i = 1 to pos - 1 do
55874: LD_ADDR_VAR 0 5
55878: PUSH
55879: DOUBLE
55880: LD_INT 1
55882: DEC
55883: ST_TO_ADDR
55884: LD_VAR 0 2
55888: PUSH
55889: LD_INT 1
55891: MINUS
55892: PUSH
55893: FOR_TO
55894: IFFALSE 55939
// begin tmp := tmp [ pos [ i ] ] ;
55896: LD_ADDR_VAR 0 6
55900: PUSH
55901: LD_VAR 0 6
55905: PUSH
55906: LD_VAR 0 2
55910: PUSH
55911: LD_VAR 0 5
55915: ARRAY
55916: ARRAY
55917: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55918: LD_ADDR_VAR 0 7
55922: PUSH
55923: LD_VAR 0 7
55927: PUSH
55928: LD_VAR 0 6
55932: PUSH
55933: EMPTY
55934: LIST
55935: ADD
55936: ST_TO_ADDR
// end ;
55937: GO 55893
55939: POP
55940: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55941: LD_ADDR_VAR 0 6
55945: PUSH
55946: LD_VAR 0 6
55950: PPUSH
55951: LD_VAR 0 2
55955: PUSH
55956: LD_VAR 0 2
55960: ARRAY
55961: PPUSH
55962: LD_VAR 0 3
55966: PPUSH
55967: CALL_OW 1
55971: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55972: LD_ADDR_VAR 0 7
55976: PUSH
55977: LD_VAR 0 7
55981: PPUSH
55982: LD_VAR 0 7
55986: PPUSH
55987: LD_VAR 0 6
55991: PPUSH
55992: CALL_OW 1
55996: ST_TO_ADDR
// for i = s_arr downto 2 do
55997: LD_ADDR_VAR 0 5
56001: PUSH
56002: DOUBLE
56003: LD_VAR 0 7
56007: INC
56008: ST_TO_ADDR
56009: LD_INT 2
56011: PUSH
56012: FOR_DOWNTO
56013: IFFALSE 56097
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56015: LD_ADDR_VAR 0 6
56019: PUSH
56020: LD_VAR 0 7
56024: PUSH
56025: LD_VAR 0 5
56029: PUSH
56030: LD_INT 1
56032: MINUS
56033: ARRAY
56034: PPUSH
56035: LD_VAR 0 2
56039: PUSH
56040: LD_VAR 0 5
56044: PUSH
56045: LD_INT 1
56047: MINUS
56048: ARRAY
56049: PPUSH
56050: LD_VAR 0 7
56054: PUSH
56055: LD_VAR 0 5
56059: ARRAY
56060: PPUSH
56061: CALL_OW 1
56065: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56066: LD_ADDR_VAR 0 7
56070: PUSH
56071: LD_VAR 0 7
56075: PPUSH
56076: LD_VAR 0 5
56080: PUSH
56081: LD_INT 1
56083: MINUS
56084: PPUSH
56085: LD_VAR 0 6
56089: PPUSH
56090: CALL_OW 1
56094: ST_TO_ADDR
// end ;
56095: GO 56012
56097: POP
56098: POP
// result := s_arr [ 1 ] ;
56099: LD_ADDR_VAR 0 4
56103: PUSH
56104: LD_VAR 0 7
56108: PUSH
56109: LD_INT 1
56111: ARRAY
56112: ST_TO_ADDR
// end ; end ;
56113: LD_VAR 0 4
56117: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56118: LD_INT 0
56120: PPUSH
56121: PPUSH
// if not list then
56122: LD_VAR 0 1
56126: NOT
56127: IFFALSE 56131
// exit ;
56129: GO 56222
// i := list [ pos1 ] ;
56131: LD_ADDR_VAR 0 5
56135: PUSH
56136: LD_VAR 0 1
56140: PUSH
56141: LD_VAR 0 2
56145: ARRAY
56146: ST_TO_ADDR
// if not i then
56147: LD_VAR 0 5
56151: NOT
56152: IFFALSE 56156
// exit ;
56154: GO 56222
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56156: LD_ADDR_VAR 0 1
56160: PUSH
56161: LD_VAR 0 1
56165: PPUSH
56166: LD_VAR 0 2
56170: PPUSH
56171: LD_VAR 0 1
56175: PUSH
56176: LD_VAR 0 3
56180: ARRAY
56181: PPUSH
56182: CALL_OW 1
56186: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56187: LD_ADDR_VAR 0 1
56191: PUSH
56192: LD_VAR 0 1
56196: PPUSH
56197: LD_VAR 0 3
56201: PPUSH
56202: LD_VAR 0 5
56206: PPUSH
56207: CALL_OW 1
56211: ST_TO_ADDR
// result := list ;
56212: LD_ADDR_VAR 0 4
56216: PUSH
56217: LD_VAR 0 1
56221: ST_TO_ADDR
// end ;
56222: LD_VAR 0 4
56226: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56227: LD_INT 0
56229: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56230: LD_ADDR_VAR 0 5
56234: PUSH
56235: LD_VAR 0 1
56239: PPUSH
56240: CALL_OW 250
56244: PPUSH
56245: LD_VAR 0 1
56249: PPUSH
56250: CALL_OW 251
56254: PPUSH
56255: LD_VAR 0 2
56259: PPUSH
56260: LD_VAR 0 3
56264: PPUSH
56265: LD_VAR 0 4
56269: PPUSH
56270: CALL 56280 0 5
56274: ST_TO_ADDR
// end ;
56275: LD_VAR 0 5
56279: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56280: LD_INT 0
56282: PPUSH
56283: PPUSH
56284: PPUSH
56285: PPUSH
// if not list then
56286: LD_VAR 0 3
56290: NOT
56291: IFFALSE 56295
// exit ;
56293: GO 56683
// result := [ ] ;
56295: LD_ADDR_VAR 0 6
56299: PUSH
56300: EMPTY
56301: ST_TO_ADDR
// for i in list do
56302: LD_ADDR_VAR 0 7
56306: PUSH
56307: LD_VAR 0 3
56311: PUSH
56312: FOR_IN
56313: IFFALSE 56515
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56315: LD_ADDR_VAR 0 9
56319: PUSH
56320: LD_VAR 0 7
56324: PPUSH
56325: LD_VAR 0 1
56329: PPUSH
56330: LD_VAR 0 2
56334: PPUSH
56335: CALL_OW 297
56339: ST_TO_ADDR
// if not result then
56340: LD_VAR 0 6
56344: NOT
56345: IFFALSE 56371
// result := [ [ i , tmp ] ] else
56347: LD_ADDR_VAR 0 6
56351: PUSH
56352: LD_VAR 0 7
56356: PUSH
56357: LD_VAR 0 9
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: PUSH
56366: EMPTY
56367: LIST
56368: ST_TO_ADDR
56369: GO 56513
// begin if result [ result ] [ 2 ] < tmp then
56371: LD_VAR 0 6
56375: PUSH
56376: LD_VAR 0 6
56380: ARRAY
56381: PUSH
56382: LD_INT 2
56384: ARRAY
56385: PUSH
56386: LD_VAR 0 9
56390: LESS
56391: IFFALSE 56433
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56393: LD_ADDR_VAR 0 6
56397: PUSH
56398: LD_VAR 0 6
56402: PPUSH
56403: LD_VAR 0 6
56407: PUSH
56408: LD_INT 1
56410: PLUS
56411: PPUSH
56412: LD_VAR 0 7
56416: PUSH
56417: LD_VAR 0 9
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: PPUSH
56426: CALL_OW 2
56430: ST_TO_ADDR
56431: GO 56513
// for j = 1 to result do
56433: LD_ADDR_VAR 0 8
56437: PUSH
56438: DOUBLE
56439: LD_INT 1
56441: DEC
56442: ST_TO_ADDR
56443: LD_VAR 0 6
56447: PUSH
56448: FOR_TO
56449: IFFALSE 56511
// begin if tmp < result [ j ] [ 2 ] then
56451: LD_VAR 0 9
56455: PUSH
56456: LD_VAR 0 6
56460: PUSH
56461: LD_VAR 0 8
56465: ARRAY
56466: PUSH
56467: LD_INT 2
56469: ARRAY
56470: LESS
56471: IFFALSE 56509
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56473: LD_ADDR_VAR 0 6
56477: PUSH
56478: LD_VAR 0 6
56482: PPUSH
56483: LD_VAR 0 8
56487: PPUSH
56488: LD_VAR 0 7
56492: PUSH
56493: LD_VAR 0 9
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: PPUSH
56502: CALL_OW 2
56506: ST_TO_ADDR
// break ;
56507: GO 56511
// end ; end ;
56509: GO 56448
56511: POP
56512: POP
// end ; end ;
56513: GO 56312
56515: POP
56516: POP
// if result and not asc then
56517: LD_VAR 0 6
56521: PUSH
56522: LD_VAR 0 4
56526: NOT
56527: AND
56528: IFFALSE 56603
// begin tmp := result ;
56530: LD_ADDR_VAR 0 9
56534: PUSH
56535: LD_VAR 0 6
56539: ST_TO_ADDR
// for i = tmp downto 1 do
56540: LD_ADDR_VAR 0 7
56544: PUSH
56545: DOUBLE
56546: LD_VAR 0 9
56550: INC
56551: ST_TO_ADDR
56552: LD_INT 1
56554: PUSH
56555: FOR_DOWNTO
56556: IFFALSE 56601
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56558: LD_ADDR_VAR 0 6
56562: PUSH
56563: LD_VAR 0 6
56567: PPUSH
56568: LD_VAR 0 9
56572: PUSH
56573: LD_VAR 0 7
56577: MINUS
56578: PUSH
56579: LD_INT 1
56581: PLUS
56582: PPUSH
56583: LD_VAR 0 9
56587: PUSH
56588: LD_VAR 0 7
56592: ARRAY
56593: PPUSH
56594: CALL_OW 1
56598: ST_TO_ADDR
56599: GO 56555
56601: POP
56602: POP
// end ; tmp := [ ] ;
56603: LD_ADDR_VAR 0 9
56607: PUSH
56608: EMPTY
56609: ST_TO_ADDR
// if mode then
56610: LD_VAR 0 5
56614: IFFALSE 56683
// begin for i = 1 to result do
56616: LD_ADDR_VAR 0 7
56620: PUSH
56621: DOUBLE
56622: LD_INT 1
56624: DEC
56625: ST_TO_ADDR
56626: LD_VAR 0 6
56630: PUSH
56631: FOR_TO
56632: IFFALSE 56671
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56634: LD_ADDR_VAR 0 9
56638: PUSH
56639: LD_VAR 0 9
56643: PPUSH
56644: LD_VAR 0 7
56648: PPUSH
56649: LD_VAR 0 6
56653: PUSH
56654: LD_VAR 0 7
56658: ARRAY
56659: PUSH
56660: LD_INT 1
56662: ARRAY
56663: PPUSH
56664: CALL_OW 1
56668: ST_TO_ADDR
56669: GO 56631
56671: POP
56672: POP
// result := tmp ;
56673: LD_ADDR_VAR 0 6
56677: PUSH
56678: LD_VAR 0 9
56682: ST_TO_ADDR
// end ; end ;
56683: LD_VAR 0 6
56687: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56688: LD_INT 0
56690: PPUSH
56691: PPUSH
56692: PPUSH
56693: PPUSH
56694: PPUSH
56695: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56696: LD_ADDR_VAR 0 5
56700: PUSH
56701: LD_INT 0
56703: PUSH
56704: LD_INT 0
56706: PUSH
56707: LD_INT 0
56709: PUSH
56710: EMPTY
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: LIST
56716: LIST
56717: ST_TO_ADDR
// if not x or not y then
56718: LD_VAR 0 2
56722: NOT
56723: PUSH
56724: LD_VAR 0 3
56728: NOT
56729: OR
56730: IFFALSE 56734
// exit ;
56732: GO 58380
// if not range then
56734: LD_VAR 0 4
56738: NOT
56739: IFFALSE 56749
// range := 10 ;
56741: LD_ADDR_VAR 0 4
56745: PUSH
56746: LD_INT 10
56748: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56749: LD_ADDR_VAR 0 8
56753: PUSH
56754: LD_INT 81
56756: PUSH
56757: LD_VAR 0 1
56761: PUSH
56762: EMPTY
56763: LIST
56764: LIST
56765: PUSH
56766: LD_INT 92
56768: PUSH
56769: LD_VAR 0 2
56773: PUSH
56774: LD_VAR 0 3
56778: PUSH
56779: LD_VAR 0 4
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: LIST
56788: LIST
56789: PUSH
56790: LD_INT 3
56792: PUSH
56793: LD_INT 21
56795: PUSH
56796: LD_INT 3
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: PUSH
56807: EMPTY
56808: LIST
56809: LIST
56810: LIST
56811: PPUSH
56812: CALL_OW 69
56816: ST_TO_ADDR
// if not tmp then
56817: LD_VAR 0 8
56821: NOT
56822: IFFALSE 56826
// exit ;
56824: GO 58380
// for i in tmp do
56826: LD_ADDR_VAR 0 6
56830: PUSH
56831: LD_VAR 0 8
56835: PUSH
56836: FOR_IN
56837: IFFALSE 58355
// begin points := [ 0 , 0 , 0 ] ;
56839: LD_ADDR_VAR 0 9
56843: PUSH
56844: LD_INT 0
56846: PUSH
56847: LD_INT 0
56849: PUSH
56850: LD_INT 0
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: LIST
56857: ST_TO_ADDR
// bpoints := 1 ;
56858: LD_ADDR_VAR 0 10
56862: PUSH
56863: LD_INT 1
56865: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56866: LD_VAR 0 6
56870: PPUSH
56871: CALL_OW 247
56875: PUSH
56876: LD_INT 1
56878: DOUBLE
56879: EQUAL
56880: IFTRUE 56884
56882: GO 57462
56884: POP
// begin if GetClass ( i ) = 1 then
56885: LD_VAR 0 6
56889: PPUSH
56890: CALL_OW 257
56894: PUSH
56895: LD_INT 1
56897: EQUAL
56898: IFFALSE 56919
// points := [ 10 , 5 , 3 ] ;
56900: LD_ADDR_VAR 0 9
56904: PUSH
56905: LD_INT 10
56907: PUSH
56908: LD_INT 5
56910: PUSH
56911: LD_INT 3
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: LIST
56918: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56919: LD_VAR 0 6
56923: PPUSH
56924: CALL_OW 257
56928: PUSH
56929: LD_INT 2
56931: PUSH
56932: LD_INT 3
56934: PUSH
56935: LD_INT 4
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: LIST
56942: IN
56943: IFFALSE 56964
// points := [ 3 , 2 , 1 ] ;
56945: LD_ADDR_VAR 0 9
56949: PUSH
56950: LD_INT 3
56952: PUSH
56953: LD_INT 2
56955: PUSH
56956: LD_INT 1
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: LIST
56963: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56964: LD_VAR 0 6
56968: PPUSH
56969: CALL_OW 257
56973: PUSH
56974: LD_INT 5
56976: EQUAL
56977: IFFALSE 56998
// points := [ 130 , 5 , 2 ] ;
56979: LD_ADDR_VAR 0 9
56983: PUSH
56984: LD_INT 130
56986: PUSH
56987: LD_INT 5
56989: PUSH
56990: LD_INT 2
56992: PUSH
56993: EMPTY
56994: LIST
56995: LIST
56996: LIST
56997: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56998: LD_VAR 0 6
57002: PPUSH
57003: CALL_OW 257
57007: PUSH
57008: LD_INT 8
57010: EQUAL
57011: IFFALSE 57032
// points := [ 35 , 35 , 30 ] ;
57013: LD_ADDR_VAR 0 9
57017: PUSH
57018: LD_INT 35
57020: PUSH
57021: LD_INT 35
57023: PUSH
57024: LD_INT 30
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: LIST
57031: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57032: LD_VAR 0 6
57036: PPUSH
57037: CALL_OW 257
57041: PUSH
57042: LD_INT 9
57044: EQUAL
57045: IFFALSE 57066
// points := [ 20 , 55 , 40 ] ;
57047: LD_ADDR_VAR 0 9
57051: PUSH
57052: LD_INT 20
57054: PUSH
57055: LD_INT 55
57057: PUSH
57058: LD_INT 40
57060: PUSH
57061: EMPTY
57062: LIST
57063: LIST
57064: LIST
57065: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57066: LD_VAR 0 6
57070: PPUSH
57071: CALL_OW 257
57075: PUSH
57076: LD_INT 12
57078: PUSH
57079: LD_INT 16
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: IN
57086: IFFALSE 57107
// points := [ 5 , 3 , 2 ] ;
57088: LD_ADDR_VAR 0 9
57092: PUSH
57093: LD_INT 5
57095: PUSH
57096: LD_INT 3
57098: PUSH
57099: LD_INT 2
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: LIST
57106: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57107: LD_VAR 0 6
57111: PPUSH
57112: CALL_OW 257
57116: PUSH
57117: LD_INT 17
57119: EQUAL
57120: IFFALSE 57141
// points := [ 100 , 50 , 75 ] ;
57122: LD_ADDR_VAR 0 9
57126: PUSH
57127: LD_INT 100
57129: PUSH
57130: LD_INT 50
57132: PUSH
57133: LD_INT 75
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: LIST
57140: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57141: LD_VAR 0 6
57145: PPUSH
57146: CALL_OW 257
57150: PUSH
57151: LD_INT 15
57153: EQUAL
57154: IFFALSE 57175
// points := [ 10 , 5 , 3 ] ;
57156: LD_ADDR_VAR 0 9
57160: PUSH
57161: LD_INT 10
57163: PUSH
57164: LD_INT 5
57166: PUSH
57167: LD_INT 3
57169: PUSH
57170: EMPTY
57171: LIST
57172: LIST
57173: LIST
57174: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57175: LD_VAR 0 6
57179: PPUSH
57180: CALL_OW 257
57184: PUSH
57185: LD_INT 14
57187: EQUAL
57188: IFFALSE 57209
// points := [ 10 , 0 , 0 ] ;
57190: LD_ADDR_VAR 0 9
57194: PUSH
57195: LD_INT 10
57197: PUSH
57198: LD_INT 0
57200: PUSH
57201: LD_INT 0
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: LIST
57208: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57209: LD_VAR 0 6
57213: PPUSH
57214: CALL_OW 257
57218: PUSH
57219: LD_INT 11
57221: EQUAL
57222: IFFALSE 57243
// points := [ 30 , 10 , 5 ] ;
57224: LD_ADDR_VAR 0 9
57228: PUSH
57229: LD_INT 30
57231: PUSH
57232: LD_INT 10
57234: PUSH
57235: LD_INT 5
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: LIST
57242: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57243: LD_VAR 0 1
57247: PPUSH
57248: LD_INT 5
57250: PPUSH
57251: CALL_OW 321
57255: PUSH
57256: LD_INT 2
57258: EQUAL
57259: IFFALSE 57276
// bpoints := bpoints * 1.8 ;
57261: LD_ADDR_VAR 0 10
57265: PUSH
57266: LD_VAR 0 10
57270: PUSH
57271: LD_REAL  1.80000000000000E+0000
57274: MUL
57275: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57276: LD_VAR 0 6
57280: PPUSH
57281: CALL_OW 257
57285: PUSH
57286: LD_INT 1
57288: PUSH
57289: LD_INT 2
57291: PUSH
57292: LD_INT 3
57294: PUSH
57295: LD_INT 4
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: LIST
57302: LIST
57303: IN
57304: PUSH
57305: LD_VAR 0 1
57309: PPUSH
57310: LD_INT 51
57312: PPUSH
57313: CALL_OW 321
57317: PUSH
57318: LD_INT 2
57320: EQUAL
57321: AND
57322: IFFALSE 57339
// bpoints := bpoints * 1.2 ;
57324: LD_ADDR_VAR 0 10
57328: PUSH
57329: LD_VAR 0 10
57333: PUSH
57334: LD_REAL  1.20000000000000E+0000
57337: MUL
57338: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57339: LD_VAR 0 6
57343: PPUSH
57344: CALL_OW 257
57348: PUSH
57349: LD_INT 5
57351: PUSH
57352: LD_INT 7
57354: PUSH
57355: LD_INT 9
57357: PUSH
57358: EMPTY
57359: LIST
57360: LIST
57361: LIST
57362: IN
57363: PUSH
57364: LD_VAR 0 1
57368: PPUSH
57369: LD_INT 52
57371: PPUSH
57372: CALL_OW 321
57376: PUSH
57377: LD_INT 2
57379: EQUAL
57380: AND
57381: IFFALSE 57398
// bpoints := bpoints * 1.5 ;
57383: LD_ADDR_VAR 0 10
57387: PUSH
57388: LD_VAR 0 10
57392: PUSH
57393: LD_REAL  1.50000000000000E+0000
57396: MUL
57397: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57398: LD_VAR 0 1
57402: PPUSH
57403: LD_INT 66
57405: PPUSH
57406: CALL_OW 321
57410: PUSH
57411: LD_INT 2
57413: EQUAL
57414: IFFALSE 57431
// bpoints := bpoints * 1.1 ;
57416: LD_ADDR_VAR 0 10
57420: PUSH
57421: LD_VAR 0 10
57425: PUSH
57426: LD_REAL  1.10000000000000E+0000
57429: MUL
57430: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57431: LD_ADDR_VAR 0 10
57435: PUSH
57436: LD_VAR 0 10
57440: PUSH
57441: LD_VAR 0 6
57445: PPUSH
57446: LD_INT 1
57448: PPUSH
57449: CALL_OW 259
57453: PUSH
57454: LD_REAL  1.15000000000000E+0000
57457: MUL
57458: MUL
57459: ST_TO_ADDR
// end ; unit_vehicle :
57460: GO 58284
57462: LD_INT 2
57464: DOUBLE
57465: EQUAL
57466: IFTRUE 57470
57468: GO 58272
57470: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57471: LD_VAR 0 6
57475: PPUSH
57476: CALL_OW 264
57480: PUSH
57481: LD_INT 2
57483: PUSH
57484: LD_INT 42
57486: PUSH
57487: LD_INT 24
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: LIST
57494: IN
57495: IFFALSE 57516
// points := [ 25 , 5 , 3 ] ;
57497: LD_ADDR_VAR 0 9
57501: PUSH
57502: LD_INT 25
57504: PUSH
57505: LD_INT 5
57507: PUSH
57508: LD_INT 3
57510: PUSH
57511: EMPTY
57512: LIST
57513: LIST
57514: LIST
57515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57516: LD_VAR 0 6
57520: PPUSH
57521: CALL_OW 264
57525: PUSH
57526: LD_INT 4
57528: PUSH
57529: LD_INT 43
57531: PUSH
57532: LD_INT 25
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: LIST
57539: IN
57540: IFFALSE 57561
// points := [ 40 , 15 , 5 ] ;
57542: LD_ADDR_VAR 0 9
57546: PUSH
57547: LD_INT 40
57549: PUSH
57550: LD_INT 15
57552: PUSH
57553: LD_INT 5
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: LIST
57560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57561: LD_VAR 0 6
57565: PPUSH
57566: CALL_OW 264
57570: PUSH
57571: LD_INT 3
57573: PUSH
57574: LD_INT 23
57576: PUSH
57577: EMPTY
57578: LIST
57579: LIST
57580: IN
57581: IFFALSE 57602
// points := [ 7 , 25 , 8 ] ;
57583: LD_ADDR_VAR 0 9
57587: PUSH
57588: LD_INT 7
57590: PUSH
57591: LD_INT 25
57593: PUSH
57594: LD_INT 8
57596: PUSH
57597: EMPTY
57598: LIST
57599: LIST
57600: LIST
57601: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57602: LD_VAR 0 6
57606: PPUSH
57607: CALL_OW 264
57611: PUSH
57612: LD_INT 5
57614: PUSH
57615: LD_INT 27
57617: PUSH
57618: LD_INT 44
57620: PUSH
57621: EMPTY
57622: LIST
57623: LIST
57624: LIST
57625: IN
57626: IFFALSE 57647
// points := [ 14 , 50 , 16 ] ;
57628: LD_ADDR_VAR 0 9
57632: PUSH
57633: LD_INT 14
57635: PUSH
57636: LD_INT 50
57638: PUSH
57639: LD_INT 16
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: LIST
57646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57647: LD_VAR 0 6
57651: PPUSH
57652: CALL_OW 264
57656: PUSH
57657: LD_INT 6
57659: PUSH
57660: LD_INT 46
57662: PUSH
57663: EMPTY
57664: LIST
57665: LIST
57666: IN
57667: IFFALSE 57688
// points := [ 32 , 120 , 70 ] ;
57669: LD_ADDR_VAR 0 9
57673: PUSH
57674: LD_INT 32
57676: PUSH
57677: LD_INT 120
57679: PUSH
57680: LD_INT 70
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: LIST
57687: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57688: LD_VAR 0 6
57692: PPUSH
57693: CALL_OW 264
57697: PUSH
57698: LD_INT 7
57700: PUSH
57701: LD_INT 28
57703: PUSH
57704: LD_INT 45
57706: PUSH
57707: EMPTY
57708: LIST
57709: LIST
57710: LIST
57711: IN
57712: IFFALSE 57733
// points := [ 35 , 20 , 45 ] ;
57714: LD_ADDR_VAR 0 9
57718: PUSH
57719: LD_INT 35
57721: PUSH
57722: LD_INT 20
57724: PUSH
57725: LD_INT 45
57727: PUSH
57728: EMPTY
57729: LIST
57730: LIST
57731: LIST
57732: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57733: LD_VAR 0 6
57737: PPUSH
57738: CALL_OW 264
57742: PUSH
57743: LD_INT 47
57745: PUSH
57746: EMPTY
57747: LIST
57748: IN
57749: IFFALSE 57770
// points := [ 67 , 45 , 75 ] ;
57751: LD_ADDR_VAR 0 9
57755: PUSH
57756: LD_INT 67
57758: PUSH
57759: LD_INT 45
57761: PUSH
57762: LD_INT 75
57764: PUSH
57765: EMPTY
57766: LIST
57767: LIST
57768: LIST
57769: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57770: LD_VAR 0 6
57774: PPUSH
57775: CALL_OW 264
57779: PUSH
57780: LD_INT 26
57782: PUSH
57783: EMPTY
57784: LIST
57785: IN
57786: IFFALSE 57807
// points := [ 120 , 30 , 80 ] ;
57788: LD_ADDR_VAR 0 9
57792: PUSH
57793: LD_INT 120
57795: PUSH
57796: LD_INT 30
57798: PUSH
57799: LD_INT 80
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: LIST
57806: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57807: LD_VAR 0 6
57811: PPUSH
57812: CALL_OW 264
57816: PUSH
57817: LD_INT 22
57819: PUSH
57820: EMPTY
57821: LIST
57822: IN
57823: IFFALSE 57844
// points := [ 40 , 1 , 1 ] ;
57825: LD_ADDR_VAR 0 9
57829: PUSH
57830: LD_INT 40
57832: PUSH
57833: LD_INT 1
57835: PUSH
57836: LD_INT 1
57838: PUSH
57839: EMPTY
57840: LIST
57841: LIST
57842: LIST
57843: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57844: LD_VAR 0 6
57848: PPUSH
57849: CALL_OW 264
57853: PUSH
57854: LD_INT 29
57856: PUSH
57857: EMPTY
57858: LIST
57859: IN
57860: IFFALSE 57881
// points := [ 70 , 200 , 400 ] ;
57862: LD_ADDR_VAR 0 9
57866: PUSH
57867: LD_INT 70
57869: PUSH
57870: LD_INT 200
57872: PUSH
57873: LD_INT 400
57875: PUSH
57876: EMPTY
57877: LIST
57878: LIST
57879: LIST
57880: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57881: LD_VAR 0 6
57885: PPUSH
57886: CALL_OW 264
57890: PUSH
57891: LD_INT 14
57893: PUSH
57894: LD_INT 53
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: IN
57901: IFFALSE 57922
// points := [ 40 , 10 , 20 ] ;
57903: LD_ADDR_VAR 0 9
57907: PUSH
57908: LD_INT 40
57910: PUSH
57911: LD_INT 10
57913: PUSH
57914: LD_INT 20
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: LIST
57921: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57922: LD_VAR 0 6
57926: PPUSH
57927: CALL_OW 264
57931: PUSH
57932: LD_INT 9
57934: PUSH
57935: EMPTY
57936: LIST
57937: IN
57938: IFFALSE 57959
// points := [ 5 , 70 , 20 ] ;
57940: LD_ADDR_VAR 0 9
57944: PUSH
57945: LD_INT 5
57947: PUSH
57948: LD_INT 70
57950: PUSH
57951: LD_INT 20
57953: PUSH
57954: EMPTY
57955: LIST
57956: LIST
57957: LIST
57958: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57959: LD_VAR 0 6
57963: PPUSH
57964: CALL_OW 264
57968: PUSH
57969: LD_INT 10
57971: PUSH
57972: EMPTY
57973: LIST
57974: IN
57975: IFFALSE 57996
// points := [ 35 , 110 , 70 ] ;
57977: LD_ADDR_VAR 0 9
57981: PUSH
57982: LD_INT 35
57984: PUSH
57985: LD_INT 110
57987: PUSH
57988: LD_INT 70
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: LIST
57995: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57996: LD_VAR 0 6
58000: PPUSH
58001: CALL_OW 265
58005: PUSH
58006: LD_INT 25
58008: EQUAL
58009: IFFALSE 58030
// points := [ 80 , 65 , 100 ] ;
58011: LD_ADDR_VAR 0 9
58015: PUSH
58016: LD_INT 80
58018: PUSH
58019: LD_INT 65
58021: PUSH
58022: LD_INT 100
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: LIST
58029: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58030: LD_VAR 0 6
58034: PPUSH
58035: CALL_OW 263
58039: PUSH
58040: LD_INT 1
58042: EQUAL
58043: IFFALSE 58078
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58045: LD_ADDR_VAR 0 10
58049: PUSH
58050: LD_VAR 0 10
58054: PUSH
58055: LD_VAR 0 6
58059: PPUSH
58060: CALL_OW 311
58064: PPUSH
58065: LD_INT 3
58067: PPUSH
58068: CALL_OW 259
58072: PUSH
58073: LD_INT 4
58075: MUL
58076: MUL
58077: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58078: LD_VAR 0 6
58082: PPUSH
58083: CALL_OW 263
58087: PUSH
58088: LD_INT 2
58090: EQUAL
58091: IFFALSE 58142
// begin j := IsControledBy ( i ) ;
58093: LD_ADDR_VAR 0 7
58097: PUSH
58098: LD_VAR 0 6
58102: PPUSH
58103: CALL_OW 312
58107: ST_TO_ADDR
// if j then
58108: LD_VAR 0 7
58112: IFFALSE 58142
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58114: LD_ADDR_VAR 0 10
58118: PUSH
58119: LD_VAR 0 10
58123: PUSH
58124: LD_VAR 0 7
58128: PPUSH
58129: LD_INT 3
58131: PPUSH
58132: CALL_OW 259
58136: PUSH
58137: LD_INT 3
58139: MUL
58140: MUL
58141: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58142: LD_VAR 0 6
58146: PPUSH
58147: CALL_OW 264
58151: PUSH
58152: LD_INT 5
58154: PUSH
58155: LD_INT 6
58157: PUSH
58158: LD_INT 46
58160: PUSH
58161: LD_INT 44
58163: PUSH
58164: LD_INT 47
58166: PUSH
58167: LD_INT 45
58169: PUSH
58170: LD_INT 28
58172: PUSH
58173: LD_INT 7
58175: PUSH
58176: LD_INT 27
58178: PUSH
58179: LD_INT 29
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: LIST
58186: LIST
58187: LIST
58188: LIST
58189: LIST
58190: LIST
58191: LIST
58192: LIST
58193: IN
58194: PUSH
58195: LD_VAR 0 1
58199: PPUSH
58200: LD_INT 52
58202: PPUSH
58203: CALL_OW 321
58207: PUSH
58208: LD_INT 2
58210: EQUAL
58211: AND
58212: IFFALSE 58229
// bpoints := bpoints * 1.2 ;
58214: LD_ADDR_VAR 0 10
58218: PUSH
58219: LD_VAR 0 10
58223: PUSH
58224: LD_REAL  1.20000000000000E+0000
58227: MUL
58228: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58229: LD_VAR 0 6
58233: PPUSH
58234: CALL_OW 264
58238: PUSH
58239: LD_INT 6
58241: PUSH
58242: LD_INT 46
58244: PUSH
58245: LD_INT 47
58247: PUSH
58248: EMPTY
58249: LIST
58250: LIST
58251: LIST
58252: IN
58253: IFFALSE 58270
// bpoints := bpoints * 1.2 ;
58255: LD_ADDR_VAR 0 10
58259: PUSH
58260: LD_VAR 0 10
58264: PUSH
58265: LD_REAL  1.20000000000000E+0000
58268: MUL
58269: ST_TO_ADDR
// end ; unit_building :
58270: GO 58284
58272: LD_INT 3
58274: DOUBLE
58275: EQUAL
58276: IFTRUE 58280
58278: GO 58283
58280: POP
// ; end ;
58281: GO 58284
58283: POP
// for j = 1 to 3 do
58284: LD_ADDR_VAR 0 7
58288: PUSH
58289: DOUBLE
58290: LD_INT 1
58292: DEC
58293: ST_TO_ADDR
58294: LD_INT 3
58296: PUSH
58297: FOR_TO
58298: IFFALSE 58351
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58300: LD_ADDR_VAR 0 5
58304: PUSH
58305: LD_VAR 0 5
58309: PPUSH
58310: LD_VAR 0 7
58314: PPUSH
58315: LD_VAR 0 5
58319: PUSH
58320: LD_VAR 0 7
58324: ARRAY
58325: PUSH
58326: LD_VAR 0 9
58330: PUSH
58331: LD_VAR 0 7
58335: ARRAY
58336: PUSH
58337: LD_VAR 0 10
58341: MUL
58342: PLUS
58343: PPUSH
58344: CALL_OW 1
58348: ST_TO_ADDR
58349: GO 58297
58351: POP
58352: POP
// end ;
58353: GO 56836
58355: POP
58356: POP
// result := Replace ( result , 4 , tmp ) ;
58357: LD_ADDR_VAR 0 5
58361: PUSH
58362: LD_VAR 0 5
58366: PPUSH
58367: LD_INT 4
58369: PPUSH
58370: LD_VAR 0 8
58374: PPUSH
58375: CALL_OW 1
58379: ST_TO_ADDR
// end ;
58380: LD_VAR 0 5
58384: RET
// export function DangerAtRange ( unit , range ) ; begin
58385: LD_INT 0
58387: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58388: LD_ADDR_VAR 0 3
58392: PUSH
58393: LD_VAR 0 1
58397: PPUSH
58398: CALL_OW 255
58402: PPUSH
58403: LD_VAR 0 1
58407: PPUSH
58408: CALL_OW 250
58412: PPUSH
58413: LD_VAR 0 1
58417: PPUSH
58418: CALL_OW 251
58422: PPUSH
58423: LD_VAR 0 2
58427: PPUSH
58428: CALL 56688 0 4
58432: ST_TO_ADDR
// end ;
58433: LD_VAR 0 3
58437: RET
// export function DangerInArea ( side , area ) ; begin
58438: LD_INT 0
58440: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58441: LD_ADDR_VAR 0 3
58445: PUSH
58446: LD_VAR 0 2
58450: PPUSH
58451: LD_INT 81
58453: PUSH
58454: LD_VAR 0 1
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: PPUSH
58463: CALL_OW 70
58467: ST_TO_ADDR
// end ;
58468: LD_VAR 0 3
58472: RET
// export function IsExtension ( b ) ; begin
58473: LD_INT 0
58475: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58476: LD_ADDR_VAR 0 2
58480: PUSH
58481: LD_VAR 0 1
58485: PUSH
58486: LD_INT 23
58488: PUSH
58489: LD_INT 20
58491: PUSH
58492: LD_INT 22
58494: PUSH
58495: LD_INT 17
58497: PUSH
58498: LD_INT 24
58500: PUSH
58501: LD_INT 21
58503: PUSH
58504: LD_INT 19
58506: PUSH
58507: LD_INT 16
58509: PUSH
58510: LD_INT 25
58512: PUSH
58513: LD_INT 18
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: LIST
58524: LIST
58525: LIST
58526: LIST
58527: IN
58528: ST_TO_ADDR
// end ;
58529: LD_VAR 0 2
58533: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58534: LD_INT 0
58536: PPUSH
58537: PPUSH
58538: PPUSH
// result := [ ] ;
58539: LD_ADDR_VAR 0 3
58543: PUSH
58544: EMPTY
58545: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58546: LD_ADDR_VAR 0 4
58550: PUSH
58551: LD_VAR 0 2
58555: PPUSH
58556: LD_INT 21
58558: PUSH
58559: LD_INT 3
58561: PUSH
58562: EMPTY
58563: LIST
58564: LIST
58565: PPUSH
58566: CALL_OW 70
58570: ST_TO_ADDR
// if not tmp then
58571: LD_VAR 0 4
58575: NOT
58576: IFFALSE 58580
// exit ;
58578: GO 58638
// for i in tmp do
58580: LD_ADDR_VAR 0 5
58584: PUSH
58585: LD_VAR 0 4
58589: PUSH
58590: FOR_IN
58591: IFFALSE 58626
// if GetBase ( i ) <> base then
58593: LD_VAR 0 5
58597: PPUSH
58598: CALL_OW 274
58602: PUSH
58603: LD_VAR 0 1
58607: NONEQUAL
58608: IFFALSE 58624
// ComLinkToBase ( base , i ) ;
58610: LD_VAR 0 1
58614: PPUSH
58615: LD_VAR 0 5
58619: PPUSH
58620: CALL_OW 169
58624: GO 58590
58626: POP
58627: POP
// result := tmp ;
58628: LD_ADDR_VAR 0 3
58632: PUSH
58633: LD_VAR 0 4
58637: ST_TO_ADDR
// end ;
58638: LD_VAR 0 3
58642: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58643: LD_INT 0
58645: PPUSH
58646: PPUSH
// if BuildingStatus ( b ) = bs_build then
58647: LD_VAR 0 2
58651: PPUSH
58652: CALL_OW 461
58656: PUSH
58657: LD_INT 1
58659: EQUAL
58660: IFFALSE 58720
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58662: LD_VAR 0 1
58666: PPUSH
58667: LD_STRING h
58669: PUSH
58670: LD_VAR 0 2
58674: PPUSH
58675: CALL_OW 250
58679: PUSH
58680: LD_VAR 0 2
58684: PPUSH
58685: CALL_OW 251
58689: PUSH
58690: LD_VAR 0 2
58694: PUSH
58695: LD_INT 0
58697: PUSH
58698: LD_INT 0
58700: PUSH
58701: LD_INT 0
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: LIST
58708: LIST
58709: LIST
58710: LIST
58711: LIST
58712: PUSH
58713: EMPTY
58714: LIST
58715: PPUSH
58716: CALL_OW 446
// end ;
58720: LD_VAR 0 3
58724: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58725: LD_INT 0
58727: PPUSH
58728: PPUSH
58729: PPUSH
58730: PPUSH
58731: PPUSH
58732: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58733: LD_VAR 0 1
58737: NOT
58738: PUSH
58739: LD_VAR 0 1
58743: PPUSH
58744: CALL_OW 263
58748: PUSH
58749: LD_INT 2
58751: EQUAL
58752: NOT
58753: OR
58754: IFFALSE 58758
// exit ;
58756: GO 59074
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58758: LD_ADDR_VAR 0 6
58762: PUSH
58763: LD_INT 22
58765: PUSH
58766: LD_VAR 0 1
58770: PPUSH
58771: CALL_OW 255
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: PUSH
58780: LD_INT 2
58782: PUSH
58783: LD_INT 30
58785: PUSH
58786: LD_INT 36
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: PUSH
58793: LD_INT 34
58795: PUSH
58796: LD_INT 31
58798: PUSH
58799: EMPTY
58800: LIST
58801: LIST
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: PUSH
58808: EMPTY
58809: LIST
58810: LIST
58811: PPUSH
58812: CALL_OW 69
58816: ST_TO_ADDR
// if not tmp then
58817: LD_VAR 0 6
58821: NOT
58822: IFFALSE 58826
// exit ;
58824: GO 59074
// result := [ ] ;
58826: LD_ADDR_VAR 0 2
58830: PUSH
58831: EMPTY
58832: ST_TO_ADDR
// for i in tmp do
58833: LD_ADDR_VAR 0 3
58837: PUSH
58838: LD_VAR 0 6
58842: PUSH
58843: FOR_IN
58844: IFFALSE 58915
// begin t := UnitsInside ( i ) ;
58846: LD_ADDR_VAR 0 4
58850: PUSH
58851: LD_VAR 0 3
58855: PPUSH
58856: CALL_OW 313
58860: ST_TO_ADDR
// if t then
58861: LD_VAR 0 4
58865: IFFALSE 58913
// for j in t do
58867: LD_ADDR_VAR 0 7
58871: PUSH
58872: LD_VAR 0 4
58876: PUSH
58877: FOR_IN
58878: IFFALSE 58911
// result := Insert ( result , result + 1 , j ) ;
58880: LD_ADDR_VAR 0 2
58884: PUSH
58885: LD_VAR 0 2
58889: PPUSH
58890: LD_VAR 0 2
58894: PUSH
58895: LD_INT 1
58897: PLUS
58898: PPUSH
58899: LD_VAR 0 7
58903: PPUSH
58904: CALL_OW 2
58908: ST_TO_ADDR
58909: GO 58877
58911: POP
58912: POP
// end ;
58913: GO 58843
58915: POP
58916: POP
// if not result then
58917: LD_VAR 0 2
58921: NOT
58922: IFFALSE 58926
// exit ;
58924: GO 59074
// mech := result [ 1 ] ;
58926: LD_ADDR_VAR 0 5
58930: PUSH
58931: LD_VAR 0 2
58935: PUSH
58936: LD_INT 1
58938: ARRAY
58939: ST_TO_ADDR
// if result > 1 then
58940: LD_VAR 0 2
58944: PUSH
58945: LD_INT 1
58947: GREATER
58948: IFFALSE 59060
// for i = 2 to result do
58950: LD_ADDR_VAR 0 3
58954: PUSH
58955: DOUBLE
58956: LD_INT 2
58958: DEC
58959: ST_TO_ADDR
58960: LD_VAR 0 2
58964: PUSH
58965: FOR_TO
58966: IFFALSE 59058
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58968: LD_ADDR_VAR 0 4
58972: PUSH
58973: LD_VAR 0 2
58977: PUSH
58978: LD_VAR 0 3
58982: ARRAY
58983: PPUSH
58984: LD_INT 3
58986: PPUSH
58987: CALL_OW 259
58991: PUSH
58992: LD_VAR 0 2
58996: PUSH
58997: LD_VAR 0 3
59001: ARRAY
59002: PPUSH
59003: CALL_OW 432
59007: MINUS
59008: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59009: LD_VAR 0 4
59013: PUSH
59014: LD_VAR 0 5
59018: PPUSH
59019: LD_INT 3
59021: PPUSH
59022: CALL_OW 259
59026: PUSH
59027: LD_VAR 0 5
59031: PPUSH
59032: CALL_OW 432
59036: MINUS
59037: GREATEREQUAL
59038: IFFALSE 59056
// mech := result [ i ] ;
59040: LD_ADDR_VAR 0 5
59044: PUSH
59045: LD_VAR 0 2
59049: PUSH
59050: LD_VAR 0 3
59054: ARRAY
59055: ST_TO_ADDR
// end ;
59056: GO 58965
59058: POP
59059: POP
// ComLinkTo ( vehicle , mech ) ;
59060: LD_VAR 0 1
59064: PPUSH
59065: LD_VAR 0 5
59069: PPUSH
59070: CALL_OW 135
// end ;
59074: LD_VAR 0 2
59078: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59079: LD_INT 0
59081: PPUSH
59082: PPUSH
59083: PPUSH
59084: PPUSH
59085: PPUSH
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
// result := [ ] ;
59094: LD_ADDR_VAR 0 7
59098: PUSH
59099: EMPTY
59100: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59101: LD_VAR 0 1
59105: PPUSH
59106: CALL_OW 266
59110: PUSH
59111: LD_INT 0
59113: PUSH
59114: LD_INT 1
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: IN
59121: NOT
59122: IFFALSE 59126
// exit ;
59124: GO 60757
// if name then
59126: LD_VAR 0 3
59130: IFFALSE 59146
// SetBName ( base_dep , name ) ;
59132: LD_VAR 0 1
59136: PPUSH
59137: LD_VAR 0 3
59141: PPUSH
59142: CALL_OW 500
// base := GetBase ( base_dep ) ;
59146: LD_ADDR_VAR 0 15
59150: PUSH
59151: LD_VAR 0 1
59155: PPUSH
59156: CALL_OW 274
59160: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59161: LD_ADDR_VAR 0 16
59165: PUSH
59166: LD_VAR 0 1
59170: PPUSH
59171: CALL_OW 255
59175: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59176: LD_ADDR_VAR 0 17
59180: PUSH
59181: LD_VAR 0 1
59185: PPUSH
59186: CALL_OW 248
59190: ST_TO_ADDR
// if sources then
59191: LD_VAR 0 5
59195: IFFALSE 59242
// for i = 1 to 3 do
59197: LD_ADDR_VAR 0 8
59201: PUSH
59202: DOUBLE
59203: LD_INT 1
59205: DEC
59206: ST_TO_ADDR
59207: LD_INT 3
59209: PUSH
59210: FOR_TO
59211: IFFALSE 59240
// AddResourceType ( base , i , sources [ i ] ) ;
59213: LD_VAR 0 15
59217: PPUSH
59218: LD_VAR 0 8
59222: PPUSH
59223: LD_VAR 0 5
59227: PUSH
59228: LD_VAR 0 8
59232: ARRAY
59233: PPUSH
59234: CALL_OW 276
59238: GO 59210
59240: POP
59241: POP
// buildings := GetBaseBuildings ( base , area ) ;
59242: LD_ADDR_VAR 0 18
59246: PUSH
59247: LD_VAR 0 15
59251: PPUSH
59252: LD_VAR 0 2
59256: PPUSH
59257: CALL 58534 0 2
59261: ST_TO_ADDR
// InitHc ;
59262: CALL_OW 19
// InitUc ;
59266: CALL_OW 18
// uc_side := side ;
59270: LD_ADDR_OWVAR 20
59274: PUSH
59275: LD_VAR 0 16
59279: ST_TO_ADDR
// uc_nation := nation ;
59280: LD_ADDR_OWVAR 21
59284: PUSH
59285: LD_VAR 0 17
59289: ST_TO_ADDR
// if buildings then
59290: LD_VAR 0 18
59294: IFFALSE 60616
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59296: LD_ADDR_VAR 0 19
59300: PUSH
59301: LD_VAR 0 18
59305: PPUSH
59306: LD_INT 2
59308: PUSH
59309: LD_INT 30
59311: PUSH
59312: LD_INT 29
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PUSH
59319: LD_INT 30
59321: PUSH
59322: LD_INT 30
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: PUSH
59329: EMPTY
59330: LIST
59331: LIST
59332: LIST
59333: PPUSH
59334: CALL_OW 72
59338: ST_TO_ADDR
// if tmp then
59339: LD_VAR 0 19
59343: IFFALSE 59391
// for i in tmp do
59345: LD_ADDR_VAR 0 8
59349: PUSH
59350: LD_VAR 0 19
59354: PUSH
59355: FOR_IN
59356: IFFALSE 59389
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59358: LD_VAR 0 8
59362: PPUSH
59363: CALL_OW 250
59367: PPUSH
59368: LD_VAR 0 8
59372: PPUSH
59373: CALL_OW 251
59377: PPUSH
59378: LD_VAR 0 16
59382: PPUSH
59383: CALL_OW 441
59387: GO 59355
59389: POP
59390: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59391: LD_VAR 0 18
59395: PPUSH
59396: LD_INT 2
59398: PUSH
59399: LD_INT 30
59401: PUSH
59402: LD_INT 32
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: PUSH
59409: LD_INT 30
59411: PUSH
59412: LD_INT 33
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PUSH
59419: EMPTY
59420: LIST
59421: LIST
59422: LIST
59423: PPUSH
59424: CALL_OW 72
59428: IFFALSE 59516
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59430: LD_ADDR_VAR 0 8
59434: PUSH
59435: LD_VAR 0 18
59439: PPUSH
59440: LD_INT 2
59442: PUSH
59443: LD_INT 30
59445: PUSH
59446: LD_INT 32
59448: PUSH
59449: EMPTY
59450: LIST
59451: LIST
59452: PUSH
59453: LD_INT 30
59455: PUSH
59456: LD_INT 33
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PUSH
59463: EMPTY
59464: LIST
59465: LIST
59466: LIST
59467: PPUSH
59468: CALL_OW 72
59472: PUSH
59473: FOR_IN
59474: IFFALSE 59514
// begin if not GetBWeapon ( i ) then
59476: LD_VAR 0 8
59480: PPUSH
59481: CALL_OW 269
59485: NOT
59486: IFFALSE 59512
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59488: LD_VAR 0 8
59492: PPUSH
59493: LD_VAR 0 8
59497: PPUSH
59498: LD_VAR 0 2
59502: PPUSH
59503: CALL 60762 0 2
59507: PPUSH
59508: CALL_OW 431
// end ;
59512: GO 59473
59514: POP
59515: POP
// end ; for i = 1 to personel do
59516: LD_ADDR_VAR 0 8
59520: PUSH
59521: DOUBLE
59522: LD_INT 1
59524: DEC
59525: ST_TO_ADDR
59526: LD_VAR 0 6
59530: PUSH
59531: FOR_TO
59532: IFFALSE 60596
// begin if i > 4 then
59534: LD_VAR 0 8
59538: PUSH
59539: LD_INT 4
59541: GREATER
59542: IFFALSE 59546
// break ;
59544: GO 60596
// case i of 1 :
59546: LD_VAR 0 8
59550: PUSH
59551: LD_INT 1
59553: DOUBLE
59554: EQUAL
59555: IFTRUE 59559
59557: GO 59639
59559: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59560: LD_ADDR_VAR 0 12
59564: PUSH
59565: LD_VAR 0 18
59569: PPUSH
59570: LD_INT 22
59572: PUSH
59573: LD_VAR 0 16
59577: PUSH
59578: EMPTY
59579: LIST
59580: LIST
59581: PUSH
59582: LD_INT 58
59584: PUSH
59585: EMPTY
59586: LIST
59587: PUSH
59588: LD_INT 2
59590: PUSH
59591: LD_INT 30
59593: PUSH
59594: LD_INT 32
59596: PUSH
59597: EMPTY
59598: LIST
59599: LIST
59600: PUSH
59601: LD_INT 30
59603: PUSH
59604: LD_INT 4
59606: PUSH
59607: EMPTY
59608: LIST
59609: LIST
59610: PUSH
59611: LD_INT 30
59613: PUSH
59614: LD_INT 5
59616: PUSH
59617: EMPTY
59618: LIST
59619: LIST
59620: PUSH
59621: EMPTY
59622: LIST
59623: LIST
59624: LIST
59625: LIST
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: LIST
59631: PPUSH
59632: CALL_OW 72
59636: ST_TO_ADDR
59637: GO 59861
59639: LD_INT 2
59641: DOUBLE
59642: EQUAL
59643: IFTRUE 59647
59645: GO 59709
59647: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59648: LD_ADDR_VAR 0 12
59652: PUSH
59653: LD_VAR 0 18
59657: PPUSH
59658: LD_INT 22
59660: PUSH
59661: LD_VAR 0 16
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: PUSH
59670: LD_INT 2
59672: PUSH
59673: LD_INT 30
59675: PUSH
59676: LD_INT 0
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: PUSH
59683: LD_INT 30
59685: PUSH
59686: LD_INT 1
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: LIST
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: PPUSH
59702: CALL_OW 72
59706: ST_TO_ADDR
59707: GO 59861
59709: LD_INT 3
59711: DOUBLE
59712: EQUAL
59713: IFTRUE 59717
59715: GO 59779
59717: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59718: LD_ADDR_VAR 0 12
59722: PUSH
59723: LD_VAR 0 18
59727: PPUSH
59728: LD_INT 22
59730: PUSH
59731: LD_VAR 0 16
59735: PUSH
59736: EMPTY
59737: LIST
59738: LIST
59739: PUSH
59740: LD_INT 2
59742: PUSH
59743: LD_INT 30
59745: PUSH
59746: LD_INT 2
59748: PUSH
59749: EMPTY
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 30
59755: PUSH
59756: LD_INT 3
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: EMPTY
59764: LIST
59765: LIST
59766: LIST
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: PPUSH
59772: CALL_OW 72
59776: ST_TO_ADDR
59777: GO 59861
59779: LD_INT 4
59781: DOUBLE
59782: EQUAL
59783: IFTRUE 59787
59785: GO 59860
59787: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59788: LD_ADDR_VAR 0 12
59792: PUSH
59793: LD_VAR 0 18
59797: PPUSH
59798: LD_INT 22
59800: PUSH
59801: LD_VAR 0 16
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: PUSH
59810: LD_INT 2
59812: PUSH
59813: LD_INT 30
59815: PUSH
59816: LD_INT 6
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PUSH
59823: LD_INT 30
59825: PUSH
59826: LD_INT 7
59828: PUSH
59829: EMPTY
59830: LIST
59831: LIST
59832: PUSH
59833: LD_INT 30
59835: PUSH
59836: LD_INT 8
59838: PUSH
59839: EMPTY
59840: LIST
59841: LIST
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: PPUSH
59853: CALL_OW 72
59857: ST_TO_ADDR
59858: GO 59861
59860: POP
// if i = 1 then
59861: LD_VAR 0 8
59865: PUSH
59866: LD_INT 1
59868: EQUAL
59869: IFFALSE 59980
// begin tmp := [ ] ;
59871: LD_ADDR_VAR 0 19
59875: PUSH
59876: EMPTY
59877: ST_TO_ADDR
// for j in f do
59878: LD_ADDR_VAR 0 9
59882: PUSH
59883: LD_VAR 0 12
59887: PUSH
59888: FOR_IN
59889: IFFALSE 59962
// if GetBType ( j ) = b_bunker then
59891: LD_VAR 0 9
59895: PPUSH
59896: CALL_OW 266
59900: PUSH
59901: LD_INT 32
59903: EQUAL
59904: IFFALSE 59931
// tmp := Insert ( tmp , 1 , j ) else
59906: LD_ADDR_VAR 0 19
59910: PUSH
59911: LD_VAR 0 19
59915: PPUSH
59916: LD_INT 1
59918: PPUSH
59919: LD_VAR 0 9
59923: PPUSH
59924: CALL_OW 2
59928: ST_TO_ADDR
59929: GO 59960
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59931: LD_ADDR_VAR 0 19
59935: PUSH
59936: LD_VAR 0 19
59940: PPUSH
59941: LD_VAR 0 19
59945: PUSH
59946: LD_INT 1
59948: PLUS
59949: PPUSH
59950: LD_VAR 0 9
59954: PPUSH
59955: CALL_OW 2
59959: ST_TO_ADDR
59960: GO 59888
59962: POP
59963: POP
// if tmp then
59964: LD_VAR 0 19
59968: IFFALSE 59980
// f := tmp ;
59970: LD_ADDR_VAR 0 12
59974: PUSH
59975: LD_VAR 0 19
59979: ST_TO_ADDR
// end ; x := personel [ i ] ;
59980: LD_ADDR_VAR 0 13
59984: PUSH
59985: LD_VAR 0 6
59989: PUSH
59990: LD_VAR 0 8
59994: ARRAY
59995: ST_TO_ADDR
// if x = - 1 then
59996: LD_VAR 0 13
60000: PUSH
60001: LD_INT 1
60003: NEG
60004: EQUAL
60005: IFFALSE 60214
// begin for j in f do
60007: LD_ADDR_VAR 0 9
60011: PUSH
60012: LD_VAR 0 12
60016: PUSH
60017: FOR_IN
60018: IFFALSE 60210
// repeat InitHc ;
60020: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60024: LD_VAR 0 9
60028: PPUSH
60029: CALL_OW 266
60033: PUSH
60034: LD_INT 5
60036: EQUAL
60037: IFFALSE 60107
// begin if UnitsInside ( j ) < 3 then
60039: LD_VAR 0 9
60043: PPUSH
60044: CALL_OW 313
60048: PUSH
60049: LD_INT 3
60051: LESS
60052: IFFALSE 60088
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60054: LD_INT 0
60056: PPUSH
60057: LD_INT 5
60059: PUSH
60060: LD_INT 8
60062: PUSH
60063: LD_INT 9
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: LIST
60070: PUSH
60071: LD_VAR 0 17
60075: ARRAY
60076: PPUSH
60077: LD_VAR 0 4
60081: PPUSH
60082: CALL_OW 380
60086: GO 60105
// PrepareHuman ( false , i , skill ) ;
60088: LD_INT 0
60090: PPUSH
60091: LD_VAR 0 8
60095: PPUSH
60096: LD_VAR 0 4
60100: PPUSH
60101: CALL_OW 380
// end else
60105: GO 60124
// PrepareHuman ( false , i , skill ) ;
60107: LD_INT 0
60109: PPUSH
60110: LD_VAR 0 8
60114: PPUSH
60115: LD_VAR 0 4
60119: PPUSH
60120: CALL_OW 380
// un := CreateHuman ;
60124: LD_ADDR_VAR 0 14
60128: PUSH
60129: CALL_OW 44
60133: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60134: LD_ADDR_VAR 0 7
60138: PUSH
60139: LD_VAR 0 7
60143: PPUSH
60144: LD_INT 1
60146: PPUSH
60147: LD_VAR 0 14
60151: PPUSH
60152: CALL_OW 2
60156: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60157: LD_VAR 0 14
60161: PPUSH
60162: LD_VAR 0 9
60166: PPUSH
60167: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60171: LD_VAR 0 9
60175: PPUSH
60176: CALL_OW 313
60180: PUSH
60181: LD_INT 6
60183: EQUAL
60184: PUSH
60185: LD_VAR 0 9
60189: PPUSH
60190: CALL_OW 266
60194: PUSH
60195: LD_INT 32
60197: PUSH
60198: LD_INT 31
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: IN
60205: OR
60206: IFFALSE 60020
60208: GO 60017
60210: POP
60211: POP
// end else
60212: GO 60594
// for j = 1 to x do
60214: LD_ADDR_VAR 0 9
60218: PUSH
60219: DOUBLE
60220: LD_INT 1
60222: DEC
60223: ST_TO_ADDR
60224: LD_VAR 0 13
60228: PUSH
60229: FOR_TO
60230: IFFALSE 60592
// begin InitHc ;
60232: CALL_OW 19
// if not f then
60236: LD_VAR 0 12
60240: NOT
60241: IFFALSE 60330
// begin PrepareHuman ( false , i , skill ) ;
60243: LD_INT 0
60245: PPUSH
60246: LD_VAR 0 8
60250: PPUSH
60251: LD_VAR 0 4
60255: PPUSH
60256: CALL_OW 380
// un := CreateHuman ;
60260: LD_ADDR_VAR 0 14
60264: PUSH
60265: CALL_OW 44
60269: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60270: LD_ADDR_VAR 0 7
60274: PUSH
60275: LD_VAR 0 7
60279: PPUSH
60280: LD_INT 1
60282: PPUSH
60283: LD_VAR 0 14
60287: PPUSH
60288: CALL_OW 2
60292: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60293: LD_VAR 0 14
60297: PPUSH
60298: LD_VAR 0 1
60302: PPUSH
60303: CALL_OW 250
60307: PPUSH
60308: LD_VAR 0 1
60312: PPUSH
60313: CALL_OW 251
60317: PPUSH
60318: LD_INT 10
60320: PPUSH
60321: LD_INT 0
60323: PPUSH
60324: CALL_OW 50
// continue ;
60328: GO 60229
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60330: LD_VAR 0 12
60334: PUSH
60335: LD_INT 1
60337: ARRAY
60338: PPUSH
60339: CALL_OW 313
60343: PUSH
60344: LD_VAR 0 12
60348: PUSH
60349: LD_INT 1
60351: ARRAY
60352: PPUSH
60353: CALL_OW 266
60357: PUSH
60358: LD_INT 32
60360: PUSH
60361: LD_INT 31
60363: PUSH
60364: EMPTY
60365: LIST
60366: LIST
60367: IN
60368: AND
60369: PUSH
60370: LD_VAR 0 12
60374: PUSH
60375: LD_INT 1
60377: ARRAY
60378: PPUSH
60379: CALL_OW 313
60383: PUSH
60384: LD_INT 6
60386: EQUAL
60387: OR
60388: IFFALSE 60408
// f := Delete ( f , 1 ) ;
60390: LD_ADDR_VAR 0 12
60394: PUSH
60395: LD_VAR 0 12
60399: PPUSH
60400: LD_INT 1
60402: PPUSH
60403: CALL_OW 3
60407: ST_TO_ADDR
// if not f then
60408: LD_VAR 0 12
60412: NOT
60413: IFFALSE 60431
// begin x := x + 2 ;
60415: LD_ADDR_VAR 0 13
60419: PUSH
60420: LD_VAR 0 13
60424: PUSH
60425: LD_INT 2
60427: PLUS
60428: ST_TO_ADDR
// continue ;
60429: GO 60229
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60431: LD_VAR 0 12
60435: PUSH
60436: LD_INT 1
60438: ARRAY
60439: PPUSH
60440: CALL_OW 266
60444: PUSH
60445: LD_INT 5
60447: EQUAL
60448: IFFALSE 60522
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60450: LD_VAR 0 12
60454: PUSH
60455: LD_INT 1
60457: ARRAY
60458: PPUSH
60459: CALL_OW 313
60463: PUSH
60464: LD_INT 3
60466: LESS
60467: IFFALSE 60503
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60469: LD_INT 0
60471: PPUSH
60472: LD_INT 5
60474: PUSH
60475: LD_INT 8
60477: PUSH
60478: LD_INT 9
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: LIST
60485: PUSH
60486: LD_VAR 0 17
60490: ARRAY
60491: PPUSH
60492: LD_VAR 0 4
60496: PPUSH
60497: CALL_OW 380
60501: GO 60520
// PrepareHuman ( false , i , skill ) ;
60503: LD_INT 0
60505: PPUSH
60506: LD_VAR 0 8
60510: PPUSH
60511: LD_VAR 0 4
60515: PPUSH
60516: CALL_OW 380
// end else
60520: GO 60539
// PrepareHuman ( false , i , skill ) ;
60522: LD_INT 0
60524: PPUSH
60525: LD_VAR 0 8
60529: PPUSH
60530: LD_VAR 0 4
60534: PPUSH
60535: CALL_OW 380
// un := CreateHuman ;
60539: LD_ADDR_VAR 0 14
60543: PUSH
60544: CALL_OW 44
60548: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60549: LD_ADDR_VAR 0 7
60553: PUSH
60554: LD_VAR 0 7
60558: PPUSH
60559: LD_INT 1
60561: PPUSH
60562: LD_VAR 0 14
60566: PPUSH
60567: CALL_OW 2
60571: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60572: LD_VAR 0 14
60576: PPUSH
60577: LD_VAR 0 12
60581: PUSH
60582: LD_INT 1
60584: ARRAY
60585: PPUSH
60586: CALL_OW 52
// end ;
60590: GO 60229
60592: POP
60593: POP
// end ;
60594: GO 59531
60596: POP
60597: POP
// result := result ^ buildings ;
60598: LD_ADDR_VAR 0 7
60602: PUSH
60603: LD_VAR 0 7
60607: PUSH
60608: LD_VAR 0 18
60612: ADD
60613: ST_TO_ADDR
// end else
60614: GO 60757
// begin for i = 1 to personel do
60616: LD_ADDR_VAR 0 8
60620: PUSH
60621: DOUBLE
60622: LD_INT 1
60624: DEC
60625: ST_TO_ADDR
60626: LD_VAR 0 6
60630: PUSH
60631: FOR_TO
60632: IFFALSE 60755
// begin if i > 4 then
60634: LD_VAR 0 8
60638: PUSH
60639: LD_INT 4
60641: GREATER
60642: IFFALSE 60646
// break ;
60644: GO 60755
// x := personel [ i ] ;
60646: LD_ADDR_VAR 0 13
60650: PUSH
60651: LD_VAR 0 6
60655: PUSH
60656: LD_VAR 0 8
60660: ARRAY
60661: ST_TO_ADDR
// if x = - 1 then
60662: LD_VAR 0 13
60666: PUSH
60667: LD_INT 1
60669: NEG
60670: EQUAL
60671: IFFALSE 60675
// continue ;
60673: GO 60631
// PrepareHuman ( false , i , skill ) ;
60675: LD_INT 0
60677: PPUSH
60678: LD_VAR 0 8
60682: PPUSH
60683: LD_VAR 0 4
60687: PPUSH
60688: CALL_OW 380
// un := CreateHuman ;
60692: LD_ADDR_VAR 0 14
60696: PUSH
60697: CALL_OW 44
60701: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60702: LD_VAR 0 14
60706: PPUSH
60707: LD_VAR 0 1
60711: PPUSH
60712: CALL_OW 250
60716: PPUSH
60717: LD_VAR 0 1
60721: PPUSH
60722: CALL_OW 251
60726: PPUSH
60727: LD_INT 10
60729: PPUSH
60730: LD_INT 0
60732: PPUSH
60733: CALL_OW 50
// result := result ^ un ;
60737: LD_ADDR_VAR 0 7
60741: PUSH
60742: LD_VAR 0 7
60746: PUSH
60747: LD_VAR 0 14
60751: ADD
60752: ST_TO_ADDR
// end ;
60753: GO 60631
60755: POP
60756: POP
// end ; end ;
60757: LD_VAR 0 7
60761: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60762: LD_INT 0
60764: PPUSH
60765: PPUSH
60766: PPUSH
60767: PPUSH
60768: PPUSH
60769: PPUSH
60770: PPUSH
60771: PPUSH
60772: PPUSH
60773: PPUSH
60774: PPUSH
60775: PPUSH
60776: PPUSH
60777: PPUSH
60778: PPUSH
60779: PPUSH
// result := false ;
60780: LD_ADDR_VAR 0 3
60784: PUSH
60785: LD_INT 0
60787: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60788: LD_VAR 0 1
60792: NOT
60793: PUSH
60794: LD_VAR 0 1
60798: PPUSH
60799: CALL_OW 266
60803: PUSH
60804: LD_INT 32
60806: PUSH
60807: LD_INT 33
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: IN
60814: NOT
60815: OR
60816: IFFALSE 60820
// exit ;
60818: GO 61956
// nat := GetNation ( tower ) ;
60820: LD_ADDR_VAR 0 12
60824: PUSH
60825: LD_VAR 0 1
60829: PPUSH
60830: CALL_OW 248
60834: ST_TO_ADDR
// side := GetSide ( tower ) ;
60835: LD_ADDR_VAR 0 16
60839: PUSH
60840: LD_VAR 0 1
60844: PPUSH
60845: CALL_OW 255
60849: ST_TO_ADDR
// x := GetX ( tower ) ;
60850: LD_ADDR_VAR 0 10
60854: PUSH
60855: LD_VAR 0 1
60859: PPUSH
60860: CALL_OW 250
60864: ST_TO_ADDR
// y := GetY ( tower ) ;
60865: LD_ADDR_VAR 0 11
60869: PUSH
60870: LD_VAR 0 1
60874: PPUSH
60875: CALL_OW 251
60879: ST_TO_ADDR
// if not x or not y then
60880: LD_VAR 0 10
60884: NOT
60885: PUSH
60886: LD_VAR 0 11
60890: NOT
60891: OR
60892: IFFALSE 60896
// exit ;
60894: GO 61956
// weapon := 0 ;
60896: LD_ADDR_VAR 0 18
60900: PUSH
60901: LD_INT 0
60903: ST_TO_ADDR
// fac_list := [ ] ;
60904: LD_ADDR_VAR 0 17
60908: PUSH
60909: EMPTY
60910: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60911: LD_ADDR_VAR 0 6
60915: PUSH
60916: LD_VAR 0 1
60920: PPUSH
60921: CALL_OW 274
60925: PPUSH
60926: LD_VAR 0 2
60930: PPUSH
60931: CALL 58534 0 2
60935: PPUSH
60936: LD_INT 30
60938: PUSH
60939: LD_INT 3
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: PPUSH
60946: CALL_OW 72
60950: ST_TO_ADDR
// if not factories then
60951: LD_VAR 0 6
60955: NOT
60956: IFFALSE 60960
// exit ;
60958: GO 61956
// for i in factories do
60960: LD_ADDR_VAR 0 8
60964: PUSH
60965: LD_VAR 0 6
60969: PUSH
60970: FOR_IN
60971: IFFALSE 60996
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60973: LD_ADDR_VAR 0 17
60977: PUSH
60978: LD_VAR 0 17
60982: PUSH
60983: LD_VAR 0 8
60987: PPUSH
60988: CALL_OW 478
60992: UNION
60993: ST_TO_ADDR
60994: GO 60970
60996: POP
60997: POP
// if not fac_list then
60998: LD_VAR 0 17
61002: NOT
61003: IFFALSE 61007
// exit ;
61005: GO 61956
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61007: LD_ADDR_VAR 0 5
61011: PUSH
61012: LD_INT 4
61014: PUSH
61015: LD_INT 5
61017: PUSH
61018: LD_INT 9
61020: PUSH
61021: LD_INT 10
61023: PUSH
61024: LD_INT 6
61026: PUSH
61027: LD_INT 7
61029: PUSH
61030: LD_INT 11
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: LIST
61037: LIST
61038: LIST
61039: LIST
61040: LIST
61041: PUSH
61042: LD_INT 27
61044: PUSH
61045: LD_INT 28
61047: PUSH
61048: LD_INT 26
61050: PUSH
61051: LD_INT 30
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: LIST
61058: LIST
61059: PUSH
61060: LD_INT 43
61062: PUSH
61063: LD_INT 44
61065: PUSH
61066: LD_INT 46
61068: PUSH
61069: LD_INT 45
61071: PUSH
61072: LD_INT 47
61074: PUSH
61075: LD_INT 49
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: LIST
61082: LIST
61083: LIST
61084: LIST
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: LIST
61090: PUSH
61091: LD_VAR 0 12
61095: ARRAY
61096: ST_TO_ADDR
// for i in list do
61097: LD_ADDR_VAR 0 8
61101: PUSH
61102: LD_VAR 0 5
61106: PUSH
61107: FOR_IN
61108: IFFALSE 61141
// if not i in fac_list then
61110: LD_VAR 0 8
61114: PUSH
61115: LD_VAR 0 17
61119: IN
61120: NOT
61121: IFFALSE 61139
// list := list diff i ;
61123: LD_ADDR_VAR 0 5
61127: PUSH
61128: LD_VAR 0 5
61132: PUSH
61133: LD_VAR 0 8
61137: DIFF
61138: ST_TO_ADDR
61139: GO 61107
61141: POP
61142: POP
// if not list then
61143: LD_VAR 0 5
61147: NOT
61148: IFFALSE 61152
// exit ;
61150: GO 61956
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61152: LD_VAR 0 12
61156: PUSH
61157: LD_INT 3
61159: EQUAL
61160: PUSH
61161: LD_INT 49
61163: PUSH
61164: LD_VAR 0 5
61168: IN
61169: AND
61170: PUSH
61171: LD_INT 31
61173: PPUSH
61174: LD_VAR 0 16
61178: PPUSH
61179: CALL_OW 321
61183: PUSH
61184: LD_INT 2
61186: EQUAL
61187: AND
61188: IFFALSE 61248
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61190: LD_INT 22
61192: PUSH
61193: LD_VAR 0 16
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: PUSH
61202: LD_INT 35
61204: PUSH
61205: LD_INT 49
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 91
61214: PUSH
61215: LD_VAR 0 1
61219: PUSH
61220: LD_INT 10
61222: PUSH
61223: EMPTY
61224: LIST
61225: LIST
61226: LIST
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: LIST
61232: PPUSH
61233: CALL_OW 69
61237: NOT
61238: IFFALSE 61248
// weapon := ru_time_lapser ;
61240: LD_ADDR_VAR 0 18
61244: PUSH
61245: LD_INT 49
61247: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61248: LD_VAR 0 12
61252: PUSH
61253: LD_INT 1
61255: PUSH
61256: LD_INT 2
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: IN
61263: PUSH
61264: LD_INT 11
61266: PUSH
61267: LD_VAR 0 5
61271: IN
61272: PUSH
61273: LD_INT 30
61275: PUSH
61276: LD_VAR 0 5
61280: IN
61281: OR
61282: AND
61283: PUSH
61284: LD_INT 6
61286: PPUSH
61287: LD_VAR 0 16
61291: PPUSH
61292: CALL_OW 321
61296: PUSH
61297: LD_INT 2
61299: EQUAL
61300: AND
61301: IFFALSE 61466
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61303: LD_INT 22
61305: PUSH
61306: LD_VAR 0 16
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: PUSH
61315: LD_INT 2
61317: PUSH
61318: LD_INT 35
61320: PUSH
61321: LD_INT 11
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PUSH
61328: LD_INT 35
61330: PUSH
61331: LD_INT 30
61333: PUSH
61334: EMPTY
61335: LIST
61336: LIST
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: LIST
61342: PUSH
61343: LD_INT 91
61345: PUSH
61346: LD_VAR 0 1
61350: PUSH
61351: LD_INT 18
61353: PUSH
61354: EMPTY
61355: LIST
61356: LIST
61357: LIST
61358: PUSH
61359: EMPTY
61360: LIST
61361: LIST
61362: LIST
61363: PPUSH
61364: CALL_OW 69
61368: NOT
61369: PUSH
61370: LD_INT 22
61372: PUSH
61373: LD_VAR 0 16
61377: PUSH
61378: EMPTY
61379: LIST
61380: LIST
61381: PUSH
61382: LD_INT 2
61384: PUSH
61385: LD_INT 30
61387: PUSH
61388: LD_INT 32
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PUSH
61395: LD_INT 30
61397: PUSH
61398: LD_INT 33
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PUSH
61405: EMPTY
61406: LIST
61407: LIST
61408: LIST
61409: PUSH
61410: LD_INT 91
61412: PUSH
61413: LD_VAR 0 1
61417: PUSH
61418: LD_INT 12
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: LIST
61425: PUSH
61426: EMPTY
61427: LIST
61428: LIST
61429: LIST
61430: PUSH
61431: EMPTY
61432: LIST
61433: PPUSH
61434: CALL_OW 69
61438: PUSH
61439: LD_INT 2
61441: GREATER
61442: AND
61443: IFFALSE 61466
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61445: LD_ADDR_VAR 0 18
61449: PUSH
61450: LD_INT 11
61452: PUSH
61453: LD_INT 30
61455: PUSH
61456: EMPTY
61457: LIST
61458: LIST
61459: PUSH
61460: LD_VAR 0 12
61464: ARRAY
61465: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61466: LD_VAR 0 18
61470: NOT
61471: PUSH
61472: LD_INT 40
61474: PPUSH
61475: LD_VAR 0 16
61479: PPUSH
61480: CALL_OW 321
61484: PUSH
61485: LD_INT 2
61487: EQUAL
61488: AND
61489: PUSH
61490: LD_INT 7
61492: PUSH
61493: LD_VAR 0 5
61497: IN
61498: PUSH
61499: LD_INT 28
61501: PUSH
61502: LD_VAR 0 5
61506: IN
61507: OR
61508: PUSH
61509: LD_INT 45
61511: PUSH
61512: LD_VAR 0 5
61516: IN
61517: OR
61518: AND
61519: IFFALSE 61773
// begin hex := GetHexInfo ( x , y ) ;
61521: LD_ADDR_VAR 0 4
61525: PUSH
61526: LD_VAR 0 10
61530: PPUSH
61531: LD_VAR 0 11
61535: PPUSH
61536: CALL_OW 546
61540: ST_TO_ADDR
// if hex [ 1 ] then
61541: LD_VAR 0 4
61545: PUSH
61546: LD_INT 1
61548: ARRAY
61549: IFFALSE 61553
// exit ;
61551: GO 61956
// height := hex [ 2 ] ;
61553: LD_ADDR_VAR 0 15
61557: PUSH
61558: LD_VAR 0 4
61562: PUSH
61563: LD_INT 2
61565: ARRAY
61566: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61567: LD_ADDR_VAR 0 14
61571: PUSH
61572: LD_INT 0
61574: PUSH
61575: LD_INT 2
61577: PUSH
61578: LD_INT 3
61580: PUSH
61581: LD_INT 5
61583: PUSH
61584: EMPTY
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: ST_TO_ADDR
// for i in tmp do
61590: LD_ADDR_VAR 0 8
61594: PUSH
61595: LD_VAR 0 14
61599: PUSH
61600: FOR_IN
61601: IFFALSE 61771
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61603: LD_ADDR_VAR 0 9
61607: PUSH
61608: LD_VAR 0 10
61612: PPUSH
61613: LD_VAR 0 8
61617: PPUSH
61618: LD_INT 5
61620: PPUSH
61621: CALL_OW 272
61625: PUSH
61626: LD_VAR 0 11
61630: PPUSH
61631: LD_VAR 0 8
61635: PPUSH
61636: LD_INT 5
61638: PPUSH
61639: CALL_OW 273
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61648: LD_VAR 0 9
61652: PUSH
61653: LD_INT 1
61655: ARRAY
61656: PPUSH
61657: LD_VAR 0 9
61661: PUSH
61662: LD_INT 2
61664: ARRAY
61665: PPUSH
61666: CALL_OW 488
61670: IFFALSE 61769
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61672: LD_ADDR_VAR 0 4
61676: PUSH
61677: LD_VAR 0 9
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: PPUSH
61686: LD_VAR 0 9
61690: PUSH
61691: LD_INT 2
61693: ARRAY
61694: PPUSH
61695: CALL_OW 546
61699: ST_TO_ADDR
// if hex [ 1 ] then
61700: LD_VAR 0 4
61704: PUSH
61705: LD_INT 1
61707: ARRAY
61708: IFFALSE 61712
// continue ;
61710: GO 61600
// h := hex [ 2 ] ;
61712: LD_ADDR_VAR 0 13
61716: PUSH
61717: LD_VAR 0 4
61721: PUSH
61722: LD_INT 2
61724: ARRAY
61725: ST_TO_ADDR
// if h + 7 < height then
61726: LD_VAR 0 13
61730: PUSH
61731: LD_INT 7
61733: PLUS
61734: PUSH
61735: LD_VAR 0 15
61739: LESS
61740: IFFALSE 61769
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61742: LD_ADDR_VAR 0 18
61746: PUSH
61747: LD_INT 7
61749: PUSH
61750: LD_INT 28
61752: PUSH
61753: LD_INT 45
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: LIST
61760: PUSH
61761: LD_VAR 0 12
61765: ARRAY
61766: ST_TO_ADDR
// break ;
61767: GO 61771
// end ; end ; end ;
61769: GO 61600
61771: POP
61772: POP
// end ; if not weapon then
61773: LD_VAR 0 18
61777: NOT
61778: IFFALSE 61838
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61780: LD_ADDR_VAR 0 5
61784: PUSH
61785: LD_VAR 0 5
61789: PUSH
61790: LD_INT 11
61792: PUSH
61793: LD_INT 30
61795: PUSH
61796: LD_INT 49
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: LIST
61803: DIFF
61804: ST_TO_ADDR
// if not list then
61805: LD_VAR 0 5
61809: NOT
61810: IFFALSE 61814
// exit ;
61812: GO 61956
// weapon := list [ rand ( 1 , list ) ] ;
61814: LD_ADDR_VAR 0 18
61818: PUSH
61819: LD_VAR 0 5
61823: PUSH
61824: LD_INT 1
61826: PPUSH
61827: LD_VAR 0 5
61831: PPUSH
61832: CALL_OW 12
61836: ARRAY
61837: ST_TO_ADDR
// end ; if weapon then
61838: LD_VAR 0 18
61842: IFFALSE 61956
// begin tmp := CostOfWeapon ( weapon ) ;
61844: LD_ADDR_VAR 0 14
61848: PUSH
61849: LD_VAR 0 18
61853: PPUSH
61854: CALL_OW 451
61858: ST_TO_ADDR
// j := GetBase ( tower ) ;
61859: LD_ADDR_VAR 0 9
61863: PUSH
61864: LD_VAR 0 1
61868: PPUSH
61869: CALL_OW 274
61873: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61874: LD_VAR 0 9
61878: PPUSH
61879: LD_INT 1
61881: PPUSH
61882: CALL_OW 275
61886: PUSH
61887: LD_VAR 0 14
61891: PUSH
61892: LD_INT 1
61894: ARRAY
61895: GREATEREQUAL
61896: PUSH
61897: LD_VAR 0 9
61901: PPUSH
61902: LD_INT 2
61904: PPUSH
61905: CALL_OW 275
61909: PUSH
61910: LD_VAR 0 14
61914: PUSH
61915: LD_INT 2
61917: ARRAY
61918: GREATEREQUAL
61919: AND
61920: PUSH
61921: LD_VAR 0 9
61925: PPUSH
61926: LD_INT 3
61928: PPUSH
61929: CALL_OW 275
61933: PUSH
61934: LD_VAR 0 14
61938: PUSH
61939: LD_INT 3
61941: ARRAY
61942: GREATEREQUAL
61943: AND
61944: IFFALSE 61956
// result := weapon ;
61946: LD_ADDR_VAR 0 3
61950: PUSH
61951: LD_VAR 0 18
61955: ST_TO_ADDR
// end ; end ;
61956: LD_VAR 0 3
61960: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61961: LD_INT 0
61963: PPUSH
61964: PPUSH
// result := true ;
61965: LD_ADDR_VAR 0 3
61969: PUSH
61970: LD_INT 1
61972: ST_TO_ADDR
// if array1 = array2 then
61973: LD_VAR 0 1
61977: PUSH
61978: LD_VAR 0 2
61982: EQUAL
61983: IFFALSE 62043
// begin for i = 1 to array1 do
61985: LD_ADDR_VAR 0 4
61989: PUSH
61990: DOUBLE
61991: LD_INT 1
61993: DEC
61994: ST_TO_ADDR
61995: LD_VAR 0 1
61999: PUSH
62000: FOR_TO
62001: IFFALSE 62039
// if array1 [ i ] <> array2 [ i ] then
62003: LD_VAR 0 1
62007: PUSH
62008: LD_VAR 0 4
62012: ARRAY
62013: PUSH
62014: LD_VAR 0 2
62018: PUSH
62019: LD_VAR 0 4
62023: ARRAY
62024: NONEQUAL
62025: IFFALSE 62037
// begin result := false ;
62027: LD_ADDR_VAR 0 3
62031: PUSH
62032: LD_INT 0
62034: ST_TO_ADDR
// break ;
62035: GO 62039
// end ;
62037: GO 62000
62039: POP
62040: POP
// end else
62041: GO 62051
// result := false ;
62043: LD_ADDR_VAR 0 3
62047: PUSH
62048: LD_INT 0
62050: ST_TO_ADDR
// end ;
62051: LD_VAR 0 3
62055: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62056: LD_INT 0
62058: PPUSH
62059: PPUSH
62060: PPUSH
// pom := GetBase ( fac ) ;
62061: LD_ADDR_VAR 0 5
62065: PUSH
62066: LD_VAR 0 1
62070: PPUSH
62071: CALL_OW 274
62075: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62076: LD_ADDR_VAR 0 4
62080: PUSH
62081: LD_VAR 0 2
62085: PUSH
62086: LD_INT 1
62088: ARRAY
62089: PPUSH
62090: LD_VAR 0 2
62094: PUSH
62095: LD_INT 2
62097: ARRAY
62098: PPUSH
62099: LD_VAR 0 2
62103: PUSH
62104: LD_INT 3
62106: ARRAY
62107: PPUSH
62108: LD_VAR 0 2
62112: PUSH
62113: LD_INT 4
62115: ARRAY
62116: PPUSH
62117: CALL_OW 449
62121: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62122: LD_ADDR_VAR 0 3
62126: PUSH
62127: LD_VAR 0 5
62131: PPUSH
62132: LD_INT 1
62134: PPUSH
62135: CALL_OW 275
62139: PUSH
62140: LD_VAR 0 4
62144: PUSH
62145: LD_INT 1
62147: ARRAY
62148: GREATEREQUAL
62149: PUSH
62150: LD_VAR 0 5
62154: PPUSH
62155: LD_INT 2
62157: PPUSH
62158: CALL_OW 275
62162: PUSH
62163: LD_VAR 0 4
62167: PUSH
62168: LD_INT 2
62170: ARRAY
62171: GREATEREQUAL
62172: AND
62173: PUSH
62174: LD_VAR 0 5
62178: PPUSH
62179: LD_INT 3
62181: PPUSH
62182: CALL_OW 275
62186: PUSH
62187: LD_VAR 0 4
62191: PUSH
62192: LD_INT 3
62194: ARRAY
62195: GREATEREQUAL
62196: AND
62197: ST_TO_ADDR
// end ;
62198: LD_VAR 0 3
62202: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62203: LD_INT 0
62205: PPUSH
62206: PPUSH
62207: PPUSH
62208: PPUSH
// pom := GetBase ( building ) ;
62209: LD_ADDR_VAR 0 3
62213: PUSH
62214: LD_VAR 0 1
62218: PPUSH
62219: CALL_OW 274
62223: ST_TO_ADDR
// if not pom then
62224: LD_VAR 0 3
62228: NOT
62229: IFFALSE 62233
// exit ;
62231: GO 62403
// btype := GetBType ( building ) ;
62233: LD_ADDR_VAR 0 5
62237: PUSH
62238: LD_VAR 0 1
62242: PPUSH
62243: CALL_OW 266
62247: ST_TO_ADDR
// if btype = b_armoury then
62248: LD_VAR 0 5
62252: PUSH
62253: LD_INT 4
62255: EQUAL
62256: IFFALSE 62266
// btype := b_barracks ;
62258: LD_ADDR_VAR 0 5
62262: PUSH
62263: LD_INT 5
62265: ST_TO_ADDR
// if btype = b_depot then
62266: LD_VAR 0 5
62270: PUSH
62271: LD_INT 0
62273: EQUAL
62274: IFFALSE 62284
// btype := b_warehouse ;
62276: LD_ADDR_VAR 0 5
62280: PUSH
62281: LD_INT 1
62283: ST_TO_ADDR
// if btype = b_workshop then
62284: LD_VAR 0 5
62288: PUSH
62289: LD_INT 2
62291: EQUAL
62292: IFFALSE 62302
// btype := b_factory ;
62294: LD_ADDR_VAR 0 5
62298: PUSH
62299: LD_INT 3
62301: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62302: LD_ADDR_VAR 0 4
62306: PUSH
62307: LD_VAR 0 5
62311: PPUSH
62312: LD_VAR 0 1
62316: PPUSH
62317: CALL_OW 248
62321: PPUSH
62322: CALL_OW 450
62326: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62327: LD_ADDR_VAR 0 2
62331: PUSH
62332: LD_VAR 0 3
62336: PPUSH
62337: LD_INT 1
62339: PPUSH
62340: CALL_OW 275
62344: PUSH
62345: LD_VAR 0 4
62349: PUSH
62350: LD_INT 1
62352: ARRAY
62353: GREATEREQUAL
62354: PUSH
62355: LD_VAR 0 3
62359: PPUSH
62360: LD_INT 2
62362: PPUSH
62363: CALL_OW 275
62367: PUSH
62368: LD_VAR 0 4
62372: PUSH
62373: LD_INT 2
62375: ARRAY
62376: GREATEREQUAL
62377: AND
62378: PUSH
62379: LD_VAR 0 3
62383: PPUSH
62384: LD_INT 3
62386: PPUSH
62387: CALL_OW 275
62391: PUSH
62392: LD_VAR 0 4
62396: PUSH
62397: LD_INT 3
62399: ARRAY
62400: GREATEREQUAL
62401: AND
62402: ST_TO_ADDR
// end ;
62403: LD_VAR 0 2
62407: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62408: LD_INT 0
62410: PPUSH
62411: PPUSH
62412: PPUSH
// pom := GetBase ( building ) ;
62413: LD_ADDR_VAR 0 4
62417: PUSH
62418: LD_VAR 0 1
62422: PPUSH
62423: CALL_OW 274
62427: ST_TO_ADDR
// if not pom then
62428: LD_VAR 0 4
62432: NOT
62433: IFFALSE 62437
// exit ;
62435: GO 62538
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62437: LD_ADDR_VAR 0 5
62441: PUSH
62442: LD_VAR 0 2
62446: PPUSH
62447: LD_VAR 0 1
62451: PPUSH
62452: CALL_OW 248
62456: PPUSH
62457: CALL_OW 450
62461: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62462: LD_ADDR_VAR 0 3
62466: PUSH
62467: LD_VAR 0 4
62471: PPUSH
62472: LD_INT 1
62474: PPUSH
62475: CALL_OW 275
62479: PUSH
62480: LD_VAR 0 5
62484: PUSH
62485: LD_INT 1
62487: ARRAY
62488: GREATEREQUAL
62489: PUSH
62490: LD_VAR 0 4
62494: PPUSH
62495: LD_INT 2
62497: PPUSH
62498: CALL_OW 275
62502: PUSH
62503: LD_VAR 0 5
62507: PUSH
62508: LD_INT 2
62510: ARRAY
62511: GREATEREQUAL
62512: AND
62513: PUSH
62514: LD_VAR 0 4
62518: PPUSH
62519: LD_INT 3
62521: PPUSH
62522: CALL_OW 275
62526: PUSH
62527: LD_VAR 0 5
62531: PUSH
62532: LD_INT 3
62534: ARRAY
62535: GREATEREQUAL
62536: AND
62537: ST_TO_ADDR
// end ;
62538: LD_VAR 0 3
62542: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62543: LD_INT 0
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
62554: PPUSH
// result := false ;
62555: LD_ADDR_VAR 0 6
62559: PUSH
62560: LD_INT 0
62562: ST_TO_ADDR
// if not base or not btype or not x or not y then
62563: LD_VAR 0 1
62567: NOT
62568: PUSH
62569: LD_VAR 0 2
62573: NOT
62574: OR
62575: PUSH
62576: LD_VAR 0 3
62580: NOT
62581: OR
62582: PUSH
62583: LD_VAR 0 4
62587: NOT
62588: OR
62589: IFFALSE 62593
// exit ;
62591: GO 63202
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62593: LD_ADDR_VAR 0 12
62597: PUSH
62598: LD_VAR 0 2
62602: PPUSH
62603: LD_VAR 0 3
62607: PPUSH
62608: LD_VAR 0 4
62612: PPUSH
62613: LD_VAR 0 5
62617: PPUSH
62618: LD_VAR 0 1
62622: PUSH
62623: LD_INT 1
62625: ARRAY
62626: PPUSH
62627: CALL_OW 248
62631: PPUSH
62632: LD_INT 0
62634: PPUSH
62635: CALL 64039 0 6
62639: ST_TO_ADDR
// if not hexes then
62640: LD_VAR 0 12
62644: NOT
62645: IFFALSE 62649
// exit ;
62647: GO 63202
// for i = 1 to hexes do
62649: LD_ADDR_VAR 0 7
62653: PUSH
62654: DOUBLE
62655: LD_INT 1
62657: DEC
62658: ST_TO_ADDR
62659: LD_VAR 0 12
62663: PUSH
62664: FOR_TO
62665: IFFALSE 63200
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62667: LD_ADDR_VAR 0 11
62671: PUSH
62672: LD_VAR 0 12
62676: PUSH
62677: LD_VAR 0 7
62681: ARRAY
62682: PUSH
62683: LD_INT 1
62685: ARRAY
62686: PPUSH
62687: LD_VAR 0 12
62691: PUSH
62692: LD_VAR 0 7
62696: ARRAY
62697: PUSH
62698: LD_INT 2
62700: ARRAY
62701: PPUSH
62702: CALL_OW 428
62706: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62707: LD_VAR 0 12
62711: PUSH
62712: LD_VAR 0 7
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PPUSH
62722: LD_VAR 0 12
62726: PUSH
62727: LD_VAR 0 7
62731: ARRAY
62732: PUSH
62733: LD_INT 2
62735: ARRAY
62736: PPUSH
62737: CALL_OW 351
62741: PUSH
62742: LD_VAR 0 12
62746: PUSH
62747: LD_VAR 0 7
62751: ARRAY
62752: PUSH
62753: LD_INT 1
62755: ARRAY
62756: PPUSH
62757: LD_VAR 0 12
62761: PUSH
62762: LD_VAR 0 7
62766: ARRAY
62767: PUSH
62768: LD_INT 2
62770: ARRAY
62771: PPUSH
62772: CALL_OW 488
62776: NOT
62777: OR
62778: PUSH
62779: LD_VAR 0 11
62783: PPUSH
62784: CALL_OW 247
62788: PUSH
62789: LD_INT 3
62791: EQUAL
62792: OR
62793: IFFALSE 62799
// exit ;
62795: POP
62796: POP
62797: GO 63202
// if not tmp or not tmp in base then
62799: LD_VAR 0 11
62803: NOT
62804: PUSH
62805: LD_VAR 0 11
62809: PUSH
62810: LD_VAR 0 1
62814: IN
62815: NOT
62816: OR
62817: IFFALSE 62821
// continue ;
62819: GO 62664
// result := true ;
62821: LD_ADDR_VAR 0 6
62825: PUSH
62826: LD_INT 1
62828: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62829: LD_ADDR_VAR 0 15
62833: PUSH
62834: LD_VAR 0 1
62838: PPUSH
62839: LD_INT 22
62841: PUSH
62842: LD_VAR 0 11
62846: PPUSH
62847: CALL_OW 255
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 2
62858: PUSH
62859: LD_INT 30
62861: PUSH
62862: LD_INT 0
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: PUSH
62869: LD_INT 30
62871: PUSH
62872: LD_INT 1
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PUSH
62879: EMPTY
62880: LIST
62881: LIST
62882: LIST
62883: PUSH
62884: EMPTY
62885: LIST
62886: LIST
62887: PPUSH
62888: CALL_OW 72
62892: ST_TO_ADDR
// if dep then
62893: LD_VAR 0 15
62897: IFFALSE 63033
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62899: LD_ADDR_VAR 0 14
62903: PUSH
62904: LD_VAR 0 15
62908: PUSH
62909: LD_INT 1
62911: ARRAY
62912: PPUSH
62913: CALL_OW 250
62917: PPUSH
62918: LD_VAR 0 15
62922: PUSH
62923: LD_INT 1
62925: ARRAY
62926: PPUSH
62927: CALL_OW 254
62931: PPUSH
62932: LD_INT 5
62934: PPUSH
62935: CALL_OW 272
62939: PUSH
62940: LD_VAR 0 15
62944: PUSH
62945: LD_INT 1
62947: ARRAY
62948: PPUSH
62949: CALL_OW 251
62953: PPUSH
62954: LD_VAR 0 15
62958: PUSH
62959: LD_INT 1
62961: ARRAY
62962: PPUSH
62963: CALL_OW 254
62967: PPUSH
62968: LD_INT 5
62970: PPUSH
62971: CALL_OW 273
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62980: LD_VAR 0 14
62984: PUSH
62985: LD_INT 1
62987: ARRAY
62988: PPUSH
62989: LD_VAR 0 14
62993: PUSH
62994: LD_INT 2
62996: ARRAY
62997: PPUSH
62998: CALL_OW 488
63002: IFFALSE 63033
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63004: LD_VAR 0 11
63008: PPUSH
63009: LD_VAR 0 14
63013: PUSH
63014: LD_INT 1
63016: ARRAY
63017: PPUSH
63018: LD_VAR 0 14
63022: PUSH
63023: LD_INT 2
63025: ARRAY
63026: PPUSH
63027: CALL_OW 111
// continue ;
63031: GO 62664
// end ; end ; r := GetDir ( tmp ) ;
63033: LD_ADDR_VAR 0 13
63037: PUSH
63038: LD_VAR 0 11
63042: PPUSH
63043: CALL_OW 254
63047: ST_TO_ADDR
// if r = 5 then
63048: LD_VAR 0 13
63052: PUSH
63053: LD_INT 5
63055: EQUAL
63056: IFFALSE 63066
// r := 0 ;
63058: LD_ADDR_VAR 0 13
63062: PUSH
63063: LD_INT 0
63065: ST_TO_ADDR
// for j = r to 5 do
63066: LD_ADDR_VAR 0 8
63070: PUSH
63071: DOUBLE
63072: LD_VAR 0 13
63076: DEC
63077: ST_TO_ADDR
63078: LD_INT 5
63080: PUSH
63081: FOR_TO
63082: IFFALSE 63196
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63084: LD_ADDR_VAR 0 9
63088: PUSH
63089: LD_VAR 0 11
63093: PPUSH
63094: CALL_OW 250
63098: PPUSH
63099: LD_VAR 0 8
63103: PPUSH
63104: LD_INT 2
63106: PPUSH
63107: CALL_OW 272
63111: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63112: LD_ADDR_VAR 0 10
63116: PUSH
63117: LD_VAR 0 11
63121: PPUSH
63122: CALL_OW 251
63126: PPUSH
63127: LD_VAR 0 8
63131: PPUSH
63132: LD_INT 2
63134: PPUSH
63135: CALL_OW 273
63139: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63140: LD_VAR 0 9
63144: PPUSH
63145: LD_VAR 0 10
63149: PPUSH
63150: CALL_OW 488
63154: PUSH
63155: LD_VAR 0 9
63159: PPUSH
63160: LD_VAR 0 10
63164: PPUSH
63165: CALL_OW 428
63169: NOT
63170: AND
63171: IFFALSE 63194
// begin ComMoveXY ( tmp , _x , _y ) ;
63173: LD_VAR 0 11
63177: PPUSH
63178: LD_VAR 0 9
63182: PPUSH
63183: LD_VAR 0 10
63187: PPUSH
63188: CALL_OW 111
// break ;
63192: GO 63196
// end ; end ;
63194: GO 63081
63196: POP
63197: POP
// end ;
63198: GO 62664
63200: POP
63201: POP
// end ;
63202: LD_VAR 0 6
63206: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63207: LD_INT 0
63209: PPUSH
63210: PPUSH
63211: PPUSH
63212: PPUSH
63213: PPUSH
63214: PPUSH
63215: PPUSH
63216: PPUSH
63217: PPUSH
63218: PPUSH
// result := false ;
63219: LD_ADDR_VAR 0 6
63223: PUSH
63224: LD_INT 0
63226: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63227: LD_VAR 0 1
63231: NOT
63232: PUSH
63233: LD_VAR 0 1
63237: PPUSH
63238: CALL_OW 266
63242: PUSH
63243: LD_INT 0
63245: PUSH
63246: LD_INT 1
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: IN
63253: NOT
63254: OR
63255: PUSH
63256: LD_VAR 0 2
63260: NOT
63261: OR
63262: PUSH
63263: LD_VAR 0 5
63267: PUSH
63268: LD_INT 0
63270: PUSH
63271: LD_INT 1
63273: PUSH
63274: LD_INT 2
63276: PUSH
63277: LD_INT 3
63279: PUSH
63280: LD_INT 4
63282: PUSH
63283: LD_INT 5
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: LIST
63290: LIST
63291: LIST
63292: LIST
63293: IN
63294: NOT
63295: OR
63296: PUSH
63297: LD_VAR 0 3
63301: PPUSH
63302: LD_VAR 0 4
63306: PPUSH
63307: CALL_OW 488
63311: NOT
63312: OR
63313: IFFALSE 63317
// exit ;
63315: GO 64034
// pom := GetBase ( depot ) ;
63317: LD_ADDR_VAR 0 10
63321: PUSH
63322: LD_VAR 0 1
63326: PPUSH
63327: CALL_OW 274
63331: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63332: LD_ADDR_VAR 0 11
63336: PUSH
63337: LD_VAR 0 2
63341: PPUSH
63342: LD_VAR 0 1
63346: PPUSH
63347: CALL_OW 248
63351: PPUSH
63352: CALL_OW 450
63356: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63357: LD_VAR 0 10
63361: PPUSH
63362: LD_INT 1
63364: PPUSH
63365: CALL_OW 275
63369: PUSH
63370: LD_VAR 0 11
63374: PUSH
63375: LD_INT 1
63377: ARRAY
63378: GREATEREQUAL
63379: PUSH
63380: LD_VAR 0 10
63384: PPUSH
63385: LD_INT 2
63387: PPUSH
63388: CALL_OW 275
63392: PUSH
63393: LD_VAR 0 11
63397: PUSH
63398: LD_INT 2
63400: ARRAY
63401: GREATEREQUAL
63402: AND
63403: PUSH
63404: LD_VAR 0 10
63408: PPUSH
63409: LD_INT 3
63411: PPUSH
63412: CALL_OW 275
63416: PUSH
63417: LD_VAR 0 11
63421: PUSH
63422: LD_INT 3
63424: ARRAY
63425: GREATEREQUAL
63426: AND
63427: NOT
63428: IFFALSE 63432
// exit ;
63430: GO 64034
// if GetBType ( depot ) = b_depot then
63432: LD_VAR 0 1
63436: PPUSH
63437: CALL_OW 266
63441: PUSH
63442: LD_INT 0
63444: EQUAL
63445: IFFALSE 63457
// dist := 28 else
63447: LD_ADDR_VAR 0 14
63451: PUSH
63452: LD_INT 28
63454: ST_TO_ADDR
63455: GO 63465
// dist := 36 ;
63457: LD_ADDR_VAR 0 14
63461: PUSH
63462: LD_INT 36
63464: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63465: LD_VAR 0 1
63469: PPUSH
63470: LD_VAR 0 3
63474: PPUSH
63475: LD_VAR 0 4
63479: PPUSH
63480: CALL_OW 297
63484: PUSH
63485: LD_VAR 0 14
63489: GREATER
63490: IFFALSE 63494
// exit ;
63492: GO 64034
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63494: LD_ADDR_VAR 0 12
63498: PUSH
63499: LD_VAR 0 2
63503: PPUSH
63504: LD_VAR 0 3
63508: PPUSH
63509: LD_VAR 0 4
63513: PPUSH
63514: LD_VAR 0 5
63518: PPUSH
63519: LD_VAR 0 1
63523: PPUSH
63524: CALL_OW 248
63528: PPUSH
63529: LD_INT 0
63531: PPUSH
63532: CALL 64039 0 6
63536: ST_TO_ADDR
// if not hexes then
63537: LD_VAR 0 12
63541: NOT
63542: IFFALSE 63546
// exit ;
63544: GO 64034
// hex := GetHexInfo ( x , y ) ;
63546: LD_ADDR_VAR 0 15
63550: PUSH
63551: LD_VAR 0 3
63555: PPUSH
63556: LD_VAR 0 4
63560: PPUSH
63561: CALL_OW 546
63565: ST_TO_ADDR
// if hex [ 1 ] then
63566: LD_VAR 0 15
63570: PUSH
63571: LD_INT 1
63573: ARRAY
63574: IFFALSE 63578
// exit ;
63576: GO 64034
// height := hex [ 2 ] ;
63578: LD_ADDR_VAR 0 13
63582: PUSH
63583: LD_VAR 0 15
63587: PUSH
63588: LD_INT 2
63590: ARRAY
63591: ST_TO_ADDR
// for i = 1 to hexes do
63592: LD_ADDR_VAR 0 7
63596: PUSH
63597: DOUBLE
63598: LD_INT 1
63600: DEC
63601: ST_TO_ADDR
63602: LD_VAR 0 12
63606: PUSH
63607: FOR_TO
63608: IFFALSE 63938
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63610: LD_VAR 0 12
63614: PUSH
63615: LD_VAR 0 7
63619: ARRAY
63620: PUSH
63621: LD_INT 1
63623: ARRAY
63624: PPUSH
63625: LD_VAR 0 12
63629: PUSH
63630: LD_VAR 0 7
63634: ARRAY
63635: PUSH
63636: LD_INT 2
63638: ARRAY
63639: PPUSH
63640: CALL_OW 488
63644: NOT
63645: PUSH
63646: LD_VAR 0 12
63650: PUSH
63651: LD_VAR 0 7
63655: ARRAY
63656: PUSH
63657: LD_INT 1
63659: ARRAY
63660: PPUSH
63661: LD_VAR 0 12
63665: PUSH
63666: LD_VAR 0 7
63670: ARRAY
63671: PUSH
63672: LD_INT 2
63674: ARRAY
63675: PPUSH
63676: CALL_OW 428
63680: PUSH
63681: LD_INT 0
63683: GREATER
63684: OR
63685: PUSH
63686: LD_VAR 0 12
63690: PUSH
63691: LD_VAR 0 7
63695: ARRAY
63696: PUSH
63697: LD_INT 1
63699: ARRAY
63700: PPUSH
63701: LD_VAR 0 12
63705: PUSH
63706: LD_VAR 0 7
63710: ARRAY
63711: PUSH
63712: LD_INT 2
63714: ARRAY
63715: PPUSH
63716: CALL_OW 351
63720: OR
63721: IFFALSE 63727
// exit ;
63723: POP
63724: POP
63725: GO 64034
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63727: LD_ADDR_VAR 0 8
63731: PUSH
63732: LD_VAR 0 12
63736: PUSH
63737: LD_VAR 0 7
63741: ARRAY
63742: PUSH
63743: LD_INT 1
63745: ARRAY
63746: PPUSH
63747: LD_VAR 0 12
63751: PUSH
63752: LD_VAR 0 7
63756: ARRAY
63757: PUSH
63758: LD_INT 2
63760: ARRAY
63761: PPUSH
63762: CALL_OW 546
63766: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63767: LD_VAR 0 8
63771: PUSH
63772: LD_INT 1
63774: ARRAY
63775: PUSH
63776: LD_VAR 0 8
63780: PUSH
63781: LD_INT 2
63783: ARRAY
63784: PUSH
63785: LD_VAR 0 13
63789: PUSH
63790: LD_INT 2
63792: PLUS
63793: GREATER
63794: OR
63795: PUSH
63796: LD_VAR 0 8
63800: PUSH
63801: LD_INT 2
63803: ARRAY
63804: PUSH
63805: LD_VAR 0 13
63809: PUSH
63810: LD_INT 2
63812: MINUS
63813: LESS
63814: OR
63815: PUSH
63816: LD_VAR 0 8
63820: PUSH
63821: LD_INT 3
63823: ARRAY
63824: PUSH
63825: LD_INT 0
63827: PUSH
63828: LD_INT 8
63830: PUSH
63831: LD_INT 9
63833: PUSH
63834: LD_INT 10
63836: PUSH
63837: LD_INT 11
63839: PUSH
63840: LD_INT 12
63842: PUSH
63843: LD_INT 13
63845: PUSH
63846: LD_INT 16
63848: PUSH
63849: LD_INT 17
63851: PUSH
63852: LD_INT 18
63854: PUSH
63855: LD_INT 19
63857: PUSH
63858: LD_INT 20
63860: PUSH
63861: LD_INT 21
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: IN
63879: NOT
63880: OR
63881: PUSH
63882: LD_VAR 0 8
63886: PUSH
63887: LD_INT 5
63889: ARRAY
63890: NOT
63891: OR
63892: PUSH
63893: LD_VAR 0 8
63897: PUSH
63898: LD_INT 6
63900: ARRAY
63901: PUSH
63902: LD_INT 1
63904: PUSH
63905: LD_INT 2
63907: PUSH
63908: LD_INT 7
63910: PUSH
63911: LD_INT 9
63913: PUSH
63914: LD_INT 10
63916: PUSH
63917: LD_INT 11
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: IN
63928: NOT
63929: OR
63930: IFFALSE 63936
// exit ;
63932: POP
63933: POP
63934: GO 64034
// end ;
63936: GO 63607
63938: POP
63939: POP
// side := GetSide ( depot ) ;
63940: LD_ADDR_VAR 0 9
63944: PUSH
63945: LD_VAR 0 1
63949: PPUSH
63950: CALL_OW 255
63954: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63955: LD_VAR 0 9
63959: PPUSH
63960: LD_VAR 0 3
63964: PPUSH
63965: LD_VAR 0 4
63969: PPUSH
63970: LD_INT 20
63972: PPUSH
63973: CALL 56688 0 4
63977: PUSH
63978: LD_INT 4
63980: ARRAY
63981: IFFALSE 63985
// exit ;
63983: GO 64034
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63985: LD_VAR 0 2
63989: PUSH
63990: LD_INT 29
63992: PUSH
63993: LD_INT 30
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: IN
64000: PUSH
64001: LD_VAR 0 3
64005: PPUSH
64006: LD_VAR 0 4
64010: PPUSH
64011: LD_VAR 0 9
64015: PPUSH
64016: CALL_OW 440
64020: NOT
64021: AND
64022: IFFALSE 64026
// exit ;
64024: GO 64034
// result := true ;
64026: LD_ADDR_VAR 0 6
64030: PUSH
64031: LD_INT 1
64033: ST_TO_ADDR
// end ;
64034: LD_VAR 0 6
64038: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
64039: LD_INT 0
64041: PPUSH
64042: PPUSH
64043: PPUSH
64044: PPUSH
64045: PPUSH
64046: PPUSH
64047: PPUSH
64048: PPUSH
64049: PPUSH
64050: PPUSH
64051: PPUSH
64052: PPUSH
64053: PPUSH
64054: PPUSH
64055: PPUSH
64056: PPUSH
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
64061: PPUSH
64062: PPUSH
64063: PPUSH
64064: PPUSH
64065: PPUSH
64066: PPUSH
64067: PPUSH
64068: PPUSH
64069: PPUSH
64070: PPUSH
64071: PPUSH
64072: PPUSH
64073: PPUSH
64074: PPUSH
64075: PPUSH
64076: PPUSH
64077: PPUSH
64078: PPUSH
64079: PPUSH
64080: PPUSH
64081: PPUSH
64082: PPUSH
64083: PPUSH
64084: PPUSH
64085: PPUSH
64086: PPUSH
64087: PPUSH
64088: PPUSH
64089: PPUSH
64090: PPUSH
64091: PPUSH
64092: PPUSH
64093: PPUSH
64094: PPUSH
64095: PPUSH
64096: PPUSH
64097: PPUSH
64098: PPUSH
// result = [ ] ;
64099: LD_ADDR_VAR 0 7
64103: PUSH
64104: EMPTY
64105: ST_TO_ADDR
// temp_list = [ ] ;
64106: LD_ADDR_VAR 0 9
64110: PUSH
64111: EMPTY
64112: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64113: LD_VAR 0 4
64117: PUSH
64118: LD_INT 0
64120: PUSH
64121: LD_INT 1
64123: PUSH
64124: LD_INT 2
64126: PUSH
64127: LD_INT 3
64129: PUSH
64130: LD_INT 4
64132: PUSH
64133: LD_INT 5
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: IN
64144: NOT
64145: PUSH
64146: LD_VAR 0 1
64150: PUSH
64151: LD_INT 0
64153: PUSH
64154: LD_INT 1
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: IN
64161: PUSH
64162: LD_VAR 0 5
64166: PUSH
64167: LD_INT 1
64169: PUSH
64170: LD_INT 2
64172: PUSH
64173: LD_INT 3
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: LIST
64180: IN
64181: NOT
64182: AND
64183: OR
64184: IFFALSE 64188
// exit ;
64186: GO 82579
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64188: LD_VAR 0 1
64192: PUSH
64193: LD_INT 6
64195: PUSH
64196: LD_INT 7
64198: PUSH
64199: LD_INT 8
64201: PUSH
64202: LD_INT 13
64204: PUSH
64205: LD_INT 12
64207: PUSH
64208: LD_INT 15
64210: PUSH
64211: LD_INT 11
64213: PUSH
64214: LD_INT 14
64216: PUSH
64217: LD_INT 10
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: IN
64231: IFFALSE 64241
// btype = b_lab ;
64233: LD_ADDR_VAR 0 1
64237: PUSH
64238: LD_INT 6
64240: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64241: LD_VAR 0 6
64245: PUSH
64246: LD_INT 0
64248: PUSH
64249: LD_INT 1
64251: PUSH
64252: LD_INT 2
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: LIST
64259: IN
64260: NOT
64261: PUSH
64262: LD_VAR 0 1
64266: PUSH
64267: LD_INT 0
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: LD_INT 2
64275: PUSH
64276: LD_INT 3
64278: PUSH
64279: LD_INT 6
64281: PUSH
64282: LD_INT 36
64284: PUSH
64285: LD_INT 4
64287: PUSH
64288: LD_INT 5
64290: PUSH
64291: LD_INT 31
64293: PUSH
64294: LD_INT 32
64296: PUSH
64297: LD_INT 33
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: IN
64313: NOT
64314: PUSH
64315: LD_VAR 0 6
64319: PUSH
64320: LD_INT 1
64322: EQUAL
64323: AND
64324: OR
64325: PUSH
64326: LD_VAR 0 1
64330: PUSH
64331: LD_INT 2
64333: PUSH
64334: LD_INT 3
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: IN
64341: NOT
64342: PUSH
64343: LD_VAR 0 6
64347: PUSH
64348: LD_INT 2
64350: EQUAL
64351: AND
64352: OR
64353: IFFALSE 64363
// mode = 0 ;
64355: LD_ADDR_VAR 0 6
64359: PUSH
64360: LD_INT 0
64362: ST_TO_ADDR
// case mode of 0 :
64363: LD_VAR 0 6
64367: PUSH
64368: LD_INT 0
64370: DOUBLE
64371: EQUAL
64372: IFTRUE 64376
64374: GO 75829
64376: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64377: LD_ADDR_VAR 0 11
64381: PUSH
64382: LD_INT 0
64384: PUSH
64385: LD_INT 0
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 0
64394: PUSH
64395: LD_INT 1
64397: NEG
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: LD_INT 1
64405: PUSH
64406: LD_INT 0
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: LD_INT 1
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 0
64425: PUSH
64426: LD_INT 1
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 1
64435: NEG
64436: PUSH
64437: LD_INT 0
64439: PUSH
64440: EMPTY
64441: LIST
64442: LIST
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: LD_INT 1
64450: NEG
64451: PUSH
64452: EMPTY
64453: LIST
64454: LIST
64455: PUSH
64456: LD_INT 1
64458: NEG
64459: PUSH
64460: LD_INT 2
64462: NEG
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: PUSH
64468: LD_INT 0
64470: PUSH
64471: LD_INT 2
64473: NEG
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: PUSH
64479: LD_INT 1
64481: PUSH
64482: LD_INT 1
64484: NEG
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: LD_INT 2
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: PUSH
64500: LD_INT 0
64502: PUSH
64503: LD_INT 2
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: LD_INT 1
64512: NEG
64513: PUSH
64514: LD_INT 1
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: PUSH
64521: LD_INT 1
64523: PUSH
64524: LD_INT 3
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 0
64533: PUSH
64534: LD_INT 3
64536: PUSH
64537: EMPTY
64538: LIST
64539: LIST
64540: PUSH
64541: LD_INT 1
64543: NEG
64544: PUSH
64545: LD_INT 2
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: PUSH
64552: EMPTY
64553: LIST
64554: LIST
64555: LIST
64556: LIST
64557: LIST
64558: LIST
64559: LIST
64560: LIST
64561: LIST
64562: LIST
64563: LIST
64564: LIST
64565: LIST
64566: LIST
64567: LIST
64568: LIST
64569: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64570: LD_ADDR_VAR 0 12
64574: PUSH
64575: LD_INT 0
64577: PUSH
64578: LD_INT 0
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 0
64587: PUSH
64588: LD_INT 1
64590: NEG
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 1
64598: PUSH
64599: LD_INT 0
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: PUSH
64606: LD_INT 1
64608: PUSH
64609: LD_INT 1
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 0
64618: PUSH
64619: LD_INT 1
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: PUSH
64626: LD_INT 1
64628: NEG
64629: PUSH
64630: LD_INT 0
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 1
64639: NEG
64640: PUSH
64641: LD_INT 1
64643: NEG
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 1
64651: PUSH
64652: LD_INT 1
64654: NEG
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: LD_INT 2
64662: PUSH
64663: LD_INT 0
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 2
64672: PUSH
64673: LD_INT 1
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 1
64682: NEG
64683: PUSH
64684: LD_INT 1
64686: PUSH
64687: EMPTY
64688: LIST
64689: LIST
64690: PUSH
64691: LD_INT 2
64693: NEG
64694: PUSH
64695: LD_INT 0
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: PUSH
64702: LD_INT 2
64704: NEG
64705: PUSH
64706: LD_INT 1
64708: NEG
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: PUSH
64714: LD_INT 2
64716: NEG
64717: PUSH
64718: LD_INT 1
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 3
64727: NEG
64728: PUSH
64729: LD_INT 0
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 3
64738: NEG
64739: PUSH
64740: LD_INT 1
64742: NEG
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64766: LD_ADDR_VAR 0 13
64770: PUSH
64771: LD_INT 0
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 0
64783: PUSH
64784: LD_INT 1
64786: NEG
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 1
64794: PUSH
64795: LD_INT 0
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: PUSH
64802: LD_INT 1
64804: PUSH
64805: LD_INT 1
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: LD_INT 1
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: PUSH
64822: LD_INT 1
64824: NEG
64825: PUSH
64826: LD_INT 0
64828: PUSH
64829: EMPTY
64830: LIST
64831: LIST
64832: PUSH
64833: LD_INT 1
64835: NEG
64836: PUSH
64837: LD_INT 1
64839: NEG
64840: PUSH
64841: EMPTY
64842: LIST
64843: LIST
64844: PUSH
64845: LD_INT 1
64847: NEG
64848: PUSH
64849: LD_INT 2
64851: NEG
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PUSH
64857: LD_INT 2
64859: PUSH
64860: LD_INT 1
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 2
64869: PUSH
64870: LD_INT 2
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: LD_INT 1
64879: PUSH
64880: LD_INT 2
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 2
64889: NEG
64890: PUSH
64891: LD_INT 1
64893: NEG
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 2
64901: NEG
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 2
64913: NEG
64914: PUSH
64915: LD_INT 3
64917: NEG
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 3
64925: NEG
64926: PUSH
64927: LD_INT 2
64929: NEG
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: LD_INT 3
64937: NEG
64938: PUSH
64939: LD_INT 3
64941: NEG
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: LIST
64951: LIST
64952: LIST
64953: LIST
64954: LIST
64955: LIST
64956: LIST
64957: LIST
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: LIST
64963: LIST
64964: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64965: LD_ADDR_VAR 0 14
64969: PUSH
64970: LD_INT 0
64972: PUSH
64973: LD_INT 0
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 0
64982: PUSH
64983: LD_INT 1
64985: NEG
64986: PUSH
64987: EMPTY
64988: LIST
64989: LIST
64990: PUSH
64991: LD_INT 1
64993: PUSH
64994: LD_INT 0
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PUSH
65001: LD_INT 1
65003: PUSH
65004: LD_INT 1
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 0
65013: PUSH
65014: LD_INT 1
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 1
65023: NEG
65024: PUSH
65025: LD_INT 0
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PUSH
65032: LD_INT 1
65034: NEG
65035: PUSH
65036: LD_INT 1
65038: NEG
65039: PUSH
65040: EMPTY
65041: LIST
65042: LIST
65043: PUSH
65044: LD_INT 1
65046: NEG
65047: PUSH
65048: LD_INT 2
65050: NEG
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 0
65058: PUSH
65059: LD_INT 2
65061: NEG
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 1
65069: PUSH
65070: LD_INT 1
65072: NEG
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 1
65080: PUSH
65081: LD_INT 2
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 0
65090: PUSH
65091: LD_INT 2
65093: PUSH
65094: EMPTY
65095: LIST
65096: LIST
65097: PUSH
65098: LD_INT 1
65100: NEG
65101: PUSH
65102: LD_INT 1
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: LD_INT 1
65111: NEG
65112: PUSH
65113: LD_INT 3
65115: NEG
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 0
65123: PUSH
65124: LD_INT 3
65126: NEG
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 1
65134: PUSH
65135: LD_INT 2
65137: NEG
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65161: LD_ADDR_VAR 0 15
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 0
65178: PUSH
65179: LD_INT 1
65181: NEG
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 1
65189: PUSH
65190: LD_INT 0
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 1
65199: PUSH
65200: LD_INT 1
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 0
65209: PUSH
65210: LD_INT 1
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PUSH
65217: LD_INT 1
65219: NEG
65220: PUSH
65221: LD_INT 0
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: LD_INT 1
65230: NEG
65231: PUSH
65232: LD_INT 1
65234: NEG
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 1
65242: PUSH
65243: LD_INT 1
65245: NEG
65246: PUSH
65247: EMPTY
65248: LIST
65249: LIST
65250: PUSH
65251: LD_INT 2
65253: PUSH
65254: LD_INT 0
65256: PUSH
65257: EMPTY
65258: LIST
65259: LIST
65260: PUSH
65261: LD_INT 2
65263: PUSH
65264: LD_INT 1
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: PUSH
65271: LD_INT 1
65273: NEG
65274: PUSH
65275: LD_INT 1
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 2
65284: NEG
65285: PUSH
65286: LD_INT 0
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 2
65295: NEG
65296: PUSH
65297: LD_INT 1
65299: NEG
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PUSH
65305: LD_INT 2
65307: PUSH
65308: LD_INT 1
65310: NEG
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: PUSH
65316: LD_INT 3
65318: PUSH
65319: LD_INT 0
65321: PUSH
65322: EMPTY
65323: LIST
65324: LIST
65325: PUSH
65326: LD_INT 3
65328: PUSH
65329: LD_INT 1
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65354: LD_ADDR_VAR 0 16
65358: PUSH
65359: LD_INT 0
65361: PUSH
65362: LD_INT 0
65364: PUSH
65365: EMPTY
65366: LIST
65367: LIST
65368: PUSH
65369: LD_INT 0
65371: PUSH
65372: LD_INT 1
65374: NEG
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 1
65382: PUSH
65383: LD_INT 0
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: LD_INT 1
65392: PUSH
65393: LD_INT 1
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: LD_INT 1
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 1
65412: NEG
65413: PUSH
65414: LD_INT 0
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: PUSH
65421: LD_INT 1
65423: NEG
65424: PUSH
65425: LD_INT 1
65427: NEG
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 1
65435: NEG
65436: PUSH
65437: LD_INT 2
65439: NEG
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: PUSH
65445: LD_INT 2
65447: PUSH
65448: LD_INT 1
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 2
65457: PUSH
65458: LD_INT 2
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PUSH
65465: LD_INT 1
65467: PUSH
65468: LD_INT 2
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 2
65477: NEG
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 2
65489: NEG
65490: PUSH
65491: LD_INT 2
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 3
65501: PUSH
65502: LD_INT 2
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 3
65511: PUSH
65512: LD_INT 3
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 3
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65547: LD_ADDR_VAR 0 17
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: LD_INT 0
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 0
65564: PUSH
65565: LD_INT 1
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 1
65575: PUSH
65576: LD_INT 0
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 1
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 0
65595: PUSH
65596: LD_INT 1
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 1
65605: NEG
65606: PUSH
65607: LD_INT 0
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: LD_INT 1
65616: NEG
65617: PUSH
65618: LD_INT 1
65620: NEG
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 1
65628: NEG
65629: PUSH
65630: LD_INT 2
65632: NEG
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: LD_INT 2
65643: NEG
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 1
65651: PUSH
65652: LD_INT 1
65654: NEG
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 2
65662: PUSH
65663: LD_INT 0
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 2
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 2
65682: PUSH
65683: LD_INT 2
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: PUSH
65693: LD_INT 2
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: LD_INT 0
65702: PUSH
65703: LD_INT 2
65705: PUSH
65706: EMPTY
65707: LIST
65708: LIST
65709: PUSH
65710: LD_INT 1
65712: NEG
65713: PUSH
65714: LD_INT 1
65716: PUSH
65717: EMPTY
65718: LIST
65719: LIST
65720: PUSH
65721: LD_INT 2
65723: NEG
65724: PUSH
65725: LD_INT 0
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 2
65734: NEG
65735: PUSH
65736: LD_INT 1
65738: NEG
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PUSH
65744: LD_INT 2
65746: NEG
65747: PUSH
65748: LD_INT 2
65750: NEG
65751: PUSH
65752: EMPTY
65753: LIST
65754: LIST
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: LIST
65763: LIST
65764: LIST
65765: LIST
65766: LIST
65767: LIST
65768: LIST
65769: LIST
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65777: LD_ADDR_VAR 0 18
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 0
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 0
65794: PUSH
65795: LD_INT 1
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 1
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 1
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 0
65825: PUSH
65826: LD_INT 1
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 1
65835: NEG
65836: PUSH
65837: LD_INT 0
65839: PUSH
65840: EMPTY
65841: LIST
65842: LIST
65843: PUSH
65844: LD_INT 1
65846: NEG
65847: PUSH
65848: LD_INT 1
65850: NEG
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 1
65858: NEG
65859: PUSH
65860: LD_INT 2
65862: NEG
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: PUSH
65868: LD_INT 0
65870: PUSH
65871: LD_INT 2
65873: NEG
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: PUSH
65879: LD_INT 1
65881: PUSH
65882: LD_INT 1
65884: NEG
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 2
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 2
65902: PUSH
65903: LD_INT 1
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: LD_INT 2
65912: PUSH
65913: LD_INT 2
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 1
65922: PUSH
65923: LD_INT 2
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: PUSH
65930: LD_INT 0
65932: PUSH
65933: LD_INT 2
65935: PUSH
65936: EMPTY
65937: LIST
65938: LIST
65939: PUSH
65940: LD_INT 1
65942: NEG
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: EMPTY
65948: LIST
65949: LIST
65950: PUSH
65951: LD_INT 2
65953: NEG
65954: PUSH
65955: LD_INT 0
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 2
65964: NEG
65965: PUSH
65966: LD_INT 1
65968: NEG
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 2
65976: NEG
65977: PUSH
65978: LD_INT 2
65980: NEG
65981: PUSH
65982: EMPTY
65983: LIST
65984: LIST
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66007: LD_ADDR_VAR 0 19
66011: PUSH
66012: LD_INT 0
66014: PUSH
66015: LD_INT 0
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 0
66024: PUSH
66025: LD_INT 1
66027: NEG
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 1
66035: PUSH
66036: LD_INT 0
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: LD_INT 1
66045: PUSH
66046: LD_INT 1
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: LD_INT 1
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PUSH
66063: LD_INT 1
66065: NEG
66066: PUSH
66067: LD_INT 0
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: PUSH
66074: LD_INT 1
66076: NEG
66077: PUSH
66078: LD_INT 1
66080: NEG
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 1
66088: NEG
66089: PUSH
66090: LD_INT 2
66092: NEG
66093: PUSH
66094: EMPTY
66095: LIST
66096: LIST
66097: PUSH
66098: LD_INT 0
66100: PUSH
66101: LD_INT 2
66103: NEG
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 1
66111: PUSH
66112: LD_INT 1
66114: NEG
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: LD_INT 0
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 2
66132: PUSH
66133: LD_INT 1
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: LD_INT 2
66142: PUSH
66143: LD_INT 2
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 1
66152: PUSH
66153: LD_INT 2
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: LD_INT 0
66162: PUSH
66163: LD_INT 2
66165: PUSH
66166: EMPTY
66167: LIST
66168: LIST
66169: PUSH
66170: LD_INT 1
66172: NEG
66173: PUSH
66174: LD_INT 1
66176: PUSH
66177: EMPTY
66178: LIST
66179: LIST
66180: PUSH
66181: LD_INT 2
66183: NEG
66184: PUSH
66185: LD_INT 0
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 2
66194: NEG
66195: PUSH
66196: LD_INT 1
66198: NEG
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 2
66206: NEG
66207: PUSH
66208: LD_INT 2
66210: NEG
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66237: LD_ADDR_VAR 0 20
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: LD_INT 0
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: LD_INT 0
66254: PUSH
66255: LD_INT 1
66257: NEG
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: LD_INT 0
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: PUSH
66276: LD_INT 1
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: PUSH
66283: LD_INT 0
66285: PUSH
66286: LD_INT 1
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: LD_INT 0
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 1
66306: NEG
66307: PUSH
66308: LD_INT 1
66310: NEG
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: NEG
66319: PUSH
66320: LD_INT 2
66322: NEG
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 0
66330: PUSH
66331: LD_INT 2
66333: NEG
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 1
66341: PUSH
66342: LD_INT 1
66344: NEG
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 2
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: LD_INT 2
66362: PUSH
66363: LD_INT 1
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 2
66372: PUSH
66373: LD_INT 2
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: LD_INT 2
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 2
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 2
66424: NEG
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: NEG
66437: PUSH
66438: LD_INT 2
66440: NEG
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66467: LD_ADDR_VAR 0 21
66471: PUSH
66472: LD_INT 0
66474: PUSH
66475: LD_INT 0
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 0
66484: PUSH
66485: LD_INT 1
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 1
66495: PUSH
66496: LD_INT 0
66498: PUSH
66499: EMPTY
66500: LIST
66501: LIST
66502: PUSH
66503: LD_INT 1
66505: PUSH
66506: LD_INT 1
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: LD_INT 1
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: NEG
66537: PUSH
66538: LD_INT 1
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: LD_INT 2
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: LD_INT 2
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 1
66571: PUSH
66572: LD_INT 1
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 2
66582: PUSH
66583: LD_INT 0
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 2
66592: PUSH
66593: LD_INT 1
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 2
66602: PUSH
66603: LD_INT 2
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: LD_INT 1
66612: PUSH
66613: LD_INT 2
66615: PUSH
66616: EMPTY
66617: LIST
66618: LIST
66619: PUSH
66620: LD_INT 0
66622: PUSH
66623: LD_INT 2
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 1
66632: NEG
66633: PUSH
66634: LD_INT 1
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: NEG
66644: PUSH
66645: LD_INT 0
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PUSH
66652: LD_INT 2
66654: NEG
66655: PUSH
66656: LD_INT 1
66658: NEG
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 2
66666: NEG
66667: PUSH
66668: LD_INT 2
66670: NEG
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66697: LD_ADDR_VAR 0 22
66701: PUSH
66702: LD_INT 0
66704: PUSH
66705: LD_INT 0
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 0
66714: PUSH
66715: LD_INT 1
66717: NEG
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 1
66725: PUSH
66726: LD_INT 0
66728: PUSH
66729: EMPTY
66730: LIST
66731: LIST
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: LD_INT 1
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 0
66745: PUSH
66746: LD_INT 1
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 1
66755: NEG
66756: PUSH
66757: LD_INT 0
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: NEG
66767: PUSH
66768: LD_INT 1
66770: NEG
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 1
66778: NEG
66779: PUSH
66780: LD_INT 2
66782: NEG
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 0
66790: PUSH
66791: LD_INT 2
66793: NEG
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 1
66801: PUSH
66802: LD_INT 1
66804: NEG
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 2
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 2
66822: PUSH
66823: LD_INT 1
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 2
66832: PUSH
66833: LD_INT 2
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: LD_INT 1
66842: PUSH
66843: LD_INT 2
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 0
66852: PUSH
66853: LD_INT 2
66855: PUSH
66856: EMPTY
66857: LIST
66858: LIST
66859: PUSH
66860: LD_INT 1
66862: NEG
66863: PUSH
66864: LD_INT 1
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 2
66873: NEG
66874: PUSH
66875: LD_INT 0
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 2
66884: NEG
66885: PUSH
66886: LD_INT 1
66888: NEG
66889: PUSH
66890: EMPTY
66891: LIST
66892: LIST
66893: PUSH
66894: LD_INT 2
66896: NEG
66897: PUSH
66898: LD_INT 2
66900: NEG
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66927: LD_ADDR_VAR 0 23
66931: PUSH
66932: LD_INT 0
66934: PUSH
66935: LD_INT 0
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: LD_INT 1
66947: NEG
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 1
66955: PUSH
66956: LD_INT 0
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: LD_INT 1
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: LD_INT 1
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 1
66996: NEG
66997: PUSH
66998: LD_INT 1
67000: NEG
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 1
67008: NEG
67009: PUSH
67010: LD_INT 2
67012: NEG
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 0
67020: PUSH
67021: LD_INT 2
67023: NEG
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: LD_INT 1
67031: PUSH
67032: LD_INT 1
67034: NEG
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 2
67042: PUSH
67043: LD_INT 0
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: LD_INT 1
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: LD_INT 2
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 1
67072: PUSH
67073: LD_INT 2
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 1
67092: NEG
67093: PUSH
67094: LD_INT 1
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 2
67103: NEG
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 2
67114: NEG
67115: PUSH
67116: LD_INT 1
67118: NEG
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PUSH
67124: LD_INT 2
67126: NEG
67127: PUSH
67128: LD_INT 2
67130: NEG
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 2
67138: NEG
67139: PUSH
67140: LD_INT 3
67142: NEG
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 1
67150: NEG
67151: PUSH
67152: LD_INT 3
67154: NEG
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: PUSH
67163: LD_INT 2
67165: NEG
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 2
67173: PUSH
67174: LD_INT 1
67176: NEG
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67207: LD_ADDR_VAR 0 24
67211: PUSH
67212: LD_INT 0
67214: PUSH
67215: LD_INT 0
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 0
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: LD_INT 0
67238: PUSH
67239: EMPTY
67240: LIST
67241: LIST
67242: PUSH
67243: LD_INT 1
67245: PUSH
67246: LD_INT 1
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 0
67255: PUSH
67256: LD_INT 1
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 1
67265: NEG
67266: PUSH
67267: LD_INT 0
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: PUSH
67274: LD_INT 1
67276: NEG
67277: PUSH
67278: LD_INT 1
67280: NEG
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 1
67288: NEG
67289: PUSH
67290: LD_INT 2
67292: NEG
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: LD_INT 2
67303: NEG
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 1
67311: PUSH
67312: LD_INT 1
67314: NEG
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 2
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 2
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: PUSH
67343: LD_INT 2
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 1
67352: PUSH
67353: LD_INT 2
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: LD_INT 2
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 1
67372: NEG
67373: PUSH
67374: LD_INT 1
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 2
67383: NEG
67384: PUSH
67385: LD_INT 0
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 2
67394: NEG
67395: PUSH
67396: LD_INT 1
67398: NEG
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 2
67406: NEG
67407: PUSH
67408: LD_INT 2
67410: NEG
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 1
67418: PUSH
67419: LD_INT 2
67421: NEG
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 2
67429: PUSH
67430: LD_INT 1
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 3
67440: PUSH
67441: LD_INT 1
67443: PUSH
67444: EMPTY
67445: LIST
67446: LIST
67447: PUSH
67448: LD_INT 3
67450: PUSH
67451: LD_INT 2
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67483: LD_ADDR_VAR 0 25
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: LD_INT 0
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 0
67500: PUSH
67501: LD_INT 1
67503: NEG
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 1
67511: PUSH
67512: LD_INT 0
67514: PUSH
67515: EMPTY
67516: LIST
67517: LIST
67518: PUSH
67519: LD_INT 1
67521: PUSH
67522: LD_INT 1
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 0
67531: PUSH
67532: LD_INT 1
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 1
67541: NEG
67542: PUSH
67543: LD_INT 0
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 1
67552: NEG
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: LD_INT 2
67568: NEG
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: LD_INT 2
67579: NEG
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: PUSH
67588: LD_INT 1
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 2
67598: PUSH
67599: LD_INT 0
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 2
67608: PUSH
67609: LD_INT 1
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 2
67618: PUSH
67619: LD_INT 2
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: PUSH
67626: LD_INT 1
67628: PUSH
67629: LD_INT 2
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: LD_INT 2
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: LD_INT 1
67648: NEG
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 2
67659: NEG
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 2
67670: NEG
67671: PUSH
67672: LD_INT 1
67674: NEG
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 2
67682: NEG
67683: PUSH
67684: LD_INT 2
67686: NEG
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 3
67694: PUSH
67695: LD_INT 1
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 3
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 2
67714: PUSH
67715: LD_INT 3
67717: PUSH
67718: EMPTY
67719: LIST
67720: LIST
67721: PUSH
67722: LD_INT 1
67724: PUSH
67725: LD_INT 3
67727: PUSH
67728: EMPTY
67729: LIST
67730: LIST
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: LIST
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67757: LD_ADDR_VAR 0 26
67761: PUSH
67762: LD_INT 0
67764: PUSH
67765: LD_INT 0
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: LD_INT 1
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: LD_INT 1
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 1
67815: NEG
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: NEG
67827: PUSH
67828: LD_INT 1
67830: NEG
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 1
67838: NEG
67839: PUSH
67840: LD_INT 2
67842: NEG
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 0
67850: PUSH
67851: LD_INT 2
67853: NEG
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 1
67861: PUSH
67862: LD_INT 1
67864: NEG
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 2
67872: PUSH
67873: LD_INT 0
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 2
67892: PUSH
67893: LD_INT 2
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: LD_INT 2
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: LD_INT 2
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 1
67922: NEG
67923: PUSH
67924: LD_INT 1
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 2
67933: NEG
67934: PUSH
67935: LD_INT 0
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: LD_INT 1
67948: NEG
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 2
67956: NEG
67957: PUSH
67958: LD_INT 2
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 2
67968: PUSH
67969: LD_INT 3
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: LD_INT 3
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 1
67988: NEG
67989: PUSH
67990: LD_INT 2
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 2
67999: NEG
68000: PUSH
68001: LD_INT 1
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: LIST
68012: LIST
68013: LIST
68014: LIST
68015: LIST
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: LIST
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68033: LD_ADDR_VAR 0 27
68037: PUSH
68038: LD_INT 0
68040: PUSH
68041: LD_INT 0
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: LD_INT 1
68053: NEG
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 1
68061: PUSH
68062: LD_INT 0
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 1
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 0
68081: PUSH
68082: LD_INT 1
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 1
68102: NEG
68103: PUSH
68104: LD_INT 1
68106: NEG
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 1
68114: NEG
68115: PUSH
68116: LD_INT 2
68118: NEG
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: LD_INT 2
68129: NEG
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: LD_INT 1
68140: NEG
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 2
68148: PUSH
68149: LD_INT 0
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 2
68158: PUSH
68159: LD_INT 1
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 2
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 1
68178: PUSH
68179: LD_INT 2
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: LD_INT 2
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: LD_INT 1
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 2
68209: NEG
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: NEG
68221: PUSH
68222: LD_INT 1
68224: NEG
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: LD_INT 2
68232: NEG
68233: PUSH
68234: LD_INT 2
68236: NEG
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: LD_INT 2
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 2
68255: NEG
68256: PUSH
68257: LD_INT 1
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 3
68266: NEG
68267: PUSH
68268: LD_INT 1
68270: NEG
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: PUSH
68276: LD_INT 3
68278: NEG
68279: PUSH
68280: LD_INT 2
68282: NEG
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68313: LD_ADDR_VAR 0 28
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 0
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 0
68330: PUSH
68331: LD_INT 1
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: LD_INT 0
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 0
68361: PUSH
68362: LD_INT 1
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PUSH
68369: LD_INT 1
68371: NEG
68372: PUSH
68373: LD_INT 0
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PUSH
68380: LD_INT 1
68382: NEG
68383: PUSH
68384: LD_INT 1
68386: NEG
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: LD_INT 2
68398: NEG
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 0
68406: PUSH
68407: LD_INT 2
68409: NEG
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 1
68417: PUSH
68418: LD_INT 1
68420: NEG
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 2
68428: PUSH
68429: LD_INT 0
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: LD_INT 1
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 2
68448: PUSH
68449: LD_INT 2
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: EMPTY
68463: LIST
68464: LIST
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: LD_INT 2
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: NEG
68479: PUSH
68480: LD_INT 1
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 2
68489: NEG
68490: PUSH
68491: LD_INT 0
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 2
68500: NEG
68501: PUSH
68502: LD_INT 1
68504: NEG
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 2
68512: NEG
68513: PUSH
68514: LD_INT 2
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 2
68524: NEG
68525: PUSH
68526: LD_INT 3
68528: NEG
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 1
68536: NEG
68537: PUSH
68538: LD_INT 3
68540: NEG
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 3
68548: NEG
68549: PUSH
68550: LD_INT 1
68552: NEG
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 3
68560: NEG
68561: PUSH
68562: LD_INT 2
68564: NEG
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68595: LD_ADDR_VAR 0 29
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 0
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 1
68623: PUSH
68624: LD_INT 0
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 1
68633: PUSH
68634: LD_INT 1
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 0
68643: PUSH
68644: LD_INT 1
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 1
68653: NEG
68654: PUSH
68655: LD_INT 0
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 1
68664: NEG
68665: PUSH
68666: LD_INT 1
68668: NEG
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 1
68676: NEG
68677: PUSH
68678: LD_INT 2
68680: NEG
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 0
68688: PUSH
68689: LD_INT 2
68691: NEG
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 1
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 2
68710: PUSH
68711: LD_INT 0
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 2
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: PUSH
68728: LD_INT 1
68730: PUSH
68731: LD_INT 2
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 0
68740: PUSH
68741: LD_INT 2
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 1
68750: NEG
68751: PUSH
68752: LD_INT 1
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 2
68761: NEG
68762: PUSH
68763: LD_INT 1
68765: NEG
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: LD_INT 2
68777: NEG
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: LD_INT 3
68789: NEG
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: PUSH
68798: LD_INT 1
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 3
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 1
68818: PUSH
68819: LD_INT 3
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 1
68828: NEG
68829: PUSH
68830: LD_INT 2
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 3
68839: NEG
68840: PUSH
68841: LD_INT 2
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68874: LD_ADDR_VAR 0 30
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: LD_INT 0
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: LD_INT 1
68894: NEG
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 1
68902: PUSH
68903: LD_INT 0
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 1
68912: PUSH
68913: LD_INT 1
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 0
68922: PUSH
68923: LD_INT 1
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 1
68932: NEG
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 1
68943: NEG
68944: PUSH
68945: LD_INT 1
68947: NEG
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: LD_INT 1
68955: NEG
68956: PUSH
68957: LD_INT 2
68959: NEG
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 1
68978: PUSH
68979: LD_INT 1
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 2
68989: PUSH
68990: LD_INT 0
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 2
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 2
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: LD_INT 2
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: NEG
69030: PUSH
69031: LD_INT 1
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: NEG
69041: PUSH
69042: LD_INT 0
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 2
69051: NEG
69052: PUSH
69053: LD_INT 1
69055: NEG
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: NEG
69064: PUSH
69065: LD_INT 3
69067: NEG
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: LD_INT 1
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 3
69086: PUSH
69087: LD_INT 2
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: LD_INT 3
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 2
69106: NEG
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 3
69117: NEG
69118: PUSH
69119: LD_INT 1
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69152: LD_ADDR_VAR 0 31
69156: PUSH
69157: LD_INT 0
69159: PUSH
69160: LD_INT 0
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: PUSH
69167: LD_INT 0
69169: PUSH
69170: LD_INT 1
69172: NEG
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PUSH
69178: LD_INT 1
69180: PUSH
69181: LD_INT 0
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 1
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 1
69210: NEG
69211: PUSH
69212: LD_INT 0
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: NEG
69222: PUSH
69223: LD_INT 1
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 1
69233: NEG
69234: PUSH
69235: LD_INT 2
69237: NEG
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 1
69245: PUSH
69246: LD_INT 1
69248: NEG
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 2
69256: PUSH
69257: LD_INT 0
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 2
69266: PUSH
69267: LD_INT 1
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 2
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: LD_INT 2
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 0
69296: PUSH
69297: LD_INT 2
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 1
69306: NEG
69307: PUSH
69308: LD_INT 1
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 2
69317: NEG
69318: PUSH
69319: LD_INT 1
69321: NEG
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 2
69329: NEG
69330: PUSH
69331: LD_INT 2
69333: NEG
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PUSH
69339: LD_INT 2
69341: NEG
69342: PUSH
69343: LD_INT 3
69345: NEG
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 2
69353: PUSH
69354: LD_INT 1
69356: NEG
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 3
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: PUSH
69375: LD_INT 3
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 1
69384: NEG
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 3
69395: NEG
69396: PUSH
69397: LD_INT 2
69399: NEG
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69430: LD_ADDR_VAR 0 32
69434: PUSH
69435: LD_INT 0
69437: PUSH
69438: LD_INT 0
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: LD_INT 1
69450: NEG
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 1
69458: PUSH
69459: LD_INT 0
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 1
69468: PUSH
69469: LD_INT 1
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 0
69478: PUSH
69479: LD_INT 1
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 1
69488: NEG
69489: PUSH
69490: LD_INT 0
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 1
69499: NEG
69500: PUSH
69501: LD_INT 1
69503: NEG
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 1
69511: NEG
69512: PUSH
69513: LD_INT 2
69515: NEG
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 0
69523: PUSH
69524: LD_INT 2
69526: NEG
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 1
69534: PUSH
69535: LD_INT 1
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 2
69545: PUSH
69546: LD_INT 1
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 2
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 1
69565: PUSH
69566: LD_INT 2
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 0
69575: PUSH
69576: LD_INT 2
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 1
69585: NEG
69586: PUSH
69587: LD_INT 1
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 2
69596: NEG
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 2
69607: NEG
69608: PUSH
69609: LD_INT 1
69611: NEG
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 1
69619: NEG
69620: PUSH
69621: LD_INT 3
69623: NEG
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: LD_INT 1
69631: PUSH
69632: LD_INT 2
69634: NEG
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 3
69642: PUSH
69643: LD_INT 2
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 2
69652: PUSH
69653: LD_INT 3
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 2
69662: NEG
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 3
69673: NEG
69674: PUSH
69675: LD_INT 1
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69708: LD_ADDR_VAR 0 33
69712: PUSH
69713: LD_INT 0
69715: PUSH
69716: LD_INT 0
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 0
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: LD_INT 0
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 1
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 1
69777: NEG
69778: PUSH
69779: LD_INT 1
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: LD_INT 2
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 1
69801: PUSH
69802: LD_INT 1
69804: NEG
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 2
69812: PUSH
69813: LD_INT 0
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 2
69822: PUSH
69823: LD_INT 1
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: LD_INT 2
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 0
69842: PUSH
69843: LD_INT 2
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 1
69852: NEG
69853: PUSH
69854: LD_INT 1
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 2
69863: NEG
69864: PUSH
69865: LD_INT 0
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: LD_INT 2
69874: NEG
69875: PUSH
69876: LD_INT 1
69878: NEG
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 2
69886: NEG
69887: PUSH
69888: LD_INT 2
69890: NEG
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 2
69898: NEG
69899: PUSH
69900: LD_INT 3
69902: NEG
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 2
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 3
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: LD_INT 3
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 1
69941: NEG
69942: PUSH
69943: LD_INT 2
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: PUSH
69950: LD_INT 3
69952: NEG
69953: PUSH
69954: LD_INT 2
69956: NEG
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69987: LD_ADDR_VAR 0 34
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 0
70004: PUSH
70005: LD_INT 1
70007: NEG
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 1
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 1
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 0
70035: PUSH
70036: LD_INT 1
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: LD_INT 1
70045: NEG
70046: PUSH
70047: LD_INT 0
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: LD_INT 1
70060: NEG
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 1
70068: NEG
70069: PUSH
70070: LD_INT 2
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 0
70080: PUSH
70081: LD_INT 2
70083: NEG
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 1
70091: PUSH
70092: LD_INT 1
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 2
70102: PUSH
70103: LD_INT 1
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 2
70112: PUSH
70113: LD_INT 2
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: LD_INT 2
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 1
70132: NEG
70133: PUSH
70134: LD_INT 1
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 2
70143: NEG
70144: PUSH
70145: LD_INT 0
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 1
70178: NEG
70179: PUSH
70180: LD_INT 3
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 1
70190: PUSH
70191: LD_INT 2
70193: NEG
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: LD_INT 2
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: LD_INT 3
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: NEG
70222: PUSH
70223: LD_INT 1
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PUSH
70230: LD_INT 3
70232: NEG
70233: PUSH
70234: LD_INT 1
70236: NEG
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70267: LD_ADDR_VAR 0 35
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 0
70284: PUSH
70285: LD_INT 1
70287: NEG
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: PUSH
70293: LD_INT 1
70295: PUSH
70296: LD_INT 0
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: LD_INT 1
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 0
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 1
70325: NEG
70326: PUSH
70327: LD_INT 0
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 1
70336: NEG
70337: PUSH
70338: LD_INT 1
70340: NEG
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 2
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 2
70358: NEG
70359: PUSH
70360: LD_INT 1
70362: NEG
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: LIST
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70379: LD_ADDR_VAR 0 36
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: LD_INT 1
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PUSH
70439: LD_INT 0
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 1
70448: NEG
70449: PUSH
70450: LD_INT 1
70452: NEG
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: LD_INT 2
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: PUSH
70473: LD_INT 2
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: LIST
70490: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70491: LD_ADDR_VAR 0 37
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: LD_INT 0
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 0
70508: PUSH
70509: LD_INT 1
70511: NEG
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 1
70519: PUSH
70520: LD_INT 0
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: LD_INT 1
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: LD_INT 1
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 1
70549: NEG
70550: PUSH
70551: LD_INT 0
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 1
70560: NEG
70561: PUSH
70562: LD_INT 1
70564: NEG
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 1
70572: PUSH
70573: LD_INT 1
70575: NEG
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 1
70583: NEG
70584: PUSH
70585: LD_INT 1
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70603: LD_ADDR_VAR 0 38
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 0
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 1
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 0
70651: PUSH
70652: LD_INT 1
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 1
70661: NEG
70662: PUSH
70663: LD_INT 0
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 2
70684: PUSH
70685: LD_INT 1
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 2
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70715: LD_ADDR_VAR 0 39
70719: PUSH
70720: LD_INT 0
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 0
70732: PUSH
70733: LD_INT 1
70735: NEG
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 1
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 1
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: NEG
70774: PUSH
70775: LD_INT 0
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: LD_INT 1
70788: NEG
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PUSH
70794: LD_INT 1
70796: NEG
70797: PUSH
70798: LD_INT 2
70800: NEG
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 2
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70827: LD_ADDR_VAR 0 40
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: LD_INT 0
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 0
70844: PUSH
70845: LD_INT 1
70847: NEG
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: LD_INT 0
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 0
70875: PUSH
70876: LD_INT 1
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 1
70885: NEG
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 1
70896: NEG
70897: PUSH
70898: LD_INT 1
70900: NEG
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 1
70908: PUSH
70909: LD_INT 1
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70939: LD_ADDR_VAR 0 41
70943: PUSH
70944: LD_INT 0
70946: PUSH
70947: LD_INT 0
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 0
70956: PUSH
70957: LD_INT 1
70959: NEG
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: PUSH
70968: LD_INT 0
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 1
70977: PUSH
70978: LD_INT 1
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 0
70987: PUSH
70988: LD_INT 1
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 1
70997: NEG
70998: PUSH
70999: LD_INT 0
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 1
71008: NEG
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 1
71032: PUSH
71033: LD_INT 1
71035: NEG
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 2
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 2
71063: PUSH
71064: LD_INT 2
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 1
71073: PUSH
71074: LD_INT 2
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 1
71083: NEG
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 2
71094: NEG
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 2
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: LD_INT 3
71133: NEG
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 2
71141: PUSH
71142: LD_INT 1
71144: NEG
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: LD_INT 3
71152: PUSH
71153: LD_INT 0
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 3
71162: PUSH
71163: LD_INT 1
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 3
71172: PUSH
71173: LD_INT 2
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 3
71182: PUSH
71183: LD_INT 3
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 2
71192: PUSH
71193: LD_INT 3
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 3
71213: NEG
71214: PUSH
71215: LD_INT 0
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 3
71224: NEG
71225: PUSH
71226: LD_INT 1
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 3
71236: NEG
71237: PUSH
71238: LD_INT 2
71240: NEG
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 3
71248: NEG
71249: PUSH
71250: LD_INT 3
71252: NEG
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: LIST
71288: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71289: LD_ADDR_VAR 0 42
71293: PUSH
71294: LD_INT 0
71296: PUSH
71297: LD_INT 0
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: PUSH
71304: LD_INT 0
71306: PUSH
71307: LD_INT 1
71309: NEG
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: PUSH
71318: LD_INT 0
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 1
71327: PUSH
71328: LD_INT 1
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: LD_INT 1
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: LD_INT 0
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 1
71358: NEG
71359: PUSH
71360: LD_INT 1
71362: NEG
71363: PUSH
71364: EMPTY
71365: LIST
71366: LIST
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: LD_INT 2
71374: NEG
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PUSH
71380: LD_INT 0
71382: PUSH
71383: LD_INT 2
71385: NEG
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 1
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 2
71404: PUSH
71405: LD_INT 1
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 2
71414: PUSH
71415: LD_INT 2
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: LD_INT 2
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 0
71434: PUSH
71435: LD_INT 2
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 1
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 2
71455: NEG
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 2
71467: NEG
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 2
71479: NEG
71480: PUSH
71481: LD_INT 3
71483: NEG
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 1
71491: NEG
71492: PUSH
71493: LD_INT 3
71495: NEG
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: LD_INT 3
71506: NEG
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 1
71514: PUSH
71515: LD_INT 2
71517: NEG
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 3
71525: PUSH
71526: LD_INT 2
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 3
71535: PUSH
71536: LD_INT 3
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 2
71545: PUSH
71546: LD_INT 3
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: LD_INT 3
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 0
71565: PUSH
71566: LD_INT 3
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: LD_INT 2
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 3
71586: NEG
71587: PUSH
71588: LD_INT 2
71590: NEG
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 3
71598: NEG
71599: PUSH
71600: LD_INT 3
71602: NEG
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71639: LD_ADDR_VAR 0 43
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: LD_INT 0
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 0
71656: PUSH
71657: LD_INT 1
71659: NEG
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 1
71667: PUSH
71668: LD_INT 0
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 0
71687: PUSH
71688: LD_INT 1
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: LD_INT 0
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 1
71708: NEG
71709: PUSH
71710: LD_INT 1
71712: NEG
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 1
71720: NEG
71721: PUSH
71722: LD_INT 2
71724: NEG
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 0
71732: PUSH
71733: LD_INT 2
71735: NEG
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: PUSH
71744: LD_INT 1
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 2
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 2
71764: PUSH
71765: LD_INT 1
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 1
71774: PUSH
71775: LD_INT 2
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: LD_INT 2
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: LD_INT 1
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 2
71805: NEG
71806: PUSH
71807: LD_INT 0
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: LD_INT 2
71816: NEG
71817: PUSH
71818: LD_INT 1
71820: NEG
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: NEG
71829: PUSH
71830: LD_INT 3
71832: NEG
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: LD_INT 3
71843: NEG
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 1
71851: PUSH
71852: LD_INT 2
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 2
71862: PUSH
71863: LD_INT 1
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 3
71873: PUSH
71874: LD_INT 0
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: LD_INT 3
71883: PUSH
71884: LD_INT 1
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 1
71893: PUSH
71894: LD_INT 3
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: LD_INT 0
71903: PUSH
71904: LD_INT 3
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 1
71913: NEG
71914: PUSH
71915: LD_INT 2
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 2
71924: NEG
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 3
71935: NEG
71936: PUSH
71937: LD_INT 0
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 3
71946: NEG
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71987: LD_ADDR_VAR 0 44
71991: PUSH
71992: LD_INT 0
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: LD_INT 0
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 1
72025: PUSH
72026: LD_INT 1
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 0
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 1
72045: NEG
72046: PUSH
72047: LD_INT 0
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: LD_INT 2
72072: NEG
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 1
72080: PUSH
72081: LD_INT 1
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 2
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 2
72101: PUSH
72102: LD_INT 1
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 2
72111: PUSH
72112: LD_INT 2
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: LD_INT 2
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 1
72131: NEG
72132: PUSH
72133: LD_INT 1
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 2
72142: NEG
72143: PUSH
72144: LD_INT 0
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 2
72153: NEG
72154: PUSH
72155: LD_INT 1
72157: NEG
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 2
72165: NEG
72166: PUSH
72167: LD_INT 2
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 2
72177: NEG
72178: PUSH
72179: LD_INT 3
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 2
72189: PUSH
72190: LD_INT 1
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 3
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 3
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 3
72220: PUSH
72221: LD_INT 2
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 3
72230: PUSH
72231: LD_INT 3
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 2
72240: PUSH
72241: LD_INT 3
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 2
72250: NEG
72251: PUSH
72252: LD_INT 1
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 3
72261: NEG
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 3
72272: NEG
72273: PUSH
72274: LD_INT 1
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 3
72284: NEG
72285: PUSH
72286: LD_INT 2
72288: NEG
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 3
72296: NEG
72297: PUSH
72298: LD_INT 3
72300: NEG
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72337: LD_ADDR_VAR 0 45
72341: PUSH
72342: LD_INT 0
72344: PUSH
72345: LD_INT 0
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 0
72354: PUSH
72355: LD_INT 1
72357: NEG
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: LD_INT 1
72375: PUSH
72376: LD_INT 1
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 0
72385: PUSH
72386: LD_INT 1
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: LD_INT 1
72395: NEG
72396: PUSH
72397: LD_INT 0
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 1
72406: NEG
72407: PUSH
72408: LD_INT 1
72410: NEG
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 1
72418: NEG
72419: PUSH
72420: LD_INT 2
72422: NEG
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: LD_INT 0
72430: PUSH
72431: LD_INT 2
72433: NEG
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 1
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 2
72452: PUSH
72453: LD_INT 1
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 2
72462: PUSH
72463: LD_INT 2
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 1
72472: PUSH
72473: LD_INT 2
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: LD_INT 2
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: LD_INT 1
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 2
72503: NEG
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 2
72515: NEG
72516: PUSH
72517: LD_INT 2
72519: NEG
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 2
72527: NEG
72528: PUSH
72529: LD_INT 3
72531: NEG
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 1
72539: NEG
72540: PUSH
72541: LD_INT 3
72543: NEG
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 0
72551: PUSH
72552: LD_INT 3
72554: NEG
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 1
72562: PUSH
72563: LD_INT 2
72565: NEG
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 3
72573: PUSH
72574: LD_INT 2
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 3
72583: PUSH
72584: LD_INT 3
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 2
72593: PUSH
72594: LD_INT 3
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 1
72603: PUSH
72604: LD_INT 3
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: PUSH
72611: LD_INT 0
72613: PUSH
72614: LD_INT 3
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: LD_INT 2
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 3
72634: NEG
72635: PUSH
72636: LD_INT 2
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 3
72646: NEG
72647: PUSH
72648: LD_INT 3
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72687: LD_ADDR_VAR 0 46
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: LD_INT 0
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 0
72704: PUSH
72705: LD_INT 1
72707: NEG
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 0
72735: PUSH
72736: LD_INT 1
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: NEG
72746: PUSH
72747: LD_INT 0
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 1
72756: NEG
72757: PUSH
72758: LD_INT 1
72760: NEG
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 1
72768: NEG
72769: PUSH
72770: LD_INT 2
72772: NEG
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 0
72780: PUSH
72781: LD_INT 2
72783: NEG
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 1
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 2
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 1
72822: PUSH
72823: LD_INT 2
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: LD_INT 2
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 1
72842: NEG
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 2
72853: NEG
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 2
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 1
72876: NEG
72877: PUSH
72878: LD_INT 3
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 0
72888: PUSH
72889: LD_INT 3
72891: NEG
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: LD_INT 2
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 2
72910: PUSH
72911: LD_INT 1
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 3
72921: PUSH
72922: LD_INT 0
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: LD_INT 3
72931: PUSH
72932: LD_INT 1
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: PUSH
72942: LD_INT 3
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PUSH
72949: LD_INT 0
72951: PUSH
72952: LD_INT 3
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: LD_INT 2
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 2
72972: NEG
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 3
72983: NEG
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 3
72994: NEG
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: LIST
73029: LIST
73030: LIST
73031: LIST
73032: LIST
73033: LIST
73034: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73035: LD_ADDR_VAR 0 47
73039: PUSH
73040: LD_INT 0
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 0
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: LD_INT 1
73063: PUSH
73064: LD_INT 0
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: LD_INT 1
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: LD_INT 1
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 1
73093: NEG
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: LD_INT 1
73104: NEG
73105: PUSH
73106: LD_INT 1
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 1
73116: NEG
73117: PUSH
73118: LD_INT 2
73120: NEG
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 0
73128: PUSH
73129: LD_INT 2
73131: NEG
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: LD_INT 1
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 2
73150: NEG
73151: PUSH
73152: LD_INT 1
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: LD_INT 2
73166: NEG
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: LIST
73176: LIST
73177: LIST
73178: LIST
73179: LIST
73180: LIST
73181: LIST
73182: LIST
73183: LIST
73184: LIST
73185: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73186: LD_ADDR_VAR 0 48
73190: PUSH
73191: LD_INT 0
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: PUSH
73225: LD_INT 1
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: EMPTY
73239: LIST
73240: LIST
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: LD_INT 1
73259: NEG
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 1
73267: NEG
73268: PUSH
73269: LD_INT 2
73271: NEG
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: LD_INT 0
73279: PUSH
73280: LD_INT 2
73282: NEG
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 1
73290: PUSH
73291: LD_INT 1
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 2
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 2
73311: PUSH
73312: LD_INT 1
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: LIST
73323: LIST
73324: LIST
73325: LIST
73326: LIST
73327: LIST
73328: LIST
73329: LIST
73330: LIST
73331: LIST
73332: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73333: LD_ADDR_VAR 0 49
73337: PUSH
73338: LD_INT 0
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: LD_INT 0
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: LD_INT 0
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: LD_INT 1
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 0
73381: PUSH
73382: LD_INT 1
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 1
73391: NEG
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 1
73402: NEG
73403: PUSH
73404: LD_INT 1
73406: NEG
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: LD_INT 1
73417: NEG
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 2
73425: PUSH
73426: LD_INT 0
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 1
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 2
73445: PUSH
73446: LD_INT 2
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 1
73455: PUSH
73456: LD_INT 2
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73477: LD_ADDR_VAR 0 50
73481: PUSH
73482: LD_INT 0
73484: PUSH
73485: LD_INT 0
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 0
73494: PUSH
73495: LD_INT 1
73497: NEG
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: LD_INT 1
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: LD_INT 1
73518: PUSH
73519: EMPTY
73520: LIST
73521: LIST
73522: PUSH
73523: LD_INT 0
73525: PUSH
73526: LD_INT 1
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 1
73535: NEG
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 1
73546: NEG
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 2
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 2
73568: PUSH
73569: LD_INT 2
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: LD_INT 2
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 0
73588: PUSH
73589: LD_INT 2
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: NEG
73599: PUSH
73600: LD_INT 1
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73621: LD_ADDR_VAR 0 51
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 0
73638: PUSH
73639: LD_INT 1
73641: NEG
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 1
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: PUSH
73660: LD_INT 1
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 0
73669: PUSH
73670: LD_INT 1
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 1
73679: NEG
73680: PUSH
73681: LD_INT 0
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: LD_INT 1
73694: NEG
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 1
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: LD_INT 1
73748: NEG
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73768: LD_ADDR_VAR 0 52
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 0
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: PUSH
73797: LD_INT 0
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: LD_INT 0
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 2
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: NEG
73862: PUSH
73863: LD_INT 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 2
73872: NEG
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 2
73883: NEG
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 2
73895: NEG
73896: PUSH
73897: LD_INT 2
73899: NEG
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73919: LD_ADDR_VAR 0 53
73923: PUSH
73924: LD_INT 0
73926: PUSH
73927: LD_INT 0
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 0
73936: PUSH
73937: LD_INT 1
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 1
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 1
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 0
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 1
73977: NEG
73978: PUSH
73979: LD_INT 0
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 1
73988: NEG
73989: PUSH
73990: LD_INT 1
73992: NEG
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 1
74000: NEG
74001: PUSH
74002: LD_INT 2
74004: NEG
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 0
74012: PUSH
74013: LD_INT 2
74015: NEG
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: LD_INT 1
74026: NEG
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 2
74034: PUSH
74035: LD_INT 0
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 2
74044: PUSH
74045: LD_INT 1
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 2
74054: PUSH
74055: LD_INT 2
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 1
74064: PUSH
74065: LD_INT 2
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 0
74074: PUSH
74075: LD_INT 2
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 1
74084: NEG
74085: PUSH
74086: LD_INT 1
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 2
74095: NEG
74096: PUSH
74097: LD_INT 0
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 2
74106: NEG
74107: PUSH
74108: LD_INT 1
74110: NEG
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 2
74118: NEG
74119: PUSH
74120: LD_INT 2
74122: NEG
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74149: LD_ADDR_VAR 0 54
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: LD_INT 0
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 0
74166: PUSH
74167: LD_INT 1
74169: NEG
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: LD_INT 0
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 1
74187: PUSH
74188: LD_INT 1
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PUSH
74195: LD_INT 0
74197: PUSH
74198: LD_INT 1
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: LD_INT 0
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 1
74218: NEG
74219: PUSH
74220: LD_INT 1
74222: NEG
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: LD_INT 2
74234: NEG
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 0
74242: PUSH
74243: LD_INT 2
74245: NEG
74246: PUSH
74247: EMPTY
74248: LIST
74249: LIST
74250: PUSH
74251: LD_INT 1
74253: PUSH
74254: LD_INT 1
74256: NEG
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: LD_INT 2
74264: PUSH
74265: LD_INT 0
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: PUSH
74275: LD_INT 1
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 2
74284: PUSH
74285: LD_INT 2
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 1
74294: PUSH
74295: LD_INT 2
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 0
74304: PUSH
74305: LD_INT 2
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 1
74314: NEG
74315: PUSH
74316: LD_INT 1
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: LD_INT 2
74325: NEG
74326: PUSH
74327: LD_INT 0
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 2
74336: NEG
74337: PUSH
74338: LD_INT 1
74340: NEG
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: PUSH
74346: LD_INT 2
74348: NEG
74349: PUSH
74350: LD_INT 2
74352: NEG
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: LIST
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74379: LD_ADDR_VAR 0 55
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 0
74396: PUSH
74397: LD_INT 1
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 1
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 1
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 0
74427: PUSH
74428: LD_INT 1
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 1
74437: NEG
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 1
74448: NEG
74449: PUSH
74450: LD_INT 1
74452: NEG
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: LD_INT 2
74464: NEG
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 0
74472: PUSH
74473: LD_INT 2
74475: NEG
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: PUSH
74484: LD_INT 1
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 2
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: LD_INT 1
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 2
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 1
74524: PUSH
74525: LD_INT 2
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 0
74534: PUSH
74535: LD_INT 2
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: LD_INT 1
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 2
74555: NEG
74556: PUSH
74557: LD_INT 0
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: LD_INT 1
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: NEG
74579: PUSH
74580: LD_INT 2
74582: NEG
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74609: LD_ADDR_VAR 0 56
74613: PUSH
74614: LD_INT 0
74616: PUSH
74617: LD_INT 0
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 0
74626: PUSH
74627: LD_INT 1
74629: NEG
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 1
74637: PUSH
74638: LD_INT 0
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 1
74647: PUSH
74648: LD_INT 1
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 0
74657: PUSH
74658: LD_INT 1
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: LD_INT 0
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 1
74678: NEG
74679: PUSH
74680: LD_INT 1
74682: NEG
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 1
74690: NEG
74691: PUSH
74692: LD_INT 2
74694: NEG
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 0
74702: PUSH
74703: LD_INT 2
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 1
74713: PUSH
74714: LD_INT 1
74716: NEG
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 2
74724: PUSH
74725: LD_INT 0
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 2
74734: PUSH
74735: LD_INT 1
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: LD_INT 2
74744: PUSH
74745: LD_INT 2
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 1
74754: PUSH
74755: LD_INT 2
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 0
74764: PUSH
74765: LD_INT 2
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 2
74785: NEG
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 2
74796: NEG
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 2
74808: NEG
74809: PUSH
74810: LD_INT 2
74812: NEG
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: LIST
74822: LIST
74823: LIST
74824: LIST
74825: LIST
74826: LIST
74827: LIST
74828: LIST
74829: LIST
74830: LIST
74831: LIST
74832: LIST
74833: LIST
74834: LIST
74835: LIST
74836: LIST
74837: LIST
74838: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74839: LD_ADDR_VAR 0 57
74843: PUSH
74844: LD_INT 0
74846: PUSH
74847: LD_INT 0
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: LD_INT 0
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: PUSH
74878: LD_INT 1
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 0
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 1
74897: NEG
74898: PUSH
74899: LD_INT 0
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: LD_INT 1
74908: NEG
74909: PUSH
74910: LD_INT 1
74912: NEG
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 2
74924: NEG
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 0
74932: PUSH
74933: LD_INT 2
74935: NEG
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 1
74943: PUSH
74944: LD_INT 1
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 2
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: LD_INT 2
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PUSH
74972: LD_INT 2
74974: PUSH
74975: LD_INT 2
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 1
74984: PUSH
74985: LD_INT 2
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 0
74994: PUSH
74995: LD_INT 2
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: LD_INT 1
75004: NEG
75005: PUSH
75006: LD_INT 1
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: LD_INT 0
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 2
75026: NEG
75027: PUSH
75028: LD_INT 1
75030: NEG
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 2
75038: NEG
75039: PUSH
75040: LD_INT 2
75042: NEG
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: LIST
75055: LIST
75056: LIST
75057: LIST
75058: LIST
75059: LIST
75060: LIST
75061: LIST
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75069: LD_ADDR_VAR 0 58
75073: PUSH
75074: LD_INT 0
75076: PUSH
75077: LD_INT 0
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: LD_INT 1
75089: NEG
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 1
75097: PUSH
75098: LD_INT 0
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: PUSH
75108: LD_INT 1
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 0
75117: PUSH
75118: LD_INT 1
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 1
75127: NEG
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 1
75142: NEG
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: NEG
75151: PUSH
75152: LD_INT 2
75154: NEG
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: LD_INT 2
75165: NEG
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 1
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 2
75184: PUSH
75185: LD_INT 0
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 2
75194: PUSH
75195: LD_INT 1
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 2
75204: PUSH
75205: LD_INT 2
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 1
75214: PUSH
75215: LD_INT 2
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: LD_INT 2
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 1
75234: NEG
75235: PUSH
75236: LD_INT 1
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 2
75245: NEG
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 2
75256: NEG
75257: PUSH
75258: LD_INT 1
75260: NEG
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 2
75268: NEG
75269: PUSH
75270: LD_INT 2
75272: NEG
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75299: LD_ADDR_VAR 0 59
75303: PUSH
75304: LD_INT 0
75306: PUSH
75307: LD_INT 0
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: LD_INT 0
75316: PUSH
75317: LD_INT 1
75319: NEG
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 1
75327: PUSH
75328: LD_INT 0
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 1
75337: PUSH
75338: LD_INT 1
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 0
75347: PUSH
75348: LD_INT 1
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: NEG
75358: PUSH
75359: LD_INT 0
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: PUSH
75366: LD_INT 1
75368: NEG
75369: PUSH
75370: LD_INT 1
75372: NEG
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75387: LD_ADDR_VAR 0 60
75391: PUSH
75392: LD_INT 0
75394: PUSH
75395: LD_INT 0
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 0
75404: PUSH
75405: LD_INT 1
75407: NEG
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: LD_INT 0
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 1
75425: PUSH
75426: LD_INT 1
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 0
75435: PUSH
75436: LD_INT 1
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 1
75445: NEG
75446: PUSH
75447: LD_INT 0
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: NEG
75457: PUSH
75458: LD_INT 1
75460: NEG
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: LIST
75474: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75475: LD_ADDR_VAR 0 61
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 0
75492: PUSH
75493: LD_INT 1
75495: NEG
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PUSH
75501: LD_INT 1
75503: PUSH
75504: LD_INT 0
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: LD_INT 1
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 1
75533: NEG
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: LD_INT 1
75548: NEG
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75563: LD_ADDR_VAR 0 62
75567: PUSH
75568: LD_INT 0
75570: PUSH
75571: LD_INT 0
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 0
75580: PUSH
75581: LD_INT 1
75583: NEG
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: LD_INT 1
75591: PUSH
75592: LD_INT 0
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: PUSH
75599: LD_INT 1
75601: PUSH
75602: LD_INT 1
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 1
75621: NEG
75622: PUSH
75623: LD_INT 0
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 1
75632: NEG
75633: PUSH
75634: LD_INT 1
75636: NEG
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75651: LD_ADDR_VAR 0 63
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: LD_INT 0
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 0
75668: PUSH
75669: LD_INT 1
75671: NEG
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 1
75679: PUSH
75680: LD_INT 0
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 1
75689: PUSH
75690: LD_INT 1
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 0
75699: PUSH
75700: LD_INT 1
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 1
75709: NEG
75710: PUSH
75711: LD_INT 0
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: LD_INT 1
75724: NEG
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75739: LD_ADDR_VAR 0 64
75743: PUSH
75744: LD_INT 0
75746: PUSH
75747: LD_INT 0
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 0
75756: PUSH
75757: LD_INT 1
75759: NEG
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 1
75767: PUSH
75768: LD_INT 0
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: LD_INT 1
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 0
75787: PUSH
75788: LD_INT 1
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: NEG
75798: PUSH
75799: LD_INT 0
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: LIST
75822: LIST
75823: LIST
75824: LIST
75825: LIST
75826: ST_TO_ADDR
// end ; 1 :
75827: GO 81724
75829: LD_INT 1
75831: DOUBLE
75832: EQUAL
75833: IFTRUE 75837
75835: GO 78460
75837: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75838: LD_ADDR_VAR 0 11
75842: PUSH
75843: LD_INT 1
75845: NEG
75846: PUSH
75847: LD_INT 3
75849: NEG
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: LD_INT 3
75860: NEG
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 1
75868: PUSH
75869: LD_INT 2
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: LIST
75881: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75882: LD_ADDR_VAR 0 12
75886: PUSH
75887: LD_INT 2
75889: PUSH
75890: LD_INT 1
75892: NEG
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 3
75900: PUSH
75901: LD_INT 0
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 3
75910: PUSH
75911: LD_INT 1
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: LIST
75922: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75923: LD_ADDR_VAR 0 13
75927: PUSH
75928: LD_INT 3
75930: PUSH
75931: LD_INT 2
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 3
75940: PUSH
75941: LD_INT 3
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 2
75950: PUSH
75951: LD_INT 3
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: LIST
75962: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75963: LD_ADDR_VAR 0 14
75967: PUSH
75968: LD_INT 1
75970: PUSH
75971: LD_INT 3
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 0
75980: PUSH
75981: LD_INT 3
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 1
75990: NEG
75991: PUSH
75992: LD_INT 2
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: LIST
76003: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76004: LD_ADDR_VAR 0 15
76008: PUSH
76009: LD_INT 2
76011: NEG
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: LD_INT 3
76022: NEG
76023: PUSH
76024: LD_INT 0
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: NEG
76034: PUSH
76035: LD_INT 1
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: LIST
76047: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76048: LD_ADDR_VAR 0 16
76052: PUSH
76053: LD_INT 2
76055: NEG
76056: PUSH
76057: LD_INT 3
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 3
76067: NEG
76068: PUSH
76069: LD_INT 2
76071: NEG
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 3
76079: NEG
76080: PUSH
76081: LD_INT 3
76083: NEG
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: LIST
76093: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76094: LD_ADDR_VAR 0 17
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: LD_INT 3
76105: NEG
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: LD_INT 3
76116: NEG
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 1
76124: PUSH
76125: LD_INT 2
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: LIST
76137: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76138: LD_ADDR_VAR 0 18
76142: PUSH
76143: LD_INT 2
76145: PUSH
76146: LD_INT 1
76148: NEG
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 3
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 3
76166: PUSH
76167: LD_INT 1
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: LIST
76178: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76179: LD_ADDR_VAR 0 19
76183: PUSH
76184: LD_INT 3
76186: PUSH
76187: LD_INT 2
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: LD_INT 3
76196: PUSH
76197: LD_INT 3
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 2
76206: PUSH
76207: LD_INT 3
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: EMPTY
76215: LIST
76216: LIST
76217: LIST
76218: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76219: LD_ADDR_VAR 0 20
76223: PUSH
76224: LD_INT 1
76226: PUSH
76227: LD_INT 3
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 0
76236: PUSH
76237: LD_INT 3
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 1
76246: NEG
76247: PUSH
76248: LD_INT 2
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: LIST
76259: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76260: LD_ADDR_VAR 0 21
76264: PUSH
76265: LD_INT 2
76267: NEG
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 3
76278: NEG
76279: PUSH
76280: LD_INT 0
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 3
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: NEG
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: LIST
76303: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76304: LD_ADDR_VAR 0 22
76308: PUSH
76309: LD_INT 2
76311: NEG
76312: PUSH
76313: LD_INT 3
76315: NEG
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 3
76323: NEG
76324: PUSH
76325: LD_INT 2
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 3
76335: NEG
76336: PUSH
76337: LD_INT 3
76339: NEG
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: LIST
76349: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76350: LD_ADDR_VAR 0 23
76354: PUSH
76355: LD_INT 0
76357: PUSH
76358: LD_INT 3
76360: NEG
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 1
76368: NEG
76369: PUSH
76370: LD_INT 4
76372: NEG
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 1
76380: PUSH
76381: LD_INT 3
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: LIST
76393: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76394: LD_ADDR_VAR 0 24
76398: PUSH
76399: LD_INT 3
76401: PUSH
76402: LD_INT 0
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 3
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 4
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: LIST
76434: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76435: LD_ADDR_VAR 0 25
76439: PUSH
76440: LD_INT 3
76442: PUSH
76443: LD_INT 3
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 4
76452: PUSH
76453: LD_INT 3
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 3
76462: PUSH
76463: LD_INT 4
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: LIST
76474: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76475: LD_ADDR_VAR 0 26
76479: PUSH
76480: LD_INT 0
76482: PUSH
76483: LD_INT 3
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 1
76492: PUSH
76493: LD_INT 4
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 1
76502: NEG
76503: PUSH
76504: LD_INT 3
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: LIST
76515: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76516: LD_ADDR_VAR 0 27
76520: PUSH
76521: LD_INT 3
76523: NEG
76524: PUSH
76525: LD_INT 0
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 3
76534: NEG
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 4
76545: NEG
76546: PUSH
76547: LD_INT 1
76549: NEG
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: LIST
76559: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76560: LD_ADDR_VAR 0 28
76564: PUSH
76565: LD_INT 3
76567: NEG
76568: PUSH
76569: LD_INT 3
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 3
76579: NEG
76580: PUSH
76581: LD_INT 4
76583: NEG
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 4
76591: NEG
76592: PUSH
76593: LD_INT 3
76595: NEG
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: LIST
76605: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76606: LD_ADDR_VAR 0 29
76610: PUSH
76611: LD_INT 1
76613: NEG
76614: PUSH
76615: LD_INT 3
76617: NEG
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 0
76625: PUSH
76626: LD_INT 3
76628: NEG
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 1
76636: PUSH
76637: LD_INT 2
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 1
76647: NEG
76648: PUSH
76649: LD_INT 4
76651: NEG
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 0
76659: PUSH
76660: LD_INT 4
76662: NEG
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: LD_INT 1
76670: PUSH
76671: LD_INT 3
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 1
76681: NEG
76682: PUSH
76683: LD_INT 5
76685: NEG
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: LD_INT 0
76693: PUSH
76694: LD_INT 5
76696: NEG
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 1
76704: PUSH
76705: LD_INT 4
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 1
76715: NEG
76716: PUSH
76717: LD_INT 6
76719: NEG
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: LD_INT 6
76730: NEG
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 1
76738: PUSH
76739: LD_INT 5
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76761: LD_ADDR_VAR 0 30
76765: PUSH
76766: LD_INT 2
76768: PUSH
76769: LD_INT 1
76771: NEG
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: LD_INT 3
76779: PUSH
76780: LD_INT 0
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 3
76789: PUSH
76790: LD_INT 1
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 3
76799: PUSH
76800: LD_INT 1
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 4
76810: PUSH
76811: LD_INT 0
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 4
76820: PUSH
76821: LD_INT 1
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 4
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 5
76841: PUSH
76842: LD_INT 0
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 5
76851: PUSH
76852: LD_INT 1
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 5
76861: PUSH
76862: LD_INT 1
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 6
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 6
76882: PUSH
76883: LD_INT 1
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76904: LD_ADDR_VAR 0 31
76908: PUSH
76909: LD_INT 3
76911: PUSH
76912: LD_INT 2
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 3
76921: PUSH
76922: LD_INT 3
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 2
76931: PUSH
76932: LD_INT 3
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 4
76941: PUSH
76942: LD_INT 3
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 4
76951: PUSH
76952: LD_INT 4
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 3
76961: PUSH
76962: LD_INT 4
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 5
76971: PUSH
76972: LD_INT 4
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 5
76981: PUSH
76982: LD_INT 5
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 4
76991: PUSH
76992: LD_INT 5
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 6
77001: PUSH
77002: LD_INT 5
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 6
77011: PUSH
77012: LD_INT 6
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 5
77021: PUSH
77022: LD_INT 6
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: LIST
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: LIST
77041: LIST
77042: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77043: LD_ADDR_VAR 0 32
77047: PUSH
77048: LD_INT 1
77050: PUSH
77051: LD_INT 3
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 0
77060: PUSH
77061: LD_INT 3
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: LD_INT 2
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 1
77081: PUSH
77082: LD_INT 4
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 0
77091: PUSH
77092: LD_INT 4
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: NEG
77102: PUSH
77103: LD_INT 3
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 1
77112: PUSH
77113: LD_INT 5
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: LD_INT 5
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 1
77132: NEG
77133: PUSH
77134: LD_INT 4
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 1
77143: PUSH
77144: LD_INT 6
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: LD_INT 6
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 1
77163: NEG
77164: PUSH
77165: LD_INT 5
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77186: LD_ADDR_VAR 0 33
77190: PUSH
77191: LD_INT 2
77193: NEG
77194: PUSH
77195: LD_INT 1
77197: PUSH
77198: EMPTY
77199: LIST
77200: LIST
77201: PUSH
77202: LD_INT 3
77204: NEG
77205: PUSH
77206: LD_INT 0
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 3
77215: NEG
77216: PUSH
77217: LD_INT 1
77219: NEG
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 3
77227: NEG
77228: PUSH
77229: LD_INT 1
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 4
77238: NEG
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 4
77249: NEG
77250: PUSH
77251: LD_INT 1
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 4
77261: NEG
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 5
77272: NEG
77273: PUSH
77274: LD_INT 0
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 5
77283: NEG
77284: PUSH
77285: LD_INT 1
77287: NEG
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: PUSH
77293: LD_INT 5
77295: NEG
77296: PUSH
77297: LD_INT 1
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 6
77306: NEG
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 6
77317: NEG
77318: PUSH
77319: LD_INT 1
77321: NEG
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: LIST
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77341: LD_ADDR_VAR 0 34
77345: PUSH
77346: LD_INT 2
77348: NEG
77349: PUSH
77350: LD_INT 3
77352: NEG
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 3
77360: NEG
77361: PUSH
77362: LD_INT 2
77364: NEG
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 3
77372: NEG
77373: PUSH
77374: LD_INT 3
77376: NEG
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 3
77384: NEG
77385: PUSH
77386: LD_INT 4
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 4
77396: NEG
77397: PUSH
77398: LD_INT 3
77400: NEG
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 4
77408: NEG
77409: PUSH
77410: LD_INT 4
77412: NEG
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 4
77420: NEG
77421: PUSH
77422: LD_INT 5
77424: NEG
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 5
77432: NEG
77433: PUSH
77434: LD_INT 4
77436: NEG
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 5
77444: NEG
77445: PUSH
77446: LD_INT 5
77448: NEG
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 5
77456: NEG
77457: PUSH
77458: LD_INT 6
77460: NEG
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 6
77468: NEG
77469: PUSH
77470: LD_INT 5
77472: NEG
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: LD_INT 6
77480: NEG
77481: PUSH
77482: LD_INT 6
77484: NEG
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: LIST
77496: LIST
77497: LIST
77498: LIST
77499: LIST
77500: LIST
77501: LIST
77502: LIST
77503: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77504: LD_ADDR_VAR 0 41
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: LD_INT 2
77514: NEG
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 1
77522: NEG
77523: PUSH
77524: LD_INT 3
77526: NEG
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: PUSH
77535: LD_INT 2
77537: NEG
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: LIST
77547: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77548: LD_ADDR_VAR 0 42
77552: PUSH
77553: LD_INT 2
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 2
77565: PUSH
77566: LD_INT 1
77568: NEG
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 3
77576: PUSH
77577: LD_INT 1
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: LIST
77588: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77589: LD_ADDR_VAR 0 43
77593: PUSH
77594: LD_INT 2
77596: PUSH
77597: LD_INT 2
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 3
77606: PUSH
77607: LD_INT 2
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 2
77616: PUSH
77617: LD_INT 3
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: LIST
77628: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77629: LD_ADDR_VAR 0 44
77633: PUSH
77634: LD_INT 0
77636: PUSH
77637: LD_INT 2
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 1
77646: PUSH
77647: LD_INT 3
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: LD_INT 1
77656: NEG
77657: PUSH
77658: LD_INT 2
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: LIST
77669: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77670: LD_ADDR_VAR 0 45
77674: PUSH
77675: LD_INT 2
77677: NEG
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 2
77688: NEG
77689: PUSH
77690: LD_INT 1
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 3
77699: NEG
77700: PUSH
77701: LD_INT 1
77703: NEG
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: LIST
77713: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77714: LD_ADDR_VAR 0 46
77718: PUSH
77719: LD_INT 2
77721: NEG
77722: PUSH
77723: LD_INT 2
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 2
77733: NEG
77734: PUSH
77735: LD_INT 3
77737: NEG
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 3
77745: NEG
77746: PUSH
77747: LD_INT 2
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: LIST
77759: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77760: LD_ADDR_VAR 0 47
77764: PUSH
77765: LD_INT 2
77767: NEG
77768: PUSH
77769: LD_INT 3
77771: NEG
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 1
77779: NEG
77780: PUSH
77781: LD_INT 3
77783: NEG
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77793: LD_ADDR_VAR 0 48
77797: PUSH
77798: LD_INT 1
77800: PUSH
77801: LD_INT 2
77803: NEG
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 2
77811: PUSH
77812: LD_INT 1
77814: NEG
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77824: LD_ADDR_VAR 0 49
77828: PUSH
77829: LD_INT 3
77831: PUSH
77832: LD_INT 1
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 3
77841: PUSH
77842: LD_INT 2
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77853: LD_ADDR_VAR 0 50
77857: PUSH
77858: LD_INT 2
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 1
77870: PUSH
77871: LD_INT 3
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77882: LD_ADDR_VAR 0 51
77886: PUSH
77887: LD_INT 1
77889: NEG
77890: PUSH
77891: LD_INT 2
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 2
77900: NEG
77901: PUSH
77902: LD_INT 1
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77913: LD_ADDR_VAR 0 52
77917: PUSH
77918: LD_INT 3
77920: NEG
77921: PUSH
77922: LD_INT 1
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 3
77932: NEG
77933: PUSH
77934: LD_INT 2
77936: NEG
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77946: LD_ADDR_VAR 0 53
77950: PUSH
77951: LD_INT 1
77953: NEG
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: LD_INT 3
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 1
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: LIST
77989: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77990: LD_ADDR_VAR 0 54
77994: PUSH
77995: LD_INT 2
77997: PUSH
77998: LD_INT 1
78000: NEG
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 3
78008: PUSH
78009: LD_INT 0
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78031: LD_ADDR_VAR 0 55
78035: PUSH
78036: LD_INT 3
78038: PUSH
78039: LD_INT 2
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 3
78048: PUSH
78049: LD_INT 3
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 2
78058: PUSH
78059: LD_INT 3
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: LIST
78070: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78071: LD_ADDR_VAR 0 56
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 3
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 3
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: NEG
78099: PUSH
78100: LD_INT 2
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: LIST
78111: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78112: LD_ADDR_VAR 0 57
78116: PUSH
78117: LD_INT 2
78119: NEG
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 3
78130: NEG
78131: PUSH
78132: LD_INT 0
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 3
78141: NEG
78142: PUSH
78143: LD_INT 1
78145: NEG
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: LIST
78155: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78156: LD_ADDR_VAR 0 58
78160: PUSH
78161: LD_INT 2
78163: NEG
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 3
78175: NEG
78176: PUSH
78177: LD_INT 2
78179: NEG
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 3
78187: NEG
78188: PUSH
78189: LD_INT 3
78191: NEG
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: LIST
78201: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78202: LD_ADDR_VAR 0 59
78206: PUSH
78207: LD_INT 1
78209: NEG
78210: PUSH
78211: LD_INT 2
78213: NEG
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: LD_INT 0
78221: PUSH
78222: LD_INT 2
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 1
78232: PUSH
78233: LD_INT 1
78235: NEG
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: LIST
78245: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78246: LD_ADDR_VAR 0 60
78250: PUSH
78251: LD_INT 1
78253: PUSH
78254: LD_INT 1
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 2
78264: PUSH
78265: LD_INT 0
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 2
78274: PUSH
78275: LD_INT 1
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: LIST
78286: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78287: LD_ADDR_VAR 0 61
78291: PUSH
78292: LD_INT 2
78294: PUSH
78295: LD_INT 1
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 2
78304: PUSH
78305: LD_INT 2
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 1
78314: PUSH
78315: LD_INT 2
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: LIST
78326: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78327: LD_ADDR_VAR 0 62
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: LD_INT 2
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 0
78344: PUSH
78345: LD_INT 2
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: NEG
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78368: LD_ADDR_VAR 0 63
78372: PUSH
78373: LD_INT 1
78375: NEG
78376: PUSH
78377: LD_INT 1
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 2
78386: NEG
78387: PUSH
78388: LD_INT 0
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 2
78397: NEG
78398: PUSH
78399: LD_INT 1
78401: NEG
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: LIST
78411: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78412: LD_ADDR_VAR 0 64
78416: PUSH
78417: LD_INT 1
78419: NEG
78420: PUSH
78421: LD_INT 2
78423: NEG
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 2
78431: NEG
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 2
78443: NEG
78444: PUSH
78445: LD_INT 2
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: LIST
78457: ST_TO_ADDR
// end ; 2 :
78458: GO 81724
78460: LD_INT 2
78462: DOUBLE
78463: EQUAL
78464: IFTRUE 78468
78466: GO 81723
78468: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78469: LD_ADDR_VAR 0 29
78473: PUSH
78474: LD_INT 4
78476: PUSH
78477: LD_INT 0
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 4
78486: PUSH
78487: LD_INT 1
78489: NEG
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 5
78497: PUSH
78498: LD_INT 0
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 5
78507: PUSH
78508: LD_INT 1
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 4
78517: PUSH
78518: LD_INT 1
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 3
78527: PUSH
78528: LD_INT 0
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 3
78537: PUSH
78538: LD_INT 1
78540: NEG
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 3
78548: PUSH
78549: LD_INT 2
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 5
78559: PUSH
78560: LD_INT 2
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 3
78569: PUSH
78570: LD_INT 3
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 3
78579: PUSH
78580: LD_INT 2
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 4
78589: PUSH
78590: LD_INT 3
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: LD_INT 4
78599: PUSH
78600: LD_INT 4
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 3
78609: PUSH
78610: LD_INT 4
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 2
78619: PUSH
78620: LD_INT 3
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 2
78629: PUSH
78630: LD_INT 2
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 4
78639: PUSH
78640: LD_INT 2
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 2
78649: PUSH
78650: LD_INT 4
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 0
78659: PUSH
78660: LD_INT 4
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 0
78669: PUSH
78670: LD_INT 3
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 1
78679: PUSH
78680: LD_INT 4
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: LD_INT 5
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 0
78699: PUSH
78700: LD_INT 5
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 1
78709: NEG
78710: PUSH
78711: LD_INT 4
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 1
78720: NEG
78721: PUSH
78722: LD_INT 3
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 2
78731: PUSH
78732: LD_INT 5
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 2
78741: NEG
78742: PUSH
78743: LD_INT 3
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 3
78752: NEG
78753: PUSH
78754: LD_INT 0
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 3
78763: NEG
78764: PUSH
78765: LD_INT 1
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 2
78775: NEG
78776: PUSH
78777: LD_INT 0
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 2
78786: NEG
78787: PUSH
78788: LD_INT 1
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 3
78797: NEG
78798: PUSH
78799: LD_INT 1
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 4
78808: NEG
78809: PUSH
78810: LD_INT 0
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 4
78819: NEG
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 4
78831: NEG
78832: PUSH
78833: LD_INT 2
78835: NEG
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 2
78843: NEG
78844: PUSH
78845: LD_INT 2
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 4
78854: NEG
78855: PUSH
78856: LD_INT 4
78858: NEG
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 4
78866: NEG
78867: PUSH
78868: LD_INT 5
78870: NEG
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: LD_INT 3
78878: NEG
78879: PUSH
78880: LD_INT 4
78882: NEG
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 3
78890: NEG
78891: PUSH
78892: LD_INT 3
78894: NEG
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 4
78902: NEG
78903: PUSH
78904: LD_INT 3
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 5
78914: NEG
78915: PUSH
78916: LD_INT 4
78918: NEG
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 5
78926: NEG
78927: PUSH
78928: LD_INT 5
78930: NEG
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PUSH
78936: LD_INT 3
78938: NEG
78939: PUSH
78940: LD_INT 5
78942: NEG
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 5
78950: NEG
78951: PUSH
78952: LD_INT 3
78954: NEG
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79007: LD_ADDR_VAR 0 30
79011: PUSH
79012: LD_INT 4
79014: PUSH
79015: LD_INT 4
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 4
79024: PUSH
79025: LD_INT 3
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 5
79034: PUSH
79035: LD_INT 4
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 5
79044: PUSH
79045: LD_INT 5
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 4
79054: PUSH
79055: LD_INT 5
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 3
79064: PUSH
79065: LD_INT 4
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 3
79074: PUSH
79075: LD_INT 3
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 5
79084: PUSH
79085: LD_INT 3
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 3
79094: PUSH
79095: LD_INT 5
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 0
79104: PUSH
79105: LD_INT 3
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 0
79114: PUSH
79115: LD_INT 2
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 1
79124: PUSH
79125: LD_INT 3
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 1
79134: PUSH
79135: LD_INT 4
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: LD_INT 4
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: LD_INT 3
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: LD_INT 1
79165: NEG
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 2
79176: PUSH
79177: LD_INT 4
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 2
79186: NEG
79187: PUSH
79188: LD_INT 2
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 4
79197: NEG
79198: PUSH
79199: LD_INT 0
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 4
79208: NEG
79209: PUSH
79210: LD_INT 1
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 3
79220: NEG
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: NEG
79232: PUSH
79233: LD_INT 1
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 4
79242: NEG
79243: PUSH
79244: LD_INT 1
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 5
79253: NEG
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 5
79264: NEG
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 5
79276: NEG
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 3
79288: NEG
79289: PUSH
79290: LD_INT 2
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 3
79299: NEG
79300: PUSH
79301: LD_INT 3
79303: NEG
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 3
79311: NEG
79312: PUSH
79313: LD_INT 4
79315: NEG
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 2
79323: NEG
79324: PUSH
79325: LD_INT 3
79327: NEG
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 2
79335: NEG
79336: PUSH
79337: LD_INT 2
79339: NEG
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 3
79347: NEG
79348: PUSH
79349: LD_INT 2
79351: NEG
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 4
79359: NEG
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 4
79371: NEG
79372: PUSH
79373: LD_INT 4
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 2
79383: NEG
79384: PUSH
79385: LD_INT 4
79387: NEG
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 4
79395: NEG
79396: PUSH
79397: LD_INT 2
79399: NEG
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 0
79407: PUSH
79408: LD_INT 4
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 0
79418: PUSH
79419: LD_INT 5
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 4
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 1
79440: PUSH
79441: LD_INT 3
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 0
79451: PUSH
79452: LD_INT 3
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 1
79462: NEG
79463: PUSH
79464: LD_INT 4
79466: NEG
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: PUSH
79472: LD_INT 1
79474: NEG
79475: PUSH
79476: LD_INT 5
79478: NEG
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: LD_INT 2
79486: PUSH
79487: LD_INT 3
79489: NEG
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 2
79497: NEG
79498: PUSH
79499: LD_INT 5
79501: NEG
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79554: LD_ADDR_VAR 0 31
79558: PUSH
79559: LD_INT 0
79561: PUSH
79562: LD_INT 4
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 0
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 1
79581: PUSH
79582: LD_INT 4
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 1
79591: PUSH
79592: LD_INT 5
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 0
79601: PUSH
79602: LD_INT 5
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 1
79611: NEG
79612: PUSH
79613: LD_INT 4
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 1
79622: NEG
79623: PUSH
79624: LD_INT 3
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 2
79633: PUSH
79634: LD_INT 5
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 2
79643: NEG
79644: PUSH
79645: LD_INT 3
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: LD_INT 0
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: LD_INT 1
79669: NEG
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: LD_INT 0
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 2
79688: NEG
79689: PUSH
79690: LD_INT 1
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 3
79699: NEG
79700: PUSH
79701: LD_INT 1
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 4
79710: NEG
79711: PUSH
79712: LD_INT 0
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 4
79721: NEG
79722: PUSH
79723: LD_INT 1
79725: NEG
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 4
79733: NEG
79734: PUSH
79735: LD_INT 2
79737: NEG
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 2
79745: NEG
79746: PUSH
79747: LD_INT 2
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 4
79756: NEG
79757: PUSH
79758: LD_INT 4
79760: NEG
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 4
79768: NEG
79769: PUSH
79770: LD_INT 5
79772: NEG
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 3
79780: NEG
79781: PUSH
79782: LD_INT 4
79784: NEG
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 3
79792: NEG
79793: PUSH
79794: LD_INT 3
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 4
79804: NEG
79805: PUSH
79806: LD_INT 3
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 5
79816: NEG
79817: PUSH
79818: LD_INT 4
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 5
79828: NEG
79829: PUSH
79830: LD_INT 5
79832: NEG
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 3
79840: NEG
79841: PUSH
79842: LD_INT 5
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 5
79852: NEG
79853: PUSH
79854: LD_INT 3
79856: NEG
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: LD_INT 3
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 0
79875: PUSH
79876: LD_INT 4
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 1
79886: PUSH
79887: LD_INT 3
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 1
79897: PUSH
79898: LD_INT 2
79900: NEG
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 0
79908: PUSH
79909: LD_INT 2
79911: NEG
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 1
79919: NEG
79920: PUSH
79921: LD_INT 3
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 1
79931: NEG
79932: PUSH
79933: LD_INT 4
79935: NEG
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 2
79943: PUSH
79944: LD_INT 2
79946: NEG
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 2
79954: NEG
79955: PUSH
79956: LD_INT 4
79958: NEG
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 4
79966: PUSH
79967: LD_INT 0
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 4
79976: PUSH
79977: LD_INT 1
79979: NEG
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 5
79987: PUSH
79988: LD_INT 0
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 5
79997: PUSH
79998: LD_INT 1
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 4
80007: PUSH
80008: LD_INT 1
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 3
80017: PUSH
80018: LD_INT 0
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 3
80027: PUSH
80028: LD_INT 1
80030: NEG
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: LD_INT 2
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 5
80049: PUSH
80050: LD_INT 2
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80104: LD_ADDR_VAR 0 32
80108: PUSH
80109: LD_INT 4
80111: NEG
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 4
80122: NEG
80123: PUSH
80124: LD_INT 1
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 3
80134: NEG
80135: PUSH
80136: LD_INT 0
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 4
80156: NEG
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 5
80167: NEG
80168: PUSH
80169: LD_INT 0
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 5
80178: NEG
80179: PUSH
80180: LD_INT 1
80182: NEG
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 5
80190: NEG
80191: PUSH
80192: LD_INT 2
80194: NEG
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 3
80202: NEG
80203: PUSH
80204: LD_INT 2
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 3
80213: NEG
80214: PUSH
80215: LD_INT 3
80217: NEG
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 3
80225: NEG
80226: PUSH
80227: LD_INT 4
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 2
80237: NEG
80238: PUSH
80239: LD_INT 3
80241: NEG
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: LD_INT 2
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 3
80261: NEG
80262: PUSH
80263: LD_INT 2
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 4
80273: NEG
80274: PUSH
80275: LD_INT 3
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 4
80285: NEG
80286: PUSH
80287: LD_INT 4
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 2
80297: NEG
80298: PUSH
80299: LD_INT 4
80301: NEG
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 4
80309: NEG
80310: PUSH
80311: LD_INT 2
80313: NEG
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: LD_INT 4
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 0
80332: PUSH
80333: LD_INT 5
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 1
80343: PUSH
80344: LD_INT 4
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 1
80354: PUSH
80355: LD_INT 3
80357: NEG
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 0
80365: PUSH
80366: LD_INT 3
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 1
80376: NEG
80377: PUSH
80378: LD_INT 4
80380: NEG
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 1
80388: NEG
80389: PUSH
80390: LD_INT 5
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 2
80400: PUSH
80401: LD_INT 3
80403: NEG
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 2
80411: NEG
80412: PUSH
80413: LD_INT 5
80415: NEG
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 3
80423: PUSH
80424: LD_INT 0
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 3
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 4
80444: PUSH
80445: LD_INT 0
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 4
80454: PUSH
80455: LD_INT 1
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 3
80464: PUSH
80465: LD_INT 1
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 2
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 2
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: LD_INT 2
80498: NEG
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 4
80506: PUSH
80507: LD_INT 2
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: PUSH
80514: LD_INT 4
80516: PUSH
80517: LD_INT 4
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 4
80526: PUSH
80527: LD_INT 3
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 5
80536: PUSH
80537: LD_INT 4
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 5
80546: PUSH
80547: LD_INT 5
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 4
80556: PUSH
80557: LD_INT 5
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 3
80566: PUSH
80567: LD_INT 4
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 3
80576: PUSH
80577: LD_INT 3
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: PUSH
80584: LD_INT 5
80586: PUSH
80587: LD_INT 3
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 3
80596: PUSH
80597: LD_INT 5
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80651: LD_ADDR_VAR 0 33
80655: PUSH
80656: LD_INT 4
80658: NEG
80659: PUSH
80660: LD_INT 4
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 4
80670: NEG
80671: PUSH
80672: LD_INT 5
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 3
80682: NEG
80683: PUSH
80684: LD_INT 4
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 3
80694: NEG
80695: PUSH
80696: LD_INT 3
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 4
80706: NEG
80707: PUSH
80708: LD_INT 3
80710: NEG
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 5
80718: NEG
80719: PUSH
80720: LD_INT 4
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 5
80730: NEG
80731: PUSH
80732: LD_INT 5
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: LD_INT 5
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 5
80754: NEG
80755: PUSH
80756: LD_INT 3
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 0
80766: PUSH
80767: LD_INT 3
80769: NEG
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 0
80777: PUSH
80778: LD_INT 4
80780: NEG
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: LD_INT 3
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: LD_INT 2
80802: NEG
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: LD_INT 2
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: LD_INT 3
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: LD_INT 4
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 2
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 2
80856: NEG
80857: PUSH
80858: LD_INT 4
80860: NEG
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 4
80868: PUSH
80869: LD_INT 0
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 4
80878: PUSH
80879: LD_INT 1
80881: NEG
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 5
80889: PUSH
80890: LD_INT 0
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 5
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 4
80909: PUSH
80910: LD_INT 1
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 3
80919: PUSH
80920: LD_INT 0
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 3
80929: PUSH
80930: LD_INT 1
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 3
80940: PUSH
80941: LD_INT 2
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 5
80951: PUSH
80952: LD_INT 2
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 3
80961: PUSH
80962: LD_INT 3
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 3
80971: PUSH
80972: LD_INT 2
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 4
80981: PUSH
80982: LD_INT 3
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 4
80991: PUSH
80992: LD_INT 4
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 3
81001: PUSH
81002: LD_INT 4
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 2
81011: PUSH
81012: LD_INT 3
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: LD_INT 2
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 4
81031: PUSH
81032: LD_INT 2
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 2
81041: PUSH
81042: LD_INT 4
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 0
81051: PUSH
81052: LD_INT 4
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 0
81061: PUSH
81062: LD_INT 3
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 1
81071: PUSH
81072: LD_INT 4
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 1
81081: PUSH
81082: LD_INT 5
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 0
81091: PUSH
81092: LD_INT 5
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: PUSH
81099: LD_INT 1
81101: NEG
81102: PUSH
81103: LD_INT 4
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 1
81112: NEG
81113: PUSH
81114: LD_INT 3
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 2
81123: PUSH
81124: LD_INT 5
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 2
81133: NEG
81134: PUSH
81135: LD_INT 3
81137: PUSH
81138: EMPTY
81139: LIST
81140: LIST
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81189: LD_ADDR_VAR 0 34
81193: PUSH
81194: LD_INT 0
81196: PUSH
81197: LD_INT 4
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 5
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 1
81218: PUSH
81219: LD_INT 4
81221: NEG
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 1
81229: PUSH
81230: LD_INT 3
81232: NEG
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 0
81240: PUSH
81241: LD_INT 3
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 1
81251: NEG
81252: PUSH
81253: LD_INT 4
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 5
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 2
81275: PUSH
81276: LD_INT 3
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 2
81286: NEG
81287: PUSH
81288: LD_INT 5
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 3
81298: PUSH
81299: LD_INT 0
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 3
81308: PUSH
81309: LD_INT 1
81311: NEG
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 4
81319: PUSH
81320: LD_INT 0
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 4
81329: PUSH
81330: LD_INT 1
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 3
81339: PUSH
81340: LD_INT 1
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: PUSH
81350: LD_INT 0
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 2
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 2
81370: PUSH
81371: LD_INT 2
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 4
81381: PUSH
81382: LD_INT 2
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 4
81391: PUSH
81392: LD_INT 4
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 4
81401: PUSH
81402: LD_INT 3
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 5
81411: PUSH
81412: LD_INT 4
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 5
81421: PUSH
81422: LD_INT 5
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 4
81431: PUSH
81432: LD_INT 5
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 3
81441: PUSH
81442: LD_INT 4
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 3
81451: PUSH
81452: LD_INT 3
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 5
81461: PUSH
81462: LD_INT 3
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 3
81471: PUSH
81472: LD_INT 5
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 3
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 0
81491: PUSH
81492: LD_INT 2
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: PUSH
81502: LD_INT 3
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 1
81511: PUSH
81512: LD_INT 4
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: LD_INT 4
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 1
81531: NEG
81532: PUSH
81533: LD_INT 3
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 1
81542: NEG
81543: PUSH
81544: LD_INT 2
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 2
81553: PUSH
81554: LD_INT 4
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 2
81563: NEG
81564: PUSH
81565: LD_INT 2
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 4
81574: NEG
81575: PUSH
81576: LD_INT 0
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 4
81585: NEG
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 3
81597: NEG
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 3
81608: NEG
81609: PUSH
81610: LD_INT 1
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 4
81619: NEG
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 5
81630: NEG
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 5
81641: NEG
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 5
81653: NEG
81654: PUSH
81655: LD_INT 2
81657: NEG
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 3
81665: NEG
81666: PUSH
81667: LD_INT 2
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: ST_TO_ADDR
// end ; end ;
81721: GO 81724
81723: POP
// case btype of b_depot , b_warehouse :
81724: LD_VAR 0 1
81728: PUSH
81729: LD_INT 0
81731: DOUBLE
81732: EQUAL
81733: IFTRUE 81743
81735: LD_INT 1
81737: DOUBLE
81738: EQUAL
81739: IFTRUE 81743
81741: GO 81944
81743: POP
// case nation of nation_american :
81744: LD_VAR 0 5
81748: PUSH
81749: LD_INT 1
81751: DOUBLE
81752: EQUAL
81753: IFTRUE 81757
81755: GO 81813
81757: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81758: LD_ADDR_VAR 0 9
81762: PUSH
81763: LD_VAR 0 11
81767: PUSH
81768: LD_VAR 0 12
81772: PUSH
81773: LD_VAR 0 13
81777: PUSH
81778: LD_VAR 0 14
81782: PUSH
81783: LD_VAR 0 15
81787: PUSH
81788: LD_VAR 0 16
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: PUSH
81801: LD_VAR 0 4
81805: PUSH
81806: LD_INT 1
81808: PLUS
81809: ARRAY
81810: ST_TO_ADDR
81811: GO 81942
81813: LD_INT 2
81815: DOUBLE
81816: EQUAL
81817: IFTRUE 81821
81819: GO 81877
81821: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81822: LD_ADDR_VAR 0 9
81826: PUSH
81827: LD_VAR 0 17
81831: PUSH
81832: LD_VAR 0 18
81836: PUSH
81837: LD_VAR 0 19
81841: PUSH
81842: LD_VAR 0 20
81846: PUSH
81847: LD_VAR 0 21
81851: PUSH
81852: LD_VAR 0 22
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: PUSH
81865: LD_VAR 0 4
81869: PUSH
81870: LD_INT 1
81872: PLUS
81873: ARRAY
81874: ST_TO_ADDR
81875: GO 81942
81877: LD_INT 3
81879: DOUBLE
81880: EQUAL
81881: IFTRUE 81885
81883: GO 81941
81885: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81886: LD_ADDR_VAR 0 9
81890: PUSH
81891: LD_VAR 0 23
81895: PUSH
81896: LD_VAR 0 24
81900: PUSH
81901: LD_VAR 0 25
81905: PUSH
81906: LD_VAR 0 26
81910: PUSH
81911: LD_VAR 0 27
81915: PUSH
81916: LD_VAR 0 28
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: PUSH
81929: LD_VAR 0 4
81933: PUSH
81934: LD_INT 1
81936: PLUS
81937: ARRAY
81938: ST_TO_ADDR
81939: GO 81942
81941: POP
81942: GO 82497
81944: LD_INT 2
81946: DOUBLE
81947: EQUAL
81948: IFTRUE 81958
81950: LD_INT 3
81952: DOUBLE
81953: EQUAL
81954: IFTRUE 81958
81956: GO 82014
81958: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81959: LD_ADDR_VAR 0 9
81963: PUSH
81964: LD_VAR 0 29
81968: PUSH
81969: LD_VAR 0 30
81973: PUSH
81974: LD_VAR 0 31
81978: PUSH
81979: LD_VAR 0 32
81983: PUSH
81984: LD_VAR 0 33
81988: PUSH
81989: LD_VAR 0 34
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: PUSH
82002: LD_VAR 0 4
82006: PUSH
82007: LD_INT 1
82009: PLUS
82010: ARRAY
82011: ST_TO_ADDR
82012: GO 82497
82014: LD_INT 16
82016: DOUBLE
82017: EQUAL
82018: IFTRUE 82076
82020: LD_INT 17
82022: DOUBLE
82023: EQUAL
82024: IFTRUE 82076
82026: LD_INT 18
82028: DOUBLE
82029: EQUAL
82030: IFTRUE 82076
82032: LD_INT 19
82034: DOUBLE
82035: EQUAL
82036: IFTRUE 82076
82038: LD_INT 22
82040: DOUBLE
82041: EQUAL
82042: IFTRUE 82076
82044: LD_INT 20
82046: DOUBLE
82047: EQUAL
82048: IFTRUE 82076
82050: LD_INT 21
82052: DOUBLE
82053: EQUAL
82054: IFTRUE 82076
82056: LD_INT 23
82058: DOUBLE
82059: EQUAL
82060: IFTRUE 82076
82062: LD_INT 24
82064: DOUBLE
82065: EQUAL
82066: IFTRUE 82076
82068: LD_INT 25
82070: DOUBLE
82071: EQUAL
82072: IFTRUE 82076
82074: GO 82132
82076: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82077: LD_ADDR_VAR 0 9
82081: PUSH
82082: LD_VAR 0 35
82086: PUSH
82087: LD_VAR 0 36
82091: PUSH
82092: LD_VAR 0 37
82096: PUSH
82097: LD_VAR 0 38
82101: PUSH
82102: LD_VAR 0 39
82106: PUSH
82107: LD_VAR 0 40
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: PUSH
82120: LD_VAR 0 4
82124: PUSH
82125: LD_INT 1
82127: PLUS
82128: ARRAY
82129: ST_TO_ADDR
82130: GO 82497
82132: LD_INT 6
82134: DOUBLE
82135: EQUAL
82136: IFTRUE 82188
82138: LD_INT 7
82140: DOUBLE
82141: EQUAL
82142: IFTRUE 82188
82144: LD_INT 8
82146: DOUBLE
82147: EQUAL
82148: IFTRUE 82188
82150: LD_INT 13
82152: DOUBLE
82153: EQUAL
82154: IFTRUE 82188
82156: LD_INT 12
82158: DOUBLE
82159: EQUAL
82160: IFTRUE 82188
82162: LD_INT 15
82164: DOUBLE
82165: EQUAL
82166: IFTRUE 82188
82168: LD_INT 11
82170: DOUBLE
82171: EQUAL
82172: IFTRUE 82188
82174: LD_INT 14
82176: DOUBLE
82177: EQUAL
82178: IFTRUE 82188
82180: LD_INT 10
82182: DOUBLE
82183: EQUAL
82184: IFTRUE 82188
82186: GO 82244
82188: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82189: LD_ADDR_VAR 0 9
82193: PUSH
82194: LD_VAR 0 41
82198: PUSH
82199: LD_VAR 0 42
82203: PUSH
82204: LD_VAR 0 43
82208: PUSH
82209: LD_VAR 0 44
82213: PUSH
82214: LD_VAR 0 45
82218: PUSH
82219: LD_VAR 0 46
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: PUSH
82232: LD_VAR 0 4
82236: PUSH
82237: LD_INT 1
82239: PLUS
82240: ARRAY
82241: ST_TO_ADDR
82242: GO 82497
82244: LD_INT 36
82246: DOUBLE
82247: EQUAL
82248: IFTRUE 82252
82250: GO 82308
82252: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82253: LD_ADDR_VAR 0 9
82257: PUSH
82258: LD_VAR 0 47
82262: PUSH
82263: LD_VAR 0 48
82267: PUSH
82268: LD_VAR 0 49
82272: PUSH
82273: LD_VAR 0 50
82277: PUSH
82278: LD_VAR 0 51
82282: PUSH
82283: LD_VAR 0 52
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: PUSH
82296: LD_VAR 0 4
82300: PUSH
82301: LD_INT 1
82303: PLUS
82304: ARRAY
82305: ST_TO_ADDR
82306: GO 82497
82308: LD_INT 4
82310: DOUBLE
82311: EQUAL
82312: IFTRUE 82334
82314: LD_INT 5
82316: DOUBLE
82317: EQUAL
82318: IFTRUE 82334
82320: LD_INT 34
82322: DOUBLE
82323: EQUAL
82324: IFTRUE 82334
82326: LD_INT 37
82328: DOUBLE
82329: EQUAL
82330: IFTRUE 82334
82332: GO 82390
82334: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82335: LD_ADDR_VAR 0 9
82339: PUSH
82340: LD_VAR 0 53
82344: PUSH
82345: LD_VAR 0 54
82349: PUSH
82350: LD_VAR 0 55
82354: PUSH
82355: LD_VAR 0 56
82359: PUSH
82360: LD_VAR 0 57
82364: PUSH
82365: LD_VAR 0 58
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: PUSH
82378: LD_VAR 0 4
82382: PUSH
82383: LD_INT 1
82385: PLUS
82386: ARRAY
82387: ST_TO_ADDR
82388: GO 82497
82390: LD_INT 31
82392: DOUBLE
82393: EQUAL
82394: IFTRUE 82440
82396: LD_INT 32
82398: DOUBLE
82399: EQUAL
82400: IFTRUE 82440
82402: LD_INT 33
82404: DOUBLE
82405: EQUAL
82406: IFTRUE 82440
82408: LD_INT 27
82410: DOUBLE
82411: EQUAL
82412: IFTRUE 82440
82414: LD_INT 26
82416: DOUBLE
82417: EQUAL
82418: IFTRUE 82440
82420: LD_INT 28
82422: DOUBLE
82423: EQUAL
82424: IFTRUE 82440
82426: LD_INT 29
82428: DOUBLE
82429: EQUAL
82430: IFTRUE 82440
82432: LD_INT 30
82434: DOUBLE
82435: EQUAL
82436: IFTRUE 82440
82438: GO 82496
82440: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82441: LD_ADDR_VAR 0 9
82445: PUSH
82446: LD_VAR 0 59
82450: PUSH
82451: LD_VAR 0 60
82455: PUSH
82456: LD_VAR 0 61
82460: PUSH
82461: LD_VAR 0 62
82465: PUSH
82466: LD_VAR 0 63
82470: PUSH
82471: LD_VAR 0 64
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: PUSH
82484: LD_VAR 0 4
82488: PUSH
82489: LD_INT 1
82491: PLUS
82492: ARRAY
82493: ST_TO_ADDR
82494: GO 82497
82496: POP
// temp_list2 = [ ] ;
82497: LD_ADDR_VAR 0 10
82501: PUSH
82502: EMPTY
82503: ST_TO_ADDR
// for i in temp_list do
82504: LD_ADDR_VAR 0 8
82508: PUSH
82509: LD_VAR 0 9
82513: PUSH
82514: FOR_IN
82515: IFFALSE 82567
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82517: LD_ADDR_VAR 0 10
82521: PUSH
82522: LD_VAR 0 10
82526: PUSH
82527: LD_VAR 0 8
82531: PUSH
82532: LD_INT 1
82534: ARRAY
82535: PUSH
82536: LD_VAR 0 2
82540: PLUS
82541: PUSH
82542: LD_VAR 0 8
82546: PUSH
82547: LD_INT 2
82549: ARRAY
82550: PUSH
82551: LD_VAR 0 3
82555: PLUS
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: EMPTY
82562: LIST
82563: ADD
82564: ST_TO_ADDR
82565: GO 82514
82567: POP
82568: POP
// result = temp_list2 ;
82569: LD_ADDR_VAR 0 7
82573: PUSH
82574: LD_VAR 0 10
82578: ST_TO_ADDR
// end ;
82579: LD_VAR 0 7
82583: RET
// export function EnemyInRange ( unit , dist ) ; begin
82584: LD_INT 0
82586: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82587: LD_ADDR_VAR 0 3
82591: PUSH
82592: LD_VAR 0 1
82596: PPUSH
82597: CALL_OW 255
82601: PPUSH
82602: LD_VAR 0 1
82606: PPUSH
82607: CALL_OW 250
82611: PPUSH
82612: LD_VAR 0 1
82616: PPUSH
82617: CALL_OW 251
82621: PPUSH
82622: LD_VAR 0 2
82626: PPUSH
82627: CALL 56688 0 4
82631: PUSH
82632: LD_INT 4
82634: ARRAY
82635: ST_TO_ADDR
// end ;
82636: LD_VAR 0 3
82640: RET
// export function PlayerSeeMe ( unit ) ; begin
82641: LD_INT 0
82643: PPUSH
// result := See ( your_side , unit ) ;
82644: LD_ADDR_VAR 0 2
82648: PUSH
82649: LD_OWVAR 2
82653: PPUSH
82654: LD_VAR 0 1
82658: PPUSH
82659: CALL_OW 292
82663: ST_TO_ADDR
// end ;
82664: LD_VAR 0 2
82668: RET
// export function ReverseDir ( unit ) ; begin
82669: LD_INT 0
82671: PPUSH
// if not unit then
82672: LD_VAR 0 1
82676: NOT
82677: IFFALSE 82681
// exit ;
82679: GO 82704
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82681: LD_ADDR_VAR 0 2
82685: PUSH
82686: LD_VAR 0 1
82690: PPUSH
82691: CALL_OW 254
82695: PUSH
82696: LD_INT 3
82698: PLUS
82699: PUSH
82700: LD_INT 6
82702: MOD
82703: ST_TO_ADDR
// end ;
82704: LD_VAR 0 2
82708: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82709: LD_INT 0
82711: PPUSH
82712: PPUSH
82713: PPUSH
82714: PPUSH
82715: PPUSH
// if not hexes then
82716: LD_VAR 0 2
82720: NOT
82721: IFFALSE 82725
// exit ;
82723: GO 82873
// dist := 9999 ;
82725: LD_ADDR_VAR 0 5
82729: PUSH
82730: LD_INT 9999
82732: ST_TO_ADDR
// for i = 1 to hexes do
82733: LD_ADDR_VAR 0 4
82737: PUSH
82738: DOUBLE
82739: LD_INT 1
82741: DEC
82742: ST_TO_ADDR
82743: LD_VAR 0 2
82747: PUSH
82748: FOR_TO
82749: IFFALSE 82861
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82751: LD_VAR 0 1
82755: PPUSH
82756: LD_VAR 0 2
82760: PUSH
82761: LD_VAR 0 4
82765: ARRAY
82766: PUSH
82767: LD_INT 1
82769: ARRAY
82770: PPUSH
82771: LD_VAR 0 2
82775: PUSH
82776: LD_VAR 0 4
82780: ARRAY
82781: PUSH
82782: LD_INT 2
82784: ARRAY
82785: PPUSH
82786: CALL_OW 297
82790: PUSH
82791: LD_VAR 0 5
82795: LESS
82796: IFFALSE 82859
// begin hex := hexes [ i ] ;
82798: LD_ADDR_VAR 0 7
82802: PUSH
82803: LD_VAR 0 2
82807: PUSH
82808: LD_VAR 0 4
82812: ARRAY
82813: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82814: LD_ADDR_VAR 0 5
82818: PUSH
82819: LD_VAR 0 1
82823: PPUSH
82824: LD_VAR 0 2
82828: PUSH
82829: LD_VAR 0 4
82833: ARRAY
82834: PUSH
82835: LD_INT 1
82837: ARRAY
82838: PPUSH
82839: LD_VAR 0 2
82843: PUSH
82844: LD_VAR 0 4
82848: ARRAY
82849: PUSH
82850: LD_INT 2
82852: ARRAY
82853: PPUSH
82854: CALL_OW 297
82858: ST_TO_ADDR
// end ; end ;
82859: GO 82748
82861: POP
82862: POP
// result := hex ;
82863: LD_ADDR_VAR 0 3
82867: PUSH
82868: LD_VAR 0 7
82872: ST_TO_ADDR
// end ;
82873: LD_VAR 0 3
82877: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82878: LD_INT 0
82880: PPUSH
82881: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82882: LD_VAR 0 1
82886: NOT
82887: PUSH
82888: LD_VAR 0 1
82892: PUSH
82893: LD_INT 21
82895: PUSH
82896: LD_INT 2
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 23
82905: PUSH
82906: LD_INT 2
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PPUSH
82917: CALL_OW 69
82921: IN
82922: NOT
82923: OR
82924: IFFALSE 82928
// exit ;
82926: GO 82975
// for i = 1 to 3 do
82928: LD_ADDR_VAR 0 3
82932: PUSH
82933: DOUBLE
82934: LD_INT 1
82936: DEC
82937: ST_TO_ADDR
82938: LD_INT 3
82940: PUSH
82941: FOR_TO
82942: IFFALSE 82973
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82944: LD_VAR 0 1
82948: PPUSH
82949: CALL_OW 250
82953: PPUSH
82954: LD_VAR 0 1
82958: PPUSH
82959: CALL_OW 251
82963: PPUSH
82964: LD_INT 1
82966: PPUSH
82967: CALL_OW 453
82971: GO 82941
82973: POP
82974: POP
// end ;
82975: LD_VAR 0 2
82979: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82980: LD_INT 0
82982: PPUSH
82983: PPUSH
82984: PPUSH
82985: PPUSH
82986: PPUSH
82987: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82988: LD_VAR 0 1
82992: NOT
82993: PUSH
82994: LD_VAR 0 2
82998: NOT
82999: OR
83000: PUSH
83001: LD_VAR 0 1
83005: PPUSH
83006: CALL_OW 314
83010: OR
83011: IFFALSE 83015
// exit ;
83013: GO 83456
// x := GetX ( enemy_unit ) ;
83015: LD_ADDR_VAR 0 7
83019: PUSH
83020: LD_VAR 0 2
83024: PPUSH
83025: CALL_OW 250
83029: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83030: LD_ADDR_VAR 0 8
83034: PUSH
83035: LD_VAR 0 2
83039: PPUSH
83040: CALL_OW 251
83044: ST_TO_ADDR
// if not x or not y then
83045: LD_VAR 0 7
83049: NOT
83050: PUSH
83051: LD_VAR 0 8
83055: NOT
83056: OR
83057: IFFALSE 83061
// exit ;
83059: GO 83456
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83061: LD_ADDR_VAR 0 6
83065: PUSH
83066: LD_VAR 0 7
83070: PPUSH
83071: LD_INT 0
83073: PPUSH
83074: LD_INT 4
83076: PPUSH
83077: CALL_OW 272
83081: PUSH
83082: LD_VAR 0 8
83086: PPUSH
83087: LD_INT 0
83089: PPUSH
83090: LD_INT 4
83092: PPUSH
83093: CALL_OW 273
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_VAR 0 7
83106: PPUSH
83107: LD_INT 1
83109: PPUSH
83110: LD_INT 4
83112: PPUSH
83113: CALL_OW 272
83117: PUSH
83118: LD_VAR 0 8
83122: PPUSH
83123: LD_INT 1
83125: PPUSH
83126: LD_INT 4
83128: PPUSH
83129: CALL_OW 273
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_VAR 0 7
83142: PPUSH
83143: LD_INT 2
83145: PPUSH
83146: LD_INT 4
83148: PPUSH
83149: CALL_OW 272
83153: PUSH
83154: LD_VAR 0 8
83158: PPUSH
83159: LD_INT 2
83161: PPUSH
83162: LD_INT 4
83164: PPUSH
83165: CALL_OW 273
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_VAR 0 7
83178: PPUSH
83179: LD_INT 3
83181: PPUSH
83182: LD_INT 4
83184: PPUSH
83185: CALL_OW 272
83189: PUSH
83190: LD_VAR 0 8
83194: PPUSH
83195: LD_INT 3
83197: PPUSH
83198: LD_INT 4
83200: PPUSH
83201: CALL_OW 273
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_VAR 0 7
83214: PPUSH
83215: LD_INT 4
83217: PPUSH
83218: LD_INT 4
83220: PPUSH
83221: CALL_OW 272
83225: PUSH
83226: LD_VAR 0 8
83230: PPUSH
83231: LD_INT 4
83233: PPUSH
83234: LD_INT 4
83236: PPUSH
83237: CALL_OW 273
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PUSH
83246: LD_VAR 0 7
83250: PPUSH
83251: LD_INT 5
83253: PPUSH
83254: LD_INT 4
83256: PPUSH
83257: CALL_OW 272
83261: PUSH
83262: LD_VAR 0 8
83266: PPUSH
83267: LD_INT 5
83269: PPUSH
83270: LD_INT 4
83272: PPUSH
83273: CALL_OW 273
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: ST_TO_ADDR
// for i = tmp downto 1 do
83290: LD_ADDR_VAR 0 4
83294: PUSH
83295: DOUBLE
83296: LD_VAR 0 6
83300: INC
83301: ST_TO_ADDR
83302: LD_INT 1
83304: PUSH
83305: FOR_DOWNTO
83306: IFFALSE 83407
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83308: LD_VAR 0 6
83312: PUSH
83313: LD_VAR 0 4
83317: ARRAY
83318: PUSH
83319: LD_INT 1
83321: ARRAY
83322: PPUSH
83323: LD_VAR 0 6
83327: PUSH
83328: LD_VAR 0 4
83332: ARRAY
83333: PUSH
83334: LD_INT 2
83336: ARRAY
83337: PPUSH
83338: CALL_OW 488
83342: NOT
83343: PUSH
83344: LD_VAR 0 6
83348: PUSH
83349: LD_VAR 0 4
83353: ARRAY
83354: PUSH
83355: LD_INT 1
83357: ARRAY
83358: PPUSH
83359: LD_VAR 0 6
83363: PUSH
83364: LD_VAR 0 4
83368: ARRAY
83369: PUSH
83370: LD_INT 2
83372: ARRAY
83373: PPUSH
83374: CALL_OW 428
83378: PUSH
83379: LD_INT 0
83381: NONEQUAL
83382: OR
83383: IFFALSE 83405
// tmp := Delete ( tmp , i ) ;
83385: LD_ADDR_VAR 0 6
83389: PUSH
83390: LD_VAR 0 6
83394: PPUSH
83395: LD_VAR 0 4
83399: PPUSH
83400: CALL_OW 3
83404: ST_TO_ADDR
83405: GO 83305
83407: POP
83408: POP
// j := GetClosestHex ( unit , tmp ) ;
83409: LD_ADDR_VAR 0 5
83413: PUSH
83414: LD_VAR 0 1
83418: PPUSH
83419: LD_VAR 0 6
83423: PPUSH
83424: CALL 82709 0 2
83428: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83429: LD_VAR 0 1
83433: PPUSH
83434: LD_VAR 0 5
83438: PUSH
83439: LD_INT 1
83441: ARRAY
83442: PPUSH
83443: LD_VAR 0 5
83447: PUSH
83448: LD_INT 2
83450: ARRAY
83451: PPUSH
83452: CALL_OW 111
// end ;
83456: LD_VAR 0 3
83460: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83461: LD_INT 0
83463: PPUSH
83464: PPUSH
83465: PPUSH
// uc_side = 0 ;
83466: LD_ADDR_OWVAR 20
83470: PUSH
83471: LD_INT 0
83473: ST_TO_ADDR
// uc_nation = 0 ;
83474: LD_ADDR_OWVAR 21
83478: PUSH
83479: LD_INT 0
83481: ST_TO_ADDR
// InitHc_All ( ) ;
83482: CALL_OW 584
// InitVc ;
83486: CALL_OW 20
// if mastodonts then
83490: LD_VAR 0 6
83494: IFFALSE 83561
// for i = 1 to mastodonts do
83496: LD_ADDR_VAR 0 11
83500: PUSH
83501: DOUBLE
83502: LD_INT 1
83504: DEC
83505: ST_TO_ADDR
83506: LD_VAR 0 6
83510: PUSH
83511: FOR_TO
83512: IFFALSE 83559
// begin vc_chassis := 31 ;
83514: LD_ADDR_OWVAR 37
83518: PUSH
83519: LD_INT 31
83521: ST_TO_ADDR
// vc_control := control_rider ;
83522: LD_ADDR_OWVAR 38
83526: PUSH
83527: LD_INT 4
83529: ST_TO_ADDR
// animal := CreateVehicle ;
83530: LD_ADDR_VAR 0 12
83534: PUSH
83535: CALL_OW 45
83539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83540: LD_VAR 0 12
83544: PPUSH
83545: LD_VAR 0 8
83549: PPUSH
83550: LD_INT 0
83552: PPUSH
83553: CALL 85749 0 3
// end ;
83557: GO 83511
83559: POP
83560: POP
// if horses then
83561: LD_VAR 0 5
83565: IFFALSE 83632
// for i = 1 to horses do
83567: LD_ADDR_VAR 0 11
83571: PUSH
83572: DOUBLE
83573: LD_INT 1
83575: DEC
83576: ST_TO_ADDR
83577: LD_VAR 0 5
83581: PUSH
83582: FOR_TO
83583: IFFALSE 83630
// begin hc_class := 21 ;
83585: LD_ADDR_OWVAR 28
83589: PUSH
83590: LD_INT 21
83592: ST_TO_ADDR
// hc_gallery :=  ;
83593: LD_ADDR_OWVAR 33
83597: PUSH
83598: LD_STRING 
83600: ST_TO_ADDR
// animal := CreateHuman ;
83601: LD_ADDR_VAR 0 12
83605: PUSH
83606: CALL_OW 44
83610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83611: LD_VAR 0 12
83615: PPUSH
83616: LD_VAR 0 8
83620: PPUSH
83621: LD_INT 0
83623: PPUSH
83624: CALL 85749 0 3
// end ;
83628: GO 83582
83630: POP
83631: POP
// if birds then
83632: LD_VAR 0 1
83636: IFFALSE 83703
// for i = 1 to birds do
83638: LD_ADDR_VAR 0 11
83642: PUSH
83643: DOUBLE
83644: LD_INT 1
83646: DEC
83647: ST_TO_ADDR
83648: LD_VAR 0 1
83652: PUSH
83653: FOR_TO
83654: IFFALSE 83701
// begin hc_class = 18 ;
83656: LD_ADDR_OWVAR 28
83660: PUSH
83661: LD_INT 18
83663: ST_TO_ADDR
// hc_gallery =  ;
83664: LD_ADDR_OWVAR 33
83668: PUSH
83669: LD_STRING 
83671: ST_TO_ADDR
// animal := CreateHuman ;
83672: LD_ADDR_VAR 0 12
83676: PUSH
83677: CALL_OW 44
83681: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83682: LD_VAR 0 12
83686: PPUSH
83687: LD_VAR 0 8
83691: PPUSH
83692: LD_INT 0
83694: PPUSH
83695: CALL 85749 0 3
// end ;
83699: GO 83653
83701: POP
83702: POP
// if tigers then
83703: LD_VAR 0 2
83707: IFFALSE 83791
// for i = 1 to tigers do
83709: LD_ADDR_VAR 0 11
83713: PUSH
83714: DOUBLE
83715: LD_INT 1
83717: DEC
83718: ST_TO_ADDR
83719: LD_VAR 0 2
83723: PUSH
83724: FOR_TO
83725: IFFALSE 83789
// begin hc_class = class_tiger ;
83727: LD_ADDR_OWVAR 28
83731: PUSH
83732: LD_INT 14
83734: ST_TO_ADDR
// hc_gallery =  ;
83735: LD_ADDR_OWVAR 33
83739: PUSH
83740: LD_STRING 
83742: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83743: LD_ADDR_OWVAR 35
83747: PUSH
83748: LD_INT 7
83750: NEG
83751: PPUSH
83752: LD_INT 7
83754: PPUSH
83755: CALL_OW 12
83759: ST_TO_ADDR
// animal := CreateHuman ;
83760: LD_ADDR_VAR 0 12
83764: PUSH
83765: CALL_OW 44
83769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83770: LD_VAR 0 12
83774: PPUSH
83775: LD_VAR 0 8
83779: PPUSH
83780: LD_INT 0
83782: PPUSH
83783: CALL 85749 0 3
// end ;
83787: GO 83724
83789: POP
83790: POP
// if apemans then
83791: LD_VAR 0 3
83795: IFFALSE 83918
// for i = 1 to apemans do
83797: LD_ADDR_VAR 0 11
83801: PUSH
83802: DOUBLE
83803: LD_INT 1
83805: DEC
83806: ST_TO_ADDR
83807: LD_VAR 0 3
83811: PUSH
83812: FOR_TO
83813: IFFALSE 83916
// begin hc_class = class_apeman ;
83815: LD_ADDR_OWVAR 28
83819: PUSH
83820: LD_INT 12
83822: ST_TO_ADDR
// hc_gallery =  ;
83823: LD_ADDR_OWVAR 33
83827: PUSH
83828: LD_STRING 
83830: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83831: LD_ADDR_OWVAR 35
83835: PUSH
83836: LD_INT 5
83838: NEG
83839: PPUSH
83840: LD_INT 5
83842: PPUSH
83843: CALL_OW 12
83847: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83848: LD_ADDR_OWVAR 31
83852: PUSH
83853: LD_INT 1
83855: PPUSH
83856: LD_INT 3
83858: PPUSH
83859: CALL_OW 12
83863: PUSH
83864: LD_INT 1
83866: PPUSH
83867: LD_INT 3
83869: PPUSH
83870: CALL_OW 12
83874: PUSH
83875: LD_INT 0
83877: PUSH
83878: LD_INT 0
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: ST_TO_ADDR
// animal := CreateHuman ;
83887: LD_ADDR_VAR 0 12
83891: PUSH
83892: CALL_OW 44
83896: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83897: LD_VAR 0 12
83901: PPUSH
83902: LD_VAR 0 8
83906: PPUSH
83907: LD_INT 0
83909: PPUSH
83910: CALL 85749 0 3
// end ;
83914: GO 83812
83916: POP
83917: POP
// if enchidnas then
83918: LD_VAR 0 4
83922: IFFALSE 83989
// for i = 1 to enchidnas do
83924: LD_ADDR_VAR 0 11
83928: PUSH
83929: DOUBLE
83930: LD_INT 1
83932: DEC
83933: ST_TO_ADDR
83934: LD_VAR 0 4
83938: PUSH
83939: FOR_TO
83940: IFFALSE 83987
// begin hc_class = 13 ;
83942: LD_ADDR_OWVAR 28
83946: PUSH
83947: LD_INT 13
83949: ST_TO_ADDR
// hc_gallery =  ;
83950: LD_ADDR_OWVAR 33
83954: PUSH
83955: LD_STRING 
83957: ST_TO_ADDR
// animal := CreateHuman ;
83958: LD_ADDR_VAR 0 12
83962: PUSH
83963: CALL_OW 44
83967: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83968: LD_VAR 0 12
83972: PPUSH
83973: LD_VAR 0 8
83977: PPUSH
83978: LD_INT 0
83980: PPUSH
83981: CALL 85749 0 3
// end ;
83985: GO 83939
83987: POP
83988: POP
// if fishes then
83989: LD_VAR 0 7
83993: IFFALSE 84060
// for i = 1 to fishes do
83995: LD_ADDR_VAR 0 11
83999: PUSH
84000: DOUBLE
84001: LD_INT 1
84003: DEC
84004: ST_TO_ADDR
84005: LD_VAR 0 7
84009: PUSH
84010: FOR_TO
84011: IFFALSE 84058
// begin hc_class = 20 ;
84013: LD_ADDR_OWVAR 28
84017: PUSH
84018: LD_INT 20
84020: ST_TO_ADDR
// hc_gallery =  ;
84021: LD_ADDR_OWVAR 33
84025: PUSH
84026: LD_STRING 
84028: ST_TO_ADDR
// animal := CreateHuman ;
84029: LD_ADDR_VAR 0 12
84033: PUSH
84034: CALL_OW 44
84038: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84039: LD_VAR 0 12
84043: PPUSH
84044: LD_VAR 0 9
84048: PPUSH
84049: LD_INT 0
84051: PPUSH
84052: CALL 85749 0 3
// end ;
84056: GO 84010
84058: POP
84059: POP
// end ;
84060: LD_VAR 0 10
84064: RET
// export function WantHeal ( sci , unit ) ; begin
84065: LD_INT 0
84067: PPUSH
// if GetTaskList ( sci ) > 0 then
84068: LD_VAR 0 1
84072: PPUSH
84073: CALL_OW 437
84077: PUSH
84078: LD_INT 0
84080: GREATER
84081: IFFALSE 84151
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84083: LD_VAR 0 1
84087: PPUSH
84088: CALL_OW 437
84092: PUSH
84093: LD_INT 1
84095: ARRAY
84096: PUSH
84097: LD_INT 1
84099: ARRAY
84100: PUSH
84101: LD_STRING l
84103: EQUAL
84104: PUSH
84105: LD_VAR 0 1
84109: PPUSH
84110: CALL_OW 437
84114: PUSH
84115: LD_INT 1
84117: ARRAY
84118: PUSH
84119: LD_INT 4
84121: ARRAY
84122: PUSH
84123: LD_VAR 0 2
84127: EQUAL
84128: AND
84129: IFFALSE 84141
// result := true else
84131: LD_ADDR_VAR 0 3
84135: PUSH
84136: LD_INT 1
84138: ST_TO_ADDR
84139: GO 84149
// result := false ;
84141: LD_ADDR_VAR 0 3
84145: PUSH
84146: LD_INT 0
84148: ST_TO_ADDR
// end else
84149: GO 84159
// result := false ;
84151: LD_ADDR_VAR 0 3
84155: PUSH
84156: LD_INT 0
84158: ST_TO_ADDR
// end ;
84159: LD_VAR 0 3
84163: RET
// export function HealTarget ( sci ) ; begin
84164: LD_INT 0
84166: PPUSH
// if not sci then
84167: LD_VAR 0 1
84171: NOT
84172: IFFALSE 84176
// exit ;
84174: GO 84241
// result := 0 ;
84176: LD_ADDR_VAR 0 2
84180: PUSH
84181: LD_INT 0
84183: ST_TO_ADDR
// if GetTaskList ( sci ) then
84184: LD_VAR 0 1
84188: PPUSH
84189: CALL_OW 437
84193: IFFALSE 84241
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84195: LD_VAR 0 1
84199: PPUSH
84200: CALL_OW 437
84204: PUSH
84205: LD_INT 1
84207: ARRAY
84208: PUSH
84209: LD_INT 1
84211: ARRAY
84212: PUSH
84213: LD_STRING l
84215: EQUAL
84216: IFFALSE 84241
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84218: LD_ADDR_VAR 0 2
84222: PUSH
84223: LD_VAR 0 1
84227: PPUSH
84228: CALL_OW 437
84232: PUSH
84233: LD_INT 1
84235: ARRAY
84236: PUSH
84237: LD_INT 4
84239: ARRAY
84240: ST_TO_ADDR
// end ;
84241: LD_VAR 0 2
84245: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84246: LD_INT 0
84248: PPUSH
84249: PPUSH
84250: PPUSH
84251: PPUSH
// if not base_units then
84252: LD_VAR 0 1
84256: NOT
84257: IFFALSE 84261
// exit ;
84259: GO 84348
// result := false ;
84261: LD_ADDR_VAR 0 2
84265: PUSH
84266: LD_INT 0
84268: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84269: LD_ADDR_VAR 0 5
84273: PUSH
84274: LD_VAR 0 1
84278: PPUSH
84279: LD_INT 21
84281: PUSH
84282: LD_INT 3
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PPUSH
84289: CALL_OW 72
84293: ST_TO_ADDR
// if not tmp then
84294: LD_VAR 0 5
84298: NOT
84299: IFFALSE 84303
// exit ;
84301: GO 84348
// for i in tmp do
84303: LD_ADDR_VAR 0 3
84307: PUSH
84308: LD_VAR 0 5
84312: PUSH
84313: FOR_IN
84314: IFFALSE 84346
// begin result := EnemyInRange ( i , 22 ) ;
84316: LD_ADDR_VAR 0 2
84320: PUSH
84321: LD_VAR 0 3
84325: PPUSH
84326: LD_INT 22
84328: PPUSH
84329: CALL 82584 0 2
84333: ST_TO_ADDR
// if result then
84334: LD_VAR 0 2
84338: IFFALSE 84344
// exit ;
84340: POP
84341: POP
84342: GO 84348
// end ;
84344: GO 84313
84346: POP
84347: POP
// end ;
84348: LD_VAR 0 2
84352: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84353: LD_INT 0
84355: PPUSH
84356: PPUSH
// if not units then
84357: LD_VAR 0 1
84361: NOT
84362: IFFALSE 84366
// exit ;
84364: GO 84436
// result := [ ] ;
84366: LD_ADDR_VAR 0 3
84370: PUSH
84371: EMPTY
84372: ST_TO_ADDR
// for i in units do
84373: LD_ADDR_VAR 0 4
84377: PUSH
84378: LD_VAR 0 1
84382: PUSH
84383: FOR_IN
84384: IFFALSE 84434
// if GetTag ( i ) = tag then
84386: LD_VAR 0 4
84390: PPUSH
84391: CALL_OW 110
84395: PUSH
84396: LD_VAR 0 2
84400: EQUAL
84401: IFFALSE 84432
// result := Insert ( result , result + 1 , i ) ;
84403: LD_ADDR_VAR 0 3
84407: PUSH
84408: LD_VAR 0 3
84412: PPUSH
84413: LD_VAR 0 3
84417: PUSH
84418: LD_INT 1
84420: PLUS
84421: PPUSH
84422: LD_VAR 0 4
84426: PPUSH
84427: CALL_OW 2
84431: ST_TO_ADDR
84432: GO 84383
84434: POP
84435: POP
// end ;
84436: LD_VAR 0 3
84440: RET
// export function IsDriver ( un ) ; begin
84441: LD_INT 0
84443: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84444: LD_ADDR_VAR 0 2
84448: PUSH
84449: LD_VAR 0 1
84453: PUSH
84454: LD_INT 55
84456: PUSH
84457: EMPTY
84458: LIST
84459: PPUSH
84460: CALL_OW 69
84464: IN
84465: ST_TO_ADDR
// end ;
84466: LD_VAR 0 2
84470: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84471: LD_INT 0
84473: PPUSH
84474: PPUSH
// list := [ ] ;
84475: LD_ADDR_VAR 0 5
84479: PUSH
84480: EMPTY
84481: ST_TO_ADDR
// case d of 0 :
84482: LD_VAR 0 3
84486: PUSH
84487: LD_INT 0
84489: DOUBLE
84490: EQUAL
84491: IFTRUE 84495
84493: GO 84628
84495: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84496: LD_ADDR_VAR 0 5
84500: PUSH
84501: LD_VAR 0 1
84505: PUSH
84506: LD_INT 4
84508: MINUS
84509: PUSH
84510: LD_VAR 0 2
84514: PUSH
84515: LD_INT 4
84517: MINUS
84518: PUSH
84519: LD_INT 2
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: LIST
84526: PUSH
84527: LD_VAR 0 1
84531: PUSH
84532: LD_INT 3
84534: MINUS
84535: PUSH
84536: LD_VAR 0 2
84540: PUSH
84541: LD_INT 1
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: LIST
84548: PUSH
84549: LD_VAR 0 1
84553: PUSH
84554: LD_INT 4
84556: PLUS
84557: PUSH
84558: LD_VAR 0 2
84562: PUSH
84563: LD_INT 4
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: LIST
84570: PUSH
84571: LD_VAR 0 1
84575: PUSH
84576: LD_INT 3
84578: PLUS
84579: PUSH
84580: LD_VAR 0 2
84584: PUSH
84585: LD_INT 3
84587: PLUS
84588: PUSH
84589: LD_INT 5
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: LIST
84596: PUSH
84597: LD_VAR 0 1
84601: PUSH
84602: LD_VAR 0 2
84606: PUSH
84607: LD_INT 4
84609: PLUS
84610: PUSH
84611: LD_INT 0
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: LIST
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: ST_TO_ADDR
// end ; 1 :
84626: GO 85326
84628: LD_INT 1
84630: DOUBLE
84631: EQUAL
84632: IFTRUE 84636
84634: GO 84769
84636: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84637: LD_ADDR_VAR 0 5
84641: PUSH
84642: LD_VAR 0 1
84646: PUSH
84647: LD_VAR 0 2
84651: PUSH
84652: LD_INT 4
84654: MINUS
84655: PUSH
84656: LD_INT 3
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: LIST
84663: PUSH
84664: LD_VAR 0 1
84668: PUSH
84669: LD_INT 3
84671: MINUS
84672: PUSH
84673: LD_VAR 0 2
84677: PUSH
84678: LD_INT 3
84680: MINUS
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: LIST
84689: PUSH
84690: LD_VAR 0 1
84694: PUSH
84695: LD_INT 4
84697: MINUS
84698: PUSH
84699: LD_VAR 0 2
84703: PUSH
84704: LD_INT 1
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: LIST
84711: PUSH
84712: LD_VAR 0 1
84716: PUSH
84717: LD_VAR 0 2
84721: PUSH
84722: LD_INT 3
84724: PLUS
84725: PUSH
84726: LD_INT 0
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: LIST
84733: PUSH
84734: LD_VAR 0 1
84738: PUSH
84739: LD_INT 4
84741: PLUS
84742: PUSH
84743: LD_VAR 0 2
84747: PUSH
84748: LD_INT 4
84750: PLUS
84751: PUSH
84752: LD_INT 5
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: LIST
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: ST_TO_ADDR
// end ; 2 :
84767: GO 85326
84769: LD_INT 2
84771: DOUBLE
84772: EQUAL
84773: IFTRUE 84777
84775: GO 84906
84777: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84778: LD_ADDR_VAR 0 5
84782: PUSH
84783: LD_VAR 0 1
84787: PUSH
84788: LD_VAR 0 2
84792: PUSH
84793: LD_INT 3
84795: MINUS
84796: PUSH
84797: LD_INT 3
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: LIST
84804: PUSH
84805: LD_VAR 0 1
84809: PUSH
84810: LD_INT 4
84812: PLUS
84813: PUSH
84814: LD_VAR 0 2
84818: PUSH
84819: LD_INT 4
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: LIST
84826: PUSH
84827: LD_VAR 0 1
84831: PUSH
84832: LD_VAR 0 2
84836: PUSH
84837: LD_INT 4
84839: PLUS
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: LIST
84848: PUSH
84849: LD_VAR 0 1
84853: PUSH
84854: LD_INT 3
84856: MINUS
84857: PUSH
84858: LD_VAR 0 2
84862: PUSH
84863: LD_INT 1
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: LIST
84870: PUSH
84871: LD_VAR 0 1
84875: PUSH
84876: LD_INT 4
84878: MINUS
84879: PUSH
84880: LD_VAR 0 2
84884: PUSH
84885: LD_INT 4
84887: MINUS
84888: PUSH
84889: LD_INT 2
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: LIST
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: ST_TO_ADDR
// end ; 3 :
84904: GO 85326
84906: LD_INT 3
84908: DOUBLE
84909: EQUAL
84910: IFTRUE 84914
84912: GO 85047
84914: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84915: LD_ADDR_VAR 0 5
84919: PUSH
84920: LD_VAR 0 1
84924: PUSH
84925: LD_INT 3
84927: PLUS
84928: PUSH
84929: LD_VAR 0 2
84933: PUSH
84934: LD_INT 4
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: LIST
84941: PUSH
84942: LD_VAR 0 1
84946: PUSH
84947: LD_INT 4
84949: PLUS
84950: PUSH
84951: LD_VAR 0 2
84955: PUSH
84956: LD_INT 4
84958: PLUS
84959: PUSH
84960: LD_INT 5
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: LIST
84967: PUSH
84968: LD_VAR 0 1
84972: PUSH
84973: LD_INT 4
84975: MINUS
84976: PUSH
84977: LD_VAR 0 2
84981: PUSH
84982: LD_INT 1
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: LIST
84989: PUSH
84990: LD_VAR 0 1
84994: PUSH
84995: LD_VAR 0 2
84999: PUSH
85000: LD_INT 4
85002: MINUS
85003: PUSH
85004: LD_INT 3
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: LIST
85011: PUSH
85012: LD_VAR 0 1
85016: PUSH
85017: LD_INT 3
85019: MINUS
85020: PUSH
85021: LD_VAR 0 2
85025: PUSH
85026: LD_INT 3
85028: MINUS
85029: PUSH
85030: LD_INT 2
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: LIST
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: ST_TO_ADDR
// end ; 4 :
85045: GO 85326
85047: LD_INT 4
85049: DOUBLE
85050: EQUAL
85051: IFTRUE 85055
85053: GO 85188
85055: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85056: LD_ADDR_VAR 0 5
85060: PUSH
85061: LD_VAR 0 1
85065: PUSH
85066: LD_VAR 0 2
85070: PUSH
85071: LD_INT 4
85073: PLUS
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: LIST
85082: PUSH
85083: LD_VAR 0 1
85087: PUSH
85088: LD_INT 3
85090: PLUS
85091: PUSH
85092: LD_VAR 0 2
85096: PUSH
85097: LD_INT 3
85099: PLUS
85100: PUSH
85101: LD_INT 5
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: LIST
85108: PUSH
85109: LD_VAR 0 1
85113: PUSH
85114: LD_INT 4
85116: PLUS
85117: PUSH
85118: LD_VAR 0 2
85122: PUSH
85123: LD_INT 4
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: LIST
85130: PUSH
85131: LD_VAR 0 1
85135: PUSH
85136: LD_VAR 0 2
85140: PUSH
85141: LD_INT 3
85143: MINUS
85144: PUSH
85145: LD_INT 3
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: PUSH
85153: LD_VAR 0 1
85157: PUSH
85158: LD_INT 4
85160: MINUS
85161: PUSH
85162: LD_VAR 0 2
85166: PUSH
85167: LD_INT 4
85169: MINUS
85170: PUSH
85171: LD_INT 2
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: LIST
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: ST_TO_ADDR
// end ; 5 :
85186: GO 85326
85188: LD_INT 5
85190: DOUBLE
85191: EQUAL
85192: IFTRUE 85196
85194: GO 85325
85196: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85197: LD_ADDR_VAR 0 5
85201: PUSH
85202: LD_VAR 0 1
85206: PUSH
85207: LD_INT 4
85209: MINUS
85210: PUSH
85211: LD_VAR 0 2
85215: PUSH
85216: LD_INT 1
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: LIST
85223: PUSH
85224: LD_VAR 0 1
85228: PUSH
85229: LD_VAR 0 2
85233: PUSH
85234: LD_INT 4
85236: MINUS
85237: PUSH
85238: LD_INT 3
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: LIST
85245: PUSH
85246: LD_VAR 0 1
85250: PUSH
85251: LD_INT 4
85253: PLUS
85254: PUSH
85255: LD_VAR 0 2
85259: PUSH
85260: LD_INT 4
85262: PLUS
85263: PUSH
85264: LD_INT 5
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: LIST
85271: PUSH
85272: LD_VAR 0 1
85276: PUSH
85277: LD_INT 3
85279: PLUS
85280: PUSH
85281: LD_VAR 0 2
85285: PUSH
85286: LD_INT 4
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: PUSH
85294: LD_VAR 0 1
85298: PUSH
85299: LD_VAR 0 2
85303: PUSH
85304: LD_INT 3
85306: PLUS
85307: PUSH
85308: LD_INT 0
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: LIST
85315: PUSH
85316: EMPTY
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: ST_TO_ADDR
// end ; end ;
85323: GO 85326
85325: POP
// result := list ;
85326: LD_ADDR_VAR 0 4
85330: PUSH
85331: LD_VAR 0 5
85335: ST_TO_ADDR
// end ;
85336: LD_VAR 0 4
85340: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85341: LD_INT 0
85343: PPUSH
85344: PPUSH
85345: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85346: LD_VAR 0 1
85350: NOT
85351: PUSH
85352: LD_VAR 0 2
85356: PUSH
85357: LD_INT 1
85359: PUSH
85360: LD_INT 2
85362: PUSH
85363: LD_INT 3
85365: PUSH
85366: LD_INT 4
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: IN
85375: NOT
85376: OR
85377: IFFALSE 85381
// exit ;
85379: GO 85473
// tmp := [ ] ;
85381: LD_ADDR_VAR 0 5
85385: PUSH
85386: EMPTY
85387: ST_TO_ADDR
// for i in units do
85388: LD_ADDR_VAR 0 4
85392: PUSH
85393: LD_VAR 0 1
85397: PUSH
85398: FOR_IN
85399: IFFALSE 85442
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85401: LD_ADDR_VAR 0 5
85405: PUSH
85406: LD_VAR 0 5
85410: PPUSH
85411: LD_VAR 0 5
85415: PUSH
85416: LD_INT 1
85418: PLUS
85419: PPUSH
85420: LD_VAR 0 4
85424: PPUSH
85425: LD_VAR 0 2
85429: PPUSH
85430: CALL_OW 259
85434: PPUSH
85435: CALL_OW 2
85439: ST_TO_ADDR
85440: GO 85398
85442: POP
85443: POP
// if not tmp then
85444: LD_VAR 0 5
85448: NOT
85449: IFFALSE 85453
// exit ;
85451: GO 85473
// result := SortListByListDesc ( units , tmp ) ;
85453: LD_ADDR_VAR 0 3
85457: PUSH
85458: LD_VAR 0 1
85462: PPUSH
85463: LD_VAR 0 5
85467: PPUSH
85468: CALL_OW 77
85472: ST_TO_ADDR
// end ;
85473: LD_VAR 0 3
85477: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85478: LD_INT 0
85480: PPUSH
85481: PPUSH
85482: PPUSH
// result := false ;
85483: LD_ADDR_VAR 0 3
85487: PUSH
85488: LD_INT 0
85490: ST_TO_ADDR
// x := GetX ( building ) ;
85491: LD_ADDR_VAR 0 4
85495: PUSH
85496: LD_VAR 0 2
85500: PPUSH
85501: CALL_OW 250
85505: ST_TO_ADDR
// y := GetY ( building ) ;
85506: LD_ADDR_VAR 0 5
85510: PUSH
85511: LD_VAR 0 2
85515: PPUSH
85516: CALL_OW 251
85520: ST_TO_ADDR
// if not building or not x or not y then
85521: LD_VAR 0 2
85525: NOT
85526: PUSH
85527: LD_VAR 0 4
85531: NOT
85532: OR
85533: PUSH
85534: LD_VAR 0 5
85538: NOT
85539: OR
85540: IFFALSE 85544
// exit ;
85542: GO 85636
// if GetTaskList ( unit ) then
85544: LD_VAR 0 1
85548: PPUSH
85549: CALL_OW 437
85553: IFFALSE 85636
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85555: LD_STRING e
85557: PUSH
85558: LD_VAR 0 1
85562: PPUSH
85563: CALL_OW 437
85567: PUSH
85568: LD_INT 1
85570: ARRAY
85571: PUSH
85572: LD_INT 1
85574: ARRAY
85575: EQUAL
85576: PUSH
85577: LD_VAR 0 4
85581: PUSH
85582: LD_VAR 0 1
85586: PPUSH
85587: CALL_OW 437
85591: PUSH
85592: LD_INT 1
85594: ARRAY
85595: PUSH
85596: LD_INT 2
85598: ARRAY
85599: EQUAL
85600: AND
85601: PUSH
85602: LD_VAR 0 5
85606: PUSH
85607: LD_VAR 0 1
85611: PPUSH
85612: CALL_OW 437
85616: PUSH
85617: LD_INT 1
85619: ARRAY
85620: PUSH
85621: LD_INT 3
85623: ARRAY
85624: EQUAL
85625: AND
85626: IFFALSE 85636
// result := true end ;
85628: LD_ADDR_VAR 0 3
85632: PUSH
85633: LD_INT 1
85635: ST_TO_ADDR
// end ;
85636: LD_VAR 0 3
85640: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85641: LD_INT 0
85643: PPUSH
// result := false ;
85644: LD_ADDR_VAR 0 4
85648: PUSH
85649: LD_INT 0
85651: ST_TO_ADDR
// if GetTaskList ( unit ) then
85652: LD_VAR 0 1
85656: PPUSH
85657: CALL_OW 437
85661: IFFALSE 85744
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85663: LD_STRING M
85665: PUSH
85666: LD_VAR 0 1
85670: PPUSH
85671: CALL_OW 437
85675: PUSH
85676: LD_INT 1
85678: ARRAY
85679: PUSH
85680: LD_INT 1
85682: ARRAY
85683: EQUAL
85684: PUSH
85685: LD_VAR 0 2
85689: PUSH
85690: LD_VAR 0 1
85694: PPUSH
85695: CALL_OW 437
85699: PUSH
85700: LD_INT 1
85702: ARRAY
85703: PUSH
85704: LD_INT 2
85706: ARRAY
85707: EQUAL
85708: AND
85709: PUSH
85710: LD_VAR 0 3
85714: PUSH
85715: LD_VAR 0 1
85719: PPUSH
85720: CALL_OW 437
85724: PUSH
85725: LD_INT 1
85727: ARRAY
85728: PUSH
85729: LD_INT 3
85731: ARRAY
85732: EQUAL
85733: AND
85734: IFFALSE 85744
// result := true ;
85736: LD_ADDR_VAR 0 4
85740: PUSH
85741: LD_INT 1
85743: ST_TO_ADDR
// end ; end ;
85744: LD_VAR 0 4
85748: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85749: LD_INT 0
85751: PPUSH
85752: PPUSH
85753: PPUSH
85754: PPUSH
// if not unit or not area then
85755: LD_VAR 0 1
85759: NOT
85760: PUSH
85761: LD_VAR 0 2
85765: NOT
85766: OR
85767: IFFALSE 85771
// exit ;
85769: GO 85935
// tmp := AreaToList ( area , i ) ;
85771: LD_ADDR_VAR 0 6
85775: PUSH
85776: LD_VAR 0 2
85780: PPUSH
85781: LD_VAR 0 5
85785: PPUSH
85786: CALL_OW 517
85790: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85791: LD_ADDR_VAR 0 5
85795: PUSH
85796: DOUBLE
85797: LD_INT 1
85799: DEC
85800: ST_TO_ADDR
85801: LD_VAR 0 6
85805: PUSH
85806: LD_INT 1
85808: ARRAY
85809: PUSH
85810: FOR_TO
85811: IFFALSE 85933
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85813: LD_ADDR_VAR 0 7
85817: PUSH
85818: LD_VAR 0 6
85822: PUSH
85823: LD_INT 1
85825: ARRAY
85826: PUSH
85827: LD_VAR 0 5
85831: ARRAY
85832: PUSH
85833: LD_VAR 0 6
85837: PUSH
85838: LD_INT 2
85840: ARRAY
85841: PUSH
85842: LD_VAR 0 5
85846: ARRAY
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85852: LD_VAR 0 7
85856: PUSH
85857: LD_INT 1
85859: ARRAY
85860: PPUSH
85861: LD_VAR 0 7
85865: PUSH
85866: LD_INT 2
85868: ARRAY
85869: PPUSH
85870: CALL_OW 428
85874: PUSH
85875: LD_INT 0
85877: EQUAL
85878: IFFALSE 85931
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85880: LD_VAR 0 1
85884: PPUSH
85885: LD_VAR 0 7
85889: PUSH
85890: LD_INT 1
85892: ARRAY
85893: PPUSH
85894: LD_VAR 0 7
85898: PUSH
85899: LD_INT 2
85901: ARRAY
85902: PPUSH
85903: LD_VAR 0 3
85907: PPUSH
85908: CALL_OW 48
// result := IsPlaced ( unit ) ;
85912: LD_ADDR_VAR 0 4
85916: PUSH
85917: LD_VAR 0 1
85921: PPUSH
85922: CALL_OW 305
85926: ST_TO_ADDR
// exit ;
85927: POP
85928: POP
85929: GO 85935
// end ; end ;
85931: GO 85810
85933: POP
85934: POP
// end ;
85935: LD_VAR 0 4
85939: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85940: LD_INT 0
85942: PPUSH
85943: PPUSH
85944: PPUSH
// if not side or side > 8 then
85945: LD_VAR 0 1
85949: NOT
85950: PUSH
85951: LD_VAR 0 1
85955: PUSH
85956: LD_INT 8
85958: GREATER
85959: OR
85960: IFFALSE 85964
// exit ;
85962: GO 86151
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85964: LD_ADDR_VAR 0 4
85968: PUSH
85969: LD_INT 22
85971: PUSH
85972: LD_VAR 0 1
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 21
85983: PUSH
85984: LD_INT 3
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PPUSH
85995: CALL_OW 69
85999: ST_TO_ADDR
// if not tmp then
86000: LD_VAR 0 4
86004: NOT
86005: IFFALSE 86009
// exit ;
86007: GO 86151
// enable_addtolog := true ;
86009: LD_ADDR_OWVAR 81
86013: PUSH
86014: LD_INT 1
86016: ST_TO_ADDR
// AddToLog ( [ ) ;
86017: LD_STRING [
86019: PPUSH
86020: CALL_OW 561
// for i in tmp do
86024: LD_ADDR_VAR 0 3
86028: PUSH
86029: LD_VAR 0 4
86033: PUSH
86034: FOR_IN
86035: IFFALSE 86142
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86037: LD_STRING [
86039: PUSH
86040: LD_VAR 0 3
86044: PPUSH
86045: CALL_OW 266
86049: STR
86050: PUSH
86051: LD_STRING , 
86053: STR
86054: PUSH
86055: LD_VAR 0 3
86059: PPUSH
86060: CALL_OW 250
86064: STR
86065: PUSH
86066: LD_STRING , 
86068: STR
86069: PUSH
86070: LD_VAR 0 3
86074: PPUSH
86075: CALL_OW 251
86079: STR
86080: PUSH
86081: LD_STRING , 
86083: STR
86084: PUSH
86085: LD_VAR 0 3
86089: PPUSH
86090: CALL_OW 254
86094: STR
86095: PUSH
86096: LD_STRING , 
86098: STR
86099: PUSH
86100: LD_VAR 0 3
86104: PPUSH
86105: LD_INT 1
86107: PPUSH
86108: CALL_OW 268
86112: STR
86113: PUSH
86114: LD_STRING , 
86116: STR
86117: PUSH
86118: LD_VAR 0 3
86122: PPUSH
86123: LD_INT 2
86125: PPUSH
86126: CALL_OW 268
86130: STR
86131: PUSH
86132: LD_STRING ],
86134: STR
86135: PPUSH
86136: CALL_OW 561
// end ;
86140: GO 86034
86142: POP
86143: POP
// AddToLog ( ]; ) ;
86144: LD_STRING ];
86146: PPUSH
86147: CALL_OW 561
// end ;
86151: LD_VAR 0 2
86155: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86156: LD_INT 0
86158: PPUSH
86159: PPUSH
86160: PPUSH
86161: PPUSH
86162: PPUSH
// if not area or not rate or not max then
86163: LD_VAR 0 1
86167: NOT
86168: PUSH
86169: LD_VAR 0 2
86173: NOT
86174: OR
86175: PUSH
86176: LD_VAR 0 4
86180: NOT
86181: OR
86182: IFFALSE 86186
// exit ;
86184: GO 86378
// while 1 do
86186: LD_INT 1
86188: IFFALSE 86378
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86190: LD_ADDR_VAR 0 9
86194: PUSH
86195: LD_VAR 0 1
86199: PPUSH
86200: LD_INT 1
86202: PPUSH
86203: CALL_OW 287
86207: PUSH
86208: LD_INT 10
86210: MUL
86211: ST_TO_ADDR
// r := rate / 10 ;
86212: LD_ADDR_VAR 0 7
86216: PUSH
86217: LD_VAR 0 2
86221: PUSH
86222: LD_INT 10
86224: DIVREAL
86225: ST_TO_ADDR
// time := 1 1$00 ;
86226: LD_ADDR_VAR 0 8
86230: PUSH
86231: LD_INT 2100
86233: ST_TO_ADDR
// if amount < min then
86234: LD_VAR 0 9
86238: PUSH
86239: LD_VAR 0 3
86243: LESS
86244: IFFALSE 86262
// r := r * 2 else
86246: LD_ADDR_VAR 0 7
86250: PUSH
86251: LD_VAR 0 7
86255: PUSH
86256: LD_INT 2
86258: MUL
86259: ST_TO_ADDR
86260: GO 86288
// if amount > max then
86262: LD_VAR 0 9
86266: PUSH
86267: LD_VAR 0 4
86271: GREATER
86272: IFFALSE 86288
// r := r / 2 ;
86274: LD_ADDR_VAR 0 7
86278: PUSH
86279: LD_VAR 0 7
86283: PUSH
86284: LD_INT 2
86286: DIVREAL
86287: ST_TO_ADDR
// time := time / r ;
86288: LD_ADDR_VAR 0 8
86292: PUSH
86293: LD_VAR 0 8
86297: PUSH
86298: LD_VAR 0 7
86302: DIVREAL
86303: ST_TO_ADDR
// if time < 0 then
86304: LD_VAR 0 8
86308: PUSH
86309: LD_INT 0
86311: LESS
86312: IFFALSE 86329
// time := time * - 1 ;
86314: LD_ADDR_VAR 0 8
86318: PUSH
86319: LD_VAR 0 8
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: MUL
86328: ST_TO_ADDR
// wait ( time ) ;
86329: LD_VAR 0 8
86333: PPUSH
86334: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86338: LD_INT 35
86340: PPUSH
86341: LD_INT 875
86343: PPUSH
86344: CALL_OW 12
86348: PPUSH
86349: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86353: LD_INT 1
86355: PPUSH
86356: LD_INT 5
86358: PPUSH
86359: CALL_OW 12
86363: PPUSH
86364: LD_VAR 0 1
86368: PPUSH
86369: LD_INT 1
86371: PPUSH
86372: CALL_OW 55
// end ;
86376: GO 86186
// end ;
86378: LD_VAR 0 5
86382: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86383: LD_INT 0
86385: PPUSH
86386: PPUSH
86387: PPUSH
86388: PPUSH
86389: PPUSH
86390: PPUSH
86391: PPUSH
86392: PPUSH
// if not turrets or not factories then
86393: LD_VAR 0 1
86397: NOT
86398: PUSH
86399: LD_VAR 0 2
86403: NOT
86404: OR
86405: IFFALSE 86409
// exit ;
86407: GO 86716
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86409: LD_ADDR_VAR 0 10
86413: PUSH
86414: LD_INT 5
86416: PUSH
86417: LD_INT 6
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 2
86426: PUSH
86427: LD_INT 4
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 3
86436: PUSH
86437: LD_INT 5
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 24
86451: PUSH
86452: LD_INT 25
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 23
86461: PUSH
86462: LD_INT 27
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 42
86475: PUSH
86476: LD_INT 43
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: LD_INT 44
86485: PUSH
86486: LD_INT 46
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 45
86495: PUSH
86496: LD_INT 47
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: LIST
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: LIST
86512: ST_TO_ADDR
// result := [ ] ;
86513: LD_ADDR_VAR 0 3
86517: PUSH
86518: EMPTY
86519: ST_TO_ADDR
// for i in turrets do
86520: LD_ADDR_VAR 0 4
86524: PUSH
86525: LD_VAR 0 1
86529: PUSH
86530: FOR_IN
86531: IFFALSE 86714
// begin nat := GetNation ( i ) ;
86533: LD_ADDR_VAR 0 7
86537: PUSH
86538: LD_VAR 0 4
86542: PPUSH
86543: CALL_OW 248
86547: ST_TO_ADDR
// weapon := 0 ;
86548: LD_ADDR_VAR 0 8
86552: PUSH
86553: LD_INT 0
86555: ST_TO_ADDR
// if not nat then
86556: LD_VAR 0 7
86560: NOT
86561: IFFALSE 86565
// continue ;
86563: GO 86530
// for j in list [ nat ] do
86565: LD_ADDR_VAR 0 5
86569: PUSH
86570: LD_VAR 0 10
86574: PUSH
86575: LD_VAR 0 7
86579: ARRAY
86580: PUSH
86581: FOR_IN
86582: IFFALSE 86623
// if GetBWeapon ( i ) = j [ 1 ] then
86584: LD_VAR 0 4
86588: PPUSH
86589: CALL_OW 269
86593: PUSH
86594: LD_VAR 0 5
86598: PUSH
86599: LD_INT 1
86601: ARRAY
86602: EQUAL
86603: IFFALSE 86621
// begin weapon := j [ 2 ] ;
86605: LD_ADDR_VAR 0 8
86609: PUSH
86610: LD_VAR 0 5
86614: PUSH
86615: LD_INT 2
86617: ARRAY
86618: ST_TO_ADDR
// break ;
86619: GO 86623
// end ;
86621: GO 86581
86623: POP
86624: POP
// if not weapon then
86625: LD_VAR 0 8
86629: NOT
86630: IFFALSE 86634
// continue ;
86632: GO 86530
// for k in factories do
86634: LD_ADDR_VAR 0 6
86638: PUSH
86639: LD_VAR 0 2
86643: PUSH
86644: FOR_IN
86645: IFFALSE 86710
// begin weapons := AvailableWeaponList ( k ) ;
86647: LD_ADDR_VAR 0 9
86651: PUSH
86652: LD_VAR 0 6
86656: PPUSH
86657: CALL_OW 478
86661: ST_TO_ADDR
// if not weapons then
86662: LD_VAR 0 9
86666: NOT
86667: IFFALSE 86671
// continue ;
86669: GO 86644
// if weapon in weapons then
86671: LD_VAR 0 8
86675: PUSH
86676: LD_VAR 0 9
86680: IN
86681: IFFALSE 86708
// begin result := [ i , weapon ] ;
86683: LD_ADDR_VAR 0 3
86687: PUSH
86688: LD_VAR 0 4
86692: PUSH
86693: LD_VAR 0 8
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: ST_TO_ADDR
// exit ;
86702: POP
86703: POP
86704: POP
86705: POP
86706: GO 86716
// end ; end ;
86708: GO 86644
86710: POP
86711: POP
// end ;
86712: GO 86530
86714: POP
86715: POP
// end ;
86716: LD_VAR 0 3
86720: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86721: LD_INT 0
86723: PPUSH
// if not side or side > 8 then
86724: LD_VAR 0 3
86728: NOT
86729: PUSH
86730: LD_VAR 0 3
86734: PUSH
86735: LD_INT 8
86737: GREATER
86738: OR
86739: IFFALSE 86743
// exit ;
86741: GO 86802
// if not range then
86743: LD_VAR 0 4
86747: NOT
86748: IFFALSE 86759
// range := - 12 ;
86750: LD_ADDR_VAR 0 4
86754: PUSH
86755: LD_INT 12
86757: NEG
86758: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86759: LD_VAR 0 1
86763: PPUSH
86764: LD_VAR 0 2
86768: PPUSH
86769: LD_VAR 0 3
86773: PPUSH
86774: LD_VAR 0 4
86778: PPUSH
86779: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86783: LD_VAR 0 1
86787: PPUSH
86788: LD_VAR 0 2
86792: PPUSH
86793: LD_VAR 0 3
86797: PPUSH
86798: CALL_OW 331
// end ;
86802: LD_VAR 0 5
86806: RET
// export function Video ( mode ) ; begin
86807: LD_INT 0
86809: PPUSH
// ingame_video = mode ;
86810: LD_ADDR_OWVAR 52
86814: PUSH
86815: LD_VAR 0 1
86819: ST_TO_ADDR
// interface_hidden = mode ;
86820: LD_ADDR_OWVAR 54
86824: PUSH
86825: LD_VAR 0 1
86829: ST_TO_ADDR
// end ;
86830: LD_VAR 0 2
86834: RET
// export function Join ( array , element ) ; begin
86835: LD_INT 0
86837: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86838: LD_ADDR_VAR 0 3
86842: PUSH
86843: LD_VAR 0 1
86847: PPUSH
86848: LD_VAR 0 1
86852: PUSH
86853: LD_INT 1
86855: PLUS
86856: PPUSH
86857: LD_VAR 0 2
86861: PPUSH
86862: CALL_OW 1
86866: ST_TO_ADDR
// end ;
86867: LD_VAR 0 3
86871: RET
// export function JoinUnion ( array , element ) ; begin
86872: LD_INT 0
86874: PPUSH
// result := array union element ;
86875: LD_ADDR_VAR 0 3
86879: PUSH
86880: LD_VAR 0 1
86884: PUSH
86885: LD_VAR 0 2
86889: UNION
86890: ST_TO_ADDR
// end ;
86891: LD_VAR 0 3
86895: RET
// export function GetBehemoths ( side ) ; begin
86896: LD_INT 0
86898: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86899: LD_ADDR_VAR 0 2
86903: PUSH
86904: LD_INT 22
86906: PUSH
86907: LD_VAR 0 1
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 31
86918: PUSH
86919: LD_INT 25
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PPUSH
86930: CALL_OW 69
86934: ST_TO_ADDR
// end ;
86935: LD_VAR 0 2
86939: RET
// export function Shuffle ( array ) ; var i , index ; begin
86940: LD_INT 0
86942: PPUSH
86943: PPUSH
86944: PPUSH
// result := [ ] ;
86945: LD_ADDR_VAR 0 2
86949: PUSH
86950: EMPTY
86951: ST_TO_ADDR
// if not array then
86952: LD_VAR 0 1
86956: NOT
86957: IFFALSE 86961
// exit ;
86959: GO 87060
// Randomize ;
86961: CALL_OW 10
// for i = array downto 1 do
86965: LD_ADDR_VAR 0 3
86969: PUSH
86970: DOUBLE
86971: LD_VAR 0 1
86975: INC
86976: ST_TO_ADDR
86977: LD_INT 1
86979: PUSH
86980: FOR_DOWNTO
86981: IFFALSE 87058
// begin index := rand ( 1 , array ) ;
86983: LD_ADDR_VAR 0 4
86987: PUSH
86988: LD_INT 1
86990: PPUSH
86991: LD_VAR 0 1
86995: PPUSH
86996: CALL_OW 12
87000: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87001: LD_ADDR_VAR 0 2
87005: PUSH
87006: LD_VAR 0 2
87010: PPUSH
87011: LD_VAR 0 2
87015: PUSH
87016: LD_INT 1
87018: PLUS
87019: PPUSH
87020: LD_VAR 0 1
87024: PUSH
87025: LD_VAR 0 4
87029: ARRAY
87030: PPUSH
87031: CALL_OW 2
87035: ST_TO_ADDR
// array := Delete ( array , index ) ;
87036: LD_ADDR_VAR 0 1
87040: PUSH
87041: LD_VAR 0 1
87045: PPUSH
87046: LD_VAR 0 4
87050: PPUSH
87051: CALL_OW 3
87055: ST_TO_ADDR
// end ;
87056: GO 86980
87058: POP
87059: POP
// end ;
87060: LD_VAR 0 2
87064: RET
// export function GetBaseMaterials ( base ) ; begin
87065: LD_INT 0
87067: PPUSH
// result := [ 0 , 0 , 0 ] ;
87068: LD_ADDR_VAR 0 2
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: LD_INT 0
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: LIST
87086: ST_TO_ADDR
// if not base then
87087: LD_VAR 0 1
87091: NOT
87092: IFFALSE 87096
// exit ;
87094: GO 87145
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87096: LD_ADDR_VAR 0 2
87100: PUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: LD_INT 1
87108: PPUSH
87109: CALL_OW 275
87113: PUSH
87114: LD_VAR 0 1
87118: PPUSH
87119: LD_INT 2
87121: PPUSH
87122: CALL_OW 275
87126: PUSH
87127: LD_VAR 0 1
87131: PPUSH
87132: LD_INT 3
87134: PPUSH
87135: CALL_OW 275
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: LIST
87144: ST_TO_ADDR
// end ;
87145: LD_VAR 0 2
87149: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87150: LD_INT 0
87152: PPUSH
87153: PPUSH
// result := array ;
87154: LD_ADDR_VAR 0 3
87158: PUSH
87159: LD_VAR 0 1
87163: ST_TO_ADDR
// if size > 0 then
87164: LD_VAR 0 2
87168: PUSH
87169: LD_INT 0
87171: GREATER
87172: IFFALSE 87218
// for i := array downto size do
87174: LD_ADDR_VAR 0 4
87178: PUSH
87179: DOUBLE
87180: LD_VAR 0 1
87184: INC
87185: ST_TO_ADDR
87186: LD_VAR 0 2
87190: PUSH
87191: FOR_DOWNTO
87192: IFFALSE 87216
// result := Delete ( result , result ) ;
87194: LD_ADDR_VAR 0 3
87198: PUSH
87199: LD_VAR 0 3
87203: PPUSH
87204: LD_VAR 0 3
87208: PPUSH
87209: CALL_OW 3
87213: ST_TO_ADDR
87214: GO 87191
87216: POP
87217: POP
// end ;
87218: LD_VAR 0 3
87222: RET
// export function ComExit ( unit ) ; var tmp ; begin
87223: LD_INT 0
87225: PPUSH
87226: PPUSH
// if not IsInUnit ( unit ) then
87227: LD_VAR 0 1
87231: PPUSH
87232: CALL_OW 310
87236: NOT
87237: IFFALSE 87241
// exit ;
87239: GO 87301
// tmp := IsInUnit ( unit ) ;
87241: LD_ADDR_VAR 0 3
87245: PUSH
87246: LD_VAR 0 1
87250: PPUSH
87251: CALL_OW 310
87255: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87256: LD_VAR 0 3
87260: PPUSH
87261: CALL_OW 247
87265: PUSH
87266: LD_INT 2
87268: EQUAL
87269: IFFALSE 87282
// ComExitVehicle ( unit ) else
87271: LD_VAR 0 1
87275: PPUSH
87276: CALL_OW 121
87280: GO 87291
// ComExitBuilding ( unit ) ;
87282: LD_VAR 0 1
87286: PPUSH
87287: CALL_OW 122
// result := tmp ;
87291: LD_ADDR_VAR 0 2
87295: PUSH
87296: LD_VAR 0 3
87300: ST_TO_ADDR
// end ;
87301: LD_VAR 0 2
87305: RET
// export function ResetHc ; begin
87306: LD_INT 0
87308: PPUSH
// InitHc ;
87309: CALL_OW 19
// hc_importance := 0 ;
87313: LD_ADDR_OWVAR 32
87317: PUSH
87318: LD_INT 0
87320: ST_TO_ADDR
// end ;
87321: LD_VAR 0 1
87325: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87326: LD_INT 0
87328: PPUSH
87329: PPUSH
87330: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87331: LD_ADDR_VAR 0 6
87335: PUSH
87336: LD_VAR 0 1
87340: PUSH
87341: LD_VAR 0 3
87345: PLUS
87346: PUSH
87347: LD_INT 2
87349: DIV
87350: ST_TO_ADDR
// if _x < 0 then
87351: LD_VAR 0 6
87355: PUSH
87356: LD_INT 0
87358: LESS
87359: IFFALSE 87376
// _x := _x * - 1 ;
87361: LD_ADDR_VAR 0 6
87365: PUSH
87366: LD_VAR 0 6
87370: PUSH
87371: LD_INT 1
87373: NEG
87374: MUL
87375: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87376: LD_ADDR_VAR 0 7
87380: PUSH
87381: LD_VAR 0 2
87385: PUSH
87386: LD_VAR 0 4
87390: PLUS
87391: PUSH
87392: LD_INT 2
87394: DIV
87395: ST_TO_ADDR
// if _y < 0 then
87396: LD_VAR 0 7
87400: PUSH
87401: LD_INT 0
87403: LESS
87404: IFFALSE 87421
// _y := _y * - 1 ;
87406: LD_ADDR_VAR 0 7
87410: PUSH
87411: LD_VAR 0 7
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: MUL
87420: ST_TO_ADDR
// result := [ _x , _y ] ;
87421: LD_ADDR_VAR 0 5
87425: PUSH
87426: LD_VAR 0 6
87430: PUSH
87431: LD_VAR 0 7
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: ST_TO_ADDR
// end ;
87440: LD_VAR 0 5
87444: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87445: LD_INT 0
87447: PPUSH
87448: PPUSH
87449: PPUSH
87450: PPUSH
// task := GetTaskList ( unit ) ;
87451: LD_ADDR_VAR 0 7
87455: PUSH
87456: LD_VAR 0 1
87460: PPUSH
87461: CALL_OW 437
87465: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87466: LD_VAR 0 7
87470: NOT
87471: PUSH
87472: LD_VAR 0 1
87476: PPUSH
87477: LD_VAR 0 2
87481: PPUSH
87482: CALL_OW 308
87486: NOT
87487: AND
87488: IFFALSE 87492
// exit ;
87490: GO 87610
// if IsInArea ( unit , area ) then
87492: LD_VAR 0 1
87496: PPUSH
87497: LD_VAR 0 2
87501: PPUSH
87502: CALL_OW 308
87506: IFFALSE 87524
// begin ComMoveToArea ( unit , goAway ) ;
87508: LD_VAR 0 1
87512: PPUSH
87513: LD_VAR 0 3
87517: PPUSH
87518: CALL_OW 113
// exit ;
87522: GO 87610
// end ; if task [ 1 ] [ 1 ] <> M then
87524: LD_VAR 0 7
87528: PUSH
87529: LD_INT 1
87531: ARRAY
87532: PUSH
87533: LD_INT 1
87535: ARRAY
87536: PUSH
87537: LD_STRING M
87539: NONEQUAL
87540: IFFALSE 87544
// exit ;
87542: GO 87610
// x := task [ 1 ] [ 2 ] ;
87544: LD_ADDR_VAR 0 5
87548: PUSH
87549: LD_VAR 0 7
87553: PUSH
87554: LD_INT 1
87556: ARRAY
87557: PUSH
87558: LD_INT 2
87560: ARRAY
87561: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87562: LD_ADDR_VAR 0 6
87566: PUSH
87567: LD_VAR 0 7
87571: PUSH
87572: LD_INT 1
87574: ARRAY
87575: PUSH
87576: LD_INT 3
87578: ARRAY
87579: ST_TO_ADDR
// if InArea ( x , y , area ) then
87580: LD_VAR 0 5
87584: PPUSH
87585: LD_VAR 0 6
87589: PPUSH
87590: LD_VAR 0 2
87594: PPUSH
87595: CALL_OW 309
87599: IFFALSE 87610
// ComStop ( unit ) ;
87601: LD_VAR 0 1
87605: PPUSH
87606: CALL_OW 141
// end ;
87610: LD_VAR 0 4
87614: RET
// export function Abs ( value ) ; begin
87615: LD_INT 0
87617: PPUSH
// result := value ;
87618: LD_ADDR_VAR 0 2
87622: PUSH
87623: LD_VAR 0 1
87627: ST_TO_ADDR
// if value < 0 then
87628: LD_VAR 0 1
87632: PUSH
87633: LD_INT 0
87635: LESS
87636: IFFALSE 87653
// result := value * - 1 ;
87638: LD_ADDR_VAR 0 2
87642: PUSH
87643: LD_VAR 0 1
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: MUL
87652: ST_TO_ADDR
// end ;
87653: LD_VAR 0 2
87657: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87658: LD_INT 0
87660: PPUSH
87661: PPUSH
87662: PPUSH
87663: PPUSH
87664: PPUSH
87665: PPUSH
87666: PPUSH
87667: PPUSH
// if not unit or not building then
87668: LD_VAR 0 1
87672: NOT
87673: PUSH
87674: LD_VAR 0 2
87678: NOT
87679: OR
87680: IFFALSE 87684
// exit ;
87682: GO 87910
// x := GetX ( building ) ;
87684: LD_ADDR_VAR 0 4
87688: PUSH
87689: LD_VAR 0 2
87693: PPUSH
87694: CALL_OW 250
87698: ST_TO_ADDR
// y := GetY ( building ) ;
87699: LD_ADDR_VAR 0 6
87703: PUSH
87704: LD_VAR 0 2
87708: PPUSH
87709: CALL_OW 251
87713: ST_TO_ADDR
// d := GetDir ( building ) ;
87714: LD_ADDR_VAR 0 8
87718: PUSH
87719: LD_VAR 0 2
87723: PPUSH
87724: CALL_OW 254
87728: ST_TO_ADDR
// r := 4 ;
87729: LD_ADDR_VAR 0 9
87733: PUSH
87734: LD_INT 4
87736: ST_TO_ADDR
// for i := 1 to 5 do
87737: LD_ADDR_VAR 0 10
87741: PUSH
87742: DOUBLE
87743: LD_INT 1
87745: DEC
87746: ST_TO_ADDR
87747: LD_INT 5
87749: PUSH
87750: FOR_TO
87751: IFFALSE 87908
// begin _x := ShiftX ( x , d , r + i ) ;
87753: LD_ADDR_VAR 0 5
87757: PUSH
87758: LD_VAR 0 4
87762: PPUSH
87763: LD_VAR 0 8
87767: PPUSH
87768: LD_VAR 0 9
87772: PUSH
87773: LD_VAR 0 10
87777: PLUS
87778: PPUSH
87779: CALL_OW 272
87783: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87784: LD_ADDR_VAR 0 7
87788: PUSH
87789: LD_VAR 0 6
87793: PPUSH
87794: LD_VAR 0 8
87798: PPUSH
87799: LD_VAR 0 9
87803: PUSH
87804: LD_VAR 0 10
87808: PLUS
87809: PPUSH
87810: CALL_OW 273
87814: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87815: LD_VAR 0 5
87819: PPUSH
87820: LD_VAR 0 7
87824: PPUSH
87825: CALL_OW 488
87829: PUSH
87830: LD_VAR 0 5
87834: PPUSH
87835: LD_VAR 0 7
87839: PPUSH
87840: CALL_OW 428
87844: PPUSH
87845: CALL_OW 247
87849: PUSH
87850: LD_INT 3
87852: PUSH
87853: LD_INT 2
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: IN
87860: NOT
87861: AND
87862: IFFALSE 87906
// begin ComMoveXY ( unit , _x , _y ) ;
87864: LD_VAR 0 1
87868: PPUSH
87869: LD_VAR 0 5
87873: PPUSH
87874: LD_VAR 0 7
87878: PPUSH
87879: CALL_OW 111
// result := [ _x , _y ] ;
87883: LD_ADDR_VAR 0 3
87887: PUSH
87888: LD_VAR 0 5
87892: PUSH
87893: LD_VAR 0 7
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: ST_TO_ADDR
// exit ;
87902: POP
87903: POP
87904: GO 87910
// end ; end ;
87906: GO 87750
87908: POP
87909: POP
// end ; end_of_file end_of_file
87910: LD_VAR 0 3
87914: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87915: LD_VAR 0 2
87919: PUSH
87920: LD_INT 100
87922: EQUAL
87923: IFFALSE 88872
// begin if not StreamModeActive then
87925: LD_EXP 133
87929: NOT
87930: IFFALSE 87940
// StreamModeActive := true ;
87932: LD_ADDR_EXP 133
87936: PUSH
87937: LD_INT 1
87939: ST_TO_ADDR
// if p3 = 0 then
87940: LD_VAR 0 3
87944: PUSH
87945: LD_INT 0
87947: EQUAL
87948: IFFALSE 87954
// InitStreamMode ;
87950: CALL 89030 0 0
// if p3 = 1 then
87954: LD_VAR 0 3
87958: PUSH
87959: LD_INT 1
87961: EQUAL
87962: IFFALSE 87972
// sRocket := true ;
87964: LD_ADDR_EXP 138
87968: PUSH
87969: LD_INT 1
87971: ST_TO_ADDR
// if p3 = 2 then
87972: LD_VAR 0 3
87976: PUSH
87977: LD_INT 2
87979: EQUAL
87980: IFFALSE 87990
// sSpeed := true ;
87982: LD_ADDR_EXP 137
87986: PUSH
87987: LD_INT 1
87989: ST_TO_ADDR
// if p3 = 3 then
87990: LD_VAR 0 3
87994: PUSH
87995: LD_INT 3
87997: EQUAL
87998: IFFALSE 88008
// sEngine := true ;
88000: LD_ADDR_EXP 139
88004: PUSH
88005: LD_INT 1
88007: ST_TO_ADDR
// if p3 = 4 then
88008: LD_VAR 0 3
88012: PUSH
88013: LD_INT 4
88015: EQUAL
88016: IFFALSE 88026
// sSpec := true ;
88018: LD_ADDR_EXP 136
88022: PUSH
88023: LD_INT 1
88025: ST_TO_ADDR
// if p3 = 5 then
88026: LD_VAR 0 3
88030: PUSH
88031: LD_INT 5
88033: EQUAL
88034: IFFALSE 88044
// sLevel := true ;
88036: LD_ADDR_EXP 140
88040: PUSH
88041: LD_INT 1
88043: ST_TO_ADDR
// if p3 = 6 then
88044: LD_VAR 0 3
88048: PUSH
88049: LD_INT 6
88051: EQUAL
88052: IFFALSE 88062
// sArmoury := true ;
88054: LD_ADDR_EXP 141
88058: PUSH
88059: LD_INT 1
88061: ST_TO_ADDR
// if p3 = 7 then
88062: LD_VAR 0 3
88066: PUSH
88067: LD_INT 7
88069: EQUAL
88070: IFFALSE 88080
// sRadar := true ;
88072: LD_ADDR_EXP 142
88076: PUSH
88077: LD_INT 1
88079: ST_TO_ADDR
// if p3 = 8 then
88080: LD_VAR 0 3
88084: PUSH
88085: LD_INT 8
88087: EQUAL
88088: IFFALSE 88098
// sBunker := true ;
88090: LD_ADDR_EXP 143
88094: PUSH
88095: LD_INT 1
88097: ST_TO_ADDR
// if p3 = 9 then
88098: LD_VAR 0 3
88102: PUSH
88103: LD_INT 9
88105: EQUAL
88106: IFFALSE 88116
// sHack := true ;
88108: LD_ADDR_EXP 144
88112: PUSH
88113: LD_INT 1
88115: ST_TO_ADDR
// if p3 = 10 then
88116: LD_VAR 0 3
88120: PUSH
88121: LD_INT 10
88123: EQUAL
88124: IFFALSE 88134
// sFire := true ;
88126: LD_ADDR_EXP 145
88130: PUSH
88131: LD_INT 1
88133: ST_TO_ADDR
// if p3 = 11 then
88134: LD_VAR 0 3
88138: PUSH
88139: LD_INT 11
88141: EQUAL
88142: IFFALSE 88152
// sRefresh := true ;
88144: LD_ADDR_EXP 146
88148: PUSH
88149: LD_INT 1
88151: ST_TO_ADDR
// if p3 = 12 then
88152: LD_VAR 0 3
88156: PUSH
88157: LD_INT 12
88159: EQUAL
88160: IFFALSE 88170
// sExp := true ;
88162: LD_ADDR_EXP 147
88166: PUSH
88167: LD_INT 1
88169: ST_TO_ADDR
// if p3 = 13 then
88170: LD_VAR 0 3
88174: PUSH
88175: LD_INT 13
88177: EQUAL
88178: IFFALSE 88188
// sDepot := true ;
88180: LD_ADDR_EXP 148
88184: PUSH
88185: LD_INT 1
88187: ST_TO_ADDR
// if p3 = 14 then
88188: LD_VAR 0 3
88192: PUSH
88193: LD_INT 14
88195: EQUAL
88196: IFFALSE 88206
// sFlag := true ;
88198: LD_ADDR_EXP 149
88202: PUSH
88203: LD_INT 1
88205: ST_TO_ADDR
// if p3 = 15 then
88206: LD_VAR 0 3
88210: PUSH
88211: LD_INT 15
88213: EQUAL
88214: IFFALSE 88224
// sKamikadze := true ;
88216: LD_ADDR_EXP 157
88220: PUSH
88221: LD_INT 1
88223: ST_TO_ADDR
// if p3 = 16 then
88224: LD_VAR 0 3
88228: PUSH
88229: LD_INT 16
88231: EQUAL
88232: IFFALSE 88242
// sTroll := true ;
88234: LD_ADDR_EXP 158
88238: PUSH
88239: LD_INT 1
88241: ST_TO_ADDR
// if p3 = 17 then
88242: LD_VAR 0 3
88246: PUSH
88247: LD_INT 17
88249: EQUAL
88250: IFFALSE 88260
// sSlow := true ;
88252: LD_ADDR_EXP 159
88256: PUSH
88257: LD_INT 1
88259: ST_TO_ADDR
// if p3 = 18 then
88260: LD_VAR 0 3
88264: PUSH
88265: LD_INT 18
88267: EQUAL
88268: IFFALSE 88278
// sLack := true ;
88270: LD_ADDR_EXP 160
88274: PUSH
88275: LD_INT 1
88277: ST_TO_ADDR
// if p3 = 19 then
88278: LD_VAR 0 3
88282: PUSH
88283: LD_INT 19
88285: EQUAL
88286: IFFALSE 88296
// sTank := true ;
88288: LD_ADDR_EXP 162
88292: PUSH
88293: LD_INT 1
88295: ST_TO_ADDR
// if p3 = 20 then
88296: LD_VAR 0 3
88300: PUSH
88301: LD_INT 20
88303: EQUAL
88304: IFFALSE 88314
// sRemote := true ;
88306: LD_ADDR_EXP 163
88310: PUSH
88311: LD_INT 1
88313: ST_TO_ADDR
// if p3 = 21 then
88314: LD_VAR 0 3
88318: PUSH
88319: LD_INT 21
88321: EQUAL
88322: IFFALSE 88332
// sPowell := true ;
88324: LD_ADDR_EXP 164
88328: PUSH
88329: LD_INT 1
88331: ST_TO_ADDR
// if p3 = 22 then
88332: LD_VAR 0 3
88336: PUSH
88337: LD_INT 22
88339: EQUAL
88340: IFFALSE 88350
// sTeleport := true ;
88342: LD_ADDR_EXP 167
88346: PUSH
88347: LD_INT 1
88349: ST_TO_ADDR
// if p3 = 23 then
88350: LD_VAR 0 3
88354: PUSH
88355: LD_INT 23
88357: EQUAL
88358: IFFALSE 88368
// sOilTower := true ;
88360: LD_ADDR_EXP 169
88364: PUSH
88365: LD_INT 1
88367: ST_TO_ADDR
// if p3 = 24 then
88368: LD_VAR 0 3
88372: PUSH
88373: LD_INT 24
88375: EQUAL
88376: IFFALSE 88386
// sShovel := true ;
88378: LD_ADDR_EXP 170
88382: PUSH
88383: LD_INT 1
88385: ST_TO_ADDR
// if p3 = 25 then
88386: LD_VAR 0 3
88390: PUSH
88391: LD_INT 25
88393: EQUAL
88394: IFFALSE 88404
// sSheik := true ;
88396: LD_ADDR_EXP 171
88400: PUSH
88401: LD_INT 1
88403: ST_TO_ADDR
// if p3 = 26 then
88404: LD_VAR 0 3
88408: PUSH
88409: LD_INT 26
88411: EQUAL
88412: IFFALSE 88422
// sEarthquake := true ;
88414: LD_ADDR_EXP 173
88418: PUSH
88419: LD_INT 1
88421: ST_TO_ADDR
// if p3 = 27 then
88422: LD_VAR 0 3
88426: PUSH
88427: LD_INT 27
88429: EQUAL
88430: IFFALSE 88440
// sAI := true ;
88432: LD_ADDR_EXP 174
88436: PUSH
88437: LD_INT 1
88439: ST_TO_ADDR
// if p3 = 28 then
88440: LD_VAR 0 3
88444: PUSH
88445: LD_INT 28
88447: EQUAL
88448: IFFALSE 88458
// sCargo := true ;
88450: LD_ADDR_EXP 177
88454: PUSH
88455: LD_INT 1
88457: ST_TO_ADDR
// if p3 = 29 then
88458: LD_VAR 0 3
88462: PUSH
88463: LD_INT 29
88465: EQUAL
88466: IFFALSE 88476
// sDLaser := true ;
88468: LD_ADDR_EXP 178
88472: PUSH
88473: LD_INT 1
88475: ST_TO_ADDR
// if p3 = 30 then
88476: LD_VAR 0 3
88480: PUSH
88481: LD_INT 30
88483: EQUAL
88484: IFFALSE 88494
// sExchange := true ;
88486: LD_ADDR_EXP 179
88490: PUSH
88491: LD_INT 1
88493: ST_TO_ADDR
// if p3 = 31 then
88494: LD_VAR 0 3
88498: PUSH
88499: LD_INT 31
88501: EQUAL
88502: IFFALSE 88512
// sFac := true ;
88504: LD_ADDR_EXP 180
88508: PUSH
88509: LD_INT 1
88511: ST_TO_ADDR
// if p3 = 32 then
88512: LD_VAR 0 3
88516: PUSH
88517: LD_INT 32
88519: EQUAL
88520: IFFALSE 88530
// sPower := true ;
88522: LD_ADDR_EXP 181
88526: PUSH
88527: LD_INT 1
88529: ST_TO_ADDR
// if p3 = 33 then
88530: LD_VAR 0 3
88534: PUSH
88535: LD_INT 33
88537: EQUAL
88538: IFFALSE 88548
// sRandom := true ;
88540: LD_ADDR_EXP 182
88544: PUSH
88545: LD_INT 1
88547: ST_TO_ADDR
// if p3 = 34 then
88548: LD_VAR 0 3
88552: PUSH
88553: LD_INT 34
88555: EQUAL
88556: IFFALSE 88566
// sShield := true ;
88558: LD_ADDR_EXP 183
88562: PUSH
88563: LD_INT 1
88565: ST_TO_ADDR
// if p3 = 35 then
88566: LD_VAR 0 3
88570: PUSH
88571: LD_INT 35
88573: EQUAL
88574: IFFALSE 88584
// sTime := true ;
88576: LD_ADDR_EXP 184
88580: PUSH
88581: LD_INT 1
88583: ST_TO_ADDR
// if p3 = 36 then
88584: LD_VAR 0 3
88588: PUSH
88589: LD_INT 36
88591: EQUAL
88592: IFFALSE 88602
// sTools := true ;
88594: LD_ADDR_EXP 185
88598: PUSH
88599: LD_INT 1
88601: ST_TO_ADDR
// if p3 = 101 then
88602: LD_VAR 0 3
88606: PUSH
88607: LD_INT 101
88609: EQUAL
88610: IFFALSE 88620
// sSold := true ;
88612: LD_ADDR_EXP 150
88616: PUSH
88617: LD_INT 1
88619: ST_TO_ADDR
// if p3 = 102 then
88620: LD_VAR 0 3
88624: PUSH
88625: LD_INT 102
88627: EQUAL
88628: IFFALSE 88638
// sDiff := true ;
88630: LD_ADDR_EXP 151
88634: PUSH
88635: LD_INT 1
88637: ST_TO_ADDR
// if p3 = 103 then
88638: LD_VAR 0 3
88642: PUSH
88643: LD_INT 103
88645: EQUAL
88646: IFFALSE 88656
// sFog := true ;
88648: LD_ADDR_EXP 154
88652: PUSH
88653: LD_INT 1
88655: ST_TO_ADDR
// if p3 = 104 then
88656: LD_VAR 0 3
88660: PUSH
88661: LD_INT 104
88663: EQUAL
88664: IFFALSE 88674
// sReset := true ;
88666: LD_ADDR_EXP 155
88670: PUSH
88671: LD_INT 1
88673: ST_TO_ADDR
// if p3 = 105 then
88674: LD_VAR 0 3
88678: PUSH
88679: LD_INT 105
88681: EQUAL
88682: IFFALSE 88692
// sSun := true ;
88684: LD_ADDR_EXP 156
88688: PUSH
88689: LD_INT 1
88691: ST_TO_ADDR
// if p3 = 106 then
88692: LD_VAR 0 3
88696: PUSH
88697: LD_INT 106
88699: EQUAL
88700: IFFALSE 88710
// sTiger := true ;
88702: LD_ADDR_EXP 152
88706: PUSH
88707: LD_INT 1
88709: ST_TO_ADDR
// if p3 = 107 then
88710: LD_VAR 0 3
88714: PUSH
88715: LD_INT 107
88717: EQUAL
88718: IFFALSE 88728
// sBomb := true ;
88720: LD_ADDR_EXP 153
88724: PUSH
88725: LD_INT 1
88727: ST_TO_ADDR
// if p3 = 108 then
88728: LD_VAR 0 3
88732: PUSH
88733: LD_INT 108
88735: EQUAL
88736: IFFALSE 88746
// sWound := true ;
88738: LD_ADDR_EXP 161
88742: PUSH
88743: LD_INT 1
88745: ST_TO_ADDR
// if p3 = 109 then
88746: LD_VAR 0 3
88750: PUSH
88751: LD_INT 109
88753: EQUAL
88754: IFFALSE 88764
// sBetray := true ;
88756: LD_ADDR_EXP 165
88760: PUSH
88761: LD_INT 1
88763: ST_TO_ADDR
// if p3 = 110 then
88764: LD_VAR 0 3
88768: PUSH
88769: LD_INT 110
88771: EQUAL
88772: IFFALSE 88782
// sContamin := true ;
88774: LD_ADDR_EXP 166
88778: PUSH
88779: LD_INT 1
88781: ST_TO_ADDR
// if p3 = 111 then
88782: LD_VAR 0 3
88786: PUSH
88787: LD_INT 111
88789: EQUAL
88790: IFFALSE 88800
// sOil := true ;
88792: LD_ADDR_EXP 168
88796: PUSH
88797: LD_INT 1
88799: ST_TO_ADDR
// if p3 = 112 then
88800: LD_VAR 0 3
88804: PUSH
88805: LD_INT 112
88807: EQUAL
88808: IFFALSE 88818
// sStu := true ;
88810: LD_ADDR_EXP 172
88814: PUSH
88815: LD_INT 1
88817: ST_TO_ADDR
// if p3 = 113 then
88818: LD_VAR 0 3
88822: PUSH
88823: LD_INT 113
88825: EQUAL
88826: IFFALSE 88836
// sBazooka := true ;
88828: LD_ADDR_EXP 175
88832: PUSH
88833: LD_INT 1
88835: ST_TO_ADDR
// if p3 = 114 then
88836: LD_VAR 0 3
88840: PUSH
88841: LD_INT 114
88843: EQUAL
88844: IFFALSE 88854
// sMortar := true ;
88846: LD_ADDR_EXP 176
88850: PUSH
88851: LD_INT 1
88853: ST_TO_ADDR
// if p3 = 115 then
88854: LD_VAR 0 3
88858: PUSH
88859: LD_INT 115
88861: EQUAL
88862: IFFALSE 88872
// sRanger := true ;
88864: LD_ADDR_EXP 186
88868: PUSH
88869: LD_INT 1
88871: ST_TO_ADDR
// end ; if p2 = 101 then
88872: LD_VAR 0 2
88876: PUSH
88877: LD_INT 101
88879: EQUAL
88880: IFFALSE 89008
// begin case p3 of 1 :
88882: LD_VAR 0 3
88886: PUSH
88887: LD_INT 1
88889: DOUBLE
88890: EQUAL
88891: IFTRUE 88895
88893: GO 88902
88895: POP
// hHackUnlimitedResources ; 2 :
88896: CALL 100043 0 0
88900: GO 89008
88902: LD_INT 2
88904: DOUBLE
88905: EQUAL
88906: IFTRUE 88910
88908: GO 88917
88910: POP
// hHackSetLevel10 ; 3 :
88911: CALL 100176 0 0
88915: GO 89008
88917: LD_INT 3
88919: DOUBLE
88920: EQUAL
88921: IFTRUE 88925
88923: GO 88932
88925: POP
// hHackSetLevel10YourUnits ; 4 :
88926: CALL 100261 0 0
88930: GO 89008
88932: LD_INT 4
88934: DOUBLE
88935: EQUAL
88936: IFTRUE 88940
88938: GO 88947
88940: POP
// hHackInvincible ; 5 :
88941: CALL 100709 0 0
88945: GO 89008
88947: LD_INT 5
88949: DOUBLE
88950: EQUAL
88951: IFTRUE 88955
88953: GO 88962
88955: POP
// hHackInvisible ; 6 :
88956: CALL 100820 0 0
88960: GO 89008
88962: LD_INT 6
88964: DOUBLE
88965: EQUAL
88966: IFTRUE 88970
88968: GO 88977
88970: POP
// hHackChangeYourSide ; 7 :
88971: CALL 100877 0 0
88975: GO 89008
88977: LD_INT 7
88979: DOUBLE
88980: EQUAL
88981: IFTRUE 88985
88983: GO 88992
88985: POP
// hHackChangeUnitSide ; 8 :
88986: CALL 100919 0 0
88990: GO 89008
88992: LD_INT 8
88994: DOUBLE
88995: EQUAL
88996: IFTRUE 89000
88998: GO 89007
89000: POP
// hHackFog ; end ;
89001: CALL 101020 0 0
89005: GO 89008
89007: POP
// end ; end ;
89008: PPOPN 6
89010: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89011: GO 89013
89013: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89014: LD_STRING initStreamRollete();
89016: PPUSH
89017: CALL_OW 559
// InitStreamMode ;
89021: CALL 89030 0 0
// DefineStreamItems ( ) ;
89025: CALL 89470 0 0
// end ;
89029: END
// function InitStreamMode ; begin
89030: LD_INT 0
89032: PPUSH
// streamModeActive := false ;
89033: LD_ADDR_EXP 133
89037: PUSH
89038: LD_INT 0
89040: ST_TO_ADDR
// normalCounter := 36 ;
89041: LD_ADDR_EXP 134
89045: PUSH
89046: LD_INT 36
89048: ST_TO_ADDR
// hardcoreCounter := 16 ;
89049: LD_ADDR_EXP 135
89053: PUSH
89054: LD_INT 16
89056: ST_TO_ADDR
// sRocket := false ;
89057: LD_ADDR_EXP 138
89061: PUSH
89062: LD_INT 0
89064: ST_TO_ADDR
// sSpeed := false ;
89065: LD_ADDR_EXP 137
89069: PUSH
89070: LD_INT 0
89072: ST_TO_ADDR
// sEngine := false ;
89073: LD_ADDR_EXP 139
89077: PUSH
89078: LD_INT 0
89080: ST_TO_ADDR
// sSpec := false ;
89081: LD_ADDR_EXP 136
89085: PUSH
89086: LD_INT 0
89088: ST_TO_ADDR
// sLevel := false ;
89089: LD_ADDR_EXP 140
89093: PUSH
89094: LD_INT 0
89096: ST_TO_ADDR
// sArmoury := false ;
89097: LD_ADDR_EXP 141
89101: PUSH
89102: LD_INT 0
89104: ST_TO_ADDR
// sRadar := false ;
89105: LD_ADDR_EXP 142
89109: PUSH
89110: LD_INT 0
89112: ST_TO_ADDR
// sBunker := false ;
89113: LD_ADDR_EXP 143
89117: PUSH
89118: LD_INT 0
89120: ST_TO_ADDR
// sHack := false ;
89121: LD_ADDR_EXP 144
89125: PUSH
89126: LD_INT 0
89128: ST_TO_ADDR
// sFire := false ;
89129: LD_ADDR_EXP 145
89133: PUSH
89134: LD_INT 0
89136: ST_TO_ADDR
// sRefresh := false ;
89137: LD_ADDR_EXP 146
89141: PUSH
89142: LD_INT 0
89144: ST_TO_ADDR
// sExp := false ;
89145: LD_ADDR_EXP 147
89149: PUSH
89150: LD_INT 0
89152: ST_TO_ADDR
// sDepot := false ;
89153: LD_ADDR_EXP 148
89157: PUSH
89158: LD_INT 0
89160: ST_TO_ADDR
// sFlag := false ;
89161: LD_ADDR_EXP 149
89165: PUSH
89166: LD_INT 0
89168: ST_TO_ADDR
// sKamikadze := false ;
89169: LD_ADDR_EXP 157
89173: PUSH
89174: LD_INT 0
89176: ST_TO_ADDR
// sTroll := false ;
89177: LD_ADDR_EXP 158
89181: PUSH
89182: LD_INT 0
89184: ST_TO_ADDR
// sSlow := false ;
89185: LD_ADDR_EXP 159
89189: PUSH
89190: LD_INT 0
89192: ST_TO_ADDR
// sLack := false ;
89193: LD_ADDR_EXP 160
89197: PUSH
89198: LD_INT 0
89200: ST_TO_ADDR
// sTank := false ;
89201: LD_ADDR_EXP 162
89205: PUSH
89206: LD_INT 0
89208: ST_TO_ADDR
// sRemote := false ;
89209: LD_ADDR_EXP 163
89213: PUSH
89214: LD_INT 0
89216: ST_TO_ADDR
// sPowell := false ;
89217: LD_ADDR_EXP 164
89221: PUSH
89222: LD_INT 0
89224: ST_TO_ADDR
// sTeleport := false ;
89225: LD_ADDR_EXP 167
89229: PUSH
89230: LD_INT 0
89232: ST_TO_ADDR
// sOilTower := false ;
89233: LD_ADDR_EXP 169
89237: PUSH
89238: LD_INT 0
89240: ST_TO_ADDR
// sShovel := false ;
89241: LD_ADDR_EXP 170
89245: PUSH
89246: LD_INT 0
89248: ST_TO_ADDR
// sSheik := false ;
89249: LD_ADDR_EXP 171
89253: PUSH
89254: LD_INT 0
89256: ST_TO_ADDR
// sEarthquake := false ;
89257: LD_ADDR_EXP 173
89261: PUSH
89262: LD_INT 0
89264: ST_TO_ADDR
// sAI := false ;
89265: LD_ADDR_EXP 174
89269: PUSH
89270: LD_INT 0
89272: ST_TO_ADDR
// sCargo := false ;
89273: LD_ADDR_EXP 177
89277: PUSH
89278: LD_INT 0
89280: ST_TO_ADDR
// sDLaser := false ;
89281: LD_ADDR_EXP 178
89285: PUSH
89286: LD_INT 0
89288: ST_TO_ADDR
// sExchange := false ;
89289: LD_ADDR_EXP 179
89293: PUSH
89294: LD_INT 0
89296: ST_TO_ADDR
// sFac := false ;
89297: LD_ADDR_EXP 180
89301: PUSH
89302: LD_INT 0
89304: ST_TO_ADDR
// sPower := false ;
89305: LD_ADDR_EXP 181
89309: PUSH
89310: LD_INT 0
89312: ST_TO_ADDR
// sRandom := false ;
89313: LD_ADDR_EXP 182
89317: PUSH
89318: LD_INT 0
89320: ST_TO_ADDR
// sShield := false ;
89321: LD_ADDR_EXP 183
89325: PUSH
89326: LD_INT 0
89328: ST_TO_ADDR
// sTime := false ;
89329: LD_ADDR_EXP 184
89333: PUSH
89334: LD_INT 0
89336: ST_TO_ADDR
// sTools := false ;
89337: LD_ADDR_EXP 185
89341: PUSH
89342: LD_INT 0
89344: ST_TO_ADDR
// sSold := false ;
89345: LD_ADDR_EXP 150
89349: PUSH
89350: LD_INT 0
89352: ST_TO_ADDR
// sDiff := false ;
89353: LD_ADDR_EXP 151
89357: PUSH
89358: LD_INT 0
89360: ST_TO_ADDR
// sFog := false ;
89361: LD_ADDR_EXP 154
89365: PUSH
89366: LD_INT 0
89368: ST_TO_ADDR
// sReset := false ;
89369: LD_ADDR_EXP 155
89373: PUSH
89374: LD_INT 0
89376: ST_TO_ADDR
// sSun := false ;
89377: LD_ADDR_EXP 156
89381: PUSH
89382: LD_INT 0
89384: ST_TO_ADDR
// sTiger := false ;
89385: LD_ADDR_EXP 152
89389: PUSH
89390: LD_INT 0
89392: ST_TO_ADDR
// sBomb := false ;
89393: LD_ADDR_EXP 153
89397: PUSH
89398: LD_INT 0
89400: ST_TO_ADDR
// sWound := false ;
89401: LD_ADDR_EXP 161
89405: PUSH
89406: LD_INT 0
89408: ST_TO_ADDR
// sBetray := false ;
89409: LD_ADDR_EXP 165
89413: PUSH
89414: LD_INT 0
89416: ST_TO_ADDR
// sContamin := false ;
89417: LD_ADDR_EXP 166
89421: PUSH
89422: LD_INT 0
89424: ST_TO_ADDR
// sOil := false ;
89425: LD_ADDR_EXP 168
89429: PUSH
89430: LD_INT 0
89432: ST_TO_ADDR
// sStu := false ;
89433: LD_ADDR_EXP 172
89437: PUSH
89438: LD_INT 0
89440: ST_TO_ADDR
// sBazooka := false ;
89441: LD_ADDR_EXP 175
89445: PUSH
89446: LD_INT 0
89448: ST_TO_ADDR
// sMortar := false ;
89449: LD_ADDR_EXP 176
89453: PUSH
89454: LD_INT 0
89456: ST_TO_ADDR
// sRanger := false ;
89457: LD_ADDR_EXP 186
89461: PUSH
89462: LD_INT 0
89464: ST_TO_ADDR
// end ;
89465: LD_VAR 0 1
89469: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
89470: LD_INT 0
89472: PPUSH
89473: PPUSH
89474: PPUSH
89475: PPUSH
89476: PPUSH
// result := [ ] ;
89477: LD_ADDR_VAR 0 1
89481: PUSH
89482: EMPTY
89483: ST_TO_ADDR
// if campaign_id = 1 then
89484: LD_OWVAR 69
89488: PUSH
89489: LD_INT 1
89491: EQUAL
89492: IFFALSE 92430
// begin case mission_number of 1 :
89494: LD_OWVAR 70
89498: PUSH
89499: LD_INT 1
89501: DOUBLE
89502: EQUAL
89503: IFTRUE 89507
89505: GO 89571
89507: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
89508: LD_ADDR_VAR 0 1
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: LD_INT 4
89518: PUSH
89519: LD_INT 11
89521: PUSH
89522: LD_INT 12
89524: PUSH
89525: LD_INT 15
89527: PUSH
89528: LD_INT 16
89530: PUSH
89531: LD_INT 22
89533: PUSH
89534: LD_INT 23
89536: PUSH
89537: LD_INT 26
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 101
89553: PUSH
89554: LD_INT 102
89556: PUSH
89557: LD_INT 106
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: LIST
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: ST_TO_ADDR
89569: GO 92428
89571: LD_INT 2
89573: DOUBLE
89574: EQUAL
89575: IFTRUE 89579
89577: GO 89651
89579: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
89580: LD_ADDR_VAR 0 1
89584: PUSH
89585: LD_INT 2
89587: PUSH
89588: LD_INT 4
89590: PUSH
89591: LD_INT 11
89593: PUSH
89594: LD_INT 12
89596: PUSH
89597: LD_INT 15
89599: PUSH
89600: LD_INT 16
89602: PUSH
89603: LD_INT 22
89605: PUSH
89606: LD_INT 23
89608: PUSH
89609: LD_INT 26
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 101
89625: PUSH
89626: LD_INT 102
89628: PUSH
89629: LD_INT 105
89631: PUSH
89632: LD_INT 106
89634: PUSH
89635: LD_INT 108
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: ST_TO_ADDR
89649: GO 92428
89651: LD_INT 3
89653: DOUBLE
89654: EQUAL
89655: IFTRUE 89659
89657: GO 89735
89659: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
89660: LD_ADDR_VAR 0 1
89664: PUSH
89665: LD_INT 2
89667: PUSH
89668: LD_INT 4
89670: PUSH
89671: LD_INT 5
89673: PUSH
89674: LD_INT 11
89676: PUSH
89677: LD_INT 12
89679: PUSH
89680: LD_INT 15
89682: PUSH
89683: LD_INT 16
89685: PUSH
89686: LD_INT 22
89688: PUSH
89689: LD_INT 26
89691: PUSH
89692: LD_INT 36
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 101
89709: PUSH
89710: LD_INT 102
89712: PUSH
89713: LD_INT 105
89715: PUSH
89716: LD_INT 106
89718: PUSH
89719: LD_INT 108
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: ST_TO_ADDR
89733: GO 92428
89735: LD_INT 4
89737: DOUBLE
89738: EQUAL
89739: IFTRUE 89743
89741: GO 89827
89743: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89744: LD_ADDR_VAR 0 1
89748: PUSH
89749: LD_INT 2
89751: PUSH
89752: LD_INT 4
89754: PUSH
89755: LD_INT 5
89757: PUSH
89758: LD_INT 8
89760: PUSH
89761: LD_INT 11
89763: PUSH
89764: LD_INT 12
89766: PUSH
89767: LD_INT 15
89769: PUSH
89770: LD_INT 16
89772: PUSH
89773: LD_INT 22
89775: PUSH
89776: LD_INT 23
89778: PUSH
89779: LD_INT 26
89781: PUSH
89782: LD_INT 36
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 101
89801: PUSH
89802: LD_INT 102
89804: PUSH
89805: LD_INT 105
89807: PUSH
89808: LD_INT 106
89810: PUSH
89811: LD_INT 108
89813: PUSH
89814: EMPTY
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: ST_TO_ADDR
89825: GO 92428
89827: LD_INT 5
89829: DOUBLE
89830: EQUAL
89831: IFTRUE 89835
89833: GO 89935
89835: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89836: LD_ADDR_VAR 0 1
89840: PUSH
89841: LD_INT 2
89843: PUSH
89844: LD_INT 4
89846: PUSH
89847: LD_INT 5
89849: PUSH
89850: LD_INT 6
89852: PUSH
89853: LD_INT 8
89855: PUSH
89856: LD_INT 11
89858: PUSH
89859: LD_INT 12
89861: PUSH
89862: LD_INT 15
89864: PUSH
89865: LD_INT 16
89867: PUSH
89868: LD_INT 22
89870: PUSH
89871: LD_INT 23
89873: PUSH
89874: LD_INT 25
89876: PUSH
89877: LD_INT 26
89879: PUSH
89880: LD_INT 36
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 101
89901: PUSH
89902: LD_INT 102
89904: PUSH
89905: LD_INT 105
89907: PUSH
89908: LD_INT 106
89910: PUSH
89911: LD_INT 108
89913: PUSH
89914: LD_INT 109
89916: PUSH
89917: LD_INT 112
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: ST_TO_ADDR
89933: GO 92428
89935: LD_INT 6
89937: DOUBLE
89938: EQUAL
89939: IFTRUE 89943
89941: GO 90063
89943: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89944: LD_ADDR_VAR 0 1
89948: PUSH
89949: LD_INT 2
89951: PUSH
89952: LD_INT 4
89954: PUSH
89955: LD_INT 5
89957: PUSH
89958: LD_INT 6
89960: PUSH
89961: LD_INT 8
89963: PUSH
89964: LD_INT 11
89966: PUSH
89967: LD_INT 12
89969: PUSH
89970: LD_INT 15
89972: PUSH
89973: LD_INT 16
89975: PUSH
89976: LD_INT 20
89978: PUSH
89979: LD_INT 21
89981: PUSH
89982: LD_INT 22
89984: PUSH
89985: LD_INT 23
89987: PUSH
89988: LD_INT 25
89990: PUSH
89991: LD_INT 26
89993: PUSH
89994: LD_INT 30
89996: PUSH
89997: LD_INT 31
89999: PUSH
90000: LD_INT 32
90002: PUSH
90003: LD_INT 36
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 101
90029: PUSH
90030: LD_INT 102
90032: PUSH
90033: LD_INT 105
90035: PUSH
90036: LD_INT 106
90038: PUSH
90039: LD_INT 108
90041: PUSH
90042: LD_INT 109
90044: PUSH
90045: LD_INT 112
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: ST_TO_ADDR
90061: GO 92428
90063: LD_INT 7
90065: DOUBLE
90066: EQUAL
90067: IFTRUE 90071
90069: GO 90171
90071: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90072: LD_ADDR_VAR 0 1
90076: PUSH
90077: LD_INT 2
90079: PUSH
90080: LD_INT 4
90082: PUSH
90083: LD_INT 5
90085: PUSH
90086: LD_INT 7
90088: PUSH
90089: LD_INT 11
90091: PUSH
90092: LD_INT 12
90094: PUSH
90095: LD_INT 15
90097: PUSH
90098: LD_INT 16
90100: PUSH
90101: LD_INT 20
90103: PUSH
90104: LD_INT 21
90106: PUSH
90107: LD_INT 22
90109: PUSH
90110: LD_INT 23
90112: PUSH
90113: LD_INT 25
90115: PUSH
90116: LD_INT 26
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 101
90137: PUSH
90138: LD_INT 102
90140: PUSH
90141: LD_INT 103
90143: PUSH
90144: LD_INT 105
90146: PUSH
90147: LD_INT 106
90149: PUSH
90150: LD_INT 108
90152: PUSH
90153: LD_INT 112
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: ST_TO_ADDR
90169: GO 92428
90171: LD_INT 8
90173: DOUBLE
90174: EQUAL
90175: IFTRUE 90179
90177: GO 90307
90179: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90180: LD_ADDR_VAR 0 1
90184: PUSH
90185: LD_INT 2
90187: PUSH
90188: LD_INT 4
90190: PUSH
90191: LD_INT 5
90193: PUSH
90194: LD_INT 6
90196: PUSH
90197: LD_INT 7
90199: PUSH
90200: LD_INT 8
90202: PUSH
90203: LD_INT 11
90205: PUSH
90206: LD_INT 12
90208: PUSH
90209: LD_INT 15
90211: PUSH
90212: LD_INT 16
90214: PUSH
90215: LD_INT 20
90217: PUSH
90218: LD_INT 21
90220: PUSH
90221: LD_INT 22
90223: PUSH
90224: LD_INT 23
90226: PUSH
90227: LD_INT 25
90229: PUSH
90230: LD_INT 26
90232: PUSH
90233: LD_INT 30
90235: PUSH
90236: LD_INT 31
90238: PUSH
90239: LD_INT 32
90241: PUSH
90242: LD_INT 36
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 101
90269: PUSH
90270: LD_INT 102
90272: PUSH
90273: LD_INT 103
90275: PUSH
90276: LD_INT 105
90278: PUSH
90279: LD_INT 106
90281: PUSH
90282: LD_INT 108
90284: PUSH
90285: LD_INT 109
90287: PUSH
90288: LD_INT 112
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: ST_TO_ADDR
90305: GO 92428
90307: LD_INT 9
90309: DOUBLE
90310: EQUAL
90311: IFTRUE 90315
90313: GO 90451
90315: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
90316: LD_ADDR_VAR 0 1
90320: PUSH
90321: LD_INT 2
90323: PUSH
90324: LD_INT 4
90326: PUSH
90327: LD_INT 5
90329: PUSH
90330: LD_INT 6
90332: PUSH
90333: LD_INT 7
90335: PUSH
90336: LD_INT 8
90338: PUSH
90339: LD_INT 11
90341: PUSH
90342: LD_INT 12
90344: PUSH
90345: LD_INT 15
90347: PUSH
90348: LD_INT 16
90350: PUSH
90351: LD_INT 20
90353: PUSH
90354: LD_INT 21
90356: PUSH
90357: LD_INT 22
90359: PUSH
90360: LD_INT 23
90362: PUSH
90363: LD_INT 25
90365: PUSH
90366: LD_INT 26
90368: PUSH
90369: LD_INT 28
90371: PUSH
90372: LD_INT 30
90374: PUSH
90375: LD_INT 31
90377: PUSH
90378: LD_INT 32
90380: PUSH
90381: LD_INT 36
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 101
90409: PUSH
90410: LD_INT 102
90412: PUSH
90413: LD_INT 103
90415: PUSH
90416: LD_INT 105
90418: PUSH
90419: LD_INT 106
90421: PUSH
90422: LD_INT 108
90424: PUSH
90425: LD_INT 109
90427: PUSH
90428: LD_INT 112
90430: PUSH
90431: LD_INT 114
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: ST_TO_ADDR
90449: GO 92428
90451: LD_INT 10
90453: DOUBLE
90454: EQUAL
90455: IFTRUE 90459
90457: GO 90643
90459: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
90460: LD_ADDR_VAR 0 1
90464: PUSH
90465: LD_INT 2
90467: PUSH
90468: LD_INT 4
90470: PUSH
90471: LD_INT 5
90473: PUSH
90474: LD_INT 6
90476: PUSH
90477: LD_INT 7
90479: PUSH
90480: LD_INT 8
90482: PUSH
90483: LD_INT 9
90485: PUSH
90486: LD_INT 10
90488: PUSH
90489: LD_INT 11
90491: PUSH
90492: LD_INT 12
90494: PUSH
90495: LD_INT 13
90497: PUSH
90498: LD_INT 14
90500: PUSH
90501: LD_INT 15
90503: PUSH
90504: LD_INT 16
90506: PUSH
90507: LD_INT 17
90509: PUSH
90510: LD_INT 18
90512: PUSH
90513: LD_INT 19
90515: PUSH
90516: LD_INT 20
90518: PUSH
90519: LD_INT 21
90521: PUSH
90522: LD_INT 22
90524: PUSH
90525: LD_INT 23
90527: PUSH
90528: LD_INT 24
90530: PUSH
90531: LD_INT 25
90533: PUSH
90534: LD_INT 26
90536: PUSH
90537: LD_INT 28
90539: PUSH
90540: LD_INT 30
90542: PUSH
90543: LD_INT 31
90545: PUSH
90546: LD_INT 32
90548: PUSH
90549: LD_INT 36
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 101
90585: PUSH
90586: LD_INT 102
90588: PUSH
90589: LD_INT 103
90591: PUSH
90592: LD_INT 104
90594: PUSH
90595: LD_INT 105
90597: PUSH
90598: LD_INT 106
90600: PUSH
90601: LD_INT 107
90603: PUSH
90604: LD_INT 108
90606: PUSH
90607: LD_INT 109
90609: PUSH
90610: LD_INT 110
90612: PUSH
90613: LD_INT 111
90615: PUSH
90616: LD_INT 112
90618: PUSH
90619: LD_INT 114
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: ST_TO_ADDR
90641: GO 92428
90643: LD_INT 11
90645: DOUBLE
90646: EQUAL
90647: IFTRUE 90651
90649: GO 90843
90651: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
90652: LD_ADDR_VAR 0 1
90656: PUSH
90657: LD_INT 2
90659: PUSH
90660: LD_INT 3
90662: PUSH
90663: LD_INT 4
90665: PUSH
90666: LD_INT 5
90668: PUSH
90669: LD_INT 6
90671: PUSH
90672: LD_INT 7
90674: PUSH
90675: LD_INT 8
90677: PUSH
90678: LD_INT 9
90680: PUSH
90681: LD_INT 10
90683: PUSH
90684: LD_INT 11
90686: PUSH
90687: LD_INT 12
90689: PUSH
90690: LD_INT 13
90692: PUSH
90693: LD_INT 14
90695: PUSH
90696: LD_INT 15
90698: PUSH
90699: LD_INT 16
90701: PUSH
90702: LD_INT 17
90704: PUSH
90705: LD_INT 18
90707: PUSH
90708: LD_INT 19
90710: PUSH
90711: LD_INT 20
90713: PUSH
90714: LD_INT 21
90716: PUSH
90717: LD_INT 22
90719: PUSH
90720: LD_INT 23
90722: PUSH
90723: LD_INT 24
90725: PUSH
90726: LD_INT 25
90728: PUSH
90729: LD_INT 26
90731: PUSH
90732: LD_INT 28
90734: PUSH
90735: LD_INT 30
90737: PUSH
90738: LD_INT 31
90740: PUSH
90741: LD_INT 32
90743: PUSH
90744: LD_INT 34
90746: PUSH
90747: LD_INT 36
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 101
90785: PUSH
90786: LD_INT 102
90788: PUSH
90789: LD_INT 103
90791: PUSH
90792: LD_INT 104
90794: PUSH
90795: LD_INT 105
90797: PUSH
90798: LD_INT 106
90800: PUSH
90801: LD_INT 107
90803: PUSH
90804: LD_INT 108
90806: PUSH
90807: LD_INT 109
90809: PUSH
90810: LD_INT 110
90812: PUSH
90813: LD_INT 111
90815: PUSH
90816: LD_INT 112
90818: PUSH
90819: LD_INT 114
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: ST_TO_ADDR
90841: GO 92428
90843: LD_INT 12
90845: DOUBLE
90846: EQUAL
90847: IFTRUE 90851
90849: GO 91059
90851: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90852: LD_ADDR_VAR 0 1
90856: PUSH
90857: LD_INT 1
90859: PUSH
90860: LD_INT 2
90862: PUSH
90863: LD_INT 3
90865: PUSH
90866: LD_INT 4
90868: PUSH
90869: LD_INT 5
90871: PUSH
90872: LD_INT 6
90874: PUSH
90875: LD_INT 7
90877: PUSH
90878: LD_INT 8
90880: PUSH
90881: LD_INT 9
90883: PUSH
90884: LD_INT 10
90886: PUSH
90887: LD_INT 11
90889: PUSH
90890: LD_INT 12
90892: PUSH
90893: LD_INT 13
90895: PUSH
90896: LD_INT 14
90898: PUSH
90899: LD_INT 15
90901: PUSH
90902: LD_INT 16
90904: PUSH
90905: LD_INT 17
90907: PUSH
90908: LD_INT 18
90910: PUSH
90911: LD_INT 19
90913: PUSH
90914: LD_INT 20
90916: PUSH
90917: LD_INT 21
90919: PUSH
90920: LD_INT 22
90922: PUSH
90923: LD_INT 23
90925: PUSH
90926: LD_INT 24
90928: PUSH
90929: LD_INT 25
90931: PUSH
90932: LD_INT 26
90934: PUSH
90935: LD_INT 27
90937: PUSH
90938: LD_INT 28
90940: PUSH
90941: LD_INT 30
90943: PUSH
90944: LD_INT 31
90946: PUSH
90947: LD_INT 32
90949: PUSH
90950: LD_INT 33
90952: PUSH
90953: LD_INT 34
90955: PUSH
90956: LD_INT 36
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: LIST
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 101
90997: PUSH
90998: LD_INT 102
91000: PUSH
91001: LD_INT 103
91003: PUSH
91004: LD_INT 104
91006: PUSH
91007: LD_INT 105
91009: PUSH
91010: LD_INT 106
91012: PUSH
91013: LD_INT 107
91015: PUSH
91016: LD_INT 108
91018: PUSH
91019: LD_INT 109
91021: PUSH
91022: LD_INT 110
91024: PUSH
91025: LD_INT 111
91027: PUSH
91028: LD_INT 112
91030: PUSH
91031: LD_INT 113
91033: PUSH
91034: LD_INT 114
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: ST_TO_ADDR
91057: GO 92428
91059: LD_INT 13
91061: DOUBLE
91062: EQUAL
91063: IFTRUE 91067
91065: GO 91263
91067: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91068: LD_ADDR_VAR 0 1
91072: PUSH
91073: LD_INT 1
91075: PUSH
91076: LD_INT 2
91078: PUSH
91079: LD_INT 3
91081: PUSH
91082: LD_INT 4
91084: PUSH
91085: LD_INT 5
91087: PUSH
91088: LD_INT 8
91090: PUSH
91091: LD_INT 9
91093: PUSH
91094: LD_INT 10
91096: PUSH
91097: LD_INT 11
91099: PUSH
91100: LD_INT 12
91102: PUSH
91103: LD_INT 14
91105: PUSH
91106: LD_INT 15
91108: PUSH
91109: LD_INT 16
91111: PUSH
91112: LD_INT 17
91114: PUSH
91115: LD_INT 18
91117: PUSH
91118: LD_INT 19
91120: PUSH
91121: LD_INT 20
91123: PUSH
91124: LD_INT 21
91126: PUSH
91127: LD_INT 22
91129: PUSH
91130: LD_INT 23
91132: PUSH
91133: LD_INT 24
91135: PUSH
91136: LD_INT 25
91138: PUSH
91139: LD_INT 26
91141: PUSH
91142: LD_INT 27
91144: PUSH
91145: LD_INT 28
91147: PUSH
91148: LD_INT 30
91150: PUSH
91151: LD_INT 31
91153: PUSH
91154: LD_INT 32
91156: PUSH
91157: LD_INT 33
91159: PUSH
91160: LD_INT 34
91162: PUSH
91163: LD_INT 36
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 101
91201: PUSH
91202: LD_INT 102
91204: PUSH
91205: LD_INT 103
91207: PUSH
91208: LD_INT 104
91210: PUSH
91211: LD_INT 105
91213: PUSH
91214: LD_INT 106
91216: PUSH
91217: LD_INT 107
91219: PUSH
91220: LD_INT 108
91222: PUSH
91223: LD_INT 109
91225: PUSH
91226: LD_INT 110
91228: PUSH
91229: LD_INT 111
91231: PUSH
91232: LD_INT 112
91234: PUSH
91235: LD_INT 113
91237: PUSH
91238: LD_INT 114
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: ST_TO_ADDR
91261: GO 92428
91263: LD_INT 14
91265: DOUBLE
91266: EQUAL
91267: IFTRUE 91271
91269: GO 91483
91271: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
91272: LD_ADDR_VAR 0 1
91276: PUSH
91277: LD_INT 1
91279: PUSH
91280: LD_INT 2
91282: PUSH
91283: LD_INT 3
91285: PUSH
91286: LD_INT 4
91288: PUSH
91289: LD_INT 5
91291: PUSH
91292: LD_INT 6
91294: PUSH
91295: LD_INT 7
91297: PUSH
91298: LD_INT 8
91300: PUSH
91301: LD_INT 9
91303: PUSH
91304: LD_INT 10
91306: PUSH
91307: LD_INT 11
91309: PUSH
91310: LD_INT 12
91312: PUSH
91313: LD_INT 13
91315: PUSH
91316: LD_INT 14
91318: PUSH
91319: LD_INT 15
91321: PUSH
91322: LD_INT 16
91324: PUSH
91325: LD_INT 17
91327: PUSH
91328: LD_INT 18
91330: PUSH
91331: LD_INT 19
91333: PUSH
91334: LD_INT 20
91336: PUSH
91337: LD_INT 21
91339: PUSH
91340: LD_INT 22
91342: PUSH
91343: LD_INT 23
91345: PUSH
91346: LD_INT 24
91348: PUSH
91349: LD_INT 25
91351: PUSH
91352: LD_INT 26
91354: PUSH
91355: LD_INT 27
91357: PUSH
91358: LD_INT 28
91360: PUSH
91361: LD_INT 29
91363: PUSH
91364: LD_INT 30
91366: PUSH
91367: LD_INT 31
91369: PUSH
91370: LD_INT 32
91372: PUSH
91373: LD_INT 33
91375: PUSH
91376: LD_INT 34
91378: PUSH
91379: LD_INT 36
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 101
91421: PUSH
91422: LD_INT 102
91424: PUSH
91425: LD_INT 103
91427: PUSH
91428: LD_INT 104
91430: PUSH
91431: LD_INT 105
91433: PUSH
91434: LD_INT 106
91436: PUSH
91437: LD_INT 107
91439: PUSH
91440: LD_INT 108
91442: PUSH
91443: LD_INT 109
91445: PUSH
91446: LD_INT 110
91448: PUSH
91449: LD_INT 111
91451: PUSH
91452: LD_INT 112
91454: PUSH
91455: LD_INT 113
91457: PUSH
91458: LD_INT 114
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: ST_TO_ADDR
91481: GO 92428
91483: LD_INT 15
91485: DOUBLE
91486: EQUAL
91487: IFTRUE 91491
91489: GO 91703
91491: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
91492: LD_ADDR_VAR 0 1
91496: PUSH
91497: LD_INT 1
91499: PUSH
91500: LD_INT 2
91502: PUSH
91503: LD_INT 3
91505: PUSH
91506: LD_INT 4
91508: PUSH
91509: LD_INT 5
91511: PUSH
91512: LD_INT 6
91514: PUSH
91515: LD_INT 7
91517: PUSH
91518: LD_INT 8
91520: PUSH
91521: LD_INT 9
91523: PUSH
91524: LD_INT 10
91526: PUSH
91527: LD_INT 11
91529: PUSH
91530: LD_INT 12
91532: PUSH
91533: LD_INT 13
91535: PUSH
91536: LD_INT 14
91538: PUSH
91539: LD_INT 15
91541: PUSH
91542: LD_INT 16
91544: PUSH
91545: LD_INT 17
91547: PUSH
91548: LD_INT 18
91550: PUSH
91551: LD_INT 19
91553: PUSH
91554: LD_INT 20
91556: PUSH
91557: LD_INT 21
91559: PUSH
91560: LD_INT 22
91562: PUSH
91563: LD_INT 23
91565: PUSH
91566: LD_INT 24
91568: PUSH
91569: LD_INT 25
91571: PUSH
91572: LD_INT 26
91574: PUSH
91575: LD_INT 27
91577: PUSH
91578: LD_INT 28
91580: PUSH
91581: LD_INT 29
91583: PUSH
91584: LD_INT 30
91586: PUSH
91587: LD_INT 31
91589: PUSH
91590: LD_INT 32
91592: PUSH
91593: LD_INT 33
91595: PUSH
91596: LD_INT 34
91598: PUSH
91599: LD_INT 36
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 101
91641: PUSH
91642: LD_INT 102
91644: PUSH
91645: LD_INT 103
91647: PUSH
91648: LD_INT 104
91650: PUSH
91651: LD_INT 105
91653: PUSH
91654: LD_INT 106
91656: PUSH
91657: LD_INT 107
91659: PUSH
91660: LD_INT 108
91662: PUSH
91663: LD_INT 109
91665: PUSH
91666: LD_INT 110
91668: PUSH
91669: LD_INT 111
91671: PUSH
91672: LD_INT 112
91674: PUSH
91675: LD_INT 113
91677: PUSH
91678: LD_INT 114
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: ST_TO_ADDR
91701: GO 92428
91703: LD_INT 16
91705: DOUBLE
91706: EQUAL
91707: IFTRUE 91711
91709: GO 91835
91711: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91712: LD_ADDR_VAR 0 1
91716: PUSH
91717: LD_INT 2
91719: PUSH
91720: LD_INT 4
91722: PUSH
91723: LD_INT 5
91725: PUSH
91726: LD_INT 7
91728: PUSH
91729: LD_INT 11
91731: PUSH
91732: LD_INT 12
91734: PUSH
91735: LD_INT 15
91737: PUSH
91738: LD_INT 16
91740: PUSH
91741: LD_INT 20
91743: PUSH
91744: LD_INT 21
91746: PUSH
91747: LD_INT 22
91749: PUSH
91750: LD_INT 23
91752: PUSH
91753: LD_INT 25
91755: PUSH
91756: LD_INT 26
91758: PUSH
91759: LD_INT 30
91761: PUSH
91762: LD_INT 31
91764: PUSH
91765: LD_INT 32
91767: PUSH
91768: LD_INT 33
91770: PUSH
91771: LD_INT 34
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 101
91797: PUSH
91798: LD_INT 102
91800: PUSH
91801: LD_INT 103
91803: PUSH
91804: LD_INT 106
91806: PUSH
91807: LD_INT 108
91809: PUSH
91810: LD_INT 112
91812: PUSH
91813: LD_INT 113
91815: PUSH
91816: LD_INT 114
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: ST_TO_ADDR
91833: GO 92428
91835: LD_INT 17
91837: DOUBLE
91838: EQUAL
91839: IFTRUE 91843
91841: GO 92055
91843: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91844: LD_ADDR_VAR 0 1
91848: PUSH
91849: LD_INT 1
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: LD_INT 4
91860: PUSH
91861: LD_INT 5
91863: PUSH
91864: LD_INT 6
91866: PUSH
91867: LD_INT 7
91869: PUSH
91870: LD_INT 8
91872: PUSH
91873: LD_INT 9
91875: PUSH
91876: LD_INT 10
91878: PUSH
91879: LD_INT 11
91881: PUSH
91882: LD_INT 12
91884: PUSH
91885: LD_INT 13
91887: PUSH
91888: LD_INT 14
91890: PUSH
91891: LD_INT 15
91893: PUSH
91894: LD_INT 16
91896: PUSH
91897: LD_INT 17
91899: PUSH
91900: LD_INT 18
91902: PUSH
91903: LD_INT 19
91905: PUSH
91906: LD_INT 20
91908: PUSH
91909: LD_INT 21
91911: PUSH
91912: LD_INT 22
91914: PUSH
91915: LD_INT 23
91917: PUSH
91918: LD_INT 24
91920: PUSH
91921: LD_INT 25
91923: PUSH
91924: LD_INT 26
91926: PUSH
91927: LD_INT 27
91929: PUSH
91930: LD_INT 28
91932: PUSH
91933: LD_INT 29
91935: PUSH
91936: LD_INT 30
91938: PUSH
91939: LD_INT 31
91941: PUSH
91942: LD_INT 32
91944: PUSH
91945: LD_INT 33
91947: PUSH
91948: LD_INT 34
91950: PUSH
91951: LD_INT 36
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 101
91993: PUSH
91994: LD_INT 102
91996: PUSH
91997: LD_INT 103
91999: PUSH
92000: LD_INT 104
92002: PUSH
92003: LD_INT 105
92005: PUSH
92006: LD_INT 106
92008: PUSH
92009: LD_INT 107
92011: PUSH
92012: LD_INT 108
92014: PUSH
92015: LD_INT 109
92017: PUSH
92018: LD_INT 110
92020: PUSH
92021: LD_INT 111
92023: PUSH
92024: LD_INT 112
92026: PUSH
92027: LD_INT 113
92029: PUSH
92030: LD_INT 114
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: ST_TO_ADDR
92053: GO 92428
92055: LD_INT 18
92057: DOUBLE
92058: EQUAL
92059: IFTRUE 92063
92061: GO 92199
92063: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92064: LD_ADDR_VAR 0 1
92068: PUSH
92069: LD_INT 2
92071: PUSH
92072: LD_INT 4
92074: PUSH
92075: LD_INT 5
92077: PUSH
92078: LD_INT 7
92080: PUSH
92081: LD_INT 11
92083: PUSH
92084: LD_INT 12
92086: PUSH
92087: LD_INT 15
92089: PUSH
92090: LD_INT 16
92092: PUSH
92093: LD_INT 20
92095: PUSH
92096: LD_INT 21
92098: PUSH
92099: LD_INT 22
92101: PUSH
92102: LD_INT 23
92104: PUSH
92105: LD_INT 25
92107: PUSH
92108: LD_INT 26
92110: PUSH
92111: LD_INT 30
92113: PUSH
92114: LD_INT 31
92116: PUSH
92117: LD_INT 32
92119: PUSH
92120: LD_INT 33
92122: PUSH
92123: LD_INT 34
92125: PUSH
92126: LD_INT 35
92128: PUSH
92129: LD_INT 36
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: PUSH
92155: LD_INT 101
92157: PUSH
92158: LD_INT 102
92160: PUSH
92161: LD_INT 103
92163: PUSH
92164: LD_INT 106
92166: PUSH
92167: LD_INT 108
92169: PUSH
92170: LD_INT 112
92172: PUSH
92173: LD_INT 113
92175: PUSH
92176: LD_INT 114
92178: PUSH
92179: LD_INT 115
92181: PUSH
92182: EMPTY
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: ST_TO_ADDR
92197: GO 92428
92199: LD_INT 19
92201: DOUBLE
92202: EQUAL
92203: IFTRUE 92207
92205: GO 92427
92207: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92208: LD_ADDR_VAR 0 1
92212: PUSH
92213: LD_INT 1
92215: PUSH
92216: LD_INT 2
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: LD_INT 4
92224: PUSH
92225: LD_INT 5
92227: PUSH
92228: LD_INT 6
92230: PUSH
92231: LD_INT 7
92233: PUSH
92234: LD_INT 8
92236: PUSH
92237: LD_INT 9
92239: PUSH
92240: LD_INT 10
92242: PUSH
92243: LD_INT 11
92245: PUSH
92246: LD_INT 12
92248: PUSH
92249: LD_INT 13
92251: PUSH
92252: LD_INT 14
92254: PUSH
92255: LD_INT 15
92257: PUSH
92258: LD_INT 16
92260: PUSH
92261: LD_INT 17
92263: PUSH
92264: LD_INT 18
92266: PUSH
92267: LD_INT 19
92269: PUSH
92270: LD_INT 20
92272: PUSH
92273: LD_INT 21
92275: PUSH
92276: LD_INT 22
92278: PUSH
92279: LD_INT 23
92281: PUSH
92282: LD_INT 24
92284: PUSH
92285: LD_INT 25
92287: PUSH
92288: LD_INT 26
92290: PUSH
92291: LD_INT 27
92293: PUSH
92294: LD_INT 28
92296: PUSH
92297: LD_INT 29
92299: PUSH
92300: LD_INT 30
92302: PUSH
92303: LD_INT 31
92305: PUSH
92306: LD_INT 32
92308: PUSH
92309: LD_INT 33
92311: PUSH
92312: LD_INT 34
92314: PUSH
92315: LD_INT 35
92317: PUSH
92318: LD_INT 36
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 101
92361: PUSH
92362: LD_INT 102
92364: PUSH
92365: LD_INT 103
92367: PUSH
92368: LD_INT 104
92370: PUSH
92371: LD_INT 105
92373: PUSH
92374: LD_INT 106
92376: PUSH
92377: LD_INT 107
92379: PUSH
92380: LD_INT 108
92382: PUSH
92383: LD_INT 109
92385: PUSH
92386: LD_INT 110
92388: PUSH
92389: LD_INT 111
92391: PUSH
92392: LD_INT 112
92394: PUSH
92395: LD_INT 113
92397: PUSH
92398: LD_INT 114
92400: PUSH
92401: LD_INT 115
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: ST_TO_ADDR
92425: GO 92428
92427: POP
// end else
92428: GO 92647
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
92430: LD_ADDR_VAR 0 1
92434: PUSH
92435: LD_INT 1
92437: PUSH
92438: LD_INT 2
92440: PUSH
92441: LD_INT 3
92443: PUSH
92444: LD_INT 4
92446: PUSH
92447: LD_INT 5
92449: PUSH
92450: LD_INT 6
92452: PUSH
92453: LD_INT 7
92455: PUSH
92456: LD_INT 8
92458: PUSH
92459: LD_INT 9
92461: PUSH
92462: LD_INT 10
92464: PUSH
92465: LD_INT 11
92467: PUSH
92468: LD_INT 12
92470: PUSH
92471: LD_INT 13
92473: PUSH
92474: LD_INT 14
92476: PUSH
92477: LD_INT 15
92479: PUSH
92480: LD_INT 16
92482: PUSH
92483: LD_INT 17
92485: PUSH
92486: LD_INT 18
92488: PUSH
92489: LD_INT 19
92491: PUSH
92492: LD_INT 20
92494: PUSH
92495: LD_INT 21
92497: PUSH
92498: LD_INT 22
92500: PUSH
92501: LD_INT 23
92503: PUSH
92504: LD_INT 24
92506: PUSH
92507: LD_INT 25
92509: PUSH
92510: LD_INT 26
92512: PUSH
92513: LD_INT 27
92515: PUSH
92516: LD_INT 28
92518: PUSH
92519: LD_INT 29
92521: PUSH
92522: LD_INT 30
92524: PUSH
92525: LD_INT 31
92527: PUSH
92528: LD_INT 32
92530: PUSH
92531: LD_INT 33
92533: PUSH
92534: LD_INT 34
92536: PUSH
92537: LD_INT 35
92539: PUSH
92540: LD_INT 36
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: PUSH
92581: LD_INT 101
92583: PUSH
92584: LD_INT 102
92586: PUSH
92587: LD_INT 103
92589: PUSH
92590: LD_INT 104
92592: PUSH
92593: LD_INT 105
92595: PUSH
92596: LD_INT 106
92598: PUSH
92599: LD_INT 107
92601: PUSH
92602: LD_INT 108
92604: PUSH
92605: LD_INT 109
92607: PUSH
92608: LD_INT 110
92610: PUSH
92611: LD_INT 111
92613: PUSH
92614: LD_INT 112
92616: PUSH
92617: LD_INT 113
92619: PUSH
92620: LD_INT 114
92622: PUSH
92623: LD_INT 115
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: ST_TO_ADDR
// if result then
92647: LD_VAR 0 1
92651: IFFALSE 92940
// begin normal :=  ;
92653: LD_ADDR_VAR 0 3
92657: PUSH
92658: LD_STRING 
92660: ST_TO_ADDR
// hardcore :=  ;
92661: LD_ADDR_VAR 0 4
92665: PUSH
92666: LD_STRING 
92668: ST_TO_ADDR
// for i = 1 to normalCounter do
92669: LD_ADDR_VAR 0 5
92673: PUSH
92674: DOUBLE
92675: LD_INT 1
92677: DEC
92678: ST_TO_ADDR
92679: LD_EXP 134
92683: PUSH
92684: FOR_TO
92685: IFFALSE 92786
// begin tmp := 0 ;
92687: LD_ADDR_VAR 0 2
92691: PUSH
92692: LD_STRING 0
92694: ST_TO_ADDR
// if result [ 1 ] then
92695: LD_VAR 0 1
92699: PUSH
92700: LD_INT 1
92702: ARRAY
92703: IFFALSE 92768
// if result [ 1 ] [ 1 ] = i then
92705: LD_VAR 0 1
92709: PUSH
92710: LD_INT 1
92712: ARRAY
92713: PUSH
92714: LD_INT 1
92716: ARRAY
92717: PUSH
92718: LD_VAR 0 5
92722: EQUAL
92723: IFFALSE 92768
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92725: LD_ADDR_VAR 0 1
92729: PUSH
92730: LD_VAR 0 1
92734: PPUSH
92735: LD_INT 1
92737: PPUSH
92738: LD_VAR 0 1
92742: PUSH
92743: LD_INT 1
92745: ARRAY
92746: PPUSH
92747: LD_INT 1
92749: PPUSH
92750: CALL_OW 3
92754: PPUSH
92755: CALL_OW 1
92759: ST_TO_ADDR
// tmp := 1 ;
92760: LD_ADDR_VAR 0 2
92764: PUSH
92765: LD_STRING 1
92767: ST_TO_ADDR
// end ; normal := normal & tmp ;
92768: LD_ADDR_VAR 0 3
92772: PUSH
92773: LD_VAR 0 3
92777: PUSH
92778: LD_VAR 0 2
92782: STR
92783: ST_TO_ADDR
// end ;
92784: GO 92684
92786: POP
92787: POP
// for i = 1 to hardcoreCounter do
92788: LD_ADDR_VAR 0 5
92792: PUSH
92793: DOUBLE
92794: LD_INT 1
92796: DEC
92797: ST_TO_ADDR
92798: LD_EXP 135
92802: PUSH
92803: FOR_TO
92804: IFFALSE 92909
// begin tmp := 0 ;
92806: LD_ADDR_VAR 0 2
92810: PUSH
92811: LD_STRING 0
92813: ST_TO_ADDR
// if result [ 2 ] then
92814: LD_VAR 0 1
92818: PUSH
92819: LD_INT 2
92821: ARRAY
92822: IFFALSE 92891
// if result [ 2 ] [ 1 ] = 100 + i then
92824: LD_VAR 0 1
92828: PUSH
92829: LD_INT 2
92831: ARRAY
92832: PUSH
92833: LD_INT 1
92835: ARRAY
92836: PUSH
92837: LD_INT 100
92839: PUSH
92840: LD_VAR 0 5
92844: PLUS
92845: EQUAL
92846: IFFALSE 92891
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92848: LD_ADDR_VAR 0 1
92852: PUSH
92853: LD_VAR 0 1
92857: PPUSH
92858: LD_INT 2
92860: PPUSH
92861: LD_VAR 0 1
92865: PUSH
92866: LD_INT 2
92868: ARRAY
92869: PPUSH
92870: LD_INT 1
92872: PPUSH
92873: CALL_OW 3
92877: PPUSH
92878: CALL_OW 1
92882: ST_TO_ADDR
// tmp := 1 ;
92883: LD_ADDR_VAR 0 2
92887: PUSH
92888: LD_STRING 1
92890: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92891: LD_ADDR_VAR 0 4
92895: PUSH
92896: LD_VAR 0 4
92900: PUSH
92901: LD_VAR 0 2
92905: STR
92906: ST_TO_ADDR
// end ;
92907: GO 92803
92909: POP
92910: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92911: LD_STRING getStreamItemsFromMission("
92913: PUSH
92914: LD_VAR 0 3
92918: STR
92919: PUSH
92920: LD_STRING ","
92922: STR
92923: PUSH
92924: LD_VAR 0 4
92928: STR
92929: PUSH
92930: LD_STRING ")
92932: STR
92933: PPUSH
92934: CALL_OW 559
// end else
92938: GO 92947
// ToLua ( getStreamItemsFromMission("","") ) ;
92940: LD_STRING getStreamItemsFromMission("","")
92942: PPUSH
92943: CALL_OW 559
// end ;
92947: LD_VAR 0 1
92951: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92952: LD_EXP 133
92956: PUSH
92957: LD_EXP 138
92961: AND
92962: IFFALSE 93086
92964: GO 92966
92966: DISABLE
92967: LD_INT 0
92969: PPUSH
92970: PPUSH
// begin enable ;
92971: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92972: LD_ADDR_VAR 0 2
92976: PUSH
92977: LD_INT 22
92979: PUSH
92980: LD_OWVAR 2
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 2
92991: PUSH
92992: LD_INT 34
92994: PUSH
92995: LD_INT 7
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: LD_INT 34
93004: PUSH
93005: LD_INT 45
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 34
93014: PUSH
93015: LD_INT 28
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 34
93024: PUSH
93025: LD_INT 47
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PPUSH
93043: CALL_OW 69
93047: ST_TO_ADDR
// if not tmp then
93048: LD_VAR 0 2
93052: NOT
93053: IFFALSE 93057
// exit ;
93055: GO 93086
// for i in tmp do
93057: LD_ADDR_VAR 0 1
93061: PUSH
93062: LD_VAR 0 2
93066: PUSH
93067: FOR_IN
93068: IFFALSE 93084
// begin SetLives ( i , 0 ) ;
93070: LD_VAR 0 1
93074: PPUSH
93075: LD_INT 0
93077: PPUSH
93078: CALL_OW 234
// end ;
93082: GO 93067
93084: POP
93085: POP
// end ;
93086: PPOPN 2
93088: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93089: LD_EXP 133
93093: PUSH
93094: LD_EXP 139
93098: AND
93099: IFFALSE 93183
93101: GO 93103
93103: DISABLE
93104: LD_INT 0
93106: PPUSH
93107: PPUSH
// begin enable ;
93108: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93109: LD_ADDR_VAR 0 2
93113: PUSH
93114: LD_INT 22
93116: PUSH
93117: LD_OWVAR 2
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 32
93128: PUSH
93129: LD_INT 3
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PPUSH
93140: CALL_OW 69
93144: ST_TO_ADDR
// if not tmp then
93145: LD_VAR 0 2
93149: NOT
93150: IFFALSE 93154
// exit ;
93152: GO 93183
// for i in tmp do
93154: LD_ADDR_VAR 0 1
93158: PUSH
93159: LD_VAR 0 2
93163: PUSH
93164: FOR_IN
93165: IFFALSE 93181
// begin SetLives ( i , 0 ) ;
93167: LD_VAR 0 1
93171: PPUSH
93172: LD_INT 0
93174: PPUSH
93175: CALL_OW 234
// end ;
93179: GO 93164
93181: POP
93182: POP
// end ;
93183: PPOPN 2
93185: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93186: LD_EXP 133
93190: PUSH
93191: LD_EXP 136
93195: AND
93196: IFFALSE 93289
93198: GO 93200
93200: DISABLE
93201: LD_INT 0
93203: PPUSH
// begin enable ;
93204: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93205: LD_ADDR_VAR 0 1
93209: PUSH
93210: LD_INT 22
93212: PUSH
93213: LD_OWVAR 2
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 2
93224: PUSH
93225: LD_INT 25
93227: PUSH
93228: LD_INT 5
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PUSH
93235: LD_INT 25
93237: PUSH
93238: LD_INT 9
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 25
93247: PUSH
93248: LD_INT 8
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PPUSH
93265: CALL_OW 69
93269: PUSH
93270: FOR_IN
93271: IFFALSE 93287
// begin SetClass ( i , 1 ) ;
93273: LD_VAR 0 1
93277: PPUSH
93278: LD_INT 1
93280: PPUSH
93281: CALL_OW 336
// end ;
93285: GO 93270
93287: POP
93288: POP
// end ;
93289: PPOPN 1
93291: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93292: LD_EXP 133
93296: PUSH
93297: LD_EXP 137
93301: AND
93302: PUSH
93303: LD_OWVAR 65
93307: PUSH
93308: LD_INT 7
93310: LESS
93311: AND
93312: IFFALSE 93326
93314: GO 93316
93316: DISABLE
// begin enable ;
93317: ENABLE
// game_speed := 7 ;
93318: LD_ADDR_OWVAR 65
93322: PUSH
93323: LD_INT 7
93325: ST_TO_ADDR
// end ;
93326: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93327: LD_EXP 133
93331: PUSH
93332: LD_EXP 140
93336: AND
93337: IFFALSE 93539
93339: GO 93341
93341: DISABLE
93342: LD_INT 0
93344: PPUSH
93345: PPUSH
93346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93347: LD_ADDR_VAR 0 3
93351: PUSH
93352: LD_INT 81
93354: PUSH
93355: LD_OWVAR 2
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 21
93366: PUSH
93367: LD_INT 1
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PPUSH
93378: CALL_OW 69
93382: ST_TO_ADDR
// if not tmp then
93383: LD_VAR 0 3
93387: NOT
93388: IFFALSE 93392
// exit ;
93390: GO 93539
// if tmp > 5 then
93392: LD_VAR 0 3
93396: PUSH
93397: LD_INT 5
93399: GREATER
93400: IFFALSE 93412
// k := 5 else
93402: LD_ADDR_VAR 0 2
93406: PUSH
93407: LD_INT 5
93409: ST_TO_ADDR
93410: GO 93422
// k := tmp ;
93412: LD_ADDR_VAR 0 2
93416: PUSH
93417: LD_VAR 0 3
93421: ST_TO_ADDR
// for i := 1 to k do
93422: LD_ADDR_VAR 0 1
93426: PUSH
93427: DOUBLE
93428: LD_INT 1
93430: DEC
93431: ST_TO_ADDR
93432: LD_VAR 0 2
93436: PUSH
93437: FOR_TO
93438: IFFALSE 93537
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93440: LD_VAR 0 3
93444: PUSH
93445: LD_VAR 0 1
93449: ARRAY
93450: PPUSH
93451: LD_VAR 0 1
93455: PUSH
93456: LD_INT 4
93458: MOD
93459: PUSH
93460: LD_INT 1
93462: PLUS
93463: PPUSH
93464: CALL_OW 259
93468: PUSH
93469: LD_INT 10
93471: LESS
93472: IFFALSE 93535
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93474: LD_VAR 0 3
93478: PUSH
93479: LD_VAR 0 1
93483: ARRAY
93484: PPUSH
93485: LD_VAR 0 1
93489: PUSH
93490: LD_INT 4
93492: MOD
93493: PUSH
93494: LD_INT 1
93496: PLUS
93497: PPUSH
93498: LD_VAR 0 3
93502: PUSH
93503: LD_VAR 0 1
93507: ARRAY
93508: PPUSH
93509: LD_VAR 0 1
93513: PUSH
93514: LD_INT 4
93516: MOD
93517: PUSH
93518: LD_INT 1
93520: PLUS
93521: PPUSH
93522: CALL_OW 259
93526: PUSH
93527: LD_INT 1
93529: PLUS
93530: PPUSH
93531: CALL_OW 237
93535: GO 93437
93537: POP
93538: POP
// end ;
93539: PPOPN 3
93541: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93542: LD_EXP 133
93546: PUSH
93547: LD_EXP 141
93551: AND
93552: IFFALSE 93572
93554: GO 93556
93556: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93557: LD_INT 4
93559: PPUSH
93560: LD_OWVAR 2
93564: PPUSH
93565: LD_INT 0
93567: PPUSH
93568: CALL_OW 324
93572: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93573: LD_EXP 133
93577: PUSH
93578: LD_EXP 170
93582: AND
93583: IFFALSE 93603
93585: GO 93587
93587: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93588: LD_INT 19
93590: PPUSH
93591: LD_OWVAR 2
93595: PPUSH
93596: LD_INT 0
93598: PPUSH
93599: CALL_OW 324
93603: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93604: LD_EXP 133
93608: PUSH
93609: LD_EXP 142
93613: AND
93614: IFFALSE 93716
93616: GO 93618
93618: DISABLE
93619: LD_INT 0
93621: PPUSH
93622: PPUSH
// begin enable ;
93623: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93624: LD_ADDR_VAR 0 2
93628: PUSH
93629: LD_INT 22
93631: PUSH
93632: LD_OWVAR 2
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 2
93643: PUSH
93644: LD_INT 34
93646: PUSH
93647: LD_INT 11
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 34
93656: PUSH
93657: LD_INT 30
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: LIST
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PPUSH
93673: CALL_OW 69
93677: ST_TO_ADDR
// if not tmp then
93678: LD_VAR 0 2
93682: NOT
93683: IFFALSE 93687
// exit ;
93685: GO 93716
// for i in tmp do
93687: LD_ADDR_VAR 0 1
93691: PUSH
93692: LD_VAR 0 2
93696: PUSH
93697: FOR_IN
93698: IFFALSE 93714
// begin SetLives ( i , 0 ) ;
93700: LD_VAR 0 1
93704: PPUSH
93705: LD_INT 0
93707: PPUSH
93708: CALL_OW 234
// end ;
93712: GO 93697
93714: POP
93715: POP
// end ;
93716: PPOPN 2
93718: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93719: LD_EXP 133
93723: PUSH
93724: LD_EXP 143
93728: AND
93729: IFFALSE 93749
93731: GO 93733
93733: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93734: LD_INT 32
93736: PPUSH
93737: LD_OWVAR 2
93741: PPUSH
93742: LD_INT 0
93744: PPUSH
93745: CALL_OW 324
93749: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93750: LD_EXP 133
93754: PUSH
93755: LD_EXP 144
93759: AND
93760: IFFALSE 93941
93762: GO 93764
93764: DISABLE
93765: LD_INT 0
93767: PPUSH
93768: PPUSH
93769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93770: LD_ADDR_VAR 0 2
93774: PUSH
93775: LD_INT 22
93777: PUSH
93778: LD_OWVAR 2
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 33
93789: PUSH
93790: LD_INT 3
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PPUSH
93801: CALL_OW 69
93805: ST_TO_ADDR
// if not tmp then
93806: LD_VAR 0 2
93810: NOT
93811: IFFALSE 93815
// exit ;
93813: GO 93941
// side := 0 ;
93815: LD_ADDR_VAR 0 3
93819: PUSH
93820: LD_INT 0
93822: ST_TO_ADDR
// for i := 1 to 8 do
93823: LD_ADDR_VAR 0 1
93827: PUSH
93828: DOUBLE
93829: LD_INT 1
93831: DEC
93832: ST_TO_ADDR
93833: LD_INT 8
93835: PUSH
93836: FOR_TO
93837: IFFALSE 93885
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93839: LD_OWVAR 2
93843: PUSH
93844: LD_VAR 0 1
93848: NONEQUAL
93849: PUSH
93850: LD_OWVAR 2
93854: PPUSH
93855: LD_VAR 0 1
93859: PPUSH
93860: CALL_OW 81
93864: PUSH
93865: LD_INT 2
93867: EQUAL
93868: AND
93869: IFFALSE 93883
// begin side := i ;
93871: LD_ADDR_VAR 0 3
93875: PUSH
93876: LD_VAR 0 1
93880: ST_TO_ADDR
// break ;
93881: GO 93885
// end ;
93883: GO 93836
93885: POP
93886: POP
// if not side then
93887: LD_VAR 0 3
93891: NOT
93892: IFFALSE 93896
// exit ;
93894: GO 93941
// for i := 1 to tmp do
93896: LD_ADDR_VAR 0 1
93900: PUSH
93901: DOUBLE
93902: LD_INT 1
93904: DEC
93905: ST_TO_ADDR
93906: LD_VAR 0 2
93910: PUSH
93911: FOR_TO
93912: IFFALSE 93939
// if Prob ( 60 ) then
93914: LD_INT 60
93916: PPUSH
93917: CALL_OW 13
93921: IFFALSE 93937
// SetSide ( i , side ) ;
93923: LD_VAR 0 1
93927: PPUSH
93928: LD_VAR 0 3
93932: PPUSH
93933: CALL_OW 235
93937: GO 93911
93939: POP
93940: POP
// end ;
93941: PPOPN 3
93943: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93944: LD_EXP 133
93948: PUSH
93949: LD_EXP 146
93953: AND
93954: IFFALSE 94073
93956: GO 93958
93958: DISABLE
93959: LD_INT 0
93961: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93962: LD_ADDR_VAR 0 1
93966: PUSH
93967: LD_INT 22
93969: PUSH
93970: LD_OWVAR 2
93974: PUSH
93975: EMPTY
93976: LIST
93977: LIST
93978: PUSH
93979: LD_INT 21
93981: PUSH
93982: LD_INT 1
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 3
93991: PUSH
93992: LD_INT 23
93994: PUSH
93995: LD_INT 0
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: LIST
94010: PPUSH
94011: CALL_OW 69
94015: PUSH
94016: FOR_IN
94017: IFFALSE 94071
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94019: LD_VAR 0 1
94023: PPUSH
94024: CALL_OW 257
94028: PUSH
94029: LD_INT 1
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: LD_INT 3
94037: PUSH
94038: LD_INT 4
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: IN
94047: IFFALSE 94069
// SetClass ( un , rand ( 1 , 4 ) ) ;
94049: LD_VAR 0 1
94053: PPUSH
94054: LD_INT 1
94056: PPUSH
94057: LD_INT 4
94059: PPUSH
94060: CALL_OW 12
94064: PPUSH
94065: CALL_OW 336
94069: GO 94016
94071: POP
94072: POP
// end ;
94073: PPOPN 1
94075: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94076: LD_EXP 133
94080: PUSH
94081: LD_EXP 145
94085: AND
94086: IFFALSE 94165
94088: GO 94090
94090: DISABLE
94091: LD_INT 0
94093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94094: LD_ADDR_VAR 0 1
94098: PUSH
94099: LD_INT 22
94101: PUSH
94102: LD_OWVAR 2
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 21
94113: PUSH
94114: LD_INT 3
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PPUSH
94125: CALL_OW 69
94129: ST_TO_ADDR
// if not tmp then
94130: LD_VAR 0 1
94134: NOT
94135: IFFALSE 94139
// exit ;
94137: GO 94165
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94139: LD_VAR 0 1
94143: PUSH
94144: LD_INT 1
94146: PPUSH
94147: LD_VAR 0 1
94151: PPUSH
94152: CALL_OW 12
94156: ARRAY
94157: PPUSH
94158: LD_INT 100
94160: PPUSH
94161: CALL_OW 234
// end ;
94165: PPOPN 1
94167: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94168: LD_EXP 133
94172: PUSH
94173: LD_EXP 147
94177: AND
94178: IFFALSE 94276
94180: GO 94182
94182: DISABLE
94183: LD_INT 0
94185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94186: LD_ADDR_VAR 0 1
94190: PUSH
94191: LD_INT 22
94193: PUSH
94194: LD_OWVAR 2
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 21
94205: PUSH
94206: LD_INT 1
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PPUSH
94217: CALL_OW 69
94221: ST_TO_ADDR
// if not tmp then
94222: LD_VAR 0 1
94226: NOT
94227: IFFALSE 94231
// exit ;
94229: GO 94276
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94231: LD_VAR 0 1
94235: PUSH
94236: LD_INT 1
94238: PPUSH
94239: LD_VAR 0 1
94243: PPUSH
94244: CALL_OW 12
94248: ARRAY
94249: PPUSH
94250: LD_INT 1
94252: PPUSH
94253: LD_INT 4
94255: PPUSH
94256: CALL_OW 12
94260: PPUSH
94261: LD_INT 3000
94263: PPUSH
94264: LD_INT 9000
94266: PPUSH
94267: CALL_OW 12
94271: PPUSH
94272: CALL_OW 492
// end ;
94276: PPOPN 1
94278: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94279: LD_EXP 133
94283: PUSH
94284: LD_EXP 148
94288: AND
94289: IFFALSE 94309
94291: GO 94293
94293: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94294: LD_INT 1
94296: PPUSH
94297: LD_OWVAR 2
94301: PPUSH
94302: LD_INT 0
94304: PPUSH
94305: CALL_OW 324
94309: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94310: LD_EXP 133
94314: PUSH
94315: LD_EXP 149
94319: AND
94320: IFFALSE 94403
94322: GO 94324
94324: DISABLE
94325: LD_INT 0
94327: PPUSH
94328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94329: LD_ADDR_VAR 0 2
94333: PUSH
94334: LD_INT 22
94336: PUSH
94337: LD_OWVAR 2
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 21
94348: PUSH
94349: LD_INT 3
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PPUSH
94360: CALL_OW 69
94364: ST_TO_ADDR
// if not tmp then
94365: LD_VAR 0 2
94369: NOT
94370: IFFALSE 94374
// exit ;
94372: GO 94403
// for i in tmp do
94374: LD_ADDR_VAR 0 1
94378: PUSH
94379: LD_VAR 0 2
94383: PUSH
94384: FOR_IN
94385: IFFALSE 94401
// SetBLevel ( i , 10 ) ;
94387: LD_VAR 0 1
94391: PPUSH
94392: LD_INT 10
94394: PPUSH
94395: CALL_OW 241
94399: GO 94384
94401: POP
94402: POP
// end ;
94403: PPOPN 2
94405: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94406: LD_EXP 133
94410: PUSH
94411: LD_EXP 150
94415: AND
94416: IFFALSE 94527
94418: GO 94420
94420: DISABLE
94421: LD_INT 0
94423: PPUSH
94424: PPUSH
94425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94426: LD_ADDR_VAR 0 3
94430: PUSH
94431: LD_INT 22
94433: PUSH
94434: LD_OWVAR 2
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 25
94445: PUSH
94446: LD_INT 1
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PPUSH
94457: CALL_OW 69
94461: ST_TO_ADDR
// if not tmp then
94462: LD_VAR 0 3
94466: NOT
94467: IFFALSE 94471
// exit ;
94469: GO 94527
// un := tmp [ rand ( 1 , tmp ) ] ;
94471: LD_ADDR_VAR 0 2
94475: PUSH
94476: LD_VAR 0 3
94480: PUSH
94481: LD_INT 1
94483: PPUSH
94484: LD_VAR 0 3
94488: PPUSH
94489: CALL_OW 12
94493: ARRAY
94494: ST_TO_ADDR
// if Crawls ( un ) then
94495: LD_VAR 0 2
94499: PPUSH
94500: CALL_OW 318
94504: IFFALSE 94515
// ComWalk ( un ) ;
94506: LD_VAR 0 2
94510: PPUSH
94511: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94515: LD_VAR 0 2
94519: PPUSH
94520: LD_INT 5
94522: PPUSH
94523: CALL_OW 336
// end ;
94527: PPOPN 3
94529: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
94530: LD_EXP 133
94534: PUSH
94535: LD_EXP 151
94539: AND
94540: PUSH
94541: LD_OWVAR 67
94545: PUSH
94546: LD_INT 3
94548: LESS
94549: AND
94550: IFFALSE 94569
94552: GO 94554
94554: DISABLE
// Difficulty := Difficulty + 1 ;
94555: LD_ADDR_OWVAR 67
94559: PUSH
94560: LD_OWVAR 67
94564: PUSH
94565: LD_INT 1
94567: PLUS
94568: ST_TO_ADDR
94569: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94570: LD_EXP 133
94574: PUSH
94575: LD_EXP 152
94579: AND
94580: IFFALSE 94683
94582: GO 94584
94584: DISABLE
94585: LD_INT 0
94587: PPUSH
// begin for i := 1 to 5 do
94588: LD_ADDR_VAR 0 1
94592: PUSH
94593: DOUBLE
94594: LD_INT 1
94596: DEC
94597: ST_TO_ADDR
94598: LD_INT 5
94600: PUSH
94601: FOR_TO
94602: IFFALSE 94681
// begin uc_nation := nation_nature ;
94604: LD_ADDR_OWVAR 21
94608: PUSH
94609: LD_INT 0
94611: ST_TO_ADDR
// uc_side := 0 ;
94612: LD_ADDR_OWVAR 20
94616: PUSH
94617: LD_INT 0
94619: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94620: LD_ADDR_OWVAR 29
94624: PUSH
94625: LD_INT 12
94627: PUSH
94628: LD_INT 12
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: ST_TO_ADDR
// hc_agressivity := 20 ;
94635: LD_ADDR_OWVAR 35
94639: PUSH
94640: LD_INT 20
94642: ST_TO_ADDR
// hc_class := class_tiger ;
94643: LD_ADDR_OWVAR 28
94647: PUSH
94648: LD_INT 14
94650: ST_TO_ADDR
// hc_gallery :=  ;
94651: LD_ADDR_OWVAR 33
94655: PUSH
94656: LD_STRING 
94658: ST_TO_ADDR
// hc_name :=  ;
94659: LD_ADDR_OWVAR 26
94663: PUSH
94664: LD_STRING 
94666: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94667: CALL_OW 44
94671: PPUSH
94672: LD_INT 0
94674: PPUSH
94675: CALL_OW 51
// end ;
94679: GO 94601
94681: POP
94682: POP
// end ;
94683: PPOPN 1
94685: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94686: LD_EXP 133
94690: PUSH
94691: LD_EXP 153
94695: AND
94696: IFFALSE 94705
94698: GO 94700
94700: DISABLE
// StreamSibBomb ;
94701: CALL 94706 0 0
94705: END
// export function StreamSibBomb ; var i , x , y ; begin
94706: LD_INT 0
94708: PPUSH
94709: PPUSH
94710: PPUSH
94711: PPUSH
// result := false ;
94712: LD_ADDR_VAR 0 1
94716: PUSH
94717: LD_INT 0
94719: ST_TO_ADDR
// for i := 1 to 16 do
94720: LD_ADDR_VAR 0 2
94724: PUSH
94725: DOUBLE
94726: LD_INT 1
94728: DEC
94729: ST_TO_ADDR
94730: LD_INT 16
94732: PUSH
94733: FOR_TO
94734: IFFALSE 94933
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94736: LD_ADDR_VAR 0 3
94740: PUSH
94741: LD_INT 10
94743: PUSH
94744: LD_INT 20
94746: PUSH
94747: LD_INT 30
94749: PUSH
94750: LD_INT 40
94752: PUSH
94753: LD_INT 50
94755: PUSH
94756: LD_INT 60
94758: PUSH
94759: LD_INT 70
94761: PUSH
94762: LD_INT 80
94764: PUSH
94765: LD_INT 90
94767: PUSH
94768: LD_INT 100
94770: PUSH
94771: LD_INT 110
94773: PUSH
94774: LD_INT 120
94776: PUSH
94777: LD_INT 130
94779: PUSH
94780: LD_INT 140
94782: PUSH
94783: LD_INT 150
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 1
94805: PPUSH
94806: LD_INT 15
94808: PPUSH
94809: CALL_OW 12
94813: ARRAY
94814: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94815: LD_ADDR_VAR 0 4
94819: PUSH
94820: LD_INT 10
94822: PUSH
94823: LD_INT 20
94825: PUSH
94826: LD_INT 30
94828: PUSH
94829: LD_INT 40
94831: PUSH
94832: LD_INT 50
94834: PUSH
94835: LD_INT 60
94837: PUSH
94838: LD_INT 70
94840: PUSH
94841: LD_INT 80
94843: PUSH
94844: LD_INT 90
94846: PUSH
94847: LD_INT 100
94849: PUSH
94850: LD_INT 110
94852: PUSH
94853: LD_INT 120
94855: PUSH
94856: LD_INT 130
94858: PUSH
94859: LD_INT 140
94861: PUSH
94862: LD_INT 150
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 1
94884: PPUSH
94885: LD_INT 15
94887: PPUSH
94888: CALL_OW 12
94892: ARRAY
94893: ST_TO_ADDR
// if ValidHex ( x , y ) then
94894: LD_VAR 0 3
94898: PPUSH
94899: LD_VAR 0 4
94903: PPUSH
94904: CALL_OW 488
94908: IFFALSE 94931
// begin result := [ x , y ] ;
94910: LD_ADDR_VAR 0 1
94914: PUSH
94915: LD_VAR 0 3
94919: PUSH
94920: LD_VAR 0 4
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: ST_TO_ADDR
// break ;
94929: GO 94933
// end ; end ;
94931: GO 94733
94933: POP
94934: POP
// if result then
94935: LD_VAR 0 1
94939: IFFALSE 94999
// begin ToLua ( playSibBomb() ) ;
94941: LD_STRING playSibBomb()
94943: PPUSH
94944: CALL_OW 559
// wait ( 0 0$14 ) ;
94948: LD_INT 490
94950: PPUSH
94951: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94955: LD_VAR 0 1
94959: PUSH
94960: LD_INT 1
94962: ARRAY
94963: PPUSH
94964: LD_VAR 0 1
94968: PUSH
94969: LD_INT 2
94971: ARRAY
94972: PPUSH
94973: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94977: LD_VAR 0 1
94981: PUSH
94982: LD_INT 1
94984: ARRAY
94985: PPUSH
94986: LD_VAR 0 1
94990: PUSH
94991: LD_INT 2
94993: ARRAY
94994: PPUSH
94995: CALL_OW 429
// end ; end ;
94999: LD_VAR 0 1
95003: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95004: LD_EXP 133
95008: PUSH
95009: LD_EXP 155
95013: AND
95014: IFFALSE 95026
95016: GO 95018
95018: DISABLE
// YouLost (  ) ;
95019: LD_STRING 
95021: PPUSH
95022: CALL_OW 104
95026: END
// every 0 0$1 trigger StreamModeActive and sFog do
95027: LD_EXP 133
95031: PUSH
95032: LD_EXP 154
95036: AND
95037: IFFALSE 95051
95039: GO 95041
95041: DISABLE
// FogOff ( your_side ) ;
95042: LD_OWVAR 2
95046: PPUSH
95047: CALL_OW 344
95051: END
// every 0 0$1 trigger StreamModeActive and sSun do
95052: LD_EXP 133
95056: PUSH
95057: LD_EXP 156
95061: AND
95062: IFFALSE 95090
95064: GO 95066
95066: DISABLE
// begin solar_recharge_percent := 0 ;
95067: LD_ADDR_OWVAR 79
95071: PUSH
95072: LD_INT 0
95074: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95075: LD_INT 10500
95077: PPUSH
95078: CALL_OW 67
// solar_recharge_percent := 100 ;
95082: LD_ADDR_OWVAR 79
95086: PUSH
95087: LD_INT 100
95089: ST_TO_ADDR
// end ;
95090: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95091: LD_EXP 133
95095: PUSH
95096: LD_EXP 157
95100: AND
95101: IFFALSE 95340
95103: GO 95105
95105: DISABLE
95106: LD_INT 0
95108: PPUSH
95109: PPUSH
95110: PPUSH
// begin tmp := [ ] ;
95111: LD_ADDR_VAR 0 3
95115: PUSH
95116: EMPTY
95117: ST_TO_ADDR
// for i := 1 to 6 do
95118: LD_ADDR_VAR 0 1
95122: PUSH
95123: DOUBLE
95124: LD_INT 1
95126: DEC
95127: ST_TO_ADDR
95128: LD_INT 6
95130: PUSH
95131: FOR_TO
95132: IFFALSE 95237
// begin uc_nation := nation_nature ;
95134: LD_ADDR_OWVAR 21
95138: PUSH
95139: LD_INT 0
95141: ST_TO_ADDR
// uc_side := 0 ;
95142: LD_ADDR_OWVAR 20
95146: PUSH
95147: LD_INT 0
95149: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95150: LD_ADDR_OWVAR 29
95154: PUSH
95155: LD_INT 12
95157: PUSH
95158: LD_INT 12
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: ST_TO_ADDR
// hc_agressivity := 20 ;
95165: LD_ADDR_OWVAR 35
95169: PUSH
95170: LD_INT 20
95172: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95173: LD_ADDR_OWVAR 28
95177: PUSH
95178: LD_INT 17
95180: ST_TO_ADDR
// hc_gallery :=  ;
95181: LD_ADDR_OWVAR 33
95185: PUSH
95186: LD_STRING 
95188: ST_TO_ADDR
// hc_name :=  ;
95189: LD_ADDR_OWVAR 26
95193: PUSH
95194: LD_STRING 
95196: ST_TO_ADDR
// un := CreateHuman ;
95197: LD_ADDR_VAR 0 2
95201: PUSH
95202: CALL_OW 44
95206: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95207: LD_VAR 0 2
95211: PPUSH
95212: LD_INT 1
95214: PPUSH
95215: CALL_OW 51
// tmp := tmp ^ un ;
95219: LD_ADDR_VAR 0 3
95223: PUSH
95224: LD_VAR 0 3
95228: PUSH
95229: LD_VAR 0 2
95233: ADD
95234: ST_TO_ADDR
// end ;
95235: GO 95131
95237: POP
95238: POP
// repeat wait ( 0 0$1 ) ;
95239: LD_INT 35
95241: PPUSH
95242: CALL_OW 67
// for un in tmp do
95246: LD_ADDR_VAR 0 2
95250: PUSH
95251: LD_VAR 0 3
95255: PUSH
95256: FOR_IN
95257: IFFALSE 95331
// begin if IsDead ( un ) then
95259: LD_VAR 0 2
95263: PPUSH
95264: CALL_OW 301
95268: IFFALSE 95288
// begin tmp := tmp diff un ;
95270: LD_ADDR_VAR 0 3
95274: PUSH
95275: LD_VAR 0 3
95279: PUSH
95280: LD_VAR 0 2
95284: DIFF
95285: ST_TO_ADDR
// continue ;
95286: GO 95256
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95288: LD_VAR 0 2
95292: PPUSH
95293: LD_INT 3
95295: PUSH
95296: LD_INT 22
95298: PUSH
95299: LD_INT 0
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: PUSH
95306: EMPTY
95307: LIST
95308: LIST
95309: PPUSH
95310: CALL_OW 69
95314: PPUSH
95315: LD_VAR 0 2
95319: PPUSH
95320: CALL_OW 74
95324: PPUSH
95325: CALL_OW 115
// end ;
95329: GO 95256
95331: POP
95332: POP
// until not tmp ;
95333: LD_VAR 0 3
95337: NOT
95338: IFFALSE 95239
// end ;
95340: PPOPN 3
95342: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95343: LD_EXP 133
95347: PUSH
95348: LD_EXP 158
95352: AND
95353: IFFALSE 95407
95355: GO 95357
95357: DISABLE
// begin ToLua ( displayTroll(); ) ;
95358: LD_STRING displayTroll();
95360: PPUSH
95361: CALL_OW 559
// wait ( 3 3$00 ) ;
95365: LD_INT 6300
95367: PPUSH
95368: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95372: LD_STRING hideTroll();
95374: PPUSH
95375: CALL_OW 559
// wait ( 1 1$00 ) ;
95379: LD_INT 2100
95381: PPUSH
95382: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95386: LD_STRING displayTroll();
95388: PPUSH
95389: CALL_OW 559
// wait ( 1 1$00 ) ;
95393: LD_INT 2100
95395: PPUSH
95396: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95400: LD_STRING hideTroll();
95402: PPUSH
95403: CALL_OW 559
// end ;
95407: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95408: LD_EXP 133
95412: PUSH
95413: LD_EXP 159
95417: AND
95418: IFFALSE 95481
95420: GO 95422
95422: DISABLE
95423: LD_INT 0
95425: PPUSH
// begin p := 0 ;
95426: LD_ADDR_VAR 0 1
95430: PUSH
95431: LD_INT 0
95433: ST_TO_ADDR
// repeat game_speed := 1 ;
95434: LD_ADDR_OWVAR 65
95438: PUSH
95439: LD_INT 1
95441: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95442: LD_INT 35
95444: PPUSH
95445: CALL_OW 67
// p := p + 1 ;
95449: LD_ADDR_VAR 0 1
95453: PUSH
95454: LD_VAR 0 1
95458: PUSH
95459: LD_INT 1
95461: PLUS
95462: ST_TO_ADDR
// until p >= 60 ;
95463: LD_VAR 0 1
95467: PUSH
95468: LD_INT 60
95470: GREATEREQUAL
95471: IFFALSE 95434
// game_speed := 4 ;
95473: LD_ADDR_OWVAR 65
95477: PUSH
95478: LD_INT 4
95480: ST_TO_ADDR
// end ;
95481: PPOPN 1
95483: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95484: LD_EXP 133
95488: PUSH
95489: LD_EXP 160
95493: AND
95494: IFFALSE 95640
95496: GO 95498
95498: DISABLE
95499: LD_INT 0
95501: PPUSH
95502: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95503: LD_ADDR_VAR 0 1
95507: PUSH
95508: LD_INT 22
95510: PUSH
95511: LD_OWVAR 2
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 2
95522: PUSH
95523: LD_INT 30
95525: PUSH
95526: LD_INT 0
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 30
95535: PUSH
95536: LD_INT 1
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: LIST
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: PPUSH
95552: CALL_OW 69
95556: ST_TO_ADDR
// if not depot then
95557: LD_VAR 0 1
95561: NOT
95562: IFFALSE 95566
// exit ;
95564: GO 95640
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95566: LD_ADDR_VAR 0 2
95570: PUSH
95571: LD_VAR 0 1
95575: PUSH
95576: LD_INT 1
95578: PPUSH
95579: LD_VAR 0 1
95583: PPUSH
95584: CALL_OW 12
95588: ARRAY
95589: PPUSH
95590: CALL_OW 274
95594: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95595: LD_VAR 0 2
95599: PPUSH
95600: LD_INT 1
95602: PPUSH
95603: LD_INT 0
95605: PPUSH
95606: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95610: LD_VAR 0 2
95614: PPUSH
95615: LD_INT 2
95617: PPUSH
95618: LD_INT 0
95620: PPUSH
95621: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95625: LD_VAR 0 2
95629: PPUSH
95630: LD_INT 3
95632: PPUSH
95633: LD_INT 0
95635: PPUSH
95636: CALL_OW 277
// end ;
95640: PPOPN 2
95642: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95643: LD_EXP 133
95647: PUSH
95648: LD_EXP 161
95652: AND
95653: IFFALSE 95750
95655: GO 95657
95657: DISABLE
95658: LD_INT 0
95660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95661: LD_ADDR_VAR 0 1
95665: PUSH
95666: LD_INT 22
95668: PUSH
95669: LD_OWVAR 2
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 21
95680: PUSH
95681: LD_INT 1
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 3
95690: PUSH
95691: LD_INT 23
95693: PUSH
95694: LD_INT 0
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: LIST
95709: PPUSH
95710: CALL_OW 69
95714: ST_TO_ADDR
// if not tmp then
95715: LD_VAR 0 1
95719: NOT
95720: IFFALSE 95724
// exit ;
95722: GO 95750
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95724: LD_VAR 0 1
95728: PUSH
95729: LD_INT 1
95731: PPUSH
95732: LD_VAR 0 1
95736: PPUSH
95737: CALL_OW 12
95741: ARRAY
95742: PPUSH
95743: LD_INT 200
95745: PPUSH
95746: CALL_OW 234
// end ;
95750: PPOPN 1
95752: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95753: LD_EXP 133
95757: PUSH
95758: LD_EXP 162
95762: AND
95763: IFFALSE 95842
95765: GO 95767
95767: DISABLE
95768: LD_INT 0
95770: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95771: LD_ADDR_VAR 0 1
95775: PUSH
95776: LD_INT 22
95778: PUSH
95779: LD_OWVAR 2
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 21
95790: PUSH
95791: LD_INT 2
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PPUSH
95802: CALL_OW 69
95806: ST_TO_ADDR
// if not tmp then
95807: LD_VAR 0 1
95811: NOT
95812: IFFALSE 95816
// exit ;
95814: GO 95842
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95816: LD_VAR 0 1
95820: PUSH
95821: LD_INT 1
95823: PPUSH
95824: LD_VAR 0 1
95828: PPUSH
95829: CALL_OW 12
95833: ARRAY
95834: PPUSH
95835: LD_INT 60
95837: PPUSH
95838: CALL_OW 234
// end ;
95842: PPOPN 1
95844: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95845: LD_EXP 133
95849: PUSH
95850: LD_EXP 163
95854: AND
95855: IFFALSE 95954
95857: GO 95859
95859: DISABLE
95860: LD_INT 0
95862: PPUSH
95863: PPUSH
// begin enable ;
95864: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95865: LD_ADDR_VAR 0 1
95869: PUSH
95870: LD_INT 22
95872: PUSH
95873: LD_OWVAR 2
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: PUSH
95882: LD_INT 61
95884: PUSH
95885: EMPTY
95886: LIST
95887: PUSH
95888: LD_INT 33
95890: PUSH
95891: LD_INT 2
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: LIST
95902: PPUSH
95903: CALL_OW 69
95907: ST_TO_ADDR
// if not tmp then
95908: LD_VAR 0 1
95912: NOT
95913: IFFALSE 95917
// exit ;
95915: GO 95954
// for i in tmp do
95917: LD_ADDR_VAR 0 2
95921: PUSH
95922: LD_VAR 0 1
95926: PUSH
95927: FOR_IN
95928: IFFALSE 95952
// if IsControledBy ( i ) then
95930: LD_VAR 0 2
95934: PPUSH
95935: CALL_OW 312
95939: IFFALSE 95950
// ComUnlink ( i ) ;
95941: LD_VAR 0 2
95945: PPUSH
95946: CALL_OW 136
95950: GO 95927
95952: POP
95953: POP
// end ;
95954: PPOPN 2
95956: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95957: LD_EXP 133
95961: PUSH
95962: LD_EXP 164
95966: AND
95967: IFFALSE 96107
95969: GO 95971
95971: DISABLE
95972: LD_INT 0
95974: PPUSH
95975: PPUSH
// begin ToLua ( displayPowell(); ) ;
95976: LD_STRING displayPowell();
95978: PPUSH
95979: CALL_OW 559
// uc_side := 0 ;
95983: LD_ADDR_OWVAR 20
95987: PUSH
95988: LD_INT 0
95990: ST_TO_ADDR
// uc_nation := 2 ;
95991: LD_ADDR_OWVAR 21
95995: PUSH
95996: LD_INT 2
95998: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95999: LD_ADDR_OWVAR 37
96003: PUSH
96004: LD_INT 14
96006: ST_TO_ADDR
// vc_engine := engine_siberite ;
96007: LD_ADDR_OWVAR 39
96011: PUSH
96012: LD_INT 3
96014: ST_TO_ADDR
// vc_control := control_apeman ;
96015: LD_ADDR_OWVAR 38
96019: PUSH
96020: LD_INT 5
96022: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96023: LD_ADDR_OWVAR 40
96027: PUSH
96028: LD_INT 29
96030: ST_TO_ADDR
// un := CreateVehicle ;
96031: LD_ADDR_VAR 0 2
96035: PUSH
96036: CALL_OW 45
96040: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96041: LD_VAR 0 2
96045: PPUSH
96046: LD_INT 1
96048: PPUSH
96049: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96053: LD_INT 35
96055: PPUSH
96056: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96060: LD_VAR 0 2
96064: PPUSH
96065: LD_INT 22
96067: PUSH
96068: LD_OWVAR 2
96072: PUSH
96073: EMPTY
96074: LIST
96075: LIST
96076: PPUSH
96077: CALL_OW 69
96081: PPUSH
96082: LD_VAR 0 2
96086: PPUSH
96087: CALL_OW 74
96091: PPUSH
96092: CALL_OW 115
// until IsDead ( un ) ;
96096: LD_VAR 0 2
96100: PPUSH
96101: CALL_OW 301
96105: IFFALSE 96053
// end ;
96107: PPOPN 2
96109: END
// every 0 0$1 trigger StreamModeActive and sStu do
96110: LD_EXP 133
96114: PUSH
96115: LD_EXP 172
96119: AND
96120: IFFALSE 96136
96122: GO 96124
96124: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96125: LD_STRING displayStucuk();
96127: PPUSH
96128: CALL_OW 559
// ResetFog ;
96132: CALL_OW 335
// end ;
96136: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96137: LD_EXP 133
96141: PUSH
96142: LD_EXP 165
96146: AND
96147: IFFALSE 96288
96149: GO 96151
96151: DISABLE
96152: LD_INT 0
96154: PPUSH
96155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96156: LD_ADDR_VAR 0 2
96160: PUSH
96161: LD_INT 22
96163: PUSH
96164: LD_OWVAR 2
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 21
96175: PUSH
96176: LD_INT 1
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PPUSH
96187: CALL_OW 69
96191: ST_TO_ADDR
// if not tmp then
96192: LD_VAR 0 2
96196: NOT
96197: IFFALSE 96201
// exit ;
96199: GO 96288
// un := tmp [ rand ( 1 , tmp ) ] ;
96201: LD_ADDR_VAR 0 1
96205: PUSH
96206: LD_VAR 0 2
96210: PUSH
96211: LD_INT 1
96213: PPUSH
96214: LD_VAR 0 2
96218: PPUSH
96219: CALL_OW 12
96223: ARRAY
96224: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96225: LD_VAR 0 1
96229: PPUSH
96230: LD_INT 0
96232: PPUSH
96233: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96237: LD_VAR 0 1
96241: PPUSH
96242: LD_OWVAR 3
96246: PUSH
96247: LD_VAR 0 1
96251: DIFF
96252: PPUSH
96253: LD_VAR 0 1
96257: PPUSH
96258: CALL_OW 74
96262: PPUSH
96263: CALL_OW 115
// wait ( 0 0$20 ) ;
96267: LD_INT 700
96269: PPUSH
96270: CALL_OW 67
// SetSide ( un , your_side ) ;
96274: LD_VAR 0 1
96278: PPUSH
96279: LD_OWVAR 2
96283: PPUSH
96284: CALL_OW 235
// end ;
96288: PPOPN 2
96290: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96291: LD_EXP 133
96295: PUSH
96296: LD_EXP 166
96300: AND
96301: IFFALSE 96407
96303: GO 96305
96305: DISABLE
96306: LD_INT 0
96308: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96309: LD_ADDR_VAR 0 1
96313: PUSH
96314: LD_INT 22
96316: PUSH
96317: LD_OWVAR 2
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 2
96328: PUSH
96329: LD_INT 30
96331: PUSH
96332: LD_INT 0
96334: PUSH
96335: EMPTY
96336: LIST
96337: LIST
96338: PUSH
96339: LD_INT 30
96341: PUSH
96342: LD_INT 1
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: LIST
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PPUSH
96358: CALL_OW 69
96362: ST_TO_ADDR
// if not depot then
96363: LD_VAR 0 1
96367: NOT
96368: IFFALSE 96372
// exit ;
96370: GO 96407
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96372: LD_VAR 0 1
96376: PUSH
96377: LD_INT 1
96379: ARRAY
96380: PPUSH
96381: CALL_OW 250
96385: PPUSH
96386: LD_VAR 0 1
96390: PUSH
96391: LD_INT 1
96393: ARRAY
96394: PPUSH
96395: CALL_OW 251
96399: PPUSH
96400: LD_INT 70
96402: PPUSH
96403: CALL_OW 495
// end ;
96407: PPOPN 1
96409: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96410: LD_EXP 133
96414: PUSH
96415: LD_EXP 167
96419: AND
96420: IFFALSE 96631
96422: GO 96424
96424: DISABLE
96425: LD_INT 0
96427: PPUSH
96428: PPUSH
96429: PPUSH
96430: PPUSH
96431: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96432: LD_ADDR_VAR 0 5
96436: PUSH
96437: LD_INT 22
96439: PUSH
96440: LD_OWVAR 2
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PUSH
96449: LD_INT 21
96451: PUSH
96452: LD_INT 1
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: EMPTY
96460: LIST
96461: LIST
96462: PPUSH
96463: CALL_OW 69
96467: ST_TO_ADDR
// if not tmp then
96468: LD_VAR 0 5
96472: NOT
96473: IFFALSE 96477
// exit ;
96475: GO 96631
// for i in tmp do
96477: LD_ADDR_VAR 0 1
96481: PUSH
96482: LD_VAR 0 5
96486: PUSH
96487: FOR_IN
96488: IFFALSE 96629
// begin d := rand ( 0 , 5 ) ;
96490: LD_ADDR_VAR 0 4
96494: PUSH
96495: LD_INT 0
96497: PPUSH
96498: LD_INT 5
96500: PPUSH
96501: CALL_OW 12
96505: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96506: LD_ADDR_VAR 0 2
96510: PUSH
96511: LD_VAR 0 1
96515: PPUSH
96516: CALL_OW 250
96520: PPUSH
96521: LD_VAR 0 4
96525: PPUSH
96526: LD_INT 3
96528: PPUSH
96529: LD_INT 12
96531: PPUSH
96532: CALL_OW 12
96536: PPUSH
96537: CALL_OW 272
96541: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96542: LD_ADDR_VAR 0 3
96546: PUSH
96547: LD_VAR 0 1
96551: PPUSH
96552: CALL_OW 251
96556: PPUSH
96557: LD_VAR 0 4
96561: PPUSH
96562: LD_INT 3
96564: PPUSH
96565: LD_INT 12
96567: PPUSH
96568: CALL_OW 12
96572: PPUSH
96573: CALL_OW 273
96577: ST_TO_ADDR
// if ValidHex ( x , y ) then
96578: LD_VAR 0 2
96582: PPUSH
96583: LD_VAR 0 3
96587: PPUSH
96588: CALL_OW 488
96592: IFFALSE 96627
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96594: LD_VAR 0 1
96598: PPUSH
96599: LD_VAR 0 2
96603: PPUSH
96604: LD_VAR 0 3
96608: PPUSH
96609: LD_INT 3
96611: PPUSH
96612: LD_INT 6
96614: PPUSH
96615: CALL_OW 12
96619: PPUSH
96620: LD_INT 1
96622: PPUSH
96623: CALL_OW 483
// end ;
96627: GO 96487
96629: POP
96630: POP
// end ;
96631: PPOPN 5
96633: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96634: LD_EXP 133
96638: PUSH
96639: LD_EXP 168
96643: AND
96644: IFFALSE 96738
96646: GO 96648
96648: DISABLE
96649: LD_INT 0
96651: PPUSH
96652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96653: LD_ADDR_VAR 0 2
96657: PUSH
96658: LD_INT 22
96660: PUSH
96661: LD_OWVAR 2
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 32
96672: PUSH
96673: LD_INT 1
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 21
96682: PUSH
96683: LD_INT 2
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: LIST
96694: PPUSH
96695: CALL_OW 69
96699: ST_TO_ADDR
// if not tmp then
96700: LD_VAR 0 2
96704: NOT
96705: IFFALSE 96709
// exit ;
96707: GO 96738
// for i in tmp do
96709: LD_ADDR_VAR 0 1
96713: PUSH
96714: LD_VAR 0 2
96718: PUSH
96719: FOR_IN
96720: IFFALSE 96736
// SetFuel ( i , 0 ) ;
96722: LD_VAR 0 1
96726: PPUSH
96727: LD_INT 0
96729: PPUSH
96730: CALL_OW 240
96734: GO 96719
96736: POP
96737: POP
// end ;
96738: PPOPN 2
96740: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96741: LD_EXP 133
96745: PUSH
96746: LD_EXP 169
96750: AND
96751: IFFALSE 96817
96753: GO 96755
96755: DISABLE
96756: LD_INT 0
96758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96759: LD_ADDR_VAR 0 1
96763: PUSH
96764: LD_INT 22
96766: PUSH
96767: LD_OWVAR 2
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 30
96778: PUSH
96779: LD_INT 29
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: PPUSH
96790: CALL_OW 69
96794: ST_TO_ADDR
// if not tmp then
96795: LD_VAR 0 1
96799: NOT
96800: IFFALSE 96804
// exit ;
96802: GO 96817
// DestroyUnit ( tmp [ 1 ] ) ;
96804: LD_VAR 0 1
96808: PUSH
96809: LD_INT 1
96811: ARRAY
96812: PPUSH
96813: CALL_OW 65
// end ;
96817: PPOPN 1
96819: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96820: LD_EXP 133
96824: PUSH
96825: LD_EXP 171
96829: AND
96830: IFFALSE 96959
96832: GO 96834
96834: DISABLE
96835: LD_INT 0
96837: PPUSH
// begin uc_side := 0 ;
96838: LD_ADDR_OWVAR 20
96842: PUSH
96843: LD_INT 0
96845: ST_TO_ADDR
// uc_nation := nation_arabian ;
96846: LD_ADDR_OWVAR 21
96850: PUSH
96851: LD_INT 2
96853: ST_TO_ADDR
// hc_gallery :=  ;
96854: LD_ADDR_OWVAR 33
96858: PUSH
96859: LD_STRING 
96861: ST_TO_ADDR
// hc_name :=  ;
96862: LD_ADDR_OWVAR 26
96866: PUSH
96867: LD_STRING 
96869: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96870: LD_INT 1
96872: PPUSH
96873: LD_INT 11
96875: PPUSH
96876: LD_INT 10
96878: PPUSH
96879: CALL_OW 380
// un := CreateHuman ;
96883: LD_ADDR_VAR 0 1
96887: PUSH
96888: CALL_OW 44
96892: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96893: LD_VAR 0 1
96897: PPUSH
96898: LD_INT 1
96900: PPUSH
96901: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96905: LD_INT 35
96907: PPUSH
96908: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96912: LD_VAR 0 1
96916: PPUSH
96917: LD_INT 22
96919: PUSH
96920: LD_OWVAR 2
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PPUSH
96929: CALL_OW 69
96933: PPUSH
96934: LD_VAR 0 1
96938: PPUSH
96939: CALL_OW 74
96943: PPUSH
96944: CALL_OW 115
// until IsDead ( un ) ;
96948: LD_VAR 0 1
96952: PPUSH
96953: CALL_OW 301
96957: IFFALSE 96905
// end ;
96959: PPOPN 1
96961: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96962: LD_EXP 133
96966: PUSH
96967: LD_EXP 173
96971: AND
96972: IFFALSE 96984
96974: GO 96976
96976: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96977: LD_STRING earthquake(getX(game), 0, 32)
96979: PPUSH
96980: CALL_OW 559
96984: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96985: LD_EXP 133
96989: PUSH
96990: LD_EXP 174
96994: AND
96995: IFFALSE 97086
96997: GO 96999
96999: DISABLE
97000: LD_INT 0
97002: PPUSH
// begin enable ;
97003: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97004: LD_ADDR_VAR 0 1
97008: PUSH
97009: LD_INT 22
97011: PUSH
97012: LD_OWVAR 2
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 21
97023: PUSH
97024: LD_INT 2
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 33
97033: PUSH
97034: LD_INT 3
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: LIST
97045: PPUSH
97046: CALL_OW 69
97050: ST_TO_ADDR
// if not tmp then
97051: LD_VAR 0 1
97055: NOT
97056: IFFALSE 97060
// exit ;
97058: GO 97086
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97060: LD_VAR 0 1
97064: PUSH
97065: LD_INT 1
97067: PPUSH
97068: LD_VAR 0 1
97072: PPUSH
97073: CALL_OW 12
97077: ARRAY
97078: PPUSH
97079: LD_INT 1
97081: PPUSH
97082: CALL_OW 234
// end ;
97086: PPOPN 1
97088: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97089: LD_EXP 133
97093: PUSH
97094: LD_EXP 175
97098: AND
97099: IFFALSE 97240
97101: GO 97103
97103: DISABLE
97104: LD_INT 0
97106: PPUSH
97107: PPUSH
97108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97109: LD_ADDR_VAR 0 3
97113: PUSH
97114: LD_INT 22
97116: PUSH
97117: LD_OWVAR 2
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 25
97128: PUSH
97129: LD_INT 1
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PPUSH
97140: CALL_OW 69
97144: ST_TO_ADDR
// if not tmp then
97145: LD_VAR 0 3
97149: NOT
97150: IFFALSE 97154
// exit ;
97152: GO 97240
// un := tmp [ rand ( 1 , tmp ) ] ;
97154: LD_ADDR_VAR 0 2
97158: PUSH
97159: LD_VAR 0 3
97163: PUSH
97164: LD_INT 1
97166: PPUSH
97167: LD_VAR 0 3
97171: PPUSH
97172: CALL_OW 12
97176: ARRAY
97177: ST_TO_ADDR
// if Crawls ( un ) then
97178: LD_VAR 0 2
97182: PPUSH
97183: CALL_OW 318
97187: IFFALSE 97198
// ComWalk ( un ) ;
97189: LD_VAR 0 2
97193: PPUSH
97194: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97198: LD_VAR 0 2
97202: PPUSH
97203: LD_INT 9
97205: PPUSH
97206: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97210: LD_INT 28
97212: PPUSH
97213: LD_OWVAR 2
97217: PPUSH
97218: LD_INT 2
97220: PPUSH
97221: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97225: LD_INT 29
97227: PPUSH
97228: LD_OWVAR 2
97232: PPUSH
97233: LD_INT 2
97235: PPUSH
97236: CALL_OW 322
// end ;
97240: PPOPN 3
97242: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97243: LD_EXP 133
97247: PUSH
97248: LD_EXP 176
97252: AND
97253: IFFALSE 97364
97255: GO 97257
97257: DISABLE
97258: LD_INT 0
97260: PPUSH
97261: PPUSH
97262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97263: LD_ADDR_VAR 0 3
97267: PUSH
97268: LD_INT 22
97270: PUSH
97271: LD_OWVAR 2
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 25
97282: PUSH
97283: LD_INT 1
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PPUSH
97294: CALL_OW 69
97298: ST_TO_ADDR
// if not tmp then
97299: LD_VAR 0 3
97303: NOT
97304: IFFALSE 97308
// exit ;
97306: GO 97364
// un := tmp [ rand ( 1 , tmp ) ] ;
97308: LD_ADDR_VAR 0 2
97312: PUSH
97313: LD_VAR 0 3
97317: PUSH
97318: LD_INT 1
97320: PPUSH
97321: LD_VAR 0 3
97325: PPUSH
97326: CALL_OW 12
97330: ARRAY
97331: ST_TO_ADDR
// if Crawls ( un ) then
97332: LD_VAR 0 2
97336: PPUSH
97337: CALL_OW 318
97341: IFFALSE 97352
// ComWalk ( un ) ;
97343: LD_VAR 0 2
97347: PPUSH
97348: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97352: LD_VAR 0 2
97356: PPUSH
97357: LD_INT 8
97359: PPUSH
97360: CALL_OW 336
// end ;
97364: PPOPN 3
97366: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97367: LD_EXP 133
97371: PUSH
97372: LD_EXP 177
97376: AND
97377: IFFALSE 97521
97379: GO 97381
97381: DISABLE
97382: LD_INT 0
97384: PPUSH
97385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97386: LD_ADDR_VAR 0 2
97390: PUSH
97391: LD_INT 22
97393: PUSH
97394: LD_OWVAR 2
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: PUSH
97403: LD_INT 21
97405: PUSH
97406: LD_INT 2
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: LD_INT 2
97415: PUSH
97416: LD_INT 34
97418: PUSH
97419: LD_INT 12
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PUSH
97426: LD_INT 34
97428: PUSH
97429: LD_INT 51
97431: PUSH
97432: EMPTY
97433: LIST
97434: LIST
97435: PUSH
97436: LD_INT 34
97438: PUSH
97439: LD_INT 32
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: PUSH
97452: EMPTY
97453: LIST
97454: LIST
97455: LIST
97456: PPUSH
97457: CALL_OW 69
97461: ST_TO_ADDR
// if not tmp then
97462: LD_VAR 0 2
97466: NOT
97467: IFFALSE 97471
// exit ;
97469: GO 97521
// for i in tmp do
97471: LD_ADDR_VAR 0 1
97475: PUSH
97476: LD_VAR 0 2
97480: PUSH
97481: FOR_IN
97482: IFFALSE 97519
// if GetCargo ( i , mat_artifact ) = 0 then
97484: LD_VAR 0 1
97488: PPUSH
97489: LD_INT 4
97491: PPUSH
97492: CALL_OW 289
97496: PUSH
97497: LD_INT 0
97499: EQUAL
97500: IFFALSE 97517
// SetCargo ( i , mat_siberit , 100 ) ;
97502: LD_VAR 0 1
97506: PPUSH
97507: LD_INT 3
97509: PPUSH
97510: LD_INT 100
97512: PPUSH
97513: CALL_OW 290
97517: GO 97481
97519: POP
97520: POP
// end ;
97521: PPOPN 2
97523: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97524: LD_EXP 133
97528: PUSH
97529: LD_EXP 178
97533: AND
97534: IFFALSE 97717
97536: GO 97538
97538: DISABLE
97539: LD_INT 0
97541: PPUSH
97542: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97543: LD_ADDR_VAR 0 2
97547: PUSH
97548: LD_INT 22
97550: PUSH
97551: LD_OWVAR 2
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PPUSH
97560: CALL_OW 69
97564: ST_TO_ADDR
// if not tmp then
97565: LD_VAR 0 2
97569: NOT
97570: IFFALSE 97574
// exit ;
97572: GO 97717
// for i := 1 to 2 do
97574: LD_ADDR_VAR 0 1
97578: PUSH
97579: DOUBLE
97580: LD_INT 1
97582: DEC
97583: ST_TO_ADDR
97584: LD_INT 2
97586: PUSH
97587: FOR_TO
97588: IFFALSE 97715
// begin uc_side := your_side ;
97590: LD_ADDR_OWVAR 20
97594: PUSH
97595: LD_OWVAR 2
97599: ST_TO_ADDR
// uc_nation := nation_american ;
97600: LD_ADDR_OWVAR 21
97604: PUSH
97605: LD_INT 1
97607: ST_TO_ADDR
// vc_chassis := us_morphling ;
97608: LD_ADDR_OWVAR 37
97612: PUSH
97613: LD_INT 5
97615: ST_TO_ADDR
// vc_engine := engine_siberite ;
97616: LD_ADDR_OWVAR 39
97620: PUSH
97621: LD_INT 3
97623: ST_TO_ADDR
// vc_control := control_computer ;
97624: LD_ADDR_OWVAR 38
97628: PUSH
97629: LD_INT 3
97631: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97632: LD_ADDR_OWVAR 40
97636: PUSH
97637: LD_INT 10
97639: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97640: LD_VAR 0 2
97644: PUSH
97645: LD_INT 1
97647: ARRAY
97648: PPUSH
97649: CALL_OW 310
97653: NOT
97654: IFFALSE 97701
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97656: CALL_OW 45
97660: PPUSH
97661: LD_VAR 0 2
97665: PUSH
97666: LD_INT 1
97668: ARRAY
97669: PPUSH
97670: CALL_OW 250
97674: PPUSH
97675: LD_VAR 0 2
97679: PUSH
97680: LD_INT 1
97682: ARRAY
97683: PPUSH
97684: CALL_OW 251
97688: PPUSH
97689: LD_INT 12
97691: PPUSH
97692: LD_INT 1
97694: PPUSH
97695: CALL_OW 50
97699: GO 97713
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97701: CALL_OW 45
97705: PPUSH
97706: LD_INT 1
97708: PPUSH
97709: CALL_OW 51
// end ;
97713: GO 97587
97715: POP
97716: POP
// end ;
97717: PPOPN 2
97719: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97720: LD_EXP 133
97724: PUSH
97725: LD_EXP 179
97729: AND
97730: IFFALSE 97952
97732: GO 97734
97734: DISABLE
97735: LD_INT 0
97737: PPUSH
97738: PPUSH
97739: PPUSH
97740: PPUSH
97741: PPUSH
97742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97743: LD_ADDR_VAR 0 6
97747: PUSH
97748: LD_INT 22
97750: PUSH
97751: LD_OWVAR 2
97755: PUSH
97756: EMPTY
97757: LIST
97758: LIST
97759: PUSH
97760: LD_INT 21
97762: PUSH
97763: LD_INT 1
97765: PUSH
97766: EMPTY
97767: LIST
97768: LIST
97769: PUSH
97770: LD_INT 3
97772: PUSH
97773: LD_INT 23
97775: PUSH
97776: LD_INT 0
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PUSH
97787: EMPTY
97788: LIST
97789: LIST
97790: LIST
97791: PPUSH
97792: CALL_OW 69
97796: ST_TO_ADDR
// if not tmp then
97797: LD_VAR 0 6
97801: NOT
97802: IFFALSE 97806
// exit ;
97804: GO 97952
// s1 := rand ( 1 , 4 ) ;
97806: LD_ADDR_VAR 0 2
97810: PUSH
97811: LD_INT 1
97813: PPUSH
97814: LD_INT 4
97816: PPUSH
97817: CALL_OW 12
97821: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97822: LD_ADDR_VAR 0 4
97826: PUSH
97827: LD_VAR 0 6
97831: PUSH
97832: LD_INT 1
97834: ARRAY
97835: PPUSH
97836: LD_VAR 0 2
97840: PPUSH
97841: CALL_OW 259
97845: ST_TO_ADDR
// if s1 = 1 then
97846: LD_VAR 0 2
97850: PUSH
97851: LD_INT 1
97853: EQUAL
97854: IFFALSE 97874
// s2 := rand ( 2 , 4 ) else
97856: LD_ADDR_VAR 0 3
97860: PUSH
97861: LD_INT 2
97863: PPUSH
97864: LD_INT 4
97866: PPUSH
97867: CALL_OW 12
97871: ST_TO_ADDR
97872: GO 97882
// s2 := 1 ;
97874: LD_ADDR_VAR 0 3
97878: PUSH
97879: LD_INT 1
97881: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97882: LD_ADDR_VAR 0 5
97886: PUSH
97887: LD_VAR 0 6
97891: PUSH
97892: LD_INT 1
97894: ARRAY
97895: PPUSH
97896: LD_VAR 0 3
97900: PPUSH
97901: CALL_OW 259
97905: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97906: LD_VAR 0 6
97910: PUSH
97911: LD_INT 1
97913: ARRAY
97914: PPUSH
97915: LD_VAR 0 2
97919: PPUSH
97920: LD_VAR 0 5
97924: PPUSH
97925: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97929: LD_VAR 0 6
97933: PUSH
97934: LD_INT 1
97936: ARRAY
97937: PPUSH
97938: LD_VAR 0 3
97942: PPUSH
97943: LD_VAR 0 4
97947: PPUSH
97948: CALL_OW 237
// end ;
97952: PPOPN 6
97954: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97955: LD_EXP 133
97959: PUSH
97960: LD_EXP 180
97964: AND
97965: IFFALSE 98044
97967: GO 97969
97969: DISABLE
97970: LD_INT 0
97972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97973: LD_ADDR_VAR 0 1
97977: PUSH
97978: LD_INT 22
97980: PUSH
97981: LD_OWVAR 2
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: PUSH
97990: LD_INT 30
97992: PUSH
97993: LD_INT 3
97995: PUSH
97996: EMPTY
97997: LIST
97998: LIST
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PPUSH
98004: CALL_OW 69
98008: ST_TO_ADDR
// if not tmp then
98009: LD_VAR 0 1
98013: NOT
98014: IFFALSE 98018
// exit ;
98016: GO 98044
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98018: LD_VAR 0 1
98022: PUSH
98023: LD_INT 1
98025: PPUSH
98026: LD_VAR 0 1
98030: PPUSH
98031: CALL_OW 12
98035: ARRAY
98036: PPUSH
98037: LD_INT 1
98039: PPUSH
98040: CALL_OW 234
// end ;
98044: PPOPN 1
98046: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98047: LD_EXP 133
98051: PUSH
98052: LD_EXP 181
98056: AND
98057: IFFALSE 98169
98059: GO 98061
98061: DISABLE
98062: LD_INT 0
98064: PPUSH
98065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98066: LD_ADDR_VAR 0 2
98070: PUSH
98071: LD_INT 22
98073: PUSH
98074: LD_OWVAR 2
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: LD_INT 2
98085: PUSH
98086: LD_INT 30
98088: PUSH
98089: LD_INT 27
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PUSH
98096: LD_INT 30
98098: PUSH
98099: LD_INT 26
98101: PUSH
98102: EMPTY
98103: LIST
98104: LIST
98105: PUSH
98106: LD_INT 30
98108: PUSH
98109: LD_INT 28
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PPUSH
98126: CALL_OW 69
98130: ST_TO_ADDR
// if not tmp then
98131: LD_VAR 0 2
98135: NOT
98136: IFFALSE 98140
// exit ;
98138: GO 98169
// for i in tmp do
98140: LD_ADDR_VAR 0 1
98144: PUSH
98145: LD_VAR 0 2
98149: PUSH
98150: FOR_IN
98151: IFFALSE 98167
// SetLives ( i , 1 ) ;
98153: LD_VAR 0 1
98157: PPUSH
98158: LD_INT 1
98160: PPUSH
98161: CALL_OW 234
98165: GO 98150
98167: POP
98168: POP
// end ;
98169: PPOPN 2
98171: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98172: LD_EXP 133
98176: PUSH
98177: LD_EXP 182
98181: AND
98182: IFFALSE 98456
98184: GO 98186
98186: DISABLE
98187: LD_INT 0
98189: PPUSH
98190: PPUSH
98191: PPUSH
// begin i := rand ( 1 , 7 ) ;
98192: LD_ADDR_VAR 0 1
98196: PUSH
98197: LD_INT 1
98199: PPUSH
98200: LD_INT 7
98202: PPUSH
98203: CALL_OW 12
98207: ST_TO_ADDR
// case i of 1 :
98208: LD_VAR 0 1
98212: PUSH
98213: LD_INT 1
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98221
98219: GO 98231
98221: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98222: LD_STRING earthquake(getX(game), 0, 32)
98224: PPUSH
98225: CALL_OW 559
98229: GO 98456
98231: LD_INT 2
98233: DOUBLE
98234: EQUAL
98235: IFTRUE 98239
98237: GO 98253
98239: POP
// begin ToLua ( displayStucuk(); ) ;
98240: LD_STRING displayStucuk();
98242: PPUSH
98243: CALL_OW 559
// ResetFog ;
98247: CALL_OW 335
// end ; 3 :
98251: GO 98456
98253: LD_INT 3
98255: DOUBLE
98256: EQUAL
98257: IFTRUE 98261
98259: GO 98365
98261: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98262: LD_ADDR_VAR 0 2
98266: PUSH
98267: LD_INT 22
98269: PUSH
98270: LD_OWVAR 2
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: LD_INT 25
98281: PUSH
98282: LD_INT 1
98284: PUSH
98285: EMPTY
98286: LIST
98287: LIST
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PPUSH
98293: CALL_OW 69
98297: ST_TO_ADDR
// if not tmp then
98298: LD_VAR 0 2
98302: NOT
98303: IFFALSE 98307
// exit ;
98305: GO 98456
// un := tmp [ rand ( 1 , tmp ) ] ;
98307: LD_ADDR_VAR 0 3
98311: PUSH
98312: LD_VAR 0 2
98316: PUSH
98317: LD_INT 1
98319: PPUSH
98320: LD_VAR 0 2
98324: PPUSH
98325: CALL_OW 12
98329: ARRAY
98330: ST_TO_ADDR
// if Crawls ( un ) then
98331: LD_VAR 0 3
98335: PPUSH
98336: CALL_OW 318
98340: IFFALSE 98351
// ComWalk ( un ) ;
98342: LD_VAR 0 3
98346: PPUSH
98347: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98351: LD_VAR 0 3
98355: PPUSH
98356: LD_INT 8
98358: PPUSH
98359: CALL_OW 336
// end ; 4 :
98363: GO 98456
98365: LD_INT 4
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98373
98371: GO 98434
98373: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98374: LD_ADDR_VAR 0 2
98378: PUSH
98379: LD_INT 22
98381: PUSH
98382: LD_OWVAR 2
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 30
98393: PUSH
98394: LD_INT 29
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: PPUSH
98405: CALL_OW 69
98409: ST_TO_ADDR
// if not tmp then
98410: LD_VAR 0 2
98414: NOT
98415: IFFALSE 98419
// exit ;
98417: GO 98456
// DestroyUnit ( tmp [ 1 ] ) ;
98419: LD_VAR 0 2
98423: PUSH
98424: LD_INT 1
98426: ARRAY
98427: PPUSH
98428: CALL_OW 65
// end ; 5 .. 7 :
98432: GO 98456
98434: LD_INT 5
98436: DOUBLE
98437: GREATEREQUAL
98438: IFFALSE 98446
98440: LD_INT 7
98442: DOUBLE
98443: LESSEQUAL
98444: IFTRUE 98448
98446: GO 98455
98448: POP
// StreamSibBomb ; end ;
98449: CALL 94706 0 0
98453: GO 98456
98455: POP
// end ;
98456: PPOPN 3
98458: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98459: LD_EXP 133
98463: PUSH
98464: LD_EXP 183
98468: AND
98469: IFFALSE 98625
98471: GO 98473
98473: DISABLE
98474: LD_INT 0
98476: PPUSH
98477: PPUSH
98478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98479: LD_ADDR_VAR 0 2
98483: PUSH
98484: LD_INT 81
98486: PUSH
98487: LD_OWVAR 2
98491: PUSH
98492: EMPTY
98493: LIST
98494: LIST
98495: PUSH
98496: LD_INT 2
98498: PUSH
98499: LD_INT 21
98501: PUSH
98502: LD_INT 1
98504: PUSH
98505: EMPTY
98506: LIST
98507: LIST
98508: PUSH
98509: LD_INT 21
98511: PUSH
98512: LD_INT 2
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: EMPTY
98520: LIST
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: PPUSH
98528: CALL_OW 69
98532: ST_TO_ADDR
// if not tmp then
98533: LD_VAR 0 2
98537: NOT
98538: IFFALSE 98542
// exit ;
98540: GO 98625
// p := 0 ;
98542: LD_ADDR_VAR 0 3
98546: PUSH
98547: LD_INT 0
98549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98550: LD_INT 35
98552: PPUSH
98553: CALL_OW 67
// p := p + 1 ;
98557: LD_ADDR_VAR 0 3
98561: PUSH
98562: LD_VAR 0 3
98566: PUSH
98567: LD_INT 1
98569: PLUS
98570: ST_TO_ADDR
// for i in tmp do
98571: LD_ADDR_VAR 0 1
98575: PUSH
98576: LD_VAR 0 2
98580: PUSH
98581: FOR_IN
98582: IFFALSE 98613
// if GetLives ( i ) < 1000 then
98584: LD_VAR 0 1
98588: PPUSH
98589: CALL_OW 256
98593: PUSH
98594: LD_INT 1000
98596: LESS
98597: IFFALSE 98611
// SetLives ( i , 1000 ) ;
98599: LD_VAR 0 1
98603: PPUSH
98604: LD_INT 1000
98606: PPUSH
98607: CALL_OW 234
98611: GO 98581
98613: POP
98614: POP
// until p > 20 ;
98615: LD_VAR 0 3
98619: PUSH
98620: LD_INT 20
98622: GREATER
98623: IFFALSE 98550
// end ;
98625: PPOPN 3
98627: END
// every 0 0$1 trigger StreamModeActive and sTime do
98628: LD_EXP 133
98632: PUSH
98633: LD_EXP 184
98637: AND
98638: IFFALSE 98673
98640: GO 98642
98642: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98643: LD_INT 28
98645: PPUSH
98646: LD_OWVAR 2
98650: PPUSH
98651: LD_INT 2
98653: PPUSH
98654: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98658: LD_INT 30
98660: PPUSH
98661: LD_OWVAR 2
98665: PPUSH
98666: LD_INT 2
98668: PPUSH
98669: CALL_OW 322
// end ;
98673: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98674: LD_EXP 133
98678: PUSH
98679: LD_EXP 185
98683: AND
98684: IFFALSE 98805
98686: GO 98688
98688: DISABLE
98689: LD_INT 0
98691: PPUSH
98692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98693: LD_ADDR_VAR 0 2
98697: PUSH
98698: LD_INT 22
98700: PUSH
98701: LD_OWVAR 2
98705: PUSH
98706: EMPTY
98707: LIST
98708: LIST
98709: PUSH
98710: LD_INT 21
98712: PUSH
98713: LD_INT 1
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: LD_INT 3
98722: PUSH
98723: LD_INT 23
98725: PUSH
98726: LD_INT 0
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: LIST
98741: PPUSH
98742: CALL_OW 69
98746: ST_TO_ADDR
// if not tmp then
98747: LD_VAR 0 2
98751: NOT
98752: IFFALSE 98756
// exit ;
98754: GO 98805
// for i in tmp do
98756: LD_ADDR_VAR 0 1
98760: PUSH
98761: LD_VAR 0 2
98765: PUSH
98766: FOR_IN
98767: IFFALSE 98803
// begin if Crawls ( i ) then
98769: LD_VAR 0 1
98773: PPUSH
98774: CALL_OW 318
98778: IFFALSE 98789
// ComWalk ( i ) ;
98780: LD_VAR 0 1
98784: PPUSH
98785: CALL_OW 138
// SetClass ( i , 2 ) ;
98789: LD_VAR 0 1
98793: PPUSH
98794: LD_INT 2
98796: PPUSH
98797: CALL_OW 336
// end ;
98801: GO 98766
98803: POP
98804: POP
// end ;
98805: PPOPN 2
98807: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98808: LD_EXP 133
98812: PUSH
98813: LD_EXP 186
98817: AND
98818: IFFALSE 99099
98820: GO 98822
98822: DISABLE
98823: LD_INT 0
98825: PPUSH
98826: PPUSH
98827: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98828: LD_OWVAR 2
98832: PPUSH
98833: LD_INT 9
98835: PPUSH
98836: LD_INT 1
98838: PPUSH
98839: LD_INT 1
98841: PPUSH
98842: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98846: LD_INT 9
98848: PPUSH
98849: LD_OWVAR 2
98853: PPUSH
98854: CALL_OW 343
// uc_side := 9 ;
98858: LD_ADDR_OWVAR 20
98862: PUSH
98863: LD_INT 9
98865: ST_TO_ADDR
// uc_nation := 2 ;
98866: LD_ADDR_OWVAR 21
98870: PUSH
98871: LD_INT 2
98873: ST_TO_ADDR
// hc_name := Dark Warrior ;
98874: LD_ADDR_OWVAR 26
98878: PUSH
98879: LD_STRING Dark Warrior
98881: ST_TO_ADDR
// hc_gallery :=  ;
98882: LD_ADDR_OWVAR 33
98886: PUSH
98887: LD_STRING 
98889: ST_TO_ADDR
// hc_noskilllimit := true ;
98890: LD_ADDR_OWVAR 76
98894: PUSH
98895: LD_INT 1
98897: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98898: LD_ADDR_OWVAR 31
98902: PUSH
98903: LD_INT 30
98905: PUSH
98906: LD_INT 30
98908: PUSH
98909: LD_INT 30
98911: PUSH
98912: LD_INT 30
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: ST_TO_ADDR
// un := CreateHuman ;
98921: LD_ADDR_VAR 0 3
98925: PUSH
98926: CALL_OW 44
98930: ST_TO_ADDR
// hc_noskilllimit := false ;
98931: LD_ADDR_OWVAR 76
98935: PUSH
98936: LD_INT 0
98938: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98939: LD_VAR 0 3
98943: PPUSH
98944: LD_INT 1
98946: PPUSH
98947: CALL_OW 51
// p := 0 ;
98951: LD_ADDR_VAR 0 2
98955: PUSH
98956: LD_INT 0
98958: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98959: LD_INT 35
98961: PPUSH
98962: CALL_OW 67
// p := p + 1 ;
98966: LD_ADDR_VAR 0 2
98970: PUSH
98971: LD_VAR 0 2
98975: PUSH
98976: LD_INT 1
98978: PLUS
98979: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98980: LD_VAR 0 3
98984: PPUSH
98985: CALL_OW 256
98989: PUSH
98990: LD_INT 1000
98992: LESS
98993: IFFALSE 99007
// SetLives ( un , 1000 ) ;
98995: LD_VAR 0 3
98999: PPUSH
99000: LD_INT 1000
99002: PPUSH
99003: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99007: LD_VAR 0 3
99011: PPUSH
99012: LD_INT 81
99014: PUSH
99015: LD_OWVAR 2
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: PUSH
99024: LD_INT 91
99026: PUSH
99027: LD_VAR 0 3
99031: PUSH
99032: LD_INT 30
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: LIST
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PPUSH
99044: CALL_OW 69
99048: PPUSH
99049: LD_VAR 0 3
99053: PPUSH
99054: CALL_OW 74
99058: PPUSH
99059: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99063: LD_VAR 0 2
99067: PUSH
99068: LD_INT 60
99070: GREATER
99071: PUSH
99072: LD_VAR 0 3
99076: PPUSH
99077: CALL_OW 301
99081: OR
99082: IFFALSE 98959
// if un then
99084: LD_VAR 0 3
99088: IFFALSE 99099
// RemoveUnit ( un ) ;
99090: LD_VAR 0 3
99094: PPUSH
99095: CALL_OW 64
// end ;
99099: PPOPN 3
99101: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99102: LD_INT 0
99104: PPUSH
// case cmd of 301 :
99105: LD_VAR 0 1
99109: PUSH
99110: LD_INT 301
99112: DOUBLE
99113: EQUAL
99114: IFTRUE 99118
99116: GO 99150
99118: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99119: LD_VAR 0 6
99123: PPUSH
99124: LD_VAR 0 7
99128: PPUSH
99129: LD_VAR 0 8
99133: PPUSH
99134: LD_VAR 0 4
99138: PPUSH
99139: LD_VAR 0 5
99143: PPUSH
99144: CALL 100351 0 5
99148: GO 99271
99150: LD_INT 302
99152: DOUBLE
99153: EQUAL
99154: IFTRUE 99158
99156: GO 99195
99158: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99159: LD_VAR 0 6
99163: PPUSH
99164: LD_VAR 0 7
99168: PPUSH
99169: LD_VAR 0 8
99173: PPUSH
99174: LD_VAR 0 9
99178: PPUSH
99179: LD_VAR 0 4
99183: PPUSH
99184: LD_VAR 0 5
99188: PPUSH
99189: CALL 100442 0 6
99193: GO 99271
99195: LD_INT 303
99197: DOUBLE
99198: EQUAL
99199: IFTRUE 99203
99201: GO 99240
99203: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99204: LD_VAR 0 6
99208: PPUSH
99209: LD_VAR 0 7
99213: PPUSH
99214: LD_VAR 0 8
99218: PPUSH
99219: LD_VAR 0 9
99223: PPUSH
99224: LD_VAR 0 4
99228: PPUSH
99229: LD_VAR 0 5
99233: PPUSH
99234: CALL 99276 0 6
99238: GO 99271
99240: LD_INT 304
99242: DOUBLE
99243: EQUAL
99244: IFTRUE 99248
99246: GO 99270
99248: POP
// hHackTeleport ( unit , x , y ) ; end ;
99249: LD_VAR 0 2
99253: PPUSH
99254: LD_VAR 0 4
99258: PPUSH
99259: LD_VAR 0 5
99263: PPUSH
99264: CALL 101035 0 3
99268: GO 99271
99270: POP
// end ;
99271: LD_VAR 0 12
99275: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99276: LD_INT 0
99278: PPUSH
99279: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99280: LD_VAR 0 1
99284: PUSH
99285: LD_INT 1
99287: LESS
99288: PUSH
99289: LD_VAR 0 1
99293: PUSH
99294: LD_INT 3
99296: GREATER
99297: OR
99298: PUSH
99299: LD_VAR 0 5
99303: PPUSH
99304: LD_VAR 0 6
99308: PPUSH
99309: CALL_OW 428
99313: OR
99314: IFFALSE 99318
// exit ;
99316: GO 100038
// uc_side := your_side ;
99318: LD_ADDR_OWVAR 20
99322: PUSH
99323: LD_OWVAR 2
99327: ST_TO_ADDR
// uc_nation := nation ;
99328: LD_ADDR_OWVAR 21
99332: PUSH
99333: LD_VAR 0 1
99337: ST_TO_ADDR
// bc_level = 1 ;
99338: LD_ADDR_OWVAR 43
99342: PUSH
99343: LD_INT 1
99345: ST_TO_ADDR
// case btype of 1 :
99346: LD_VAR 0 2
99350: PUSH
99351: LD_INT 1
99353: DOUBLE
99354: EQUAL
99355: IFTRUE 99359
99357: GO 99370
99359: POP
// bc_type := b_depot ; 2 :
99360: LD_ADDR_OWVAR 42
99364: PUSH
99365: LD_INT 0
99367: ST_TO_ADDR
99368: GO 99982
99370: LD_INT 2
99372: DOUBLE
99373: EQUAL
99374: IFTRUE 99378
99376: GO 99389
99378: POP
// bc_type := b_warehouse ; 3 :
99379: LD_ADDR_OWVAR 42
99383: PUSH
99384: LD_INT 1
99386: ST_TO_ADDR
99387: GO 99982
99389: LD_INT 3
99391: DOUBLE
99392: EQUAL
99393: IFTRUE 99397
99395: GO 99408
99397: POP
// bc_type := b_lab ; 4 .. 9 :
99398: LD_ADDR_OWVAR 42
99402: PUSH
99403: LD_INT 6
99405: ST_TO_ADDR
99406: GO 99982
99408: LD_INT 4
99410: DOUBLE
99411: GREATEREQUAL
99412: IFFALSE 99420
99414: LD_INT 9
99416: DOUBLE
99417: LESSEQUAL
99418: IFTRUE 99422
99420: GO 99474
99422: POP
// begin bc_type := b_lab_half ;
99423: LD_ADDR_OWVAR 42
99427: PUSH
99428: LD_INT 7
99430: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99431: LD_ADDR_OWVAR 44
99435: PUSH
99436: LD_INT 10
99438: PUSH
99439: LD_INT 11
99441: PUSH
99442: LD_INT 12
99444: PUSH
99445: LD_INT 15
99447: PUSH
99448: LD_INT 14
99450: PUSH
99451: LD_INT 13
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: PUSH
99462: LD_VAR 0 2
99466: PUSH
99467: LD_INT 3
99469: MINUS
99470: ARRAY
99471: ST_TO_ADDR
// end ; 10 .. 13 :
99472: GO 99982
99474: LD_INT 10
99476: DOUBLE
99477: GREATEREQUAL
99478: IFFALSE 99486
99480: LD_INT 13
99482: DOUBLE
99483: LESSEQUAL
99484: IFTRUE 99488
99486: GO 99565
99488: POP
// begin bc_type := b_lab_full ;
99489: LD_ADDR_OWVAR 42
99493: PUSH
99494: LD_INT 8
99496: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99497: LD_ADDR_OWVAR 44
99501: PUSH
99502: LD_INT 10
99504: PUSH
99505: LD_INT 12
99507: PUSH
99508: LD_INT 14
99510: PUSH
99511: LD_INT 13
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: PUSH
99520: LD_VAR 0 2
99524: PUSH
99525: LD_INT 9
99527: MINUS
99528: ARRAY
99529: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99530: LD_ADDR_OWVAR 45
99534: PUSH
99535: LD_INT 11
99537: PUSH
99538: LD_INT 15
99540: PUSH
99541: LD_INT 12
99543: PUSH
99544: LD_INT 15
99546: PUSH
99547: EMPTY
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: PUSH
99553: LD_VAR 0 2
99557: PUSH
99558: LD_INT 9
99560: MINUS
99561: ARRAY
99562: ST_TO_ADDR
// end ; 14 :
99563: GO 99982
99565: LD_INT 14
99567: DOUBLE
99568: EQUAL
99569: IFTRUE 99573
99571: GO 99584
99573: POP
// bc_type := b_workshop ; 15 :
99574: LD_ADDR_OWVAR 42
99578: PUSH
99579: LD_INT 2
99581: ST_TO_ADDR
99582: GO 99982
99584: LD_INT 15
99586: DOUBLE
99587: EQUAL
99588: IFTRUE 99592
99590: GO 99603
99592: POP
// bc_type := b_factory ; 16 :
99593: LD_ADDR_OWVAR 42
99597: PUSH
99598: LD_INT 3
99600: ST_TO_ADDR
99601: GO 99982
99603: LD_INT 16
99605: DOUBLE
99606: EQUAL
99607: IFTRUE 99611
99609: GO 99622
99611: POP
// bc_type := b_ext_gun ; 17 :
99612: LD_ADDR_OWVAR 42
99616: PUSH
99617: LD_INT 17
99619: ST_TO_ADDR
99620: GO 99982
99622: LD_INT 17
99624: DOUBLE
99625: EQUAL
99626: IFTRUE 99630
99628: GO 99658
99630: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99631: LD_ADDR_OWVAR 42
99635: PUSH
99636: LD_INT 19
99638: PUSH
99639: LD_INT 23
99641: PUSH
99642: LD_INT 19
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: LIST
99649: PUSH
99650: LD_VAR 0 1
99654: ARRAY
99655: ST_TO_ADDR
99656: GO 99982
99658: LD_INT 18
99660: DOUBLE
99661: EQUAL
99662: IFTRUE 99666
99664: GO 99677
99666: POP
// bc_type := b_ext_radar ; 19 :
99667: LD_ADDR_OWVAR 42
99671: PUSH
99672: LD_INT 20
99674: ST_TO_ADDR
99675: GO 99982
99677: LD_INT 19
99679: DOUBLE
99680: EQUAL
99681: IFTRUE 99685
99683: GO 99696
99685: POP
// bc_type := b_ext_radio ; 20 :
99686: LD_ADDR_OWVAR 42
99690: PUSH
99691: LD_INT 22
99693: ST_TO_ADDR
99694: GO 99982
99696: LD_INT 20
99698: DOUBLE
99699: EQUAL
99700: IFTRUE 99704
99702: GO 99715
99704: POP
// bc_type := b_ext_siberium ; 21 :
99705: LD_ADDR_OWVAR 42
99709: PUSH
99710: LD_INT 21
99712: ST_TO_ADDR
99713: GO 99982
99715: LD_INT 21
99717: DOUBLE
99718: EQUAL
99719: IFTRUE 99723
99721: GO 99734
99723: POP
// bc_type := b_ext_computer ; 22 :
99724: LD_ADDR_OWVAR 42
99728: PUSH
99729: LD_INT 24
99731: ST_TO_ADDR
99732: GO 99982
99734: LD_INT 22
99736: DOUBLE
99737: EQUAL
99738: IFTRUE 99742
99740: GO 99753
99742: POP
// bc_type := b_ext_track ; 23 :
99743: LD_ADDR_OWVAR 42
99747: PUSH
99748: LD_INT 16
99750: ST_TO_ADDR
99751: GO 99982
99753: LD_INT 23
99755: DOUBLE
99756: EQUAL
99757: IFTRUE 99761
99759: GO 99772
99761: POP
// bc_type := b_ext_laser ; 24 :
99762: LD_ADDR_OWVAR 42
99766: PUSH
99767: LD_INT 25
99769: ST_TO_ADDR
99770: GO 99982
99772: LD_INT 24
99774: DOUBLE
99775: EQUAL
99776: IFTRUE 99780
99778: GO 99791
99780: POP
// bc_type := b_control_tower ; 25 :
99781: LD_ADDR_OWVAR 42
99785: PUSH
99786: LD_INT 36
99788: ST_TO_ADDR
99789: GO 99982
99791: LD_INT 25
99793: DOUBLE
99794: EQUAL
99795: IFTRUE 99799
99797: GO 99810
99799: POP
// bc_type := b_breastwork ; 26 :
99800: LD_ADDR_OWVAR 42
99804: PUSH
99805: LD_INT 31
99807: ST_TO_ADDR
99808: GO 99982
99810: LD_INT 26
99812: DOUBLE
99813: EQUAL
99814: IFTRUE 99818
99816: GO 99829
99818: POP
// bc_type := b_bunker ; 27 :
99819: LD_ADDR_OWVAR 42
99823: PUSH
99824: LD_INT 32
99826: ST_TO_ADDR
99827: GO 99982
99829: LD_INT 27
99831: DOUBLE
99832: EQUAL
99833: IFTRUE 99837
99835: GO 99848
99837: POP
// bc_type := b_turret ; 28 :
99838: LD_ADDR_OWVAR 42
99842: PUSH
99843: LD_INT 33
99845: ST_TO_ADDR
99846: GO 99982
99848: LD_INT 28
99850: DOUBLE
99851: EQUAL
99852: IFTRUE 99856
99854: GO 99867
99856: POP
// bc_type := b_armoury ; 29 :
99857: LD_ADDR_OWVAR 42
99861: PUSH
99862: LD_INT 4
99864: ST_TO_ADDR
99865: GO 99982
99867: LD_INT 29
99869: DOUBLE
99870: EQUAL
99871: IFTRUE 99875
99873: GO 99886
99875: POP
// bc_type := b_barracks ; 30 :
99876: LD_ADDR_OWVAR 42
99880: PUSH
99881: LD_INT 5
99883: ST_TO_ADDR
99884: GO 99982
99886: LD_INT 30
99888: DOUBLE
99889: EQUAL
99890: IFTRUE 99894
99892: GO 99905
99894: POP
// bc_type := b_solar_power ; 31 :
99895: LD_ADDR_OWVAR 42
99899: PUSH
99900: LD_INT 27
99902: ST_TO_ADDR
99903: GO 99982
99905: LD_INT 31
99907: DOUBLE
99908: EQUAL
99909: IFTRUE 99913
99911: GO 99924
99913: POP
// bc_type := b_oil_power ; 32 :
99914: LD_ADDR_OWVAR 42
99918: PUSH
99919: LD_INT 26
99921: ST_TO_ADDR
99922: GO 99982
99924: LD_INT 32
99926: DOUBLE
99927: EQUAL
99928: IFTRUE 99932
99930: GO 99943
99932: POP
// bc_type := b_siberite_power ; 33 :
99933: LD_ADDR_OWVAR 42
99937: PUSH
99938: LD_INT 28
99940: ST_TO_ADDR
99941: GO 99982
99943: LD_INT 33
99945: DOUBLE
99946: EQUAL
99947: IFTRUE 99951
99949: GO 99962
99951: POP
// bc_type := b_oil_mine ; 34 :
99952: LD_ADDR_OWVAR 42
99956: PUSH
99957: LD_INT 29
99959: ST_TO_ADDR
99960: GO 99982
99962: LD_INT 34
99964: DOUBLE
99965: EQUAL
99966: IFTRUE 99970
99968: GO 99981
99970: POP
// bc_type := b_siberite_mine ; end ;
99971: LD_ADDR_OWVAR 42
99975: PUSH
99976: LD_INT 30
99978: ST_TO_ADDR
99979: GO 99982
99981: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99982: LD_ADDR_VAR 0 8
99986: PUSH
99987: LD_VAR 0 5
99991: PPUSH
99992: LD_VAR 0 6
99996: PPUSH
99997: LD_VAR 0 3
100001: PPUSH
100002: CALL_OW 47
100006: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100007: LD_OWVAR 42
100011: PUSH
100012: LD_INT 32
100014: PUSH
100015: LD_INT 33
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: IN
100022: IFFALSE 100038
// PlaceWeaponTurret ( b , weapon ) ;
100024: LD_VAR 0 8
100028: PPUSH
100029: LD_VAR 0 4
100033: PPUSH
100034: CALL_OW 431
// end ;
100038: LD_VAR 0 7
100042: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100043: LD_INT 0
100045: PPUSH
100046: PPUSH
100047: PPUSH
100048: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100049: LD_ADDR_VAR 0 4
100053: PUSH
100054: LD_INT 22
100056: PUSH
100057: LD_OWVAR 2
100061: PUSH
100062: EMPTY
100063: LIST
100064: LIST
100065: PUSH
100066: LD_INT 2
100068: PUSH
100069: LD_INT 30
100071: PUSH
100072: LD_INT 0
100074: PUSH
100075: EMPTY
100076: LIST
100077: LIST
100078: PUSH
100079: LD_INT 30
100081: PUSH
100082: LD_INT 1
100084: PUSH
100085: EMPTY
100086: LIST
100087: LIST
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: LIST
100093: PUSH
100094: EMPTY
100095: LIST
100096: LIST
100097: PPUSH
100098: CALL_OW 69
100102: ST_TO_ADDR
// if not tmp then
100103: LD_VAR 0 4
100107: NOT
100108: IFFALSE 100112
// exit ;
100110: GO 100171
// for i in tmp do
100112: LD_ADDR_VAR 0 2
100116: PUSH
100117: LD_VAR 0 4
100121: PUSH
100122: FOR_IN
100123: IFFALSE 100169
// for j = 1 to 3 do
100125: LD_ADDR_VAR 0 3
100129: PUSH
100130: DOUBLE
100131: LD_INT 1
100133: DEC
100134: ST_TO_ADDR
100135: LD_INT 3
100137: PUSH
100138: FOR_TO
100139: IFFALSE 100165
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100141: LD_VAR 0 2
100145: PPUSH
100146: CALL_OW 274
100150: PPUSH
100151: LD_VAR 0 3
100155: PPUSH
100156: LD_INT 99999
100158: PPUSH
100159: CALL_OW 277
100163: GO 100138
100165: POP
100166: POP
100167: GO 100122
100169: POP
100170: POP
// end ;
100171: LD_VAR 0 1
100175: RET
// export function hHackSetLevel10 ; var i , j ; begin
100176: LD_INT 0
100178: PPUSH
100179: PPUSH
100180: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100181: LD_ADDR_VAR 0 2
100185: PUSH
100186: LD_INT 21
100188: PUSH
100189: LD_INT 1
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PPUSH
100196: CALL_OW 69
100200: PUSH
100201: FOR_IN
100202: IFFALSE 100254
// if IsSelected ( i ) then
100204: LD_VAR 0 2
100208: PPUSH
100209: CALL_OW 306
100213: IFFALSE 100252
// begin for j := 1 to 4 do
100215: LD_ADDR_VAR 0 3
100219: PUSH
100220: DOUBLE
100221: LD_INT 1
100223: DEC
100224: ST_TO_ADDR
100225: LD_INT 4
100227: PUSH
100228: FOR_TO
100229: IFFALSE 100250
// SetSkill ( i , j , 10 ) ;
100231: LD_VAR 0 2
100235: PPUSH
100236: LD_VAR 0 3
100240: PPUSH
100241: LD_INT 10
100243: PPUSH
100244: CALL_OW 237
100248: GO 100228
100250: POP
100251: POP
// end ;
100252: GO 100201
100254: POP
100255: POP
// end ;
100256: LD_VAR 0 1
100260: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100261: LD_INT 0
100263: PPUSH
100264: PPUSH
100265: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100266: LD_ADDR_VAR 0 2
100270: PUSH
100271: LD_INT 22
100273: PUSH
100274: LD_OWVAR 2
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: PUSH
100283: LD_INT 21
100285: PUSH
100286: LD_INT 1
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: EMPTY
100294: LIST
100295: LIST
100296: PPUSH
100297: CALL_OW 69
100301: PUSH
100302: FOR_IN
100303: IFFALSE 100344
// begin for j := 1 to 4 do
100305: LD_ADDR_VAR 0 3
100309: PUSH
100310: DOUBLE
100311: LD_INT 1
100313: DEC
100314: ST_TO_ADDR
100315: LD_INT 4
100317: PUSH
100318: FOR_TO
100319: IFFALSE 100340
// SetSkill ( i , j , 10 ) ;
100321: LD_VAR 0 2
100325: PPUSH
100326: LD_VAR 0 3
100330: PPUSH
100331: LD_INT 10
100333: PPUSH
100334: CALL_OW 237
100338: GO 100318
100340: POP
100341: POP
// end ;
100342: GO 100302
100344: POP
100345: POP
// end ;
100346: LD_VAR 0 1
100350: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100351: LD_INT 0
100353: PPUSH
// uc_side := your_side ;
100354: LD_ADDR_OWVAR 20
100358: PUSH
100359: LD_OWVAR 2
100363: ST_TO_ADDR
// uc_nation := nation ;
100364: LD_ADDR_OWVAR 21
100368: PUSH
100369: LD_VAR 0 1
100373: ST_TO_ADDR
// InitHc ;
100374: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100378: LD_INT 0
100380: PPUSH
100381: LD_VAR 0 2
100385: PPUSH
100386: LD_VAR 0 3
100390: PPUSH
100391: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100395: LD_VAR 0 4
100399: PPUSH
100400: LD_VAR 0 5
100404: PPUSH
100405: CALL_OW 428
100409: PUSH
100410: LD_INT 0
100412: EQUAL
100413: IFFALSE 100437
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100415: CALL_OW 44
100419: PPUSH
100420: LD_VAR 0 4
100424: PPUSH
100425: LD_VAR 0 5
100429: PPUSH
100430: LD_INT 1
100432: PPUSH
100433: CALL_OW 48
// end ;
100437: LD_VAR 0 6
100441: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100442: LD_INT 0
100444: PPUSH
100445: PPUSH
// uc_side := your_side ;
100446: LD_ADDR_OWVAR 20
100450: PUSH
100451: LD_OWVAR 2
100455: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100456: LD_VAR 0 1
100460: PUSH
100461: LD_INT 1
100463: PUSH
100464: LD_INT 2
100466: PUSH
100467: LD_INT 3
100469: PUSH
100470: LD_INT 4
100472: PUSH
100473: LD_INT 5
100475: PUSH
100476: EMPTY
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: IN
100483: IFFALSE 100495
// uc_nation := nation_american else
100485: LD_ADDR_OWVAR 21
100489: PUSH
100490: LD_INT 1
100492: ST_TO_ADDR
100493: GO 100538
// if chassis in [ 11 , 12 , 13 , 14 ] then
100495: LD_VAR 0 1
100499: PUSH
100500: LD_INT 11
100502: PUSH
100503: LD_INT 12
100505: PUSH
100506: LD_INT 13
100508: PUSH
100509: LD_INT 14
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: LIST
100516: LIST
100517: IN
100518: IFFALSE 100530
// uc_nation := nation_arabian else
100520: LD_ADDR_OWVAR 21
100524: PUSH
100525: LD_INT 2
100527: ST_TO_ADDR
100528: GO 100538
// uc_nation := nation_russian ;
100530: LD_ADDR_OWVAR 21
100534: PUSH
100535: LD_INT 3
100537: ST_TO_ADDR
// vc_chassis := chassis ;
100538: LD_ADDR_OWVAR 37
100542: PUSH
100543: LD_VAR 0 1
100547: ST_TO_ADDR
// vc_engine := engine ;
100548: LD_ADDR_OWVAR 39
100552: PUSH
100553: LD_VAR 0 2
100557: ST_TO_ADDR
// vc_control := control ;
100558: LD_ADDR_OWVAR 38
100562: PUSH
100563: LD_VAR 0 3
100567: ST_TO_ADDR
// vc_weapon := weapon ;
100568: LD_ADDR_OWVAR 40
100572: PUSH
100573: LD_VAR 0 4
100577: ST_TO_ADDR
// un := CreateVehicle ;
100578: LD_ADDR_VAR 0 8
100582: PUSH
100583: CALL_OW 45
100587: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100588: LD_VAR 0 8
100592: PPUSH
100593: LD_INT 0
100595: PPUSH
100596: LD_INT 5
100598: PPUSH
100599: CALL_OW 12
100603: PPUSH
100604: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100608: LD_VAR 0 8
100612: PPUSH
100613: LD_VAR 0 5
100617: PPUSH
100618: LD_VAR 0 6
100622: PPUSH
100623: LD_INT 1
100625: PPUSH
100626: CALL_OW 48
// end ;
100630: LD_VAR 0 7
100634: RET
// export hInvincible ; every 1 do
100635: GO 100637
100637: DISABLE
// hInvincible := [ ] ;
100638: LD_ADDR_EXP 187
100642: PUSH
100643: EMPTY
100644: ST_TO_ADDR
100645: END
// every 10 do var i ;
100646: GO 100648
100648: DISABLE
100649: LD_INT 0
100651: PPUSH
// begin enable ;
100652: ENABLE
// if not hInvincible then
100653: LD_EXP 187
100657: NOT
100658: IFFALSE 100662
// exit ;
100660: GO 100706
// for i in hInvincible do
100662: LD_ADDR_VAR 0 1
100666: PUSH
100667: LD_EXP 187
100671: PUSH
100672: FOR_IN
100673: IFFALSE 100704
// if GetLives ( i ) < 1000 then
100675: LD_VAR 0 1
100679: PPUSH
100680: CALL_OW 256
100684: PUSH
100685: LD_INT 1000
100687: LESS
100688: IFFALSE 100702
// SetLives ( i , 1000 ) ;
100690: LD_VAR 0 1
100694: PPUSH
100695: LD_INT 1000
100697: PPUSH
100698: CALL_OW 234
100702: GO 100672
100704: POP
100705: POP
// end ;
100706: PPOPN 1
100708: END
// export function hHackInvincible ; var i ; begin
100709: LD_INT 0
100711: PPUSH
100712: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100713: LD_ADDR_VAR 0 2
100717: PUSH
100718: LD_INT 2
100720: PUSH
100721: LD_INT 21
100723: PUSH
100724: LD_INT 1
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 21
100733: PUSH
100734: LD_INT 2
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: EMPTY
100742: LIST
100743: LIST
100744: LIST
100745: PPUSH
100746: CALL_OW 69
100750: PUSH
100751: FOR_IN
100752: IFFALSE 100813
// if IsSelected ( i ) then
100754: LD_VAR 0 2
100758: PPUSH
100759: CALL_OW 306
100763: IFFALSE 100811
// begin if i in hInvincible then
100765: LD_VAR 0 2
100769: PUSH
100770: LD_EXP 187
100774: IN
100775: IFFALSE 100795
// hInvincible := hInvincible diff i else
100777: LD_ADDR_EXP 187
100781: PUSH
100782: LD_EXP 187
100786: PUSH
100787: LD_VAR 0 2
100791: DIFF
100792: ST_TO_ADDR
100793: GO 100811
// hInvincible := hInvincible union i ;
100795: LD_ADDR_EXP 187
100799: PUSH
100800: LD_EXP 187
100804: PUSH
100805: LD_VAR 0 2
100809: UNION
100810: ST_TO_ADDR
// end ;
100811: GO 100751
100813: POP
100814: POP
// end ;
100815: LD_VAR 0 1
100819: RET
// export function hHackInvisible ; var i , j ; begin
100820: LD_INT 0
100822: PPUSH
100823: PPUSH
100824: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100825: LD_ADDR_VAR 0 2
100829: PUSH
100830: LD_INT 21
100832: PUSH
100833: LD_INT 1
100835: PUSH
100836: EMPTY
100837: LIST
100838: LIST
100839: PPUSH
100840: CALL_OW 69
100844: PUSH
100845: FOR_IN
100846: IFFALSE 100870
// if IsSelected ( i ) then
100848: LD_VAR 0 2
100852: PPUSH
100853: CALL_OW 306
100857: IFFALSE 100868
// ComForceInvisible ( i ) ;
100859: LD_VAR 0 2
100863: PPUSH
100864: CALL_OW 496
100868: GO 100845
100870: POP
100871: POP
// end ;
100872: LD_VAR 0 1
100876: RET
// export function hHackChangeYourSide ; begin
100877: LD_INT 0
100879: PPUSH
// if your_side = 8 then
100880: LD_OWVAR 2
100884: PUSH
100885: LD_INT 8
100887: EQUAL
100888: IFFALSE 100900
// your_side := 0 else
100890: LD_ADDR_OWVAR 2
100894: PUSH
100895: LD_INT 0
100897: ST_TO_ADDR
100898: GO 100914
// your_side := your_side + 1 ;
100900: LD_ADDR_OWVAR 2
100904: PUSH
100905: LD_OWVAR 2
100909: PUSH
100910: LD_INT 1
100912: PLUS
100913: ST_TO_ADDR
// end ;
100914: LD_VAR 0 1
100918: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100919: LD_INT 0
100921: PPUSH
100922: PPUSH
100923: PPUSH
// for i in all_units do
100924: LD_ADDR_VAR 0 2
100928: PUSH
100929: LD_OWVAR 3
100933: PUSH
100934: FOR_IN
100935: IFFALSE 101013
// if IsSelected ( i ) then
100937: LD_VAR 0 2
100941: PPUSH
100942: CALL_OW 306
100946: IFFALSE 101011
// begin j := GetSide ( i ) ;
100948: LD_ADDR_VAR 0 3
100952: PUSH
100953: LD_VAR 0 2
100957: PPUSH
100958: CALL_OW 255
100962: ST_TO_ADDR
// if j = 8 then
100963: LD_VAR 0 3
100967: PUSH
100968: LD_INT 8
100970: EQUAL
100971: IFFALSE 100983
// j := 0 else
100973: LD_ADDR_VAR 0 3
100977: PUSH
100978: LD_INT 0
100980: ST_TO_ADDR
100981: GO 100997
// j := j + 1 ;
100983: LD_ADDR_VAR 0 3
100987: PUSH
100988: LD_VAR 0 3
100992: PUSH
100993: LD_INT 1
100995: PLUS
100996: ST_TO_ADDR
// SetSide ( i , j ) ;
100997: LD_VAR 0 2
101001: PPUSH
101002: LD_VAR 0 3
101006: PPUSH
101007: CALL_OW 235
// end ;
101011: GO 100934
101013: POP
101014: POP
// end ;
101015: LD_VAR 0 1
101019: RET
// export function hHackFog ; begin
101020: LD_INT 0
101022: PPUSH
// FogOff ( true ) ;
101023: LD_INT 1
101025: PPUSH
101026: CALL_OW 344
// end ;
101030: LD_VAR 0 1
101034: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101035: LD_INT 0
101037: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101038: LD_VAR 0 1
101042: PPUSH
101043: LD_VAR 0 2
101047: PPUSH
101048: LD_VAR 0 3
101052: PPUSH
101053: LD_INT 1
101055: PPUSH
101056: LD_INT 1
101058: PPUSH
101059: CALL_OW 483
// CenterOnXY ( x , y ) ;
101063: LD_VAR 0 2
101067: PPUSH
101068: LD_VAR 0 3
101072: PPUSH
101073: CALL_OW 84
// end ; end_of_file
101077: LD_VAR 0 4
101081: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101082: LD_INT 0
101084: PPUSH
101085: PPUSH
101086: PPUSH
101087: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101088: LD_VAR 0 1
101092: PPUSH
101093: CALL_OW 264
101097: PUSH
101098: LD_EXP 76
101102: EQUAL
101103: IFFALSE 101175
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101105: LD_INT 68
101107: PPUSH
101108: LD_VAR 0 1
101112: PPUSH
101113: CALL_OW 255
101117: PPUSH
101118: CALL_OW 321
101122: PUSH
101123: LD_INT 2
101125: EQUAL
101126: IFFALSE 101138
// eff := 70 else
101128: LD_ADDR_VAR 0 4
101132: PUSH
101133: LD_INT 70
101135: ST_TO_ADDR
101136: GO 101146
// eff := 30 ;
101138: LD_ADDR_VAR 0 4
101142: PUSH
101143: LD_INT 30
101145: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101146: LD_VAR 0 1
101150: PPUSH
101151: CALL_OW 250
101155: PPUSH
101156: LD_VAR 0 1
101160: PPUSH
101161: CALL_OW 251
101165: PPUSH
101166: LD_VAR 0 4
101170: PPUSH
101171: CALL_OW 495
// end ; end ;
101175: LD_VAR 0 2
101179: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101180: LD_INT 0
101182: PPUSH
// end ;
101183: LD_VAR 0 4
101187: RET
// export function SOS_Command ( cmd ) ; begin
101188: LD_INT 0
101190: PPUSH
// end ;
101191: LD_VAR 0 2
101195: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101196: LD_INT 0
101198: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101199: LD_VAR 0 1
101203: PUSH
101204: LD_INT 250
101206: EQUAL
101207: PUSH
101208: LD_VAR 0 2
101212: PPUSH
101213: CALL_OW 264
101217: PUSH
101218: LD_EXP 79
101222: EQUAL
101223: AND
101224: IFFALSE 101245
// MinerPlaceMine ( unit , x , y ) ;
101226: LD_VAR 0 2
101230: PPUSH
101231: LD_VAR 0 4
101235: PPUSH
101236: LD_VAR 0 5
101240: PPUSH
101241: CALL 103586 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101245: LD_VAR 0 1
101249: PUSH
101250: LD_INT 251
101252: EQUAL
101253: PUSH
101254: LD_VAR 0 2
101258: PPUSH
101259: CALL_OW 264
101263: PUSH
101264: LD_EXP 79
101268: EQUAL
101269: AND
101270: IFFALSE 101291
// MinerDetonateMine ( unit , x , y ) ;
101272: LD_VAR 0 2
101276: PPUSH
101277: LD_VAR 0 4
101281: PPUSH
101282: LD_VAR 0 5
101286: PPUSH
101287: CALL 103863 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101291: LD_VAR 0 1
101295: PUSH
101296: LD_INT 252
101298: EQUAL
101299: PUSH
101300: LD_VAR 0 2
101304: PPUSH
101305: CALL_OW 264
101309: PUSH
101310: LD_EXP 79
101314: EQUAL
101315: AND
101316: IFFALSE 101337
// MinerCreateMinefield ( unit , x , y ) ;
101318: LD_VAR 0 2
101322: PPUSH
101323: LD_VAR 0 4
101327: PPUSH
101328: LD_VAR 0 5
101332: PPUSH
101333: CALL 104280 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101337: LD_VAR 0 1
101341: PUSH
101342: LD_INT 253
101344: EQUAL
101345: PUSH
101346: LD_VAR 0 2
101350: PPUSH
101351: CALL_OW 257
101355: PUSH
101356: LD_INT 5
101358: EQUAL
101359: AND
101360: IFFALSE 101381
// ComBinocular ( unit , x , y ) ;
101362: LD_VAR 0 2
101366: PPUSH
101367: LD_VAR 0 4
101371: PPUSH
101372: LD_VAR 0 5
101376: PPUSH
101377: CALL 104651 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101381: LD_VAR 0 1
101385: PUSH
101386: LD_INT 254
101388: EQUAL
101389: PUSH
101390: LD_VAR 0 2
101394: PPUSH
101395: CALL_OW 264
101399: PUSH
101400: LD_EXP 74
101404: EQUAL
101405: AND
101406: PUSH
101407: LD_VAR 0 3
101411: PPUSH
101412: CALL_OW 263
101416: PUSH
101417: LD_INT 3
101419: EQUAL
101420: AND
101421: IFFALSE 101437
// HackDestroyVehicle ( unit , selectedUnit ) ;
101423: LD_VAR 0 2
101427: PPUSH
101428: LD_VAR 0 3
101432: PPUSH
101433: CALL 102946 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101437: LD_VAR 0 1
101441: PUSH
101442: LD_INT 255
101444: EQUAL
101445: PUSH
101446: LD_VAR 0 2
101450: PPUSH
101451: CALL_OW 264
101455: PUSH
101456: LD_INT 14
101458: PUSH
101459: LD_INT 53
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: IN
101466: AND
101467: PUSH
101468: LD_VAR 0 4
101472: PPUSH
101473: LD_VAR 0 5
101477: PPUSH
101478: CALL_OW 488
101482: AND
101483: IFFALSE 101507
// CutTreeXYR ( unit , x , y , 12 ) ;
101485: LD_VAR 0 2
101489: PPUSH
101490: LD_VAR 0 4
101494: PPUSH
101495: LD_VAR 0 5
101499: PPUSH
101500: LD_INT 12
101502: PPUSH
101503: CALL 101512 0 4
// end ;
101507: LD_VAR 0 6
101511: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101512: LD_INT 0
101514: PPUSH
101515: PPUSH
101516: PPUSH
101517: PPUSH
101518: PPUSH
101519: PPUSH
101520: PPUSH
101521: PPUSH
101522: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101523: LD_VAR 0 1
101527: NOT
101528: PUSH
101529: LD_VAR 0 2
101533: PPUSH
101534: LD_VAR 0 3
101538: PPUSH
101539: CALL_OW 488
101543: NOT
101544: OR
101545: PUSH
101546: LD_VAR 0 4
101550: NOT
101551: OR
101552: IFFALSE 101556
// exit ;
101554: GO 101896
// list := [ ] ;
101556: LD_ADDR_VAR 0 13
101560: PUSH
101561: EMPTY
101562: ST_TO_ADDR
// if x - r < 0 then
101563: LD_VAR 0 2
101567: PUSH
101568: LD_VAR 0 4
101572: MINUS
101573: PUSH
101574: LD_INT 0
101576: LESS
101577: IFFALSE 101589
// min_x := 0 else
101579: LD_ADDR_VAR 0 7
101583: PUSH
101584: LD_INT 0
101586: ST_TO_ADDR
101587: GO 101605
// min_x := x - r ;
101589: LD_ADDR_VAR 0 7
101593: PUSH
101594: LD_VAR 0 2
101598: PUSH
101599: LD_VAR 0 4
101603: MINUS
101604: ST_TO_ADDR
// if y - r < 0 then
101605: LD_VAR 0 3
101609: PUSH
101610: LD_VAR 0 4
101614: MINUS
101615: PUSH
101616: LD_INT 0
101618: LESS
101619: IFFALSE 101631
// min_y := 0 else
101621: LD_ADDR_VAR 0 8
101625: PUSH
101626: LD_INT 0
101628: ST_TO_ADDR
101629: GO 101647
// min_y := y - r ;
101631: LD_ADDR_VAR 0 8
101635: PUSH
101636: LD_VAR 0 3
101640: PUSH
101641: LD_VAR 0 4
101645: MINUS
101646: ST_TO_ADDR
// max_x := x + r ;
101647: LD_ADDR_VAR 0 9
101651: PUSH
101652: LD_VAR 0 2
101656: PUSH
101657: LD_VAR 0 4
101661: PLUS
101662: ST_TO_ADDR
// max_y := y + r ;
101663: LD_ADDR_VAR 0 10
101667: PUSH
101668: LD_VAR 0 3
101672: PUSH
101673: LD_VAR 0 4
101677: PLUS
101678: ST_TO_ADDR
// for _x = min_x to max_x do
101679: LD_ADDR_VAR 0 11
101683: PUSH
101684: DOUBLE
101685: LD_VAR 0 7
101689: DEC
101690: ST_TO_ADDR
101691: LD_VAR 0 9
101695: PUSH
101696: FOR_TO
101697: IFFALSE 101814
// for _y = min_y to max_y do
101699: LD_ADDR_VAR 0 12
101703: PUSH
101704: DOUBLE
101705: LD_VAR 0 8
101709: DEC
101710: ST_TO_ADDR
101711: LD_VAR 0 10
101715: PUSH
101716: FOR_TO
101717: IFFALSE 101810
// begin if not ValidHex ( _x , _y ) then
101719: LD_VAR 0 11
101723: PPUSH
101724: LD_VAR 0 12
101728: PPUSH
101729: CALL_OW 488
101733: NOT
101734: IFFALSE 101738
// continue ;
101736: GO 101716
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101738: LD_VAR 0 11
101742: PPUSH
101743: LD_VAR 0 12
101747: PPUSH
101748: CALL_OW 351
101752: PUSH
101753: LD_VAR 0 11
101757: PPUSH
101758: LD_VAR 0 12
101762: PPUSH
101763: CALL_OW 554
101767: AND
101768: IFFALSE 101808
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101770: LD_ADDR_VAR 0 13
101774: PUSH
101775: LD_VAR 0 13
101779: PPUSH
101780: LD_VAR 0 13
101784: PUSH
101785: LD_INT 1
101787: PLUS
101788: PPUSH
101789: LD_VAR 0 11
101793: PUSH
101794: LD_VAR 0 12
101798: PUSH
101799: EMPTY
101800: LIST
101801: LIST
101802: PPUSH
101803: CALL_OW 2
101807: ST_TO_ADDR
// end ;
101808: GO 101716
101810: POP
101811: POP
101812: GO 101696
101814: POP
101815: POP
// if not list then
101816: LD_VAR 0 13
101820: NOT
101821: IFFALSE 101825
// exit ;
101823: GO 101896
// for i in list do
101825: LD_ADDR_VAR 0 6
101829: PUSH
101830: LD_VAR 0 13
101834: PUSH
101835: FOR_IN
101836: IFFALSE 101894
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101838: LD_VAR 0 1
101842: PPUSH
101843: LD_STRING M
101845: PUSH
101846: LD_VAR 0 6
101850: PUSH
101851: LD_INT 1
101853: ARRAY
101854: PUSH
101855: LD_VAR 0 6
101859: PUSH
101860: LD_INT 2
101862: ARRAY
101863: PUSH
101864: LD_INT 0
101866: PUSH
101867: LD_INT 0
101869: PUSH
101870: LD_INT 0
101872: PUSH
101873: LD_INT 0
101875: PUSH
101876: EMPTY
101877: LIST
101878: LIST
101879: LIST
101880: LIST
101881: LIST
101882: LIST
101883: LIST
101884: PUSH
101885: EMPTY
101886: LIST
101887: PPUSH
101888: CALL_OW 447
101892: GO 101835
101894: POP
101895: POP
// end ;
101896: LD_VAR 0 5
101900: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101901: LD_EXP 188
101905: NOT
101906: IFFALSE 101956
101908: GO 101910
101910: DISABLE
// begin initHack := true ;
101911: LD_ADDR_EXP 188
101915: PUSH
101916: LD_INT 1
101918: ST_TO_ADDR
// hackTanks := [ ] ;
101919: LD_ADDR_EXP 189
101923: PUSH
101924: EMPTY
101925: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101926: LD_ADDR_EXP 190
101930: PUSH
101931: EMPTY
101932: ST_TO_ADDR
// hackLimit := 3 ;
101933: LD_ADDR_EXP 191
101937: PUSH
101938: LD_INT 3
101940: ST_TO_ADDR
// hackDist := 12 ;
101941: LD_ADDR_EXP 192
101945: PUSH
101946: LD_INT 12
101948: ST_TO_ADDR
// hackCounter := [ ] ;
101949: LD_ADDR_EXP 193
101953: PUSH
101954: EMPTY
101955: ST_TO_ADDR
// end ;
101956: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101957: LD_EXP 188
101961: PUSH
101962: LD_INT 34
101964: PUSH
101965: LD_EXP 74
101969: PUSH
101970: EMPTY
101971: LIST
101972: LIST
101973: PPUSH
101974: CALL_OW 69
101978: AND
101979: IFFALSE 102234
101981: GO 101983
101983: DISABLE
101984: LD_INT 0
101986: PPUSH
101987: PPUSH
// begin enable ;
101988: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
101989: LD_ADDR_VAR 0 1
101993: PUSH
101994: LD_INT 34
101996: PUSH
101997: LD_EXP 74
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PPUSH
102006: CALL_OW 69
102010: PUSH
102011: FOR_IN
102012: IFFALSE 102232
// begin if not i in hackTanks then
102014: LD_VAR 0 1
102018: PUSH
102019: LD_EXP 189
102023: IN
102024: NOT
102025: IFFALSE 102108
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102027: LD_ADDR_EXP 189
102031: PUSH
102032: LD_EXP 189
102036: PPUSH
102037: LD_EXP 189
102041: PUSH
102042: LD_INT 1
102044: PLUS
102045: PPUSH
102046: LD_VAR 0 1
102050: PPUSH
102051: CALL_OW 1
102055: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102056: LD_ADDR_EXP 190
102060: PUSH
102061: LD_EXP 190
102065: PPUSH
102066: LD_EXP 190
102070: PUSH
102071: LD_INT 1
102073: PLUS
102074: PPUSH
102075: EMPTY
102076: PPUSH
102077: CALL_OW 1
102081: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102082: LD_ADDR_EXP 193
102086: PUSH
102087: LD_EXP 193
102091: PPUSH
102092: LD_EXP 193
102096: PUSH
102097: LD_INT 1
102099: PLUS
102100: PPUSH
102101: EMPTY
102102: PPUSH
102103: CALL_OW 1
102107: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102108: LD_VAR 0 1
102112: PPUSH
102113: CALL_OW 302
102117: NOT
102118: IFFALSE 102131
// begin HackUnlinkAll ( i ) ;
102120: LD_VAR 0 1
102124: PPUSH
102125: CALL 102237 0 1
// continue ;
102129: GO 102011
// end ; HackCheckCapturedStatus ( i ) ;
102131: LD_VAR 0 1
102135: PPUSH
102136: CALL 102680 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102140: LD_ADDR_VAR 0 2
102144: PUSH
102145: LD_INT 81
102147: PUSH
102148: LD_VAR 0 1
102152: PPUSH
102153: CALL_OW 255
102157: PUSH
102158: EMPTY
102159: LIST
102160: LIST
102161: PUSH
102162: LD_INT 33
102164: PUSH
102165: LD_INT 3
102167: PUSH
102168: EMPTY
102169: LIST
102170: LIST
102171: PUSH
102172: LD_INT 91
102174: PUSH
102175: LD_VAR 0 1
102179: PUSH
102180: LD_EXP 192
102184: PUSH
102185: EMPTY
102186: LIST
102187: LIST
102188: LIST
102189: PUSH
102190: LD_INT 50
102192: PUSH
102193: EMPTY
102194: LIST
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: LIST
102200: LIST
102201: PPUSH
102202: CALL_OW 69
102206: ST_TO_ADDR
// if not tmp then
102207: LD_VAR 0 2
102211: NOT
102212: IFFALSE 102216
// continue ;
102214: GO 102011
// HackLink ( i , tmp ) ;
102216: LD_VAR 0 1
102220: PPUSH
102221: LD_VAR 0 2
102225: PPUSH
102226: CALL 102373 0 2
// end ;
102230: GO 102011
102232: POP
102233: POP
// end ;
102234: PPOPN 2
102236: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102237: LD_INT 0
102239: PPUSH
102240: PPUSH
102241: PPUSH
// if not hack in hackTanks then
102242: LD_VAR 0 1
102246: PUSH
102247: LD_EXP 189
102251: IN
102252: NOT
102253: IFFALSE 102257
// exit ;
102255: GO 102368
// index := GetElementIndex ( hackTanks , hack ) ;
102257: LD_ADDR_VAR 0 4
102261: PUSH
102262: LD_EXP 189
102266: PPUSH
102267: LD_VAR 0 1
102271: PPUSH
102272: CALL 55577 0 2
102276: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102277: LD_EXP 190
102281: PUSH
102282: LD_VAR 0 4
102286: ARRAY
102287: IFFALSE 102368
// begin for i in hackTanksCaptured [ index ] do
102289: LD_ADDR_VAR 0 3
102293: PUSH
102294: LD_EXP 190
102298: PUSH
102299: LD_VAR 0 4
102303: ARRAY
102304: PUSH
102305: FOR_IN
102306: IFFALSE 102332
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102308: LD_VAR 0 3
102312: PUSH
102313: LD_INT 1
102315: ARRAY
102316: PPUSH
102317: LD_VAR 0 3
102321: PUSH
102322: LD_INT 2
102324: ARRAY
102325: PPUSH
102326: CALL_OW 235
102330: GO 102305
102332: POP
102333: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102334: LD_ADDR_EXP 190
102338: PUSH
102339: LD_EXP 190
102343: PPUSH
102344: LD_VAR 0 4
102348: PPUSH
102349: EMPTY
102350: PPUSH
102351: CALL_OW 1
102355: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102356: LD_VAR 0 1
102360: PPUSH
102361: LD_INT 0
102363: PPUSH
102364: CALL_OW 505
// end ; end ;
102368: LD_VAR 0 2
102372: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102373: LD_INT 0
102375: PPUSH
102376: PPUSH
102377: PPUSH
// if not hack in hackTanks or not vehicles then
102378: LD_VAR 0 1
102382: PUSH
102383: LD_EXP 189
102387: IN
102388: NOT
102389: PUSH
102390: LD_VAR 0 2
102394: NOT
102395: OR
102396: IFFALSE 102400
// exit ;
102398: GO 102675
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102400: LD_ADDR_VAR 0 2
102404: PUSH
102405: LD_VAR 0 1
102409: PPUSH
102410: LD_VAR 0 2
102414: PPUSH
102415: LD_INT 1
102417: PPUSH
102418: LD_INT 1
102420: PPUSH
102421: CALL 56227 0 4
102425: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102426: LD_ADDR_VAR 0 5
102430: PUSH
102431: LD_EXP 189
102435: PPUSH
102436: LD_VAR 0 1
102440: PPUSH
102441: CALL 55577 0 2
102445: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102446: LD_EXP 190
102450: PUSH
102451: LD_VAR 0 5
102455: ARRAY
102456: PUSH
102457: LD_EXP 191
102461: LESS
102462: IFFALSE 102651
// begin for i := 1 to vehicles do
102464: LD_ADDR_VAR 0 4
102468: PUSH
102469: DOUBLE
102470: LD_INT 1
102472: DEC
102473: ST_TO_ADDR
102474: LD_VAR 0 2
102478: PUSH
102479: FOR_TO
102480: IFFALSE 102649
// begin if hackTanksCaptured [ index ] = hackLimit then
102482: LD_EXP 190
102486: PUSH
102487: LD_VAR 0 5
102491: ARRAY
102492: PUSH
102493: LD_EXP 191
102497: EQUAL
102498: IFFALSE 102502
// break ;
102500: GO 102649
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102502: LD_ADDR_EXP 193
102506: PUSH
102507: LD_EXP 193
102511: PPUSH
102512: LD_VAR 0 5
102516: PPUSH
102517: LD_EXP 193
102521: PUSH
102522: LD_VAR 0 5
102526: ARRAY
102527: PUSH
102528: LD_INT 1
102530: PLUS
102531: PPUSH
102532: CALL_OW 1
102536: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102537: LD_ADDR_EXP 190
102541: PUSH
102542: LD_EXP 190
102546: PPUSH
102547: LD_VAR 0 5
102551: PUSH
102552: LD_EXP 190
102556: PUSH
102557: LD_VAR 0 5
102561: ARRAY
102562: PUSH
102563: LD_INT 1
102565: PLUS
102566: PUSH
102567: EMPTY
102568: LIST
102569: LIST
102570: PPUSH
102571: LD_VAR 0 2
102575: PUSH
102576: LD_VAR 0 4
102580: ARRAY
102581: PUSH
102582: LD_VAR 0 2
102586: PUSH
102587: LD_VAR 0 4
102591: ARRAY
102592: PPUSH
102593: CALL_OW 255
102597: PUSH
102598: EMPTY
102599: LIST
102600: LIST
102601: PPUSH
102602: CALL 55792 0 3
102606: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102607: LD_VAR 0 2
102611: PUSH
102612: LD_VAR 0 4
102616: ARRAY
102617: PPUSH
102618: LD_VAR 0 1
102622: PPUSH
102623: CALL_OW 255
102627: PPUSH
102628: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102632: LD_VAR 0 2
102636: PUSH
102637: LD_VAR 0 4
102641: ARRAY
102642: PPUSH
102643: CALL_OW 141
// end ;
102647: GO 102479
102649: POP
102650: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102651: LD_VAR 0 1
102655: PPUSH
102656: LD_EXP 190
102660: PUSH
102661: LD_VAR 0 5
102665: ARRAY
102666: PUSH
102667: LD_INT 0
102669: PLUS
102670: PPUSH
102671: CALL_OW 505
// end ;
102675: LD_VAR 0 3
102679: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102680: LD_INT 0
102682: PPUSH
102683: PPUSH
102684: PPUSH
102685: PPUSH
// if not hack in hackTanks then
102686: LD_VAR 0 1
102690: PUSH
102691: LD_EXP 189
102695: IN
102696: NOT
102697: IFFALSE 102701
// exit ;
102699: GO 102941
// index := GetElementIndex ( hackTanks , hack ) ;
102701: LD_ADDR_VAR 0 4
102705: PUSH
102706: LD_EXP 189
102710: PPUSH
102711: LD_VAR 0 1
102715: PPUSH
102716: CALL 55577 0 2
102720: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102721: LD_ADDR_VAR 0 3
102725: PUSH
102726: DOUBLE
102727: LD_EXP 190
102731: PUSH
102732: LD_VAR 0 4
102736: ARRAY
102737: INC
102738: ST_TO_ADDR
102739: LD_INT 1
102741: PUSH
102742: FOR_DOWNTO
102743: IFFALSE 102915
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102745: LD_ADDR_VAR 0 5
102749: PUSH
102750: LD_EXP 190
102754: PUSH
102755: LD_VAR 0 4
102759: ARRAY
102760: PUSH
102761: LD_VAR 0 3
102765: ARRAY
102766: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102767: LD_VAR 0 5
102771: PUSH
102772: LD_INT 1
102774: ARRAY
102775: PPUSH
102776: CALL_OW 302
102780: NOT
102781: PUSH
102782: LD_VAR 0 5
102786: PUSH
102787: LD_INT 1
102789: ARRAY
102790: PPUSH
102791: CALL_OW 255
102795: PUSH
102796: LD_VAR 0 1
102800: PPUSH
102801: CALL_OW 255
102805: NONEQUAL
102806: OR
102807: IFFALSE 102913
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102809: LD_VAR 0 5
102813: PUSH
102814: LD_INT 1
102816: ARRAY
102817: PPUSH
102818: CALL_OW 305
102822: PUSH
102823: LD_VAR 0 5
102827: PUSH
102828: LD_INT 1
102830: ARRAY
102831: PPUSH
102832: CALL_OW 255
102836: PUSH
102837: LD_VAR 0 1
102841: PPUSH
102842: CALL_OW 255
102846: EQUAL
102847: AND
102848: IFFALSE 102872
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102850: LD_VAR 0 5
102854: PUSH
102855: LD_INT 1
102857: ARRAY
102858: PPUSH
102859: LD_VAR 0 5
102863: PUSH
102864: LD_INT 2
102866: ARRAY
102867: PPUSH
102868: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102872: LD_ADDR_EXP 190
102876: PUSH
102877: LD_EXP 190
102881: PPUSH
102882: LD_VAR 0 4
102886: PPUSH
102887: LD_EXP 190
102891: PUSH
102892: LD_VAR 0 4
102896: ARRAY
102897: PPUSH
102898: LD_VAR 0 3
102902: PPUSH
102903: CALL_OW 3
102907: PPUSH
102908: CALL_OW 1
102912: ST_TO_ADDR
// end ; end ;
102913: GO 102742
102915: POP
102916: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102917: LD_VAR 0 1
102921: PPUSH
102922: LD_EXP 190
102926: PUSH
102927: LD_VAR 0 4
102931: ARRAY
102932: PUSH
102933: LD_INT 0
102935: PLUS
102936: PPUSH
102937: CALL_OW 505
// end ;
102941: LD_VAR 0 2
102945: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102946: LD_INT 0
102948: PPUSH
102949: PPUSH
102950: PPUSH
102951: PPUSH
// if not hack in hackTanks then
102952: LD_VAR 0 1
102956: PUSH
102957: LD_EXP 189
102961: IN
102962: NOT
102963: IFFALSE 102967
// exit ;
102965: GO 103052
// index := GetElementIndex ( hackTanks , hack ) ;
102967: LD_ADDR_VAR 0 5
102971: PUSH
102972: LD_EXP 189
102976: PPUSH
102977: LD_VAR 0 1
102981: PPUSH
102982: CALL 55577 0 2
102986: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
102987: LD_ADDR_VAR 0 4
102991: PUSH
102992: DOUBLE
102993: LD_INT 1
102995: DEC
102996: ST_TO_ADDR
102997: LD_EXP 190
103001: PUSH
103002: LD_VAR 0 5
103006: ARRAY
103007: PUSH
103008: FOR_TO
103009: IFFALSE 103050
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103011: LD_EXP 190
103015: PUSH
103016: LD_VAR 0 5
103020: ARRAY
103021: PUSH
103022: LD_VAR 0 4
103026: ARRAY
103027: PUSH
103028: LD_INT 1
103030: ARRAY
103031: PUSH
103032: LD_VAR 0 2
103036: EQUAL
103037: IFFALSE 103048
// KillUnit ( vehicle ) ;
103039: LD_VAR 0 2
103043: PPUSH
103044: CALL_OW 66
103048: GO 103008
103050: POP
103051: POP
// end ;
103052: LD_VAR 0 3
103056: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103057: LD_EXP 194
103061: NOT
103062: IFFALSE 103097
103064: GO 103066
103066: DISABLE
// begin initMiner := true ;
103067: LD_ADDR_EXP 194
103071: PUSH
103072: LD_INT 1
103074: ST_TO_ADDR
// minersList := [ ] ;
103075: LD_ADDR_EXP 195
103079: PUSH
103080: EMPTY
103081: ST_TO_ADDR
// minerMinesList := [ ] ;
103082: LD_ADDR_EXP 196
103086: PUSH
103087: EMPTY
103088: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103089: LD_ADDR_EXP 197
103093: PUSH
103094: LD_INT 5
103096: ST_TO_ADDR
// end ;
103097: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103098: LD_EXP 194
103102: PUSH
103103: LD_INT 34
103105: PUSH
103106: LD_EXP 79
103110: PUSH
103111: EMPTY
103112: LIST
103113: LIST
103114: PPUSH
103115: CALL_OW 69
103119: AND
103120: IFFALSE 103583
103122: GO 103124
103124: DISABLE
103125: LD_INT 0
103127: PPUSH
103128: PPUSH
103129: PPUSH
103130: PPUSH
// begin enable ;
103131: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103132: LD_ADDR_VAR 0 1
103136: PUSH
103137: LD_INT 34
103139: PUSH
103140: LD_EXP 79
103144: PUSH
103145: EMPTY
103146: LIST
103147: LIST
103148: PPUSH
103149: CALL_OW 69
103153: PUSH
103154: FOR_IN
103155: IFFALSE 103227
// begin if not i in minersList then
103157: LD_VAR 0 1
103161: PUSH
103162: LD_EXP 195
103166: IN
103167: NOT
103168: IFFALSE 103225
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103170: LD_ADDR_EXP 195
103174: PUSH
103175: LD_EXP 195
103179: PPUSH
103180: LD_EXP 195
103184: PUSH
103185: LD_INT 1
103187: PLUS
103188: PPUSH
103189: LD_VAR 0 1
103193: PPUSH
103194: CALL_OW 1
103198: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103199: LD_ADDR_EXP 196
103203: PUSH
103204: LD_EXP 196
103208: PPUSH
103209: LD_EXP 196
103213: PUSH
103214: LD_INT 1
103216: PLUS
103217: PPUSH
103218: EMPTY
103219: PPUSH
103220: CALL_OW 1
103224: ST_TO_ADDR
// end end ;
103225: GO 103154
103227: POP
103228: POP
// for i := minerMinesList downto 1 do
103229: LD_ADDR_VAR 0 1
103233: PUSH
103234: DOUBLE
103235: LD_EXP 196
103239: INC
103240: ST_TO_ADDR
103241: LD_INT 1
103243: PUSH
103244: FOR_DOWNTO
103245: IFFALSE 103581
// begin if IsLive ( minersList [ i ] ) then
103247: LD_EXP 195
103251: PUSH
103252: LD_VAR 0 1
103256: ARRAY
103257: PPUSH
103258: CALL_OW 300
103262: IFFALSE 103290
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103264: LD_EXP 195
103268: PUSH
103269: LD_VAR 0 1
103273: ARRAY
103274: PPUSH
103275: LD_EXP 196
103279: PUSH
103280: LD_VAR 0 1
103284: ARRAY
103285: PPUSH
103286: CALL_OW 505
// if not minerMinesList [ i ] then
103290: LD_EXP 196
103294: PUSH
103295: LD_VAR 0 1
103299: ARRAY
103300: NOT
103301: IFFALSE 103305
// continue ;
103303: GO 103244
// for j := minerMinesList [ i ] downto 1 do
103305: LD_ADDR_VAR 0 2
103309: PUSH
103310: DOUBLE
103311: LD_EXP 196
103315: PUSH
103316: LD_VAR 0 1
103320: ARRAY
103321: INC
103322: ST_TO_ADDR
103323: LD_INT 1
103325: PUSH
103326: FOR_DOWNTO
103327: IFFALSE 103577
// begin side := GetSide ( minersList [ i ] ) ;
103329: LD_ADDR_VAR 0 3
103333: PUSH
103334: LD_EXP 195
103338: PUSH
103339: LD_VAR 0 1
103343: ARRAY
103344: PPUSH
103345: CALL_OW 255
103349: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103350: LD_ADDR_VAR 0 4
103354: PUSH
103355: LD_EXP 196
103359: PUSH
103360: LD_VAR 0 1
103364: ARRAY
103365: PUSH
103366: LD_VAR 0 2
103370: ARRAY
103371: PUSH
103372: LD_INT 1
103374: ARRAY
103375: PPUSH
103376: LD_EXP 196
103380: PUSH
103381: LD_VAR 0 1
103385: ARRAY
103386: PUSH
103387: LD_VAR 0 2
103391: ARRAY
103392: PUSH
103393: LD_INT 2
103395: ARRAY
103396: PPUSH
103397: CALL_OW 428
103401: ST_TO_ADDR
// if not tmp then
103402: LD_VAR 0 4
103406: NOT
103407: IFFALSE 103411
// continue ;
103409: GO 103326
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103411: LD_VAR 0 4
103415: PUSH
103416: LD_INT 81
103418: PUSH
103419: LD_VAR 0 3
103423: PUSH
103424: EMPTY
103425: LIST
103426: LIST
103427: PPUSH
103428: CALL_OW 69
103432: IN
103433: PUSH
103434: LD_EXP 196
103438: PUSH
103439: LD_VAR 0 1
103443: ARRAY
103444: PUSH
103445: LD_VAR 0 2
103449: ARRAY
103450: PUSH
103451: LD_INT 1
103453: ARRAY
103454: PPUSH
103455: LD_EXP 196
103459: PUSH
103460: LD_VAR 0 1
103464: ARRAY
103465: PUSH
103466: LD_VAR 0 2
103470: ARRAY
103471: PUSH
103472: LD_INT 2
103474: ARRAY
103475: PPUSH
103476: CALL_OW 458
103480: AND
103481: IFFALSE 103575
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103483: LD_EXP 196
103487: PUSH
103488: LD_VAR 0 1
103492: ARRAY
103493: PUSH
103494: LD_VAR 0 2
103498: ARRAY
103499: PUSH
103500: LD_INT 1
103502: ARRAY
103503: PPUSH
103504: LD_EXP 196
103508: PUSH
103509: LD_VAR 0 1
103513: ARRAY
103514: PUSH
103515: LD_VAR 0 2
103519: ARRAY
103520: PUSH
103521: LD_INT 2
103523: ARRAY
103524: PPUSH
103525: LD_VAR 0 3
103529: PPUSH
103530: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103534: LD_ADDR_EXP 196
103538: PUSH
103539: LD_EXP 196
103543: PPUSH
103544: LD_VAR 0 1
103548: PPUSH
103549: LD_EXP 196
103553: PUSH
103554: LD_VAR 0 1
103558: ARRAY
103559: PPUSH
103560: LD_VAR 0 2
103564: PPUSH
103565: CALL_OW 3
103569: PPUSH
103570: CALL_OW 1
103574: ST_TO_ADDR
// end ; end ;
103575: GO 103326
103577: POP
103578: POP
// end ;
103579: GO 103244
103581: POP
103582: POP
// end ;
103583: PPOPN 4
103585: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103586: LD_INT 0
103588: PPUSH
103589: PPUSH
// result := false ;
103590: LD_ADDR_VAR 0 4
103594: PUSH
103595: LD_INT 0
103597: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103598: LD_VAR 0 1
103602: PPUSH
103603: CALL_OW 264
103607: PUSH
103608: LD_EXP 79
103612: EQUAL
103613: NOT
103614: IFFALSE 103618
// exit ;
103616: GO 103858
// index := GetElementIndex ( minersList , unit ) ;
103618: LD_ADDR_VAR 0 5
103622: PUSH
103623: LD_EXP 195
103627: PPUSH
103628: LD_VAR 0 1
103632: PPUSH
103633: CALL 55577 0 2
103637: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103638: LD_EXP 196
103642: PUSH
103643: LD_VAR 0 5
103647: ARRAY
103648: PUSH
103649: LD_EXP 197
103653: GREATEREQUAL
103654: IFFALSE 103658
// exit ;
103656: GO 103858
// ComMoveXY ( unit , x , y ) ;
103658: LD_VAR 0 1
103662: PPUSH
103663: LD_VAR 0 2
103667: PPUSH
103668: LD_VAR 0 3
103672: PPUSH
103673: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103677: LD_INT 35
103679: PPUSH
103680: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103684: LD_VAR 0 1
103688: PPUSH
103689: LD_VAR 0 2
103693: PPUSH
103694: LD_VAR 0 3
103698: PPUSH
103699: CALL 85641 0 3
103703: NOT
103704: PUSH
103705: LD_VAR 0 1
103709: PPUSH
103710: CALL_OW 314
103714: AND
103715: IFFALSE 103719
// exit ;
103717: GO 103858
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103719: LD_VAR 0 2
103723: PPUSH
103724: LD_VAR 0 3
103728: PPUSH
103729: CALL_OW 428
103733: PUSH
103734: LD_VAR 0 1
103738: EQUAL
103739: PUSH
103740: LD_VAR 0 1
103744: PPUSH
103745: CALL_OW 314
103749: NOT
103750: AND
103751: IFFALSE 103677
// PlaySoundXY ( x , y , PlantMine ) ;
103753: LD_VAR 0 2
103757: PPUSH
103758: LD_VAR 0 3
103762: PPUSH
103763: LD_STRING PlantMine
103765: PPUSH
103766: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103770: LD_VAR 0 2
103774: PPUSH
103775: LD_VAR 0 3
103779: PPUSH
103780: LD_VAR 0 1
103784: PPUSH
103785: CALL_OW 255
103789: PPUSH
103790: LD_INT 0
103792: PPUSH
103793: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103797: LD_ADDR_EXP 196
103801: PUSH
103802: LD_EXP 196
103806: PPUSH
103807: LD_VAR 0 5
103811: PUSH
103812: LD_EXP 196
103816: PUSH
103817: LD_VAR 0 5
103821: ARRAY
103822: PUSH
103823: LD_INT 1
103825: PLUS
103826: PUSH
103827: EMPTY
103828: LIST
103829: LIST
103830: PPUSH
103831: LD_VAR 0 2
103835: PUSH
103836: LD_VAR 0 3
103840: PUSH
103841: EMPTY
103842: LIST
103843: LIST
103844: PPUSH
103845: CALL 55792 0 3
103849: ST_TO_ADDR
// result := true ;
103850: LD_ADDR_VAR 0 4
103854: PUSH
103855: LD_INT 1
103857: ST_TO_ADDR
// end ;
103858: LD_VAR 0 4
103862: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103863: LD_INT 0
103865: PPUSH
103866: PPUSH
103867: PPUSH
// if not unit in minersList then
103868: LD_VAR 0 1
103872: PUSH
103873: LD_EXP 195
103877: IN
103878: NOT
103879: IFFALSE 103883
// exit ;
103881: GO 104275
// index := GetElementIndex ( minersList , unit ) ;
103883: LD_ADDR_VAR 0 6
103887: PUSH
103888: LD_EXP 195
103892: PPUSH
103893: LD_VAR 0 1
103897: PPUSH
103898: CALL 55577 0 2
103902: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103903: LD_ADDR_VAR 0 5
103907: PUSH
103908: DOUBLE
103909: LD_EXP 196
103913: PUSH
103914: LD_VAR 0 6
103918: ARRAY
103919: INC
103920: ST_TO_ADDR
103921: LD_INT 1
103923: PUSH
103924: FOR_DOWNTO
103925: IFFALSE 104086
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103927: LD_EXP 196
103931: PUSH
103932: LD_VAR 0 6
103936: ARRAY
103937: PUSH
103938: LD_VAR 0 5
103942: ARRAY
103943: PUSH
103944: LD_INT 1
103946: ARRAY
103947: PUSH
103948: LD_VAR 0 2
103952: EQUAL
103953: PUSH
103954: LD_EXP 196
103958: PUSH
103959: LD_VAR 0 6
103963: ARRAY
103964: PUSH
103965: LD_VAR 0 5
103969: ARRAY
103970: PUSH
103971: LD_INT 2
103973: ARRAY
103974: PUSH
103975: LD_VAR 0 3
103979: EQUAL
103980: AND
103981: IFFALSE 104084
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103983: LD_EXP 196
103987: PUSH
103988: LD_VAR 0 6
103992: ARRAY
103993: PUSH
103994: LD_VAR 0 5
103998: ARRAY
103999: PUSH
104000: LD_INT 1
104002: ARRAY
104003: PPUSH
104004: LD_EXP 196
104008: PUSH
104009: LD_VAR 0 6
104013: ARRAY
104014: PUSH
104015: LD_VAR 0 5
104019: ARRAY
104020: PUSH
104021: LD_INT 2
104023: ARRAY
104024: PPUSH
104025: LD_VAR 0 1
104029: PPUSH
104030: CALL_OW 255
104034: PPUSH
104035: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104039: LD_ADDR_EXP 196
104043: PUSH
104044: LD_EXP 196
104048: PPUSH
104049: LD_VAR 0 6
104053: PPUSH
104054: LD_EXP 196
104058: PUSH
104059: LD_VAR 0 6
104063: ARRAY
104064: PPUSH
104065: LD_VAR 0 5
104069: PPUSH
104070: CALL_OW 3
104074: PPUSH
104075: CALL_OW 1
104079: ST_TO_ADDR
// exit ;
104080: POP
104081: POP
104082: GO 104275
// end ; end ;
104084: GO 103924
104086: POP
104087: POP
// for i := minerMinesList [ index ] downto 1 do
104088: LD_ADDR_VAR 0 5
104092: PUSH
104093: DOUBLE
104094: LD_EXP 196
104098: PUSH
104099: LD_VAR 0 6
104103: ARRAY
104104: INC
104105: ST_TO_ADDR
104106: LD_INT 1
104108: PUSH
104109: FOR_DOWNTO
104110: IFFALSE 104273
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104112: LD_EXP 196
104116: PUSH
104117: LD_VAR 0 6
104121: ARRAY
104122: PUSH
104123: LD_VAR 0 5
104127: ARRAY
104128: PUSH
104129: LD_INT 1
104131: ARRAY
104132: PPUSH
104133: LD_EXP 196
104137: PUSH
104138: LD_VAR 0 6
104142: ARRAY
104143: PUSH
104144: LD_VAR 0 5
104148: ARRAY
104149: PUSH
104150: LD_INT 2
104152: ARRAY
104153: PPUSH
104154: LD_VAR 0 2
104158: PPUSH
104159: LD_VAR 0 3
104163: PPUSH
104164: CALL_OW 298
104168: PUSH
104169: LD_INT 6
104171: LESS
104172: IFFALSE 104271
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104174: LD_EXP 196
104178: PUSH
104179: LD_VAR 0 6
104183: ARRAY
104184: PUSH
104185: LD_VAR 0 5
104189: ARRAY
104190: PUSH
104191: LD_INT 1
104193: ARRAY
104194: PPUSH
104195: LD_EXP 196
104199: PUSH
104200: LD_VAR 0 6
104204: ARRAY
104205: PUSH
104206: LD_VAR 0 5
104210: ARRAY
104211: PUSH
104212: LD_INT 2
104214: ARRAY
104215: PPUSH
104216: LD_VAR 0 1
104220: PPUSH
104221: CALL_OW 255
104225: PPUSH
104226: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104230: LD_ADDR_EXP 196
104234: PUSH
104235: LD_EXP 196
104239: PPUSH
104240: LD_VAR 0 6
104244: PPUSH
104245: LD_EXP 196
104249: PUSH
104250: LD_VAR 0 6
104254: ARRAY
104255: PPUSH
104256: LD_VAR 0 5
104260: PPUSH
104261: CALL_OW 3
104265: PPUSH
104266: CALL_OW 1
104270: ST_TO_ADDR
// end ; end ;
104271: GO 104109
104273: POP
104274: POP
// end ;
104275: LD_VAR 0 4
104279: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104280: LD_INT 0
104282: PPUSH
104283: PPUSH
104284: PPUSH
104285: PPUSH
104286: PPUSH
104287: PPUSH
104288: PPUSH
104289: PPUSH
104290: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104291: LD_VAR 0 1
104295: PPUSH
104296: CALL_OW 264
104300: PUSH
104301: LD_EXP 79
104305: EQUAL
104306: NOT
104307: PUSH
104308: LD_VAR 0 1
104312: PUSH
104313: LD_EXP 195
104317: IN
104318: NOT
104319: OR
104320: IFFALSE 104324
// exit ;
104322: GO 104646
// index := GetElementIndex ( minersList , unit ) ;
104324: LD_ADDR_VAR 0 6
104328: PUSH
104329: LD_EXP 195
104333: PPUSH
104334: LD_VAR 0 1
104338: PPUSH
104339: CALL 55577 0 2
104343: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104344: LD_ADDR_VAR 0 8
104348: PUSH
104349: LD_EXP 197
104353: PUSH
104354: LD_EXP 196
104358: PUSH
104359: LD_VAR 0 6
104363: ARRAY
104364: MINUS
104365: ST_TO_ADDR
// if not minesFreeAmount then
104366: LD_VAR 0 8
104370: NOT
104371: IFFALSE 104375
// exit ;
104373: GO 104646
// tmp := [ ] ;
104375: LD_ADDR_VAR 0 7
104379: PUSH
104380: EMPTY
104381: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104382: LD_ADDR_VAR 0 5
104386: PUSH
104387: DOUBLE
104388: LD_INT 1
104390: DEC
104391: ST_TO_ADDR
104392: LD_VAR 0 8
104396: PUSH
104397: FOR_TO
104398: IFFALSE 104593
// begin _d := rand ( 0 , 5 ) ;
104400: LD_ADDR_VAR 0 11
104404: PUSH
104405: LD_INT 0
104407: PPUSH
104408: LD_INT 5
104410: PPUSH
104411: CALL_OW 12
104415: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104416: LD_ADDR_VAR 0 12
104420: PUSH
104421: LD_INT 2
104423: PPUSH
104424: LD_INT 6
104426: PPUSH
104427: CALL_OW 12
104431: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104432: LD_ADDR_VAR 0 9
104436: PUSH
104437: LD_VAR 0 2
104441: PPUSH
104442: LD_VAR 0 11
104446: PPUSH
104447: LD_VAR 0 12
104451: PPUSH
104452: CALL_OW 272
104456: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104457: LD_ADDR_VAR 0 10
104461: PUSH
104462: LD_VAR 0 3
104466: PPUSH
104467: LD_VAR 0 11
104471: PPUSH
104472: LD_VAR 0 12
104476: PPUSH
104477: CALL_OW 273
104481: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104482: LD_VAR 0 9
104486: PPUSH
104487: LD_VAR 0 10
104491: PPUSH
104492: CALL_OW 488
104496: PUSH
104497: LD_VAR 0 9
104501: PUSH
104502: LD_VAR 0 10
104506: PUSH
104507: EMPTY
104508: LIST
104509: LIST
104510: PUSH
104511: LD_VAR 0 7
104515: IN
104516: NOT
104517: AND
104518: PUSH
104519: LD_VAR 0 9
104523: PPUSH
104524: LD_VAR 0 10
104528: PPUSH
104529: CALL_OW 458
104533: NOT
104534: AND
104535: IFFALSE 104577
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104537: LD_ADDR_VAR 0 7
104541: PUSH
104542: LD_VAR 0 7
104546: PPUSH
104547: LD_VAR 0 7
104551: PUSH
104552: LD_INT 1
104554: PLUS
104555: PPUSH
104556: LD_VAR 0 9
104560: PUSH
104561: LD_VAR 0 10
104565: PUSH
104566: EMPTY
104567: LIST
104568: LIST
104569: PPUSH
104570: CALL_OW 1
104574: ST_TO_ADDR
104575: GO 104591
// i := i - 1 ;
104577: LD_ADDR_VAR 0 5
104581: PUSH
104582: LD_VAR 0 5
104586: PUSH
104587: LD_INT 1
104589: MINUS
104590: ST_TO_ADDR
// end ;
104591: GO 104397
104593: POP
104594: POP
// for i in tmp do
104595: LD_ADDR_VAR 0 5
104599: PUSH
104600: LD_VAR 0 7
104604: PUSH
104605: FOR_IN
104606: IFFALSE 104644
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104608: LD_VAR 0 1
104612: PPUSH
104613: LD_VAR 0 5
104617: PUSH
104618: LD_INT 1
104620: ARRAY
104621: PPUSH
104622: LD_VAR 0 5
104626: PUSH
104627: LD_INT 2
104629: ARRAY
104630: PPUSH
104631: CALL 103586 0 3
104635: NOT
104636: IFFALSE 104642
// exit ;
104638: POP
104639: POP
104640: GO 104646
104642: GO 104605
104644: POP
104645: POP
// end ;
104646: LD_VAR 0 4
104650: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104651: LD_INT 0
104653: PPUSH
104654: PPUSH
104655: PPUSH
104656: PPUSH
104657: PPUSH
104658: PPUSH
104659: PPUSH
// if not GetClass ( unit ) = class_sniper then
104660: LD_VAR 0 1
104664: PPUSH
104665: CALL_OW 257
104669: PUSH
104670: LD_INT 5
104672: EQUAL
104673: NOT
104674: IFFALSE 104678
// exit ;
104676: GO 105066
// dist := 8 ;
104678: LD_ADDR_VAR 0 5
104682: PUSH
104683: LD_INT 8
104685: ST_TO_ADDR
// viewRange := 12 ;
104686: LD_ADDR_VAR 0 7
104690: PUSH
104691: LD_INT 12
104693: ST_TO_ADDR
// side := GetSide ( unit ) ;
104694: LD_ADDR_VAR 0 6
104698: PUSH
104699: LD_VAR 0 1
104703: PPUSH
104704: CALL_OW 255
104708: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104709: LD_INT 61
104711: PPUSH
104712: LD_VAR 0 6
104716: PPUSH
104717: CALL_OW 321
104721: PUSH
104722: LD_INT 2
104724: EQUAL
104725: IFFALSE 104735
// viewRange := 16 ;
104727: LD_ADDR_VAR 0 7
104731: PUSH
104732: LD_INT 16
104734: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104735: LD_VAR 0 1
104739: PPUSH
104740: LD_VAR 0 2
104744: PPUSH
104745: LD_VAR 0 3
104749: PPUSH
104750: CALL_OW 297
104754: PUSH
104755: LD_VAR 0 5
104759: GREATER
104760: IFFALSE 104839
// begin ComMoveXY ( unit , x , y ) ;
104762: LD_VAR 0 1
104766: PPUSH
104767: LD_VAR 0 2
104771: PPUSH
104772: LD_VAR 0 3
104776: PPUSH
104777: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104781: LD_INT 35
104783: PPUSH
104784: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104788: LD_VAR 0 1
104792: PPUSH
104793: LD_VAR 0 2
104797: PPUSH
104798: LD_VAR 0 3
104802: PPUSH
104803: CALL 85641 0 3
104807: NOT
104808: IFFALSE 104812
// exit ;
104810: GO 105066
// until GetDistUnitXY ( unit , x , y ) < dist ;
104812: LD_VAR 0 1
104816: PPUSH
104817: LD_VAR 0 2
104821: PPUSH
104822: LD_VAR 0 3
104826: PPUSH
104827: CALL_OW 297
104831: PUSH
104832: LD_VAR 0 5
104836: LESS
104837: IFFALSE 104781
// end ; ComTurnXY ( unit , x , y ) ;
104839: LD_VAR 0 1
104843: PPUSH
104844: LD_VAR 0 2
104848: PPUSH
104849: LD_VAR 0 3
104853: PPUSH
104854: CALL_OW 118
// wait ( 5 ) ;
104858: LD_INT 5
104860: PPUSH
104861: CALL_OW 67
// _d := GetDir ( unit ) ;
104865: LD_ADDR_VAR 0 10
104869: PUSH
104870: LD_VAR 0 1
104874: PPUSH
104875: CALL_OW 254
104879: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104880: LD_ADDR_VAR 0 8
104884: PUSH
104885: LD_VAR 0 1
104889: PPUSH
104890: CALL_OW 250
104894: PPUSH
104895: LD_VAR 0 10
104899: PPUSH
104900: LD_VAR 0 5
104904: PPUSH
104905: CALL_OW 272
104909: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104910: LD_ADDR_VAR 0 9
104914: PUSH
104915: LD_VAR 0 1
104919: PPUSH
104920: CALL_OW 251
104924: PPUSH
104925: LD_VAR 0 10
104929: PPUSH
104930: LD_VAR 0 5
104934: PPUSH
104935: CALL_OW 273
104939: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104940: LD_VAR 0 8
104944: PPUSH
104945: LD_VAR 0 9
104949: PPUSH
104950: CALL_OW 488
104954: NOT
104955: IFFALSE 104959
// exit ;
104957: GO 105066
// ComAnimCustom ( unit , 1 ) ;
104959: LD_VAR 0 1
104963: PPUSH
104964: LD_INT 1
104966: PPUSH
104967: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104971: LD_VAR 0 8
104975: PPUSH
104976: LD_VAR 0 9
104980: PPUSH
104981: LD_VAR 0 6
104985: PPUSH
104986: LD_VAR 0 7
104990: PPUSH
104991: CALL_OW 330
// repeat wait ( 1 ) ;
104995: LD_INT 1
104997: PPUSH
104998: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105002: LD_VAR 0 1
105006: PPUSH
105007: CALL_OW 316
105011: PUSH
105012: LD_VAR 0 1
105016: PPUSH
105017: CALL_OW 314
105021: OR
105022: PUSH
105023: LD_VAR 0 1
105027: PPUSH
105028: CALL_OW 302
105032: NOT
105033: OR
105034: PUSH
105035: LD_VAR 0 1
105039: PPUSH
105040: CALL_OW 301
105044: OR
105045: IFFALSE 104995
// RemoveSeeing ( _x , _y , side ) ;
105047: LD_VAR 0 8
105051: PPUSH
105052: LD_VAR 0 9
105056: PPUSH
105057: LD_VAR 0 6
105061: PPUSH
105062: CALL_OW 331
// end ; end_of_file
105066: LD_VAR 0 4
105070: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105071: LD_INT 0
105073: PPUSH
105074: PPUSH
105075: PPUSH
105076: PPUSH
105077: PPUSH
105078: PPUSH
105079: PPUSH
105080: PPUSH
105081: PPUSH
105082: PPUSH
105083: PPUSH
105084: PPUSH
105085: PPUSH
105086: PPUSH
105087: PPUSH
105088: PPUSH
105089: PPUSH
105090: PPUSH
105091: PPUSH
105092: PPUSH
105093: PPUSH
105094: PPUSH
105095: PPUSH
105096: PPUSH
105097: PPUSH
105098: PPUSH
105099: PPUSH
105100: PPUSH
105101: PPUSH
105102: PPUSH
105103: PPUSH
105104: PPUSH
105105: PPUSH
105106: PPUSH
// if not list then
105107: LD_VAR 0 1
105111: NOT
105112: IFFALSE 105116
// exit ;
105114: GO 109775
// base := list [ 1 ] ;
105116: LD_ADDR_VAR 0 3
105120: PUSH
105121: LD_VAR 0 1
105125: PUSH
105126: LD_INT 1
105128: ARRAY
105129: ST_TO_ADDR
// group := list [ 2 ] ;
105130: LD_ADDR_VAR 0 4
105134: PUSH
105135: LD_VAR 0 1
105139: PUSH
105140: LD_INT 2
105142: ARRAY
105143: ST_TO_ADDR
// path := list [ 3 ] ;
105144: LD_ADDR_VAR 0 5
105148: PUSH
105149: LD_VAR 0 1
105153: PUSH
105154: LD_INT 3
105156: ARRAY
105157: ST_TO_ADDR
// flags := list [ 4 ] ;
105158: LD_ADDR_VAR 0 6
105162: PUSH
105163: LD_VAR 0 1
105167: PUSH
105168: LD_INT 4
105170: ARRAY
105171: ST_TO_ADDR
// mined := [ ] ;
105172: LD_ADDR_VAR 0 27
105176: PUSH
105177: EMPTY
105178: ST_TO_ADDR
// bombed := [ ] ;
105179: LD_ADDR_VAR 0 28
105183: PUSH
105184: EMPTY
105185: ST_TO_ADDR
// healers := [ ] ;
105186: LD_ADDR_VAR 0 31
105190: PUSH
105191: EMPTY
105192: ST_TO_ADDR
// to_heal := [ ] ;
105193: LD_ADDR_VAR 0 30
105197: PUSH
105198: EMPTY
105199: ST_TO_ADDR
// repairs := [ ] ;
105200: LD_ADDR_VAR 0 33
105204: PUSH
105205: EMPTY
105206: ST_TO_ADDR
// to_repair := [ ] ;
105207: LD_ADDR_VAR 0 32
105211: PUSH
105212: EMPTY
105213: ST_TO_ADDR
// if not group or not path then
105214: LD_VAR 0 4
105218: NOT
105219: PUSH
105220: LD_VAR 0 5
105224: NOT
105225: OR
105226: IFFALSE 105230
// exit ;
105228: GO 109775
// side := GetSide ( group [ 1 ] ) ;
105230: LD_ADDR_VAR 0 35
105234: PUSH
105235: LD_VAR 0 4
105239: PUSH
105240: LD_INT 1
105242: ARRAY
105243: PPUSH
105244: CALL_OW 255
105248: ST_TO_ADDR
// if flags then
105249: LD_VAR 0 6
105253: IFFALSE 105397
// begin f_ignore_area := flags [ 1 ] ;
105255: LD_ADDR_VAR 0 17
105259: PUSH
105260: LD_VAR 0 6
105264: PUSH
105265: LD_INT 1
105267: ARRAY
105268: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105269: LD_ADDR_VAR 0 18
105273: PUSH
105274: LD_VAR 0 6
105278: PUSH
105279: LD_INT 2
105281: ARRAY
105282: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105283: LD_ADDR_VAR 0 19
105287: PUSH
105288: LD_VAR 0 6
105292: PUSH
105293: LD_INT 3
105295: ARRAY
105296: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105297: LD_ADDR_VAR 0 20
105301: PUSH
105302: LD_VAR 0 6
105306: PUSH
105307: LD_INT 4
105309: ARRAY
105310: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105311: LD_ADDR_VAR 0 21
105315: PUSH
105316: LD_VAR 0 6
105320: PUSH
105321: LD_INT 5
105323: ARRAY
105324: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105325: LD_ADDR_VAR 0 22
105329: PUSH
105330: LD_VAR 0 6
105334: PUSH
105335: LD_INT 6
105337: ARRAY
105338: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105339: LD_ADDR_VAR 0 23
105343: PUSH
105344: LD_VAR 0 6
105348: PUSH
105349: LD_INT 7
105351: ARRAY
105352: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105353: LD_ADDR_VAR 0 24
105357: PUSH
105358: LD_VAR 0 6
105362: PUSH
105363: LD_INT 8
105365: ARRAY
105366: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105367: LD_ADDR_VAR 0 25
105371: PUSH
105372: LD_VAR 0 6
105376: PUSH
105377: LD_INT 9
105379: ARRAY
105380: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105381: LD_ADDR_VAR 0 26
105385: PUSH
105386: LD_VAR 0 6
105390: PUSH
105391: LD_INT 10
105393: ARRAY
105394: ST_TO_ADDR
// end else
105395: GO 105477
// begin f_ignore_area := false ;
105397: LD_ADDR_VAR 0 17
105401: PUSH
105402: LD_INT 0
105404: ST_TO_ADDR
// f_capture := false ;
105405: LD_ADDR_VAR 0 18
105409: PUSH
105410: LD_INT 0
105412: ST_TO_ADDR
// f_ignore_civ := false ;
105413: LD_ADDR_VAR 0 19
105417: PUSH
105418: LD_INT 0
105420: ST_TO_ADDR
// f_murder := false ;
105421: LD_ADDR_VAR 0 20
105425: PUSH
105426: LD_INT 0
105428: ST_TO_ADDR
// f_mines := false ;
105429: LD_ADDR_VAR 0 21
105433: PUSH
105434: LD_INT 0
105436: ST_TO_ADDR
// f_repair := false ;
105437: LD_ADDR_VAR 0 22
105441: PUSH
105442: LD_INT 0
105444: ST_TO_ADDR
// f_heal := false ;
105445: LD_ADDR_VAR 0 23
105449: PUSH
105450: LD_INT 0
105452: ST_TO_ADDR
// f_spacetime := false ;
105453: LD_ADDR_VAR 0 24
105457: PUSH
105458: LD_INT 0
105460: ST_TO_ADDR
// f_attack_depot := false ;
105461: LD_ADDR_VAR 0 25
105465: PUSH
105466: LD_INT 0
105468: ST_TO_ADDR
// f_crawl := false ;
105469: LD_ADDR_VAR 0 26
105473: PUSH
105474: LD_INT 0
105476: ST_TO_ADDR
// end ; if f_heal then
105477: LD_VAR 0 23
105481: IFFALSE 105508
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105483: LD_ADDR_VAR 0 31
105487: PUSH
105488: LD_VAR 0 4
105492: PPUSH
105493: LD_INT 25
105495: PUSH
105496: LD_INT 4
105498: PUSH
105499: EMPTY
105500: LIST
105501: LIST
105502: PPUSH
105503: CALL_OW 72
105507: ST_TO_ADDR
// if f_repair then
105508: LD_VAR 0 22
105512: IFFALSE 105539
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105514: LD_ADDR_VAR 0 33
105518: PUSH
105519: LD_VAR 0 4
105523: PPUSH
105524: LD_INT 25
105526: PUSH
105527: LD_INT 3
105529: PUSH
105530: EMPTY
105531: LIST
105532: LIST
105533: PPUSH
105534: CALL_OW 72
105538: ST_TO_ADDR
// units_path := [ ] ;
105539: LD_ADDR_VAR 0 16
105543: PUSH
105544: EMPTY
105545: ST_TO_ADDR
// for i = 1 to group do
105546: LD_ADDR_VAR 0 7
105550: PUSH
105551: DOUBLE
105552: LD_INT 1
105554: DEC
105555: ST_TO_ADDR
105556: LD_VAR 0 4
105560: PUSH
105561: FOR_TO
105562: IFFALSE 105591
// units_path := Replace ( units_path , i , path ) ;
105564: LD_ADDR_VAR 0 16
105568: PUSH
105569: LD_VAR 0 16
105573: PPUSH
105574: LD_VAR 0 7
105578: PPUSH
105579: LD_VAR 0 5
105583: PPUSH
105584: CALL_OW 1
105588: ST_TO_ADDR
105589: GO 105561
105591: POP
105592: POP
// repeat for i = group downto 1 do
105593: LD_ADDR_VAR 0 7
105597: PUSH
105598: DOUBLE
105599: LD_VAR 0 4
105603: INC
105604: ST_TO_ADDR
105605: LD_INT 1
105607: PUSH
105608: FOR_DOWNTO
105609: IFFALSE 109731
// begin wait ( 5 ) ;
105611: LD_INT 5
105613: PPUSH
105614: CALL_OW 67
// tmp := [ ] ;
105618: LD_ADDR_VAR 0 14
105622: PUSH
105623: EMPTY
105624: ST_TO_ADDR
// attacking := false ;
105625: LD_ADDR_VAR 0 29
105629: PUSH
105630: LD_INT 0
105632: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105633: LD_VAR 0 4
105637: PUSH
105638: LD_VAR 0 7
105642: ARRAY
105643: PPUSH
105644: CALL_OW 301
105648: PUSH
105649: LD_VAR 0 4
105653: PUSH
105654: LD_VAR 0 7
105658: ARRAY
105659: NOT
105660: OR
105661: IFFALSE 105770
// begin if GetType ( group [ i ] ) = unit_human then
105663: LD_VAR 0 4
105667: PUSH
105668: LD_VAR 0 7
105672: ARRAY
105673: PPUSH
105674: CALL_OW 247
105678: PUSH
105679: LD_INT 1
105681: EQUAL
105682: IFFALSE 105728
// begin to_heal := to_heal diff group [ i ] ;
105684: LD_ADDR_VAR 0 30
105688: PUSH
105689: LD_VAR 0 30
105693: PUSH
105694: LD_VAR 0 4
105698: PUSH
105699: LD_VAR 0 7
105703: ARRAY
105704: DIFF
105705: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105706: LD_ADDR_VAR 0 31
105710: PUSH
105711: LD_VAR 0 31
105715: PUSH
105716: LD_VAR 0 4
105720: PUSH
105721: LD_VAR 0 7
105725: ARRAY
105726: DIFF
105727: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105728: LD_ADDR_VAR 0 4
105732: PUSH
105733: LD_VAR 0 4
105737: PPUSH
105738: LD_VAR 0 7
105742: PPUSH
105743: CALL_OW 3
105747: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105748: LD_ADDR_VAR 0 16
105752: PUSH
105753: LD_VAR 0 16
105757: PPUSH
105758: LD_VAR 0 7
105762: PPUSH
105763: CALL_OW 3
105767: ST_TO_ADDR
// continue ;
105768: GO 105608
// end ; if f_repair then
105770: LD_VAR 0 22
105774: IFFALSE 106263
// begin if GetType ( group [ i ] ) = unit_vehicle then
105776: LD_VAR 0 4
105780: PUSH
105781: LD_VAR 0 7
105785: ARRAY
105786: PPUSH
105787: CALL_OW 247
105791: PUSH
105792: LD_INT 2
105794: EQUAL
105795: IFFALSE 105985
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105797: LD_VAR 0 4
105801: PUSH
105802: LD_VAR 0 7
105806: ARRAY
105807: PPUSH
105808: CALL_OW 256
105812: PUSH
105813: LD_INT 700
105815: LESS
105816: PUSH
105817: LD_VAR 0 4
105821: PUSH
105822: LD_VAR 0 7
105826: ARRAY
105827: PUSH
105828: LD_VAR 0 32
105832: IN
105833: NOT
105834: AND
105835: IFFALSE 105859
// to_repair := to_repair union group [ i ] ;
105837: LD_ADDR_VAR 0 32
105841: PUSH
105842: LD_VAR 0 32
105846: PUSH
105847: LD_VAR 0 4
105851: PUSH
105852: LD_VAR 0 7
105856: ARRAY
105857: UNION
105858: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105859: LD_VAR 0 4
105863: PUSH
105864: LD_VAR 0 7
105868: ARRAY
105869: PPUSH
105870: CALL_OW 256
105874: PUSH
105875: LD_INT 1000
105877: EQUAL
105878: PUSH
105879: LD_VAR 0 4
105883: PUSH
105884: LD_VAR 0 7
105888: ARRAY
105889: PUSH
105890: LD_VAR 0 32
105894: IN
105895: AND
105896: IFFALSE 105920
// to_repair := to_repair diff group [ i ] ;
105898: LD_ADDR_VAR 0 32
105902: PUSH
105903: LD_VAR 0 32
105907: PUSH
105908: LD_VAR 0 4
105912: PUSH
105913: LD_VAR 0 7
105917: ARRAY
105918: DIFF
105919: ST_TO_ADDR
// if group [ i ] in to_repair then
105920: LD_VAR 0 4
105924: PUSH
105925: LD_VAR 0 7
105929: ARRAY
105930: PUSH
105931: LD_VAR 0 32
105935: IN
105936: IFFALSE 105983
// begin if not IsInArea ( group [ i ] , f_repair ) then
105938: LD_VAR 0 4
105942: PUSH
105943: LD_VAR 0 7
105947: ARRAY
105948: PPUSH
105949: LD_VAR 0 22
105953: PPUSH
105954: CALL_OW 308
105958: NOT
105959: IFFALSE 105981
// ComMoveToArea ( group [ i ] , f_repair ) ;
105961: LD_VAR 0 4
105965: PUSH
105966: LD_VAR 0 7
105970: ARRAY
105971: PPUSH
105972: LD_VAR 0 22
105976: PPUSH
105977: CALL_OW 113
// continue ;
105981: GO 105608
// end ; end else
105983: GO 106263
// if group [ i ] in repairs then
105985: LD_VAR 0 4
105989: PUSH
105990: LD_VAR 0 7
105994: ARRAY
105995: PUSH
105996: LD_VAR 0 33
106000: IN
106001: IFFALSE 106263
// begin if IsInUnit ( group [ i ] ) then
106003: LD_VAR 0 4
106007: PUSH
106008: LD_VAR 0 7
106012: ARRAY
106013: PPUSH
106014: CALL_OW 310
106018: IFFALSE 106086
// begin z := IsInUnit ( group [ i ] ) ;
106020: LD_ADDR_VAR 0 13
106024: PUSH
106025: LD_VAR 0 4
106029: PUSH
106030: LD_VAR 0 7
106034: ARRAY
106035: PPUSH
106036: CALL_OW 310
106040: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106041: LD_VAR 0 13
106045: PUSH
106046: LD_VAR 0 32
106050: IN
106051: PUSH
106052: LD_VAR 0 13
106056: PPUSH
106057: LD_VAR 0 22
106061: PPUSH
106062: CALL_OW 308
106066: AND
106067: IFFALSE 106084
// ComExitVehicle ( group [ i ] ) ;
106069: LD_VAR 0 4
106073: PUSH
106074: LD_VAR 0 7
106078: ARRAY
106079: PPUSH
106080: CALL_OW 121
// end else
106084: GO 106263
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106086: LD_ADDR_VAR 0 13
106090: PUSH
106091: LD_VAR 0 4
106095: PPUSH
106096: LD_INT 95
106098: PUSH
106099: LD_VAR 0 22
106103: PUSH
106104: EMPTY
106105: LIST
106106: LIST
106107: PUSH
106108: LD_INT 58
106110: PUSH
106111: EMPTY
106112: LIST
106113: PUSH
106114: EMPTY
106115: LIST
106116: LIST
106117: PPUSH
106118: CALL_OW 72
106122: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106123: LD_VAR 0 4
106127: PUSH
106128: LD_VAR 0 7
106132: ARRAY
106133: PPUSH
106134: CALL_OW 314
106138: NOT
106139: IFFALSE 106261
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106141: LD_ADDR_VAR 0 10
106145: PUSH
106146: LD_VAR 0 13
106150: PPUSH
106151: LD_VAR 0 4
106155: PUSH
106156: LD_VAR 0 7
106160: ARRAY
106161: PPUSH
106162: CALL_OW 74
106166: ST_TO_ADDR
// if not x then
106167: LD_VAR 0 10
106171: NOT
106172: IFFALSE 106176
// continue ;
106174: GO 105608
// if GetLives ( x ) < 1000 then
106176: LD_VAR 0 10
106180: PPUSH
106181: CALL_OW 256
106185: PUSH
106186: LD_INT 1000
106188: LESS
106189: IFFALSE 106213
// ComRepairVehicle ( group [ i ] , x ) else
106191: LD_VAR 0 4
106195: PUSH
106196: LD_VAR 0 7
106200: ARRAY
106201: PPUSH
106202: LD_VAR 0 10
106206: PPUSH
106207: CALL_OW 129
106211: GO 106261
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106213: LD_VAR 0 23
106217: PUSH
106218: LD_VAR 0 4
106222: PUSH
106223: LD_VAR 0 7
106227: ARRAY
106228: PPUSH
106229: CALL_OW 256
106233: PUSH
106234: LD_INT 1000
106236: LESS
106237: AND
106238: NOT
106239: IFFALSE 106261
// ComEnterUnit ( group [ i ] , x ) ;
106241: LD_VAR 0 4
106245: PUSH
106246: LD_VAR 0 7
106250: ARRAY
106251: PPUSH
106252: LD_VAR 0 10
106256: PPUSH
106257: CALL_OW 120
// end ; continue ;
106261: GO 105608
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106263: LD_VAR 0 23
106267: PUSH
106268: LD_VAR 0 4
106272: PUSH
106273: LD_VAR 0 7
106277: ARRAY
106278: PPUSH
106279: CALL_OW 247
106283: PUSH
106284: LD_INT 1
106286: EQUAL
106287: AND
106288: IFFALSE 106766
// begin if group [ i ] in healers then
106290: LD_VAR 0 4
106294: PUSH
106295: LD_VAR 0 7
106299: ARRAY
106300: PUSH
106301: LD_VAR 0 31
106305: IN
106306: IFFALSE 106579
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106308: LD_VAR 0 4
106312: PUSH
106313: LD_VAR 0 7
106317: ARRAY
106318: PPUSH
106319: LD_VAR 0 23
106323: PPUSH
106324: CALL_OW 308
106328: NOT
106329: PUSH
106330: LD_VAR 0 4
106334: PUSH
106335: LD_VAR 0 7
106339: ARRAY
106340: PPUSH
106341: CALL_OW 314
106345: NOT
106346: AND
106347: IFFALSE 106371
// ComMoveToArea ( group [ i ] , f_heal ) else
106349: LD_VAR 0 4
106353: PUSH
106354: LD_VAR 0 7
106358: ARRAY
106359: PPUSH
106360: LD_VAR 0 23
106364: PPUSH
106365: CALL_OW 113
106369: GO 106577
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106371: LD_VAR 0 4
106375: PUSH
106376: LD_VAR 0 7
106380: ARRAY
106381: PPUSH
106382: CALL 84164 0 1
106386: PPUSH
106387: CALL_OW 256
106391: PUSH
106392: LD_INT 1000
106394: EQUAL
106395: IFFALSE 106414
// ComStop ( group [ i ] ) else
106397: LD_VAR 0 4
106401: PUSH
106402: LD_VAR 0 7
106406: ARRAY
106407: PPUSH
106408: CALL_OW 141
106412: GO 106577
// if not HasTask ( group [ i ] ) and to_heal then
106414: LD_VAR 0 4
106418: PUSH
106419: LD_VAR 0 7
106423: ARRAY
106424: PPUSH
106425: CALL_OW 314
106429: NOT
106430: PUSH
106431: LD_VAR 0 30
106435: AND
106436: IFFALSE 106577
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106438: LD_ADDR_VAR 0 13
106442: PUSH
106443: LD_VAR 0 30
106447: PPUSH
106448: LD_INT 3
106450: PUSH
106451: LD_INT 54
106453: PUSH
106454: EMPTY
106455: LIST
106456: PUSH
106457: EMPTY
106458: LIST
106459: LIST
106460: PPUSH
106461: CALL_OW 72
106465: PPUSH
106466: LD_VAR 0 4
106470: PUSH
106471: LD_VAR 0 7
106475: ARRAY
106476: PPUSH
106477: CALL_OW 74
106481: ST_TO_ADDR
// if z then
106482: LD_VAR 0 13
106486: IFFALSE 106577
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106488: LD_INT 91
106490: PUSH
106491: LD_VAR 0 13
106495: PUSH
106496: LD_INT 10
106498: PUSH
106499: EMPTY
106500: LIST
106501: LIST
106502: LIST
106503: PUSH
106504: LD_INT 81
106506: PUSH
106507: LD_VAR 0 13
106511: PPUSH
106512: CALL_OW 255
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: PUSH
106521: EMPTY
106522: LIST
106523: LIST
106524: PPUSH
106525: CALL_OW 69
106529: PUSH
106530: LD_INT 0
106532: EQUAL
106533: IFFALSE 106557
// ComHeal ( group [ i ] , z ) else
106535: LD_VAR 0 4
106539: PUSH
106540: LD_VAR 0 7
106544: ARRAY
106545: PPUSH
106546: LD_VAR 0 13
106550: PPUSH
106551: CALL_OW 128
106555: GO 106577
// ComMoveToArea ( group [ i ] , f_heal ) ;
106557: LD_VAR 0 4
106561: PUSH
106562: LD_VAR 0 7
106566: ARRAY
106567: PPUSH
106568: LD_VAR 0 23
106572: PPUSH
106573: CALL_OW 113
// end ; continue ;
106577: GO 105608
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106579: LD_VAR 0 4
106583: PUSH
106584: LD_VAR 0 7
106588: ARRAY
106589: PPUSH
106590: CALL_OW 256
106594: PUSH
106595: LD_INT 700
106597: LESS
106598: PUSH
106599: LD_VAR 0 4
106603: PUSH
106604: LD_VAR 0 7
106608: ARRAY
106609: PUSH
106610: LD_VAR 0 30
106614: IN
106615: NOT
106616: AND
106617: IFFALSE 106641
// to_heal := to_heal union group [ i ] ;
106619: LD_ADDR_VAR 0 30
106623: PUSH
106624: LD_VAR 0 30
106628: PUSH
106629: LD_VAR 0 4
106633: PUSH
106634: LD_VAR 0 7
106638: ARRAY
106639: UNION
106640: ST_TO_ADDR
// if group [ i ] in to_heal then
106641: LD_VAR 0 4
106645: PUSH
106646: LD_VAR 0 7
106650: ARRAY
106651: PUSH
106652: LD_VAR 0 30
106656: IN
106657: IFFALSE 106766
// begin if GetLives ( group [ i ] ) = 1000 then
106659: LD_VAR 0 4
106663: PUSH
106664: LD_VAR 0 7
106668: ARRAY
106669: PPUSH
106670: CALL_OW 256
106674: PUSH
106675: LD_INT 1000
106677: EQUAL
106678: IFFALSE 106704
// to_heal := to_heal diff group [ i ] else
106680: LD_ADDR_VAR 0 30
106684: PUSH
106685: LD_VAR 0 30
106689: PUSH
106690: LD_VAR 0 4
106694: PUSH
106695: LD_VAR 0 7
106699: ARRAY
106700: DIFF
106701: ST_TO_ADDR
106702: GO 106766
// begin if not IsInArea ( group [ i ] , to_heal ) then
106704: LD_VAR 0 4
106708: PUSH
106709: LD_VAR 0 7
106713: ARRAY
106714: PPUSH
106715: LD_VAR 0 30
106719: PPUSH
106720: CALL_OW 308
106724: NOT
106725: IFFALSE 106749
// ComMoveToArea ( group [ i ] , f_heal ) else
106727: LD_VAR 0 4
106731: PUSH
106732: LD_VAR 0 7
106736: ARRAY
106737: PPUSH
106738: LD_VAR 0 23
106742: PPUSH
106743: CALL_OW 113
106747: GO 106764
// ComHold ( group [ i ] ) ;
106749: LD_VAR 0 4
106753: PUSH
106754: LD_VAR 0 7
106758: ARRAY
106759: PPUSH
106760: CALL_OW 140
// continue ;
106764: GO 105608
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106766: LD_VAR 0 4
106770: PUSH
106771: LD_VAR 0 7
106775: ARRAY
106776: PPUSH
106777: LD_INT 10
106779: PPUSH
106780: CALL 82584 0 2
106784: NOT
106785: PUSH
106786: LD_VAR 0 16
106790: PUSH
106791: LD_VAR 0 7
106795: ARRAY
106796: PUSH
106797: EMPTY
106798: EQUAL
106799: NOT
106800: AND
106801: IFFALSE 107067
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106803: LD_VAR 0 4
106807: PUSH
106808: LD_VAR 0 7
106812: ARRAY
106813: PPUSH
106814: CALL_OW 262
106818: PUSH
106819: LD_INT 1
106821: PUSH
106822: LD_INT 2
106824: PUSH
106825: EMPTY
106826: LIST
106827: LIST
106828: IN
106829: IFFALSE 106870
// if GetFuel ( group [ i ] ) < 10 then
106831: LD_VAR 0 4
106835: PUSH
106836: LD_VAR 0 7
106840: ARRAY
106841: PPUSH
106842: CALL_OW 261
106846: PUSH
106847: LD_INT 10
106849: LESS
106850: IFFALSE 106870
// SetFuel ( group [ i ] , 12 ) ;
106852: LD_VAR 0 4
106856: PUSH
106857: LD_VAR 0 7
106861: ARRAY
106862: PPUSH
106863: LD_INT 12
106865: PPUSH
106866: CALL_OW 240
// if units_path [ i ] then
106870: LD_VAR 0 16
106874: PUSH
106875: LD_VAR 0 7
106879: ARRAY
106880: IFFALSE 107065
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106882: LD_VAR 0 4
106886: PUSH
106887: LD_VAR 0 7
106891: ARRAY
106892: PPUSH
106893: LD_VAR 0 16
106897: PUSH
106898: LD_VAR 0 7
106902: ARRAY
106903: PUSH
106904: LD_INT 1
106906: ARRAY
106907: PUSH
106908: LD_INT 1
106910: ARRAY
106911: PPUSH
106912: LD_VAR 0 16
106916: PUSH
106917: LD_VAR 0 7
106921: ARRAY
106922: PUSH
106923: LD_INT 1
106925: ARRAY
106926: PUSH
106927: LD_INT 2
106929: ARRAY
106930: PPUSH
106931: CALL_OW 297
106935: PUSH
106936: LD_INT 6
106938: GREATER
106939: IFFALSE 107014
// begin if not HasTask ( group [ i ] ) then
106941: LD_VAR 0 4
106945: PUSH
106946: LD_VAR 0 7
106950: ARRAY
106951: PPUSH
106952: CALL_OW 314
106956: NOT
106957: IFFALSE 107012
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106959: LD_VAR 0 4
106963: PUSH
106964: LD_VAR 0 7
106968: ARRAY
106969: PPUSH
106970: LD_VAR 0 16
106974: PUSH
106975: LD_VAR 0 7
106979: ARRAY
106980: PUSH
106981: LD_INT 1
106983: ARRAY
106984: PUSH
106985: LD_INT 1
106987: ARRAY
106988: PPUSH
106989: LD_VAR 0 16
106993: PUSH
106994: LD_VAR 0 7
106998: ARRAY
106999: PUSH
107000: LD_INT 1
107002: ARRAY
107003: PUSH
107004: LD_INT 2
107006: ARRAY
107007: PPUSH
107008: CALL_OW 114
// end else
107012: GO 107065
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107014: LD_ADDR_VAR 0 15
107018: PUSH
107019: LD_VAR 0 16
107023: PUSH
107024: LD_VAR 0 7
107028: ARRAY
107029: PPUSH
107030: LD_INT 1
107032: PPUSH
107033: CALL_OW 3
107037: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107038: LD_ADDR_VAR 0 16
107042: PUSH
107043: LD_VAR 0 16
107047: PPUSH
107048: LD_VAR 0 7
107052: PPUSH
107053: LD_VAR 0 15
107057: PPUSH
107058: CALL_OW 1
107062: ST_TO_ADDR
// continue ;
107063: GO 105608
// end ; end ; end else
107065: GO 109729
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107067: LD_ADDR_VAR 0 14
107071: PUSH
107072: LD_INT 81
107074: PUSH
107075: LD_VAR 0 4
107079: PUSH
107080: LD_VAR 0 7
107084: ARRAY
107085: PPUSH
107086: CALL_OW 255
107090: PUSH
107091: EMPTY
107092: LIST
107093: LIST
107094: PPUSH
107095: CALL_OW 69
107099: ST_TO_ADDR
// if not tmp then
107100: LD_VAR 0 14
107104: NOT
107105: IFFALSE 107109
// continue ;
107107: GO 105608
// if f_ignore_area then
107109: LD_VAR 0 17
107113: IFFALSE 107201
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107115: LD_ADDR_VAR 0 15
107119: PUSH
107120: LD_VAR 0 14
107124: PPUSH
107125: LD_INT 3
107127: PUSH
107128: LD_INT 92
107130: PUSH
107131: LD_VAR 0 17
107135: PUSH
107136: LD_INT 1
107138: ARRAY
107139: PUSH
107140: LD_VAR 0 17
107144: PUSH
107145: LD_INT 2
107147: ARRAY
107148: PUSH
107149: LD_VAR 0 17
107153: PUSH
107154: LD_INT 3
107156: ARRAY
107157: PUSH
107158: EMPTY
107159: LIST
107160: LIST
107161: LIST
107162: LIST
107163: PUSH
107164: EMPTY
107165: LIST
107166: LIST
107167: PPUSH
107168: CALL_OW 72
107172: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107173: LD_VAR 0 14
107177: PUSH
107178: LD_VAR 0 15
107182: DIFF
107183: IFFALSE 107201
// tmp := tmp diff tmp2 ;
107185: LD_ADDR_VAR 0 14
107189: PUSH
107190: LD_VAR 0 14
107194: PUSH
107195: LD_VAR 0 15
107199: DIFF
107200: ST_TO_ADDR
// end ; if not f_murder then
107201: LD_VAR 0 20
107205: NOT
107206: IFFALSE 107264
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107208: LD_ADDR_VAR 0 15
107212: PUSH
107213: LD_VAR 0 14
107217: PPUSH
107218: LD_INT 3
107220: PUSH
107221: LD_INT 50
107223: PUSH
107224: EMPTY
107225: LIST
107226: PUSH
107227: EMPTY
107228: LIST
107229: LIST
107230: PPUSH
107231: CALL_OW 72
107235: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107236: LD_VAR 0 14
107240: PUSH
107241: LD_VAR 0 15
107245: DIFF
107246: IFFALSE 107264
// tmp := tmp diff tmp2 ;
107248: LD_ADDR_VAR 0 14
107252: PUSH
107253: LD_VAR 0 14
107257: PUSH
107258: LD_VAR 0 15
107262: DIFF
107263: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107264: LD_ADDR_VAR 0 14
107268: PUSH
107269: LD_VAR 0 4
107273: PUSH
107274: LD_VAR 0 7
107278: ARRAY
107279: PPUSH
107280: LD_VAR 0 14
107284: PPUSH
107285: LD_INT 1
107287: PPUSH
107288: LD_INT 1
107290: PPUSH
107291: CALL 56227 0 4
107295: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107296: LD_VAR 0 4
107300: PUSH
107301: LD_VAR 0 7
107305: ARRAY
107306: PPUSH
107307: CALL_OW 257
107311: PUSH
107312: LD_INT 1
107314: EQUAL
107315: IFFALSE 107763
// begin if WantPlant ( group [ i ] ) then
107317: LD_VAR 0 4
107321: PUSH
107322: LD_VAR 0 7
107326: ARRAY
107327: PPUSH
107328: CALL 55728 0 1
107332: IFFALSE 107336
// continue ;
107334: GO 105608
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107336: LD_VAR 0 18
107340: PUSH
107341: LD_VAR 0 4
107345: PUSH
107346: LD_VAR 0 7
107350: ARRAY
107351: PPUSH
107352: CALL_OW 310
107356: NOT
107357: AND
107358: PUSH
107359: LD_VAR 0 14
107363: PUSH
107364: LD_INT 1
107366: ARRAY
107367: PUSH
107368: LD_VAR 0 14
107372: PPUSH
107373: LD_INT 21
107375: PUSH
107376: LD_INT 2
107378: PUSH
107379: EMPTY
107380: LIST
107381: LIST
107382: PUSH
107383: LD_INT 58
107385: PUSH
107386: EMPTY
107387: LIST
107388: PUSH
107389: EMPTY
107390: LIST
107391: LIST
107392: PPUSH
107393: CALL_OW 72
107397: IN
107398: AND
107399: IFFALSE 107435
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107401: LD_VAR 0 4
107405: PUSH
107406: LD_VAR 0 7
107410: ARRAY
107411: PPUSH
107412: LD_VAR 0 14
107416: PUSH
107417: LD_INT 1
107419: ARRAY
107420: PPUSH
107421: CALL_OW 120
// attacking := true ;
107425: LD_ADDR_VAR 0 29
107429: PUSH
107430: LD_INT 1
107432: ST_TO_ADDR
// continue ;
107433: GO 105608
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107435: LD_VAR 0 26
107439: PUSH
107440: LD_VAR 0 4
107444: PUSH
107445: LD_VAR 0 7
107449: ARRAY
107450: PPUSH
107451: CALL_OW 257
107455: PUSH
107456: LD_INT 1
107458: EQUAL
107459: AND
107460: PUSH
107461: LD_VAR 0 4
107465: PUSH
107466: LD_VAR 0 7
107470: ARRAY
107471: PPUSH
107472: CALL_OW 256
107476: PUSH
107477: LD_INT 800
107479: LESS
107480: AND
107481: PUSH
107482: LD_VAR 0 4
107486: PUSH
107487: LD_VAR 0 7
107491: ARRAY
107492: PPUSH
107493: CALL_OW 318
107497: NOT
107498: AND
107499: IFFALSE 107516
// ComCrawl ( group [ i ] ) ;
107501: LD_VAR 0 4
107505: PUSH
107506: LD_VAR 0 7
107510: ARRAY
107511: PPUSH
107512: CALL_OW 137
// if f_mines then
107516: LD_VAR 0 21
107520: IFFALSE 107763
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107522: LD_VAR 0 14
107526: PUSH
107527: LD_INT 1
107529: ARRAY
107530: PPUSH
107531: CALL_OW 247
107535: PUSH
107536: LD_INT 3
107538: EQUAL
107539: PUSH
107540: LD_VAR 0 14
107544: PUSH
107545: LD_INT 1
107547: ARRAY
107548: PUSH
107549: LD_VAR 0 27
107553: IN
107554: NOT
107555: AND
107556: IFFALSE 107763
// begin x := GetX ( tmp [ 1 ] ) ;
107558: LD_ADDR_VAR 0 10
107562: PUSH
107563: LD_VAR 0 14
107567: PUSH
107568: LD_INT 1
107570: ARRAY
107571: PPUSH
107572: CALL_OW 250
107576: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107577: LD_ADDR_VAR 0 11
107581: PUSH
107582: LD_VAR 0 14
107586: PUSH
107587: LD_INT 1
107589: ARRAY
107590: PPUSH
107591: CALL_OW 251
107595: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107596: LD_ADDR_VAR 0 12
107600: PUSH
107601: LD_VAR 0 4
107605: PUSH
107606: LD_VAR 0 7
107610: ARRAY
107611: PPUSH
107612: CALL 82669 0 1
107616: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107617: LD_VAR 0 4
107621: PUSH
107622: LD_VAR 0 7
107626: ARRAY
107627: PPUSH
107628: LD_VAR 0 10
107632: PPUSH
107633: LD_VAR 0 11
107637: PPUSH
107638: LD_VAR 0 14
107642: PUSH
107643: LD_INT 1
107645: ARRAY
107646: PPUSH
107647: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107651: LD_VAR 0 4
107655: PUSH
107656: LD_VAR 0 7
107660: ARRAY
107661: PPUSH
107662: LD_VAR 0 10
107666: PPUSH
107667: LD_VAR 0 12
107671: PPUSH
107672: LD_INT 7
107674: PPUSH
107675: CALL_OW 272
107679: PPUSH
107680: LD_VAR 0 11
107684: PPUSH
107685: LD_VAR 0 12
107689: PPUSH
107690: LD_INT 7
107692: PPUSH
107693: CALL_OW 273
107697: PPUSH
107698: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107702: LD_VAR 0 4
107706: PUSH
107707: LD_VAR 0 7
107711: ARRAY
107712: PPUSH
107713: LD_INT 71
107715: PPUSH
107716: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107720: LD_ADDR_VAR 0 27
107724: PUSH
107725: LD_VAR 0 27
107729: PPUSH
107730: LD_VAR 0 27
107734: PUSH
107735: LD_INT 1
107737: PLUS
107738: PPUSH
107739: LD_VAR 0 14
107743: PUSH
107744: LD_INT 1
107746: ARRAY
107747: PPUSH
107748: CALL_OW 1
107752: ST_TO_ADDR
// attacking := true ;
107753: LD_ADDR_VAR 0 29
107757: PUSH
107758: LD_INT 1
107760: ST_TO_ADDR
// continue ;
107761: GO 105608
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107763: LD_VAR 0 4
107767: PUSH
107768: LD_VAR 0 7
107772: ARRAY
107773: PPUSH
107774: CALL_OW 257
107778: PUSH
107779: LD_INT 17
107781: EQUAL
107782: PUSH
107783: LD_VAR 0 4
107787: PUSH
107788: LD_VAR 0 7
107792: ARRAY
107793: PPUSH
107794: CALL_OW 110
107798: PUSH
107799: LD_INT 71
107801: EQUAL
107802: NOT
107803: AND
107804: IFFALSE 107950
// begin attacking := false ;
107806: LD_ADDR_VAR 0 29
107810: PUSH
107811: LD_INT 0
107813: ST_TO_ADDR
// k := 5 ;
107814: LD_ADDR_VAR 0 9
107818: PUSH
107819: LD_INT 5
107821: ST_TO_ADDR
// if tmp < k then
107822: LD_VAR 0 14
107826: PUSH
107827: LD_VAR 0 9
107831: LESS
107832: IFFALSE 107844
// k := tmp ;
107834: LD_ADDR_VAR 0 9
107838: PUSH
107839: LD_VAR 0 14
107843: ST_TO_ADDR
// for j = 1 to k do
107844: LD_ADDR_VAR 0 8
107848: PUSH
107849: DOUBLE
107850: LD_INT 1
107852: DEC
107853: ST_TO_ADDR
107854: LD_VAR 0 9
107858: PUSH
107859: FOR_TO
107860: IFFALSE 107948
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107862: LD_VAR 0 14
107866: PUSH
107867: LD_VAR 0 8
107871: ARRAY
107872: PUSH
107873: LD_VAR 0 14
107877: PPUSH
107878: LD_INT 58
107880: PUSH
107881: EMPTY
107882: LIST
107883: PPUSH
107884: CALL_OW 72
107888: IN
107889: NOT
107890: IFFALSE 107946
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107892: LD_VAR 0 4
107896: PUSH
107897: LD_VAR 0 7
107901: ARRAY
107902: PPUSH
107903: LD_VAR 0 14
107907: PUSH
107908: LD_VAR 0 8
107912: ARRAY
107913: PPUSH
107914: CALL_OW 115
// attacking := true ;
107918: LD_ADDR_VAR 0 29
107922: PUSH
107923: LD_INT 1
107925: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107926: LD_VAR 0 4
107930: PUSH
107931: LD_VAR 0 7
107935: ARRAY
107936: PPUSH
107937: LD_INT 71
107939: PPUSH
107940: CALL_OW 109
// continue ;
107944: GO 107859
// end ; end ;
107946: GO 107859
107948: POP
107949: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107950: LD_VAR 0 4
107954: PUSH
107955: LD_VAR 0 7
107959: ARRAY
107960: PPUSH
107961: CALL_OW 257
107965: PUSH
107966: LD_INT 8
107968: EQUAL
107969: PUSH
107970: LD_VAR 0 4
107974: PUSH
107975: LD_VAR 0 7
107979: ARRAY
107980: PPUSH
107981: CALL_OW 264
107985: PUSH
107986: LD_INT 28
107988: PUSH
107989: LD_INT 45
107991: PUSH
107992: LD_INT 7
107994: PUSH
107995: LD_INT 47
107997: PUSH
107998: EMPTY
107999: LIST
108000: LIST
108001: LIST
108002: LIST
108003: IN
108004: OR
108005: IFFALSE 108261
// begin attacking := false ;
108007: LD_ADDR_VAR 0 29
108011: PUSH
108012: LD_INT 0
108014: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108015: LD_VAR 0 14
108019: PUSH
108020: LD_INT 1
108022: ARRAY
108023: PPUSH
108024: CALL_OW 266
108028: PUSH
108029: LD_INT 32
108031: PUSH
108032: LD_INT 31
108034: PUSH
108035: LD_INT 33
108037: PUSH
108038: LD_INT 4
108040: PUSH
108041: LD_INT 5
108043: PUSH
108044: EMPTY
108045: LIST
108046: LIST
108047: LIST
108048: LIST
108049: LIST
108050: IN
108051: IFFALSE 108237
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108053: LD_ADDR_VAR 0 9
108057: PUSH
108058: LD_VAR 0 14
108062: PUSH
108063: LD_INT 1
108065: ARRAY
108066: PPUSH
108067: CALL_OW 266
108071: PPUSH
108072: LD_VAR 0 14
108076: PUSH
108077: LD_INT 1
108079: ARRAY
108080: PPUSH
108081: CALL_OW 250
108085: PPUSH
108086: LD_VAR 0 14
108090: PUSH
108091: LD_INT 1
108093: ARRAY
108094: PPUSH
108095: CALL_OW 251
108099: PPUSH
108100: LD_VAR 0 14
108104: PUSH
108105: LD_INT 1
108107: ARRAY
108108: PPUSH
108109: CALL_OW 254
108113: PPUSH
108114: LD_VAR 0 14
108118: PUSH
108119: LD_INT 1
108121: ARRAY
108122: PPUSH
108123: CALL_OW 248
108127: PPUSH
108128: LD_INT 0
108130: PPUSH
108131: CALL 64039 0 6
108135: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108136: LD_ADDR_VAR 0 8
108140: PUSH
108141: LD_VAR 0 4
108145: PUSH
108146: LD_VAR 0 7
108150: ARRAY
108151: PPUSH
108152: LD_VAR 0 9
108156: PPUSH
108157: CALL 82709 0 2
108161: ST_TO_ADDR
// if j then
108162: LD_VAR 0 8
108166: IFFALSE 108235
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108168: LD_VAR 0 8
108172: PUSH
108173: LD_INT 1
108175: ARRAY
108176: PPUSH
108177: LD_VAR 0 8
108181: PUSH
108182: LD_INT 2
108184: ARRAY
108185: PPUSH
108186: CALL_OW 488
108190: IFFALSE 108235
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108192: LD_VAR 0 4
108196: PUSH
108197: LD_VAR 0 7
108201: ARRAY
108202: PPUSH
108203: LD_VAR 0 8
108207: PUSH
108208: LD_INT 1
108210: ARRAY
108211: PPUSH
108212: LD_VAR 0 8
108216: PUSH
108217: LD_INT 2
108219: ARRAY
108220: PPUSH
108221: CALL_OW 116
// attacking := true ;
108225: LD_ADDR_VAR 0 29
108229: PUSH
108230: LD_INT 1
108232: ST_TO_ADDR
// continue ;
108233: GO 105608
// end ; end else
108235: GO 108261
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108237: LD_VAR 0 4
108241: PUSH
108242: LD_VAR 0 7
108246: ARRAY
108247: PPUSH
108248: LD_VAR 0 14
108252: PUSH
108253: LD_INT 1
108255: ARRAY
108256: PPUSH
108257: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108261: LD_VAR 0 4
108265: PUSH
108266: LD_VAR 0 7
108270: ARRAY
108271: PPUSH
108272: CALL_OW 265
108276: PUSH
108277: LD_INT 11
108279: EQUAL
108280: IFFALSE 108558
// begin k := 10 ;
108282: LD_ADDR_VAR 0 9
108286: PUSH
108287: LD_INT 10
108289: ST_TO_ADDR
// x := 0 ;
108290: LD_ADDR_VAR 0 10
108294: PUSH
108295: LD_INT 0
108297: ST_TO_ADDR
// if tmp < k then
108298: LD_VAR 0 14
108302: PUSH
108303: LD_VAR 0 9
108307: LESS
108308: IFFALSE 108320
// k := tmp ;
108310: LD_ADDR_VAR 0 9
108314: PUSH
108315: LD_VAR 0 14
108319: ST_TO_ADDR
// for j = k downto 1 do
108320: LD_ADDR_VAR 0 8
108324: PUSH
108325: DOUBLE
108326: LD_VAR 0 9
108330: INC
108331: ST_TO_ADDR
108332: LD_INT 1
108334: PUSH
108335: FOR_DOWNTO
108336: IFFALSE 108411
// begin if GetType ( tmp [ j ] ) = unit_human then
108338: LD_VAR 0 14
108342: PUSH
108343: LD_VAR 0 8
108347: ARRAY
108348: PPUSH
108349: CALL_OW 247
108353: PUSH
108354: LD_INT 1
108356: EQUAL
108357: IFFALSE 108409
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108359: LD_VAR 0 4
108363: PUSH
108364: LD_VAR 0 7
108368: ARRAY
108369: PPUSH
108370: LD_VAR 0 14
108374: PUSH
108375: LD_VAR 0 8
108379: ARRAY
108380: PPUSH
108381: CALL 82980 0 2
// x := tmp [ j ] ;
108385: LD_ADDR_VAR 0 10
108389: PUSH
108390: LD_VAR 0 14
108394: PUSH
108395: LD_VAR 0 8
108399: ARRAY
108400: ST_TO_ADDR
// attacking := true ;
108401: LD_ADDR_VAR 0 29
108405: PUSH
108406: LD_INT 1
108408: ST_TO_ADDR
// end ; end ;
108409: GO 108335
108411: POP
108412: POP
// if not x then
108413: LD_VAR 0 10
108417: NOT
108418: IFFALSE 108558
// begin attacking := true ;
108420: LD_ADDR_VAR 0 29
108424: PUSH
108425: LD_INT 1
108427: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108428: LD_VAR 0 4
108432: PUSH
108433: LD_VAR 0 7
108437: ARRAY
108438: PPUSH
108439: CALL_OW 250
108443: PPUSH
108444: LD_VAR 0 4
108448: PUSH
108449: LD_VAR 0 7
108453: ARRAY
108454: PPUSH
108455: CALL_OW 251
108459: PPUSH
108460: CALL_OW 546
108464: PUSH
108465: LD_INT 2
108467: ARRAY
108468: PUSH
108469: LD_VAR 0 14
108473: PUSH
108474: LD_INT 1
108476: ARRAY
108477: PPUSH
108478: CALL_OW 250
108482: PPUSH
108483: LD_VAR 0 14
108487: PUSH
108488: LD_INT 1
108490: ARRAY
108491: PPUSH
108492: CALL_OW 251
108496: PPUSH
108497: CALL_OW 546
108501: PUSH
108502: LD_INT 2
108504: ARRAY
108505: EQUAL
108506: IFFALSE 108534
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108508: LD_VAR 0 4
108512: PUSH
108513: LD_VAR 0 7
108517: ARRAY
108518: PPUSH
108519: LD_VAR 0 14
108523: PUSH
108524: LD_INT 1
108526: ARRAY
108527: PPUSH
108528: CALL 82980 0 2
108532: GO 108558
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108534: LD_VAR 0 4
108538: PUSH
108539: LD_VAR 0 7
108543: ARRAY
108544: PPUSH
108545: LD_VAR 0 14
108549: PUSH
108550: LD_INT 1
108552: ARRAY
108553: PPUSH
108554: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108558: LD_VAR 0 4
108562: PUSH
108563: LD_VAR 0 7
108567: ARRAY
108568: PPUSH
108569: CALL_OW 264
108573: PUSH
108574: LD_INT 29
108576: EQUAL
108577: IFFALSE 108943
// begin if WantsToAttack ( group [ i ] ) in bombed then
108579: LD_VAR 0 4
108583: PUSH
108584: LD_VAR 0 7
108588: ARRAY
108589: PPUSH
108590: CALL_OW 319
108594: PUSH
108595: LD_VAR 0 28
108599: IN
108600: IFFALSE 108604
// continue ;
108602: GO 105608
// k := 8 ;
108604: LD_ADDR_VAR 0 9
108608: PUSH
108609: LD_INT 8
108611: ST_TO_ADDR
// x := 0 ;
108612: LD_ADDR_VAR 0 10
108616: PUSH
108617: LD_INT 0
108619: ST_TO_ADDR
// if tmp < k then
108620: LD_VAR 0 14
108624: PUSH
108625: LD_VAR 0 9
108629: LESS
108630: IFFALSE 108642
// k := tmp ;
108632: LD_ADDR_VAR 0 9
108636: PUSH
108637: LD_VAR 0 14
108641: ST_TO_ADDR
// for j = 1 to k do
108642: LD_ADDR_VAR 0 8
108646: PUSH
108647: DOUBLE
108648: LD_INT 1
108650: DEC
108651: ST_TO_ADDR
108652: LD_VAR 0 9
108656: PUSH
108657: FOR_TO
108658: IFFALSE 108790
// begin if GetType ( tmp [ j ] ) = unit_building then
108660: LD_VAR 0 14
108664: PUSH
108665: LD_VAR 0 8
108669: ARRAY
108670: PPUSH
108671: CALL_OW 247
108675: PUSH
108676: LD_INT 3
108678: EQUAL
108679: IFFALSE 108788
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108681: LD_VAR 0 14
108685: PUSH
108686: LD_VAR 0 8
108690: ARRAY
108691: PUSH
108692: LD_VAR 0 28
108696: IN
108697: NOT
108698: PUSH
108699: LD_VAR 0 14
108703: PUSH
108704: LD_VAR 0 8
108708: ARRAY
108709: PPUSH
108710: CALL_OW 313
108714: AND
108715: IFFALSE 108788
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108717: LD_VAR 0 4
108721: PUSH
108722: LD_VAR 0 7
108726: ARRAY
108727: PPUSH
108728: LD_VAR 0 14
108732: PUSH
108733: LD_VAR 0 8
108737: ARRAY
108738: PPUSH
108739: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108743: LD_ADDR_VAR 0 28
108747: PUSH
108748: LD_VAR 0 28
108752: PPUSH
108753: LD_VAR 0 28
108757: PUSH
108758: LD_INT 1
108760: PLUS
108761: PPUSH
108762: LD_VAR 0 14
108766: PUSH
108767: LD_VAR 0 8
108771: ARRAY
108772: PPUSH
108773: CALL_OW 1
108777: ST_TO_ADDR
// attacking := true ;
108778: LD_ADDR_VAR 0 29
108782: PUSH
108783: LD_INT 1
108785: ST_TO_ADDR
// break ;
108786: GO 108790
// end ; end ;
108788: GO 108657
108790: POP
108791: POP
// if not attacking and f_attack_depot then
108792: LD_VAR 0 29
108796: NOT
108797: PUSH
108798: LD_VAR 0 25
108802: AND
108803: IFFALSE 108898
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108805: LD_ADDR_VAR 0 13
108809: PUSH
108810: LD_VAR 0 14
108814: PPUSH
108815: LD_INT 2
108817: PUSH
108818: LD_INT 30
108820: PUSH
108821: LD_INT 0
108823: PUSH
108824: EMPTY
108825: LIST
108826: LIST
108827: PUSH
108828: LD_INT 30
108830: PUSH
108831: LD_INT 1
108833: PUSH
108834: EMPTY
108835: LIST
108836: LIST
108837: PUSH
108838: EMPTY
108839: LIST
108840: LIST
108841: LIST
108842: PPUSH
108843: CALL_OW 72
108847: ST_TO_ADDR
// if z then
108848: LD_VAR 0 13
108852: IFFALSE 108898
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108854: LD_VAR 0 4
108858: PUSH
108859: LD_VAR 0 7
108863: ARRAY
108864: PPUSH
108865: LD_VAR 0 13
108869: PPUSH
108870: LD_VAR 0 4
108874: PUSH
108875: LD_VAR 0 7
108879: ARRAY
108880: PPUSH
108881: CALL_OW 74
108885: PPUSH
108886: CALL_OW 115
// attacking := true ;
108890: LD_ADDR_VAR 0 29
108894: PUSH
108895: LD_INT 1
108897: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108898: LD_VAR 0 4
108902: PUSH
108903: LD_VAR 0 7
108907: ARRAY
108908: PPUSH
108909: CALL_OW 256
108913: PUSH
108914: LD_INT 500
108916: LESS
108917: IFFALSE 108943
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108919: LD_VAR 0 4
108923: PUSH
108924: LD_VAR 0 7
108928: ARRAY
108929: PPUSH
108930: LD_VAR 0 14
108934: PUSH
108935: LD_INT 1
108937: ARRAY
108938: PPUSH
108939: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108943: LD_VAR 0 4
108947: PUSH
108948: LD_VAR 0 7
108952: ARRAY
108953: PPUSH
108954: CALL_OW 264
108958: PUSH
108959: LD_INT 49
108961: EQUAL
108962: IFFALSE 109083
// begin if not HasTask ( group [ i ] ) then
108964: LD_VAR 0 4
108968: PUSH
108969: LD_VAR 0 7
108973: ARRAY
108974: PPUSH
108975: CALL_OW 314
108979: NOT
108980: IFFALSE 109083
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
108982: LD_ADDR_VAR 0 9
108986: PUSH
108987: LD_INT 81
108989: PUSH
108990: LD_VAR 0 4
108994: PUSH
108995: LD_VAR 0 7
108999: ARRAY
109000: PPUSH
109001: CALL_OW 255
109005: PUSH
109006: EMPTY
109007: LIST
109008: LIST
109009: PPUSH
109010: CALL_OW 69
109014: PPUSH
109015: LD_VAR 0 4
109019: PUSH
109020: LD_VAR 0 7
109024: ARRAY
109025: PPUSH
109026: CALL_OW 74
109030: ST_TO_ADDR
// if k then
109031: LD_VAR 0 9
109035: IFFALSE 109083
// if GetDistUnits ( group [ i ] , k ) > 10 then
109037: LD_VAR 0 4
109041: PUSH
109042: LD_VAR 0 7
109046: ARRAY
109047: PPUSH
109048: LD_VAR 0 9
109052: PPUSH
109053: CALL_OW 296
109057: PUSH
109058: LD_INT 10
109060: GREATER
109061: IFFALSE 109083
// ComMoveUnit ( group [ i ] , k ) ;
109063: LD_VAR 0 4
109067: PUSH
109068: LD_VAR 0 7
109072: ARRAY
109073: PPUSH
109074: LD_VAR 0 9
109078: PPUSH
109079: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109083: LD_VAR 0 4
109087: PUSH
109088: LD_VAR 0 7
109092: ARRAY
109093: PPUSH
109094: CALL_OW 256
109098: PUSH
109099: LD_INT 250
109101: LESS
109102: PUSH
109103: LD_VAR 0 4
109107: PUSH
109108: LD_VAR 0 7
109112: ARRAY
109113: PUSH
109114: LD_INT 21
109116: PUSH
109117: LD_INT 2
109119: PUSH
109120: EMPTY
109121: LIST
109122: LIST
109123: PUSH
109124: LD_INT 23
109126: PUSH
109127: LD_INT 2
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: PUSH
109134: EMPTY
109135: LIST
109136: LIST
109137: PPUSH
109138: CALL_OW 69
109142: IN
109143: AND
109144: IFFALSE 109269
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109146: LD_ADDR_VAR 0 9
109150: PUSH
109151: LD_OWVAR 3
109155: PUSH
109156: LD_VAR 0 4
109160: PUSH
109161: LD_VAR 0 7
109165: ARRAY
109166: DIFF
109167: PPUSH
109168: LD_VAR 0 4
109172: PUSH
109173: LD_VAR 0 7
109177: ARRAY
109178: PPUSH
109179: CALL_OW 74
109183: ST_TO_ADDR
// if not k then
109184: LD_VAR 0 9
109188: NOT
109189: IFFALSE 109193
// continue ;
109191: GO 105608
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109193: LD_VAR 0 9
109197: PUSH
109198: LD_INT 81
109200: PUSH
109201: LD_VAR 0 4
109205: PUSH
109206: LD_VAR 0 7
109210: ARRAY
109211: PPUSH
109212: CALL_OW 255
109216: PUSH
109217: EMPTY
109218: LIST
109219: LIST
109220: PPUSH
109221: CALL_OW 69
109225: IN
109226: PUSH
109227: LD_VAR 0 9
109231: PPUSH
109232: LD_VAR 0 4
109236: PUSH
109237: LD_VAR 0 7
109241: ARRAY
109242: PPUSH
109243: CALL_OW 296
109247: PUSH
109248: LD_INT 5
109250: LESS
109251: AND
109252: IFFALSE 109269
// ComAutodestruct ( group [ i ] ) ;
109254: LD_VAR 0 4
109258: PUSH
109259: LD_VAR 0 7
109263: ARRAY
109264: PPUSH
109265: CALL 82878 0 1
// end ; if f_attack_depot then
109269: LD_VAR 0 25
109273: IFFALSE 109385
// begin k := 6 ;
109275: LD_ADDR_VAR 0 9
109279: PUSH
109280: LD_INT 6
109282: ST_TO_ADDR
// if tmp < k then
109283: LD_VAR 0 14
109287: PUSH
109288: LD_VAR 0 9
109292: LESS
109293: IFFALSE 109305
// k := tmp ;
109295: LD_ADDR_VAR 0 9
109299: PUSH
109300: LD_VAR 0 14
109304: ST_TO_ADDR
// for j = 1 to k do
109305: LD_ADDR_VAR 0 8
109309: PUSH
109310: DOUBLE
109311: LD_INT 1
109313: DEC
109314: ST_TO_ADDR
109315: LD_VAR 0 9
109319: PUSH
109320: FOR_TO
109321: IFFALSE 109383
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109323: LD_VAR 0 8
109327: PPUSH
109328: CALL_OW 266
109332: PUSH
109333: LD_INT 0
109335: PUSH
109336: LD_INT 1
109338: PUSH
109339: EMPTY
109340: LIST
109341: LIST
109342: IN
109343: IFFALSE 109381
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109345: LD_VAR 0 4
109349: PUSH
109350: LD_VAR 0 7
109354: ARRAY
109355: PPUSH
109356: LD_VAR 0 14
109360: PUSH
109361: LD_VAR 0 8
109365: ARRAY
109366: PPUSH
109367: CALL_OW 115
// attacking := true ;
109371: LD_ADDR_VAR 0 29
109375: PUSH
109376: LD_INT 1
109378: ST_TO_ADDR
// break ;
109379: GO 109383
// end ;
109381: GO 109320
109383: POP
109384: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109385: LD_VAR 0 4
109389: PUSH
109390: LD_VAR 0 7
109394: ARRAY
109395: PPUSH
109396: CALL_OW 302
109400: PUSH
109401: LD_VAR 0 29
109405: NOT
109406: AND
109407: IFFALSE 109729
// begin if GetTag ( group [ i ] ) = 71 then
109409: LD_VAR 0 4
109413: PUSH
109414: LD_VAR 0 7
109418: ARRAY
109419: PPUSH
109420: CALL_OW 110
109424: PUSH
109425: LD_INT 71
109427: EQUAL
109428: IFFALSE 109469
// begin if HasTask ( group [ i ] ) then
109430: LD_VAR 0 4
109434: PUSH
109435: LD_VAR 0 7
109439: ARRAY
109440: PPUSH
109441: CALL_OW 314
109445: IFFALSE 109451
// continue else
109447: GO 105608
109449: GO 109469
// SetTag ( group [ i ] , 0 ) ;
109451: LD_VAR 0 4
109455: PUSH
109456: LD_VAR 0 7
109460: ARRAY
109461: PPUSH
109462: LD_INT 0
109464: PPUSH
109465: CALL_OW 109
// end ; k := 8 ;
109469: LD_ADDR_VAR 0 9
109473: PUSH
109474: LD_INT 8
109476: ST_TO_ADDR
// x := 0 ;
109477: LD_ADDR_VAR 0 10
109481: PUSH
109482: LD_INT 0
109484: ST_TO_ADDR
// if tmp < k then
109485: LD_VAR 0 14
109489: PUSH
109490: LD_VAR 0 9
109494: LESS
109495: IFFALSE 109507
// k := tmp ;
109497: LD_ADDR_VAR 0 9
109501: PUSH
109502: LD_VAR 0 14
109506: ST_TO_ADDR
// for j = 1 to k do
109507: LD_ADDR_VAR 0 8
109511: PUSH
109512: DOUBLE
109513: LD_INT 1
109515: DEC
109516: ST_TO_ADDR
109517: LD_VAR 0 9
109521: PUSH
109522: FOR_TO
109523: IFFALSE 109621
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109525: LD_VAR 0 14
109529: PUSH
109530: LD_VAR 0 8
109534: ARRAY
109535: PPUSH
109536: CALL_OW 247
109540: PUSH
109541: LD_INT 1
109543: EQUAL
109544: PUSH
109545: LD_VAR 0 14
109549: PUSH
109550: LD_VAR 0 8
109554: ARRAY
109555: PPUSH
109556: CALL_OW 256
109560: PUSH
109561: LD_INT 250
109563: LESS
109564: PUSH
109565: LD_VAR 0 20
109569: AND
109570: PUSH
109571: LD_VAR 0 20
109575: NOT
109576: PUSH
109577: LD_VAR 0 14
109581: PUSH
109582: LD_VAR 0 8
109586: ARRAY
109587: PPUSH
109588: CALL_OW 256
109592: PUSH
109593: LD_INT 250
109595: GREATEREQUAL
109596: AND
109597: OR
109598: AND
109599: IFFALSE 109619
// begin x := tmp [ j ] ;
109601: LD_ADDR_VAR 0 10
109605: PUSH
109606: LD_VAR 0 14
109610: PUSH
109611: LD_VAR 0 8
109615: ARRAY
109616: ST_TO_ADDR
// break ;
109617: GO 109621
// end ;
109619: GO 109522
109621: POP
109622: POP
// if x then
109623: LD_VAR 0 10
109627: IFFALSE 109651
// ComAttackUnit ( group [ i ] , x ) else
109629: LD_VAR 0 4
109633: PUSH
109634: LD_VAR 0 7
109638: ARRAY
109639: PPUSH
109640: LD_VAR 0 10
109644: PPUSH
109645: CALL_OW 115
109649: GO 109675
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109651: LD_VAR 0 4
109655: PUSH
109656: LD_VAR 0 7
109660: ARRAY
109661: PPUSH
109662: LD_VAR 0 14
109666: PUSH
109667: LD_INT 1
109669: ARRAY
109670: PPUSH
109671: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109675: LD_VAR 0 4
109679: PUSH
109680: LD_VAR 0 7
109684: ARRAY
109685: PPUSH
109686: CALL_OW 314
109690: NOT
109691: IFFALSE 109729
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109693: LD_VAR 0 4
109697: PUSH
109698: LD_VAR 0 7
109702: ARRAY
109703: PPUSH
109704: LD_VAR 0 14
109708: PPUSH
109709: LD_VAR 0 4
109713: PUSH
109714: LD_VAR 0 7
109718: ARRAY
109719: PPUSH
109720: CALL_OW 74
109724: PPUSH
109725: CALL_OW 115
// end ; end ; end ;
109729: GO 105608
109731: POP
109732: POP
// wait ( 0 0$2 ) ;
109733: LD_INT 70
109735: PPUSH
109736: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109740: LD_VAR 0 4
109744: NOT
109745: PUSH
109746: LD_VAR 0 4
109750: PUSH
109751: EMPTY
109752: EQUAL
109753: OR
109754: PUSH
109755: LD_INT 81
109757: PUSH
109758: LD_VAR 0 35
109762: PUSH
109763: EMPTY
109764: LIST
109765: LIST
109766: PPUSH
109767: CALL_OW 69
109771: NOT
109772: OR
109773: IFFALSE 105593
// end ;
109775: LD_VAR 0 2
109779: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
109780: LD_INT 0
109782: PPUSH
109783: PPUSH
109784: PPUSH
109785: PPUSH
109786: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
109787: LD_VAR 0 1
109791: NOT
109792: PUSH
109793: LD_EXP 90
109797: PUSH
109798: LD_VAR 0 1
109802: ARRAY
109803: NOT
109804: OR
109805: PUSH
109806: LD_VAR 0 2
109810: NOT
109811: OR
109812: PUSH
109813: LD_VAR 0 3
109817: NOT
109818: OR
109819: IFFALSE 109823
// exit ;
109821: GO 110336
// side := mc_sides [ base ] ;
109823: LD_ADDR_VAR 0 6
109827: PUSH
109828: LD_EXP 116
109832: PUSH
109833: LD_VAR 0 1
109837: ARRAY
109838: ST_TO_ADDR
// if not side then
109839: LD_VAR 0 6
109843: NOT
109844: IFFALSE 109848
// exit ;
109846: GO 110336
// for i in solds do
109848: LD_ADDR_VAR 0 7
109852: PUSH
109853: LD_VAR 0 2
109857: PUSH
109858: FOR_IN
109859: IFFALSE 109920
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109861: LD_VAR 0 7
109865: PPUSH
109866: CALL_OW 310
109870: PPUSH
109871: CALL_OW 266
109875: PUSH
109876: LD_INT 32
109878: PUSH
109879: LD_INT 31
109881: PUSH
109882: EMPTY
109883: LIST
109884: LIST
109885: IN
109886: IFFALSE 109906
// solds := solds diff i else
109888: LD_ADDR_VAR 0 2
109892: PUSH
109893: LD_VAR 0 2
109897: PUSH
109898: LD_VAR 0 7
109902: DIFF
109903: ST_TO_ADDR
109904: GO 109918
// SetTag ( i , 18 ) ;
109906: LD_VAR 0 7
109910: PPUSH
109911: LD_INT 18
109913: PPUSH
109914: CALL_OW 109
109918: GO 109858
109920: POP
109921: POP
// if not solds then
109922: LD_VAR 0 2
109926: NOT
109927: IFFALSE 109931
// exit ;
109929: GO 110336
// repeat wait ( 0 0$1 ) ;
109931: LD_INT 35
109933: PPUSH
109934: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
109938: LD_ADDR_VAR 0 5
109942: PUSH
109943: LD_VAR 0 6
109947: PPUSH
109948: LD_VAR 0 3
109952: PPUSH
109953: CALL 52593 0 2
109957: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109958: LD_EXP 90
109962: PUSH
109963: LD_VAR 0 1
109967: ARRAY
109968: NOT
109969: PUSH
109970: LD_EXP 90
109974: PUSH
109975: LD_VAR 0 1
109979: ARRAY
109980: PUSH
109981: EMPTY
109982: EQUAL
109983: OR
109984: IFFALSE 110021
// begin for i in solds do
109986: LD_ADDR_VAR 0 7
109990: PUSH
109991: LD_VAR 0 2
109995: PUSH
109996: FOR_IN
109997: IFFALSE 110010
// ComStop ( i ) ;
109999: LD_VAR 0 7
110003: PPUSH
110004: CALL_OW 141
110008: GO 109996
110010: POP
110011: POP
// solds := [ ] ;
110012: LD_ADDR_VAR 0 2
110016: PUSH
110017: EMPTY
110018: ST_TO_ADDR
// exit ;
110019: GO 110336
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
110021: LD_VAR 0 5
110025: NOT
110026: PUSH
110027: LD_VAR 0 5
110031: PUSH
110032: LD_INT 3
110034: GREATER
110035: OR
110036: PUSH
110037: LD_EXP 112
110041: PUSH
110042: LD_VAR 0 1
110046: ARRAY
110047: OR
110048: IFFALSE 110089
// begin for i in solds do
110050: LD_ADDR_VAR 0 7
110054: PUSH
110055: LD_VAR 0 2
110059: PUSH
110060: FOR_IN
110061: IFFALSE 110085
// if HasTask ( i ) then
110063: LD_VAR 0 7
110067: PPUSH
110068: CALL_OW 314
110072: IFFALSE 110083
// ComStop ( i ) ;
110074: LD_VAR 0 7
110078: PPUSH
110079: CALL_OW 141
110083: GO 110060
110085: POP
110086: POP
// break ;
110087: GO 110324
// end ; for i in solds do
110089: LD_ADDR_VAR 0 7
110093: PUSH
110094: LD_VAR 0 2
110098: PUSH
110099: FOR_IN
110100: IFFALSE 110316
// begin if IsInUnit ( i ) then
110102: LD_VAR 0 7
110106: PPUSH
110107: CALL_OW 310
110111: IFFALSE 110122
// ComExitBuilding ( i ) ;
110113: LD_VAR 0 7
110117: PPUSH
110118: CALL_OW 122
// if GetLives ( i ) > 333 then
110122: LD_VAR 0 7
110126: PPUSH
110127: CALL_OW 256
110131: PUSH
110132: LD_INT 333
110134: GREATER
110135: IFFALSE 110163
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110137: LD_VAR 0 7
110141: PPUSH
110142: LD_VAR 0 5
110146: PPUSH
110147: LD_VAR 0 7
110151: PPUSH
110152: CALL_OW 74
110156: PPUSH
110157: CALL_OW 115
110161: GO 110314
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110163: LD_ADDR_VAR 0 8
110167: PUSH
110168: LD_EXP 90
110172: PUSH
110173: LD_VAR 0 1
110177: ARRAY
110178: PPUSH
110179: LD_INT 2
110181: PUSH
110182: LD_INT 30
110184: PUSH
110185: LD_INT 0
110187: PUSH
110188: EMPTY
110189: LIST
110190: LIST
110191: PUSH
110192: LD_INT 30
110194: PUSH
110195: LD_INT 1
110197: PUSH
110198: EMPTY
110199: LIST
110200: LIST
110201: PUSH
110202: LD_INT 30
110204: PUSH
110205: LD_INT 6
110207: PUSH
110208: EMPTY
110209: LIST
110210: LIST
110211: PUSH
110212: EMPTY
110213: LIST
110214: LIST
110215: LIST
110216: LIST
110217: PPUSH
110218: CALL_OW 72
110222: PPUSH
110223: LD_VAR 0 7
110227: PPUSH
110228: CALL_OW 74
110232: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110233: LD_VAR 0 7
110237: PPUSH
110238: LD_VAR 0 8
110242: PPUSH
110243: CALL_OW 250
110247: PPUSH
110248: LD_INT 3
110250: PPUSH
110251: LD_INT 5
110253: PPUSH
110254: CALL_OW 272
110258: PPUSH
110259: LD_VAR 0 8
110263: PPUSH
110264: CALL_OW 251
110268: PPUSH
110269: LD_INT 3
110271: PPUSH
110272: LD_INT 5
110274: PPUSH
110275: CALL_OW 273
110279: PPUSH
110280: CALL_OW 111
// SetTag ( i , 0 ) ;
110284: LD_VAR 0 7
110288: PPUSH
110289: LD_INT 0
110291: PPUSH
110292: CALL_OW 109
// solds := solds diff i ;
110296: LD_ADDR_VAR 0 2
110300: PUSH
110301: LD_VAR 0 2
110305: PUSH
110306: LD_VAR 0 7
110310: DIFF
110311: ST_TO_ADDR
// continue ;
110312: GO 110099
// end ; end ;
110314: GO 110099
110316: POP
110317: POP
// until solds ;
110318: LD_VAR 0 2
110322: IFFALSE 109931
// MC_Reset ( base , 18 ) ;
110324: LD_VAR 0 1
110328: PPUSH
110329: LD_INT 18
110331: PPUSH
110332: CALL 24856 0 2
// end ;
110336: LD_VAR 0 4
110340: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
110341: LD_INT 0
110343: PPUSH
110344: PPUSH
110345: PPUSH
110346: PPUSH
110347: PPUSH
110348: PPUSH
110349: PPUSH
110350: PPUSH
110351: PPUSH
110352: PPUSH
110353: PPUSH
110354: PPUSH
110355: PPUSH
110356: PPUSH
110357: PPUSH
110358: PPUSH
110359: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110360: LD_ADDR_VAR 0 13
110364: PUSH
110365: LD_EXP 90
110369: PUSH
110370: LD_VAR 0 1
110374: ARRAY
110375: PPUSH
110376: LD_INT 25
110378: PUSH
110379: LD_INT 3
110381: PUSH
110382: EMPTY
110383: LIST
110384: LIST
110385: PPUSH
110386: CALL_OW 72
110390: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110391: LD_EXP 130
110395: PUSH
110396: LD_VAR 0 1
110400: ARRAY
110401: IFFALSE 110425
// mechs := mechs diff mc_remote_driver [ base ] ;
110403: LD_ADDR_VAR 0 13
110407: PUSH
110408: LD_VAR 0 13
110412: PUSH
110413: LD_EXP 130
110417: PUSH
110418: LD_VAR 0 1
110422: ARRAY
110423: DIFF
110424: ST_TO_ADDR
// for i in mechs do
110425: LD_ADDR_VAR 0 5
110429: PUSH
110430: LD_VAR 0 13
110434: PUSH
110435: FOR_IN
110436: IFFALSE 110471
// if GetTag ( i ) > 0 then
110438: LD_VAR 0 5
110442: PPUSH
110443: CALL_OW 110
110447: PUSH
110448: LD_INT 0
110450: GREATER
110451: IFFALSE 110469
// mechs := mechs diff i ;
110453: LD_ADDR_VAR 0 13
110457: PUSH
110458: LD_VAR 0 13
110462: PUSH
110463: LD_VAR 0 5
110467: DIFF
110468: ST_TO_ADDR
110469: GO 110435
110471: POP
110472: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110473: LD_ADDR_VAR 0 9
110477: PUSH
110478: LD_EXP 90
110482: PUSH
110483: LD_VAR 0 1
110487: ARRAY
110488: PPUSH
110489: LD_INT 2
110491: PUSH
110492: LD_INT 25
110494: PUSH
110495: LD_INT 1
110497: PUSH
110498: EMPTY
110499: LIST
110500: LIST
110501: PUSH
110502: LD_INT 25
110504: PUSH
110505: LD_INT 5
110507: PUSH
110508: EMPTY
110509: LIST
110510: LIST
110511: PUSH
110512: LD_INT 25
110514: PUSH
110515: LD_INT 8
110517: PUSH
110518: EMPTY
110519: LIST
110520: LIST
110521: PUSH
110522: LD_INT 25
110524: PUSH
110525: LD_INT 9
110527: PUSH
110528: EMPTY
110529: LIST
110530: LIST
110531: PUSH
110532: EMPTY
110533: LIST
110534: LIST
110535: LIST
110536: LIST
110537: LIST
110538: PPUSH
110539: CALL_OW 72
110543: ST_TO_ADDR
// if not defenders and not solds then
110544: LD_VAR 0 2
110548: NOT
110549: PUSH
110550: LD_VAR 0 9
110554: NOT
110555: AND
110556: IFFALSE 110560
// exit ;
110558: GO 112186
// depot_under_attack := false ;
110560: LD_ADDR_VAR 0 17
110564: PUSH
110565: LD_INT 0
110567: ST_TO_ADDR
// sold_defenders := [ ] ;
110568: LD_ADDR_VAR 0 18
110572: PUSH
110573: EMPTY
110574: ST_TO_ADDR
// if mechs then
110575: LD_VAR 0 13
110579: IFFALSE 110708
// for i in defenders do
110581: LD_ADDR_VAR 0 5
110585: PUSH
110586: LD_VAR 0 2
110590: PUSH
110591: FOR_IN
110592: IFFALSE 110706
// begin SetTag ( i , 20 ) ;
110594: LD_VAR 0 5
110598: PPUSH
110599: LD_INT 20
110601: PPUSH
110602: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
110606: LD_VAR 0 5
110610: PPUSH
110611: CALL_OW 263
110615: PUSH
110616: LD_INT 1
110618: EQUAL
110619: PUSH
110620: LD_VAR 0 5
110624: PPUSH
110625: CALL_OW 311
110629: NOT
110630: AND
110631: PUSH
110632: LD_VAR 0 13
110636: AND
110637: IFFALSE 110704
// begin un := mechs [ 1 ] ;
110639: LD_ADDR_VAR 0 11
110643: PUSH
110644: LD_VAR 0 13
110648: PUSH
110649: LD_INT 1
110651: ARRAY
110652: ST_TO_ADDR
// ComExitBuilding ( un ) ;
110653: LD_VAR 0 11
110657: PPUSH
110658: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
110662: LD_VAR 0 11
110666: PPUSH
110667: LD_VAR 0 5
110671: PPUSH
110672: CALL_OW 180
// SetTag ( un , 19 ) ;
110676: LD_VAR 0 11
110680: PPUSH
110681: LD_INT 19
110683: PPUSH
110684: CALL_OW 109
// mechs := mechs diff un ;
110688: LD_ADDR_VAR 0 13
110692: PUSH
110693: LD_VAR 0 13
110697: PUSH
110698: LD_VAR 0 11
110702: DIFF
110703: ST_TO_ADDR
// end ; end ;
110704: GO 110591
110706: POP
110707: POP
// if solds then
110708: LD_VAR 0 9
110712: IFFALSE 110771
// for i in solds do
110714: LD_ADDR_VAR 0 5
110718: PUSH
110719: LD_VAR 0 9
110723: PUSH
110724: FOR_IN
110725: IFFALSE 110769
// if not GetTag ( i ) then
110727: LD_VAR 0 5
110731: PPUSH
110732: CALL_OW 110
110736: NOT
110737: IFFALSE 110767
// begin defenders := defenders union i ;
110739: LD_ADDR_VAR 0 2
110743: PUSH
110744: LD_VAR 0 2
110748: PUSH
110749: LD_VAR 0 5
110753: UNION
110754: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110755: LD_VAR 0 5
110759: PPUSH
110760: LD_INT 18
110762: PPUSH
110763: CALL_OW 109
// end ;
110767: GO 110724
110769: POP
110770: POP
// repeat wait ( 0 0$1 ) ;
110771: LD_INT 35
110773: PPUSH
110774: CALL_OW 67
// enemy := mc_scan [ base ] ;
110778: LD_ADDR_VAR 0 3
110782: PUSH
110783: LD_EXP 113
110787: PUSH
110788: LD_VAR 0 1
110792: ARRAY
110793: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110794: LD_EXP 90
110798: PUSH
110799: LD_VAR 0 1
110803: ARRAY
110804: NOT
110805: PUSH
110806: LD_EXP 90
110810: PUSH
110811: LD_VAR 0 1
110815: ARRAY
110816: PUSH
110817: EMPTY
110818: EQUAL
110819: OR
110820: IFFALSE 110857
// begin for i in defenders do
110822: LD_ADDR_VAR 0 5
110826: PUSH
110827: LD_VAR 0 2
110831: PUSH
110832: FOR_IN
110833: IFFALSE 110846
// ComStop ( i ) ;
110835: LD_VAR 0 5
110839: PPUSH
110840: CALL_OW 141
110844: GO 110832
110846: POP
110847: POP
// defenders := [ ] ;
110848: LD_ADDR_VAR 0 2
110852: PUSH
110853: EMPTY
110854: ST_TO_ADDR
// exit ;
110855: GO 112186
// end ; for i in defenders do
110857: LD_ADDR_VAR 0 5
110861: PUSH
110862: LD_VAR 0 2
110866: PUSH
110867: FOR_IN
110868: IFFALSE 111686
// begin e := NearestUnitToUnit ( enemy , i ) ;
110870: LD_ADDR_VAR 0 14
110874: PUSH
110875: LD_VAR 0 3
110879: PPUSH
110880: LD_VAR 0 5
110884: PPUSH
110885: CALL_OW 74
110889: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110890: LD_ADDR_VAR 0 8
110894: PUSH
110895: LD_EXP 90
110899: PUSH
110900: LD_VAR 0 1
110904: ARRAY
110905: PPUSH
110906: LD_INT 2
110908: PUSH
110909: LD_INT 30
110911: PUSH
110912: LD_INT 0
110914: PUSH
110915: EMPTY
110916: LIST
110917: LIST
110918: PUSH
110919: LD_INT 30
110921: PUSH
110922: LD_INT 1
110924: PUSH
110925: EMPTY
110926: LIST
110927: LIST
110928: PUSH
110929: EMPTY
110930: LIST
110931: LIST
110932: LIST
110933: PPUSH
110934: CALL_OW 72
110938: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110939: LD_ADDR_VAR 0 17
110943: PUSH
110944: LD_VAR 0 8
110948: NOT
110949: PUSH
110950: LD_VAR 0 8
110954: PPUSH
110955: LD_INT 3
110957: PUSH
110958: LD_INT 24
110960: PUSH
110961: LD_INT 600
110963: PUSH
110964: EMPTY
110965: LIST
110966: LIST
110967: PUSH
110968: EMPTY
110969: LIST
110970: LIST
110971: PPUSH
110972: CALL_OW 72
110976: OR
110977: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
110978: LD_VAR 0 5
110982: PPUSH
110983: CALL_OW 247
110987: PUSH
110988: LD_INT 2
110990: DOUBLE
110991: EQUAL
110992: IFTRUE 110996
110994: GO 111392
110996: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
110997: LD_VAR 0 5
111001: PPUSH
111002: CALL_OW 256
111006: PUSH
111007: LD_INT 650
111009: GREATER
111010: PUSH
111011: LD_VAR 0 5
111015: PPUSH
111016: LD_VAR 0 14
111020: PPUSH
111021: CALL_OW 296
111025: PUSH
111026: LD_INT 40
111028: LESS
111029: PUSH
111030: LD_VAR 0 14
111034: PPUSH
111035: LD_EXP 115
111039: PUSH
111040: LD_VAR 0 1
111044: ARRAY
111045: PPUSH
111046: CALL_OW 308
111050: OR
111051: AND
111052: IFFALSE 111174
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111054: LD_VAR 0 5
111058: PPUSH
111059: CALL_OW 262
111063: PUSH
111064: LD_INT 1
111066: EQUAL
111067: PUSH
111068: LD_VAR 0 5
111072: PPUSH
111073: CALL_OW 261
111077: PUSH
111078: LD_INT 30
111080: LESS
111081: AND
111082: PUSH
111083: LD_VAR 0 8
111087: AND
111088: IFFALSE 111158
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111090: LD_VAR 0 5
111094: PPUSH
111095: LD_VAR 0 8
111099: PPUSH
111100: LD_VAR 0 5
111104: PPUSH
111105: CALL_OW 74
111109: PPUSH
111110: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111114: LD_VAR 0 5
111118: PPUSH
111119: LD_VAR 0 8
111123: PPUSH
111124: LD_VAR 0 5
111128: PPUSH
111129: CALL_OW 74
111133: PPUSH
111134: CALL_OW 296
111138: PUSH
111139: LD_INT 6
111141: LESS
111142: IFFALSE 111156
// SetFuel ( i , 100 ) ;
111144: LD_VAR 0 5
111148: PPUSH
111149: LD_INT 100
111151: PPUSH
111152: CALL_OW 240
// end else
111156: GO 111172
// ComAttackUnit ( i , e ) ;
111158: LD_VAR 0 5
111162: PPUSH
111163: LD_VAR 0 14
111167: PPUSH
111168: CALL_OW 115
// end else
111172: GO 111275
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111174: LD_VAR 0 14
111178: PPUSH
111179: LD_EXP 115
111183: PUSH
111184: LD_VAR 0 1
111188: ARRAY
111189: PPUSH
111190: CALL_OW 308
111194: NOT
111195: PUSH
111196: LD_VAR 0 5
111200: PPUSH
111201: LD_VAR 0 14
111205: PPUSH
111206: CALL_OW 296
111210: PUSH
111211: LD_INT 40
111213: GREATEREQUAL
111214: AND
111215: PUSH
111216: LD_VAR 0 5
111220: PPUSH
111221: CALL_OW 256
111225: PUSH
111226: LD_INT 650
111228: LESSEQUAL
111229: OR
111230: PUSH
111231: LD_VAR 0 5
111235: PPUSH
111236: LD_EXP 114
111240: PUSH
111241: LD_VAR 0 1
111245: ARRAY
111246: PPUSH
111247: CALL_OW 308
111251: NOT
111252: AND
111253: IFFALSE 111275
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111255: LD_VAR 0 5
111259: PPUSH
111260: LD_EXP 114
111264: PUSH
111265: LD_VAR 0 1
111269: ARRAY
111270: PPUSH
111271: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111275: LD_VAR 0 5
111279: PPUSH
111280: CALL_OW 256
111284: PUSH
111285: LD_INT 998
111287: LESS
111288: PUSH
111289: LD_VAR 0 5
111293: PPUSH
111294: CALL_OW 263
111298: PUSH
111299: LD_INT 1
111301: EQUAL
111302: AND
111303: PUSH
111304: LD_VAR 0 5
111308: PPUSH
111309: CALL_OW 311
111313: AND
111314: PUSH
111315: LD_VAR 0 5
111319: PPUSH
111320: LD_EXP 114
111324: PUSH
111325: LD_VAR 0 1
111329: ARRAY
111330: PPUSH
111331: CALL_OW 308
111335: AND
111336: IFFALSE 111390
// begin mech := IsDrivenBy ( i ) ;
111338: LD_ADDR_VAR 0 10
111342: PUSH
111343: LD_VAR 0 5
111347: PPUSH
111348: CALL_OW 311
111352: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111353: LD_VAR 0 10
111357: PPUSH
111358: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111362: LD_VAR 0 10
111366: PPUSH
111367: LD_VAR 0 5
111371: PPUSH
111372: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111376: LD_VAR 0 10
111380: PPUSH
111381: LD_VAR 0 5
111385: PPUSH
111386: CALL_OW 180
// end ; end ; unit_human :
111390: GO 111657
111392: LD_INT 1
111394: DOUBLE
111395: EQUAL
111396: IFTRUE 111400
111398: GO 111656
111400: POP
// begin b := IsInUnit ( i ) ;
111401: LD_ADDR_VAR 0 19
111405: PUSH
111406: LD_VAR 0 5
111410: PPUSH
111411: CALL_OW 310
111415: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111416: LD_ADDR_VAR 0 20
111420: PUSH
111421: LD_VAR 0 19
111425: NOT
111426: PUSH
111427: LD_VAR 0 19
111431: PPUSH
111432: CALL_OW 266
111436: PUSH
111437: LD_INT 32
111439: PUSH
111440: LD_INT 31
111442: PUSH
111443: EMPTY
111444: LIST
111445: LIST
111446: IN
111447: OR
111448: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111449: LD_VAR 0 17
111453: PUSH
111454: LD_VAR 0 2
111458: PPUSH
111459: LD_INT 21
111461: PUSH
111462: LD_INT 2
111464: PUSH
111465: EMPTY
111466: LIST
111467: LIST
111468: PPUSH
111469: CALL_OW 72
111473: PUSH
111474: LD_INT 1
111476: LESSEQUAL
111477: OR
111478: PUSH
111479: LD_VAR 0 20
111483: AND
111484: PUSH
111485: LD_VAR 0 5
111489: PUSH
111490: LD_VAR 0 18
111494: IN
111495: NOT
111496: AND
111497: IFFALSE 111590
// begin if b then
111499: LD_VAR 0 19
111503: IFFALSE 111552
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111505: LD_VAR 0 19
111509: PPUSH
111510: LD_VAR 0 3
111514: PPUSH
111515: LD_VAR 0 19
111519: PPUSH
111520: CALL_OW 74
111524: PPUSH
111525: CALL_OW 296
111529: PUSH
111530: LD_INT 10
111532: LESS
111533: PUSH
111534: LD_VAR 0 19
111538: PPUSH
111539: CALL_OW 461
111543: PUSH
111544: LD_INT 7
111546: NONEQUAL
111547: AND
111548: IFFALSE 111552
// continue ;
111550: GO 110867
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111552: LD_ADDR_VAR 0 18
111556: PUSH
111557: LD_VAR 0 18
111561: PPUSH
111562: LD_VAR 0 18
111566: PUSH
111567: LD_INT 1
111569: PLUS
111570: PPUSH
111571: LD_VAR 0 5
111575: PPUSH
111576: CALL_OW 1
111580: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111581: LD_VAR 0 5
111585: PPUSH
111586: CALL_OW 122
// end ; if sold_defenders then
111590: LD_VAR 0 18
111594: IFFALSE 111654
// if i in sold_defenders then
111596: LD_VAR 0 5
111600: PUSH
111601: LD_VAR 0 18
111605: IN
111606: IFFALSE 111654
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111608: LD_VAR 0 5
111612: PPUSH
111613: CALL_OW 314
111617: NOT
111618: PUSH
111619: LD_VAR 0 5
111623: PPUSH
111624: LD_VAR 0 14
111628: PPUSH
111629: CALL_OW 296
111633: PUSH
111634: LD_INT 30
111636: LESS
111637: AND
111638: IFFALSE 111654
// ComAttackUnit ( i , e ) ;
111640: LD_VAR 0 5
111644: PPUSH
111645: LD_VAR 0 14
111649: PPUSH
111650: CALL_OW 115
// end ; end ; end ;
111654: GO 111657
111656: POP
// if IsDead ( i ) then
111657: LD_VAR 0 5
111661: PPUSH
111662: CALL_OW 301
111666: IFFALSE 111684
// defenders := defenders diff i ;
111668: LD_ADDR_VAR 0 2
111672: PUSH
111673: LD_VAR 0 2
111677: PUSH
111678: LD_VAR 0 5
111682: DIFF
111683: ST_TO_ADDR
// end ;
111684: GO 110867
111686: POP
111687: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111688: LD_VAR 0 3
111692: NOT
111693: PUSH
111694: LD_VAR 0 2
111698: NOT
111699: OR
111700: PUSH
111701: LD_EXP 90
111705: PUSH
111706: LD_VAR 0 1
111710: ARRAY
111711: NOT
111712: OR
111713: IFFALSE 110771
// MC_Reset ( base , 18 ) ;
111715: LD_VAR 0 1
111719: PPUSH
111720: LD_INT 18
111722: PPUSH
111723: CALL 24856 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111727: LD_ADDR_VAR 0 2
111731: PUSH
111732: LD_VAR 0 2
111736: PUSH
111737: LD_VAR 0 2
111741: PPUSH
111742: LD_INT 2
111744: PUSH
111745: LD_INT 25
111747: PUSH
111748: LD_INT 1
111750: PUSH
111751: EMPTY
111752: LIST
111753: LIST
111754: PUSH
111755: LD_INT 25
111757: PUSH
111758: LD_INT 5
111760: PUSH
111761: EMPTY
111762: LIST
111763: LIST
111764: PUSH
111765: LD_INT 25
111767: PUSH
111768: LD_INT 8
111770: PUSH
111771: EMPTY
111772: LIST
111773: LIST
111774: PUSH
111775: LD_INT 25
111777: PUSH
111778: LD_INT 9
111780: PUSH
111781: EMPTY
111782: LIST
111783: LIST
111784: PUSH
111785: EMPTY
111786: LIST
111787: LIST
111788: LIST
111789: LIST
111790: LIST
111791: PPUSH
111792: CALL_OW 72
111796: DIFF
111797: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111798: LD_VAR 0 3
111802: NOT
111803: PUSH
111804: LD_VAR 0 2
111808: PPUSH
111809: LD_INT 21
111811: PUSH
111812: LD_INT 2
111814: PUSH
111815: EMPTY
111816: LIST
111817: LIST
111818: PPUSH
111819: CALL_OW 72
111823: AND
111824: IFFALSE 112162
// begin tmp := FilterByTag ( defenders , 19 ) ;
111826: LD_ADDR_VAR 0 12
111830: PUSH
111831: LD_VAR 0 2
111835: PPUSH
111836: LD_INT 19
111838: PPUSH
111839: CALL 84353 0 2
111843: ST_TO_ADDR
// if tmp then
111844: LD_VAR 0 12
111848: IFFALSE 111918
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111850: LD_ADDR_VAR 0 12
111854: PUSH
111855: LD_VAR 0 12
111859: PPUSH
111860: LD_INT 25
111862: PUSH
111863: LD_INT 3
111865: PUSH
111866: EMPTY
111867: LIST
111868: LIST
111869: PPUSH
111870: CALL_OW 72
111874: ST_TO_ADDR
// if tmp then
111875: LD_VAR 0 12
111879: IFFALSE 111918
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111881: LD_ADDR_EXP 102
111885: PUSH
111886: LD_EXP 102
111890: PPUSH
111891: LD_VAR 0 1
111895: PPUSH
111896: LD_EXP 102
111900: PUSH
111901: LD_VAR 0 1
111905: ARRAY
111906: PUSH
111907: LD_VAR 0 12
111911: UNION
111912: PPUSH
111913: CALL_OW 1
111917: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111918: LD_VAR 0 1
111922: PPUSH
111923: LD_INT 19
111925: PPUSH
111926: CALL 24856 0 2
// repeat wait ( 0 0$1 ) ;
111930: LD_INT 35
111932: PPUSH
111933: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111937: LD_EXP 90
111941: PUSH
111942: LD_VAR 0 1
111946: ARRAY
111947: NOT
111948: PUSH
111949: LD_EXP 90
111953: PUSH
111954: LD_VAR 0 1
111958: ARRAY
111959: PUSH
111960: EMPTY
111961: EQUAL
111962: OR
111963: IFFALSE 112000
// begin for i in defenders do
111965: LD_ADDR_VAR 0 5
111969: PUSH
111970: LD_VAR 0 2
111974: PUSH
111975: FOR_IN
111976: IFFALSE 111989
// ComStop ( i ) ;
111978: LD_VAR 0 5
111982: PPUSH
111983: CALL_OW 141
111987: GO 111975
111989: POP
111990: POP
// defenders := [ ] ;
111991: LD_ADDR_VAR 0 2
111995: PUSH
111996: EMPTY
111997: ST_TO_ADDR
// exit ;
111998: GO 112186
// end ; for i in defenders do
112000: LD_ADDR_VAR 0 5
112004: PUSH
112005: LD_VAR 0 2
112009: PUSH
112010: FOR_IN
112011: IFFALSE 112100
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112013: LD_VAR 0 5
112017: PPUSH
112018: LD_EXP 114
112022: PUSH
112023: LD_VAR 0 1
112027: ARRAY
112028: PPUSH
112029: CALL_OW 308
112033: NOT
112034: IFFALSE 112058
// ComMoveToArea ( i , mc_parking [ base ] ) else
112036: LD_VAR 0 5
112040: PPUSH
112041: LD_EXP 114
112045: PUSH
112046: LD_VAR 0 1
112050: ARRAY
112051: PPUSH
112052: CALL_OW 113
112056: GO 112098
// if GetControl ( i ) = control_manual then
112058: LD_VAR 0 5
112062: PPUSH
112063: CALL_OW 263
112067: PUSH
112068: LD_INT 1
112070: EQUAL
112071: IFFALSE 112098
// if IsDrivenBy ( i ) then
112073: LD_VAR 0 5
112077: PPUSH
112078: CALL_OW 311
112082: IFFALSE 112098
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112084: LD_VAR 0 5
112088: PPUSH
112089: CALL_OW 311
112093: PPUSH
112094: CALL_OW 121
// end ;
112098: GO 112010
112100: POP
112101: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112102: LD_VAR 0 2
112106: PPUSH
112107: LD_INT 95
112109: PUSH
112110: LD_EXP 114
112114: PUSH
112115: LD_VAR 0 1
112119: ARRAY
112120: PUSH
112121: EMPTY
112122: LIST
112123: LIST
112124: PPUSH
112125: CALL_OW 72
112129: PUSH
112130: LD_VAR 0 2
112134: EQUAL
112135: PUSH
112136: LD_EXP 113
112140: PUSH
112141: LD_VAR 0 1
112145: ARRAY
112146: OR
112147: PUSH
112148: LD_EXP 90
112152: PUSH
112153: LD_VAR 0 1
112157: ARRAY
112158: NOT
112159: OR
112160: IFFALSE 111930
// end ; MC_Reset ( base , 19 ) ;
112162: LD_VAR 0 1
112166: PPUSH
112167: LD_INT 19
112169: PPUSH
112170: CALL 24856 0 2
// MC_Reset ( base , 20 ) ;
112174: LD_VAR 0 1
112178: PPUSH
112179: LD_INT 20
112181: PPUSH
112182: CALL 24856 0 2
// end ; end_of_file
112186: LD_VAR 0 4
112190: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112191: LD_VAR 0 1
112195: PUSH
112196: LD_INT 200
112198: DOUBLE
112199: GREATEREQUAL
112200: IFFALSE 112208
112202: LD_INT 299
112204: DOUBLE
112205: LESSEQUAL
112206: IFTRUE 112210
112208: GO 112242
112210: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112211: LD_VAR 0 1
112215: PPUSH
112216: LD_VAR 0 2
112220: PPUSH
112221: LD_VAR 0 3
112225: PPUSH
112226: LD_VAR 0 4
112230: PPUSH
112231: LD_VAR 0 5
112235: PPUSH
112236: CALL 101196 0 5
112240: GO 112319
112242: LD_INT 300
112244: DOUBLE
112245: GREATEREQUAL
112246: IFFALSE 112254
112248: LD_INT 399
112250: DOUBLE
112251: LESSEQUAL
112252: IFTRUE 112256
112254: GO 112318
112256: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112257: LD_VAR 0 1
112261: PPUSH
112262: LD_VAR 0 2
112266: PPUSH
112267: LD_VAR 0 3
112271: PPUSH
112272: LD_VAR 0 4
112276: PPUSH
112277: LD_VAR 0 5
112281: PPUSH
112282: LD_VAR 0 6
112286: PPUSH
112287: LD_VAR 0 7
112291: PPUSH
112292: LD_VAR 0 8
112296: PPUSH
112297: LD_VAR 0 9
112301: PPUSH
112302: LD_VAR 0 10
112306: PPUSH
112307: LD_VAR 0 11
112311: PPUSH
112312: CALL 99102 0 11
112316: GO 112319
112318: POP
// end ;
112319: PPOPN 11
112321: END
