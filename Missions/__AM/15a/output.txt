// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 10441 0 0
// InitNature ;
  19: CALL 10265 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAmerican ;
  36: CALL 3961 0 0
// PrepareAlliance ;
  40: CALL 1111 0 0
// PrepareArabian ;
  44: CALL 5616 0 0
// PrepareRussian ;
  48: CALL 7476 0 0
// PrepareLegion ;
  52: CALL 5917 0 0
// Action ;
  56: CALL 9881 0 0
// MC_Start ( ) ;
  60: CALL 12553 0 0
// end ;
  64: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 1 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 1
  75: ST_TO_ADDR
// russianDestroyed := false ;
  76: LD_ADDR_EXP 2
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// legionDestroyed := false ;
  84: LD_ADDR_EXP 3
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanDestroyed := false ;
  92: LD_ADDR_EXP 4
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// arabianDestroyed := false ;
 100: LD_ADDR_EXP 5
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// end ;
 108: LD_VAR 0 1
 112: RET
// export function CustomInitMacro ( ) ; begin
 113: LD_INT 0
 115: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 116: LD_ADDR_EXP 80
 120: PUSH
 121: LD_INT 26
 123: PUSH
 124: LD_INT 1
 126: PUSH
 127: LD_INT 4
 129: PUSH
 130: LD_INT 8
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: LIST
 138: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 139: LD_ADDR_EXP 81
 143: PUSH
 144: LD_INT 27
 146: PUSH
 147: LD_INT 2
 149: PUSH
 150: LD_INT 3
 152: PUSH
 153: LD_INT 7
 155: PUSH
 156: EMPTY
 157: LIST
 158: LIST
 159: LIST
 160: LIST
 161: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 162: LD_INT 1
 164: PPUSH
 165: LD_INT 6
 167: PUSH
 168: LD_INT 7
 170: PUSH
 171: LD_INT 9
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: PUSH
 179: LD_OWVAR 67
 183: ARRAY
 184: PPUSH
 185: LD_INT 28
 187: PPUSH
 188: CALL 33658 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 192: LD_INT 1
 194: PPUSH
 195: LD_INT 10
 197: PUSH
 198: LD_INT 11
 200: PUSH
 201: LD_INT 13
 203: PUSH
 204: LD_INT 15
 206: PUSH
 207: EMPTY
 208: LIST
 209: LIST
 210: LIST
 211: LIST
 212: PPUSH
 213: CALL 34718 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 29
 222: PUSH
 223: EMPTY
 224: LIST
 225: PPUSH
 226: CALL 34811 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 230: LD_ADDR_EXP 85
 234: PUSH
 235: LD_EXP 85
 239: PPUSH
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 2
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: PUSH
 253: LD_INT 25
 255: PUSH
 256: LD_INT 15
 258: PUSH
 259: EMPTY
 260: LIST
 261: LIST
 262: PUSH
 263: EMPTY
 264: LIST
 265: LIST
 266: PPUSH
 267: CALL_OW 69
 271: PPUSH
 272: CALL_OW 1
 276: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 13
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 31
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_INT 13
 300: PUSH
 301: LD_INT 2
 303: PUSH
 304: LD_INT 1
 306: PUSH
 307: LD_INT 31
 309: PUSH
 310: EMPTY
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_INT 13
 318: PUSH
 319: LD_INT 1
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 28
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: PUSH
 334: LD_INT 13
 336: PUSH
 337: LD_INT 1
 339: PUSH
 340: LD_INT 1
 342: PUSH
 343: LD_INT 28
 345: PUSH
 346: EMPTY
 347: LIST
 348: LIST
 349: LIST
 350: LIST
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: LD_INT 1
 357: PUSH
 358: LD_INT 1
 360: PUSH
 361: LD_INT 28
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: PUSH
 370: LD_INT 13
 372: PUSH
 373: LD_INT 1
 375: PUSH
 376: LD_INT 1
 378: PUSH
 379: LD_INT 28
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: PPUSH
 396: CALL 33976 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 4
 405: PPUSH
 406: CALL 34161 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 10
 415: PUSH
 416: LD_INT 11
 418: PUSH
 419: LD_INT 12
 421: PUSH
 422: LD_INT 14
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PPUSH
 431: CALL 34718 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 435: LD_INT 2
 437: PPUSH
 438: LD_INT 14
 440: PUSH
 441: EMPTY
 442: LIST
 443: PPUSH
 444: CALL 34811 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 448: LD_INT 2
 450: PPUSH
 451: LD_INT 21
 453: PUSH
 454: LD_INT 3
 456: PUSH
 457: LD_INT 3
 459: PUSH
 460: LD_INT 51
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 24
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 3
 477: PUSH
 478: LD_INT 47
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 24
 489: PUSH
 490: LD_INT 3
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 47
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 24
 507: PUSH
 508: LD_INT 3
 510: PUSH
 511: LD_INT 3
 513: PUSH
 514: LD_INT 47
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 24
 525: PUSH
 526: LD_INT 3
 528: PUSH
 529: LD_INT 3
 531: PUSH
 532: LD_INT 47
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_INT 24
 543: PUSH
 544: LD_INT 3
 546: PUSH
 547: LD_INT 3
 549: PUSH
 550: LD_INT 47
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL 33976 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 571: LD_INT 2
 573: PPUSH
 574: LD_INT 5
 576: PPUSH
 577: CALL 34161 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 581: LD_INT 2
 583: PPUSH
 584: LD_INT 0
 586: PPUSH
 587: CALL 34591 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 591: LD_INT 3
 593: PPUSH
 594: LD_INT 10
 596: PUSH
 597: LD_INT 12
 599: PUSH
 600: LD_INT 15
 602: PUSH
 603: EMPTY
 604: LIST
 605: LIST
 606: LIST
 607: PUSH
 608: LD_OWVAR 67
 612: ARRAY
 613: PPUSH
 614: LD_INT 24
 616: PPUSH
 617: CALL 33658 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 621: LD_INT 3
 623: PPUSH
 624: LD_INT 10
 626: PUSH
 627: LD_INT 11
 629: PUSH
 630: LD_INT 13
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL 34718 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 646: LD_INT 3
 648: PPUSH
 649: LD_INT 13
 651: PUSH
 652: EMPTY
 653: LIST
 654: PPUSH
 655: CALL 34811 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 659: LD_ADDR_EXP 85
 663: PUSH
 664: LD_EXP 85
 668: PPUSH
 669: LD_INT 3
 671: PPUSH
 672: LD_INT 22
 674: PUSH
 675: LD_INT 8
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: PUSH
 682: LD_INT 25
 684: PUSH
 685: LD_INT 15
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PPUSH
 696: CALL_OW 69
 700: PPUSH
 701: CALL_OW 1
 705: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 706: LD_INT 3
 708: PPUSH
 709: LD_INT 13
 711: PUSH
 712: LD_INT 2
 714: PUSH
 715: LD_INT 1
 717: PUSH
 718: LD_INT 31
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 13
 729: PUSH
 730: LD_INT 2
 732: PUSH
 733: LD_INT 1
 735: PUSH
 736: LD_INT 31
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 13
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 2
 753: PUSH
 754: LD_INT 32
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 14
 765: PUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 1
 771: PUSH
 772: LD_INT 28
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 14
 783: PUSH
 784: LD_INT 1
 786: PUSH
 787: LD_INT 1
 789: PUSH
 790: LD_INT 28
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 14
 801: PUSH
 802: LD_INT 1
 804: PUSH
 805: LD_INT 1
 807: PUSH
 808: LD_INT 28
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 14
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: LD_INT 1
 825: PUSH
 826: LD_INT 28
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: PPUSH
 844: CALL 33976 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 848: LD_INT 3
 850: PPUSH
 851: LD_INT 4
 853: PPUSH
 854: CALL 34161 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 858: LD_INT 4
 860: PPUSH
 861: LD_INT 10
 863: PUSH
 864: LD_INT 12
 866: PUSH
 867: LD_INT 11
 869: PUSH
 870: LD_INT 15
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PPUSH
 879: CALL 34718 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 883: LD_INT 4
 885: PPUSH
 886: LD_INT 7
 888: PUSH
 889: EMPTY
 890: LIST
 891: PPUSH
 892: CALL 34811 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 896: LD_INT 4
 898: PPUSH
 899: LD_INT 5
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: LD_INT 7
 907: PUSH
 908: LD_INT 9
 910: PUSH
 911: LD_INT 10
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PPUSH
 921: CALL 35129 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
 925: LD_INT 4
 927: PPUSH
 928: LD_INT 54
 930: PPUSH
 931: LD_INT 85
 933: PPUSH
 934: LD_INT 2
 936: PPUSH
 937: LD_INT 25
 939: PUSH
 940: LD_INT 16
 942: PUSH
 943: LD_INT 17
 945: PUSH
 946: LD_INT 18
 948: PUSH
 949: LD_INT 22
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: PPUSH
 959: CALL 34923 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
 963: LD_INT 4
 965: PPUSH
 966: LD_INT 5
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: LD_INT 7
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PUSH
 984: LD_INT 5
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 1
 992: PUSH
 993: LD_INT 6
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: PUSH
1002: LD_INT 5
1004: PUSH
1005: LD_INT 1
1007: PUSH
1008: LD_INT 1
1010: PUSH
1011: LD_INT 7
1013: PUSH
1014: EMPTY
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: PUSH
1020: LD_INT 5
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 1
1028: PUSH
1029: LD_INT 6
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: PUSH
1038: LD_INT 5
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 1
1061: PUSH
1062: LD_INT 3
1064: PUSH
1065: LD_INT 13
1067: PUSH
1068: EMPTY
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PPUSH
1082: CALL 33976 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1086: LD_INT 4
1088: PPUSH
1089: LD_INT 4
1091: PPUSH
1092: CALL 34161 0 2
// MC_SetTame ( 4 , powellApe ) ;
1096: LD_INT 4
1098: PPUSH
1099: LD_INT 11
1101: PPUSH
1102: CALL 34542 0 2
// end ; end_of_file
1106: LD_VAR 0 1
1110: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1111: LD_INT 0
1113: PPUSH
1114: PPUSH
1115: PPUSH
1116: PPUSH
1117: PPUSH
// uc_side := 7 ;
1118: LD_ADDR_OWVAR 20
1122: PUSH
1123: LD_INT 7
1125: ST_TO_ADDR
// tmp := [ ] ;
1126: LD_ADDR_VAR 0 5
1130: PUSH
1131: EMPTY
1132: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1133: LD_ADDR_EXP 6
1137: PUSH
1138: LD_STRING JMM
1140: PPUSH
1141: LD_EXP 1
1145: NOT
1146: PPUSH
1147: LD_STRING 14a_
1149: PPUSH
1150: CALL 40146 0 3
1154: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1155: LD_ADDR_EXP 37
1159: PUSH
1160: LD_STRING Burlak
1162: PPUSH
1163: LD_EXP 1
1167: NOT
1168: PPUSH
1169: LD_STRING 14a_
1171: PPUSH
1172: CALL 40146 0 3
1176: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1177: LD_ADDR_EXP 21
1181: PUSH
1182: LD_STRING Joan
1184: PPUSH
1185: LD_EXP 1
1189: NOT
1190: PPUSH
1191: LD_STRING 13a_
1193: PPUSH
1194: CALL 40146 0 3
1198: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1199: LD_ADDR_EXP 7
1203: PUSH
1204: LD_STRING Roth
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 13a_
1215: PPUSH
1216: CALL 40146 0 3
1220: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1221: LD_ADDR_EXP 23
1225: PUSH
1226: LD_STRING Gossudarov
1228: PPUSH
1229: LD_EXP 1
1233: NOT
1234: PPUSH
1235: LD_STRING 13a_
1237: PPUSH
1238: CALL 40146 0 3
1242: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1243: LD_ADDR_EXP 22
1247: PUSH
1248: LD_STRING DeltaDoctor
1250: PPUSH
1251: LD_EXP 1
1255: NOT
1256: PPUSH
1257: LD_STRING 13a_
1259: PPUSH
1260: CALL 40146 0 3
1264: ST_TO_ADDR
// if DeltaDoctor then
1265: LD_EXP 22
1269: IFFALSE 1287
// tmp := tmp ^ DeltaDoctor ;
1271: LD_ADDR_VAR 0 5
1275: PUSH
1276: LD_VAR 0 5
1280: PUSH
1281: LD_EXP 22
1285: ADD
1286: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1287: LD_ADDR_EXP 20
1291: PUSH
1292: LD_STRING Simms
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_STRING 13a_
1303: PPUSH
1304: CALL 40146 0 3
1308: ST_TO_ADDR
// if Simms then
1309: LD_EXP 20
1313: IFFALSE 1331
// tmp := tmp ^ Simms ;
1315: LD_ADDR_VAR 0 5
1319: PUSH
1320: LD_VAR 0 5
1324: PUSH
1325: LD_EXP 20
1329: ADD
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1331: LD_ADDR_EXP 18
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_STRING 13a_
1347: PPUSH
1348: CALL 40146 0 3
1352: ST_TO_ADDR
// if Frank then
1353: LD_EXP 18
1357: IFFALSE 1375
// tmp := tmp ^ Frank ;
1359: LD_ADDR_VAR 0 5
1363: PUSH
1364: LD_VAR 0 5
1368: PUSH
1369: LD_EXP 18
1373: ADD
1374: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1375: LD_ADDR_EXP 24
1379: PUSH
1380: LD_STRING Kirilenkova
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 13a_
1391: PPUSH
1392: CALL 40146 0 3
1396: ST_TO_ADDR
// if Kirilenkova then
1397: LD_EXP 24
1401: IFFALSE 1419
// tmp := tmp ^ Kirilenkova ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_VAR 0 5
1412: PUSH
1413: LD_EXP 24
1417: ADD
1418: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1419: LD_ADDR_EXP 25
1423: PUSH
1424: LD_STRING Titov
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 13a_
1435: PPUSH
1436: CALL 40146 0 3
1440: ST_TO_ADDR
// if Titov then
1441: LD_EXP 25
1445: IFFALSE 1463
// tmp := tmp ^ Titov ;
1447: LD_ADDR_VAR 0 5
1451: PUSH
1452: LD_VAR 0 5
1456: PUSH
1457: LD_EXP 25
1461: ADD
1462: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 26
1467: PUSH
1468: LD_STRING Fadeev
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 40146 0 3
1484: ST_TO_ADDR
// if Fadeev then
1485: LD_EXP 26
1489: IFFALSE 1507
// tmp := tmp ^ Fadeev ;
1491: LD_ADDR_VAR 0 5
1495: PUSH
1496: LD_VAR 0 5
1500: PUSH
1501: LD_EXP 26
1505: ADD
1506: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 27
1511: PUSH
1512: LD_STRING Dolgov
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 40146 0 3
1528: ST_TO_ADDR
// if Dolgov then
1529: LD_EXP 27
1533: IFFALSE 1551
// tmp := tmp ^ Dolgov ;
1535: LD_ADDR_VAR 0 5
1539: PUSH
1540: LD_VAR 0 5
1544: PUSH
1545: LD_EXP 27
1549: ADD
1550: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1551: LD_ADDR_EXP 28
1555: PUSH
1556: LD_STRING Petrosyan
1558: PPUSH
1559: LD_EXP 1
1563: NOT
1564: PPUSH
1565: LD_STRING 13a_
1567: PPUSH
1568: CALL 40146 0 3
1572: ST_TO_ADDR
// if Petrosyan then
1573: LD_EXP 28
1577: IFFALSE 1595
// tmp := tmp ^ Petrosyan ;
1579: LD_ADDR_VAR 0 5
1583: PUSH
1584: LD_VAR 0 5
1588: PUSH
1589: LD_EXP 28
1593: ADD
1594: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1595: LD_ADDR_EXP 29
1599: PUSH
1600: LD_STRING Scholtze
1602: PPUSH
1603: LD_EXP 1
1607: NOT
1608: PPUSH
1609: LD_STRING 13a_
1611: PPUSH
1612: CALL 40146 0 3
1616: ST_TO_ADDR
// if Scholtze then
1617: LD_EXP 29
1621: IFFALSE 1639
// tmp := tmp ^ Scholtze ;
1623: LD_ADDR_VAR 0 5
1627: PUSH
1628: LD_VAR 0 5
1632: PUSH
1633: LD_EXP 29
1637: ADD
1638: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1639: LD_ADDR_EXP 30
1643: PUSH
1644: LD_STRING Oblukov
1646: PPUSH
1647: LD_EXP 1
1651: NOT
1652: PPUSH
1653: LD_STRING 13a_
1655: PPUSH
1656: CALL 40146 0 3
1660: ST_TO_ADDR
// if Oblukov then
1661: LD_EXP 30
1665: IFFALSE 1683
// tmp := tmp ^ Oblukov ;
1667: LD_ADDR_VAR 0 5
1671: PUSH
1672: LD_VAR 0 5
1676: PUSH
1677: LD_EXP 30
1681: ADD
1682: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1683: LD_ADDR_EXP 31
1687: PUSH
1688: LD_STRING Kapitsova
1690: PPUSH
1691: LD_EXP 1
1695: NOT
1696: PPUSH
1697: LD_STRING 13a_
1699: PPUSH
1700: CALL 40146 0 3
1704: ST_TO_ADDR
// if Kapitsova then
1705: LD_EXP 31
1709: IFFALSE 1727
// tmp := tmp ^ Kapitsova ;
1711: LD_ADDR_VAR 0 5
1715: PUSH
1716: LD_VAR 0 5
1720: PUSH
1721: LD_EXP 31
1725: ADD
1726: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1727: LD_ADDR_EXP 32
1731: PUSH
1732: LD_STRING Lipshchin
1734: PPUSH
1735: LD_EXP 1
1739: NOT
1740: PPUSH
1741: LD_STRING 13a_
1743: PPUSH
1744: CALL 40146 0 3
1748: ST_TO_ADDR
// if Lipshchin then
1749: LD_EXP 32
1753: IFFALSE 1771
// tmp := tmp ^ Lipshchin ;
1755: LD_ADDR_VAR 0 5
1759: PUSH
1760: LD_VAR 0 5
1764: PUSH
1765: LD_EXP 32
1769: ADD
1770: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1771: LD_ADDR_EXP 33
1775: PUSH
1776: LD_STRING Petrovova
1778: PPUSH
1779: LD_EXP 1
1783: NOT
1784: PPUSH
1785: LD_STRING 13a_
1787: PPUSH
1788: CALL 40146 0 3
1792: ST_TO_ADDR
// if Petrovova then
1793: LD_EXP 33
1797: IFFALSE 1815
// tmp := tmp ^ Petrovova ;
1799: LD_ADDR_VAR 0 5
1803: PUSH
1804: LD_VAR 0 5
1808: PUSH
1809: LD_EXP 33
1813: ADD
1814: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
1815: LD_ADDR_EXP 34
1819: PUSH
1820: LD_STRING Kovalyuk
1822: PPUSH
1823: LD_EXP 1
1827: NOT
1828: PPUSH
1829: LD_STRING 13a_
1831: PPUSH
1832: CALL 40146 0 3
1836: ST_TO_ADDR
// if Kovalyuk then
1837: LD_EXP 34
1841: IFFALSE 1859
// tmp := tmp ^ Kovalyuk ;
1843: LD_ADDR_VAR 0 5
1847: PUSH
1848: LD_VAR 0 5
1852: PUSH
1853: LD_EXP 34
1857: ADD
1858: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
1859: LD_ADDR_EXP 35
1863: PUSH
1864: LD_STRING Kuzmov
1866: PPUSH
1867: LD_EXP 1
1871: NOT
1872: PPUSH
1873: LD_STRING 13a_
1875: PPUSH
1876: CALL 40146 0 3
1880: ST_TO_ADDR
// if Kuzmov then
1881: LD_EXP 35
1885: IFFALSE 1903
// tmp := tmp ^ Kuzmov ;
1887: LD_ADDR_VAR 0 5
1891: PUSH
1892: LD_VAR 0 5
1896: PUSH
1897: LD_EXP 35
1901: ADD
1902: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
1903: LD_ADDR_EXP 36
1907: PUSH
1908: LD_STRING Karamazov
1910: PPUSH
1911: LD_EXP 1
1915: NOT
1916: PPUSH
1917: LD_STRING 13a_
1919: PPUSH
1920: CALL 40146 0 3
1924: ST_TO_ADDR
// if Karamazov then
1925: LD_EXP 36
1929: IFFALSE 1947
// tmp := tmp ^ Karamazov ;
1931: LD_ADDR_VAR 0 5
1935: PUSH
1936: LD_VAR 0 5
1940: PUSH
1941: LD_EXP 36
1945: ADD
1946: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
1947: LD_ADDR_EXP 38
1951: PUSH
1952: LD_STRING Belkov
1954: PPUSH
1955: LD_EXP 1
1959: NOT
1960: PPUSH
1961: LD_STRING 13a_
1963: PPUSH
1964: CALL 40146 0 3
1968: ST_TO_ADDR
// if Belkov then
1969: LD_EXP 38
1973: IFFALSE 1991
// tmp := tmp ^ Belkov ;
1975: LD_ADDR_VAR 0 5
1979: PUSH
1980: LD_VAR 0 5
1984: PUSH
1985: LD_EXP 38
1989: ADD
1990: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
1991: LD_ADDR_EXP 39
1995: PUSH
1996: LD_STRING Gnyevko
1998: PPUSH
1999: LD_EXP 1
2003: NOT
2004: PPUSH
2005: LD_STRING 13a_
2007: PPUSH
2008: CALL 40146 0 3
2012: ST_TO_ADDR
// if Gnyevko then
2013: LD_EXP 39
2017: IFFALSE 2035
// tmp := tmp ^ Gnyevko ;
2019: LD_ADDR_VAR 0 5
2023: PUSH
2024: LD_VAR 0 5
2028: PUSH
2029: LD_EXP 39
2033: ADD
2034: ST_TO_ADDR
// if not Lisa then
2035: LD_EXP 8
2039: NOT
2040: IFFALSE 2086
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 8
2046: PUSH
2047: LD_STRING Lisa
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 40146 0 3
2063: ST_TO_ADDR
// if Lisa then
2064: LD_EXP 8
2068: IFFALSE 2086
// tmp := tmp ^ Lisa ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 8
2084: ADD
2085: ST_TO_ADDR
// end ; if not Donaldson then
2086: LD_EXP 9
2090: NOT
2091: IFFALSE 2137
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2093: LD_ADDR_EXP 9
2097: PUSH
2098: LD_STRING Donaldson
2100: PPUSH
2101: LD_EXP 1
2105: NOT
2106: PPUSH
2107: LD_STRING 13a_
2109: PPUSH
2110: CALL 40146 0 3
2114: ST_TO_ADDR
// if Donaldson then
2115: LD_EXP 9
2119: IFFALSE 2137
// tmp := tmp ^ Donaldson ;
2121: LD_ADDR_VAR 0 5
2125: PUSH
2126: LD_VAR 0 5
2130: PUSH
2131: LD_EXP 9
2135: ADD
2136: ST_TO_ADDR
// end ; if not Bobby then
2137: LD_EXP 10
2141: NOT
2142: IFFALSE 2188
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2144: LD_ADDR_EXP 10
2148: PUSH
2149: LD_STRING Bobby
2151: PPUSH
2152: LD_EXP 1
2156: NOT
2157: PPUSH
2158: LD_STRING 13a_
2160: PPUSH
2161: CALL 40146 0 3
2165: ST_TO_ADDR
// if Bobby then
2166: LD_EXP 10
2170: IFFALSE 2188
// tmp := tmp ^ Bobby ;
2172: LD_ADDR_VAR 0 5
2176: PUSH
2177: LD_VAR 0 5
2181: PUSH
2182: LD_EXP 10
2186: ADD
2187: ST_TO_ADDR
// end ; if not Cyrus then
2188: LD_EXP 11
2192: NOT
2193: IFFALSE 2239
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2195: LD_ADDR_EXP 11
2199: PUSH
2200: LD_STRING Cyrus
2202: PPUSH
2203: LD_EXP 1
2207: NOT
2208: PPUSH
2209: LD_STRING 13a_
2211: PPUSH
2212: CALL 40146 0 3
2216: ST_TO_ADDR
// if Cyrus then
2217: LD_EXP 11
2221: IFFALSE 2239
// tmp := tmp ^ Cyrus ;
2223: LD_ADDR_VAR 0 5
2227: PUSH
2228: LD_VAR 0 5
2232: PUSH
2233: LD_EXP 11
2237: ADD
2238: ST_TO_ADDR
// end ; if not Brown then
2239: LD_EXP 13
2243: NOT
2244: IFFALSE 2290
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2246: LD_ADDR_EXP 13
2250: PUSH
2251: LD_STRING Brown
2253: PPUSH
2254: LD_EXP 1
2258: NOT
2259: PPUSH
2260: LD_STRING 13a_
2262: PPUSH
2263: CALL 40146 0 3
2267: ST_TO_ADDR
// if Brown then
2268: LD_EXP 13
2272: IFFALSE 2290
// tmp := tmp ^ Brown ;
2274: LD_ADDR_VAR 0 5
2278: PUSH
2279: LD_VAR 0 5
2283: PUSH
2284: LD_EXP 13
2288: ADD
2289: ST_TO_ADDR
// end ; if not Gladstone then
2290: LD_EXP 14
2294: NOT
2295: IFFALSE 2341
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2297: LD_ADDR_EXP 14
2301: PUSH
2302: LD_STRING Gladstone
2304: PPUSH
2305: LD_EXP 1
2309: NOT
2310: PPUSH
2311: LD_STRING 13a_
2313: PPUSH
2314: CALL 40146 0 3
2318: ST_TO_ADDR
// if Gladstone then
2319: LD_EXP 14
2323: IFFALSE 2341
// tmp := tmp ^ Gladstone ;
2325: LD_ADDR_VAR 0 5
2329: PUSH
2330: LD_VAR 0 5
2334: PUSH
2335: LD_EXP 14
2339: ADD
2340: ST_TO_ADDR
// end ; if not Cornel then
2341: LD_EXP 16
2345: NOT
2346: IFFALSE 2392
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2348: LD_ADDR_EXP 16
2352: PUSH
2353: LD_STRING Cornel
2355: PPUSH
2356: LD_EXP 1
2360: NOT
2361: PPUSH
2362: LD_STRING 13a_
2364: PPUSH
2365: CALL 40146 0 3
2369: ST_TO_ADDR
// if Cornel then
2370: LD_EXP 16
2374: IFFALSE 2392
// tmp := tmp ^ Cornel ;
2376: LD_ADDR_VAR 0 5
2380: PUSH
2381: LD_VAR 0 5
2385: PUSH
2386: LD_EXP 16
2390: ADD
2391: ST_TO_ADDR
// end ; if not Houten then
2392: LD_EXP 15
2396: NOT
2397: IFFALSE 2443
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2399: LD_ADDR_EXP 15
2403: PUSH
2404: LD_STRING Houten
2406: PPUSH
2407: LD_EXP 1
2411: NOT
2412: PPUSH
2413: LD_STRING 13a_
2415: PPUSH
2416: CALL 40146 0 3
2420: ST_TO_ADDR
// if Houten then
2421: LD_EXP 15
2425: IFFALSE 2443
// tmp := tmp ^ Houten ;
2427: LD_ADDR_VAR 0 5
2431: PUSH
2432: LD_VAR 0 5
2436: PUSH
2437: LD_EXP 15
2441: ADD
2442: ST_TO_ADDR
// end ; if not Gary then
2443: LD_EXP 17
2447: NOT
2448: IFFALSE 2494
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2450: LD_ADDR_EXP 17
2454: PUSH
2455: LD_STRING Gary
2457: PPUSH
2458: LD_EXP 1
2462: NOT
2463: PPUSH
2464: LD_STRING 13a_
2466: PPUSH
2467: CALL 40146 0 3
2471: ST_TO_ADDR
// if Gary then
2472: LD_EXP 17
2476: IFFALSE 2494
// tmp := tmp ^ Gary ;
2478: LD_ADDR_VAR 0 5
2482: PUSH
2483: LD_VAR 0 5
2487: PUSH
2488: LD_EXP 17
2492: ADD
2493: ST_TO_ADDR
// end ; if not Kikuchi then
2494: LD_EXP 19
2498: NOT
2499: IFFALSE 2545
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2501: LD_ADDR_EXP 19
2505: PUSH
2506: LD_STRING Kikuchi
2508: PPUSH
2509: LD_EXP 1
2513: NOT
2514: PPUSH
2515: LD_STRING 13a_
2517: PPUSH
2518: CALL 40146 0 3
2522: ST_TO_ADDR
// if Kikuchi then
2523: LD_EXP 19
2527: IFFALSE 2545
// tmp := tmp ^ Kikuchi ;
2529: LD_ADDR_VAR 0 5
2533: PUSH
2534: LD_VAR 0 5
2538: PUSH
2539: LD_EXP 19
2543: ADD
2544: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2545: LD_ADDR_VAR 0 5
2549: PUSH
2550: LD_VAR 0 5
2554: PUSH
2555: LD_STRING 13a_others
2557: PPUSH
2558: CALL_OW 31
2562: UNION
2563: ST_TO_ADDR
// tmp := tmp diff 0 ;
2564: LD_ADDR_VAR 0 5
2568: PUSH
2569: LD_VAR 0 5
2573: PUSH
2574: LD_INT 0
2576: DIFF
2577: ST_TO_ADDR
// if tmp < 15 then
2578: LD_VAR 0 5
2582: PUSH
2583: LD_INT 15
2585: LESS
2586: IFFALSE 2674
// for i = 15 downto tmp do
2588: LD_ADDR_VAR 0 2
2592: PUSH
2593: DOUBLE
2594: LD_INT 15
2596: INC
2597: ST_TO_ADDR
2598: LD_VAR 0 5
2602: PUSH
2603: FOR_DOWNTO
2604: IFFALSE 2672
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2606: LD_ADDR_OWVAR 21
2610: PUSH
2611: LD_INT 1
2613: PUSH
2614: LD_INT 3
2616: PUSH
2617: EMPTY
2618: LIST
2619: LIST
2620: PUSH
2621: LD_INT 1
2623: PPUSH
2624: LD_INT 2
2626: PPUSH
2627: CALL_OW 12
2631: ARRAY
2632: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2633: LD_INT 0
2635: PPUSH
2636: LD_INT 1
2638: PPUSH
2639: LD_INT 4
2641: PPUSH
2642: CALL_OW 12
2646: PPUSH
2647: LD_INT 8
2649: PPUSH
2650: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2654: LD_ADDR_VAR 0 5
2658: PUSH
2659: LD_VAR 0 5
2663: PUSH
2664: CALL_OW 44
2668: ADD
2669: ST_TO_ADDR
// end ;
2670: GO 2603
2672: POP
2673: POP
// if not debug then
2674: LD_EXP 1
2678: NOT
2679: IFFALSE 2845
// selected = CharacterSelection (  , [ 12 , 11 , 10 ] [ Difficulty ] , [ 12 , 11 , 10 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2681: LD_ADDR_VAR 0 4
2685: PUSH
2686: LD_STRING 
2688: PPUSH
2689: LD_INT 12
2691: PUSH
2692: LD_INT 11
2694: PUSH
2695: LD_INT 10
2697: PUSH
2698: EMPTY
2699: LIST
2700: LIST
2701: LIST
2702: PUSH
2703: LD_OWVAR 67
2707: ARRAY
2708: PPUSH
2709: LD_INT 12
2711: PUSH
2712: LD_INT 11
2714: PUSH
2715: LD_INT 10
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: LIST
2722: PUSH
2723: LD_OWVAR 67
2727: ARRAY
2728: PPUSH
2729: LD_INT -6
2731: PUSH
2732: LD_EXP 6
2736: PUSH
2737: LD_EXP 37
2741: PUSH
2742: LD_EXP 7
2746: PUSH
2747: LD_EXP 21
2751: PUSH
2752: LD_EXP 23
2756: PUSH
2757: LD_INT -2
2759: PUSH
2760: LD_INT -3
2762: PUSH
2763: LD_INT -5
2765: PUSH
2766: EMPTY
2767: LIST
2768: LIST
2769: LIST
2770: LIST
2771: LIST
2772: LIST
2773: LIST
2774: LIST
2775: LIST
2776: PUSH
2777: LD_VAR 0 5
2781: ADD
2782: PPUSH
2783: LD_INT 1
2785: PUSH
2786: LD_INT 4
2788: PUSH
2789: LD_INT 2
2791: PUSH
2792: LD_INT 1
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: LD_INT 3
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 0
2807: PUSH
2808: LD_INT 3
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: LIST
2815: PUSH
2816: LD_INT 9
2818: PUSH
2819: LD_INT 0
2821: PUSH
2822: LD_INT 3
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: PPUSH
2838: CALL_OW 42
2842: ST_TO_ADDR
2843: GO 2924
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
2845: LD_ADDR_VAR 0 4
2849: PUSH
2850: LD_EXP 25
2854: PUSH
2855: LD_EXP 26
2859: PUSH
2860: LD_EXP 27
2864: PUSH
2865: LD_EXP 28
2869: PUSH
2870: LD_EXP 29
2874: PUSH
2875: LD_EXP 30
2879: PUSH
2880: LD_EXP 31
2884: PUSH
2885: LD_EXP 32
2889: PUSH
2890: LD_EXP 33
2894: PUSH
2895: LD_EXP 34
2899: PUSH
2900: LD_EXP 35
2904: PUSH
2905: LD_EXP 36
2909: PUSH
2910: EMPTY
2911: LIST
2912: LIST
2913: LIST
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: LIST
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: ST_TO_ADDR
// uc_nation := 1 ;
2924: LD_ADDR_OWVAR 21
2928: PUSH
2929: LD_INT 1
2931: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
2932: LD_INT 5
2934: PPUSH
2935: LD_INT 3
2937: PPUSH
2938: LD_INT 1
2940: PPUSH
2941: LD_INT 6
2943: PPUSH
2944: LD_INT 100
2946: PPUSH
2947: CALL 46897 0 5
// veh := CreateVehicle ;
2951: LD_ADDR_VAR 0 3
2955: PUSH
2956: CALL_OW 45
2960: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
2961: LD_VAR 0 3
2965: PPUSH
2966: LD_INT 7
2968: NEG
2969: PPUSH
2970: CALL_OW 242
// SetDir ( veh , 3 ) ;
2974: LD_VAR 0 3
2978: PPUSH
2979: LD_INT 3
2981: PPUSH
2982: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
2986: LD_VAR 0 3
2990: PPUSH
2991: LD_INT 31
2993: PPUSH
2994: LD_INT 0
2996: PPUSH
2997: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3001: LD_EXP 6
3005: PPUSH
3006: LD_VAR 0 3
3010: PPUSH
3011: CALL_OW 52
// uc_nation := 3 ;
3015: LD_ADDR_OWVAR 21
3019: PUSH
3020: LD_INT 3
3022: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3023: LD_INT 22
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: LD_INT 1
3031: PPUSH
3032: LD_INT 45
3034: PPUSH
3035: LD_INT 100
3037: PPUSH
3038: CALL 46897 0 5
// veh := CreateVehicle ;
3042: LD_ADDR_VAR 0 3
3046: PUSH
3047: CALL_OW 45
3051: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3052: LD_VAR 0 3
3056: PPUSH
3057: LD_INT 7
3059: NEG
3060: PPUSH
3061: CALL_OW 242
// SetDir ( veh , 3 ) ;
3065: LD_VAR 0 3
3069: PPUSH
3070: LD_INT 3
3072: PPUSH
3073: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3077: LD_VAR 0 3
3081: PPUSH
3082: LD_INT 31
3084: PPUSH
3085: LD_INT 0
3087: PPUSH
3088: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3092: LD_EXP 37
3096: PPUSH
3097: LD_VAR 0 3
3101: PPUSH
3102: CALL_OW 52
// for i in selected do
3106: LD_ADDR_VAR 0 2
3110: PUSH
3111: LD_VAR 0 4
3115: PUSH
3116: FOR_IN
3117: IFFALSE 3675
// begin uc_nation := GetNation ( i ) ;
3119: LD_ADDR_OWVAR 21
3123: PUSH
3124: LD_VAR 0 2
3128: PPUSH
3129: CALL_OW 248
3133: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3134: LD_VAR 0 2
3138: PUSH
3139: LD_EXP 8
3143: PUSH
3144: LD_EXP 9
3148: PUSH
3149: LD_EXP 11
3153: PUSH
3154: LD_EXP 10
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: LIST
3163: LIST
3164: IN
3165: IFFALSE 3188
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3167: LD_INT 5
3169: PPUSH
3170: LD_INT 3
3172: PPUSH
3173: LD_INT 1
3175: PPUSH
3176: LD_INT 6
3178: PPUSH
3179: LD_INT 100
3181: PPUSH
3182: CALL 46897 0 5
3186: GO 3622
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3188: LD_VAR 0 2
3192: PUSH
3193: LD_EXP 30
3197: PUSH
3198: LD_EXP 35
3202: PUSH
3203: LD_EXP 33
3207: PUSH
3208: LD_EXP 25
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: IN
3219: IFFALSE 3250
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3221: LD_INT 24
3223: PPUSH
3224: LD_INT 1
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: LD_INT 46
3232: PPUSH
3233: LD_INT 65
3235: PPUSH
3236: LD_INT 75
3238: PPUSH
3239: CALL_OW 12
3243: PPUSH
3244: CALL 46897 0 5
3248: GO 3622
// if i = Karamazov then
3250: LD_VAR 0 2
3254: PUSH
3255: LD_EXP 36
3259: EQUAL
3260: IFFALSE 3283
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3262: LD_INT 22
3264: PPUSH
3265: LD_INT 3
3267: PPUSH
3268: LD_INT 1
3270: PPUSH
3271: LD_INT 52
3273: PPUSH
3274: LD_INT 100
3276: PPUSH
3277: CALL 46897 0 5
3281: GO 3622
// if i = Brown then
3283: LD_VAR 0 2
3287: PUSH
3288: LD_EXP 13
3292: EQUAL
3293: IFFALSE 3316
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3295: LD_INT 3
3297: PPUSH
3298: LD_INT 3
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: LD_INT 13
3306: PPUSH
3307: LD_INT 100
3309: PPUSH
3310: CALL 46897 0 5
3314: GO 3622
// if uc_nation = nation_american then
3316: LD_OWVAR 21
3320: PUSH
3321: LD_INT 1
3323: EQUAL
3324: IFFALSE 3475
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3326: LD_INT 3
3328: PUSH
3329: LD_INT 5
3331: PUSH
3332: LD_INT 5
3334: PUSH
3335: EMPTY
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: LD_OWVAR 21
3344: PUSH
3345: LD_INT 3
3347: MOD
3348: PUSH
3349: LD_INT 1
3351: PLUS
3352: ARRAY
3353: PPUSH
3354: LD_INT 1
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 1
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: PUSH
3368: LD_OWVAR 21
3372: PUSH
3373: LD_INT 3
3375: MOD
3376: PUSH
3377: LD_INT 1
3379: PLUS
3380: ARRAY
3381: PPUSH
3382: LD_INT 1
3384: PPUSH
3385: LD_INT 11
3387: PUSH
3388: LD_INT 4
3390: PUSH
3391: LD_INT 5
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_INT 6
3401: PUSH
3402: LD_INT 7
3404: PUSH
3405: LD_INT 9
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 6
3415: PUSH
3416: LD_INT 9
3418: PUSH
3419: LD_INT 12
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: PUSH
3432: LD_OWVAR 21
3436: PUSH
3437: LD_INT 3
3439: MOD
3440: PUSH
3441: LD_INT 1
3443: PLUS
3444: ARRAY
3445: PUSH
3446: LD_INT 1
3448: PPUSH
3449: LD_INT 3
3451: PPUSH
3452: CALL_OW 12
3456: ARRAY
3457: PPUSH
3458: LD_INT 65
3460: PPUSH
3461: LD_INT 75
3463: PPUSH
3464: CALL_OW 12
3468: PPUSH
3469: CALL 46897 0 5
// end else
3473: GO 3622
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3475: LD_INT 22
3477: PUSH
3478: LD_INT 23
3480: PUSH
3481: LD_INT 23
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_OWVAR 21
3493: PUSH
3494: LD_INT 3
3496: MOD
3497: PUSH
3498: LD_INT 1
3500: PLUS
3501: ARRAY
3502: PPUSH
3503: LD_INT 1
3505: PUSH
3506: LD_INT 3
3508: PUSH
3509: LD_INT 1
3511: PUSH
3512: EMPTY
3513: LIST
3514: LIST
3515: LIST
3516: PUSH
3517: LD_OWVAR 21
3521: PUSH
3522: LD_INT 3
3524: MOD
3525: PUSH
3526: LD_INT 1
3528: PLUS
3529: ARRAY
3530: PPUSH
3531: LD_INT 1
3533: PPUSH
3534: LD_INT 45
3536: PUSH
3537: LD_INT 43
3539: PUSH
3540: LD_INT 44
3542: PUSH
3543: EMPTY
3544: LIST
3545: LIST
3546: LIST
3547: PUSH
3548: LD_INT 46
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: LD_INT 44
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: PUSH
3562: LD_INT 46
3564: PUSH
3565: LD_INT 43
3567: PUSH
3568: LD_INT 45
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: PUSH
3576: EMPTY
3577: LIST
3578: LIST
3579: LIST
3580: PUSH
3581: LD_OWVAR 21
3585: PUSH
3586: LD_INT 3
3588: MOD
3589: PUSH
3590: LD_INT 1
3592: PLUS
3593: ARRAY
3594: PUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 3
3600: PPUSH
3601: CALL_OW 12
3605: ARRAY
3606: PPUSH
3607: LD_INT 65
3609: PPUSH
3610: LD_INT 75
3612: PPUSH
3613: CALL_OW 12
3617: PPUSH
3618: CALL 46897 0 5
// end ; veh := CreateVehicle ;
3622: LD_ADDR_VAR 0 3
3626: PUSH
3627: CALL_OW 45
3631: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 3
3639: PPUSH
3640: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 30
3651: PPUSH
3652: LD_INT 0
3654: PPUSH
3655: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
3659: LD_VAR 0 2
3663: PPUSH
3664: LD_VAR 0 3
3668: PPUSH
3669: CALL_OW 52
// end ;
3673: GO 3116
3675: POP
3676: POP
// if LoadVariable ( 11_artifact_captured , 0 ) then
3677: LD_STRING 11_artifact_captured
3679: PPUSH
3680: LD_INT 0
3682: PPUSH
3683: CALL_OW 30
3687: IFFALSE 3773
// begin uc_nation := nation_american ;
3689: LD_ADDR_OWVAR 21
3693: PUSH
3694: LD_INT 1
3696: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3697: LD_INT 3
3699: PPUSH
3700: LD_INT 3
3702: PPUSH
3703: LD_INT 3
3705: PPUSH
3706: LD_INT 12
3708: PPUSH
3709: LD_INT 100
3711: PPUSH
3712: CALL 46897 0 5
// veh := CreateVehicle ;
3716: LD_ADDR_VAR 0 3
3720: PUSH
3721: CALL_OW 45
3725: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3726: LD_VAR 0 3
3730: PPUSH
3731: LD_INT 3
3733: PPUSH
3734: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
3738: LD_VAR 0 3
3742: PPUSH
3743: LD_INT 198
3745: PPUSH
3746: LD_INT 22
3748: PPUSH
3749: LD_INT 0
3751: PPUSH
3752: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
3756: LD_VAR 0 3
3760: PPUSH
3761: LD_INT 4
3763: PPUSH
3764: LD_INT 50
3766: PPUSH
3767: CALL_OW 290
// end else
3771: GO 3792
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
3773: LD_INT 4
3775: PPUSH
3776: LD_INT 267
3778: PPUSH
3779: LD_INT 226
3781: PPUSH
3782: LD_INT 5
3784: PPUSH
3785: LD_INT 0
3787: PPUSH
3788: CALL_OW 58
// end ; uc_nation := nation_american ;
3792: LD_ADDR_OWVAR 21
3796: PUSH
3797: LD_INT 1
3799: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3800: LD_INT 3
3802: PPUSH
3803: LD_INT 3
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 12
3811: PPUSH
3812: LD_INT 100
3814: PPUSH
3815: CALL 46897 0 5
// veh := CreateVehicle ;
3819: LD_ADDR_VAR 0 3
3823: PUSH
3824: CALL_OW 45
3828: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
3841: LD_VAR 0 3
3845: PPUSH
3846: LD_INT 218
3848: PPUSH
3849: LD_INT 23
3851: PPUSH
3852: LD_INT 0
3854: PPUSH
3855: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
3859: LD_VAR 0 3
3863: PPUSH
3864: LD_INT 4
3866: PPUSH
3867: LD_INT 30
3869: PPUSH
3870: CALL_OW 290
// uc_nation := nation_russian ;
3874: LD_ADDR_OWVAR 21
3878: PUSH
3879: LD_INT 3
3881: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
3882: LD_INT 22
3884: PPUSH
3885: LD_INT 3
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 51
3893: PPUSH
3894: LD_INT 100
3896: PPUSH
3897: CALL 46897 0 5
// veh := CreateVehicle ;
3901: LD_ADDR_VAR 0 3
3905: PUSH
3906: CALL_OW 45
3910: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3911: LD_VAR 0 3
3915: PPUSH
3916: LD_INT 3
3918: PPUSH
3919: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
3923: LD_VAR 0 3
3927: PPUSH
3928: LD_INT 214
3930: PPUSH
3931: LD_INT 20
3933: PPUSH
3934: LD_INT 0
3936: PPUSH
3937: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
3941: LD_VAR 0 3
3945: PPUSH
3946: LD_INT 4
3948: PPUSH
3949: LD_INT 40
3951: PPUSH
3952: CALL_OW 290
// end ; end_of_file
3956: LD_VAR 0 1
3960: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
3961: LD_INT 0
3963: PPUSH
3964: PPUSH
3965: PPUSH
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 1 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 1
3980: ST_TO_ADDR
// uc_nation := 1 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 1
3988: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
3989: LD_INT 387
3991: PPUSH
3992: CALL_OW 274
3996: PPUSH
3997: LD_INT 1
3999: PPUSH
4000: LD_INT 25500
4002: PPUSH
4003: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4007: LD_INT 387
4009: PPUSH
4010: CALL_OW 274
4014: PPUSH
4015: LD_INT 2
4017: PPUSH
4018: LD_INT 4000
4020: PPUSH
4021: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4025: LD_INT 387
4027: PPUSH
4028: CALL_OW 274
4032: PPUSH
4033: LD_INT 3
4035: PPUSH
4036: LD_INT 50
4038: PPUSH
4039: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4043: LD_INT 476
4045: PPUSH
4046: CALL_OW 274
4050: PPUSH
4051: LD_INT 1
4053: PPUSH
4054: LD_INT 7500
4056: PPUSH
4057: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4061: LD_INT 476
4063: PPUSH
4064: CALL_OW 274
4068: PPUSH
4069: LD_INT 2
4071: PPUSH
4072: LD_INT 4000
4074: PPUSH
4075: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4079: LD_INT 476
4081: PPUSH
4082: CALL_OW 274
4086: PPUSH
4087: LD_INT 3
4089: PPUSH
4090: LD_INT 10
4092: PPUSH
4093: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4097: LD_ADDR_EXP 40
4101: PUSH
4102: LD_STRING Powell
4104: PPUSH
4105: CALL_OW 25
4109: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4110: LD_EXP 40
4114: PPUSH
4115: LD_INT 57
4117: PPUSH
4118: LD_INT 94
4120: PPUSH
4121: LD_INT 0
4123: PPUSH
4124: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4128: LD_EXP 40
4132: PPUSH
4133: LD_INT 58
4135: PPUSH
4136: LD_INT 94
4138: PPUSH
4139: CALL_OW 118
// tmp := [ ] ;
4143: LD_ADDR_VAR 0 6
4147: PUSH
4148: EMPTY
4149: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4150: LD_ADDR_EXP 8
4154: PUSH
4155: LD_STRING Lisa
4157: PPUSH
4158: LD_EXP 1
4162: NOT
4163: PPUSH
4164: LD_STRING 12p_
4166: PPUSH
4167: CALL 40146 0 3
4171: ST_TO_ADDR
// if Lisa then
4172: LD_EXP 8
4176: IFFALSE 4194
// tmp := tmp ^ Lisa ;
4178: LD_ADDR_VAR 0 6
4182: PUSH
4183: LD_VAR 0 6
4187: PUSH
4188: LD_EXP 8
4192: ADD
4193: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4194: LD_ADDR_EXP 9
4198: PUSH
4199: LD_STRING Donaldson
4201: PPUSH
4202: LD_EXP 1
4206: NOT
4207: PPUSH
4208: LD_STRING 12p_
4210: PPUSH
4211: CALL 40146 0 3
4215: ST_TO_ADDR
// if Donaldson then
4216: LD_EXP 9
4220: IFFALSE 4238
// tmp := tmp ^ Donaldson ;
4222: LD_ADDR_VAR 0 6
4226: PUSH
4227: LD_VAR 0 6
4231: PUSH
4232: LD_EXP 9
4236: ADD
4237: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4238: LD_ADDR_EXP 10
4242: PUSH
4243: LD_STRING Bobby
4245: PPUSH
4246: LD_EXP 1
4250: NOT
4251: PPUSH
4252: LD_STRING 12p_
4254: PPUSH
4255: CALL 40146 0 3
4259: ST_TO_ADDR
// if Bobby then
4260: LD_EXP 10
4264: IFFALSE 4282
// tmp := tmp ^ Bobby ;
4266: LD_ADDR_VAR 0 6
4270: PUSH
4271: LD_VAR 0 6
4275: PUSH
4276: LD_EXP 10
4280: ADD
4281: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4282: LD_ADDR_EXP 11
4286: PUSH
4287: LD_STRING Cyrus
4289: PPUSH
4290: LD_EXP 1
4294: NOT
4295: PPUSH
4296: LD_STRING 12p_
4298: PPUSH
4299: CALL 40146 0 3
4303: ST_TO_ADDR
// if Cyrus then
4304: LD_EXP 11
4308: IFFALSE 4326
// tmp := tmp ^ Cyrus ;
4310: LD_ADDR_VAR 0 6
4314: PUSH
4315: LD_VAR 0 6
4319: PUSH
4320: LD_EXP 11
4324: ADD
4325: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4326: LD_ADDR_EXP 13
4330: PUSH
4331: LD_STRING Brown
4333: PPUSH
4334: LD_EXP 1
4338: NOT
4339: PPUSH
4340: LD_STRING 12p_
4342: PPUSH
4343: CALL 40146 0 3
4347: ST_TO_ADDR
// if Brown then
4348: LD_EXP 13
4352: IFFALSE 4370
// tmp := tmp ^ Brown ;
4354: LD_ADDR_VAR 0 6
4358: PUSH
4359: LD_VAR 0 6
4363: PUSH
4364: LD_EXP 13
4368: ADD
4369: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4370: LD_ADDR_EXP 14
4374: PUSH
4375: LD_STRING Gladstone
4377: PPUSH
4378: LD_EXP 1
4382: NOT
4383: PPUSH
4384: LD_STRING 12p_
4386: PPUSH
4387: CALL 40146 0 3
4391: ST_TO_ADDR
// if Gladstone then
4392: LD_EXP 14
4396: IFFALSE 4414
// tmp := tmp ^ Gladstone ;
4398: LD_ADDR_VAR 0 6
4402: PUSH
4403: LD_VAR 0 6
4407: PUSH
4408: LD_EXP 14
4412: ADD
4413: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4414: LD_ADDR_EXP 15
4418: PUSH
4419: LD_STRING Houten
4421: PPUSH
4422: LD_EXP 1
4426: NOT
4427: PPUSH
4428: LD_STRING 12p_
4430: PPUSH
4431: CALL 40146 0 3
4435: ST_TO_ADDR
// if Houten then
4436: LD_EXP 15
4440: IFFALSE 4458
// tmp := tmp ^ Houten ;
4442: LD_ADDR_VAR 0 6
4446: PUSH
4447: LD_VAR 0 6
4451: PUSH
4452: LD_EXP 15
4456: ADD
4457: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4458: LD_ADDR_EXP 16
4462: PUSH
4463: LD_STRING Cornel
4465: PPUSH
4466: LD_EXP 1
4470: NOT
4471: PPUSH
4472: LD_STRING 12p_
4474: PPUSH
4475: CALL 40146 0 3
4479: ST_TO_ADDR
// if Cornel then
4480: LD_EXP 16
4484: IFFALSE 4502
// tmp := tmp ^ Cornel ;
4486: LD_ADDR_VAR 0 6
4490: PUSH
4491: LD_VAR 0 6
4495: PUSH
4496: LD_EXP 16
4500: ADD
4501: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
4502: LD_ADDR_EXP 17
4506: PUSH
4507: LD_STRING Gary
4509: PPUSH
4510: LD_EXP 1
4514: NOT
4515: PPUSH
4516: LD_STRING 12p_
4518: PPUSH
4519: CALL 40146 0 3
4523: ST_TO_ADDR
// if Gary then
4524: LD_EXP 17
4528: IFFALSE 4546
// tmp := tmp ^ Gary ;
4530: LD_ADDR_VAR 0 6
4534: PUSH
4535: LD_VAR 0 6
4539: PUSH
4540: LD_EXP 17
4544: ADD
4545: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
4546: LD_ADDR_EXP 19
4550: PUSH
4551: LD_STRING Kikuchi
4553: PPUSH
4554: LD_EXP 1
4558: NOT
4559: PPUSH
4560: LD_STRING 12p_
4562: PPUSH
4563: CALL 40146 0 3
4567: ST_TO_ADDR
// if Kikuchi then
4568: LD_EXP 19
4572: IFFALSE 4590
// tmp := tmp ^ Kikuchi ;
4574: LD_ADDR_VAR 0 6
4578: PUSH
4579: LD_VAR 0 6
4583: PUSH
4584: LD_EXP 19
4588: ADD
4589: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
4590: LD_ADDR_VAR 0 6
4594: PUSH
4595: LD_VAR 0 6
4599: PUSH
4600: LD_STRING 12p_others
4602: PPUSH
4603: CALL_OW 31
4607: UNION
4608: ST_TO_ADDR
// if tmp < 36 then
4609: LD_VAR 0 6
4613: PUSH
4614: LD_INT 36
4616: LESS
4617: IFFALSE 4684
// for i = 1 to 36 - tmp do
4619: LD_ADDR_VAR 0 2
4623: PUSH
4624: DOUBLE
4625: LD_INT 1
4627: DEC
4628: ST_TO_ADDR
4629: LD_INT 36
4631: PUSH
4632: LD_VAR 0 6
4636: MINUS
4637: PUSH
4638: FOR_TO
4639: IFFALSE 4682
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
4641: LD_INT 1
4643: PPUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_INT 4
4651: MOD
4652: PUSH
4653: LD_INT 1
4655: PLUS
4656: PPUSH
4657: LD_INT 10
4659: PPUSH
4660: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4664: LD_ADDR_VAR 0 6
4668: PUSH
4669: LD_VAR 0 6
4673: PUSH
4674: CALL_OW 44
4678: ADD
4679: ST_TO_ADDR
// end ;
4680: GO 4638
4682: POP
4683: POP
// for i in tmp do
4684: LD_ADDR_VAR 0 2
4688: PUSH
4689: LD_VAR 0 6
4693: PUSH
4694: FOR_IN
4695: IFFALSE 4720
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
4697: LD_VAR 0 2
4701: PPUSH
4702: LD_INT 62
4704: PPUSH
4705: LD_INT 93
4707: PPUSH
4708: LD_INT 9
4710: PPUSH
4711: LD_INT 0
4713: PPUSH
4714: CALL_OW 50
4718: GO 4694
4720: POP
4721: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
4722: LD_ADDR_EXP 56
4726: PUSH
4727: LD_EXP 56
4731: PPUSH
4732: LD_INT 4
4734: PPUSH
4735: LD_INT 22
4737: PUSH
4738: LD_INT 1
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PPUSH
4745: CALL_OW 69
4749: PPUSH
4750: CALL_OW 1
4754: ST_TO_ADDR
// uc_side := 0 ;
4755: LD_ADDR_OWVAR 20
4759: PUSH
4760: LD_INT 0
4762: ST_TO_ADDR
// uc_nation := 0 ;
4763: LD_ADDR_OWVAR 21
4767: PUSH
4768: LD_INT 0
4770: ST_TO_ADDR
// for i = 1 to 4 do
4771: LD_ADDR_VAR 0 2
4775: PUSH
4776: DOUBLE
4777: LD_INT 1
4779: DEC
4780: ST_TO_ADDR
4781: LD_INT 4
4783: PUSH
4784: FOR_TO
4785: IFFALSE 4816
// begin InitHc ;
4787: CALL_OW 19
// hc_class := class_apeman ;
4791: LD_ADDR_OWVAR 28
4795: PUSH
4796: LD_INT 12
4798: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4799: CALL_OW 44
4803: PPUSH
4804: LD_INT 11
4806: PPUSH
4807: LD_INT 0
4809: PPUSH
4810: CALL_OW 49
// end ;
4814: GO 4784
4816: POP
4817: POP
// end ;
4818: LD_VAR 0 1
4822: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
4823: LD_EXP 4
4827: NOT
4828: PUSH
4829: LD_INT 4
4831: PPUSH
4832: LD_INT 1
4834: PPUSH
4835: CALL 35442 0 2
4839: NOT
4840: AND
4841: IFFALSE 5613
4843: GO 4845
4845: DISABLE
4846: LD_INT 0
4848: PPUSH
4849: PPUSH
4850: PPUSH
// begin enable ;
4851: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
4852: LD_INT 22
4854: PUSH
4855: LD_INT 1
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 23
4864: PUSH
4865: LD_INT 1
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: LD_INT 30
4874: PUSH
4875: LD_INT 3
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: LIST
4886: PPUSH
4887: CALL_OW 69
4891: NOT
4892: IFFALSE 4896
// exit ;
4894: GO 5613
// if Prob ( 40 ) then
4896: LD_INT 40
4898: PPUSH
4899: CALL_OW 13
4903: IFFALSE 5030
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
4905: LD_INT 4
4907: PPUSH
4908: LD_INT 5
4910: PUSH
4911: LD_INT 1
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: LD_INT 7
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 5
4928: PUSH
4929: LD_INT 1
4931: PUSH
4932: LD_INT 2
4934: PUSH
4935: LD_INT 7
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 5
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: LD_INT 2
4952: PUSH
4953: LD_INT 7
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 5
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: LD_INT 2
4970: PUSH
4971: LD_INT 6
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 5
4982: PUSH
4983: LD_INT 1
4985: PUSH
4986: LD_INT 2
4988: PUSH
4989: LD_INT 6
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 5
5000: PUSH
5001: LD_INT 1
5003: PUSH
5004: LD_INT 2
5006: PUSH
5007: LD_INT 6
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: PPUSH
5024: CALL 34024 0 2
// end else
5028: GO 5153
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5030: LD_INT 4
5032: PPUSH
5033: LD_INT 5
5035: PUSH
5036: LD_INT 1
5038: PUSH
5039: LD_INT 2
5041: PUSH
5042: LD_INT 7
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 5
5053: PUSH
5054: LD_INT 1
5056: PUSH
5057: LD_INT 2
5059: PUSH
5060: LD_INT 9
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 5
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: LD_INT 2
5077: PUSH
5078: LD_INT 9
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 5
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: LD_INT 2
5095: PUSH
5096: LD_INT 6
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 5
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: LD_INT 2
5113: PUSH
5114: LD_INT 6
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: PUSH
5123: LD_INT 5
5125: PUSH
5126: LD_INT 1
5128: PUSH
5129: LD_INT 2
5131: PUSH
5132: LD_INT 6
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: PPUSH
5149: CALL 34024 0 2
// end ; repeat wait ( 0 0$1 ) ;
5153: LD_INT 35
5155: PPUSH
5156: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5160: LD_INT 4
5162: PPUSH
5163: LD_INT 1
5165: PPUSH
5166: CALL 35442 0 2
5170: PUSH
5171: LD_INT 6
5173: GREATEREQUAL
5174: IFFALSE 5153
// wait ( 0 0$30 ) ;
5176: LD_INT 1050
5178: PPUSH
5179: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5183: LD_ADDR_VAR 0 2
5187: PUSH
5188: LD_INT 4
5190: PPUSH
5191: LD_INT 1
5193: PPUSH
5194: CALL 35442 0 2
5198: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5199: LD_ADDR_EXP 75
5203: PUSH
5204: LD_EXP 75
5208: PPUSH
5209: LD_INT 4
5211: PPUSH
5212: LD_EXP 75
5216: PUSH
5217: LD_INT 4
5219: ARRAY
5220: PUSH
5221: LD_VAR 0 2
5225: DIFF
5226: PPUSH
5227: CALL_OW 1
5231: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5232: LD_ADDR_VAR 0 3
5236: PUSH
5237: LD_INT 0
5239: PPUSH
5240: LD_INT 2
5242: PPUSH
5243: CALL_OW 12
5247: ST_TO_ADDR
// if target then
5248: LD_VAR 0 3
5252: IFFALSE 5380
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5254: LD_ADDR_VAR 0 2
5258: PUSH
5259: LD_VAR 0 2
5263: PPUSH
5264: LD_INT 24
5266: PUSH
5267: LD_INT 250
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: PPUSH
5274: CALL_OW 72
5278: ST_TO_ADDR
// for i in tmp do
5279: LD_ADDR_VAR 0 1
5283: PUSH
5284: LD_VAR 0 2
5288: PUSH
5289: FOR_IN
5290: IFFALSE 5330
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5292: LD_VAR 0 1
5296: PPUSH
5297: LD_INT 114
5299: PPUSH
5300: LD_INT 108
5302: PPUSH
5303: CALL_OW 297
5307: PUSH
5308: LD_INT 9
5310: GREATER
5311: IFFALSE 5328
// ComMoveXY ( i , 114 , 108 ) ;
5313: LD_VAR 0 1
5317: PPUSH
5318: LD_INT 114
5320: PPUSH
5321: LD_INT 108
5323: PPUSH
5324: CALL_OW 111
5328: GO 5289
5330: POP
5331: POP
// wait ( 0 0$1 ) ;
5332: LD_INT 35
5334: PPUSH
5335: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5339: LD_VAR 0 2
5343: PPUSH
5344: LD_INT 92
5346: PUSH
5347: LD_INT 114
5349: PUSH
5350: LD_INT 108
5352: PUSH
5353: LD_INT 9
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: LIST
5360: LIST
5361: PPUSH
5362: CALL_OW 72
5366: PUSH
5367: LD_VAR 0 2
5371: PUSH
5372: LD_INT 1
5374: MINUS
5375: GREATEREQUAL
5376: IFFALSE 5254
// end else
5378: GO 5504
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5380: LD_ADDR_VAR 0 2
5384: PUSH
5385: LD_VAR 0 2
5389: PPUSH
5390: LD_INT 24
5392: PUSH
5393: LD_INT 250
5395: PUSH
5396: EMPTY
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 72
5404: ST_TO_ADDR
// for i in tmp do
5405: LD_ADDR_VAR 0 1
5409: PUSH
5410: LD_VAR 0 2
5414: PUSH
5415: FOR_IN
5416: IFFALSE 5456
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5418: LD_VAR 0 1
5422: PPUSH
5423: LD_INT 129
5425: PPUSH
5426: LD_INT 139
5428: PPUSH
5429: CALL_OW 297
5433: PUSH
5434: LD_INT 9
5436: GREATER
5437: IFFALSE 5454
// ComMoveXY ( i , 129 , 139 ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_INT 129
5446: PPUSH
5447: LD_INT 139
5449: PPUSH
5450: CALL_OW 111
5454: GO 5415
5456: POP
5457: POP
// wait ( 0 0$1 ) ;
5458: LD_INT 35
5460: PPUSH
5461: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5465: LD_VAR 0 2
5469: PPUSH
5470: LD_INT 92
5472: PUSH
5473: LD_INT 129
5475: PUSH
5476: LD_INT 139
5478: PUSH
5479: LD_INT 9
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: PPUSH
5488: CALL_OW 72
5492: PUSH
5493: LD_VAR 0 2
5497: PUSH
5498: LD_INT 1
5500: MINUS
5501: GREATEREQUAL
5502: IFFALSE 5380
// end ; repeat wait ( 0 0$1 ) ;
5504: LD_INT 35
5506: PPUSH
5507: CALL_OW 67
// for i in tmp do
5511: LD_ADDR_VAR 0 1
5515: PUSH
5516: LD_VAR 0 2
5520: PUSH
5521: FOR_IN
5522: IFFALSE 5604
// begin if GetLives ( i ) > 251 then
5524: LD_VAR 0 1
5528: PPUSH
5529: CALL_OW 256
5533: PUSH
5534: LD_INT 251
5536: GREATER
5537: IFFALSE 5575
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
5539: LD_VAR 0 1
5543: PPUSH
5544: LD_INT 81
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PPUSH
5554: CALL_OW 69
5558: PPUSH
5559: LD_VAR 0 1
5563: PPUSH
5564: CALL_OW 74
5568: PPUSH
5569: CALL_OW 115
5573: GO 5602
// if IsDead ( i ) then
5575: LD_VAR 0 1
5579: PPUSH
5580: CALL_OW 301
5584: IFFALSE 5602
// tmp := tmp diff i ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: LD_VAR 0 2
5595: PUSH
5596: LD_VAR 0 1
5600: DIFF
5601: ST_TO_ADDR
// end ;
5602: GO 5521
5604: POP
5605: POP
// until not tmp ;
5606: LD_VAR 0 2
5610: NOT
5611: IFFALSE 5504
// end ; end_of_file
5613: PPOPN 3
5615: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
5616: LD_INT 0
5618: PPUSH
5619: PPUSH
5620: PPUSH
5621: PPUSH
5622: PPUSH
// side := 2 ;
5623: LD_ADDR_VAR 0 5
5627: PUSH
5628: LD_INT 2
5630: ST_TO_ADDR
// uc_side := side ;
5631: LD_ADDR_OWVAR 20
5635: PUSH
5636: LD_VAR 0 5
5640: ST_TO_ADDR
// uc_nation := 2 ;
5641: LD_ADDR_OWVAR 21
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
5649: LD_ADDR_VAR 0 4
5653: PUSH
5654: LD_INT 22
5656: PUSH
5657: LD_VAR 0 5
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: LD_INT 30
5668: PUSH
5669: LD_INT 32
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: PUSH
5676: LD_INT 58
5678: PUSH
5679: EMPTY
5680: LIST
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: LIST
5686: PPUSH
5687: CALL_OW 69
5691: ST_TO_ADDR
// for i = 1 to 10 do
5692: LD_ADDR_VAR 0 2
5696: PUSH
5697: DOUBLE
5698: LD_INT 1
5700: DEC
5701: ST_TO_ADDR
5702: LD_INT 10
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5778
// begin uc_nation := nation_nature ;
5708: LD_ADDR_OWVAR 21
5712: PUSH
5713: LD_INT 0
5715: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5716: LD_ADDR_OWVAR 28
5720: PUSH
5721: LD_INT 15
5723: ST_TO_ADDR
// hc_gallery :=  ;
5724: LD_ADDR_OWVAR 33
5728: PUSH
5729: LD_STRING 
5731: ST_TO_ADDR
// hc_name :=  ;
5732: LD_ADDR_OWVAR 26
5736: PUSH
5737: LD_STRING 
5739: ST_TO_ADDR
// un := CreateHuman ;
5740: LD_ADDR_VAR 0 3
5744: PUSH
5745: CALL_OW 44
5749: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5750: LD_VAR 0 3
5754: PPUSH
5755: LD_VAR 0 4
5759: PUSH
5760: LD_VAR 0 4
5764: PUSH
5765: LD_VAR 0 2
5769: MINUS
5770: ARRAY
5771: PPUSH
5772: CALL_OW 52
// end ;
5776: GO 5705
5778: POP
5779: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
5780: LD_INT 503
5782: PPUSH
5783: LD_INT 27
5785: PPUSH
5786: LD_STRING 
5788: PPUSH
5789: LD_INT 8
5791: PUSH
5792: LD_INT 9
5794: PUSH
5795: LD_INT 10
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PPUSH
5809: LD_INT 3000
5811: PUSH
5812: LD_INT 500
5814: PUSH
5815: LD_INT 150
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: PPUSH
5823: LD_INT 16
5825: PUSH
5826: LD_INT 6
5828: PUSH
5829: LD_INT 6
5831: PUSH
5832: LD_INT 6
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: LIST
5839: LIST
5840: PPUSH
5841: CALL 50306 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
5845: LD_ADDR_EXP 56
5849: PUSH
5850: LD_EXP 56
5854: PPUSH
5855: LD_INT 1
5857: PPUSH
5858: LD_INT 22
5860: PUSH
5861: LD_VAR 0 5
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 23
5872: PUSH
5873: LD_INT 2
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 3
5882: PUSH
5883: LD_INT 21
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: PPUSH
5902: CALL_OW 69
5906: PPUSH
5907: CALL_OW 1
5911: ST_TO_ADDR
// end ; end_of_file
5912: LD_VAR 0 1
5916: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
5917: LD_INT 0
5919: PPUSH
5920: PPUSH
5921: PPUSH
5922: PPUSH
5923: PPUSH
// side := 8 ;
5924: LD_ADDR_VAR 0 3
5928: PUSH
5929: LD_INT 8
5931: ST_TO_ADDR
// uc_side := side ;
5932: LD_ADDR_OWVAR 20
5936: PUSH
5937: LD_VAR 0 3
5941: ST_TO_ADDR
// uc_nation := 2 ;
5942: LD_ADDR_OWVAR 21
5946: PUSH
5947: LD_INT 2
5949: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
5950: LD_ADDR_VAR 0 2
5954: PUSH
5955: LD_INT 22
5957: PUSH
5958: LD_VAR 0 3
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 21
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: PPUSH
5981: CALL_OW 69
5985: PUSH
5986: FOR_IN
5987: IFFALSE 6003
// SetBLevel ( i , 10 ) ;
5989: LD_VAR 0 2
5993: PPUSH
5994: LD_INT 10
5996: PPUSH
5997: CALL_OW 241
6001: GO 5986
6003: POP
6004: POP
// Schulz := PrepareUnit ( Schulz , false ,  ) ;
6005: LD_ADDR_EXP 41
6009: PUSH
6010: LD_STRING Schulz
6012: PPUSH
6013: LD_INT 0
6015: PPUSH
6016: LD_STRING 
6018: PPUSH
6019: CALL 40146 0 3
6023: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6024: LD_ADDR_EXP 42
6028: PUSH
6029: LD_STRING Kozlov
6031: PPUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_STRING 
6037: PPUSH
6038: CALL 40146 0 3
6042: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6043: LD_EXP 42
6047: PPUSH
6048: LD_INT 22
6050: PUSH
6051: LD_INT 8
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 23
6060: PUSH
6061: LD_INT 3
6063: PUSH
6064: EMPTY
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 30
6070: PUSH
6071: LD_INT 8
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: PPUSH
6083: CALL_OW 69
6087: PUSH
6088: LD_INT 1
6090: ARRAY
6091: PPUSH
6092: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6096: LD_EXP 42
6100: PPUSH
6101: LD_INT 3
6103: PPUSH
6104: LD_INT 10
6106: PPUSH
6107: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6111: LD_ADDR_VAR 0 5
6115: PUSH
6116: LD_INT 22
6118: PUSH
6119: LD_VAR 0 3
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 30
6130: PUSH
6131: LD_INT 32
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 58
6140: PUSH
6141: EMPTY
6142: LIST
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: LIST
6148: PPUSH
6149: CALL_OW 69
6153: ST_TO_ADDR
// for i = 1 to 10 do
6154: LD_ADDR_VAR 0 2
6158: PUSH
6159: DOUBLE
6160: LD_INT 1
6162: DEC
6163: ST_TO_ADDR
6164: LD_INT 10
6166: PUSH
6167: FOR_TO
6168: IFFALSE 6240
// begin uc_nation := nation_nature ;
6170: LD_ADDR_OWVAR 21
6174: PUSH
6175: LD_INT 0
6177: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6178: LD_ADDR_OWVAR 28
6182: PUSH
6183: LD_INT 15
6185: ST_TO_ADDR
// hc_gallery :=  ;
6186: LD_ADDR_OWVAR 33
6190: PUSH
6191: LD_STRING 
6193: ST_TO_ADDR
// hc_name :=  ;
6194: LD_ADDR_OWVAR 26
6198: PUSH
6199: LD_STRING 
6201: ST_TO_ADDR
// un := CreateHuman ;
6202: LD_ADDR_VAR 0 4
6206: PUSH
6207: CALL_OW 44
6211: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6212: LD_VAR 0 4
6216: PPUSH
6217: LD_VAR 0 5
6221: PUSH
6222: LD_VAR 0 5
6226: PUSH
6227: LD_VAR 0 2
6231: MINUS
6232: ARRAY
6233: PPUSH
6234: CALL_OW 52
// end ;
6238: GO 6167
6240: POP
6241: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6242: LD_INT 324
6244: PPUSH
6245: LD_INT 3
6247: PPUSH
6248: LD_STRING 
6250: PPUSH
6251: LD_INT 8
6253: PUSH
6254: LD_INT 9
6256: PUSH
6257: LD_INT 10
6259: PUSH
6260: EMPTY
6261: LIST
6262: LIST
6263: LIST
6264: PUSH
6265: LD_OWVAR 67
6269: ARRAY
6270: PPUSH
6271: LD_INT 3000
6273: PUSH
6274: LD_INT 500
6276: PUSH
6277: LD_INT 150
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: PPUSH
6285: LD_INT 16
6287: PUSH
6288: LD_INT 6
6290: PUSH
6291: LD_INT 6
6293: PUSH
6294: LD_INT 8
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: PPUSH
6303: CALL 50306 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6307: LD_ADDR_EXP 56
6311: PUSH
6312: LD_EXP 56
6316: PPUSH
6317: LD_INT 3
6319: PPUSH
6320: LD_INT 22
6322: PUSH
6323: LD_VAR 0 3
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PUSH
6332: LD_INT 23
6334: PUSH
6335: LD_INT 2
6337: PUSH
6338: EMPTY
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 3
6344: PUSH
6345: LD_INT 21
6347: PUSH
6348: LD_INT 2
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: PPUSH
6364: CALL_OW 69
6368: PUSH
6369: LD_EXP 41
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// end ;
6380: LD_VAR 0 1
6384: RET
// export function BuildKozlovBomb ; begin
6385: LD_INT 0
6387: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
6388: LD_INT 332
6390: PPUSH
6391: CALL_OW 302
6395: NOT
6396: PUSH
6397: LD_INT 336
6399: PPUSH
6400: CALL_OW 302
6404: NOT
6405: OR
6406: IFFALSE 6410
// exit ;
6408: GO 6507
// ComChangeProfession ( Kozlov , 4 ) ;
6410: LD_EXP 42
6414: PPUSH
6415: LD_INT 4
6417: PPUSH
6418: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
6422: LD_INT 336
6424: PPUSH
6425: LD_INT 25
6427: PPUSH
6428: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
6432: LD_INT 35
6434: PPUSH
6435: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
6439: LD_INT 25
6441: PPUSH
6442: LD_INT 8
6444: PPUSH
6445: CALL_OW 321
6449: PUSH
6450: LD_INT 2
6452: EQUAL
6453: IFFALSE 6432
// ComExitBuilding ( Kozlov ) ;
6455: LD_EXP 42
6459: PPUSH
6460: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
6464: LD_EXP 42
6468: PPUSH
6469: LD_INT 332
6471: PPUSH
6472: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
6476: LD_EXP 42
6480: PPUSH
6481: LD_INT 3
6483: PPUSH
6484: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
6488: LD_INT 332
6490: PPUSH
6491: LD_INT 23
6493: PPUSH
6494: LD_INT 3
6496: PPUSH
6497: LD_INT 1
6499: PPUSH
6500: LD_INT 48
6502: PPUSH
6503: CALL_OW 125
// end ;
6507: LD_VAR 0 1
6511: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
6512: LD_EXP 3
6516: NOT
6517: PUSH
6518: LD_INT 3
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: CALL 35442 0 2
6528: NOT
6529: AND
6530: IFFALSE 7370
6532: GO 6534
6534: DISABLE
6535: LD_INT 0
6537: PPUSH
6538: PPUSH
6539: PPUSH
// begin enable ;
6540: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6541: LD_INT 22
6543: PUSH
6544: LD_INT 8
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: LD_INT 23
6553: PUSH
6554: LD_INT 2
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: PUSH
6561: LD_INT 30
6563: PUSH
6564: LD_INT 3
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: EMPTY
6572: LIST
6573: LIST
6574: LIST
6575: PPUSH
6576: CALL_OW 69
6580: NOT
6581: IFFALSE 6585
// exit ;
6583: GO 7370
// if Prob ( 40 ) then
6585: LD_INT 40
6587: PPUSH
6588: CALL_OW 13
6592: IFFALSE 6719
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6594: LD_INT 3
6596: PPUSH
6597: LD_INT 14
6599: PUSH
6600: LD_INT 1
6602: PUSH
6603: LD_INT 2
6605: PUSH
6606: LD_INT 28
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 14
6617: PUSH
6618: LD_INT 1
6620: PUSH
6621: LD_INT 2
6623: PUSH
6624: LD_INT 28
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 14
6635: PUSH
6636: LD_INT 1
6638: PUSH
6639: LD_INT 2
6641: PUSH
6642: LD_INT 28
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 14
6653: PUSH
6654: LD_INT 1
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 28
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 14
6671: PUSH
6672: LD_INT 1
6674: PUSH
6675: LD_INT 2
6677: PUSH
6678: LD_INT 28
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 14
6689: PUSH
6690: LD_INT 1
6692: PUSH
6693: LD_INT 2
6695: PUSH
6696: LD_INT 26
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: LIST
6712: PPUSH
6713: CALL 34024 0 2
// end else
6717: GO 6910
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6719: LD_INT 3
6721: PPUSH
6722: LD_INT 14
6724: PUSH
6725: LD_INT 1
6727: PUSH
6728: LD_INT 2
6730: PUSH
6731: LD_INT 27
6733: PUSH
6734: LD_INT 26
6736: PUSH
6737: LD_INT 26
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: PUSH
6745: LD_OWVAR 67
6749: ARRAY
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: LD_INT 14
6759: PUSH
6760: LD_INT 1
6762: PUSH
6763: LD_INT 2
6765: PUSH
6766: LD_INT 27
6768: PUSH
6769: LD_INT 26
6771: PUSH
6772: LD_INT 26
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: LIST
6779: PUSH
6780: LD_OWVAR 67
6784: ARRAY
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 14
6794: PUSH
6795: LD_INT 1
6797: PUSH
6798: LD_INT 2
6800: PUSH
6801: LD_INT 26
6803: PUSH
6804: LD_INT 26
6806: PUSH
6807: LD_INT 29
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PUSH
6815: LD_OWVAR 67
6819: ARRAY
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PUSH
6827: LD_INT 13
6829: PUSH
6830: LD_INT 1
6832: PUSH
6833: LD_INT 2
6835: PUSH
6836: LD_INT 26
6838: PUSH
6839: LD_INT 29
6841: PUSH
6842: LD_INT 29
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PUSH
6850: LD_OWVAR 67
6854: ARRAY
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 13
6864: PUSH
6865: LD_INT 1
6867: PUSH
6868: LD_INT 2
6870: PUSH
6871: LD_INT 29
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 14
6882: PUSH
6883: LD_INT 1
6885: PUSH
6886: LD_INT 2
6888: PUSH
6889: LD_INT 26
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: PPUSH
6906: CALL 34024 0 2
// end ; repeat wait ( 0 0$1 ) ;
6910: LD_INT 35
6912: PPUSH
6913: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6917: LD_INT 3
6919: PPUSH
6920: LD_INT 1
6922: PPUSH
6923: CALL 35442 0 2
6927: PUSH
6928: LD_INT 6
6930: GREATEREQUAL
6931: IFFALSE 6910
// wait ( 0 0$30 ) ;
6933: LD_INT 1050
6935: PPUSH
6936: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6940: LD_ADDR_VAR 0 2
6944: PUSH
6945: LD_INT 3
6947: PPUSH
6948: LD_INT 1
6950: PPUSH
6951: CALL 35442 0 2
6955: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6956: LD_ADDR_EXP 75
6960: PUSH
6961: LD_EXP 75
6965: PPUSH
6966: LD_INT 3
6968: PPUSH
6969: LD_EXP 75
6973: PUSH
6974: LD_INT 3
6976: ARRAY
6977: PUSH
6978: LD_VAR 0 2
6982: DIFF
6983: PPUSH
6984: CALL_OW 1
6988: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6989: LD_ADDR_VAR 0 3
6993: PUSH
6994: LD_INT 0
6996: PPUSH
6997: LD_INT 2
6999: PPUSH
7000: CALL_OW 12
7004: ST_TO_ADDR
// if target then
7005: LD_VAR 0 3
7009: IFFALSE 7137
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7011: LD_ADDR_VAR 0 2
7015: PUSH
7016: LD_VAR 0 2
7020: PPUSH
7021: LD_INT 24
7023: PUSH
7024: LD_INT 250
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PPUSH
7031: CALL_OW 72
7035: ST_TO_ADDR
// for i in tmp do
7036: LD_ADDR_VAR 0 1
7040: PUSH
7041: LD_VAR 0 2
7045: PUSH
7046: FOR_IN
7047: IFFALSE 7087
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7049: LD_VAR 0 1
7053: PPUSH
7054: LD_INT 89
7056: PPUSH
7057: LD_INT 71
7059: PPUSH
7060: CALL_OW 297
7064: PUSH
7065: LD_INT 9
7067: GREATER
7068: IFFALSE 7085
// ComMoveXY ( i , 89 , 71 ) ;
7070: LD_VAR 0 1
7074: PPUSH
7075: LD_INT 89
7077: PPUSH
7078: LD_INT 71
7080: PPUSH
7081: CALL_OW 111
7085: GO 7046
7087: POP
7088: POP
// wait ( 0 0$1 ) ;
7089: LD_INT 35
7091: PPUSH
7092: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7096: LD_VAR 0 2
7100: PPUSH
7101: LD_INT 92
7103: PUSH
7104: LD_INT 89
7106: PUSH
7107: LD_INT 71
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PPUSH
7119: CALL_OW 72
7123: PUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_INT 1
7131: MINUS
7132: GREATEREQUAL
7133: IFFALSE 7011
// end else
7135: GO 7261
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7137: LD_ADDR_VAR 0 2
7141: PUSH
7142: LD_VAR 0 2
7146: PPUSH
7147: LD_INT 24
7149: PUSH
7150: LD_INT 250
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: ST_TO_ADDR
// for i in tmp do
7162: LD_ADDR_VAR 0 1
7166: PUSH
7167: LD_VAR 0 2
7171: PUSH
7172: FOR_IN
7173: IFFALSE 7213
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7175: LD_VAR 0 1
7179: PPUSH
7180: LD_INT 147
7182: PPUSH
7183: LD_INT 4
7185: PPUSH
7186: CALL_OW 297
7190: PUSH
7191: LD_INT 9
7193: GREATER
7194: IFFALSE 7211
// ComMoveXY ( i , 147 , 4 ) ;
7196: LD_VAR 0 1
7200: PPUSH
7201: LD_INT 147
7203: PPUSH
7204: LD_INT 4
7206: PPUSH
7207: CALL_OW 111
7211: GO 7172
7213: POP
7214: POP
// wait ( 0 0$1 ) ;
7215: LD_INT 35
7217: PPUSH
7218: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7222: LD_VAR 0 2
7226: PPUSH
7227: LD_INT 92
7229: PUSH
7230: LD_INT 147
7232: PUSH
7233: LD_INT 4
7235: PUSH
7236: LD_INT 9
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 72
7249: PUSH
7250: LD_VAR 0 2
7254: PUSH
7255: LD_INT 1
7257: MINUS
7258: GREATEREQUAL
7259: IFFALSE 7137
// end ; repeat wait ( 0 0$1 ) ;
7261: LD_INT 35
7263: PPUSH
7264: CALL_OW 67
// for i in tmp do
7268: LD_ADDR_VAR 0 1
7272: PUSH
7273: LD_VAR 0 2
7277: PUSH
7278: FOR_IN
7279: IFFALSE 7361
// begin if GetLives ( i ) > 251 then
7281: LD_VAR 0 1
7285: PPUSH
7286: CALL_OW 256
7290: PUSH
7291: LD_INT 251
7293: GREATER
7294: IFFALSE 7332
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7296: LD_VAR 0 1
7300: PPUSH
7301: LD_INT 81
7303: PUSH
7304: LD_INT 8
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PPUSH
7311: CALL_OW 69
7315: PPUSH
7316: LD_VAR 0 1
7320: PPUSH
7321: CALL_OW 74
7325: PPUSH
7326: CALL_OW 115
7330: GO 7359
// if IsDead ( i ) then
7332: LD_VAR 0 1
7336: PPUSH
7337: CALL_OW 301
7341: IFFALSE 7359
// tmp := tmp diff i ;
7343: LD_ADDR_VAR 0 2
7347: PUSH
7348: LD_VAR 0 2
7352: PUSH
7353: LD_VAR 0 1
7357: DIFF
7358: ST_TO_ADDR
// end ;
7359: GO 7278
7361: POP
7362: POP
// until not tmp ;
7363: LD_VAR 0 2
7367: NOT
7368: IFFALSE 7261
// end ;
7370: PPOPN 3
7372: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
7373: LD_EXP 42
7377: PPUSH
7378: CALL_OW 302
7382: PUSH
7383: LD_EXP 3
7387: NOT
7388: AND
7389: IFFALSE 7398
7391: GO 7393
7393: DISABLE
// BuildKozlovBomb ;
7394: CALL 6385 0 0
7398: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
7399: LD_INT 22
7401: PUSH
7402: LD_INT 8
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: PUSH
7409: LD_INT 34
7411: PUSH
7412: LD_INT 48
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: PUSH
7419: EMPTY
7420: LIST
7421: LIST
7422: PPUSH
7423: CALL_OW 69
7427: IFFALSE 7475
7429: GO 7431
7431: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
7432: LD_INT 22
7434: PUSH
7435: LD_INT 8
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 34
7444: PUSH
7445: LD_INT 48
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PPUSH
7456: CALL_OW 69
7460: PUSH
7461: LD_INT 1
7463: ARRAY
7464: PPUSH
7465: LD_INT 173
7467: PPUSH
7468: LD_INT 96
7470: PPUSH
7471: CALL_OW 116
// end ; end_of_file
7475: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7476: LD_INT 0
7478: PPUSH
7479: PPUSH
7480: PPUSH
7481: PPUSH
7482: PPUSH
7483: PPUSH
7484: PPUSH
7485: PPUSH
7486: PPUSH
// side := 3 ;
7487: LD_ADDR_VAR 0 6
7491: PUSH
7492: LD_INT 3
7494: ST_TO_ADDR
// uc_side := side ;
7495: LD_ADDR_OWVAR 20
7499: PUSH
7500: LD_VAR 0 6
7504: ST_TO_ADDR
// uc_nation := 3 ;
7505: LD_ADDR_OWVAR 21
7509: PUSH
7510: LD_INT 3
7512: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7513: LD_ADDR_VAR 0 2
7517: PUSH
7518: LD_INT 22
7520: PUSH
7521: LD_VAR 0 6
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 21
7532: PUSH
7533: LD_INT 3
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PPUSH
7544: CALL_OW 69
7548: PUSH
7549: FOR_IN
7550: IFFALSE 7566
// SetBLevel ( i , 10 ) ;
7552: LD_VAR 0 2
7556: PPUSH
7557: LD_INT 10
7559: PPUSH
7560: CALL_OW 241
7564: GO 7549
7566: POP
7567: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7568: LD_ADDR_VAR 0 9
7572: PUSH
7573: LD_INT 22
7575: PUSH
7576: LD_VAR 0 6
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 30
7587: PUSH
7588: LD_INT 34
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: ST_TO_ADDR
// if teleport then
7604: LD_VAR 0 9
7608: IFFALSE 7629
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7610: LD_VAR 0 9
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_INT 123
7621: PPUSH
7622: LD_INT 122
7624: PPUSH
7625: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7629: LD_ADDR_EXP 43
7633: PUSH
7634: LD_STRING Platonov
7636: PPUSH
7637: CALL_OW 25
7641: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7642: LD_ADDR_EXP 34
7646: PUSH
7647: LD_STRING Kovalyuk
7649: PPUSH
7650: CALL_OW 25
7654: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7655: LD_ADDR_EXP 44
7659: PUSH
7660: LD_STRING Yakotich
7662: PPUSH
7663: CALL_OW 25
7667: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7668: LD_ADDR_EXP 45
7672: PUSH
7673: LD_STRING Gleb
7675: PPUSH
7676: CALL_OW 25
7680: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7681: LD_STRING 03_Cornel
7683: PPUSH
7684: CALL_OW 28
7688: IFFALSE 7736
// begin Bierezov := NewCharacter ( Mikhail ) ;
7690: LD_ADDR_EXP 46
7694: PUSH
7695: LD_STRING Mikhail
7697: PPUSH
7698: CALL_OW 25
7702: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7703: LD_EXP 46
7707: PPUSH
7708: LD_INT 197
7710: PPUSH
7711: LD_INT 111
7713: PPUSH
7714: LD_INT 9
7716: PPUSH
7717: LD_INT 0
7719: PPUSH
7720: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7724: LD_EXP 46
7728: PPUSH
7729: LD_INT 3
7731: PPUSH
7732: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7736: LD_EXP 43
7740: PPUSH
7741: LD_INT 126
7743: PPUSH
7744: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7748: LD_EXP 34
7752: PPUSH
7753: LD_INT 134
7755: PPUSH
7756: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7760: LD_EXP 44
7764: PPUSH
7765: LD_INT 197
7767: PPUSH
7768: LD_INT 111
7770: PPUSH
7771: LD_INT 9
7773: PPUSH
7774: LD_INT 0
7776: PPUSH
7777: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7781: LD_EXP 45
7785: PPUSH
7786: LD_INT 197
7788: PPUSH
7789: LD_INT 111
7791: PPUSH
7792: LD_INT 9
7794: PPUSH
7795: LD_INT 0
7797: PPUSH
7798: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7802: LD_ADDR_VAR 0 5
7806: PUSH
7807: LD_INT 126
7809: PPUSH
7810: LD_INT 2
7812: PPUSH
7813: LD_STRING zhukov
7815: PPUSH
7816: LD_INT 9
7818: PUSH
7819: LD_INT 10
7821: PUSH
7822: LD_INT 10
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: LD_OWVAR 67
7834: ARRAY
7835: PPUSH
7836: LD_INT 99999
7838: PUSH
7839: LD_INT 1000
7841: PUSH
7842: LD_INT 300
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: PPUSH
7850: LD_INT 12
7852: PUSH
7853: LD_INT 8
7855: PUSH
7856: LD_INT 13
7858: PUSH
7859: LD_INT 8
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: LIST
7866: LIST
7867: PPUSH
7868: CALL 50306 0 6
7872: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7873: LD_ADDR_VAR 0 4
7877: PUSH
7878: LD_INT 267
7880: PPUSH
7881: CALL_OW 274
7885: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7886: LD_VAR 0 4
7890: PPUSH
7891: LD_INT 1
7893: PPUSH
7894: LD_INT 5000
7896: PPUSH
7897: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7901: LD_VAR 0 4
7905: PPUSH
7906: LD_INT 2
7908: PPUSH
7909: LD_INT 200
7911: PPUSH
7912: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7916: LD_VAR 0 4
7920: PPUSH
7921: LD_INT 3
7923: PPUSH
7924: LD_INT 200
7926: PPUSH
7927: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7931: LD_ADDR_EXP 56
7935: PUSH
7936: LD_EXP 56
7940: PPUSH
7941: LD_INT 2
7943: PPUSH
7944: LD_VAR 0 5
7948: PUSH
7949: LD_INT 22
7951: PUSH
7952: LD_VAR 0 6
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: PUSH
7961: LD_INT 3
7963: PUSH
7964: LD_INT 21
7966: PUSH
7967: LD_INT 2
7969: PUSH
7970: EMPTY
7971: LIST
7972: LIST
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PUSH
7978: EMPTY
7979: LIST
7980: LIST
7981: PPUSH
7982: CALL_OW 69
7986: UNION
7987: PUSH
7988: LD_EXP 43
7992: DIFF
7993: PPUSH
7994: CALL_OW 1
7998: ST_TO_ADDR
// behemoths := [ ] ;
7999: LD_ADDR_EXP 47
8003: PUSH
8004: EMPTY
8005: ST_TO_ADDR
// behemothBuilders := [ ] ;
8006: LD_ADDR_EXP 48
8010: PUSH
8011: EMPTY
8012: ST_TO_ADDR
// j := 3 ;
8013: LD_ADDR_VAR 0 3
8017: PUSH
8018: LD_INT 3
8020: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8021: LD_ADDR_VAR 0 2
8025: PUSH
8026: LD_INT 22
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PUSH
8036: LD_INT 25
8038: PUSH
8039: LD_INT 3
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PUSH
8046: EMPTY
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL_OW 69
8054: PUSH
8055: FOR_IN
8056: IFFALSE 8106
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8058: LD_ADDR_EXP 48
8062: PUSH
8063: LD_EXP 48
8067: PPUSH
8068: LD_VAR 0 2
8072: PPUSH
8073: CALL 82642 0 2
8077: ST_TO_ADDR
// j := j - 1 ;
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_VAR 0 3
8087: PUSH
8088: LD_INT 1
8090: MINUS
8091: ST_TO_ADDR
// if j = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8104
// break ;
8102: GO 8106
// end ;
8104: GO 8055
8106: POP
8107: POP
// end ;
8108: LD_VAR 0 1
8112: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8113: LD_INT 0
8115: PPUSH
8116: PPUSH
8117: PPUSH
8118: PPUSH
8119: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8120: LD_ADDR_VAR 0 4
8124: PUSH
8125: LD_INT 209
8127: PUSH
8128: LD_INT 149
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PUSH
8135: LD_INT 219
8137: PUSH
8138: LD_INT 154
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PUSH
8145: LD_INT 223
8147: PUSH
8148: LD_INT 149
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 232
8157: PUSH
8158: LD_INT 155
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: LIST
8169: LIST
8170: ST_TO_ADDR
// if not behemothBuilders then
8171: LD_EXP 48
8175: NOT
8176: IFFALSE 8180
// exit ;
8178: GO 8284
// j := 1 ;
8180: LD_ADDR_VAR 0 3
8184: PUSH
8185: LD_INT 1
8187: ST_TO_ADDR
// for i in behemothBuilders do
8188: LD_ADDR_VAR 0 2
8192: PUSH
8193: LD_EXP 48
8197: PUSH
8198: FOR_IN
8199: IFFALSE 8282
// begin if IsInUnit ( i ) then
8201: LD_VAR 0 2
8205: PPUSH
8206: CALL_OW 310
8210: IFFALSE 8221
// ComExitBuilding ( i ) ;
8212: LD_VAR 0 2
8216: PPUSH
8217: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8221: LD_VAR 0 2
8225: PPUSH
8226: LD_INT 37
8228: PPUSH
8229: LD_VAR 0 4
8233: PUSH
8234: LD_VAR 0 3
8238: ARRAY
8239: PUSH
8240: LD_INT 1
8242: ARRAY
8243: PPUSH
8244: LD_VAR 0 4
8248: PUSH
8249: LD_VAR 0 3
8253: ARRAY
8254: PUSH
8255: LD_INT 2
8257: ARRAY
8258: PPUSH
8259: LD_INT 0
8261: PPUSH
8262: CALL_OW 230
// j := j + 1 ;
8266: LD_ADDR_VAR 0 3
8270: PUSH
8271: LD_VAR 0 3
8275: PUSH
8276: LD_INT 1
8278: PLUS
8279: ST_TO_ADDR
// end ;
8280: GO 8198
8282: POP
8283: POP
// end ;
8284: LD_VAR 0 1
8288: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8289: LD_INT 3
8291: PPUSH
8292: CALL 82690 0 1
8296: PUSH
8297: LD_INT 22
8299: PUSH
8300: LD_INT 3
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: PUSH
8307: LD_INT 30
8309: PUSH
8310: LD_INT 37
8312: PUSH
8313: EMPTY
8314: LIST
8315: LIST
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PPUSH
8321: CALL_OW 69
8325: NOT
8326: AND
8327: IFFALSE 8513
8329: GO 8331
8331: DISABLE
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
// begin enable ;
8336: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8337: LD_ADDR_VAR 0 2
8341: PUSH
8342: LD_INT 3
8344: PPUSH
8345: CALL 82690 0 1
8349: ST_TO_ADDR
// for i in tmp do
8350: LD_ADDR_VAR 0 1
8354: PUSH
8355: LD_VAR 0 2
8359: PUSH
8360: FOR_IN
8361: IFFALSE 8511
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8363: LD_VAR 0 1
8367: PPUSH
8368: LD_INT 7
8370: PPUSH
8371: CALL_OW 308
8375: PUSH
8376: LD_VAR 0 1
8380: PPUSH
8381: CALL_OW 110
8385: PUSH
8386: LD_INT 2
8388: EQUAL
8389: NOT
8390: AND
8391: IFFALSE 8405
// SetTag ( i , 2 ) ;
8393: LD_VAR 0 1
8397: PPUSH
8398: LD_INT 2
8400: PPUSH
8401: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8405: LD_INT 81
8407: PUSH
8408: LD_INT 3
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: LD_INT 91
8417: PUSH
8418: LD_VAR 0 1
8422: PUSH
8423: LD_INT 12
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: PPUSH
8435: CALL_OW 69
8439: NOT
8440: PUSH
8441: LD_VAR 0 1
8445: PPUSH
8446: CALL_OW 110
8450: PUSH
8451: LD_INT 2
8453: EQUAL
8454: NOT
8455: AND
8456: IFFALSE 8475
// ComAgressiveMove ( i , 64 , 93 ) else
8458: LD_VAR 0 1
8462: PPUSH
8463: LD_INT 64
8465: PPUSH
8466: LD_INT 93
8468: PPUSH
8469: CALL_OW 114
8473: GO 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8475: LD_VAR 0 1
8479: PPUSH
8480: LD_INT 81
8482: PUSH
8483: LD_INT 3
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PPUSH
8490: CALL_OW 69
8494: PPUSH
8495: LD_VAR 0 1
8499: PPUSH
8500: CALL_OW 74
8504: PPUSH
8505: CALL_OW 115
// end ;
8509: GO 8360
8511: POP
8512: POP
// end ;
8513: PPOPN 2
8515: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
8516: LD_EXP 2
8520: NOT
8521: PUSH
8522: LD_INT 2
8524: PPUSH
8525: LD_INT 1
8527: PPUSH
8528: CALL 35442 0 2
8532: NOT
8533: AND
8534: IFFALSE 9454
8536: GO 8538
8538: DISABLE
8539: LD_INT 0
8541: PPUSH
8542: PPUSH
8543: PPUSH
8544: PPUSH
// begin enable ;
8545: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8546: LD_INT 22
8548: PUSH
8549: LD_INT 3
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: PUSH
8556: LD_INT 30
8558: PUSH
8559: LD_INT 3
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 69
8574: NOT
8575: IFFALSE 8579
// exit ;
8577: GO 9454
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8579: LD_ADDR_VAR 0 4
8583: PUSH
8584: LD_INT 22
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PUSH
8594: LD_INT 30
8596: PUSH
8597: LD_INT 34
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: ST_TO_ADDR
// if Prob ( 40 ) then
8613: LD_INT 40
8615: PPUSH
8616: CALL_OW 13
8620: IFFALSE 8747
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8622: LD_INT 2
8624: PPUSH
8625: LD_INT 22
8627: PUSH
8628: LD_INT 3
8630: PUSH
8631: LD_INT 3
8633: PUSH
8634: LD_INT 49
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: PUSH
8643: LD_INT 22
8645: PUSH
8646: LD_INT 3
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: LD_INT 49
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 22
8663: PUSH
8664: LD_INT 3
8666: PUSH
8667: LD_INT 3
8669: PUSH
8670: LD_INT 49
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: PUSH
8679: LD_INT 24
8681: PUSH
8682: LD_INT 3
8684: PUSH
8685: LD_INT 3
8687: PUSH
8688: LD_INT 46
8690: PUSH
8691: EMPTY
8692: LIST
8693: LIST
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 24
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 3
8705: PUSH
8706: LD_INT 46
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: PUSH
8715: LD_INT 24
8717: PUSH
8718: LD_INT 3
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: LIST
8731: LIST
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: PPUSH
8741: CALL 34024 0 2
// end else
8745: GO 8870
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8747: LD_INT 2
8749: PPUSH
8750: LD_INT 24
8752: PUSH
8753: LD_INT 3
8755: PUSH
8756: LD_INT 3
8758: PUSH
8759: LD_INT 47
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 24
8770: PUSH
8771: LD_INT 3
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: LD_INT 47
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: PUSH
8786: LD_INT 24
8788: PUSH
8789: LD_INT 3
8791: PUSH
8792: LD_INT 3
8794: PUSH
8795: LD_INT 47
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 24
8806: PUSH
8807: LD_INT 3
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: LD_INT 46
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: LIST
8820: LIST
8821: PUSH
8822: LD_INT 24
8824: PUSH
8825: LD_INT 3
8827: PUSH
8828: LD_INT 3
8830: PUSH
8831: LD_INT 46
8833: PUSH
8834: EMPTY
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: PUSH
8840: LD_INT 24
8842: PUSH
8843: LD_INT 3
8845: PUSH
8846: LD_INT 3
8848: PUSH
8849: LD_INT 46
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: LIST
8862: LIST
8863: LIST
8864: LIST
8865: PPUSH
8866: CALL 34024 0 2
// end ; if Difficulty > 1 then
8870: LD_OWVAR 67
8874: PUSH
8875: LD_INT 1
8877: GREATER
8878: IFFALSE 8908
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
8880: LD_INT 2
8882: PPUSH
8883: LD_INT 24
8885: PUSH
8886: LD_INT 3
8888: PUSH
8889: LD_INT 3
8891: PUSH
8892: LD_INT 47
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: EMPTY
8902: LIST
8903: PPUSH
8904: CALL 34024 0 2
// repeat wait ( 0 0$1 ) ;
8908: LD_INT 35
8910: PPUSH
8911: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
8915: LD_INT 2
8917: PPUSH
8918: LD_INT 1
8920: PPUSH
8921: CALL 35442 0 2
8925: PUSH
8926: LD_INT 6
8928: PUSH
8929: LD_INT 7
8931: PUSH
8932: LD_INT 7
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: LIST
8939: PUSH
8940: LD_OWVAR 67
8944: ARRAY
8945: GREATEREQUAL
8946: IFFALSE 8908
// wait ( 0 0$30 ) ;
8948: LD_INT 1050
8950: PPUSH
8951: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
8955: LD_ADDR_VAR 0 2
8959: PUSH
8960: LD_INT 2
8962: PPUSH
8963: LD_INT 1
8965: PPUSH
8966: CALL 35442 0 2
8970: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
8971: LD_ADDR_EXP 75
8975: PUSH
8976: LD_EXP 75
8980: PPUSH
8981: LD_INT 2
8983: PPUSH
8984: LD_EXP 75
8988: PUSH
8989: LD_INT 2
8991: ARRAY
8992: PUSH
8993: LD_VAR 0 2
8997: DIFF
8998: PPUSH
8999: CALL_OW 1
9003: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9004: LD_ADDR_VAR 0 3
9008: PUSH
9009: LD_INT 0
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 12
9019: ST_TO_ADDR
// if target then
9020: LD_VAR 0 3
9024: IFFALSE 9152
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PPUSH
9036: LD_INT 24
9038: PUSH
9039: LD_INT 250
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: PPUSH
9046: CALL_OW 72
9050: ST_TO_ADDR
// for i in tmp do
9051: LD_ADDR_VAR 0 1
9055: PUSH
9056: LD_VAR 0 2
9060: PUSH
9061: FOR_IN
9062: IFFALSE 9102
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9064: LD_VAR 0 1
9068: PPUSH
9069: LD_INT 139
9071: PPUSH
9072: LD_INT 89
9074: PPUSH
9075: CALL_OW 297
9079: PUSH
9080: LD_INT 9
9082: GREATER
9083: IFFALSE 9100
// ComMoveXY ( i , 139 , 89 ) ;
9085: LD_VAR 0 1
9089: PPUSH
9090: LD_INT 139
9092: PPUSH
9093: LD_INT 89
9095: PPUSH
9096: CALL_OW 111
9100: GO 9061
9102: POP
9103: POP
// wait ( 0 0$1 ) ;
9104: LD_INT 35
9106: PPUSH
9107: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 92
9118: PUSH
9119: LD_INT 139
9121: PUSH
9122: LD_INT 89
9124: PUSH
9125: LD_INT 9
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 72
9138: PUSH
9139: LD_VAR 0 2
9143: PUSH
9144: LD_INT 1
9146: MINUS
9147: GREATEREQUAL
9148: IFFALSE 9026
// end else
9150: GO 9294
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9152: LD_VAR 0 2
9156: PPUSH
9157: LD_VAR 0 4
9161: PUSH
9162: LD_INT 1
9164: ARRAY
9165: PPUSH
9166: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9170: LD_ADDR_VAR 0 2
9174: PUSH
9175: LD_VAR 0 2
9179: PPUSH
9180: LD_INT 24
9182: PUSH
9183: LD_INT 250
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PPUSH
9190: CALL_OW 72
9194: ST_TO_ADDR
// for i in tmp do
9195: LD_ADDR_VAR 0 1
9199: PUSH
9200: LD_VAR 0 2
9204: PUSH
9205: FOR_IN
9206: IFFALSE 9246
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 124
9215: PPUSH
9216: LD_INT 139
9218: PPUSH
9219: CALL_OW 297
9223: PUSH
9224: LD_INT 9
9226: GREATER
9227: IFFALSE 9244
// ComMoveXY ( i , 124 , 139 ) ;
9229: LD_VAR 0 1
9233: PPUSH
9234: LD_INT 124
9236: PPUSH
9237: LD_INT 139
9239: PPUSH
9240: CALL_OW 111
9244: GO 9205
9246: POP
9247: POP
// wait ( 0 0$1 ) ;
9248: LD_INT 35
9250: PPUSH
9251: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9255: LD_VAR 0 2
9259: PPUSH
9260: LD_INT 92
9262: PUSH
9263: LD_INT 124
9265: PUSH
9266: LD_INT 139
9268: PUSH
9269: LD_INT 9
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 72
9282: PUSH
9283: LD_VAR 0 2
9287: PUSH
9288: LD_INT 1
9290: MINUS
9291: GREATEREQUAL
9292: IFFALSE 9170
// end ; repeat wait ( 0 0$1 ) ;
9294: LD_INT 35
9296: PPUSH
9297: CALL_OW 67
// for i in tmp do
9301: LD_ADDR_VAR 0 1
9305: PUSH
9306: LD_VAR 0 2
9310: PUSH
9311: FOR_IN
9312: IFFALSE 9445
// begin if GetLives ( i ) > 251 then
9314: LD_VAR 0 1
9318: PPUSH
9319: CALL_OW 256
9323: PUSH
9324: LD_INT 251
9326: GREATER
9327: IFFALSE 9416
// begin if GetWeapon ( i ) = ru_time_lapser then
9329: LD_VAR 0 1
9333: PPUSH
9334: CALL_OW 264
9338: PUSH
9339: LD_INT 49
9341: EQUAL
9342: IFFALSE 9380
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
9344: LD_VAR 0 1
9348: PPUSH
9349: LD_INT 81
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PPUSH
9359: CALL_OW 69
9363: PPUSH
9364: LD_VAR 0 1
9368: PPUSH
9369: CALL_OW 74
9373: PPUSH
9374: CALL_OW 112
9378: GO 9414
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9380: LD_VAR 0 1
9384: PPUSH
9385: LD_INT 81
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PPUSH
9395: CALL_OW 69
9399: PPUSH
9400: LD_VAR 0 1
9404: PPUSH
9405: CALL_OW 74
9409: PPUSH
9410: CALL_OW 115
// end else
9414: GO 9443
// if IsDead ( i ) then
9416: LD_VAR 0 1
9420: PPUSH
9421: CALL_OW 301
9425: IFFALSE 9443
// tmp := tmp diff i ;
9427: LD_ADDR_VAR 0 2
9431: PUSH
9432: LD_VAR 0 2
9436: PUSH
9437: LD_VAR 0 1
9441: DIFF
9442: ST_TO_ADDR
// end ;
9443: GO 9311
9445: POP
9446: POP
// until not tmp ;
9447: LD_VAR 0 2
9451: NOT
9452: IFFALSE 9294
// end ; end_of_file
9454: PPOPN 4
9456: END
// export function CustomEvent ( event ) ; begin
9457: LD_INT 0
9459: PPUSH
// end ;
9460: LD_VAR 0 2
9464: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9465: LD_VAR 0 2
9469: PPUSH
9470: LD_VAR 0 3
9474: PPUSH
9475: LD_INT 15
9477: PPUSH
9478: CALL_OW 309
9482: IFFALSE 9491
// YouLost ( MothContaminate ) ;
9484: LD_STRING MothContaminate
9486: PPUSH
9487: CALL_OW 104
// end ;
9491: PPOPN 3
9493: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9494: LD_VAR 0 2
9498: PPUSH
9499: LD_VAR 0 3
9503: PPUSH
9504: LD_INT 15
9506: PPUSH
9507: CALL_OW 309
9511: IFFALSE 9527
// begin wait ( 0 0$6 ) ;
9513: LD_INT 210
9515: PPUSH
9516: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
9520: LD_STRING MothContaminateBomb
9522: PPUSH
9523: CALL_OW 104
// end ; end ;
9527: PPOPN 3
9529: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9530: LD_VAR 0 1
9534: PUSH
9535: LD_EXP 6
9539: EQUAL
9540: IFFALSE 9551
// begin YouLost ( JMM ) ;
9542: LD_STRING JMM
9544: PPUSH
9545: CALL_OW 104
// exit ;
9549: GO 9560
// end ; MCE_UnitDestroyed ( un ) ;
9551: LD_VAR 0 1
9555: PPUSH
9556: CALL 37416 0 1
// end ;
9560: PPOPN 1
9562: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9563: LD_VAR 0 1
9567: PPUSH
9568: LD_VAR 0 2
9572: PPUSH
9573: CALL 39528 0 2
// end ;
9577: PPOPN 2
9579: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9580: LD_VAR 0 1
9584: PPUSH
9585: CALL 38596 0 1
// end ;
9589: PPOPN 1
9591: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
9592: LD_VAR 0 1
9596: PUSH
9597: LD_INT 22
9599: PUSH
9600: LD_INT 8
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 30
9609: PUSH
9610: LD_INT 2
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PUSH
9617: LD_INT 23
9619: PUSH
9620: LD_INT 3
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: LIST
9631: PPUSH
9632: CALL_OW 69
9636: IN
9637: IFFALSE 9664
// begin ComUpgrade ( building ) ;
9639: LD_VAR 0 1
9643: PPUSH
9644: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
9648: LD_EXP 42
9652: PPUSH
9653: LD_VAR 0 1
9657: PPUSH
9658: CALL 49870 0 2
// exit ;
9662: GO 9673
// end ; MCE_BuildingComplete ( building ) ;
9664: LD_VAR 0 1
9668: PPUSH
9669: CALL 38837 0 1
// end ;
9673: PPOPN 1
9675: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_VAR 0 2
9685: PPUSH
9686: CALL 37112 0 2
// end ;
9690: PPOPN 2
9692: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9693: LD_VAR 0 1
9697: PPUSH
9698: LD_VAR 0 2
9702: PPUSH
9703: LD_VAR 0 3
9707: PPUSH
9708: LD_VAR 0 4
9712: PPUSH
9713: LD_VAR 0 5
9717: PPUSH
9718: CALL 36732 0 5
// end ;
9722: PPOPN 5
9724: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
9725: LD_VAR 0 1
9729: PPUSH
9730: LD_VAR 0 2
9734: PPUSH
9735: CALL 36328 0 2
// end ;
9739: PPOPN 2
9741: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9742: LD_VAR 0 1
9746: PPUSH
9747: LD_VAR 0 2
9751: PPUSH
9752: LD_VAR 0 3
9756: PPUSH
9757: LD_VAR 0 4
9761: PPUSH
9762: CALL 36166 0 4
// end ;
9766: PPOPN 4
9768: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9769: LD_VAR 0 1
9773: PPUSH
9774: LD_VAR 0 2
9778: PPUSH
9779: LD_VAR 0 3
9783: PPUSH
9784: CALL 35941 0 3
// end ;
9788: PPOPN 3
9790: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_VAR 0 2
9800: PPUSH
9801: CALL 35826 0 2
// end ;
9805: PPOPN 2
9807: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9808: LD_VAR 0 1
9812: PPUSH
9813: LD_VAR 0 2
9817: PPUSH
9818: CALL 39789 0 2
// end ;
9822: PPOPN 2
9824: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_VAR 0 2
9834: PPUSH
9835: LD_VAR 0 3
9839: PPUSH
9840: LD_VAR 0 4
9844: PPUSH
9845: CALL 40005 0 4
// end ;
9849: PPOPN 4
9851: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
9852: LD_VAR 0 1
9856: PPUSH
9857: LD_VAR 0 2
9861: PPUSH
9862: CALL 35635 0 2
// end ;
9866: PPOPN 2
9868: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
9869: LD_VAR 0 1
9873: PPUSH
9874: CALL 82957 0 1
// end ; end_of_file
9878: PPOPN 1
9880: END
// export function Action ; begin
9881: LD_INT 0
9883: PPUSH
// InGameOn ;
9884: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
9888: LD_EXP 6
9892: PPUSH
9893: CALL_OW 87
// InGameOff ;
9897: CALL_OW 9
// end ;
9901: LD_VAR 0 1
9905: RET
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
9906: LD_EXP 3
9910: IFFALSE 10262
9912: GO 9914
9914: DISABLE
9915: LD_INT 0
9917: PPUSH
9918: PPUSH
// begin MC_Kill ( 3 ) ;
9919: LD_INT 3
9921: PPUSH
9922: CALL 10676 0 1
// if IsOk ( Schulz ) then
9926: LD_EXP 41
9930: PPUSH
9931: CALL_OW 302
9935: IFFALSE 9957
// begin DialogueOn ;
9937: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
9941: LD_EXP 41
9945: PPUSH
9946: LD_STRING D15-Szulc-1
9948: PPUSH
9949: CALL_OW 94
// DialogueOff ;
9953: CALL_OW 7
// end ; SetAttitude ( 8 , 7 , att_friend , true ) ;
9957: LD_INT 8
9959: PPUSH
9960: LD_INT 7
9962: PPUSH
9963: LD_INT 1
9965: PPUSH
9966: LD_INT 1
9968: PPUSH
9969: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
9973: LD_ADDR_VAR 0 1
9977: PUSH
9978: LD_INT 22
9980: PUSH
9981: LD_INT 8
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: PUSH
9988: LD_INT 21
9990: PUSH
9991: LD_INT 3
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: PUSH
9998: LD_INT 23
10000: PUSH
10001: LD_INT 3
10003: PUSH
10004: EMPTY
10005: LIST
10006: LIST
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: PPUSH
10013: CALL_OW 69
10017: PUSH
10018: FOR_IN
10019: IFFALSE 10032
// DestroyUnit ( i ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: CALL_OW 65
10030: GO 10018
10032: POP
10033: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
10034: LD_ADDR_VAR 0 2
10038: PUSH
10039: LD_INT 22
10041: PUSH
10042: LD_INT 8
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 21
10051: PUSH
10052: LD_INT 1
10054: PUSH
10055: EMPTY
10056: LIST
10057: LIST
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: PPUSH
10063: CALL_OW 69
10067: PUSH
10068: LD_INT 22
10070: PUSH
10071: LD_INT 8
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 21
10080: PUSH
10081: LD_INT 2
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 1
10090: PUSH
10091: EMPTY
10092: LIST
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: LIST
10098: PPUSH
10099: CALL_OW 69
10103: ADD
10104: ST_TO_ADDR
// if tmp then
10105: LD_VAR 0 2
10109: IFFALSE 10262
// repeat wait ( 0 0$1 ) ;
10111: LD_INT 35
10113: PPUSH
10114: CALL_OW 67
// for i in tmp do
10118: LD_ADDR_VAR 0 1
10122: PUSH
10123: LD_VAR 0 2
10127: PUSH
10128: FOR_IN
10129: IFFALSE 10211
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
10131: LD_VAR 0 1
10135: PPUSH
10136: CALL_OW 310
10140: PUSH
10141: LD_VAR 0 1
10145: PPUSH
10146: CALL_OW 310
10150: PPUSH
10151: CALL_OW 247
10155: PUSH
10156: LD_INT 3
10158: EQUAL
10159: AND
10160: IFFALSE 10171
// ComExitBuilding ( i ) ;
10162: LD_VAR 0 1
10166: PPUSH
10167: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
10171: LD_VAR 0 1
10175: PPUSH
10176: LD_INT 10
10178: PPUSH
10179: LD_INT 1
10181: PPUSH
10182: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
10186: LD_VAR 0 1
10190: PPUSH
10191: LD_INT 32
10193: PPUSH
10194: CALL_OW 308
10198: IFFALSE 10209
// RemoveUnit ( i ) ;
10200: LD_VAR 0 1
10204: PPUSH
10205: CALL_OW 64
// end ;
10209: GO 10128
10211: POP
10212: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
10213: LD_INT 22
10215: PUSH
10216: LD_INT 8
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 2
10225: PUSH
10226: LD_INT 21
10228: PUSH
10229: LD_INT 1
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 33
10238: PUSH
10239: LD_INT 1
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PPUSH
10255: CALL_OW 69
10259: NOT
10260: IFFALSE 10111
// end ; end_of_file
10262: PPOPN 2
10264: END
// export function InitNature ; begin
10265: LD_INT 0
10267: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
10268: LD_INT 3
10270: PPUSH
10271: LD_INT 3
10273: PPUSH
10274: LD_INT 2
10276: PPUSH
10277: LD_INT 1
10279: PPUSH
10280: LD_INT 1
10282: PPUSH
10283: LD_INT 0
10285: PPUSH
10286: LD_INT 0
10288: PPUSH
10289: LD_INT 17
10291: PPUSH
10292: LD_INT 0
10294: PPUSH
10295: CALL 74711 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
10299: LD_INT 2
10301: PPUSH
10302: LD_INT 1
10304: PPUSH
10305: LD_INT 1
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 0
10316: PPUSH
10317: LD_INT 0
10319: PPUSH
10320: LD_INT 18
10322: PPUSH
10323: LD_INT 0
10325: PPUSH
10326: CALL 74711 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
10330: LD_INT 4
10332: PPUSH
10333: LD_INT 1
10335: PPUSH
10336: LD_INT 2
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: LD_INT 0
10350: PPUSH
10351: LD_INT 19
10353: PPUSH
10354: LD_INT 0
10356: PPUSH
10357: CALL 74711 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
10361: LD_INT 0
10363: PPUSH
10364: LD_INT 0
10366: PPUSH
10367: LD_INT 0
10369: PPUSH
10370: LD_INT 0
10372: PPUSH
10373: LD_INT 0
10375: PPUSH
10376: LD_INT 0
10378: PPUSH
10379: LD_INT 9
10381: PPUSH
10382: LD_INT 0
10384: PPUSH
10385: LD_INT 20
10387: PPUSH
10388: CALL 74711 0 9
// end ; end_of_file
10392: LD_VAR 0 1
10396: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10397: GO 10399
10399: DISABLE
// begin ru_radar := 98 ;
10400: LD_ADDR_EXP 49
10404: PUSH
10405: LD_INT 98
10407: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10408: LD_ADDR_EXP 50
10412: PUSH
10413: LD_INT 89
10415: ST_TO_ADDR
// us_hack := 99 ;
10416: LD_ADDR_EXP 51
10420: PUSH
10421: LD_INT 99
10423: ST_TO_ADDR
// us_artillery := 97 ;
10424: LD_ADDR_EXP 52
10428: PUSH
10429: LD_INT 97
10431: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10432: LD_ADDR_EXP 53
10436: PUSH
10437: LD_INT 91
10439: ST_TO_ADDR
// end ; end_of_file
10440: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
10441: LD_INT 0
10443: PPUSH
10444: PPUSH
// skirmish := false ;
10445: LD_ADDR_EXP 54
10449: PUSH
10450: LD_INT 0
10452: ST_TO_ADDR
// debug_mc := false ;
10453: LD_ADDR_EXP 55
10457: PUSH
10458: LD_INT 0
10460: ST_TO_ADDR
// mc_bases := [ ] ;
10461: LD_ADDR_EXP 56
10465: PUSH
10466: EMPTY
10467: ST_TO_ADDR
// mc_sides := [ ] ;
10468: LD_ADDR_EXP 82
10472: PUSH
10473: EMPTY
10474: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
10475: LD_ADDR_EXP 57
10479: PUSH
10480: EMPTY
10481: ST_TO_ADDR
// mc_building_repairs := [ ] ;
10482: LD_ADDR_EXP 58
10486: PUSH
10487: EMPTY
10488: ST_TO_ADDR
// mc_need_heal := [ ] ;
10489: LD_ADDR_EXP 59
10493: PUSH
10494: EMPTY
10495: ST_TO_ADDR
// mc_healers := [ ] ;
10496: LD_ADDR_EXP 60
10500: PUSH
10501: EMPTY
10502: ST_TO_ADDR
// mc_build_list := [ ] ;
10503: LD_ADDR_EXP 61
10507: PUSH
10508: EMPTY
10509: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
10510: LD_ADDR_EXP 88
10514: PUSH
10515: EMPTY
10516: ST_TO_ADDR
// mc_builders := [ ] ;
10517: LD_ADDR_EXP 62
10521: PUSH
10522: EMPTY
10523: ST_TO_ADDR
// mc_construct_list := [ ] ;
10524: LD_ADDR_EXP 63
10528: PUSH
10529: EMPTY
10530: ST_TO_ADDR
// mc_turret_list := [ ] ;
10531: LD_ADDR_EXP 64
10535: PUSH
10536: EMPTY
10537: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
10538: LD_ADDR_EXP 65
10542: PUSH
10543: EMPTY
10544: ST_TO_ADDR
// mc_miners := [ ] ;
10545: LD_ADDR_EXP 70
10549: PUSH
10550: EMPTY
10551: ST_TO_ADDR
// mc_mines := [ ] ;
10552: LD_ADDR_EXP 69
10556: PUSH
10557: EMPTY
10558: ST_TO_ADDR
// mc_minefields := [ ] ;
10559: LD_ADDR_EXP 71
10563: PUSH
10564: EMPTY
10565: ST_TO_ADDR
// mc_crates := [ ] ;
10566: LD_ADDR_EXP 72
10570: PUSH
10571: EMPTY
10572: ST_TO_ADDR
// mc_crates_collector := [ ] ;
10573: LD_ADDR_EXP 73
10577: PUSH
10578: EMPTY
10579: ST_TO_ADDR
// mc_crates_area := [ ] ;
10580: LD_ADDR_EXP 74
10584: PUSH
10585: EMPTY
10586: ST_TO_ADDR
// mc_vehicles := [ ] ;
10587: LD_ADDR_EXP 75
10591: PUSH
10592: EMPTY
10593: ST_TO_ADDR
// mc_attack := [ ] ;
10594: LD_ADDR_EXP 76
10598: PUSH
10599: EMPTY
10600: ST_TO_ADDR
// mc_produce := [ ] ;
10601: LD_ADDR_EXP 77
10605: PUSH
10606: EMPTY
10607: ST_TO_ADDR
// mc_defender := [ ] ;
10608: LD_ADDR_EXP 78
10612: PUSH
10613: EMPTY
10614: ST_TO_ADDR
// mc_parking := [ ] ;
10615: LD_ADDR_EXP 80
10619: PUSH
10620: EMPTY
10621: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
10622: LD_ADDR_EXP 66
10626: PUSH
10627: EMPTY
10628: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
10629: LD_ADDR_EXP 68
10633: PUSH
10634: EMPTY
10635: ST_TO_ADDR
// mc_scan := [ ] ;
10636: LD_ADDR_EXP 79
10640: PUSH
10641: EMPTY
10642: ST_TO_ADDR
// mc_scan_area := [ ] ;
10643: LD_ADDR_EXP 81
10647: PUSH
10648: EMPTY
10649: ST_TO_ADDR
// mc_tech := [ ] ;
10650: LD_ADDR_EXP 83
10654: PUSH
10655: EMPTY
10656: ST_TO_ADDR
// mc_class := [ ] ;
10657: LD_ADDR_EXP 97
10661: PUSH
10662: EMPTY
10663: ST_TO_ADDR
// mc_class_case_use := [ ] ;
10664: LD_ADDR_EXP 98
10668: PUSH
10669: EMPTY
10670: ST_TO_ADDR
// end ;
10671: LD_VAR 0 1
10675: RET
// export function MC_Kill ( base ) ; begin
10676: LD_INT 0
10678: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
10679: LD_ADDR_EXP 56
10683: PUSH
10684: LD_EXP 56
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: EMPTY
10695: PPUSH
10696: CALL_OW 1
10700: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
10701: LD_ADDR_EXP 57
10705: PUSH
10706: LD_EXP 57
10710: PPUSH
10711: LD_VAR 0 1
10715: PPUSH
10716: EMPTY
10717: PPUSH
10718: CALL_OW 1
10722: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
10723: LD_ADDR_EXP 58
10727: PUSH
10728: LD_EXP 58
10732: PPUSH
10733: LD_VAR 0 1
10737: PPUSH
10738: EMPTY
10739: PPUSH
10740: CALL_OW 1
10744: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
10745: LD_ADDR_EXP 59
10749: PUSH
10750: LD_EXP 59
10754: PPUSH
10755: LD_VAR 0 1
10759: PPUSH
10760: EMPTY
10761: PPUSH
10762: CALL_OW 1
10766: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
10767: LD_ADDR_EXP 60
10771: PUSH
10772: LD_EXP 60
10776: PPUSH
10777: LD_VAR 0 1
10781: PPUSH
10782: EMPTY
10783: PPUSH
10784: CALL_OW 1
10788: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
10789: LD_ADDR_EXP 61
10793: PUSH
10794: LD_EXP 61
10798: PPUSH
10799: LD_VAR 0 1
10803: PPUSH
10804: EMPTY
10805: PPUSH
10806: CALL_OW 1
10810: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
10811: LD_ADDR_EXP 62
10815: PUSH
10816: LD_EXP 62
10820: PPUSH
10821: LD_VAR 0 1
10825: PPUSH
10826: EMPTY
10827: PPUSH
10828: CALL_OW 1
10832: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
10833: LD_ADDR_EXP 63
10837: PUSH
10838: LD_EXP 63
10842: PPUSH
10843: LD_VAR 0 1
10847: PPUSH
10848: EMPTY
10849: PPUSH
10850: CALL_OW 1
10854: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
10855: LD_ADDR_EXP 64
10859: PUSH
10860: LD_EXP 64
10864: PPUSH
10865: LD_VAR 0 1
10869: PPUSH
10870: EMPTY
10871: PPUSH
10872: CALL_OW 1
10876: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
10877: LD_ADDR_EXP 65
10881: PUSH
10882: LD_EXP 65
10886: PPUSH
10887: LD_VAR 0 1
10891: PPUSH
10892: EMPTY
10893: PPUSH
10894: CALL_OW 1
10898: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
10899: LD_ADDR_EXP 66
10903: PUSH
10904: LD_EXP 66
10908: PPUSH
10909: LD_VAR 0 1
10913: PPUSH
10914: EMPTY
10915: PPUSH
10916: CALL_OW 1
10920: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
10921: LD_ADDR_EXP 67
10925: PUSH
10926: LD_EXP 67
10930: PPUSH
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 0
10938: PPUSH
10939: CALL_OW 1
10943: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
10944: LD_ADDR_EXP 68
10948: PUSH
10949: LD_EXP 68
10953: PPUSH
10954: LD_VAR 0 1
10958: PPUSH
10959: EMPTY
10960: PPUSH
10961: CALL_OW 1
10965: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
10966: LD_ADDR_EXP 69
10970: PUSH
10971: LD_EXP 69
10975: PPUSH
10976: LD_VAR 0 1
10980: PPUSH
10981: EMPTY
10982: PPUSH
10983: CALL_OW 1
10987: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
10988: LD_ADDR_EXP 70
10992: PUSH
10993: LD_EXP 70
10997: PPUSH
10998: LD_VAR 0 1
11002: PPUSH
11003: EMPTY
11004: PPUSH
11005: CALL_OW 1
11009: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
11010: LD_ADDR_EXP 71
11014: PUSH
11015: LD_EXP 71
11019: PPUSH
11020: LD_VAR 0 1
11024: PPUSH
11025: EMPTY
11026: PPUSH
11027: CALL_OW 1
11031: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
11032: LD_ADDR_EXP 72
11036: PUSH
11037: LD_EXP 72
11041: PPUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: EMPTY
11048: PPUSH
11049: CALL_OW 1
11053: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
11054: LD_ADDR_EXP 73
11058: PUSH
11059: LD_EXP 73
11063: PPUSH
11064: LD_VAR 0 1
11068: PPUSH
11069: EMPTY
11070: PPUSH
11071: CALL_OW 1
11075: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
11076: LD_ADDR_EXP 74
11080: PUSH
11081: LD_EXP 74
11085: PPUSH
11086: LD_VAR 0 1
11090: PPUSH
11091: EMPTY
11092: PPUSH
11093: CALL_OW 1
11097: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
11098: LD_ADDR_EXP 75
11102: PUSH
11103: LD_EXP 75
11107: PPUSH
11108: LD_VAR 0 1
11112: PPUSH
11113: EMPTY
11114: PPUSH
11115: CALL_OW 1
11119: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
11120: LD_ADDR_EXP 76
11124: PUSH
11125: LD_EXP 76
11129: PPUSH
11130: LD_VAR 0 1
11134: PPUSH
11135: EMPTY
11136: PPUSH
11137: CALL_OW 1
11141: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
11142: LD_ADDR_EXP 77
11146: PUSH
11147: LD_EXP 77
11151: PPUSH
11152: LD_VAR 0 1
11156: PPUSH
11157: EMPTY
11158: PPUSH
11159: CALL_OW 1
11163: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
11164: LD_ADDR_EXP 78
11168: PUSH
11169: LD_EXP 78
11173: PPUSH
11174: LD_VAR 0 1
11178: PPUSH
11179: EMPTY
11180: PPUSH
11181: CALL_OW 1
11185: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
11186: LD_ADDR_EXP 79
11190: PUSH
11191: LD_EXP 79
11195: PPUSH
11196: LD_VAR 0 1
11200: PPUSH
11201: EMPTY
11202: PPUSH
11203: CALL_OW 1
11207: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
11208: LD_ADDR_EXP 80
11212: PUSH
11213: LD_EXP 80
11217: PPUSH
11218: LD_VAR 0 1
11222: PPUSH
11223: EMPTY
11224: PPUSH
11225: CALL_OW 1
11229: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
11230: LD_ADDR_EXP 81
11234: PUSH
11235: LD_EXP 81
11239: PPUSH
11240: LD_VAR 0 1
11244: PPUSH
11245: EMPTY
11246: PPUSH
11247: CALL_OW 1
11251: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
11252: LD_ADDR_EXP 83
11256: PUSH
11257: LD_EXP 83
11261: PPUSH
11262: LD_VAR 0 1
11266: PPUSH
11267: EMPTY
11268: PPUSH
11269: CALL_OW 1
11273: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
11274: LD_ADDR_EXP 85
11278: PUSH
11279: LD_EXP 85
11283: PPUSH
11284: LD_VAR 0 1
11288: PPUSH
11289: EMPTY
11290: PPUSH
11291: CALL_OW 1
11295: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
11296: LD_ADDR_EXP 86
11300: PUSH
11301: LD_EXP 86
11305: PPUSH
11306: LD_VAR 0 1
11310: PPUSH
11311: EMPTY
11312: PPUSH
11313: CALL_OW 1
11317: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
11318: LD_ADDR_EXP 87
11322: PUSH
11323: LD_EXP 87
11327: PPUSH
11328: LD_VAR 0 1
11332: PPUSH
11333: EMPTY
11334: PPUSH
11335: CALL_OW 1
11339: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
11340: LD_ADDR_EXP 88
11344: PUSH
11345: LD_EXP 88
11349: PPUSH
11350: LD_VAR 0 1
11354: PPUSH
11355: EMPTY
11356: PPUSH
11357: CALL_OW 1
11361: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
11362: LD_ADDR_EXP 89
11366: PUSH
11367: LD_EXP 89
11371: PPUSH
11372: LD_VAR 0 1
11376: PPUSH
11377: EMPTY
11378: PPUSH
11379: CALL_OW 1
11383: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
11384: LD_ADDR_EXP 90
11388: PUSH
11389: LD_EXP 90
11393: PPUSH
11394: LD_VAR 0 1
11398: PPUSH
11399: EMPTY
11400: PPUSH
11401: CALL_OW 1
11405: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
11406: LD_ADDR_EXP 91
11410: PUSH
11411: LD_EXP 91
11415: PPUSH
11416: LD_VAR 0 1
11420: PPUSH
11421: EMPTY
11422: PPUSH
11423: CALL_OW 1
11427: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
11428: LD_ADDR_EXP 92
11432: PUSH
11433: LD_EXP 92
11437: PPUSH
11438: LD_VAR 0 1
11442: PPUSH
11443: EMPTY
11444: PPUSH
11445: CALL_OW 1
11449: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
11450: LD_ADDR_EXP 93
11454: PUSH
11455: LD_EXP 93
11459: PPUSH
11460: LD_VAR 0 1
11464: PPUSH
11465: EMPTY
11466: PPUSH
11467: CALL_OW 1
11471: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
11472: LD_ADDR_EXP 94
11476: PUSH
11477: LD_EXP 94
11481: PPUSH
11482: LD_VAR 0 1
11486: PPUSH
11487: EMPTY
11488: PPUSH
11489: CALL_OW 1
11493: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
11494: LD_ADDR_EXP 95
11498: PUSH
11499: LD_EXP 95
11503: PPUSH
11504: LD_VAR 0 1
11508: PPUSH
11509: EMPTY
11510: PPUSH
11511: CALL_OW 1
11515: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
11516: LD_ADDR_EXP 96
11520: PUSH
11521: LD_EXP 96
11525: PPUSH
11526: LD_VAR 0 1
11530: PPUSH
11531: EMPTY
11532: PPUSH
11533: CALL_OW 1
11537: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
11538: LD_ADDR_EXP 97
11542: PUSH
11543: LD_EXP 97
11547: PPUSH
11548: LD_VAR 0 1
11552: PPUSH
11553: EMPTY
11554: PPUSH
11555: CALL_OW 1
11559: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
11560: LD_ADDR_EXP 98
11564: PUSH
11565: LD_EXP 98
11569: PPUSH
11570: LD_VAR 0 1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 1
11582: ST_TO_ADDR
// end ;
11583: LD_VAR 0 2
11587: RET
// export function MC_Add ( side , units ) ; var base ; begin
11588: LD_INT 0
11590: PPUSH
11591: PPUSH
// base := mc_bases + 1 ;
11592: LD_ADDR_VAR 0 4
11596: PUSH
11597: LD_EXP 56
11601: PUSH
11602: LD_INT 1
11604: PLUS
11605: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
11606: LD_ADDR_EXP 82
11610: PUSH
11611: LD_EXP 82
11615: PPUSH
11616: LD_VAR 0 4
11620: PPUSH
11621: LD_VAR 0 1
11625: PPUSH
11626: CALL_OW 1
11630: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
11631: LD_ADDR_EXP 56
11635: PUSH
11636: LD_EXP 56
11640: PPUSH
11641: LD_VAR 0 4
11645: PPUSH
11646: LD_VAR 0 2
11650: PPUSH
11651: CALL_OW 1
11655: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
11656: LD_ADDR_EXP 57
11660: PUSH
11661: LD_EXP 57
11665: PPUSH
11666: LD_VAR 0 4
11670: PPUSH
11671: EMPTY
11672: PPUSH
11673: CALL_OW 1
11677: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
11678: LD_ADDR_EXP 58
11682: PUSH
11683: LD_EXP 58
11687: PPUSH
11688: LD_VAR 0 4
11692: PPUSH
11693: EMPTY
11694: PPUSH
11695: CALL_OW 1
11699: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
11700: LD_ADDR_EXP 59
11704: PUSH
11705: LD_EXP 59
11709: PPUSH
11710: LD_VAR 0 4
11714: PPUSH
11715: EMPTY
11716: PPUSH
11717: CALL_OW 1
11721: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
11722: LD_ADDR_EXP 60
11726: PUSH
11727: LD_EXP 60
11731: PPUSH
11732: LD_VAR 0 4
11736: PPUSH
11737: EMPTY
11738: PPUSH
11739: CALL_OW 1
11743: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
11744: LD_ADDR_EXP 61
11748: PUSH
11749: LD_EXP 61
11753: PPUSH
11754: LD_VAR 0 4
11758: PPUSH
11759: EMPTY
11760: PPUSH
11761: CALL_OW 1
11765: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
11766: LD_ADDR_EXP 62
11770: PUSH
11771: LD_EXP 62
11775: PPUSH
11776: LD_VAR 0 4
11780: PPUSH
11781: EMPTY
11782: PPUSH
11783: CALL_OW 1
11787: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
11788: LD_ADDR_EXP 63
11792: PUSH
11793: LD_EXP 63
11797: PPUSH
11798: LD_VAR 0 4
11802: PPUSH
11803: EMPTY
11804: PPUSH
11805: CALL_OW 1
11809: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
11810: LD_ADDR_EXP 64
11814: PUSH
11815: LD_EXP 64
11819: PPUSH
11820: LD_VAR 0 4
11824: PPUSH
11825: EMPTY
11826: PPUSH
11827: CALL_OW 1
11831: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
11832: LD_ADDR_EXP 65
11836: PUSH
11837: LD_EXP 65
11841: PPUSH
11842: LD_VAR 0 4
11846: PPUSH
11847: EMPTY
11848: PPUSH
11849: CALL_OW 1
11853: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
11854: LD_ADDR_EXP 66
11858: PUSH
11859: LD_EXP 66
11863: PPUSH
11864: LD_VAR 0 4
11868: PPUSH
11869: EMPTY
11870: PPUSH
11871: CALL_OW 1
11875: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
11876: LD_ADDR_EXP 67
11880: PUSH
11881: LD_EXP 67
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: LD_INT 0
11893: PPUSH
11894: CALL_OW 1
11898: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
11899: LD_ADDR_EXP 68
11903: PUSH
11904: LD_EXP 68
11908: PPUSH
11909: LD_VAR 0 4
11913: PPUSH
11914: EMPTY
11915: PPUSH
11916: CALL_OW 1
11920: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
11921: LD_ADDR_EXP 69
11925: PUSH
11926: LD_EXP 69
11930: PPUSH
11931: LD_VAR 0 4
11935: PPUSH
11936: EMPTY
11937: PPUSH
11938: CALL_OW 1
11942: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
11943: LD_ADDR_EXP 70
11947: PUSH
11948: LD_EXP 70
11952: PPUSH
11953: LD_VAR 0 4
11957: PPUSH
11958: EMPTY
11959: PPUSH
11960: CALL_OW 1
11964: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
11965: LD_ADDR_EXP 71
11969: PUSH
11970: LD_EXP 71
11974: PPUSH
11975: LD_VAR 0 4
11979: PPUSH
11980: EMPTY
11981: PPUSH
11982: CALL_OW 1
11986: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
11987: LD_ADDR_EXP 72
11991: PUSH
11992: LD_EXP 72
11996: PPUSH
11997: LD_VAR 0 4
12001: PPUSH
12002: EMPTY
12003: PPUSH
12004: CALL_OW 1
12008: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
12009: LD_ADDR_EXP 73
12013: PUSH
12014: LD_EXP 73
12018: PPUSH
12019: LD_VAR 0 4
12023: PPUSH
12024: EMPTY
12025: PPUSH
12026: CALL_OW 1
12030: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
12031: LD_ADDR_EXP 74
12035: PUSH
12036: LD_EXP 74
12040: PPUSH
12041: LD_VAR 0 4
12045: PPUSH
12046: EMPTY
12047: PPUSH
12048: CALL_OW 1
12052: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
12053: LD_ADDR_EXP 75
12057: PUSH
12058: LD_EXP 75
12062: PPUSH
12063: LD_VAR 0 4
12067: PPUSH
12068: EMPTY
12069: PPUSH
12070: CALL_OW 1
12074: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
12075: LD_ADDR_EXP 76
12079: PUSH
12080: LD_EXP 76
12084: PPUSH
12085: LD_VAR 0 4
12089: PPUSH
12090: EMPTY
12091: PPUSH
12092: CALL_OW 1
12096: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
12097: LD_ADDR_EXP 77
12101: PUSH
12102: LD_EXP 77
12106: PPUSH
12107: LD_VAR 0 4
12111: PPUSH
12112: EMPTY
12113: PPUSH
12114: CALL_OW 1
12118: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
12119: LD_ADDR_EXP 78
12123: PUSH
12124: LD_EXP 78
12128: PPUSH
12129: LD_VAR 0 4
12133: PPUSH
12134: EMPTY
12135: PPUSH
12136: CALL_OW 1
12140: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
12141: LD_ADDR_EXP 79
12145: PUSH
12146: LD_EXP 79
12150: PPUSH
12151: LD_VAR 0 4
12155: PPUSH
12156: EMPTY
12157: PPUSH
12158: CALL_OW 1
12162: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
12163: LD_ADDR_EXP 80
12167: PUSH
12168: LD_EXP 80
12172: PPUSH
12173: LD_VAR 0 4
12177: PPUSH
12178: EMPTY
12179: PPUSH
12180: CALL_OW 1
12184: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
12185: LD_ADDR_EXP 81
12189: PUSH
12190: LD_EXP 81
12194: PPUSH
12195: LD_VAR 0 4
12199: PPUSH
12200: EMPTY
12201: PPUSH
12202: CALL_OW 1
12206: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
12207: LD_ADDR_EXP 83
12211: PUSH
12212: LD_EXP 83
12216: PPUSH
12217: LD_VAR 0 4
12221: PPUSH
12222: EMPTY
12223: PPUSH
12224: CALL_OW 1
12228: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
12229: LD_ADDR_EXP 85
12233: PUSH
12234: LD_EXP 85
12238: PPUSH
12239: LD_VAR 0 4
12243: PPUSH
12244: EMPTY
12245: PPUSH
12246: CALL_OW 1
12250: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
12251: LD_ADDR_EXP 86
12255: PUSH
12256: LD_EXP 86
12260: PPUSH
12261: LD_VAR 0 4
12265: PPUSH
12266: EMPTY
12267: PPUSH
12268: CALL_OW 1
12272: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
12273: LD_ADDR_EXP 87
12277: PUSH
12278: LD_EXP 87
12282: PPUSH
12283: LD_VAR 0 4
12287: PPUSH
12288: EMPTY
12289: PPUSH
12290: CALL_OW 1
12294: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
12295: LD_ADDR_EXP 88
12299: PUSH
12300: LD_EXP 88
12304: PPUSH
12305: LD_VAR 0 4
12309: PPUSH
12310: EMPTY
12311: PPUSH
12312: CALL_OW 1
12316: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
12317: LD_ADDR_EXP 89
12321: PUSH
12322: LD_EXP 89
12326: PPUSH
12327: LD_VAR 0 4
12331: PPUSH
12332: EMPTY
12333: PPUSH
12334: CALL_OW 1
12338: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
12339: LD_ADDR_EXP 90
12343: PUSH
12344: LD_EXP 90
12348: PPUSH
12349: LD_VAR 0 4
12353: PPUSH
12354: EMPTY
12355: PPUSH
12356: CALL_OW 1
12360: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
12361: LD_ADDR_EXP 91
12365: PUSH
12366: LD_EXP 91
12370: PPUSH
12371: LD_VAR 0 4
12375: PPUSH
12376: EMPTY
12377: PPUSH
12378: CALL_OW 1
12382: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
12383: LD_ADDR_EXP 92
12387: PUSH
12388: LD_EXP 92
12392: PPUSH
12393: LD_VAR 0 4
12397: PPUSH
12398: EMPTY
12399: PPUSH
12400: CALL_OW 1
12404: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
12405: LD_ADDR_EXP 93
12409: PUSH
12410: LD_EXP 93
12414: PPUSH
12415: LD_VAR 0 4
12419: PPUSH
12420: EMPTY
12421: PPUSH
12422: CALL_OW 1
12426: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
12427: LD_ADDR_EXP 94
12431: PUSH
12432: LD_EXP 94
12436: PPUSH
12437: LD_VAR 0 4
12441: PPUSH
12442: EMPTY
12443: PPUSH
12444: CALL_OW 1
12448: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
12449: LD_ADDR_EXP 95
12453: PUSH
12454: LD_EXP 95
12458: PPUSH
12459: LD_VAR 0 4
12463: PPUSH
12464: EMPTY
12465: PPUSH
12466: CALL_OW 1
12470: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
12471: LD_ADDR_EXP 96
12475: PUSH
12476: LD_EXP 96
12480: PPUSH
12481: LD_VAR 0 4
12485: PPUSH
12486: EMPTY
12487: PPUSH
12488: CALL_OW 1
12492: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
12493: LD_ADDR_EXP 97
12497: PUSH
12498: LD_EXP 97
12502: PPUSH
12503: LD_VAR 0 4
12507: PPUSH
12508: EMPTY
12509: PPUSH
12510: CALL_OW 1
12514: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
12515: LD_ADDR_EXP 98
12519: PUSH
12520: LD_EXP 98
12524: PPUSH
12525: LD_VAR 0 4
12529: PPUSH
12530: LD_INT 0
12532: PPUSH
12533: CALL_OW 1
12537: ST_TO_ADDR
// result := base ;
12538: LD_ADDR_VAR 0 3
12542: PUSH
12543: LD_VAR 0 4
12547: ST_TO_ADDR
// end ;
12548: LD_VAR 0 3
12552: RET
// export function MC_Start ( ) ; var i ; begin
12553: LD_INT 0
12555: PPUSH
12556: PPUSH
// for i = 1 to mc_bases do
12557: LD_ADDR_VAR 0 2
12561: PUSH
12562: DOUBLE
12563: LD_INT 1
12565: DEC
12566: ST_TO_ADDR
12567: LD_EXP 56
12571: PUSH
12572: FOR_TO
12573: IFFALSE 13650
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
12575: LD_ADDR_EXP 56
12579: PUSH
12580: LD_EXP 56
12584: PPUSH
12585: LD_VAR 0 2
12589: PPUSH
12590: LD_EXP 56
12594: PUSH
12595: LD_VAR 0 2
12599: ARRAY
12600: PUSH
12601: LD_INT 0
12603: DIFF
12604: PPUSH
12605: CALL_OW 1
12609: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
12610: LD_ADDR_EXP 57
12614: PUSH
12615: LD_EXP 57
12619: PPUSH
12620: LD_VAR 0 2
12624: PPUSH
12625: EMPTY
12626: PPUSH
12627: CALL_OW 1
12631: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
12632: LD_ADDR_EXP 58
12636: PUSH
12637: LD_EXP 58
12641: PPUSH
12642: LD_VAR 0 2
12646: PPUSH
12647: EMPTY
12648: PPUSH
12649: CALL_OW 1
12653: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
12654: LD_ADDR_EXP 59
12658: PUSH
12659: LD_EXP 59
12663: PPUSH
12664: LD_VAR 0 2
12668: PPUSH
12669: EMPTY
12670: PPUSH
12671: CALL_OW 1
12675: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
12676: LD_ADDR_EXP 60
12680: PUSH
12681: LD_EXP 60
12685: PPUSH
12686: LD_VAR 0 2
12690: PPUSH
12691: EMPTY
12692: PUSH
12693: EMPTY
12694: PUSH
12695: EMPTY
12696: LIST
12697: LIST
12698: PPUSH
12699: CALL_OW 1
12703: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
12704: LD_ADDR_EXP 61
12708: PUSH
12709: LD_EXP 61
12713: PPUSH
12714: LD_VAR 0 2
12718: PPUSH
12719: EMPTY
12720: PPUSH
12721: CALL_OW 1
12725: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
12726: LD_ADDR_EXP 88
12730: PUSH
12731: LD_EXP 88
12735: PPUSH
12736: LD_VAR 0 2
12740: PPUSH
12741: EMPTY
12742: PPUSH
12743: CALL_OW 1
12747: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
12748: LD_ADDR_EXP 62
12752: PUSH
12753: LD_EXP 62
12757: PPUSH
12758: LD_VAR 0 2
12762: PPUSH
12763: EMPTY
12764: PPUSH
12765: CALL_OW 1
12769: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
12770: LD_ADDR_EXP 63
12774: PUSH
12775: LD_EXP 63
12779: PPUSH
12780: LD_VAR 0 2
12784: PPUSH
12785: EMPTY
12786: PPUSH
12787: CALL_OW 1
12791: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
12792: LD_ADDR_EXP 64
12796: PUSH
12797: LD_EXP 64
12801: PPUSH
12802: LD_VAR 0 2
12806: PPUSH
12807: LD_EXP 56
12811: PUSH
12812: LD_VAR 0 2
12816: ARRAY
12817: PPUSH
12818: LD_INT 2
12820: PUSH
12821: LD_INT 30
12823: PUSH
12824: LD_INT 32
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 30
12833: PUSH
12834: LD_INT 33
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: LIST
12845: PPUSH
12846: CALL_OW 72
12850: PPUSH
12851: CALL_OW 1
12855: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
12856: LD_ADDR_EXP 65
12860: PUSH
12861: LD_EXP 65
12865: PPUSH
12866: LD_VAR 0 2
12870: PPUSH
12871: LD_EXP 56
12875: PUSH
12876: LD_VAR 0 2
12880: ARRAY
12881: PPUSH
12882: LD_INT 2
12884: PUSH
12885: LD_INT 30
12887: PUSH
12888: LD_INT 32
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: LD_INT 30
12897: PUSH
12898: LD_INT 31
12900: PUSH
12901: EMPTY
12902: LIST
12903: LIST
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 58
12912: PUSH
12913: EMPTY
12914: LIST
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: PPUSH
12920: CALL_OW 72
12924: PPUSH
12925: CALL_OW 1
12929: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
12930: LD_ADDR_EXP 66
12934: PUSH
12935: LD_EXP 66
12939: PPUSH
12940: LD_VAR 0 2
12944: PPUSH
12945: EMPTY
12946: PPUSH
12947: CALL_OW 1
12951: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
12952: LD_ADDR_EXP 70
12956: PUSH
12957: LD_EXP 70
12961: PPUSH
12962: LD_VAR 0 2
12966: PPUSH
12967: EMPTY
12968: PPUSH
12969: CALL_OW 1
12973: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
12974: LD_ADDR_EXP 69
12978: PUSH
12979: LD_EXP 69
12983: PPUSH
12984: LD_VAR 0 2
12988: PPUSH
12989: EMPTY
12990: PPUSH
12991: CALL_OW 1
12995: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
12996: LD_ADDR_EXP 71
13000: PUSH
13001: LD_EXP 71
13005: PPUSH
13006: LD_VAR 0 2
13010: PPUSH
13011: EMPTY
13012: PPUSH
13013: CALL_OW 1
13017: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
13018: LD_ADDR_EXP 72
13022: PUSH
13023: LD_EXP 72
13027: PPUSH
13028: LD_VAR 0 2
13032: PPUSH
13033: EMPTY
13034: PPUSH
13035: CALL_OW 1
13039: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
13040: LD_ADDR_EXP 73
13044: PUSH
13045: LD_EXP 73
13049: PPUSH
13050: LD_VAR 0 2
13054: PPUSH
13055: EMPTY
13056: PPUSH
13057: CALL_OW 1
13061: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
13062: LD_ADDR_EXP 74
13066: PUSH
13067: LD_EXP 74
13071: PPUSH
13072: LD_VAR 0 2
13076: PPUSH
13077: EMPTY
13078: PPUSH
13079: CALL_OW 1
13083: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
13084: LD_ADDR_EXP 75
13088: PUSH
13089: LD_EXP 75
13093: PPUSH
13094: LD_VAR 0 2
13098: PPUSH
13099: EMPTY
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
13106: LD_ADDR_EXP 76
13110: PUSH
13111: LD_EXP 76
13115: PPUSH
13116: LD_VAR 0 2
13120: PPUSH
13121: EMPTY
13122: PPUSH
13123: CALL_OW 1
13127: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
13128: LD_ADDR_EXP 77
13132: PUSH
13133: LD_EXP 77
13137: PPUSH
13138: LD_VAR 0 2
13142: PPUSH
13143: EMPTY
13144: PPUSH
13145: CALL_OW 1
13149: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
13150: LD_ADDR_EXP 78
13154: PUSH
13155: LD_EXP 78
13159: PPUSH
13160: LD_VAR 0 2
13164: PPUSH
13165: EMPTY
13166: PPUSH
13167: CALL_OW 1
13171: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
13172: LD_ADDR_EXP 67
13176: PUSH
13177: LD_EXP 67
13181: PPUSH
13182: LD_VAR 0 2
13186: PPUSH
13187: LD_INT 0
13189: PPUSH
13190: CALL_OW 1
13194: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
13195: LD_ADDR_EXP 80
13199: PUSH
13200: LD_EXP 80
13204: PPUSH
13205: LD_VAR 0 2
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 1
13217: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
13218: LD_ADDR_EXP 68
13222: PUSH
13223: LD_EXP 68
13227: PPUSH
13228: LD_VAR 0 2
13232: PPUSH
13233: EMPTY
13234: PPUSH
13235: CALL_OW 1
13239: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
13240: LD_ADDR_EXP 79
13244: PUSH
13245: LD_EXP 79
13249: PPUSH
13250: LD_VAR 0 2
13254: PPUSH
13255: LD_INT 0
13257: PPUSH
13258: CALL_OW 1
13262: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
13263: LD_ADDR_EXP 81
13267: PUSH
13268: LD_EXP 81
13272: PPUSH
13273: LD_VAR 0 2
13277: PPUSH
13278: EMPTY
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
13285: LD_ADDR_EXP 84
13289: PUSH
13290: LD_EXP 84
13294: PPUSH
13295: LD_VAR 0 2
13299: PPUSH
13300: LD_INT 0
13302: PPUSH
13303: CALL_OW 1
13307: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
13308: LD_ADDR_EXP 85
13312: PUSH
13313: LD_EXP 85
13317: PPUSH
13318: LD_VAR 0 2
13322: PPUSH
13323: EMPTY
13324: PPUSH
13325: CALL_OW 1
13329: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
13330: LD_ADDR_EXP 86
13334: PUSH
13335: LD_EXP 86
13339: PPUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: EMPTY
13346: PPUSH
13347: CALL_OW 1
13351: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
13352: LD_ADDR_EXP 87
13356: PUSH
13357: LD_EXP 87
13361: PPUSH
13362: LD_VAR 0 2
13366: PPUSH
13367: EMPTY
13368: PPUSH
13369: CALL_OW 1
13373: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
13374: LD_ADDR_EXP 89
13378: PUSH
13379: LD_EXP 89
13383: PPUSH
13384: LD_VAR 0 2
13388: PPUSH
13389: LD_EXP 56
13393: PUSH
13394: LD_VAR 0 2
13398: ARRAY
13399: PPUSH
13400: LD_INT 2
13402: PUSH
13403: LD_INT 30
13405: PUSH
13406: LD_INT 6
13408: PUSH
13409: EMPTY
13410: LIST
13411: LIST
13412: PUSH
13413: LD_INT 30
13415: PUSH
13416: LD_INT 7
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PUSH
13423: LD_INT 30
13425: PUSH
13426: LD_INT 8
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 72
13443: PPUSH
13444: CALL_OW 1
13448: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
13449: LD_ADDR_EXP 90
13453: PUSH
13454: LD_EXP 90
13458: PPUSH
13459: LD_VAR 0 2
13463: PPUSH
13464: EMPTY
13465: PPUSH
13466: CALL_OW 1
13470: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
13471: LD_ADDR_EXP 91
13475: PUSH
13476: LD_EXP 91
13480: PPUSH
13481: LD_VAR 0 2
13485: PPUSH
13486: EMPTY
13487: PPUSH
13488: CALL_OW 1
13492: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
13493: LD_ADDR_EXP 92
13497: PUSH
13498: LD_EXP 92
13502: PPUSH
13503: LD_VAR 0 2
13507: PPUSH
13508: EMPTY
13509: PPUSH
13510: CALL_OW 1
13514: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
13515: LD_ADDR_EXP 93
13519: PUSH
13520: LD_EXP 93
13524: PPUSH
13525: LD_VAR 0 2
13529: PPUSH
13530: EMPTY
13531: PPUSH
13532: CALL_OW 1
13536: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
13537: LD_ADDR_EXP 94
13541: PUSH
13542: LD_EXP 94
13546: PPUSH
13547: LD_VAR 0 2
13551: PPUSH
13552: EMPTY
13553: PPUSH
13554: CALL_OW 1
13558: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
13559: LD_ADDR_EXP 95
13563: PUSH
13564: LD_EXP 95
13568: PPUSH
13569: LD_VAR 0 2
13573: PPUSH
13574: EMPTY
13575: PPUSH
13576: CALL_OW 1
13580: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
13581: LD_ADDR_EXP 96
13585: PUSH
13586: LD_EXP 96
13590: PPUSH
13591: LD_VAR 0 2
13595: PPUSH
13596: EMPTY
13597: PPUSH
13598: CALL_OW 1
13602: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
13603: LD_ADDR_EXP 97
13607: PUSH
13608: LD_EXP 97
13612: PPUSH
13613: LD_VAR 0 2
13617: PPUSH
13618: EMPTY
13619: PPUSH
13620: CALL_OW 1
13624: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
13625: LD_ADDR_EXP 98
13629: PUSH
13630: LD_EXP 98
13634: PPUSH
13635: LD_VAR 0 2
13639: PPUSH
13640: LD_INT 0
13642: PPUSH
13643: CALL_OW 1
13647: ST_TO_ADDR
// end ;
13648: GO 12572
13650: POP
13651: POP
// MC_InitSides ( ) ;
13652: CALL 13938 0 0
// MC_InitResearch ( ) ;
13656: CALL 13677 0 0
// CustomInitMacro ( ) ;
13660: CALL 113 0 0
// skirmish := true ;
13664: LD_ADDR_EXP 54
13668: PUSH
13669: LD_INT 1
13671: ST_TO_ADDR
// end ;
13672: LD_VAR 0 1
13676: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
13677: LD_INT 0
13679: PPUSH
13680: PPUSH
13681: PPUSH
13682: PPUSH
13683: PPUSH
13684: PPUSH
// if not mc_bases then
13685: LD_EXP 56
13689: NOT
13690: IFFALSE 13694
// exit ;
13692: GO 13933
// for i = 1 to 8 do
13694: LD_ADDR_VAR 0 2
13698: PUSH
13699: DOUBLE
13700: LD_INT 1
13702: DEC
13703: ST_TO_ADDR
13704: LD_INT 8
13706: PUSH
13707: FOR_TO
13708: IFFALSE 13734
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
13710: LD_ADDR_EXP 83
13714: PUSH
13715: LD_EXP 83
13719: PPUSH
13720: LD_VAR 0 2
13724: PPUSH
13725: EMPTY
13726: PPUSH
13727: CALL_OW 1
13731: ST_TO_ADDR
13732: GO 13707
13734: POP
13735: POP
// tmp := [ ] ;
13736: LD_ADDR_VAR 0 5
13740: PUSH
13741: EMPTY
13742: ST_TO_ADDR
// for i = 1 to mc_sides do
13743: LD_ADDR_VAR 0 2
13747: PUSH
13748: DOUBLE
13749: LD_INT 1
13751: DEC
13752: ST_TO_ADDR
13753: LD_EXP 82
13757: PUSH
13758: FOR_TO
13759: IFFALSE 13817
// if not mc_sides [ i ] in tmp then
13761: LD_EXP 82
13765: PUSH
13766: LD_VAR 0 2
13770: ARRAY
13771: PUSH
13772: LD_VAR 0 5
13776: IN
13777: NOT
13778: IFFALSE 13815
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
13780: LD_ADDR_VAR 0 5
13784: PUSH
13785: LD_VAR 0 5
13789: PPUSH
13790: LD_VAR 0 5
13794: PUSH
13795: LD_INT 1
13797: PLUS
13798: PPUSH
13799: LD_EXP 82
13803: PUSH
13804: LD_VAR 0 2
13808: ARRAY
13809: PPUSH
13810: CALL_OW 2
13814: ST_TO_ADDR
13815: GO 13758
13817: POP
13818: POP
// if not tmp then
13819: LD_VAR 0 5
13823: NOT
13824: IFFALSE 13828
// exit ;
13826: GO 13933
// for j in tmp do
13828: LD_ADDR_VAR 0 3
13832: PUSH
13833: LD_VAR 0 5
13837: PUSH
13838: FOR_IN
13839: IFFALSE 13931
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
13841: LD_ADDR_VAR 0 6
13845: PUSH
13846: LD_INT 22
13848: PUSH
13849: LD_VAR 0 3
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: PPUSH
13858: CALL_OW 69
13862: ST_TO_ADDR
// if not un then
13863: LD_VAR 0 6
13867: NOT
13868: IFFALSE 13872
// continue ;
13870: GO 13838
// nation := GetNation ( un [ 1 ] ) ;
13872: LD_ADDR_VAR 0 4
13876: PUSH
13877: LD_VAR 0 6
13881: PUSH
13882: LD_INT 1
13884: ARRAY
13885: PPUSH
13886: CALL_OW 248
13890: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
13891: LD_ADDR_EXP 83
13895: PUSH
13896: LD_EXP 83
13900: PPUSH
13901: LD_VAR 0 3
13905: PPUSH
13906: LD_VAR 0 3
13910: PPUSH
13911: LD_VAR 0 4
13915: PPUSH
13916: LD_INT 1
13918: PPUSH
13919: CALL 40209 0 3
13923: PPUSH
13924: CALL_OW 1
13928: ST_TO_ADDR
// end ;
13929: GO 13838
13931: POP
13932: POP
// end ;
13933: LD_VAR 0 1
13937: RET
// export function MC_InitSides ( ) ; var i ; begin
13938: LD_INT 0
13940: PPUSH
13941: PPUSH
// if not mc_bases then
13942: LD_EXP 56
13946: NOT
13947: IFFALSE 13951
// exit ;
13949: GO 14025
// for i = 1 to mc_bases do
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: DOUBLE
13957: LD_INT 1
13959: DEC
13960: ST_TO_ADDR
13961: LD_EXP 56
13965: PUSH
13966: FOR_TO
13967: IFFALSE 14023
// if mc_bases [ i ] then
13969: LD_EXP 56
13973: PUSH
13974: LD_VAR 0 2
13978: ARRAY
13979: IFFALSE 14021
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
13981: LD_ADDR_EXP 82
13985: PUSH
13986: LD_EXP 82
13990: PPUSH
13991: LD_VAR 0 2
13995: PPUSH
13996: LD_EXP 56
14000: PUSH
14001: LD_VAR 0 2
14005: ARRAY
14006: PUSH
14007: LD_INT 1
14009: ARRAY
14010: PPUSH
14011: CALL_OW 255
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
14021: GO 13966
14023: POP
14024: POP
// end ;
14025: LD_VAR 0 1
14029: RET
// every 0 0$01 trigger skirmish do
14030: LD_EXP 54
14034: IFFALSE 14188
14036: GO 14038
14038: DISABLE
// begin enable ;
14039: ENABLE
// MC_CheckBuildings ( ) ;
14040: CALL 18686 0 0
// MC_CheckPeopleLife ( ) ;
14044: CALL 18811 0 0
// RaiseSailEvent ( 100 ) ;
14048: LD_INT 100
14050: PPUSH
14051: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
14055: LD_INT 103
14057: PPUSH
14058: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
14062: LD_INT 104
14064: PPUSH
14065: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
14069: LD_INT 105
14071: PPUSH
14072: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
14076: LD_INT 106
14078: PPUSH
14079: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
14083: LD_INT 107
14085: PPUSH
14086: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
14090: LD_INT 108
14092: PPUSH
14093: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
14097: LD_INT 109
14099: PPUSH
14100: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
14104: LD_INT 110
14106: PPUSH
14107: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
14111: LD_INT 111
14113: PPUSH
14114: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
14118: LD_INT 112
14120: PPUSH
14121: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
14125: LD_INT 113
14127: PPUSH
14128: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
14132: LD_INT 120
14134: PPUSH
14135: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
14139: LD_INT 121
14141: PPUSH
14142: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
14146: LD_INT 122
14148: PPUSH
14149: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
14153: LD_INT 123
14155: PPUSH
14156: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
14160: LD_INT 124
14162: PPUSH
14163: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
14167: LD_INT 125
14169: PPUSH
14170: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
14174: LD_INT 126
14176: PPUSH
14177: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
14181: LD_INT 200
14183: PPUSH
14184: CALL_OW 427
// end ;
14188: END
// on SailEvent ( event ) do begin if event < 100 then
14189: LD_VAR 0 1
14193: PUSH
14194: LD_INT 100
14196: LESS
14197: IFFALSE 14208
// CustomEvent ( event ) ;
14199: LD_VAR 0 1
14203: PPUSH
14204: CALL 9457 0 1
// if event = 100 then
14208: LD_VAR 0 1
14212: PUSH
14213: LD_INT 100
14215: EQUAL
14216: IFFALSE 14222
// MC_ClassManager ( ) ;
14218: CALL 14614 0 0
// if event = 101 then
14222: LD_VAR 0 1
14226: PUSH
14227: LD_INT 101
14229: EQUAL
14230: IFFALSE 14236
// MC_RepairBuildings ( ) ;
14232: CALL 19407 0 0
// if event = 102 then
14236: LD_VAR 0 1
14240: PUSH
14241: LD_INT 102
14243: EQUAL
14244: IFFALSE 14250
// MC_Heal ( ) ;
14246: CALL 20139 0 0
// if event = 103 then
14250: LD_VAR 0 1
14254: PUSH
14255: LD_INT 103
14257: EQUAL
14258: IFFALSE 14264
// MC_Build ( ) ;
14260: CALL 20561 0 0
// if event = 104 then
14264: LD_VAR 0 1
14268: PUSH
14269: LD_INT 104
14271: EQUAL
14272: IFFALSE 14278
// MC_TurretWeapon ( ) ;
14274: CALL 22174 0 0
// if event = 105 then
14278: LD_VAR 0 1
14282: PUSH
14283: LD_INT 105
14285: EQUAL
14286: IFFALSE 14292
// MC_BuildUpgrade ( ) ;
14288: CALL 21725 0 0
// if event = 106 then
14292: LD_VAR 0 1
14296: PUSH
14297: LD_INT 106
14299: EQUAL
14300: IFFALSE 14306
// MC_PlantMines ( ) ;
14302: CALL 22604 0 0
// if event = 107 then
14306: LD_VAR 0 1
14310: PUSH
14311: LD_INT 107
14313: EQUAL
14314: IFFALSE 14320
// MC_CollectCrates ( ) ;
14316: CALL 23638 0 0
// if event = 108 then
14320: LD_VAR 0 1
14324: PUSH
14325: LD_INT 108
14327: EQUAL
14328: IFFALSE 14334
// MC_LinkRemoteControl ( ) ;
14330: CALL 25414 0 0
// if event = 109 then
14334: LD_VAR 0 1
14338: PUSH
14339: LD_INT 109
14341: EQUAL
14342: IFFALSE 14348
// MC_ProduceVehicle ( ) ;
14344: CALL 25595 0 0
// if event = 110 then
14348: LD_VAR 0 1
14352: PUSH
14353: LD_INT 110
14355: EQUAL
14356: IFFALSE 14362
// MC_SendAttack ( ) ;
14358: CALL 26061 0 0
// if event = 111 then
14362: LD_VAR 0 1
14366: PUSH
14367: LD_INT 111
14369: EQUAL
14370: IFFALSE 14376
// MC_Defend ( ) ;
14372: CALL 26169 0 0
// if event = 112 then
14376: LD_VAR 0 1
14380: PUSH
14381: LD_INT 112
14383: EQUAL
14384: IFFALSE 14390
// MC_Research ( ) ;
14386: CALL 26774 0 0
// if event = 113 then
14390: LD_VAR 0 1
14394: PUSH
14395: LD_INT 113
14397: EQUAL
14398: IFFALSE 14404
// MC_MinesTrigger ( ) ;
14400: CALL 27888 0 0
// if event = 120 then
14404: LD_VAR 0 1
14408: PUSH
14409: LD_INT 120
14411: EQUAL
14412: IFFALSE 14418
// MC_RepairVehicle ( ) ;
14414: CALL 27987 0 0
// if event = 121 then
14418: LD_VAR 0 1
14422: PUSH
14423: LD_INT 121
14425: EQUAL
14426: IFFALSE 14432
// MC_TameApe ( ) ;
14428: CALL 28717 0 0
// if event = 122 then
14432: LD_VAR 0 1
14436: PUSH
14437: LD_INT 122
14439: EQUAL
14440: IFFALSE 14446
// MC_ChangeApeClass ( ) ;
14442: CALL 29546 0 0
// if event = 123 then
14446: LD_VAR 0 1
14450: PUSH
14451: LD_INT 123
14453: EQUAL
14454: IFFALSE 14460
// MC_Bazooka ( ) ;
14456: CALL 30196 0 0
// if event = 124 then
14460: LD_VAR 0 1
14464: PUSH
14465: LD_INT 124
14467: EQUAL
14468: IFFALSE 14474
// MC_TeleportExit ( ) ;
14470: CALL 30394 0 0
// if event = 125 then
14474: LD_VAR 0 1
14478: PUSH
14479: LD_INT 125
14481: EQUAL
14482: IFFALSE 14488
// MC_Deposits ( ) ;
14484: CALL 31041 0 0
// if event = 126 then
14488: LD_VAR 0 1
14492: PUSH
14493: LD_INT 126
14495: EQUAL
14496: IFFALSE 14502
// MC_RemoteDriver ( ) ;
14498: CALL 31666 0 0
// if event = 200 then
14502: LD_VAR 0 1
14506: PUSH
14507: LD_INT 200
14509: EQUAL
14510: IFFALSE 14516
// MC_Idle ( ) ;
14512: CALL 33399 0 0
// end ;
14516: PPOPN 1
14518: END
// export function MC_Reset ( base , tag ) ; var i ; begin
14519: LD_INT 0
14521: PPUSH
14522: PPUSH
// if not mc_bases [ base ] or not tag then
14523: LD_EXP 56
14527: PUSH
14528: LD_VAR 0 1
14532: ARRAY
14533: NOT
14534: PUSH
14535: LD_VAR 0 2
14539: NOT
14540: OR
14541: IFFALSE 14545
// exit ;
14543: GO 14609
// for i in mc_bases [ base ] union mc_ape [ base ] do
14545: LD_ADDR_VAR 0 4
14549: PUSH
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: PUSH
14561: LD_EXP 85
14565: PUSH
14566: LD_VAR 0 1
14570: ARRAY
14571: UNION
14572: PUSH
14573: FOR_IN
14574: IFFALSE 14607
// if GetTag ( i ) = tag then
14576: LD_VAR 0 4
14580: PPUSH
14581: CALL_OW 110
14585: PUSH
14586: LD_VAR 0 2
14590: EQUAL
14591: IFFALSE 14605
// SetTag ( i , 0 ) ;
14593: LD_VAR 0 4
14597: PPUSH
14598: LD_INT 0
14600: PPUSH
14601: CALL_OW 109
14605: GO 14573
14607: POP
14608: POP
// end ;
14609: LD_VAR 0 3
14613: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
14614: LD_INT 0
14616: PPUSH
14617: PPUSH
14618: PPUSH
14619: PPUSH
14620: PPUSH
14621: PPUSH
14622: PPUSH
14623: PPUSH
// if not mc_bases then
14624: LD_EXP 56
14628: NOT
14629: IFFALSE 14633
// exit ;
14631: GO 15091
// for i = 1 to mc_bases do
14633: LD_ADDR_VAR 0 2
14637: PUSH
14638: DOUBLE
14639: LD_INT 1
14641: DEC
14642: ST_TO_ADDR
14643: LD_EXP 56
14647: PUSH
14648: FOR_TO
14649: IFFALSE 15089
// begin tmp := MC_ClassCheckReq ( i ) ;
14651: LD_ADDR_VAR 0 4
14655: PUSH
14656: LD_VAR 0 2
14660: PPUSH
14661: CALL 15096 0 1
14665: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
14666: LD_ADDR_EXP 97
14670: PUSH
14671: LD_EXP 97
14675: PPUSH
14676: LD_VAR 0 2
14680: PPUSH
14681: LD_VAR 0 4
14685: PPUSH
14686: CALL_OW 1
14690: ST_TO_ADDR
// if not tmp then
14691: LD_VAR 0 4
14695: NOT
14696: IFFALSE 14700
// continue ;
14698: GO 14648
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
14700: LD_ADDR_VAR 0 6
14704: PUSH
14705: LD_EXP 56
14709: PUSH
14710: LD_VAR 0 2
14714: ARRAY
14715: PPUSH
14716: LD_INT 2
14718: PUSH
14719: LD_INT 30
14721: PUSH
14722: LD_INT 4
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PUSH
14729: LD_INT 30
14731: PUSH
14732: LD_INT 5
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: LIST
14743: PPUSH
14744: CALL_OW 72
14748: PUSH
14749: LD_EXP 56
14753: PUSH
14754: LD_VAR 0 2
14758: ARRAY
14759: PPUSH
14760: LD_INT 2
14762: PUSH
14763: LD_INT 30
14765: PUSH
14766: LD_INT 0
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PUSH
14773: LD_INT 30
14775: PUSH
14776: LD_INT 1
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 72
14792: PUSH
14793: LD_EXP 56
14797: PUSH
14798: LD_VAR 0 2
14802: ARRAY
14803: PPUSH
14804: LD_INT 30
14806: PUSH
14807: LD_INT 3
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 72
14818: PUSH
14819: LD_EXP 56
14823: PUSH
14824: LD_VAR 0 2
14828: ARRAY
14829: PPUSH
14830: LD_INT 2
14832: PUSH
14833: LD_INT 30
14835: PUSH
14836: LD_INT 6
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: PUSH
14843: LD_INT 30
14845: PUSH
14846: LD_INT 7
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 30
14855: PUSH
14856: LD_INT 8
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: PPUSH
14869: CALL_OW 72
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: LIST
14878: LIST
14879: ST_TO_ADDR
// for j = 1 to 4 do
14880: LD_ADDR_VAR 0 3
14884: PUSH
14885: DOUBLE
14886: LD_INT 1
14888: DEC
14889: ST_TO_ADDR
14890: LD_INT 4
14892: PUSH
14893: FOR_TO
14894: IFFALSE 15085
// begin if not tmp [ j ] then
14896: LD_VAR 0 4
14900: PUSH
14901: LD_VAR 0 3
14905: ARRAY
14906: NOT
14907: IFFALSE 14911
// continue ;
14909: GO 14893
// for p in tmp [ j ] do
14911: LD_ADDR_VAR 0 5
14915: PUSH
14916: LD_VAR 0 4
14920: PUSH
14921: LD_VAR 0 3
14925: ARRAY
14926: PUSH
14927: FOR_IN
14928: IFFALSE 15081
// begin if not b [ j ] then
14930: LD_VAR 0 6
14934: PUSH
14935: LD_VAR 0 3
14939: ARRAY
14940: NOT
14941: IFFALSE 14945
// break ;
14943: GO 15081
// e := 0 ;
14945: LD_ADDR_VAR 0 7
14949: PUSH
14950: LD_INT 0
14952: ST_TO_ADDR
// for k in b [ j ] do
14953: LD_ADDR_VAR 0 8
14957: PUSH
14958: LD_VAR 0 6
14962: PUSH
14963: LD_VAR 0 3
14967: ARRAY
14968: PUSH
14969: FOR_IN
14970: IFFALSE 14997
// if IsNotFull ( k ) then
14972: LD_VAR 0 8
14976: PPUSH
14977: CALL 44285 0 1
14981: IFFALSE 14995
// begin e := k ;
14983: LD_ADDR_VAR 0 7
14987: PUSH
14988: LD_VAR 0 8
14992: ST_TO_ADDR
// break ;
14993: GO 14997
// end ;
14995: GO 14969
14997: POP
14998: POP
// if e and not UnitGoingToBuilding ( p , e ) then
14999: LD_VAR 0 7
15003: PUSH
15004: LD_VAR 0 5
15008: PPUSH
15009: LD_VAR 0 7
15013: PPUSH
15014: CALL 81404 0 2
15018: NOT
15019: AND
15020: IFFALSE 15079
// begin if IsInUnit ( p ) then
15022: LD_VAR 0 5
15026: PPUSH
15027: CALL_OW 310
15031: IFFALSE 15042
// ComExitBuilding ( p ) ;
15033: LD_VAR 0 5
15037: PPUSH
15038: CALL_OW 122
// ComEnterUnit ( p , e ) ;
15042: LD_VAR 0 5
15046: PPUSH
15047: LD_VAR 0 7
15051: PPUSH
15052: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
15056: LD_VAR 0 5
15060: PPUSH
15061: LD_VAR 0 3
15065: PPUSH
15066: CALL_OW 183
// AddComExitBuilding ( p ) ;
15070: LD_VAR 0 5
15074: PPUSH
15075: CALL_OW 182
// end ; end ;
15079: GO 14927
15081: POP
15082: POP
// end ;
15083: GO 14893
15085: POP
15086: POP
// end ;
15087: GO 14648
15089: POP
15090: POP
// end ;
15091: LD_VAR 0 1
15095: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
15096: LD_INT 0
15098: PPUSH
15099: PPUSH
15100: PPUSH
15101: PPUSH
15102: PPUSH
15103: PPUSH
15104: PPUSH
15105: PPUSH
15106: PPUSH
15107: PPUSH
15108: PPUSH
15109: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
15110: LD_VAR 0 1
15114: NOT
15115: PUSH
15116: LD_EXP 56
15120: PUSH
15121: LD_VAR 0 1
15125: ARRAY
15126: NOT
15127: OR
15128: PUSH
15129: LD_EXP 56
15133: PUSH
15134: LD_VAR 0 1
15138: ARRAY
15139: PPUSH
15140: LD_INT 2
15142: PUSH
15143: LD_INT 30
15145: PUSH
15146: LD_INT 0
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: PUSH
15153: LD_INT 30
15155: PUSH
15156: LD_INT 1
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: PUSH
15163: EMPTY
15164: LIST
15165: LIST
15166: LIST
15167: PPUSH
15168: CALL_OW 72
15172: NOT
15173: OR
15174: IFFALSE 15178
// exit ;
15176: GO 18681
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15178: LD_ADDR_VAR 0 4
15182: PUSH
15183: LD_EXP 56
15187: PUSH
15188: LD_VAR 0 1
15192: ARRAY
15193: PPUSH
15194: LD_INT 2
15196: PUSH
15197: LD_INT 25
15199: PUSH
15200: LD_INT 1
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PUSH
15207: LD_INT 25
15209: PUSH
15210: LD_INT 2
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: LD_INT 25
15219: PUSH
15220: LD_INT 3
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: PUSH
15227: LD_INT 25
15229: PUSH
15230: LD_INT 4
15232: PUSH
15233: EMPTY
15234: LIST
15235: LIST
15236: PUSH
15237: LD_INT 25
15239: PUSH
15240: LD_INT 5
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: LD_INT 25
15249: PUSH
15250: LD_INT 8
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 25
15259: PUSH
15260: LD_INT 9
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: PPUSH
15277: CALL_OW 72
15281: ST_TO_ADDR
// if not tmp then
15282: LD_VAR 0 4
15286: NOT
15287: IFFALSE 15291
// exit ;
15289: GO 18681
// for i in tmp do
15291: LD_ADDR_VAR 0 3
15295: PUSH
15296: LD_VAR 0 4
15300: PUSH
15301: FOR_IN
15302: IFFALSE 15333
// if GetTag ( i ) then
15304: LD_VAR 0 3
15308: PPUSH
15309: CALL_OW 110
15313: IFFALSE 15331
// tmp := tmp diff i ;
15315: LD_ADDR_VAR 0 4
15319: PUSH
15320: LD_VAR 0 4
15324: PUSH
15325: LD_VAR 0 3
15329: DIFF
15330: ST_TO_ADDR
15331: GO 15301
15333: POP
15334: POP
// if not tmp then
15335: LD_VAR 0 4
15339: NOT
15340: IFFALSE 15344
// exit ;
15342: GO 18681
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15344: LD_ADDR_VAR 0 5
15348: PUSH
15349: LD_EXP 56
15353: PUSH
15354: LD_VAR 0 1
15358: ARRAY
15359: PPUSH
15360: LD_INT 2
15362: PUSH
15363: LD_INT 25
15365: PUSH
15366: LD_INT 1
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: PUSH
15373: LD_INT 25
15375: PUSH
15376: LD_INT 5
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PUSH
15383: LD_INT 25
15385: PUSH
15386: LD_INT 8
15388: PUSH
15389: EMPTY
15390: LIST
15391: LIST
15392: PUSH
15393: LD_INT 25
15395: PUSH
15396: LD_INT 9
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: PUSH
15403: EMPTY
15404: LIST
15405: LIST
15406: LIST
15407: LIST
15408: LIST
15409: PPUSH
15410: CALL_OW 72
15414: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
15415: LD_ADDR_VAR 0 6
15419: PUSH
15420: LD_EXP 56
15424: PUSH
15425: LD_VAR 0 1
15429: ARRAY
15430: PPUSH
15431: LD_INT 25
15433: PUSH
15434: LD_INT 2
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: PPUSH
15441: CALL_OW 72
15445: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15446: LD_ADDR_VAR 0 7
15450: PUSH
15451: LD_EXP 56
15455: PUSH
15456: LD_VAR 0 1
15460: ARRAY
15461: PPUSH
15462: LD_INT 25
15464: PUSH
15465: LD_INT 3
15467: PUSH
15468: EMPTY
15469: LIST
15470: LIST
15471: PPUSH
15472: CALL_OW 72
15476: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
15477: LD_ADDR_VAR 0 8
15481: PUSH
15482: LD_EXP 56
15486: PUSH
15487: LD_VAR 0 1
15491: ARRAY
15492: PPUSH
15493: LD_INT 25
15495: PUSH
15496: LD_INT 4
15498: PUSH
15499: EMPTY
15500: LIST
15501: LIST
15502: PUSH
15503: LD_INT 24
15505: PUSH
15506: LD_INT 251
15508: PUSH
15509: EMPTY
15510: LIST
15511: LIST
15512: PUSH
15513: EMPTY
15514: LIST
15515: LIST
15516: PPUSH
15517: CALL_OW 72
15521: ST_TO_ADDR
// if mc_scan [ base ] then
15522: LD_EXP 79
15526: PUSH
15527: LD_VAR 0 1
15531: ARRAY
15532: IFFALSE 15993
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
15534: LD_ADDR_EXP 98
15538: PUSH
15539: LD_EXP 98
15543: PPUSH
15544: LD_VAR 0 1
15548: PPUSH
15549: LD_INT 4
15551: PPUSH
15552: CALL_OW 1
15556: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
15557: LD_ADDR_VAR 0 12
15561: PUSH
15562: LD_EXP 56
15566: PUSH
15567: LD_VAR 0 1
15571: ARRAY
15572: PPUSH
15573: LD_INT 2
15575: PUSH
15576: LD_INT 30
15578: PUSH
15579: LD_INT 4
15581: PUSH
15582: EMPTY
15583: LIST
15584: LIST
15585: PUSH
15586: LD_INT 30
15588: PUSH
15589: LD_INT 5
15591: PUSH
15592: EMPTY
15593: LIST
15594: LIST
15595: PUSH
15596: EMPTY
15597: LIST
15598: LIST
15599: LIST
15600: PPUSH
15601: CALL_OW 72
15605: ST_TO_ADDR
// if not b then
15606: LD_VAR 0 12
15610: NOT
15611: IFFALSE 15615
// exit ;
15613: GO 18681
// p := [ ] ;
15615: LD_ADDR_VAR 0 11
15619: PUSH
15620: EMPTY
15621: ST_TO_ADDR
// if sci >= 2 then
15622: LD_VAR 0 8
15626: PUSH
15627: LD_INT 2
15629: GREATEREQUAL
15630: IFFALSE 15661
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
15632: LD_ADDR_VAR 0 8
15636: PUSH
15637: LD_VAR 0 8
15641: PUSH
15642: LD_INT 1
15644: ARRAY
15645: PUSH
15646: LD_VAR 0 8
15650: PUSH
15651: LD_INT 2
15653: ARRAY
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: ST_TO_ADDR
15659: GO 15722
// if sci = 1 then
15661: LD_VAR 0 8
15665: PUSH
15666: LD_INT 1
15668: EQUAL
15669: IFFALSE 15690
// sci := [ sci [ 1 ] ] else
15671: LD_ADDR_VAR 0 8
15675: PUSH
15676: LD_VAR 0 8
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: EMPTY
15686: LIST
15687: ST_TO_ADDR
15688: GO 15722
// if sci = 0 then
15690: LD_VAR 0 8
15694: PUSH
15695: LD_INT 0
15697: EQUAL
15698: IFFALSE 15722
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
15700: LD_ADDR_VAR 0 11
15704: PUSH
15705: LD_VAR 0 4
15709: PPUSH
15710: LD_INT 4
15712: PPUSH
15713: CALL 81267 0 2
15717: PUSH
15718: LD_INT 1
15720: ARRAY
15721: ST_TO_ADDR
// if eng > 4 then
15722: LD_VAR 0 6
15726: PUSH
15727: LD_INT 4
15729: GREATER
15730: IFFALSE 15776
// for i = eng downto 4 do
15732: LD_ADDR_VAR 0 3
15736: PUSH
15737: DOUBLE
15738: LD_VAR 0 6
15742: INC
15743: ST_TO_ADDR
15744: LD_INT 4
15746: PUSH
15747: FOR_DOWNTO
15748: IFFALSE 15774
// eng := eng diff eng [ i ] ;
15750: LD_ADDR_VAR 0 6
15754: PUSH
15755: LD_VAR 0 6
15759: PUSH
15760: LD_VAR 0 6
15764: PUSH
15765: LD_VAR 0 3
15769: ARRAY
15770: DIFF
15771: ST_TO_ADDR
15772: GO 15747
15774: POP
15775: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
15776: LD_ADDR_VAR 0 4
15780: PUSH
15781: LD_VAR 0 4
15785: PUSH
15786: LD_VAR 0 5
15790: PUSH
15791: LD_VAR 0 6
15795: UNION
15796: PUSH
15797: LD_VAR 0 7
15801: UNION
15802: PUSH
15803: LD_VAR 0 8
15807: UNION
15808: DIFF
15809: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
15810: LD_ADDR_VAR 0 13
15814: PUSH
15815: LD_EXP 56
15819: PUSH
15820: LD_VAR 0 1
15824: ARRAY
15825: PPUSH
15826: LD_INT 2
15828: PUSH
15829: LD_INT 30
15831: PUSH
15832: LD_INT 32
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 30
15841: PUSH
15842: LD_INT 31
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PUSH
15849: EMPTY
15850: LIST
15851: LIST
15852: LIST
15853: PPUSH
15854: CALL_OW 72
15858: PUSH
15859: LD_EXP 56
15863: PUSH
15864: LD_VAR 0 1
15868: ARRAY
15869: PPUSH
15870: LD_INT 2
15872: PUSH
15873: LD_INT 30
15875: PUSH
15876: LD_INT 4
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: LD_INT 30
15885: PUSH
15886: LD_INT 5
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: LIST
15897: PPUSH
15898: CALL_OW 72
15902: PUSH
15903: LD_INT 6
15905: MUL
15906: PLUS
15907: ST_TO_ADDR
// if bcount < tmp then
15908: LD_VAR 0 13
15912: PUSH
15913: LD_VAR 0 4
15917: LESS
15918: IFFALSE 15964
// for i = tmp downto bcount do
15920: LD_ADDR_VAR 0 3
15924: PUSH
15925: DOUBLE
15926: LD_VAR 0 4
15930: INC
15931: ST_TO_ADDR
15932: LD_VAR 0 13
15936: PUSH
15937: FOR_DOWNTO
15938: IFFALSE 15962
// tmp := Delete ( tmp , tmp ) ;
15940: LD_ADDR_VAR 0 4
15944: PUSH
15945: LD_VAR 0 4
15949: PPUSH
15950: LD_VAR 0 4
15954: PPUSH
15955: CALL_OW 3
15959: ST_TO_ADDR
15960: GO 15937
15962: POP
15963: POP
// result := [ tmp , 0 , 0 , p ] ;
15964: LD_ADDR_VAR 0 2
15968: PUSH
15969: LD_VAR 0 4
15973: PUSH
15974: LD_INT 0
15976: PUSH
15977: LD_INT 0
15979: PUSH
15980: LD_VAR 0 11
15984: PUSH
15985: EMPTY
15986: LIST
15987: LIST
15988: LIST
15989: LIST
15990: ST_TO_ADDR
// exit ;
15991: GO 18681
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
15993: LD_EXP 56
15997: PUSH
15998: LD_VAR 0 1
16002: ARRAY
16003: PPUSH
16004: LD_INT 2
16006: PUSH
16007: LD_INT 30
16009: PUSH
16010: LD_INT 6
16012: PUSH
16013: EMPTY
16014: LIST
16015: LIST
16016: PUSH
16017: LD_INT 30
16019: PUSH
16020: LD_INT 7
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PUSH
16027: LD_INT 30
16029: PUSH
16030: LD_INT 8
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: PPUSH
16043: CALL_OW 72
16047: NOT
16048: PUSH
16049: LD_EXP 56
16053: PUSH
16054: LD_VAR 0 1
16058: ARRAY
16059: PPUSH
16060: LD_INT 30
16062: PUSH
16063: LD_INT 3
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: PPUSH
16070: CALL_OW 72
16074: NOT
16075: AND
16076: IFFALSE 16148
// begin if eng = tmp then
16078: LD_VAR 0 6
16082: PUSH
16083: LD_VAR 0 4
16087: EQUAL
16088: IFFALSE 16092
// exit ;
16090: GO 18681
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
16092: LD_ADDR_EXP 98
16096: PUSH
16097: LD_EXP 98
16101: PPUSH
16102: LD_VAR 0 1
16106: PPUSH
16107: LD_INT 1
16109: PPUSH
16110: CALL_OW 1
16114: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
16115: LD_ADDR_VAR 0 2
16119: PUSH
16120: LD_INT 0
16122: PUSH
16123: LD_VAR 0 4
16127: PUSH
16128: LD_VAR 0 6
16132: DIFF
16133: PUSH
16134: LD_INT 0
16136: PUSH
16137: LD_INT 0
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: LIST
16144: LIST
16145: ST_TO_ADDR
// exit ;
16146: GO 18681
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
16148: LD_EXP 83
16152: PUSH
16153: LD_EXP 82
16157: PUSH
16158: LD_VAR 0 1
16162: ARRAY
16163: ARRAY
16164: PUSH
16165: LD_EXP 56
16169: PUSH
16170: LD_VAR 0 1
16174: ARRAY
16175: PPUSH
16176: LD_INT 2
16178: PUSH
16179: LD_INT 30
16181: PUSH
16182: LD_INT 6
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: LD_INT 30
16191: PUSH
16192: LD_INT 7
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: LD_INT 30
16201: PUSH
16202: LD_INT 8
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: PPUSH
16215: CALL_OW 72
16219: AND
16220: PUSH
16221: LD_EXP 56
16225: PUSH
16226: LD_VAR 0 1
16230: ARRAY
16231: PPUSH
16232: LD_INT 30
16234: PUSH
16235: LD_INT 3
16237: PUSH
16238: EMPTY
16239: LIST
16240: LIST
16241: PPUSH
16242: CALL_OW 72
16246: NOT
16247: AND
16248: IFFALSE 16462
// begin if sci >= 6 then
16250: LD_VAR 0 8
16254: PUSH
16255: LD_INT 6
16257: GREATEREQUAL
16258: IFFALSE 16262
// exit ;
16260: GO 18681
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
16262: LD_ADDR_EXP 98
16266: PUSH
16267: LD_EXP 98
16271: PPUSH
16272: LD_VAR 0 1
16276: PPUSH
16277: LD_INT 2
16279: PPUSH
16280: CALL_OW 1
16284: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
16285: LD_ADDR_VAR 0 9
16289: PUSH
16290: LD_VAR 0 4
16294: PUSH
16295: LD_VAR 0 8
16299: DIFF
16300: PPUSH
16301: LD_INT 4
16303: PPUSH
16304: CALL 81267 0 2
16308: ST_TO_ADDR
// p := [ ] ;
16309: LD_ADDR_VAR 0 11
16313: PUSH
16314: EMPTY
16315: ST_TO_ADDR
// if sci < 6 and sort > 6 then
16316: LD_VAR 0 8
16320: PUSH
16321: LD_INT 6
16323: LESS
16324: PUSH
16325: LD_VAR 0 9
16329: PUSH
16330: LD_INT 6
16332: GREATER
16333: AND
16334: IFFALSE 16415
// begin for i = 1 to 6 - sci do
16336: LD_ADDR_VAR 0 3
16340: PUSH
16341: DOUBLE
16342: LD_INT 1
16344: DEC
16345: ST_TO_ADDR
16346: LD_INT 6
16348: PUSH
16349: LD_VAR 0 8
16353: MINUS
16354: PUSH
16355: FOR_TO
16356: IFFALSE 16411
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
16358: LD_ADDR_VAR 0 11
16362: PUSH
16363: LD_VAR 0 11
16367: PPUSH
16368: LD_VAR 0 11
16372: PUSH
16373: LD_INT 1
16375: PLUS
16376: PPUSH
16377: LD_VAR 0 9
16381: PUSH
16382: LD_INT 1
16384: ARRAY
16385: PPUSH
16386: CALL_OW 2
16390: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
16391: LD_ADDR_VAR 0 9
16395: PUSH
16396: LD_VAR 0 9
16400: PPUSH
16401: LD_INT 1
16403: PPUSH
16404: CALL_OW 3
16408: ST_TO_ADDR
// end ;
16409: GO 16355
16411: POP
16412: POP
// end else
16413: GO 16435
// if sort then
16415: LD_VAR 0 9
16419: IFFALSE 16435
// p := sort [ 1 ] ;
16421: LD_ADDR_VAR 0 11
16425: PUSH
16426: LD_VAR 0 9
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
16435: LD_ADDR_VAR 0 2
16439: PUSH
16440: LD_INT 0
16442: PUSH
16443: LD_INT 0
16445: PUSH
16446: LD_INT 0
16448: PUSH
16449: LD_VAR 0 11
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: LIST
16458: LIST
16459: ST_TO_ADDR
// exit ;
16460: GO 18681
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
16462: LD_EXP 83
16466: PUSH
16467: LD_EXP 82
16471: PUSH
16472: LD_VAR 0 1
16476: ARRAY
16477: ARRAY
16478: PUSH
16479: LD_EXP 56
16483: PUSH
16484: LD_VAR 0 1
16488: ARRAY
16489: PPUSH
16490: LD_INT 2
16492: PUSH
16493: LD_INT 30
16495: PUSH
16496: LD_INT 6
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 30
16505: PUSH
16506: LD_INT 7
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PUSH
16513: LD_INT 30
16515: PUSH
16516: LD_INT 8
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 72
16533: AND
16534: PUSH
16535: LD_EXP 56
16539: PUSH
16540: LD_VAR 0 1
16544: ARRAY
16545: PPUSH
16546: LD_INT 30
16548: PUSH
16549: LD_INT 3
16551: PUSH
16552: EMPTY
16553: LIST
16554: LIST
16555: PPUSH
16556: CALL_OW 72
16560: AND
16561: IFFALSE 17295
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
16563: LD_ADDR_EXP 98
16567: PUSH
16568: LD_EXP 98
16572: PPUSH
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_INT 3
16580: PPUSH
16581: CALL_OW 1
16585: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
16586: LD_ADDR_VAR 0 2
16590: PUSH
16591: LD_INT 0
16593: PUSH
16594: LD_INT 0
16596: PUSH
16597: LD_INT 0
16599: PUSH
16600: LD_INT 0
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: LIST
16608: ST_TO_ADDR
// if not eng then
16609: LD_VAR 0 6
16613: NOT
16614: IFFALSE 16677
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
16616: LD_ADDR_VAR 0 11
16620: PUSH
16621: LD_VAR 0 4
16625: PPUSH
16626: LD_INT 2
16628: PPUSH
16629: CALL 81267 0 2
16633: PUSH
16634: LD_INT 1
16636: ARRAY
16637: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
16638: LD_ADDR_VAR 0 2
16642: PUSH
16643: LD_VAR 0 2
16647: PPUSH
16648: LD_INT 2
16650: PPUSH
16651: LD_VAR 0 11
16655: PPUSH
16656: CALL_OW 1
16660: ST_TO_ADDR
// tmp := tmp diff p ;
16661: LD_ADDR_VAR 0 4
16665: PUSH
16666: LD_VAR 0 4
16670: PUSH
16671: LD_VAR 0 11
16675: DIFF
16676: ST_TO_ADDR
// end ; if tmp and sci < 6 then
16677: LD_VAR 0 4
16681: PUSH
16682: LD_VAR 0 8
16686: PUSH
16687: LD_INT 6
16689: LESS
16690: AND
16691: IFFALSE 16879
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
16693: LD_ADDR_VAR 0 9
16697: PUSH
16698: LD_VAR 0 4
16702: PUSH
16703: LD_VAR 0 8
16707: PUSH
16708: LD_VAR 0 7
16712: UNION
16713: DIFF
16714: PPUSH
16715: LD_INT 4
16717: PPUSH
16718: CALL 81267 0 2
16722: ST_TO_ADDR
// p := [ ] ;
16723: LD_ADDR_VAR 0 11
16727: PUSH
16728: EMPTY
16729: ST_TO_ADDR
// if sort then
16730: LD_VAR 0 9
16734: IFFALSE 16850
// for i = 1 to 6 - sci do
16736: LD_ADDR_VAR 0 3
16740: PUSH
16741: DOUBLE
16742: LD_INT 1
16744: DEC
16745: ST_TO_ADDR
16746: LD_INT 6
16748: PUSH
16749: LD_VAR 0 8
16753: MINUS
16754: PUSH
16755: FOR_TO
16756: IFFALSE 16848
// begin if i = sort then
16758: LD_VAR 0 3
16762: PUSH
16763: LD_VAR 0 9
16767: EQUAL
16768: IFFALSE 16772
// break ;
16770: GO 16848
// if GetClass ( i ) = 4 then
16772: LD_VAR 0 3
16776: PPUSH
16777: CALL_OW 257
16781: PUSH
16782: LD_INT 4
16784: EQUAL
16785: IFFALSE 16789
// continue ;
16787: GO 16755
// p := Insert ( p , p + 1 , sort [ i ] ) ;
16789: LD_ADDR_VAR 0 11
16793: PUSH
16794: LD_VAR 0 11
16798: PPUSH
16799: LD_VAR 0 11
16803: PUSH
16804: LD_INT 1
16806: PLUS
16807: PPUSH
16808: LD_VAR 0 9
16812: PUSH
16813: LD_VAR 0 3
16817: ARRAY
16818: PPUSH
16819: CALL_OW 2
16823: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
16824: LD_ADDR_VAR 0 4
16828: PUSH
16829: LD_VAR 0 4
16833: PUSH
16834: LD_VAR 0 9
16838: PUSH
16839: LD_VAR 0 3
16843: ARRAY
16844: DIFF
16845: ST_TO_ADDR
// end ;
16846: GO 16755
16848: POP
16849: POP
// if p then
16850: LD_VAR 0 11
16854: IFFALSE 16879
// result := Replace ( result , 4 , p ) ;
16856: LD_ADDR_VAR 0 2
16860: PUSH
16861: LD_VAR 0 2
16865: PPUSH
16866: LD_INT 4
16868: PPUSH
16869: LD_VAR 0 11
16873: PPUSH
16874: CALL_OW 1
16878: ST_TO_ADDR
// end ; if tmp and mech < 6 then
16879: LD_VAR 0 4
16883: PUSH
16884: LD_VAR 0 7
16888: PUSH
16889: LD_INT 6
16891: LESS
16892: AND
16893: IFFALSE 17081
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
16895: LD_ADDR_VAR 0 9
16899: PUSH
16900: LD_VAR 0 4
16904: PUSH
16905: LD_VAR 0 8
16909: PUSH
16910: LD_VAR 0 7
16914: UNION
16915: DIFF
16916: PPUSH
16917: LD_INT 3
16919: PPUSH
16920: CALL 81267 0 2
16924: ST_TO_ADDR
// p := [ ] ;
16925: LD_ADDR_VAR 0 11
16929: PUSH
16930: EMPTY
16931: ST_TO_ADDR
// if sort then
16932: LD_VAR 0 9
16936: IFFALSE 17052
// for i = 1 to 6 - mech do
16938: LD_ADDR_VAR 0 3
16942: PUSH
16943: DOUBLE
16944: LD_INT 1
16946: DEC
16947: ST_TO_ADDR
16948: LD_INT 6
16950: PUSH
16951: LD_VAR 0 7
16955: MINUS
16956: PUSH
16957: FOR_TO
16958: IFFALSE 17050
// begin if i = sort then
16960: LD_VAR 0 3
16964: PUSH
16965: LD_VAR 0 9
16969: EQUAL
16970: IFFALSE 16974
// break ;
16972: GO 17050
// if GetClass ( i ) = 3 then
16974: LD_VAR 0 3
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_INT 3
16986: EQUAL
16987: IFFALSE 16991
// continue ;
16989: GO 16957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
16991: LD_ADDR_VAR 0 11
16995: PUSH
16996: LD_VAR 0 11
17000: PPUSH
17001: LD_VAR 0 11
17005: PUSH
17006: LD_INT 1
17008: PLUS
17009: PPUSH
17010: LD_VAR 0 9
17014: PUSH
17015: LD_VAR 0 3
17019: ARRAY
17020: PPUSH
17021: CALL_OW 2
17025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17026: LD_ADDR_VAR 0 4
17030: PUSH
17031: LD_VAR 0 4
17035: PUSH
17036: LD_VAR 0 9
17040: PUSH
17041: LD_VAR 0 3
17045: ARRAY
17046: DIFF
17047: ST_TO_ADDR
// end ;
17048: GO 16957
17050: POP
17051: POP
// if p then
17052: LD_VAR 0 11
17056: IFFALSE 17081
// result := Replace ( result , 3 , p ) ;
17058: LD_ADDR_VAR 0 2
17062: PUSH
17063: LD_VAR 0 2
17067: PPUSH
17068: LD_INT 3
17070: PPUSH
17071: LD_VAR 0 11
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
17081: LD_VAR 0 4
17085: PUSH
17086: LD_INT 6
17088: GREATER
17089: PUSH
17090: LD_VAR 0 6
17094: PUSH
17095: LD_INT 6
17097: LESS
17098: AND
17099: IFFALSE 17293
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
17101: LD_ADDR_VAR 0 9
17105: PUSH
17106: LD_VAR 0 4
17110: PUSH
17111: LD_VAR 0 8
17115: PUSH
17116: LD_VAR 0 7
17120: UNION
17121: PUSH
17122: LD_VAR 0 6
17126: UNION
17127: DIFF
17128: PPUSH
17129: LD_INT 2
17131: PPUSH
17132: CALL 81267 0 2
17136: ST_TO_ADDR
// p := [ ] ;
17137: LD_ADDR_VAR 0 11
17141: PUSH
17142: EMPTY
17143: ST_TO_ADDR
// if sort then
17144: LD_VAR 0 9
17148: IFFALSE 17264
// for i = 1 to 6 - eng do
17150: LD_ADDR_VAR 0 3
17154: PUSH
17155: DOUBLE
17156: LD_INT 1
17158: DEC
17159: ST_TO_ADDR
17160: LD_INT 6
17162: PUSH
17163: LD_VAR 0 6
17167: MINUS
17168: PUSH
17169: FOR_TO
17170: IFFALSE 17262
// begin if i = sort then
17172: LD_VAR 0 3
17176: PUSH
17177: LD_VAR 0 9
17181: EQUAL
17182: IFFALSE 17186
// break ;
17184: GO 17262
// if GetClass ( i ) = 2 then
17186: LD_VAR 0 3
17190: PPUSH
17191: CALL_OW 257
17195: PUSH
17196: LD_INT 2
17198: EQUAL
17199: IFFALSE 17203
// continue ;
17201: GO 17169
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17203: LD_ADDR_VAR 0 11
17207: PUSH
17208: LD_VAR 0 11
17212: PPUSH
17213: LD_VAR 0 11
17217: PUSH
17218: LD_INT 1
17220: PLUS
17221: PPUSH
17222: LD_VAR 0 9
17226: PUSH
17227: LD_VAR 0 3
17231: ARRAY
17232: PPUSH
17233: CALL_OW 2
17237: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17238: LD_ADDR_VAR 0 4
17242: PUSH
17243: LD_VAR 0 4
17247: PUSH
17248: LD_VAR 0 9
17252: PUSH
17253: LD_VAR 0 3
17257: ARRAY
17258: DIFF
17259: ST_TO_ADDR
// end ;
17260: GO 17169
17262: POP
17263: POP
// if p then
17264: LD_VAR 0 11
17268: IFFALSE 17293
// result := Replace ( result , 2 , p ) ;
17270: LD_ADDR_VAR 0 2
17274: PUSH
17275: LD_VAR 0 2
17279: PPUSH
17280: LD_INT 2
17282: PPUSH
17283: LD_VAR 0 11
17287: PPUSH
17288: CALL_OW 1
17292: ST_TO_ADDR
// end ; exit ;
17293: GO 18681
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
17295: LD_EXP 83
17299: PUSH
17300: LD_EXP 82
17304: PUSH
17305: LD_VAR 0 1
17309: ARRAY
17310: ARRAY
17311: NOT
17312: PUSH
17313: LD_EXP 56
17317: PUSH
17318: LD_VAR 0 1
17322: ARRAY
17323: PPUSH
17324: LD_INT 30
17326: PUSH
17327: LD_INT 3
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 72
17338: AND
17339: PUSH
17340: LD_EXP 61
17344: PUSH
17345: LD_VAR 0 1
17349: ARRAY
17350: AND
17351: IFFALSE 17959
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
17353: LD_ADDR_EXP 98
17357: PUSH
17358: LD_EXP 98
17362: PPUSH
17363: LD_VAR 0 1
17367: PPUSH
17368: LD_INT 5
17370: PPUSH
17371: CALL_OW 1
17375: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
17376: LD_ADDR_VAR 0 2
17380: PUSH
17381: LD_INT 0
17383: PUSH
17384: LD_INT 0
17386: PUSH
17387: LD_INT 0
17389: PUSH
17390: LD_INT 0
17392: PUSH
17393: EMPTY
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: ST_TO_ADDR
// if sci > 1 then
17399: LD_VAR 0 8
17403: PUSH
17404: LD_INT 1
17406: GREATER
17407: IFFALSE 17435
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
17409: LD_ADDR_VAR 0 4
17413: PUSH
17414: LD_VAR 0 4
17418: PUSH
17419: LD_VAR 0 8
17423: PUSH
17424: LD_VAR 0 8
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: DIFF
17433: DIFF
17434: ST_TO_ADDR
// if tmp and not sci then
17435: LD_VAR 0 4
17439: PUSH
17440: LD_VAR 0 8
17444: NOT
17445: AND
17446: IFFALSE 17515
// begin sort := SortBySkill ( tmp , 4 ) ;
17448: LD_ADDR_VAR 0 9
17452: PUSH
17453: LD_VAR 0 4
17457: PPUSH
17458: LD_INT 4
17460: PPUSH
17461: CALL 81267 0 2
17465: ST_TO_ADDR
// if sort then
17466: LD_VAR 0 9
17470: IFFALSE 17486
// p := sort [ 1 ] ;
17472: LD_ADDR_VAR 0 11
17476: PUSH
17477: LD_VAR 0 9
17481: PUSH
17482: LD_INT 1
17484: ARRAY
17485: ST_TO_ADDR
// if p then
17486: LD_VAR 0 11
17490: IFFALSE 17515
// result := Replace ( result , 4 , p ) ;
17492: LD_ADDR_VAR 0 2
17496: PUSH
17497: LD_VAR 0 2
17501: PPUSH
17502: LD_INT 4
17504: PPUSH
17505: LD_VAR 0 11
17509: PPUSH
17510: CALL_OW 1
17514: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
17515: LD_ADDR_VAR 0 4
17519: PUSH
17520: LD_VAR 0 4
17524: PUSH
17525: LD_VAR 0 7
17529: DIFF
17530: ST_TO_ADDR
// if tmp and mech < 6 then
17531: LD_VAR 0 4
17535: PUSH
17536: LD_VAR 0 7
17540: PUSH
17541: LD_INT 6
17543: LESS
17544: AND
17545: IFFALSE 17733
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
17547: LD_ADDR_VAR 0 9
17551: PUSH
17552: LD_VAR 0 4
17556: PUSH
17557: LD_VAR 0 8
17561: PUSH
17562: LD_VAR 0 7
17566: UNION
17567: DIFF
17568: PPUSH
17569: LD_INT 3
17571: PPUSH
17572: CALL 81267 0 2
17576: ST_TO_ADDR
// p := [ ] ;
17577: LD_ADDR_VAR 0 11
17581: PUSH
17582: EMPTY
17583: ST_TO_ADDR
// if sort then
17584: LD_VAR 0 9
17588: IFFALSE 17704
// for i = 1 to 6 - mech do
17590: LD_ADDR_VAR 0 3
17594: PUSH
17595: DOUBLE
17596: LD_INT 1
17598: DEC
17599: ST_TO_ADDR
17600: LD_INT 6
17602: PUSH
17603: LD_VAR 0 7
17607: MINUS
17608: PUSH
17609: FOR_TO
17610: IFFALSE 17702
// begin if i = sort then
17612: LD_VAR 0 3
17616: PUSH
17617: LD_VAR 0 9
17621: EQUAL
17622: IFFALSE 17626
// break ;
17624: GO 17702
// if GetClass ( i ) = 3 then
17626: LD_VAR 0 3
17630: PPUSH
17631: CALL_OW 257
17635: PUSH
17636: LD_INT 3
17638: EQUAL
17639: IFFALSE 17643
// continue ;
17641: GO 17609
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17643: LD_ADDR_VAR 0 11
17647: PUSH
17648: LD_VAR 0 11
17652: PPUSH
17653: LD_VAR 0 11
17657: PUSH
17658: LD_INT 1
17660: PLUS
17661: PPUSH
17662: LD_VAR 0 9
17666: PUSH
17667: LD_VAR 0 3
17671: ARRAY
17672: PPUSH
17673: CALL_OW 2
17677: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17678: LD_ADDR_VAR 0 4
17682: PUSH
17683: LD_VAR 0 4
17687: PUSH
17688: LD_VAR 0 9
17692: PUSH
17693: LD_VAR 0 3
17697: ARRAY
17698: DIFF
17699: ST_TO_ADDR
// end ;
17700: GO 17609
17702: POP
17703: POP
// if p then
17704: LD_VAR 0 11
17708: IFFALSE 17733
// result := Replace ( result , 3 , p ) ;
17710: LD_ADDR_VAR 0 2
17714: PUSH
17715: LD_VAR 0 2
17719: PPUSH
17720: LD_INT 3
17722: PPUSH
17723: LD_VAR 0 11
17727: PPUSH
17728: CALL_OW 1
17732: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
17733: LD_ADDR_VAR 0 4
17737: PUSH
17738: LD_VAR 0 4
17742: PUSH
17743: LD_VAR 0 6
17747: DIFF
17748: ST_TO_ADDR
// if tmp and eng < 6 then
17749: LD_VAR 0 4
17753: PUSH
17754: LD_VAR 0 6
17758: PUSH
17759: LD_INT 6
17761: LESS
17762: AND
17763: IFFALSE 17957
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
17765: LD_ADDR_VAR 0 9
17769: PUSH
17770: LD_VAR 0 4
17774: PUSH
17775: LD_VAR 0 8
17779: PUSH
17780: LD_VAR 0 7
17784: UNION
17785: PUSH
17786: LD_VAR 0 6
17790: UNION
17791: DIFF
17792: PPUSH
17793: LD_INT 2
17795: PPUSH
17796: CALL 81267 0 2
17800: ST_TO_ADDR
// p := [ ] ;
17801: LD_ADDR_VAR 0 11
17805: PUSH
17806: EMPTY
17807: ST_TO_ADDR
// if sort then
17808: LD_VAR 0 9
17812: IFFALSE 17928
// for i = 1 to 6 - eng do
17814: LD_ADDR_VAR 0 3
17818: PUSH
17819: DOUBLE
17820: LD_INT 1
17822: DEC
17823: ST_TO_ADDR
17824: LD_INT 6
17826: PUSH
17827: LD_VAR 0 6
17831: MINUS
17832: PUSH
17833: FOR_TO
17834: IFFALSE 17926
// begin if i = sort then
17836: LD_VAR 0 3
17840: PUSH
17841: LD_VAR 0 9
17845: EQUAL
17846: IFFALSE 17850
// break ;
17848: GO 17926
// if GetClass ( i ) = 2 then
17850: LD_VAR 0 3
17854: PPUSH
17855: CALL_OW 257
17859: PUSH
17860: LD_INT 2
17862: EQUAL
17863: IFFALSE 17867
// continue ;
17865: GO 17833
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17867: LD_ADDR_VAR 0 11
17871: PUSH
17872: LD_VAR 0 11
17876: PPUSH
17877: LD_VAR 0 11
17881: PUSH
17882: LD_INT 1
17884: PLUS
17885: PPUSH
17886: LD_VAR 0 9
17890: PUSH
17891: LD_VAR 0 3
17895: ARRAY
17896: PPUSH
17897: CALL_OW 2
17901: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17902: LD_ADDR_VAR 0 4
17906: PUSH
17907: LD_VAR 0 4
17911: PUSH
17912: LD_VAR 0 9
17916: PUSH
17917: LD_VAR 0 3
17921: ARRAY
17922: DIFF
17923: ST_TO_ADDR
// end ;
17924: GO 17833
17926: POP
17927: POP
// if p then
17928: LD_VAR 0 11
17932: IFFALSE 17957
// result := Replace ( result , 2 , p ) ;
17934: LD_ADDR_VAR 0 2
17938: PUSH
17939: LD_VAR 0 2
17943: PPUSH
17944: LD_INT 2
17946: PPUSH
17947: LD_VAR 0 11
17951: PPUSH
17952: CALL_OW 1
17956: ST_TO_ADDR
// end ; exit ;
17957: GO 18681
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
17959: LD_EXP 83
17963: PUSH
17964: LD_EXP 82
17968: PUSH
17969: LD_VAR 0 1
17973: ARRAY
17974: ARRAY
17975: NOT
17976: PUSH
17977: LD_EXP 56
17981: PUSH
17982: LD_VAR 0 1
17986: ARRAY
17987: PPUSH
17988: LD_INT 30
17990: PUSH
17991: LD_INT 3
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: PPUSH
17998: CALL_OW 72
18002: AND
18003: PUSH
18004: LD_EXP 61
18008: PUSH
18009: LD_VAR 0 1
18013: ARRAY
18014: NOT
18015: AND
18016: IFFALSE 18681
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
18018: LD_ADDR_EXP 98
18022: PUSH
18023: LD_EXP 98
18027: PPUSH
18028: LD_VAR 0 1
18032: PPUSH
18033: LD_INT 6
18035: PPUSH
18036: CALL_OW 1
18040: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
18041: LD_ADDR_VAR 0 2
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: LD_INT 0
18051: PUSH
18052: LD_INT 0
18054: PUSH
18055: LD_INT 0
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: ST_TO_ADDR
// if sci >= 1 then
18064: LD_VAR 0 8
18068: PUSH
18069: LD_INT 1
18071: GREATEREQUAL
18072: IFFALSE 18094
// tmp := tmp diff sci [ 1 ] ;
18074: LD_ADDR_VAR 0 4
18078: PUSH
18079: LD_VAR 0 4
18083: PUSH
18084: LD_VAR 0 8
18088: PUSH
18089: LD_INT 1
18091: ARRAY
18092: DIFF
18093: ST_TO_ADDR
// if tmp and not sci then
18094: LD_VAR 0 4
18098: PUSH
18099: LD_VAR 0 8
18103: NOT
18104: AND
18105: IFFALSE 18174
// begin sort := SortBySkill ( tmp , 4 ) ;
18107: LD_ADDR_VAR 0 9
18111: PUSH
18112: LD_VAR 0 4
18116: PPUSH
18117: LD_INT 4
18119: PPUSH
18120: CALL 81267 0 2
18124: ST_TO_ADDR
// if sort then
18125: LD_VAR 0 9
18129: IFFALSE 18145
// p := sort [ 1 ] ;
18131: LD_ADDR_VAR 0 11
18135: PUSH
18136: LD_VAR 0 9
18140: PUSH
18141: LD_INT 1
18143: ARRAY
18144: ST_TO_ADDR
// if p then
18145: LD_VAR 0 11
18149: IFFALSE 18174
// result := Replace ( result , 4 , p ) ;
18151: LD_ADDR_VAR 0 2
18155: PUSH
18156: LD_VAR 0 2
18160: PPUSH
18161: LD_INT 4
18163: PPUSH
18164: LD_VAR 0 11
18168: PPUSH
18169: CALL_OW 1
18173: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
18174: LD_ADDR_VAR 0 4
18178: PUSH
18179: LD_VAR 0 4
18183: PUSH
18184: LD_VAR 0 7
18188: DIFF
18189: ST_TO_ADDR
// if tmp and mech < 6 then
18190: LD_VAR 0 4
18194: PUSH
18195: LD_VAR 0 7
18199: PUSH
18200: LD_INT 6
18202: LESS
18203: AND
18204: IFFALSE 18386
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
18206: LD_ADDR_VAR 0 9
18210: PUSH
18211: LD_VAR 0 4
18215: PUSH
18216: LD_VAR 0 7
18220: DIFF
18221: PPUSH
18222: LD_INT 3
18224: PPUSH
18225: CALL 81267 0 2
18229: ST_TO_ADDR
// p := [ ] ;
18230: LD_ADDR_VAR 0 11
18234: PUSH
18235: EMPTY
18236: ST_TO_ADDR
// if sort then
18237: LD_VAR 0 9
18241: IFFALSE 18357
// for i = 1 to 6 - mech do
18243: LD_ADDR_VAR 0 3
18247: PUSH
18248: DOUBLE
18249: LD_INT 1
18251: DEC
18252: ST_TO_ADDR
18253: LD_INT 6
18255: PUSH
18256: LD_VAR 0 7
18260: MINUS
18261: PUSH
18262: FOR_TO
18263: IFFALSE 18355
// begin if i = sort then
18265: LD_VAR 0 3
18269: PUSH
18270: LD_VAR 0 9
18274: EQUAL
18275: IFFALSE 18279
// break ;
18277: GO 18355
// if GetClass ( i ) = 3 then
18279: LD_VAR 0 3
18283: PPUSH
18284: CALL_OW 257
18288: PUSH
18289: LD_INT 3
18291: EQUAL
18292: IFFALSE 18296
// continue ;
18294: GO 18262
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18296: LD_ADDR_VAR 0 11
18300: PUSH
18301: LD_VAR 0 11
18305: PPUSH
18306: LD_VAR 0 11
18310: PUSH
18311: LD_INT 1
18313: PLUS
18314: PPUSH
18315: LD_VAR 0 9
18319: PUSH
18320: LD_VAR 0 3
18324: ARRAY
18325: PPUSH
18326: CALL_OW 2
18330: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18331: LD_ADDR_VAR 0 4
18335: PUSH
18336: LD_VAR 0 4
18340: PUSH
18341: LD_VAR 0 9
18345: PUSH
18346: LD_VAR 0 3
18350: ARRAY
18351: DIFF
18352: ST_TO_ADDR
// end ;
18353: GO 18262
18355: POP
18356: POP
// if p then
18357: LD_VAR 0 11
18361: IFFALSE 18386
// result := Replace ( result , 3 , p ) ;
18363: LD_ADDR_VAR 0 2
18367: PUSH
18368: LD_VAR 0 2
18372: PPUSH
18373: LD_INT 3
18375: PPUSH
18376: LD_VAR 0 11
18380: PPUSH
18381: CALL_OW 1
18385: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_VAR 0 4
18395: PUSH
18396: LD_VAR 0 6
18400: DIFF
18401: ST_TO_ADDR
// if tmp and eng < 4 then
18402: LD_VAR 0 4
18406: PUSH
18407: LD_VAR 0 6
18411: PUSH
18412: LD_INT 4
18414: LESS
18415: AND
18416: IFFALSE 18606
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
18418: LD_ADDR_VAR 0 9
18422: PUSH
18423: LD_VAR 0 4
18427: PUSH
18428: LD_VAR 0 7
18432: PUSH
18433: LD_VAR 0 6
18437: UNION
18438: DIFF
18439: PPUSH
18440: LD_INT 2
18442: PPUSH
18443: CALL 81267 0 2
18447: ST_TO_ADDR
// p := [ ] ;
18448: LD_ADDR_VAR 0 11
18452: PUSH
18453: EMPTY
18454: ST_TO_ADDR
// if sort then
18455: LD_VAR 0 9
18459: IFFALSE 18575
// for i = 1 to 4 - eng do
18461: LD_ADDR_VAR 0 3
18465: PUSH
18466: DOUBLE
18467: LD_INT 1
18469: DEC
18470: ST_TO_ADDR
18471: LD_INT 4
18473: PUSH
18474: LD_VAR 0 6
18478: MINUS
18479: PUSH
18480: FOR_TO
18481: IFFALSE 18573
// begin if i = sort then
18483: LD_VAR 0 3
18487: PUSH
18488: LD_VAR 0 9
18492: EQUAL
18493: IFFALSE 18497
// break ;
18495: GO 18573
// if GetClass ( i ) = 2 then
18497: LD_VAR 0 3
18501: PPUSH
18502: CALL_OW 257
18506: PUSH
18507: LD_INT 2
18509: EQUAL
18510: IFFALSE 18514
// continue ;
18512: GO 18480
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18514: LD_ADDR_VAR 0 11
18518: PUSH
18519: LD_VAR 0 11
18523: PPUSH
18524: LD_VAR 0 11
18528: PUSH
18529: LD_INT 1
18531: PLUS
18532: PPUSH
18533: LD_VAR 0 9
18537: PUSH
18538: LD_VAR 0 3
18542: ARRAY
18543: PPUSH
18544: CALL_OW 2
18548: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18549: LD_ADDR_VAR 0 4
18553: PUSH
18554: LD_VAR 0 4
18558: PUSH
18559: LD_VAR 0 9
18563: PUSH
18564: LD_VAR 0 3
18568: ARRAY
18569: DIFF
18570: ST_TO_ADDR
// end ;
18571: GO 18480
18573: POP
18574: POP
// if p then
18575: LD_VAR 0 11
18579: IFFALSE 18604
// result := Replace ( result , 2 , p ) ;
18581: LD_ADDR_VAR 0 2
18585: PUSH
18586: LD_VAR 0 2
18590: PPUSH
18591: LD_INT 2
18593: PPUSH
18594: LD_VAR 0 11
18598: PPUSH
18599: CALL_OW 1
18603: ST_TO_ADDR
// end else
18604: GO 18650
// for i = eng downto 5 do
18606: LD_ADDR_VAR 0 3
18610: PUSH
18611: DOUBLE
18612: LD_VAR 0 6
18616: INC
18617: ST_TO_ADDR
18618: LD_INT 5
18620: PUSH
18621: FOR_DOWNTO
18622: IFFALSE 18648
// tmp := tmp union eng [ i ] ;
18624: LD_ADDR_VAR 0 4
18628: PUSH
18629: LD_VAR 0 4
18633: PUSH
18634: LD_VAR 0 6
18638: PUSH
18639: LD_VAR 0 3
18643: ARRAY
18644: UNION
18645: ST_TO_ADDR
18646: GO 18621
18648: POP
18649: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
18650: LD_ADDR_VAR 0 2
18654: PUSH
18655: LD_VAR 0 2
18659: PPUSH
18660: LD_INT 1
18662: PPUSH
18663: LD_VAR 0 4
18667: PUSH
18668: LD_VAR 0 5
18672: DIFF
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// exit ;
18679: GO 18681
// end ; end ;
18681: LD_VAR 0 2
18685: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
18690: PPUSH
// if not mc_bases then
18691: LD_EXP 56
18695: NOT
18696: IFFALSE 18700
// exit ;
18698: GO 18806
// for i = 1 to mc_bases do
18700: LD_ADDR_VAR 0 2
18704: PUSH
18705: DOUBLE
18706: LD_INT 1
18708: DEC
18709: ST_TO_ADDR
18710: LD_EXP 56
18714: PUSH
18715: FOR_TO
18716: IFFALSE 18797
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
18718: LD_ADDR_VAR 0 3
18722: PUSH
18723: LD_EXP 56
18727: PUSH
18728: LD_VAR 0 2
18732: ARRAY
18733: PPUSH
18734: LD_INT 21
18736: PUSH
18737: LD_INT 3
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 3
18746: PUSH
18747: LD_INT 24
18749: PUSH
18750: LD_INT 1000
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PPUSH
18765: CALL_OW 72
18769: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
18770: LD_ADDR_EXP 57
18774: PUSH
18775: LD_EXP 57
18779: PPUSH
18780: LD_VAR 0 2
18784: PPUSH
18785: LD_VAR 0 3
18789: PPUSH
18790: CALL_OW 1
18794: ST_TO_ADDR
// end ;
18795: GO 18715
18797: POP
18798: POP
// RaiseSailEvent ( 101 ) ;
18799: LD_INT 101
18801: PPUSH
18802: CALL_OW 427
// end ;
18806: LD_VAR 0 1
18810: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
18811: LD_INT 0
18813: PPUSH
18814: PPUSH
18815: PPUSH
18816: PPUSH
18817: PPUSH
18818: PPUSH
18819: PPUSH
// if not mc_bases then
18820: LD_EXP 56
18824: NOT
18825: IFFALSE 18829
// exit ;
18827: GO 19402
// for i = 1 to mc_bases do
18829: LD_ADDR_VAR 0 2
18833: PUSH
18834: DOUBLE
18835: LD_INT 1
18837: DEC
18838: ST_TO_ADDR
18839: LD_EXP 56
18843: PUSH
18844: FOR_TO
18845: IFFALSE 19393
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
18847: LD_ADDR_VAR 0 5
18851: PUSH
18852: LD_EXP 56
18856: PUSH
18857: LD_VAR 0 2
18861: ARRAY
18862: PUSH
18863: LD_EXP 85
18867: PUSH
18868: LD_VAR 0 2
18872: ARRAY
18873: UNION
18874: PPUSH
18875: LD_INT 21
18877: PUSH
18878: LD_INT 1
18880: PUSH
18881: EMPTY
18882: LIST
18883: LIST
18884: PUSH
18885: LD_INT 1
18887: PUSH
18888: LD_INT 3
18890: PUSH
18891: LD_INT 54
18893: PUSH
18894: EMPTY
18895: LIST
18896: PUSH
18897: EMPTY
18898: LIST
18899: LIST
18900: PUSH
18901: LD_INT 3
18903: PUSH
18904: LD_INT 24
18906: PUSH
18907: LD_INT 800
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PPUSH
18927: CALL_OW 72
18931: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
18932: LD_ADDR_VAR 0 6
18936: PUSH
18937: LD_EXP 56
18941: PUSH
18942: LD_VAR 0 2
18946: ARRAY
18947: PPUSH
18948: LD_INT 21
18950: PUSH
18951: LD_INT 1
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: LD_INT 1
18960: PUSH
18961: LD_INT 3
18963: PUSH
18964: LD_INT 54
18966: PUSH
18967: EMPTY
18968: LIST
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PUSH
18974: LD_INT 3
18976: PUSH
18977: LD_INT 24
18979: PUSH
18980: LD_INT 250
18982: PUSH
18983: EMPTY
18984: LIST
18985: LIST
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: LIST
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: PPUSH
19000: CALL_OW 72
19004: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
19005: LD_ADDR_VAR 0 7
19009: PUSH
19010: LD_VAR 0 5
19014: PUSH
19015: LD_VAR 0 6
19019: DIFF
19020: ST_TO_ADDR
// if not need_heal_1 then
19021: LD_VAR 0 6
19025: NOT
19026: IFFALSE 19059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
19028: LD_ADDR_EXP 59
19032: PUSH
19033: LD_EXP 59
19037: PPUSH
19038: LD_VAR 0 2
19042: PUSH
19043: LD_INT 1
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: PPUSH
19050: EMPTY
19051: PPUSH
19052: CALL 47019 0 3
19056: ST_TO_ADDR
19057: GO 19129
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
19059: LD_ADDR_EXP 59
19063: PUSH
19064: LD_EXP 59
19068: PPUSH
19069: LD_VAR 0 2
19073: PUSH
19074: LD_INT 1
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: PPUSH
19081: LD_EXP 59
19085: PUSH
19086: LD_VAR 0 2
19090: ARRAY
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: PPUSH
19096: LD_INT 3
19098: PUSH
19099: LD_INT 24
19101: PUSH
19102: LD_INT 1000
19104: PUSH
19105: EMPTY
19106: LIST
19107: LIST
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: PPUSH
19113: CALL_OW 72
19117: PUSH
19118: LD_VAR 0 6
19122: UNION
19123: PPUSH
19124: CALL 47019 0 3
19128: ST_TO_ADDR
// if not need_heal_2 then
19129: LD_VAR 0 7
19133: NOT
19134: IFFALSE 19167
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
19136: LD_ADDR_EXP 59
19140: PUSH
19141: LD_EXP 59
19145: PPUSH
19146: LD_VAR 0 2
19150: PUSH
19151: LD_INT 2
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: PPUSH
19158: EMPTY
19159: PPUSH
19160: CALL 47019 0 3
19164: ST_TO_ADDR
19165: GO 19199
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
19167: LD_ADDR_EXP 59
19171: PUSH
19172: LD_EXP 59
19176: PPUSH
19177: LD_VAR 0 2
19181: PUSH
19182: LD_INT 2
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: PPUSH
19189: LD_VAR 0 7
19193: PPUSH
19194: CALL 47019 0 3
19198: ST_TO_ADDR
// if need_heal_2 then
19199: LD_VAR 0 7
19203: IFFALSE 19375
// for j in need_heal_2 do
19205: LD_ADDR_VAR 0 3
19209: PUSH
19210: LD_VAR 0 7
19214: PUSH
19215: FOR_IN
19216: IFFALSE 19373
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
19218: LD_ADDR_VAR 0 5
19222: PUSH
19223: LD_EXP 56
19227: PUSH
19228: LD_VAR 0 2
19232: ARRAY
19233: PPUSH
19234: LD_INT 2
19236: PUSH
19237: LD_INT 30
19239: PUSH
19240: LD_INT 6
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PUSH
19247: LD_INT 30
19249: PUSH
19250: LD_INT 7
19252: PUSH
19253: EMPTY
19254: LIST
19255: LIST
19256: PUSH
19257: LD_INT 30
19259: PUSH
19260: LD_INT 8
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: PUSH
19267: LD_INT 30
19269: PUSH
19270: LD_INT 0
19272: PUSH
19273: EMPTY
19274: LIST
19275: LIST
19276: PUSH
19277: LD_INT 30
19279: PUSH
19280: LD_INT 1
19282: PUSH
19283: EMPTY
19284: LIST
19285: LIST
19286: PUSH
19287: LD_INT 25
19289: PUSH
19290: LD_INT 4
19292: PUSH
19293: EMPTY
19294: LIST
19295: LIST
19296: PUSH
19297: EMPTY
19298: LIST
19299: LIST
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: LIST
19305: PPUSH
19306: CALL_OW 72
19310: ST_TO_ADDR
// if tmp then
19311: LD_VAR 0 5
19315: IFFALSE 19371
// begin k := NearestUnitToUnit ( tmp , j ) ;
19317: LD_ADDR_VAR 0 4
19321: PUSH
19322: LD_VAR 0 5
19326: PPUSH
19327: LD_VAR 0 3
19331: PPUSH
19332: CALL_OW 74
19336: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
19337: LD_VAR 0 3
19341: PPUSH
19342: LD_VAR 0 4
19346: PPUSH
19347: CALL_OW 296
19351: PUSH
19352: LD_INT 7
19354: GREATER
19355: IFFALSE 19371
// ComMoveUnit ( j , k ) ;
19357: LD_VAR 0 3
19361: PPUSH
19362: LD_VAR 0 4
19366: PPUSH
19367: CALL_OW 112
// end ; end ;
19371: GO 19215
19373: POP
19374: POP
// if not need_heal_1 and not need_heal_2 then
19375: LD_VAR 0 6
19379: NOT
19380: PUSH
19381: LD_VAR 0 7
19385: NOT
19386: AND
19387: IFFALSE 19391
// continue ;
19389: GO 18844
// end ;
19391: GO 18844
19393: POP
19394: POP
// RaiseSailEvent ( 102 ) ;
19395: LD_INT 102
19397: PPUSH
19398: CALL_OW 427
// end ;
19402: LD_VAR 0 1
19406: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
19407: LD_INT 0
19409: PPUSH
19410: PPUSH
19411: PPUSH
19412: PPUSH
19413: PPUSH
19414: PPUSH
// if not mc_bases then
19415: LD_EXP 56
19419: NOT
19420: IFFALSE 19424
// exit ;
19422: GO 20134
// for i = 1 to mc_bases do
19424: LD_ADDR_VAR 0 2
19428: PUSH
19429: DOUBLE
19430: LD_INT 1
19432: DEC
19433: ST_TO_ADDR
19434: LD_EXP 56
19438: PUSH
19439: FOR_TO
19440: IFFALSE 20132
// begin if not mc_building_need_repair [ i ] then
19442: LD_EXP 57
19446: PUSH
19447: LD_VAR 0 2
19451: ARRAY
19452: NOT
19453: IFFALSE 19627
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
19455: LD_ADDR_VAR 0 6
19459: PUSH
19460: LD_EXP 75
19464: PUSH
19465: LD_VAR 0 2
19469: ARRAY
19470: PPUSH
19471: LD_INT 3
19473: PUSH
19474: LD_INT 24
19476: PUSH
19477: LD_INT 1000
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: PUSH
19484: EMPTY
19485: LIST
19486: LIST
19487: PUSH
19488: LD_INT 2
19490: PUSH
19491: LD_INT 34
19493: PUSH
19494: LD_INT 13
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: PUSH
19501: LD_INT 34
19503: PUSH
19504: LD_INT 52
19506: PUSH
19507: EMPTY
19508: LIST
19509: LIST
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: LIST
19515: PUSH
19516: EMPTY
19517: LIST
19518: LIST
19519: PPUSH
19520: CALL_OW 72
19524: ST_TO_ADDR
// if cranes then
19525: LD_VAR 0 6
19529: IFFALSE 19591
// for j in cranes do
19531: LD_ADDR_VAR 0 3
19535: PUSH
19536: LD_VAR 0 6
19540: PUSH
19541: FOR_IN
19542: IFFALSE 19589
// if not IsInArea ( j , mc_parking [ i ] ) then
19544: LD_VAR 0 3
19548: PPUSH
19549: LD_EXP 80
19553: PUSH
19554: LD_VAR 0 2
19558: ARRAY
19559: PPUSH
19560: CALL_OW 308
19564: NOT
19565: IFFALSE 19587
// ComMoveToArea ( j , mc_parking [ i ] ) ;
19567: LD_VAR 0 3
19571: PPUSH
19572: LD_EXP 80
19576: PUSH
19577: LD_VAR 0 2
19581: ARRAY
19582: PPUSH
19583: CALL_OW 113
19587: GO 19541
19589: POP
19590: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19591: LD_ADDR_EXP 58
19595: PUSH
19596: LD_EXP 58
19600: PPUSH
19601: LD_VAR 0 2
19605: PPUSH
19606: EMPTY
19607: PPUSH
19608: CALL_OW 1
19612: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
19613: LD_VAR 0 2
19617: PPUSH
19618: LD_INT 101
19620: PPUSH
19621: CALL 14519 0 2
// continue ;
19625: GO 19439
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
19627: LD_ADDR_EXP 62
19631: PUSH
19632: LD_EXP 62
19636: PPUSH
19637: LD_VAR 0 2
19641: PPUSH
19642: EMPTY
19643: PPUSH
19644: CALL_OW 1
19648: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
19649: LD_VAR 0 2
19653: PPUSH
19654: LD_INT 103
19656: PPUSH
19657: CALL 14519 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
19661: LD_ADDR_VAR 0 5
19665: PUSH
19666: LD_EXP 56
19670: PUSH
19671: LD_VAR 0 2
19675: ARRAY
19676: PUSH
19677: LD_EXP 85
19681: PUSH
19682: LD_VAR 0 2
19686: ARRAY
19687: UNION
19688: PPUSH
19689: LD_INT 2
19691: PUSH
19692: LD_INT 25
19694: PUSH
19695: LD_INT 2
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: PUSH
19702: LD_INT 25
19704: PUSH
19705: LD_INT 16
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: LIST
19716: PUSH
19717: EMPTY
19718: LIST
19719: PPUSH
19720: CALL_OW 72
19724: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
19725: LD_ADDR_VAR 0 6
19729: PUSH
19730: LD_EXP 75
19734: PUSH
19735: LD_VAR 0 2
19739: ARRAY
19740: PPUSH
19741: LD_INT 2
19743: PUSH
19744: LD_INT 34
19746: PUSH
19747: LD_INT 13
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PUSH
19754: LD_INT 34
19756: PUSH
19757: LD_INT 52
19759: PUSH
19760: EMPTY
19761: LIST
19762: LIST
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: LIST
19768: PPUSH
19769: CALL_OW 72
19773: ST_TO_ADDR
// if cranes then
19774: LD_VAR 0 6
19778: IFFALSE 19914
// begin for j in cranes do
19780: LD_ADDR_VAR 0 3
19784: PUSH
19785: LD_VAR 0 6
19789: PUSH
19790: FOR_IN
19791: IFFALSE 19912
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
19793: LD_VAR 0 3
19797: PPUSH
19798: CALL_OW 256
19802: PUSH
19803: LD_INT 500
19805: GREATEREQUAL
19806: PUSH
19807: LD_VAR 0 3
19811: PPUSH
19812: CALL_OW 314
19816: NOT
19817: AND
19818: IFFALSE 19852
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
19820: LD_VAR 0 3
19824: PPUSH
19825: LD_EXP 57
19829: PUSH
19830: LD_VAR 0 2
19834: ARRAY
19835: PPUSH
19836: LD_VAR 0 3
19840: PPUSH
19841: CALL_OW 74
19845: PPUSH
19846: CALL_OW 130
19850: GO 19910
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
19852: LD_VAR 0 3
19856: PPUSH
19857: CALL_OW 256
19861: PUSH
19862: LD_INT 500
19864: LESS
19865: PUSH
19866: LD_VAR 0 3
19870: PPUSH
19871: LD_EXP 80
19875: PUSH
19876: LD_VAR 0 2
19880: ARRAY
19881: PPUSH
19882: CALL_OW 308
19886: NOT
19887: AND
19888: IFFALSE 19910
// ComMoveToArea ( j , mc_parking [ i ] ) ;
19890: LD_VAR 0 3
19894: PPUSH
19895: LD_EXP 80
19899: PUSH
19900: LD_VAR 0 2
19904: ARRAY
19905: PPUSH
19906: CALL_OW 113
19910: GO 19790
19912: POP
19913: POP
// end ; if not tmp then
19914: LD_VAR 0 5
19918: NOT
19919: IFFALSE 19923
// continue ;
19921: GO 19439
// for j in tmp do
19923: LD_ADDR_VAR 0 3
19927: PUSH
19928: LD_VAR 0 5
19932: PUSH
19933: FOR_IN
19934: IFFALSE 20128
// begin if mc_need_heal [ i ] then
19936: LD_EXP 59
19940: PUSH
19941: LD_VAR 0 2
19945: ARRAY
19946: IFFALSE 19994
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
19948: LD_VAR 0 3
19952: PUSH
19953: LD_EXP 59
19957: PUSH
19958: LD_VAR 0 2
19962: ARRAY
19963: PUSH
19964: LD_INT 1
19966: ARRAY
19967: IN
19968: PUSH
19969: LD_VAR 0 3
19973: PUSH
19974: LD_EXP 59
19978: PUSH
19979: LD_VAR 0 2
19983: ARRAY
19984: PUSH
19985: LD_INT 2
19987: ARRAY
19988: IN
19989: OR
19990: IFFALSE 19994
// continue ;
19992: GO 19933
// if IsInUnit ( j ) then
19994: LD_VAR 0 3
19998: PPUSH
19999: CALL_OW 310
20003: IFFALSE 20014
// ComExitBuilding ( j ) ;
20005: LD_VAR 0 3
20009: PPUSH
20010: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
20014: LD_VAR 0 3
20018: PUSH
20019: LD_EXP 58
20023: PUSH
20024: LD_VAR 0 2
20028: ARRAY
20029: IN
20030: NOT
20031: IFFALSE 20089
// begin SetTag ( j , 101 ) ;
20033: LD_VAR 0 3
20037: PPUSH
20038: LD_INT 101
20040: PPUSH
20041: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
20045: LD_ADDR_EXP 58
20049: PUSH
20050: LD_EXP 58
20054: PPUSH
20055: LD_VAR 0 2
20059: PUSH
20060: LD_EXP 58
20064: PUSH
20065: LD_VAR 0 2
20069: ARRAY
20070: PUSH
20071: LD_INT 1
20073: PLUS
20074: PUSH
20075: EMPTY
20076: LIST
20077: LIST
20078: PPUSH
20079: LD_VAR 0 3
20083: PPUSH
20084: CALL 47019 0 3
20088: ST_TO_ADDR
// end ; wait ( 1 ) ;
20089: LD_INT 1
20091: PPUSH
20092: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
20096: LD_VAR 0 3
20100: PPUSH
20101: LD_EXP 57
20105: PUSH
20106: LD_VAR 0 2
20110: ARRAY
20111: PPUSH
20112: LD_VAR 0 3
20116: PPUSH
20117: CALL_OW 74
20121: PPUSH
20122: CALL_OW 130
// end ;
20126: GO 19933
20128: POP
20129: POP
// end ;
20130: GO 19439
20132: POP
20133: POP
// end ;
20134: LD_VAR 0 1
20138: RET
// export function MC_Heal ; var i , j , tmp ; begin
20139: LD_INT 0
20141: PPUSH
20142: PPUSH
20143: PPUSH
20144: PPUSH
// if not mc_bases then
20145: LD_EXP 56
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20556
// for i = 1 to mc_bases do
20154: LD_ADDR_VAR 0 2
20158: PUSH
20159: DOUBLE
20160: LD_INT 1
20162: DEC
20163: ST_TO_ADDR
20164: LD_EXP 56
20168: PUSH
20169: FOR_TO
20170: IFFALSE 20554
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
20172: LD_EXP 59
20176: PUSH
20177: LD_VAR 0 2
20181: ARRAY
20182: PUSH
20183: LD_INT 1
20185: ARRAY
20186: NOT
20187: PUSH
20188: LD_EXP 59
20192: PUSH
20193: LD_VAR 0 2
20197: ARRAY
20198: PUSH
20199: LD_INT 2
20201: ARRAY
20202: NOT
20203: AND
20204: IFFALSE 20242
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
20206: LD_ADDR_EXP 60
20210: PUSH
20211: LD_EXP 60
20215: PPUSH
20216: LD_VAR 0 2
20220: PPUSH
20221: EMPTY
20222: PPUSH
20223: CALL_OW 1
20227: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
20228: LD_VAR 0 2
20232: PPUSH
20233: LD_INT 102
20235: PPUSH
20236: CALL 14519 0 2
// continue ;
20240: GO 20169
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
20242: LD_ADDR_VAR 0 4
20246: PUSH
20247: LD_EXP 56
20251: PUSH
20252: LD_VAR 0 2
20256: ARRAY
20257: PPUSH
20258: LD_INT 25
20260: PUSH
20261: LD_INT 4
20263: PUSH
20264: EMPTY
20265: LIST
20266: LIST
20267: PPUSH
20268: CALL_OW 72
20272: ST_TO_ADDR
// if not tmp then
20273: LD_VAR 0 4
20277: NOT
20278: IFFALSE 20282
// continue ;
20280: GO 20169
// if mc_taming [ i ] then
20282: LD_EXP 87
20286: PUSH
20287: LD_VAR 0 2
20291: ARRAY
20292: IFFALSE 20316
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20294: LD_ADDR_EXP 87
20298: PUSH
20299: LD_EXP 87
20303: PPUSH
20304: LD_VAR 0 2
20308: PPUSH
20309: EMPTY
20310: PPUSH
20311: CALL_OW 1
20315: ST_TO_ADDR
// for j in tmp do
20316: LD_ADDR_VAR 0 3
20320: PUSH
20321: LD_VAR 0 4
20325: PUSH
20326: FOR_IN
20327: IFFALSE 20550
// begin if IsInUnit ( j ) then
20329: LD_VAR 0 3
20333: PPUSH
20334: CALL_OW 310
20338: IFFALSE 20349
// ComExitBuilding ( j ) ;
20340: LD_VAR 0 3
20344: PPUSH
20345: CALL_OW 122
// if not j in mc_healers [ i ] then
20349: LD_VAR 0 3
20353: PUSH
20354: LD_EXP 60
20358: PUSH
20359: LD_VAR 0 2
20363: ARRAY
20364: IN
20365: NOT
20366: IFFALSE 20412
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
20368: LD_ADDR_EXP 60
20372: PUSH
20373: LD_EXP 60
20377: PPUSH
20378: LD_VAR 0 2
20382: PUSH
20383: LD_EXP 60
20387: PUSH
20388: LD_VAR 0 2
20392: ARRAY
20393: PUSH
20394: LD_INT 1
20396: PLUS
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PPUSH
20402: LD_VAR 0 3
20406: PPUSH
20407: CALL 47019 0 3
20411: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
20412: LD_VAR 0 3
20416: PPUSH
20417: CALL_OW 110
20421: PUSH
20422: LD_INT 102
20424: NONEQUAL
20425: IFFALSE 20439
// SetTag ( j , 102 ) ;
20427: LD_VAR 0 3
20431: PPUSH
20432: LD_INT 102
20434: PPUSH
20435: CALL_OW 109
// Wait ( 3 ) ;
20439: LD_INT 3
20441: PPUSH
20442: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
20446: LD_EXP 59
20450: PUSH
20451: LD_VAR 0 2
20455: ARRAY
20456: PUSH
20457: LD_INT 1
20459: ARRAY
20460: IFFALSE 20492
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
20462: LD_VAR 0 3
20466: PPUSH
20467: LD_EXP 59
20471: PUSH
20472: LD_VAR 0 2
20476: ARRAY
20477: PUSH
20478: LD_INT 1
20480: ARRAY
20481: PUSH
20482: LD_INT 1
20484: ARRAY
20485: PPUSH
20486: CALL_OW 128
20490: GO 20548
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
20492: LD_VAR 0 3
20496: PPUSH
20497: CALL_OW 314
20501: NOT
20502: PUSH
20503: LD_EXP 59
20507: PUSH
20508: LD_VAR 0 2
20512: ARRAY
20513: PUSH
20514: LD_INT 2
20516: ARRAY
20517: AND
20518: IFFALSE 20548
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
20520: LD_VAR 0 3
20524: PPUSH
20525: LD_EXP 59
20529: PUSH
20530: LD_VAR 0 2
20534: ARRAY
20535: PUSH
20536: LD_INT 2
20538: ARRAY
20539: PUSH
20540: LD_INT 1
20542: ARRAY
20543: PPUSH
20544: CALL_OW 128
// end ;
20548: GO 20326
20550: POP
20551: POP
// end ;
20552: GO 20169
20554: POP
20555: POP
// end ;
20556: LD_VAR 0 1
20560: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
20561: LD_INT 0
20563: PPUSH
20564: PPUSH
20565: PPUSH
20566: PPUSH
20567: PPUSH
// if not mc_bases then
20568: LD_EXP 56
20572: NOT
20573: IFFALSE 20577
// exit ;
20575: GO 21720
// for i = 1 to mc_bases do
20577: LD_ADDR_VAR 0 2
20581: PUSH
20582: DOUBLE
20583: LD_INT 1
20585: DEC
20586: ST_TO_ADDR
20587: LD_EXP 56
20591: PUSH
20592: FOR_TO
20593: IFFALSE 21718
// begin if mc_scan [ i ] then
20595: LD_EXP 79
20599: PUSH
20600: LD_VAR 0 2
20604: ARRAY
20605: IFFALSE 20609
// continue ;
20607: GO 20592
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
20609: LD_EXP 61
20613: PUSH
20614: LD_VAR 0 2
20618: ARRAY
20619: NOT
20620: PUSH
20621: LD_EXP 63
20625: PUSH
20626: LD_VAR 0 2
20630: ARRAY
20631: NOT
20632: AND
20633: PUSH
20634: LD_EXP 62
20638: PUSH
20639: LD_VAR 0 2
20643: ARRAY
20644: AND
20645: IFFALSE 20683
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
20647: LD_ADDR_EXP 62
20651: PUSH
20652: LD_EXP 62
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
20669: LD_VAR 0 2
20673: PPUSH
20674: LD_INT 103
20676: PPUSH
20677: CALL 14519 0 2
// continue ;
20681: GO 20592
// end ; if mc_construct_list [ i ] then
20683: LD_EXP 63
20687: PUSH
20688: LD_VAR 0 2
20692: ARRAY
20693: IFFALSE 20913
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
20695: LD_ADDR_VAR 0 4
20699: PUSH
20700: LD_EXP 56
20704: PUSH
20705: LD_VAR 0 2
20709: ARRAY
20710: PPUSH
20711: LD_INT 25
20713: PUSH
20714: LD_INT 2
20716: PUSH
20717: EMPTY
20718: LIST
20719: LIST
20720: PPUSH
20721: CALL_OW 72
20725: PUSH
20726: LD_EXP 58
20730: PUSH
20731: LD_VAR 0 2
20735: ARRAY
20736: DIFF
20737: ST_TO_ADDR
// if not tmp then
20738: LD_VAR 0 4
20742: NOT
20743: IFFALSE 20747
// continue ;
20745: GO 20592
// for j in tmp do
20747: LD_ADDR_VAR 0 3
20751: PUSH
20752: LD_VAR 0 4
20756: PUSH
20757: FOR_IN
20758: IFFALSE 20909
// begin if not mc_builders [ i ] then
20760: LD_EXP 62
20764: PUSH
20765: LD_VAR 0 2
20769: ARRAY
20770: NOT
20771: IFFALSE 20829
// begin SetTag ( j , 103 ) ;
20773: LD_VAR 0 3
20777: PPUSH
20778: LD_INT 103
20780: PPUSH
20781: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
20785: LD_ADDR_EXP 62
20789: PUSH
20790: LD_EXP 62
20794: PPUSH
20795: LD_VAR 0 2
20799: PUSH
20800: LD_EXP 62
20804: PUSH
20805: LD_VAR 0 2
20809: ARRAY
20810: PUSH
20811: LD_INT 1
20813: PLUS
20814: PUSH
20815: EMPTY
20816: LIST
20817: LIST
20818: PPUSH
20819: LD_VAR 0 3
20823: PPUSH
20824: CALL 47019 0 3
20828: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
20829: LD_VAR 0 3
20833: PPUSH
20834: CALL_OW 310
20838: IFFALSE 20849
// ComExitBuilding ( j ) ;
20840: LD_VAR 0 3
20844: PPUSH
20845: CALL_OW 122
// wait ( 3 ) ;
20849: LD_INT 3
20851: PPUSH
20852: CALL_OW 67
// if not mc_construct_list [ i ] then
20856: LD_EXP 63
20860: PUSH
20861: LD_VAR 0 2
20865: ARRAY
20866: NOT
20867: IFFALSE 20871
// break ;
20869: GO 20909
// if not HasTask ( j ) then
20871: LD_VAR 0 3
20875: PPUSH
20876: CALL_OW 314
20880: NOT
20881: IFFALSE 20907
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
20883: LD_VAR 0 3
20887: PPUSH
20888: LD_EXP 63
20892: PUSH
20893: LD_VAR 0 2
20897: ARRAY
20898: PUSH
20899: LD_INT 1
20901: ARRAY
20902: PPUSH
20903: CALL 49870 0 2
// end ;
20907: GO 20757
20909: POP
20910: POP
// end else
20911: GO 21716
// if mc_build_list [ i ] then
20913: LD_EXP 61
20917: PUSH
20918: LD_VAR 0 2
20922: ARRAY
20923: IFFALSE 21716
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
20925: LD_ADDR_VAR 0 5
20929: PUSH
20930: LD_EXP 56
20934: PUSH
20935: LD_VAR 0 2
20939: ARRAY
20940: PPUSH
20941: LD_INT 2
20943: PUSH
20944: LD_INT 30
20946: PUSH
20947: LD_INT 0
20949: PUSH
20950: EMPTY
20951: LIST
20952: LIST
20953: PUSH
20954: LD_INT 30
20956: PUSH
20957: LD_INT 1
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: PUSH
20964: EMPTY
20965: LIST
20966: LIST
20967: LIST
20968: PPUSH
20969: CALL_OW 72
20973: ST_TO_ADDR
// if depot then
20974: LD_VAR 0 5
20978: IFFALSE 20996
// depot := depot [ 1 ] else
20980: LD_ADDR_VAR 0 5
20984: PUSH
20985: LD_VAR 0 5
20989: PUSH
20990: LD_INT 1
20992: ARRAY
20993: ST_TO_ADDR
20994: GO 21004
// depot := 0 ;
20996: LD_ADDR_VAR 0 5
21000: PUSH
21001: LD_INT 0
21003: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
21004: LD_EXP 61
21008: PUSH
21009: LD_VAR 0 2
21013: ARRAY
21014: PUSH
21015: LD_INT 1
21017: ARRAY
21018: PUSH
21019: LD_INT 1
21021: ARRAY
21022: PPUSH
21023: CALL 49700 0 1
21027: PUSH
21028: LD_EXP 56
21032: PUSH
21033: LD_VAR 0 2
21037: ARRAY
21038: PPUSH
21039: LD_INT 2
21041: PUSH
21042: LD_INT 30
21044: PUSH
21045: LD_INT 2
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: PUSH
21052: LD_INT 30
21054: PUSH
21055: LD_INT 3
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: LIST
21066: PPUSH
21067: CALL_OW 72
21071: NOT
21072: AND
21073: IFFALSE 21178
// begin for j = 1 to mc_build_list [ i ] do
21075: LD_ADDR_VAR 0 3
21079: PUSH
21080: DOUBLE
21081: LD_INT 1
21083: DEC
21084: ST_TO_ADDR
21085: LD_EXP 61
21089: PUSH
21090: LD_VAR 0 2
21094: ARRAY
21095: PUSH
21096: FOR_TO
21097: IFFALSE 21176
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
21099: LD_EXP 61
21103: PUSH
21104: LD_VAR 0 2
21108: ARRAY
21109: PUSH
21110: LD_VAR 0 3
21114: ARRAY
21115: PUSH
21116: LD_INT 1
21118: ARRAY
21119: PUSH
21120: LD_INT 2
21122: EQUAL
21123: IFFALSE 21174
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
21125: LD_ADDR_EXP 61
21129: PUSH
21130: LD_EXP 61
21134: PPUSH
21135: LD_VAR 0 2
21139: PPUSH
21140: LD_EXP 61
21144: PUSH
21145: LD_VAR 0 2
21149: ARRAY
21150: PPUSH
21151: LD_VAR 0 3
21155: PPUSH
21156: LD_INT 1
21158: PPUSH
21159: LD_INT 0
21161: PPUSH
21162: CALL 46437 0 4
21166: PPUSH
21167: CALL_OW 1
21171: ST_TO_ADDR
// break ;
21172: GO 21176
// end ;
21174: GO 21096
21176: POP
21177: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
21178: LD_EXP 61
21182: PUSH
21183: LD_VAR 0 2
21187: ARRAY
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PUSH
21193: LD_INT 1
21195: ARRAY
21196: PUSH
21197: LD_INT 0
21199: EQUAL
21200: PUSH
21201: LD_VAR 0 5
21205: PUSH
21206: LD_VAR 0 5
21210: PPUSH
21211: LD_EXP 61
21215: PUSH
21216: LD_VAR 0 2
21220: ARRAY
21221: PUSH
21222: LD_INT 1
21224: ARRAY
21225: PUSH
21226: LD_INT 1
21228: ARRAY
21229: PPUSH
21230: LD_EXP 61
21234: PUSH
21235: LD_VAR 0 2
21239: ARRAY
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: PUSH
21245: LD_INT 2
21247: ARRAY
21248: PPUSH
21249: LD_EXP 61
21253: PUSH
21254: LD_VAR 0 2
21258: ARRAY
21259: PUSH
21260: LD_INT 1
21262: ARRAY
21263: PUSH
21264: LD_INT 3
21266: ARRAY
21267: PPUSH
21268: LD_EXP 61
21272: PUSH
21273: LD_VAR 0 2
21277: ARRAY
21278: PUSH
21279: LD_INT 1
21281: ARRAY
21282: PUSH
21283: LD_INT 4
21285: ARRAY
21286: PPUSH
21287: CALL 54434 0 5
21291: AND
21292: OR
21293: IFFALSE 21574
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
21295: LD_ADDR_VAR 0 4
21299: PUSH
21300: LD_EXP 56
21304: PUSH
21305: LD_VAR 0 2
21309: ARRAY
21310: PPUSH
21311: LD_INT 25
21313: PUSH
21314: LD_INT 2
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: PPUSH
21321: CALL_OW 72
21325: PUSH
21326: LD_EXP 58
21330: PUSH
21331: LD_VAR 0 2
21335: ARRAY
21336: DIFF
21337: ST_TO_ADDR
// if not tmp then
21338: LD_VAR 0 4
21342: NOT
21343: IFFALSE 21347
// continue ;
21345: GO 20592
// for j in tmp do
21347: LD_ADDR_VAR 0 3
21351: PUSH
21352: LD_VAR 0 4
21356: PUSH
21357: FOR_IN
21358: IFFALSE 21570
// begin if not mc_builders [ i ] then
21360: LD_EXP 62
21364: PUSH
21365: LD_VAR 0 2
21369: ARRAY
21370: NOT
21371: IFFALSE 21429
// begin SetTag ( j , 103 ) ;
21373: LD_VAR 0 3
21377: PPUSH
21378: LD_INT 103
21380: PPUSH
21381: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
21385: LD_ADDR_EXP 62
21389: PUSH
21390: LD_EXP 62
21394: PPUSH
21395: LD_VAR 0 2
21399: PUSH
21400: LD_EXP 62
21404: PUSH
21405: LD_VAR 0 2
21409: ARRAY
21410: PUSH
21411: LD_INT 1
21413: PLUS
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PPUSH
21419: LD_VAR 0 3
21423: PPUSH
21424: CALL 47019 0 3
21428: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
21429: LD_VAR 0 3
21433: PPUSH
21434: CALL_OW 310
21438: IFFALSE 21449
// ComExitBuilding ( j ) ;
21440: LD_VAR 0 3
21444: PPUSH
21445: CALL_OW 122
// wait ( 3 ) ;
21449: LD_INT 3
21451: PPUSH
21452: CALL_OW 67
// if not mc_build_list [ i ] then
21456: LD_EXP 61
21460: PUSH
21461: LD_VAR 0 2
21465: ARRAY
21466: NOT
21467: IFFALSE 21471
// break ;
21469: GO 21570
// if not HasTask ( j ) then
21471: LD_VAR 0 3
21475: PPUSH
21476: CALL_OW 314
21480: NOT
21481: IFFALSE 21568
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
21483: LD_VAR 0 3
21487: PPUSH
21488: LD_EXP 61
21492: PUSH
21493: LD_VAR 0 2
21497: ARRAY
21498: PUSH
21499: LD_INT 1
21501: ARRAY
21502: PUSH
21503: LD_INT 1
21505: ARRAY
21506: PPUSH
21507: LD_EXP 61
21511: PUSH
21512: LD_VAR 0 2
21516: ARRAY
21517: PUSH
21518: LD_INT 1
21520: ARRAY
21521: PUSH
21522: LD_INT 2
21524: ARRAY
21525: PPUSH
21526: LD_EXP 61
21530: PUSH
21531: LD_VAR 0 2
21535: ARRAY
21536: PUSH
21537: LD_INT 1
21539: ARRAY
21540: PUSH
21541: LD_INT 3
21543: ARRAY
21544: PPUSH
21545: LD_EXP 61
21549: PUSH
21550: LD_VAR 0 2
21554: ARRAY
21555: PUSH
21556: LD_INT 1
21558: ARRAY
21559: PUSH
21560: LD_INT 4
21562: ARRAY
21563: PPUSH
21564: CALL_OW 145
// end ;
21568: GO 21357
21570: POP
21571: POP
// end else
21572: GO 21716
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
21574: LD_EXP 56
21578: PUSH
21579: LD_VAR 0 2
21583: ARRAY
21584: PPUSH
21585: LD_EXP 61
21589: PUSH
21590: LD_VAR 0 2
21594: ARRAY
21595: PUSH
21596: LD_INT 1
21598: ARRAY
21599: PUSH
21600: LD_INT 1
21602: ARRAY
21603: PPUSH
21604: LD_EXP 61
21608: PUSH
21609: LD_VAR 0 2
21613: ARRAY
21614: PUSH
21615: LD_INT 1
21617: ARRAY
21618: PUSH
21619: LD_INT 2
21621: ARRAY
21622: PPUSH
21623: LD_EXP 61
21627: PUSH
21628: LD_VAR 0 2
21632: ARRAY
21633: PUSH
21634: LD_INT 1
21636: ARRAY
21637: PUSH
21638: LD_INT 3
21640: ARRAY
21641: PPUSH
21642: LD_EXP 61
21646: PUSH
21647: LD_VAR 0 2
21651: ARRAY
21652: PUSH
21653: LD_INT 1
21655: ARRAY
21656: PUSH
21657: LD_INT 4
21659: ARRAY
21660: PPUSH
21661: CALL 53770 0 5
21665: NOT
21666: IFFALSE 21716
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
21668: LD_ADDR_EXP 61
21672: PUSH
21673: LD_EXP 61
21677: PPUSH
21678: LD_VAR 0 2
21682: PPUSH
21683: LD_EXP 61
21687: PUSH
21688: LD_VAR 0 2
21692: ARRAY
21693: PPUSH
21694: LD_INT 1
21696: PPUSH
21697: LD_INT 1
21699: NEG
21700: PPUSH
21701: LD_INT 0
21703: PPUSH
21704: CALL 46437 0 4
21708: PPUSH
21709: CALL_OW 1
21713: ST_TO_ADDR
// continue ;
21714: GO 20592
// end ; end ; end ;
21716: GO 20592
21718: POP
21719: POP
// end ;
21720: LD_VAR 0 1
21724: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
21725: LD_INT 0
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
21732: PPUSH
// if not mc_bases then
21733: LD_EXP 56
21737: NOT
21738: IFFALSE 21742
// exit ;
21740: GO 22169
// for i = 1 to mc_bases do
21742: LD_ADDR_VAR 0 2
21746: PUSH
21747: DOUBLE
21748: LD_INT 1
21750: DEC
21751: ST_TO_ADDR
21752: LD_EXP 56
21756: PUSH
21757: FOR_TO
21758: IFFALSE 22167
// begin tmp := mc_build_upgrade [ i ] ;
21760: LD_ADDR_VAR 0 4
21764: PUSH
21765: LD_EXP 88
21769: PUSH
21770: LD_VAR 0 2
21774: ARRAY
21775: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
21776: LD_ADDR_VAR 0 6
21780: PUSH
21781: LD_EXP 89
21785: PUSH
21786: LD_VAR 0 2
21790: ARRAY
21791: PPUSH
21792: LD_INT 2
21794: PUSH
21795: LD_INT 30
21797: PUSH
21798: LD_INT 6
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PUSH
21805: LD_INT 30
21807: PUSH
21808: LD_INT 7
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: LIST
21819: PPUSH
21820: CALL_OW 72
21824: ST_TO_ADDR
// if not tmp and not lab then
21825: LD_VAR 0 4
21829: NOT
21830: PUSH
21831: LD_VAR 0 6
21835: NOT
21836: AND
21837: IFFALSE 21841
// continue ;
21839: GO 21757
// if tmp then
21841: LD_VAR 0 4
21845: IFFALSE 21965
// for j in tmp do
21847: LD_ADDR_VAR 0 3
21851: PUSH
21852: LD_VAR 0 4
21856: PUSH
21857: FOR_IN
21858: IFFALSE 21963
// begin if UpgradeCost ( j ) then
21860: LD_VAR 0 3
21864: PPUSH
21865: CALL 53430 0 1
21869: IFFALSE 21961
// begin ComUpgrade ( j ) ;
21871: LD_VAR 0 3
21875: PPUSH
21876: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
21880: LD_ADDR_EXP 88
21884: PUSH
21885: LD_EXP 88
21889: PPUSH
21890: LD_VAR 0 2
21894: PPUSH
21895: LD_EXP 88
21899: PUSH
21900: LD_VAR 0 2
21904: ARRAY
21905: PUSH
21906: LD_VAR 0 3
21910: DIFF
21911: PPUSH
21912: CALL_OW 1
21916: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
21917: LD_ADDR_EXP 63
21921: PUSH
21922: LD_EXP 63
21926: PPUSH
21927: LD_VAR 0 2
21931: PUSH
21932: LD_EXP 63
21936: PUSH
21937: LD_VAR 0 2
21941: ARRAY
21942: PUSH
21943: LD_INT 1
21945: PLUS
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: PPUSH
21951: LD_VAR 0 3
21955: PPUSH
21956: CALL 47019 0 3
21960: ST_TO_ADDR
// end ; end ;
21961: GO 21857
21963: POP
21964: POP
// if not lab or not mc_lab_upgrade [ i ] then
21965: LD_VAR 0 6
21969: NOT
21970: PUSH
21971: LD_EXP 90
21975: PUSH
21976: LD_VAR 0 2
21980: ARRAY
21981: NOT
21982: OR
21983: IFFALSE 21987
// continue ;
21985: GO 21757
// for j in lab do
21987: LD_ADDR_VAR 0 3
21991: PUSH
21992: LD_VAR 0 6
21996: PUSH
21997: FOR_IN
21998: IFFALSE 22163
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
22000: LD_VAR 0 3
22004: PPUSH
22005: CALL_OW 266
22009: PUSH
22010: LD_INT 6
22012: PUSH
22013: LD_INT 7
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: IN
22020: PUSH
22021: LD_VAR 0 3
22025: PPUSH
22026: CALL_OW 461
22030: PUSH
22031: LD_INT 1
22033: NONEQUAL
22034: AND
22035: IFFALSE 22161
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
22037: LD_VAR 0 3
22041: PPUSH
22042: LD_EXP 90
22046: PUSH
22047: LD_VAR 0 2
22051: ARRAY
22052: PUSH
22053: LD_INT 1
22055: ARRAY
22056: PPUSH
22057: CALL 53635 0 2
22061: IFFALSE 22161
// begin ComCancel ( j ) ;
22063: LD_VAR 0 3
22067: PPUSH
22068: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
22072: LD_VAR 0 3
22076: PPUSH
22077: LD_EXP 90
22081: PUSH
22082: LD_VAR 0 2
22086: ARRAY
22087: PUSH
22088: LD_INT 1
22090: ARRAY
22091: PPUSH
22092: CALL_OW 207
// if not j in mc_construct_list [ i ] then
22096: LD_VAR 0 3
22100: PUSH
22101: LD_EXP 63
22105: PUSH
22106: LD_VAR 0 2
22110: ARRAY
22111: IN
22112: NOT
22113: IFFALSE 22159
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
22115: LD_ADDR_EXP 63
22119: PUSH
22120: LD_EXP 63
22124: PPUSH
22125: LD_VAR 0 2
22129: PUSH
22130: LD_EXP 63
22134: PUSH
22135: LD_VAR 0 2
22139: ARRAY
22140: PUSH
22141: LD_INT 1
22143: PLUS
22144: PUSH
22145: EMPTY
22146: LIST
22147: LIST
22148: PPUSH
22149: LD_VAR 0 3
22153: PPUSH
22154: CALL 47019 0 3
22158: ST_TO_ADDR
// break ;
22159: GO 22163
// end ; end ; end ;
22161: GO 21997
22163: POP
22164: POP
// end ;
22165: GO 21757
22167: POP
22168: POP
// end ;
22169: LD_VAR 0 1
22173: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
22174: LD_INT 0
22176: PPUSH
22177: PPUSH
22178: PPUSH
22179: PPUSH
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
22184: PPUSH
// if not mc_bases then
22185: LD_EXP 56
22189: NOT
22190: IFFALSE 22194
// exit ;
22192: GO 22599
// for i = 1 to mc_bases do
22194: LD_ADDR_VAR 0 2
22198: PUSH
22199: DOUBLE
22200: LD_INT 1
22202: DEC
22203: ST_TO_ADDR
22204: LD_EXP 56
22208: PUSH
22209: FOR_TO
22210: IFFALSE 22597
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
22212: LD_EXP 64
22216: PUSH
22217: LD_VAR 0 2
22221: ARRAY
22222: NOT
22223: PUSH
22224: LD_EXP 56
22228: PUSH
22229: LD_VAR 0 2
22233: ARRAY
22234: PPUSH
22235: LD_INT 30
22237: PUSH
22238: LD_INT 3
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PPUSH
22245: CALL_OW 72
22249: NOT
22250: OR
22251: IFFALSE 22255
// continue ;
22253: GO 22209
// busy := false ;
22255: LD_ADDR_VAR 0 8
22259: PUSH
22260: LD_INT 0
22262: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
22263: LD_ADDR_VAR 0 4
22267: PUSH
22268: LD_EXP 56
22272: PUSH
22273: LD_VAR 0 2
22277: ARRAY
22278: PPUSH
22279: LD_INT 30
22281: PUSH
22282: LD_INT 3
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: PPUSH
22289: CALL_OW 72
22293: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
22294: LD_ADDR_VAR 0 6
22298: PUSH
22299: LD_EXP 64
22303: PUSH
22304: LD_VAR 0 2
22308: ARRAY
22309: PPUSH
22310: LD_INT 2
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 32
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: LD_INT 30
22325: PUSH
22326: LD_INT 33
22328: PUSH
22329: EMPTY
22330: LIST
22331: LIST
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: LIST
22337: PPUSH
22338: CALL_OW 72
22342: ST_TO_ADDR
// if not t then
22343: LD_VAR 0 6
22347: NOT
22348: IFFALSE 22352
// continue ;
22350: GO 22209
// for j in tmp do
22352: LD_ADDR_VAR 0 3
22356: PUSH
22357: LD_VAR 0 4
22361: PUSH
22362: FOR_IN
22363: IFFALSE 22393
// if not BuildingStatus ( j ) = bs_idle then
22365: LD_VAR 0 3
22369: PPUSH
22370: CALL_OW 461
22374: PUSH
22375: LD_INT 2
22377: EQUAL
22378: NOT
22379: IFFALSE 22391
// begin busy := true ;
22381: LD_ADDR_VAR 0 8
22385: PUSH
22386: LD_INT 1
22388: ST_TO_ADDR
// break ;
22389: GO 22393
// end ;
22391: GO 22362
22393: POP
22394: POP
// if busy then
22395: LD_VAR 0 8
22399: IFFALSE 22403
// continue ;
22401: GO 22209
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
22403: LD_ADDR_VAR 0 7
22407: PUSH
22408: LD_VAR 0 6
22412: PPUSH
22413: LD_INT 35
22415: PUSH
22416: LD_INT 0
22418: PUSH
22419: EMPTY
22420: LIST
22421: LIST
22422: PPUSH
22423: CALL_OW 72
22427: ST_TO_ADDR
// if tw then
22428: LD_VAR 0 7
22432: IFFALSE 22509
// begin tw := tw [ 1 ] ;
22434: LD_ADDR_VAR 0 7
22438: PUSH
22439: LD_VAR 0 7
22443: PUSH
22444: LD_INT 1
22446: ARRAY
22447: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
22448: LD_ADDR_VAR 0 9
22452: PUSH
22453: LD_VAR 0 7
22457: PPUSH
22458: LD_EXP 81
22462: PUSH
22463: LD_VAR 0 2
22467: ARRAY
22468: PPUSH
22469: CALL 51989 0 2
22473: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
22474: LD_EXP 95
22478: PUSH
22479: LD_VAR 0 2
22483: ARRAY
22484: IFFALSE 22507
// if not weapon in mc_allowed_tower_weapons [ i ] then
22486: LD_VAR 0 9
22490: PUSH
22491: LD_EXP 95
22495: PUSH
22496: LD_VAR 0 2
22500: ARRAY
22501: IN
22502: NOT
22503: IFFALSE 22507
// continue ;
22505: GO 22209
// end else
22507: GO 22572
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
22509: LD_ADDR_VAR 0 5
22513: PUSH
22514: LD_EXP 64
22518: PUSH
22519: LD_VAR 0 2
22523: ARRAY
22524: PPUSH
22525: LD_VAR 0 4
22529: PPUSH
22530: CALL 82190 0 2
22534: ST_TO_ADDR
// if not tmp2 then
22535: LD_VAR 0 5
22539: NOT
22540: IFFALSE 22544
// continue ;
22542: GO 22209
// tw := tmp2 [ 1 ] ;
22544: LD_ADDR_VAR 0 7
22548: PUSH
22549: LD_VAR 0 5
22553: PUSH
22554: LD_INT 1
22556: ARRAY
22557: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
22558: LD_ADDR_VAR 0 9
22562: PUSH
22563: LD_VAR 0 5
22567: PUSH
22568: LD_INT 2
22570: ARRAY
22571: ST_TO_ADDR
// end ; if not weapon then
22572: LD_VAR 0 9
22576: NOT
22577: IFFALSE 22581
// continue ;
22579: GO 22209
// ComPlaceWeapon ( tw , weapon ) ;
22581: LD_VAR 0 7
22585: PPUSH
22586: LD_VAR 0 9
22590: PPUSH
22591: CALL_OW 148
// end ;
22595: GO 22209
22597: POP
22598: POP
// end ;
22599: LD_VAR 0 1
22603: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
22604: LD_INT 0
22606: PPUSH
22607: PPUSH
22608: PPUSH
22609: PPUSH
22610: PPUSH
22611: PPUSH
// if not mc_bases then
22612: LD_EXP 56
22616: NOT
22617: IFFALSE 22621
// exit ;
22619: GO 23633
// for i = 1 to mc_bases do
22621: LD_ADDR_VAR 0 2
22625: PUSH
22626: DOUBLE
22627: LD_INT 1
22629: DEC
22630: ST_TO_ADDR
22631: LD_EXP 56
22635: PUSH
22636: FOR_TO
22637: IFFALSE 23631
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
22639: LD_EXP 69
22643: PUSH
22644: LD_VAR 0 2
22648: ARRAY
22649: NOT
22650: PUSH
22651: LD_EXP 69
22655: PUSH
22656: LD_VAR 0 2
22660: ARRAY
22661: PUSH
22662: LD_EXP 70
22666: PUSH
22667: LD_VAR 0 2
22671: ARRAY
22672: EQUAL
22673: OR
22674: IFFALSE 22678
// continue ;
22676: GO 22636
// if mc_miners [ i ] then
22678: LD_EXP 70
22682: PUSH
22683: LD_VAR 0 2
22687: ARRAY
22688: IFFALSE 23318
// begin k := 1 ;
22690: LD_ADDR_VAR 0 4
22694: PUSH
22695: LD_INT 1
22697: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
22698: LD_ADDR_VAR 0 3
22702: PUSH
22703: DOUBLE
22704: LD_EXP 70
22708: PUSH
22709: LD_VAR 0 2
22713: ARRAY
22714: INC
22715: ST_TO_ADDR
22716: LD_INT 1
22718: PUSH
22719: FOR_DOWNTO
22720: IFFALSE 23316
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
22722: LD_EXP 70
22726: PUSH
22727: LD_VAR 0 2
22731: ARRAY
22732: PUSH
22733: LD_VAR 0 3
22737: ARRAY
22738: PPUSH
22739: CALL_OW 301
22743: PUSH
22744: LD_EXP 70
22748: PUSH
22749: LD_VAR 0 2
22753: ARRAY
22754: PUSH
22755: LD_VAR 0 3
22759: ARRAY
22760: PPUSH
22761: CALL_OW 257
22765: PUSH
22766: LD_INT 1
22768: NONEQUAL
22769: OR
22770: IFFALSE 22833
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
22772: LD_ADDR_VAR 0 5
22776: PUSH
22777: LD_EXP 70
22781: PUSH
22782: LD_VAR 0 2
22786: ARRAY
22787: PUSH
22788: LD_EXP 70
22792: PUSH
22793: LD_VAR 0 2
22797: ARRAY
22798: PUSH
22799: LD_VAR 0 3
22803: ARRAY
22804: DIFF
22805: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
22806: LD_ADDR_EXP 70
22810: PUSH
22811: LD_EXP 70
22815: PPUSH
22816: LD_VAR 0 2
22820: PPUSH
22821: LD_VAR 0 5
22825: PPUSH
22826: CALL_OW 1
22830: ST_TO_ADDR
// continue ;
22831: GO 22719
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
22833: LD_EXP 70
22837: PUSH
22838: LD_VAR 0 2
22842: ARRAY
22843: PUSH
22844: LD_VAR 0 3
22848: ARRAY
22849: PPUSH
22850: CALL 46955 0 1
22854: PUSH
22855: LD_EXP 70
22859: PUSH
22860: LD_VAR 0 2
22864: ARRAY
22865: PUSH
22866: LD_VAR 0 3
22870: ARRAY
22871: PPUSH
22872: CALL_OW 255
22876: PPUSH
22877: LD_EXP 69
22881: PUSH
22882: LD_VAR 0 2
22886: ARRAY
22887: PUSH
22888: LD_VAR 0 4
22892: ARRAY
22893: PUSH
22894: LD_INT 1
22896: ARRAY
22897: PPUSH
22898: LD_EXP 69
22902: PUSH
22903: LD_VAR 0 2
22907: ARRAY
22908: PUSH
22909: LD_VAR 0 4
22913: ARRAY
22914: PUSH
22915: LD_INT 2
22917: ARRAY
22918: PPUSH
22919: LD_INT 15
22921: PPUSH
22922: CALL 47915 0 4
22926: PUSH
22927: LD_INT 4
22929: ARRAY
22930: PUSH
22931: LD_EXP 70
22935: PUSH
22936: LD_VAR 0 2
22940: ARRAY
22941: PUSH
22942: LD_VAR 0 3
22946: ARRAY
22947: PPUSH
22948: LD_INT 10
22950: PPUSH
22951: CALL 49612 0 2
22955: PUSH
22956: LD_INT 4
22958: ARRAY
22959: OR
22960: AND
22961: IFFALSE 22984
// ComStop ( mc_miners [ i ] [ j ] ) ;
22963: LD_EXP 70
22967: PUSH
22968: LD_VAR 0 2
22972: ARRAY
22973: PUSH
22974: LD_VAR 0 3
22978: ARRAY
22979: PPUSH
22980: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
22984: LD_EXP 70
22988: PUSH
22989: LD_VAR 0 2
22993: ARRAY
22994: PUSH
22995: LD_VAR 0 3
22999: ARRAY
23000: PPUSH
23001: CALL_OW 257
23005: PUSH
23006: LD_INT 1
23008: EQUAL
23009: PUSH
23010: LD_EXP 70
23014: PUSH
23015: LD_VAR 0 2
23019: ARRAY
23020: PUSH
23021: LD_VAR 0 3
23025: ARRAY
23026: PPUSH
23027: CALL_OW 459
23031: NOT
23032: AND
23033: PUSH
23034: LD_EXP 70
23038: PUSH
23039: LD_VAR 0 2
23043: ARRAY
23044: PUSH
23045: LD_VAR 0 3
23049: ARRAY
23050: PPUSH
23051: CALL_OW 255
23055: PPUSH
23056: LD_EXP 69
23060: PUSH
23061: LD_VAR 0 2
23065: ARRAY
23066: PUSH
23067: LD_VAR 0 4
23071: ARRAY
23072: PUSH
23073: LD_INT 1
23075: ARRAY
23076: PPUSH
23077: LD_EXP 69
23081: PUSH
23082: LD_VAR 0 2
23086: ARRAY
23087: PUSH
23088: LD_VAR 0 4
23092: ARRAY
23093: PUSH
23094: LD_INT 2
23096: ARRAY
23097: PPUSH
23098: LD_INT 15
23100: PPUSH
23101: CALL 47915 0 4
23105: PUSH
23106: LD_INT 4
23108: ARRAY
23109: PUSH
23110: LD_INT 0
23112: EQUAL
23113: AND
23114: PUSH
23115: LD_EXP 70
23119: PUSH
23120: LD_VAR 0 2
23124: ARRAY
23125: PUSH
23126: LD_VAR 0 3
23130: ARRAY
23131: PPUSH
23132: CALL_OW 314
23136: NOT
23137: AND
23138: IFFALSE 23314
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
23140: LD_EXP 70
23144: PUSH
23145: LD_VAR 0 2
23149: ARRAY
23150: PUSH
23151: LD_VAR 0 3
23155: ARRAY
23156: PPUSH
23157: CALL_OW 310
23161: IFFALSE 23184
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
23163: LD_EXP 70
23167: PUSH
23168: LD_VAR 0 2
23172: ARRAY
23173: PUSH
23174: LD_VAR 0 3
23178: ARRAY
23179: PPUSH
23180: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
23184: LD_EXP 70
23188: PUSH
23189: LD_VAR 0 2
23193: ARRAY
23194: PUSH
23195: LD_VAR 0 3
23199: ARRAY
23200: PPUSH
23201: CALL_OW 314
23205: NOT
23206: IFFALSE 23274
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
23208: LD_EXP 70
23212: PUSH
23213: LD_VAR 0 2
23217: ARRAY
23218: PUSH
23219: LD_VAR 0 3
23223: ARRAY
23224: PPUSH
23225: LD_EXP 69
23229: PUSH
23230: LD_VAR 0 2
23234: ARRAY
23235: PUSH
23236: LD_VAR 0 4
23240: ARRAY
23241: PUSH
23242: LD_INT 1
23244: ARRAY
23245: PPUSH
23246: LD_EXP 69
23250: PUSH
23251: LD_VAR 0 2
23255: ARRAY
23256: PUSH
23257: LD_VAR 0 4
23261: ARRAY
23262: PUSH
23263: LD_INT 2
23265: ARRAY
23266: PPUSH
23267: LD_INT 0
23269: PPUSH
23270: CALL_OW 193
// k := k + 1 ;
23274: LD_ADDR_VAR 0 4
23278: PUSH
23279: LD_VAR 0 4
23283: PUSH
23284: LD_INT 1
23286: PLUS
23287: ST_TO_ADDR
// if k > mc_mines [ i ] then
23288: LD_VAR 0 4
23292: PUSH
23293: LD_EXP 69
23297: PUSH
23298: LD_VAR 0 2
23302: ARRAY
23303: GREATER
23304: IFFALSE 23314
// k := 1 ;
23306: LD_ADDR_VAR 0 4
23310: PUSH
23311: LD_INT 1
23313: ST_TO_ADDR
// end ; end ;
23314: GO 22719
23316: POP
23317: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
23318: LD_ADDR_VAR 0 5
23322: PUSH
23323: LD_EXP 56
23327: PUSH
23328: LD_VAR 0 2
23332: ARRAY
23333: PPUSH
23334: LD_INT 2
23336: PUSH
23337: LD_INT 30
23339: PUSH
23340: LD_INT 4
23342: PUSH
23343: EMPTY
23344: LIST
23345: LIST
23346: PUSH
23347: LD_INT 30
23349: PUSH
23350: LD_INT 5
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: PUSH
23357: LD_INT 30
23359: PUSH
23360: LD_INT 32
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: PPUSH
23373: CALL_OW 72
23377: ST_TO_ADDR
// if not tmp then
23378: LD_VAR 0 5
23382: NOT
23383: IFFALSE 23387
// continue ;
23385: GO 22636
// list := [ ] ;
23387: LD_ADDR_VAR 0 6
23391: PUSH
23392: EMPTY
23393: ST_TO_ADDR
// for j in tmp do
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: LD_VAR 0 5
23403: PUSH
23404: FOR_IN
23405: IFFALSE 23474
// begin for k in UnitsInside ( j ) do
23407: LD_ADDR_VAR 0 4
23411: PUSH
23412: LD_VAR 0 3
23416: PPUSH
23417: CALL_OW 313
23421: PUSH
23422: FOR_IN
23423: IFFALSE 23470
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
23425: LD_VAR 0 4
23429: PPUSH
23430: CALL_OW 257
23434: PUSH
23435: LD_INT 1
23437: EQUAL
23438: PUSH
23439: LD_VAR 0 4
23443: PPUSH
23444: CALL_OW 459
23448: NOT
23449: AND
23450: IFFALSE 23468
// list := list ^ k ;
23452: LD_ADDR_VAR 0 6
23456: PUSH
23457: LD_VAR 0 6
23461: PUSH
23462: LD_VAR 0 4
23466: ADD
23467: ST_TO_ADDR
23468: GO 23422
23470: POP
23471: POP
// end ;
23472: GO 23404
23474: POP
23475: POP
// list := list diff mc_miners [ i ] ;
23476: LD_ADDR_VAR 0 6
23480: PUSH
23481: LD_VAR 0 6
23485: PUSH
23486: LD_EXP 70
23490: PUSH
23491: LD_VAR 0 2
23495: ARRAY
23496: DIFF
23497: ST_TO_ADDR
// if not list then
23498: LD_VAR 0 6
23502: NOT
23503: IFFALSE 23507
// continue ;
23505: GO 22636
// k := mc_mines [ i ] - mc_miners [ i ] ;
23507: LD_ADDR_VAR 0 4
23511: PUSH
23512: LD_EXP 69
23516: PUSH
23517: LD_VAR 0 2
23521: ARRAY
23522: PUSH
23523: LD_EXP 70
23527: PUSH
23528: LD_VAR 0 2
23532: ARRAY
23533: MINUS
23534: ST_TO_ADDR
// if k > list then
23535: LD_VAR 0 4
23539: PUSH
23540: LD_VAR 0 6
23544: GREATER
23545: IFFALSE 23557
// k := list ;
23547: LD_ADDR_VAR 0 4
23551: PUSH
23552: LD_VAR 0 6
23556: ST_TO_ADDR
// for j = 1 to k do
23557: LD_ADDR_VAR 0 3
23561: PUSH
23562: DOUBLE
23563: LD_INT 1
23565: DEC
23566: ST_TO_ADDR
23567: LD_VAR 0 4
23571: PUSH
23572: FOR_TO
23573: IFFALSE 23627
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
23575: LD_ADDR_EXP 70
23579: PUSH
23580: LD_EXP 70
23584: PPUSH
23585: LD_VAR 0 2
23589: PUSH
23590: LD_EXP 70
23594: PUSH
23595: LD_VAR 0 2
23599: ARRAY
23600: PUSH
23601: LD_INT 1
23603: PLUS
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: PPUSH
23609: LD_VAR 0 6
23613: PUSH
23614: LD_VAR 0 3
23618: ARRAY
23619: PPUSH
23620: CALL 47019 0 3
23624: ST_TO_ADDR
23625: GO 23572
23627: POP
23628: POP
// end ;
23629: GO 22636
23631: POP
23632: POP
// end ;
23633: LD_VAR 0 1
23637: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
23638: LD_INT 0
23640: PPUSH
23641: PPUSH
23642: PPUSH
23643: PPUSH
23644: PPUSH
23645: PPUSH
23646: PPUSH
23647: PPUSH
23648: PPUSH
23649: PPUSH
// if not mc_bases then
23650: LD_EXP 56
23654: NOT
23655: IFFALSE 23659
// exit ;
23657: GO 25409
// for i = 1 to mc_bases do
23659: LD_ADDR_VAR 0 2
23663: PUSH
23664: DOUBLE
23665: LD_INT 1
23667: DEC
23668: ST_TO_ADDR
23669: LD_EXP 56
23673: PUSH
23674: FOR_TO
23675: IFFALSE 25407
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
23677: LD_EXP 56
23681: PUSH
23682: LD_VAR 0 2
23686: ARRAY
23687: NOT
23688: PUSH
23689: LD_EXP 63
23693: PUSH
23694: LD_VAR 0 2
23698: ARRAY
23699: OR
23700: IFFALSE 23704
// continue ;
23702: GO 23674
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
23704: LD_EXP 72
23708: PUSH
23709: LD_VAR 0 2
23713: ARRAY
23714: NOT
23715: PUSH
23716: LD_EXP 73
23720: PUSH
23721: LD_VAR 0 2
23725: ARRAY
23726: AND
23727: IFFALSE 23765
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23729: LD_ADDR_EXP 73
23733: PUSH
23734: LD_EXP 73
23738: PPUSH
23739: LD_VAR 0 2
23743: PPUSH
23744: EMPTY
23745: PPUSH
23746: CALL_OW 1
23750: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
23751: LD_VAR 0 2
23755: PPUSH
23756: LD_INT 107
23758: PPUSH
23759: CALL 14519 0 2
// continue ;
23763: GO 23674
// end ; target := [ ] ;
23765: LD_ADDR_VAR 0 6
23769: PUSH
23770: EMPTY
23771: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
23772: LD_ADDR_VAR 0 3
23776: PUSH
23777: DOUBLE
23778: LD_EXP 72
23782: PUSH
23783: LD_VAR 0 2
23787: ARRAY
23788: INC
23789: ST_TO_ADDR
23790: LD_INT 1
23792: PUSH
23793: FOR_DOWNTO
23794: IFFALSE 24054
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
23796: LD_EXP 72
23800: PUSH
23801: LD_VAR 0 2
23805: ARRAY
23806: PUSH
23807: LD_VAR 0 3
23811: ARRAY
23812: PUSH
23813: LD_INT 2
23815: ARRAY
23816: PPUSH
23817: LD_EXP 72
23821: PUSH
23822: LD_VAR 0 2
23826: ARRAY
23827: PUSH
23828: LD_VAR 0 3
23832: ARRAY
23833: PUSH
23834: LD_INT 3
23836: ARRAY
23837: PPUSH
23838: CALL_OW 488
23842: PUSH
23843: LD_EXP 72
23847: PUSH
23848: LD_VAR 0 2
23852: ARRAY
23853: PUSH
23854: LD_VAR 0 3
23858: ARRAY
23859: PUSH
23860: LD_INT 2
23862: ARRAY
23863: PPUSH
23864: LD_EXP 72
23868: PUSH
23869: LD_VAR 0 2
23873: ARRAY
23874: PUSH
23875: LD_VAR 0 3
23879: ARRAY
23880: PUSH
23881: LD_INT 3
23883: ARRAY
23884: PPUSH
23885: CALL_OW 284
23889: PUSH
23890: LD_INT 0
23892: EQUAL
23893: AND
23894: IFFALSE 23949
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
23896: LD_ADDR_VAR 0 5
23900: PUSH
23901: LD_EXP 72
23905: PUSH
23906: LD_VAR 0 2
23910: ARRAY
23911: PPUSH
23912: LD_VAR 0 3
23916: PPUSH
23917: CALL_OW 3
23921: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
23922: LD_ADDR_EXP 72
23926: PUSH
23927: LD_EXP 72
23931: PPUSH
23932: LD_VAR 0 2
23936: PPUSH
23937: LD_VAR 0 5
23941: PPUSH
23942: CALL_OW 1
23946: ST_TO_ADDR
// continue ;
23947: GO 23793
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
23949: LD_EXP 56
23953: PUSH
23954: LD_VAR 0 2
23958: ARRAY
23959: PUSH
23960: LD_INT 1
23962: ARRAY
23963: PPUSH
23964: CALL_OW 255
23968: PPUSH
23969: LD_EXP 72
23973: PUSH
23974: LD_VAR 0 2
23978: ARRAY
23979: PUSH
23980: LD_VAR 0 3
23984: ARRAY
23985: PUSH
23986: LD_INT 2
23988: ARRAY
23989: PPUSH
23990: LD_EXP 72
23994: PUSH
23995: LD_VAR 0 2
23999: ARRAY
24000: PUSH
24001: LD_VAR 0 3
24005: ARRAY
24006: PUSH
24007: LD_INT 3
24009: ARRAY
24010: PPUSH
24011: LD_INT 30
24013: PPUSH
24014: CALL 47915 0 4
24018: PUSH
24019: LD_INT 4
24021: ARRAY
24022: PUSH
24023: LD_INT 0
24025: EQUAL
24026: IFFALSE 24052
// begin target := mc_crates [ i ] [ j ] ;
24028: LD_ADDR_VAR 0 6
24032: PUSH
24033: LD_EXP 72
24037: PUSH
24038: LD_VAR 0 2
24042: ARRAY
24043: PUSH
24044: LD_VAR 0 3
24048: ARRAY
24049: ST_TO_ADDR
// break ;
24050: GO 24054
// end ; end ;
24052: GO 23793
24054: POP
24055: POP
// if not target then
24056: LD_VAR 0 6
24060: NOT
24061: IFFALSE 24065
// continue ;
24063: GO 23674
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
24065: LD_ADDR_VAR 0 7
24069: PUSH
24070: LD_EXP 75
24074: PUSH
24075: LD_VAR 0 2
24079: ARRAY
24080: PPUSH
24081: LD_INT 2
24083: PUSH
24084: LD_INT 3
24086: PUSH
24087: LD_INT 58
24089: PUSH
24090: EMPTY
24091: LIST
24092: PUSH
24093: EMPTY
24094: LIST
24095: LIST
24096: PUSH
24097: LD_INT 61
24099: PUSH
24100: EMPTY
24101: LIST
24102: PUSH
24103: LD_INT 33
24105: PUSH
24106: LD_INT 5
24108: PUSH
24109: EMPTY
24110: LIST
24111: LIST
24112: PUSH
24113: LD_INT 33
24115: PUSH
24116: LD_INT 3
24118: PUSH
24119: EMPTY
24120: LIST
24121: LIST
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 2
24132: PUSH
24133: LD_INT 34
24135: PUSH
24136: LD_INT 32
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PUSH
24143: LD_INT 34
24145: PUSH
24146: LD_INT 51
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: PUSH
24153: LD_INT 34
24155: PUSH
24156: LD_INT 12
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 72
24177: ST_TO_ADDR
// if not cargo then
24178: LD_VAR 0 7
24182: NOT
24183: IFFALSE 24826
// begin if mc_crates_collector [ i ] < 5 then
24185: LD_EXP 73
24189: PUSH
24190: LD_VAR 0 2
24194: ARRAY
24195: PUSH
24196: LD_INT 5
24198: LESS
24199: IFFALSE 24565
// begin if mc_ape [ i ] then
24201: LD_EXP 85
24205: PUSH
24206: LD_VAR 0 2
24210: ARRAY
24211: IFFALSE 24258
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
24213: LD_ADDR_VAR 0 5
24217: PUSH
24218: LD_EXP 85
24222: PUSH
24223: LD_VAR 0 2
24227: ARRAY
24228: PPUSH
24229: LD_INT 25
24231: PUSH
24232: LD_INT 16
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: PUSH
24239: LD_INT 24
24241: PUSH
24242: LD_INT 750
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PPUSH
24253: CALL_OW 72
24257: ST_TO_ADDR
// if not tmp then
24258: LD_VAR 0 5
24262: NOT
24263: IFFALSE 24310
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
24265: LD_ADDR_VAR 0 5
24269: PUSH
24270: LD_EXP 56
24274: PUSH
24275: LD_VAR 0 2
24279: ARRAY
24280: PPUSH
24281: LD_INT 25
24283: PUSH
24284: LD_INT 2
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: LD_INT 24
24293: PUSH
24294: LD_INT 750
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PPUSH
24305: CALL_OW 72
24309: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
24310: LD_EXP 85
24314: PUSH
24315: LD_VAR 0 2
24319: ARRAY
24320: PUSH
24321: LD_EXP 56
24325: PUSH
24326: LD_VAR 0 2
24330: ARRAY
24331: PPUSH
24332: LD_INT 25
24334: PUSH
24335: LD_INT 2
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: LD_INT 24
24344: PUSH
24345: LD_INT 750
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: PUSH
24352: EMPTY
24353: LIST
24354: LIST
24355: PPUSH
24356: CALL_OW 72
24360: AND
24361: PUSH
24362: LD_VAR 0 5
24366: PUSH
24367: LD_INT 5
24369: LESS
24370: AND
24371: IFFALSE 24453
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
24373: LD_ADDR_VAR 0 3
24377: PUSH
24378: LD_EXP 56
24382: PUSH
24383: LD_VAR 0 2
24387: ARRAY
24388: PPUSH
24389: LD_INT 25
24391: PUSH
24392: LD_INT 2
24394: PUSH
24395: EMPTY
24396: LIST
24397: LIST
24398: PUSH
24399: LD_INT 24
24401: PUSH
24402: LD_INT 750
24404: PUSH
24405: EMPTY
24406: LIST
24407: LIST
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PPUSH
24413: CALL_OW 72
24417: PUSH
24418: FOR_IN
24419: IFFALSE 24451
// begin tmp := tmp union j ;
24421: LD_ADDR_VAR 0 5
24425: PUSH
24426: LD_VAR 0 5
24430: PUSH
24431: LD_VAR 0 3
24435: UNION
24436: ST_TO_ADDR
// if tmp >= 5 then
24437: LD_VAR 0 5
24441: PUSH
24442: LD_INT 5
24444: GREATEREQUAL
24445: IFFALSE 24449
// break ;
24447: GO 24451
// end ;
24449: GO 24418
24451: POP
24452: POP
// end ; if not tmp then
24453: LD_VAR 0 5
24457: NOT
24458: IFFALSE 24462
// continue ;
24460: GO 23674
// for j in tmp do
24462: LD_ADDR_VAR 0 3
24466: PUSH
24467: LD_VAR 0 5
24471: PUSH
24472: FOR_IN
24473: IFFALSE 24563
// if not GetTag ( j ) then
24475: LD_VAR 0 3
24479: PPUSH
24480: CALL_OW 110
24484: NOT
24485: IFFALSE 24561
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
24487: LD_ADDR_EXP 73
24491: PUSH
24492: LD_EXP 73
24496: PPUSH
24497: LD_VAR 0 2
24501: PUSH
24502: LD_EXP 73
24506: PUSH
24507: LD_VAR 0 2
24511: ARRAY
24512: PUSH
24513: LD_INT 1
24515: PLUS
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PPUSH
24521: LD_VAR 0 3
24525: PPUSH
24526: CALL 47019 0 3
24530: ST_TO_ADDR
// SetTag ( j , 107 ) ;
24531: LD_VAR 0 3
24535: PPUSH
24536: LD_INT 107
24538: PPUSH
24539: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
24543: LD_EXP 73
24547: PUSH
24548: LD_VAR 0 2
24552: ARRAY
24553: PUSH
24554: LD_INT 5
24556: GREATEREQUAL
24557: IFFALSE 24561
// break ;
24559: GO 24563
// end ;
24561: GO 24472
24563: POP
24564: POP
// end ; if mc_crates_collector [ i ] and target then
24565: LD_EXP 73
24569: PUSH
24570: LD_VAR 0 2
24574: ARRAY
24575: PUSH
24576: LD_VAR 0 6
24580: AND
24581: IFFALSE 24824
// begin if mc_crates_collector [ i ] < target [ 1 ] then
24583: LD_EXP 73
24587: PUSH
24588: LD_VAR 0 2
24592: ARRAY
24593: PUSH
24594: LD_VAR 0 6
24598: PUSH
24599: LD_INT 1
24601: ARRAY
24602: LESS
24603: IFFALSE 24623
// tmp := mc_crates_collector [ i ] else
24605: LD_ADDR_VAR 0 5
24609: PUSH
24610: LD_EXP 73
24614: PUSH
24615: LD_VAR 0 2
24619: ARRAY
24620: ST_TO_ADDR
24621: GO 24637
// tmp := target [ 1 ] ;
24623: LD_ADDR_VAR 0 5
24627: PUSH
24628: LD_VAR 0 6
24632: PUSH
24633: LD_INT 1
24635: ARRAY
24636: ST_TO_ADDR
// k := 0 ;
24637: LD_ADDR_VAR 0 4
24641: PUSH
24642: LD_INT 0
24644: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
24645: LD_ADDR_VAR 0 3
24649: PUSH
24650: LD_EXP 73
24654: PUSH
24655: LD_VAR 0 2
24659: ARRAY
24660: PUSH
24661: FOR_IN
24662: IFFALSE 24822
// begin k := k + 1 ;
24664: LD_ADDR_VAR 0 4
24668: PUSH
24669: LD_VAR 0 4
24673: PUSH
24674: LD_INT 1
24676: PLUS
24677: ST_TO_ADDR
// if k > tmp then
24678: LD_VAR 0 4
24682: PUSH
24683: LD_VAR 0 5
24687: GREATER
24688: IFFALSE 24692
// break ;
24690: GO 24822
// if not GetClass ( j ) in [ 2 , 16 ] then
24692: LD_VAR 0 3
24696: PPUSH
24697: CALL_OW 257
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: LD_INT 16
24707: PUSH
24708: EMPTY
24709: LIST
24710: LIST
24711: IN
24712: NOT
24713: IFFALSE 24766
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
24715: LD_ADDR_EXP 73
24719: PUSH
24720: LD_EXP 73
24724: PPUSH
24725: LD_VAR 0 2
24729: PPUSH
24730: LD_EXP 73
24734: PUSH
24735: LD_VAR 0 2
24739: ARRAY
24740: PUSH
24741: LD_VAR 0 3
24745: DIFF
24746: PPUSH
24747: CALL_OW 1
24751: ST_TO_ADDR
// SetTag ( j , 0 ) ;
24752: LD_VAR 0 3
24756: PPUSH
24757: LD_INT 0
24759: PPUSH
24760: CALL_OW 109
// continue ;
24764: GO 24661
// end ; if IsInUnit ( j ) then
24766: LD_VAR 0 3
24770: PPUSH
24771: CALL_OW 310
24775: IFFALSE 24786
// ComExitBuilding ( j ) ;
24777: LD_VAR 0 3
24781: PPUSH
24782: CALL_OW 122
// wait ( 3 ) ;
24786: LD_INT 3
24788: PPUSH
24789: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
24793: LD_VAR 0 3
24797: PPUSH
24798: LD_VAR 0 6
24802: PUSH
24803: LD_INT 2
24805: ARRAY
24806: PPUSH
24807: LD_VAR 0 6
24811: PUSH
24812: LD_INT 3
24814: ARRAY
24815: PPUSH
24816: CALL_OW 117
// end ;
24820: GO 24661
24822: POP
24823: POP
// end ; end else
24824: GO 25405
// begin for j in cargo do
24826: LD_ADDR_VAR 0 3
24830: PUSH
24831: LD_VAR 0 7
24835: PUSH
24836: FOR_IN
24837: IFFALSE 25403
// begin if GetTag ( j ) <> 0 then
24839: LD_VAR 0 3
24843: PPUSH
24844: CALL_OW 110
24848: PUSH
24849: LD_INT 0
24851: NONEQUAL
24852: IFFALSE 24856
// continue ;
24854: GO 24836
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
24856: LD_VAR 0 3
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 1000
24868: LESS
24869: PUSH
24870: LD_VAR 0 3
24874: PPUSH
24875: LD_EXP 80
24879: PUSH
24880: LD_VAR 0 2
24884: ARRAY
24885: PPUSH
24886: CALL_OW 308
24890: NOT
24891: AND
24892: IFFALSE 24914
// ComMoveToArea ( j , mc_parking [ i ] ) ;
24894: LD_VAR 0 3
24898: PPUSH
24899: LD_EXP 80
24903: PUSH
24904: LD_VAR 0 2
24908: ARRAY
24909: PPUSH
24910: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
24914: LD_VAR 0 3
24918: PPUSH
24919: CALL_OW 256
24923: PUSH
24924: LD_INT 1000
24926: LESS
24927: PUSH
24928: LD_VAR 0 3
24932: PPUSH
24933: LD_EXP 80
24937: PUSH
24938: LD_VAR 0 2
24942: ARRAY
24943: PPUSH
24944: CALL_OW 308
24948: AND
24949: IFFALSE 24953
// continue ;
24951: GO 24836
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
24953: LD_VAR 0 3
24957: PPUSH
24958: CALL_OW 262
24962: PUSH
24963: LD_INT 2
24965: EQUAL
24966: PUSH
24967: LD_VAR 0 3
24971: PPUSH
24972: CALL_OW 261
24976: PUSH
24977: LD_INT 15
24979: LESS
24980: AND
24981: IFFALSE 24985
// continue ;
24983: GO 24836
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
24985: LD_VAR 0 3
24989: PPUSH
24990: CALL_OW 262
24994: PUSH
24995: LD_INT 1
24997: EQUAL
24998: PUSH
24999: LD_VAR 0 3
25003: PPUSH
25004: CALL_OW 261
25008: PUSH
25009: LD_INT 10
25011: LESS
25012: AND
25013: IFFALSE 25342
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25015: LD_ADDR_VAR 0 8
25019: PUSH
25020: LD_EXP 56
25024: PUSH
25025: LD_VAR 0 2
25029: ARRAY
25030: PPUSH
25031: LD_INT 2
25033: PUSH
25034: LD_INT 30
25036: PUSH
25037: LD_INT 0
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 30
25046: PUSH
25047: LD_INT 1
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: LIST
25058: PPUSH
25059: CALL_OW 72
25063: ST_TO_ADDR
// if not depot then
25064: LD_VAR 0 8
25068: NOT
25069: IFFALSE 25073
// continue ;
25071: GO 24836
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
25073: LD_VAR 0 3
25077: PPUSH
25078: LD_VAR 0 8
25082: PPUSH
25083: LD_VAR 0 3
25087: PPUSH
25088: CALL_OW 74
25092: PPUSH
25093: CALL_OW 296
25097: PUSH
25098: LD_INT 6
25100: LESS
25101: IFFALSE 25117
// SetFuel ( j , 100 ) else
25103: LD_VAR 0 3
25107: PPUSH
25108: LD_INT 100
25110: PPUSH
25111: CALL_OW 240
25115: GO 25342
// if GetFuel ( j ) = 0 then
25117: LD_VAR 0 3
25121: PPUSH
25122: CALL_OW 261
25126: PUSH
25127: LD_INT 0
25129: EQUAL
25130: IFFALSE 25342
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
25132: LD_ADDR_EXP 75
25136: PUSH
25137: LD_EXP 75
25141: PPUSH
25142: LD_VAR 0 2
25146: PPUSH
25147: LD_EXP 75
25151: PUSH
25152: LD_VAR 0 2
25156: ARRAY
25157: PUSH
25158: LD_VAR 0 3
25162: DIFF
25163: PPUSH
25164: CALL_OW 1
25168: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
25169: LD_VAR 0 3
25173: PPUSH
25174: CALL_OW 263
25178: PUSH
25179: LD_INT 1
25181: EQUAL
25182: IFFALSE 25198
// ComExitVehicle ( IsInUnit ( j ) ) ;
25184: LD_VAR 0 3
25188: PPUSH
25189: CALL_OW 310
25193: PPUSH
25194: CALL_OW 121
// if GetControl ( j ) = control_remote then
25198: LD_VAR 0 3
25202: PPUSH
25203: CALL_OW 263
25207: PUSH
25208: LD_INT 2
25210: EQUAL
25211: IFFALSE 25222
// ComUnlink ( j ) ;
25213: LD_VAR 0 3
25217: PPUSH
25218: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
25222: LD_ADDR_VAR 0 9
25226: PUSH
25227: LD_VAR 0 2
25231: PPUSH
25232: LD_INT 3
25234: PPUSH
25235: CALL 34479 0 2
25239: ST_TO_ADDR
// if fac then
25240: LD_VAR 0 9
25244: IFFALSE 25340
// begin for k in fac do
25246: LD_ADDR_VAR 0 4
25250: PUSH
25251: LD_VAR 0 9
25255: PUSH
25256: FOR_IN
25257: IFFALSE 25338
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
25259: LD_ADDR_VAR 0 10
25263: PUSH
25264: LD_VAR 0 9
25268: PPUSH
25269: LD_VAR 0 3
25273: PPUSH
25274: CALL_OW 265
25278: PPUSH
25279: LD_VAR 0 3
25283: PPUSH
25284: CALL_OW 262
25288: PPUSH
25289: LD_VAR 0 3
25293: PPUSH
25294: CALL_OW 263
25298: PPUSH
25299: LD_VAR 0 3
25303: PPUSH
25304: CALL_OW 264
25308: PPUSH
25309: CALL 44551 0 5
25313: ST_TO_ADDR
// if components then
25314: LD_VAR 0 10
25318: IFFALSE 25336
// begin MC_InsertProduceList ( i , components ) ;
25320: LD_VAR 0 2
25324: PPUSH
25325: LD_VAR 0 10
25329: PPUSH
25330: CALL 34024 0 2
// break ;
25334: GO 25338
// end ; end ;
25336: GO 25256
25338: POP
25339: POP
// end ; continue ;
25340: GO 24836
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
25342: LD_VAR 0 3
25346: PPUSH
25347: LD_INT 1
25349: PPUSH
25350: CALL_OW 289
25354: PUSH
25355: LD_INT 100
25357: LESS
25358: PUSH
25359: LD_VAR 0 3
25363: PPUSH
25364: CALL_OW 314
25368: NOT
25369: AND
25370: IFFALSE 25399
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
25372: LD_VAR 0 3
25376: PPUSH
25377: LD_VAR 0 6
25381: PUSH
25382: LD_INT 2
25384: ARRAY
25385: PPUSH
25386: LD_VAR 0 6
25390: PUSH
25391: LD_INT 3
25393: ARRAY
25394: PPUSH
25395: CALL_OW 117
// break ;
25399: GO 25403
// end ;
25401: GO 24836
25403: POP
25404: POP
// end ; end ;
25405: GO 23674
25407: POP
25408: POP
// end ;
25409: LD_VAR 0 1
25413: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
25414: LD_INT 0
25416: PPUSH
25417: PPUSH
25418: PPUSH
25419: PPUSH
// if not mc_bases then
25420: LD_EXP 56
25424: NOT
25425: IFFALSE 25429
// exit ;
25427: GO 25590
// for i = 1 to mc_bases do
25429: LD_ADDR_VAR 0 2
25433: PUSH
25434: DOUBLE
25435: LD_INT 1
25437: DEC
25438: ST_TO_ADDR
25439: LD_EXP 56
25443: PUSH
25444: FOR_TO
25445: IFFALSE 25588
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
25447: LD_ADDR_VAR 0 4
25451: PUSH
25452: LD_EXP 75
25456: PUSH
25457: LD_VAR 0 2
25461: ARRAY
25462: PUSH
25463: LD_EXP 78
25467: PUSH
25468: LD_VAR 0 2
25472: ARRAY
25473: UNION
25474: PPUSH
25475: LD_INT 33
25477: PUSH
25478: LD_INT 2
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PPUSH
25485: CALL_OW 72
25489: ST_TO_ADDR
// if tmp then
25490: LD_VAR 0 4
25494: IFFALSE 25586
// for j in tmp do
25496: LD_ADDR_VAR 0 3
25500: PUSH
25501: LD_VAR 0 4
25505: PUSH
25506: FOR_IN
25507: IFFALSE 25584
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
25509: LD_VAR 0 3
25513: PPUSH
25514: CALL_OW 312
25518: NOT
25519: PUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL_OW 256
25529: PUSH
25530: LD_INT 250
25532: GREATEREQUAL
25533: AND
25534: IFFALSE 25547
// Connect ( j ) else
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 49952 0 1
25545: GO 25582
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
25547: LD_VAR 0 3
25551: PPUSH
25552: CALL_OW 256
25556: PUSH
25557: LD_INT 250
25559: LESS
25560: PUSH
25561: LD_VAR 0 3
25565: PPUSH
25566: CALL_OW 312
25570: AND
25571: IFFALSE 25582
// ComUnlink ( j ) ;
25573: LD_VAR 0 3
25577: PPUSH
25578: CALL_OW 136
25582: GO 25506
25584: POP
25585: POP
// end ;
25586: GO 25444
25588: POP
25589: POP
// end ;
25590: LD_VAR 0 1
25594: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
25595: LD_INT 0
25597: PPUSH
25598: PPUSH
25599: PPUSH
25600: PPUSH
25601: PPUSH
// if not mc_bases then
25602: LD_EXP 56
25606: NOT
25607: IFFALSE 25611
// exit ;
25609: GO 26056
// for i = 1 to mc_bases do
25611: LD_ADDR_VAR 0 2
25615: PUSH
25616: DOUBLE
25617: LD_INT 1
25619: DEC
25620: ST_TO_ADDR
25621: LD_EXP 56
25625: PUSH
25626: FOR_TO
25627: IFFALSE 26054
// begin if not mc_produce [ i ] then
25629: LD_EXP 77
25633: PUSH
25634: LD_VAR 0 2
25638: ARRAY
25639: NOT
25640: IFFALSE 25644
// continue ;
25642: GO 25626
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
25644: LD_ADDR_VAR 0 5
25648: PUSH
25649: LD_EXP 56
25653: PUSH
25654: LD_VAR 0 2
25658: ARRAY
25659: PPUSH
25660: LD_INT 30
25662: PUSH
25663: LD_INT 3
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: PPUSH
25670: CALL_OW 72
25674: ST_TO_ADDR
// if not fac then
25675: LD_VAR 0 5
25679: NOT
25680: IFFALSE 25684
// continue ;
25682: GO 25626
// for j in fac do
25684: LD_ADDR_VAR 0 3
25688: PUSH
25689: LD_VAR 0 5
25693: PUSH
25694: FOR_IN
25695: IFFALSE 26050
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
25697: LD_VAR 0 3
25701: PPUSH
25702: CALL_OW 461
25706: PUSH
25707: LD_INT 2
25709: NONEQUAL
25710: PUSH
25711: LD_VAR 0 3
25715: PPUSH
25716: LD_INT 15
25718: PPUSH
25719: CALL 49612 0 2
25723: PUSH
25724: LD_INT 4
25726: ARRAY
25727: OR
25728: IFFALSE 25732
// continue ;
25730: GO 25694
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
25732: LD_VAR 0 3
25736: PPUSH
25737: LD_EXP 77
25741: PUSH
25742: LD_VAR 0 2
25746: ARRAY
25747: PUSH
25748: LD_INT 1
25750: ARRAY
25751: PUSH
25752: LD_INT 1
25754: ARRAY
25755: PPUSH
25756: LD_EXP 77
25760: PUSH
25761: LD_VAR 0 2
25765: ARRAY
25766: PUSH
25767: LD_INT 1
25769: ARRAY
25770: PUSH
25771: LD_INT 2
25773: ARRAY
25774: PPUSH
25775: LD_EXP 77
25779: PUSH
25780: LD_VAR 0 2
25784: ARRAY
25785: PUSH
25786: LD_INT 1
25788: ARRAY
25789: PUSH
25790: LD_INT 3
25792: ARRAY
25793: PPUSH
25794: LD_EXP 77
25798: PUSH
25799: LD_VAR 0 2
25803: ARRAY
25804: PUSH
25805: LD_INT 1
25807: ARRAY
25808: PUSH
25809: LD_INT 4
25811: ARRAY
25812: PPUSH
25813: CALL_OW 448
25817: PUSH
25818: LD_VAR 0 3
25822: PPUSH
25823: LD_EXP 77
25827: PUSH
25828: LD_VAR 0 2
25832: ARRAY
25833: PUSH
25834: LD_INT 1
25836: ARRAY
25837: PUSH
25838: LD_INT 1
25840: ARRAY
25841: PUSH
25842: LD_EXP 77
25846: PUSH
25847: LD_VAR 0 2
25851: ARRAY
25852: PUSH
25853: LD_INT 1
25855: ARRAY
25856: PUSH
25857: LD_INT 2
25859: ARRAY
25860: PUSH
25861: LD_EXP 77
25865: PUSH
25866: LD_VAR 0 2
25870: ARRAY
25871: PUSH
25872: LD_INT 1
25874: ARRAY
25875: PUSH
25876: LD_INT 3
25878: ARRAY
25879: PUSH
25880: LD_EXP 77
25884: PUSH
25885: LD_VAR 0 2
25889: ARRAY
25890: PUSH
25891: LD_INT 1
25893: ARRAY
25894: PUSH
25895: LD_INT 4
25897: ARRAY
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: PPUSH
25905: CALL 53283 0 2
25909: AND
25910: IFFALSE 26048
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
25912: LD_VAR 0 3
25916: PPUSH
25917: LD_EXP 77
25921: PUSH
25922: LD_VAR 0 2
25926: ARRAY
25927: PUSH
25928: LD_INT 1
25930: ARRAY
25931: PUSH
25932: LD_INT 1
25934: ARRAY
25935: PPUSH
25936: LD_EXP 77
25940: PUSH
25941: LD_VAR 0 2
25945: ARRAY
25946: PUSH
25947: LD_INT 1
25949: ARRAY
25950: PUSH
25951: LD_INT 2
25953: ARRAY
25954: PPUSH
25955: LD_EXP 77
25959: PUSH
25960: LD_VAR 0 2
25964: ARRAY
25965: PUSH
25966: LD_INT 1
25968: ARRAY
25969: PUSH
25970: LD_INT 3
25972: ARRAY
25973: PPUSH
25974: LD_EXP 77
25978: PUSH
25979: LD_VAR 0 2
25983: ARRAY
25984: PUSH
25985: LD_INT 1
25987: ARRAY
25988: PUSH
25989: LD_INT 4
25991: ARRAY
25992: PPUSH
25993: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
25997: LD_ADDR_VAR 0 4
26001: PUSH
26002: LD_EXP 77
26006: PUSH
26007: LD_VAR 0 2
26011: ARRAY
26012: PPUSH
26013: LD_INT 1
26015: PPUSH
26016: CALL_OW 3
26020: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
26021: LD_ADDR_EXP 77
26025: PUSH
26026: LD_EXP 77
26030: PPUSH
26031: LD_VAR 0 2
26035: PPUSH
26036: LD_VAR 0 4
26040: PPUSH
26041: CALL_OW 1
26045: ST_TO_ADDR
// break ;
26046: GO 26050
// end ; end ;
26048: GO 25694
26050: POP
26051: POP
// end ;
26052: GO 25626
26054: POP
26055: POP
// end ;
26056: LD_VAR 0 1
26060: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
26061: LD_INT 0
26063: PPUSH
26064: PPUSH
26065: PPUSH
// if not mc_bases then
26066: LD_EXP 56
26070: NOT
26071: IFFALSE 26075
// exit ;
26073: GO 26164
// for i = 1 to mc_bases do
26075: LD_ADDR_VAR 0 2
26079: PUSH
26080: DOUBLE
26081: LD_INT 1
26083: DEC
26084: ST_TO_ADDR
26085: LD_EXP 56
26089: PUSH
26090: FOR_TO
26091: IFFALSE 26162
// begin if mc_attack [ i ] then
26093: LD_EXP 76
26097: PUSH
26098: LD_VAR 0 2
26102: ARRAY
26103: IFFALSE 26160
// begin tmp := mc_attack [ i ] [ 1 ] ;
26105: LD_ADDR_VAR 0 3
26109: PUSH
26110: LD_EXP 76
26114: PUSH
26115: LD_VAR 0 2
26119: ARRAY
26120: PUSH
26121: LD_INT 1
26123: ARRAY
26124: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
26125: LD_ADDR_EXP 76
26129: PUSH
26130: LD_EXP 76
26134: PPUSH
26135: LD_VAR 0 2
26139: PPUSH
26140: EMPTY
26141: PPUSH
26142: CALL_OW 1
26146: ST_TO_ADDR
// Attack ( tmp ) ;
26147: LD_VAR 0 3
26151: PPUSH
26152: CALL 75496 0 1
// exit ;
26156: POP
26157: POP
26158: GO 26164
// end ; end ;
26160: GO 26090
26162: POP
26163: POP
// end ;
26164: LD_VAR 0 1
26168: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
26169: LD_INT 0
26171: PPUSH
26172: PPUSH
26173: PPUSH
26174: PPUSH
26175: PPUSH
26176: PPUSH
26177: PPUSH
// if not mc_bases then
26178: LD_EXP 56
26182: NOT
26183: IFFALSE 26187
// exit ;
26185: GO 26769
// for i = 1 to mc_bases do
26187: LD_ADDR_VAR 0 2
26191: PUSH
26192: DOUBLE
26193: LD_INT 1
26195: DEC
26196: ST_TO_ADDR
26197: LD_EXP 56
26201: PUSH
26202: FOR_TO
26203: IFFALSE 26767
// begin if not mc_bases [ i ] then
26205: LD_EXP 56
26209: PUSH
26210: LD_VAR 0 2
26214: ARRAY
26215: NOT
26216: IFFALSE 26220
// continue ;
26218: GO 26202
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
26220: LD_ADDR_VAR 0 7
26224: PUSH
26225: LD_EXP 56
26229: PUSH
26230: LD_VAR 0 2
26234: ARRAY
26235: PUSH
26236: LD_INT 1
26238: ARRAY
26239: PPUSH
26240: CALL 43855 0 1
26244: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
26245: LD_ADDR_EXP 79
26249: PUSH
26250: LD_EXP 79
26254: PPUSH
26255: LD_VAR 0 2
26259: PPUSH
26260: LD_EXP 56
26264: PUSH
26265: LD_VAR 0 2
26269: ARRAY
26270: PUSH
26271: LD_INT 1
26273: ARRAY
26274: PPUSH
26275: CALL_OW 255
26279: PPUSH
26280: LD_EXP 81
26284: PUSH
26285: LD_VAR 0 2
26289: ARRAY
26290: PPUSH
26291: CALL 41773 0 2
26295: PPUSH
26296: CALL_OW 1
26300: ST_TO_ADDR
// if not mc_scan [ i ] then
26301: LD_EXP 79
26305: PUSH
26306: LD_VAR 0 2
26310: ARRAY
26311: NOT
26312: IFFALSE 26467
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26314: LD_ADDR_VAR 0 4
26318: PUSH
26319: LD_EXP 56
26323: PUSH
26324: LD_VAR 0 2
26328: ARRAY
26329: PPUSH
26330: LD_INT 2
26332: PUSH
26333: LD_INT 25
26335: PUSH
26336: LD_INT 5
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 25
26345: PUSH
26346: LD_INT 8
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 25
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: PPUSH
26369: CALL_OW 72
26373: ST_TO_ADDR
// if not tmp then
26374: LD_VAR 0 4
26378: NOT
26379: IFFALSE 26383
// continue ;
26381: GO 26202
// for j in tmp do
26383: LD_ADDR_VAR 0 3
26387: PUSH
26388: LD_VAR 0 4
26392: PUSH
26393: FOR_IN
26394: IFFALSE 26465
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
26396: LD_VAR 0 3
26400: PPUSH
26401: CALL_OW 310
26405: PPUSH
26406: CALL_OW 266
26410: PUSH
26411: LD_INT 5
26413: EQUAL
26414: PUSH
26415: LD_VAR 0 3
26419: PPUSH
26420: CALL_OW 257
26424: PUSH
26425: LD_INT 1
26427: EQUAL
26428: AND
26429: PUSH
26430: LD_VAR 0 3
26434: PPUSH
26435: CALL_OW 459
26439: NOT
26440: AND
26441: PUSH
26442: LD_VAR 0 7
26446: AND
26447: IFFALSE 26463
// ComChangeProfession ( j , class ) ;
26449: LD_VAR 0 3
26453: PPUSH
26454: LD_VAR 0 7
26458: PPUSH
26459: CALL_OW 123
26463: GO 26393
26465: POP
26466: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
26467: LD_EXP 79
26471: PUSH
26472: LD_VAR 0 2
26476: ARRAY
26477: PUSH
26478: LD_EXP 78
26482: PUSH
26483: LD_VAR 0 2
26487: ARRAY
26488: NOT
26489: AND
26490: PUSH
26491: LD_EXP 56
26495: PUSH
26496: LD_VAR 0 2
26500: ARRAY
26501: PPUSH
26502: LD_INT 30
26504: PUSH
26505: LD_INT 32
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PPUSH
26512: CALL_OW 72
26516: NOT
26517: AND
26518: PUSH
26519: LD_EXP 56
26523: PUSH
26524: LD_VAR 0 2
26528: ARRAY
26529: PPUSH
26530: LD_INT 2
26532: PUSH
26533: LD_INT 30
26535: PUSH
26536: LD_INT 4
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 30
26545: PUSH
26546: LD_INT 5
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: LIST
26557: PPUSH
26558: CALL_OW 72
26562: NOT
26563: AND
26564: IFFALSE 26696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26566: LD_ADDR_VAR 0 4
26570: PUSH
26571: LD_EXP 56
26575: PUSH
26576: LD_VAR 0 2
26580: ARRAY
26581: PPUSH
26582: LD_INT 2
26584: PUSH
26585: LD_INT 25
26587: PUSH
26588: LD_INT 1
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 25
26597: PUSH
26598: LD_INT 5
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 25
26607: PUSH
26608: LD_INT 8
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 25
26617: PUSH
26618: LD_INT 9
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: PPUSH
26632: CALL_OW 72
26636: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
26637: LD_ADDR_VAR 0 4
26641: PUSH
26642: LD_VAR 0 4
26646: PUSH
26647: LD_VAR 0 4
26651: PPUSH
26652: LD_INT 18
26654: PPUSH
26655: CALL 80279 0 2
26659: DIFF
26660: ST_TO_ADDR
// if tmp then
26661: LD_VAR 0 4
26665: IFFALSE 26696
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
26667: LD_VAR 0 2
26671: PPUSH
26672: LD_VAR 0 4
26676: PPUSH
26677: LD_EXP 81
26681: PUSH
26682: LD_VAR 0 2
26686: ARRAY
26687: PPUSH
26688: CALL 41808 0 3
// exit ;
26692: POP
26693: POP
26694: GO 26769
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
26696: LD_EXP 79
26700: PUSH
26701: LD_VAR 0 2
26705: ARRAY
26706: PUSH
26707: LD_EXP 78
26711: PUSH
26712: LD_VAR 0 2
26716: ARRAY
26717: AND
26718: IFFALSE 26765
// begin tmp := mc_defender [ i ] ;
26720: LD_ADDR_VAR 0 4
26724: PUSH
26725: LD_EXP 78
26729: PUSH
26730: LD_VAR 0 2
26734: ARRAY
26735: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
26736: LD_VAR 0 2
26740: PPUSH
26741: LD_VAR 0 4
26745: PPUSH
26746: LD_EXP 79
26750: PUSH
26751: LD_VAR 0 2
26755: ARRAY
26756: PPUSH
26757: CALL 42306 0 3
// exit ;
26761: POP
26762: POP
26763: GO 26769
// end ; end ;
26765: GO 26202
26767: POP
26768: POP
// end ;
26769: LD_VAR 0 1
26773: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
26774: LD_INT 0
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
26780: PPUSH
26781: PPUSH
26782: PPUSH
26783: PPUSH
26784: PPUSH
26785: PPUSH
26786: PPUSH
// if not mc_bases then
26787: LD_EXP 56
26791: NOT
26792: IFFALSE 26796
// exit ;
26794: GO 27883
// for i = 1 to mc_bases do
26796: LD_ADDR_VAR 0 2
26800: PUSH
26801: DOUBLE
26802: LD_INT 1
26804: DEC
26805: ST_TO_ADDR
26806: LD_EXP 56
26810: PUSH
26811: FOR_TO
26812: IFFALSE 27881
// begin tmp := mc_lab [ i ] ;
26814: LD_ADDR_VAR 0 6
26818: PUSH
26819: LD_EXP 89
26823: PUSH
26824: LD_VAR 0 2
26828: ARRAY
26829: ST_TO_ADDR
// if not tmp then
26830: LD_VAR 0 6
26834: NOT
26835: IFFALSE 26839
// continue ;
26837: GO 26811
// idle_lab := 0 ;
26839: LD_ADDR_VAR 0 11
26843: PUSH
26844: LD_INT 0
26846: ST_TO_ADDR
// for j in tmp do
26847: LD_ADDR_VAR 0 3
26851: PUSH
26852: LD_VAR 0 6
26856: PUSH
26857: FOR_IN
26858: IFFALSE 27877
// begin researching := false ;
26860: LD_ADDR_VAR 0 10
26864: PUSH
26865: LD_INT 0
26867: ST_TO_ADDR
// side := GetSide ( j ) ;
26868: LD_ADDR_VAR 0 4
26872: PUSH
26873: LD_VAR 0 3
26877: PPUSH
26878: CALL_OW 255
26882: ST_TO_ADDR
// if not mc_tech [ side ] then
26883: LD_EXP 83
26887: PUSH
26888: LD_VAR 0 4
26892: ARRAY
26893: NOT
26894: IFFALSE 26898
// continue ;
26896: GO 26857
// if BuildingStatus ( j ) = bs_idle then
26898: LD_VAR 0 3
26902: PPUSH
26903: CALL_OW 461
26907: PUSH
26908: LD_INT 2
26910: EQUAL
26911: IFFALSE 27099
// begin if idle_lab and UnitsInside ( j ) < 6 then
26913: LD_VAR 0 11
26917: PUSH
26918: LD_VAR 0 3
26922: PPUSH
26923: CALL_OW 313
26927: PUSH
26928: LD_INT 6
26930: LESS
26931: AND
26932: IFFALSE 27003
// begin tmp2 := UnitsInside ( idle_lab ) ;
26934: LD_ADDR_VAR 0 9
26938: PUSH
26939: LD_VAR 0 11
26943: PPUSH
26944: CALL_OW 313
26948: ST_TO_ADDR
// if tmp2 then
26949: LD_VAR 0 9
26953: IFFALSE 26995
// for x in tmp2 do
26955: LD_ADDR_VAR 0 7
26959: PUSH
26960: LD_VAR 0 9
26964: PUSH
26965: FOR_IN
26966: IFFALSE 26993
// begin ComExitBuilding ( x ) ;
26968: LD_VAR 0 7
26972: PPUSH
26973: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
26977: LD_VAR 0 7
26981: PPUSH
26982: LD_VAR 0 3
26986: PPUSH
26987: CALL_OW 180
// end ;
26991: GO 26965
26993: POP
26994: POP
// idle_lab := 0 ;
26995: LD_ADDR_VAR 0 11
26999: PUSH
27000: LD_INT 0
27002: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
27003: LD_ADDR_VAR 0 5
27007: PUSH
27008: LD_EXP 83
27012: PUSH
27013: LD_VAR 0 4
27017: ARRAY
27018: PUSH
27019: FOR_IN
27020: IFFALSE 27080
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
27022: LD_VAR 0 3
27026: PPUSH
27027: LD_VAR 0 5
27031: PPUSH
27032: CALL_OW 430
27036: PUSH
27037: LD_VAR 0 4
27041: PPUSH
27042: LD_VAR 0 5
27046: PPUSH
27047: CALL 40878 0 2
27051: AND
27052: IFFALSE 27078
// begin researching := true ;
27054: LD_ADDR_VAR 0 10
27058: PUSH
27059: LD_INT 1
27061: ST_TO_ADDR
// ComResearch ( j , t ) ;
27062: LD_VAR 0 3
27066: PPUSH
27067: LD_VAR 0 5
27071: PPUSH
27072: CALL_OW 124
// break ;
27076: GO 27080
// end ;
27078: GO 27019
27080: POP
27081: POP
// if not researching then
27082: LD_VAR 0 10
27086: NOT
27087: IFFALSE 27099
// idle_lab := j ;
27089: LD_ADDR_VAR 0 11
27093: PUSH
27094: LD_VAR 0 3
27098: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
27099: LD_VAR 0 3
27103: PPUSH
27104: CALL_OW 461
27108: PUSH
27109: LD_INT 10
27111: EQUAL
27112: IFFALSE 27700
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
27114: LD_EXP 85
27118: PUSH
27119: LD_VAR 0 2
27123: ARRAY
27124: NOT
27125: PUSH
27126: LD_EXP 86
27130: PUSH
27131: LD_VAR 0 2
27135: ARRAY
27136: NOT
27137: AND
27138: PUSH
27139: LD_EXP 83
27143: PUSH
27144: LD_VAR 0 4
27148: ARRAY
27149: PUSH
27150: LD_INT 1
27152: GREATER
27153: AND
27154: IFFALSE 27285
// begin ComCancel ( j ) ;
27156: LD_VAR 0 3
27160: PPUSH
27161: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
27165: LD_ADDR_EXP 83
27169: PUSH
27170: LD_EXP 83
27174: PPUSH
27175: LD_VAR 0 4
27179: PPUSH
27180: LD_EXP 83
27184: PUSH
27185: LD_VAR 0 4
27189: ARRAY
27190: PPUSH
27191: LD_EXP 83
27195: PUSH
27196: LD_VAR 0 4
27200: ARRAY
27201: PUSH
27202: LD_INT 1
27204: MINUS
27205: PPUSH
27206: LD_EXP 83
27210: PUSH
27211: LD_VAR 0 4
27215: ARRAY
27216: PPUSH
27217: LD_INT 0
27219: PPUSH
27220: CALL 46437 0 4
27224: PPUSH
27225: CALL_OW 1
27229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
27230: LD_ADDR_EXP 83
27234: PUSH
27235: LD_EXP 83
27239: PPUSH
27240: LD_VAR 0 4
27244: PPUSH
27245: LD_EXP 83
27249: PUSH
27250: LD_VAR 0 4
27254: ARRAY
27255: PPUSH
27256: LD_EXP 83
27260: PUSH
27261: LD_VAR 0 4
27265: ARRAY
27266: PPUSH
27267: LD_INT 1
27269: PPUSH
27270: LD_INT 0
27272: PPUSH
27273: CALL 46437 0 4
27277: PPUSH
27278: CALL_OW 1
27282: ST_TO_ADDR
// continue ;
27283: GO 26857
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
27285: LD_EXP 85
27289: PUSH
27290: LD_VAR 0 2
27294: ARRAY
27295: PUSH
27296: LD_EXP 86
27300: PUSH
27301: LD_VAR 0 2
27305: ARRAY
27306: NOT
27307: AND
27308: IFFALSE 27435
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
27310: LD_ADDR_EXP 86
27314: PUSH
27315: LD_EXP 86
27319: PPUSH
27320: LD_VAR 0 2
27324: PUSH
27325: LD_EXP 86
27329: PUSH
27330: LD_VAR 0 2
27334: ARRAY
27335: PUSH
27336: LD_INT 1
27338: PLUS
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PPUSH
27344: LD_EXP 85
27348: PUSH
27349: LD_VAR 0 2
27353: ARRAY
27354: PUSH
27355: LD_INT 1
27357: ARRAY
27358: PPUSH
27359: CALL 47019 0 3
27363: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
27364: LD_EXP 85
27368: PUSH
27369: LD_VAR 0 2
27373: ARRAY
27374: PUSH
27375: LD_INT 1
27377: ARRAY
27378: PPUSH
27379: LD_INT 112
27381: PPUSH
27382: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
27386: LD_ADDR_VAR 0 9
27390: PUSH
27391: LD_EXP 85
27395: PUSH
27396: LD_VAR 0 2
27400: ARRAY
27401: PPUSH
27402: LD_INT 1
27404: PPUSH
27405: CALL_OW 3
27409: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
27410: LD_ADDR_EXP 85
27414: PUSH
27415: LD_EXP 85
27419: PPUSH
27420: LD_VAR 0 2
27424: PPUSH
27425: LD_VAR 0 9
27429: PPUSH
27430: CALL_OW 1
27434: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
27435: LD_EXP 85
27439: PUSH
27440: LD_VAR 0 2
27444: ARRAY
27445: PUSH
27446: LD_EXP 86
27450: PUSH
27451: LD_VAR 0 2
27455: ARRAY
27456: AND
27457: PUSH
27458: LD_EXP 86
27462: PUSH
27463: LD_VAR 0 2
27467: ARRAY
27468: PUSH
27469: LD_INT 1
27471: ARRAY
27472: PPUSH
27473: CALL_OW 310
27477: NOT
27478: AND
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 313
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: AND
27494: IFFALSE 27550
// begin tmp2 := UnitsInside ( j ) ;
27496: LD_ADDR_VAR 0 9
27500: PUSH
27501: LD_VAR 0 3
27505: PPUSH
27506: CALL_OW 313
27510: ST_TO_ADDR
// if tmp2 = 6 then
27511: LD_VAR 0 9
27515: PUSH
27516: LD_INT 6
27518: EQUAL
27519: IFFALSE 27550
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
27521: LD_VAR 0 9
27525: PUSH
27526: LD_INT 1
27528: ARRAY
27529: PPUSH
27530: LD_INT 112
27532: PPUSH
27533: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
27537: LD_VAR 0 9
27541: PUSH
27542: LD_INT 1
27544: ARRAY
27545: PPUSH
27546: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
27550: LD_EXP 86
27554: PUSH
27555: LD_VAR 0 2
27559: ARRAY
27560: PUSH
27561: LD_EXP 86
27565: PUSH
27566: LD_VAR 0 2
27570: ARRAY
27571: PUSH
27572: LD_INT 1
27574: ARRAY
27575: PPUSH
27576: CALL_OW 314
27580: NOT
27581: AND
27582: PUSH
27583: LD_EXP 86
27587: PUSH
27588: LD_VAR 0 2
27592: ARRAY
27593: PUSH
27594: LD_INT 1
27596: ARRAY
27597: PPUSH
27598: CALL_OW 310
27602: NOT
27603: AND
27604: IFFALSE 27630
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
27606: LD_EXP 86
27610: PUSH
27611: LD_VAR 0 2
27615: ARRAY
27616: PUSH
27617: LD_INT 1
27619: ARRAY
27620: PPUSH
27621: LD_VAR 0 3
27625: PPUSH
27626: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
27630: LD_EXP 86
27634: PUSH
27635: LD_VAR 0 2
27639: ARRAY
27640: PUSH
27641: LD_INT 1
27643: ARRAY
27644: PPUSH
27645: CALL_OW 310
27649: PUSH
27650: LD_EXP 86
27654: PUSH
27655: LD_VAR 0 2
27659: ARRAY
27660: PUSH
27661: LD_INT 1
27663: ARRAY
27664: PPUSH
27665: CALL_OW 310
27669: PPUSH
27670: CALL_OW 461
27674: PUSH
27675: LD_INT 3
27677: NONEQUAL
27678: AND
27679: IFFALSE 27700
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
27681: LD_EXP 86
27685: PUSH
27686: LD_VAR 0 2
27690: ARRAY
27691: PUSH
27692: LD_INT 1
27694: ARRAY
27695: PPUSH
27696: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
27700: LD_VAR 0 3
27704: PPUSH
27705: CALL_OW 461
27709: PUSH
27710: LD_INT 6
27712: EQUAL
27713: PUSH
27714: LD_VAR 0 6
27718: PUSH
27719: LD_INT 1
27721: GREATER
27722: AND
27723: IFFALSE 27875
// begin sci := [ ] ;
27725: LD_ADDR_VAR 0 8
27729: PUSH
27730: EMPTY
27731: ST_TO_ADDR
// for x in ( tmp diff j ) do
27732: LD_ADDR_VAR 0 7
27736: PUSH
27737: LD_VAR 0 6
27741: PUSH
27742: LD_VAR 0 3
27746: DIFF
27747: PUSH
27748: FOR_IN
27749: IFFALSE 27801
// begin if sci = 6 then
27751: LD_VAR 0 8
27755: PUSH
27756: LD_INT 6
27758: EQUAL
27759: IFFALSE 27763
// break ;
27761: GO 27801
// if BuildingStatus ( x ) = bs_idle then
27763: LD_VAR 0 7
27767: PPUSH
27768: CALL_OW 461
27772: PUSH
27773: LD_INT 2
27775: EQUAL
27776: IFFALSE 27799
// sci := sci ^ UnitsInside ( x ) ;
27778: LD_ADDR_VAR 0 8
27782: PUSH
27783: LD_VAR 0 8
27787: PUSH
27788: LD_VAR 0 7
27792: PPUSH
27793: CALL_OW 313
27797: ADD
27798: ST_TO_ADDR
// end ;
27799: GO 27748
27801: POP
27802: POP
// if not sci then
27803: LD_VAR 0 8
27807: NOT
27808: IFFALSE 27812
// continue ;
27810: GO 26857
// for x in sci do
27812: LD_ADDR_VAR 0 7
27816: PUSH
27817: LD_VAR 0 8
27821: PUSH
27822: FOR_IN
27823: IFFALSE 27873
// if IsInUnit ( x ) and not HasTask ( x ) then
27825: LD_VAR 0 7
27829: PPUSH
27830: CALL_OW 310
27834: PUSH
27835: LD_VAR 0 7
27839: PPUSH
27840: CALL_OW 314
27844: NOT
27845: AND
27846: IFFALSE 27871
// begin ComExitBuilding ( x ) ;
27848: LD_VAR 0 7
27852: PPUSH
27853: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
27857: LD_VAR 0 7
27861: PPUSH
27862: LD_VAR 0 3
27866: PPUSH
27867: CALL_OW 180
// end ;
27871: GO 27822
27873: POP
27874: POP
// end ; end ;
27875: GO 26857
27877: POP
27878: POP
// end ;
27879: GO 26811
27881: POP
27882: POP
// end ;
27883: LD_VAR 0 1
27887: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
27888: LD_INT 0
27890: PPUSH
27891: PPUSH
// if not mc_bases then
27892: LD_EXP 56
27896: NOT
27897: IFFALSE 27901
// exit ;
27899: GO 27982
// for i = 1 to mc_bases do
27901: LD_ADDR_VAR 0 2
27905: PUSH
27906: DOUBLE
27907: LD_INT 1
27909: DEC
27910: ST_TO_ADDR
27911: LD_EXP 56
27915: PUSH
27916: FOR_TO
27917: IFFALSE 27980
// if mc_mines [ i ] and mc_miners [ i ] then
27919: LD_EXP 69
27923: PUSH
27924: LD_VAR 0 2
27928: ARRAY
27929: PUSH
27930: LD_EXP 70
27934: PUSH
27935: LD_VAR 0 2
27939: ARRAY
27940: AND
27941: IFFALSE 27978
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
27943: LD_EXP 70
27947: PUSH
27948: LD_VAR 0 2
27952: ARRAY
27953: PUSH
27954: LD_INT 1
27956: ARRAY
27957: PPUSH
27958: CALL_OW 255
27962: PPUSH
27963: LD_EXP 69
27967: PUSH
27968: LD_VAR 0 2
27972: ARRAY
27973: PPUSH
27974: CALL 44008 0 2
27978: GO 27916
27980: POP
27981: POP
// end ;
27982: LD_VAR 0 1
27986: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
27987: LD_INT 0
27989: PPUSH
27990: PPUSH
27991: PPUSH
27992: PPUSH
27993: PPUSH
27994: PPUSH
27995: PPUSH
27996: PPUSH
// if not mc_bases or not mc_parking then
27997: LD_EXP 56
28001: NOT
28002: PUSH
28003: LD_EXP 80
28007: NOT
28008: OR
28009: IFFALSE 28013
// exit ;
28011: GO 28712
// for i = 1 to mc_bases do
28013: LD_ADDR_VAR 0 2
28017: PUSH
28018: DOUBLE
28019: LD_INT 1
28021: DEC
28022: ST_TO_ADDR
28023: LD_EXP 56
28027: PUSH
28028: FOR_TO
28029: IFFALSE 28710
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
28031: LD_EXP 56
28035: PUSH
28036: LD_VAR 0 2
28040: ARRAY
28041: NOT
28042: PUSH
28043: LD_EXP 80
28047: PUSH
28048: LD_VAR 0 2
28052: ARRAY
28053: NOT
28054: OR
28055: IFFALSE 28059
// continue ;
28057: GO 28028
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
28059: LD_ADDR_VAR 0 5
28063: PUSH
28064: LD_EXP 56
28068: PUSH
28069: LD_VAR 0 2
28073: ARRAY
28074: PUSH
28075: LD_INT 1
28077: ARRAY
28078: PPUSH
28079: CALL_OW 255
28083: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28084: LD_ADDR_VAR 0 6
28088: PUSH
28089: LD_EXP 56
28093: PUSH
28094: LD_VAR 0 2
28098: ARRAY
28099: PPUSH
28100: LD_INT 30
28102: PUSH
28103: LD_INT 3
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PPUSH
28110: CALL_OW 72
28114: ST_TO_ADDR
// if not fac then
28115: LD_VAR 0 6
28119: NOT
28120: IFFALSE 28171
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28122: LD_ADDR_VAR 0 6
28126: PUSH
28127: LD_EXP 56
28131: PUSH
28132: LD_VAR 0 2
28136: ARRAY
28137: PPUSH
28138: LD_INT 2
28140: PUSH
28141: LD_INT 30
28143: PUSH
28144: LD_INT 0
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 30
28153: PUSH
28154: LD_INT 1
28156: PUSH
28157: EMPTY
28158: LIST
28159: LIST
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: LIST
28165: PPUSH
28166: CALL_OW 72
28170: ST_TO_ADDR
// if not fac then
28171: LD_VAR 0 6
28175: NOT
28176: IFFALSE 28180
// continue ;
28178: GO 28028
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28180: LD_ADDR_VAR 0 7
28184: PUSH
28185: LD_EXP 80
28189: PUSH
28190: LD_VAR 0 2
28194: ARRAY
28195: PPUSH
28196: LD_INT 22
28198: PUSH
28199: LD_VAR 0 5
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 21
28210: PUSH
28211: LD_INT 2
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 3
28220: PUSH
28221: LD_INT 24
28223: PUSH
28224: LD_INT 1000
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PUSH
28235: EMPTY
28236: LIST
28237: LIST
28238: LIST
28239: PPUSH
28240: CALL_OW 70
28244: ST_TO_ADDR
// for j in fac do
28245: LD_ADDR_VAR 0 3
28249: PUSH
28250: LD_VAR 0 6
28254: PUSH
28255: FOR_IN
28256: IFFALSE 28337
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28258: LD_ADDR_VAR 0 7
28262: PUSH
28263: LD_VAR 0 7
28267: PUSH
28268: LD_INT 22
28270: PUSH
28271: LD_VAR 0 5
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 91
28282: PUSH
28283: LD_VAR 0 3
28287: PUSH
28288: LD_INT 15
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 21
28298: PUSH
28299: LD_INT 2
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 24
28311: PUSH
28312: LD_INT 1000
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: LIST
28327: LIST
28328: PPUSH
28329: CALL_OW 69
28333: UNION
28334: ST_TO_ADDR
28335: GO 28255
28337: POP
28338: POP
// if not vehs then
28339: LD_VAR 0 7
28343: NOT
28344: IFFALSE 28370
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
28346: LD_ADDR_EXP 68
28350: PUSH
28351: LD_EXP 68
28355: PPUSH
28356: LD_VAR 0 2
28360: PPUSH
28361: EMPTY
28362: PPUSH
28363: CALL_OW 1
28367: ST_TO_ADDR
// continue ;
28368: GO 28028
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28370: LD_ADDR_VAR 0 8
28374: PUSH
28375: LD_EXP 56
28379: PUSH
28380: LD_VAR 0 2
28384: ARRAY
28385: PPUSH
28386: LD_INT 30
28388: PUSH
28389: LD_INT 3
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PPUSH
28396: CALL_OW 72
28400: ST_TO_ADDR
// if tmp then
28401: LD_VAR 0 8
28405: IFFALSE 28508
// begin for j in tmp do
28407: LD_ADDR_VAR 0 3
28411: PUSH
28412: LD_VAR 0 8
28416: PUSH
28417: FOR_IN
28418: IFFALSE 28506
// for k in UnitsInside ( j ) do
28420: LD_ADDR_VAR 0 4
28424: PUSH
28425: LD_VAR 0 3
28429: PPUSH
28430: CALL_OW 313
28434: PUSH
28435: FOR_IN
28436: IFFALSE 28502
// if k then
28438: LD_VAR 0 4
28442: IFFALSE 28500
// if not k in mc_repair_vehicle [ i ] then
28444: LD_VAR 0 4
28448: PUSH
28449: LD_EXP 68
28453: PUSH
28454: LD_VAR 0 2
28458: ARRAY
28459: IN
28460: NOT
28461: IFFALSE 28500
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
28463: LD_ADDR_EXP 68
28467: PUSH
28468: LD_EXP 68
28472: PPUSH
28473: LD_VAR 0 2
28477: PPUSH
28478: LD_EXP 68
28482: PUSH
28483: LD_VAR 0 2
28487: ARRAY
28488: PUSH
28489: LD_VAR 0 4
28493: UNION
28494: PPUSH
28495: CALL_OW 1
28499: ST_TO_ADDR
28500: GO 28435
28502: POP
28503: POP
28504: GO 28417
28506: POP
28507: POP
// end ; if not mc_repair_vehicle [ i ] then
28508: LD_EXP 68
28512: PUSH
28513: LD_VAR 0 2
28517: ARRAY
28518: NOT
28519: IFFALSE 28523
// continue ;
28521: GO 28028
// for j in mc_repair_vehicle [ i ] do
28523: LD_ADDR_VAR 0 3
28527: PUSH
28528: LD_EXP 68
28532: PUSH
28533: LD_VAR 0 2
28537: ARRAY
28538: PUSH
28539: FOR_IN
28540: IFFALSE 28706
// begin if GetClass ( j ) <> 3 then
28542: LD_VAR 0 3
28546: PPUSH
28547: CALL_OW 257
28551: PUSH
28552: LD_INT 3
28554: NONEQUAL
28555: IFFALSE 28596
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
28557: LD_ADDR_EXP 68
28561: PUSH
28562: LD_EXP 68
28566: PPUSH
28567: LD_VAR 0 2
28571: PPUSH
28572: LD_EXP 68
28576: PUSH
28577: LD_VAR 0 2
28581: ARRAY
28582: PUSH
28583: LD_VAR 0 3
28587: DIFF
28588: PPUSH
28589: CALL_OW 1
28593: ST_TO_ADDR
// continue ;
28594: GO 28539
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
28596: LD_VAR 0 3
28600: PPUSH
28601: CALL_OW 311
28605: NOT
28606: PUSH
28607: LD_VAR 0 3
28611: PUSH
28612: LD_EXP 59
28616: PUSH
28617: LD_VAR 0 2
28621: ARRAY
28622: PUSH
28623: LD_INT 1
28625: ARRAY
28626: IN
28627: NOT
28628: AND
28629: PUSH
28630: LD_VAR 0 3
28634: PUSH
28635: LD_EXP 59
28639: PUSH
28640: LD_VAR 0 2
28644: ARRAY
28645: PUSH
28646: LD_INT 2
28648: ARRAY
28649: IN
28650: NOT
28651: AND
28652: IFFALSE 28704
// begin if IsInUnit ( j ) then
28654: LD_VAR 0 3
28658: PPUSH
28659: CALL_OW 310
28663: IFFALSE 28674
// ComExitBuilding ( j ) ;
28665: LD_VAR 0 3
28669: PPUSH
28670: CALL_OW 122
// if not HasTask ( j ) then
28674: LD_VAR 0 3
28678: PPUSH
28679: CALL_OW 314
28683: NOT
28684: IFFALSE 28704
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
28686: LD_VAR 0 3
28690: PPUSH
28691: LD_VAR 0 7
28695: PUSH
28696: LD_INT 1
28698: ARRAY
28699: PPUSH
28700: CALL_OW 189
// end ; end ;
28704: GO 28539
28706: POP
28707: POP
// end ;
28708: GO 28028
28710: POP
28711: POP
// end ;
28712: LD_VAR 0 1
28716: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
28717: LD_INT 0
28719: PPUSH
28720: PPUSH
28721: PPUSH
28722: PPUSH
28723: PPUSH
28724: PPUSH
28725: PPUSH
28726: PPUSH
28727: PPUSH
28728: PPUSH
28729: PPUSH
// if not mc_bases then
28730: LD_EXP 56
28734: NOT
28735: IFFALSE 28739
// exit ;
28737: GO 29541
// for i = 1 to mc_bases do
28739: LD_ADDR_VAR 0 2
28743: PUSH
28744: DOUBLE
28745: LD_INT 1
28747: DEC
28748: ST_TO_ADDR
28749: LD_EXP 56
28753: PUSH
28754: FOR_TO
28755: IFFALSE 29539
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
28757: LD_EXP 84
28761: PUSH
28762: LD_VAR 0 2
28766: ARRAY
28767: NOT
28768: PUSH
28769: LD_EXP 59
28773: PUSH
28774: LD_VAR 0 2
28778: ARRAY
28779: PUSH
28780: LD_INT 1
28782: ARRAY
28783: OR
28784: PUSH
28785: LD_EXP 59
28789: PUSH
28790: LD_VAR 0 2
28794: ARRAY
28795: PUSH
28796: LD_INT 2
28798: ARRAY
28799: OR
28800: PUSH
28801: LD_EXP 82
28805: PUSH
28806: LD_VAR 0 2
28810: ARRAY
28811: PPUSH
28812: LD_INT 1
28814: PPUSH
28815: CALL_OW 325
28819: NOT
28820: OR
28821: PUSH
28822: LD_EXP 79
28826: PUSH
28827: LD_VAR 0 2
28831: ARRAY
28832: OR
28833: IFFALSE 28837
// continue ;
28835: GO 28754
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
28837: LD_ADDR_VAR 0 8
28841: PUSH
28842: LD_EXP 56
28846: PUSH
28847: LD_VAR 0 2
28851: ARRAY
28852: PPUSH
28853: LD_INT 25
28855: PUSH
28856: LD_INT 4
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 50
28865: PUSH
28866: EMPTY
28867: LIST
28868: PUSH
28869: LD_INT 3
28871: PUSH
28872: LD_INT 60
28874: PUSH
28875: EMPTY
28876: LIST
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: LIST
28886: PPUSH
28887: CALL_OW 72
28891: PUSH
28892: LD_EXP 60
28896: PUSH
28897: LD_VAR 0 2
28901: ARRAY
28902: DIFF
28903: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28904: LD_ADDR_VAR 0 9
28908: PUSH
28909: LD_EXP 56
28913: PUSH
28914: LD_VAR 0 2
28918: ARRAY
28919: PPUSH
28920: LD_INT 2
28922: PUSH
28923: LD_INT 30
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 30
28935: PUSH
28936: LD_INT 1
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: LIST
28947: PPUSH
28948: CALL_OW 72
28952: ST_TO_ADDR
// if not tmp or not dep then
28953: LD_VAR 0 8
28957: NOT
28958: PUSH
28959: LD_VAR 0 9
28963: NOT
28964: OR
28965: IFFALSE 28969
// continue ;
28967: GO 28754
// side := GetSide ( tmp [ 1 ] ) ;
28969: LD_ADDR_VAR 0 11
28973: PUSH
28974: LD_VAR 0 8
28978: PUSH
28979: LD_INT 1
28981: ARRAY
28982: PPUSH
28983: CALL_OW 255
28987: ST_TO_ADDR
// dep := dep [ 1 ] ;
28988: LD_ADDR_VAR 0 9
28992: PUSH
28993: LD_VAR 0 9
28997: PUSH
28998: LD_INT 1
29000: ARRAY
29001: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
29002: LD_ADDR_VAR 0 7
29006: PUSH
29007: LD_EXP 84
29011: PUSH
29012: LD_VAR 0 2
29016: ARRAY
29017: PPUSH
29018: LD_INT 22
29020: PUSH
29021: LD_INT 0
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 25
29030: PUSH
29031: LD_INT 12
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PPUSH
29042: CALL_OW 70
29046: PUSH
29047: LD_INT 22
29049: PUSH
29050: LD_INT 0
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 25
29059: PUSH
29060: LD_INT 12
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: LD_INT 91
29069: PUSH
29070: LD_VAR 0 9
29074: PUSH
29075: LD_INT 20
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: LIST
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: LIST
29087: PPUSH
29088: CALL_OW 69
29092: UNION
29093: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
29094: LD_ADDR_VAR 0 10
29098: PUSH
29099: LD_EXP 84
29103: PUSH
29104: LD_VAR 0 2
29108: ARRAY
29109: PPUSH
29110: LD_INT 81
29112: PUSH
29113: LD_VAR 0 11
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PPUSH
29122: CALL_OW 70
29126: ST_TO_ADDR
// if not apes or danger_at_area then
29127: LD_VAR 0 7
29131: NOT
29132: PUSH
29133: LD_VAR 0 10
29137: OR
29138: IFFALSE 29188
// begin if mc_taming [ i ] then
29140: LD_EXP 87
29144: PUSH
29145: LD_VAR 0 2
29149: ARRAY
29150: IFFALSE 29186
// begin MC_Reset ( i , 121 ) ;
29152: LD_VAR 0 2
29156: PPUSH
29157: LD_INT 121
29159: PPUSH
29160: CALL 14519 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29164: LD_ADDR_EXP 87
29168: PUSH
29169: LD_EXP 87
29173: PPUSH
29174: LD_VAR 0 2
29178: PPUSH
29179: EMPTY
29180: PPUSH
29181: CALL_OW 1
29185: ST_TO_ADDR
// end ; continue ;
29186: GO 28754
// end ; for j in tmp do
29188: LD_ADDR_VAR 0 3
29192: PUSH
29193: LD_VAR 0 8
29197: PUSH
29198: FOR_IN
29199: IFFALSE 29535
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
29201: LD_VAR 0 3
29205: PUSH
29206: LD_EXP 87
29210: PUSH
29211: LD_VAR 0 2
29215: ARRAY
29216: IN
29217: NOT
29218: PUSH
29219: LD_EXP 87
29223: PUSH
29224: LD_VAR 0 2
29228: ARRAY
29229: PUSH
29230: LD_INT 3
29232: LESS
29233: AND
29234: IFFALSE 29292
// begin SetTag ( j , 121 ) ;
29236: LD_VAR 0 3
29240: PPUSH
29241: LD_INT 121
29243: PPUSH
29244: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
29248: LD_ADDR_EXP 87
29252: PUSH
29253: LD_EXP 87
29257: PPUSH
29258: LD_VAR 0 2
29262: PUSH
29263: LD_EXP 87
29267: PUSH
29268: LD_VAR 0 2
29272: ARRAY
29273: PUSH
29274: LD_INT 1
29276: PLUS
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PPUSH
29282: LD_VAR 0 3
29286: PPUSH
29287: CALL 47019 0 3
29291: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
29292: LD_VAR 0 3
29296: PUSH
29297: LD_EXP 87
29301: PUSH
29302: LD_VAR 0 2
29306: ARRAY
29307: IN
29308: IFFALSE 29533
// begin if GetClass ( j ) <> 4 then
29310: LD_VAR 0 3
29314: PPUSH
29315: CALL_OW 257
29319: PUSH
29320: LD_INT 4
29322: NONEQUAL
29323: IFFALSE 29376
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
29325: LD_ADDR_EXP 87
29329: PUSH
29330: LD_EXP 87
29334: PPUSH
29335: LD_VAR 0 2
29339: PPUSH
29340: LD_EXP 87
29344: PUSH
29345: LD_VAR 0 2
29349: ARRAY
29350: PUSH
29351: LD_VAR 0 3
29355: DIFF
29356: PPUSH
29357: CALL_OW 1
29361: ST_TO_ADDR
// SetTag ( j , 0 ) ;
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 0
29369: PPUSH
29370: CALL_OW 109
// continue ;
29374: GO 29198
// end ; if IsInUnit ( j ) then
29376: LD_VAR 0 3
29380: PPUSH
29381: CALL_OW 310
29385: IFFALSE 29396
// ComExitBuilding ( j ) ;
29387: LD_VAR 0 3
29391: PPUSH
29392: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
29396: LD_ADDR_VAR 0 6
29400: PUSH
29401: LD_VAR 0 7
29405: PPUSH
29406: LD_VAR 0 3
29410: PPUSH
29411: CALL_OW 74
29415: ST_TO_ADDR
// if not ape then
29416: LD_VAR 0 6
29420: NOT
29421: IFFALSE 29425
// break ;
29423: GO 29535
// x := GetX ( ape ) ;
29425: LD_ADDR_VAR 0 4
29429: PUSH
29430: LD_VAR 0 6
29434: PPUSH
29435: CALL_OW 250
29439: ST_TO_ADDR
// y := GetY ( ape ) ;
29440: LD_ADDR_VAR 0 5
29444: PUSH
29445: LD_VAR 0 6
29449: PPUSH
29450: CALL_OW 251
29454: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29455: LD_VAR 0 4
29459: PPUSH
29460: LD_VAR 0 5
29464: PPUSH
29465: CALL_OW 488
29469: NOT
29470: PUSH
29471: LD_VAR 0 11
29475: PPUSH
29476: LD_VAR 0 4
29480: PPUSH
29481: LD_VAR 0 5
29485: PPUSH
29486: LD_INT 20
29488: PPUSH
29489: CALL 47915 0 4
29493: PUSH
29494: LD_INT 4
29496: ARRAY
29497: OR
29498: IFFALSE 29502
// break ;
29500: GO 29535
// if not HasTask ( j ) then
29502: LD_VAR 0 3
29506: PPUSH
29507: CALL_OW 314
29511: NOT
29512: IFFALSE 29533
// ComTameXY ( j , x , y ) ;
29514: LD_VAR 0 3
29518: PPUSH
29519: LD_VAR 0 4
29523: PPUSH
29524: LD_VAR 0 5
29528: PPUSH
29529: CALL_OW 131
// end ; end ;
29533: GO 29198
29535: POP
29536: POP
// end ;
29537: GO 28754
29539: POP
29540: POP
// end ;
29541: LD_VAR 0 1
29545: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
29546: LD_INT 0
29548: PPUSH
29549: PPUSH
29550: PPUSH
29551: PPUSH
29552: PPUSH
29553: PPUSH
29554: PPUSH
29555: PPUSH
// if not mc_bases then
29556: LD_EXP 56
29560: NOT
29561: IFFALSE 29565
// exit ;
29563: GO 30191
// for i = 1 to mc_bases do
29565: LD_ADDR_VAR 0 2
29569: PUSH
29570: DOUBLE
29571: LD_INT 1
29573: DEC
29574: ST_TO_ADDR
29575: LD_EXP 56
29579: PUSH
29580: FOR_TO
29581: IFFALSE 30189
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
29583: LD_EXP 85
29587: PUSH
29588: LD_VAR 0 2
29592: ARRAY
29593: NOT
29594: PUSH
29595: LD_EXP 85
29599: PUSH
29600: LD_VAR 0 2
29604: ARRAY
29605: PPUSH
29606: LD_INT 25
29608: PUSH
29609: LD_INT 12
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PPUSH
29616: CALL_OW 72
29620: NOT
29621: OR
29622: IFFALSE 29626
// continue ;
29624: GO 29580
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
29626: LD_ADDR_VAR 0 5
29630: PUSH
29631: LD_EXP 85
29635: PUSH
29636: LD_VAR 0 2
29640: ARRAY
29641: PUSH
29642: LD_INT 1
29644: ARRAY
29645: PPUSH
29646: CALL_OW 255
29650: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
29651: LD_VAR 0 5
29655: PPUSH
29656: LD_INT 2
29658: PPUSH
29659: CALL_OW 325
29663: IFFALSE 29916
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
29665: LD_ADDR_VAR 0 4
29669: PUSH
29670: LD_EXP 85
29674: PUSH
29675: LD_VAR 0 2
29679: ARRAY
29680: PPUSH
29681: LD_INT 25
29683: PUSH
29684: LD_INT 16
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PPUSH
29691: CALL_OW 72
29695: ST_TO_ADDR
// if tmp < 6 then
29696: LD_VAR 0 4
29700: PUSH
29701: LD_INT 6
29703: LESS
29704: IFFALSE 29916
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29706: LD_ADDR_VAR 0 6
29710: PUSH
29711: LD_EXP 56
29715: PUSH
29716: LD_VAR 0 2
29720: ARRAY
29721: PPUSH
29722: LD_INT 2
29724: PUSH
29725: LD_INT 30
29727: PUSH
29728: LD_INT 0
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PUSH
29735: LD_INT 30
29737: PUSH
29738: LD_INT 1
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: LIST
29749: PPUSH
29750: CALL_OW 72
29754: ST_TO_ADDR
// if depot then
29755: LD_VAR 0 6
29759: IFFALSE 29916
// begin selected := 0 ;
29761: LD_ADDR_VAR 0 7
29765: PUSH
29766: LD_INT 0
29768: ST_TO_ADDR
// for j in depot do
29769: LD_ADDR_VAR 0 3
29773: PUSH
29774: LD_VAR 0 6
29778: PUSH
29779: FOR_IN
29780: IFFALSE 29811
// begin if UnitsInside ( j ) < 6 then
29782: LD_VAR 0 3
29786: PPUSH
29787: CALL_OW 313
29791: PUSH
29792: LD_INT 6
29794: LESS
29795: IFFALSE 29809
// begin selected := j ;
29797: LD_ADDR_VAR 0 7
29801: PUSH
29802: LD_VAR 0 3
29806: ST_TO_ADDR
// break ;
29807: GO 29811
// end ; end ;
29809: GO 29779
29811: POP
29812: POP
// if selected then
29813: LD_VAR 0 7
29817: IFFALSE 29916
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
29819: LD_ADDR_VAR 0 3
29823: PUSH
29824: LD_EXP 85
29828: PUSH
29829: LD_VAR 0 2
29833: ARRAY
29834: PPUSH
29835: LD_INT 25
29837: PUSH
29838: LD_INT 12
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PPUSH
29845: CALL_OW 72
29849: PUSH
29850: FOR_IN
29851: IFFALSE 29914
// if not HasTask ( j ) then
29853: LD_VAR 0 3
29857: PPUSH
29858: CALL_OW 314
29862: NOT
29863: IFFALSE 29912
// begin if not IsInUnit ( j ) then
29865: LD_VAR 0 3
29869: PPUSH
29870: CALL_OW 310
29874: NOT
29875: IFFALSE 29891
// ComEnterUnit ( j , selected ) ;
29877: LD_VAR 0 3
29881: PPUSH
29882: LD_VAR 0 7
29886: PPUSH
29887: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
29891: LD_VAR 0 3
29895: PPUSH
29896: LD_INT 16
29898: PPUSH
29899: CALL_OW 183
// AddComExitBuilding ( j ) ;
29903: LD_VAR 0 3
29907: PPUSH
29908: CALL_OW 182
// end ;
29912: GO 29850
29914: POP
29915: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
29916: LD_VAR 0 5
29920: PPUSH
29921: LD_INT 11
29923: PPUSH
29924: CALL_OW 325
29928: IFFALSE 30187
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
29930: LD_ADDR_VAR 0 4
29934: PUSH
29935: LD_EXP 85
29939: PUSH
29940: LD_VAR 0 2
29944: ARRAY
29945: PPUSH
29946: LD_INT 25
29948: PUSH
29949: LD_INT 16
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PPUSH
29956: CALL_OW 72
29960: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
29961: LD_VAR 0 4
29965: PUSH
29966: LD_INT 6
29968: GREATEREQUAL
29969: PUSH
29970: LD_VAR 0 5
29974: PPUSH
29975: LD_INT 2
29977: PPUSH
29978: CALL_OW 325
29982: NOT
29983: OR
29984: IFFALSE 30187
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
29986: LD_ADDR_VAR 0 8
29990: PUSH
29991: LD_EXP 56
29995: PUSH
29996: LD_VAR 0 2
30000: ARRAY
30001: PPUSH
30002: LD_INT 2
30004: PUSH
30005: LD_INT 30
30007: PUSH
30008: LD_INT 4
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 30
30017: PUSH
30018: LD_INT 5
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: LIST
30029: PPUSH
30030: CALL_OW 72
30034: ST_TO_ADDR
// if barracks then
30035: LD_VAR 0 8
30039: IFFALSE 30187
// begin selected := 0 ;
30041: LD_ADDR_VAR 0 7
30045: PUSH
30046: LD_INT 0
30048: ST_TO_ADDR
// for j in barracks do
30049: LD_ADDR_VAR 0 3
30053: PUSH
30054: LD_VAR 0 8
30058: PUSH
30059: FOR_IN
30060: IFFALSE 30091
// begin if UnitsInside ( j ) < 6 then
30062: LD_VAR 0 3
30066: PPUSH
30067: CALL_OW 313
30071: PUSH
30072: LD_INT 6
30074: LESS
30075: IFFALSE 30089
// begin selected := j ;
30077: LD_ADDR_VAR 0 7
30081: PUSH
30082: LD_VAR 0 3
30086: ST_TO_ADDR
// break ;
30087: GO 30091
// end ; end ;
30089: GO 30059
30091: POP
30092: POP
// if selected then
30093: LD_VAR 0 7
30097: IFFALSE 30187
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
30099: LD_ADDR_VAR 0 3
30103: PUSH
30104: LD_EXP 85
30108: PUSH
30109: LD_VAR 0 2
30113: ARRAY
30114: PPUSH
30115: LD_INT 25
30117: PUSH
30118: LD_INT 12
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PPUSH
30125: CALL_OW 72
30129: PUSH
30130: FOR_IN
30131: IFFALSE 30185
// if not IsInUnit ( j ) and not HasTask ( j ) then
30133: LD_VAR 0 3
30137: PPUSH
30138: CALL_OW 310
30142: NOT
30143: PUSH
30144: LD_VAR 0 3
30148: PPUSH
30149: CALL_OW 314
30153: NOT
30154: AND
30155: IFFALSE 30183
// begin ComEnterUnit ( j , selected ) ;
30157: LD_VAR 0 3
30161: PPUSH
30162: LD_VAR 0 7
30166: PPUSH
30167: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
30171: LD_VAR 0 3
30175: PPUSH
30176: LD_INT 15
30178: PPUSH
30179: CALL_OW 183
// end ;
30183: GO 30130
30185: POP
30186: POP
// end ; end ; end ; end ; end ;
30187: GO 29580
30189: POP
30190: POP
// end ;
30191: LD_VAR 0 1
30195: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
30196: LD_INT 0
30198: PPUSH
30199: PPUSH
30200: PPUSH
30201: PPUSH
// if not mc_bases then
30202: LD_EXP 56
30206: NOT
30207: IFFALSE 30211
// exit ;
30209: GO 30389
// for i = 1 to mc_bases do
30211: LD_ADDR_VAR 0 2
30215: PUSH
30216: DOUBLE
30217: LD_INT 1
30219: DEC
30220: ST_TO_ADDR
30221: LD_EXP 56
30225: PUSH
30226: FOR_TO
30227: IFFALSE 30387
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
30229: LD_ADDR_VAR 0 4
30233: PUSH
30234: LD_EXP 56
30238: PUSH
30239: LD_VAR 0 2
30243: ARRAY
30244: PPUSH
30245: LD_INT 25
30247: PUSH
30248: LD_INT 9
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PPUSH
30255: CALL_OW 72
30259: ST_TO_ADDR
// if not tmp then
30260: LD_VAR 0 4
30264: NOT
30265: IFFALSE 30269
// continue ;
30267: GO 30226
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
30269: LD_EXP 82
30273: PUSH
30274: LD_VAR 0 2
30278: ARRAY
30279: PPUSH
30280: LD_INT 29
30282: PPUSH
30283: CALL_OW 325
30287: NOT
30288: PUSH
30289: LD_EXP 82
30293: PUSH
30294: LD_VAR 0 2
30298: ARRAY
30299: PPUSH
30300: LD_INT 28
30302: PPUSH
30303: CALL_OW 325
30307: NOT
30308: AND
30309: IFFALSE 30313
// continue ;
30311: GO 30226
// for j in tmp do
30313: LD_ADDR_VAR 0 3
30317: PUSH
30318: LD_VAR 0 4
30322: PUSH
30323: FOR_IN
30324: IFFALSE 30383
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
30326: LD_VAR 0 3
30330: PUSH
30331: LD_EXP 59
30335: PUSH
30336: LD_VAR 0 2
30340: ARRAY
30341: PUSH
30342: LD_INT 1
30344: ARRAY
30345: IN
30346: NOT
30347: PUSH
30348: LD_VAR 0 3
30352: PUSH
30353: LD_EXP 59
30357: PUSH
30358: LD_VAR 0 2
30362: ARRAY
30363: PUSH
30364: LD_INT 2
30366: ARRAY
30367: IN
30368: NOT
30369: AND
30370: IFFALSE 30381
// ComSpaceTimeShoot ( j ) ;
30372: LD_VAR 0 3
30376: PPUSH
30377: CALL 40969 0 1
30381: GO 30323
30383: POP
30384: POP
// end ;
30385: GO 30226
30387: POP
30388: POP
// end ;
30389: LD_VAR 0 1
30393: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
30394: LD_INT 0
30396: PPUSH
30397: PPUSH
30398: PPUSH
30399: PPUSH
30400: PPUSH
30401: PPUSH
30402: PPUSH
30403: PPUSH
30404: PPUSH
// if not mc_bases then
30405: LD_EXP 56
30409: NOT
30410: IFFALSE 30414
// exit ;
30412: GO 31036
// for i = 1 to mc_bases do
30414: LD_ADDR_VAR 0 2
30418: PUSH
30419: DOUBLE
30420: LD_INT 1
30422: DEC
30423: ST_TO_ADDR
30424: LD_EXP 56
30428: PUSH
30429: FOR_TO
30430: IFFALSE 31034
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
30432: LD_EXP 91
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: NOT
30443: PUSH
30444: LD_INT 38
30446: PPUSH
30447: LD_EXP 82
30451: PUSH
30452: LD_VAR 0 2
30456: ARRAY
30457: PPUSH
30458: CALL_OW 321
30462: PUSH
30463: LD_INT 2
30465: NONEQUAL
30466: OR
30467: IFFALSE 30471
// continue ;
30469: GO 30429
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
30471: LD_ADDR_VAR 0 8
30475: PUSH
30476: LD_EXP 56
30480: PUSH
30481: LD_VAR 0 2
30485: ARRAY
30486: PPUSH
30487: LD_INT 30
30489: PUSH
30490: LD_INT 34
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PPUSH
30497: CALL_OW 72
30501: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
30502: LD_ADDR_VAR 0 9
30506: PUSH
30507: LD_EXP 56
30511: PUSH
30512: LD_VAR 0 2
30516: ARRAY
30517: PPUSH
30518: LD_INT 25
30520: PUSH
30521: LD_INT 4
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PPUSH
30528: CALL_OW 72
30532: PPUSH
30533: LD_INT 0
30535: PPUSH
30536: CALL 80279 0 2
30540: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
30541: LD_VAR 0 9
30545: NOT
30546: PUSH
30547: LD_VAR 0 8
30551: NOT
30552: OR
30553: PUSH
30554: LD_EXP 56
30558: PUSH
30559: LD_VAR 0 2
30563: ARRAY
30564: PPUSH
30565: LD_INT 124
30567: PPUSH
30568: CALL 80279 0 2
30572: OR
30573: IFFALSE 30577
// continue ;
30575: GO 30429
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
30577: LD_EXP 92
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PUSH
30588: LD_EXP 91
30592: PUSH
30593: LD_VAR 0 2
30597: ARRAY
30598: LESS
30599: PUSH
30600: LD_EXP 92
30604: PUSH
30605: LD_VAR 0 2
30609: ARRAY
30610: PUSH
30611: LD_VAR 0 8
30615: LESS
30616: AND
30617: IFFALSE 31032
// begin tmp := sci [ 1 ] ;
30619: LD_ADDR_VAR 0 7
30623: PUSH
30624: LD_VAR 0 9
30628: PUSH
30629: LD_INT 1
30631: ARRAY
30632: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
30633: LD_VAR 0 7
30637: PPUSH
30638: LD_INT 124
30640: PPUSH
30641: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
30645: LD_ADDR_VAR 0 3
30649: PUSH
30650: DOUBLE
30651: LD_EXP 91
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: INC
30662: ST_TO_ADDR
30663: LD_EXP 91
30667: PUSH
30668: LD_VAR 0 2
30672: ARRAY
30673: PUSH
30674: FOR_DOWNTO
30675: IFFALSE 31018
// begin if IsInUnit ( tmp ) then
30677: LD_VAR 0 7
30681: PPUSH
30682: CALL_OW 310
30686: IFFALSE 30697
// ComExitBuilding ( tmp ) ;
30688: LD_VAR 0 7
30692: PPUSH
30693: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
30697: LD_INT 35
30699: PPUSH
30700: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
30704: LD_VAR 0 7
30708: PPUSH
30709: CALL_OW 310
30713: NOT
30714: PUSH
30715: LD_VAR 0 7
30719: PPUSH
30720: CALL_OW 314
30724: NOT
30725: AND
30726: IFFALSE 30697
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
30728: LD_ADDR_VAR 0 6
30732: PUSH
30733: LD_VAR 0 7
30737: PPUSH
30738: CALL_OW 250
30742: PUSH
30743: LD_VAR 0 7
30747: PPUSH
30748: CALL_OW 251
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30757: LD_INT 35
30759: PPUSH
30760: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
30764: LD_ADDR_VAR 0 4
30768: PUSH
30769: LD_EXP 91
30773: PUSH
30774: LD_VAR 0 2
30778: ARRAY
30779: PUSH
30780: LD_VAR 0 3
30784: ARRAY
30785: PUSH
30786: LD_INT 1
30788: ARRAY
30789: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
30790: LD_ADDR_VAR 0 5
30794: PUSH
30795: LD_EXP 91
30799: PUSH
30800: LD_VAR 0 2
30804: ARRAY
30805: PUSH
30806: LD_VAR 0 3
30810: ARRAY
30811: PUSH
30812: LD_INT 2
30814: ARRAY
30815: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
30816: LD_VAR 0 7
30820: PPUSH
30821: LD_INT 10
30823: PPUSH
30824: CALL 49612 0 2
30828: PUSH
30829: LD_INT 4
30831: ARRAY
30832: IFFALSE 30870
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
30834: LD_VAR 0 7
30838: PPUSH
30839: LD_VAR 0 6
30843: PUSH
30844: LD_INT 1
30846: ARRAY
30847: PPUSH
30848: LD_VAR 0 6
30852: PUSH
30853: LD_INT 2
30855: ARRAY
30856: PPUSH
30857: CALL_OW 111
// wait ( 0 0$10 ) ;
30861: LD_INT 350
30863: PPUSH
30864: CALL_OW 67
// end else
30868: GO 30896
// begin ComMoveXY ( tmp , x , y ) ;
30870: LD_VAR 0 7
30874: PPUSH
30875: LD_VAR 0 4
30879: PPUSH
30880: LD_VAR 0 5
30884: PPUSH
30885: CALL_OW 111
// wait ( 0 0$3 ) ;
30889: LD_INT 105
30891: PPUSH
30892: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
30896: LD_VAR 0 7
30900: PPUSH
30901: LD_VAR 0 4
30905: PPUSH
30906: LD_VAR 0 5
30910: PPUSH
30911: CALL_OW 307
30915: IFFALSE 30757
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
30917: LD_VAR 0 7
30921: PPUSH
30922: LD_VAR 0 4
30926: PPUSH
30927: LD_VAR 0 5
30931: PPUSH
30932: LD_VAR 0 8
30936: PUSH
30937: LD_VAR 0 3
30941: ARRAY
30942: PPUSH
30943: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
30947: LD_INT 35
30949: PPUSH
30950: CALL_OW 67
// until not HasTask ( tmp ) ;
30954: LD_VAR 0 7
30958: PPUSH
30959: CALL_OW 314
30963: NOT
30964: IFFALSE 30947
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
30966: LD_ADDR_EXP 92
30970: PUSH
30971: LD_EXP 92
30975: PPUSH
30976: LD_VAR 0 2
30980: PUSH
30981: LD_EXP 92
30985: PUSH
30986: LD_VAR 0 2
30990: ARRAY
30991: PUSH
30992: LD_INT 1
30994: PLUS
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PPUSH
31000: LD_VAR 0 8
31004: PUSH
31005: LD_VAR 0 3
31009: ARRAY
31010: PPUSH
31011: CALL 47019 0 3
31015: ST_TO_ADDR
// end ;
31016: GO 30674
31018: POP
31019: POP
// MC_Reset ( i , 124 ) ;
31020: LD_VAR 0 2
31024: PPUSH
31025: LD_INT 124
31027: PPUSH
31028: CALL 14519 0 2
// end ; end ;
31032: GO 30429
31034: POP
31035: POP
// end ;
31036: LD_VAR 0 1
31040: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
31041: LD_INT 0
31043: PPUSH
31044: PPUSH
31045: PPUSH
// if not mc_bases then
31046: LD_EXP 56
31050: NOT
31051: IFFALSE 31055
// exit ;
31053: GO 31661
// for i = 1 to mc_bases do
31055: LD_ADDR_VAR 0 2
31059: PUSH
31060: DOUBLE
31061: LD_INT 1
31063: DEC
31064: ST_TO_ADDR
31065: LD_EXP 56
31069: PUSH
31070: FOR_TO
31071: IFFALSE 31659
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31073: LD_ADDR_VAR 0 3
31077: PUSH
31078: LD_EXP 56
31082: PUSH
31083: LD_VAR 0 2
31087: ARRAY
31088: PPUSH
31089: LD_INT 25
31091: PUSH
31092: LD_INT 4
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PPUSH
31099: CALL_OW 72
31103: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
31104: LD_VAR 0 3
31108: NOT
31109: PUSH
31110: LD_EXP 93
31114: PUSH
31115: LD_VAR 0 2
31119: ARRAY
31120: NOT
31121: OR
31122: PUSH
31123: LD_EXP 56
31127: PUSH
31128: LD_VAR 0 2
31132: ARRAY
31133: PPUSH
31134: LD_INT 2
31136: PUSH
31137: LD_INT 30
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 30
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: LIST
31161: PPUSH
31162: CALL_OW 72
31166: NOT
31167: OR
31168: IFFALSE 31218
// begin if mc_deposits_finder [ i ] then
31170: LD_EXP 94
31174: PUSH
31175: LD_VAR 0 2
31179: ARRAY
31180: IFFALSE 31216
// begin MC_Reset ( i , 125 ) ;
31182: LD_VAR 0 2
31186: PPUSH
31187: LD_INT 125
31189: PPUSH
31190: CALL 14519 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
31194: LD_ADDR_EXP 94
31198: PUSH
31199: LD_EXP 94
31203: PPUSH
31204: LD_VAR 0 2
31208: PPUSH
31209: EMPTY
31210: PPUSH
31211: CALL_OW 1
31215: ST_TO_ADDR
// end ; continue ;
31216: GO 31070
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
31218: LD_EXP 93
31222: PUSH
31223: LD_VAR 0 2
31227: ARRAY
31228: PUSH
31229: LD_INT 1
31231: ARRAY
31232: PUSH
31233: LD_INT 3
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: EQUAL
31240: PUSH
31241: LD_INT 20
31243: PPUSH
31244: LD_EXP 82
31248: PUSH
31249: LD_VAR 0 2
31253: ARRAY
31254: PPUSH
31255: CALL_OW 321
31259: PUSH
31260: LD_INT 2
31262: NONEQUAL
31263: AND
31264: IFFALSE 31314
// begin if mc_deposits_finder [ i ] then
31266: LD_EXP 94
31270: PUSH
31271: LD_VAR 0 2
31275: ARRAY
31276: IFFALSE 31312
// begin MC_Reset ( i , 125 ) ;
31278: LD_VAR 0 2
31282: PPUSH
31283: LD_INT 125
31285: PPUSH
31286: CALL 14519 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
31290: LD_ADDR_EXP 94
31294: PUSH
31295: LD_EXP 94
31299: PPUSH
31300: LD_VAR 0 2
31304: PPUSH
31305: EMPTY
31306: PPUSH
31307: CALL_OW 1
31311: ST_TO_ADDR
// end ; continue ;
31312: GO 31070
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
31314: LD_EXP 93
31318: PUSH
31319: LD_VAR 0 2
31323: ARRAY
31324: PUSH
31325: LD_INT 1
31327: ARRAY
31328: PUSH
31329: LD_INT 1
31331: ARRAY
31332: PPUSH
31333: LD_EXP 93
31337: PUSH
31338: LD_VAR 0 2
31342: ARRAY
31343: PUSH
31344: LD_INT 1
31346: ARRAY
31347: PUSH
31348: LD_INT 2
31350: ARRAY
31351: PPUSH
31352: LD_EXP 82
31356: PUSH
31357: LD_VAR 0 2
31361: ARRAY
31362: PPUSH
31363: CALL_OW 440
31367: IFFALSE 31410
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
31369: LD_ADDR_EXP 93
31373: PUSH
31374: LD_EXP 93
31378: PPUSH
31379: LD_VAR 0 2
31383: PPUSH
31384: LD_EXP 93
31388: PUSH
31389: LD_VAR 0 2
31393: ARRAY
31394: PPUSH
31395: LD_INT 1
31397: PPUSH
31398: CALL_OW 3
31402: PPUSH
31403: CALL_OW 1
31407: ST_TO_ADDR
31408: GO 31657
// begin if not mc_deposits_finder [ i ] then
31410: LD_EXP 94
31414: PUSH
31415: LD_VAR 0 2
31419: ARRAY
31420: NOT
31421: IFFALSE 31473
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
31423: LD_ADDR_EXP 94
31427: PUSH
31428: LD_EXP 94
31432: PPUSH
31433: LD_VAR 0 2
31437: PPUSH
31438: LD_VAR 0 3
31442: PUSH
31443: LD_INT 1
31445: ARRAY
31446: PUSH
31447: EMPTY
31448: LIST
31449: PPUSH
31450: CALL_OW 1
31454: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
31455: LD_VAR 0 3
31459: PUSH
31460: LD_INT 1
31462: ARRAY
31463: PPUSH
31464: LD_INT 125
31466: PPUSH
31467: CALL_OW 109
// end else
31471: GO 31657
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
31473: LD_EXP 94
31477: PUSH
31478: LD_VAR 0 2
31482: ARRAY
31483: PUSH
31484: LD_INT 1
31486: ARRAY
31487: PPUSH
31488: CALL_OW 310
31492: IFFALSE 31515
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
31494: LD_EXP 94
31498: PUSH
31499: LD_VAR 0 2
31503: ARRAY
31504: PUSH
31505: LD_INT 1
31507: ARRAY
31508: PPUSH
31509: CALL_OW 122
31513: GO 31657
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
31515: LD_EXP 94
31519: PUSH
31520: LD_VAR 0 2
31524: ARRAY
31525: PUSH
31526: LD_INT 1
31528: ARRAY
31529: PPUSH
31530: CALL_OW 314
31534: NOT
31535: PUSH
31536: LD_EXP 94
31540: PUSH
31541: LD_VAR 0 2
31545: ARRAY
31546: PUSH
31547: LD_INT 1
31549: ARRAY
31550: PPUSH
31551: LD_EXP 93
31555: PUSH
31556: LD_VAR 0 2
31560: ARRAY
31561: PUSH
31562: LD_INT 1
31564: ARRAY
31565: PUSH
31566: LD_INT 1
31568: ARRAY
31569: PPUSH
31570: LD_EXP 93
31574: PUSH
31575: LD_VAR 0 2
31579: ARRAY
31580: PUSH
31581: LD_INT 1
31583: ARRAY
31584: PUSH
31585: LD_INT 2
31587: ARRAY
31588: PPUSH
31589: CALL_OW 297
31593: PUSH
31594: LD_INT 6
31596: GREATER
31597: AND
31598: IFFALSE 31657
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
31600: LD_EXP 94
31604: PUSH
31605: LD_VAR 0 2
31609: ARRAY
31610: PUSH
31611: LD_INT 1
31613: ARRAY
31614: PPUSH
31615: LD_EXP 93
31619: PUSH
31620: LD_VAR 0 2
31624: ARRAY
31625: PUSH
31626: LD_INT 1
31628: ARRAY
31629: PUSH
31630: LD_INT 1
31632: ARRAY
31633: PPUSH
31634: LD_EXP 93
31638: PUSH
31639: LD_VAR 0 2
31643: ARRAY
31644: PUSH
31645: LD_INT 1
31647: ARRAY
31648: PUSH
31649: LD_INT 2
31651: ARRAY
31652: PPUSH
31653: CALL_OW 111
// end ; end ; end ;
31657: GO 31070
31659: POP
31660: POP
// end ;
31661: LD_VAR 0 1
31665: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
31666: LD_INT 0
31668: PPUSH
31669: PPUSH
31670: PPUSH
31671: PPUSH
31672: PPUSH
31673: PPUSH
31674: PPUSH
31675: PPUSH
31676: PPUSH
31677: PPUSH
31678: PPUSH
// if not mc_bases then
31679: LD_EXP 56
31683: NOT
31684: IFFALSE 31688
// exit ;
31686: GO 32412
// for i = 1 to mc_bases do
31688: LD_ADDR_VAR 0 2
31692: PUSH
31693: DOUBLE
31694: LD_INT 1
31696: DEC
31697: ST_TO_ADDR
31698: LD_EXP 56
31702: PUSH
31703: FOR_TO
31704: IFFALSE 32410
// begin if not mc_bases [ i ] then
31706: LD_EXP 56
31710: PUSH
31711: LD_VAR 0 2
31715: ARRAY
31716: NOT
31717: IFFALSE 31721
// continue ;
31719: GO 31703
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
31721: LD_ADDR_VAR 0 7
31725: PUSH
31726: LD_EXP 56
31730: PUSH
31731: LD_VAR 0 2
31735: ARRAY
31736: PUSH
31737: LD_INT 1
31739: ARRAY
31740: PPUSH
31741: CALL_OW 248
31745: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
31746: LD_VAR 0 7
31750: PUSH
31751: LD_INT 3
31753: EQUAL
31754: PUSH
31755: LD_EXP 75
31759: PUSH
31760: LD_VAR 0 2
31764: ARRAY
31765: PUSH
31766: LD_EXP 78
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: UNION
31777: PPUSH
31778: LD_INT 33
31780: PUSH
31781: LD_INT 2
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PPUSH
31788: CALL_OW 72
31792: NOT
31793: OR
31794: IFFALSE 31798
// continue ;
31796: GO 31703
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
31798: LD_ADDR_VAR 0 9
31802: PUSH
31803: LD_EXP 56
31807: PUSH
31808: LD_VAR 0 2
31812: ARRAY
31813: PPUSH
31814: LD_INT 30
31816: PUSH
31817: LD_INT 36
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PPUSH
31824: CALL_OW 72
31828: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
31829: LD_ADDR_VAR 0 10
31833: PUSH
31834: LD_EXP 75
31838: PUSH
31839: LD_VAR 0 2
31843: ARRAY
31844: PPUSH
31845: LD_INT 34
31847: PUSH
31848: LD_INT 31
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PPUSH
31855: CALL_OW 72
31859: ST_TO_ADDR
// if not cts and not mcts then
31860: LD_VAR 0 9
31864: NOT
31865: PUSH
31866: LD_VAR 0 10
31870: NOT
31871: AND
31872: IFFALSE 31876
// continue ;
31874: GO 31703
// x := cts ;
31876: LD_ADDR_VAR 0 11
31880: PUSH
31881: LD_VAR 0 9
31885: ST_TO_ADDR
// if not x then
31886: LD_VAR 0 11
31890: NOT
31891: IFFALSE 31903
// x := mcts ;
31893: LD_ADDR_VAR 0 11
31897: PUSH
31898: LD_VAR 0 10
31902: ST_TO_ADDR
// if mc_remote_driver [ i ] then
31903: LD_EXP 96
31907: PUSH
31908: LD_VAR 0 2
31912: ARRAY
31913: IFFALSE 32182
// for j in mc_remote_driver [ i ] do
31915: LD_ADDR_VAR 0 3
31919: PUSH
31920: LD_EXP 96
31924: PUSH
31925: LD_VAR 0 2
31929: ARRAY
31930: PUSH
31931: FOR_IN
31932: IFFALSE 32180
// begin if GetClass ( j ) <> 3 then
31934: LD_VAR 0 3
31938: PPUSH
31939: CALL_OW 257
31943: PUSH
31944: LD_INT 3
31946: NONEQUAL
31947: IFFALSE 32000
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
31949: LD_ADDR_EXP 96
31953: PUSH
31954: LD_EXP 96
31958: PPUSH
31959: LD_VAR 0 2
31963: PPUSH
31964: LD_EXP 96
31968: PUSH
31969: LD_VAR 0 2
31973: ARRAY
31974: PUSH
31975: LD_VAR 0 3
31979: DIFF
31980: PPUSH
31981: CALL_OW 1
31985: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31986: LD_VAR 0 3
31990: PPUSH
31991: LD_INT 0
31993: PPUSH
31994: CALL_OW 109
// continue ;
31998: GO 31931
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
32000: LD_VAR 0 3
32004: PPUSH
32005: CALL_OW 310
32009: NOT
32010: PUSH
32011: LD_VAR 0 3
32015: PPUSH
32016: CALL_OW 310
32020: PPUSH
32021: CALL_OW 266
32025: PUSH
32026: LD_INT 36
32028: NONEQUAL
32029: PUSH
32030: LD_VAR 0 3
32034: PPUSH
32035: CALL 80367 0 1
32039: NOT
32040: AND
32041: OR
32042: IFFALSE 32178
// begin if IsInUnit ( j ) then
32044: LD_VAR 0 3
32048: PPUSH
32049: CALL_OW 310
32053: IFFALSE 32064
// ComExitBuilding ( j ) ;
32055: LD_VAR 0 3
32059: PPUSH
32060: CALL_OW 122
// ct := 0 ;
32064: LD_ADDR_VAR 0 8
32068: PUSH
32069: LD_INT 0
32071: ST_TO_ADDR
// for k in x do
32072: LD_ADDR_VAR 0 4
32076: PUSH
32077: LD_VAR 0 11
32081: PUSH
32082: FOR_IN
32083: IFFALSE 32156
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
32085: LD_VAR 0 4
32089: PPUSH
32090: CALL_OW 264
32094: PUSH
32095: LD_INT 31
32097: EQUAL
32098: PUSH
32099: LD_VAR 0 4
32103: PPUSH
32104: CALL_OW 311
32108: NOT
32109: AND
32110: PUSH
32111: LD_VAR 0 4
32115: PPUSH
32116: CALL_OW 266
32120: PUSH
32121: LD_INT 36
32123: EQUAL
32124: PUSH
32125: LD_VAR 0 4
32129: PPUSH
32130: CALL_OW 313
32134: PUSH
32135: LD_INT 3
32137: LESS
32138: AND
32139: OR
32140: IFFALSE 32154
// begin ct := k ;
32142: LD_ADDR_VAR 0 8
32146: PUSH
32147: LD_VAR 0 4
32151: ST_TO_ADDR
// break ;
32152: GO 32156
// end ;
32154: GO 32082
32156: POP
32157: POP
// if ct then
32158: LD_VAR 0 8
32162: IFFALSE 32178
// ComEnterUnit ( j , ct ) ;
32164: LD_VAR 0 3
32168: PPUSH
32169: LD_VAR 0 8
32173: PPUSH
32174: CALL_OW 120
// end ; end ;
32178: GO 31931
32180: POP
32181: POP
// places := 0 ;
32182: LD_ADDR_VAR 0 5
32186: PUSH
32187: LD_INT 0
32189: ST_TO_ADDR
// for j = 1 to x do
32190: LD_ADDR_VAR 0 3
32194: PUSH
32195: DOUBLE
32196: LD_INT 1
32198: DEC
32199: ST_TO_ADDR
32200: LD_VAR 0 11
32204: PUSH
32205: FOR_TO
32206: IFFALSE 32261
// if GetWeapon ( x [ j ] ) = ar_control_tower then
32208: LD_VAR 0 11
32212: PUSH
32213: LD_VAR 0 3
32217: ARRAY
32218: PPUSH
32219: CALL_OW 264
32223: PUSH
32224: LD_INT 31
32226: EQUAL
32227: IFFALSE 32245
// places := places + 1 else
32229: LD_ADDR_VAR 0 5
32233: PUSH
32234: LD_VAR 0 5
32238: PUSH
32239: LD_INT 1
32241: PLUS
32242: ST_TO_ADDR
32243: GO 32259
// places := places + 3 ;
32245: LD_ADDR_VAR 0 5
32249: PUSH
32250: LD_VAR 0 5
32254: PUSH
32255: LD_INT 3
32257: PLUS
32258: ST_TO_ADDR
32259: GO 32205
32261: POP
32262: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
32263: LD_ADDR_VAR 0 6
32267: PUSH
32268: LD_EXP 56
32272: PUSH
32273: LD_VAR 0 2
32277: ARRAY
32278: PPUSH
32279: LD_INT 25
32281: PUSH
32282: LD_INT 3
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PPUSH
32289: CALL_OW 72
32293: PUSH
32294: LD_EXP 96
32298: PUSH
32299: LD_VAR 0 2
32303: ARRAY
32304: DIFF
32305: PPUSH
32306: LD_INT 3
32308: PPUSH
32309: CALL 81267 0 2
32313: ST_TO_ADDR
// if not tmp then
32314: LD_VAR 0 6
32318: NOT
32319: IFFALSE 32323
// continue ;
32321: GO 31703
// places := places - mc_remote_driver [ i ] ;
32323: LD_ADDR_VAR 0 5
32327: PUSH
32328: LD_VAR 0 5
32332: PUSH
32333: LD_EXP 96
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: MINUS
32344: ST_TO_ADDR
// if places then
32345: LD_VAR 0 5
32349: IFFALSE 32408
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
32351: LD_ADDR_EXP 96
32355: PUSH
32356: LD_EXP 96
32360: PPUSH
32361: LD_VAR 0 2
32365: PPUSH
32366: LD_EXP 96
32370: PUSH
32371: LD_VAR 0 2
32375: ARRAY
32376: PUSH
32377: LD_VAR 0 6
32381: PUSH
32382: LD_INT 1
32384: ARRAY
32385: UNION
32386: PPUSH
32387: CALL_OW 1
32391: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
32392: LD_VAR 0 6
32396: PUSH
32397: LD_INT 1
32399: ARRAY
32400: PPUSH
32401: LD_INT 126
32403: PPUSH
32404: CALL_OW 109
// end ; end ;
32408: GO 31703
32410: POP
32411: POP
// end ;
32412: LD_VAR 0 1
32416: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
32417: LD_INT 0
32419: PPUSH
32420: PPUSH
32421: PPUSH
32422: PPUSH
32423: PPUSH
32424: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
32425: LD_VAR 0 1
32429: NOT
32430: PUSH
32431: LD_VAR 0 2
32435: NOT
32436: OR
32437: PUSH
32438: LD_VAR 0 3
32442: NOT
32443: OR
32444: PUSH
32445: LD_VAR 0 4
32449: PUSH
32450: LD_INT 1
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 3
32458: PUSH
32459: LD_INT 4
32461: PUSH
32462: LD_INT 5
32464: PUSH
32465: LD_INT 8
32467: PUSH
32468: LD_INT 9
32470: PUSH
32471: LD_INT 15
32473: PUSH
32474: LD_INT 16
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: IN
32488: NOT
32489: OR
32490: IFFALSE 32494
// exit ;
32492: GO 33394
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
32494: LD_ADDR_VAR 0 2
32498: PUSH
32499: LD_VAR 0 2
32503: PPUSH
32504: LD_INT 21
32506: PUSH
32507: LD_INT 3
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 24
32516: PUSH
32517: LD_INT 250
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PPUSH
32528: CALL_OW 72
32532: ST_TO_ADDR
// case class of 1 , 15 :
32533: LD_VAR 0 4
32537: PUSH
32538: LD_INT 1
32540: DOUBLE
32541: EQUAL
32542: IFTRUE 32552
32544: LD_INT 15
32546: DOUBLE
32547: EQUAL
32548: IFTRUE 32552
32550: GO 32637
32552: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
32553: LD_ADDR_VAR 0 8
32557: PUSH
32558: LD_VAR 0 2
32562: PPUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 30
32568: PUSH
32569: LD_INT 32
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 30
32578: PUSH
32579: LD_INT 31
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: LIST
32590: PPUSH
32591: CALL_OW 72
32595: PUSH
32596: LD_VAR 0 2
32600: PPUSH
32601: LD_INT 2
32603: PUSH
32604: LD_INT 30
32606: PUSH
32607: LD_INT 4
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 30
32616: PUSH
32617: LD_INT 5
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: LIST
32628: PPUSH
32629: CALL_OW 72
32633: ADD
32634: ST_TO_ADDR
32635: GO 32883
32637: LD_INT 2
32639: DOUBLE
32640: EQUAL
32641: IFTRUE 32651
32643: LD_INT 16
32645: DOUBLE
32646: EQUAL
32647: IFTRUE 32651
32649: GO 32697
32651: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
32652: LD_ADDR_VAR 0 8
32656: PUSH
32657: LD_VAR 0 2
32661: PPUSH
32662: LD_INT 2
32664: PUSH
32665: LD_INT 30
32667: PUSH
32668: LD_INT 0
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 30
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 72
32694: ST_TO_ADDR
32695: GO 32883
32697: LD_INT 3
32699: DOUBLE
32700: EQUAL
32701: IFTRUE 32705
32703: GO 32751
32705: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
32706: LD_ADDR_VAR 0 8
32710: PUSH
32711: LD_VAR 0 2
32715: PPUSH
32716: LD_INT 2
32718: PUSH
32719: LD_INT 30
32721: PUSH
32722: LD_INT 2
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 30
32731: PUSH
32732: LD_INT 3
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: LIST
32743: PPUSH
32744: CALL_OW 72
32748: ST_TO_ADDR
32749: GO 32883
32751: LD_INT 4
32753: DOUBLE
32754: EQUAL
32755: IFTRUE 32759
32757: GO 32816
32759: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
32760: LD_ADDR_VAR 0 8
32764: PUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_INT 2
32772: PUSH
32773: LD_INT 30
32775: PUSH
32776: LD_INT 6
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 30
32785: PUSH
32786: LD_INT 7
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 30
32795: PUSH
32796: LD_INT 8
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: PPUSH
32809: CALL_OW 72
32813: ST_TO_ADDR
32814: GO 32883
32816: LD_INT 5
32818: DOUBLE
32819: EQUAL
32820: IFTRUE 32836
32822: LD_INT 8
32824: DOUBLE
32825: EQUAL
32826: IFTRUE 32836
32828: LD_INT 9
32830: DOUBLE
32831: EQUAL
32832: IFTRUE 32836
32834: GO 32882
32836: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
32837: LD_ADDR_VAR 0 8
32841: PUSH
32842: LD_VAR 0 2
32846: PPUSH
32847: LD_INT 2
32849: PUSH
32850: LD_INT 30
32852: PUSH
32853: LD_INT 4
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 30
32862: PUSH
32863: LD_INT 5
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: LIST
32874: PPUSH
32875: CALL_OW 72
32879: ST_TO_ADDR
32880: GO 32883
32882: POP
// if not tmp then
32883: LD_VAR 0 8
32887: NOT
32888: IFFALSE 32892
// exit ;
32890: GO 33394
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
32892: LD_VAR 0 4
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: LD_INT 15
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: IN
32907: PUSH
32908: LD_EXP 65
32912: PUSH
32913: LD_VAR 0 1
32917: ARRAY
32918: AND
32919: IFFALSE 33075
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
32921: LD_ADDR_VAR 0 9
32925: PUSH
32926: LD_EXP 65
32930: PUSH
32931: LD_VAR 0 1
32935: ARRAY
32936: PUSH
32937: LD_INT 1
32939: ARRAY
32940: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
32941: LD_VAR 0 9
32945: PUSH
32946: LD_EXP 66
32950: PUSH
32951: LD_VAR 0 1
32955: ARRAY
32956: IN
32957: NOT
32958: IFFALSE 33073
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
32960: LD_ADDR_EXP 66
32964: PUSH
32965: LD_EXP 66
32969: PPUSH
32970: LD_VAR 0 1
32974: PUSH
32975: LD_EXP 66
32979: PUSH
32980: LD_VAR 0 1
32984: ARRAY
32985: PUSH
32986: LD_INT 1
32988: PLUS
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PPUSH
32994: LD_VAR 0 9
32998: PPUSH
32999: CALL 47019 0 3
33003: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
33004: LD_ADDR_EXP 65
33008: PUSH
33009: LD_EXP 65
33013: PPUSH
33014: LD_VAR 0 1
33018: PPUSH
33019: LD_EXP 65
33023: PUSH
33024: LD_VAR 0 1
33028: ARRAY
33029: PUSH
33030: LD_VAR 0 9
33034: DIFF
33035: PPUSH
33036: CALL_OW 1
33040: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
33041: LD_VAR 0 3
33045: PPUSH
33046: LD_EXP 66
33050: PUSH
33051: LD_VAR 0 1
33055: ARRAY
33056: PUSH
33057: LD_EXP 66
33061: PUSH
33062: LD_VAR 0 1
33066: ARRAY
33067: ARRAY
33068: PPUSH
33069: CALL_OW 120
// end ; exit ;
33073: GO 33394
// end ; if tmp > 1 then
33075: LD_VAR 0 8
33079: PUSH
33080: LD_INT 1
33082: GREATER
33083: IFFALSE 33187
// for i = 2 to tmp do
33085: LD_ADDR_VAR 0 6
33089: PUSH
33090: DOUBLE
33091: LD_INT 2
33093: DEC
33094: ST_TO_ADDR
33095: LD_VAR 0 8
33099: PUSH
33100: FOR_TO
33101: IFFALSE 33185
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
33103: LD_VAR 0 8
33107: PUSH
33108: LD_VAR 0 6
33112: ARRAY
33113: PPUSH
33114: CALL_OW 461
33118: PUSH
33119: LD_INT 6
33121: EQUAL
33122: IFFALSE 33183
// begin x := tmp [ i ] ;
33124: LD_ADDR_VAR 0 9
33128: PUSH
33129: LD_VAR 0 8
33133: PUSH
33134: LD_VAR 0 6
33138: ARRAY
33139: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
33140: LD_ADDR_VAR 0 8
33144: PUSH
33145: LD_VAR 0 8
33149: PPUSH
33150: LD_VAR 0 6
33154: PPUSH
33155: CALL_OW 3
33159: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
33160: LD_ADDR_VAR 0 8
33164: PUSH
33165: LD_VAR 0 8
33169: PPUSH
33170: LD_INT 1
33172: PPUSH
33173: LD_VAR 0 9
33177: PPUSH
33178: CALL_OW 2
33182: ST_TO_ADDR
// end ;
33183: GO 33100
33185: POP
33186: POP
// for i in tmp do
33187: LD_ADDR_VAR 0 6
33191: PUSH
33192: LD_VAR 0 8
33196: PUSH
33197: FOR_IN
33198: IFFALSE 33267
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
33200: LD_VAR 0 6
33204: PPUSH
33205: CALL_OW 313
33209: PUSH
33210: LD_INT 6
33212: LESS
33213: PUSH
33214: LD_VAR 0 6
33218: PPUSH
33219: CALL_OW 266
33223: PUSH
33224: LD_INT 31
33226: PUSH
33227: LD_INT 32
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: IN
33234: NOT
33235: AND
33236: PUSH
33237: LD_VAR 0 6
33241: PPUSH
33242: CALL_OW 313
33246: PUSH
33247: LD_INT 0
33249: EQUAL
33250: OR
33251: IFFALSE 33265
// begin j := i ;
33253: LD_ADDR_VAR 0 7
33257: PUSH
33258: LD_VAR 0 6
33262: ST_TO_ADDR
// break ;
33263: GO 33267
// end ; end ;
33265: GO 33197
33267: POP
33268: POP
// if j then
33269: LD_VAR 0 7
33273: IFFALSE 33291
// ComEnterUnit ( unit , j ) else
33275: LD_VAR 0 3
33279: PPUSH
33280: LD_VAR 0 7
33284: PPUSH
33285: CALL_OW 120
33289: GO 33394
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33291: LD_ADDR_VAR 0 10
33295: PUSH
33296: LD_VAR 0 2
33300: PPUSH
33301: LD_INT 2
33303: PUSH
33304: LD_INT 30
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 30
33316: PUSH
33317: LD_INT 1
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: LIST
33328: PPUSH
33329: CALL_OW 72
33333: ST_TO_ADDR
// if depot then
33334: LD_VAR 0 10
33338: IFFALSE 33394
// begin depot := NearestUnitToUnit ( depot , unit ) ;
33340: LD_ADDR_VAR 0 10
33344: PUSH
33345: LD_VAR 0 10
33349: PPUSH
33350: LD_VAR 0 3
33354: PPUSH
33355: CALL_OW 74
33359: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
33360: LD_VAR 0 3
33364: PPUSH
33365: LD_VAR 0 10
33369: PPUSH
33370: CALL_OW 296
33374: PUSH
33375: LD_INT 10
33377: GREATER
33378: IFFALSE 33394
// ComStandNearbyBuilding ( unit , depot ) ;
33380: LD_VAR 0 3
33384: PPUSH
33385: LD_VAR 0 10
33389: PPUSH
33390: CALL 41586 0 2
// end ; end ; end ;
33394: LD_VAR 0 5
33398: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
33399: LD_INT 0
33401: PPUSH
33402: PPUSH
33403: PPUSH
33404: PPUSH
// if not mc_bases then
33405: LD_EXP 56
33409: NOT
33410: IFFALSE 33414
// exit ;
33412: GO 33653
// for i = 1 to mc_bases do
33414: LD_ADDR_VAR 0 2
33418: PUSH
33419: DOUBLE
33420: LD_INT 1
33422: DEC
33423: ST_TO_ADDR
33424: LD_EXP 56
33428: PUSH
33429: FOR_TO
33430: IFFALSE 33651
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
33432: LD_ADDR_VAR 0 4
33436: PUSH
33437: LD_EXP 56
33441: PUSH
33442: LD_VAR 0 2
33446: ARRAY
33447: PPUSH
33448: LD_INT 21
33450: PUSH
33451: LD_INT 1
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PPUSH
33458: CALL_OW 72
33462: PUSH
33463: LD_EXP 85
33467: PUSH
33468: LD_VAR 0 2
33472: ARRAY
33473: UNION
33474: ST_TO_ADDR
// if not tmp then
33475: LD_VAR 0 4
33479: NOT
33480: IFFALSE 33484
// continue ;
33482: GO 33429
// for j in tmp do
33484: LD_ADDR_VAR 0 3
33488: PUSH
33489: LD_VAR 0 4
33493: PUSH
33494: FOR_IN
33495: IFFALSE 33647
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
33497: LD_VAR 0 3
33501: PPUSH
33502: CALL_OW 110
33506: NOT
33507: PUSH
33508: LD_VAR 0 3
33512: PPUSH
33513: CALL_OW 314
33517: NOT
33518: AND
33519: PUSH
33520: LD_VAR 0 3
33524: PPUSH
33525: CALL_OW 311
33529: NOT
33530: AND
33531: PUSH
33532: LD_VAR 0 3
33536: PPUSH
33537: CALL_OW 310
33541: NOT
33542: AND
33543: PUSH
33544: LD_VAR 0 3
33548: PUSH
33549: LD_EXP 59
33553: PUSH
33554: LD_VAR 0 2
33558: ARRAY
33559: PUSH
33560: LD_INT 1
33562: ARRAY
33563: IN
33564: NOT
33565: AND
33566: PUSH
33567: LD_VAR 0 3
33571: PUSH
33572: LD_EXP 59
33576: PUSH
33577: LD_VAR 0 2
33581: ARRAY
33582: PUSH
33583: LD_INT 2
33585: ARRAY
33586: IN
33587: NOT
33588: AND
33589: PUSH
33590: LD_VAR 0 3
33594: PUSH
33595: LD_EXP 68
33599: PUSH
33600: LD_VAR 0 2
33604: ARRAY
33605: IN
33606: NOT
33607: AND
33608: IFFALSE 33645
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
33610: LD_VAR 0 2
33614: PPUSH
33615: LD_EXP 56
33619: PUSH
33620: LD_VAR 0 2
33624: ARRAY
33625: PPUSH
33626: LD_VAR 0 3
33630: PPUSH
33631: LD_VAR 0 3
33635: PPUSH
33636: CALL_OW 257
33640: PPUSH
33641: CALL 32417 0 4
// end ;
33645: GO 33494
33647: POP
33648: POP
// end ;
33649: GO 33429
33651: POP
33652: POP
// end ;
33653: LD_VAR 0 1
33657: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
33658: LD_INT 0
33660: PPUSH
33661: PPUSH
33662: PPUSH
33663: PPUSH
33664: PPUSH
33665: PPUSH
// if not mc_bases [ base ] then
33666: LD_EXP 56
33670: PUSH
33671: LD_VAR 0 1
33675: ARRAY
33676: NOT
33677: IFFALSE 33681
// exit ;
33679: GO 33863
// tmp := [ ] ;
33681: LD_ADDR_VAR 0 6
33685: PUSH
33686: EMPTY
33687: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
33688: LD_ADDR_VAR 0 7
33692: PUSH
33693: LD_VAR 0 3
33697: PPUSH
33698: LD_INT 0
33700: PPUSH
33701: CALL_OW 517
33705: ST_TO_ADDR
// if not list then
33706: LD_VAR 0 7
33710: NOT
33711: IFFALSE 33715
// exit ;
33713: GO 33863
// for i = 1 to amount do
33715: LD_ADDR_VAR 0 5
33719: PUSH
33720: DOUBLE
33721: LD_INT 1
33723: DEC
33724: ST_TO_ADDR
33725: LD_VAR 0 2
33729: PUSH
33730: FOR_TO
33731: IFFALSE 33811
// begin x := rand ( 1 , list [ 1 ] ) ;
33733: LD_ADDR_VAR 0 8
33737: PUSH
33738: LD_INT 1
33740: PPUSH
33741: LD_VAR 0 7
33745: PUSH
33746: LD_INT 1
33748: ARRAY
33749: PPUSH
33750: CALL_OW 12
33754: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
33755: LD_ADDR_VAR 0 6
33759: PUSH
33760: LD_VAR 0 6
33764: PPUSH
33765: LD_VAR 0 5
33769: PPUSH
33770: LD_VAR 0 7
33774: PUSH
33775: LD_INT 1
33777: ARRAY
33778: PUSH
33779: LD_VAR 0 8
33783: ARRAY
33784: PUSH
33785: LD_VAR 0 7
33789: PUSH
33790: LD_INT 2
33792: ARRAY
33793: PUSH
33794: LD_VAR 0 8
33798: ARRAY
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PPUSH
33804: CALL_OW 1
33808: ST_TO_ADDR
// end ;
33809: GO 33730
33811: POP
33812: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
33813: LD_ADDR_EXP 69
33817: PUSH
33818: LD_EXP 69
33822: PPUSH
33823: LD_VAR 0 1
33827: PPUSH
33828: LD_VAR 0 6
33832: PPUSH
33833: CALL_OW 1
33837: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
33838: LD_ADDR_EXP 71
33842: PUSH
33843: LD_EXP 71
33847: PPUSH
33848: LD_VAR 0 1
33852: PPUSH
33853: LD_VAR 0 3
33857: PPUSH
33858: CALL_OW 1
33862: ST_TO_ADDR
// end ;
33863: LD_VAR 0 4
33867: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
33868: LD_INT 0
33870: PPUSH
// if not mc_bases [ base ] then
33871: LD_EXP 56
33875: PUSH
33876: LD_VAR 0 1
33880: ARRAY
33881: NOT
33882: IFFALSE 33886
// exit ;
33884: GO 33911
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
33886: LD_ADDR_EXP 61
33890: PUSH
33891: LD_EXP 61
33895: PPUSH
33896: LD_VAR 0 1
33900: PPUSH
33901: LD_VAR 0 2
33905: PPUSH
33906: CALL_OW 1
33910: ST_TO_ADDR
// end ;
33911: LD_VAR 0 3
33915: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
33916: LD_INT 0
33918: PPUSH
// if not mc_bases [ base ] then
33919: LD_EXP 56
33923: PUSH
33924: LD_VAR 0 1
33928: ARRAY
33929: NOT
33930: IFFALSE 33934
// exit ;
33932: GO 33971
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
33934: LD_ADDR_EXP 61
33938: PUSH
33939: LD_EXP 61
33943: PPUSH
33944: LD_VAR 0 1
33948: PPUSH
33949: LD_EXP 61
33953: PUSH
33954: LD_VAR 0 1
33958: ARRAY
33959: PUSH
33960: LD_VAR 0 2
33964: UNION
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// end ;
33971: LD_VAR 0 3
33975: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
33976: LD_INT 0
33978: PPUSH
// if not mc_bases [ base ] then
33979: LD_EXP 56
33983: PUSH
33984: LD_VAR 0 1
33988: ARRAY
33989: NOT
33990: IFFALSE 33994
// exit ;
33992: GO 34019
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
33994: LD_ADDR_EXP 77
33998: PUSH
33999: LD_EXP 77
34003: PPUSH
34004: LD_VAR 0 1
34008: PPUSH
34009: LD_VAR 0 2
34013: PPUSH
34014: CALL_OW 1
34018: ST_TO_ADDR
// end ;
34019: LD_VAR 0 3
34023: RET
// export function MC_InsertProduceList ( base , components ) ; begin
34024: LD_INT 0
34026: PPUSH
// if not mc_bases [ base ] then
34027: LD_EXP 56
34031: PUSH
34032: LD_VAR 0 1
34036: ARRAY
34037: NOT
34038: IFFALSE 34042
// exit ;
34040: GO 34079
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
34042: LD_ADDR_EXP 77
34046: PUSH
34047: LD_EXP 77
34051: PPUSH
34052: LD_VAR 0 1
34056: PPUSH
34057: LD_EXP 77
34061: PUSH
34062: LD_VAR 0 1
34066: ARRAY
34067: PUSH
34068: LD_VAR 0 2
34072: ADD
34073: PPUSH
34074: CALL_OW 1
34078: ST_TO_ADDR
// end ;
34079: LD_VAR 0 3
34083: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
34084: LD_INT 0
34086: PPUSH
// if not mc_bases [ base ] then
34087: LD_EXP 56
34091: PUSH
34092: LD_VAR 0 1
34096: ARRAY
34097: NOT
34098: IFFALSE 34102
// exit ;
34100: GO 34156
// mc_defender := Replace ( mc_defender , base , deflist ) ;
34102: LD_ADDR_EXP 78
34106: PUSH
34107: LD_EXP 78
34111: PPUSH
34112: LD_VAR 0 1
34116: PPUSH
34117: LD_VAR 0 2
34121: PPUSH
34122: CALL_OW 1
34126: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
34127: LD_ADDR_EXP 67
34131: PUSH
34132: LD_EXP 67
34136: PPUSH
34137: LD_VAR 0 1
34141: PPUSH
34142: LD_VAR 0 2
34146: PUSH
34147: LD_INT 0
34149: PLUS
34150: PPUSH
34151: CALL_OW 1
34155: ST_TO_ADDR
// end ;
34156: LD_VAR 0 3
34160: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
34161: LD_INT 0
34163: PPUSH
// if not mc_bases [ base ] then
34164: LD_EXP 56
34168: PUSH
34169: LD_VAR 0 1
34173: ARRAY
34174: NOT
34175: IFFALSE 34179
// exit ;
34177: GO 34204
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
34179: LD_ADDR_EXP 67
34183: PUSH
34184: LD_EXP 67
34188: PPUSH
34189: LD_VAR 0 1
34193: PPUSH
34194: LD_VAR 0 2
34198: PPUSH
34199: CALL_OW 1
34203: ST_TO_ADDR
// end ;
34204: LD_VAR 0 3
34208: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
34209: LD_INT 0
34211: PPUSH
34212: PPUSH
34213: PPUSH
34214: PPUSH
// if not mc_bases [ base ] then
34215: LD_EXP 56
34219: PUSH
34220: LD_VAR 0 1
34224: ARRAY
34225: NOT
34226: IFFALSE 34230
// exit ;
34228: GO 34295
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
34230: LD_ADDR_EXP 76
34234: PUSH
34235: LD_EXP 76
34239: PPUSH
34240: LD_VAR 0 1
34244: PUSH
34245: LD_EXP 76
34249: PUSH
34250: LD_VAR 0 1
34254: ARRAY
34255: PUSH
34256: LD_INT 1
34258: PLUS
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PPUSH
34264: LD_VAR 0 1
34268: PUSH
34269: LD_VAR 0 2
34273: PUSH
34274: LD_VAR 0 3
34278: PUSH
34279: LD_VAR 0 4
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: PPUSH
34290: CALL 47019 0 3
34294: ST_TO_ADDR
// end ;
34295: LD_VAR 0 5
34299: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
34300: LD_INT 0
34302: PPUSH
// if not mc_bases [ base ] then
34303: LD_EXP 56
34307: PUSH
34308: LD_VAR 0 1
34312: ARRAY
34313: NOT
34314: IFFALSE 34318
// exit ;
34316: GO 34343
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
34318: LD_ADDR_EXP 93
34322: PUSH
34323: LD_EXP 93
34327: PPUSH
34328: LD_VAR 0 1
34332: PPUSH
34333: LD_VAR 0 2
34337: PPUSH
34338: CALL_OW 1
34342: ST_TO_ADDR
// end ;
34343: LD_VAR 0 3
34347: RET
// export function MC_GetMinesField ( base ) ; begin
34348: LD_INT 0
34350: PPUSH
// result := mc_mines [ base ] ;
34351: LD_ADDR_VAR 0 2
34355: PUSH
34356: LD_EXP 69
34360: PUSH
34361: LD_VAR 0 1
34365: ARRAY
34366: ST_TO_ADDR
// end ;
34367: LD_VAR 0 2
34371: RET
// export function MC_GetProduceList ( base ) ; begin
34372: LD_INT 0
34374: PPUSH
// result := mc_produce [ base ] ;
34375: LD_ADDR_VAR 0 2
34379: PUSH
34380: LD_EXP 77
34384: PUSH
34385: LD_VAR 0 1
34389: ARRAY
34390: ST_TO_ADDR
// end ;
34391: LD_VAR 0 2
34395: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
34396: LD_INT 0
34398: PPUSH
34399: PPUSH
// if not mc_bases then
34400: LD_EXP 56
34404: NOT
34405: IFFALSE 34409
// exit ;
34407: GO 34474
// if mc_bases [ base ] then
34409: LD_EXP 56
34413: PUSH
34414: LD_VAR 0 1
34418: ARRAY
34419: IFFALSE 34474
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34421: LD_ADDR_VAR 0 3
34425: PUSH
34426: LD_EXP 56
34430: PUSH
34431: LD_VAR 0 1
34435: ARRAY
34436: PPUSH
34437: LD_INT 30
34439: PUSH
34440: LD_VAR 0 2
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PPUSH
34449: CALL_OW 72
34453: ST_TO_ADDR
// if result then
34454: LD_VAR 0 3
34458: IFFALSE 34474
// result := result [ 1 ] ;
34460: LD_ADDR_VAR 0 3
34464: PUSH
34465: LD_VAR 0 3
34469: PUSH
34470: LD_INT 1
34472: ARRAY
34473: ST_TO_ADDR
// end ; end ;
34474: LD_VAR 0 3
34478: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
34479: LD_INT 0
34481: PPUSH
34482: PPUSH
// if not mc_bases then
34483: LD_EXP 56
34487: NOT
34488: IFFALSE 34492
// exit ;
34490: GO 34537
// if mc_bases [ base ] then
34492: LD_EXP 56
34496: PUSH
34497: LD_VAR 0 1
34501: ARRAY
34502: IFFALSE 34537
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34504: LD_ADDR_VAR 0 3
34508: PUSH
34509: LD_EXP 56
34513: PUSH
34514: LD_VAR 0 1
34518: ARRAY
34519: PPUSH
34520: LD_INT 30
34522: PUSH
34523: LD_VAR 0 2
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PPUSH
34532: CALL_OW 72
34536: ST_TO_ADDR
// end ;
34537: LD_VAR 0 3
34541: RET
// export function MC_SetTame ( base , area ) ; begin
34542: LD_INT 0
34544: PPUSH
// if not mc_bases or not base then
34545: LD_EXP 56
34549: NOT
34550: PUSH
34551: LD_VAR 0 1
34555: NOT
34556: OR
34557: IFFALSE 34561
// exit ;
34559: GO 34586
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
34561: LD_ADDR_EXP 84
34565: PUSH
34566: LD_EXP 84
34570: PPUSH
34571: LD_VAR 0 1
34575: PPUSH
34576: LD_VAR 0 2
34580: PPUSH
34581: CALL_OW 1
34585: ST_TO_ADDR
// end ;
34586: LD_VAR 0 3
34590: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
34591: LD_INT 0
34593: PPUSH
34594: PPUSH
// if not mc_bases or not base then
34595: LD_EXP 56
34599: NOT
34600: PUSH
34601: LD_VAR 0 1
34605: NOT
34606: OR
34607: IFFALSE 34611
// exit ;
34609: GO 34713
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34611: LD_ADDR_VAR 0 4
34615: PUSH
34616: LD_EXP 56
34620: PUSH
34621: LD_VAR 0 1
34625: ARRAY
34626: PPUSH
34627: LD_INT 30
34629: PUSH
34630: LD_VAR 0 2
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PPUSH
34639: CALL_OW 72
34643: ST_TO_ADDR
// if not tmp then
34644: LD_VAR 0 4
34648: NOT
34649: IFFALSE 34653
// exit ;
34651: GO 34713
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
34653: LD_ADDR_EXP 88
34657: PUSH
34658: LD_EXP 88
34662: PPUSH
34663: LD_VAR 0 1
34667: PPUSH
34668: LD_EXP 88
34672: PUSH
34673: LD_VAR 0 1
34677: ARRAY
34678: PPUSH
34679: LD_EXP 88
34683: PUSH
34684: LD_VAR 0 1
34688: ARRAY
34689: PUSH
34690: LD_INT 1
34692: PLUS
34693: PPUSH
34694: LD_VAR 0 4
34698: PUSH
34699: LD_INT 1
34701: ARRAY
34702: PPUSH
34703: CALL_OW 2
34707: PPUSH
34708: CALL_OW 1
34712: ST_TO_ADDR
// end ;
34713: LD_VAR 0 3
34717: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
34718: LD_INT 0
34720: PPUSH
34721: PPUSH
// if not mc_bases or not base or not kinds then
34722: LD_EXP 56
34726: NOT
34727: PUSH
34728: LD_VAR 0 1
34732: NOT
34733: OR
34734: PUSH
34735: LD_VAR 0 2
34739: NOT
34740: OR
34741: IFFALSE 34745
// exit ;
34743: GO 34806
// for i in kinds do
34745: LD_ADDR_VAR 0 4
34749: PUSH
34750: LD_VAR 0 2
34754: PUSH
34755: FOR_IN
34756: IFFALSE 34804
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
34758: LD_ADDR_EXP 90
34762: PUSH
34763: LD_EXP 90
34767: PPUSH
34768: LD_VAR 0 1
34772: PUSH
34773: LD_EXP 90
34777: PUSH
34778: LD_VAR 0 1
34782: ARRAY
34783: PUSH
34784: LD_INT 1
34786: PLUS
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PPUSH
34792: LD_VAR 0 4
34796: PPUSH
34797: CALL 47019 0 3
34801: ST_TO_ADDR
34802: GO 34755
34804: POP
34805: POP
// end ;
34806: LD_VAR 0 3
34810: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
34811: LD_INT 0
34813: PPUSH
// if not mc_bases or not base or not areas then
34814: LD_EXP 56
34818: NOT
34819: PUSH
34820: LD_VAR 0 1
34824: NOT
34825: OR
34826: PUSH
34827: LD_VAR 0 2
34831: NOT
34832: OR
34833: IFFALSE 34837
// exit ;
34835: GO 34862
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
34837: LD_ADDR_EXP 74
34841: PUSH
34842: LD_EXP 74
34846: PPUSH
34847: LD_VAR 0 1
34851: PPUSH
34852: LD_VAR 0 2
34856: PPUSH
34857: CALL_OW 1
34861: ST_TO_ADDR
// end ;
34862: LD_VAR 0 3
34866: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
34867: LD_INT 0
34869: PPUSH
// if not mc_bases or not base or not teleports_exit then
34870: LD_EXP 56
34874: NOT
34875: PUSH
34876: LD_VAR 0 1
34880: NOT
34881: OR
34882: PUSH
34883: LD_VAR 0 2
34887: NOT
34888: OR
34889: IFFALSE 34893
// exit ;
34891: GO 34918
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
34893: LD_ADDR_EXP 91
34897: PUSH
34898: LD_EXP 91
34902: PPUSH
34903: LD_VAR 0 1
34907: PPUSH
34908: LD_VAR 0 2
34912: PPUSH
34913: CALL_OW 1
34917: ST_TO_ADDR
// end ;
34918: LD_VAR 0 3
34922: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
34923: LD_INT 0
34925: PPUSH
34926: PPUSH
34927: PPUSH
// if not mc_bases or not base or not ext_list then
34928: LD_EXP 56
34932: NOT
34933: PUSH
34934: LD_VAR 0 1
34938: NOT
34939: OR
34940: PUSH
34941: LD_VAR 0 5
34945: NOT
34946: OR
34947: IFFALSE 34951
// exit ;
34949: GO 35124
// tmp := GetFacExtXYD ( x , y , d ) ;
34951: LD_ADDR_VAR 0 8
34955: PUSH
34956: LD_VAR 0 2
34960: PPUSH
34961: LD_VAR 0 3
34965: PPUSH
34966: LD_VAR 0 4
34970: PPUSH
34971: CALL 80397 0 3
34975: ST_TO_ADDR
// if not tmp then
34976: LD_VAR 0 8
34980: NOT
34981: IFFALSE 34985
// exit ;
34983: GO 35124
// for i in tmp do
34985: LD_ADDR_VAR 0 7
34989: PUSH
34990: LD_VAR 0 8
34994: PUSH
34995: FOR_IN
34996: IFFALSE 35122
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
34998: LD_ADDR_EXP 61
35002: PUSH
35003: LD_EXP 61
35007: PPUSH
35008: LD_VAR 0 1
35012: PPUSH
35013: LD_EXP 61
35017: PUSH
35018: LD_VAR 0 1
35022: ARRAY
35023: PPUSH
35024: LD_EXP 61
35028: PUSH
35029: LD_VAR 0 1
35033: ARRAY
35034: PUSH
35035: LD_INT 1
35037: PLUS
35038: PPUSH
35039: LD_VAR 0 5
35043: PUSH
35044: LD_INT 1
35046: ARRAY
35047: PUSH
35048: LD_VAR 0 7
35052: PUSH
35053: LD_INT 1
35055: ARRAY
35056: PUSH
35057: LD_VAR 0 7
35061: PUSH
35062: LD_INT 2
35064: ARRAY
35065: PUSH
35066: LD_VAR 0 7
35070: PUSH
35071: LD_INT 3
35073: ARRAY
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: PPUSH
35081: CALL_OW 2
35085: PPUSH
35086: CALL_OW 1
35090: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
35091: LD_ADDR_VAR 0 5
35095: PUSH
35096: LD_VAR 0 5
35100: PPUSH
35101: LD_INT 1
35103: PPUSH
35104: CALL_OW 3
35108: ST_TO_ADDR
// if not ext_list then
35109: LD_VAR 0 5
35113: NOT
35114: IFFALSE 35120
// exit ;
35116: POP
35117: POP
35118: GO 35124
// end ;
35120: GO 34995
35122: POP
35123: POP
// end ;
35124: LD_VAR 0 6
35128: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
35129: LD_INT 0
35131: PPUSH
// if not mc_bases or not base or not weapon_list then
35132: LD_EXP 56
35136: NOT
35137: PUSH
35138: LD_VAR 0 1
35142: NOT
35143: OR
35144: PUSH
35145: LD_VAR 0 2
35149: NOT
35150: OR
35151: IFFALSE 35155
// exit ;
35153: GO 35180
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
35155: LD_ADDR_EXP 95
35159: PUSH
35160: LD_EXP 95
35164: PPUSH
35165: LD_VAR 0 1
35169: PPUSH
35170: LD_VAR 0 2
35174: PPUSH
35175: CALL_OW 1
35179: ST_TO_ADDR
// end ;
35180: LD_VAR 0 3
35184: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
35185: LD_INT 0
35187: PPUSH
// if not mc_bases or not base or not tech_list then
35188: LD_EXP 56
35192: NOT
35193: PUSH
35194: LD_VAR 0 1
35198: NOT
35199: OR
35200: PUSH
35201: LD_VAR 0 2
35205: NOT
35206: OR
35207: IFFALSE 35211
// exit ;
35209: GO 35236
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
35211: LD_ADDR_EXP 83
35215: PUSH
35216: LD_EXP 83
35220: PPUSH
35221: LD_VAR 0 1
35225: PPUSH
35226: LD_VAR 0 2
35230: PPUSH
35231: CALL_OW 1
35235: ST_TO_ADDR
// end ;
35236: LD_VAR 0 3
35240: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
35241: LD_INT 0
35243: PPUSH
// if not mc_bases or not parking_area or not base then
35244: LD_EXP 56
35248: NOT
35249: PUSH
35250: LD_VAR 0 2
35254: NOT
35255: OR
35256: PUSH
35257: LD_VAR 0 1
35261: NOT
35262: OR
35263: IFFALSE 35267
// exit ;
35265: GO 35292
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
35267: LD_ADDR_EXP 80
35271: PUSH
35272: LD_EXP 80
35276: PPUSH
35277: LD_VAR 0 1
35281: PPUSH
35282: LD_VAR 0 2
35286: PPUSH
35287: CALL_OW 1
35291: ST_TO_ADDR
// end ;
35292: LD_VAR 0 3
35296: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
35297: LD_INT 0
35299: PPUSH
// if not mc_bases or not base or not scan_area then
35300: LD_EXP 56
35304: NOT
35305: PUSH
35306: LD_VAR 0 1
35310: NOT
35311: OR
35312: PUSH
35313: LD_VAR 0 2
35317: NOT
35318: OR
35319: IFFALSE 35323
// exit ;
35321: GO 35348
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
35323: LD_ADDR_EXP 81
35327: PUSH
35328: LD_EXP 81
35332: PPUSH
35333: LD_VAR 0 1
35337: PPUSH
35338: LD_VAR 0 2
35342: PPUSH
35343: CALL_OW 1
35347: ST_TO_ADDR
// end ;
35348: LD_VAR 0 3
35352: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
35353: LD_INT 0
35355: PPUSH
35356: PPUSH
// if not mc_bases or not base then
35357: LD_EXP 56
35361: NOT
35362: PUSH
35363: LD_VAR 0 1
35367: NOT
35368: OR
35369: IFFALSE 35373
// exit ;
35371: GO 35437
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
35373: LD_ADDR_VAR 0 3
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: LD_INT 2
35383: PUSH
35384: LD_INT 3
35386: PUSH
35387: LD_INT 4
35389: PUSH
35390: LD_INT 11
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: LIST
35399: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
35400: LD_ADDR_EXP 83
35404: PUSH
35405: LD_EXP 83
35409: PPUSH
35410: LD_VAR 0 1
35414: PPUSH
35415: LD_EXP 83
35419: PUSH
35420: LD_VAR 0 1
35424: ARRAY
35425: PUSH
35426: LD_VAR 0 3
35430: DIFF
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// end ;
35437: LD_VAR 0 2
35441: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
35442: LD_INT 0
35444: PPUSH
// result := mc_vehicles [ base ] ;
35445: LD_ADDR_VAR 0 3
35449: PUSH
35450: LD_EXP 75
35454: PUSH
35455: LD_VAR 0 1
35459: ARRAY
35460: ST_TO_ADDR
// if onlyCombat then
35461: LD_VAR 0 2
35465: IFFALSE 35630
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
35467: LD_ADDR_VAR 0 3
35471: PUSH
35472: LD_VAR 0 3
35476: PUSH
35477: LD_VAR 0 3
35481: PPUSH
35482: LD_INT 2
35484: PUSH
35485: LD_INT 34
35487: PUSH
35488: LD_INT 12
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 34
35497: PUSH
35498: LD_INT 51
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 34
35507: PUSH
35508: LD_EXP 50
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 34
35519: PUSH
35520: LD_INT 32
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 34
35529: PUSH
35530: LD_INT 13
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 34
35539: PUSH
35540: LD_INT 52
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 34
35549: PUSH
35550: LD_INT 14
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 34
35559: PUSH
35560: LD_INT 53
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 34
35569: PUSH
35570: LD_EXP 49
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 34
35581: PUSH
35582: LD_INT 31
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 34
35591: PUSH
35592: LD_INT 48
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 34
35601: PUSH
35602: LD_INT 8
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: PPUSH
35624: CALL_OW 72
35628: DIFF
35629: ST_TO_ADDR
// end ; end_of_file
35630: LD_VAR 0 3
35634: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
35635: LD_INT 0
35637: PPUSH
35638: PPUSH
35639: PPUSH
// if not mc_bases or not skirmish then
35640: LD_EXP 56
35644: NOT
35645: PUSH
35646: LD_EXP 54
35650: NOT
35651: OR
35652: IFFALSE 35656
// exit ;
35654: GO 35821
// for i = 1 to mc_bases do
35656: LD_ADDR_VAR 0 4
35660: PUSH
35661: DOUBLE
35662: LD_INT 1
35664: DEC
35665: ST_TO_ADDR
35666: LD_EXP 56
35670: PUSH
35671: FOR_TO
35672: IFFALSE 35819
// begin if sci in mc_bases [ i ] then
35674: LD_VAR 0 2
35678: PUSH
35679: LD_EXP 56
35683: PUSH
35684: LD_VAR 0 4
35688: ARRAY
35689: IN
35690: IFFALSE 35817
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
35692: LD_ADDR_EXP 85
35696: PUSH
35697: LD_EXP 85
35701: PPUSH
35702: LD_VAR 0 4
35706: PUSH
35707: LD_EXP 85
35711: PUSH
35712: LD_VAR 0 4
35716: ARRAY
35717: PUSH
35718: LD_INT 1
35720: PLUS
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PPUSH
35726: LD_VAR 0 1
35730: PPUSH
35731: CALL 47019 0 3
35735: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
35736: LD_ADDR_VAR 0 5
35740: PUSH
35741: LD_EXP 56
35745: PUSH
35746: LD_VAR 0 4
35750: ARRAY
35751: PPUSH
35752: LD_INT 2
35754: PUSH
35755: LD_INT 30
35757: PUSH
35758: LD_INT 0
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 30
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: LIST
35779: PPUSH
35780: CALL_OW 72
35784: PPUSH
35785: LD_VAR 0 1
35789: PPUSH
35790: CALL_OW 74
35794: ST_TO_ADDR
// if tmp then
35795: LD_VAR 0 5
35799: IFFALSE 35815
// ComStandNearbyBuilding ( ape , tmp ) ;
35801: LD_VAR 0 1
35805: PPUSH
35806: LD_VAR 0 5
35810: PPUSH
35811: CALL 41586 0 2
// break ;
35815: GO 35819
// end ; end ;
35817: GO 35671
35819: POP
35820: POP
// end ;
35821: LD_VAR 0 3
35825: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
35826: LD_INT 0
35828: PPUSH
35829: PPUSH
35830: PPUSH
// if not mc_bases or not skirmish then
35831: LD_EXP 56
35835: NOT
35836: PUSH
35837: LD_EXP 54
35841: NOT
35842: OR
35843: IFFALSE 35847
// exit ;
35845: GO 35936
// for i = 1 to mc_bases do
35847: LD_ADDR_VAR 0 4
35851: PUSH
35852: DOUBLE
35853: LD_INT 1
35855: DEC
35856: ST_TO_ADDR
35857: LD_EXP 56
35861: PUSH
35862: FOR_TO
35863: IFFALSE 35934
// begin if building in mc_busy_turret_list [ i ] then
35865: LD_VAR 0 1
35869: PUSH
35870: LD_EXP 66
35874: PUSH
35875: LD_VAR 0 4
35879: ARRAY
35880: IN
35881: IFFALSE 35932
// begin tmp := mc_busy_turret_list [ i ] diff building ;
35883: LD_ADDR_VAR 0 5
35887: PUSH
35888: LD_EXP 66
35892: PUSH
35893: LD_VAR 0 4
35897: ARRAY
35898: PUSH
35899: LD_VAR 0 1
35903: DIFF
35904: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
35905: LD_ADDR_EXP 66
35909: PUSH
35910: LD_EXP 66
35914: PPUSH
35915: LD_VAR 0 4
35919: PPUSH
35920: LD_VAR 0 5
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// break ;
35930: GO 35934
// end ; end ;
35932: GO 35862
35934: POP
35935: POP
// end ;
35936: LD_VAR 0 3
35940: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
35941: LD_INT 0
35943: PPUSH
35944: PPUSH
35945: PPUSH
// if not mc_bases or not skirmish then
35946: LD_EXP 56
35950: NOT
35951: PUSH
35952: LD_EXP 54
35956: NOT
35957: OR
35958: IFFALSE 35962
// exit ;
35960: GO 36161
// for i = 1 to mc_bases do
35962: LD_ADDR_VAR 0 5
35966: PUSH
35967: DOUBLE
35968: LD_INT 1
35970: DEC
35971: ST_TO_ADDR
35972: LD_EXP 56
35976: PUSH
35977: FOR_TO
35978: IFFALSE 36159
// if building in mc_bases [ i ] then
35980: LD_VAR 0 1
35984: PUSH
35985: LD_EXP 56
35989: PUSH
35990: LD_VAR 0 5
35994: ARRAY
35995: IN
35996: IFFALSE 36157
// begin tmp := mc_bases [ i ] diff building ;
35998: LD_ADDR_VAR 0 6
36002: PUSH
36003: LD_EXP 56
36007: PUSH
36008: LD_VAR 0 5
36012: ARRAY
36013: PUSH
36014: LD_VAR 0 1
36018: DIFF
36019: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
36020: LD_ADDR_EXP 56
36024: PUSH
36025: LD_EXP 56
36029: PPUSH
36030: LD_VAR 0 5
36034: PPUSH
36035: LD_VAR 0 6
36039: PPUSH
36040: CALL_OW 1
36044: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
36045: LD_VAR 0 1
36049: PUSH
36050: LD_EXP 64
36054: PUSH
36055: LD_VAR 0 5
36059: ARRAY
36060: IN
36061: IFFALSE 36100
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
36063: LD_ADDR_EXP 64
36067: PUSH
36068: LD_EXP 64
36072: PPUSH
36073: LD_VAR 0 5
36077: PPUSH
36078: LD_EXP 64
36082: PUSH
36083: LD_VAR 0 5
36087: ARRAY
36088: PUSH
36089: LD_VAR 0 1
36093: DIFF
36094: PPUSH
36095: CALL_OW 1
36099: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
36100: LD_VAR 0 1
36104: PUSH
36105: LD_EXP 65
36109: PUSH
36110: LD_VAR 0 5
36114: ARRAY
36115: IN
36116: IFFALSE 36155
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
36118: LD_ADDR_EXP 65
36122: PUSH
36123: LD_EXP 65
36127: PPUSH
36128: LD_VAR 0 5
36132: PPUSH
36133: LD_EXP 65
36137: PUSH
36138: LD_VAR 0 5
36142: ARRAY
36143: PUSH
36144: LD_VAR 0 1
36148: DIFF
36149: PPUSH
36150: CALL_OW 1
36154: ST_TO_ADDR
// break ;
36155: GO 36159
// end ;
36157: GO 35977
36159: POP
36160: POP
// end ;
36161: LD_VAR 0 4
36165: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
36166: LD_INT 0
36168: PPUSH
36169: PPUSH
36170: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
36171: LD_EXP 56
36175: NOT
36176: PUSH
36177: LD_EXP 54
36181: NOT
36182: OR
36183: PUSH
36184: LD_VAR 0 3
36188: PUSH
36189: LD_EXP 82
36193: IN
36194: NOT
36195: OR
36196: IFFALSE 36200
// exit ;
36198: GO 36323
// for i = 1 to mc_vehicles do
36200: LD_ADDR_VAR 0 6
36204: PUSH
36205: DOUBLE
36206: LD_INT 1
36208: DEC
36209: ST_TO_ADDR
36210: LD_EXP 75
36214: PUSH
36215: FOR_TO
36216: IFFALSE 36321
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
36218: LD_VAR 0 2
36222: PUSH
36223: LD_EXP 75
36227: PUSH
36228: LD_VAR 0 6
36232: ARRAY
36233: IN
36234: PUSH
36235: LD_VAR 0 1
36239: PUSH
36240: LD_EXP 75
36244: PUSH
36245: LD_VAR 0 6
36249: ARRAY
36250: IN
36251: OR
36252: IFFALSE 36319
// begin tmp := mc_vehicles [ i ] diff old ;
36254: LD_ADDR_VAR 0 7
36258: PUSH
36259: LD_EXP 75
36263: PUSH
36264: LD_VAR 0 6
36268: ARRAY
36269: PUSH
36270: LD_VAR 0 2
36274: DIFF
36275: ST_TO_ADDR
// tmp := tmp diff new ;
36276: LD_ADDR_VAR 0 7
36280: PUSH
36281: LD_VAR 0 7
36285: PUSH
36286: LD_VAR 0 1
36290: DIFF
36291: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
36292: LD_ADDR_EXP 75
36296: PUSH
36297: LD_EXP 75
36301: PPUSH
36302: LD_VAR 0 6
36306: PPUSH
36307: LD_VAR 0 7
36311: PPUSH
36312: CALL_OW 1
36316: ST_TO_ADDR
// break ;
36317: GO 36321
// end ;
36319: GO 36215
36321: POP
36322: POP
// end ;
36323: LD_VAR 0 5
36327: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
36328: LD_INT 0
36330: PPUSH
36331: PPUSH
36332: PPUSH
36333: PPUSH
// if not mc_bases or not skirmish then
36334: LD_EXP 56
36338: NOT
36339: PUSH
36340: LD_EXP 54
36344: NOT
36345: OR
36346: IFFALSE 36350
// exit ;
36348: GO 36727
// side := GetSide ( vehicle ) ;
36350: LD_ADDR_VAR 0 5
36354: PUSH
36355: LD_VAR 0 1
36359: PPUSH
36360: CALL_OW 255
36364: ST_TO_ADDR
// for i = 1 to mc_bases do
36365: LD_ADDR_VAR 0 4
36369: PUSH
36370: DOUBLE
36371: LD_INT 1
36373: DEC
36374: ST_TO_ADDR
36375: LD_EXP 56
36379: PUSH
36380: FOR_TO
36381: IFFALSE 36725
// begin if factory in mc_bases [ i ] then
36383: LD_VAR 0 2
36387: PUSH
36388: LD_EXP 56
36392: PUSH
36393: LD_VAR 0 4
36397: ARRAY
36398: IN
36399: IFFALSE 36723
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
36401: LD_EXP 78
36405: PUSH
36406: LD_VAR 0 4
36410: ARRAY
36411: PUSH
36412: LD_EXP 67
36416: PUSH
36417: LD_VAR 0 4
36421: ARRAY
36422: LESS
36423: PUSH
36424: LD_VAR 0 1
36428: PPUSH
36429: CALL_OW 264
36433: PUSH
36434: LD_INT 31
36436: PUSH
36437: LD_INT 32
36439: PUSH
36440: LD_INT 51
36442: PUSH
36443: LD_EXP 50
36447: PUSH
36448: LD_INT 12
36450: PUSH
36451: LD_INT 30
36453: PUSH
36454: LD_EXP 49
36458: PUSH
36459: LD_INT 11
36461: PUSH
36462: LD_INT 53
36464: PUSH
36465: LD_INT 14
36467: PUSH
36468: LD_EXP 53
36472: PUSH
36473: LD_INT 29
36475: PUSH
36476: LD_EXP 51
36480: PUSH
36481: LD_INT 13
36483: PUSH
36484: LD_INT 52
36486: PUSH
36487: LD_INT 48
36489: PUSH
36490: LD_INT 8
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: IN
36512: NOT
36513: AND
36514: IFFALSE 36562
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
36516: LD_ADDR_EXP 78
36520: PUSH
36521: LD_EXP 78
36525: PPUSH
36526: LD_VAR 0 4
36530: PUSH
36531: LD_EXP 78
36535: PUSH
36536: LD_VAR 0 4
36540: ARRAY
36541: PUSH
36542: LD_INT 1
36544: PLUS
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PPUSH
36550: LD_VAR 0 1
36554: PPUSH
36555: CALL 47019 0 3
36559: ST_TO_ADDR
36560: GO 36606
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
36562: LD_ADDR_EXP 75
36566: PUSH
36567: LD_EXP 75
36571: PPUSH
36572: LD_VAR 0 4
36576: PUSH
36577: LD_EXP 75
36581: PUSH
36582: LD_VAR 0 4
36586: ARRAY
36587: PUSH
36588: LD_INT 1
36590: PLUS
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PPUSH
36596: LD_VAR 0 1
36600: PPUSH
36601: CALL 47019 0 3
36605: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
36606: LD_VAR 0 1
36610: PPUSH
36611: CALL_OW 263
36615: PUSH
36616: LD_INT 2
36618: EQUAL
36619: IFFALSE 36639
// begin repeat wait ( 0 0$1 ) ;
36621: LD_INT 35
36623: PPUSH
36624: CALL_OW 67
// until IsControledBy ( vehicle ) ;
36628: LD_VAR 0 1
36632: PPUSH
36633: CALL_OW 312
36637: IFFALSE 36621
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
36639: LD_VAR 0 1
36643: PPUSH
36644: LD_EXP 80
36648: PUSH
36649: LD_VAR 0 4
36653: ARRAY
36654: PPUSH
36655: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
36659: LD_VAR 0 1
36663: PPUSH
36664: CALL_OW 263
36668: PUSH
36669: LD_INT 1
36671: NONEQUAL
36672: IFFALSE 36676
// break ;
36674: GO 36725
// repeat wait ( 0 0$1 ) ;
36676: LD_INT 35
36678: PPUSH
36679: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
36683: LD_VAR 0 1
36687: PPUSH
36688: LD_EXP 80
36692: PUSH
36693: LD_VAR 0 4
36697: ARRAY
36698: PPUSH
36699: CALL_OW 308
36703: IFFALSE 36676
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
36705: LD_VAR 0 1
36709: PPUSH
36710: CALL_OW 311
36714: PPUSH
36715: CALL_OW 121
// exit ;
36719: POP
36720: POP
36721: GO 36727
// end ; end ;
36723: GO 36380
36725: POP
36726: POP
// end ;
36727: LD_VAR 0 3
36731: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
36732: LD_INT 0
36734: PPUSH
36735: PPUSH
36736: PPUSH
36737: PPUSH
// if not mc_bases or not skirmish then
36738: LD_EXP 56
36742: NOT
36743: PUSH
36744: LD_EXP 54
36748: NOT
36749: OR
36750: IFFALSE 36754
// exit ;
36752: GO 37107
// repeat wait ( 0 0$1 ) ;
36754: LD_INT 35
36756: PPUSH
36757: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
36761: LD_VAR 0 2
36765: PPUSH
36766: LD_VAR 0 3
36770: PPUSH
36771: CALL_OW 284
36775: IFFALSE 36754
// if GetResourceTypeXY ( x , y ) = mat_artefact then
36777: LD_VAR 0 2
36781: PPUSH
36782: LD_VAR 0 3
36786: PPUSH
36787: CALL_OW 283
36791: PUSH
36792: LD_INT 4
36794: EQUAL
36795: IFFALSE 36799
// exit ;
36797: GO 37107
// for i = 1 to mc_bases do
36799: LD_ADDR_VAR 0 7
36803: PUSH
36804: DOUBLE
36805: LD_INT 1
36807: DEC
36808: ST_TO_ADDR
36809: LD_EXP 56
36813: PUSH
36814: FOR_TO
36815: IFFALSE 37105
// begin if mc_crates_area [ i ] then
36817: LD_EXP 74
36821: PUSH
36822: LD_VAR 0 7
36826: ARRAY
36827: IFFALSE 36938
// for j in mc_crates_area [ i ] do
36829: LD_ADDR_VAR 0 8
36833: PUSH
36834: LD_EXP 74
36838: PUSH
36839: LD_VAR 0 7
36843: ARRAY
36844: PUSH
36845: FOR_IN
36846: IFFALSE 36936
// if InArea ( x , y , j ) then
36848: LD_VAR 0 2
36852: PPUSH
36853: LD_VAR 0 3
36857: PPUSH
36858: LD_VAR 0 8
36862: PPUSH
36863: CALL_OW 309
36867: IFFALSE 36934
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
36869: LD_ADDR_EXP 72
36873: PUSH
36874: LD_EXP 72
36878: PPUSH
36879: LD_VAR 0 7
36883: PUSH
36884: LD_EXP 72
36888: PUSH
36889: LD_VAR 0 7
36893: ARRAY
36894: PUSH
36895: LD_INT 1
36897: PLUS
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PPUSH
36903: LD_VAR 0 4
36907: PUSH
36908: LD_VAR 0 2
36912: PUSH
36913: LD_VAR 0 3
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: LIST
36922: PPUSH
36923: CALL 47019 0 3
36927: ST_TO_ADDR
// exit ;
36928: POP
36929: POP
36930: POP
36931: POP
36932: GO 37107
// end ;
36934: GO 36845
36936: POP
36937: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36938: LD_ADDR_VAR 0 9
36942: PUSH
36943: LD_EXP 56
36947: PUSH
36948: LD_VAR 0 7
36952: ARRAY
36953: PPUSH
36954: LD_INT 2
36956: PUSH
36957: LD_INT 30
36959: PUSH
36960: LD_INT 0
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 30
36969: PUSH
36970: LD_INT 1
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: LIST
36981: PPUSH
36982: CALL_OW 72
36986: ST_TO_ADDR
// if not depot then
36987: LD_VAR 0 9
36991: NOT
36992: IFFALSE 36996
// continue ;
36994: GO 36814
// for j in depot do
36996: LD_ADDR_VAR 0 8
37000: PUSH
37001: LD_VAR 0 9
37005: PUSH
37006: FOR_IN
37007: IFFALSE 37101
// if GetDistUnitXY ( j , x , y ) < 30 then
37009: LD_VAR 0 8
37013: PPUSH
37014: LD_VAR 0 2
37018: PPUSH
37019: LD_VAR 0 3
37023: PPUSH
37024: CALL_OW 297
37028: PUSH
37029: LD_INT 30
37031: LESS
37032: IFFALSE 37099
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
37034: LD_ADDR_EXP 72
37038: PUSH
37039: LD_EXP 72
37043: PPUSH
37044: LD_VAR 0 7
37048: PUSH
37049: LD_EXP 72
37053: PUSH
37054: LD_VAR 0 7
37058: ARRAY
37059: PUSH
37060: LD_INT 1
37062: PLUS
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PPUSH
37068: LD_VAR 0 4
37072: PUSH
37073: LD_VAR 0 2
37077: PUSH
37078: LD_VAR 0 3
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: LIST
37087: PPUSH
37088: CALL 47019 0 3
37092: ST_TO_ADDR
// exit ;
37093: POP
37094: POP
37095: POP
37096: POP
37097: GO 37107
// end ;
37099: GO 37006
37101: POP
37102: POP
// end ;
37103: GO 36814
37105: POP
37106: POP
// end ;
37107: LD_VAR 0 6
37111: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
37112: LD_INT 0
37114: PPUSH
37115: PPUSH
37116: PPUSH
37117: PPUSH
// if not mc_bases or not skirmish then
37118: LD_EXP 56
37122: NOT
37123: PUSH
37124: LD_EXP 54
37128: NOT
37129: OR
37130: IFFALSE 37134
// exit ;
37132: GO 37411
// side := GetSide ( lab ) ;
37134: LD_ADDR_VAR 0 4
37138: PUSH
37139: LD_VAR 0 2
37143: PPUSH
37144: CALL_OW 255
37148: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
37149: LD_VAR 0 4
37153: PUSH
37154: LD_EXP 82
37158: IN
37159: NOT
37160: PUSH
37161: LD_EXP 83
37165: NOT
37166: OR
37167: PUSH
37168: LD_EXP 56
37172: NOT
37173: OR
37174: IFFALSE 37178
// exit ;
37176: GO 37411
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
37178: LD_ADDR_EXP 83
37182: PUSH
37183: LD_EXP 83
37187: PPUSH
37188: LD_VAR 0 4
37192: PPUSH
37193: LD_EXP 83
37197: PUSH
37198: LD_VAR 0 4
37202: ARRAY
37203: PUSH
37204: LD_VAR 0 1
37208: DIFF
37209: PPUSH
37210: CALL_OW 1
37214: ST_TO_ADDR
// for i = 1 to mc_bases do
37215: LD_ADDR_VAR 0 5
37219: PUSH
37220: DOUBLE
37221: LD_INT 1
37223: DEC
37224: ST_TO_ADDR
37225: LD_EXP 56
37229: PUSH
37230: FOR_TO
37231: IFFALSE 37409
// begin if lab in mc_bases [ i ] then
37233: LD_VAR 0 2
37237: PUSH
37238: LD_EXP 56
37242: PUSH
37243: LD_VAR 0 5
37247: ARRAY
37248: IN
37249: IFFALSE 37407
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
37251: LD_VAR 0 1
37255: PUSH
37256: LD_INT 11
37258: PUSH
37259: LD_INT 4
37261: PUSH
37262: LD_INT 3
37264: PUSH
37265: LD_INT 2
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: IN
37274: PUSH
37275: LD_EXP 86
37279: PUSH
37280: LD_VAR 0 5
37284: ARRAY
37285: AND
37286: IFFALSE 37407
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
37288: LD_ADDR_VAR 0 6
37292: PUSH
37293: LD_EXP 86
37297: PUSH
37298: LD_VAR 0 5
37302: ARRAY
37303: PUSH
37304: LD_INT 1
37306: ARRAY
37307: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37308: LD_ADDR_EXP 86
37312: PUSH
37313: LD_EXP 86
37317: PPUSH
37318: LD_VAR 0 5
37322: PPUSH
37323: EMPTY
37324: PPUSH
37325: CALL_OW 1
37329: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
37330: LD_VAR 0 6
37334: PPUSH
37335: LD_INT 0
37337: PPUSH
37338: CALL_OW 109
// ComExitBuilding ( tmp ) ;
37342: LD_VAR 0 6
37346: PPUSH
37347: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
37351: LD_ADDR_EXP 85
37355: PUSH
37356: LD_EXP 85
37360: PPUSH
37361: LD_VAR 0 5
37365: PPUSH
37366: LD_EXP 85
37370: PUSH
37371: LD_VAR 0 5
37375: ARRAY
37376: PPUSH
37377: LD_INT 1
37379: PPUSH
37380: LD_VAR 0 6
37384: PPUSH
37385: CALL_OW 2
37389: PPUSH
37390: CALL_OW 1
37394: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
37395: LD_VAR 0 5
37399: PPUSH
37400: LD_INT 112
37402: PPUSH
37403: CALL 14519 0 2
// end ; end ; end ;
37407: GO 37230
37409: POP
37410: POP
// end ;
37411: LD_VAR 0 3
37415: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
37416: LD_INT 0
37418: PPUSH
37419: PPUSH
37420: PPUSH
37421: PPUSH
37422: PPUSH
37423: PPUSH
37424: PPUSH
37425: PPUSH
// if not mc_bases or not skirmish then
37426: LD_EXP 56
37430: NOT
37431: PUSH
37432: LD_EXP 54
37436: NOT
37437: OR
37438: IFFALSE 37442
// exit ;
37440: GO 38591
// for i = 1 to mc_bases do
37442: LD_ADDR_VAR 0 3
37446: PUSH
37447: DOUBLE
37448: LD_INT 1
37450: DEC
37451: ST_TO_ADDR
37452: LD_EXP 56
37456: PUSH
37457: FOR_TO
37458: IFFALSE 38589
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
37460: LD_VAR 0 1
37464: PUSH
37465: LD_EXP 56
37469: PUSH
37470: LD_VAR 0 3
37474: ARRAY
37475: IN
37476: PUSH
37477: LD_VAR 0 1
37481: PUSH
37482: LD_EXP 63
37486: PUSH
37487: LD_VAR 0 3
37491: ARRAY
37492: IN
37493: OR
37494: PUSH
37495: LD_VAR 0 1
37499: PUSH
37500: LD_EXP 78
37504: PUSH
37505: LD_VAR 0 3
37509: ARRAY
37510: IN
37511: OR
37512: PUSH
37513: LD_VAR 0 1
37517: PUSH
37518: LD_EXP 75
37522: PUSH
37523: LD_VAR 0 3
37527: ARRAY
37528: IN
37529: OR
37530: PUSH
37531: LD_VAR 0 1
37535: PUSH
37536: LD_EXP 85
37540: PUSH
37541: LD_VAR 0 3
37545: ARRAY
37546: IN
37547: OR
37548: PUSH
37549: LD_VAR 0 1
37553: PUSH
37554: LD_EXP 86
37558: PUSH
37559: LD_VAR 0 3
37563: ARRAY
37564: IN
37565: OR
37566: IFFALSE 38587
// begin if un in mc_ape [ i ] then
37568: LD_VAR 0 1
37572: PUSH
37573: LD_EXP 85
37577: PUSH
37578: LD_VAR 0 3
37582: ARRAY
37583: IN
37584: IFFALSE 37623
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
37586: LD_ADDR_EXP 85
37590: PUSH
37591: LD_EXP 85
37595: PPUSH
37596: LD_VAR 0 3
37600: PPUSH
37601: LD_EXP 85
37605: PUSH
37606: LD_VAR 0 3
37610: ARRAY
37611: PUSH
37612: LD_VAR 0 1
37616: DIFF
37617: PPUSH
37618: CALL_OW 1
37622: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
37623: LD_VAR 0 1
37627: PUSH
37628: LD_EXP 86
37632: PUSH
37633: LD_VAR 0 3
37637: ARRAY
37638: IN
37639: IFFALSE 37663
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37641: LD_ADDR_EXP 86
37645: PUSH
37646: LD_EXP 86
37650: PPUSH
37651: LD_VAR 0 3
37655: PPUSH
37656: EMPTY
37657: PPUSH
37658: CALL_OW 1
37662: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
37663: LD_VAR 0 1
37667: PPUSH
37668: CALL_OW 247
37672: PUSH
37673: LD_INT 2
37675: EQUAL
37676: PUSH
37677: LD_VAR 0 1
37681: PPUSH
37682: CALL_OW 110
37686: PUSH
37687: LD_INT 20
37689: EQUAL
37690: PUSH
37691: LD_VAR 0 1
37695: PUSH
37696: LD_EXP 78
37700: PUSH
37701: LD_VAR 0 3
37705: ARRAY
37706: IN
37707: OR
37708: PUSH
37709: LD_VAR 0 1
37713: PPUSH
37714: CALL_OW 264
37718: PUSH
37719: LD_INT 12
37721: PUSH
37722: LD_INT 51
37724: PUSH
37725: LD_EXP 50
37729: PUSH
37730: LD_INT 32
37732: PUSH
37733: LD_INT 13
37735: PUSH
37736: LD_INT 52
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: LIST
37743: LIST
37744: LIST
37745: LIST
37746: IN
37747: OR
37748: AND
37749: IFFALSE 37927
// begin if un in mc_defender [ i ] then
37751: LD_VAR 0 1
37755: PUSH
37756: LD_EXP 78
37760: PUSH
37761: LD_VAR 0 3
37765: ARRAY
37766: IN
37767: IFFALSE 37806
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
37769: LD_ADDR_EXP 78
37773: PUSH
37774: LD_EXP 78
37778: PPUSH
37779: LD_VAR 0 3
37783: PPUSH
37784: LD_EXP 78
37788: PUSH
37789: LD_VAR 0 3
37793: ARRAY
37794: PUSH
37795: LD_VAR 0 1
37799: DIFF
37800: PPUSH
37801: CALL_OW 1
37805: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
37806: LD_ADDR_VAR 0 8
37810: PUSH
37811: LD_VAR 0 3
37815: PPUSH
37816: LD_INT 3
37818: PPUSH
37819: CALL 34479 0 2
37823: ST_TO_ADDR
// if fac then
37824: LD_VAR 0 8
37828: IFFALSE 37927
// begin for j in fac do
37830: LD_ADDR_VAR 0 4
37834: PUSH
37835: LD_VAR 0 8
37839: PUSH
37840: FOR_IN
37841: IFFALSE 37925
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
37843: LD_ADDR_VAR 0 9
37847: PUSH
37848: LD_VAR 0 8
37852: PPUSH
37853: LD_VAR 0 1
37857: PPUSH
37858: CALL_OW 265
37862: PPUSH
37863: LD_VAR 0 1
37867: PPUSH
37868: CALL_OW 262
37872: PPUSH
37873: LD_VAR 0 1
37877: PPUSH
37878: CALL_OW 263
37882: PPUSH
37883: LD_VAR 0 1
37887: PPUSH
37888: CALL_OW 264
37892: PPUSH
37893: CALL 44551 0 5
37897: ST_TO_ADDR
// if components then
37898: LD_VAR 0 9
37902: IFFALSE 37923
// begin MC_InsertProduceList ( i , [ components ] ) ;
37904: LD_VAR 0 3
37908: PPUSH
37909: LD_VAR 0 9
37913: PUSH
37914: EMPTY
37915: LIST
37916: PPUSH
37917: CALL 34024 0 2
// break ;
37921: GO 37925
// end ; end ;
37923: GO 37840
37925: POP
37926: POP
// end ; end ; if GetType ( un ) = unit_building then
37927: LD_VAR 0 1
37931: PPUSH
37932: CALL_OW 247
37936: PUSH
37937: LD_INT 3
37939: EQUAL
37940: IFFALSE 38255
// begin btype := GetBType ( un ) ;
37942: LD_ADDR_VAR 0 5
37946: PUSH
37947: LD_VAR 0 1
37951: PPUSH
37952: CALL_OW 266
37956: ST_TO_ADDR
// if btype = b_warehouse then
37957: LD_VAR 0 5
37961: PUSH
37962: LD_INT 1
37964: EQUAL
37965: IFFALSE 37983
// begin btype := b_depot ;
37967: LD_ADDR_VAR 0 5
37971: PUSH
37972: LD_INT 0
37974: ST_TO_ADDR
// pos := 1 ;
37975: LD_ADDR_VAR 0 6
37979: PUSH
37980: LD_INT 1
37982: ST_TO_ADDR
// end ; if btype = b_factory then
37983: LD_VAR 0 5
37987: PUSH
37988: LD_INT 3
37990: EQUAL
37991: IFFALSE 38009
// begin btype := b_workshop ;
37993: LD_ADDR_VAR 0 5
37997: PUSH
37998: LD_INT 2
38000: ST_TO_ADDR
// pos := 1 ;
38001: LD_ADDR_VAR 0 6
38005: PUSH
38006: LD_INT 1
38008: ST_TO_ADDR
// end ; if btype = b_barracks then
38009: LD_VAR 0 5
38013: PUSH
38014: LD_INT 5
38016: EQUAL
38017: IFFALSE 38027
// btype := b_armoury ;
38019: LD_ADDR_VAR 0 5
38023: PUSH
38024: LD_INT 4
38026: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
38027: LD_VAR 0 5
38031: PUSH
38032: LD_INT 7
38034: PUSH
38035: LD_INT 8
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: IN
38042: IFFALSE 38052
// btype := b_lab ;
38044: LD_ADDR_VAR 0 5
38048: PUSH
38049: LD_INT 6
38051: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
38052: LD_ADDR_EXP 61
38056: PUSH
38057: LD_EXP 61
38061: PPUSH
38062: LD_VAR 0 3
38066: PUSH
38067: LD_EXP 61
38071: PUSH
38072: LD_VAR 0 3
38076: ARRAY
38077: PUSH
38078: LD_INT 1
38080: PLUS
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PPUSH
38086: LD_VAR 0 5
38090: PUSH
38091: LD_VAR 0 1
38095: PPUSH
38096: CALL_OW 250
38100: PUSH
38101: LD_VAR 0 1
38105: PPUSH
38106: CALL_OW 251
38110: PUSH
38111: LD_VAR 0 1
38115: PPUSH
38116: CALL_OW 254
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: LIST
38125: LIST
38126: PPUSH
38127: CALL 47019 0 3
38131: ST_TO_ADDR
// if pos = 1 then
38132: LD_VAR 0 6
38136: PUSH
38137: LD_INT 1
38139: EQUAL
38140: IFFALSE 38255
// begin tmp := mc_build_list [ i ] ;
38142: LD_ADDR_VAR 0 7
38146: PUSH
38147: LD_EXP 61
38151: PUSH
38152: LD_VAR 0 3
38156: ARRAY
38157: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38158: LD_VAR 0 7
38162: PPUSH
38163: LD_INT 2
38165: PUSH
38166: LD_INT 30
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 30
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: LIST
38190: PPUSH
38191: CALL_OW 72
38195: IFFALSE 38205
// pos := 2 ;
38197: LD_ADDR_VAR 0 6
38201: PUSH
38202: LD_INT 2
38204: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
38205: LD_ADDR_VAR 0 7
38209: PUSH
38210: LD_VAR 0 7
38214: PPUSH
38215: LD_VAR 0 6
38219: PPUSH
38220: LD_VAR 0 7
38224: PPUSH
38225: CALL 47345 0 3
38229: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
38230: LD_ADDR_EXP 61
38234: PUSH
38235: LD_EXP 61
38239: PPUSH
38240: LD_VAR 0 3
38244: PPUSH
38245: LD_VAR 0 7
38249: PPUSH
38250: CALL_OW 1
38254: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
38255: LD_VAR 0 1
38259: PUSH
38260: LD_EXP 56
38264: PUSH
38265: LD_VAR 0 3
38269: ARRAY
38270: IN
38271: IFFALSE 38310
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
38273: LD_ADDR_EXP 56
38277: PUSH
38278: LD_EXP 56
38282: PPUSH
38283: LD_VAR 0 3
38287: PPUSH
38288: LD_EXP 56
38292: PUSH
38293: LD_VAR 0 3
38297: ARRAY
38298: PUSH
38299: LD_VAR 0 1
38303: DIFF
38304: PPUSH
38305: CALL_OW 1
38309: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
38310: LD_VAR 0 1
38314: PUSH
38315: LD_EXP 63
38319: PUSH
38320: LD_VAR 0 3
38324: ARRAY
38325: IN
38326: IFFALSE 38365
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
38328: LD_ADDR_EXP 63
38332: PUSH
38333: LD_EXP 63
38337: PPUSH
38338: LD_VAR 0 3
38342: PPUSH
38343: LD_EXP 63
38347: PUSH
38348: LD_VAR 0 3
38352: ARRAY
38353: PUSH
38354: LD_VAR 0 1
38358: DIFF
38359: PPUSH
38360: CALL_OW 1
38364: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
38365: LD_VAR 0 1
38369: PUSH
38370: LD_EXP 75
38374: PUSH
38375: LD_VAR 0 3
38379: ARRAY
38380: IN
38381: IFFALSE 38420
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
38383: LD_ADDR_EXP 75
38387: PUSH
38388: LD_EXP 75
38392: PPUSH
38393: LD_VAR 0 3
38397: PPUSH
38398: LD_EXP 75
38402: PUSH
38403: LD_VAR 0 3
38407: ARRAY
38408: PUSH
38409: LD_VAR 0 1
38413: DIFF
38414: PPUSH
38415: CALL_OW 1
38419: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
38420: LD_VAR 0 1
38424: PUSH
38425: LD_EXP 78
38429: PUSH
38430: LD_VAR 0 3
38434: ARRAY
38435: IN
38436: IFFALSE 38475
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
38438: LD_ADDR_EXP 78
38442: PUSH
38443: LD_EXP 78
38447: PPUSH
38448: LD_VAR 0 3
38452: PPUSH
38453: LD_EXP 78
38457: PUSH
38458: LD_VAR 0 3
38462: ARRAY
38463: PUSH
38464: LD_VAR 0 1
38468: DIFF
38469: PPUSH
38470: CALL_OW 1
38474: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
38475: LD_VAR 0 1
38479: PUSH
38480: LD_EXP 65
38484: PUSH
38485: LD_VAR 0 3
38489: ARRAY
38490: IN
38491: IFFALSE 38530
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
38493: LD_ADDR_EXP 65
38497: PUSH
38498: LD_EXP 65
38502: PPUSH
38503: LD_VAR 0 3
38507: PPUSH
38508: LD_EXP 65
38512: PUSH
38513: LD_VAR 0 3
38517: ARRAY
38518: PUSH
38519: LD_VAR 0 1
38523: DIFF
38524: PPUSH
38525: CALL_OW 1
38529: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
38530: LD_VAR 0 1
38534: PUSH
38535: LD_EXP 64
38539: PUSH
38540: LD_VAR 0 3
38544: ARRAY
38545: IN
38546: IFFALSE 38585
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
38548: LD_ADDR_EXP 64
38552: PUSH
38553: LD_EXP 64
38557: PPUSH
38558: LD_VAR 0 3
38562: PPUSH
38563: LD_EXP 64
38567: PUSH
38568: LD_VAR 0 3
38572: ARRAY
38573: PUSH
38574: LD_VAR 0 1
38578: DIFF
38579: PPUSH
38580: CALL_OW 1
38584: ST_TO_ADDR
// end ; break ;
38585: GO 38589
// end ;
38587: GO 37457
38589: POP
38590: POP
// end ;
38591: LD_VAR 0 2
38595: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
38596: LD_INT 0
38598: PPUSH
38599: PPUSH
38600: PPUSH
// if not mc_bases or not skirmish then
38601: LD_EXP 56
38605: NOT
38606: PUSH
38607: LD_EXP 54
38611: NOT
38612: OR
38613: IFFALSE 38617
// exit ;
38615: GO 38832
// for i = 1 to mc_bases do
38617: LD_ADDR_VAR 0 3
38621: PUSH
38622: DOUBLE
38623: LD_INT 1
38625: DEC
38626: ST_TO_ADDR
38627: LD_EXP 56
38631: PUSH
38632: FOR_TO
38633: IFFALSE 38830
// begin if building in mc_construct_list [ i ] then
38635: LD_VAR 0 1
38639: PUSH
38640: LD_EXP 63
38644: PUSH
38645: LD_VAR 0 3
38649: ARRAY
38650: IN
38651: IFFALSE 38828
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
38653: LD_ADDR_EXP 63
38657: PUSH
38658: LD_EXP 63
38662: PPUSH
38663: LD_VAR 0 3
38667: PPUSH
38668: LD_EXP 63
38672: PUSH
38673: LD_VAR 0 3
38677: ARRAY
38678: PUSH
38679: LD_VAR 0 1
38683: DIFF
38684: PPUSH
38685: CALL_OW 1
38689: ST_TO_ADDR
// if building in mc_lab [ i ] then
38690: LD_VAR 0 1
38694: PUSH
38695: LD_EXP 89
38699: PUSH
38700: LD_VAR 0 3
38704: ARRAY
38705: IN
38706: IFFALSE 38761
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
38708: LD_ADDR_EXP 90
38712: PUSH
38713: LD_EXP 90
38717: PPUSH
38718: LD_VAR 0 3
38722: PPUSH
38723: LD_EXP 90
38727: PUSH
38728: LD_VAR 0 3
38732: ARRAY
38733: PPUSH
38734: LD_INT 1
38736: PPUSH
38737: LD_EXP 90
38741: PUSH
38742: LD_VAR 0 3
38746: ARRAY
38747: PPUSH
38748: LD_INT 0
38750: PPUSH
38751: CALL 46437 0 4
38755: PPUSH
38756: CALL_OW 1
38760: ST_TO_ADDR
// if not building in mc_bases [ i ] then
38761: LD_VAR 0 1
38765: PUSH
38766: LD_EXP 56
38770: PUSH
38771: LD_VAR 0 3
38775: ARRAY
38776: IN
38777: NOT
38778: IFFALSE 38824
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
38780: LD_ADDR_EXP 56
38784: PUSH
38785: LD_EXP 56
38789: PPUSH
38790: LD_VAR 0 3
38794: PUSH
38795: LD_EXP 56
38799: PUSH
38800: LD_VAR 0 3
38804: ARRAY
38805: PUSH
38806: LD_INT 1
38808: PLUS
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PPUSH
38814: LD_VAR 0 1
38818: PPUSH
38819: CALL 47019 0 3
38823: ST_TO_ADDR
// exit ;
38824: POP
38825: POP
38826: GO 38832
// end ; end ;
38828: GO 38632
38830: POP
38831: POP
// end ;
38832: LD_VAR 0 2
38836: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
38837: LD_INT 0
38839: PPUSH
38840: PPUSH
38841: PPUSH
38842: PPUSH
38843: PPUSH
38844: PPUSH
38845: PPUSH
// if not mc_bases or not skirmish then
38846: LD_EXP 56
38850: NOT
38851: PUSH
38852: LD_EXP 54
38856: NOT
38857: OR
38858: IFFALSE 38862
// exit ;
38860: GO 39523
// for i = 1 to mc_bases do
38862: LD_ADDR_VAR 0 3
38866: PUSH
38867: DOUBLE
38868: LD_INT 1
38870: DEC
38871: ST_TO_ADDR
38872: LD_EXP 56
38876: PUSH
38877: FOR_TO
38878: IFFALSE 39521
// begin if building in mc_construct_list [ i ] then
38880: LD_VAR 0 1
38884: PUSH
38885: LD_EXP 63
38889: PUSH
38890: LD_VAR 0 3
38894: ARRAY
38895: IN
38896: IFFALSE 39519
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
38898: LD_ADDR_EXP 63
38902: PUSH
38903: LD_EXP 63
38907: PPUSH
38908: LD_VAR 0 3
38912: PPUSH
38913: LD_EXP 63
38917: PUSH
38918: LD_VAR 0 3
38922: ARRAY
38923: PUSH
38924: LD_VAR 0 1
38928: DIFF
38929: PPUSH
38930: CALL_OW 1
38934: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
38935: LD_ADDR_EXP 56
38939: PUSH
38940: LD_EXP 56
38944: PPUSH
38945: LD_VAR 0 3
38949: PUSH
38950: LD_EXP 56
38954: PUSH
38955: LD_VAR 0 3
38959: ARRAY
38960: PUSH
38961: LD_INT 1
38963: PLUS
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PPUSH
38969: LD_VAR 0 1
38973: PPUSH
38974: CALL 47019 0 3
38978: ST_TO_ADDR
// btype := GetBType ( building ) ;
38979: LD_ADDR_VAR 0 5
38983: PUSH
38984: LD_VAR 0 1
38988: PPUSH
38989: CALL_OW 266
38993: ST_TO_ADDR
// side := GetSide ( building ) ;
38994: LD_ADDR_VAR 0 8
38998: PUSH
38999: LD_VAR 0 1
39003: PPUSH
39004: CALL_OW 255
39008: ST_TO_ADDR
// if btype = b_lab then
39009: LD_VAR 0 5
39013: PUSH
39014: LD_INT 6
39016: EQUAL
39017: IFFALSE 39067
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
39019: LD_ADDR_EXP 89
39023: PUSH
39024: LD_EXP 89
39028: PPUSH
39029: LD_VAR 0 3
39033: PUSH
39034: LD_EXP 89
39038: PUSH
39039: LD_VAR 0 3
39043: ARRAY
39044: PUSH
39045: LD_INT 1
39047: PLUS
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PPUSH
39053: LD_VAR 0 1
39057: PPUSH
39058: CALL 47019 0 3
39062: ST_TO_ADDR
// exit ;
39063: POP
39064: POP
39065: GO 39523
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
39067: LD_VAR 0 5
39071: PUSH
39072: LD_INT 0
39074: PUSH
39075: LD_INT 2
39077: PUSH
39078: LD_INT 4
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: LIST
39085: IN
39086: IFFALSE 39210
// begin if btype = b_armoury then
39088: LD_VAR 0 5
39092: PUSH
39093: LD_INT 4
39095: EQUAL
39096: IFFALSE 39106
// btype := b_barracks ;
39098: LD_ADDR_VAR 0 5
39102: PUSH
39103: LD_INT 5
39105: ST_TO_ADDR
// if btype = b_depot then
39106: LD_VAR 0 5
39110: PUSH
39111: LD_INT 0
39113: EQUAL
39114: IFFALSE 39124
// btype := b_warehouse ;
39116: LD_ADDR_VAR 0 5
39120: PUSH
39121: LD_INT 1
39123: ST_TO_ADDR
// if btype = b_workshop then
39124: LD_VAR 0 5
39128: PUSH
39129: LD_INT 2
39131: EQUAL
39132: IFFALSE 39142
// btype := b_factory ;
39134: LD_ADDR_VAR 0 5
39138: PUSH
39139: LD_INT 3
39141: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
39142: LD_VAR 0 5
39146: PPUSH
39147: LD_VAR 0 8
39151: PPUSH
39152: CALL_OW 323
39156: PUSH
39157: LD_INT 1
39159: EQUAL
39160: IFFALSE 39206
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
39162: LD_ADDR_EXP 88
39166: PUSH
39167: LD_EXP 88
39171: PPUSH
39172: LD_VAR 0 3
39176: PUSH
39177: LD_EXP 88
39181: PUSH
39182: LD_VAR 0 3
39186: ARRAY
39187: PUSH
39188: LD_INT 1
39190: PLUS
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PPUSH
39196: LD_VAR 0 1
39200: PPUSH
39201: CALL 47019 0 3
39205: ST_TO_ADDR
// exit ;
39206: POP
39207: POP
39208: GO 39523
// end ; if btype in [ b_bunker , b_turret ] then
39210: LD_VAR 0 5
39214: PUSH
39215: LD_INT 32
39217: PUSH
39218: LD_INT 33
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: IN
39225: IFFALSE 39515
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
39227: LD_ADDR_EXP 64
39231: PUSH
39232: LD_EXP 64
39236: PPUSH
39237: LD_VAR 0 3
39241: PUSH
39242: LD_EXP 64
39246: PUSH
39247: LD_VAR 0 3
39251: ARRAY
39252: PUSH
39253: LD_INT 1
39255: PLUS
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PPUSH
39261: LD_VAR 0 1
39265: PPUSH
39266: CALL 47019 0 3
39270: ST_TO_ADDR
// if btype = b_bunker then
39271: LD_VAR 0 5
39275: PUSH
39276: LD_INT 32
39278: EQUAL
39279: IFFALSE 39515
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
39281: LD_ADDR_EXP 65
39285: PUSH
39286: LD_EXP 65
39290: PPUSH
39291: LD_VAR 0 3
39295: PUSH
39296: LD_EXP 65
39300: PUSH
39301: LD_VAR 0 3
39305: ARRAY
39306: PUSH
39307: LD_INT 1
39309: PLUS
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PPUSH
39315: LD_VAR 0 1
39319: PPUSH
39320: CALL 47019 0 3
39324: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
39325: LD_ADDR_VAR 0 6
39329: PUSH
39330: LD_EXP 56
39334: PUSH
39335: LD_VAR 0 3
39339: ARRAY
39340: PPUSH
39341: LD_INT 25
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 3
39353: PUSH
39354: LD_INT 54
39356: PUSH
39357: EMPTY
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PPUSH
39368: CALL_OW 72
39372: ST_TO_ADDR
// if tmp then
39373: LD_VAR 0 6
39377: IFFALSE 39383
// exit ;
39379: POP
39380: POP
39381: GO 39523
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39383: LD_ADDR_VAR 0 6
39387: PUSH
39388: LD_EXP 56
39392: PUSH
39393: LD_VAR 0 3
39397: ARRAY
39398: PPUSH
39399: LD_INT 2
39401: PUSH
39402: LD_INT 30
39404: PUSH
39405: LD_INT 4
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 30
39414: PUSH
39415: LD_INT 5
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: LIST
39426: PPUSH
39427: CALL_OW 72
39431: ST_TO_ADDR
// if not tmp then
39432: LD_VAR 0 6
39436: NOT
39437: IFFALSE 39443
// exit ;
39439: POP
39440: POP
39441: GO 39523
// for j in tmp do
39443: LD_ADDR_VAR 0 4
39447: PUSH
39448: LD_VAR 0 6
39452: PUSH
39453: FOR_IN
39454: IFFALSE 39513
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
39456: LD_ADDR_VAR 0 7
39460: PUSH
39461: LD_VAR 0 4
39465: PPUSH
39466: CALL_OW 313
39470: PPUSH
39471: LD_INT 25
39473: PUSH
39474: LD_INT 1
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PPUSH
39481: CALL_OW 72
39485: ST_TO_ADDR
// if units then
39486: LD_VAR 0 7
39490: IFFALSE 39511
// begin ComExitBuilding ( units [ 1 ] ) ;
39492: LD_VAR 0 7
39496: PUSH
39497: LD_INT 1
39499: ARRAY
39500: PPUSH
39501: CALL_OW 122
// exit ;
39505: POP
39506: POP
39507: POP
39508: POP
39509: GO 39523
// end ; end ;
39511: GO 39453
39513: POP
39514: POP
// end ; end ; exit ;
39515: POP
39516: POP
39517: GO 39523
// end ; end ;
39519: GO 38877
39521: POP
39522: POP
// end ;
39523: LD_VAR 0 2
39527: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
39528: LD_INT 0
39530: PPUSH
39531: PPUSH
39532: PPUSH
39533: PPUSH
39534: PPUSH
39535: PPUSH
39536: PPUSH
// if not mc_bases or not skirmish then
39537: LD_EXP 56
39541: NOT
39542: PUSH
39543: LD_EXP 54
39547: NOT
39548: OR
39549: IFFALSE 39553
// exit ;
39551: GO 39784
// btype := GetBType ( building ) ;
39553: LD_ADDR_VAR 0 6
39557: PUSH
39558: LD_VAR 0 1
39562: PPUSH
39563: CALL_OW 266
39567: ST_TO_ADDR
// x := GetX ( building ) ;
39568: LD_ADDR_VAR 0 7
39572: PUSH
39573: LD_VAR 0 1
39577: PPUSH
39578: CALL_OW 250
39582: ST_TO_ADDR
// y := GetY ( building ) ;
39583: LD_ADDR_VAR 0 8
39587: PUSH
39588: LD_VAR 0 1
39592: PPUSH
39593: CALL_OW 251
39597: ST_TO_ADDR
// d := GetDir ( building ) ;
39598: LD_ADDR_VAR 0 9
39602: PUSH
39603: LD_VAR 0 1
39607: PPUSH
39608: CALL_OW 254
39612: ST_TO_ADDR
// for i = 1 to mc_bases do
39613: LD_ADDR_VAR 0 4
39617: PUSH
39618: DOUBLE
39619: LD_INT 1
39621: DEC
39622: ST_TO_ADDR
39623: LD_EXP 56
39627: PUSH
39628: FOR_TO
39629: IFFALSE 39782
// begin if not mc_build_list [ i ] then
39631: LD_EXP 61
39635: PUSH
39636: LD_VAR 0 4
39640: ARRAY
39641: NOT
39642: IFFALSE 39646
// continue ;
39644: GO 39628
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
39646: LD_VAR 0 6
39650: PUSH
39651: LD_VAR 0 7
39655: PUSH
39656: LD_VAR 0 8
39660: PUSH
39661: LD_VAR 0 9
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: PPUSH
39672: LD_EXP 61
39676: PUSH
39677: LD_VAR 0 4
39681: ARRAY
39682: PUSH
39683: LD_INT 1
39685: ARRAY
39686: PPUSH
39687: CALL 53188 0 2
39691: IFFALSE 39780
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
39693: LD_ADDR_EXP 61
39697: PUSH
39698: LD_EXP 61
39702: PPUSH
39703: LD_VAR 0 4
39707: PPUSH
39708: LD_EXP 61
39712: PUSH
39713: LD_VAR 0 4
39717: ARRAY
39718: PPUSH
39719: LD_INT 1
39721: PPUSH
39722: CALL_OW 3
39726: PPUSH
39727: CALL_OW 1
39731: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
39732: LD_ADDR_EXP 63
39736: PUSH
39737: LD_EXP 63
39741: PPUSH
39742: LD_VAR 0 4
39746: PUSH
39747: LD_EXP 63
39751: PUSH
39752: LD_VAR 0 4
39756: ARRAY
39757: PUSH
39758: LD_INT 1
39760: PLUS
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PPUSH
39766: LD_VAR 0 1
39770: PPUSH
39771: CALL 47019 0 3
39775: ST_TO_ADDR
// exit ;
39776: POP
39777: POP
39778: GO 39784
// end ; end ;
39780: GO 39628
39782: POP
39783: POP
// end ;
39784: LD_VAR 0 3
39788: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
39789: LD_INT 0
39791: PPUSH
39792: PPUSH
39793: PPUSH
// if not mc_bases or not skirmish then
39794: LD_EXP 56
39798: NOT
39799: PUSH
39800: LD_EXP 54
39804: NOT
39805: OR
39806: IFFALSE 39810
// exit ;
39808: GO 40000
// for i = 1 to mc_bases do
39810: LD_ADDR_VAR 0 4
39814: PUSH
39815: DOUBLE
39816: LD_INT 1
39818: DEC
39819: ST_TO_ADDR
39820: LD_EXP 56
39824: PUSH
39825: FOR_TO
39826: IFFALSE 39913
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
39828: LD_VAR 0 1
39832: PUSH
39833: LD_EXP 64
39837: PUSH
39838: LD_VAR 0 4
39842: ARRAY
39843: IN
39844: PUSH
39845: LD_VAR 0 1
39849: PUSH
39850: LD_EXP 65
39854: PUSH
39855: LD_VAR 0 4
39859: ARRAY
39860: IN
39861: NOT
39862: AND
39863: IFFALSE 39911
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
39865: LD_ADDR_EXP 65
39869: PUSH
39870: LD_EXP 65
39874: PPUSH
39875: LD_VAR 0 4
39879: PUSH
39880: LD_EXP 65
39884: PUSH
39885: LD_VAR 0 4
39889: ARRAY
39890: PUSH
39891: LD_INT 1
39893: PLUS
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PPUSH
39899: LD_VAR 0 1
39903: PPUSH
39904: CALL 47019 0 3
39908: ST_TO_ADDR
// break ;
39909: GO 39913
// end ; end ;
39911: GO 39825
39913: POP
39914: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
39915: LD_VAR 0 1
39919: PPUSH
39920: CALL_OW 257
39924: PUSH
39925: LD_EXP 82
39929: IN
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: CALL_OW 266
39940: PUSH
39941: LD_INT 5
39943: EQUAL
39944: AND
39945: PUSH
39946: LD_VAR 0 2
39950: PPUSH
39951: CALL_OW 110
39955: PUSH
39956: LD_INT 18
39958: NONEQUAL
39959: AND
39960: IFFALSE 40000
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
39962: LD_VAR 0 2
39966: PPUSH
39967: CALL_OW 257
39971: PUSH
39972: LD_INT 5
39974: PUSH
39975: LD_INT 8
39977: PUSH
39978: LD_INT 9
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: LIST
39985: IN
39986: IFFALSE 40000
// SetClass ( unit , 1 ) ;
39988: LD_VAR 0 2
39992: PPUSH
39993: LD_INT 1
39995: PPUSH
39996: CALL_OW 336
// end ;
40000: LD_VAR 0 3
40004: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
40005: LD_INT 0
40007: PPUSH
40008: PPUSH
// if not mc_bases or not skirmish then
40009: LD_EXP 56
40013: NOT
40014: PUSH
40015: LD_EXP 54
40019: NOT
40020: OR
40021: IFFALSE 40025
// exit ;
40023: GO 40141
// if GetLives ( abandoned_vehicle ) > 250 then
40025: LD_VAR 0 2
40029: PPUSH
40030: CALL_OW 256
40034: PUSH
40035: LD_INT 250
40037: GREATER
40038: IFFALSE 40042
// exit ;
40040: GO 40141
// for i = 1 to mc_bases do
40042: LD_ADDR_VAR 0 6
40046: PUSH
40047: DOUBLE
40048: LD_INT 1
40050: DEC
40051: ST_TO_ADDR
40052: LD_EXP 56
40056: PUSH
40057: FOR_TO
40058: IFFALSE 40139
// begin if driver in mc_bases [ i ] then
40060: LD_VAR 0 1
40064: PUSH
40065: LD_EXP 56
40069: PUSH
40070: LD_VAR 0 6
40074: ARRAY
40075: IN
40076: IFFALSE 40137
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
40078: LD_VAR 0 1
40082: PPUSH
40083: LD_EXP 56
40087: PUSH
40088: LD_VAR 0 6
40092: ARRAY
40093: PPUSH
40094: LD_INT 2
40096: PUSH
40097: LD_INT 30
40099: PUSH
40100: LD_INT 0
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 30
40109: PUSH
40110: LD_INT 1
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: LIST
40121: PPUSH
40122: CALL_OW 72
40126: PUSH
40127: LD_INT 1
40129: ARRAY
40130: PPUSH
40131: CALL_OW 112
// break ;
40135: GO 40139
// end ; end ;
40137: GO 40057
40139: POP
40140: POP
// end ; end_of_file
40141: LD_VAR 0 5
40145: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
40146: LD_INT 0
40148: PPUSH
40149: PPUSH
// if exist_mode then
40150: LD_VAR 0 2
40154: IFFALSE 40179
// unit := CreateCharacter ( prefix & ident ) else
40156: LD_ADDR_VAR 0 5
40160: PUSH
40161: LD_VAR 0 3
40165: PUSH
40166: LD_VAR 0 1
40170: STR
40171: PPUSH
40172: CALL_OW 34
40176: ST_TO_ADDR
40177: GO 40194
// unit := NewCharacter ( ident ) ;
40179: LD_ADDR_VAR 0 5
40183: PUSH
40184: LD_VAR 0 1
40188: PPUSH
40189: CALL_OW 25
40193: ST_TO_ADDR
// result := unit ;
40194: LD_ADDR_VAR 0 4
40198: PUSH
40199: LD_VAR 0 5
40203: ST_TO_ADDR
// end ;
40204: LD_VAR 0 4
40208: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
40209: LD_INT 0
40211: PPUSH
40212: PPUSH
// if not side or not nation then
40213: LD_VAR 0 1
40217: NOT
40218: PUSH
40219: LD_VAR 0 2
40223: NOT
40224: OR
40225: IFFALSE 40229
// exit ;
40227: GO 40873
// case nation of nation_american :
40229: LD_VAR 0 2
40233: PUSH
40234: LD_INT 1
40236: DOUBLE
40237: EQUAL
40238: IFTRUE 40242
40240: GO 40416
40242: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
40243: LD_ADDR_VAR 0 4
40247: PUSH
40248: LD_INT 35
40250: PUSH
40251: LD_INT 45
40253: PUSH
40254: LD_INT 46
40256: PUSH
40257: LD_INT 47
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: LD_INT 2
40265: PUSH
40266: LD_INT 6
40268: PUSH
40269: LD_INT 15
40271: PUSH
40272: LD_INT 16
40274: PUSH
40275: LD_INT 7
40277: PUSH
40278: LD_INT 12
40280: PUSH
40281: LD_INT 13
40283: PUSH
40284: LD_INT 10
40286: PUSH
40287: LD_INT 14
40289: PUSH
40290: LD_INT 20
40292: PUSH
40293: LD_INT 21
40295: PUSH
40296: LD_INT 22
40298: PUSH
40299: LD_INT 25
40301: PUSH
40302: LD_INT 32
40304: PUSH
40305: LD_INT 27
40307: PUSH
40308: LD_INT 36
40310: PUSH
40311: LD_INT 69
40313: PUSH
40314: LD_INT 39
40316: PUSH
40317: LD_INT 34
40319: PUSH
40320: LD_INT 40
40322: PUSH
40323: LD_INT 48
40325: PUSH
40326: LD_INT 49
40328: PUSH
40329: LD_INT 50
40331: PUSH
40332: LD_INT 51
40334: PUSH
40335: LD_INT 52
40337: PUSH
40338: LD_INT 53
40340: PUSH
40341: LD_INT 54
40343: PUSH
40344: LD_INT 55
40346: PUSH
40347: LD_INT 56
40349: PUSH
40350: LD_INT 57
40352: PUSH
40353: LD_INT 58
40355: PUSH
40356: LD_INT 59
40358: PUSH
40359: LD_INT 60
40361: PUSH
40362: LD_INT 61
40364: PUSH
40365: LD_INT 62
40367: PUSH
40368: LD_INT 80
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: ST_TO_ADDR
40414: GO 40797
40416: LD_INT 2
40418: DOUBLE
40419: EQUAL
40420: IFTRUE 40424
40422: GO 40606
40424: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
40425: LD_ADDR_VAR 0 4
40429: PUSH
40430: LD_INT 35
40432: PUSH
40433: LD_INT 45
40435: PUSH
40436: LD_INT 46
40438: PUSH
40439: LD_INT 47
40441: PUSH
40442: LD_INT 70
40444: PUSH
40445: LD_INT 1
40447: PUSH
40448: LD_INT 11
40450: PUSH
40451: LD_INT 3
40453: PUSH
40454: LD_INT 4
40456: PUSH
40457: LD_INT 5
40459: PUSH
40460: LD_INT 6
40462: PUSH
40463: LD_INT 15
40465: PUSH
40466: LD_INT 18
40468: PUSH
40469: LD_INT 7
40471: PUSH
40472: LD_INT 17
40474: PUSH
40475: LD_INT 8
40477: PUSH
40478: LD_INT 20
40480: PUSH
40481: LD_INT 21
40483: PUSH
40484: LD_INT 22
40486: PUSH
40487: LD_INT 72
40489: PUSH
40490: LD_INT 26
40492: PUSH
40493: LD_INT 69
40495: PUSH
40496: LD_INT 39
40498: PUSH
40499: LD_INT 40
40501: PUSH
40502: LD_INT 41
40504: PUSH
40505: LD_INT 42
40507: PUSH
40508: LD_INT 43
40510: PUSH
40511: LD_INT 48
40513: PUSH
40514: LD_INT 49
40516: PUSH
40517: LD_INT 50
40519: PUSH
40520: LD_INT 51
40522: PUSH
40523: LD_INT 52
40525: PUSH
40526: LD_INT 53
40528: PUSH
40529: LD_INT 54
40531: PUSH
40532: LD_INT 55
40534: PUSH
40535: LD_INT 56
40537: PUSH
40538: LD_INT 60
40540: PUSH
40541: LD_INT 61
40543: PUSH
40544: LD_INT 62
40546: PUSH
40547: LD_INT 66
40549: PUSH
40550: LD_INT 67
40552: PUSH
40553: LD_INT 68
40555: PUSH
40556: LD_INT 81
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: ST_TO_ADDR
40604: GO 40797
40606: LD_INT 3
40608: DOUBLE
40609: EQUAL
40610: IFTRUE 40614
40612: GO 40796
40614: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
40615: LD_ADDR_VAR 0 4
40619: PUSH
40620: LD_INT 46
40622: PUSH
40623: LD_INT 47
40625: PUSH
40626: LD_INT 1
40628: PUSH
40629: LD_INT 2
40631: PUSH
40632: LD_INT 11
40634: PUSH
40635: LD_INT 9
40637: PUSH
40638: LD_INT 20
40640: PUSH
40641: LD_INT 19
40643: PUSH
40644: LD_INT 21
40646: PUSH
40647: LD_INT 24
40649: PUSH
40650: LD_INT 22
40652: PUSH
40653: LD_INT 25
40655: PUSH
40656: LD_INT 28
40658: PUSH
40659: LD_INT 29
40661: PUSH
40662: LD_INT 30
40664: PUSH
40665: LD_INT 31
40667: PUSH
40668: LD_INT 37
40670: PUSH
40671: LD_INT 38
40673: PUSH
40674: LD_INT 32
40676: PUSH
40677: LD_INT 27
40679: PUSH
40680: LD_INT 33
40682: PUSH
40683: LD_INT 69
40685: PUSH
40686: LD_INT 39
40688: PUSH
40689: LD_INT 34
40691: PUSH
40692: LD_INT 40
40694: PUSH
40695: LD_INT 71
40697: PUSH
40698: LD_INT 23
40700: PUSH
40701: LD_INT 44
40703: PUSH
40704: LD_INT 48
40706: PUSH
40707: LD_INT 49
40709: PUSH
40710: LD_INT 50
40712: PUSH
40713: LD_INT 51
40715: PUSH
40716: LD_INT 52
40718: PUSH
40719: LD_INT 53
40721: PUSH
40722: LD_INT 54
40724: PUSH
40725: LD_INT 55
40727: PUSH
40728: LD_INT 56
40730: PUSH
40731: LD_INT 57
40733: PUSH
40734: LD_INT 58
40736: PUSH
40737: LD_INT 59
40739: PUSH
40740: LD_INT 63
40742: PUSH
40743: LD_INT 64
40745: PUSH
40746: LD_INT 65
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: LIST
40766: LIST
40767: LIST
40768: LIST
40769: LIST
40770: LIST
40771: LIST
40772: LIST
40773: LIST
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: LIST
40789: LIST
40790: LIST
40791: LIST
40792: LIST
40793: ST_TO_ADDR
40794: GO 40797
40796: POP
// if state > - 1 and state < 3 then
40797: LD_VAR 0 3
40801: PUSH
40802: LD_INT 1
40804: NEG
40805: GREATER
40806: PUSH
40807: LD_VAR 0 3
40811: PUSH
40812: LD_INT 3
40814: LESS
40815: AND
40816: IFFALSE 40873
// for i in result do
40818: LD_ADDR_VAR 0 5
40822: PUSH
40823: LD_VAR 0 4
40827: PUSH
40828: FOR_IN
40829: IFFALSE 40871
// if GetTech ( i , side ) <> state then
40831: LD_VAR 0 5
40835: PPUSH
40836: LD_VAR 0 1
40840: PPUSH
40841: CALL_OW 321
40845: PUSH
40846: LD_VAR 0 3
40850: NONEQUAL
40851: IFFALSE 40869
// result := result diff i ;
40853: LD_ADDR_VAR 0 4
40857: PUSH
40858: LD_VAR 0 4
40862: PUSH
40863: LD_VAR 0 5
40867: DIFF
40868: ST_TO_ADDR
40869: GO 40828
40871: POP
40872: POP
// end ;
40873: LD_VAR 0 4
40877: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
40878: LD_INT 0
40880: PPUSH
40881: PPUSH
40882: PPUSH
// result := true ;
40883: LD_ADDR_VAR 0 3
40887: PUSH
40888: LD_INT 1
40890: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
40891: LD_ADDR_VAR 0 5
40895: PUSH
40896: LD_VAR 0 2
40900: PPUSH
40901: CALL_OW 480
40905: ST_TO_ADDR
// if not tmp then
40906: LD_VAR 0 5
40910: NOT
40911: IFFALSE 40915
// exit ;
40913: GO 40964
// for i in tmp do
40915: LD_ADDR_VAR 0 4
40919: PUSH
40920: LD_VAR 0 5
40924: PUSH
40925: FOR_IN
40926: IFFALSE 40962
// if GetTech ( i , side ) <> state_researched then
40928: LD_VAR 0 4
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: CALL_OW 321
40942: PUSH
40943: LD_INT 2
40945: NONEQUAL
40946: IFFALSE 40960
// begin result := false ;
40948: LD_ADDR_VAR 0 3
40952: PUSH
40953: LD_INT 0
40955: ST_TO_ADDR
// exit ;
40956: POP
40957: POP
40958: GO 40964
// end ;
40960: GO 40925
40962: POP
40963: POP
// end ;
40964: LD_VAR 0 3
40968: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
40969: LD_INT 0
40971: PPUSH
40972: PPUSH
40973: PPUSH
40974: PPUSH
40975: PPUSH
40976: PPUSH
40977: PPUSH
40978: PPUSH
40979: PPUSH
40980: PPUSH
40981: PPUSH
40982: PPUSH
40983: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
40984: LD_VAR 0 1
40988: NOT
40989: PUSH
40990: LD_VAR 0 1
40994: PPUSH
40995: CALL_OW 257
40999: PUSH
41000: LD_INT 9
41002: NONEQUAL
41003: OR
41004: IFFALSE 41008
// exit ;
41006: GO 41581
// side := GetSide ( unit ) ;
41008: LD_ADDR_VAR 0 9
41012: PUSH
41013: LD_VAR 0 1
41017: PPUSH
41018: CALL_OW 255
41022: ST_TO_ADDR
// tech_space := tech_spacanom ;
41023: LD_ADDR_VAR 0 12
41027: PUSH
41028: LD_INT 29
41030: ST_TO_ADDR
// tech_time := tech_taurad ;
41031: LD_ADDR_VAR 0 13
41035: PUSH
41036: LD_INT 28
41038: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
41039: LD_ADDR_VAR 0 11
41043: PUSH
41044: LD_VAR 0 1
41048: PPUSH
41049: CALL_OW 310
41053: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
41054: LD_VAR 0 11
41058: PPUSH
41059: CALL_OW 247
41063: PUSH
41064: LD_INT 2
41066: EQUAL
41067: IFFALSE 41071
// exit ;
41069: GO 41581
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
41071: LD_ADDR_VAR 0 8
41075: PUSH
41076: LD_INT 81
41078: PUSH
41079: LD_VAR 0 9
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: LD_INT 3
41090: PUSH
41091: LD_INT 21
41093: PUSH
41094: LD_INT 3
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PPUSH
41109: CALL_OW 69
41113: ST_TO_ADDR
// if not tmp then
41114: LD_VAR 0 8
41118: NOT
41119: IFFALSE 41123
// exit ;
41121: GO 41581
// if in_unit then
41123: LD_VAR 0 11
41127: IFFALSE 41151
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
41129: LD_ADDR_VAR 0 10
41133: PUSH
41134: LD_VAR 0 8
41138: PPUSH
41139: LD_VAR 0 11
41143: PPUSH
41144: CALL_OW 74
41148: ST_TO_ADDR
41149: GO 41171
// enemy := NearestUnitToUnit ( tmp , unit ) ;
41151: LD_ADDR_VAR 0 10
41155: PUSH
41156: LD_VAR 0 8
41160: PPUSH
41161: LD_VAR 0 1
41165: PPUSH
41166: CALL_OW 74
41170: ST_TO_ADDR
// if not enemy then
41171: LD_VAR 0 10
41175: NOT
41176: IFFALSE 41180
// exit ;
41178: GO 41581
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
41180: LD_VAR 0 11
41184: PUSH
41185: LD_VAR 0 11
41189: PPUSH
41190: LD_VAR 0 10
41194: PPUSH
41195: CALL_OW 296
41199: PUSH
41200: LD_INT 13
41202: GREATER
41203: AND
41204: PUSH
41205: LD_VAR 0 1
41209: PPUSH
41210: LD_VAR 0 10
41214: PPUSH
41215: CALL_OW 296
41219: PUSH
41220: LD_INT 12
41222: GREATER
41223: OR
41224: IFFALSE 41228
// exit ;
41226: GO 41581
// missile := [ 1 ] ;
41228: LD_ADDR_VAR 0 14
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: EMPTY
41237: LIST
41238: ST_TO_ADDR
// if Researched ( side , tech_space ) then
41239: LD_VAR 0 9
41243: PPUSH
41244: LD_VAR 0 12
41248: PPUSH
41249: CALL_OW 325
41253: IFFALSE 41282
// missile := Insert ( missile , missile + 1 , 2 ) ;
41255: LD_ADDR_VAR 0 14
41259: PUSH
41260: LD_VAR 0 14
41264: PPUSH
41265: LD_VAR 0 14
41269: PUSH
41270: LD_INT 1
41272: PLUS
41273: PPUSH
41274: LD_INT 2
41276: PPUSH
41277: CALL_OW 2
41281: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
41282: LD_VAR 0 9
41286: PPUSH
41287: LD_VAR 0 13
41291: PPUSH
41292: CALL_OW 325
41296: PUSH
41297: LD_VAR 0 10
41301: PPUSH
41302: CALL_OW 255
41306: PPUSH
41307: LD_VAR 0 13
41311: PPUSH
41312: CALL_OW 325
41316: NOT
41317: AND
41318: IFFALSE 41347
// missile := Insert ( missile , missile + 1 , 3 ) ;
41320: LD_ADDR_VAR 0 14
41324: PUSH
41325: LD_VAR 0 14
41329: PPUSH
41330: LD_VAR 0 14
41334: PUSH
41335: LD_INT 1
41337: PLUS
41338: PPUSH
41339: LD_INT 3
41341: PPUSH
41342: CALL_OW 2
41346: ST_TO_ADDR
// if missile < 2 then
41347: LD_VAR 0 14
41351: PUSH
41352: LD_INT 2
41354: LESS
41355: IFFALSE 41359
// exit ;
41357: GO 41581
// x := GetX ( enemy ) ;
41359: LD_ADDR_VAR 0 4
41363: PUSH
41364: LD_VAR 0 10
41368: PPUSH
41369: CALL_OW 250
41373: ST_TO_ADDR
// y := GetY ( enemy ) ;
41374: LD_ADDR_VAR 0 5
41378: PUSH
41379: LD_VAR 0 10
41383: PPUSH
41384: CALL_OW 251
41388: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
41389: LD_ADDR_VAR 0 6
41393: PUSH
41394: LD_VAR 0 4
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PPUSH
41403: LD_INT 1
41405: PPUSH
41406: CALL_OW 12
41410: PLUS
41411: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
41412: LD_ADDR_VAR 0 7
41416: PUSH
41417: LD_VAR 0 5
41421: PUSH
41422: LD_INT 1
41424: NEG
41425: PPUSH
41426: LD_INT 1
41428: PPUSH
41429: CALL_OW 12
41433: PLUS
41434: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
41435: LD_VAR 0 6
41439: PPUSH
41440: LD_VAR 0 7
41444: PPUSH
41445: CALL_OW 488
41449: NOT
41450: IFFALSE 41472
// begin _x := x ;
41452: LD_ADDR_VAR 0 6
41456: PUSH
41457: LD_VAR 0 4
41461: ST_TO_ADDR
// _y := y ;
41462: LD_ADDR_VAR 0 7
41466: PUSH
41467: LD_VAR 0 5
41471: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
41472: LD_ADDR_VAR 0 3
41476: PUSH
41477: LD_INT 1
41479: PPUSH
41480: LD_VAR 0 14
41484: PPUSH
41485: CALL_OW 12
41489: ST_TO_ADDR
// case i of 1 :
41490: LD_VAR 0 3
41494: PUSH
41495: LD_INT 1
41497: DOUBLE
41498: EQUAL
41499: IFTRUE 41503
41501: GO 41520
41503: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
41504: LD_VAR 0 1
41508: PPUSH
41509: LD_VAR 0 10
41513: PPUSH
41514: CALL_OW 115
41518: GO 41581
41520: LD_INT 2
41522: DOUBLE
41523: EQUAL
41524: IFTRUE 41528
41526: GO 41550
41528: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
41529: LD_VAR 0 1
41533: PPUSH
41534: LD_VAR 0 6
41538: PPUSH
41539: LD_VAR 0 7
41543: PPUSH
41544: CALL_OW 153
41548: GO 41581
41550: LD_INT 3
41552: DOUBLE
41553: EQUAL
41554: IFTRUE 41558
41556: GO 41580
41558: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
41559: LD_VAR 0 1
41563: PPUSH
41564: LD_VAR 0 6
41568: PPUSH
41569: LD_VAR 0 7
41573: PPUSH
41574: CALL_OW 154
41578: GO 41581
41580: POP
// end ;
41581: LD_VAR 0 2
41585: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
41586: LD_INT 0
41588: PPUSH
41589: PPUSH
41590: PPUSH
41591: PPUSH
41592: PPUSH
41593: PPUSH
// if not unit or not building then
41594: LD_VAR 0 1
41598: NOT
41599: PUSH
41600: LD_VAR 0 2
41604: NOT
41605: OR
41606: IFFALSE 41610
// exit ;
41608: GO 41768
// x := GetX ( building ) ;
41610: LD_ADDR_VAR 0 5
41614: PUSH
41615: LD_VAR 0 2
41619: PPUSH
41620: CALL_OW 250
41624: ST_TO_ADDR
// y := GetY ( building ) ;
41625: LD_ADDR_VAR 0 6
41629: PUSH
41630: LD_VAR 0 2
41634: PPUSH
41635: CALL_OW 251
41639: ST_TO_ADDR
// for i = 0 to 5 do
41640: LD_ADDR_VAR 0 4
41644: PUSH
41645: DOUBLE
41646: LD_INT 0
41648: DEC
41649: ST_TO_ADDR
41650: LD_INT 5
41652: PUSH
41653: FOR_TO
41654: IFFALSE 41766
// begin _x := ShiftX ( x , i , 3 ) ;
41656: LD_ADDR_VAR 0 7
41660: PUSH
41661: LD_VAR 0 5
41665: PPUSH
41666: LD_VAR 0 4
41670: PPUSH
41671: LD_INT 3
41673: PPUSH
41674: CALL_OW 272
41678: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
41679: LD_ADDR_VAR 0 8
41683: PUSH
41684: LD_VAR 0 6
41688: PPUSH
41689: LD_VAR 0 4
41693: PPUSH
41694: LD_INT 3
41696: PPUSH
41697: CALL_OW 273
41701: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
41702: LD_VAR 0 7
41706: PPUSH
41707: LD_VAR 0 8
41711: PPUSH
41712: CALL_OW 488
41716: NOT
41717: IFFALSE 41721
// continue ;
41719: GO 41653
// if HexInfo ( _x , _y ) = 0 then
41721: LD_VAR 0 7
41725: PPUSH
41726: LD_VAR 0 8
41730: PPUSH
41731: CALL_OW 428
41735: PUSH
41736: LD_INT 0
41738: EQUAL
41739: IFFALSE 41764
// begin ComMoveXY ( unit , _x , _y ) ;
41741: LD_VAR 0 1
41745: PPUSH
41746: LD_VAR 0 7
41750: PPUSH
41751: LD_VAR 0 8
41755: PPUSH
41756: CALL_OW 111
// exit ;
41760: POP
41761: POP
41762: GO 41768
// end ; end ;
41764: GO 41653
41766: POP
41767: POP
// end ;
41768: LD_VAR 0 3
41772: RET
// export function ScanBase ( side , base_area ) ; begin
41773: LD_INT 0
41775: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
41776: LD_ADDR_VAR 0 3
41780: PUSH
41781: LD_VAR 0 2
41785: PPUSH
41786: LD_INT 81
41788: PUSH
41789: LD_VAR 0 1
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PPUSH
41798: CALL_OW 70
41802: ST_TO_ADDR
// end ;
41803: LD_VAR 0 3
41807: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
41808: LD_INT 0
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
41814: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
41815: LD_VAR 0 1
41819: NOT
41820: PUSH
41821: LD_EXP 56
41825: PUSH
41826: LD_VAR 0 1
41830: ARRAY
41831: NOT
41832: OR
41833: PUSH
41834: LD_VAR 0 2
41838: NOT
41839: OR
41840: PUSH
41841: LD_VAR 0 3
41845: NOT
41846: OR
41847: IFFALSE 41851
// exit ;
41849: GO 42301
// side := mc_sides [ base ] ;
41851: LD_ADDR_VAR 0 6
41855: PUSH
41856: LD_EXP 82
41860: PUSH
41861: LD_VAR 0 1
41865: ARRAY
41866: ST_TO_ADDR
// if not side then
41867: LD_VAR 0 6
41871: NOT
41872: IFFALSE 41876
// exit ;
41874: GO 42301
// for i in solds do
41876: LD_ADDR_VAR 0 7
41880: PUSH
41881: LD_VAR 0 2
41885: PUSH
41886: FOR_IN
41887: IFFALSE 41948
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
41889: LD_VAR 0 7
41893: PPUSH
41894: CALL_OW 310
41898: PPUSH
41899: CALL_OW 266
41903: PUSH
41904: LD_INT 32
41906: PUSH
41907: LD_INT 31
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: IN
41914: IFFALSE 41934
// solds := solds diff i else
41916: LD_ADDR_VAR 0 2
41920: PUSH
41921: LD_VAR 0 2
41925: PUSH
41926: LD_VAR 0 7
41930: DIFF
41931: ST_TO_ADDR
41932: GO 41946
// SetTag ( i , 18 ) ;
41934: LD_VAR 0 7
41938: PPUSH
41939: LD_INT 18
41941: PPUSH
41942: CALL_OW 109
41946: GO 41886
41948: POP
41949: POP
// if not solds then
41950: LD_VAR 0 2
41954: NOT
41955: IFFALSE 41959
// exit ;
41957: GO 42301
// repeat wait ( 0 0$1 ) ;
41959: LD_INT 35
41961: PPUSH
41962: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
41966: LD_ADDR_VAR 0 5
41970: PUSH
41971: LD_VAR 0 6
41975: PPUSH
41976: LD_VAR 0 3
41980: PPUSH
41981: CALL 41773 0 2
41985: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
41986: LD_VAR 0 5
41990: NOT
41991: PUSH
41992: LD_VAR 0 5
41996: PUSH
41997: LD_INT 3
41999: GREATER
42000: OR
42001: PUSH
42002: LD_EXP 78
42006: PUSH
42007: LD_VAR 0 1
42011: ARRAY
42012: OR
42013: IFFALSE 42054
// begin for i in solds do
42015: LD_ADDR_VAR 0 7
42019: PUSH
42020: LD_VAR 0 2
42024: PUSH
42025: FOR_IN
42026: IFFALSE 42050
// if HasTask ( i ) then
42028: LD_VAR 0 7
42032: PPUSH
42033: CALL_OW 314
42037: IFFALSE 42048
// ComStop ( i ) ;
42039: LD_VAR 0 7
42043: PPUSH
42044: CALL_OW 141
42048: GO 42025
42050: POP
42051: POP
// break ;
42052: GO 42289
// end ; for i in solds do
42054: LD_ADDR_VAR 0 7
42058: PUSH
42059: LD_VAR 0 2
42063: PUSH
42064: FOR_IN
42065: IFFALSE 42281
// begin if IsInUnit ( i ) then
42067: LD_VAR 0 7
42071: PPUSH
42072: CALL_OW 310
42076: IFFALSE 42087
// ComExitBuilding ( i ) ;
42078: LD_VAR 0 7
42082: PPUSH
42083: CALL_OW 122
// if GetLives ( i ) > 333 then
42087: LD_VAR 0 7
42091: PPUSH
42092: CALL_OW 256
42096: PUSH
42097: LD_INT 333
42099: GREATER
42100: IFFALSE 42128
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
42102: LD_VAR 0 7
42106: PPUSH
42107: LD_VAR 0 5
42111: PPUSH
42112: LD_VAR 0 7
42116: PPUSH
42117: CALL_OW 74
42121: PPUSH
42122: CALL_OW 115
42126: GO 42279
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
42128: LD_ADDR_VAR 0 8
42132: PUSH
42133: LD_EXP 56
42137: PUSH
42138: LD_VAR 0 1
42142: ARRAY
42143: PPUSH
42144: LD_INT 2
42146: PUSH
42147: LD_INT 30
42149: PUSH
42150: LD_INT 0
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 30
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 30
42169: PUSH
42170: LD_INT 6
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: PPUSH
42183: CALL_OW 72
42187: PPUSH
42188: LD_VAR 0 7
42192: PPUSH
42193: CALL_OW 74
42197: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
42198: LD_VAR 0 7
42202: PPUSH
42203: LD_VAR 0 8
42207: PPUSH
42208: CALL_OW 250
42212: PPUSH
42213: LD_INT 3
42215: PPUSH
42216: LD_INT 5
42218: PPUSH
42219: CALL_OW 272
42223: PPUSH
42224: LD_VAR 0 8
42228: PPUSH
42229: CALL_OW 251
42233: PPUSH
42234: LD_INT 3
42236: PPUSH
42237: LD_INT 5
42239: PPUSH
42240: CALL_OW 273
42244: PPUSH
42245: CALL_OW 111
// SetTag ( i , 0 ) ;
42249: LD_VAR 0 7
42253: PPUSH
42254: LD_INT 0
42256: PPUSH
42257: CALL_OW 109
// solds := solds diff i ;
42261: LD_ADDR_VAR 0 2
42265: PUSH
42266: LD_VAR 0 2
42270: PUSH
42271: LD_VAR 0 7
42275: DIFF
42276: ST_TO_ADDR
// continue ;
42277: GO 42064
// end ; end ;
42279: GO 42064
42281: POP
42282: POP
// until solds ;
42283: LD_VAR 0 2
42287: IFFALSE 41959
// MC_Reset ( base , 18 ) ;
42289: LD_VAR 0 1
42293: PPUSH
42294: LD_INT 18
42296: PPUSH
42297: CALL 14519 0 2
// end ;
42301: LD_VAR 0 4
42305: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
42306: LD_INT 0
42308: PPUSH
42309: PPUSH
42310: PPUSH
42311: PPUSH
42312: PPUSH
42313: PPUSH
42314: PPUSH
42315: PPUSH
42316: PPUSH
42317: PPUSH
42318: PPUSH
42319: PPUSH
42320: PPUSH
42321: PPUSH
42322: PPUSH
42323: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
42324: LD_ADDR_VAR 0 12
42328: PUSH
42329: LD_EXP 56
42333: PUSH
42334: LD_VAR 0 1
42338: ARRAY
42339: PPUSH
42340: LD_INT 25
42342: PUSH
42343: LD_INT 3
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PPUSH
42350: CALL_OW 72
42354: ST_TO_ADDR
// if mc_remote_driver [ base ] then
42355: LD_EXP 96
42359: PUSH
42360: LD_VAR 0 1
42364: ARRAY
42365: IFFALSE 42389
// mechs := mechs diff mc_remote_driver [ base ] ;
42367: LD_ADDR_VAR 0 12
42371: PUSH
42372: LD_VAR 0 12
42376: PUSH
42377: LD_EXP 96
42381: PUSH
42382: LD_VAR 0 1
42386: ARRAY
42387: DIFF
42388: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42389: LD_ADDR_VAR 0 8
42393: PUSH
42394: LD_EXP 56
42398: PUSH
42399: LD_VAR 0 1
42403: ARRAY
42404: PPUSH
42405: LD_INT 2
42407: PUSH
42408: LD_INT 25
42410: PUSH
42411: LD_INT 1
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 25
42420: PUSH
42421: LD_INT 5
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 25
42430: PUSH
42431: LD_INT 8
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 25
42440: PUSH
42441: LD_INT 9
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: PPUSH
42455: CALL_OW 72
42459: ST_TO_ADDR
// if not defenders and not solds then
42460: LD_VAR 0 2
42464: NOT
42465: PUSH
42466: LD_VAR 0 8
42470: NOT
42471: AND
42472: IFFALSE 42476
// exit ;
42474: GO 43850
// depot_under_attack := false ;
42476: LD_ADDR_VAR 0 16
42480: PUSH
42481: LD_INT 0
42483: ST_TO_ADDR
// sold_defenders := [ ] ;
42484: LD_ADDR_VAR 0 17
42488: PUSH
42489: EMPTY
42490: ST_TO_ADDR
// if mechs then
42491: LD_VAR 0 12
42495: IFFALSE 42624
// for i in defenders do
42497: LD_ADDR_VAR 0 5
42501: PUSH
42502: LD_VAR 0 2
42506: PUSH
42507: FOR_IN
42508: IFFALSE 42622
// begin SetTag ( i , 20 ) ;
42510: LD_VAR 0 5
42514: PPUSH
42515: LD_INT 20
42517: PPUSH
42518: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
42522: LD_VAR 0 5
42526: PPUSH
42527: CALL_OW 263
42531: PUSH
42532: LD_INT 1
42534: EQUAL
42535: PUSH
42536: LD_VAR 0 5
42540: PPUSH
42541: CALL_OW 311
42545: NOT
42546: AND
42547: PUSH
42548: LD_VAR 0 12
42552: AND
42553: IFFALSE 42620
// begin un := mechs [ 1 ] ;
42555: LD_ADDR_VAR 0 10
42559: PUSH
42560: LD_VAR 0 12
42564: PUSH
42565: LD_INT 1
42567: ARRAY
42568: ST_TO_ADDR
// ComExitBuilding ( un ) ;
42569: LD_VAR 0 10
42573: PPUSH
42574: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
42578: LD_VAR 0 10
42582: PPUSH
42583: LD_VAR 0 5
42587: PPUSH
42588: CALL_OW 180
// SetTag ( un , 19 ) ;
42592: LD_VAR 0 10
42596: PPUSH
42597: LD_INT 19
42599: PPUSH
42600: CALL_OW 109
// mechs := mechs diff un ;
42604: LD_ADDR_VAR 0 12
42608: PUSH
42609: LD_VAR 0 12
42613: PUSH
42614: LD_VAR 0 10
42618: DIFF
42619: ST_TO_ADDR
// end ; end ;
42620: GO 42507
42622: POP
42623: POP
// if solds then
42624: LD_VAR 0 8
42628: IFFALSE 42687
// for i in solds do
42630: LD_ADDR_VAR 0 5
42634: PUSH
42635: LD_VAR 0 8
42639: PUSH
42640: FOR_IN
42641: IFFALSE 42685
// if not GetTag ( i ) then
42643: LD_VAR 0 5
42647: PPUSH
42648: CALL_OW 110
42652: NOT
42653: IFFALSE 42683
// begin defenders := defenders union i ;
42655: LD_ADDR_VAR 0 2
42659: PUSH
42660: LD_VAR 0 2
42664: PUSH
42665: LD_VAR 0 5
42669: UNION
42670: ST_TO_ADDR
// SetTag ( i , 18 ) ;
42671: LD_VAR 0 5
42675: PPUSH
42676: LD_INT 18
42678: PPUSH
42679: CALL_OW 109
// end ;
42683: GO 42640
42685: POP
42686: POP
// repeat wait ( 0 0$1 ) ;
42687: LD_INT 35
42689: PPUSH
42690: CALL_OW 67
// enemy := mc_scan [ base ] ;
42694: LD_ADDR_VAR 0 3
42698: PUSH
42699: LD_EXP 79
42703: PUSH
42704: LD_VAR 0 1
42708: ARRAY
42709: ST_TO_ADDR
// for i in defenders do
42710: LD_ADDR_VAR 0 5
42714: PUSH
42715: LD_VAR 0 2
42719: PUSH
42720: FOR_IN
42721: IFFALSE 43451
// begin e := NearestUnitToUnit ( enemy , i ) ;
42723: LD_ADDR_VAR 0 13
42727: PUSH
42728: LD_VAR 0 3
42732: PPUSH
42733: LD_VAR 0 5
42737: PPUSH
42738: CALL_OW 74
42742: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
42743: LD_ADDR_VAR 0 16
42747: PUSH
42748: LD_EXP 56
42752: PUSH
42753: LD_VAR 0 1
42757: ARRAY
42758: PPUSH
42759: LD_INT 2
42761: PUSH
42762: LD_INT 30
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 30
42774: PUSH
42775: LD_INT 1
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: LIST
42786: PPUSH
42787: CALL_OW 72
42791: NOT
42792: PUSH
42793: LD_EXP 56
42797: PUSH
42798: LD_VAR 0 1
42802: ARRAY
42803: PPUSH
42804: LD_INT 2
42806: PUSH
42807: LD_INT 30
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 30
42819: PUSH
42820: LD_INT 1
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: LIST
42831: PPUSH
42832: CALL_OW 72
42836: PPUSH
42837: CALL_OW 256
42841: PUSH
42842: LD_INT 600
42844: LESS
42845: OR
42846: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
42847: LD_VAR 0 5
42851: PPUSH
42852: CALL_OW 247
42856: PUSH
42857: LD_INT 2
42859: DOUBLE
42860: EQUAL
42861: IFTRUE 42865
42863: GO 43157
42865: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
42866: LD_VAR 0 5
42870: PPUSH
42871: CALL_OW 256
42875: PUSH
42876: LD_INT 650
42878: GREATER
42879: PUSH
42880: LD_VAR 0 5
42884: PPUSH
42885: LD_VAR 0 13
42889: PPUSH
42890: CALL_OW 296
42894: PUSH
42895: LD_INT 40
42897: LESS
42898: PUSH
42899: LD_VAR 0 13
42903: PPUSH
42904: LD_EXP 81
42908: PUSH
42909: LD_VAR 0 1
42913: ARRAY
42914: PPUSH
42915: CALL_OW 308
42919: OR
42920: AND
42921: IFFALSE 42939
// ComAttackUnit ( i , e ) else
42923: LD_VAR 0 5
42927: PPUSH
42928: LD_VAR 0 13
42932: PPUSH
42933: CALL_OW 115
42937: GO 43040
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
42939: LD_VAR 0 13
42943: PPUSH
42944: LD_EXP 81
42948: PUSH
42949: LD_VAR 0 1
42953: ARRAY
42954: PPUSH
42955: CALL_OW 308
42959: NOT
42960: PUSH
42961: LD_VAR 0 5
42965: PPUSH
42966: LD_VAR 0 13
42970: PPUSH
42971: CALL_OW 296
42975: PUSH
42976: LD_INT 40
42978: GREATEREQUAL
42979: AND
42980: PUSH
42981: LD_VAR 0 5
42985: PPUSH
42986: CALL_OW 256
42990: PUSH
42991: LD_INT 650
42993: LESSEQUAL
42994: OR
42995: PUSH
42996: LD_VAR 0 5
43000: PPUSH
43001: LD_EXP 80
43005: PUSH
43006: LD_VAR 0 1
43010: ARRAY
43011: PPUSH
43012: CALL_OW 308
43016: NOT
43017: AND
43018: IFFALSE 43040
// ComMoveToArea ( i , mc_parking [ base ] ) ;
43020: LD_VAR 0 5
43024: PPUSH
43025: LD_EXP 80
43029: PUSH
43030: LD_VAR 0 1
43034: ARRAY
43035: PPUSH
43036: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
43040: LD_VAR 0 5
43044: PPUSH
43045: CALL_OW 256
43049: PUSH
43050: LD_INT 998
43052: LESS
43053: PUSH
43054: LD_VAR 0 5
43058: PPUSH
43059: CALL_OW 263
43063: PUSH
43064: LD_INT 1
43066: EQUAL
43067: AND
43068: PUSH
43069: LD_VAR 0 5
43073: PPUSH
43074: CALL_OW 311
43078: AND
43079: PUSH
43080: LD_VAR 0 5
43084: PPUSH
43085: LD_EXP 80
43089: PUSH
43090: LD_VAR 0 1
43094: ARRAY
43095: PPUSH
43096: CALL_OW 308
43100: AND
43101: IFFALSE 43155
// begin mech := IsDrivenBy ( i ) ;
43103: LD_ADDR_VAR 0 9
43107: PUSH
43108: LD_VAR 0 5
43112: PPUSH
43113: CALL_OW 311
43117: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
43118: LD_VAR 0 9
43122: PPUSH
43123: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
43127: LD_VAR 0 9
43131: PPUSH
43132: LD_VAR 0 5
43136: PPUSH
43137: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
43141: LD_VAR 0 9
43145: PPUSH
43146: LD_VAR 0 5
43150: PPUSH
43151: CALL_OW 180
// end ; end ; unit_human :
43155: GO 43422
43157: LD_INT 1
43159: DOUBLE
43160: EQUAL
43161: IFTRUE 43165
43163: GO 43421
43165: POP
// begin b := IsInUnit ( i ) ;
43166: LD_ADDR_VAR 0 18
43170: PUSH
43171: LD_VAR 0 5
43175: PPUSH
43176: CALL_OW 310
43180: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
43181: LD_ADDR_VAR 0 19
43185: PUSH
43186: LD_VAR 0 18
43190: NOT
43191: PUSH
43192: LD_VAR 0 18
43196: PPUSH
43197: CALL_OW 266
43201: PUSH
43202: LD_INT 32
43204: PUSH
43205: LD_INT 31
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: IN
43212: OR
43213: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
43214: LD_VAR 0 16
43218: PUSH
43219: LD_VAR 0 2
43223: PPUSH
43224: LD_INT 21
43226: PUSH
43227: LD_INT 2
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PPUSH
43234: CALL_OW 72
43238: PUSH
43239: LD_INT 1
43241: LESSEQUAL
43242: OR
43243: PUSH
43244: LD_VAR 0 19
43248: AND
43249: PUSH
43250: LD_VAR 0 5
43254: PUSH
43255: LD_VAR 0 17
43259: IN
43260: NOT
43261: AND
43262: IFFALSE 43355
// begin if b then
43264: LD_VAR 0 18
43268: IFFALSE 43317
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
43270: LD_VAR 0 18
43274: PPUSH
43275: LD_VAR 0 3
43279: PPUSH
43280: LD_VAR 0 18
43284: PPUSH
43285: CALL_OW 74
43289: PPUSH
43290: CALL_OW 296
43294: PUSH
43295: LD_INT 10
43297: LESS
43298: PUSH
43299: LD_VAR 0 18
43303: PPUSH
43304: CALL_OW 461
43308: PUSH
43309: LD_INT 7
43311: NONEQUAL
43312: AND
43313: IFFALSE 43317
// continue ;
43315: GO 42720
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
43317: LD_ADDR_VAR 0 17
43321: PUSH
43322: LD_VAR 0 17
43326: PPUSH
43327: LD_VAR 0 17
43331: PUSH
43332: LD_INT 1
43334: PLUS
43335: PPUSH
43336: LD_VAR 0 5
43340: PPUSH
43341: CALL_OW 1
43345: ST_TO_ADDR
// ComExitBuilding ( i ) ;
43346: LD_VAR 0 5
43350: PPUSH
43351: CALL_OW 122
// end ; if sold_defenders then
43355: LD_VAR 0 17
43359: IFFALSE 43419
// if i in sold_defenders then
43361: LD_VAR 0 5
43365: PUSH
43366: LD_VAR 0 17
43370: IN
43371: IFFALSE 43419
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
43373: LD_VAR 0 5
43377: PPUSH
43378: CALL_OW 314
43382: NOT
43383: PUSH
43384: LD_VAR 0 5
43388: PPUSH
43389: LD_VAR 0 13
43393: PPUSH
43394: CALL_OW 296
43398: PUSH
43399: LD_INT 30
43401: LESS
43402: AND
43403: IFFALSE 43419
// ComAttackUnit ( i , e ) ;
43405: LD_VAR 0 5
43409: PPUSH
43410: LD_VAR 0 13
43414: PPUSH
43415: CALL_OW 115
// end ; end ; end ;
43419: GO 43422
43421: POP
// if IsDead ( i ) then
43422: LD_VAR 0 5
43426: PPUSH
43427: CALL_OW 301
43431: IFFALSE 43449
// defenders := defenders diff i ;
43433: LD_ADDR_VAR 0 2
43437: PUSH
43438: LD_VAR 0 2
43442: PUSH
43443: LD_VAR 0 5
43447: DIFF
43448: ST_TO_ADDR
// end ;
43449: GO 42720
43451: POP
43452: POP
// until not enemy or not defenders ;
43453: LD_VAR 0 3
43457: NOT
43458: PUSH
43459: LD_VAR 0 2
43463: NOT
43464: OR
43465: IFFALSE 42687
// MC_Reset ( base , 18 ) ;
43467: LD_VAR 0 1
43471: PPUSH
43472: LD_INT 18
43474: PPUSH
43475: CALL 14519 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43479: LD_ADDR_VAR 0 2
43483: PUSH
43484: LD_VAR 0 2
43488: PUSH
43489: LD_VAR 0 2
43493: PPUSH
43494: LD_INT 2
43496: PUSH
43497: LD_INT 25
43499: PUSH
43500: LD_INT 1
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 25
43509: PUSH
43510: LD_INT 5
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 25
43519: PUSH
43520: LD_INT 8
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 25
43529: PUSH
43530: LD_INT 9
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: PPUSH
43544: CALL_OW 72
43548: DIFF
43549: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
43550: LD_VAR 0 3
43554: NOT
43555: PUSH
43556: LD_VAR 0 2
43560: PPUSH
43561: LD_INT 21
43563: PUSH
43564: LD_INT 2
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PPUSH
43571: CALL_OW 72
43575: AND
43576: IFFALSE 43838
// begin tmp := FilterByTag ( defenders , 19 ) ;
43578: LD_ADDR_VAR 0 11
43582: PUSH
43583: LD_VAR 0 2
43587: PPUSH
43588: LD_INT 19
43590: PPUSH
43591: CALL 80279 0 2
43595: ST_TO_ADDR
// if tmp then
43596: LD_VAR 0 11
43600: IFFALSE 43670
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
43602: LD_ADDR_VAR 0 11
43606: PUSH
43607: LD_VAR 0 11
43611: PPUSH
43612: LD_INT 25
43614: PUSH
43615: LD_INT 3
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PPUSH
43622: CALL_OW 72
43626: ST_TO_ADDR
// if tmp then
43627: LD_VAR 0 11
43631: IFFALSE 43670
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
43633: LD_ADDR_EXP 68
43637: PUSH
43638: LD_EXP 68
43642: PPUSH
43643: LD_VAR 0 1
43647: PPUSH
43648: LD_EXP 68
43652: PUSH
43653: LD_VAR 0 1
43657: ARRAY
43658: PUSH
43659: LD_VAR 0 11
43663: UNION
43664: PPUSH
43665: CALL_OW 1
43669: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
43670: LD_VAR 0 1
43674: PPUSH
43675: LD_INT 19
43677: PPUSH
43678: CALL 14519 0 2
// repeat wait ( 0 0$1 ) ;
43682: LD_INT 35
43684: PPUSH
43685: CALL_OW 67
// for i in defenders do
43689: LD_ADDR_VAR 0 5
43693: PUSH
43694: LD_VAR 0 2
43698: PUSH
43699: FOR_IN
43700: IFFALSE 43789
// begin if not IsInArea ( i , mc_parking [ base ] ) then
43702: LD_VAR 0 5
43706: PPUSH
43707: LD_EXP 80
43711: PUSH
43712: LD_VAR 0 1
43716: ARRAY
43717: PPUSH
43718: CALL_OW 308
43722: NOT
43723: IFFALSE 43747
// ComMoveToArea ( i , mc_parking [ base ] ) else
43725: LD_VAR 0 5
43729: PPUSH
43730: LD_EXP 80
43734: PUSH
43735: LD_VAR 0 1
43739: ARRAY
43740: PPUSH
43741: CALL_OW 113
43745: GO 43787
// if GetControl ( i ) = control_manual then
43747: LD_VAR 0 5
43751: PPUSH
43752: CALL_OW 263
43756: PUSH
43757: LD_INT 1
43759: EQUAL
43760: IFFALSE 43787
// if IsDrivenBy ( i ) then
43762: LD_VAR 0 5
43766: PPUSH
43767: CALL_OW 311
43771: IFFALSE 43787
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
43773: LD_VAR 0 5
43777: PPUSH
43778: CALL_OW 311
43782: PPUSH
43783: CALL_OW 121
// end ;
43787: GO 43699
43789: POP
43790: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
43791: LD_VAR 0 2
43795: PPUSH
43796: LD_INT 95
43798: PUSH
43799: LD_EXP 80
43803: PUSH
43804: LD_VAR 0 1
43808: ARRAY
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PPUSH
43814: CALL_OW 72
43818: PUSH
43819: LD_VAR 0 2
43823: EQUAL
43824: PUSH
43825: LD_EXP 79
43829: PUSH
43830: LD_VAR 0 1
43834: ARRAY
43835: OR
43836: IFFALSE 43682
// end ; MC_Reset ( base , 20 ) ;
43838: LD_VAR 0 1
43842: PPUSH
43843: LD_INT 20
43845: PPUSH
43846: CALL 14519 0 2
// end ;
43850: LD_VAR 0 4
43854: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
43855: LD_INT 0
43857: PPUSH
43858: PPUSH
43859: PPUSH
43860: PPUSH
// result := false ;
43861: LD_ADDR_VAR 0 2
43865: PUSH
43866: LD_INT 0
43868: ST_TO_ADDR
// side := GetSide ( unit ) ;
43869: LD_ADDR_VAR 0 3
43873: PUSH
43874: LD_VAR 0 1
43878: PPUSH
43879: CALL_OW 255
43883: ST_TO_ADDR
// nat := GetNation ( unit ) ;
43884: LD_ADDR_VAR 0 4
43888: PUSH
43889: LD_VAR 0 1
43893: PPUSH
43894: CALL_OW 248
43898: ST_TO_ADDR
// case nat of 1 :
43899: LD_VAR 0 4
43903: PUSH
43904: LD_INT 1
43906: DOUBLE
43907: EQUAL
43908: IFTRUE 43912
43910: GO 43923
43912: POP
// tech := tech_lassight ; 2 :
43913: LD_ADDR_VAR 0 5
43917: PUSH
43918: LD_INT 12
43920: ST_TO_ADDR
43921: GO 43962
43923: LD_INT 2
43925: DOUBLE
43926: EQUAL
43927: IFTRUE 43931
43929: GO 43942
43931: POP
// tech := tech_mortar ; 3 :
43932: LD_ADDR_VAR 0 5
43936: PUSH
43937: LD_INT 41
43939: ST_TO_ADDR
43940: GO 43962
43942: LD_INT 3
43944: DOUBLE
43945: EQUAL
43946: IFTRUE 43950
43948: GO 43961
43950: POP
// tech := tech_bazooka ; end ;
43951: LD_ADDR_VAR 0 5
43955: PUSH
43956: LD_INT 44
43958: ST_TO_ADDR
43959: GO 43962
43961: POP
// if Researched ( side , tech ) then
43962: LD_VAR 0 3
43966: PPUSH
43967: LD_VAR 0 5
43971: PPUSH
43972: CALL_OW 325
43976: IFFALSE 44003
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
43978: LD_ADDR_VAR 0 2
43982: PUSH
43983: LD_INT 5
43985: PUSH
43986: LD_INT 8
43988: PUSH
43989: LD_INT 9
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: LIST
43996: PUSH
43997: LD_VAR 0 4
44001: ARRAY
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 2
44007: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
44012: PPUSH
// if not mines then
44013: LD_VAR 0 2
44017: NOT
44018: IFFALSE 44022
// exit ;
44020: GO 44166
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
44022: LD_ADDR_VAR 0 5
44026: PUSH
44027: LD_INT 81
44029: PUSH
44030: LD_VAR 0 1
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: LD_INT 21
44044: PUSH
44045: LD_INT 3
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PPUSH
44060: CALL_OW 69
44064: ST_TO_ADDR
// for i in mines do
44065: LD_ADDR_VAR 0 4
44069: PUSH
44070: LD_VAR 0 2
44074: PUSH
44075: FOR_IN
44076: IFFALSE 44164
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
44078: LD_VAR 0 4
44082: PUSH
44083: LD_INT 1
44085: ARRAY
44086: PPUSH
44087: LD_VAR 0 4
44091: PUSH
44092: LD_INT 2
44094: ARRAY
44095: PPUSH
44096: CALL_OW 458
44100: NOT
44101: IFFALSE 44105
// continue ;
44103: GO 44075
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
44105: LD_VAR 0 4
44109: PUSH
44110: LD_INT 1
44112: ARRAY
44113: PPUSH
44114: LD_VAR 0 4
44118: PUSH
44119: LD_INT 2
44121: ARRAY
44122: PPUSH
44123: CALL_OW 428
44127: PUSH
44128: LD_VAR 0 5
44132: IN
44133: IFFALSE 44162
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
44135: LD_VAR 0 4
44139: PUSH
44140: LD_INT 1
44142: ARRAY
44143: PPUSH
44144: LD_VAR 0 4
44148: PUSH
44149: LD_INT 2
44151: ARRAY
44152: PPUSH
44153: LD_VAR 0 1
44157: PPUSH
44158: CALL_OW 456
// end ;
44162: GO 44075
44164: POP
44165: POP
// end ;
44166: LD_VAR 0 3
44170: RET
// export function Count ( array ) ; var i ; begin
44171: LD_INT 0
44173: PPUSH
44174: PPUSH
// result := 0 ;
44175: LD_ADDR_VAR 0 2
44179: PUSH
44180: LD_INT 0
44182: ST_TO_ADDR
// for i in array do
44183: LD_ADDR_VAR 0 3
44187: PUSH
44188: LD_VAR 0 1
44192: PUSH
44193: FOR_IN
44194: IFFALSE 44218
// if i then
44196: LD_VAR 0 3
44200: IFFALSE 44216
// result := result + 1 ;
44202: LD_ADDR_VAR 0 2
44206: PUSH
44207: LD_VAR 0 2
44211: PUSH
44212: LD_INT 1
44214: PLUS
44215: ST_TO_ADDR
44216: GO 44193
44218: POP
44219: POP
// end ;
44220: LD_VAR 0 2
44224: RET
// export function IsEmpty ( building ) ; begin
44225: LD_INT 0
44227: PPUSH
// if not building then
44228: LD_VAR 0 1
44232: NOT
44233: IFFALSE 44237
// exit ;
44235: GO 44280
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
44237: LD_ADDR_VAR 0 2
44241: PUSH
44242: LD_VAR 0 1
44246: PUSH
44247: LD_INT 22
44249: PUSH
44250: LD_VAR 0 1
44254: PPUSH
44255: CALL_OW 255
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 58
44266: PUSH
44267: EMPTY
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PPUSH
44274: CALL_OW 69
44278: IN
44279: ST_TO_ADDR
// end ;
44280: LD_VAR 0 2
44284: RET
// export function IsNotFull ( building ) ; begin
44285: LD_INT 0
44287: PPUSH
// if not building then
44288: LD_VAR 0 1
44292: NOT
44293: IFFALSE 44297
// exit ;
44295: GO 44316
// result := UnitsInside ( building ) < 6 ;
44297: LD_ADDR_VAR 0 2
44301: PUSH
44302: LD_VAR 0 1
44306: PPUSH
44307: CALL_OW 313
44311: PUSH
44312: LD_INT 6
44314: LESS
44315: ST_TO_ADDR
// end ;
44316: LD_VAR 0 2
44320: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
44321: LD_INT 0
44323: PPUSH
44324: PPUSH
44325: PPUSH
44326: PPUSH
// tmp := [ ] ;
44327: LD_ADDR_VAR 0 3
44331: PUSH
44332: EMPTY
44333: ST_TO_ADDR
// list := [ ] ;
44334: LD_ADDR_VAR 0 5
44338: PUSH
44339: EMPTY
44340: ST_TO_ADDR
// for i = 16 to 25 do
44341: LD_ADDR_VAR 0 4
44345: PUSH
44346: DOUBLE
44347: LD_INT 16
44349: DEC
44350: ST_TO_ADDR
44351: LD_INT 25
44353: PUSH
44354: FOR_TO
44355: IFFALSE 44428
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
44357: LD_ADDR_VAR 0 3
44361: PUSH
44362: LD_VAR 0 3
44366: PUSH
44367: LD_INT 22
44369: PUSH
44370: LD_VAR 0 1
44374: PPUSH
44375: CALL_OW 255
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 91
44386: PUSH
44387: LD_VAR 0 1
44391: PUSH
44392: LD_INT 6
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: LIST
44399: PUSH
44400: LD_INT 30
44402: PUSH
44403: LD_VAR 0 4
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: LIST
44416: PUSH
44417: EMPTY
44418: LIST
44419: PPUSH
44420: CALL_OW 69
44424: ADD
44425: ST_TO_ADDR
44426: GO 44354
44428: POP
44429: POP
// for i = 1 to tmp do
44430: LD_ADDR_VAR 0 4
44434: PUSH
44435: DOUBLE
44436: LD_INT 1
44438: DEC
44439: ST_TO_ADDR
44440: LD_VAR 0 3
44444: PUSH
44445: FOR_TO
44446: IFFALSE 44534
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
44448: LD_ADDR_VAR 0 5
44452: PUSH
44453: LD_VAR 0 5
44457: PUSH
44458: LD_VAR 0 3
44462: PUSH
44463: LD_VAR 0 4
44467: ARRAY
44468: PPUSH
44469: CALL_OW 266
44473: PUSH
44474: LD_VAR 0 3
44478: PUSH
44479: LD_VAR 0 4
44483: ARRAY
44484: PPUSH
44485: CALL_OW 250
44489: PUSH
44490: LD_VAR 0 3
44494: PUSH
44495: LD_VAR 0 4
44499: ARRAY
44500: PPUSH
44501: CALL_OW 251
44505: PUSH
44506: LD_VAR 0 3
44510: PUSH
44511: LD_VAR 0 4
44515: ARRAY
44516: PPUSH
44517: CALL_OW 254
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: PUSH
44528: EMPTY
44529: LIST
44530: ADD
44531: ST_TO_ADDR
44532: GO 44445
44534: POP
44535: POP
// result := list ;
44536: LD_ADDR_VAR 0 2
44540: PUSH
44541: LD_VAR 0 5
44545: ST_TO_ADDR
// end ;
44546: LD_VAR 0 2
44550: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
44551: LD_INT 0
44553: PPUSH
44554: PPUSH
44555: PPUSH
44556: PPUSH
44557: PPUSH
44558: PPUSH
44559: PPUSH
// if not factory then
44560: LD_VAR 0 1
44564: NOT
44565: IFFALSE 44569
// exit ;
44567: GO 45162
// if control = control_apeman then
44569: LD_VAR 0 4
44573: PUSH
44574: LD_INT 5
44576: EQUAL
44577: IFFALSE 44686
// begin tmp := UnitsInside ( factory ) ;
44579: LD_ADDR_VAR 0 8
44583: PUSH
44584: LD_VAR 0 1
44588: PPUSH
44589: CALL_OW 313
44593: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
44594: LD_VAR 0 8
44598: PPUSH
44599: LD_INT 25
44601: PUSH
44602: LD_INT 12
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PPUSH
44609: CALL_OW 72
44613: NOT
44614: IFFALSE 44624
// control := control_manual ;
44616: LD_ADDR_VAR 0 4
44620: PUSH
44621: LD_INT 1
44623: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
44624: LD_ADDR_VAR 0 8
44628: PUSH
44629: LD_VAR 0 1
44633: PPUSH
44634: CALL 44321 0 1
44638: ST_TO_ADDR
// if tmp then
44639: LD_VAR 0 8
44643: IFFALSE 44686
// begin for i in tmp do
44645: LD_ADDR_VAR 0 7
44649: PUSH
44650: LD_VAR 0 8
44654: PUSH
44655: FOR_IN
44656: IFFALSE 44684
// if i [ 1 ] = b_ext_radio then
44658: LD_VAR 0 7
44662: PUSH
44663: LD_INT 1
44665: ARRAY
44666: PUSH
44667: LD_INT 22
44669: EQUAL
44670: IFFALSE 44682
// begin control := control_remote ;
44672: LD_ADDR_VAR 0 4
44676: PUSH
44677: LD_INT 2
44679: ST_TO_ADDR
// break ;
44680: GO 44684
// end ;
44682: GO 44655
44684: POP
44685: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
44686: LD_VAR 0 1
44690: PPUSH
44691: LD_VAR 0 2
44695: PPUSH
44696: LD_VAR 0 3
44700: PPUSH
44701: LD_VAR 0 4
44705: PPUSH
44706: LD_VAR 0 5
44710: PPUSH
44711: CALL_OW 448
44715: IFFALSE 44750
// begin result := [ chassis , engine , control , weapon ] ;
44717: LD_ADDR_VAR 0 6
44721: PUSH
44722: LD_VAR 0 2
44726: PUSH
44727: LD_VAR 0 3
44731: PUSH
44732: LD_VAR 0 4
44736: PUSH
44737: LD_VAR 0 5
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: ST_TO_ADDR
// exit ;
44748: GO 45162
// end ; _chassis := AvailableChassisList ( factory ) ;
44750: LD_ADDR_VAR 0 9
44754: PUSH
44755: LD_VAR 0 1
44759: PPUSH
44760: CALL_OW 475
44764: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
44765: LD_ADDR_VAR 0 11
44769: PUSH
44770: LD_VAR 0 1
44774: PPUSH
44775: CALL_OW 476
44779: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
44780: LD_ADDR_VAR 0 12
44784: PUSH
44785: LD_VAR 0 1
44789: PPUSH
44790: CALL_OW 477
44794: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
44795: LD_ADDR_VAR 0 10
44799: PUSH
44800: LD_VAR 0 1
44804: PPUSH
44805: CALL_OW 478
44809: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
44810: LD_VAR 0 9
44814: NOT
44815: PUSH
44816: LD_VAR 0 11
44820: NOT
44821: OR
44822: PUSH
44823: LD_VAR 0 12
44827: NOT
44828: OR
44829: PUSH
44830: LD_VAR 0 10
44834: NOT
44835: OR
44836: IFFALSE 44871
// begin result := [ chassis , engine , control , weapon ] ;
44838: LD_ADDR_VAR 0 6
44842: PUSH
44843: LD_VAR 0 2
44847: PUSH
44848: LD_VAR 0 3
44852: PUSH
44853: LD_VAR 0 4
44857: PUSH
44858: LD_VAR 0 5
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: ST_TO_ADDR
// exit ;
44869: GO 45162
// end ; if not chassis in _chassis then
44871: LD_VAR 0 2
44875: PUSH
44876: LD_VAR 0 9
44880: IN
44881: NOT
44882: IFFALSE 44908
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
44884: LD_ADDR_VAR 0 2
44888: PUSH
44889: LD_VAR 0 9
44893: PUSH
44894: LD_INT 1
44896: PPUSH
44897: LD_VAR 0 9
44901: PPUSH
44902: CALL_OW 12
44906: ARRAY
44907: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
44908: LD_VAR 0 2
44912: PPUSH
44913: LD_VAR 0 3
44917: PPUSH
44918: CALL 45167 0 2
44922: NOT
44923: IFFALSE 44982
// repeat engine := _engine [ 1 ] ;
44925: LD_ADDR_VAR 0 3
44929: PUSH
44930: LD_VAR 0 11
44934: PUSH
44935: LD_INT 1
44937: ARRAY
44938: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
44939: LD_ADDR_VAR 0 11
44943: PUSH
44944: LD_VAR 0 11
44948: PPUSH
44949: LD_INT 1
44951: PPUSH
44952: CALL_OW 3
44956: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
44957: LD_VAR 0 2
44961: PPUSH
44962: LD_VAR 0 3
44966: PPUSH
44967: CALL 45167 0 2
44971: PUSH
44972: LD_VAR 0 11
44976: PUSH
44977: EMPTY
44978: EQUAL
44979: OR
44980: IFFALSE 44925
// if not control in _control then
44982: LD_VAR 0 4
44986: PUSH
44987: LD_VAR 0 12
44991: IN
44992: NOT
44993: IFFALSE 45019
// control := _control [ rand ( 1 , _control ) ] ;
44995: LD_ADDR_VAR 0 4
44999: PUSH
45000: LD_VAR 0 12
45004: PUSH
45005: LD_INT 1
45007: PPUSH
45008: LD_VAR 0 12
45012: PPUSH
45013: CALL_OW 12
45017: ARRAY
45018: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
45019: LD_VAR 0 2
45023: PPUSH
45024: LD_VAR 0 5
45028: PPUSH
45029: CALL 45387 0 2
45033: NOT
45034: IFFALSE 45093
// repeat weapon := _weapon [ 1 ] ;
45036: LD_ADDR_VAR 0 5
45040: PUSH
45041: LD_VAR 0 10
45045: PUSH
45046: LD_INT 1
45048: ARRAY
45049: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
45050: LD_ADDR_VAR 0 10
45054: PUSH
45055: LD_VAR 0 10
45059: PPUSH
45060: LD_INT 1
45062: PPUSH
45063: CALL_OW 3
45067: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
45068: LD_VAR 0 2
45072: PPUSH
45073: LD_VAR 0 5
45077: PPUSH
45078: CALL 45387 0 2
45082: PUSH
45083: LD_VAR 0 10
45087: PUSH
45088: EMPTY
45089: EQUAL
45090: OR
45091: IFFALSE 45036
// result := [ ] ;
45093: LD_ADDR_VAR 0 6
45097: PUSH
45098: EMPTY
45099: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
45100: LD_VAR 0 1
45104: PPUSH
45105: LD_VAR 0 2
45109: PPUSH
45110: LD_VAR 0 3
45114: PPUSH
45115: LD_VAR 0 4
45119: PPUSH
45120: LD_VAR 0 5
45124: PPUSH
45125: CALL_OW 448
45129: IFFALSE 45162
// result := [ chassis , engine , control , weapon ] ;
45131: LD_ADDR_VAR 0 6
45135: PUSH
45136: LD_VAR 0 2
45140: PUSH
45141: LD_VAR 0 3
45145: PUSH
45146: LD_VAR 0 4
45150: PUSH
45151: LD_VAR 0 5
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: ST_TO_ADDR
// end ;
45162: LD_VAR 0 6
45166: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
45167: LD_INT 0
45169: PPUSH
// if not chassis or not engine then
45170: LD_VAR 0 1
45174: NOT
45175: PUSH
45176: LD_VAR 0 2
45180: NOT
45181: OR
45182: IFFALSE 45186
// exit ;
45184: GO 45382
// case engine of engine_solar :
45186: LD_VAR 0 2
45190: PUSH
45191: LD_INT 2
45193: DOUBLE
45194: EQUAL
45195: IFTRUE 45199
45197: GO 45237
45199: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
45200: LD_ADDR_VAR 0 3
45204: PUSH
45205: LD_INT 11
45207: PUSH
45208: LD_INT 12
45210: PUSH
45211: LD_INT 13
45213: PUSH
45214: LD_INT 14
45216: PUSH
45217: LD_INT 1
45219: PUSH
45220: LD_INT 2
45222: PUSH
45223: LD_INT 3
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: ST_TO_ADDR
45235: GO 45366
45237: LD_INT 1
45239: DOUBLE
45240: EQUAL
45241: IFTRUE 45245
45243: GO 45307
45245: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
45246: LD_ADDR_VAR 0 3
45250: PUSH
45251: LD_INT 11
45253: PUSH
45254: LD_INT 12
45256: PUSH
45257: LD_INT 13
45259: PUSH
45260: LD_INT 14
45262: PUSH
45263: LD_INT 1
45265: PUSH
45266: LD_INT 2
45268: PUSH
45269: LD_INT 3
45271: PUSH
45272: LD_INT 4
45274: PUSH
45275: LD_INT 5
45277: PUSH
45278: LD_INT 21
45280: PUSH
45281: LD_INT 23
45283: PUSH
45284: LD_INT 22
45286: PUSH
45287: LD_INT 24
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: ST_TO_ADDR
45305: GO 45366
45307: LD_INT 3
45309: DOUBLE
45310: EQUAL
45311: IFTRUE 45315
45313: GO 45365
45315: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
45316: LD_ADDR_VAR 0 3
45320: PUSH
45321: LD_INT 13
45323: PUSH
45324: LD_INT 14
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: LD_INT 3
45332: PUSH
45333: LD_INT 4
45335: PUSH
45336: LD_INT 5
45338: PUSH
45339: LD_INT 21
45341: PUSH
45342: LD_INT 22
45344: PUSH
45345: LD_INT 23
45347: PUSH
45348: LD_INT 24
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: ST_TO_ADDR
45363: GO 45366
45365: POP
// result := ( chassis in result ) ;
45366: LD_ADDR_VAR 0 3
45370: PUSH
45371: LD_VAR 0 1
45375: PUSH
45376: LD_VAR 0 3
45380: IN
45381: ST_TO_ADDR
// end ;
45382: LD_VAR 0 3
45386: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
45387: LD_INT 0
45389: PPUSH
// if not chassis or not weapon then
45390: LD_VAR 0 1
45394: NOT
45395: PUSH
45396: LD_VAR 0 2
45400: NOT
45401: OR
45402: IFFALSE 45406
// exit ;
45404: GO 46432
// case weapon of us_machine_gun :
45406: LD_VAR 0 2
45410: PUSH
45411: LD_INT 2
45413: DOUBLE
45414: EQUAL
45415: IFTRUE 45419
45417: GO 45449
45419: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
45420: LD_ADDR_VAR 0 3
45424: PUSH
45425: LD_INT 1
45427: PUSH
45428: LD_INT 2
45430: PUSH
45431: LD_INT 3
45433: PUSH
45434: LD_INT 4
45436: PUSH
45437: LD_INT 5
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: ST_TO_ADDR
45447: GO 46416
45449: LD_INT 3
45451: DOUBLE
45452: EQUAL
45453: IFTRUE 45457
45455: GO 45487
45457: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
45458: LD_ADDR_VAR 0 3
45462: PUSH
45463: LD_INT 1
45465: PUSH
45466: LD_INT 2
45468: PUSH
45469: LD_INT 3
45471: PUSH
45472: LD_INT 4
45474: PUSH
45475: LD_INT 5
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: ST_TO_ADDR
45485: GO 46416
45487: LD_INT 11
45489: DOUBLE
45490: EQUAL
45491: IFTRUE 45495
45493: GO 45525
45495: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
45496: LD_ADDR_VAR 0 3
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: LD_INT 2
45506: PUSH
45507: LD_INT 3
45509: PUSH
45510: LD_INT 4
45512: PUSH
45513: LD_INT 5
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: ST_TO_ADDR
45523: GO 46416
45525: LD_INT 4
45527: DOUBLE
45528: EQUAL
45529: IFTRUE 45533
45531: GO 45559
45533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
45534: LD_ADDR_VAR 0 3
45538: PUSH
45539: LD_INT 2
45541: PUSH
45542: LD_INT 3
45544: PUSH
45545: LD_INT 4
45547: PUSH
45548: LD_INT 5
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: ST_TO_ADDR
45557: GO 46416
45559: LD_INT 5
45561: DOUBLE
45562: EQUAL
45563: IFTRUE 45567
45565: GO 45593
45567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
45568: LD_ADDR_VAR 0 3
45572: PUSH
45573: LD_INT 2
45575: PUSH
45576: LD_INT 3
45578: PUSH
45579: LD_INT 4
45581: PUSH
45582: LD_INT 5
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: ST_TO_ADDR
45591: GO 46416
45593: LD_INT 9
45595: DOUBLE
45596: EQUAL
45597: IFTRUE 45601
45599: GO 45627
45601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
45602: LD_ADDR_VAR 0 3
45606: PUSH
45607: LD_INT 2
45609: PUSH
45610: LD_INT 3
45612: PUSH
45613: LD_INT 4
45615: PUSH
45616: LD_INT 5
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: ST_TO_ADDR
45625: GO 46416
45627: LD_INT 7
45629: DOUBLE
45630: EQUAL
45631: IFTRUE 45635
45633: GO 45661
45635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
45636: LD_ADDR_VAR 0 3
45640: PUSH
45641: LD_INT 2
45643: PUSH
45644: LD_INT 3
45646: PUSH
45647: LD_INT 4
45649: PUSH
45650: LD_INT 5
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: ST_TO_ADDR
45659: GO 46416
45661: LD_INT 12
45663: DOUBLE
45664: EQUAL
45665: IFTRUE 45669
45667: GO 45695
45669: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
45670: LD_ADDR_VAR 0 3
45674: PUSH
45675: LD_INT 2
45677: PUSH
45678: LD_INT 3
45680: PUSH
45681: LD_INT 4
45683: PUSH
45684: LD_INT 5
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: ST_TO_ADDR
45693: GO 46416
45695: LD_INT 13
45697: DOUBLE
45698: EQUAL
45699: IFTRUE 45703
45701: GO 45729
45703: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
45704: LD_ADDR_VAR 0 3
45708: PUSH
45709: LD_INT 2
45711: PUSH
45712: LD_INT 3
45714: PUSH
45715: LD_INT 4
45717: PUSH
45718: LD_INT 5
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: ST_TO_ADDR
45727: GO 46416
45729: LD_INT 14
45731: DOUBLE
45732: EQUAL
45733: IFTRUE 45737
45735: GO 45755
45737: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
45738: LD_ADDR_VAR 0 3
45742: PUSH
45743: LD_INT 4
45745: PUSH
45746: LD_INT 5
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: ST_TO_ADDR
45753: GO 46416
45755: LD_INT 6
45757: DOUBLE
45758: EQUAL
45759: IFTRUE 45763
45761: GO 45781
45763: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
45764: LD_ADDR_VAR 0 3
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: LD_INT 5
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: ST_TO_ADDR
45779: GO 46416
45781: LD_INT 10
45783: DOUBLE
45784: EQUAL
45785: IFTRUE 45789
45787: GO 45807
45789: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
45790: LD_ADDR_VAR 0 3
45794: PUSH
45795: LD_INT 4
45797: PUSH
45798: LD_INT 5
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: ST_TO_ADDR
45805: GO 46416
45807: LD_INT 22
45809: DOUBLE
45810: EQUAL
45811: IFTRUE 45815
45813: GO 45841
45815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
45816: LD_ADDR_VAR 0 3
45820: PUSH
45821: LD_INT 11
45823: PUSH
45824: LD_INT 12
45826: PUSH
45827: LD_INT 13
45829: PUSH
45830: LD_INT 14
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: ST_TO_ADDR
45839: GO 46416
45841: LD_INT 23
45843: DOUBLE
45844: EQUAL
45845: IFTRUE 45849
45847: GO 45875
45849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
45850: LD_ADDR_VAR 0 3
45854: PUSH
45855: LD_INT 11
45857: PUSH
45858: LD_INT 12
45860: PUSH
45861: LD_INT 13
45863: PUSH
45864: LD_INT 14
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: ST_TO_ADDR
45873: GO 46416
45875: LD_INT 24
45877: DOUBLE
45878: EQUAL
45879: IFTRUE 45883
45881: GO 45909
45883: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
45884: LD_ADDR_VAR 0 3
45888: PUSH
45889: LD_INT 11
45891: PUSH
45892: LD_INT 12
45894: PUSH
45895: LD_INT 13
45897: PUSH
45898: LD_INT 14
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: ST_TO_ADDR
45907: GO 46416
45909: LD_INT 30
45911: DOUBLE
45912: EQUAL
45913: IFTRUE 45917
45915: GO 45943
45917: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
45918: LD_ADDR_VAR 0 3
45922: PUSH
45923: LD_INT 11
45925: PUSH
45926: LD_INT 12
45928: PUSH
45929: LD_INT 13
45931: PUSH
45932: LD_INT 14
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: ST_TO_ADDR
45941: GO 46416
45943: LD_INT 25
45945: DOUBLE
45946: EQUAL
45947: IFTRUE 45951
45949: GO 45969
45951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
45952: LD_ADDR_VAR 0 3
45956: PUSH
45957: LD_INT 13
45959: PUSH
45960: LD_INT 14
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: ST_TO_ADDR
45967: GO 46416
45969: LD_INT 27
45971: DOUBLE
45972: EQUAL
45973: IFTRUE 45977
45975: GO 45995
45977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
45978: LD_ADDR_VAR 0 3
45982: PUSH
45983: LD_INT 13
45985: PUSH
45986: LD_INT 14
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: ST_TO_ADDR
45993: GO 46416
45995: LD_INT 28
45997: DOUBLE
45998: EQUAL
45999: IFTRUE 46003
46001: GO 46021
46003: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
46004: LD_ADDR_VAR 0 3
46008: PUSH
46009: LD_INT 13
46011: PUSH
46012: LD_INT 14
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: ST_TO_ADDR
46019: GO 46416
46021: LD_INT 29
46023: DOUBLE
46024: EQUAL
46025: IFTRUE 46029
46027: GO 46047
46029: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
46030: LD_ADDR_VAR 0 3
46034: PUSH
46035: LD_INT 13
46037: PUSH
46038: LD_INT 14
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: ST_TO_ADDR
46045: GO 46416
46047: LD_INT 31
46049: DOUBLE
46050: EQUAL
46051: IFTRUE 46055
46053: GO 46073
46055: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
46056: LD_ADDR_VAR 0 3
46060: PUSH
46061: LD_INT 13
46063: PUSH
46064: LD_INT 14
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: ST_TO_ADDR
46071: GO 46416
46073: LD_INT 26
46075: DOUBLE
46076: EQUAL
46077: IFTRUE 46081
46079: GO 46099
46081: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
46082: LD_ADDR_VAR 0 3
46086: PUSH
46087: LD_INT 13
46089: PUSH
46090: LD_INT 14
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: ST_TO_ADDR
46097: GO 46416
46099: LD_INT 42
46101: DOUBLE
46102: EQUAL
46103: IFTRUE 46107
46105: GO 46133
46107: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
46108: LD_ADDR_VAR 0 3
46112: PUSH
46113: LD_INT 21
46115: PUSH
46116: LD_INT 22
46118: PUSH
46119: LD_INT 23
46121: PUSH
46122: LD_INT 24
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: ST_TO_ADDR
46131: GO 46416
46133: LD_INT 43
46135: DOUBLE
46136: EQUAL
46137: IFTRUE 46141
46139: GO 46167
46141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
46142: LD_ADDR_VAR 0 3
46146: PUSH
46147: LD_INT 21
46149: PUSH
46150: LD_INT 22
46152: PUSH
46153: LD_INT 23
46155: PUSH
46156: LD_INT 24
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: ST_TO_ADDR
46165: GO 46416
46167: LD_INT 44
46169: DOUBLE
46170: EQUAL
46171: IFTRUE 46175
46173: GO 46201
46175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
46176: LD_ADDR_VAR 0 3
46180: PUSH
46181: LD_INT 21
46183: PUSH
46184: LD_INT 22
46186: PUSH
46187: LD_INT 23
46189: PUSH
46190: LD_INT 24
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: ST_TO_ADDR
46199: GO 46416
46201: LD_INT 45
46203: DOUBLE
46204: EQUAL
46205: IFTRUE 46209
46207: GO 46235
46209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
46210: LD_ADDR_VAR 0 3
46214: PUSH
46215: LD_INT 21
46217: PUSH
46218: LD_INT 22
46220: PUSH
46221: LD_INT 23
46223: PUSH
46224: LD_INT 24
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: ST_TO_ADDR
46233: GO 46416
46235: LD_INT 49
46237: DOUBLE
46238: EQUAL
46239: IFTRUE 46243
46241: GO 46269
46243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
46244: LD_ADDR_VAR 0 3
46248: PUSH
46249: LD_INT 21
46251: PUSH
46252: LD_INT 22
46254: PUSH
46255: LD_INT 23
46257: PUSH
46258: LD_INT 24
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: LIST
46265: LIST
46266: ST_TO_ADDR
46267: GO 46416
46269: LD_INT 51
46271: DOUBLE
46272: EQUAL
46273: IFTRUE 46277
46275: GO 46303
46277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
46278: LD_ADDR_VAR 0 3
46282: PUSH
46283: LD_INT 21
46285: PUSH
46286: LD_INT 22
46288: PUSH
46289: LD_INT 23
46291: PUSH
46292: LD_INT 24
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: ST_TO_ADDR
46301: GO 46416
46303: LD_INT 52
46305: DOUBLE
46306: EQUAL
46307: IFTRUE 46311
46309: GO 46337
46311: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
46312: LD_ADDR_VAR 0 3
46316: PUSH
46317: LD_INT 21
46319: PUSH
46320: LD_INT 22
46322: PUSH
46323: LD_INT 23
46325: PUSH
46326: LD_INT 24
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: ST_TO_ADDR
46335: GO 46416
46337: LD_INT 53
46339: DOUBLE
46340: EQUAL
46341: IFTRUE 46345
46343: GO 46363
46345: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
46346: LD_ADDR_VAR 0 3
46350: PUSH
46351: LD_INT 23
46353: PUSH
46354: LD_INT 24
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: ST_TO_ADDR
46361: GO 46416
46363: LD_INT 46
46365: DOUBLE
46366: EQUAL
46367: IFTRUE 46371
46369: GO 46389
46371: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
46372: LD_ADDR_VAR 0 3
46376: PUSH
46377: LD_INT 23
46379: PUSH
46380: LD_INT 24
46382: PUSH
46383: EMPTY
46384: LIST
46385: LIST
46386: ST_TO_ADDR
46387: GO 46416
46389: LD_INT 47
46391: DOUBLE
46392: EQUAL
46393: IFTRUE 46397
46395: GO 46415
46397: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
46398: LD_ADDR_VAR 0 3
46402: PUSH
46403: LD_INT 23
46405: PUSH
46406: LD_INT 24
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: ST_TO_ADDR
46413: GO 46416
46415: POP
// result := ( chassis in result ) ;
46416: LD_ADDR_VAR 0 3
46420: PUSH
46421: LD_VAR 0 1
46425: PUSH
46426: LD_VAR 0 3
46430: IN
46431: ST_TO_ADDR
// end ;
46432: LD_VAR 0 3
46436: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
46437: LD_INT 0
46439: PPUSH
46440: PPUSH
46441: PPUSH
46442: PPUSH
46443: PPUSH
46444: PPUSH
46445: PPUSH
// result := array ;
46446: LD_ADDR_VAR 0 5
46450: PUSH
46451: LD_VAR 0 1
46455: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
46456: LD_VAR 0 1
46460: NOT
46461: PUSH
46462: LD_VAR 0 2
46466: NOT
46467: OR
46468: PUSH
46469: LD_VAR 0 3
46473: NOT
46474: OR
46475: PUSH
46476: LD_VAR 0 2
46480: PUSH
46481: LD_VAR 0 1
46485: GREATER
46486: OR
46487: PUSH
46488: LD_VAR 0 3
46492: PUSH
46493: LD_VAR 0 1
46497: GREATER
46498: OR
46499: IFFALSE 46503
// exit ;
46501: GO 46799
// if direction then
46503: LD_VAR 0 4
46507: IFFALSE 46571
// begin d := 1 ;
46509: LD_ADDR_VAR 0 9
46513: PUSH
46514: LD_INT 1
46516: ST_TO_ADDR
// if i_from > i_to then
46517: LD_VAR 0 2
46521: PUSH
46522: LD_VAR 0 3
46526: GREATER
46527: IFFALSE 46553
// length := ( array - i_from ) + i_to else
46529: LD_ADDR_VAR 0 11
46533: PUSH
46534: LD_VAR 0 1
46538: PUSH
46539: LD_VAR 0 2
46543: MINUS
46544: PUSH
46545: LD_VAR 0 3
46549: PLUS
46550: ST_TO_ADDR
46551: GO 46569
// length := i_to - i_from ;
46553: LD_ADDR_VAR 0 11
46557: PUSH
46558: LD_VAR 0 3
46562: PUSH
46563: LD_VAR 0 2
46567: MINUS
46568: ST_TO_ADDR
// end else
46569: GO 46632
// begin d := - 1 ;
46571: LD_ADDR_VAR 0 9
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: ST_TO_ADDR
// if i_from > i_to then
46580: LD_VAR 0 2
46584: PUSH
46585: LD_VAR 0 3
46589: GREATER
46590: IFFALSE 46610
// length := i_from - i_to else
46592: LD_ADDR_VAR 0 11
46596: PUSH
46597: LD_VAR 0 2
46601: PUSH
46602: LD_VAR 0 3
46606: MINUS
46607: ST_TO_ADDR
46608: GO 46632
// length := ( array - i_to ) + i_from ;
46610: LD_ADDR_VAR 0 11
46614: PUSH
46615: LD_VAR 0 1
46619: PUSH
46620: LD_VAR 0 3
46624: MINUS
46625: PUSH
46626: LD_VAR 0 2
46630: PLUS
46631: ST_TO_ADDR
// end ; if not length then
46632: LD_VAR 0 11
46636: NOT
46637: IFFALSE 46641
// exit ;
46639: GO 46799
// tmp := array ;
46641: LD_ADDR_VAR 0 10
46645: PUSH
46646: LD_VAR 0 1
46650: ST_TO_ADDR
// for i = 1 to length do
46651: LD_ADDR_VAR 0 6
46655: PUSH
46656: DOUBLE
46657: LD_INT 1
46659: DEC
46660: ST_TO_ADDR
46661: LD_VAR 0 11
46665: PUSH
46666: FOR_TO
46667: IFFALSE 46787
// begin for j = 1 to array do
46669: LD_ADDR_VAR 0 7
46673: PUSH
46674: DOUBLE
46675: LD_INT 1
46677: DEC
46678: ST_TO_ADDR
46679: LD_VAR 0 1
46683: PUSH
46684: FOR_TO
46685: IFFALSE 46773
// begin k := j + d ;
46687: LD_ADDR_VAR 0 8
46691: PUSH
46692: LD_VAR 0 7
46696: PUSH
46697: LD_VAR 0 9
46701: PLUS
46702: ST_TO_ADDR
// if k > array then
46703: LD_VAR 0 8
46707: PUSH
46708: LD_VAR 0 1
46712: GREATER
46713: IFFALSE 46723
// k := 1 ;
46715: LD_ADDR_VAR 0 8
46719: PUSH
46720: LD_INT 1
46722: ST_TO_ADDR
// if not k then
46723: LD_VAR 0 8
46727: NOT
46728: IFFALSE 46740
// k := array ;
46730: LD_ADDR_VAR 0 8
46734: PUSH
46735: LD_VAR 0 1
46739: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
46740: LD_ADDR_VAR 0 10
46744: PUSH
46745: LD_VAR 0 10
46749: PPUSH
46750: LD_VAR 0 8
46754: PPUSH
46755: LD_VAR 0 1
46759: PUSH
46760: LD_VAR 0 7
46764: ARRAY
46765: PPUSH
46766: CALL_OW 1
46770: ST_TO_ADDR
// end ;
46771: GO 46684
46773: POP
46774: POP
// array := tmp ;
46775: LD_ADDR_VAR 0 1
46779: PUSH
46780: LD_VAR 0 10
46784: ST_TO_ADDR
// end ;
46785: GO 46666
46787: POP
46788: POP
// result := array ;
46789: LD_ADDR_VAR 0 5
46793: PUSH
46794: LD_VAR 0 1
46798: ST_TO_ADDR
// end ;
46799: LD_VAR 0 5
46803: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
46804: LD_INT 0
46806: PPUSH
46807: PPUSH
// result := 0 ;
46808: LD_ADDR_VAR 0 3
46812: PUSH
46813: LD_INT 0
46815: ST_TO_ADDR
// if not array or not value in array then
46816: LD_VAR 0 1
46820: NOT
46821: PUSH
46822: LD_VAR 0 2
46826: PUSH
46827: LD_VAR 0 1
46831: IN
46832: NOT
46833: OR
46834: IFFALSE 46838
// exit ;
46836: GO 46892
// for i = 1 to array do
46838: LD_ADDR_VAR 0 4
46842: PUSH
46843: DOUBLE
46844: LD_INT 1
46846: DEC
46847: ST_TO_ADDR
46848: LD_VAR 0 1
46852: PUSH
46853: FOR_TO
46854: IFFALSE 46890
// if value = array [ i ] then
46856: LD_VAR 0 2
46860: PUSH
46861: LD_VAR 0 1
46865: PUSH
46866: LD_VAR 0 4
46870: ARRAY
46871: EQUAL
46872: IFFALSE 46888
// begin result := i ;
46874: LD_ADDR_VAR 0 3
46878: PUSH
46879: LD_VAR 0 4
46883: ST_TO_ADDR
// exit ;
46884: POP
46885: POP
46886: GO 46892
// end ;
46888: GO 46853
46890: POP
46891: POP
// end ;
46892: LD_VAR 0 3
46896: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
46897: LD_INT 0
46899: PPUSH
// vc_chassis := chassis ;
46900: LD_ADDR_OWVAR 37
46904: PUSH
46905: LD_VAR 0 1
46909: ST_TO_ADDR
// vc_engine := engine ;
46910: LD_ADDR_OWVAR 39
46914: PUSH
46915: LD_VAR 0 2
46919: ST_TO_ADDR
// vc_control := control ;
46920: LD_ADDR_OWVAR 38
46924: PUSH
46925: LD_VAR 0 3
46929: ST_TO_ADDR
// vc_weapon := weapon ;
46930: LD_ADDR_OWVAR 40
46934: PUSH
46935: LD_VAR 0 4
46939: ST_TO_ADDR
// vc_fuel_battery := fuel ;
46940: LD_ADDR_OWVAR 41
46944: PUSH
46945: LD_VAR 0 5
46949: ST_TO_ADDR
// end ;
46950: LD_VAR 0 6
46954: RET
// export function WantPlant ( unit ) ; var task ; begin
46955: LD_INT 0
46957: PPUSH
46958: PPUSH
// result := false ;
46959: LD_ADDR_VAR 0 2
46963: PUSH
46964: LD_INT 0
46966: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
46967: LD_ADDR_VAR 0 3
46971: PUSH
46972: LD_VAR 0 1
46976: PPUSH
46977: CALL_OW 437
46981: ST_TO_ADDR
// if task then
46982: LD_VAR 0 3
46986: IFFALSE 47014
// if task [ 1 ] [ 1 ] = p then
46988: LD_VAR 0 3
46992: PUSH
46993: LD_INT 1
46995: ARRAY
46996: PUSH
46997: LD_INT 1
46999: ARRAY
47000: PUSH
47001: LD_STRING p
47003: EQUAL
47004: IFFALSE 47014
// result := true ;
47006: LD_ADDR_VAR 0 2
47010: PUSH
47011: LD_INT 1
47013: ST_TO_ADDR
// end ;
47014: LD_VAR 0 2
47018: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
47019: LD_INT 0
47021: PPUSH
47022: PPUSH
47023: PPUSH
47024: PPUSH
// if pos < 1 then
47025: LD_VAR 0 2
47029: PUSH
47030: LD_INT 1
47032: LESS
47033: IFFALSE 47037
// exit ;
47035: GO 47340
// if pos = 1 then
47037: LD_VAR 0 2
47041: PUSH
47042: LD_INT 1
47044: EQUAL
47045: IFFALSE 47078
// result := Replace ( arr , pos [ 1 ] , value ) else
47047: LD_ADDR_VAR 0 4
47051: PUSH
47052: LD_VAR 0 1
47056: PPUSH
47057: LD_VAR 0 2
47061: PUSH
47062: LD_INT 1
47064: ARRAY
47065: PPUSH
47066: LD_VAR 0 3
47070: PPUSH
47071: CALL_OW 1
47075: ST_TO_ADDR
47076: GO 47340
// begin tmp := arr ;
47078: LD_ADDR_VAR 0 6
47082: PUSH
47083: LD_VAR 0 1
47087: ST_TO_ADDR
// s_arr := [ tmp ] ;
47088: LD_ADDR_VAR 0 7
47092: PUSH
47093: LD_VAR 0 6
47097: PUSH
47098: EMPTY
47099: LIST
47100: ST_TO_ADDR
// for i = 1 to pos - 1 do
47101: LD_ADDR_VAR 0 5
47105: PUSH
47106: DOUBLE
47107: LD_INT 1
47109: DEC
47110: ST_TO_ADDR
47111: LD_VAR 0 2
47115: PUSH
47116: LD_INT 1
47118: MINUS
47119: PUSH
47120: FOR_TO
47121: IFFALSE 47166
// begin tmp := tmp [ pos [ i ] ] ;
47123: LD_ADDR_VAR 0 6
47127: PUSH
47128: LD_VAR 0 6
47132: PUSH
47133: LD_VAR 0 2
47137: PUSH
47138: LD_VAR 0 5
47142: ARRAY
47143: ARRAY
47144: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
47145: LD_ADDR_VAR 0 7
47149: PUSH
47150: LD_VAR 0 7
47154: PUSH
47155: LD_VAR 0 6
47159: PUSH
47160: EMPTY
47161: LIST
47162: ADD
47163: ST_TO_ADDR
// end ;
47164: GO 47120
47166: POP
47167: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
47168: LD_ADDR_VAR 0 6
47172: PUSH
47173: LD_VAR 0 6
47177: PPUSH
47178: LD_VAR 0 2
47182: PUSH
47183: LD_VAR 0 2
47187: ARRAY
47188: PPUSH
47189: LD_VAR 0 3
47193: PPUSH
47194: CALL_OW 1
47198: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
47199: LD_ADDR_VAR 0 7
47203: PUSH
47204: LD_VAR 0 7
47208: PPUSH
47209: LD_VAR 0 7
47213: PPUSH
47214: LD_VAR 0 6
47218: PPUSH
47219: CALL_OW 1
47223: ST_TO_ADDR
// for i = s_arr downto 2 do
47224: LD_ADDR_VAR 0 5
47228: PUSH
47229: DOUBLE
47230: LD_VAR 0 7
47234: INC
47235: ST_TO_ADDR
47236: LD_INT 2
47238: PUSH
47239: FOR_DOWNTO
47240: IFFALSE 47324
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
47242: LD_ADDR_VAR 0 6
47246: PUSH
47247: LD_VAR 0 7
47251: PUSH
47252: LD_VAR 0 5
47256: PUSH
47257: LD_INT 1
47259: MINUS
47260: ARRAY
47261: PPUSH
47262: LD_VAR 0 2
47266: PUSH
47267: LD_VAR 0 5
47271: PUSH
47272: LD_INT 1
47274: MINUS
47275: ARRAY
47276: PPUSH
47277: LD_VAR 0 7
47281: PUSH
47282: LD_VAR 0 5
47286: ARRAY
47287: PPUSH
47288: CALL_OW 1
47292: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
47293: LD_ADDR_VAR 0 7
47297: PUSH
47298: LD_VAR 0 7
47302: PPUSH
47303: LD_VAR 0 5
47307: PUSH
47308: LD_INT 1
47310: MINUS
47311: PPUSH
47312: LD_VAR 0 6
47316: PPUSH
47317: CALL_OW 1
47321: ST_TO_ADDR
// end ;
47322: GO 47239
47324: POP
47325: POP
// result := s_arr [ 1 ] ;
47326: LD_ADDR_VAR 0 4
47330: PUSH
47331: LD_VAR 0 7
47335: PUSH
47336: LD_INT 1
47338: ARRAY
47339: ST_TO_ADDR
// end ; end ;
47340: LD_VAR 0 4
47344: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
47345: LD_INT 0
47347: PPUSH
47348: PPUSH
// if not list then
47349: LD_VAR 0 1
47353: NOT
47354: IFFALSE 47358
// exit ;
47356: GO 47449
// i := list [ pos1 ] ;
47358: LD_ADDR_VAR 0 5
47362: PUSH
47363: LD_VAR 0 1
47367: PUSH
47368: LD_VAR 0 2
47372: ARRAY
47373: ST_TO_ADDR
// if not i then
47374: LD_VAR 0 5
47378: NOT
47379: IFFALSE 47383
// exit ;
47381: GO 47449
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
47383: LD_ADDR_VAR 0 1
47387: PUSH
47388: LD_VAR 0 1
47392: PPUSH
47393: LD_VAR 0 2
47397: PPUSH
47398: LD_VAR 0 1
47402: PUSH
47403: LD_VAR 0 3
47407: ARRAY
47408: PPUSH
47409: CALL_OW 1
47413: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
47414: LD_ADDR_VAR 0 1
47418: PUSH
47419: LD_VAR 0 1
47423: PPUSH
47424: LD_VAR 0 3
47428: PPUSH
47429: LD_VAR 0 5
47433: PPUSH
47434: CALL_OW 1
47438: ST_TO_ADDR
// result := list ;
47439: LD_ADDR_VAR 0 4
47443: PUSH
47444: LD_VAR 0 1
47448: ST_TO_ADDR
// end ;
47449: LD_VAR 0 4
47453: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
47454: LD_INT 0
47456: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
47457: LD_ADDR_VAR 0 5
47461: PUSH
47462: LD_VAR 0 1
47466: PPUSH
47467: CALL_OW 250
47471: PPUSH
47472: LD_VAR 0 1
47476: PPUSH
47477: CALL_OW 251
47481: PPUSH
47482: LD_VAR 0 2
47486: PPUSH
47487: LD_VAR 0 3
47491: PPUSH
47492: LD_VAR 0 4
47496: PPUSH
47497: CALL 47507 0 5
47501: ST_TO_ADDR
// end ;
47502: LD_VAR 0 5
47506: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
47507: LD_INT 0
47509: PPUSH
47510: PPUSH
47511: PPUSH
47512: PPUSH
// if not list then
47513: LD_VAR 0 3
47517: NOT
47518: IFFALSE 47522
// exit ;
47520: GO 47910
// result := [ ] ;
47522: LD_ADDR_VAR 0 6
47526: PUSH
47527: EMPTY
47528: ST_TO_ADDR
// for i in list do
47529: LD_ADDR_VAR 0 7
47533: PUSH
47534: LD_VAR 0 3
47538: PUSH
47539: FOR_IN
47540: IFFALSE 47742
// begin tmp := GetDistUnitXY ( i , x , y ) ;
47542: LD_ADDR_VAR 0 9
47546: PUSH
47547: LD_VAR 0 7
47551: PPUSH
47552: LD_VAR 0 1
47556: PPUSH
47557: LD_VAR 0 2
47561: PPUSH
47562: CALL_OW 297
47566: ST_TO_ADDR
// if not result then
47567: LD_VAR 0 6
47571: NOT
47572: IFFALSE 47598
// result := [ [ i , tmp ] ] else
47574: LD_ADDR_VAR 0 6
47578: PUSH
47579: LD_VAR 0 7
47583: PUSH
47584: LD_VAR 0 9
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: PUSH
47593: EMPTY
47594: LIST
47595: ST_TO_ADDR
47596: GO 47740
// begin if result [ result ] [ 2 ] < tmp then
47598: LD_VAR 0 6
47602: PUSH
47603: LD_VAR 0 6
47607: ARRAY
47608: PUSH
47609: LD_INT 2
47611: ARRAY
47612: PUSH
47613: LD_VAR 0 9
47617: LESS
47618: IFFALSE 47660
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
47620: LD_ADDR_VAR 0 6
47624: PUSH
47625: LD_VAR 0 6
47629: PPUSH
47630: LD_VAR 0 6
47634: PUSH
47635: LD_INT 1
47637: PLUS
47638: PPUSH
47639: LD_VAR 0 7
47643: PUSH
47644: LD_VAR 0 9
47648: PUSH
47649: EMPTY
47650: LIST
47651: LIST
47652: PPUSH
47653: CALL_OW 2
47657: ST_TO_ADDR
47658: GO 47740
// for j = 1 to result do
47660: LD_ADDR_VAR 0 8
47664: PUSH
47665: DOUBLE
47666: LD_INT 1
47668: DEC
47669: ST_TO_ADDR
47670: LD_VAR 0 6
47674: PUSH
47675: FOR_TO
47676: IFFALSE 47738
// begin if tmp < result [ j ] [ 2 ] then
47678: LD_VAR 0 9
47682: PUSH
47683: LD_VAR 0 6
47687: PUSH
47688: LD_VAR 0 8
47692: ARRAY
47693: PUSH
47694: LD_INT 2
47696: ARRAY
47697: LESS
47698: IFFALSE 47736
// begin result := Insert ( result , j , [ i , tmp ] ) ;
47700: LD_ADDR_VAR 0 6
47704: PUSH
47705: LD_VAR 0 6
47709: PPUSH
47710: LD_VAR 0 8
47714: PPUSH
47715: LD_VAR 0 7
47719: PUSH
47720: LD_VAR 0 9
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PPUSH
47729: CALL_OW 2
47733: ST_TO_ADDR
// break ;
47734: GO 47738
// end ; end ;
47736: GO 47675
47738: POP
47739: POP
// end ; end ;
47740: GO 47539
47742: POP
47743: POP
// if result and not asc then
47744: LD_VAR 0 6
47748: PUSH
47749: LD_VAR 0 4
47753: NOT
47754: AND
47755: IFFALSE 47830
// begin tmp := result ;
47757: LD_ADDR_VAR 0 9
47761: PUSH
47762: LD_VAR 0 6
47766: ST_TO_ADDR
// for i = tmp downto 1 do
47767: LD_ADDR_VAR 0 7
47771: PUSH
47772: DOUBLE
47773: LD_VAR 0 9
47777: INC
47778: ST_TO_ADDR
47779: LD_INT 1
47781: PUSH
47782: FOR_DOWNTO
47783: IFFALSE 47828
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
47785: LD_ADDR_VAR 0 6
47789: PUSH
47790: LD_VAR 0 6
47794: PPUSH
47795: LD_VAR 0 9
47799: PUSH
47800: LD_VAR 0 7
47804: MINUS
47805: PUSH
47806: LD_INT 1
47808: PLUS
47809: PPUSH
47810: LD_VAR 0 9
47814: PUSH
47815: LD_VAR 0 7
47819: ARRAY
47820: PPUSH
47821: CALL_OW 1
47825: ST_TO_ADDR
47826: GO 47782
47828: POP
47829: POP
// end ; tmp := [ ] ;
47830: LD_ADDR_VAR 0 9
47834: PUSH
47835: EMPTY
47836: ST_TO_ADDR
// if mode then
47837: LD_VAR 0 5
47841: IFFALSE 47910
// begin for i = 1 to result do
47843: LD_ADDR_VAR 0 7
47847: PUSH
47848: DOUBLE
47849: LD_INT 1
47851: DEC
47852: ST_TO_ADDR
47853: LD_VAR 0 6
47857: PUSH
47858: FOR_TO
47859: IFFALSE 47898
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
47861: LD_ADDR_VAR 0 9
47865: PUSH
47866: LD_VAR 0 9
47870: PPUSH
47871: LD_VAR 0 7
47875: PPUSH
47876: LD_VAR 0 6
47880: PUSH
47881: LD_VAR 0 7
47885: ARRAY
47886: PUSH
47887: LD_INT 1
47889: ARRAY
47890: PPUSH
47891: CALL_OW 1
47895: ST_TO_ADDR
47896: GO 47858
47898: POP
47899: POP
// result := tmp ;
47900: LD_ADDR_VAR 0 6
47904: PUSH
47905: LD_VAR 0 9
47909: ST_TO_ADDR
// end ; end ;
47910: LD_VAR 0 6
47914: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
47915: LD_INT 0
47917: PPUSH
47918: PPUSH
47919: PPUSH
47920: PPUSH
47921: PPUSH
47922: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
47923: LD_ADDR_VAR 0 5
47927: PUSH
47928: LD_INT 0
47930: PUSH
47931: LD_INT 0
47933: PUSH
47934: LD_INT 0
47936: PUSH
47937: EMPTY
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: ST_TO_ADDR
// if not x or not y then
47945: LD_VAR 0 2
47949: NOT
47950: PUSH
47951: LD_VAR 0 3
47955: NOT
47956: OR
47957: IFFALSE 47961
// exit ;
47959: GO 49607
// if not range then
47961: LD_VAR 0 4
47965: NOT
47966: IFFALSE 47976
// range := 10 ;
47968: LD_ADDR_VAR 0 4
47972: PUSH
47973: LD_INT 10
47975: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
47976: LD_ADDR_VAR 0 8
47980: PUSH
47981: LD_INT 81
47983: PUSH
47984: LD_VAR 0 1
47988: PUSH
47989: EMPTY
47990: LIST
47991: LIST
47992: PUSH
47993: LD_INT 92
47995: PUSH
47996: LD_VAR 0 2
48000: PUSH
48001: LD_VAR 0 3
48005: PUSH
48006: LD_VAR 0 4
48010: PUSH
48011: EMPTY
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 3
48019: PUSH
48020: LD_INT 21
48022: PUSH
48023: LD_INT 3
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: LIST
48038: PPUSH
48039: CALL_OW 69
48043: ST_TO_ADDR
// if not tmp then
48044: LD_VAR 0 8
48048: NOT
48049: IFFALSE 48053
// exit ;
48051: GO 49607
// for i in tmp do
48053: LD_ADDR_VAR 0 6
48057: PUSH
48058: LD_VAR 0 8
48062: PUSH
48063: FOR_IN
48064: IFFALSE 49582
// begin points := [ 0 , 0 , 0 ] ;
48066: LD_ADDR_VAR 0 9
48070: PUSH
48071: LD_INT 0
48073: PUSH
48074: LD_INT 0
48076: PUSH
48077: LD_INT 0
48079: PUSH
48080: EMPTY
48081: LIST
48082: LIST
48083: LIST
48084: ST_TO_ADDR
// bpoints := 1 ;
48085: LD_ADDR_VAR 0 10
48089: PUSH
48090: LD_INT 1
48092: ST_TO_ADDR
// case GetType ( i ) of unit_human :
48093: LD_VAR 0 6
48097: PPUSH
48098: CALL_OW 247
48102: PUSH
48103: LD_INT 1
48105: DOUBLE
48106: EQUAL
48107: IFTRUE 48111
48109: GO 48689
48111: POP
// begin if GetClass ( i ) = 1 then
48112: LD_VAR 0 6
48116: PPUSH
48117: CALL_OW 257
48121: PUSH
48122: LD_INT 1
48124: EQUAL
48125: IFFALSE 48146
// points := [ 10 , 5 , 3 ] ;
48127: LD_ADDR_VAR 0 9
48131: PUSH
48132: LD_INT 10
48134: PUSH
48135: LD_INT 5
48137: PUSH
48138: LD_INT 3
48140: PUSH
48141: EMPTY
48142: LIST
48143: LIST
48144: LIST
48145: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
48146: LD_VAR 0 6
48150: PPUSH
48151: CALL_OW 257
48155: PUSH
48156: LD_INT 2
48158: PUSH
48159: LD_INT 3
48161: PUSH
48162: LD_INT 4
48164: PUSH
48165: EMPTY
48166: LIST
48167: LIST
48168: LIST
48169: IN
48170: IFFALSE 48191
// points := [ 3 , 2 , 1 ] ;
48172: LD_ADDR_VAR 0 9
48176: PUSH
48177: LD_INT 3
48179: PUSH
48180: LD_INT 2
48182: PUSH
48183: LD_INT 1
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: LIST
48190: ST_TO_ADDR
// if GetClass ( i ) = 5 then
48191: LD_VAR 0 6
48195: PPUSH
48196: CALL_OW 257
48200: PUSH
48201: LD_INT 5
48203: EQUAL
48204: IFFALSE 48225
// points := [ 130 , 5 , 2 ] ;
48206: LD_ADDR_VAR 0 9
48210: PUSH
48211: LD_INT 130
48213: PUSH
48214: LD_INT 5
48216: PUSH
48217: LD_INT 2
48219: PUSH
48220: EMPTY
48221: LIST
48222: LIST
48223: LIST
48224: ST_TO_ADDR
// if GetClass ( i ) = 8 then
48225: LD_VAR 0 6
48229: PPUSH
48230: CALL_OW 257
48234: PUSH
48235: LD_INT 8
48237: EQUAL
48238: IFFALSE 48259
// points := [ 35 , 35 , 30 ] ;
48240: LD_ADDR_VAR 0 9
48244: PUSH
48245: LD_INT 35
48247: PUSH
48248: LD_INT 35
48250: PUSH
48251: LD_INT 30
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: LIST
48258: ST_TO_ADDR
// if GetClass ( i ) = 9 then
48259: LD_VAR 0 6
48263: PPUSH
48264: CALL_OW 257
48268: PUSH
48269: LD_INT 9
48271: EQUAL
48272: IFFALSE 48293
// points := [ 20 , 55 , 40 ] ;
48274: LD_ADDR_VAR 0 9
48278: PUSH
48279: LD_INT 20
48281: PUSH
48282: LD_INT 55
48284: PUSH
48285: LD_INT 40
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: LIST
48292: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
48293: LD_VAR 0 6
48297: PPUSH
48298: CALL_OW 257
48302: PUSH
48303: LD_INT 12
48305: PUSH
48306: LD_INT 16
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: IN
48313: IFFALSE 48334
// points := [ 5 , 3 , 2 ] ;
48315: LD_ADDR_VAR 0 9
48319: PUSH
48320: LD_INT 5
48322: PUSH
48323: LD_INT 3
48325: PUSH
48326: LD_INT 2
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: LIST
48333: ST_TO_ADDR
// if GetClass ( i ) = 17 then
48334: LD_VAR 0 6
48338: PPUSH
48339: CALL_OW 257
48343: PUSH
48344: LD_INT 17
48346: EQUAL
48347: IFFALSE 48368
// points := [ 100 , 50 , 75 ] ;
48349: LD_ADDR_VAR 0 9
48353: PUSH
48354: LD_INT 100
48356: PUSH
48357: LD_INT 50
48359: PUSH
48360: LD_INT 75
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: LIST
48367: ST_TO_ADDR
// if GetClass ( i ) = 15 then
48368: LD_VAR 0 6
48372: PPUSH
48373: CALL_OW 257
48377: PUSH
48378: LD_INT 15
48380: EQUAL
48381: IFFALSE 48402
// points := [ 10 , 5 , 3 ] ;
48383: LD_ADDR_VAR 0 9
48387: PUSH
48388: LD_INT 10
48390: PUSH
48391: LD_INT 5
48393: PUSH
48394: LD_INT 3
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: LIST
48401: ST_TO_ADDR
// if GetClass ( i ) = 14 then
48402: LD_VAR 0 6
48406: PPUSH
48407: CALL_OW 257
48411: PUSH
48412: LD_INT 14
48414: EQUAL
48415: IFFALSE 48436
// points := [ 10 , 0 , 0 ] ;
48417: LD_ADDR_VAR 0 9
48421: PUSH
48422: LD_INT 10
48424: PUSH
48425: LD_INT 0
48427: PUSH
48428: LD_INT 0
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: LIST
48435: ST_TO_ADDR
// if GetClass ( i ) = 11 then
48436: LD_VAR 0 6
48440: PPUSH
48441: CALL_OW 257
48445: PUSH
48446: LD_INT 11
48448: EQUAL
48449: IFFALSE 48470
// points := [ 30 , 10 , 5 ] ;
48451: LD_ADDR_VAR 0 9
48455: PUSH
48456: LD_INT 30
48458: PUSH
48459: LD_INT 10
48461: PUSH
48462: LD_INT 5
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: LIST
48469: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
48470: LD_VAR 0 1
48474: PPUSH
48475: LD_INT 5
48477: PPUSH
48478: CALL_OW 321
48482: PUSH
48483: LD_INT 2
48485: EQUAL
48486: IFFALSE 48503
// bpoints := bpoints * 1.8 ;
48488: LD_ADDR_VAR 0 10
48492: PUSH
48493: LD_VAR 0 10
48497: PUSH
48498: LD_REAL  1.80000000000000E+0000
48501: MUL
48502: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
48503: LD_VAR 0 6
48507: PPUSH
48508: CALL_OW 257
48512: PUSH
48513: LD_INT 1
48515: PUSH
48516: LD_INT 2
48518: PUSH
48519: LD_INT 3
48521: PUSH
48522: LD_INT 4
48524: PUSH
48525: EMPTY
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: IN
48531: PUSH
48532: LD_VAR 0 1
48536: PPUSH
48537: LD_INT 51
48539: PPUSH
48540: CALL_OW 321
48544: PUSH
48545: LD_INT 2
48547: EQUAL
48548: AND
48549: IFFALSE 48566
// bpoints := bpoints * 1.2 ;
48551: LD_ADDR_VAR 0 10
48555: PUSH
48556: LD_VAR 0 10
48560: PUSH
48561: LD_REAL  1.20000000000000E+0000
48564: MUL
48565: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
48566: LD_VAR 0 6
48570: PPUSH
48571: CALL_OW 257
48575: PUSH
48576: LD_INT 5
48578: PUSH
48579: LD_INT 7
48581: PUSH
48582: LD_INT 9
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: LIST
48589: IN
48590: PUSH
48591: LD_VAR 0 1
48595: PPUSH
48596: LD_INT 52
48598: PPUSH
48599: CALL_OW 321
48603: PUSH
48604: LD_INT 2
48606: EQUAL
48607: AND
48608: IFFALSE 48625
// bpoints := bpoints * 1.5 ;
48610: LD_ADDR_VAR 0 10
48614: PUSH
48615: LD_VAR 0 10
48619: PUSH
48620: LD_REAL  1.50000000000000E+0000
48623: MUL
48624: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
48625: LD_VAR 0 1
48629: PPUSH
48630: LD_INT 66
48632: PPUSH
48633: CALL_OW 321
48637: PUSH
48638: LD_INT 2
48640: EQUAL
48641: IFFALSE 48658
// bpoints := bpoints * 1.1 ;
48643: LD_ADDR_VAR 0 10
48647: PUSH
48648: LD_VAR 0 10
48652: PUSH
48653: LD_REAL  1.10000000000000E+0000
48656: MUL
48657: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
48658: LD_ADDR_VAR 0 10
48662: PUSH
48663: LD_VAR 0 10
48667: PUSH
48668: LD_VAR 0 6
48672: PPUSH
48673: LD_INT 1
48675: PPUSH
48676: CALL_OW 259
48680: PUSH
48681: LD_REAL  1.15000000000000E+0000
48684: MUL
48685: MUL
48686: ST_TO_ADDR
// end ; unit_vehicle :
48687: GO 49511
48689: LD_INT 2
48691: DOUBLE
48692: EQUAL
48693: IFTRUE 48697
48695: GO 49499
48697: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
48698: LD_VAR 0 6
48702: PPUSH
48703: CALL_OW 264
48707: PUSH
48708: LD_INT 2
48710: PUSH
48711: LD_INT 42
48713: PUSH
48714: LD_INT 24
48716: PUSH
48717: EMPTY
48718: LIST
48719: LIST
48720: LIST
48721: IN
48722: IFFALSE 48743
// points := [ 25 , 5 , 3 ] ;
48724: LD_ADDR_VAR 0 9
48728: PUSH
48729: LD_INT 25
48731: PUSH
48732: LD_INT 5
48734: PUSH
48735: LD_INT 3
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: LIST
48742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
48743: LD_VAR 0 6
48747: PPUSH
48748: CALL_OW 264
48752: PUSH
48753: LD_INT 4
48755: PUSH
48756: LD_INT 43
48758: PUSH
48759: LD_INT 25
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: LIST
48766: IN
48767: IFFALSE 48788
// points := [ 40 , 15 , 5 ] ;
48769: LD_ADDR_VAR 0 9
48773: PUSH
48774: LD_INT 40
48776: PUSH
48777: LD_INT 15
48779: PUSH
48780: LD_INT 5
48782: PUSH
48783: EMPTY
48784: LIST
48785: LIST
48786: LIST
48787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
48788: LD_VAR 0 6
48792: PPUSH
48793: CALL_OW 264
48797: PUSH
48798: LD_INT 3
48800: PUSH
48801: LD_INT 23
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: IN
48808: IFFALSE 48829
// points := [ 7 , 25 , 8 ] ;
48810: LD_ADDR_VAR 0 9
48814: PUSH
48815: LD_INT 7
48817: PUSH
48818: LD_INT 25
48820: PUSH
48821: LD_INT 8
48823: PUSH
48824: EMPTY
48825: LIST
48826: LIST
48827: LIST
48828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
48829: LD_VAR 0 6
48833: PPUSH
48834: CALL_OW 264
48838: PUSH
48839: LD_INT 5
48841: PUSH
48842: LD_INT 27
48844: PUSH
48845: LD_INT 44
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: LIST
48852: IN
48853: IFFALSE 48874
// points := [ 14 , 50 , 16 ] ;
48855: LD_ADDR_VAR 0 9
48859: PUSH
48860: LD_INT 14
48862: PUSH
48863: LD_INT 50
48865: PUSH
48866: LD_INT 16
48868: PUSH
48869: EMPTY
48870: LIST
48871: LIST
48872: LIST
48873: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
48874: LD_VAR 0 6
48878: PPUSH
48879: CALL_OW 264
48883: PUSH
48884: LD_INT 6
48886: PUSH
48887: LD_INT 46
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: IN
48894: IFFALSE 48915
// points := [ 32 , 120 , 70 ] ;
48896: LD_ADDR_VAR 0 9
48900: PUSH
48901: LD_INT 32
48903: PUSH
48904: LD_INT 120
48906: PUSH
48907: LD_INT 70
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
48915: LD_VAR 0 6
48919: PPUSH
48920: CALL_OW 264
48924: PUSH
48925: LD_INT 7
48927: PUSH
48928: LD_INT 28
48930: PUSH
48931: LD_INT 45
48933: PUSH
48934: EMPTY
48935: LIST
48936: LIST
48937: LIST
48938: IN
48939: IFFALSE 48960
// points := [ 35 , 20 , 45 ] ;
48941: LD_ADDR_VAR 0 9
48945: PUSH
48946: LD_INT 35
48948: PUSH
48949: LD_INT 20
48951: PUSH
48952: LD_INT 45
48954: PUSH
48955: EMPTY
48956: LIST
48957: LIST
48958: LIST
48959: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
48960: LD_VAR 0 6
48964: PPUSH
48965: CALL_OW 264
48969: PUSH
48970: LD_INT 47
48972: PUSH
48973: EMPTY
48974: LIST
48975: IN
48976: IFFALSE 48997
// points := [ 67 , 45 , 75 ] ;
48978: LD_ADDR_VAR 0 9
48982: PUSH
48983: LD_INT 67
48985: PUSH
48986: LD_INT 45
48988: PUSH
48989: LD_INT 75
48991: PUSH
48992: EMPTY
48993: LIST
48994: LIST
48995: LIST
48996: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
48997: LD_VAR 0 6
49001: PPUSH
49002: CALL_OW 264
49006: PUSH
49007: LD_INT 26
49009: PUSH
49010: EMPTY
49011: LIST
49012: IN
49013: IFFALSE 49034
// points := [ 120 , 30 , 80 ] ;
49015: LD_ADDR_VAR 0 9
49019: PUSH
49020: LD_INT 120
49022: PUSH
49023: LD_INT 30
49025: PUSH
49026: LD_INT 80
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: LIST
49033: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
49034: LD_VAR 0 6
49038: PPUSH
49039: CALL_OW 264
49043: PUSH
49044: LD_INT 22
49046: PUSH
49047: EMPTY
49048: LIST
49049: IN
49050: IFFALSE 49071
// points := [ 40 , 1 , 1 ] ;
49052: LD_ADDR_VAR 0 9
49056: PUSH
49057: LD_INT 40
49059: PUSH
49060: LD_INT 1
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: LIST
49070: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
49071: LD_VAR 0 6
49075: PPUSH
49076: CALL_OW 264
49080: PUSH
49081: LD_INT 29
49083: PUSH
49084: EMPTY
49085: LIST
49086: IN
49087: IFFALSE 49108
// points := [ 70 , 200 , 400 ] ;
49089: LD_ADDR_VAR 0 9
49093: PUSH
49094: LD_INT 70
49096: PUSH
49097: LD_INT 200
49099: PUSH
49100: LD_INT 400
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: LIST
49107: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
49108: LD_VAR 0 6
49112: PPUSH
49113: CALL_OW 264
49117: PUSH
49118: LD_INT 14
49120: PUSH
49121: LD_INT 53
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: IN
49128: IFFALSE 49149
// points := [ 40 , 10 , 20 ] ;
49130: LD_ADDR_VAR 0 9
49134: PUSH
49135: LD_INT 40
49137: PUSH
49138: LD_INT 10
49140: PUSH
49141: LD_INT 20
49143: PUSH
49144: EMPTY
49145: LIST
49146: LIST
49147: LIST
49148: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
49149: LD_VAR 0 6
49153: PPUSH
49154: CALL_OW 264
49158: PUSH
49159: LD_INT 9
49161: PUSH
49162: EMPTY
49163: LIST
49164: IN
49165: IFFALSE 49186
// points := [ 5 , 70 , 20 ] ;
49167: LD_ADDR_VAR 0 9
49171: PUSH
49172: LD_INT 5
49174: PUSH
49175: LD_INT 70
49177: PUSH
49178: LD_INT 20
49180: PUSH
49181: EMPTY
49182: LIST
49183: LIST
49184: LIST
49185: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
49186: LD_VAR 0 6
49190: PPUSH
49191: CALL_OW 264
49195: PUSH
49196: LD_INT 10
49198: PUSH
49199: EMPTY
49200: LIST
49201: IN
49202: IFFALSE 49223
// points := [ 35 , 110 , 70 ] ;
49204: LD_ADDR_VAR 0 9
49208: PUSH
49209: LD_INT 35
49211: PUSH
49212: LD_INT 110
49214: PUSH
49215: LD_INT 70
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: LIST
49222: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
49223: LD_VAR 0 6
49227: PPUSH
49228: CALL_OW 265
49232: PUSH
49233: LD_INT 25
49235: EQUAL
49236: IFFALSE 49257
// points := [ 80 , 65 , 100 ] ;
49238: LD_ADDR_VAR 0 9
49242: PUSH
49243: LD_INT 80
49245: PUSH
49246: LD_INT 65
49248: PUSH
49249: LD_INT 100
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: LIST
49256: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
49257: LD_VAR 0 6
49261: PPUSH
49262: CALL_OW 263
49266: PUSH
49267: LD_INT 1
49269: EQUAL
49270: IFFALSE 49305
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
49272: LD_ADDR_VAR 0 10
49276: PUSH
49277: LD_VAR 0 10
49281: PUSH
49282: LD_VAR 0 6
49286: PPUSH
49287: CALL_OW 311
49291: PPUSH
49292: LD_INT 3
49294: PPUSH
49295: CALL_OW 259
49299: PUSH
49300: LD_INT 4
49302: MUL
49303: MUL
49304: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
49305: LD_VAR 0 6
49309: PPUSH
49310: CALL_OW 263
49314: PUSH
49315: LD_INT 2
49317: EQUAL
49318: IFFALSE 49369
// begin j := IsControledBy ( i ) ;
49320: LD_ADDR_VAR 0 7
49324: PUSH
49325: LD_VAR 0 6
49329: PPUSH
49330: CALL_OW 312
49334: ST_TO_ADDR
// if j then
49335: LD_VAR 0 7
49339: IFFALSE 49369
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
49341: LD_ADDR_VAR 0 10
49345: PUSH
49346: LD_VAR 0 10
49350: PUSH
49351: LD_VAR 0 7
49355: PPUSH
49356: LD_INT 3
49358: PPUSH
49359: CALL_OW 259
49363: PUSH
49364: LD_INT 3
49366: MUL
49367: MUL
49368: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
49369: LD_VAR 0 6
49373: PPUSH
49374: CALL_OW 264
49378: PUSH
49379: LD_INT 5
49381: PUSH
49382: LD_INT 6
49384: PUSH
49385: LD_INT 46
49387: PUSH
49388: LD_INT 44
49390: PUSH
49391: LD_INT 47
49393: PUSH
49394: LD_INT 45
49396: PUSH
49397: LD_INT 28
49399: PUSH
49400: LD_INT 7
49402: PUSH
49403: LD_INT 27
49405: PUSH
49406: LD_INT 29
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: IN
49421: PUSH
49422: LD_VAR 0 1
49426: PPUSH
49427: LD_INT 52
49429: PPUSH
49430: CALL_OW 321
49434: PUSH
49435: LD_INT 2
49437: EQUAL
49438: AND
49439: IFFALSE 49456
// bpoints := bpoints * 1.2 ;
49441: LD_ADDR_VAR 0 10
49445: PUSH
49446: LD_VAR 0 10
49450: PUSH
49451: LD_REAL  1.20000000000000E+0000
49454: MUL
49455: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
49456: LD_VAR 0 6
49460: PPUSH
49461: CALL_OW 264
49465: PUSH
49466: LD_INT 6
49468: PUSH
49469: LD_INT 46
49471: PUSH
49472: LD_INT 47
49474: PUSH
49475: EMPTY
49476: LIST
49477: LIST
49478: LIST
49479: IN
49480: IFFALSE 49497
// bpoints := bpoints * 1.2 ;
49482: LD_ADDR_VAR 0 10
49486: PUSH
49487: LD_VAR 0 10
49491: PUSH
49492: LD_REAL  1.20000000000000E+0000
49495: MUL
49496: ST_TO_ADDR
// end ; unit_building :
49497: GO 49511
49499: LD_INT 3
49501: DOUBLE
49502: EQUAL
49503: IFTRUE 49507
49505: GO 49510
49507: POP
// ; end ;
49508: GO 49511
49510: POP
// for j = 1 to 3 do
49511: LD_ADDR_VAR 0 7
49515: PUSH
49516: DOUBLE
49517: LD_INT 1
49519: DEC
49520: ST_TO_ADDR
49521: LD_INT 3
49523: PUSH
49524: FOR_TO
49525: IFFALSE 49578
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
49527: LD_ADDR_VAR 0 5
49531: PUSH
49532: LD_VAR 0 5
49536: PPUSH
49537: LD_VAR 0 7
49541: PPUSH
49542: LD_VAR 0 5
49546: PUSH
49547: LD_VAR 0 7
49551: ARRAY
49552: PUSH
49553: LD_VAR 0 9
49557: PUSH
49558: LD_VAR 0 7
49562: ARRAY
49563: PUSH
49564: LD_VAR 0 10
49568: MUL
49569: PLUS
49570: PPUSH
49571: CALL_OW 1
49575: ST_TO_ADDR
49576: GO 49524
49578: POP
49579: POP
// end ;
49580: GO 48063
49582: POP
49583: POP
// result := Replace ( result , 4 , tmp ) ;
49584: LD_ADDR_VAR 0 5
49588: PUSH
49589: LD_VAR 0 5
49593: PPUSH
49594: LD_INT 4
49596: PPUSH
49597: LD_VAR 0 8
49601: PPUSH
49602: CALL_OW 1
49606: ST_TO_ADDR
// end ;
49607: LD_VAR 0 5
49611: RET
// export function DangerAtRange ( unit , range ) ; begin
49612: LD_INT 0
49614: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
49615: LD_ADDR_VAR 0 3
49619: PUSH
49620: LD_VAR 0 1
49624: PPUSH
49625: CALL_OW 255
49629: PPUSH
49630: LD_VAR 0 1
49634: PPUSH
49635: CALL_OW 250
49639: PPUSH
49640: LD_VAR 0 1
49644: PPUSH
49645: CALL_OW 251
49649: PPUSH
49650: LD_VAR 0 2
49654: PPUSH
49655: CALL 47915 0 4
49659: ST_TO_ADDR
// end ;
49660: LD_VAR 0 3
49664: RET
// export function DangerInArea ( side , area ) ; begin
49665: LD_INT 0
49667: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
49668: LD_ADDR_VAR 0 3
49672: PUSH
49673: LD_VAR 0 2
49677: PPUSH
49678: LD_INT 81
49680: PUSH
49681: LD_VAR 0 1
49685: PUSH
49686: EMPTY
49687: LIST
49688: LIST
49689: PPUSH
49690: CALL_OW 70
49694: ST_TO_ADDR
// end ;
49695: LD_VAR 0 3
49699: RET
// export function IsExtension ( b ) ; begin
49700: LD_INT 0
49702: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
49703: LD_ADDR_VAR 0 2
49707: PUSH
49708: LD_VAR 0 1
49712: PUSH
49713: LD_INT 23
49715: PUSH
49716: LD_INT 20
49718: PUSH
49719: LD_INT 22
49721: PUSH
49722: LD_INT 17
49724: PUSH
49725: LD_INT 24
49727: PUSH
49728: LD_INT 21
49730: PUSH
49731: LD_INT 19
49733: PUSH
49734: LD_INT 16
49736: PUSH
49737: LD_INT 25
49739: PUSH
49740: LD_INT 18
49742: PUSH
49743: EMPTY
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: LIST
49751: LIST
49752: LIST
49753: LIST
49754: IN
49755: ST_TO_ADDR
// end ;
49756: LD_VAR 0 2
49760: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
49761: LD_INT 0
49763: PPUSH
49764: PPUSH
49765: PPUSH
// result := [ ] ;
49766: LD_ADDR_VAR 0 3
49770: PUSH
49771: EMPTY
49772: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
49773: LD_ADDR_VAR 0 4
49777: PUSH
49778: LD_VAR 0 2
49782: PPUSH
49783: LD_INT 21
49785: PUSH
49786: LD_INT 3
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: PPUSH
49793: CALL_OW 70
49797: ST_TO_ADDR
// if not tmp then
49798: LD_VAR 0 4
49802: NOT
49803: IFFALSE 49807
// exit ;
49805: GO 49865
// for i in tmp do
49807: LD_ADDR_VAR 0 5
49811: PUSH
49812: LD_VAR 0 4
49816: PUSH
49817: FOR_IN
49818: IFFALSE 49853
// if GetBase ( i ) <> base then
49820: LD_VAR 0 5
49824: PPUSH
49825: CALL_OW 274
49829: PUSH
49830: LD_VAR 0 1
49834: NONEQUAL
49835: IFFALSE 49851
// ComLinkToBase ( base , i ) ;
49837: LD_VAR 0 1
49841: PPUSH
49842: LD_VAR 0 5
49846: PPUSH
49847: CALL_OW 169
49851: GO 49817
49853: POP
49854: POP
// result := tmp ;
49855: LD_ADDR_VAR 0 3
49859: PUSH
49860: LD_VAR 0 4
49864: ST_TO_ADDR
// end ;
49865: LD_VAR 0 3
49869: RET
// export function ComComplete ( unit , b ) ; var i ; begin
49870: LD_INT 0
49872: PPUSH
49873: PPUSH
// if BuildingStatus ( b ) = bs_build then
49874: LD_VAR 0 2
49878: PPUSH
49879: CALL_OW 461
49883: PUSH
49884: LD_INT 1
49886: EQUAL
49887: IFFALSE 49947
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
49889: LD_VAR 0 1
49893: PPUSH
49894: LD_STRING h
49896: PUSH
49897: LD_VAR 0 2
49901: PPUSH
49902: CALL_OW 250
49906: PUSH
49907: LD_VAR 0 2
49911: PPUSH
49912: CALL_OW 251
49916: PUSH
49917: LD_VAR 0 2
49921: PUSH
49922: LD_INT 0
49924: PUSH
49925: LD_INT 0
49927: PUSH
49928: LD_INT 0
49930: PUSH
49931: EMPTY
49932: LIST
49933: LIST
49934: LIST
49935: LIST
49936: LIST
49937: LIST
49938: LIST
49939: PUSH
49940: EMPTY
49941: LIST
49942: PPUSH
49943: CALL_OW 446
// end ;
49947: LD_VAR 0 3
49951: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
49952: LD_INT 0
49954: PPUSH
49955: PPUSH
49956: PPUSH
49957: PPUSH
49958: PPUSH
49959: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
49960: LD_VAR 0 1
49964: NOT
49965: PUSH
49966: LD_VAR 0 1
49970: PPUSH
49971: CALL_OW 263
49975: PUSH
49976: LD_INT 2
49978: EQUAL
49979: NOT
49980: OR
49981: IFFALSE 49985
// exit ;
49983: GO 50301
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
49985: LD_ADDR_VAR 0 6
49989: PUSH
49990: LD_INT 22
49992: PUSH
49993: LD_VAR 0 1
49997: PPUSH
49998: CALL_OW 255
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PUSH
50007: LD_INT 2
50009: PUSH
50010: LD_INT 30
50012: PUSH
50013: LD_INT 36
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 34
50022: PUSH
50023: LD_INT 31
50025: PUSH
50026: EMPTY
50027: LIST
50028: LIST
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: LIST
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PPUSH
50039: CALL_OW 69
50043: ST_TO_ADDR
// if not tmp then
50044: LD_VAR 0 6
50048: NOT
50049: IFFALSE 50053
// exit ;
50051: GO 50301
// result := [ ] ;
50053: LD_ADDR_VAR 0 2
50057: PUSH
50058: EMPTY
50059: ST_TO_ADDR
// for i in tmp do
50060: LD_ADDR_VAR 0 3
50064: PUSH
50065: LD_VAR 0 6
50069: PUSH
50070: FOR_IN
50071: IFFALSE 50142
// begin t := UnitsInside ( i ) ;
50073: LD_ADDR_VAR 0 4
50077: PUSH
50078: LD_VAR 0 3
50082: PPUSH
50083: CALL_OW 313
50087: ST_TO_ADDR
// if t then
50088: LD_VAR 0 4
50092: IFFALSE 50140
// for j in t do
50094: LD_ADDR_VAR 0 7
50098: PUSH
50099: LD_VAR 0 4
50103: PUSH
50104: FOR_IN
50105: IFFALSE 50138
// result := Insert ( result , result + 1 , j ) ;
50107: LD_ADDR_VAR 0 2
50111: PUSH
50112: LD_VAR 0 2
50116: PPUSH
50117: LD_VAR 0 2
50121: PUSH
50122: LD_INT 1
50124: PLUS
50125: PPUSH
50126: LD_VAR 0 7
50130: PPUSH
50131: CALL_OW 2
50135: ST_TO_ADDR
50136: GO 50104
50138: POP
50139: POP
// end ;
50140: GO 50070
50142: POP
50143: POP
// if not result then
50144: LD_VAR 0 2
50148: NOT
50149: IFFALSE 50153
// exit ;
50151: GO 50301
// mech := result [ 1 ] ;
50153: LD_ADDR_VAR 0 5
50157: PUSH
50158: LD_VAR 0 2
50162: PUSH
50163: LD_INT 1
50165: ARRAY
50166: ST_TO_ADDR
// if result > 1 then
50167: LD_VAR 0 2
50171: PUSH
50172: LD_INT 1
50174: GREATER
50175: IFFALSE 50287
// for i = 2 to result do
50177: LD_ADDR_VAR 0 3
50181: PUSH
50182: DOUBLE
50183: LD_INT 2
50185: DEC
50186: ST_TO_ADDR
50187: LD_VAR 0 2
50191: PUSH
50192: FOR_TO
50193: IFFALSE 50285
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
50195: LD_ADDR_VAR 0 4
50199: PUSH
50200: LD_VAR 0 2
50204: PUSH
50205: LD_VAR 0 3
50209: ARRAY
50210: PPUSH
50211: LD_INT 3
50213: PPUSH
50214: CALL_OW 259
50218: PUSH
50219: LD_VAR 0 2
50223: PUSH
50224: LD_VAR 0 3
50228: ARRAY
50229: PPUSH
50230: CALL_OW 432
50234: MINUS
50235: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
50236: LD_VAR 0 4
50240: PUSH
50241: LD_VAR 0 5
50245: PPUSH
50246: LD_INT 3
50248: PPUSH
50249: CALL_OW 259
50253: PUSH
50254: LD_VAR 0 5
50258: PPUSH
50259: CALL_OW 432
50263: MINUS
50264: GREATEREQUAL
50265: IFFALSE 50283
// mech := result [ i ] ;
50267: LD_ADDR_VAR 0 5
50271: PUSH
50272: LD_VAR 0 2
50276: PUSH
50277: LD_VAR 0 3
50281: ARRAY
50282: ST_TO_ADDR
// end ;
50283: GO 50192
50285: POP
50286: POP
// ComLinkTo ( vehicle , mech ) ;
50287: LD_VAR 0 1
50291: PPUSH
50292: LD_VAR 0 5
50296: PPUSH
50297: CALL_OW 135
// end ;
50301: LD_VAR 0 2
50305: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
50306: LD_INT 0
50308: PPUSH
50309: PPUSH
50310: PPUSH
50311: PPUSH
50312: PPUSH
50313: PPUSH
50314: PPUSH
50315: PPUSH
50316: PPUSH
50317: PPUSH
50318: PPUSH
50319: PPUSH
50320: PPUSH
// result := [ ] ;
50321: LD_ADDR_VAR 0 7
50325: PUSH
50326: EMPTY
50327: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
50328: LD_VAR 0 1
50332: PPUSH
50333: CALL_OW 266
50337: PUSH
50338: LD_INT 0
50340: PUSH
50341: LD_INT 1
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: IN
50348: NOT
50349: IFFALSE 50353
// exit ;
50351: GO 51984
// if name then
50353: LD_VAR 0 3
50357: IFFALSE 50373
// SetBName ( base_dep , name ) ;
50359: LD_VAR 0 1
50363: PPUSH
50364: LD_VAR 0 3
50368: PPUSH
50369: CALL_OW 500
// base := GetBase ( base_dep ) ;
50373: LD_ADDR_VAR 0 15
50377: PUSH
50378: LD_VAR 0 1
50382: PPUSH
50383: CALL_OW 274
50387: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
50388: LD_ADDR_VAR 0 16
50392: PUSH
50393: LD_VAR 0 1
50397: PPUSH
50398: CALL_OW 255
50402: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
50403: LD_ADDR_VAR 0 17
50407: PUSH
50408: LD_VAR 0 1
50412: PPUSH
50413: CALL_OW 248
50417: ST_TO_ADDR
// if sources then
50418: LD_VAR 0 5
50422: IFFALSE 50469
// for i = 1 to 3 do
50424: LD_ADDR_VAR 0 8
50428: PUSH
50429: DOUBLE
50430: LD_INT 1
50432: DEC
50433: ST_TO_ADDR
50434: LD_INT 3
50436: PUSH
50437: FOR_TO
50438: IFFALSE 50467
// AddResourceType ( base , i , sources [ i ] ) ;
50440: LD_VAR 0 15
50444: PPUSH
50445: LD_VAR 0 8
50449: PPUSH
50450: LD_VAR 0 5
50454: PUSH
50455: LD_VAR 0 8
50459: ARRAY
50460: PPUSH
50461: CALL_OW 276
50465: GO 50437
50467: POP
50468: POP
// buildings := GetBaseBuildings ( base , area ) ;
50469: LD_ADDR_VAR 0 18
50473: PUSH
50474: LD_VAR 0 15
50478: PPUSH
50479: LD_VAR 0 2
50483: PPUSH
50484: CALL 49761 0 2
50488: ST_TO_ADDR
// InitHc ;
50489: CALL_OW 19
// InitUc ;
50493: CALL_OW 18
// uc_side := side ;
50497: LD_ADDR_OWVAR 20
50501: PUSH
50502: LD_VAR 0 16
50506: ST_TO_ADDR
// uc_nation := nation ;
50507: LD_ADDR_OWVAR 21
50511: PUSH
50512: LD_VAR 0 17
50516: ST_TO_ADDR
// if buildings then
50517: LD_VAR 0 18
50521: IFFALSE 51843
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
50523: LD_ADDR_VAR 0 19
50527: PUSH
50528: LD_VAR 0 18
50532: PPUSH
50533: LD_INT 2
50535: PUSH
50536: LD_INT 30
50538: PUSH
50539: LD_INT 29
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: PUSH
50546: LD_INT 30
50548: PUSH
50549: LD_INT 30
50551: PUSH
50552: EMPTY
50553: LIST
50554: LIST
50555: PUSH
50556: EMPTY
50557: LIST
50558: LIST
50559: LIST
50560: PPUSH
50561: CALL_OW 72
50565: ST_TO_ADDR
// if tmp then
50566: LD_VAR 0 19
50570: IFFALSE 50618
// for i in tmp do
50572: LD_ADDR_VAR 0 8
50576: PUSH
50577: LD_VAR 0 19
50581: PUSH
50582: FOR_IN
50583: IFFALSE 50616
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
50585: LD_VAR 0 8
50589: PPUSH
50590: CALL_OW 250
50594: PPUSH
50595: LD_VAR 0 8
50599: PPUSH
50600: CALL_OW 251
50604: PPUSH
50605: LD_VAR 0 16
50609: PPUSH
50610: CALL_OW 441
50614: GO 50582
50616: POP
50617: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
50618: LD_VAR 0 18
50622: PPUSH
50623: LD_INT 2
50625: PUSH
50626: LD_INT 30
50628: PUSH
50629: LD_INT 32
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 30
50638: PUSH
50639: LD_INT 33
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: LIST
50650: PPUSH
50651: CALL_OW 72
50655: IFFALSE 50743
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
50657: LD_ADDR_VAR 0 8
50661: PUSH
50662: LD_VAR 0 18
50666: PPUSH
50667: LD_INT 2
50669: PUSH
50670: LD_INT 30
50672: PUSH
50673: LD_INT 32
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 30
50682: PUSH
50683: LD_INT 33
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: EMPTY
50691: LIST
50692: LIST
50693: LIST
50694: PPUSH
50695: CALL_OW 72
50699: PUSH
50700: FOR_IN
50701: IFFALSE 50741
// begin if not GetBWeapon ( i ) then
50703: LD_VAR 0 8
50707: PPUSH
50708: CALL_OW 269
50712: NOT
50713: IFFALSE 50739
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
50715: LD_VAR 0 8
50719: PPUSH
50720: LD_VAR 0 8
50724: PPUSH
50725: LD_VAR 0 2
50729: PPUSH
50730: CALL 51989 0 2
50734: PPUSH
50735: CALL_OW 431
// end ;
50739: GO 50700
50741: POP
50742: POP
// end ; for i = 1 to personel do
50743: LD_ADDR_VAR 0 8
50747: PUSH
50748: DOUBLE
50749: LD_INT 1
50751: DEC
50752: ST_TO_ADDR
50753: LD_VAR 0 6
50757: PUSH
50758: FOR_TO
50759: IFFALSE 51823
// begin if i > 4 then
50761: LD_VAR 0 8
50765: PUSH
50766: LD_INT 4
50768: GREATER
50769: IFFALSE 50773
// break ;
50771: GO 51823
// case i of 1 :
50773: LD_VAR 0 8
50777: PUSH
50778: LD_INT 1
50780: DOUBLE
50781: EQUAL
50782: IFTRUE 50786
50784: GO 50866
50786: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
50787: LD_ADDR_VAR 0 12
50791: PUSH
50792: LD_VAR 0 18
50796: PPUSH
50797: LD_INT 22
50799: PUSH
50800: LD_VAR 0 16
50804: PUSH
50805: EMPTY
50806: LIST
50807: LIST
50808: PUSH
50809: LD_INT 58
50811: PUSH
50812: EMPTY
50813: LIST
50814: PUSH
50815: LD_INT 2
50817: PUSH
50818: LD_INT 30
50820: PUSH
50821: LD_INT 32
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: LD_INT 30
50830: PUSH
50831: LD_INT 4
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_INT 30
50840: PUSH
50841: LD_INT 5
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: PUSH
50848: EMPTY
50849: LIST
50850: LIST
50851: LIST
50852: LIST
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: LIST
50858: PPUSH
50859: CALL_OW 72
50863: ST_TO_ADDR
50864: GO 51088
50866: LD_INT 2
50868: DOUBLE
50869: EQUAL
50870: IFTRUE 50874
50872: GO 50936
50874: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
50875: LD_ADDR_VAR 0 12
50879: PUSH
50880: LD_VAR 0 18
50884: PPUSH
50885: LD_INT 22
50887: PUSH
50888: LD_VAR 0 16
50892: PUSH
50893: EMPTY
50894: LIST
50895: LIST
50896: PUSH
50897: LD_INT 2
50899: PUSH
50900: LD_INT 30
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 30
50912: PUSH
50913: LD_INT 1
50915: PUSH
50916: EMPTY
50917: LIST
50918: LIST
50919: PUSH
50920: EMPTY
50921: LIST
50922: LIST
50923: LIST
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: PPUSH
50929: CALL_OW 72
50933: ST_TO_ADDR
50934: GO 51088
50936: LD_INT 3
50938: DOUBLE
50939: EQUAL
50940: IFTRUE 50944
50942: GO 51006
50944: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
50945: LD_ADDR_VAR 0 12
50949: PUSH
50950: LD_VAR 0 18
50954: PPUSH
50955: LD_INT 22
50957: PUSH
50958: LD_VAR 0 16
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PUSH
50967: LD_INT 2
50969: PUSH
50970: LD_INT 30
50972: PUSH
50973: LD_INT 2
50975: PUSH
50976: EMPTY
50977: LIST
50978: LIST
50979: PUSH
50980: LD_INT 30
50982: PUSH
50983: LD_INT 3
50985: PUSH
50986: EMPTY
50987: LIST
50988: LIST
50989: PUSH
50990: EMPTY
50991: LIST
50992: LIST
50993: LIST
50994: PUSH
50995: EMPTY
50996: LIST
50997: LIST
50998: PPUSH
50999: CALL_OW 72
51003: ST_TO_ADDR
51004: GO 51088
51006: LD_INT 4
51008: DOUBLE
51009: EQUAL
51010: IFTRUE 51014
51012: GO 51087
51014: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
51015: LD_ADDR_VAR 0 12
51019: PUSH
51020: LD_VAR 0 18
51024: PPUSH
51025: LD_INT 22
51027: PUSH
51028: LD_VAR 0 16
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: PUSH
51037: LD_INT 2
51039: PUSH
51040: LD_INT 30
51042: PUSH
51043: LD_INT 6
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PUSH
51050: LD_INT 30
51052: PUSH
51053: LD_INT 7
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: PUSH
51060: LD_INT 30
51062: PUSH
51063: LD_INT 8
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PUSH
51070: EMPTY
51071: LIST
51072: LIST
51073: LIST
51074: LIST
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: PPUSH
51080: CALL_OW 72
51084: ST_TO_ADDR
51085: GO 51088
51087: POP
// if i = 1 then
51088: LD_VAR 0 8
51092: PUSH
51093: LD_INT 1
51095: EQUAL
51096: IFFALSE 51207
// begin tmp := [ ] ;
51098: LD_ADDR_VAR 0 19
51102: PUSH
51103: EMPTY
51104: ST_TO_ADDR
// for j in f do
51105: LD_ADDR_VAR 0 9
51109: PUSH
51110: LD_VAR 0 12
51114: PUSH
51115: FOR_IN
51116: IFFALSE 51189
// if GetBType ( j ) = b_bunker then
51118: LD_VAR 0 9
51122: PPUSH
51123: CALL_OW 266
51127: PUSH
51128: LD_INT 32
51130: EQUAL
51131: IFFALSE 51158
// tmp := Insert ( tmp , 1 , j ) else
51133: LD_ADDR_VAR 0 19
51137: PUSH
51138: LD_VAR 0 19
51142: PPUSH
51143: LD_INT 1
51145: PPUSH
51146: LD_VAR 0 9
51150: PPUSH
51151: CALL_OW 2
51155: ST_TO_ADDR
51156: GO 51187
// tmp := Insert ( tmp , tmp + 1 , j ) ;
51158: LD_ADDR_VAR 0 19
51162: PUSH
51163: LD_VAR 0 19
51167: PPUSH
51168: LD_VAR 0 19
51172: PUSH
51173: LD_INT 1
51175: PLUS
51176: PPUSH
51177: LD_VAR 0 9
51181: PPUSH
51182: CALL_OW 2
51186: ST_TO_ADDR
51187: GO 51115
51189: POP
51190: POP
// if tmp then
51191: LD_VAR 0 19
51195: IFFALSE 51207
// f := tmp ;
51197: LD_ADDR_VAR 0 12
51201: PUSH
51202: LD_VAR 0 19
51206: ST_TO_ADDR
// end ; x := personel [ i ] ;
51207: LD_ADDR_VAR 0 13
51211: PUSH
51212: LD_VAR 0 6
51216: PUSH
51217: LD_VAR 0 8
51221: ARRAY
51222: ST_TO_ADDR
// if x = - 1 then
51223: LD_VAR 0 13
51227: PUSH
51228: LD_INT 1
51230: NEG
51231: EQUAL
51232: IFFALSE 51441
// begin for j in f do
51234: LD_ADDR_VAR 0 9
51238: PUSH
51239: LD_VAR 0 12
51243: PUSH
51244: FOR_IN
51245: IFFALSE 51437
// repeat InitHc ;
51247: CALL_OW 19
// if GetBType ( j ) = b_barracks then
51251: LD_VAR 0 9
51255: PPUSH
51256: CALL_OW 266
51260: PUSH
51261: LD_INT 5
51263: EQUAL
51264: IFFALSE 51334
// begin if UnitsInside ( j ) < 3 then
51266: LD_VAR 0 9
51270: PPUSH
51271: CALL_OW 313
51275: PUSH
51276: LD_INT 3
51278: LESS
51279: IFFALSE 51315
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
51281: LD_INT 0
51283: PPUSH
51284: LD_INT 5
51286: PUSH
51287: LD_INT 8
51289: PUSH
51290: LD_INT 9
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: LIST
51297: PUSH
51298: LD_VAR 0 17
51302: ARRAY
51303: PPUSH
51304: LD_VAR 0 4
51308: PPUSH
51309: CALL_OW 380
51313: GO 51332
// PrepareHuman ( false , i , skill ) ;
51315: LD_INT 0
51317: PPUSH
51318: LD_VAR 0 8
51322: PPUSH
51323: LD_VAR 0 4
51327: PPUSH
51328: CALL_OW 380
// end else
51332: GO 51351
// PrepareHuman ( false , i , skill ) ;
51334: LD_INT 0
51336: PPUSH
51337: LD_VAR 0 8
51341: PPUSH
51342: LD_VAR 0 4
51346: PPUSH
51347: CALL_OW 380
// un := CreateHuman ;
51351: LD_ADDR_VAR 0 14
51355: PUSH
51356: CALL_OW 44
51360: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51361: LD_ADDR_VAR 0 7
51365: PUSH
51366: LD_VAR 0 7
51370: PPUSH
51371: LD_INT 1
51373: PPUSH
51374: LD_VAR 0 14
51378: PPUSH
51379: CALL_OW 2
51383: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
51384: LD_VAR 0 14
51388: PPUSH
51389: LD_VAR 0 9
51393: PPUSH
51394: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
51398: LD_VAR 0 9
51402: PPUSH
51403: CALL_OW 313
51407: PUSH
51408: LD_INT 6
51410: EQUAL
51411: PUSH
51412: LD_VAR 0 9
51416: PPUSH
51417: CALL_OW 266
51421: PUSH
51422: LD_INT 32
51424: PUSH
51425: LD_INT 31
51427: PUSH
51428: EMPTY
51429: LIST
51430: LIST
51431: IN
51432: OR
51433: IFFALSE 51247
51435: GO 51244
51437: POP
51438: POP
// end else
51439: GO 51821
// for j = 1 to x do
51441: LD_ADDR_VAR 0 9
51445: PUSH
51446: DOUBLE
51447: LD_INT 1
51449: DEC
51450: ST_TO_ADDR
51451: LD_VAR 0 13
51455: PUSH
51456: FOR_TO
51457: IFFALSE 51819
// begin InitHc ;
51459: CALL_OW 19
// if not f then
51463: LD_VAR 0 12
51467: NOT
51468: IFFALSE 51557
// begin PrepareHuman ( false , i , skill ) ;
51470: LD_INT 0
51472: PPUSH
51473: LD_VAR 0 8
51477: PPUSH
51478: LD_VAR 0 4
51482: PPUSH
51483: CALL_OW 380
// un := CreateHuman ;
51487: LD_ADDR_VAR 0 14
51491: PUSH
51492: CALL_OW 44
51496: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51497: LD_ADDR_VAR 0 7
51501: PUSH
51502: LD_VAR 0 7
51506: PPUSH
51507: LD_INT 1
51509: PPUSH
51510: LD_VAR 0 14
51514: PPUSH
51515: CALL_OW 2
51519: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
51520: LD_VAR 0 14
51524: PPUSH
51525: LD_VAR 0 1
51529: PPUSH
51530: CALL_OW 250
51534: PPUSH
51535: LD_VAR 0 1
51539: PPUSH
51540: CALL_OW 251
51544: PPUSH
51545: LD_INT 10
51547: PPUSH
51548: LD_INT 0
51550: PPUSH
51551: CALL_OW 50
// continue ;
51555: GO 51456
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
51557: LD_VAR 0 12
51561: PUSH
51562: LD_INT 1
51564: ARRAY
51565: PPUSH
51566: CALL_OW 313
51570: PUSH
51571: LD_VAR 0 12
51575: PUSH
51576: LD_INT 1
51578: ARRAY
51579: PPUSH
51580: CALL_OW 266
51584: PUSH
51585: LD_INT 32
51587: PUSH
51588: LD_INT 31
51590: PUSH
51591: EMPTY
51592: LIST
51593: LIST
51594: IN
51595: AND
51596: PUSH
51597: LD_VAR 0 12
51601: PUSH
51602: LD_INT 1
51604: ARRAY
51605: PPUSH
51606: CALL_OW 313
51610: PUSH
51611: LD_INT 6
51613: EQUAL
51614: OR
51615: IFFALSE 51635
// f := Delete ( f , 1 ) ;
51617: LD_ADDR_VAR 0 12
51621: PUSH
51622: LD_VAR 0 12
51626: PPUSH
51627: LD_INT 1
51629: PPUSH
51630: CALL_OW 3
51634: ST_TO_ADDR
// if not f then
51635: LD_VAR 0 12
51639: NOT
51640: IFFALSE 51658
// begin x := x + 2 ;
51642: LD_ADDR_VAR 0 13
51646: PUSH
51647: LD_VAR 0 13
51651: PUSH
51652: LD_INT 2
51654: PLUS
51655: ST_TO_ADDR
// continue ;
51656: GO 51456
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
51658: LD_VAR 0 12
51662: PUSH
51663: LD_INT 1
51665: ARRAY
51666: PPUSH
51667: CALL_OW 266
51671: PUSH
51672: LD_INT 5
51674: EQUAL
51675: IFFALSE 51749
// begin if UnitsInside ( f [ 1 ] ) < 3 then
51677: LD_VAR 0 12
51681: PUSH
51682: LD_INT 1
51684: ARRAY
51685: PPUSH
51686: CALL_OW 313
51690: PUSH
51691: LD_INT 3
51693: LESS
51694: IFFALSE 51730
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
51696: LD_INT 0
51698: PPUSH
51699: LD_INT 5
51701: PUSH
51702: LD_INT 8
51704: PUSH
51705: LD_INT 9
51707: PUSH
51708: EMPTY
51709: LIST
51710: LIST
51711: LIST
51712: PUSH
51713: LD_VAR 0 17
51717: ARRAY
51718: PPUSH
51719: LD_VAR 0 4
51723: PPUSH
51724: CALL_OW 380
51728: GO 51747
// PrepareHuman ( false , i , skill ) ;
51730: LD_INT 0
51732: PPUSH
51733: LD_VAR 0 8
51737: PPUSH
51738: LD_VAR 0 4
51742: PPUSH
51743: CALL_OW 380
// end else
51747: GO 51766
// PrepareHuman ( false , i , skill ) ;
51749: LD_INT 0
51751: PPUSH
51752: LD_VAR 0 8
51756: PPUSH
51757: LD_VAR 0 4
51761: PPUSH
51762: CALL_OW 380
// un := CreateHuman ;
51766: LD_ADDR_VAR 0 14
51770: PUSH
51771: CALL_OW 44
51775: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51776: LD_ADDR_VAR 0 7
51780: PUSH
51781: LD_VAR 0 7
51785: PPUSH
51786: LD_INT 1
51788: PPUSH
51789: LD_VAR 0 14
51793: PPUSH
51794: CALL_OW 2
51798: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
51799: LD_VAR 0 14
51803: PPUSH
51804: LD_VAR 0 12
51808: PUSH
51809: LD_INT 1
51811: ARRAY
51812: PPUSH
51813: CALL_OW 52
// end ;
51817: GO 51456
51819: POP
51820: POP
// end ;
51821: GO 50758
51823: POP
51824: POP
// result := result ^ buildings ;
51825: LD_ADDR_VAR 0 7
51829: PUSH
51830: LD_VAR 0 7
51834: PUSH
51835: LD_VAR 0 18
51839: ADD
51840: ST_TO_ADDR
// end else
51841: GO 51984
// begin for i = 1 to personel do
51843: LD_ADDR_VAR 0 8
51847: PUSH
51848: DOUBLE
51849: LD_INT 1
51851: DEC
51852: ST_TO_ADDR
51853: LD_VAR 0 6
51857: PUSH
51858: FOR_TO
51859: IFFALSE 51982
// begin if i > 4 then
51861: LD_VAR 0 8
51865: PUSH
51866: LD_INT 4
51868: GREATER
51869: IFFALSE 51873
// break ;
51871: GO 51982
// x := personel [ i ] ;
51873: LD_ADDR_VAR 0 13
51877: PUSH
51878: LD_VAR 0 6
51882: PUSH
51883: LD_VAR 0 8
51887: ARRAY
51888: ST_TO_ADDR
// if x = - 1 then
51889: LD_VAR 0 13
51893: PUSH
51894: LD_INT 1
51896: NEG
51897: EQUAL
51898: IFFALSE 51902
// continue ;
51900: GO 51858
// PrepareHuman ( false , i , skill ) ;
51902: LD_INT 0
51904: PPUSH
51905: LD_VAR 0 8
51909: PPUSH
51910: LD_VAR 0 4
51914: PPUSH
51915: CALL_OW 380
// un := CreateHuman ;
51919: LD_ADDR_VAR 0 14
51923: PUSH
51924: CALL_OW 44
51928: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
51929: LD_VAR 0 14
51933: PPUSH
51934: LD_VAR 0 1
51938: PPUSH
51939: CALL_OW 250
51943: PPUSH
51944: LD_VAR 0 1
51948: PPUSH
51949: CALL_OW 251
51953: PPUSH
51954: LD_INT 10
51956: PPUSH
51957: LD_INT 0
51959: PPUSH
51960: CALL_OW 50
// result := result ^ un ;
51964: LD_ADDR_VAR 0 7
51968: PUSH
51969: LD_VAR 0 7
51973: PUSH
51974: LD_VAR 0 14
51978: ADD
51979: ST_TO_ADDR
// end ;
51980: GO 51858
51982: POP
51983: POP
// end ; end ;
51984: LD_VAR 0 7
51988: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
51989: LD_INT 0
51991: PPUSH
51992: PPUSH
51993: PPUSH
51994: PPUSH
51995: PPUSH
51996: PPUSH
51997: PPUSH
51998: PPUSH
51999: PPUSH
52000: PPUSH
52001: PPUSH
52002: PPUSH
52003: PPUSH
52004: PPUSH
52005: PPUSH
52006: PPUSH
// result := false ;
52007: LD_ADDR_VAR 0 3
52011: PUSH
52012: LD_INT 0
52014: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
52015: LD_VAR 0 1
52019: NOT
52020: PUSH
52021: LD_VAR 0 1
52025: PPUSH
52026: CALL_OW 266
52030: PUSH
52031: LD_INT 32
52033: PUSH
52034: LD_INT 33
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: IN
52041: NOT
52042: OR
52043: IFFALSE 52047
// exit ;
52045: GO 53183
// nat := GetNation ( tower ) ;
52047: LD_ADDR_VAR 0 12
52051: PUSH
52052: LD_VAR 0 1
52056: PPUSH
52057: CALL_OW 248
52061: ST_TO_ADDR
// side := GetSide ( tower ) ;
52062: LD_ADDR_VAR 0 16
52066: PUSH
52067: LD_VAR 0 1
52071: PPUSH
52072: CALL_OW 255
52076: ST_TO_ADDR
// x := GetX ( tower ) ;
52077: LD_ADDR_VAR 0 10
52081: PUSH
52082: LD_VAR 0 1
52086: PPUSH
52087: CALL_OW 250
52091: ST_TO_ADDR
// y := GetY ( tower ) ;
52092: LD_ADDR_VAR 0 11
52096: PUSH
52097: LD_VAR 0 1
52101: PPUSH
52102: CALL_OW 251
52106: ST_TO_ADDR
// if not x or not y then
52107: LD_VAR 0 10
52111: NOT
52112: PUSH
52113: LD_VAR 0 11
52117: NOT
52118: OR
52119: IFFALSE 52123
// exit ;
52121: GO 53183
// weapon := 0 ;
52123: LD_ADDR_VAR 0 18
52127: PUSH
52128: LD_INT 0
52130: ST_TO_ADDR
// fac_list := [ ] ;
52131: LD_ADDR_VAR 0 17
52135: PUSH
52136: EMPTY
52137: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
52138: LD_ADDR_VAR 0 6
52142: PUSH
52143: LD_VAR 0 1
52147: PPUSH
52148: CALL_OW 274
52152: PPUSH
52153: LD_VAR 0 2
52157: PPUSH
52158: CALL 49761 0 2
52162: PPUSH
52163: LD_INT 30
52165: PUSH
52166: LD_INT 3
52168: PUSH
52169: EMPTY
52170: LIST
52171: LIST
52172: PPUSH
52173: CALL_OW 72
52177: ST_TO_ADDR
// if not factories then
52178: LD_VAR 0 6
52182: NOT
52183: IFFALSE 52187
// exit ;
52185: GO 53183
// for i in factories do
52187: LD_ADDR_VAR 0 8
52191: PUSH
52192: LD_VAR 0 6
52196: PUSH
52197: FOR_IN
52198: IFFALSE 52223
// fac_list := fac_list union AvailableWeaponList ( i ) ;
52200: LD_ADDR_VAR 0 17
52204: PUSH
52205: LD_VAR 0 17
52209: PUSH
52210: LD_VAR 0 8
52214: PPUSH
52215: CALL_OW 478
52219: UNION
52220: ST_TO_ADDR
52221: GO 52197
52223: POP
52224: POP
// if not fac_list then
52225: LD_VAR 0 17
52229: NOT
52230: IFFALSE 52234
// exit ;
52232: GO 53183
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
52234: LD_ADDR_VAR 0 5
52238: PUSH
52239: LD_INT 4
52241: PUSH
52242: LD_INT 5
52244: PUSH
52245: LD_INT 9
52247: PUSH
52248: LD_INT 10
52250: PUSH
52251: LD_INT 6
52253: PUSH
52254: LD_INT 7
52256: PUSH
52257: LD_INT 11
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: LIST
52264: LIST
52265: LIST
52266: LIST
52267: LIST
52268: PUSH
52269: LD_INT 27
52271: PUSH
52272: LD_INT 28
52274: PUSH
52275: LD_INT 26
52277: PUSH
52278: LD_INT 30
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: LIST
52285: LIST
52286: PUSH
52287: LD_INT 43
52289: PUSH
52290: LD_INT 44
52292: PUSH
52293: LD_INT 46
52295: PUSH
52296: LD_INT 45
52298: PUSH
52299: LD_INT 47
52301: PUSH
52302: LD_INT 49
52304: PUSH
52305: EMPTY
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: LIST
52317: PUSH
52318: LD_VAR 0 12
52322: ARRAY
52323: ST_TO_ADDR
// for i in list do
52324: LD_ADDR_VAR 0 8
52328: PUSH
52329: LD_VAR 0 5
52333: PUSH
52334: FOR_IN
52335: IFFALSE 52368
// if not i in fac_list then
52337: LD_VAR 0 8
52341: PUSH
52342: LD_VAR 0 17
52346: IN
52347: NOT
52348: IFFALSE 52366
// list := list diff i ;
52350: LD_ADDR_VAR 0 5
52354: PUSH
52355: LD_VAR 0 5
52359: PUSH
52360: LD_VAR 0 8
52364: DIFF
52365: ST_TO_ADDR
52366: GO 52334
52368: POP
52369: POP
// if not list then
52370: LD_VAR 0 5
52374: NOT
52375: IFFALSE 52379
// exit ;
52377: GO 53183
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
52379: LD_VAR 0 12
52383: PUSH
52384: LD_INT 3
52386: EQUAL
52387: PUSH
52388: LD_INT 49
52390: PUSH
52391: LD_VAR 0 5
52395: IN
52396: AND
52397: PUSH
52398: LD_INT 31
52400: PPUSH
52401: LD_VAR 0 16
52405: PPUSH
52406: CALL_OW 321
52410: PUSH
52411: LD_INT 2
52413: EQUAL
52414: AND
52415: IFFALSE 52475
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
52417: LD_INT 22
52419: PUSH
52420: LD_VAR 0 16
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: LD_INT 35
52431: PUSH
52432: LD_INT 49
52434: PUSH
52435: EMPTY
52436: LIST
52437: LIST
52438: PUSH
52439: LD_INT 91
52441: PUSH
52442: LD_VAR 0 1
52446: PUSH
52447: LD_INT 10
52449: PUSH
52450: EMPTY
52451: LIST
52452: LIST
52453: LIST
52454: PUSH
52455: EMPTY
52456: LIST
52457: LIST
52458: LIST
52459: PPUSH
52460: CALL_OW 69
52464: NOT
52465: IFFALSE 52475
// weapon := ru_time_lapser ;
52467: LD_ADDR_VAR 0 18
52471: PUSH
52472: LD_INT 49
52474: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
52475: LD_VAR 0 12
52479: PUSH
52480: LD_INT 1
52482: PUSH
52483: LD_INT 2
52485: PUSH
52486: EMPTY
52487: LIST
52488: LIST
52489: IN
52490: PUSH
52491: LD_INT 11
52493: PUSH
52494: LD_VAR 0 5
52498: IN
52499: PUSH
52500: LD_INT 30
52502: PUSH
52503: LD_VAR 0 5
52507: IN
52508: OR
52509: AND
52510: PUSH
52511: LD_INT 6
52513: PPUSH
52514: LD_VAR 0 16
52518: PPUSH
52519: CALL_OW 321
52523: PUSH
52524: LD_INT 2
52526: EQUAL
52527: AND
52528: IFFALSE 52693
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
52530: LD_INT 22
52532: PUSH
52533: LD_VAR 0 16
52537: PUSH
52538: EMPTY
52539: LIST
52540: LIST
52541: PUSH
52542: LD_INT 2
52544: PUSH
52545: LD_INT 35
52547: PUSH
52548: LD_INT 11
52550: PUSH
52551: EMPTY
52552: LIST
52553: LIST
52554: PUSH
52555: LD_INT 35
52557: PUSH
52558: LD_INT 30
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: PUSH
52570: LD_INT 91
52572: PUSH
52573: LD_VAR 0 1
52577: PUSH
52578: LD_INT 18
52580: PUSH
52581: EMPTY
52582: LIST
52583: LIST
52584: LIST
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: LIST
52590: PPUSH
52591: CALL_OW 69
52595: NOT
52596: PUSH
52597: LD_INT 22
52599: PUSH
52600: LD_VAR 0 16
52604: PUSH
52605: EMPTY
52606: LIST
52607: LIST
52608: PUSH
52609: LD_INT 2
52611: PUSH
52612: LD_INT 30
52614: PUSH
52615: LD_INT 32
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: PUSH
52622: LD_INT 30
52624: PUSH
52625: LD_INT 33
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: LIST
52636: PUSH
52637: LD_INT 91
52639: PUSH
52640: LD_VAR 0 1
52644: PUSH
52645: LD_INT 12
52647: PUSH
52648: EMPTY
52649: LIST
52650: LIST
52651: LIST
52652: PUSH
52653: EMPTY
52654: LIST
52655: LIST
52656: LIST
52657: PUSH
52658: EMPTY
52659: LIST
52660: PPUSH
52661: CALL_OW 69
52665: PUSH
52666: LD_INT 2
52668: GREATER
52669: AND
52670: IFFALSE 52693
// weapon := [ us_radar , ar_radar ] [ nat ] ;
52672: LD_ADDR_VAR 0 18
52676: PUSH
52677: LD_INT 11
52679: PUSH
52680: LD_INT 30
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PUSH
52687: LD_VAR 0 12
52691: ARRAY
52692: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
52693: LD_VAR 0 18
52697: NOT
52698: PUSH
52699: LD_INT 40
52701: PPUSH
52702: LD_VAR 0 16
52706: PPUSH
52707: CALL_OW 321
52711: PUSH
52712: LD_INT 2
52714: EQUAL
52715: AND
52716: PUSH
52717: LD_INT 7
52719: PUSH
52720: LD_VAR 0 5
52724: IN
52725: PUSH
52726: LD_INT 28
52728: PUSH
52729: LD_VAR 0 5
52733: IN
52734: OR
52735: PUSH
52736: LD_INT 45
52738: PUSH
52739: LD_VAR 0 5
52743: IN
52744: OR
52745: AND
52746: IFFALSE 53000
// begin hex := GetHexInfo ( x , y ) ;
52748: LD_ADDR_VAR 0 4
52752: PUSH
52753: LD_VAR 0 10
52757: PPUSH
52758: LD_VAR 0 11
52762: PPUSH
52763: CALL_OW 546
52767: ST_TO_ADDR
// if hex [ 1 ] then
52768: LD_VAR 0 4
52772: PUSH
52773: LD_INT 1
52775: ARRAY
52776: IFFALSE 52780
// exit ;
52778: GO 53183
// height := hex [ 2 ] ;
52780: LD_ADDR_VAR 0 15
52784: PUSH
52785: LD_VAR 0 4
52789: PUSH
52790: LD_INT 2
52792: ARRAY
52793: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
52794: LD_ADDR_VAR 0 14
52798: PUSH
52799: LD_INT 0
52801: PUSH
52802: LD_INT 2
52804: PUSH
52805: LD_INT 3
52807: PUSH
52808: LD_INT 5
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: LIST
52815: LIST
52816: ST_TO_ADDR
// for i in tmp do
52817: LD_ADDR_VAR 0 8
52821: PUSH
52822: LD_VAR 0 14
52826: PUSH
52827: FOR_IN
52828: IFFALSE 52998
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
52830: LD_ADDR_VAR 0 9
52834: PUSH
52835: LD_VAR 0 10
52839: PPUSH
52840: LD_VAR 0 8
52844: PPUSH
52845: LD_INT 5
52847: PPUSH
52848: CALL_OW 272
52852: PUSH
52853: LD_VAR 0 11
52857: PPUSH
52858: LD_VAR 0 8
52862: PPUSH
52863: LD_INT 5
52865: PPUSH
52866: CALL_OW 273
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52875: LD_VAR 0 9
52879: PUSH
52880: LD_INT 1
52882: ARRAY
52883: PPUSH
52884: LD_VAR 0 9
52888: PUSH
52889: LD_INT 2
52891: ARRAY
52892: PPUSH
52893: CALL_OW 488
52897: IFFALSE 52996
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
52899: LD_ADDR_VAR 0 4
52903: PUSH
52904: LD_VAR 0 9
52908: PUSH
52909: LD_INT 1
52911: ARRAY
52912: PPUSH
52913: LD_VAR 0 9
52917: PUSH
52918: LD_INT 2
52920: ARRAY
52921: PPUSH
52922: CALL_OW 546
52926: ST_TO_ADDR
// if hex [ 1 ] then
52927: LD_VAR 0 4
52931: PUSH
52932: LD_INT 1
52934: ARRAY
52935: IFFALSE 52939
// continue ;
52937: GO 52827
// h := hex [ 2 ] ;
52939: LD_ADDR_VAR 0 13
52943: PUSH
52944: LD_VAR 0 4
52948: PUSH
52949: LD_INT 2
52951: ARRAY
52952: ST_TO_ADDR
// if h + 7 < height then
52953: LD_VAR 0 13
52957: PUSH
52958: LD_INT 7
52960: PLUS
52961: PUSH
52962: LD_VAR 0 15
52966: LESS
52967: IFFALSE 52996
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
52969: LD_ADDR_VAR 0 18
52973: PUSH
52974: LD_INT 7
52976: PUSH
52977: LD_INT 28
52979: PUSH
52980: LD_INT 45
52982: PUSH
52983: EMPTY
52984: LIST
52985: LIST
52986: LIST
52987: PUSH
52988: LD_VAR 0 12
52992: ARRAY
52993: ST_TO_ADDR
// break ;
52994: GO 52998
// end ; end ; end ;
52996: GO 52827
52998: POP
52999: POP
// end ; if not weapon then
53000: LD_VAR 0 18
53004: NOT
53005: IFFALSE 53065
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
53007: LD_ADDR_VAR 0 5
53011: PUSH
53012: LD_VAR 0 5
53016: PUSH
53017: LD_INT 11
53019: PUSH
53020: LD_INT 30
53022: PUSH
53023: LD_INT 49
53025: PUSH
53026: EMPTY
53027: LIST
53028: LIST
53029: LIST
53030: DIFF
53031: ST_TO_ADDR
// if not list then
53032: LD_VAR 0 5
53036: NOT
53037: IFFALSE 53041
// exit ;
53039: GO 53183
// weapon := list [ rand ( 1 , list ) ] ;
53041: LD_ADDR_VAR 0 18
53045: PUSH
53046: LD_VAR 0 5
53050: PUSH
53051: LD_INT 1
53053: PPUSH
53054: LD_VAR 0 5
53058: PPUSH
53059: CALL_OW 12
53063: ARRAY
53064: ST_TO_ADDR
// end ; if weapon then
53065: LD_VAR 0 18
53069: IFFALSE 53183
// begin tmp := CostOfWeapon ( weapon ) ;
53071: LD_ADDR_VAR 0 14
53075: PUSH
53076: LD_VAR 0 18
53080: PPUSH
53081: CALL_OW 451
53085: ST_TO_ADDR
// j := GetBase ( tower ) ;
53086: LD_ADDR_VAR 0 9
53090: PUSH
53091: LD_VAR 0 1
53095: PPUSH
53096: CALL_OW 274
53100: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
53101: LD_VAR 0 9
53105: PPUSH
53106: LD_INT 1
53108: PPUSH
53109: CALL_OW 275
53113: PUSH
53114: LD_VAR 0 14
53118: PUSH
53119: LD_INT 1
53121: ARRAY
53122: GREATEREQUAL
53123: PUSH
53124: LD_VAR 0 9
53128: PPUSH
53129: LD_INT 2
53131: PPUSH
53132: CALL_OW 275
53136: PUSH
53137: LD_VAR 0 14
53141: PUSH
53142: LD_INT 2
53144: ARRAY
53145: GREATEREQUAL
53146: AND
53147: PUSH
53148: LD_VAR 0 9
53152: PPUSH
53153: LD_INT 3
53155: PPUSH
53156: CALL_OW 275
53160: PUSH
53161: LD_VAR 0 14
53165: PUSH
53166: LD_INT 3
53168: ARRAY
53169: GREATEREQUAL
53170: AND
53171: IFFALSE 53183
// result := weapon ;
53173: LD_ADDR_VAR 0 3
53177: PUSH
53178: LD_VAR 0 18
53182: ST_TO_ADDR
// end ; end ;
53183: LD_VAR 0 3
53187: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
53188: LD_INT 0
53190: PPUSH
53191: PPUSH
// result := true ;
53192: LD_ADDR_VAR 0 3
53196: PUSH
53197: LD_INT 1
53199: ST_TO_ADDR
// if array1 = array2 then
53200: LD_VAR 0 1
53204: PUSH
53205: LD_VAR 0 2
53209: EQUAL
53210: IFFALSE 53270
// begin for i = 1 to array1 do
53212: LD_ADDR_VAR 0 4
53216: PUSH
53217: DOUBLE
53218: LD_INT 1
53220: DEC
53221: ST_TO_ADDR
53222: LD_VAR 0 1
53226: PUSH
53227: FOR_TO
53228: IFFALSE 53266
// if array1 [ i ] <> array2 [ i ] then
53230: LD_VAR 0 1
53234: PUSH
53235: LD_VAR 0 4
53239: ARRAY
53240: PUSH
53241: LD_VAR 0 2
53245: PUSH
53246: LD_VAR 0 4
53250: ARRAY
53251: NONEQUAL
53252: IFFALSE 53264
// begin result := false ;
53254: LD_ADDR_VAR 0 3
53258: PUSH
53259: LD_INT 0
53261: ST_TO_ADDR
// break ;
53262: GO 53266
// end ;
53264: GO 53227
53266: POP
53267: POP
// end else
53268: GO 53278
// result := false ;
53270: LD_ADDR_VAR 0 3
53274: PUSH
53275: LD_INT 0
53277: ST_TO_ADDR
// end ;
53278: LD_VAR 0 3
53282: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
53283: LD_INT 0
53285: PPUSH
53286: PPUSH
53287: PPUSH
// pom := GetBase ( fac ) ;
53288: LD_ADDR_VAR 0 5
53292: PUSH
53293: LD_VAR 0 1
53297: PPUSH
53298: CALL_OW 274
53302: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
53303: LD_ADDR_VAR 0 4
53307: PUSH
53308: LD_VAR 0 2
53312: PUSH
53313: LD_INT 1
53315: ARRAY
53316: PPUSH
53317: LD_VAR 0 2
53321: PUSH
53322: LD_INT 2
53324: ARRAY
53325: PPUSH
53326: LD_VAR 0 2
53330: PUSH
53331: LD_INT 3
53333: ARRAY
53334: PPUSH
53335: LD_VAR 0 2
53339: PUSH
53340: LD_INT 4
53342: ARRAY
53343: PPUSH
53344: CALL_OW 449
53348: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53349: LD_ADDR_VAR 0 3
53353: PUSH
53354: LD_VAR 0 5
53358: PPUSH
53359: LD_INT 1
53361: PPUSH
53362: CALL_OW 275
53366: PUSH
53367: LD_VAR 0 4
53371: PUSH
53372: LD_INT 1
53374: ARRAY
53375: GREATEREQUAL
53376: PUSH
53377: LD_VAR 0 5
53381: PPUSH
53382: LD_INT 2
53384: PPUSH
53385: CALL_OW 275
53389: PUSH
53390: LD_VAR 0 4
53394: PUSH
53395: LD_INT 2
53397: ARRAY
53398: GREATEREQUAL
53399: AND
53400: PUSH
53401: LD_VAR 0 5
53405: PPUSH
53406: LD_INT 3
53408: PPUSH
53409: CALL_OW 275
53413: PUSH
53414: LD_VAR 0 4
53418: PUSH
53419: LD_INT 3
53421: ARRAY
53422: GREATEREQUAL
53423: AND
53424: ST_TO_ADDR
// end ;
53425: LD_VAR 0 3
53429: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
53430: LD_INT 0
53432: PPUSH
53433: PPUSH
53434: PPUSH
53435: PPUSH
// pom := GetBase ( building ) ;
53436: LD_ADDR_VAR 0 3
53440: PUSH
53441: LD_VAR 0 1
53445: PPUSH
53446: CALL_OW 274
53450: ST_TO_ADDR
// if not pom then
53451: LD_VAR 0 3
53455: NOT
53456: IFFALSE 53460
// exit ;
53458: GO 53630
// btype := GetBType ( building ) ;
53460: LD_ADDR_VAR 0 5
53464: PUSH
53465: LD_VAR 0 1
53469: PPUSH
53470: CALL_OW 266
53474: ST_TO_ADDR
// if btype = b_armoury then
53475: LD_VAR 0 5
53479: PUSH
53480: LD_INT 4
53482: EQUAL
53483: IFFALSE 53493
// btype := b_barracks ;
53485: LD_ADDR_VAR 0 5
53489: PUSH
53490: LD_INT 5
53492: ST_TO_ADDR
// if btype = b_depot then
53493: LD_VAR 0 5
53497: PUSH
53498: LD_INT 0
53500: EQUAL
53501: IFFALSE 53511
// btype := b_warehouse ;
53503: LD_ADDR_VAR 0 5
53507: PUSH
53508: LD_INT 1
53510: ST_TO_ADDR
// if btype = b_workshop then
53511: LD_VAR 0 5
53515: PUSH
53516: LD_INT 2
53518: EQUAL
53519: IFFALSE 53529
// btype := b_factory ;
53521: LD_ADDR_VAR 0 5
53525: PUSH
53526: LD_INT 3
53528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
53529: LD_ADDR_VAR 0 4
53533: PUSH
53534: LD_VAR 0 5
53538: PPUSH
53539: LD_VAR 0 1
53543: PPUSH
53544: CALL_OW 248
53548: PPUSH
53549: CALL_OW 450
53553: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53554: LD_ADDR_VAR 0 2
53558: PUSH
53559: LD_VAR 0 3
53563: PPUSH
53564: LD_INT 1
53566: PPUSH
53567: CALL_OW 275
53571: PUSH
53572: LD_VAR 0 4
53576: PUSH
53577: LD_INT 1
53579: ARRAY
53580: GREATEREQUAL
53581: PUSH
53582: LD_VAR 0 3
53586: PPUSH
53587: LD_INT 2
53589: PPUSH
53590: CALL_OW 275
53594: PUSH
53595: LD_VAR 0 4
53599: PUSH
53600: LD_INT 2
53602: ARRAY
53603: GREATEREQUAL
53604: AND
53605: PUSH
53606: LD_VAR 0 3
53610: PPUSH
53611: LD_INT 3
53613: PPUSH
53614: CALL_OW 275
53618: PUSH
53619: LD_VAR 0 4
53623: PUSH
53624: LD_INT 3
53626: ARRAY
53627: GREATEREQUAL
53628: AND
53629: ST_TO_ADDR
// end ;
53630: LD_VAR 0 2
53634: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
53635: LD_INT 0
53637: PPUSH
53638: PPUSH
53639: PPUSH
// pom := GetBase ( building ) ;
53640: LD_ADDR_VAR 0 4
53644: PUSH
53645: LD_VAR 0 1
53649: PPUSH
53650: CALL_OW 274
53654: ST_TO_ADDR
// if not pom then
53655: LD_VAR 0 4
53659: NOT
53660: IFFALSE 53664
// exit ;
53662: GO 53765
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
53664: LD_ADDR_VAR 0 5
53668: PUSH
53669: LD_VAR 0 2
53673: PPUSH
53674: LD_VAR 0 1
53678: PPUSH
53679: CALL_OW 248
53683: PPUSH
53684: CALL_OW 450
53688: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53689: LD_ADDR_VAR 0 3
53693: PUSH
53694: LD_VAR 0 4
53698: PPUSH
53699: LD_INT 1
53701: PPUSH
53702: CALL_OW 275
53706: PUSH
53707: LD_VAR 0 5
53711: PUSH
53712: LD_INT 1
53714: ARRAY
53715: GREATEREQUAL
53716: PUSH
53717: LD_VAR 0 4
53721: PPUSH
53722: LD_INT 2
53724: PPUSH
53725: CALL_OW 275
53729: PUSH
53730: LD_VAR 0 5
53734: PUSH
53735: LD_INT 2
53737: ARRAY
53738: GREATEREQUAL
53739: AND
53740: PUSH
53741: LD_VAR 0 4
53745: PPUSH
53746: LD_INT 3
53748: PPUSH
53749: CALL_OW 275
53753: PUSH
53754: LD_VAR 0 5
53758: PUSH
53759: LD_INT 3
53761: ARRAY
53762: GREATEREQUAL
53763: AND
53764: ST_TO_ADDR
// end ;
53765: LD_VAR 0 3
53769: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
53770: LD_INT 0
53772: PPUSH
53773: PPUSH
53774: PPUSH
53775: PPUSH
53776: PPUSH
53777: PPUSH
53778: PPUSH
53779: PPUSH
53780: PPUSH
53781: PPUSH
// result := false ;
53782: LD_ADDR_VAR 0 6
53786: PUSH
53787: LD_INT 0
53789: ST_TO_ADDR
// if not base or not btype or not x or not y then
53790: LD_VAR 0 1
53794: NOT
53795: PUSH
53796: LD_VAR 0 2
53800: NOT
53801: OR
53802: PUSH
53803: LD_VAR 0 3
53807: NOT
53808: OR
53809: PUSH
53810: LD_VAR 0 4
53814: NOT
53815: OR
53816: IFFALSE 53820
// exit ;
53818: GO 54429
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
53820: LD_ADDR_VAR 0 12
53824: PUSH
53825: LD_VAR 0 2
53829: PPUSH
53830: LD_VAR 0 3
53834: PPUSH
53835: LD_VAR 0 4
53839: PPUSH
53840: LD_VAR 0 5
53844: PPUSH
53845: LD_VAR 0 1
53849: PUSH
53850: LD_INT 1
53852: ARRAY
53853: PPUSH
53854: CALL_OW 248
53858: PPUSH
53859: LD_INT 0
53861: PPUSH
53862: CALL 55266 0 6
53866: ST_TO_ADDR
// if not hexes then
53867: LD_VAR 0 12
53871: NOT
53872: IFFALSE 53876
// exit ;
53874: GO 54429
// for i = 1 to hexes do
53876: LD_ADDR_VAR 0 7
53880: PUSH
53881: DOUBLE
53882: LD_INT 1
53884: DEC
53885: ST_TO_ADDR
53886: LD_VAR 0 12
53890: PUSH
53891: FOR_TO
53892: IFFALSE 54427
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
53894: LD_ADDR_VAR 0 11
53898: PUSH
53899: LD_VAR 0 12
53903: PUSH
53904: LD_VAR 0 7
53908: ARRAY
53909: PUSH
53910: LD_INT 1
53912: ARRAY
53913: PPUSH
53914: LD_VAR 0 12
53918: PUSH
53919: LD_VAR 0 7
53923: ARRAY
53924: PUSH
53925: LD_INT 2
53927: ARRAY
53928: PPUSH
53929: CALL_OW 428
53933: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
53934: LD_VAR 0 12
53938: PUSH
53939: LD_VAR 0 7
53943: ARRAY
53944: PUSH
53945: LD_INT 1
53947: ARRAY
53948: PPUSH
53949: LD_VAR 0 12
53953: PUSH
53954: LD_VAR 0 7
53958: ARRAY
53959: PUSH
53960: LD_INT 2
53962: ARRAY
53963: PPUSH
53964: CALL_OW 351
53968: PUSH
53969: LD_VAR 0 12
53973: PUSH
53974: LD_VAR 0 7
53978: ARRAY
53979: PUSH
53980: LD_INT 1
53982: ARRAY
53983: PPUSH
53984: LD_VAR 0 12
53988: PUSH
53989: LD_VAR 0 7
53993: ARRAY
53994: PUSH
53995: LD_INT 2
53997: ARRAY
53998: PPUSH
53999: CALL_OW 488
54003: NOT
54004: OR
54005: PUSH
54006: LD_VAR 0 11
54010: PPUSH
54011: CALL_OW 247
54015: PUSH
54016: LD_INT 3
54018: EQUAL
54019: OR
54020: IFFALSE 54026
// exit ;
54022: POP
54023: POP
54024: GO 54429
// if not tmp or not tmp in base then
54026: LD_VAR 0 11
54030: NOT
54031: PUSH
54032: LD_VAR 0 11
54036: PUSH
54037: LD_VAR 0 1
54041: IN
54042: NOT
54043: OR
54044: IFFALSE 54048
// continue ;
54046: GO 53891
// result := true ;
54048: LD_ADDR_VAR 0 6
54052: PUSH
54053: LD_INT 1
54055: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
54056: LD_ADDR_VAR 0 15
54060: PUSH
54061: LD_VAR 0 1
54065: PPUSH
54066: LD_INT 22
54068: PUSH
54069: LD_VAR 0 11
54073: PPUSH
54074: CALL_OW 255
54078: PUSH
54079: EMPTY
54080: LIST
54081: LIST
54082: PUSH
54083: LD_INT 2
54085: PUSH
54086: LD_INT 30
54088: PUSH
54089: LD_INT 0
54091: PUSH
54092: EMPTY
54093: LIST
54094: LIST
54095: PUSH
54096: LD_INT 30
54098: PUSH
54099: LD_INT 1
54101: PUSH
54102: EMPTY
54103: LIST
54104: LIST
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: LIST
54110: PUSH
54111: EMPTY
54112: LIST
54113: LIST
54114: PPUSH
54115: CALL_OW 72
54119: ST_TO_ADDR
// if dep then
54120: LD_VAR 0 15
54124: IFFALSE 54260
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
54126: LD_ADDR_VAR 0 14
54130: PUSH
54131: LD_VAR 0 15
54135: PUSH
54136: LD_INT 1
54138: ARRAY
54139: PPUSH
54140: CALL_OW 250
54144: PPUSH
54145: LD_VAR 0 15
54149: PUSH
54150: LD_INT 1
54152: ARRAY
54153: PPUSH
54154: CALL_OW 254
54158: PPUSH
54159: LD_INT 5
54161: PPUSH
54162: CALL_OW 272
54166: PUSH
54167: LD_VAR 0 15
54171: PUSH
54172: LD_INT 1
54174: ARRAY
54175: PPUSH
54176: CALL_OW 251
54180: PPUSH
54181: LD_VAR 0 15
54185: PUSH
54186: LD_INT 1
54188: ARRAY
54189: PPUSH
54190: CALL_OW 254
54194: PPUSH
54195: LD_INT 5
54197: PPUSH
54198: CALL_OW 273
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
54207: LD_VAR 0 14
54211: PUSH
54212: LD_INT 1
54214: ARRAY
54215: PPUSH
54216: LD_VAR 0 14
54220: PUSH
54221: LD_INT 2
54223: ARRAY
54224: PPUSH
54225: CALL_OW 488
54229: IFFALSE 54260
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
54231: LD_VAR 0 11
54235: PPUSH
54236: LD_VAR 0 14
54240: PUSH
54241: LD_INT 1
54243: ARRAY
54244: PPUSH
54245: LD_VAR 0 14
54249: PUSH
54250: LD_INT 2
54252: ARRAY
54253: PPUSH
54254: CALL_OW 111
// continue ;
54258: GO 53891
// end ; end ; r := GetDir ( tmp ) ;
54260: LD_ADDR_VAR 0 13
54264: PUSH
54265: LD_VAR 0 11
54269: PPUSH
54270: CALL_OW 254
54274: ST_TO_ADDR
// if r = 5 then
54275: LD_VAR 0 13
54279: PUSH
54280: LD_INT 5
54282: EQUAL
54283: IFFALSE 54293
// r := 0 ;
54285: LD_ADDR_VAR 0 13
54289: PUSH
54290: LD_INT 0
54292: ST_TO_ADDR
// for j = r to 5 do
54293: LD_ADDR_VAR 0 8
54297: PUSH
54298: DOUBLE
54299: LD_VAR 0 13
54303: DEC
54304: ST_TO_ADDR
54305: LD_INT 5
54307: PUSH
54308: FOR_TO
54309: IFFALSE 54423
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
54311: LD_ADDR_VAR 0 9
54315: PUSH
54316: LD_VAR 0 11
54320: PPUSH
54321: CALL_OW 250
54325: PPUSH
54326: LD_VAR 0 8
54330: PPUSH
54331: LD_INT 2
54333: PPUSH
54334: CALL_OW 272
54338: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
54339: LD_ADDR_VAR 0 10
54343: PUSH
54344: LD_VAR 0 11
54348: PPUSH
54349: CALL_OW 251
54353: PPUSH
54354: LD_VAR 0 8
54358: PPUSH
54359: LD_INT 2
54361: PPUSH
54362: CALL_OW 273
54366: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
54367: LD_VAR 0 9
54371: PPUSH
54372: LD_VAR 0 10
54376: PPUSH
54377: CALL_OW 488
54381: PUSH
54382: LD_VAR 0 9
54386: PPUSH
54387: LD_VAR 0 10
54391: PPUSH
54392: CALL_OW 428
54396: NOT
54397: AND
54398: IFFALSE 54421
// begin ComMoveXY ( tmp , _x , _y ) ;
54400: LD_VAR 0 11
54404: PPUSH
54405: LD_VAR 0 9
54409: PPUSH
54410: LD_VAR 0 10
54414: PPUSH
54415: CALL_OW 111
// break ;
54419: GO 54423
// end ; end ;
54421: GO 54308
54423: POP
54424: POP
// end ;
54425: GO 53891
54427: POP
54428: POP
// end ;
54429: LD_VAR 0 6
54433: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
54434: LD_INT 0
54436: PPUSH
54437: PPUSH
54438: PPUSH
54439: PPUSH
54440: PPUSH
54441: PPUSH
54442: PPUSH
54443: PPUSH
54444: PPUSH
54445: PPUSH
// result := false ;
54446: LD_ADDR_VAR 0 6
54450: PUSH
54451: LD_INT 0
54453: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
54454: LD_VAR 0 1
54458: NOT
54459: PUSH
54460: LD_VAR 0 1
54464: PPUSH
54465: CALL_OW 266
54469: PUSH
54470: LD_INT 0
54472: PUSH
54473: LD_INT 1
54475: PUSH
54476: EMPTY
54477: LIST
54478: LIST
54479: IN
54480: NOT
54481: OR
54482: PUSH
54483: LD_VAR 0 2
54487: NOT
54488: OR
54489: PUSH
54490: LD_VAR 0 5
54494: PUSH
54495: LD_INT 0
54497: PUSH
54498: LD_INT 1
54500: PUSH
54501: LD_INT 2
54503: PUSH
54504: LD_INT 3
54506: PUSH
54507: LD_INT 4
54509: PUSH
54510: LD_INT 5
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: LIST
54517: LIST
54518: LIST
54519: LIST
54520: IN
54521: NOT
54522: OR
54523: PUSH
54524: LD_VAR 0 3
54528: PPUSH
54529: LD_VAR 0 4
54533: PPUSH
54534: CALL_OW 488
54538: NOT
54539: OR
54540: IFFALSE 54544
// exit ;
54542: GO 55261
// pom := GetBase ( depot ) ;
54544: LD_ADDR_VAR 0 10
54548: PUSH
54549: LD_VAR 0 1
54553: PPUSH
54554: CALL_OW 274
54558: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
54559: LD_ADDR_VAR 0 11
54563: PUSH
54564: LD_VAR 0 2
54568: PPUSH
54569: LD_VAR 0 1
54573: PPUSH
54574: CALL_OW 248
54578: PPUSH
54579: CALL_OW 450
54583: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
54584: LD_VAR 0 10
54588: PPUSH
54589: LD_INT 1
54591: PPUSH
54592: CALL_OW 275
54596: PUSH
54597: LD_VAR 0 11
54601: PUSH
54602: LD_INT 1
54604: ARRAY
54605: GREATEREQUAL
54606: PUSH
54607: LD_VAR 0 10
54611: PPUSH
54612: LD_INT 2
54614: PPUSH
54615: CALL_OW 275
54619: PUSH
54620: LD_VAR 0 11
54624: PUSH
54625: LD_INT 2
54627: ARRAY
54628: GREATEREQUAL
54629: AND
54630: PUSH
54631: LD_VAR 0 10
54635: PPUSH
54636: LD_INT 3
54638: PPUSH
54639: CALL_OW 275
54643: PUSH
54644: LD_VAR 0 11
54648: PUSH
54649: LD_INT 3
54651: ARRAY
54652: GREATEREQUAL
54653: AND
54654: NOT
54655: IFFALSE 54659
// exit ;
54657: GO 55261
// if GetBType ( depot ) = b_depot then
54659: LD_VAR 0 1
54663: PPUSH
54664: CALL_OW 266
54668: PUSH
54669: LD_INT 0
54671: EQUAL
54672: IFFALSE 54684
// dist := 28 else
54674: LD_ADDR_VAR 0 14
54678: PUSH
54679: LD_INT 28
54681: ST_TO_ADDR
54682: GO 54692
// dist := 36 ;
54684: LD_ADDR_VAR 0 14
54688: PUSH
54689: LD_INT 36
54691: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
54692: LD_VAR 0 1
54696: PPUSH
54697: LD_VAR 0 3
54701: PPUSH
54702: LD_VAR 0 4
54706: PPUSH
54707: CALL_OW 297
54711: PUSH
54712: LD_VAR 0 14
54716: GREATER
54717: IFFALSE 54721
// exit ;
54719: GO 55261
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
54721: LD_ADDR_VAR 0 12
54725: PUSH
54726: LD_VAR 0 2
54730: PPUSH
54731: LD_VAR 0 3
54735: PPUSH
54736: LD_VAR 0 4
54740: PPUSH
54741: LD_VAR 0 5
54745: PPUSH
54746: LD_VAR 0 1
54750: PPUSH
54751: CALL_OW 248
54755: PPUSH
54756: LD_INT 0
54758: PPUSH
54759: CALL 55266 0 6
54763: ST_TO_ADDR
// if not hexes then
54764: LD_VAR 0 12
54768: NOT
54769: IFFALSE 54773
// exit ;
54771: GO 55261
// hex := GetHexInfo ( x , y ) ;
54773: LD_ADDR_VAR 0 15
54777: PUSH
54778: LD_VAR 0 3
54782: PPUSH
54783: LD_VAR 0 4
54787: PPUSH
54788: CALL_OW 546
54792: ST_TO_ADDR
// if hex [ 1 ] then
54793: LD_VAR 0 15
54797: PUSH
54798: LD_INT 1
54800: ARRAY
54801: IFFALSE 54805
// exit ;
54803: GO 55261
// height := hex [ 2 ] ;
54805: LD_ADDR_VAR 0 13
54809: PUSH
54810: LD_VAR 0 15
54814: PUSH
54815: LD_INT 2
54817: ARRAY
54818: ST_TO_ADDR
// for i = 1 to hexes do
54819: LD_ADDR_VAR 0 7
54823: PUSH
54824: DOUBLE
54825: LD_INT 1
54827: DEC
54828: ST_TO_ADDR
54829: LD_VAR 0 12
54833: PUSH
54834: FOR_TO
54835: IFFALSE 55165
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
54837: LD_VAR 0 12
54841: PUSH
54842: LD_VAR 0 7
54846: ARRAY
54847: PUSH
54848: LD_INT 1
54850: ARRAY
54851: PPUSH
54852: LD_VAR 0 12
54856: PUSH
54857: LD_VAR 0 7
54861: ARRAY
54862: PUSH
54863: LD_INT 2
54865: ARRAY
54866: PPUSH
54867: CALL_OW 488
54871: NOT
54872: PUSH
54873: LD_VAR 0 12
54877: PUSH
54878: LD_VAR 0 7
54882: ARRAY
54883: PUSH
54884: LD_INT 1
54886: ARRAY
54887: PPUSH
54888: LD_VAR 0 12
54892: PUSH
54893: LD_VAR 0 7
54897: ARRAY
54898: PUSH
54899: LD_INT 2
54901: ARRAY
54902: PPUSH
54903: CALL_OW 428
54907: PUSH
54908: LD_INT 0
54910: GREATER
54911: OR
54912: PUSH
54913: LD_VAR 0 12
54917: PUSH
54918: LD_VAR 0 7
54922: ARRAY
54923: PUSH
54924: LD_INT 1
54926: ARRAY
54927: PPUSH
54928: LD_VAR 0 12
54932: PUSH
54933: LD_VAR 0 7
54937: ARRAY
54938: PUSH
54939: LD_INT 2
54941: ARRAY
54942: PPUSH
54943: CALL_OW 351
54947: OR
54948: IFFALSE 54954
// exit ;
54950: POP
54951: POP
54952: GO 55261
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
54954: LD_ADDR_VAR 0 8
54958: PUSH
54959: LD_VAR 0 12
54963: PUSH
54964: LD_VAR 0 7
54968: ARRAY
54969: PUSH
54970: LD_INT 1
54972: ARRAY
54973: PPUSH
54974: LD_VAR 0 12
54978: PUSH
54979: LD_VAR 0 7
54983: ARRAY
54984: PUSH
54985: LD_INT 2
54987: ARRAY
54988: PPUSH
54989: CALL_OW 546
54993: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
54994: LD_VAR 0 8
54998: PUSH
54999: LD_INT 1
55001: ARRAY
55002: PUSH
55003: LD_VAR 0 8
55007: PUSH
55008: LD_INT 2
55010: ARRAY
55011: PUSH
55012: LD_VAR 0 13
55016: PUSH
55017: LD_INT 2
55019: PLUS
55020: GREATER
55021: OR
55022: PUSH
55023: LD_VAR 0 8
55027: PUSH
55028: LD_INT 2
55030: ARRAY
55031: PUSH
55032: LD_VAR 0 13
55036: PUSH
55037: LD_INT 2
55039: MINUS
55040: LESS
55041: OR
55042: PUSH
55043: LD_VAR 0 8
55047: PUSH
55048: LD_INT 3
55050: ARRAY
55051: PUSH
55052: LD_INT 0
55054: PUSH
55055: LD_INT 8
55057: PUSH
55058: LD_INT 9
55060: PUSH
55061: LD_INT 10
55063: PUSH
55064: LD_INT 11
55066: PUSH
55067: LD_INT 12
55069: PUSH
55070: LD_INT 13
55072: PUSH
55073: LD_INT 16
55075: PUSH
55076: LD_INT 17
55078: PUSH
55079: LD_INT 18
55081: PUSH
55082: LD_INT 19
55084: PUSH
55085: LD_INT 20
55087: PUSH
55088: LD_INT 21
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: LIST
55103: LIST
55104: LIST
55105: IN
55106: NOT
55107: OR
55108: PUSH
55109: LD_VAR 0 8
55113: PUSH
55114: LD_INT 5
55116: ARRAY
55117: NOT
55118: OR
55119: PUSH
55120: LD_VAR 0 8
55124: PUSH
55125: LD_INT 6
55127: ARRAY
55128: PUSH
55129: LD_INT 1
55131: PUSH
55132: LD_INT 2
55134: PUSH
55135: LD_INT 7
55137: PUSH
55138: LD_INT 9
55140: PUSH
55141: LD_INT 10
55143: PUSH
55144: LD_INT 11
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: LIST
55153: LIST
55154: IN
55155: NOT
55156: OR
55157: IFFALSE 55163
// exit ;
55159: POP
55160: POP
55161: GO 55261
// end ;
55163: GO 54834
55165: POP
55166: POP
// side := GetSide ( depot ) ;
55167: LD_ADDR_VAR 0 9
55171: PUSH
55172: LD_VAR 0 1
55176: PPUSH
55177: CALL_OW 255
55181: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
55182: LD_VAR 0 9
55186: PPUSH
55187: LD_VAR 0 3
55191: PPUSH
55192: LD_VAR 0 4
55196: PPUSH
55197: LD_INT 20
55199: PPUSH
55200: CALL 47915 0 4
55204: PUSH
55205: LD_INT 4
55207: ARRAY
55208: IFFALSE 55212
// exit ;
55210: GO 55261
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
55212: LD_VAR 0 2
55216: PUSH
55217: LD_INT 29
55219: PUSH
55220: LD_INT 30
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: IN
55227: PUSH
55228: LD_VAR 0 3
55232: PPUSH
55233: LD_VAR 0 4
55237: PPUSH
55238: LD_VAR 0 9
55242: PPUSH
55243: CALL_OW 440
55247: NOT
55248: AND
55249: IFFALSE 55253
// exit ;
55251: GO 55261
// result := true ;
55253: LD_ADDR_VAR 0 6
55257: PUSH
55258: LD_INT 1
55260: ST_TO_ADDR
// end ;
55261: LD_VAR 0 6
55265: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
55266: LD_INT 0
55268: PPUSH
55269: PPUSH
55270: PPUSH
55271: PPUSH
55272: PPUSH
55273: PPUSH
55274: PPUSH
55275: PPUSH
55276: PPUSH
55277: PPUSH
55278: PPUSH
55279: PPUSH
55280: PPUSH
55281: PPUSH
55282: PPUSH
55283: PPUSH
55284: PPUSH
55285: PPUSH
55286: PPUSH
55287: PPUSH
55288: PPUSH
55289: PPUSH
55290: PPUSH
55291: PPUSH
55292: PPUSH
55293: PPUSH
55294: PPUSH
55295: PPUSH
55296: PPUSH
55297: PPUSH
55298: PPUSH
55299: PPUSH
55300: PPUSH
55301: PPUSH
55302: PPUSH
55303: PPUSH
55304: PPUSH
55305: PPUSH
55306: PPUSH
55307: PPUSH
55308: PPUSH
55309: PPUSH
55310: PPUSH
55311: PPUSH
55312: PPUSH
55313: PPUSH
55314: PPUSH
55315: PPUSH
55316: PPUSH
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
55322: PPUSH
55323: PPUSH
55324: PPUSH
55325: PPUSH
// result = [ ] ;
55326: LD_ADDR_VAR 0 7
55330: PUSH
55331: EMPTY
55332: ST_TO_ADDR
// temp_list = [ ] ;
55333: LD_ADDR_VAR 0 9
55337: PUSH
55338: EMPTY
55339: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
55340: LD_VAR 0 4
55344: PUSH
55345: LD_INT 0
55347: PUSH
55348: LD_INT 1
55350: PUSH
55351: LD_INT 2
55353: PUSH
55354: LD_INT 3
55356: PUSH
55357: LD_INT 4
55359: PUSH
55360: LD_INT 5
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: LIST
55368: LIST
55369: LIST
55370: IN
55371: NOT
55372: PUSH
55373: LD_VAR 0 1
55377: PUSH
55378: LD_INT 0
55380: PUSH
55381: LD_INT 1
55383: PUSH
55384: EMPTY
55385: LIST
55386: LIST
55387: IN
55388: PUSH
55389: LD_VAR 0 5
55393: PUSH
55394: LD_INT 1
55396: PUSH
55397: LD_INT 2
55399: PUSH
55400: LD_INT 3
55402: PUSH
55403: EMPTY
55404: LIST
55405: LIST
55406: LIST
55407: IN
55408: NOT
55409: AND
55410: OR
55411: IFFALSE 55415
// exit ;
55413: GO 73806
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
55415: LD_VAR 0 1
55419: PUSH
55420: LD_INT 6
55422: PUSH
55423: LD_INT 7
55425: PUSH
55426: LD_INT 8
55428: PUSH
55429: LD_INT 13
55431: PUSH
55432: LD_INT 12
55434: PUSH
55435: LD_INT 15
55437: PUSH
55438: LD_INT 11
55440: PUSH
55441: LD_INT 14
55443: PUSH
55444: LD_INT 10
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: LIST
55454: LIST
55455: LIST
55456: LIST
55457: IN
55458: IFFALSE 55468
// btype = b_lab ;
55460: LD_ADDR_VAR 0 1
55464: PUSH
55465: LD_INT 6
55467: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
55468: LD_VAR 0 6
55472: PUSH
55473: LD_INT 0
55475: PUSH
55476: LD_INT 1
55478: PUSH
55479: LD_INT 2
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: LIST
55486: IN
55487: NOT
55488: PUSH
55489: LD_VAR 0 1
55493: PUSH
55494: LD_INT 0
55496: PUSH
55497: LD_INT 1
55499: PUSH
55500: LD_INT 2
55502: PUSH
55503: LD_INT 3
55505: PUSH
55506: LD_INT 6
55508: PUSH
55509: LD_INT 36
55511: PUSH
55512: LD_INT 4
55514: PUSH
55515: LD_INT 5
55517: PUSH
55518: LD_INT 31
55520: PUSH
55521: LD_INT 32
55523: PUSH
55524: LD_INT 33
55526: PUSH
55527: EMPTY
55528: LIST
55529: LIST
55530: LIST
55531: LIST
55532: LIST
55533: LIST
55534: LIST
55535: LIST
55536: LIST
55537: LIST
55538: LIST
55539: IN
55540: NOT
55541: PUSH
55542: LD_VAR 0 6
55546: PUSH
55547: LD_INT 1
55549: EQUAL
55550: AND
55551: OR
55552: PUSH
55553: LD_VAR 0 1
55557: PUSH
55558: LD_INT 2
55560: PUSH
55561: LD_INT 3
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: IN
55568: NOT
55569: PUSH
55570: LD_VAR 0 6
55574: PUSH
55575: LD_INT 2
55577: EQUAL
55578: AND
55579: OR
55580: IFFALSE 55590
// mode = 0 ;
55582: LD_ADDR_VAR 0 6
55586: PUSH
55587: LD_INT 0
55589: ST_TO_ADDR
// case mode of 0 :
55590: LD_VAR 0 6
55594: PUSH
55595: LD_INT 0
55597: DOUBLE
55598: EQUAL
55599: IFTRUE 55603
55601: GO 67056
55603: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
55604: LD_ADDR_VAR 0 11
55608: PUSH
55609: LD_INT 0
55611: PUSH
55612: LD_INT 0
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PUSH
55619: LD_INT 0
55621: PUSH
55622: LD_INT 1
55624: NEG
55625: PUSH
55626: EMPTY
55627: LIST
55628: LIST
55629: PUSH
55630: LD_INT 1
55632: PUSH
55633: LD_INT 0
55635: PUSH
55636: EMPTY
55637: LIST
55638: LIST
55639: PUSH
55640: LD_INT 1
55642: PUSH
55643: LD_INT 1
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: PUSH
55650: LD_INT 0
55652: PUSH
55653: LD_INT 1
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: PUSH
55660: LD_INT 1
55662: NEG
55663: PUSH
55664: LD_INT 0
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: PUSH
55671: LD_INT 1
55673: NEG
55674: PUSH
55675: LD_INT 1
55677: NEG
55678: PUSH
55679: EMPTY
55680: LIST
55681: LIST
55682: PUSH
55683: LD_INT 1
55685: NEG
55686: PUSH
55687: LD_INT 2
55689: NEG
55690: PUSH
55691: EMPTY
55692: LIST
55693: LIST
55694: PUSH
55695: LD_INT 0
55697: PUSH
55698: LD_INT 2
55700: NEG
55701: PUSH
55702: EMPTY
55703: LIST
55704: LIST
55705: PUSH
55706: LD_INT 1
55708: PUSH
55709: LD_INT 1
55711: NEG
55712: PUSH
55713: EMPTY
55714: LIST
55715: LIST
55716: PUSH
55717: LD_INT 1
55719: PUSH
55720: LD_INT 2
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: PUSH
55727: LD_INT 0
55729: PUSH
55730: LD_INT 2
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: PUSH
55737: LD_INT 1
55739: NEG
55740: PUSH
55741: LD_INT 1
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: PUSH
55748: LD_INT 1
55750: PUSH
55751: LD_INT 3
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: LD_INT 0
55760: PUSH
55761: LD_INT 3
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: PUSH
55768: LD_INT 1
55770: NEG
55771: PUSH
55772: LD_INT 2
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: LIST
55783: LIST
55784: LIST
55785: LIST
55786: LIST
55787: LIST
55788: LIST
55789: LIST
55790: LIST
55791: LIST
55792: LIST
55793: LIST
55794: LIST
55795: LIST
55796: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
55797: LD_ADDR_VAR 0 12
55801: PUSH
55802: LD_INT 0
55804: PUSH
55805: LD_INT 0
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: PUSH
55812: LD_INT 0
55814: PUSH
55815: LD_INT 1
55817: NEG
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PUSH
55823: LD_INT 1
55825: PUSH
55826: LD_INT 0
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: PUSH
55833: LD_INT 1
55835: PUSH
55836: LD_INT 1
55838: PUSH
55839: EMPTY
55840: LIST
55841: LIST
55842: PUSH
55843: LD_INT 0
55845: PUSH
55846: LD_INT 1
55848: PUSH
55849: EMPTY
55850: LIST
55851: LIST
55852: PUSH
55853: LD_INT 1
55855: NEG
55856: PUSH
55857: LD_INT 0
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: PUSH
55864: LD_INT 1
55866: NEG
55867: PUSH
55868: LD_INT 1
55870: NEG
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PUSH
55876: LD_INT 1
55878: PUSH
55879: LD_INT 1
55881: NEG
55882: PUSH
55883: EMPTY
55884: LIST
55885: LIST
55886: PUSH
55887: LD_INT 2
55889: PUSH
55890: LD_INT 0
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: PUSH
55897: LD_INT 2
55899: PUSH
55900: LD_INT 1
55902: PUSH
55903: EMPTY
55904: LIST
55905: LIST
55906: PUSH
55907: LD_INT 1
55909: NEG
55910: PUSH
55911: LD_INT 1
55913: PUSH
55914: EMPTY
55915: LIST
55916: LIST
55917: PUSH
55918: LD_INT 2
55920: NEG
55921: PUSH
55922: LD_INT 0
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PUSH
55929: LD_INT 2
55931: NEG
55932: PUSH
55933: LD_INT 1
55935: NEG
55936: PUSH
55937: EMPTY
55938: LIST
55939: LIST
55940: PUSH
55941: LD_INT 2
55943: NEG
55944: PUSH
55945: LD_INT 1
55947: PUSH
55948: EMPTY
55949: LIST
55950: LIST
55951: PUSH
55952: LD_INT 3
55954: NEG
55955: PUSH
55956: LD_INT 0
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: PUSH
55963: LD_INT 3
55965: NEG
55966: PUSH
55967: LD_INT 1
55969: NEG
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: LIST
55979: LIST
55980: LIST
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: LIST
55991: LIST
55992: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
55993: LD_ADDR_VAR 0 13
55997: PUSH
55998: LD_INT 0
56000: PUSH
56001: LD_INT 0
56003: PUSH
56004: EMPTY
56005: LIST
56006: LIST
56007: PUSH
56008: LD_INT 0
56010: PUSH
56011: LD_INT 1
56013: NEG
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: PUSH
56019: LD_INT 1
56021: PUSH
56022: LD_INT 0
56024: PUSH
56025: EMPTY
56026: LIST
56027: LIST
56028: PUSH
56029: LD_INT 1
56031: PUSH
56032: LD_INT 1
56034: PUSH
56035: EMPTY
56036: LIST
56037: LIST
56038: PUSH
56039: LD_INT 0
56041: PUSH
56042: LD_INT 1
56044: PUSH
56045: EMPTY
56046: LIST
56047: LIST
56048: PUSH
56049: LD_INT 1
56051: NEG
56052: PUSH
56053: LD_INT 0
56055: PUSH
56056: EMPTY
56057: LIST
56058: LIST
56059: PUSH
56060: LD_INT 1
56062: NEG
56063: PUSH
56064: LD_INT 1
56066: NEG
56067: PUSH
56068: EMPTY
56069: LIST
56070: LIST
56071: PUSH
56072: LD_INT 1
56074: NEG
56075: PUSH
56076: LD_INT 2
56078: NEG
56079: PUSH
56080: EMPTY
56081: LIST
56082: LIST
56083: PUSH
56084: LD_INT 2
56086: PUSH
56087: LD_INT 1
56089: PUSH
56090: EMPTY
56091: LIST
56092: LIST
56093: PUSH
56094: LD_INT 2
56096: PUSH
56097: LD_INT 2
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: PUSH
56104: LD_INT 1
56106: PUSH
56107: LD_INT 2
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: PUSH
56114: LD_INT 2
56116: NEG
56117: PUSH
56118: LD_INT 1
56120: NEG
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: PUSH
56126: LD_INT 2
56128: NEG
56129: PUSH
56130: LD_INT 2
56132: NEG
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PUSH
56138: LD_INT 2
56140: NEG
56141: PUSH
56142: LD_INT 3
56144: NEG
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: PUSH
56150: LD_INT 3
56152: NEG
56153: PUSH
56154: LD_INT 2
56156: NEG
56157: PUSH
56158: EMPTY
56159: LIST
56160: LIST
56161: PUSH
56162: LD_INT 3
56164: NEG
56165: PUSH
56166: LD_INT 3
56168: NEG
56169: PUSH
56170: EMPTY
56171: LIST
56172: LIST
56173: PUSH
56174: EMPTY
56175: LIST
56176: LIST
56177: LIST
56178: LIST
56179: LIST
56180: LIST
56181: LIST
56182: LIST
56183: LIST
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
56192: LD_ADDR_VAR 0 14
56196: PUSH
56197: LD_INT 0
56199: PUSH
56200: LD_INT 0
56202: PUSH
56203: EMPTY
56204: LIST
56205: LIST
56206: PUSH
56207: LD_INT 0
56209: PUSH
56210: LD_INT 1
56212: NEG
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: PUSH
56218: LD_INT 1
56220: PUSH
56221: LD_INT 0
56223: PUSH
56224: EMPTY
56225: LIST
56226: LIST
56227: PUSH
56228: LD_INT 1
56230: PUSH
56231: LD_INT 1
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: PUSH
56238: LD_INT 0
56240: PUSH
56241: LD_INT 1
56243: PUSH
56244: EMPTY
56245: LIST
56246: LIST
56247: PUSH
56248: LD_INT 1
56250: NEG
56251: PUSH
56252: LD_INT 0
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: PUSH
56259: LD_INT 1
56261: NEG
56262: PUSH
56263: LD_INT 1
56265: NEG
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: PUSH
56271: LD_INT 1
56273: NEG
56274: PUSH
56275: LD_INT 2
56277: NEG
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: PUSH
56283: LD_INT 0
56285: PUSH
56286: LD_INT 2
56288: NEG
56289: PUSH
56290: EMPTY
56291: LIST
56292: LIST
56293: PUSH
56294: LD_INT 1
56296: PUSH
56297: LD_INT 1
56299: NEG
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: PUSH
56305: LD_INT 1
56307: PUSH
56308: LD_INT 2
56310: PUSH
56311: EMPTY
56312: LIST
56313: LIST
56314: PUSH
56315: LD_INT 0
56317: PUSH
56318: LD_INT 2
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: LD_INT 1
56327: NEG
56328: PUSH
56329: LD_INT 1
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: PUSH
56336: LD_INT 1
56338: NEG
56339: PUSH
56340: LD_INT 3
56342: NEG
56343: PUSH
56344: EMPTY
56345: LIST
56346: LIST
56347: PUSH
56348: LD_INT 0
56350: PUSH
56351: LD_INT 3
56353: NEG
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: PUSH
56359: LD_INT 1
56361: PUSH
56362: LD_INT 2
56364: NEG
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: LIST
56374: LIST
56375: LIST
56376: LIST
56377: LIST
56378: LIST
56379: LIST
56380: LIST
56381: LIST
56382: LIST
56383: LIST
56384: LIST
56385: LIST
56386: LIST
56387: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
56388: LD_ADDR_VAR 0 15
56392: PUSH
56393: LD_INT 0
56395: PUSH
56396: LD_INT 0
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: PUSH
56403: LD_INT 0
56405: PUSH
56406: LD_INT 1
56408: NEG
56409: PUSH
56410: EMPTY
56411: LIST
56412: LIST
56413: PUSH
56414: LD_INT 1
56416: PUSH
56417: LD_INT 0
56419: PUSH
56420: EMPTY
56421: LIST
56422: LIST
56423: PUSH
56424: LD_INT 1
56426: PUSH
56427: LD_INT 1
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: PUSH
56434: LD_INT 0
56436: PUSH
56437: LD_INT 1
56439: PUSH
56440: EMPTY
56441: LIST
56442: LIST
56443: PUSH
56444: LD_INT 1
56446: NEG
56447: PUSH
56448: LD_INT 0
56450: PUSH
56451: EMPTY
56452: LIST
56453: LIST
56454: PUSH
56455: LD_INT 1
56457: NEG
56458: PUSH
56459: LD_INT 1
56461: NEG
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: PUSH
56467: LD_INT 1
56469: PUSH
56470: LD_INT 1
56472: NEG
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: PUSH
56478: LD_INT 2
56480: PUSH
56481: LD_INT 0
56483: PUSH
56484: EMPTY
56485: LIST
56486: LIST
56487: PUSH
56488: LD_INT 2
56490: PUSH
56491: LD_INT 1
56493: PUSH
56494: EMPTY
56495: LIST
56496: LIST
56497: PUSH
56498: LD_INT 1
56500: NEG
56501: PUSH
56502: LD_INT 1
56504: PUSH
56505: EMPTY
56506: LIST
56507: LIST
56508: PUSH
56509: LD_INT 2
56511: NEG
56512: PUSH
56513: LD_INT 0
56515: PUSH
56516: EMPTY
56517: LIST
56518: LIST
56519: PUSH
56520: LD_INT 2
56522: NEG
56523: PUSH
56524: LD_INT 1
56526: NEG
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PUSH
56532: LD_INT 2
56534: PUSH
56535: LD_INT 1
56537: NEG
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: PUSH
56543: LD_INT 3
56545: PUSH
56546: LD_INT 0
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: PUSH
56553: LD_INT 3
56555: PUSH
56556: LD_INT 1
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: LIST
56567: LIST
56568: LIST
56569: LIST
56570: LIST
56571: LIST
56572: LIST
56573: LIST
56574: LIST
56575: LIST
56576: LIST
56577: LIST
56578: LIST
56579: LIST
56580: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
56581: LD_ADDR_VAR 0 16
56585: PUSH
56586: LD_INT 0
56588: PUSH
56589: LD_INT 0
56591: PUSH
56592: EMPTY
56593: LIST
56594: LIST
56595: PUSH
56596: LD_INT 0
56598: PUSH
56599: LD_INT 1
56601: NEG
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PUSH
56607: LD_INT 1
56609: PUSH
56610: LD_INT 0
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: PUSH
56617: LD_INT 1
56619: PUSH
56620: LD_INT 1
56622: PUSH
56623: EMPTY
56624: LIST
56625: LIST
56626: PUSH
56627: LD_INT 0
56629: PUSH
56630: LD_INT 1
56632: PUSH
56633: EMPTY
56634: LIST
56635: LIST
56636: PUSH
56637: LD_INT 1
56639: NEG
56640: PUSH
56641: LD_INT 0
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: PUSH
56648: LD_INT 1
56650: NEG
56651: PUSH
56652: LD_INT 1
56654: NEG
56655: PUSH
56656: EMPTY
56657: LIST
56658: LIST
56659: PUSH
56660: LD_INT 1
56662: NEG
56663: PUSH
56664: LD_INT 2
56666: NEG
56667: PUSH
56668: EMPTY
56669: LIST
56670: LIST
56671: PUSH
56672: LD_INT 2
56674: PUSH
56675: LD_INT 1
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: PUSH
56682: LD_INT 2
56684: PUSH
56685: LD_INT 2
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PUSH
56692: LD_INT 1
56694: PUSH
56695: LD_INT 2
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: PUSH
56702: LD_INT 2
56704: NEG
56705: PUSH
56706: LD_INT 1
56708: NEG
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: PUSH
56714: LD_INT 2
56716: NEG
56717: PUSH
56718: LD_INT 2
56720: NEG
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: LD_INT 3
56728: PUSH
56729: LD_INT 2
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: PUSH
56736: LD_INT 3
56738: PUSH
56739: LD_INT 3
56741: PUSH
56742: EMPTY
56743: LIST
56744: LIST
56745: PUSH
56746: LD_INT 2
56748: PUSH
56749: LD_INT 3
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: LIST
56760: LIST
56761: LIST
56762: LIST
56763: LIST
56764: LIST
56765: LIST
56766: LIST
56767: LIST
56768: LIST
56769: LIST
56770: LIST
56771: LIST
56772: LIST
56773: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56774: LD_ADDR_VAR 0 17
56778: PUSH
56779: LD_INT 0
56781: PUSH
56782: LD_INT 0
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PUSH
56789: LD_INT 0
56791: PUSH
56792: LD_INT 1
56794: NEG
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: LD_INT 1
56802: PUSH
56803: LD_INT 0
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: PUSH
56810: LD_INT 1
56812: PUSH
56813: LD_INT 1
56815: PUSH
56816: EMPTY
56817: LIST
56818: LIST
56819: PUSH
56820: LD_INT 0
56822: PUSH
56823: LD_INT 1
56825: PUSH
56826: EMPTY
56827: LIST
56828: LIST
56829: PUSH
56830: LD_INT 1
56832: NEG
56833: PUSH
56834: LD_INT 0
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: PUSH
56841: LD_INT 1
56843: NEG
56844: PUSH
56845: LD_INT 1
56847: NEG
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: PUSH
56853: LD_INT 1
56855: NEG
56856: PUSH
56857: LD_INT 2
56859: NEG
56860: PUSH
56861: EMPTY
56862: LIST
56863: LIST
56864: PUSH
56865: LD_INT 0
56867: PUSH
56868: LD_INT 2
56870: NEG
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: LD_INT 1
56878: PUSH
56879: LD_INT 1
56881: NEG
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PUSH
56887: LD_INT 2
56889: PUSH
56890: LD_INT 0
56892: PUSH
56893: EMPTY
56894: LIST
56895: LIST
56896: PUSH
56897: LD_INT 2
56899: PUSH
56900: LD_INT 1
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: PUSH
56907: LD_INT 2
56909: PUSH
56910: LD_INT 2
56912: PUSH
56913: EMPTY
56914: LIST
56915: LIST
56916: PUSH
56917: LD_INT 1
56919: PUSH
56920: LD_INT 2
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: PUSH
56927: LD_INT 0
56929: PUSH
56930: LD_INT 2
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: PUSH
56937: LD_INT 1
56939: NEG
56940: PUSH
56941: LD_INT 1
56943: PUSH
56944: EMPTY
56945: LIST
56946: LIST
56947: PUSH
56948: LD_INT 2
56950: NEG
56951: PUSH
56952: LD_INT 0
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PUSH
56959: LD_INT 2
56961: NEG
56962: PUSH
56963: LD_INT 1
56965: NEG
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: LD_INT 2
56973: NEG
56974: PUSH
56975: LD_INT 2
56977: NEG
56978: PUSH
56979: EMPTY
56980: LIST
56981: LIST
56982: PUSH
56983: EMPTY
56984: LIST
56985: LIST
56986: LIST
56987: LIST
56988: LIST
56989: LIST
56990: LIST
56991: LIST
56992: LIST
56993: LIST
56994: LIST
56995: LIST
56996: LIST
56997: LIST
56998: LIST
56999: LIST
57000: LIST
57001: LIST
57002: LIST
57003: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57004: LD_ADDR_VAR 0 18
57008: PUSH
57009: LD_INT 0
57011: PUSH
57012: LD_INT 0
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: PUSH
57019: LD_INT 0
57021: PUSH
57022: LD_INT 1
57024: NEG
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: PUSH
57030: LD_INT 1
57032: PUSH
57033: LD_INT 0
57035: PUSH
57036: EMPTY
57037: LIST
57038: LIST
57039: PUSH
57040: LD_INT 1
57042: PUSH
57043: LD_INT 1
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: LD_INT 0
57052: PUSH
57053: LD_INT 1
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: LD_INT 1
57062: NEG
57063: PUSH
57064: LD_INT 0
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: PUSH
57071: LD_INT 1
57073: NEG
57074: PUSH
57075: LD_INT 1
57077: NEG
57078: PUSH
57079: EMPTY
57080: LIST
57081: LIST
57082: PUSH
57083: LD_INT 1
57085: NEG
57086: PUSH
57087: LD_INT 2
57089: NEG
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: LD_INT 0
57097: PUSH
57098: LD_INT 2
57100: NEG
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PUSH
57106: LD_INT 1
57108: PUSH
57109: LD_INT 1
57111: NEG
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: PUSH
57117: LD_INT 2
57119: PUSH
57120: LD_INT 0
57122: PUSH
57123: EMPTY
57124: LIST
57125: LIST
57126: PUSH
57127: LD_INT 2
57129: PUSH
57130: LD_INT 1
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: PUSH
57137: LD_INT 2
57139: PUSH
57140: LD_INT 2
57142: PUSH
57143: EMPTY
57144: LIST
57145: LIST
57146: PUSH
57147: LD_INT 1
57149: PUSH
57150: LD_INT 2
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PUSH
57157: LD_INT 0
57159: PUSH
57160: LD_INT 2
57162: PUSH
57163: EMPTY
57164: LIST
57165: LIST
57166: PUSH
57167: LD_INT 1
57169: NEG
57170: PUSH
57171: LD_INT 1
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: PUSH
57178: LD_INT 2
57180: NEG
57181: PUSH
57182: LD_INT 0
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: PUSH
57189: LD_INT 2
57191: NEG
57192: PUSH
57193: LD_INT 1
57195: NEG
57196: PUSH
57197: EMPTY
57198: LIST
57199: LIST
57200: PUSH
57201: LD_INT 2
57203: NEG
57204: PUSH
57205: LD_INT 2
57207: NEG
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: LIST
57218: LIST
57219: LIST
57220: LIST
57221: LIST
57222: LIST
57223: LIST
57224: LIST
57225: LIST
57226: LIST
57227: LIST
57228: LIST
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57234: LD_ADDR_VAR 0 19
57238: PUSH
57239: LD_INT 0
57241: PUSH
57242: LD_INT 0
57244: PUSH
57245: EMPTY
57246: LIST
57247: LIST
57248: PUSH
57249: LD_INT 0
57251: PUSH
57252: LD_INT 1
57254: NEG
57255: PUSH
57256: EMPTY
57257: LIST
57258: LIST
57259: PUSH
57260: LD_INT 1
57262: PUSH
57263: LD_INT 0
57265: PUSH
57266: EMPTY
57267: LIST
57268: LIST
57269: PUSH
57270: LD_INT 1
57272: PUSH
57273: LD_INT 1
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: PUSH
57280: LD_INT 0
57282: PUSH
57283: LD_INT 1
57285: PUSH
57286: EMPTY
57287: LIST
57288: LIST
57289: PUSH
57290: LD_INT 1
57292: NEG
57293: PUSH
57294: LD_INT 0
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: PUSH
57301: LD_INT 1
57303: NEG
57304: PUSH
57305: LD_INT 1
57307: NEG
57308: PUSH
57309: EMPTY
57310: LIST
57311: LIST
57312: PUSH
57313: LD_INT 1
57315: NEG
57316: PUSH
57317: LD_INT 2
57319: NEG
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: PUSH
57325: LD_INT 0
57327: PUSH
57328: LD_INT 2
57330: NEG
57331: PUSH
57332: EMPTY
57333: LIST
57334: LIST
57335: PUSH
57336: LD_INT 1
57338: PUSH
57339: LD_INT 1
57341: NEG
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: PUSH
57347: LD_INT 2
57349: PUSH
57350: LD_INT 0
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: PUSH
57357: LD_INT 2
57359: PUSH
57360: LD_INT 1
57362: PUSH
57363: EMPTY
57364: LIST
57365: LIST
57366: PUSH
57367: LD_INT 2
57369: PUSH
57370: LD_INT 2
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: PUSH
57377: LD_INT 1
57379: PUSH
57380: LD_INT 2
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PUSH
57387: LD_INT 0
57389: PUSH
57390: LD_INT 2
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: PUSH
57397: LD_INT 1
57399: NEG
57400: PUSH
57401: LD_INT 1
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: PUSH
57408: LD_INT 2
57410: NEG
57411: PUSH
57412: LD_INT 0
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: LD_INT 2
57421: NEG
57422: PUSH
57423: LD_INT 1
57425: NEG
57426: PUSH
57427: EMPTY
57428: LIST
57429: LIST
57430: PUSH
57431: LD_INT 2
57433: NEG
57434: PUSH
57435: LD_INT 2
57437: NEG
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: LIST
57447: LIST
57448: LIST
57449: LIST
57450: LIST
57451: LIST
57452: LIST
57453: LIST
57454: LIST
57455: LIST
57456: LIST
57457: LIST
57458: LIST
57459: LIST
57460: LIST
57461: LIST
57462: LIST
57463: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57464: LD_ADDR_VAR 0 20
57468: PUSH
57469: LD_INT 0
57471: PUSH
57472: LD_INT 0
57474: PUSH
57475: EMPTY
57476: LIST
57477: LIST
57478: PUSH
57479: LD_INT 0
57481: PUSH
57482: LD_INT 1
57484: NEG
57485: PUSH
57486: EMPTY
57487: LIST
57488: LIST
57489: PUSH
57490: LD_INT 1
57492: PUSH
57493: LD_INT 0
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: PUSH
57500: LD_INT 1
57502: PUSH
57503: LD_INT 1
57505: PUSH
57506: EMPTY
57507: LIST
57508: LIST
57509: PUSH
57510: LD_INT 0
57512: PUSH
57513: LD_INT 1
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: PUSH
57520: LD_INT 1
57522: NEG
57523: PUSH
57524: LD_INT 0
57526: PUSH
57527: EMPTY
57528: LIST
57529: LIST
57530: PUSH
57531: LD_INT 1
57533: NEG
57534: PUSH
57535: LD_INT 1
57537: NEG
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: PUSH
57543: LD_INT 1
57545: NEG
57546: PUSH
57547: LD_INT 2
57549: NEG
57550: PUSH
57551: EMPTY
57552: LIST
57553: LIST
57554: PUSH
57555: LD_INT 0
57557: PUSH
57558: LD_INT 2
57560: NEG
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: PUSH
57566: LD_INT 1
57568: PUSH
57569: LD_INT 1
57571: NEG
57572: PUSH
57573: EMPTY
57574: LIST
57575: LIST
57576: PUSH
57577: LD_INT 2
57579: PUSH
57580: LD_INT 0
57582: PUSH
57583: EMPTY
57584: LIST
57585: LIST
57586: PUSH
57587: LD_INT 2
57589: PUSH
57590: LD_INT 1
57592: PUSH
57593: EMPTY
57594: LIST
57595: LIST
57596: PUSH
57597: LD_INT 2
57599: PUSH
57600: LD_INT 2
57602: PUSH
57603: EMPTY
57604: LIST
57605: LIST
57606: PUSH
57607: LD_INT 1
57609: PUSH
57610: LD_INT 2
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: PUSH
57617: LD_INT 0
57619: PUSH
57620: LD_INT 2
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PUSH
57627: LD_INT 1
57629: NEG
57630: PUSH
57631: LD_INT 1
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PUSH
57638: LD_INT 2
57640: NEG
57641: PUSH
57642: LD_INT 0
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: LD_INT 2
57651: NEG
57652: PUSH
57653: LD_INT 1
57655: NEG
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: PUSH
57661: LD_INT 2
57663: NEG
57664: PUSH
57665: LD_INT 2
57667: NEG
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: PUSH
57673: EMPTY
57674: LIST
57675: LIST
57676: LIST
57677: LIST
57678: LIST
57679: LIST
57680: LIST
57681: LIST
57682: LIST
57683: LIST
57684: LIST
57685: LIST
57686: LIST
57687: LIST
57688: LIST
57689: LIST
57690: LIST
57691: LIST
57692: LIST
57693: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57694: LD_ADDR_VAR 0 21
57698: PUSH
57699: LD_INT 0
57701: PUSH
57702: LD_INT 0
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: PUSH
57709: LD_INT 0
57711: PUSH
57712: LD_INT 1
57714: NEG
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: PUSH
57720: LD_INT 1
57722: PUSH
57723: LD_INT 0
57725: PUSH
57726: EMPTY
57727: LIST
57728: LIST
57729: PUSH
57730: LD_INT 1
57732: PUSH
57733: LD_INT 1
57735: PUSH
57736: EMPTY
57737: LIST
57738: LIST
57739: PUSH
57740: LD_INT 0
57742: PUSH
57743: LD_INT 1
57745: PUSH
57746: EMPTY
57747: LIST
57748: LIST
57749: PUSH
57750: LD_INT 1
57752: NEG
57753: PUSH
57754: LD_INT 0
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: LD_INT 1
57763: NEG
57764: PUSH
57765: LD_INT 1
57767: NEG
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: PUSH
57773: LD_INT 1
57775: NEG
57776: PUSH
57777: LD_INT 2
57779: NEG
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: PUSH
57785: LD_INT 0
57787: PUSH
57788: LD_INT 2
57790: NEG
57791: PUSH
57792: EMPTY
57793: LIST
57794: LIST
57795: PUSH
57796: LD_INT 1
57798: PUSH
57799: LD_INT 1
57801: NEG
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PUSH
57807: LD_INT 2
57809: PUSH
57810: LD_INT 0
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: PUSH
57817: LD_INT 2
57819: PUSH
57820: LD_INT 1
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PUSH
57827: LD_INT 2
57829: PUSH
57830: LD_INT 2
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: PUSH
57837: LD_INT 1
57839: PUSH
57840: LD_INT 2
57842: PUSH
57843: EMPTY
57844: LIST
57845: LIST
57846: PUSH
57847: LD_INT 0
57849: PUSH
57850: LD_INT 2
57852: PUSH
57853: EMPTY
57854: LIST
57855: LIST
57856: PUSH
57857: LD_INT 1
57859: NEG
57860: PUSH
57861: LD_INT 1
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 2
57870: NEG
57871: PUSH
57872: LD_INT 0
57874: PUSH
57875: EMPTY
57876: LIST
57877: LIST
57878: PUSH
57879: LD_INT 2
57881: NEG
57882: PUSH
57883: LD_INT 1
57885: NEG
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PUSH
57891: LD_INT 2
57893: NEG
57894: PUSH
57895: LD_INT 2
57897: NEG
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: PUSH
57903: EMPTY
57904: LIST
57905: LIST
57906: LIST
57907: LIST
57908: LIST
57909: LIST
57910: LIST
57911: LIST
57912: LIST
57913: LIST
57914: LIST
57915: LIST
57916: LIST
57917: LIST
57918: LIST
57919: LIST
57920: LIST
57921: LIST
57922: LIST
57923: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57924: LD_ADDR_VAR 0 22
57928: PUSH
57929: LD_INT 0
57931: PUSH
57932: LD_INT 0
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: PUSH
57939: LD_INT 0
57941: PUSH
57942: LD_INT 1
57944: NEG
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: LD_INT 1
57952: PUSH
57953: LD_INT 0
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: PUSH
57960: LD_INT 1
57962: PUSH
57963: LD_INT 1
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: PUSH
57970: LD_INT 0
57972: PUSH
57973: LD_INT 1
57975: PUSH
57976: EMPTY
57977: LIST
57978: LIST
57979: PUSH
57980: LD_INT 1
57982: NEG
57983: PUSH
57984: LD_INT 0
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: PUSH
57991: LD_INT 1
57993: NEG
57994: PUSH
57995: LD_INT 1
57997: NEG
57998: PUSH
57999: EMPTY
58000: LIST
58001: LIST
58002: PUSH
58003: LD_INT 1
58005: NEG
58006: PUSH
58007: LD_INT 2
58009: NEG
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: LD_INT 0
58017: PUSH
58018: LD_INT 2
58020: NEG
58021: PUSH
58022: EMPTY
58023: LIST
58024: LIST
58025: PUSH
58026: LD_INT 1
58028: PUSH
58029: LD_INT 1
58031: NEG
58032: PUSH
58033: EMPTY
58034: LIST
58035: LIST
58036: PUSH
58037: LD_INT 2
58039: PUSH
58040: LD_INT 0
58042: PUSH
58043: EMPTY
58044: LIST
58045: LIST
58046: PUSH
58047: LD_INT 2
58049: PUSH
58050: LD_INT 1
58052: PUSH
58053: EMPTY
58054: LIST
58055: LIST
58056: PUSH
58057: LD_INT 2
58059: PUSH
58060: LD_INT 2
58062: PUSH
58063: EMPTY
58064: LIST
58065: LIST
58066: PUSH
58067: LD_INT 1
58069: PUSH
58070: LD_INT 2
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: PUSH
58077: LD_INT 0
58079: PUSH
58080: LD_INT 2
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: PUSH
58087: LD_INT 1
58089: NEG
58090: PUSH
58091: LD_INT 1
58093: PUSH
58094: EMPTY
58095: LIST
58096: LIST
58097: PUSH
58098: LD_INT 2
58100: NEG
58101: PUSH
58102: LD_INT 0
58104: PUSH
58105: EMPTY
58106: LIST
58107: LIST
58108: PUSH
58109: LD_INT 2
58111: NEG
58112: PUSH
58113: LD_INT 1
58115: NEG
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: PUSH
58121: LD_INT 2
58123: NEG
58124: PUSH
58125: LD_INT 2
58127: NEG
58128: PUSH
58129: EMPTY
58130: LIST
58131: LIST
58132: PUSH
58133: EMPTY
58134: LIST
58135: LIST
58136: LIST
58137: LIST
58138: LIST
58139: LIST
58140: LIST
58141: LIST
58142: LIST
58143: LIST
58144: LIST
58145: LIST
58146: LIST
58147: LIST
58148: LIST
58149: LIST
58150: LIST
58151: LIST
58152: LIST
58153: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
58154: LD_ADDR_VAR 0 23
58158: PUSH
58159: LD_INT 0
58161: PUSH
58162: LD_INT 0
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: PUSH
58169: LD_INT 0
58171: PUSH
58172: LD_INT 1
58174: NEG
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: PUSH
58180: LD_INT 1
58182: PUSH
58183: LD_INT 0
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PUSH
58190: LD_INT 1
58192: PUSH
58193: LD_INT 1
58195: PUSH
58196: EMPTY
58197: LIST
58198: LIST
58199: PUSH
58200: LD_INT 0
58202: PUSH
58203: LD_INT 1
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PUSH
58210: LD_INT 1
58212: NEG
58213: PUSH
58214: LD_INT 0
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: PUSH
58221: LD_INT 1
58223: NEG
58224: PUSH
58225: LD_INT 1
58227: NEG
58228: PUSH
58229: EMPTY
58230: LIST
58231: LIST
58232: PUSH
58233: LD_INT 1
58235: NEG
58236: PUSH
58237: LD_INT 2
58239: NEG
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: PUSH
58245: LD_INT 0
58247: PUSH
58248: LD_INT 2
58250: NEG
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PUSH
58256: LD_INT 1
58258: PUSH
58259: LD_INT 1
58261: NEG
58262: PUSH
58263: EMPTY
58264: LIST
58265: LIST
58266: PUSH
58267: LD_INT 2
58269: PUSH
58270: LD_INT 0
58272: PUSH
58273: EMPTY
58274: LIST
58275: LIST
58276: PUSH
58277: LD_INT 2
58279: PUSH
58280: LD_INT 1
58282: PUSH
58283: EMPTY
58284: LIST
58285: LIST
58286: PUSH
58287: LD_INT 2
58289: PUSH
58290: LD_INT 2
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: PUSH
58297: LD_INT 1
58299: PUSH
58300: LD_INT 2
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: PUSH
58307: LD_INT 0
58309: PUSH
58310: LD_INT 2
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: LD_INT 1
58319: NEG
58320: PUSH
58321: LD_INT 1
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: PUSH
58328: LD_INT 2
58330: NEG
58331: PUSH
58332: LD_INT 0
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 2
58341: NEG
58342: PUSH
58343: LD_INT 1
58345: NEG
58346: PUSH
58347: EMPTY
58348: LIST
58349: LIST
58350: PUSH
58351: LD_INT 2
58353: NEG
58354: PUSH
58355: LD_INT 2
58357: NEG
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: PUSH
58363: LD_INT 2
58365: NEG
58366: PUSH
58367: LD_INT 3
58369: NEG
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PUSH
58375: LD_INT 1
58377: NEG
58378: PUSH
58379: LD_INT 3
58381: NEG
58382: PUSH
58383: EMPTY
58384: LIST
58385: LIST
58386: PUSH
58387: LD_INT 1
58389: PUSH
58390: LD_INT 2
58392: NEG
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: PUSH
58398: LD_INT 2
58400: PUSH
58401: LD_INT 1
58403: NEG
58404: PUSH
58405: EMPTY
58406: LIST
58407: LIST
58408: PUSH
58409: EMPTY
58410: LIST
58411: LIST
58412: LIST
58413: LIST
58414: LIST
58415: LIST
58416: LIST
58417: LIST
58418: LIST
58419: LIST
58420: LIST
58421: LIST
58422: LIST
58423: LIST
58424: LIST
58425: LIST
58426: LIST
58427: LIST
58428: LIST
58429: LIST
58430: LIST
58431: LIST
58432: LIST
58433: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
58434: LD_ADDR_VAR 0 24
58438: PUSH
58439: LD_INT 0
58441: PUSH
58442: LD_INT 0
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: PUSH
58449: LD_INT 0
58451: PUSH
58452: LD_INT 1
58454: NEG
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: PUSH
58460: LD_INT 1
58462: PUSH
58463: LD_INT 0
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PUSH
58470: LD_INT 1
58472: PUSH
58473: LD_INT 1
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: PUSH
58480: LD_INT 0
58482: PUSH
58483: LD_INT 1
58485: PUSH
58486: EMPTY
58487: LIST
58488: LIST
58489: PUSH
58490: LD_INT 1
58492: NEG
58493: PUSH
58494: LD_INT 0
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: PUSH
58501: LD_INT 1
58503: NEG
58504: PUSH
58505: LD_INT 1
58507: NEG
58508: PUSH
58509: EMPTY
58510: LIST
58511: LIST
58512: PUSH
58513: LD_INT 1
58515: NEG
58516: PUSH
58517: LD_INT 2
58519: NEG
58520: PUSH
58521: EMPTY
58522: LIST
58523: LIST
58524: PUSH
58525: LD_INT 0
58527: PUSH
58528: LD_INT 2
58530: NEG
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PUSH
58536: LD_INT 1
58538: PUSH
58539: LD_INT 1
58541: NEG
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PUSH
58547: LD_INT 2
58549: PUSH
58550: LD_INT 0
58552: PUSH
58553: EMPTY
58554: LIST
58555: LIST
58556: PUSH
58557: LD_INT 2
58559: PUSH
58560: LD_INT 1
58562: PUSH
58563: EMPTY
58564: LIST
58565: LIST
58566: PUSH
58567: LD_INT 2
58569: PUSH
58570: LD_INT 2
58572: PUSH
58573: EMPTY
58574: LIST
58575: LIST
58576: PUSH
58577: LD_INT 1
58579: PUSH
58580: LD_INT 2
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: PUSH
58587: LD_INT 0
58589: PUSH
58590: LD_INT 2
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: PUSH
58597: LD_INT 1
58599: NEG
58600: PUSH
58601: LD_INT 1
58603: PUSH
58604: EMPTY
58605: LIST
58606: LIST
58607: PUSH
58608: LD_INT 2
58610: NEG
58611: PUSH
58612: LD_INT 0
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PUSH
58619: LD_INT 2
58621: NEG
58622: PUSH
58623: LD_INT 1
58625: NEG
58626: PUSH
58627: EMPTY
58628: LIST
58629: LIST
58630: PUSH
58631: LD_INT 2
58633: NEG
58634: PUSH
58635: LD_INT 2
58637: NEG
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: PUSH
58643: LD_INT 1
58645: PUSH
58646: LD_INT 2
58648: NEG
58649: PUSH
58650: EMPTY
58651: LIST
58652: LIST
58653: PUSH
58654: LD_INT 2
58656: PUSH
58657: LD_INT 1
58659: NEG
58660: PUSH
58661: EMPTY
58662: LIST
58663: LIST
58664: PUSH
58665: LD_INT 3
58667: PUSH
58668: LD_INT 1
58670: PUSH
58671: EMPTY
58672: LIST
58673: LIST
58674: PUSH
58675: LD_INT 3
58677: PUSH
58678: LD_INT 2
58680: PUSH
58681: EMPTY
58682: LIST
58683: LIST
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: LIST
58689: LIST
58690: LIST
58691: LIST
58692: LIST
58693: LIST
58694: LIST
58695: LIST
58696: LIST
58697: LIST
58698: LIST
58699: LIST
58700: LIST
58701: LIST
58702: LIST
58703: LIST
58704: LIST
58705: LIST
58706: LIST
58707: LIST
58708: LIST
58709: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
58710: LD_ADDR_VAR 0 25
58714: PUSH
58715: LD_INT 0
58717: PUSH
58718: LD_INT 0
58720: PUSH
58721: EMPTY
58722: LIST
58723: LIST
58724: PUSH
58725: LD_INT 0
58727: PUSH
58728: LD_INT 1
58730: NEG
58731: PUSH
58732: EMPTY
58733: LIST
58734: LIST
58735: PUSH
58736: LD_INT 1
58738: PUSH
58739: LD_INT 0
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: PUSH
58746: LD_INT 1
58748: PUSH
58749: LD_INT 1
58751: PUSH
58752: EMPTY
58753: LIST
58754: LIST
58755: PUSH
58756: LD_INT 0
58758: PUSH
58759: LD_INT 1
58761: PUSH
58762: EMPTY
58763: LIST
58764: LIST
58765: PUSH
58766: LD_INT 1
58768: NEG
58769: PUSH
58770: LD_INT 0
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: PUSH
58777: LD_INT 1
58779: NEG
58780: PUSH
58781: LD_INT 1
58783: NEG
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: PUSH
58789: LD_INT 1
58791: NEG
58792: PUSH
58793: LD_INT 2
58795: NEG
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: PUSH
58801: LD_INT 0
58803: PUSH
58804: LD_INT 2
58806: NEG
58807: PUSH
58808: EMPTY
58809: LIST
58810: LIST
58811: PUSH
58812: LD_INT 1
58814: PUSH
58815: LD_INT 1
58817: NEG
58818: PUSH
58819: EMPTY
58820: LIST
58821: LIST
58822: PUSH
58823: LD_INT 2
58825: PUSH
58826: LD_INT 0
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: PUSH
58833: LD_INT 2
58835: PUSH
58836: LD_INT 1
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: PUSH
58843: LD_INT 2
58845: PUSH
58846: LD_INT 2
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: LD_INT 1
58855: PUSH
58856: LD_INT 2
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PUSH
58863: LD_INT 0
58865: PUSH
58866: LD_INT 2
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: PUSH
58873: LD_INT 1
58875: NEG
58876: PUSH
58877: LD_INT 1
58879: PUSH
58880: EMPTY
58881: LIST
58882: LIST
58883: PUSH
58884: LD_INT 2
58886: NEG
58887: PUSH
58888: LD_INT 0
58890: PUSH
58891: EMPTY
58892: LIST
58893: LIST
58894: PUSH
58895: LD_INT 2
58897: NEG
58898: PUSH
58899: LD_INT 1
58901: NEG
58902: PUSH
58903: EMPTY
58904: LIST
58905: LIST
58906: PUSH
58907: LD_INT 2
58909: NEG
58910: PUSH
58911: LD_INT 2
58913: NEG
58914: PUSH
58915: EMPTY
58916: LIST
58917: LIST
58918: PUSH
58919: LD_INT 3
58921: PUSH
58922: LD_INT 1
58924: PUSH
58925: EMPTY
58926: LIST
58927: LIST
58928: PUSH
58929: LD_INT 3
58931: PUSH
58932: LD_INT 2
58934: PUSH
58935: EMPTY
58936: LIST
58937: LIST
58938: PUSH
58939: LD_INT 2
58941: PUSH
58942: LD_INT 3
58944: PUSH
58945: EMPTY
58946: LIST
58947: LIST
58948: PUSH
58949: LD_INT 1
58951: PUSH
58952: LD_INT 3
58954: PUSH
58955: EMPTY
58956: LIST
58957: LIST
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: LIST
58963: LIST
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: LIST
58970: LIST
58971: LIST
58972: LIST
58973: LIST
58974: LIST
58975: LIST
58976: LIST
58977: LIST
58978: LIST
58979: LIST
58980: LIST
58981: LIST
58982: LIST
58983: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
58984: LD_ADDR_VAR 0 26
58988: PUSH
58989: LD_INT 0
58991: PUSH
58992: LD_INT 0
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: PUSH
58999: LD_INT 0
59001: PUSH
59002: LD_INT 1
59004: NEG
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: PUSH
59010: LD_INT 1
59012: PUSH
59013: LD_INT 0
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: LD_INT 1
59022: PUSH
59023: LD_INT 1
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: PUSH
59030: LD_INT 0
59032: PUSH
59033: LD_INT 1
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: PUSH
59040: LD_INT 1
59042: NEG
59043: PUSH
59044: LD_INT 0
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: LD_INT 1
59053: NEG
59054: PUSH
59055: LD_INT 1
59057: NEG
59058: PUSH
59059: EMPTY
59060: LIST
59061: LIST
59062: PUSH
59063: LD_INT 1
59065: NEG
59066: PUSH
59067: LD_INT 2
59069: NEG
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: PUSH
59075: LD_INT 0
59077: PUSH
59078: LD_INT 2
59080: NEG
59081: PUSH
59082: EMPTY
59083: LIST
59084: LIST
59085: PUSH
59086: LD_INT 1
59088: PUSH
59089: LD_INT 1
59091: NEG
59092: PUSH
59093: EMPTY
59094: LIST
59095: LIST
59096: PUSH
59097: LD_INT 2
59099: PUSH
59100: LD_INT 0
59102: PUSH
59103: EMPTY
59104: LIST
59105: LIST
59106: PUSH
59107: LD_INT 2
59109: PUSH
59110: LD_INT 1
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: PUSH
59117: LD_INT 2
59119: PUSH
59120: LD_INT 2
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: PUSH
59127: LD_INT 1
59129: PUSH
59130: LD_INT 2
59132: PUSH
59133: EMPTY
59134: LIST
59135: LIST
59136: PUSH
59137: LD_INT 0
59139: PUSH
59140: LD_INT 2
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: PUSH
59147: LD_INT 1
59149: NEG
59150: PUSH
59151: LD_INT 1
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: PUSH
59158: LD_INT 2
59160: NEG
59161: PUSH
59162: LD_INT 0
59164: PUSH
59165: EMPTY
59166: LIST
59167: LIST
59168: PUSH
59169: LD_INT 2
59171: NEG
59172: PUSH
59173: LD_INT 1
59175: NEG
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 2
59183: NEG
59184: PUSH
59185: LD_INT 2
59187: NEG
59188: PUSH
59189: EMPTY
59190: LIST
59191: LIST
59192: PUSH
59193: LD_INT 2
59195: PUSH
59196: LD_INT 3
59198: PUSH
59199: EMPTY
59200: LIST
59201: LIST
59202: PUSH
59203: LD_INT 1
59205: PUSH
59206: LD_INT 3
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: PUSH
59213: LD_INT 1
59215: NEG
59216: PUSH
59217: LD_INT 2
59219: PUSH
59220: EMPTY
59221: LIST
59222: LIST
59223: PUSH
59224: LD_INT 2
59226: NEG
59227: PUSH
59228: LD_INT 1
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: PUSH
59235: EMPTY
59236: LIST
59237: LIST
59238: LIST
59239: LIST
59240: LIST
59241: LIST
59242: LIST
59243: LIST
59244: LIST
59245: LIST
59246: LIST
59247: LIST
59248: LIST
59249: LIST
59250: LIST
59251: LIST
59252: LIST
59253: LIST
59254: LIST
59255: LIST
59256: LIST
59257: LIST
59258: LIST
59259: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59260: LD_ADDR_VAR 0 27
59264: PUSH
59265: LD_INT 0
59267: PUSH
59268: LD_INT 0
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: PUSH
59275: LD_INT 0
59277: PUSH
59278: LD_INT 1
59280: NEG
59281: PUSH
59282: EMPTY
59283: LIST
59284: LIST
59285: PUSH
59286: LD_INT 1
59288: PUSH
59289: LD_INT 0
59291: PUSH
59292: EMPTY
59293: LIST
59294: LIST
59295: PUSH
59296: LD_INT 1
59298: PUSH
59299: LD_INT 1
59301: PUSH
59302: EMPTY
59303: LIST
59304: LIST
59305: PUSH
59306: LD_INT 0
59308: PUSH
59309: LD_INT 1
59311: PUSH
59312: EMPTY
59313: LIST
59314: LIST
59315: PUSH
59316: LD_INT 1
59318: NEG
59319: PUSH
59320: LD_INT 0
59322: PUSH
59323: EMPTY
59324: LIST
59325: LIST
59326: PUSH
59327: LD_INT 1
59329: NEG
59330: PUSH
59331: LD_INT 1
59333: NEG
59334: PUSH
59335: EMPTY
59336: LIST
59337: LIST
59338: PUSH
59339: LD_INT 1
59341: NEG
59342: PUSH
59343: LD_INT 2
59345: NEG
59346: PUSH
59347: EMPTY
59348: LIST
59349: LIST
59350: PUSH
59351: LD_INT 0
59353: PUSH
59354: LD_INT 2
59356: NEG
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: PUSH
59362: LD_INT 1
59364: PUSH
59365: LD_INT 1
59367: NEG
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PUSH
59373: LD_INT 2
59375: PUSH
59376: LD_INT 0
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PUSH
59383: LD_INT 2
59385: PUSH
59386: LD_INT 1
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: PUSH
59393: LD_INT 2
59395: PUSH
59396: LD_INT 2
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: LD_INT 1
59405: PUSH
59406: LD_INT 2
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: LD_INT 0
59415: PUSH
59416: LD_INT 2
59418: PUSH
59419: EMPTY
59420: LIST
59421: LIST
59422: PUSH
59423: LD_INT 1
59425: NEG
59426: PUSH
59427: LD_INT 1
59429: PUSH
59430: EMPTY
59431: LIST
59432: LIST
59433: PUSH
59434: LD_INT 2
59436: NEG
59437: PUSH
59438: LD_INT 0
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PUSH
59445: LD_INT 2
59447: NEG
59448: PUSH
59449: LD_INT 1
59451: NEG
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 2
59459: NEG
59460: PUSH
59461: LD_INT 2
59463: NEG
59464: PUSH
59465: EMPTY
59466: LIST
59467: LIST
59468: PUSH
59469: LD_INT 1
59471: NEG
59472: PUSH
59473: LD_INT 2
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: PUSH
59480: LD_INT 2
59482: NEG
59483: PUSH
59484: LD_INT 1
59486: PUSH
59487: EMPTY
59488: LIST
59489: LIST
59490: PUSH
59491: LD_INT 3
59493: NEG
59494: PUSH
59495: LD_INT 1
59497: NEG
59498: PUSH
59499: EMPTY
59500: LIST
59501: LIST
59502: PUSH
59503: LD_INT 3
59505: NEG
59506: PUSH
59507: LD_INT 2
59509: NEG
59510: PUSH
59511: EMPTY
59512: LIST
59513: LIST
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: LIST
59519: LIST
59520: LIST
59521: LIST
59522: LIST
59523: LIST
59524: LIST
59525: LIST
59526: LIST
59527: LIST
59528: LIST
59529: LIST
59530: LIST
59531: LIST
59532: LIST
59533: LIST
59534: LIST
59535: LIST
59536: LIST
59537: LIST
59538: LIST
59539: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59540: LD_ADDR_VAR 0 28
59544: PUSH
59545: LD_INT 0
59547: PUSH
59548: LD_INT 0
59550: PUSH
59551: EMPTY
59552: LIST
59553: LIST
59554: PUSH
59555: LD_INT 0
59557: PUSH
59558: LD_INT 1
59560: NEG
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PUSH
59566: LD_INT 1
59568: PUSH
59569: LD_INT 0
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: LD_INT 1
59578: PUSH
59579: LD_INT 1
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: LD_INT 0
59588: PUSH
59589: LD_INT 1
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 1
59598: NEG
59599: PUSH
59600: LD_INT 0
59602: PUSH
59603: EMPTY
59604: LIST
59605: LIST
59606: PUSH
59607: LD_INT 1
59609: NEG
59610: PUSH
59611: LD_INT 1
59613: NEG
59614: PUSH
59615: EMPTY
59616: LIST
59617: LIST
59618: PUSH
59619: LD_INT 1
59621: NEG
59622: PUSH
59623: LD_INT 2
59625: NEG
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PUSH
59631: LD_INT 0
59633: PUSH
59634: LD_INT 2
59636: NEG
59637: PUSH
59638: EMPTY
59639: LIST
59640: LIST
59641: PUSH
59642: LD_INT 1
59644: PUSH
59645: LD_INT 1
59647: NEG
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: LD_INT 2
59655: PUSH
59656: LD_INT 0
59658: PUSH
59659: EMPTY
59660: LIST
59661: LIST
59662: PUSH
59663: LD_INT 2
59665: PUSH
59666: LD_INT 1
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: PUSH
59673: LD_INT 2
59675: PUSH
59676: LD_INT 2
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: PUSH
59683: LD_INT 1
59685: PUSH
59686: LD_INT 2
59688: PUSH
59689: EMPTY
59690: LIST
59691: LIST
59692: PUSH
59693: LD_INT 0
59695: PUSH
59696: LD_INT 2
59698: PUSH
59699: EMPTY
59700: LIST
59701: LIST
59702: PUSH
59703: LD_INT 1
59705: NEG
59706: PUSH
59707: LD_INT 1
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: PUSH
59714: LD_INT 2
59716: NEG
59717: PUSH
59718: LD_INT 0
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: PUSH
59725: LD_INT 2
59727: NEG
59728: PUSH
59729: LD_INT 1
59731: NEG
59732: PUSH
59733: EMPTY
59734: LIST
59735: LIST
59736: PUSH
59737: LD_INT 2
59739: NEG
59740: PUSH
59741: LD_INT 2
59743: NEG
59744: PUSH
59745: EMPTY
59746: LIST
59747: LIST
59748: PUSH
59749: LD_INT 2
59751: NEG
59752: PUSH
59753: LD_INT 3
59755: NEG
59756: PUSH
59757: EMPTY
59758: LIST
59759: LIST
59760: PUSH
59761: LD_INT 1
59763: NEG
59764: PUSH
59765: LD_INT 3
59767: NEG
59768: PUSH
59769: EMPTY
59770: LIST
59771: LIST
59772: PUSH
59773: LD_INT 3
59775: NEG
59776: PUSH
59777: LD_INT 1
59779: NEG
59780: PUSH
59781: EMPTY
59782: LIST
59783: LIST
59784: PUSH
59785: LD_INT 3
59787: NEG
59788: PUSH
59789: LD_INT 2
59791: NEG
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: LIST
59801: LIST
59802: LIST
59803: LIST
59804: LIST
59805: LIST
59806: LIST
59807: LIST
59808: LIST
59809: LIST
59810: LIST
59811: LIST
59812: LIST
59813: LIST
59814: LIST
59815: LIST
59816: LIST
59817: LIST
59818: LIST
59819: LIST
59820: LIST
59821: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
59822: LD_ADDR_VAR 0 29
59826: PUSH
59827: LD_INT 0
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: PUSH
59837: LD_INT 0
59839: PUSH
59840: LD_INT 1
59842: NEG
59843: PUSH
59844: EMPTY
59845: LIST
59846: LIST
59847: PUSH
59848: LD_INT 1
59850: PUSH
59851: LD_INT 0
59853: PUSH
59854: EMPTY
59855: LIST
59856: LIST
59857: PUSH
59858: LD_INT 1
59860: PUSH
59861: LD_INT 1
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PUSH
59868: LD_INT 0
59870: PUSH
59871: LD_INT 1
59873: PUSH
59874: EMPTY
59875: LIST
59876: LIST
59877: PUSH
59878: LD_INT 1
59880: NEG
59881: PUSH
59882: LD_INT 0
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 1
59891: NEG
59892: PUSH
59893: LD_INT 1
59895: NEG
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 1
59903: NEG
59904: PUSH
59905: LD_INT 2
59907: NEG
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: PUSH
59913: LD_INT 0
59915: PUSH
59916: LD_INT 2
59918: NEG
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PUSH
59924: LD_INT 1
59926: PUSH
59927: LD_INT 1
59929: NEG
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 2
59937: PUSH
59938: LD_INT 0
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PUSH
59945: LD_INT 2
59947: PUSH
59948: LD_INT 1
59950: PUSH
59951: EMPTY
59952: LIST
59953: LIST
59954: PUSH
59955: LD_INT 1
59957: PUSH
59958: LD_INT 2
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: PUSH
59965: LD_INT 0
59967: PUSH
59968: LD_INT 2
59970: PUSH
59971: EMPTY
59972: LIST
59973: LIST
59974: PUSH
59975: LD_INT 1
59977: NEG
59978: PUSH
59979: LD_INT 1
59981: PUSH
59982: EMPTY
59983: LIST
59984: LIST
59985: PUSH
59986: LD_INT 2
59988: NEG
59989: PUSH
59990: LD_INT 1
59992: NEG
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: PUSH
59998: LD_INT 2
60000: NEG
60001: PUSH
60002: LD_INT 2
60004: NEG
60005: PUSH
60006: EMPTY
60007: LIST
60008: LIST
60009: PUSH
60010: LD_INT 2
60012: NEG
60013: PUSH
60014: LD_INT 3
60016: NEG
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PUSH
60022: LD_INT 2
60024: PUSH
60025: LD_INT 1
60027: NEG
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: PUSH
60033: LD_INT 3
60035: PUSH
60036: LD_INT 1
60038: PUSH
60039: EMPTY
60040: LIST
60041: LIST
60042: PUSH
60043: LD_INT 1
60045: PUSH
60046: LD_INT 3
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 1
60055: NEG
60056: PUSH
60057: LD_INT 2
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: PUSH
60064: LD_INT 3
60066: NEG
60067: PUSH
60068: LD_INT 2
60070: NEG
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: PUSH
60076: EMPTY
60077: LIST
60078: LIST
60079: LIST
60080: LIST
60081: LIST
60082: LIST
60083: LIST
60084: LIST
60085: LIST
60086: LIST
60087: LIST
60088: LIST
60089: LIST
60090: LIST
60091: LIST
60092: LIST
60093: LIST
60094: LIST
60095: LIST
60096: LIST
60097: LIST
60098: LIST
60099: LIST
60100: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
60101: LD_ADDR_VAR 0 30
60105: PUSH
60106: LD_INT 0
60108: PUSH
60109: LD_INT 0
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 0
60118: PUSH
60119: LD_INT 1
60121: NEG
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: PUSH
60127: LD_INT 1
60129: PUSH
60130: LD_INT 0
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: LD_INT 1
60139: PUSH
60140: LD_INT 1
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: PUSH
60147: LD_INT 0
60149: PUSH
60150: LD_INT 1
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PUSH
60157: LD_INT 1
60159: NEG
60160: PUSH
60161: LD_INT 0
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: LD_INT 1
60170: NEG
60171: PUSH
60172: LD_INT 1
60174: NEG
60175: PUSH
60176: EMPTY
60177: LIST
60178: LIST
60179: PUSH
60180: LD_INT 1
60182: NEG
60183: PUSH
60184: LD_INT 2
60186: NEG
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 0
60194: PUSH
60195: LD_INT 2
60197: NEG
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: PUSH
60203: LD_INT 1
60205: PUSH
60206: LD_INT 1
60208: NEG
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: PUSH
60214: LD_INT 2
60216: PUSH
60217: LD_INT 0
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: PUSH
60224: LD_INT 2
60226: PUSH
60227: LD_INT 1
60229: PUSH
60230: EMPTY
60231: LIST
60232: LIST
60233: PUSH
60234: LD_INT 2
60236: PUSH
60237: LD_INT 2
60239: PUSH
60240: EMPTY
60241: LIST
60242: LIST
60243: PUSH
60244: LD_INT 1
60246: PUSH
60247: LD_INT 2
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: PUSH
60254: LD_INT 1
60256: NEG
60257: PUSH
60258: LD_INT 1
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PUSH
60265: LD_INT 2
60267: NEG
60268: PUSH
60269: LD_INT 0
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: LD_INT 2
60278: NEG
60279: PUSH
60280: LD_INT 1
60282: NEG
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: PUSH
60288: LD_INT 1
60290: NEG
60291: PUSH
60292: LD_INT 3
60294: NEG
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: PUSH
60300: LD_INT 1
60302: PUSH
60303: LD_INT 2
60305: NEG
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: PUSH
60311: LD_INT 3
60313: PUSH
60314: LD_INT 2
60316: PUSH
60317: EMPTY
60318: LIST
60319: LIST
60320: PUSH
60321: LD_INT 2
60323: PUSH
60324: LD_INT 3
60326: PUSH
60327: EMPTY
60328: LIST
60329: LIST
60330: PUSH
60331: LD_INT 2
60333: NEG
60334: PUSH
60335: LD_INT 1
60337: PUSH
60338: EMPTY
60339: LIST
60340: LIST
60341: PUSH
60342: LD_INT 3
60344: NEG
60345: PUSH
60346: LD_INT 1
60348: NEG
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: LIST
60358: LIST
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: LIST
60364: LIST
60365: LIST
60366: LIST
60367: LIST
60368: LIST
60369: LIST
60370: LIST
60371: LIST
60372: LIST
60373: LIST
60374: LIST
60375: LIST
60376: LIST
60377: LIST
60378: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
60379: LD_ADDR_VAR 0 31
60383: PUSH
60384: LD_INT 0
60386: PUSH
60387: LD_INT 0
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: LD_INT 0
60396: PUSH
60397: LD_INT 1
60399: NEG
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: PUSH
60405: LD_INT 1
60407: PUSH
60408: LD_INT 0
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: LD_INT 1
60417: PUSH
60418: LD_INT 1
60420: PUSH
60421: EMPTY
60422: LIST
60423: LIST
60424: PUSH
60425: LD_INT 0
60427: PUSH
60428: LD_INT 1
60430: PUSH
60431: EMPTY
60432: LIST
60433: LIST
60434: PUSH
60435: LD_INT 1
60437: NEG
60438: PUSH
60439: LD_INT 0
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 1
60448: NEG
60449: PUSH
60450: LD_INT 1
60452: NEG
60453: PUSH
60454: EMPTY
60455: LIST
60456: LIST
60457: PUSH
60458: LD_INT 1
60460: NEG
60461: PUSH
60462: LD_INT 2
60464: NEG
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PUSH
60470: LD_INT 1
60472: PUSH
60473: LD_INT 1
60475: NEG
60476: PUSH
60477: EMPTY
60478: LIST
60479: LIST
60480: PUSH
60481: LD_INT 2
60483: PUSH
60484: LD_INT 0
60486: PUSH
60487: EMPTY
60488: LIST
60489: LIST
60490: PUSH
60491: LD_INT 2
60493: PUSH
60494: LD_INT 1
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PUSH
60501: LD_INT 2
60503: PUSH
60504: LD_INT 2
60506: PUSH
60507: EMPTY
60508: LIST
60509: LIST
60510: PUSH
60511: LD_INT 1
60513: PUSH
60514: LD_INT 2
60516: PUSH
60517: EMPTY
60518: LIST
60519: LIST
60520: PUSH
60521: LD_INT 0
60523: PUSH
60524: LD_INT 2
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: PUSH
60531: LD_INT 1
60533: NEG
60534: PUSH
60535: LD_INT 1
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: PUSH
60542: LD_INT 2
60544: NEG
60545: PUSH
60546: LD_INT 1
60548: NEG
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: PUSH
60554: LD_INT 2
60556: NEG
60557: PUSH
60558: LD_INT 2
60560: NEG
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: LD_INT 2
60568: NEG
60569: PUSH
60570: LD_INT 3
60572: NEG
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: LD_INT 2
60580: PUSH
60581: LD_INT 1
60583: NEG
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: LD_INT 3
60591: PUSH
60592: LD_INT 1
60594: PUSH
60595: EMPTY
60596: LIST
60597: LIST
60598: PUSH
60599: LD_INT 1
60601: PUSH
60602: LD_INT 3
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: PUSH
60609: LD_INT 1
60611: NEG
60612: PUSH
60613: LD_INT 2
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: LD_INT 3
60622: NEG
60623: PUSH
60624: LD_INT 2
60626: NEG
60627: PUSH
60628: EMPTY
60629: LIST
60630: LIST
60631: PUSH
60632: EMPTY
60633: LIST
60634: LIST
60635: LIST
60636: LIST
60637: LIST
60638: LIST
60639: LIST
60640: LIST
60641: LIST
60642: LIST
60643: LIST
60644: LIST
60645: LIST
60646: LIST
60647: LIST
60648: LIST
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: LIST
60654: LIST
60655: LIST
60656: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
60657: LD_ADDR_VAR 0 32
60661: PUSH
60662: LD_INT 0
60664: PUSH
60665: LD_INT 0
60667: PUSH
60668: EMPTY
60669: LIST
60670: LIST
60671: PUSH
60672: LD_INT 0
60674: PUSH
60675: LD_INT 1
60677: NEG
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: PUSH
60683: LD_INT 1
60685: PUSH
60686: LD_INT 0
60688: PUSH
60689: EMPTY
60690: LIST
60691: LIST
60692: PUSH
60693: LD_INT 1
60695: PUSH
60696: LD_INT 1
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: LD_INT 0
60705: PUSH
60706: LD_INT 1
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 1
60715: NEG
60716: PUSH
60717: LD_INT 0
60719: PUSH
60720: EMPTY
60721: LIST
60722: LIST
60723: PUSH
60724: LD_INT 1
60726: NEG
60727: PUSH
60728: LD_INT 1
60730: NEG
60731: PUSH
60732: EMPTY
60733: LIST
60734: LIST
60735: PUSH
60736: LD_INT 1
60738: NEG
60739: PUSH
60740: LD_INT 2
60742: NEG
60743: PUSH
60744: EMPTY
60745: LIST
60746: LIST
60747: PUSH
60748: LD_INT 0
60750: PUSH
60751: LD_INT 2
60753: NEG
60754: PUSH
60755: EMPTY
60756: LIST
60757: LIST
60758: PUSH
60759: LD_INT 1
60761: PUSH
60762: LD_INT 1
60764: NEG
60765: PUSH
60766: EMPTY
60767: LIST
60768: LIST
60769: PUSH
60770: LD_INT 2
60772: PUSH
60773: LD_INT 1
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PUSH
60780: LD_INT 2
60782: PUSH
60783: LD_INT 2
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: PUSH
60790: LD_INT 1
60792: PUSH
60793: LD_INT 2
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: PUSH
60800: LD_INT 0
60802: PUSH
60803: LD_INT 2
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: LD_INT 1
60812: NEG
60813: PUSH
60814: LD_INT 1
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: LD_INT 2
60823: NEG
60824: PUSH
60825: LD_INT 0
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: LD_INT 2
60834: NEG
60835: PUSH
60836: LD_INT 1
60838: NEG
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: PUSH
60844: LD_INT 1
60846: NEG
60847: PUSH
60848: LD_INT 3
60850: NEG
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: PUSH
60856: LD_INT 1
60858: PUSH
60859: LD_INT 2
60861: NEG
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PUSH
60867: LD_INT 3
60869: PUSH
60870: LD_INT 2
60872: PUSH
60873: EMPTY
60874: LIST
60875: LIST
60876: PUSH
60877: LD_INT 2
60879: PUSH
60880: LD_INT 3
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: PUSH
60887: LD_INT 2
60889: NEG
60890: PUSH
60891: LD_INT 1
60893: PUSH
60894: EMPTY
60895: LIST
60896: LIST
60897: PUSH
60898: LD_INT 3
60900: NEG
60901: PUSH
60902: LD_INT 1
60904: NEG
60905: PUSH
60906: EMPTY
60907: LIST
60908: LIST
60909: PUSH
60910: EMPTY
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: LIST
60922: LIST
60923: LIST
60924: LIST
60925: LIST
60926: LIST
60927: LIST
60928: LIST
60929: LIST
60930: LIST
60931: LIST
60932: LIST
60933: LIST
60934: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
60935: LD_ADDR_VAR 0 33
60939: PUSH
60940: LD_INT 0
60942: PUSH
60943: LD_INT 0
60945: PUSH
60946: EMPTY
60947: LIST
60948: LIST
60949: PUSH
60950: LD_INT 0
60952: PUSH
60953: LD_INT 1
60955: NEG
60956: PUSH
60957: EMPTY
60958: LIST
60959: LIST
60960: PUSH
60961: LD_INT 1
60963: PUSH
60964: LD_INT 0
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: PUSH
60971: LD_INT 1
60973: PUSH
60974: LD_INT 1
60976: PUSH
60977: EMPTY
60978: LIST
60979: LIST
60980: PUSH
60981: LD_INT 0
60983: PUSH
60984: LD_INT 1
60986: PUSH
60987: EMPTY
60988: LIST
60989: LIST
60990: PUSH
60991: LD_INT 1
60993: NEG
60994: PUSH
60995: LD_INT 0
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: LD_INT 1
61004: NEG
61005: PUSH
61006: LD_INT 1
61008: NEG
61009: PUSH
61010: EMPTY
61011: LIST
61012: LIST
61013: PUSH
61014: LD_INT 1
61016: NEG
61017: PUSH
61018: LD_INT 2
61020: NEG
61021: PUSH
61022: EMPTY
61023: LIST
61024: LIST
61025: PUSH
61026: LD_INT 1
61028: PUSH
61029: LD_INT 1
61031: NEG
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: PUSH
61037: LD_INT 2
61039: PUSH
61040: LD_INT 0
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PUSH
61047: LD_INT 2
61049: PUSH
61050: LD_INT 1
61052: PUSH
61053: EMPTY
61054: LIST
61055: LIST
61056: PUSH
61057: LD_INT 1
61059: PUSH
61060: LD_INT 2
61062: PUSH
61063: EMPTY
61064: LIST
61065: LIST
61066: PUSH
61067: LD_INT 0
61069: PUSH
61070: LD_INT 2
61072: PUSH
61073: EMPTY
61074: LIST
61075: LIST
61076: PUSH
61077: LD_INT 1
61079: NEG
61080: PUSH
61081: LD_INT 1
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: PUSH
61088: LD_INT 2
61090: NEG
61091: PUSH
61092: LD_INT 0
61094: PUSH
61095: EMPTY
61096: LIST
61097: LIST
61098: PUSH
61099: LD_INT 2
61101: NEG
61102: PUSH
61103: LD_INT 1
61105: NEG
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: LD_INT 2
61113: NEG
61114: PUSH
61115: LD_INT 2
61117: NEG
61118: PUSH
61119: EMPTY
61120: LIST
61121: LIST
61122: PUSH
61123: LD_INT 2
61125: NEG
61126: PUSH
61127: LD_INT 3
61129: NEG
61130: PUSH
61131: EMPTY
61132: LIST
61133: LIST
61134: PUSH
61135: LD_INT 2
61137: PUSH
61138: LD_INT 1
61140: NEG
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 3
61148: PUSH
61149: LD_INT 1
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: LD_INT 1
61158: PUSH
61159: LD_INT 3
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PUSH
61166: LD_INT 1
61168: NEG
61169: PUSH
61170: LD_INT 2
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: LD_INT 3
61179: NEG
61180: PUSH
61181: LD_INT 2
61183: NEG
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PUSH
61189: EMPTY
61190: LIST
61191: LIST
61192: LIST
61193: LIST
61194: LIST
61195: LIST
61196: LIST
61197: LIST
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
61214: LD_ADDR_VAR 0 34
61218: PUSH
61219: LD_INT 0
61221: PUSH
61222: LD_INT 0
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 0
61231: PUSH
61232: LD_INT 1
61234: NEG
61235: PUSH
61236: EMPTY
61237: LIST
61238: LIST
61239: PUSH
61240: LD_INT 1
61242: PUSH
61243: LD_INT 0
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: PUSH
61250: LD_INT 1
61252: PUSH
61253: LD_INT 1
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PUSH
61260: LD_INT 0
61262: PUSH
61263: LD_INT 1
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: LD_INT 1
61272: NEG
61273: PUSH
61274: LD_INT 0
61276: PUSH
61277: EMPTY
61278: LIST
61279: LIST
61280: PUSH
61281: LD_INT 1
61283: NEG
61284: PUSH
61285: LD_INT 1
61287: NEG
61288: PUSH
61289: EMPTY
61290: LIST
61291: LIST
61292: PUSH
61293: LD_INT 1
61295: NEG
61296: PUSH
61297: LD_INT 2
61299: NEG
61300: PUSH
61301: EMPTY
61302: LIST
61303: LIST
61304: PUSH
61305: LD_INT 0
61307: PUSH
61308: LD_INT 2
61310: NEG
61311: PUSH
61312: EMPTY
61313: LIST
61314: LIST
61315: PUSH
61316: LD_INT 1
61318: PUSH
61319: LD_INT 1
61321: NEG
61322: PUSH
61323: EMPTY
61324: LIST
61325: LIST
61326: PUSH
61327: LD_INT 2
61329: PUSH
61330: LD_INT 1
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: PUSH
61337: LD_INT 2
61339: PUSH
61340: LD_INT 2
61342: PUSH
61343: EMPTY
61344: LIST
61345: LIST
61346: PUSH
61347: LD_INT 1
61349: PUSH
61350: LD_INT 2
61352: PUSH
61353: EMPTY
61354: LIST
61355: LIST
61356: PUSH
61357: LD_INT 1
61359: NEG
61360: PUSH
61361: LD_INT 1
61363: PUSH
61364: EMPTY
61365: LIST
61366: LIST
61367: PUSH
61368: LD_INT 2
61370: NEG
61371: PUSH
61372: LD_INT 0
61374: PUSH
61375: EMPTY
61376: LIST
61377: LIST
61378: PUSH
61379: LD_INT 2
61381: NEG
61382: PUSH
61383: LD_INT 1
61385: NEG
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: LD_INT 2
61393: NEG
61394: PUSH
61395: LD_INT 2
61397: NEG
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: PUSH
61403: LD_INT 1
61405: NEG
61406: PUSH
61407: LD_INT 3
61409: NEG
61410: PUSH
61411: EMPTY
61412: LIST
61413: LIST
61414: PUSH
61415: LD_INT 1
61417: PUSH
61418: LD_INT 2
61420: NEG
61421: PUSH
61422: EMPTY
61423: LIST
61424: LIST
61425: PUSH
61426: LD_INT 3
61428: PUSH
61429: LD_INT 2
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: LD_INT 2
61438: PUSH
61439: LD_INT 3
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PUSH
61446: LD_INT 2
61448: NEG
61449: PUSH
61450: LD_INT 1
61452: PUSH
61453: EMPTY
61454: LIST
61455: LIST
61456: PUSH
61457: LD_INT 3
61459: NEG
61460: PUSH
61461: LD_INT 1
61463: NEG
61464: PUSH
61465: EMPTY
61466: LIST
61467: LIST
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: LIST
61473: LIST
61474: LIST
61475: LIST
61476: LIST
61477: LIST
61478: LIST
61479: LIST
61480: LIST
61481: LIST
61482: LIST
61483: LIST
61484: LIST
61485: LIST
61486: LIST
61487: LIST
61488: LIST
61489: LIST
61490: LIST
61491: LIST
61492: LIST
61493: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
61494: LD_ADDR_VAR 0 35
61498: PUSH
61499: LD_INT 0
61501: PUSH
61502: LD_INT 0
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: LD_INT 0
61511: PUSH
61512: LD_INT 1
61514: NEG
61515: PUSH
61516: EMPTY
61517: LIST
61518: LIST
61519: PUSH
61520: LD_INT 1
61522: PUSH
61523: LD_INT 0
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: LD_INT 1
61532: PUSH
61533: LD_INT 1
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 0
61542: PUSH
61543: LD_INT 1
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 1
61552: NEG
61553: PUSH
61554: LD_INT 0
61556: PUSH
61557: EMPTY
61558: LIST
61559: LIST
61560: PUSH
61561: LD_INT 1
61563: NEG
61564: PUSH
61565: LD_INT 1
61567: NEG
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: LD_INT 2
61575: PUSH
61576: LD_INT 1
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: LD_INT 2
61585: NEG
61586: PUSH
61587: LD_INT 1
61589: NEG
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PUSH
61595: EMPTY
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: LIST
61604: LIST
61605: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
61606: LD_ADDR_VAR 0 36
61610: PUSH
61611: LD_INT 0
61613: PUSH
61614: LD_INT 0
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: PUSH
61621: LD_INT 0
61623: PUSH
61624: LD_INT 1
61626: NEG
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 1
61634: PUSH
61635: LD_INT 0
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: LD_INT 1
61644: PUSH
61645: LD_INT 1
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PUSH
61652: LD_INT 0
61654: PUSH
61655: LD_INT 1
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 1
61664: NEG
61665: PUSH
61666: LD_INT 0
61668: PUSH
61669: EMPTY
61670: LIST
61671: LIST
61672: PUSH
61673: LD_INT 1
61675: NEG
61676: PUSH
61677: LD_INT 1
61679: NEG
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: LD_INT 1
61687: NEG
61688: PUSH
61689: LD_INT 2
61691: NEG
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PUSH
61697: LD_INT 1
61699: PUSH
61700: LD_INT 2
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: PUSH
61707: EMPTY
61708: LIST
61709: LIST
61710: LIST
61711: LIST
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: LIST
61717: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
61718: LD_ADDR_VAR 0 37
61722: PUSH
61723: LD_INT 0
61725: PUSH
61726: LD_INT 0
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: LD_INT 0
61735: PUSH
61736: LD_INT 1
61738: NEG
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PUSH
61744: LD_INT 1
61746: PUSH
61747: LD_INT 0
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: PUSH
61754: LD_INT 1
61756: PUSH
61757: LD_INT 1
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: PUSH
61764: LD_INT 0
61766: PUSH
61767: LD_INT 1
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: PUSH
61774: LD_INT 1
61776: NEG
61777: PUSH
61778: LD_INT 0
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: PUSH
61785: LD_INT 1
61787: NEG
61788: PUSH
61789: LD_INT 1
61791: NEG
61792: PUSH
61793: EMPTY
61794: LIST
61795: LIST
61796: PUSH
61797: LD_INT 1
61799: PUSH
61800: LD_INT 1
61802: NEG
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PUSH
61808: LD_INT 1
61810: NEG
61811: PUSH
61812: LD_INT 1
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: LIST
61827: LIST
61828: LIST
61829: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
61830: LD_ADDR_VAR 0 38
61834: PUSH
61835: LD_INT 0
61837: PUSH
61838: LD_INT 0
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: LD_INT 0
61847: PUSH
61848: LD_INT 1
61850: NEG
61851: PUSH
61852: EMPTY
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 1
61858: PUSH
61859: LD_INT 0
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: PUSH
61866: LD_INT 1
61868: PUSH
61869: LD_INT 1
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: PUSH
61876: LD_INT 0
61878: PUSH
61879: LD_INT 1
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: LD_INT 1
61888: NEG
61889: PUSH
61890: LD_INT 0
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: PUSH
61897: LD_INT 1
61899: NEG
61900: PUSH
61901: LD_INT 1
61903: NEG
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PUSH
61909: LD_INT 2
61911: PUSH
61912: LD_INT 1
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: LD_INT 2
61921: NEG
61922: PUSH
61923: LD_INT 1
61925: NEG
61926: PUSH
61927: EMPTY
61928: LIST
61929: LIST
61930: PUSH
61931: EMPTY
61932: LIST
61933: LIST
61934: LIST
61935: LIST
61936: LIST
61937: LIST
61938: LIST
61939: LIST
61940: LIST
61941: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
61942: LD_ADDR_VAR 0 39
61946: PUSH
61947: LD_INT 0
61949: PUSH
61950: LD_INT 0
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PUSH
61957: LD_INT 0
61959: PUSH
61960: LD_INT 1
61962: NEG
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: PUSH
61968: LD_INT 1
61970: PUSH
61971: LD_INT 0
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 1
61980: PUSH
61981: LD_INT 1
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: PUSH
61988: LD_INT 0
61990: PUSH
61991: LD_INT 1
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 1
62000: NEG
62001: PUSH
62002: LD_INT 0
62004: PUSH
62005: EMPTY
62006: LIST
62007: LIST
62008: PUSH
62009: LD_INT 1
62011: NEG
62012: PUSH
62013: LD_INT 1
62015: NEG
62016: PUSH
62017: EMPTY
62018: LIST
62019: LIST
62020: PUSH
62021: LD_INT 1
62023: NEG
62024: PUSH
62025: LD_INT 2
62027: NEG
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: LD_INT 1
62035: PUSH
62036: LD_INT 2
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: LIST
62047: LIST
62048: LIST
62049: LIST
62050: LIST
62051: LIST
62052: LIST
62053: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
62054: LD_ADDR_VAR 0 40
62058: PUSH
62059: LD_INT 0
62061: PUSH
62062: LD_INT 0
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: LD_INT 0
62071: PUSH
62072: LD_INT 1
62074: NEG
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: PUSH
62080: LD_INT 1
62082: PUSH
62083: LD_INT 0
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: PUSH
62090: LD_INT 1
62092: PUSH
62093: LD_INT 1
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PUSH
62100: LD_INT 0
62102: PUSH
62103: LD_INT 1
62105: PUSH
62106: EMPTY
62107: LIST
62108: LIST
62109: PUSH
62110: LD_INT 1
62112: NEG
62113: PUSH
62114: LD_INT 0
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: PUSH
62121: LD_INT 1
62123: NEG
62124: PUSH
62125: LD_INT 1
62127: NEG
62128: PUSH
62129: EMPTY
62130: LIST
62131: LIST
62132: PUSH
62133: LD_INT 1
62135: PUSH
62136: LD_INT 1
62138: NEG
62139: PUSH
62140: EMPTY
62141: LIST
62142: LIST
62143: PUSH
62144: LD_INT 1
62146: NEG
62147: PUSH
62148: LD_INT 1
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: EMPTY
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: LIST
62165: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62166: LD_ADDR_VAR 0 41
62170: PUSH
62171: LD_INT 0
62173: PUSH
62174: LD_INT 0
62176: PUSH
62177: EMPTY
62178: LIST
62179: LIST
62180: PUSH
62181: LD_INT 0
62183: PUSH
62184: LD_INT 1
62186: NEG
62187: PUSH
62188: EMPTY
62189: LIST
62190: LIST
62191: PUSH
62192: LD_INT 1
62194: PUSH
62195: LD_INT 0
62197: PUSH
62198: EMPTY
62199: LIST
62200: LIST
62201: PUSH
62202: LD_INT 1
62204: PUSH
62205: LD_INT 1
62207: PUSH
62208: EMPTY
62209: LIST
62210: LIST
62211: PUSH
62212: LD_INT 0
62214: PUSH
62215: LD_INT 1
62217: PUSH
62218: EMPTY
62219: LIST
62220: LIST
62221: PUSH
62222: LD_INT 1
62224: NEG
62225: PUSH
62226: LD_INT 0
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 1
62235: NEG
62236: PUSH
62237: LD_INT 1
62239: NEG
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: PUSH
62245: LD_INT 1
62247: NEG
62248: PUSH
62249: LD_INT 2
62251: NEG
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: PUSH
62257: LD_INT 1
62259: PUSH
62260: LD_INT 1
62262: NEG
62263: PUSH
62264: EMPTY
62265: LIST
62266: LIST
62267: PUSH
62268: LD_INT 2
62270: PUSH
62271: LD_INT 0
62273: PUSH
62274: EMPTY
62275: LIST
62276: LIST
62277: PUSH
62278: LD_INT 2
62280: PUSH
62281: LD_INT 1
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PUSH
62288: LD_INT 2
62290: PUSH
62291: LD_INT 2
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: PUSH
62298: LD_INT 1
62300: PUSH
62301: LD_INT 2
62303: PUSH
62304: EMPTY
62305: LIST
62306: LIST
62307: PUSH
62308: LD_INT 1
62310: NEG
62311: PUSH
62312: LD_INT 1
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: PUSH
62319: LD_INT 2
62321: NEG
62322: PUSH
62323: LD_INT 0
62325: PUSH
62326: EMPTY
62327: LIST
62328: LIST
62329: PUSH
62330: LD_INT 2
62332: NEG
62333: PUSH
62334: LD_INT 1
62336: NEG
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: PUSH
62342: LD_INT 2
62344: NEG
62345: PUSH
62346: LD_INT 2
62348: NEG
62349: PUSH
62350: EMPTY
62351: LIST
62352: LIST
62353: PUSH
62354: LD_INT 2
62356: NEG
62357: PUSH
62358: LD_INT 3
62360: NEG
62361: PUSH
62362: EMPTY
62363: LIST
62364: LIST
62365: PUSH
62366: LD_INT 2
62368: PUSH
62369: LD_INT 1
62371: NEG
62372: PUSH
62373: EMPTY
62374: LIST
62375: LIST
62376: PUSH
62377: LD_INT 3
62379: PUSH
62380: LD_INT 0
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: PUSH
62387: LD_INT 3
62389: PUSH
62390: LD_INT 1
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PUSH
62397: LD_INT 3
62399: PUSH
62400: LD_INT 2
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 3
62409: PUSH
62410: LD_INT 3
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 2
62419: PUSH
62420: LD_INT 3
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 2
62429: NEG
62430: PUSH
62431: LD_INT 1
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: LD_INT 3
62440: NEG
62441: PUSH
62442: LD_INT 0
62444: PUSH
62445: EMPTY
62446: LIST
62447: LIST
62448: PUSH
62449: LD_INT 3
62451: NEG
62452: PUSH
62453: LD_INT 1
62455: NEG
62456: PUSH
62457: EMPTY
62458: LIST
62459: LIST
62460: PUSH
62461: LD_INT 3
62463: NEG
62464: PUSH
62465: LD_INT 2
62467: NEG
62468: PUSH
62469: EMPTY
62470: LIST
62471: LIST
62472: PUSH
62473: LD_INT 3
62475: NEG
62476: PUSH
62477: LD_INT 3
62479: NEG
62480: PUSH
62481: EMPTY
62482: LIST
62483: LIST
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: LIST
62489: LIST
62490: LIST
62491: LIST
62492: LIST
62493: LIST
62494: LIST
62495: LIST
62496: LIST
62497: LIST
62498: LIST
62499: LIST
62500: LIST
62501: LIST
62502: LIST
62503: LIST
62504: LIST
62505: LIST
62506: LIST
62507: LIST
62508: LIST
62509: LIST
62510: LIST
62511: LIST
62512: LIST
62513: LIST
62514: LIST
62515: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62516: LD_ADDR_VAR 0 42
62520: PUSH
62521: LD_INT 0
62523: PUSH
62524: LD_INT 0
62526: PUSH
62527: EMPTY
62528: LIST
62529: LIST
62530: PUSH
62531: LD_INT 0
62533: PUSH
62534: LD_INT 1
62536: NEG
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: LD_INT 1
62544: PUSH
62545: LD_INT 0
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: PUSH
62552: LD_INT 1
62554: PUSH
62555: LD_INT 1
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: PUSH
62562: LD_INT 0
62564: PUSH
62565: LD_INT 1
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: PUSH
62572: LD_INT 1
62574: NEG
62575: PUSH
62576: LD_INT 0
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: PUSH
62583: LD_INT 1
62585: NEG
62586: PUSH
62587: LD_INT 1
62589: NEG
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 1
62597: NEG
62598: PUSH
62599: LD_INT 2
62601: NEG
62602: PUSH
62603: EMPTY
62604: LIST
62605: LIST
62606: PUSH
62607: LD_INT 0
62609: PUSH
62610: LD_INT 2
62612: NEG
62613: PUSH
62614: EMPTY
62615: LIST
62616: LIST
62617: PUSH
62618: LD_INT 1
62620: PUSH
62621: LD_INT 1
62623: NEG
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: PUSH
62629: LD_INT 2
62631: PUSH
62632: LD_INT 1
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 2
62641: PUSH
62642: LD_INT 2
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 1
62651: PUSH
62652: LD_INT 2
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 0
62661: PUSH
62662: LD_INT 2
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: LD_INT 1
62671: NEG
62672: PUSH
62673: LD_INT 1
62675: PUSH
62676: EMPTY
62677: LIST
62678: LIST
62679: PUSH
62680: LD_INT 2
62682: NEG
62683: PUSH
62684: LD_INT 1
62686: NEG
62687: PUSH
62688: EMPTY
62689: LIST
62690: LIST
62691: PUSH
62692: LD_INT 2
62694: NEG
62695: PUSH
62696: LD_INT 2
62698: NEG
62699: PUSH
62700: EMPTY
62701: LIST
62702: LIST
62703: PUSH
62704: LD_INT 2
62706: NEG
62707: PUSH
62708: LD_INT 3
62710: NEG
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: LD_INT 1
62718: NEG
62719: PUSH
62720: LD_INT 3
62722: NEG
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: PUSH
62728: LD_INT 0
62730: PUSH
62731: LD_INT 3
62733: NEG
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PUSH
62739: LD_INT 1
62741: PUSH
62742: LD_INT 2
62744: NEG
62745: PUSH
62746: EMPTY
62747: LIST
62748: LIST
62749: PUSH
62750: LD_INT 3
62752: PUSH
62753: LD_INT 2
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: PUSH
62760: LD_INT 3
62762: PUSH
62763: LD_INT 3
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PUSH
62770: LD_INT 2
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: EMPTY
62777: LIST
62778: LIST
62779: PUSH
62780: LD_INT 1
62782: PUSH
62783: LD_INT 3
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: PUSH
62790: LD_INT 0
62792: PUSH
62793: LD_INT 3
62795: PUSH
62796: EMPTY
62797: LIST
62798: LIST
62799: PUSH
62800: LD_INT 1
62802: NEG
62803: PUSH
62804: LD_INT 2
62806: PUSH
62807: EMPTY
62808: LIST
62809: LIST
62810: PUSH
62811: LD_INT 3
62813: NEG
62814: PUSH
62815: LD_INT 2
62817: NEG
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 3
62825: NEG
62826: PUSH
62827: LD_INT 3
62829: NEG
62830: PUSH
62831: EMPTY
62832: LIST
62833: LIST
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: LIST
62841: LIST
62842: LIST
62843: LIST
62844: LIST
62845: LIST
62846: LIST
62847: LIST
62848: LIST
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: LIST
62854: LIST
62855: LIST
62856: LIST
62857: LIST
62858: LIST
62859: LIST
62860: LIST
62861: LIST
62862: LIST
62863: LIST
62864: LIST
62865: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62866: LD_ADDR_VAR 0 43
62870: PUSH
62871: LD_INT 0
62873: PUSH
62874: LD_INT 0
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: PUSH
62881: LD_INT 0
62883: PUSH
62884: LD_INT 1
62886: NEG
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PUSH
62892: LD_INT 1
62894: PUSH
62895: LD_INT 0
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: LD_INT 1
62904: PUSH
62905: LD_INT 1
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 0
62914: PUSH
62915: LD_INT 1
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: PUSH
62922: LD_INT 1
62924: NEG
62925: PUSH
62926: LD_INT 0
62928: PUSH
62929: EMPTY
62930: LIST
62931: LIST
62932: PUSH
62933: LD_INT 1
62935: NEG
62936: PUSH
62937: LD_INT 1
62939: NEG
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: PUSH
62945: LD_INT 1
62947: NEG
62948: PUSH
62949: LD_INT 2
62951: NEG
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: LD_INT 2
62962: NEG
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: PUSH
62968: LD_INT 1
62970: PUSH
62971: LD_INT 1
62973: NEG
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: LD_INT 2
62981: PUSH
62982: LD_INT 0
62984: PUSH
62985: EMPTY
62986: LIST
62987: LIST
62988: PUSH
62989: LD_INT 2
62991: PUSH
62992: LD_INT 1
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 1
63001: PUSH
63002: LD_INT 2
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: LD_INT 0
63011: PUSH
63012: LD_INT 2
63014: PUSH
63015: EMPTY
63016: LIST
63017: LIST
63018: PUSH
63019: LD_INT 1
63021: NEG
63022: PUSH
63023: LD_INT 1
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: PUSH
63030: LD_INT 2
63032: NEG
63033: PUSH
63034: LD_INT 0
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 2
63043: NEG
63044: PUSH
63045: LD_INT 1
63047: NEG
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: PUSH
63053: LD_INT 1
63055: NEG
63056: PUSH
63057: LD_INT 3
63059: NEG
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 0
63067: PUSH
63068: LD_INT 3
63070: NEG
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: PUSH
63076: LD_INT 1
63078: PUSH
63079: LD_INT 2
63081: NEG
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PUSH
63087: LD_INT 2
63089: PUSH
63090: LD_INT 1
63092: NEG
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: LD_INT 3
63100: PUSH
63101: LD_INT 0
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PUSH
63108: LD_INT 3
63110: PUSH
63111: LD_INT 1
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 1
63120: PUSH
63121: LD_INT 3
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: PUSH
63128: LD_INT 0
63130: PUSH
63131: LD_INT 3
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 1
63140: NEG
63141: PUSH
63142: LD_INT 2
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PUSH
63149: LD_INT 2
63151: NEG
63152: PUSH
63153: LD_INT 1
63155: PUSH
63156: EMPTY
63157: LIST
63158: LIST
63159: PUSH
63160: LD_INT 3
63162: NEG
63163: PUSH
63164: LD_INT 0
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 3
63173: NEG
63174: PUSH
63175: LD_INT 1
63177: NEG
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: EMPTY
63184: LIST
63185: LIST
63186: LIST
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: LIST
63194: LIST
63195: LIST
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63214: LD_ADDR_VAR 0 44
63218: PUSH
63219: LD_INT 0
63221: PUSH
63222: LD_INT 0
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PUSH
63229: LD_INT 0
63231: PUSH
63232: LD_INT 1
63234: NEG
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: LD_INT 1
63242: PUSH
63243: LD_INT 0
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PUSH
63250: LD_INT 1
63252: PUSH
63253: LD_INT 1
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 0
63262: PUSH
63263: LD_INT 1
63265: PUSH
63266: EMPTY
63267: LIST
63268: LIST
63269: PUSH
63270: LD_INT 1
63272: NEG
63273: PUSH
63274: LD_INT 0
63276: PUSH
63277: EMPTY
63278: LIST
63279: LIST
63280: PUSH
63281: LD_INT 1
63283: NEG
63284: PUSH
63285: LD_INT 1
63287: NEG
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: PUSH
63293: LD_INT 1
63295: NEG
63296: PUSH
63297: LD_INT 2
63299: NEG
63300: PUSH
63301: EMPTY
63302: LIST
63303: LIST
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: LD_INT 1
63310: NEG
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: LD_INT 2
63318: PUSH
63319: LD_INT 0
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PUSH
63326: LD_INT 2
63328: PUSH
63329: LD_INT 1
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 2
63338: PUSH
63339: LD_INT 2
63341: PUSH
63342: EMPTY
63343: LIST
63344: LIST
63345: PUSH
63346: LD_INT 1
63348: PUSH
63349: LD_INT 2
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: LD_INT 1
63358: NEG
63359: PUSH
63360: LD_INT 1
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 2
63369: NEG
63370: PUSH
63371: LD_INT 0
63373: PUSH
63374: EMPTY
63375: LIST
63376: LIST
63377: PUSH
63378: LD_INT 2
63380: NEG
63381: PUSH
63382: LD_INT 1
63384: NEG
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 2
63392: NEG
63393: PUSH
63394: LD_INT 2
63396: NEG
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: PUSH
63402: LD_INT 2
63404: NEG
63405: PUSH
63406: LD_INT 3
63408: NEG
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: PUSH
63414: LD_INT 2
63416: PUSH
63417: LD_INT 1
63419: NEG
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 3
63427: PUSH
63428: LD_INT 0
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: LD_INT 3
63437: PUSH
63438: LD_INT 1
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PUSH
63445: LD_INT 3
63447: PUSH
63448: LD_INT 2
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 3
63457: PUSH
63458: LD_INT 3
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: LD_INT 2
63467: PUSH
63468: LD_INT 3
63470: PUSH
63471: EMPTY
63472: LIST
63473: LIST
63474: PUSH
63475: LD_INT 2
63477: NEG
63478: PUSH
63479: LD_INT 1
63481: PUSH
63482: EMPTY
63483: LIST
63484: LIST
63485: PUSH
63486: LD_INT 3
63488: NEG
63489: PUSH
63490: LD_INT 0
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PUSH
63497: LD_INT 3
63499: NEG
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: EMPTY
63506: LIST
63507: LIST
63508: PUSH
63509: LD_INT 3
63511: NEG
63512: PUSH
63513: LD_INT 2
63515: NEG
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 3
63523: NEG
63524: PUSH
63525: LD_INT 3
63527: NEG
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63564: LD_ADDR_VAR 0 45
63568: PUSH
63569: LD_INT 0
63571: PUSH
63572: LD_INT 0
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 0
63581: PUSH
63582: LD_INT 1
63584: NEG
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: PUSH
63590: LD_INT 1
63592: PUSH
63593: LD_INT 0
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PUSH
63600: LD_INT 1
63602: PUSH
63603: LD_INT 1
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 0
63612: PUSH
63613: LD_INT 1
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 1
63622: NEG
63623: PUSH
63624: LD_INT 0
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PUSH
63631: LD_INT 1
63633: NEG
63634: PUSH
63635: LD_INT 1
63637: NEG
63638: PUSH
63639: EMPTY
63640: LIST
63641: LIST
63642: PUSH
63643: LD_INT 1
63645: NEG
63646: PUSH
63647: LD_INT 2
63649: NEG
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 0
63657: PUSH
63658: LD_INT 2
63660: NEG
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: LD_INT 1
63668: PUSH
63669: LD_INT 1
63671: NEG
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PUSH
63677: LD_INT 2
63679: PUSH
63680: LD_INT 1
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 2
63689: PUSH
63690: LD_INT 2
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: LD_INT 2
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PUSH
63707: LD_INT 0
63709: PUSH
63710: LD_INT 2
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PUSH
63717: LD_INT 1
63719: NEG
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 2
63730: NEG
63731: PUSH
63732: LD_INT 1
63734: NEG
63735: PUSH
63736: EMPTY
63737: LIST
63738: LIST
63739: PUSH
63740: LD_INT 2
63742: NEG
63743: PUSH
63744: LD_INT 2
63746: NEG
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PUSH
63752: LD_INT 2
63754: NEG
63755: PUSH
63756: LD_INT 3
63758: NEG
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PUSH
63764: LD_INT 1
63766: NEG
63767: PUSH
63768: LD_INT 3
63770: NEG
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: PUSH
63776: LD_INT 0
63778: PUSH
63779: LD_INT 3
63781: NEG
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 1
63789: PUSH
63790: LD_INT 2
63792: NEG
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PUSH
63798: LD_INT 3
63800: PUSH
63801: LD_INT 2
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 3
63810: PUSH
63811: LD_INT 3
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 2
63820: PUSH
63821: LD_INT 3
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: PUSH
63831: LD_INT 3
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: PUSH
63838: LD_INT 0
63840: PUSH
63841: LD_INT 3
63843: PUSH
63844: EMPTY
63845: LIST
63846: LIST
63847: PUSH
63848: LD_INT 1
63850: NEG
63851: PUSH
63852: LD_INT 2
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: LD_INT 3
63861: NEG
63862: PUSH
63863: LD_INT 2
63865: NEG
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 3
63873: NEG
63874: PUSH
63875: LD_INT 3
63877: NEG
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63914: LD_ADDR_VAR 0 46
63918: PUSH
63919: LD_INT 0
63921: PUSH
63922: LD_INT 0
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 0
63931: PUSH
63932: LD_INT 1
63934: NEG
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: LD_INT 1
63942: PUSH
63943: LD_INT 0
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 1
63952: PUSH
63953: LD_INT 1
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 0
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: LD_INT 0
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: LD_INT 1
63983: NEG
63984: PUSH
63985: LD_INT 1
63987: NEG
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 1
63995: NEG
63996: PUSH
63997: LD_INT 2
63999: NEG
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: LD_INT 2
64010: NEG
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 1
64018: PUSH
64019: LD_INT 1
64021: NEG
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 2
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 2
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: LD_INT 1
64049: PUSH
64050: LD_INT 2
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: LD_INT 0
64059: PUSH
64060: LD_INT 2
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: PUSH
64067: LD_INT 1
64069: NEG
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PUSH
64078: LD_INT 2
64080: NEG
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 2
64091: NEG
64092: PUSH
64093: LD_INT 1
64095: NEG
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: NEG
64104: PUSH
64105: LD_INT 3
64107: NEG
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: LD_INT 3
64118: NEG
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 1
64126: PUSH
64127: LD_INT 2
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 2
64137: PUSH
64138: LD_INT 1
64140: NEG
64141: PUSH
64142: EMPTY
64143: LIST
64144: LIST
64145: PUSH
64146: LD_INT 3
64148: PUSH
64149: LD_INT 0
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: PUSH
64156: LD_INT 3
64158: PUSH
64159: LD_INT 1
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: LD_INT 3
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: PUSH
64176: LD_INT 0
64178: PUSH
64179: LD_INT 3
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 1
64188: NEG
64189: PUSH
64190: LD_INT 2
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: PUSH
64197: LD_INT 2
64199: NEG
64200: PUSH
64201: LD_INT 1
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 3
64210: NEG
64211: PUSH
64212: LD_INT 0
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: PUSH
64219: LD_INT 3
64221: NEG
64222: PUSH
64223: LD_INT 1
64225: NEG
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: LIST
64261: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64262: LD_ADDR_VAR 0 47
64266: PUSH
64267: LD_INT 0
64269: PUSH
64270: LD_INT 0
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 0
64279: PUSH
64280: LD_INT 1
64282: NEG
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 1
64290: PUSH
64291: LD_INT 0
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 1
64300: PUSH
64301: LD_INT 1
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PUSH
64308: LD_INT 0
64310: PUSH
64311: LD_INT 1
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PUSH
64318: LD_INT 1
64320: NEG
64321: PUSH
64322: LD_INT 0
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: LD_INT 1
64331: NEG
64332: PUSH
64333: LD_INT 1
64335: NEG
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 1
64343: NEG
64344: PUSH
64345: LD_INT 2
64347: NEG
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: LD_INT 0
64355: PUSH
64356: LD_INT 2
64358: NEG
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: PUSH
64364: LD_INT 1
64366: PUSH
64367: LD_INT 1
64369: NEG
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 2
64377: NEG
64378: PUSH
64379: LD_INT 1
64381: NEG
64382: PUSH
64383: EMPTY
64384: LIST
64385: LIST
64386: PUSH
64387: LD_INT 2
64389: NEG
64390: PUSH
64391: LD_INT 2
64393: NEG
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
64413: LD_ADDR_VAR 0 48
64417: PUSH
64418: LD_INT 0
64420: PUSH
64421: LD_INT 0
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: PUSH
64428: LD_INT 0
64430: PUSH
64431: LD_INT 1
64433: NEG
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 1
64441: PUSH
64442: LD_INT 0
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: PUSH
64449: LD_INT 1
64451: PUSH
64452: LD_INT 1
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: PUSH
64459: LD_INT 0
64461: PUSH
64462: LD_INT 1
64464: PUSH
64465: EMPTY
64466: LIST
64467: LIST
64468: PUSH
64469: LD_INT 1
64471: NEG
64472: PUSH
64473: LD_INT 0
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: LD_INT 1
64482: NEG
64483: PUSH
64484: LD_INT 1
64486: NEG
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: PUSH
64492: LD_INT 1
64494: NEG
64495: PUSH
64496: LD_INT 2
64498: NEG
64499: PUSH
64500: EMPTY
64501: LIST
64502: LIST
64503: PUSH
64504: LD_INT 0
64506: PUSH
64507: LD_INT 2
64509: NEG
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: LD_INT 1
64520: NEG
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: PUSH
64526: LD_INT 2
64528: PUSH
64529: LD_INT 0
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PUSH
64536: LD_INT 2
64538: PUSH
64539: LD_INT 1
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: LIST
64553: LIST
64554: LIST
64555: LIST
64556: LIST
64557: LIST
64558: LIST
64559: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
64560: LD_ADDR_VAR 0 49
64564: PUSH
64565: LD_INT 0
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: EMPTY
64572: LIST
64573: LIST
64574: PUSH
64575: LD_INT 0
64577: PUSH
64578: LD_INT 1
64580: NEG
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 1
64588: PUSH
64589: LD_INT 0
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 1
64598: PUSH
64599: LD_INT 1
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: PUSH
64606: LD_INT 0
64608: PUSH
64609: LD_INT 1
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 1
64618: NEG
64619: PUSH
64620: LD_INT 0
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: NEG
64630: PUSH
64631: LD_INT 1
64633: NEG
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: PUSH
64642: LD_INT 1
64644: NEG
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 2
64652: PUSH
64653: LD_INT 0
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: LD_INT 2
64662: PUSH
64663: LD_INT 1
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 2
64672: PUSH
64673: LD_INT 2
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 1
64682: PUSH
64683: LD_INT 2
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
64704: LD_ADDR_VAR 0 50
64708: PUSH
64709: LD_INT 0
64711: PUSH
64712: LD_INT 0
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: LD_INT 0
64721: PUSH
64722: LD_INT 1
64724: NEG
64725: PUSH
64726: EMPTY
64727: LIST
64728: LIST
64729: PUSH
64730: LD_INT 1
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 1
64742: PUSH
64743: LD_INT 1
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 0
64752: PUSH
64753: LD_INT 1
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PUSH
64760: LD_INT 1
64762: NEG
64763: PUSH
64764: LD_INT 0
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: PUSH
64771: LD_INT 1
64773: NEG
64774: PUSH
64775: LD_INT 1
64777: NEG
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: PUSH
64783: LD_INT 2
64785: PUSH
64786: LD_INT 1
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 2
64795: PUSH
64796: LD_INT 2
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 1
64805: PUSH
64806: LD_INT 2
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: LD_INT 2
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 1
64825: NEG
64826: PUSH
64827: LD_INT 1
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: LIST
64838: LIST
64839: LIST
64840: LIST
64841: LIST
64842: LIST
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
64848: LD_ADDR_VAR 0 51
64852: PUSH
64853: LD_INT 0
64855: PUSH
64856: LD_INT 0
64858: PUSH
64859: EMPTY
64860: LIST
64861: LIST
64862: PUSH
64863: LD_INT 0
64865: PUSH
64866: LD_INT 1
64868: NEG
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 1
64876: PUSH
64877: LD_INT 0
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: PUSH
64884: LD_INT 1
64886: PUSH
64887: LD_INT 1
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: PUSH
64894: LD_INT 0
64896: PUSH
64897: LD_INT 1
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: PUSH
64904: LD_INT 1
64906: NEG
64907: PUSH
64908: LD_INT 0
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 1
64917: NEG
64918: PUSH
64919: LD_INT 1
64921: NEG
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 1
64929: PUSH
64930: LD_INT 2
64932: PUSH
64933: EMPTY
64934: LIST
64935: LIST
64936: PUSH
64937: LD_INT 0
64939: PUSH
64940: LD_INT 2
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: NEG
64950: PUSH
64951: LD_INT 1
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: PUSH
64958: LD_INT 2
64960: NEG
64961: PUSH
64962: LD_INT 0
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PUSH
64969: LD_INT 2
64971: NEG
64972: PUSH
64973: LD_INT 1
64975: NEG
64976: PUSH
64977: EMPTY
64978: LIST
64979: LIST
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64995: LD_ADDR_VAR 0 52
64999: PUSH
65000: LD_INT 0
65002: PUSH
65003: LD_INT 0
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: LD_INT 0
65012: PUSH
65013: LD_INT 1
65015: NEG
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 1
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 1
65033: PUSH
65034: LD_INT 1
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: LD_INT 1
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: LD_INT 1
65053: NEG
65054: PUSH
65055: LD_INT 0
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 1
65064: NEG
65065: PUSH
65066: LD_INT 1
65068: NEG
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 1
65076: NEG
65077: PUSH
65078: LD_INT 2
65080: NEG
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 1
65088: NEG
65089: PUSH
65090: LD_INT 1
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 2
65099: NEG
65100: PUSH
65101: LD_INT 0
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 2
65110: NEG
65111: PUSH
65112: LD_INT 1
65114: NEG
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PUSH
65120: LD_INT 2
65122: NEG
65123: PUSH
65124: LD_INT 2
65126: NEG
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65146: LD_ADDR_VAR 0 53
65150: PUSH
65151: LD_INT 0
65153: PUSH
65154: LD_INT 0
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: PUSH
65161: LD_INT 0
65163: PUSH
65164: LD_INT 1
65166: NEG
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: LD_INT 1
65174: PUSH
65175: LD_INT 0
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: PUSH
65182: LD_INT 1
65184: PUSH
65185: LD_INT 1
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 0
65194: PUSH
65195: LD_INT 1
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 1
65204: NEG
65205: PUSH
65206: LD_INT 0
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 1
65215: NEG
65216: PUSH
65217: LD_INT 1
65219: NEG
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PUSH
65225: LD_INT 1
65227: NEG
65228: PUSH
65229: LD_INT 2
65231: NEG
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: LD_INT 0
65239: PUSH
65240: LD_INT 2
65242: NEG
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 1
65250: PUSH
65251: LD_INT 1
65253: NEG
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PUSH
65259: LD_INT 2
65261: PUSH
65262: LD_INT 0
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 2
65271: PUSH
65272: LD_INT 1
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 2
65281: PUSH
65282: LD_INT 2
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 1
65291: PUSH
65292: LD_INT 2
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 0
65301: PUSH
65302: LD_INT 2
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: LD_INT 1
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: LD_INT 2
65322: NEG
65323: PUSH
65324: LD_INT 0
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 2
65333: NEG
65334: PUSH
65335: LD_INT 1
65337: NEG
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PUSH
65343: LD_INT 2
65345: NEG
65346: PUSH
65347: LD_INT 2
65349: NEG
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: EMPTY
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65376: LD_ADDR_VAR 0 54
65380: PUSH
65381: LD_INT 0
65383: PUSH
65384: LD_INT 0
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 0
65393: PUSH
65394: LD_INT 1
65396: NEG
65397: PUSH
65398: EMPTY
65399: LIST
65400: LIST
65401: PUSH
65402: LD_INT 1
65404: PUSH
65405: LD_INT 0
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: PUSH
65412: LD_INT 1
65414: PUSH
65415: LD_INT 1
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 0
65424: PUSH
65425: LD_INT 1
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 1
65434: NEG
65435: PUSH
65436: LD_INT 0
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: NEG
65446: PUSH
65447: LD_INT 1
65449: NEG
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: LD_INT 2
65461: NEG
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 0
65469: PUSH
65470: LD_INT 2
65472: NEG
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: LD_INT 1
65480: PUSH
65481: LD_INT 1
65483: NEG
65484: PUSH
65485: EMPTY
65486: LIST
65487: LIST
65488: PUSH
65489: LD_INT 2
65491: PUSH
65492: LD_INT 0
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 2
65501: PUSH
65502: LD_INT 1
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 2
65511: PUSH
65512: LD_INT 2
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 1
65521: PUSH
65522: LD_INT 2
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 0
65531: PUSH
65532: LD_INT 2
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: NEG
65542: PUSH
65543: LD_INT 1
65545: PUSH
65546: EMPTY
65547: LIST
65548: LIST
65549: PUSH
65550: LD_INT 2
65552: NEG
65553: PUSH
65554: LD_INT 0
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 2
65563: NEG
65564: PUSH
65565: LD_INT 1
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 2
65575: NEG
65576: PUSH
65577: LD_INT 2
65579: NEG
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65606: LD_ADDR_VAR 0 55
65610: PUSH
65611: LD_INT 0
65613: PUSH
65614: LD_INT 0
65616: PUSH
65617: EMPTY
65618: LIST
65619: LIST
65620: PUSH
65621: LD_INT 0
65623: PUSH
65624: LD_INT 1
65626: NEG
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 1
65634: PUSH
65635: LD_INT 0
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 1
65644: PUSH
65645: LD_INT 1
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 0
65654: PUSH
65655: LD_INT 1
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: LD_INT 0
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: LD_INT 1
65679: NEG
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 1
65687: NEG
65688: PUSH
65689: LD_INT 2
65691: NEG
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: PUSH
65697: LD_INT 0
65699: PUSH
65700: LD_INT 2
65702: NEG
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 1
65710: PUSH
65711: LD_INT 1
65713: NEG
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 2
65721: PUSH
65722: LD_INT 0
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 2
65731: PUSH
65732: LD_INT 1
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 2
65741: PUSH
65742: LD_INT 2
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 1
65751: PUSH
65752: LD_INT 2
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 0
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: LD_INT 1
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 2
65782: NEG
65783: PUSH
65784: LD_INT 0
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 2
65793: NEG
65794: PUSH
65795: LD_INT 1
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 2
65805: NEG
65806: PUSH
65807: LD_INT 2
65809: NEG
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65836: LD_ADDR_VAR 0 56
65840: PUSH
65841: LD_INT 0
65843: PUSH
65844: LD_INT 0
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 0
65853: PUSH
65854: LD_INT 1
65856: NEG
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 1
65864: PUSH
65865: LD_INT 0
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 1
65874: PUSH
65875: LD_INT 1
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: LD_INT 0
65884: PUSH
65885: LD_INT 1
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 1
65894: NEG
65895: PUSH
65896: LD_INT 0
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 1
65905: NEG
65906: PUSH
65907: LD_INT 1
65909: NEG
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 1
65917: NEG
65918: PUSH
65919: LD_INT 2
65921: NEG
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: LD_INT 0
65929: PUSH
65930: LD_INT 2
65932: NEG
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 1
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: LD_INT 2
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 2
65961: PUSH
65962: LD_INT 1
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 2
65971: PUSH
65972: LD_INT 2
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 1
65981: PUSH
65982: LD_INT 2
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: PUSH
65989: LD_INT 0
65991: PUSH
65992: LD_INT 2
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 1
66001: NEG
66002: PUSH
66003: LD_INT 1
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 2
66012: NEG
66013: PUSH
66014: LD_INT 0
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 2
66023: NEG
66024: PUSH
66025: LD_INT 1
66027: NEG
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 2
66035: NEG
66036: PUSH
66037: LD_INT 2
66039: NEG
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66066: LD_ADDR_VAR 0 57
66070: PUSH
66071: LD_INT 0
66073: PUSH
66074: LD_INT 0
66076: PUSH
66077: EMPTY
66078: LIST
66079: LIST
66080: PUSH
66081: LD_INT 0
66083: PUSH
66084: LD_INT 1
66086: NEG
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 1
66094: PUSH
66095: LD_INT 0
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: LD_INT 1
66104: PUSH
66105: LD_INT 1
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 0
66114: PUSH
66115: LD_INT 1
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 1
66124: NEG
66125: PUSH
66126: LD_INT 0
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: LD_INT 1
66139: NEG
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 1
66147: NEG
66148: PUSH
66149: LD_INT 2
66151: NEG
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 0
66159: PUSH
66160: LD_INT 2
66162: NEG
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 1
66170: PUSH
66171: LD_INT 1
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 2
66181: PUSH
66182: LD_INT 0
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 2
66191: PUSH
66192: LD_INT 1
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 2
66201: PUSH
66202: LD_INT 2
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 1
66211: PUSH
66212: LD_INT 2
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: LD_INT 2
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 1
66231: NEG
66232: PUSH
66233: LD_INT 1
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 2
66242: NEG
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 2
66253: NEG
66254: PUSH
66255: LD_INT 1
66257: NEG
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: LD_INT 2
66265: NEG
66266: PUSH
66267: LD_INT 2
66269: NEG
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: LIST
66285: LIST
66286: LIST
66287: LIST
66288: LIST
66289: LIST
66290: LIST
66291: LIST
66292: LIST
66293: LIST
66294: LIST
66295: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66296: LD_ADDR_VAR 0 58
66300: PUSH
66301: LD_INT 0
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: PUSH
66311: LD_INT 0
66313: PUSH
66314: LD_INT 1
66316: NEG
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PUSH
66322: LD_INT 1
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 1
66334: PUSH
66335: LD_INT 1
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: LD_INT 0
66344: PUSH
66345: LD_INT 1
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 1
66354: NEG
66355: PUSH
66356: LD_INT 0
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 1
66365: NEG
66366: PUSH
66367: LD_INT 1
66369: NEG
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 1
66377: NEG
66378: PUSH
66379: LD_INT 2
66381: NEG
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 0
66389: PUSH
66390: LD_INT 2
66392: NEG
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 1
66400: PUSH
66401: LD_INT 1
66403: NEG
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 2
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 2
66421: PUSH
66422: LD_INT 1
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: LD_INT 2
66431: PUSH
66432: LD_INT 2
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 1
66441: PUSH
66442: LD_INT 2
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: LD_INT 2
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 1
66461: NEG
66462: PUSH
66463: LD_INT 1
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 2
66472: NEG
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 2
66483: NEG
66484: PUSH
66485: LD_INT 1
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 2
66495: NEG
66496: PUSH
66497: LD_INT 2
66499: NEG
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66526: LD_ADDR_VAR 0 59
66530: PUSH
66531: LD_INT 0
66533: PUSH
66534: LD_INT 0
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 0
66543: PUSH
66544: LD_INT 1
66546: NEG
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 1
66554: PUSH
66555: LD_INT 0
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: PUSH
66562: LD_INT 1
66564: PUSH
66565: LD_INT 1
66567: PUSH
66568: EMPTY
66569: LIST
66570: LIST
66571: PUSH
66572: LD_INT 0
66574: PUSH
66575: LD_INT 1
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 1
66584: NEG
66585: PUSH
66586: LD_INT 0
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 1
66599: NEG
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66614: LD_ADDR_VAR 0 60
66618: PUSH
66619: LD_INT 0
66621: PUSH
66622: LD_INT 0
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: PUSH
66629: LD_INT 0
66631: PUSH
66632: LD_INT 1
66634: NEG
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: LD_INT 1
66642: PUSH
66643: LD_INT 0
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: PUSH
66653: LD_INT 1
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 0
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 1
66672: NEG
66673: PUSH
66674: LD_INT 0
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66702: LD_ADDR_VAR 0 61
66706: PUSH
66707: LD_INT 0
66709: PUSH
66710: LD_INT 0
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 0
66719: PUSH
66720: LD_INT 1
66722: NEG
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: LD_INT 0
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: LD_INT 1
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: LD_INT 1
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: NEG
66761: PUSH
66762: LD_INT 0
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 1
66771: NEG
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66790: LD_ADDR_VAR 0 62
66794: PUSH
66795: LD_INT 0
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 0
66807: PUSH
66808: LD_INT 1
66810: NEG
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: LD_INT 0
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 0
66838: PUSH
66839: LD_INT 1
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 0
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 1
66859: NEG
66860: PUSH
66861: LD_INT 1
66863: NEG
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66878: LD_ADDR_VAR 0 63
66882: PUSH
66883: LD_INT 0
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 0
66895: PUSH
66896: LD_INT 1
66898: NEG
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: LD_INT 1
66906: PUSH
66907: LD_INT 0
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PUSH
66914: LD_INT 1
66916: PUSH
66917: LD_INT 1
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 0
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 1
66936: NEG
66937: PUSH
66938: LD_INT 0
66940: PUSH
66941: EMPTY
66942: LIST
66943: LIST
66944: PUSH
66945: LD_INT 1
66947: NEG
66948: PUSH
66949: LD_INT 1
66951: NEG
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: LIST
66965: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66966: LD_ADDR_VAR 0 64
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: LD_INT 0
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 0
66983: PUSH
66984: LD_INT 1
66986: NEG
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 1
67004: PUSH
67005: LD_INT 1
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: LD_INT 0
67014: PUSH
67015: LD_INT 1
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 1
67024: NEG
67025: PUSH
67026: LD_INT 0
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: ST_TO_ADDR
// end ; 1 :
67054: GO 72951
67056: LD_INT 1
67058: DOUBLE
67059: EQUAL
67060: IFTRUE 67064
67062: GO 69687
67064: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67065: LD_ADDR_VAR 0 11
67069: PUSH
67070: LD_INT 1
67072: NEG
67073: PUSH
67074: LD_INT 3
67076: NEG
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 0
67084: PUSH
67085: LD_INT 3
67087: NEG
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 1
67095: PUSH
67096: LD_INT 2
67098: NEG
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: EMPTY
67105: LIST
67106: LIST
67107: LIST
67108: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67109: LD_ADDR_VAR 0 12
67113: PUSH
67114: LD_INT 2
67116: PUSH
67117: LD_INT 1
67119: NEG
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 3
67127: PUSH
67128: LD_INT 0
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 3
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: LIST
67149: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67150: LD_ADDR_VAR 0 13
67154: PUSH
67155: LD_INT 3
67157: PUSH
67158: LD_INT 2
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 3
67167: PUSH
67168: LD_INT 3
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: LD_INT 3
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: LIST
67189: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67190: LD_ADDR_VAR 0 14
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: LD_INT 3
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 3
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 1
67217: NEG
67218: PUSH
67219: LD_INT 2
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: LIST
67230: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67231: LD_ADDR_VAR 0 15
67235: PUSH
67236: LD_INT 2
67238: NEG
67239: PUSH
67240: LD_INT 1
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 3
67249: NEG
67250: PUSH
67251: LD_INT 0
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 3
67260: NEG
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: LIST
67274: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67275: LD_ADDR_VAR 0 16
67279: PUSH
67280: LD_INT 2
67282: NEG
67283: PUSH
67284: LD_INT 3
67286: NEG
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 3
67294: NEG
67295: PUSH
67296: LD_INT 2
67298: NEG
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 3
67306: NEG
67307: PUSH
67308: LD_INT 3
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: LIST
67320: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67321: LD_ADDR_VAR 0 17
67325: PUSH
67326: LD_INT 1
67328: NEG
67329: PUSH
67330: LD_INT 3
67332: NEG
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: LD_INT 3
67343: NEG
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: LIST
67364: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67365: LD_ADDR_VAR 0 18
67369: PUSH
67370: LD_INT 2
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 3
67383: PUSH
67384: LD_INT 0
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 3
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: LIST
67405: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67406: LD_ADDR_VAR 0 19
67410: PUSH
67411: LD_INT 3
67413: PUSH
67414: LD_INT 2
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 3
67423: PUSH
67424: LD_INT 3
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 2
67433: PUSH
67434: LD_INT 3
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: LIST
67445: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67446: LD_ADDR_VAR 0 20
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: LD_INT 3
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 0
67463: PUSH
67464: LD_INT 3
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 1
67473: NEG
67474: PUSH
67475: LD_INT 2
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: LIST
67486: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67487: LD_ADDR_VAR 0 21
67491: PUSH
67492: LD_INT 2
67494: NEG
67495: PUSH
67496: LD_INT 1
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 3
67505: NEG
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 3
67516: NEG
67517: PUSH
67518: LD_INT 1
67520: NEG
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: LIST
67530: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67531: LD_ADDR_VAR 0 22
67535: PUSH
67536: LD_INT 2
67538: NEG
67539: PUSH
67540: LD_INT 3
67542: NEG
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 3
67550: NEG
67551: PUSH
67552: LD_INT 2
67554: NEG
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 3
67562: NEG
67563: PUSH
67564: LD_INT 3
67566: NEG
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: LIST
67576: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
67577: LD_ADDR_VAR 0 23
67581: PUSH
67582: LD_INT 0
67584: PUSH
67585: LD_INT 3
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 1
67595: NEG
67596: PUSH
67597: LD_INT 4
67599: NEG
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: PUSH
67608: LD_INT 3
67610: NEG
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: LIST
67620: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
67621: LD_ADDR_VAR 0 24
67625: PUSH
67626: LD_INT 3
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 3
67638: PUSH
67639: LD_INT 1
67641: NEG
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 4
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: LIST
67661: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
67662: LD_ADDR_VAR 0 25
67666: PUSH
67667: LD_INT 3
67669: PUSH
67670: LD_INT 3
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 4
67679: PUSH
67680: LD_INT 3
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 3
67689: PUSH
67690: LD_INT 4
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
67702: LD_ADDR_VAR 0 26
67706: PUSH
67707: LD_INT 0
67709: PUSH
67710: LD_INT 3
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: LD_INT 4
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: LD_INT 3
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: LIST
67742: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
67743: LD_ADDR_VAR 0 27
67747: PUSH
67748: LD_INT 3
67750: NEG
67751: PUSH
67752: LD_INT 0
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 3
67761: NEG
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 4
67772: NEG
67773: PUSH
67774: LD_INT 1
67776: NEG
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: LIST
67786: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
67787: LD_ADDR_VAR 0 28
67791: PUSH
67792: LD_INT 3
67794: NEG
67795: PUSH
67796: LD_INT 3
67798: NEG
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 3
67806: NEG
67807: PUSH
67808: LD_INT 4
67810: NEG
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: LD_INT 4
67818: NEG
67819: PUSH
67820: LD_INT 3
67822: NEG
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: LIST
67832: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
67833: LD_ADDR_VAR 0 29
67837: PUSH
67838: LD_INT 1
67840: NEG
67841: PUSH
67842: LD_INT 3
67844: NEG
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 0
67852: PUSH
67853: LD_INT 3
67855: NEG
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 1
67863: PUSH
67864: LD_INT 2
67866: NEG
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 1
67874: NEG
67875: PUSH
67876: LD_INT 4
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 0
67886: PUSH
67887: LD_INT 4
67889: NEG
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: LD_INT 3
67900: NEG
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: NEG
67909: PUSH
67910: LD_INT 5
67912: NEG
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: LD_INT 5
67923: NEG
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: LD_INT 4
67934: NEG
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 1
67942: NEG
67943: PUSH
67944: LD_INT 6
67946: NEG
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 0
67954: PUSH
67955: LD_INT 6
67957: NEG
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 1
67965: PUSH
67966: LD_INT 5
67968: NEG
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
67988: LD_ADDR_VAR 0 30
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: LD_INT 1
67998: NEG
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 3
68006: PUSH
68007: LD_INT 0
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 3
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 3
68026: PUSH
68027: LD_INT 1
68029: NEG
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 4
68037: PUSH
68038: LD_INT 0
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 4
68047: PUSH
68048: LD_INT 1
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 4
68057: PUSH
68058: LD_INT 1
68060: NEG
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: LD_INT 5
68068: PUSH
68069: LD_INT 0
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PUSH
68076: LD_INT 5
68078: PUSH
68079: LD_INT 1
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PUSH
68086: LD_INT 5
68088: PUSH
68089: LD_INT 1
68091: NEG
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 6
68099: PUSH
68100: LD_INT 0
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 6
68109: PUSH
68110: LD_INT 1
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
68131: LD_ADDR_VAR 0 31
68135: PUSH
68136: LD_INT 3
68138: PUSH
68139: LD_INT 2
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 3
68148: PUSH
68149: LD_INT 3
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 2
68158: PUSH
68159: LD_INT 3
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 4
68168: PUSH
68169: LD_INT 3
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 4
68178: PUSH
68179: LD_INT 4
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 3
68188: PUSH
68189: LD_INT 4
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 5
68198: PUSH
68199: LD_INT 4
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 5
68208: PUSH
68209: LD_INT 5
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 4
68218: PUSH
68219: LD_INT 5
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 6
68228: PUSH
68229: LD_INT 5
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: LD_INT 6
68238: PUSH
68239: LD_INT 6
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 5
68248: PUSH
68249: LD_INT 6
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
68270: LD_ADDR_VAR 0 32
68274: PUSH
68275: LD_INT 1
68277: PUSH
68278: LD_INT 3
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 0
68287: PUSH
68288: LD_INT 3
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: NEG
68298: PUSH
68299: LD_INT 2
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 1
68308: PUSH
68309: LD_INT 4
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 0
68318: PUSH
68319: LD_INT 4
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: NEG
68329: PUSH
68330: LD_INT 3
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: LD_INT 5
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 0
68349: PUSH
68350: LD_INT 5
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: LD_INT 4
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 1
68370: PUSH
68371: LD_INT 6
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 0
68380: PUSH
68381: LD_INT 6
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: LD_INT 5
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
68413: LD_ADDR_VAR 0 33
68417: PUSH
68418: LD_INT 2
68420: NEG
68421: PUSH
68422: LD_INT 1
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 3
68431: NEG
68432: PUSH
68433: LD_INT 0
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 3
68442: NEG
68443: PUSH
68444: LD_INT 1
68446: NEG
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 3
68454: NEG
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 4
68465: NEG
68466: PUSH
68467: LD_INT 0
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 4
68476: NEG
68477: PUSH
68478: LD_INT 1
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 4
68488: NEG
68489: PUSH
68490: LD_INT 1
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 5
68499: NEG
68500: PUSH
68501: LD_INT 0
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 5
68510: NEG
68511: PUSH
68512: LD_INT 1
68514: NEG
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 5
68522: NEG
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 6
68533: NEG
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 6
68544: NEG
68545: PUSH
68546: LD_INT 1
68548: NEG
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: LIST
68558: LIST
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
68568: LD_ADDR_VAR 0 34
68572: PUSH
68573: LD_INT 2
68575: NEG
68576: PUSH
68577: LD_INT 3
68579: NEG
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 3
68587: NEG
68588: PUSH
68589: LD_INT 2
68591: NEG
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 3
68599: NEG
68600: PUSH
68601: LD_INT 3
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 3
68611: NEG
68612: PUSH
68613: LD_INT 4
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 4
68623: NEG
68624: PUSH
68625: LD_INT 3
68627: NEG
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 4
68635: NEG
68636: PUSH
68637: LD_INT 4
68639: NEG
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 4
68647: NEG
68648: PUSH
68649: LD_INT 5
68651: NEG
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 5
68659: NEG
68660: PUSH
68661: LD_INT 4
68663: NEG
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 5
68671: NEG
68672: PUSH
68673: LD_INT 5
68675: NEG
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 5
68683: NEG
68684: PUSH
68685: LD_INT 6
68687: NEG
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 6
68695: NEG
68696: PUSH
68697: LD_INT 5
68699: NEG
68700: PUSH
68701: EMPTY
68702: LIST
68703: LIST
68704: PUSH
68705: LD_INT 6
68707: NEG
68708: PUSH
68709: LD_INT 6
68711: NEG
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
68731: LD_ADDR_VAR 0 41
68735: PUSH
68736: LD_INT 0
68738: PUSH
68739: LD_INT 2
68741: NEG
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 1
68749: NEG
68750: PUSH
68751: LD_INT 3
68753: NEG
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 1
68761: PUSH
68762: LD_INT 2
68764: NEG
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: LIST
68774: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
68775: LD_ADDR_VAR 0 42
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 2
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 3
68803: PUSH
68804: LD_INT 1
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: LIST
68815: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
68816: LD_ADDR_VAR 0 43
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 3
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 2
68843: PUSH
68844: LD_INT 3
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: LIST
68855: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
68856: LD_ADDR_VAR 0 44
68860: PUSH
68861: LD_INT 0
68863: PUSH
68864: LD_INT 2
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 1
68873: PUSH
68874: LD_INT 3
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: NEG
68884: PUSH
68885: LD_INT 2
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: LIST
68896: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68897: LD_ADDR_VAR 0 45
68901: PUSH
68902: LD_INT 2
68904: NEG
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 2
68915: NEG
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 3
68926: NEG
68927: PUSH
68928: LD_INT 1
68930: NEG
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: LIST
68940: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
68941: LD_ADDR_VAR 0 46
68945: PUSH
68946: LD_INT 2
68948: NEG
68949: PUSH
68950: LD_INT 2
68952: NEG
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 2
68960: NEG
68961: PUSH
68962: LD_INT 3
68964: NEG
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: LD_INT 3
68972: NEG
68973: PUSH
68974: LD_INT 2
68976: NEG
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: LIST
68986: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
68987: LD_ADDR_VAR 0 47
68991: PUSH
68992: LD_INT 2
68994: NEG
68995: PUSH
68996: LD_INT 3
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: NEG
69007: PUSH
69008: LD_INT 3
69010: NEG
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69020: LD_ADDR_VAR 0 48
69024: PUSH
69025: LD_INT 1
69027: PUSH
69028: LD_INT 2
69030: NEG
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 1
69041: NEG
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
69051: LD_ADDR_VAR 0 49
69055: PUSH
69056: LD_INT 3
69058: PUSH
69059: LD_INT 1
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 3
69068: PUSH
69069: LD_INT 2
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
69080: LD_ADDR_VAR 0 50
69084: PUSH
69085: LD_INT 2
69087: PUSH
69088: LD_INT 3
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 3
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69109: LD_ADDR_VAR 0 51
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: LD_INT 2
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 2
69127: NEG
69128: PUSH
69129: LD_INT 1
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69140: LD_ADDR_VAR 0 52
69144: PUSH
69145: LD_INT 3
69147: NEG
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 3
69159: NEG
69160: PUSH
69161: LD_INT 2
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69173: LD_ADDR_VAR 0 53
69177: PUSH
69178: LD_INT 1
69180: NEG
69181: PUSH
69182: LD_INT 3
69184: NEG
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: PUSH
69190: LD_INT 0
69192: PUSH
69193: LD_INT 3
69195: NEG
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: LD_INT 2
69206: NEG
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: LIST
69216: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69217: LD_ADDR_VAR 0 54
69221: PUSH
69222: LD_INT 2
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 3
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 3
69245: PUSH
69246: LD_INT 1
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: LIST
69257: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69258: LD_ADDR_VAR 0 55
69262: PUSH
69263: LD_INT 3
69265: PUSH
69266: LD_INT 2
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 3
69275: PUSH
69276: LD_INT 3
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 2
69285: PUSH
69286: LD_INT 3
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: LIST
69297: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69298: LD_ADDR_VAR 0 56
69302: PUSH
69303: LD_INT 1
69305: PUSH
69306: LD_INT 3
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: LD_INT 3
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 1
69325: NEG
69326: PUSH
69327: LD_INT 2
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69339: LD_ADDR_VAR 0 57
69343: PUSH
69344: LD_INT 2
69346: NEG
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 3
69357: NEG
69358: PUSH
69359: LD_INT 0
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 3
69368: NEG
69369: PUSH
69370: LD_INT 1
69372: NEG
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: LIST
69382: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69383: LD_ADDR_VAR 0 58
69387: PUSH
69388: LD_INT 2
69390: NEG
69391: PUSH
69392: LD_INT 3
69394: NEG
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 3
69402: NEG
69403: PUSH
69404: LD_INT 2
69406: NEG
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: LD_INT 3
69414: NEG
69415: PUSH
69416: LD_INT 3
69418: NEG
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: LIST
69428: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
69429: LD_ADDR_VAR 0 59
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: LD_INT 2
69440: NEG
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: LD_INT 2
69451: NEG
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 1
69459: PUSH
69460: LD_INT 1
69462: NEG
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: LIST
69472: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69473: LD_ADDR_VAR 0 60
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 2
69491: PUSH
69492: LD_INT 0
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: PUSH
69499: LD_INT 2
69501: PUSH
69502: LD_INT 1
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: LIST
69513: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69514: LD_ADDR_VAR 0 61
69518: PUSH
69519: LD_INT 2
69521: PUSH
69522: LD_INT 1
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 2
69531: PUSH
69532: LD_INT 2
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 1
69541: PUSH
69542: LD_INT 2
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: LIST
69553: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
69554: LD_ADDR_VAR 0 62
69558: PUSH
69559: LD_INT 1
69561: PUSH
69562: LD_INT 2
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 0
69571: PUSH
69572: LD_INT 2
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: LIST
69594: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
69595: LD_ADDR_VAR 0 63
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: LD_INT 1
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PUSH
69611: LD_INT 2
69613: NEG
69614: PUSH
69615: LD_INT 0
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: LD_INT 2
69624: NEG
69625: PUSH
69626: LD_INT 1
69628: NEG
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: LIST
69638: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69639: LD_ADDR_VAR 0 64
69643: PUSH
69644: LD_INT 1
69646: NEG
69647: PUSH
69648: LD_INT 2
69650: NEG
69651: PUSH
69652: EMPTY
69653: LIST
69654: LIST
69655: PUSH
69656: LD_INT 2
69658: NEG
69659: PUSH
69660: LD_INT 1
69662: NEG
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 2
69670: NEG
69671: PUSH
69672: LD_INT 2
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: LIST
69684: ST_TO_ADDR
// end ; 2 :
69685: GO 72951
69687: LD_INT 2
69689: DOUBLE
69690: EQUAL
69691: IFTRUE 69695
69693: GO 72950
69695: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
69696: LD_ADDR_VAR 0 29
69700: PUSH
69701: LD_INT 4
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 4
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 5
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 5
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 4
69744: PUSH
69745: LD_INT 1
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 3
69754: PUSH
69755: LD_INT 0
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 3
69764: PUSH
69765: LD_INT 1
69767: NEG
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 3
69775: PUSH
69776: LD_INT 2
69778: NEG
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 5
69786: PUSH
69787: LD_INT 2
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 3
69796: PUSH
69797: LD_INT 3
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 3
69806: PUSH
69807: LD_INT 2
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 4
69816: PUSH
69817: LD_INT 3
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 4
69826: PUSH
69827: LD_INT 4
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: LD_INT 4
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 2
69846: PUSH
69847: LD_INT 3
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 2
69856: PUSH
69857: LD_INT 2
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 4
69866: PUSH
69867: LD_INT 2
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 2
69876: PUSH
69877: LD_INT 4
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: LD_INT 4
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: LD_INT 3
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: LD_INT 4
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: PUSH
69917: LD_INT 5
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: LD_INT 5
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 1
69936: NEG
69937: PUSH
69938: LD_INT 4
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 1
69947: NEG
69948: PUSH
69949: LD_INT 3
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: LD_INT 2
69958: PUSH
69959: LD_INT 5
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 2
69968: NEG
69969: PUSH
69970: LD_INT 3
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 3
69979: NEG
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: PUSH
69988: LD_INT 3
69990: NEG
69991: PUSH
69992: LD_INT 1
69994: NEG
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: NEG
70003: PUSH
70004: LD_INT 0
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 2
70013: NEG
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 3
70024: NEG
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 4
70035: NEG
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 4
70046: NEG
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 4
70058: NEG
70059: PUSH
70060: LD_INT 2
70062: NEG
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 2
70070: NEG
70071: PUSH
70072: LD_INT 2
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 4
70081: NEG
70082: PUSH
70083: LD_INT 4
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 4
70093: NEG
70094: PUSH
70095: LD_INT 5
70097: NEG
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 3
70105: NEG
70106: PUSH
70107: LD_INT 4
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 3
70117: NEG
70118: PUSH
70119: LD_INT 3
70121: NEG
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 4
70129: NEG
70130: PUSH
70131: LD_INT 3
70133: NEG
70134: PUSH
70135: EMPTY
70136: LIST
70137: LIST
70138: PUSH
70139: LD_INT 5
70141: NEG
70142: PUSH
70143: LD_INT 4
70145: NEG
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 5
70153: NEG
70154: PUSH
70155: LD_INT 5
70157: NEG
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 3
70165: NEG
70166: PUSH
70167: LD_INT 5
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 5
70177: NEG
70178: PUSH
70179: LD_INT 3
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
70234: LD_ADDR_VAR 0 30
70238: PUSH
70239: LD_INT 4
70241: PUSH
70242: LD_INT 4
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 4
70251: PUSH
70252: LD_INT 3
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 5
70261: PUSH
70262: LD_INT 4
70264: PUSH
70265: EMPTY
70266: LIST
70267: LIST
70268: PUSH
70269: LD_INT 5
70271: PUSH
70272: LD_INT 5
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 4
70281: PUSH
70282: LD_INT 5
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: LD_INT 3
70291: PUSH
70292: LD_INT 4
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 3
70301: PUSH
70302: LD_INT 3
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: PUSH
70309: LD_INT 5
70311: PUSH
70312: LD_INT 3
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 3
70321: PUSH
70322: LD_INT 5
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: LD_INT 3
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 0
70341: PUSH
70342: LD_INT 2
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 3
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 1
70361: PUSH
70362: LD_INT 4
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 0
70371: PUSH
70372: LD_INT 4
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 1
70381: NEG
70382: PUSH
70383: LD_INT 3
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: LD_INT 2
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 2
70403: PUSH
70404: LD_INT 4
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: PUSH
70411: LD_INT 2
70413: NEG
70414: PUSH
70415: LD_INT 2
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: LD_INT 4
70424: NEG
70425: PUSH
70426: LD_INT 0
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: PUSH
70433: LD_INT 4
70435: NEG
70436: PUSH
70437: LD_INT 1
70439: NEG
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 3
70447: NEG
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 3
70458: NEG
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 4
70469: NEG
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 5
70480: NEG
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 5
70491: NEG
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 5
70503: NEG
70504: PUSH
70505: LD_INT 2
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 3
70515: NEG
70516: PUSH
70517: LD_INT 2
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: NEG
70527: PUSH
70528: LD_INT 3
70530: NEG
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 3
70538: NEG
70539: PUSH
70540: LD_INT 4
70542: NEG
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 2
70550: NEG
70551: PUSH
70552: LD_INT 3
70554: NEG
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 2
70562: NEG
70563: PUSH
70564: LD_INT 2
70566: NEG
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: LD_INT 3
70574: NEG
70575: PUSH
70576: LD_INT 2
70578: NEG
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 4
70586: NEG
70587: PUSH
70588: LD_INT 3
70590: NEG
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 4
70598: NEG
70599: PUSH
70600: LD_INT 4
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: NEG
70611: PUSH
70612: LD_INT 4
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 4
70622: NEG
70623: PUSH
70624: LD_INT 2
70626: NEG
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: LD_INT 4
70637: NEG
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 0
70645: PUSH
70646: LD_INT 5
70648: NEG
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 1
70656: PUSH
70657: LD_INT 4
70659: NEG
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 1
70667: PUSH
70668: LD_INT 3
70670: NEG
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 0
70678: PUSH
70679: LD_INT 3
70681: NEG
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 1
70689: NEG
70690: PUSH
70691: LD_INT 4
70693: NEG
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: NEG
70702: PUSH
70703: LD_INT 5
70705: NEG
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 2
70713: PUSH
70714: LD_INT 3
70716: NEG
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 2
70724: NEG
70725: PUSH
70726: LD_INT 5
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
70781: LD_ADDR_VAR 0 31
70785: PUSH
70786: LD_INT 0
70788: PUSH
70789: LD_INT 4
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: LD_INT 3
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: PUSH
70809: LD_INT 4
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: PUSH
70819: LD_INT 5
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 0
70828: PUSH
70829: LD_INT 5
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: LD_INT 4
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: LD_INT 3
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 2
70860: PUSH
70861: LD_INT 5
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 2
70870: NEG
70871: PUSH
70872: LD_INT 3
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: PUSH
70879: LD_INT 3
70881: NEG
70882: PUSH
70883: LD_INT 0
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 3
70892: NEG
70893: PUSH
70894: LD_INT 1
70896: NEG
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 2
70904: NEG
70905: PUSH
70906: LD_INT 0
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 2
70915: NEG
70916: PUSH
70917: LD_INT 1
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 3
70926: NEG
70927: PUSH
70928: LD_INT 1
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 4
70937: NEG
70938: PUSH
70939: LD_INT 0
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 4
70948: NEG
70949: PUSH
70950: LD_INT 1
70952: NEG
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 4
70960: NEG
70961: PUSH
70962: LD_INT 2
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: NEG
70973: PUSH
70974: LD_INT 2
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 4
70983: NEG
70984: PUSH
70985: LD_INT 4
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 4
70995: NEG
70996: PUSH
70997: LD_INT 5
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: LD_INT 4
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 3
71019: NEG
71020: PUSH
71021: LD_INT 3
71023: NEG
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 4
71031: NEG
71032: PUSH
71033: LD_INT 3
71035: NEG
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 5
71043: NEG
71044: PUSH
71045: LD_INT 4
71047: NEG
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 5
71055: NEG
71056: PUSH
71057: LD_INT 5
71059: NEG
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: LD_INT 3
71067: NEG
71068: PUSH
71069: LD_INT 5
71071: NEG
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 5
71079: NEG
71080: PUSH
71081: LD_INT 3
71083: NEG
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 0
71091: PUSH
71092: LD_INT 3
71094: NEG
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 0
71102: PUSH
71103: LD_INT 4
71105: NEG
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: PUSH
71114: LD_INT 3
71116: NEG
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 1
71124: PUSH
71125: LD_INT 2
71127: NEG
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 0
71135: PUSH
71136: LD_INT 2
71138: NEG
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 1
71146: NEG
71147: PUSH
71148: LD_INT 3
71150: NEG
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: LD_INT 4
71162: NEG
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PUSH
71168: LD_INT 2
71170: PUSH
71171: LD_INT 2
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 2
71181: NEG
71182: PUSH
71183: LD_INT 4
71185: NEG
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 4
71193: PUSH
71194: LD_INT 0
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 4
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 5
71214: PUSH
71215: LD_INT 0
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 5
71224: PUSH
71225: LD_INT 1
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 4
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 3
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 3
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: LD_INT 3
71265: PUSH
71266: LD_INT 2
71268: NEG
71269: PUSH
71270: EMPTY
71271: LIST
71272: LIST
71273: PUSH
71274: LD_INT 5
71276: PUSH
71277: LD_INT 2
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
71331: LD_ADDR_VAR 0 32
71335: PUSH
71336: LD_INT 4
71338: NEG
71339: PUSH
71340: LD_INT 0
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 4
71349: NEG
71350: PUSH
71351: LD_INT 1
71353: NEG
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 3
71361: NEG
71362: PUSH
71363: LD_INT 0
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 3
71372: NEG
71373: PUSH
71374: LD_INT 1
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: PUSH
71381: LD_INT 4
71383: NEG
71384: PUSH
71385: LD_INT 1
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 5
71394: NEG
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: LD_INT 5
71405: NEG
71406: PUSH
71407: LD_INT 1
71409: NEG
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 5
71417: NEG
71418: PUSH
71419: LD_INT 2
71421: NEG
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 3
71429: NEG
71430: PUSH
71431: LD_INT 2
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 3
71440: NEG
71441: PUSH
71442: LD_INT 3
71444: NEG
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 3
71452: NEG
71453: PUSH
71454: LD_INT 4
71456: NEG
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: NEG
71465: PUSH
71466: LD_INT 3
71468: NEG
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 2
71476: NEG
71477: PUSH
71478: LD_INT 2
71480: NEG
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 3
71488: NEG
71489: PUSH
71490: LD_INT 2
71492: NEG
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 4
71500: NEG
71501: PUSH
71502: LD_INT 3
71504: NEG
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: LD_INT 4
71512: NEG
71513: PUSH
71514: LD_INT 4
71516: NEG
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: LD_INT 4
71528: NEG
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 4
71536: NEG
71537: PUSH
71538: LD_INT 2
71540: NEG
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 0
71548: PUSH
71549: LD_INT 4
71551: NEG
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 0
71559: PUSH
71560: LD_INT 5
71562: NEG
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 1
71570: PUSH
71571: LD_INT 4
71573: NEG
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 1
71581: PUSH
71582: LD_INT 3
71584: NEG
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 0
71592: PUSH
71593: LD_INT 3
71595: NEG
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 1
71603: NEG
71604: PUSH
71605: LD_INT 4
71607: NEG
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 1
71615: NEG
71616: PUSH
71617: LD_INT 5
71619: NEG
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 2
71627: PUSH
71628: LD_INT 3
71630: NEG
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 2
71638: NEG
71639: PUSH
71640: LD_INT 5
71642: NEG
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 3
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 3
71660: PUSH
71661: LD_INT 1
71663: NEG
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 4
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 4
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 3
71691: PUSH
71692: LD_INT 1
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 2
71701: PUSH
71702: LD_INT 0
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: LD_INT 2
71711: PUSH
71712: LD_INT 1
71714: NEG
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 2
71722: PUSH
71723: LD_INT 2
71725: NEG
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PUSH
71731: LD_INT 4
71733: PUSH
71734: LD_INT 2
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 4
71743: PUSH
71744: LD_INT 4
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 4
71753: PUSH
71754: LD_INT 3
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 5
71763: PUSH
71764: LD_INT 4
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 5
71773: PUSH
71774: LD_INT 5
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 4
71783: PUSH
71784: LD_INT 5
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 3
71793: PUSH
71794: LD_INT 4
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 3
71803: PUSH
71804: LD_INT 3
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: LD_INT 5
71813: PUSH
71814: LD_INT 3
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 3
71823: PUSH
71824: LD_INT 5
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: LIST
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: LIST
71846: LIST
71847: LIST
71848: LIST
71849: LIST
71850: LIST
71851: LIST
71852: LIST
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
71878: LD_ADDR_VAR 0 33
71882: PUSH
71883: LD_INT 4
71885: NEG
71886: PUSH
71887: LD_INT 4
71889: NEG
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: LD_INT 4
71897: NEG
71898: PUSH
71899: LD_INT 5
71901: NEG
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 3
71909: NEG
71910: PUSH
71911: LD_INT 4
71913: NEG
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 3
71921: NEG
71922: PUSH
71923: LD_INT 3
71925: NEG
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 4
71933: NEG
71934: PUSH
71935: LD_INT 3
71937: NEG
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 5
71945: NEG
71946: PUSH
71947: LD_INT 4
71949: NEG
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 5
71957: NEG
71958: PUSH
71959: LD_INT 5
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 3
71969: NEG
71970: PUSH
71971: LD_INT 5
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 5
71981: NEG
71982: PUSH
71983: LD_INT 3
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: LD_INT 3
71996: NEG
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: LD_INT 4
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: LD_INT 3
72018: NEG
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: LD_INT 2
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 0
72037: PUSH
72038: LD_INT 2
72040: NEG
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: LD_INT 3
72052: NEG
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: LD_INT 4
72064: NEG
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 2
72072: PUSH
72073: LD_INT 2
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 2
72083: NEG
72084: PUSH
72085: LD_INT 4
72087: NEG
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: LD_INT 4
72095: PUSH
72096: LD_INT 0
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 4
72105: PUSH
72106: LD_INT 1
72108: NEG
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 5
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 5
72126: PUSH
72127: LD_INT 1
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 4
72136: PUSH
72137: LD_INT 1
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: LD_INT 3
72146: PUSH
72147: LD_INT 0
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 3
72156: PUSH
72157: LD_INT 1
72159: NEG
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 3
72167: PUSH
72168: LD_INT 2
72170: NEG
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 5
72178: PUSH
72179: LD_INT 2
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 3
72188: PUSH
72189: LD_INT 3
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 3
72198: PUSH
72199: LD_INT 2
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 4
72208: PUSH
72209: LD_INT 3
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 4
72218: PUSH
72219: LD_INT 4
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 3
72228: PUSH
72229: LD_INT 4
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: PUSH
72239: LD_INT 3
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 2
72248: PUSH
72249: LD_INT 2
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 4
72258: PUSH
72259: LD_INT 2
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 2
72268: PUSH
72269: LD_INT 4
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 0
72278: PUSH
72279: LD_INT 4
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: LD_INT 3
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: LD_INT 4
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 1
72308: PUSH
72309: LD_INT 5
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 0
72318: PUSH
72319: LD_INT 5
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 1
72328: NEG
72329: PUSH
72330: LD_INT 4
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: NEG
72340: PUSH
72341: LD_INT 3
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 2
72350: PUSH
72351: LD_INT 5
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 2
72360: NEG
72361: PUSH
72362: LD_INT 3
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
72416: LD_ADDR_VAR 0 34
72420: PUSH
72421: LD_INT 0
72423: PUSH
72424: LD_INT 4
72426: NEG
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: LD_INT 5
72437: NEG
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: LD_INT 4
72448: NEG
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 1
72456: PUSH
72457: LD_INT 3
72459: NEG
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: LD_INT 3
72470: NEG
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: NEG
72479: PUSH
72480: LD_INT 4
72482: NEG
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 1
72490: NEG
72491: PUSH
72492: LD_INT 5
72494: NEG
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 2
72502: PUSH
72503: LD_INT 3
72505: NEG
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 2
72513: NEG
72514: PUSH
72515: LD_INT 5
72517: NEG
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 3
72525: PUSH
72526: LD_INT 0
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 3
72535: PUSH
72536: LD_INT 1
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 4
72546: PUSH
72547: LD_INT 0
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 4
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 3
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 2
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 2
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: LD_INT 2
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 4
72608: PUSH
72609: LD_INT 2
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 4
72618: PUSH
72619: LD_INT 4
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 4
72628: PUSH
72629: LD_INT 3
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 5
72638: PUSH
72639: LD_INT 4
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 5
72648: PUSH
72649: LD_INT 5
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 4
72658: PUSH
72659: LD_INT 5
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 3
72668: PUSH
72669: LD_INT 4
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 3
72678: PUSH
72679: LD_INT 3
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 5
72688: PUSH
72689: LD_INT 3
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 3
72698: PUSH
72699: LD_INT 5
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 0
72708: PUSH
72709: LD_INT 3
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: LD_INT 3
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 1
72738: PUSH
72739: LD_INT 4
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: LD_INT 4
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: NEG
72759: PUSH
72760: LD_INT 3
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 1
72769: NEG
72770: PUSH
72771: LD_INT 2
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 2
72780: PUSH
72781: LD_INT 4
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 2
72790: NEG
72791: PUSH
72792: LD_INT 2
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 4
72801: NEG
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 4
72812: NEG
72813: PUSH
72814: LD_INT 1
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 3
72824: NEG
72825: PUSH
72826: LD_INT 0
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 3
72835: NEG
72836: PUSH
72837: LD_INT 1
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 4
72846: NEG
72847: PUSH
72848: LD_INT 1
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 5
72857: NEG
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 5
72868: NEG
72869: PUSH
72870: LD_INT 1
72872: NEG
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 5
72880: NEG
72881: PUSH
72882: LD_INT 2
72884: NEG
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: LD_INT 3
72892: NEG
72893: PUSH
72894: LD_INT 2
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: LIST
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: ST_TO_ADDR
// end ; end ;
72948: GO 72951
72950: POP
// case btype of b_depot , b_warehouse :
72951: LD_VAR 0 1
72955: PUSH
72956: LD_INT 0
72958: DOUBLE
72959: EQUAL
72960: IFTRUE 72970
72962: LD_INT 1
72964: DOUBLE
72965: EQUAL
72966: IFTRUE 72970
72968: GO 73171
72970: POP
// case nation of nation_american :
72971: LD_VAR 0 5
72975: PUSH
72976: LD_INT 1
72978: DOUBLE
72979: EQUAL
72980: IFTRUE 72984
72982: GO 73040
72984: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
72985: LD_ADDR_VAR 0 9
72989: PUSH
72990: LD_VAR 0 11
72994: PUSH
72995: LD_VAR 0 12
72999: PUSH
73000: LD_VAR 0 13
73004: PUSH
73005: LD_VAR 0 14
73009: PUSH
73010: LD_VAR 0 15
73014: PUSH
73015: LD_VAR 0 16
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: PUSH
73028: LD_VAR 0 4
73032: PUSH
73033: LD_INT 1
73035: PLUS
73036: ARRAY
73037: ST_TO_ADDR
73038: GO 73169
73040: LD_INT 2
73042: DOUBLE
73043: EQUAL
73044: IFTRUE 73048
73046: GO 73104
73048: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
73049: LD_ADDR_VAR 0 9
73053: PUSH
73054: LD_VAR 0 17
73058: PUSH
73059: LD_VAR 0 18
73063: PUSH
73064: LD_VAR 0 19
73068: PUSH
73069: LD_VAR 0 20
73073: PUSH
73074: LD_VAR 0 21
73078: PUSH
73079: LD_VAR 0 22
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: PUSH
73092: LD_VAR 0 4
73096: PUSH
73097: LD_INT 1
73099: PLUS
73100: ARRAY
73101: ST_TO_ADDR
73102: GO 73169
73104: LD_INT 3
73106: DOUBLE
73107: EQUAL
73108: IFTRUE 73112
73110: GO 73168
73112: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
73113: LD_ADDR_VAR 0 9
73117: PUSH
73118: LD_VAR 0 23
73122: PUSH
73123: LD_VAR 0 24
73127: PUSH
73128: LD_VAR 0 25
73132: PUSH
73133: LD_VAR 0 26
73137: PUSH
73138: LD_VAR 0 27
73142: PUSH
73143: LD_VAR 0 28
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: PUSH
73156: LD_VAR 0 4
73160: PUSH
73161: LD_INT 1
73163: PLUS
73164: ARRAY
73165: ST_TO_ADDR
73166: GO 73169
73168: POP
73169: GO 73724
73171: LD_INT 2
73173: DOUBLE
73174: EQUAL
73175: IFTRUE 73185
73177: LD_INT 3
73179: DOUBLE
73180: EQUAL
73181: IFTRUE 73185
73183: GO 73241
73185: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
73186: LD_ADDR_VAR 0 9
73190: PUSH
73191: LD_VAR 0 29
73195: PUSH
73196: LD_VAR 0 30
73200: PUSH
73201: LD_VAR 0 31
73205: PUSH
73206: LD_VAR 0 32
73210: PUSH
73211: LD_VAR 0 33
73215: PUSH
73216: LD_VAR 0 34
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: PUSH
73229: LD_VAR 0 4
73233: PUSH
73234: LD_INT 1
73236: PLUS
73237: ARRAY
73238: ST_TO_ADDR
73239: GO 73724
73241: LD_INT 16
73243: DOUBLE
73244: EQUAL
73245: IFTRUE 73303
73247: LD_INT 17
73249: DOUBLE
73250: EQUAL
73251: IFTRUE 73303
73253: LD_INT 18
73255: DOUBLE
73256: EQUAL
73257: IFTRUE 73303
73259: LD_INT 19
73261: DOUBLE
73262: EQUAL
73263: IFTRUE 73303
73265: LD_INT 22
73267: DOUBLE
73268: EQUAL
73269: IFTRUE 73303
73271: LD_INT 20
73273: DOUBLE
73274: EQUAL
73275: IFTRUE 73303
73277: LD_INT 21
73279: DOUBLE
73280: EQUAL
73281: IFTRUE 73303
73283: LD_INT 23
73285: DOUBLE
73286: EQUAL
73287: IFTRUE 73303
73289: LD_INT 24
73291: DOUBLE
73292: EQUAL
73293: IFTRUE 73303
73295: LD_INT 25
73297: DOUBLE
73298: EQUAL
73299: IFTRUE 73303
73301: GO 73359
73303: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
73304: LD_ADDR_VAR 0 9
73308: PUSH
73309: LD_VAR 0 35
73313: PUSH
73314: LD_VAR 0 36
73318: PUSH
73319: LD_VAR 0 37
73323: PUSH
73324: LD_VAR 0 38
73328: PUSH
73329: LD_VAR 0 39
73333: PUSH
73334: LD_VAR 0 40
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: PUSH
73347: LD_VAR 0 4
73351: PUSH
73352: LD_INT 1
73354: PLUS
73355: ARRAY
73356: ST_TO_ADDR
73357: GO 73724
73359: LD_INT 6
73361: DOUBLE
73362: EQUAL
73363: IFTRUE 73415
73365: LD_INT 7
73367: DOUBLE
73368: EQUAL
73369: IFTRUE 73415
73371: LD_INT 8
73373: DOUBLE
73374: EQUAL
73375: IFTRUE 73415
73377: LD_INT 13
73379: DOUBLE
73380: EQUAL
73381: IFTRUE 73415
73383: LD_INT 12
73385: DOUBLE
73386: EQUAL
73387: IFTRUE 73415
73389: LD_INT 15
73391: DOUBLE
73392: EQUAL
73393: IFTRUE 73415
73395: LD_INT 11
73397: DOUBLE
73398: EQUAL
73399: IFTRUE 73415
73401: LD_INT 14
73403: DOUBLE
73404: EQUAL
73405: IFTRUE 73415
73407: LD_INT 10
73409: DOUBLE
73410: EQUAL
73411: IFTRUE 73415
73413: GO 73471
73415: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
73416: LD_ADDR_VAR 0 9
73420: PUSH
73421: LD_VAR 0 41
73425: PUSH
73426: LD_VAR 0 42
73430: PUSH
73431: LD_VAR 0 43
73435: PUSH
73436: LD_VAR 0 44
73440: PUSH
73441: LD_VAR 0 45
73445: PUSH
73446: LD_VAR 0 46
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: PUSH
73459: LD_VAR 0 4
73463: PUSH
73464: LD_INT 1
73466: PLUS
73467: ARRAY
73468: ST_TO_ADDR
73469: GO 73724
73471: LD_INT 36
73473: DOUBLE
73474: EQUAL
73475: IFTRUE 73479
73477: GO 73535
73479: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
73480: LD_ADDR_VAR 0 9
73484: PUSH
73485: LD_VAR 0 47
73489: PUSH
73490: LD_VAR 0 48
73494: PUSH
73495: LD_VAR 0 49
73499: PUSH
73500: LD_VAR 0 50
73504: PUSH
73505: LD_VAR 0 51
73509: PUSH
73510: LD_VAR 0 52
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: PUSH
73523: LD_VAR 0 4
73527: PUSH
73528: LD_INT 1
73530: PLUS
73531: ARRAY
73532: ST_TO_ADDR
73533: GO 73724
73535: LD_INT 4
73537: DOUBLE
73538: EQUAL
73539: IFTRUE 73561
73541: LD_INT 5
73543: DOUBLE
73544: EQUAL
73545: IFTRUE 73561
73547: LD_INT 34
73549: DOUBLE
73550: EQUAL
73551: IFTRUE 73561
73553: LD_INT 37
73555: DOUBLE
73556: EQUAL
73557: IFTRUE 73561
73559: GO 73617
73561: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
73562: LD_ADDR_VAR 0 9
73566: PUSH
73567: LD_VAR 0 53
73571: PUSH
73572: LD_VAR 0 54
73576: PUSH
73577: LD_VAR 0 55
73581: PUSH
73582: LD_VAR 0 56
73586: PUSH
73587: LD_VAR 0 57
73591: PUSH
73592: LD_VAR 0 58
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: PUSH
73605: LD_VAR 0 4
73609: PUSH
73610: LD_INT 1
73612: PLUS
73613: ARRAY
73614: ST_TO_ADDR
73615: GO 73724
73617: LD_INT 31
73619: DOUBLE
73620: EQUAL
73621: IFTRUE 73667
73623: LD_INT 32
73625: DOUBLE
73626: EQUAL
73627: IFTRUE 73667
73629: LD_INT 33
73631: DOUBLE
73632: EQUAL
73633: IFTRUE 73667
73635: LD_INT 27
73637: DOUBLE
73638: EQUAL
73639: IFTRUE 73667
73641: LD_INT 26
73643: DOUBLE
73644: EQUAL
73645: IFTRUE 73667
73647: LD_INT 28
73649: DOUBLE
73650: EQUAL
73651: IFTRUE 73667
73653: LD_INT 29
73655: DOUBLE
73656: EQUAL
73657: IFTRUE 73667
73659: LD_INT 30
73661: DOUBLE
73662: EQUAL
73663: IFTRUE 73667
73665: GO 73723
73667: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
73668: LD_ADDR_VAR 0 9
73672: PUSH
73673: LD_VAR 0 59
73677: PUSH
73678: LD_VAR 0 60
73682: PUSH
73683: LD_VAR 0 61
73687: PUSH
73688: LD_VAR 0 62
73692: PUSH
73693: LD_VAR 0 63
73697: PUSH
73698: LD_VAR 0 64
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: LIST
73710: PUSH
73711: LD_VAR 0 4
73715: PUSH
73716: LD_INT 1
73718: PLUS
73719: ARRAY
73720: ST_TO_ADDR
73721: GO 73724
73723: POP
// temp_list2 = [ ] ;
73724: LD_ADDR_VAR 0 10
73728: PUSH
73729: EMPTY
73730: ST_TO_ADDR
// for i in temp_list do
73731: LD_ADDR_VAR 0 8
73735: PUSH
73736: LD_VAR 0 9
73740: PUSH
73741: FOR_IN
73742: IFFALSE 73794
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
73744: LD_ADDR_VAR 0 10
73748: PUSH
73749: LD_VAR 0 10
73753: PUSH
73754: LD_VAR 0 8
73758: PUSH
73759: LD_INT 1
73761: ARRAY
73762: PUSH
73763: LD_VAR 0 2
73767: PLUS
73768: PUSH
73769: LD_VAR 0 8
73773: PUSH
73774: LD_INT 2
73776: ARRAY
73777: PUSH
73778: LD_VAR 0 3
73782: PLUS
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: EMPTY
73789: LIST
73790: ADD
73791: ST_TO_ADDR
73792: GO 73741
73794: POP
73795: POP
// result = temp_list2 ;
73796: LD_ADDR_VAR 0 7
73800: PUSH
73801: LD_VAR 0 10
73805: ST_TO_ADDR
// end ;
73806: LD_VAR 0 7
73810: RET
// export function EnemyInRange ( unit , dist ) ; begin
73811: LD_INT 0
73813: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
73814: LD_ADDR_VAR 0 3
73818: PUSH
73819: LD_VAR 0 1
73823: PPUSH
73824: CALL_OW 255
73828: PPUSH
73829: LD_VAR 0 1
73833: PPUSH
73834: CALL_OW 250
73838: PPUSH
73839: LD_VAR 0 1
73843: PPUSH
73844: CALL_OW 251
73848: PPUSH
73849: LD_VAR 0 2
73853: PPUSH
73854: CALL 47915 0 4
73858: PUSH
73859: LD_INT 4
73861: ARRAY
73862: ST_TO_ADDR
// end ;
73863: LD_VAR 0 3
73867: RET
// export function PlayerSeeMe ( unit ) ; begin
73868: LD_INT 0
73870: PPUSH
// result := See ( your_side , unit ) ;
73871: LD_ADDR_VAR 0 2
73875: PUSH
73876: LD_OWVAR 2
73880: PPUSH
73881: LD_VAR 0 1
73885: PPUSH
73886: CALL_OW 292
73890: ST_TO_ADDR
// end ;
73891: LD_VAR 0 2
73895: RET
// export function ReverseDir ( unit ) ; begin
73896: LD_INT 0
73898: PPUSH
// if not unit then
73899: LD_VAR 0 1
73903: NOT
73904: IFFALSE 73908
// exit ;
73906: GO 73954
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
73908: LD_ADDR_VAR 0 2
73912: PUSH
73913: LD_INT 3
73915: PUSH
73916: LD_INT 4
73918: PUSH
73919: LD_INT 5
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: LD_INT 1
73927: PUSH
73928: LD_INT 2
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: PUSH
73939: LD_VAR 0 1
73943: PPUSH
73944: CALL_OW 254
73948: PUSH
73949: LD_INT 1
73951: PLUS
73952: ARRAY
73953: ST_TO_ADDR
// end ;
73954: LD_VAR 0 2
73958: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
73959: LD_INT 0
73961: PPUSH
73962: PPUSH
73963: PPUSH
73964: PPUSH
73965: PPUSH
// if not hexes then
73966: LD_VAR 0 2
73970: NOT
73971: IFFALSE 73975
// exit ;
73973: GO 74123
// dist := 9999 ;
73975: LD_ADDR_VAR 0 5
73979: PUSH
73980: LD_INT 9999
73982: ST_TO_ADDR
// for i = 1 to hexes do
73983: LD_ADDR_VAR 0 4
73987: PUSH
73988: DOUBLE
73989: LD_INT 1
73991: DEC
73992: ST_TO_ADDR
73993: LD_VAR 0 2
73997: PUSH
73998: FOR_TO
73999: IFFALSE 74111
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
74001: LD_VAR 0 1
74005: PPUSH
74006: LD_VAR 0 2
74010: PUSH
74011: LD_VAR 0 4
74015: ARRAY
74016: PUSH
74017: LD_INT 1
74019: ARRAY
74020: PPUSH
74021: LD_VAR 0 2
74025: PUSH
74026: LD_VAR 0 4
74030: ARRAY
74031: PUSH
74032: LD_INT 2
74034: ARRAY
74035: PPUSH
74036: CALL_OW 297
74040: PUSH
74041: LD_VAR 0 5
74045: LESS
74046: IFFALSE 74109
// begin hex := hexes [ i ] ;
74048: LD_ADDR_VAR 0 7
74052: PUSH
74053: LD_VAR 0 2
74057: PUSH
74058: LD_VAR 0 4
74062: ARRAY
74063: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74064: LD_ADDR_VAR 0 5
74068: PUSH
74069: LD_VAR 0 1
74073: PPUSH
74074: LD_VAR 0 2
74078: PUSH
74079: LD_VAR 0 4
74083: ARRAY
74084: PUSH
74085: LD_INT 1
74087: ARRAY
74088: PPUSH
74089: LD_VAR 0 2
74093: PUSH
74094: LD_VAR 0 4
74098: ARRAY
74099: PUSH
74100: LD_INT 2
74102: ARRAY
74103: PPUSH
74104: CALL_OW 297
74108: ST_TO_ADDR
// end ; end ;
74109: GO 73998
74111: POP
74112: POP
// result := hex ;
74113: LD_ADDR_VAR 0 3
74117: PUSH
74118: LD_VAR 0 7
74122: ST_TO_ADDR
// end ;
74123: LD_VAR 0 3
74127: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
74128: LD_INT 0
74130: PPUSH
74131: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
74132: LD_VAR 0 1
74136: NOT
74137: PUSH
74138: LD_VAR 0 1
74142: PUSH
74143: LD_INT 21
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 23
74155: PUSH
74156: LD_INT 2
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PPUSH
74167: CALL_OW 69
74171: IN
74172: NOT
74173: OR
74174: IFFALSE 74178
// exit ;
74176: GO 74225
// for i = 1 to 3 do
74178: LD_ADDR_VAR 0 3
74182: PUSH
74183: DOUBLE
74184: LD_INT 1
74186: DEC
74187: ST_TO_ADDR
74188: LD_INT 3
74190: PUSH
74191: FOR_TO
74192: IFFALSE 74223
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
74194: LD_VAR 0 1
74198: PPUSH
74199: CALL_OW 250
74203: PPUSH
74204: LD_VAR 0 1
74208: PPUSH
74209: CALL_OW 251
74213: PPUSH
74214: LD_INT 1
74216: PPUSH
74217: CALL_OW 453
74221: GO 74191
74223: POP
74224: POP
// end ;
74225: LD_VAR 0 2
74229: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
74230: LD_INT 0
74232: PPUSH
74233: PPUSH
74234: PPUSH
74235: PPUSH
74236: PPUSH
74237: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
74238: LD_VAR 0 1
74242: NOT
74243: PUSH
74244: LD_VAR 0 2
74248: NOT
74249: OR
74250: PUSH
74251: LD_VAR 0 1
74255: PPUSH
74256: CALL_OW 314
74260: OR
74261: IFFALSE 74265
// exit ;
74263: GO 74706
// x := GetX ( enemy_unit ) ;
74265: LD_ADDR_VAR 0 7
74269: PUSH
74270: LD_VAR 0 2
74274: PPUSH
74275: CALL_OW 250
74279: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
74280: LD_ADDR_VAR 0 8
74284: PUSH
74285: LD_VAR 0 2
74289: PPUSH
74290: CALL_OW 251
74294: ST_TO_ADDR
// if not x or not y then
74295: LD_VAR 0 7
74299: NOT
74300: PUSH
74301: LD_VAR 0 8
74305: NOT
74306: OR
74307: IFFALSE 74311
// exit ;
74309: GO 74706
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
74311: LD_ADDR_VAR 0 6
74315: PUSH
74316: LD_VAR 0 7
74320: PPUSH
74321: LD_INT 0
74323: PPUSH
74324: LD_INT 4
74326: PPUSH
74327: CALL_OW 272
74331: PUSH
74332: LD_VAR 0 8
74336: PPUSH
74337: LD_INT 0
74339: PPUSH
74340: LD_INT 4
74342: PPUSH
74343: CALL_OW 273
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_VAR 0 7
74356: PPUSH
74357: LD_INT 1
74359: PPUSH
74360: LD_INT 4
74362: PPUSH
74363: CALL_OW 272
74367: PUSH
74368: LD_VAR 0 8
74372: PPUSH
74373: LD_INT 1
74375: PPUSH
74376: LD_INT 4
74378: PPUSH
74379: CALL_OW 273
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_VAR 0 7
74392: PPUSH
74393: LD_INT 2
74395: PPUSH
74396: LD_INT 4
74398: PPUSH
74399: CALL_OW 272
74403: PUSH
74404: LD_VAR 0 8
74408: PPUSH
74409: LD_INT 2
74411: PPUSH
74412: LD_INT 4
74414: PPUSH
74415: CALL_OW 273
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_VAR 0 7
74428: PPUSH
74429: LD_INT 3
74431: PPUSH
74432: LD_INT 4
74434: PPUSH
74435: CALL_OW 272
74439: PUSH
74440: LD_VAR 0 8
74444: PPUSH
74445: LD_INT 3
74447: PPUSH
74448: LD_INT 4
74450: PPUSH
74451: CALL_OW 273
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_VAR 0 7
74464: PPUSH
74465: LD_INT 4
74467: PPUSH
74468: LD_INT 4
74470: PPUSH
74471: CALL_OW 272
74475: PUSH
74476: LD_VAR 0 8
74480: PPUSH
74481: LD_INT 4
74483: PPUSH
74484: LD_INT 4
74486: PPUSH
74487: CALL_OW 273
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_VAR 0 7
74500: PPUSH
74501: LD_INT 5
74503: PPUSH
74504: LD_INT 4
74506: PPUSH
74507: CALL_OW 272
74511: PUSH
74512: LD_VAR 0 8
74516: PPUSH
74517: LD_INT 5
74519: PPUSH
74520: LD_INT 4
74522: PPUSH
74523: CALL_OW 273
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: LIST
74536: LIST
74537: LIST
74538: LIST
74539: ST_TO_ADDR
// for i = tmp downto 1 do
74540: LD_ADDR_VAR 0 4
74544: PUSH
74545: DOUBLE
74546: LD_VAR 0 6
74550: INC
74551: ST_TO_ADDR
74552: LD_INT 1
74554: PUSH
74555: FOR_DOWNTO
74556: IFFALSE 74657
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
74558: LD_VAR 0 6
74562: PUSH
74563: LD_VAR 0 4
74567: ARRAY
74568: PUSH
74569: LD_INT 1
74571: ARRAY
74572: PPUSH
74573: LD_VAR 0 6
74577: PUSH
74578: LD_VAR 0 4
74582: ARRAY
74583: PUSH
74584: LD_INT 2
74586: ARRAY
74587: PPUSH
74588: CALL_OW 488
74592: NOT
74593: PUSH
74594: LD_VAR 0 6
74598: PUSH
74599: LD_VAR 0 4
74603: ARRAY
74604: PUSH
74605: LD_INT 1
74607: ARRAY
74608: PPUSH
74609: LD_VAR 0 6
74613: PUSH
74614: LD_VAR 0 4
74618: ARRAY
74619: PUSH
74620: LD_INT 2
74622: ARRAY
74623: PPUSH
74624: CALL_OW 428
74628: PUSH
74629: LD_INT 0
74631: NONEQUAL
74632: OR
74633: IFFALSE 74655
// tmp := Delete ( tmp , i ) ;
74635: LD_ADDR_VAR 0 6
74639: PUSH
74640: LD_VAR 0 6
74644: PPUSH
74645: LD_VAR 0 4
74649: PPUSH
74650: CALL_OW 3
74654: ST_TO_ADDR
74655: GO 74555
74657: POP
74658: POP
// j := GetClosestHex ( unit , tmp ) ;
74659: LD_ADDR_VAR 0 5
74663: PUSH
74664: LD_VAR 0 1
74668: PPUSH
74669: LD_VAR 0 6
74673: PPUSH
74674: CALL 73959 0 2
74678: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
74679: LD_VAR 0 1
74683: PPUSH
74684: LD_VAR 0 5
74688: PUSH
74689: LD_INT 1
74691: ARRAY
74692: PPUSH
74693: LD_VAR 0 5
74697: PUSH
74698: LD_INT 2
74700: ARRAY
74701: PPUSH
74702: CALL_OW 111
// end ;
74706: LD_VAR 0 3
74710: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
74711: LD_INT 0
74713: PPUSH
74714: PPUSH
74715: PPUSH
// uc_side = 0 ;
74716: LD_ADDR_OWVAR 20
74720: PUSH
74721: LD_INT 0
74723: ST_TO_ADDR
// uc_nation = 0 ;
74724: LD_ADDR_OWVAR 21
74728: PUSH
74729: LD_INT 0
74731: ST_TO_ADDR
// InitHc ;
74732: CALL_OW 19
// InitVc ;
74736: CALL_OW 20
// if mastodonts then
74740: LD_VAR 0 6
74744: IFFALSE 74811
// for i = 1 to mastodonts do
74746: LD_ADDR_VAR 0 11
74750: PUSH
74751: DOUBLE
74752: LD_INT 1
74754: DEC
74755: ST_TO_ADDR
74756: LD_VAR 0 6
74760: PUSH
74761: FOR_TO
74762: IFFALSE 74809
// begin vc_chassis := 31 ;
74764: LD_ADDR_OWVAR 37
74768: PUSH
74769: LD_INT 31
74771: ST_TO_ADDR
// vc_control := control_rider ;
74772: LD_ADDR_OWVAR 38
74776: PUSH
74777: LD_INT 4
74779: ST_TO_ADDR
// animal := CreateVehicle ;
74780: LD_ADDR_VAR 0 12
74784: PUSH
74785: CALL_OW 45
74789: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
74790: LD_VAR 0 12
74794: PPUSH
74795: LD_VAR 0 8
74799: PPUSH
74800: LD_INT 0
74802: PPUSH
74803: CALL 81556 0 3
// end ;
74807: GO 74761
74809: POP
74810: POP
// if horses then
74811: LD_VAR 0 5
74815: IFFALSE 74882
// for i = 1 to horses do
74817: LD_ADDR_VAR 0 11
74821: PUSH
74822: DOUBLE
74823: LD_INT 1
74825: DEC
74826: ST_TO_ADDR
74827: LD_VAR 0 5
74831: PUSH
74832: FOR_TO
74833: IFFALSE 74880
// begin hc_class := 21 ;
74835: LD_ADDR_OWVAR 28
74839: PUSH
74840: LD_INT 21
74842: ST_TO_ADDR
// hc_gallery :=  ;
74843: LD_ADDR_OWVAR 33
74847: PUSH
74848: LD_STRING 
74850: ST_TO_ADDR
// animal := CreateHuman ;
74851: LD_ADDR_VAR 0 12
74855: PUSH
74856: CALL_OW 44
74860: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
74861: LD_VAR 0 12
74865: PPUSH
74866: LD_VAR 0 8
74870: PPUSH
74871: LD_INT 0
74873: PPUSH
74874: CALL 81556 0 3
// end ;
74878: GO 74832
74880: POP
74881: POP
// if birds then
74882: LD_VAR 0 1
74886: IFFALSE 74953
// for i = 1 to birds do
74888: LD_ADDR_VAR 0 11
74892: PUSH
74893: DOUBLE
74894: LD_INT 1
74896: DEC
74897: ST_TO_ADDR
74898: LD_VAR 0 1
74902: PUSH
74903: FOR_TO
74904: IFFALSE 74951
// begin hc_class = 18 ;
74906: LD_ADDR_OWVAR 28
74910: PUSH
74911: LD_INT 18
74913: ST_TO_ADDR
// hc_gallery =  ;
74914: LD_ADDR_OWVAR 33
74918: PUSH
74919: LD_STRING 
74921: ST_TO_ADDR
// animal := CreateHuman ;
74922: LD_ADDR_VAR 0 12
74926: PUSH
74927: CALL_OW 44
74931: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
74932: LD_VAR 0 12
74936: PPUSH
74937: LD_VAR 0 8
74941: PPUSH
74942: LD_INT 0
74944: PPUSH
74945: CALL 81556 0 3
// end ;
74949: GO 74903
74951: POP
74952: POP
// if tigers then
74953: LD_VAR 0 2
74957: IFFALSE 75041
// for i = 1 to tigers do
74959: LD_ADDR_VAR 0 11
74963: PUSH
74964: DOUBLE
74965: LD_INT 1
74967: DEC
74968: ST_TO_ADDR
74969: LD_VAR 0 2
74973: PUSH
74974: FOR_TO
74975: IFFALSE 75039
// begin hc_class = class_tiger ;
74977: LD_ADDR_OWVAR 28
74981: PUSH
74982: LD_INT 14
74984: ST_TO_ADDR
// hc_gallery =  ;
74985: LD_ADDR_OWVAR 33
74989: PUSH
74990: LD_STRING 
74992: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
74993: LD_ADDR_OWVAR 35
74997: PUSH
74998: LD_INT 7
75000: NEG
75001: PPUSH
75002: LD_INT 7
75004: PPUSH
75005: CALL_OW 12
75009: ST_TO_ADDR
// animal := CreateHuman ;
75010: LD_ADDR_VAR 0 12
75014: PUSH
75015: CALL_OW 44
75019: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75020: LD_VAR 0 12
75024: PPUSH
75025: LD_VAR 0 8
75029: PPUSH
75030: LD_INT 0
75032: PPUSH
75033: CALL 81556 0 3
// end ;
75037: GO 74974
75039: POP
75040: POP
// if apemans then
75041: LD_VAR 0 3
75045: IFFALSE 75168
// for i = 1 to apemans do
75047: LD_ADDR_VAR 0 11
75051: PUSH
75052: DOUBLE
75053: LD_INT 1
75055: DEC
75056: ST_TO_ADDR
75057: LD_VAR 0 3
75061: PUSH
75062: FOR_TO
75063: IFFALSE 75166
// begin hc_class = class_apeman ;
75065: LD_ADDR_OWVAR 28
75069: PUSH
75070: LD_INT 12
75072: ST_TO_ADDR
// hc_gallery =  ;
75073: LD_ADDR_OWVAR 33
75077: PUSH
75078: LD_STRING 
75080: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
75081: LD_ADDR_OWVAR 35
75085: PUSH
75086: LD_INT 5
75088: NEG
75089: PPUSH
75090: LD_INT 5
75092: PPUSH
75093: CALL_OW 12
75097: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
75098: LD_ADDR_OWVAR 31
75102: PUSH
75103: LD_INT 1
75105: PPUSH
75106: LD_INT 3
75108: PPUSH
75109: CALL_OW 12
75113: PUSH
75114: LD_INT 1
75116: PPUSH
75117: LD_INT 3
75119: PPUSH
75120: CALL_OW 12
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: LD_INT 0
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: ST_TO_ADDR
// animal := CreateHuman ;
75137: LD_ADDR_VAR 0 12
75141: PUSH
75142: CALL_OW 44
75146: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75147: LD_VAR 0 12
75151: PPUSH
75152: LD_VAR 0 8
75156: PPUSH
75157: LD_INT 0
75159: PPUSH
75160: CALL 81556 0 3
// end ;
75164: GO 75062
75166: POP
75167: POP
// if enchidnas then
75168: LD_VAR 0 4
75172: IFFALSE 75239
// for i = 1 to enchidnas do
75174: LD_ADDR_VAR 0 11
75178: PUSH
75179: DOUBLE
75180: LD_INT 1
75182: DEC
75183: ST_TO_ADDR
75184: LD_VAR 0 4
75188: PUSH
75189: FOR_TO
75190: IFFALSE 75237
// begin hc_class = 13 ;
75192: LD_ADDR_OWVAR 28
75196: PUSH
75197: LD_INT 13
75199: ST_TO_ADDR
// hc_gallery =  ;
75200: LD_ADDR_OWVAR 33
75204: PUSH
75205: LD_STRING 
75207: ST_TO_ADDR
// animal := CreateHuman ;
75208: LD_ADDR_VAR 0 12
75212: PUSH
75213: CALL_OW 44
75217: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75218: LD_VAR 0 12
75222: PPUSH
75223: LD_VAR 0 8
75227: PPUSH
75228: LD_INT 0
75230: PPUSH
75231: CALL 81556 0 3
// end ;
75235: GO 75189
75237: POP
75238: POP
// if fishes then
75239: LD_VAR 0 7
75243: IFFALSE 75310
// for i = 1 to fishes do
75245: LD_ADDR_VAR 0 11
75249: PUSH
75250: DOUBLE
75251: LD_INT 1
75253: DEC
75254: ST_TO_ADDR
75255: LD_VAR 0 7
75259: PUSH
75260: FOR_TO
75261: IFFALSE 75308
// begin hc_class = 20 ;
75263: LD_ADDR_OWVAR 28
75267: PUSH
75268: LD_INT 20
75270: ST_TO_ADDR
// hc_gallery =  ;
75271: LD_ADDR_OWVAR 33
75275: PUSH
75276: LD_STRING 
75278: ST_TO_ADDR
// animal := CreateHuman ;
75279: LD_ADDR_VAR 0 12
75283: PUSH
75284: CALL_OW 44
75288: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
75289: LD_VAR 0 12
75293: PPUSH
75294: LD_VAR 0 9
75298: PPUSH
75299: LD_INT 0
75301: PPUSH
75302: CALL 81556 0 3
// end ;
75306: GO 75260
75308: POP
75309: POP
// end ;
75310: LD_VAR 0 10
75314: RET
// export function WantHeal ( sci , unit ) ; begin
75315: LD_INT 0
75317: PPUSH
// if GetTaskList ( sci ) > 0 then
75318: LD_VAR 0 1
75322: PPUSH
75323: CALL_OW 437
75327: PUSH
75328: LD_INT 0
75330: GREATER
75331: IFFALSE 75401
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
75333: LD_VAR 0 1
75337: PPUSH
75338: CALL_OW 437
75342: PUSH
75343: LD_INT 1
75345: ARRAY
75346: PUSH
75347: LD_INT 1
75349: ARRAY
75350: PUSH
75351: LD_STRING l
75353: EQUAL
75354: PUSH
75355: LD_VAR 0 1
75359: PPUSH
75360: CALL_OW 437
75364: PUSH
75365: LD_INT 1
75367: ARRAY
75368: PUSH
75369: LD_INT 4
75371: ARRAY
75372: PUSH
75373: LD_VAR 0 2
75377: EQUAL
75378: AND
75379: IFFALSE 75391
// result := true else
75381: LD_ADDR_VAR 0 3
75385: PUSH
75386: LD_INT 1
75388: ST_TO_ADDR
75389: GO 75399
// result := false ;
75391: LD_ADDR_VAR 0 3
75395: PUSH
75396: LD_INT 0
75398: ST_TO_ADDR
// end else
75399: GO 75409
// result := false ;
75401: LD_ADDR_VAR 0 3
75405: PUSH
75406: LD_INT 0
75408: ST_TO_ADDR
// end ;
75409: LD_VAR 0 3
75413: RET
// export function HealTarget ( sci ) ; begin
75414: LD_INT 0
75416: PPUSH
// if not sci then
75417: LD_VAR 0 1
75421: NOT
75422: IFFALSE 75426
// exit ;
75424: GO 75491
// result := 0 ;
75426: LD_ADDR_VAR 0 2
75430: PUSH
75431: LD_INT 0
75433: ST_TO_ADDR
// if GetTaskList ( sci ) then
75434: LD_VAR 0 1
75438: PPUSH
75439: CALL_OW 437
75443: IFFALSE 75491
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
75445: LD_VAR 0 1
75449: PPUSH
75450: CALL_OW 437
75454: PUSH
75455: LD_INT 1
75457: ARRAY
75458: PUSH
75459: LD_INT 1
75461: ARRAY
75462: PUSH
75463: LD_STRING l
75465: EQUAL
75466: IFFALSE 75491
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
75468: LD_ADDR_VAR 0 2
75472: PUSH
75473: LD_VAR 0 1
75477: PPUSH
75478: CALL_OW 437
75482: PUSH
75483: LD_INT 1
75485: ARRAY
75486: PUSH
75487: LD_INT 4
75489: ARRAY
75490: ST_TO_ADDR
// end ;
75491: LD_VAR 0 2
75495: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
75496: LD_INT 0
75498: PPUSH
75499: PPUSH
75500: PPUSH
75501: PPUSH
75502: PPUSH
75503: PPUSH
75504: PPUSH
75505: PPUSH
75506: PPUSH
75507: PPUSH
75508: PPUSH
75509: PPUSH
75510: PPUSH
75511: PPUSH
75512: PPUSH
75513: PPUSH
75514: PPUSH
75515: PPUSH
75516: PPUSH
75517: PPUSH
75518: PPUSH
75519: PPUSH
75520: PPUSH
75521: PPUSH
75522: PPUSH
75523: PPUSH
75524: PPUSH
75525: PPUSH
75526: PPUSH
75527: PPUSH
75528: PPUSH
75529: PPUSH
75530: PPUSH
75531: PPUSH
// if not list then
75532: LD_VAR 0 1
75536: NOT
75537: IFFALSE 75541
// exit ;
75539: GO 80167
// base := list [ 1 ] ;
75541: LD_ADDR_VAR 0 3
75545: PUSH
75546: LD_VAR 0 1
75550: PUSH
75551: LD_INT 1
75553: ARRAY
75554: ST_TO_ADDR
// group := list [ 2 ] ;
75555: LD_ADDR_VAR 0 4
75559: PUSH
75560: LD_VAR 0 1
75564: PUSH
75565: LD_INT 2
75567: ARRAY
75568: ST_TO_ADDR
// path := list [ 3 ] ;
75569: LD_ADDR_VAR 0 5
75573: PUSH
75574: LD_VAR 0 1
75578: PUSH
75579: LD_INT 3
75581: ARRAY
75582: ST_TO_ADDR
// flags := list [ 4 ] ;
75583: LD_ADDR_VAR 0 6
75587: PUSH
75588: LD_VAR 0 1
75592: PUSH
75593: LD_INT 4
75595: ARRAY
75596: ST_TO_ADDR
// mined := [ ] ;
75597: LD_ADDR_VAR 0 27
75601: PUSH
75602: EMPTY
75603: ST_TO_ADDR
// bombed := [ ] ;
75604: LD_ADDR_VAR 0 28
75608: PUSH
75609: EMPTY
75610: ST_TO_ADDR
// healers := [ ] ;
75611: LD_ADDR_VAR 0 31
75615: PUSH
75616: EMPTY
75617: ST_TO_ADDR
// to_heal := [ ] ;
75618: LD_ADDR_VAR 0 30
75622: PUSH
75623: EMPTY
75624: ST_TO_ADDR
// repairs := [ ] ;
75625: LD_ADDR_VAR 0 33
75629: PUSH
75630: EMPTY
75631: ST_TO_ADDR
// to_repair := [ ] ;
75632: LD_ADDR_VAR 0 32
75636: PUSH
75637: EMPTY
75638: ST_TO_ADDR
// if not group or not path then
75639: LD_VAR 0 4
75643: NOT
75644: PUSH
75645: LD_VAR 0 5
75649: NOT
75650: OR
75651: IFFALSE 75655
// exit ;
75653: GO 80167
// side := GetSide ( group [ 1 ] ) ;
75655: LD_ADDR_VAR 0 35
75659: PUSH
75660: LD_VAR 0 4
75664: PUSH
75665: LD_INT 1
75667: ARRAY
75668: PPUSH
75669: CALL_OW 255
75673: ST_TO_ADDR
// if flags then
75674: LD_VAR 0 6
75678: IFFALSE 75822
// begin f_ignore_area := flags [ 1 ] ;
75680: LD_ADDR_VAR 0 17
75684: PUSH
75685: LD_VAR 0 6
75689: PUSH
75690: LD_INT 1
75692: ARRAY
75693: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
75694: LD_ADDR_VAR 0 18
75698: PUSH
75699: LD_VAR 0 6
75703: PUSH
75704: LD_INT 2
75706: ARRAY
75707: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
75708: LD_ADDR_VAR 0 19
75712: PUSH
75713: LD_VAR 0 6
75717: PUSH
75718: LD_INT 3
75720: ARRAY
75721: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
75722: LD_ADDR_VAR 0 20
75726: PUSH
75727: LD_VAR 0 6
75731: PUSH
75732: LD_INT 4
75734: ARRAY
75735: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
75736: LD_ADDR_VAR 0 21
75740: PUSH
75741: LD_VAR 0 6
75745: PUSH
75746: LD_INT 5
75748: ARRAY
75749: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
75750: LD_ADDR_VAR 0 22
75754: PUSH
75755: LD_VAR 0 6
75759: PUSH
75760: LD_INT 6
75762: ARRAY
75763: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
75764: LD_ADDR_VAR 0 23
75768: PUSH
75769: LD_VAR 0 6
75773: PUSH
75774: LD_INT 7
75776: ARRAY
75777: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
75778: LD_ADDR_VAR 0 24
75782: PUSH
75783: LD_VAR 0 6
75787: PUSH
75788: LD_INT 8
75790: ARRAY
75791: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
75792: LD_ADDR_VAR 0 25
75796: PUSH
75797: LD_VAR 0 6
75801: PUSH
75802: LD_INT 9
75804: ARRAY
75805: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
75806: LD_ADDR_VAR 0 26
75810: PUSH
75811: LD_VAR 0 6
75815: PUSH
75816: LD_INT 10
75818: ARRAY
75819: ST_TO_ADDR
// end else
75820: GO 75902
// begin f_ignore_area := false ;
75822: LD_ADDR_VAR 0 17
75826: PUSH
75827: LD_INT 0
75829: ST_TO_ADDR
// f_capture := false ;
75830: LD_ADDR_VAR 0 18
75834: PUSH
75835: LD_INT 0
75837: ST_TO_ADDR
// f_ignore_civ := false ;
75838: LD_ADDR_VAR 0 19
75842: PUSH
75843: LD_INT 0
75845: ST_TO_ADDR
// f_murder := false ;
75846: LD_ADDR_VAR 0 20
75850: PUSH
75851: LD_INT 0
75853: ST_TO_ADDR
// f_mines := false ;
75854: LD_ADDR_VAR 0 21
75858: PUSH
75859: LD_INT 0
75861: ST_TO_ADDR
// f_repair := false ;
75862: LD_ADDR_VAR 0 22
75866: PUSH
75867: LD_INT 0
75869: ST_TO_ADDR
// f_heal := false ;
75870: LD_ADDR_VAR 0 23
75874: PUSH
75875: LD_INT 0
75877: ST_TO_ADDR
// f_spacetime := false ;
75878: LD_ADDR_VAR 0 24
75882: PUSH
75883: LD_INT 0
75885: ST_TO_ADDR
// f_attack_depot := false ;
75886: LD_ADDR_VAR 0 25
75890: PUSH
75891: LD_INT 0
75893: ST_TO_ADDR
// f_crawl := false ;
75894: LD_ADDR_VAR 0 26
75898: PUSH
75899: LD_INT 0
75901: ST_TO_ADDR
// end ; if f_heal then
75902: LD_VAR 0 23
75906: IFFALSE 75933
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
75908: LD_ADDR_VAR 0 31
75912: PUSH
75913: LD_VAR 0 4
75917: PPUSH
75918: LD_INT 25
75920: PUSH
75921: LD_INT 4
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PPUSH
75928: CALL_OW 72
75932: ST_TO_ADDR
// if f_repair then
75933: LD_VAR 0 22
75937: IFFALSE 75964
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
75939: LD_ADDR_VAR 0 33
75943: PUSH
75944: LD_VAR 0 4
75948: PPUSH
75949: LD_INT 25
75951: PUSH
75952: LD_INT 3
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PPUSH
75959: CALL_OW 72
75963: ST_TO_ADDR
// units_path := [ ] ;
75964: LD_ADDR_VAR 0 16
75968: PUSH
75969: EMPTY
75970: ST_TO_ADDR
// for i = 1 to group do
75971: LD_ADDR_VAR 0 7
75975: PUSH
75976: DOUBLE
75977: LD_INT 1
75979: DEC
75980: ST_TO_ADDR
75981: LD_VAR 0 4
75985: PUSH
75986: FOR_TO
75987: IFFALSE 76016
// units_path := Replace ( units_path , i , path ) ;
75989: LD_ADDR_VAR 0 16
75993: PUSH
75994: LD_VAR 0 16
75998: PPUSH
75999: LD_VAR 0 7
76003: PPUSH
76004: LD_VAR 0 5
76008: PPUSH
76009: CALL_OW 1
76013: ST_TO_ADDR
76014: GO 75986
76016: POP
76017: POP
// repeat for i = group downto 1 do
76018: LD_ADDR_VAR 0 7
76022: PUSH
76023: DOUBLE
76024: LD_VAR 0 4
76028: INC
76029: ST_TO_ADDR
76030: LD_INT 1
76032: PUSH
76033: FOR_DOWNTO
76034: IFFALSE 80130
// begin wait ( 5 ) ;
76036: LD_INT 5
76038: PPUSH
76039: CALL_OW 67
// tmp := [ ] ;
76043: LD_ADDR_VAR 0 14
76047: PUSH
76048: EMPTY
76049: ST_TO_ADDR
// attacking := false ;
76050: LD_ADDR_VAR 0 29
76054: PUSH
76055: LD_INT 0
76057: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
76058: LD_VAR 0 4
76062: PUSH
76063: LD_VAR 0 7
76067: ARRAY
76068: PPUSH
76069: CALL_OW 301
76073: PUSH
76074: LD_VAR 0 4
76078: PUSH
76079: LD_VAR 0 7
76083: ARRAY
76084: NOT
76085: OR
76086: IFFALSE 76195
// begin if GetType ( group [ i ] ) = unit_human then
76088: LD_VAR 0 4
76092: PUSH
76093: LD_VAR 0 7
76097: ARRAY
76098: PPUSH
76099: CALL_OW 247
76103: PUSH
76104: LD_INT 1
76106: EQUAL
76107: IFFALSE 76153
// begin to_heal := to_heal diff group [ i ] ;
76109: LD_ADDR_VAR 0 30
76113: PUSH
76114: LD_VAR 0 30
76118: PUSH
76119: LD_VAR 0 4
76123: PUSH
76124: LD_VAR 0 7
76128: ARRAY
76129: DIFF
76130: ST_TO_ADDR
// healers := healers diff group [ i ] ;
76131: LD_ADDR_VAR 0 31
76135: PUSH
76136: LD_VAR 0 31
76140: PUSH
76141: LD_VAR 0 4
76145: PUSH
76146: LD_VAR 0 7
76150: ARRAY
76151: DIFF
76152: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
76153: LD_ADDR_VAR 0 4
76157: PUSH
76158: LD_VAR 0 4
76162: PPUSH
76163: LD_VAR 0 7
76167: PPUSH
76168: CALL_OW 3
76172: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
76173: LD_ADDR_VAR 0 16
76177: PUSH
76178: LD_VAR 0 16
76182: PPUSH
76183: LD_VAR 0 7
76187: PPUSH
76188: CALL_OW 3
76192: ST_TO_ADDR
// continue ;
76193: GO 76033
// end ; if f_repair then
76195: LD_VAR 0 22
76199: IFFALSE 76688
// begin if GetType ( group [ i ] ) = unit_vehicle then
76201: LD_VAR 0 4
76205: PUSH
76206: LD_VAR 0 7
76210: ARRAY
76211: PPUSH
76212: CALL_OW 247
76216: PUSH
76217: LD_INT 2
76219: EQUAL
76220: IFFALSE 76410
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
76222: LD_VAR 0 4
76226: PUSH
76227: LD_VAR 0 7
76231: ARRAY
76232: PPUSH
76233: CALL_OW 256
76237: PUSH
76238: LD_INT 700
76240: LESS
76241: PUSH
76242: LD_VAR 0 4
76246: PUSH
76247: LD_VAR 0 7
76251: ARRAY
76252: PUSH
76253: LD_VAR 0 32
76257: IN
76258: NOT
76259: AND
76260: IFFALSE 76284
// to_repair := to_repair union group [ i ] ;
76262: LD_ADDR_VAR 0 32
76266: PUSH
76267: LD_VAR 0 32
76271: PUSH
76272: LD_VAR 0 4
76276: PUSH
76277: LD_VAR 0 7
76281: ARRAY
76282: UNION
76283: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
76284: LD_VAR 0 4
76288: PUSH
76289: LD_VAR 0 7
76293: ARRAY
76294: PPUSH
76295: CALL_OW 256
76299: PUSH
76300: LD_INT 1000
76302: EQUAL
76303: PUSH
76304: LD_VAR 0 4
76308: PUSH
76309: LD_VAR 0 7
76313: ARRAY
76314: PUSH
76315: LD_VAR 0 32
76319: IN
76320: AND
76321: IFFALSE 76345
// to_repair := to_repair diff group [ i ] ;
76323: LD_ADDR_VAR 0 32
76327: PUSH
76328: LD_VAR 0 32
76332: PUSH
76333: LD_VAR 0 4
76337: PUSH
76338: LD_VAR 0 7
76342: ARRAY
76343: DIFF
76344: ST_TO_ADDR
// if group [ i ] in to_repair then
76345: LD_VAR 0 4
76349: PUSH
76350: LD_VAR 0 7
76354: ARRAY
76355: PUSH
76356: LD_VAR 0 32
76360: IN
76361: IFFALSE 76408
// begin if not IsInArea ( group [ i ] , f_repair ) then
76363: LD_VAR 0 4
76367: PUSH
76368: LD_VAR 0 7
76372: ARRAY
76373: PPUSH
76374: LD_VAR 0 22
76378: PPUSH
76379: CALL_OW 308
76383: NOT
76384: IFFALSE 76406
// ComMoveToArea ( group [ i ] , f_repair ) ;
76386: LD_VAR 0 4
76390: PUSH
76391: LD_VAR 0 7
76395: ARRAY
76396: PPUSH
76397: LD_VAR 0 22
76401: PPUSH
76402: CALL_OW 113
// continue ;
76406: GO 76033
// end ; end else
76408: GO 76688
// if group [ i ] in repairs then
76410: LD_VAR 0 4
76414: PUSH
76415: LD_VAR 0 7
76419: ARRAY
76420: PUSH
76421: LD_VAR 0 33
76425: IN
76426: IFFALSE 76688
// begin if IsInUnit ( group [ i ] ) then
76428: LD_VAR 0 4
76432: PUSH
76433: LD_VAR 0 7
76437: ARRAY
76438: PPUSH
76439: CALL_OW 310
76443: IFFALSE 76511
// begin z := IsInUnit ( group [ i ] ) ;
76445: LD_ADDR_VAR 0 13
76449: PUSH
76450: LD_VAR 0 4
76454: PUSH
76455: LD_VAR 0 7
76459: ARRAY
76460: PPUSH
76461: CALL_OW 310
76465: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
76466: LD_VAR 0 13
76470: PUSH
76471: LD_VAR 0 32
76475: IN
76476: PUSH
76477: LD_VAR 0 13
76481: PPUSH
76482: LD_VAR 0 22
76486: PPUSH
76487: CALL_OW 308
76491: AND
76492: IFFALSE 76509
// ComExitVehicle ( group [ i ] ) ;
76494: LD_VAR 0 4
76498: PUSH
76499: LD_VAR 0 7
76503: ARRAY
76504: PPUSH
76505: CALL_OW 121
// end else
76509: GO 76688
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
76511: LD_ADDR_VAR 0 13
76515: PUSH
76516: LD_VAR 0 4
76520: PPUSH
76521: LD_INT 95
76523: PUSH
76524: LD_VAR 0 22
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 58
76535: PUSH
76536: EMPTY
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PPUSH
76543: CALL_OW 72
76547: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
76548: LD_VAR 0 4
76552: PUSH
76553: LD_VAR 0 7
76557: ARRAY
76558: PPUSH
76559: CALL_OW 314
76563: NOT
76564: IFFALSE 76686
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
76566: LD_ADDR_VAR 0 10
76570: PUSH
76571: LD_VAR 0 13
76575: PPUSH
76576: LD_VAR 0 4
76580: PUSH
76581: LD_VAR 0 7
76585: ARRAY
76586: PPUSH
76587: CALL_OW 74
76591: ST_TO_ADDR
// if not x then
76592: LD_VAR 0 10
76596: NOT
76597: IFFALSE 76601
// continue ;
76599: GO 76033
// if GetLives ( x ) < 1000 then
76601: LD_VAR 0 10
76605: PPUSH
76606: CALL_OW 256
76610: PUSH
76611: LD_INT 1000
76613: LESS
76614: IFFALSE 76638
// ComRepairVehicle ( group [ i ] , x ) else
76616: LD_VAR 0 4
76620: PUSH
76621: LD_VAR 0 7
76625: ARRAY
76626: PPUSH
76627: LD_VAR 0 10
76631: PPUSH
76632: CALL_OW 129
76636: GO 76686
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
76638: LD_VAR 0 23
76642: PUSH
76643: LD_VAR 0 4
76647: PUSH
76648: LD_VAR 0 7
76652: ARRAY
76653: PPUSH
76654: CALL_OW 256
76658: PUSH
76659: LD_INT 1000
76661: LESS
76662: AND
76663: NOT
76664: IFFALSE 76686
// ComEnterUnit ( group [ i ] , x ) ;
76666: LD_VAR 0 4
76670: PUSH
76671: LD_VAR 0 7
76675: ARRAY
76676: PPUSH
76677: LD_VAR 0 10
76681: PPUSH
76682: CALL_OW 120
// end ; continue ;
76686: GO 76033
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
76688: LD_VAR 0 23
76692: PUSH
76693: LD_VAR 0 4
76697: PUSH
76698: LD_VAR 0 7
76702: ARRAY
76703: PPUSH
76704: CALL_OW 247
76708: PUSH
76709: LD_INT 1
76711: EQUAL
76712: AND
76713: IFFALSE 77191
// begin if group [ i ] in healers then
76715: LD_VAR 0 4
76719: PUSH
76720: LD_VAR 0 7
76724: ARRAY
76725: PUSH
76726: LD_VAR 0 31
76730: IN
76731: IFFALSE 77004
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
76733: LD_VAR 0 4
76737: PUSH
76738: LD_VAR 0 7
76742: ARRAY
76743: PPUSH
76744: LD_VAR 0 23
76748: PPUSH
76749: CALL_OW 308
76753: NOT
76754: PUSH
76755: LD_VAR 0 4
76759: PUSH
76760: LD_VAR 0 7
76764: ARRAY
76765: PPUSH
76766: CALL_OW 314
76770: NOT
76771: AND
76772: IFFALSE 76796
// ComMoveToArea ( group [ i ] , f_heal ) else
76774: LD_VAR 0 4
76778: PUSH
76779: LD_VAR 0 7
76783: ARRAY
76784: PPUSH
76785: LD_VAR 0 23
76789: PPUSH
76790: CALL_OW 113
76794: GO 77002
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
76796: LD_VAR 0 4
76800: PUSH
76801: LD_VAR 0 7
76805: ARRAY
76806: PPUSH
76807: CALL 75414 0 1
76811: PPUSH
76812: CALL_OW 256
76816: PUSH
76817: LD_INT 1000
76819: EQUAL
76820: IFFALSE 76839
// ComStop ( group [ i ] ) else
76822: LD_VAR 0 4
76826: PUSH
76827: LD_VAR 0 7
76831: ARRAY
76832: PPUSH
76833: CALL_OW 141
76837: GO 77002
// if not HasTask ( group [ i ] ) and to_heal then
76839: LD_VAR 0 4
76843: PUSH
76844: LD_VAR 0 7
76848: ARRAY
76849: PPUSH
76850: CALL_OW 314
76854: NOT
76855: PUSH
76856: LD_VAR 0 30
76860: AND
76861: IFFALSE 77002
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
76863: LD_ADDR_VAR 0 13
76867: PUSH
76868: LD_VAR 0 30
76872: PPUSH
76873: LD_INT 3
76875: PUSH
76876: LD_INT 54
76878: PUSH
76879: EMPTY
76880: LIST
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PPUSH
76886: CALL_OW 72
76890: PPUSH
76891: LD_VAR 0 4
76895: PUSH
76896: LD_VAR 0 7
76900: ARRAY
76901: PPUSH
76902: CALL_OW 74
76906: ST_TO_ADDR
// if z then
76907: LD_VAR 0 13
76911: IFFALSE 77002
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
76913: LD_INT 91
76915: PUSH
76916: LD_VAR 0 13
76920: PUSH
76921: LD_INT 10
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 81
76931: PUSH
76932: LD_VAR 0 13
76936: PPUSH
76937: CALL_OW 255
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PPUSH
76950: CALL_OW 69
76954: PUSH
76955: LD_INT 0
76957: EQUAL
76958: IFFALSE 76982
// ComHeal ( group [ i ] , z ) else
76960: LD_VAR 0 4
76964: PUSH
76965: LD_VAR 0 7
76969: ARRAY
76970: PPUSH
76971: LD_VAR 0 13
76975: PPUSH
76976: CALL_OW 128
76980: GO 77002
// ComMoveToArea ( group [ i ] , f_heal ) ;
76982: LD_VAR 0 4
76986: PUSH
76987: LD_VAR 0 7
76991: ARRAY
76992: PPUSH
76993: LD_VAR 0 23
76997: PPUSH
76998: CALL_OW 113
// end ; continue ;
77002: GO 76033
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
77004: LD_VAR 0 4
77008: PUSH
77009: LD_VAR 0 7
77013: ARRAY
77014: PPUSH
77015: CALL_OW 256
77019: PUSH
77020: LD_INT 700
77022: LESS
77023: PUSH
77024: LD_VAR 0 4
77028: PUSH
77029: LD_VAR 0 7
77033: ARRAY
77034: PUSH
77035: LD_VAR 0 30
77039: IN
77040: NOT
77041: AND
77042: IFFALSE 77066
// to_heal := to_heal union group [ i ] ;
77044: LD_ADDR_VAR 0 30
77048: PUSH
77049: LD_VAR 0 30
77053: PUSH
77054: LD_VAR 0 4
77058: PUSH
77059: LD_VAR 0 7
77063: ARRAY
77064: UNION
77065: ST_TO_ADDR
// if group [ i ] in to_heal then
77066: LD_VAR 0 4
77070: PUSH
77071: LD_VAR 0 7
77075: ARRAY
77076: PUSH
77077: LD_VAR 0 30
77081: IN
77082: IFFALSE 77191
// begin if GetLives ( group [ i ] ) = 1000 then
77084: LD_VAR 0 4
77088: PUSH
77089: LD_VAR 0 7
77093: ARRAY
77094: PPUSH
77095: CALL_OW 256
77099: PUSH
77100: LD_INT 1000
77102: EQUAL
77103: IFFALSE 77129
// to_heal := to_heal diff group [ i ] else
77105: LD_ADDR_VAR 0 30
77109: PUSH
77110: LD_VAR 0 30
77114: PUSH
77115: LD_VAR 0 4
77119: PUSH
77120: LD_VAR 0 7
77124: ARRAY
77125: DIFF
77126: ST_TO_ADDR
77127: GO 77191
// begin if not IsInArea ( group [ i ] , to_heal ) then
77129: LD_VAR 0 4
77133: PUSH
77134: LD_VAR 0 7
77138: ARRAY
77139: PPUSH
77140: LD_VAR 0 30
77144: PPUSH
77145: CALL_OW 308
77149: NOT
77150: IFFALSE 77174
// ComMoveToArea ( group [ i ] , f_heal ) else
77152: LD_VAR 0 4
77156: PUSH
77157: LD_VAR 0 7
77161: ARRAY
77162: PPUSH
77163: LD_VAR 0 23
77167: PPUSH
77168: CALL_OW 113
77172: GO 77189
// ComHold ( group [ i ] ) ;
77174: LD_VAR 0 4
77178: PUSH
77179: LD_VAR 0 7
77183: ARRAY
77184: PPUSH
77185: CALL_OW 140
// continue ;
77189: GO 76033
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
77191: LD_VAR 0 4
77195: PUSH
77196: LD_VAR 0 7
77200: ARRAY
77201: PPUSH
77202: LD_INT 10
77204: PPUSH
77205: CALL 73811 0 2
77209: NOT
77210: PUSH
77211: LD_VAR 0 16
77215: PUSH
77216: LD_VAR 0 7
77220: ARRAY
77221: PUSH
77222: EMPTY
77223: EQUAL
77224: NOT
77225: AND
77226: IFFALSE 77492
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
77228: LD_VAR 0 4
77232: PUSH
77233: LD_VAR 0 7
77237: ARRAY
77238: PPUSH
77239: CALL_OW 262
77243: PUSH
77244: LD_INT 1
77246: PUSH
77247: LD_INT 2
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: IN
77254: IFFALSE 77295
// if GetFuel ( group [ i ] ) < 10 then
77256: LD_VAR 0 4
77260: PUSH
77261: LD_VAR 0 7
77265: ARRAY
77266: PPUSH
77267: CALL_OW 261
77271: PUSH
77272: LD_INT 10
77274: LESS
77275: IFFALSE 77295
// SetFuel ( group [ i ] , 12 ) ;
77277: LD_VAR 0 4
77281: PUSH
77282: LD_VAR 0 7
77286: ARRAY
77287: PPUSH
77288: LD_INT 12
77290: PPUSH
77291: CALL_OW 240
// if units_path [ i ] then
77295: LD_VAR 0 16
77299: PUSH
77300: LD_VAR 0 7
77304: ARRAY
77305: IFFALSE 77490
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
77307: LD_VAR 0 4
77311: PUSH
77312: LD_VAR 0 7
77316: ARRAY
77317: PPUSH
77318: LD_VAR 0 16
77322: PUSH
77323: LD_VAR 0 7
77327: ARRAY
77328: PUSH
77329: LD_INT 1
77331: ARRAY
77332: PUSH
77333: LD_INT 1
77335: ARRAY
77336: PPUSH
77337: LD_VAR 0 16
77341: PUSH
77342: LD_VAR 0 7
77346: ARRAY
77347: PUSH
77348: LD_INT 1
77350: ARRAY
77351: PUSH
77352: LD_INT 2
77354: ARRAY
77355: PPUSH
77356: CALL_OW 297
77360: PUSH
77361: LD_INT 6
77363: GREATER
77364: IFFALSE 77439
// begin if not HasTask ( group [ i ] ) then
77366: LD_VAR 0 4
77370: PUSH
77371: LD_VAR 0 7
77375: ARRAY
77376: PPUSH
77377: CALL_OW 314
77381: NOT
77382: IFFALSE 77437
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
77384: LD_VAR 0 4
77388: PUSH
77389: LD_VAR 0 7
77393: ARRAY
77394: PPUSH
77395: LD_VAR 0 16
77399: PUSH
77400: LD_VAR 0 7
77404: ARRAY
77405: PUSH
77406: LD_INT 1
77408: ARRAY
77409: PUSH
77410: LD_INT 1
77412: ARRAY
77413: PPUSH
77414: LD_VAR 0 16
77418: PUSH
77419: LD_VAR 0 7
77423: ARRAY
77424: PUSH
77425: LD_INT 1
77427: ARRAY
77428: PUSH
77429: LD_INT 2
77431: ARRAY
77432: PPUSH
77433: CALL_OW 114
// end else
77437: GO 77490
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
77439: LD_ADDR_VAR 0 15
77443: PUSH
77444: LD_VAR 0 16
77448: PUSH
77449: LD_VAR 0 7
77453: ARRAY
77454: PPUSH
77455: LD_INT 1
77457: PPUSH
77458: CALL_OW 3
77462: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
77463: LD_ADDR_VAR 0 16
77467: PUSH
77468: LD_VAR 0 16
77472: PPUSH
77473: LD_VAR 0 7
77477: PPUSH
77478: LD_VAR 0 15
77482: PPUSH
77483: CALL_OW 1
77487: ST_TO_ADDR
// continue ;
77488: GO 76033
// end ; end ; end else
77490: GO 80128
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
77492: LD_ADDR_VAR 0 14
77496: PUSH
77497: LD_INT 81
77499: PUSH
77500: LD_VAR 0 4
77504: PUSH
77505: LD_VAR 0 7
77509: ARRAY
77510: PPUSH
77511: CALL_OW 255
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PPUSH
77520: CALL_OW 69
77524: ST_TO_ADDR
// if not tmp then
77525: LD_VAR 0 14
77529: NOT
77530: IFFALSE 77534
// continue ;
77532: GO 76033
// if f_ignore_area then
77534: LD_VAR 0 17
77538: IFFALSE 77626
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
77540: LD_ADDR_VAR 0 15
77544: PUSH
77545: LD_VAR 0 14
77549: PPUSH
77550: LD_INT 3
77552: PUSH
77553: LD_INT 92
77555: PUSH
77556: LD_VAR 0 17
77560: PUSH
77561: LD_INT 1
77563: ARRAY
77564: PUSH
77565: LD_VAR 0 17
77569: PUSH
77570: LD_INT 2
77572: ARRAY
77573: PUSH
77574: LD_VAR 0 17
77578: PUSH
77579: LD_INT 3
77581: ARRAY
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PPUSH
77593: CALL_OW 72
77597: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
77598: LD_VAR 0 14
77602: PUSH
77603: LD_VAR 0 15
77607: DIFF
77608: IFFALSE 77626
// tmp := tmp diff tmp2 ;
77610: LD_ADDR_VAR 0 14
77614: PUSH
77615: LD_VAR 0 14
77619: PUSH
77620: LD_VAR 0 15
77624: DIFF
77625: ST_TO_ADDR
// end ; if not f_murder then
77626: LD_VAR 0 20
77630: NOT
77631: IFFALSE 77689
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
77633: LD_ADDR_VAR 0 15
77637: PUSH
77638: LD_VAR 0 14
77642: PPUSH
77643: LD_INT 3
77645: PUSH
77646: LD_INT 50
77648: PUSH
77649: EMPTY
77650: LIST
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PPUSH
77656: CALL_OW 72
77660: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
77661: LD_VAR 0 14
77665: PUSH
77666: LD_VAR 0 15
77670: DIFF
77671: IFFALSE 77689
// tmp := tmp diff tmp2 ;
77673: LD_ADDR_VAR 0 14
77677: PUSH
77678: LD_VAR 0 14
77682: PUSH
77683: LD_VAR 0 15
77687: DIFF
77688: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
77689: LD_ADDR_VAR 0 14
77693: PUSH
77694: LD_VAR 0 4
77698: PUSH
77699: LD_VAR 0 7
77703: ARRAY
77704: PPUSH
77705: LD_VAR 0 14
77709: PPUSH
77710: LD_INT 1
77712: PPUSH
77713: LD_INT 1
77715: PPUSH
77716: CALL 47454 0 4
77720: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
77721: LD_VAR 0 4
77725: PUSH
77726: LD_VAR 0 7
77730: ARRAY
77731: PPUSH
77732: CALL_OW 257
77736: PUSH
77737: LD_INT 1
77739: EQUAL
77740: IFFALSE 78188
// begin if WantPlant ( group [ i ] ) then
77742: LD_VAR 0 4
77746: PUSH
77747: LD_VAR 0 7
77751: ARRAY
77752: PPUSH
77753: CALL 46955 0 1
77757: IFFALSE 77761
// continue ;
77759: GO 76033
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
77761: LD_VAR 0 18
77765: PUSH
77766: LD_VAR 0 4
77770: PUSH
77771: LD_VAR 0 7
77775: ARRAY
77776: PPUSH
77777: CALL_OW 310
77781: NOT
77782: AND
77783: PUSH
77784: LD_VAR 0 14
77788: PUSH
77789: LD_INT 1
77791: ARRAY
77792: PUSH
77793: LD_VAR 0 14
77797: PPUSH
77798: LD_INT 21
77800: PUSH
77801: LD_INT 2
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 58
77810: PUSH
77811: EMPTY
77812: LIST
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PPUSH
77818: CALL_OW 72
77822: IN
77823: AND
77824: IFFALSE 77860
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
77826: LD_VAR 0 4
77830: PUSH
77831: LD_VAR 0 7
77835: ARRAY
77836: PPUSH
77837: LD_VAR 0 14
77841: PUSH
77842: LD_INT 1
77844: ARRAY
77845: PPUSH
77846: CALL_OW 120
// attacking := true ;
77850: LD_ADDR_VAR 0 29
77854: PUSH
77855: LD_INT 1
77857: ST_TO_ADDR
// continue ;
77858: GO 76033
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
77860: LD_VAR 0 26
77864: PUSH
77865: LD_VAR 0 4
77869: PUSH
77870: LD_VAR 0 7
77874: ARRAY
77875: PPUSH
77876: CALL_OW 257
77880: PUSH
77881: LD_INT 1
77883: EQUAL
77884: AND
77885: PUSH
77886: LD_VAR 0 4
77890: PUSH
77891: LD_VAR 0 7
77895: ARRAY
77896: PPUSH
77897: CALL_OW 256
77901: PUSH
77902: LD_INT 800
77904: LESS
77905: AND
77906: PUSH
77907: LD_VAR 0 4
77911: PUSH
77912: LD_VAR 0 7
77916: ARRAY
77917: PPUSH
77918: CALL_OW 318
77922: NOT
77923: AND
77924: IFFALSE 77941
// ComCrawl ( group [ i ] ) ;
77926: LD_VAR 0 4
77930: PUSH
77931: LD_VAR 0 7
77935: ARRAY
77936: PPUSH
77937: CALL_OW 137
// if f_mines then
77941: LD_VAR 0 21
77945: IFFALSE 78188
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
77947: LD_VAR 0 14
77951: PUSH
77952: LD_INT 1
77954: ARRAY
77955: PPUSH
77956: CALL_OW 247
77960: PUSH
77961: LD_INT 3
77963: EQUAL
77964: PUSH
77965: LD_VAR 0 14
77969: PUSH
77970: LD_INT 1
77972: ARRAY
77973: PUSH
77974: LD_VAR 0 27
77978: IN
77979: NOT
77980: AND
77981: IFFALSE 78188
// begin x := GetX ( tmp [ 1 ] ) ;
77983: LD_ADDR_VAR 0 10
77987: PUSH
77988: LD_VAR 0 14
77992: PUSH
77993: LD_INT 1
77995: ARRAY
77996: PPUSH
77997: CALL_OW 250
78001: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
78002: LD_ADDR_VAR 0 11
78006: PUSH
78007: LD_VAR 0 14
78011: PUSH
78012: LD_INT 1
78014: ARRAY
78015: PPUSH
78016: CALL_OW 251
78020: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
78021: LD_ADDR_VAR 0 12
78025: PUSH
78026: LD_VAR 0 4
78030: PUSH
78031: LD_VAR 0 7
78035: ARRAY
78036: PPUSH
78037: CALL 73896 0 1
78041: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
78042: LD_VAR 0 4
78046: PUSH
78047: LD_VAR 0 7
78051: ARRAY
78052: PPUSH
78053: LD_VAR 0 10
78057: PPUSH
78058: LD_VAR 0 11
78062: PPUSH
78063: LD_VAR 0 14
78067: PUSH
78068: LD_INT 1
78070: ARRAY
78071: PPUSH
78072: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
78076: LD_VAR 0 4
78080: PUSH
78081: LD_VAR 0 7
78085: ARRAY
78086: PPUSH
78087: LD_VAR 0 10
78091: PPUSH
78092: LD_VAR 0 12
78096: PPUSH
78097: LD_INT 7
78099: PPUSH
78100: CALL_OW 272
78104: PPUSH
78105: LD_VAR 0 11
78109: PPUSH
78110: LD_VAR 0 12
78114: PPUSH
78115: LD_INT 7
78117: PPUSH
78118: CALL_OW 273
78122: PPUSH
78123: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
78127: LD_VAR 0 4
78131: PUSH
78132: LD_VAR 0 7
78136: ARRAY
78137: PPUSH
78138: LD_INT 71
78140: PPUSH
78141: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
78145: LD_ADDR_VAR 0 27
78149: PUSH
78150: LD_VAR 0 27
78154: PPUSH
78155: LD_VAR 0 27
78159: PUSH
78160: LD_INT 1
78162: PLUS
78163: PPUSH
78164: LD_VAR 0 14
78168: PUSH
78169: LD_INT 1
78171: ARRAY
78172: PPUSH
78173: CALL_OW 1
78177: ST_TO_ADDR
// attacking := true ;
78178: LD_ADDR_VAR 0 29
78182: PUSH
78183: LD_INT 1
78185: ST_TO_ADDR
// continue ;
78186: GO 76033
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
78188: LD_VAR 0 4
78192: PUSH
78193: LD_VAR 0 7
78197: ARRAY
78198: PPUSH
78199: CALL_OW 257
78203: PUSH
78204: LD_INT 17
78206: EQUAL
78207: PUSH
78208: LD_VAR 0 4
78212: PUSH
78213: LD_VAR 0 7
78217: ARRAY
78218: PPUSH
78219: CALL_OW 110
78223: PUSH
78224: LD_INT 71
78226: EQUAL
78227: NOT
78228: AND
78229: IFFALSE 78375
// begin attacking := false ;
78231: LD_ADDR_VAR 0 29
78235: PUSH
78236: LD_INT 0
78238: ST_TO_ADDR
// k := 5 ;
78239: LD_ADDR_VAR 0 9
78243: PUSH
78244: LD_INT 5
78246: ST_TO_ADDR
// if tmp < k then
78247: LD_VAR 0 14
78251: PUSH
78252: LD_VAR 0 9
78256: LESS
78257: IFFALSE 78269
// k := tmp ;
78259: LD_ADDR_VAR 0 9
78263: PUSH
78264: LD_VAR 0 14
78268: ST_TO_ADDR
// for j = 1 to k do
78269: LD_ADDR_VAR 0 8
78273: PUSH
78274: DOUBLE
78275: LD_INT 1
78277: DEC
78278: ST_TO_ADDR
78279: LD_VAR 0 9
78283: PUSH
78284: FOR_TO
78285: IFFALSE 78373
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
78287: LD_VAR 0 14
78291: PUSH
78292: LD_VAR 0 8
78296: ARRAY
78297: PUSH
78298: LD_VAR 0 14
78302: PPUSH
78303: LD_INT 58
78305: PUSH
78306: EMPTY
78307: LIST
78308: PPUSH
78309: CALL_OW 72
78313: IN
78314: NOT
78315: IFFALSE 78371
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
78317: LD_VAR 0 4
78321: PUSH
78322: LD_VAR 0 7
78326: ARRAY
78327: PPUSH
78328: LD_VAR 0 14
78332: PUSH
78333: LD_VAR 0 8
78337: ARRAY
78338: PPUSH
78339: CALL_OW 115
// attacking := true ;
78343: LD_ADDR_VAR 0 29
78347: PUSH
78348: LD_INT 1
78350: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
78351: LD_VAR 0 4
78355: PUSH
78356: LD_VAR 0 7
78360: ARRAY
78361: PPUSH
78362: LD_INT 71
78364: PPUSH
78365: CALL_OW 109
// continue ;
78369: GO 78284
// end ; end ;
78371: GO 78284
78373: POP
78374: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
78375: LD_VAR 0 4
78379: PUSH
78380: LD_VAR 0 7
78384: ARRAY
78385: PPUSH
78386: CALL_OW 257
78390: PUSH
78391: LD_INT 8
78393: EQUAL
78394: PUSH
78395: LD_VAR 0 4
78399: PUSH
78400: LD_VAR 0 7
78404: ARRAY
78405: PPUSH
78406: CALL_OW 264
78410: PUSH
78411: LD_INT 28
78413: PUSH
78414: LD_INT 45
78416: PUSH
78417: LD_INT 7
78419: PUSH
78420: LD_INT 47
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: IN
78429: OR
78430: IFFALSE 78660
// begin attacking := false ;
78432: LD_ADDR_VAR 0 29
78436: PUSH
78437: LD_INT 0
78439: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
78440: LD_VAR 0 14
78444: PUSH
78445: LD_INT 1
78447: ARRAY
78448: PPUSH
78449: CALL_OW 266
78453: PUSH
78454: LD_INT 32
78456: PUSH
78457: LD_INT 31
78459: PUSH
78460: LD_INT 33
78462: PUSH
78463: LD_INT 4
78465: PUSH
78466: LD_INT 5
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: IN
78476: IFFALSE 78660
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
78478: LD_ADDR_VAR 0 9
78482: PUSH
78483: LD_VAR 0 14
78487: PUSH
78488: LD_INT 1
78490: ARRAY
78491: PPUSH
78492: CALL_OW 266
78496: PPUSH
78497: LD_VAR 0 14
78501: PUSH
78502: LD_INT 1
78504: ARRAY
78505: PPUSH
78506: CALL_OW 250
78510: PPUSH
78511: LD_VAR 0 14
78515: PUSH
78516: LD_INT 1
78518: ARRAY
78519: PPUSH
78520: CALL_OW 251
78524: PPUSH
78525: LD_VAR 0 14
78529: PUSH
78530: LD_INT 1
78532: ARRAY
78533: PPUSH
78534: CALL_OW 254
78538: PPUSH
78539: LD_VAR 0 14
78543: PUSH
78544: LD_INT 1
78546: ARRAY
78547: PPUSH
78548: CALL_OW 248
78552: PPUSH
78553: LD_INT 0
78555: PPUSH
78556: CALL 55266 0 6
78560: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
78561: LD_ADDR_VAR 0 8
78565: PUSH
78566: LD_VAR 0 4
78570: PUSH
78571: LD_VAR 0 7
78575: ARRAY
78576: PPUSH
78577: LD_VAR 0 9
78581: PPUSH
78582: CALL 73959 0 2
78586: ST_TO_ADDR
// if j then
78587: LD_VAR 0 8
78591: IFFALSE 78660
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78593: LD_VAR 0 8
78597: PUSH
78598: LD_INT 1
78600: ARRAY
78601: PPUSH
78602: LD_VAR 0 8
78606: PUSH
78607: LD_INT 2
78609: ARRAY
78610: PPUSH
78611: CALL_OW 488
78615: IFFALSE 78660
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
78617: LD_VAR 0 4
78621: PUSH
78622: LD_VAR 0 7
78626: ARRAY
78627: PPUSH
78628: LD_VAR 0 8
78632: PUSH
78633: LD_INT 1
78635: ARRAY
78636: PPUSH
78637: LD_VAR 0 8
78641: PUSH
78642: LD_INT 2
78644: ARRAY
78645: PPUSH
78646: CALL_OW 116
// attacking := true ;
78650: LD_ADDR_VAR 0 29
78654: PUSH
78655: LD_INT 1
78657: ST_TO_ADDR
// continue ;
78658: GO 76033
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
78660: LD_VAR 0 4
78664: PUSH
78665: LD_VAR 0 7
78669: ARRAY
78670: PPUSH
78671: CALL_OW 265
78675: PUSH
78676: LD_INT 11
78678: EQUAL
78679: IFFALSE 78957
// begin k := 10 ;
78681: LD_ADDR_VAR 0 9
78685: PUSH
78686: LD_INT 10
78688: ST_TO_ADDR
// x := 0 ;
78689: LD_ADDR_VAR 0 10
78693: PUSH
78694: LD_INT 0
78696: ST_TO_ADDR
// if tmp < k then
78697: LD_VAR 0 14
78701: PUSH
78702: LD_VAR 0 9
78706: LESS
78707: IFFALSE 78719
// k := tmp ;
78709: LD_ADDR_VAR 0 9
78713: PUSH
78714: LD_VAR 0 14
78718: ST_TO_ADDR
// for j = k downto 1 do
78719: LD_ADDR_VAR 0 8
78723: PUSH
78724: DOUBLE
78725: LD_VAR 0 9
78729: INC
78730: ST_TO_ADDR
78731: LD_INT 1
78733: PUSH
78734: FOR_DOWNTO
78735: IFFALSE 78810
// begin if GetType ( tmp [ j ] ) = unit_human then
78737: LD_VAR 0 14
78741: PUSH
78742: LD_VAR 0 8
78746: ARRAY
78747: PPUSH
78748: CALL_OW 247
78752: PUSH
78753: LD_INT 1
78755: EQUAL
78756: IFFALSE 78808
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
78758: LD_VAR 0 4
78762: PUSH
78763: LD_VAR 0 7
78767: ARRAY
78768: PPUSH
78769: LD_VAR 0 14
78773: PUSH
78774: LD_VAR 0 8
78778: ARRAY
78779: PPUSH
78780: CALL 74230 0 2
// x := tmp [ j ] ;
78784: LD_ADDR_VAR 0 10
78788: PUSH
78789: LD_VAR 0 14
78793: PUSH
78794: LD_VAR 0 8
78798: ARRAY
78799: ST_TO_ADDR
// attacking := true ;
78800: LD_ADDR_VAR 0 29
78804: PUSH
78805: LD_INT 1
78807: ST_TO_ADDR
// end ; end ;
78808: GO 78734
78810: POP
78811: POP
// if not x then
78812: LD_VAR 0 10
78816: NOT
78817: IFFALSE 78957
// begin attacking := true ;
78819: LD_ADDR_VAR 0 29
78823: PUSH
78824: LD_INT 1
78826: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
78827: LD_VAR 0 4
78831: PUSH
78832: LD_VAR 0 7
78836: ARRAY
78837: PPUSH
78838: CALL_OW 250
78842: PPUSH
78843: LD_VAR 0 4
78847: PUSH
78848: LD_VAR 0 7
78852: ARRAY
78853: PPUSH
78854: CALL_OW 251
78858: PPUSH
78859: CALL_OW 546
78863: PUSH
78864: LD_INT 2
78866: ARRAY
78867: PUSH
78868: LD_VAR 0 14
78872: PUSH
78873: LD_INT 1
78875: ARRAY
78876: PPUSH
78877: CALL_OW 250
78881: PPUSH
78882: LD_VAR 0 14
78886: PUSH
78887: LD_INT 1
78889: ARRAY
78890: PPUSH
78891: CALL_OW 251
78895: PPUSH
78896: CALL_OW 546
78900: PUSH
78901: LD_INT 2
78903: ARRAY
78904: EQUAL
78905: IFFALSE 78933
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
78907: LD_VAR 0 4
78911: PUSH
78912: LD_VAR 0 7
78916: ARRAY
78917: PPUSH
78918: LD_VAR 0 14
78922: PUSH
78923: LD_INT 1
78925: ARRAY
78926: PPUSH
78927: CALL 74230 0 2
78931: GO 78957
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
78933: LD_VAR 0 4
78937: PUSH
78938: LD_VAR 0 7
78942: ARRAY
78943: PPUSH
78944: LD_VAR 0 14
78948: PUSH
78949: LD_INT 1
78951: ARRAY
78952: PPUSH
78953: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
78957: LD_VAR 0 4
78961: PUSH
78962: LD_VAR 0 7
78966: ARRAY
78967: PPUSH
78968: CALL_OW 264
78972: PUSH
78973: LD_INT 29
78975: EQUAL
78976: IFFALSE 79342
// begin if WantsToAttack ( group [ i ] ) in bombed then
78978: LD_VAR 0 4
78982: PUSH
78983: LD_VAR 0 7
78987: ARRAY
78988: PPUSH
78989: CALL_OW 319
78993: PUSH
78994: LD_VAR 0 28
78998: IN
78999: IFFALSE 79003
// continue ;
79001: GO 76033
// k := 8 ;
79003: LD_ADDR_VAR 0 9
79007: PUSH
79008: LD_INT 8
79010: ST_TO_ADDR
// x := 0 ;
79011: LD_ADDR_VAR 0 10
79015: PUSH
79016: LD_INT 0
79018: ST_TO_ADDR
// if tmp < k then
79019: LD_VAR 0 14
79023: PUSH
79024: LD_VAR 0 9
79028: LESS
79029: IFFALSE 79041
// k := tmp ;
79031: LD_ADDR_VAR 0 9
79035: PUSH
79036: LD_VAR 0 14
79040: ST_TO_ADDR
// for j = 1 to k do
79041: LD_ADDR_VAR 0 8
79045: PUSH
79046: DOUBLE
79047: LD_INT 1
79049: DEC
79050: ST_TO_ADDR
79051: LD_VAR 0 9
79055: PUSH
79056: FOR_TO
79057: IFFALSE 79189
// begin if GetType ( tmp [ j ] ) = unit_building then
79059: LD_VAR 0 14
79063: PUSH
79064: LD_VAR 0 8
79068: ARRAY
79069: PPUSH
79070: CALL_OW 247
79074: PUSH
79075: LD_INT 3
79077: EQUAL
79078: IFFALSE 79187
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
79080: LD_VAR 0 14
79084: PUSH
79085: LD_VAR 0 8
79089: ARRAY
79090: PUSH
79091: LD_VAR 0 28
79095: IN
79096: NOT
79097: PUSH
79098: LD_VAR 0 14
79102: PUSH
79103: LD_VAR 0 8
79107: ARRAY
79108: PPUSH
79109: CALL_OW 313
79113: AND
79114: IFFALSE 79187
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79116: LD_VAR 0 4
79120: PUSH
79121: LD_VAR 0 7
79125: ARRAY
79126: PPUSH
79127: LD_VAR 0 14
79131: PUSH
79132: LD_VAR 0 8
79136: ARRAY
79137: PPUSH
79138: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
79142: LD_ADDR_VAR 0 28
79146: PUSH
79147: LD_VAR 0 28
79151: PPUSH
79152: LD_VAR 0 28
79156: PUSH
79157: LD_INT 1
79159: PLUS
79160: PPUSH
79161: LD_VAR 0 14
79165: PUSH
79166: LD_VAR 0 8
79170: ARRAY
79171: PPUSH
79172: CALL_OW 1
79176: ST_TO_ADDR
// attacking := true ;
79177: LD_ADDR_VAR 0 29
79181: PUSH
79182: LD_INT 1
79184: ST_TO_ADDR
// break ;
79185: GO 79189
// end ; end ;
79187: GO 79056
79189: POP
79190: POP
// if not attacking and f_attack_depot then
79191: LD_VAR 0 29
79195: NOT
79196: PUSH
79197: LD_VAR 0 25
79201: AND
79202: IFFALSE 79297
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79204: LD_ADDR_VAR 0 13
79208: PUSH
79209: LD_VAR 0 14
79213: PPUSH
79214: LD_INT 2
79216: PUSH
79217: LD_INT 30
79219: PUSH
79220: LD_INT 0
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 30
79229: PUSH
79230: LD_INT 1
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: LIST
79241: PPUSH
79242: CALL_OW 72
79246: ST_TO_ADDR
// if z then
79247: LD_VAR 0 13
79251: IFFALSE 79297
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
79253: LD_VAR 0 4
79257: PUSH
79258: LD_VAR 0 7
79262: ARRAY
79263: PPUSH
79264: LD_VAR 0 13
79268: PPUSH
79269: LD_VAR 0 4
79273: PUSH
79274: LD_VAR 0 7
79278: ARRAY
79279: PPUSH
79280: CALL_OW 74
79284: PPUSH
79285: CALL_OW 115
// attacking := true ;
79289: LD_ADDR_VAR 0 29
79293: PUSH
79294: LD_INT 1
79296: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
79297: LD_VAR 0 4
79301: PUSH
79302: LD_VAR 0 7
79306: ARRAY
79307: PPUSH
79308: CALL_OW 256
79312: PUSH
79313: LD_INT 500
79315: LESS
79316: IFFALSE 79342
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79318: LD_VAR 0 4
79322: PUSH
79323: LD_VAR 0 7
79327: ARRAY
79328: PPUSH
79329: LD_VAR 0 14
79333: PUSH
79334: LD_INT 1
79336: ARRAY
79337: PPUSH
79338: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
79342: LD_VAR 0 4
79346: PUSH
79347: LD_VAR 0 7
79351: ARRAY
79352: PPUSH
79353: CALL_OW 264
79357: PUSH
79358: LD_INT 49
79360: EQUAL
79361: IFFALSE 79482
// begin if not HasTask ( group [ i ] ) then
79363: LD_VAR 0 4
79367: PUSH
79368: LD_VAR 0 7
79372: ARRAY
79373: PPUSH
79374: CALL_OW 314
79378: NOT
79379: IFFALSE 79482
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
79381: LD_ADDR_VAR 0 9
79385: PUSH
79386: LD_INT 81
79388: PUSH
79389: LD_VAR 0 4
79393: PUSH
79394: LD_VAR 0 7
79398: ARRAY
79399: PPUSH
79400: CALL_OW 255
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PPUSH
79409: CALL_OW 69
79413: PPUSH
79414: LD_VAR 0 4
79418: PUSH
79419: LD_VAR 0 7
79423: ARRAY
79424: PPUSH
79425: CALL_OW 74
79429: ST_TO_ADDR
// if k then
79430: LD_VAR 0 9
79434: IFFALSE 79482
// if GetDistUnits ( group [ i ] , k ) > 10 then
79436: LD_VAR 0 4
79440: PUSH
79441: LD_VAR 0 7
79445: ARRAY
79446: PPUSH
79447: LD_VAR 0 9
79451: PPUSH
79452: CALL_OW 296
79456: PUSH
79457: LD_INT 10
79459: GREATER
79460: IFFALSE 79482
// ComMoveUnit ( group [ i ] , k ) ;
79462: LD_VAR 0 4
79466: PUSH
79467: LD_VAR 0 7
79471: ARRAY
79472: PPUSH
79473: LD_VAR 0 9
79477: PPUSH
79478: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79482: LD_VAR 0 4
79486: PUSH
79487: LD_VAR 0 7
79491: ARRAY
79492: PPUSH
79493: CALL_OW 256
79497: PUSH
79498: LD_INT 250
79500: LESS
79501: PUSH
79502: LD_VAR 0 4
79506: PUSH
79507: LD_VAR 0 7
79511: ARRAY
79512: PUSH
79513: LD_INT 21
79515: PUSH
79516: LD_INT 2
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 23
79525: PUSH
79526: LD_INT 2
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PPUSH
79537: CALL_OW 69
79541: IN
79542: AND
79543: IFFALSE 79668
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
79545: LD_ADDR_VAR 0 9
79549: PUSH
79550: LD_OWVAR 3
79554: PUSH
79555: LD_VAR 0 4
79559: PUSH
79560: LD_VAR 0 7
79564: ARRAY
79565: DIFF
79566: PPUSH
79567: LD_VAR 0 4
79571: PUSH
79572: LD_VAR 0 7
79576: ARRAY
79577: PPUSH
79578: CALL_OW 74
79582: ST_TO_ADDR
// if not k then
79583: LD_VAR 0 9
79587: NOT
79588: IFFALSE 79592
// continue ;
79590: GO 76033
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
79592: LD_VAR 0 9
79596: PUSH
79597: LD_INT 81
79599: PUSH
79600: LD_VAR 0 4
79604: PUSH
79605: LD_VAR 0 7
79609: ARRAY
79610: PPUSH
79611: CALL_OW 255
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PPUSH
79620: CALL_OW 69
79624: IN
79625: PUSH
79626: LD_VAR 0 9
79630: PPUSH
79631: LD_VAR 0 4
79635: PUSH
79636: LD_VAR 0 7
79640: ARRAY
79641: PPUSH
79642: CALL_OW 296
79646: PUSH
79647: LD_INT 5
79649: LESS
79650: AND
79651: IFFALSE 79668
// ComAutodestruct ( group [ i ] ) ;
79653: LD_VAR 0 4
79657: PUSH
79658: LD_VAR 0 7
79662: ARRAY
79663: PPUSH
79664: CALL 74128 0 1
// end ; if f_attack_depot then
79668: LD_VAR 0 25
79672: IFFALSE 79784
// begin k := 6 ;
79674: LD_ADDR_VAR 0 9
79678: PUSH
79679: LD_INT 6
79681: ST_TO_ADDR
// if tmp < k then
79682: LD_VAR 0 14
79686: PUSH
79687: LD_VAR 0 9
79691: LESS
79692: IFFALSE 79704
// k := tmp ;
79694: LD_ADDR_VAR 0 9
79698: PUSH
79699: LD_VAR 0 14
79703: ST_TO_ADDR
// for j = 1 to k do
79704: LD_ADDR_VAR 0 8
79708: PUSH
79709: DOUBLE
79710: LD_INT 1
79712: DEC
79713: ST_TO_ADDR
79714: LD_VAR 0 9
79718: PUSH
79719: FOR_TO
79720: IFFALSE 79782
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
79722: LD_VAR 0 8
79726: PPUSH
79727: CALL_OW 266
79731: PUSH
79732: LD_INT 0
79734: PUSH
79735: LD_INT 1
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: IN
79742: IFFALSE 79780
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79744: LD_VAR 0 4
79748: PUSH
79749: LD_VAR 0 7
79753: ARRAY
79754: PPUSH
79755: LD_VAR 0 14
79759: PUSH
79760: LD_VAR 0 8
79764: ARRAY
79765: PPUSH
79766: CALL_OW 115
// attacking := true ;
79770: LD_ADDR_VAR 0 29
79774: PUSH
79775: LD_INT 1
79777: ST_TO_ADDR
// break ;
79778: GO 79782
// end ;
79780: GO 79719
79782: POP
79783: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
79784: LD_VAR 0 4
79788: PUSH
79789: LD_VAR 0 7
79793: ARRAY
79794: PPUSH
79795: CALL_OW 302
79799: PUSH
79800: LD_VAR 0 29
79804: NOT
79805: AND
79806: IFFALSE 80128
// begin if GetTag ( group [ i ] ) = 71 then
79808: LD_VAR 0 4
79812: PUSH
79813: LD_VAR 0 7
79817: ARRAY
79818: PPUSH
79819: CALL_OW 110
79823: PUSH
79824: LD_INT 71
79826: EQUAL
79827: IFFALSE 79868
// begin if HasTask ( group [ i ] ) then
79829: LD_VAR 0 4
79833: PUSH
79834: LD_VAR 0 7
79838: ARRAY
79839: PPUSH
79840: CALL_OW 314
79844: IFFALSE 79850
// continue else
79846: GO 76033
79848: GO 79868
// SetTag ( group [ i ] , 0 ) ;
79850: LD_VAR 0 4
79854: PUSH
79855: LD_VAR 0 7
79859: ARRAY
79860: PPUSH
79861: LD_INT 0
79863: PPUSH
79864: CALL_OW 109
// end ; k := 8 ;
79868: LD_ADDR_VAR 0 9
79872: PUSH
79873: LD_INT 8
79875: ST_TO_ADDR
// x := 0 ;
79876: LD_ADDR_VAR 0 10
79880: PUSH
79881: LD_INT 0
79883: ST_TO_ADDR
// if tmp < k then
79884: LD_VAR 0 14
79888: PUSH
79889: LD_VAR 0 9
79893: LESS
79894: IFFALSE 79906
// k := tmp ;
79896: LD_ADDR_VAR 0 9
79900: PUSH
79901: LD_VAR 0 14
79905: ST_TO_ADDR
// for j = 1 to k do
79906: LD_ADDR_VAR 0 8
79910: PUSH
79911: DOUBLE
79912: LD_INT 1
79914: DEC
79915: ST_TO_ADDR
79916: LD_VAR 0 9
79920: PUSH
79921: FOR_TO
79922: IFFALSE 80020
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
79924: LD_VAR 0 14
79928: PUSH
79929: LD_VAR 0 8
79933: ARRAY
79934: PPUSH
79935: CALL_OW 247
79939: PUSH
79940: LD_INT 1
79942: EQUAL
79943: PUSH
79944: LD_VAR 0 14
79948: PUSH
79949: LD_VAR 0 8
79953: ARRAY
79954: PPUSH
79955: CALL_OW 256
79959: PUSH
79960: LD_INT 250
79962: LESS
79963: PUSH
79964: LD_VAR 0 20
79968: AND
79969: PUSH
79970: LD_VAR 0 20
79974: NOT
79975: PUSH
79976: LD_VAR 0 14
79980: PUSH
79981: LD_VAR 0 8
79985: ARRAY
79986: PPUSH
79987: CALL_OW 256
79991: PUSH
79992: LD_INT 250
79994: GREATEREQUAL
79995: AND
79996: OR
79997: AND
79998: IFFALSE 80018
// begin x := tmp [ j ] ;
80000: LD_ADDR_VAR 0 10
80004: PUSH
80005: LD_VAR 0 14
80009: PUSH
80010: LD_VAR 0 8
80014: ARRAY
80015: ST_TO_ADDR
// break ;
80016: GO 80020
// end ;
80018: GO 79921
80020: POP
80021: POP
// if x then
80022: LD_VAR 0 10
80026: IFFALSE 80050
// ComAttackUnit ( group [ i ] , x ) else
80028: LD_VAR 0 4
80032: PUSH
80033: LD_VAR 0 7
80037: ARRAY
80038: PPUSH
80039: LD_VAR 0 10
80043: PPUSH
80044: CALL_OW 115
80048: GO 80074
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80050: LD_VAR 0 4
80054: PUSH
80055: LD_VAR 0 7
80059: ARRAY
80060: PPUSH
80061: LD_VAR 0 14
80065: PUSH
80066: LD_INT 1
80068: ARRAY
80069: PPUSH
80070: CALL_OW 115
// if not HasTask ( group [ i ] ) then
80074: LD_VAR 0 4
80078: PUSH
80079: LD_VAR 0 7
80083: ARRAY
80084: PPUSH
80085: CALL_OW 314
80089: NOT
80090: IFFALSE 80128
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
80092: LD_VAR 0 4
80096: PUSH
80097: LD_VAR 0 7
80101: ARRAY
80102: PPUSH
80103: LD_VAR 0 14
80107: PPUSH
80108: LD_VAR 0 4
80112: PUSH
80113: LD_VAR 0 7
80117: ARRAY
80118: PPUSH
80119: CALL_OW 74
80123: PPUSH
80124: CALL_OW 115
// end ; end ; end ;
80128: GO 76033
80130: POP
80131: POP
// wait ( 0 0$1 ) ;
80132: LD_INT 35
80134: PPUSH
80135: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
80139: LD_VAR 0 4
80143: PUSH
80144: EMPTY
80145: EQUAL
80146: PUSH
80147: LD_INT 81
80149: PUSH
80150: LD_VAR 0 35
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PPUSH
80159: CALL_OW 69
80163: NOT
80164: OR
80165: IFFALSE 76018
// end ;
80167: LD_VAR 0 2
80171: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80172: LD_INT 0
80174: PPUSH
80175: PPUSH
80176: PPUSH
80177: PPUSH
// if not base_units then
80178: LD_VAR 0 1
80182: NOT
80183: IFFALSE 80187
// exit ;
80185: GO 80274
// result := false ;
80187: LD_ADDR_VAR 0 2
80191: PUSH
80192: LD_INT 0
80194: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80195: LD_ADDR_VAR 0 5
80199: PUSH
80200: LD_VAR 0 1
80204: PPUSH
80205: LD_INT 21
80207: PUSH
80208: LD_INT 3
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PPUSH
80215: CALL_OW 72
80219: ST_TO_ADDR
// if not tmp then
80220: LD_VAR 0 5
80224: NOT
80225: IFFALSE 80229
// exit ;
80227: GO 80274
// for i in tmp do
80229: LD_ADDR_VAR 0 3
80233: PUSH
80234: LD_VAR 0 5
80238: PUSH
80239: FOR_IN
80240: IFFALSE 80272
// begin result := EnemyInRange ( i , 22 ) ;
80242: LD_ADDR_VAR 0 2
80246: PUSH
80247: LD_VAR 0 3
80251: PPUSH
80252: LD_INT 22
80254: PPUSH
80255: CALL 73811 0 2
80259: ST_TO_ADDR
// if result then
80260: LD_VAR 0 2
80264: IFFALSE 80270
// exit ;
80266: POP
80267: POP
80268: GO 80274
// end ;
80270: GO 80239
80272: POP
80273: POP
// end ;
80274: LD_VAR 0 2
80278: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80279: LD_INT 0
80281: PPUSH
80282: PPUSH
// if not units then
80283: LD_VAR 0 1
80287: NOT
80288: IFFALSE 80292
// exit ;
80290: GO 80362
// result := [ ] ;
80292: LD_ADDR_VAR 0 3
80296: PUSH
80297: EMPTY
80298: ST_TO_ADDR
// for i in units do
80299: LD_ADDR_VAR 0 4
80303: PUSH
80304: LD_VAR 0 1
80308: PUSH
80309: FOR_IN
80310: IFFALSE 80360
// if GetTag ( i ) = tag then
80312: LD_VAR 0 4
80316: PPUSH
80317: CALL_OW 110
80321: PUSH
80322: LD_VAR 0 2
80326: EQUAL
80327: IFFALSE 80358
// result := Insert ( result , result + 1 , i ) ;
80329: LD_ADDR_VAR 0 3
80333: PUSH
80334: LD_VAR 0 3
80338: PPUSH
80339: LD_VAR 0 3
80343: PUSH
80344: LD_INT 1
80346: PLUS
80347: PPUSH
80348: LD_VAR 0 4
80352: PPUSH
80353: CALL_OW 2
80357: ST_TO_ADDR
80358: GO 80309
80360: POP
80361: POP
// end ;
80362: LD_VAR 0 3
80366: RET
// export function IsDriver ( un ) ; begin
80367: LD_INT 0
80369: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
80370: LD_ADDR_VAR 0 2
80374: PUSH
80375: LD_VAR 0 1
80379: PUSH
80380: LD_INT 55
80382: PUSH
80383: EMPTY
80384: LIST
80385: PPUSH
80386: CALL_OW 69
80390: IN
80391: ST_TO_ADDR
// end ;
80392: LD_VAR 0 2
80396: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
80397: LD_INT 0
80399: PPUSH
80400: PPUSH
// list := [ ] ;
80401: LD_ADDR_VAR 0 5
80405: PUSH
80406: EMPTY
80407: ST_TO_ADDR
// case d of 0 :
80408: LD_VAR 0 3
80412: PUSH
80413: LD_INT 0
80415: DOUBLE
80416: EQUAL
80417: IFTRUE 80421
80419: GO 80554
80421: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
80422: LD_ADDR_VAR 0 5
80426: PUSH
80427: LD_VAR 0 1
80431: PUSH
80432: LD_INT 4
80434: MINUS
80435: PUSH
80436: LD_VAR 0 2
80440: PUSH
80441: LD_INT 4
80443: MINUS
80444: PUSH
80445: LD_INT 2
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: LIST
80452: PUSH
80453: LD_VAR 0 1
80457: PUSH
80458: LD_INT 3
80460: MINUS
80461: PUSH
80462: LD_VAR 0 2
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: LIST
80474: PUSH
80475: LD_VAR 0 1
80479: PUSH
80480: LD_INT 4
80482: PLUS
80483: PUSH
80484: LD_VAR 0 2
80488: PUSH
80489: LD_INT 4
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: LIST
80496: PUSH
80497: LD_VAR 0 1
80501: PUSH
80502: LD_INT 3
80504: PLUS
80505: PUSH
80506: LD_VAR 0 2
80510: PUSH
80511: LD_INT 3
80513: PLUS
80514: PUSH
80515: LD_INT 5
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: PUSH
80523: LD_VAR 0 1
80527: PUSH
80528: LD_VAR 0 2
80532: PUSH
80533: LD_INT 4
80535: PLUS
80536: PUSH
80537: LD_INT 0
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: LIST
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: ST_TO_ADDR
// end ; 1 :
80552: GO 81252
80554: LD_INT 1
80556: DOUBLE
80557: EQUAL
80558: IFTRUE 80562
80560: GO 80695
80562: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
80563: LD_ADDR_VAR 0 5
80567: PUSH
80568: LD_VAR 0 1
80572: PUSH
80573: LD_VAR 0 2
80577: PUSH
80578: LD_INT 4
80580: MINUS
80581: PUSH
80582: LD_INT 3
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: LIST
80589: PUSH
80590: LD_VAR 0 1
80594: PUSH
80595: LD_INT 3
80597: MINUS
80598: PUSH
80599: LD_VAR 0 2
80603: PUSH
80604: LD_INT 3
80606: MINUS
80607: PUSH
80608: LD_INT 2
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: LIST
80615: PUSH
80616: LD_VAR 0 1
80620: PUSH
80621: LD_INT 4
80623: MINUS
80624: PUSH
80625: LD_VAR 0 2
80629: PUSH
80630: LD_INT 1
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: LIST
80637: PUSH
80638: LD_VAR 0 1
80642: PUSH
80643: LD_VAR 0 2
80647: PUSH
80648: LD_INT 3
80650: PLUS
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: LIST
80659: PUSH
80660: LD_VAR 0 1
80664: PUSH
80665: LD_INT 4
80667: PLUS
80668: PUSH
80669: LD_VAR 0 2
80673: PUSH
80674: LD_INT 4
80676: PLUS
80677: PUSH
80678: LD_INT 5
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: LIST
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: ST_TO_ADDR
// end ; 2 :
80693: GO 81252
80695: LD_INT 2
80697: DOUBLE
80698: EQUAL
80699: IFTRUE 80703
80701: GO 80832
80703: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
80704: LD_ADDR_VAR 0 5
80708: PUSH
80709: LD_VAR 0 1
80713: PUSH
80714: LD_VAR 0 2
80718: PUSH
80719: LD_INT 3
80721: MINUS
80722: PUSH
80723: LD_INT 3
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: LIST
80730: PUSH
80731: LD_VAR 0 1
80735: PUSH
80736: LD_INT 4
80738: PLUS
80739: PUSH
80740: LD_VAR 0 2
80744: PUSH
80745: LD_INT 4
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: LIST
80752: PUSH
80753: LD_VAR 0 1
80757: PUSH
80758: LD_VAR 0 2
80762: PUSH
80763: LD_INT 4
80765: PLUS
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: LIST
80774: PUSH
80775: LD_VAR 0 1
80779: PUSH
80780: LD_INT 3
80782: MINUS
80783: PUSH
80784: LD_VAR 0 2
80788: PUSH
80789: LD_INT 1
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: LIST
80796: PUSH
80797: LD_VAR 0 1
80801: PUSH
80802: LD_INT 4
80804: MINUS
80805: PUSH
80806: LD_VAR 0 2
80810: PUSH
80811: LD_INT 4
80813: MINUS
80814: PUSH
80815: LD_INT 2
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: LIST
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: ST_TO_ADDR
// end ; 3 :
80830: GO 81252
80832: LD_INT 3
80834: DOUBLE
80835: EQUAL
80836: IFTRUE 80840
80838: GO 80973
80840: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
80841: LD_ADDR_VAR 0 5
80845: PUSH
80846: LD_VAR 0 1
80850: PUSH
80851: LD_INT 3
80853: PLUS
80854: PUSH
80855: LD_VAR 0 2
80859: PUSH
80860: LD_INT 4
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: LIST
80867: PUSH
80868: LD_VAR 0 1
80872: PUSH
80873: LD_INT 4
80875: PLUS
80876: PUSH
80877: LD_VAR 0 2
80881: PUSH
80882: LD_INT 4
80884: PLUS
80885: PUSH
80886: LD_INT 5
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: LIST
80893: PUSH
80894: LD_VAR 0 1
80898: PUSH
80899: LD_INT 4
80901: MINUS
80902: PUSH
80903: LD_VAR 0 2
80907: PUSH
80908: LD_INT 1
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: LIST
80915: PUSH
80916: LD_VAR 0 1
80920: PUSH
80921: LD_VAR 0 2
80925: PUSH
80926: LD_INT 4
80928: MINUS
80929: PUSH
80930: LD_INT 3
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: LIST
80937: PUSH
80938: LD_VAR 0 1
80942: PUSH
80943: LD_INT 3
80945: MINUS
80946: PUSH
80947: LD_VAR 0 2
80951: PUSH
80952: LD_INT 3
80954: MINUS
80955: PUSH
80956: LD_INT 2
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: LIST
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: ST_TO_ADDR
// end ; 4 :
80971: GO 81252
80973: LD_INT 4
80975: DOUBLE
80976: EQUAL
80977: IFTRUE 80981
80979: GO 81114
80981: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
80982: LD_ADDR_VAR 0 5
80986: PUSH
80987: LD_VAR 0 1
80991: PUSH
80992: LD_VAR 0 2
80996: PUSH
80997: LD_INT 4
80999: PLUS
81000: PUSH
81001: LD_INT 0
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: LIST
81008: PUSH
81009: LD_VAR 0 1
81013: PUSH
81014: LD_INT 3
81016: PLUS
81017: PUSH
81018: LD_VAR 0 2
81022: PUSH
81023: LD_INT 3
81025: PLUS
81026: PUSH
81027: LD_INT 5
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: LIST
81034: PUSH
81035: LD_VAR 0 1
81039: PUSH
81040: LD_INT 4
81042: PLUS
81043: PUSH
81044: LD_VAR 0 2
81048: PUSH
81049: LD_INT 4
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: LIST
81056: PUSH
81057: LD_VAR 0 1
81061: PUSH
81062: LD_VAR 0 2
81066: PUSH
81067: LD_INT 3
81069: MINUS
81070: PUSH
81071: LD_INT 3
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: LIST
81078: PUSH
81079: LD_VAR 0 1
81083: PUSH
81084: LD_INT 4
81086: MINUS
81087: PUSH
81088: LD_VAR 0 2
81092: PUSH
81093: LD_INT 4
81095: MINUS
81096: PUSH
81097: LD_INT 2
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: LIST
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: ST_TO_ADDR
// end ; 5 :
81112: GO 81252
81114: LD_INT 5
81116: DOUBLE
81117: EQUAL
81118: IFTRUE 81122
81120: GO 81251
81122: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81123: LD_ADDR_VAR 0 5
81127: PUSH
81128: LD_VAR 0 1
81132: PUSH
81133: LD_INT 4
81135: MINUS
81136: PUSH
81137: LD_VAR 0 2
81141: PUSH
81142: LD_INT 1
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: LIST
81149: PUSH
81150: LD_VAR 0 1
81154: PUSH
81155: LD_VAR 0 2
81159: PUSH
81160: LD_INT 4
81162: MINUS
81163: PUSH
81164: LD_INT 3
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: LIST
81171: PUSH
81172: LD_VAR 0 1
81176: PUSH
81177: LD_INT 4
81179: PLUS
81180: PUSH
81181: LD_VAR 0 2
81185: PUSH
81186: LD_INT 4
81188: PLUS
81189: PUSH
81190: LD_INT 5
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: LIST
81197: PUSH
81198: LD_VAR 0 1
81202: PUSH
81203: LD_INT 3
81205: PLUS
81206: PUSH
81207: LD_VAR 0 2
81211: PUSH
81212: LD_INT 4
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: LIST
81219: PUSH
81220: LD_VAR 0 1
81224: PUSH
81225: LD_VAR 0 2
81229: PUSH
81230: LD_INT 3
81232: PLUS
81233: PUSH
81234: LD_INT 0
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: LIST
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: ST_TO_ADDR
// end ; end ;
81249: GO 81252
81251: POP
// result := list ;
81252: LD_ADDR_VAR 0 4
81256: PUSH
81257: LD_VAR 0 5
81261: ST_TO_ADDR
// end ;
81262: LD_VAR 0 4
81266: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81267: LD_INT 0
81269: PPUSH
81270: PPUSH
81271: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81272: LD_VAR 0 1
81276: NOT
81277: PUSH
81278: LD_VAR 0 2
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: LD_INT 2
81288: PUSH
81289: LD_INT 3
81291: PUSH
81292: LD_INT 4
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: IN
81301: NOT
81302: OR
81303: IFFALSE 81307
// exit ;
81305: GO 81399
// tmp := [ ] ;
81307: LD_ADDR_VAR 0 5
81311: PUSH
81312: EMPTY
81313: ST_TO_ADDR
// for i in units do
81314: LD_ADDR_VAR 0 4
81318: PUSH
81319: LD_VAR 0 1
81323: PUSH
81324: FOR_IN
81325: IFFALSE 81368
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81327: LD_ADDR_VAR 0 5
81331: PUSH
81332: LD_VAR 0 5
81336: PPUSH
81337: LD_VAR 0 5
81341: PUSH
81342: LD_INT 1
81344: PLUS
81345: PPUSH
81346: LD_VAR 0 4
81350: PPUSH
81351: LD_VAR 0 2
81355: PPUSH
81356: CALL_OW 259
81360: PPUSH
81361: CALL_OW 2
81365: ST_TO_ADDR
81366: GO 81324
81368: POP
81369: POP
// if not tmp then
81370: LD_VAR 0 5
81374: NOT
81375: IFFALSE 81379
// exit ;
81377: GO 81399
// result := SortListByListDesc ( units , tmp ) ;
81379: LD_ADDR_VAR 0 3
81383: PUSH
81384: LD_VAR 0 1
81388: PPUSH
81389: LD_VAR 0 5
81393: PPUSH
81394: CALL_OW 77
81398: ST_TO_ADDR
// end ;
81399: LD_VAR 0 3
81403: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
81404: LD_INT 0
81406: PPUSH
81407: PPUSH
81408: PPUSH
// x := GetX ( building ) ;
81409: LD_ADDR_VAR 0 4
81413: PUSH
81414: LD_VAR 0 2
81418: PPUSH
81419: CALL_OW 250
81423: ST_TO_ADDR
// y := GetY ( building ) ;
81424: LD_ADDR_VAR 0 5
81428: PUSH
81429: LD_VAR 0 2
81433: PPUSH
81434: CALL_OW 251
81438: ST_TO_ADDR
// if GetTaskList ( unit ) then
81439: LD_VAR 0 1
81443: PPUSH
81444: CALL_OW 437
81448: IFFALSE 81543
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
81450: LD_STRING e
81452: PUSH
81453: LD_VAR 0 1
81457: PPUSH
81458: CALL_OW 437
81462: PUSH
81463: LD_INT 1
81465: ARRAY
81466: PUSH
81467: LD_INT 1
81469: ARRAY
81470: EQUAL
81471: PUSH
81472: LD_VAR 0 4
81476: PUSH
81477: LD_VAR 0 1
81481: PPUSH
81482: CALL_OW 437
81486: PUSH
81487: LD_INT 1
81489: ARRAY
81490: PUSH
81491: LD_INT 2
81493: ARRAY
81494: EQUAL
81495: AND
81496: PUSH
81497: LD_VAR 0 5
81501: PUSH
81502: LD_VAR 0 1
81506: PPUSH
81507: CALL_OW 437
81511: PUSH
81512: LD_INT 1
81514: ARRAY
81515: PUSH
81516: LD_INT 3
81518: ARRAY
81519: EQUAL
81520: AND
81521: IFFALSE 81533
// result := true else
81523: LD_ADDR_VAR 0 3
81527: PUSH
81528: LD_INT 1
81530: ST_TO_ADDR
81531: GO 81541
// result := false ;
81533: LD_ADDR_VAR 0 3
81537: PUSH
81538: LD_INT 0
81540: ST_TO_ADDR
// end else
81541: GO 81551
// result := false ;
81543: LD_ADDR_VAR 0 3
81547: PUSH
81548: LD_INT 0
81550: ST_TO_ADDR
// end ;
81551: LD_VAR 0 3
81555: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
81556: LD_INT 0
81558: PPUSH
81559: PPUSH
81560: PPUSH
81561: PPUSH
// if not unit or not area then
81562: LD_VAR 0 1
81566: NOT
81567: PUSH
81568: LD_VAR 0 2
81572: NOT
81573: OR
81574: IFFALSE 81578
// exit ;
81576: GO 81742
// tmp := AreaToList ( area , i ) ;
81578: LD_ADDR_VAR 0 6
81582: PUSH
81583: LD_VAR 0 2
81587: PPUSH
81588: LD_VAR 0 5
81592: PPUSH
81593: CALL_OW 517
81597: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
81598: LD_ADDR_VAR 0 5
81602: PUSH
81603: DOUBLE
81604: LD_INT 1
81606: DEC
81607: ST_TO_ADDR
81608: LD_VAR 0 6
81612: PUSH
81613: LD_INT 1
81615: ARRAY
81616: PUSH
81617: FOR_TO
81618: IFFALSE 81740
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
81620: LD_ADDR_VAR 0 7
81624: PUSH
81625: LD_VAR 0 6
81629: PUSH
81630: LD_INT 1
81632: ARRAY
81633: PUSH
81634: LD_VAR 0 5
81638: ARRAY
81639: PUSH
81640: LD_VAR 0 6
81644: PUSH
81645: LD_INT 2
81647: ARRAY
81648: PUSH
81649: LD_VAR 0 5
81653: ARRAY
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
81659: LD_VAR 0 7
81663: PUSH
81664: LD_INT 1
81666: ARRAY
81667: PPUSH
81668: LD_VAR 0 7
81672: PUSH
81673: LD_INT 2
81675: ARRAY
81676: PPUSH
81677: CALL_OW 428
81681: PUSH
81682: LD_INT 0
81684: EQUAL
81685: IFFALSE 81738
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
81687: LD_VAR 0 1
81691: PPUSH
81692: LD_VAR 0 7
81696: PUSH
81697: LD_INT 1
81699: ARRAY
81700: PPUSH
81701: LD_VAR 0 7
81705: PUSH
81706: LD_INT 2
81708: ARRAY
81709: PPUSH
81710: LD_VAR 0 3
81714: PPUSH
81715: CALL_OW 48
// result := IsPlaced ( unit ) ;
81719: LD_ADDR_VAR 0 4
81723: PUSH
81724: LD_VAR 0 1
81728: PPUSH
81729: CALL_OW 305
81733: ST_TO_ADDR
// exit ;
81734: POP
81735: POP
81736: GO 81742
// end ; end ;
81738: GO 81617
81740: POP
81741: POP
// end ;
81742: LD_VAR 0 4
81746: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
81747: LD_INT 0
81749: PPUSH
81750: PPUSH
81751: PPUSH
// if not side or side > 8 then
81752: LD_VAR 0 1
81756: NOT
81757: PUSH
81758: LD_VAR 0 1
81762: PUSH
81763: LD_INT 8
81765: GREATER
81766: OR
81767: IFFALSE 81771
// exit ;
81769: GO 81958
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
81771: LD_ADDR_VAR 0 4
81775: PUSH
81776: LD_INT 22
81778: PUSH
81779: LD_VAR 0 1
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 21
81790: PUSH
81791: LD_INT 3
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PPUSH
81802: CALL_OW 69
81806: ST_TO_ADDR
// if not tmp then
81807: LD_VAR 0 4
81811: NOT
81812: IFFALSE 81816
// exit ;
81814: GO 81958
// enable_addtolog := true ;
81816: LD_ADDR_OWVAR 81
81820: PUSH
81821: LD_INT 1
81823: ST_TO_ADDR
// AddToLog ( [ ) ;
81824: LD_STRING [
81826: PPUSH
81827: CALL_OW 561
// for i in tmp do
81831: LD_ADDR_VAR 0 3
81835: PUSH
81836: LD_VAR 0 4
81840: PUSH
81841: FOR_IN
81842: IFFALSE 81949
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
81844: LD_STRING [
81846: PUSH
81847: LD_VAR 0 3
81851: PPUSH
81852: CALL_OW 266
81856: STR
81857: PUSH
81858: LD_STRING , 
81860: STR
81861: PUSH
81862: LD_VAR 0 3
81866: PPUSH
81867: CALL_OW 250
81871: STR
81872: PUSH
81873: LD_STRING , 
81875: STR
81876: PUSH
81877: LD_VAR 0 3
81881: PPUSH
81882: CALL_OW 251
81886: STR
81887: PUSH
81888: LD_STRING , 
81890: STR
81891: PUSH
81892: LD_VAR 0 3
81896: PPUSH
81897: CALL_OW 254
81901: STR
81902: PUSH
81903: LD_STRING , 
81905: STR
81906: PUSH
81907: LD_VAR 0 3
81911: PPUSH
81912: LD_INT 1
81914: PPUSH
81915: CALL_OW 268
81919: STR
81920: PUSH
81921: LD_STRING , 
81923: STR
81924: PUSH
81925: LD_VAR 0 3
81929: PPUSH
81930: LD_INT 2
81932: PPUSH
81933: CALL_OW 268
81937: STR
81938: PUSH
81939: LD_STRING ],
81941: STR
81942: PPUSH
81943: CALL_OW 561
// end ;
81947: GO 81841
81949: POP
81950: POP
// AddToLog ( ]; ) ;
81951: LD_STRING ];
81953: PPUSH
81954: CALL_OW 561
// end ;
81958: LD_VAR 0 2
81962: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
81963: LD_INT 0
81965: PPUSH
81966: PPUSH
81967: PPUSH
81968: PPUSH
81969: PPUSH
// if not area or not rate or not max then
81970: LD_VAR 0 1
81974: NOT
81975: PUSH
81976: LD_VAR 0 2
81980: NOT
81981: OR
81982: PUSH
81983: LD_VAR 0 4
81987: NOT
81988: OR
81989: IFFALSE 81993
// exit ;
81991: GO 82185
// while 1 do
81993: LD_INT 1
81995: IFFALSE 82185
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
81997: LD_ADDR_VAR 0 9
82001: PUSH
82002: LD_VAR 0 1
82006: PPUSH
82007: LD_INT 1
82009: PPUSH
82010: CALL_OW 287
82014: PUSH
82015: LD_INT 10
82017: MUL
82018: ST_TO_ADDR
// r := rate / 10 ;
82019: LD_ADDR_VAR 0 7
82023: PUSH
82024: LD_VAR 0 2
82028: PUSH
82029: LD_INT 10
82031: DIVREAL
82032: ST_TO_ADDR
// time := 1 1$00 ;
82033: LD_ADDR_VAR 0 8
82037: PUSH
82038: LD_INT 2100
82040: ST_TO_ADDR
// if amount < min then
82041: LD_VAR 0 9
82045: PUSH
82046: LD_VAR 0 3
82050: LESS
82051: IFFALSE 82069
// r := r * 2 else
82053: LD_ADDR_VAR 0 7
82057: PUSH
82058: LD_VAR 0 7
82062: PUSH
82063: LD_INT 2
82065: MUL
82066: ST_TO_ADDR
82067: GO 82095
// if amount > max then
82069: LD_VAR 0 9
82073: PUSH
82074: LD_VAR 0 4
82078: GREATER
82079: IFFALSE 82095
// r := r / 2 ;
82081: LD_ADDR_VAR 0 7
82085: PUSH
82086: LD_VAR 0 7
82090: PUSH
82091: LD_INT 2
82093: DIVREAL
82094: ST_TO_ADDR
// time := time / r ;
82095: LD_ADDR_VAR 0 8
82099: PUSH
82100: LD_VAR 0 8
82104: PUSH
82105: LD_VAR 0 7
82109: DIVREAL
82110: ST_TO_ADDR
// if time < 0 then
82111: LD_VAR 0 8
82115: PUSH
82116: LD_INT 0
82118: LESS
82119: IFFALSE 82136
// time := time * - 1 ;
82121: LD_ADDR_VAR 0 8
82125: PUSH
82126: LD_VAR 0 8
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: MUL
82135: ST_TO_ADDR
// wait ( time ) ;
82136: LD_VAR 0 8
82140: PPUSH
82141: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82145: LD_INT 35
82147: PPUSH
82148: LD_INT 875
82150: PPUSH
82151: CALL_OW 12
82155: PPUSH
82156: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82160: LD_INT 1
82162: PPUSH
82163: LD_INT 5
82165: PPUSH
82166: CALL_OW 12
82170: PPUSH
82171: LD_VAR 0 1
82175: PPUSH
82176: LD_INT 1
82178: PPUSH
82179: CALL_OW 55
// end ;
82183: GO 81993
// end ;
82185: LD_VAR 0 5
82189: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82190: LD_INT 0
82192: PPUSH
82193: PPUSH
82194: PPUSH
82195: PPUSH
82196: PPUSH
82197: PPUSH
82198: PPUSH
82199: PPUSH
// if not turrets or not factories then
82200: LD_VAR 0 1
82204: NOT
82205: PUSH
82206: LD_VAR 0 2
82210: NOT
82211: OR
82212: IFFALSE 82216
// exit ;
82214: GO 82523
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82216: LD_ADDR_VAR 0 10
82220: PUSH
82221: LD_INT 5
82223: PUSH
82224: LD_INT 6
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 2
82233: PUSH
82234: LD_INT 4
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 3
82243: PUSH
82244: LD_INT 5
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 24
82258: PUSH
82259: LD_INT 25
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 23
82268: PUSH
82269: LD_INT 27
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 42
82282: PUSH
82283: LD_INT 43
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 44
82292: PUSH
82293: LD_INT 46
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 45
82302: PUSH
82303: LD_INT 47
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: LIST
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: LIST
82319: ST_TO_ADDR
// result := [ ] ;
82320: LD_ADDR_VAR 0 3
82324: PUSH
82325: EMPTY
82326: ST_TO_ADDR
// for i in turrets do
82327: LD_ADDR_VAR 0 4
82331: PUSH
82332: LD_VAR 0 1
82336: PUSH
82337: FOR_IN
82338: IFFALSE 82521
// begin nat := GetNation ( i ) ;
82340: LD_ADDR_VAR 0 7
82344: PUSH
82345: LD_VAR 0 4
82349: PPUSH
82350: CALL_OW 248
82354: ST_TO_ADDR
// weapon := 0 ;
82355: LD_ADDR_VAR 0 8
82359: PUSH
82360: LD_INT 0
82362: ST_TO_ADDR
// if not nat then
82363: LD_VAR 0 7
82367: NOT
82368: IFFALSE 82372
// continue ;
82370: GO 82337
// for j in list [ nat ] do
82372: LD_ADDR_VAR 0 5
82376: PUSH
82377: LD_VAR 0 10
82381: PUSH
82382: LD_VAR 0 7
82386: ARRAY
82387: PUSH
82388: FOR_IN
82389: IFFALSE 82430
// if GetBWeapon ( i ) = j [ 1 ] then
82391: LD_VAR 0 4
82395: PPUSH
82396: CALL_OW 269
82400: PUSH
82401: LD_VAR 0 5
82405: PUSH
82406: LD_INT 1
82408: ARRAY
82409: EQUAL
82410: IFFALSE 82428
// begin weapon := j [ 2 ] ;
82412: LD_ADDR_VAR 0 8
82416: PUSH
82417: LD_VAR 0 5
82421: PUSH
82422: LD_INT 2
82424: ARRAY
82425: ST_TO_ADDR
// break ;
82426: GO 82430
// end ;
82428: GO 82388
82430: POP
82431: POP
// if not weapon then
82432: LD_VAR 0 8
82436: NOT
82437: IFFALSE 82441
// continue ;
82439: GO 82337
// for k in factories do
82441: LD_ADDR_VAR 0 6
82445: PUSH
82446: LD_VAR 0 2
82450: PUSH
82451: FOR_IN
82452: IFFALSE 82517
// begin weapons := AvailableWeaponList ( k ) ;
82454: LD_ADDR_VAR 0 9
82458: PUSH
82459: LD_VAR 0 6
82463: PPUSH
82464: CALL_OW 478
82468: ST_TO_ADDR
// if not weapons then
82469: LD_VAR 0 9
82473: NOT
82474: IFFALSE 82478
// continue ;
82476: GO 82451
// if weapon in weapons then
82478: LD_VAR 0 8
82482: PUSH
82483: LD_VAR 0 9
82487: IN
82488: IFFALSE 82515
// begin result := [ i , weapon ] ;
82490: LD_ADDR_VAR 0 3
82494: PUSH
82495: LD_VAR 0 4
82499: PUSH
82500: LD_VAR 0 8
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: ST_TO_ADDR
// exit ;
82509: POP
82510: POP
82511: POP
82512: POP
82513: GO 82523
// end ; end ;
82515: GO 82451
82517: POP
82518: POP
// end ;
82519: GO 82337
82521: POP
82522: POP
// end ;
82523: LD_VAR 0 3
82527: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
82528: LD_INT 0
82530: PPUSH
// if not side or side > 8 then
82531: LD_VAR 0 3
82535: NOT
82536: PUSH
82537: LD_VAR 0 3
82541: PUSH
82542: LD_INT 8
82544: GREATER
82545: OR
82546: IFFALSE 82550
// exit ;
82548: GO 82609
// if not range then
82550: LD_VAR 0 4
82554: NOT
82555: IFFALSE 82566
// range := - 12 ;
82557: LD_ADDR_VAR 0 4
82561: PUSH
82562: LD_INT 12
82564: NEG
82565: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
82566: LD_VAR 0 1
82570: PPUSH
82571: LD_VAR 0 2
82575: PPUSH
82576: LD_VAR 0 3
82580: PPUSH
82581: LD_VAR 0 4
82585: PPUSH
82586: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
82590: LD_VAR 0 1
82594: PPUSH
82595: LD_VAR 0 2
82599: PPUSH
82600: LD_VAR 0 3
82604: PPUSH
82605: CALL_OW 331
// end ;
82609: LD_VAR 0 5
82613: RET
// export function Video ( mode ) ; begin
82614: LD_INT 0
82616: PPUSH
// ingame_video = mode ;
82617: LD_ADDR_OWVAR 52
82621: PUSH
82622: LD_VAR 0 1
82626: ST_TO_ADDR
// interface_hidden = mode ;
82627: LD_ADDR_OWVAR 54
82631: PUSH
82632: LD_VAR 0 1
82636: ST_TO_ADDR
// end ;
82637: LD_VAR 0 2
82641: RET
// export function Join ( array , element ) ; begin
82642: LD_INT 0
82644: PPUSH
// result := array ^ element ;
82645: LD_ADDR_VAR 0 3
82649: PUSH
82650: LD_VAR 0 1
82654: PUSH
82655: LD_VAR 0 2
82659: ADD
82660: ST_TO_ADDR
// end ;
82661: LD_VAR 0 3
82665: RET
// export function JoinUnion ( array , element ) ; begin
82666: LD_INT 0
82668: PPUSH
// result := array union element ;
82669: LD_ADDR_VAR 0 3
82673: PUSH
82674: LD_VAR 0 1
82678: PUSH
82679: LD_VAR 0 2
82683: UNION
82684: ST_TO_ADDR
// end ;
82685: LD_VAR 0 3
82689: RET
// export function GetBehemoths ( side ) ; begin
82690: LD_INT 0
82692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
82693: LD_ADDR_VAR 0 2
82697: PUSH
82698: LD_INT 22
82700: PUSH
82701: LD_VAR 0 1
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 31
82712: PUSH
82713: LD_INT 25
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PPUSH
82724: CALL_OW 69
82728: ST_TO_ADDR
// end ;
82729: LD_VAR 0 2
82733: RET
// export function Shuffle ( array ) ; var i , index ; begin
82734: LD_INT 0
82736: PPUSH
82737: PPUSH
82738: PPUSH
// result := [ ] ;
82739: LD_ADDR_VAR 0 2
82743: PUSH
82744: EMPTY
82745: ST_TO_ADDR
// if not array then
82746: LD_VAR 0 1
82750: NOT
82751: IFFALSE 82755
// exit ;
82753: GO 82854
// Randomize ;
82755: CALL_OW 10
// for i = array downto 1 do
82759: LD_ADDR_VAR 0 3
82763: PUSH
82764: DOUBLE
82765: LD_VAR 0 1
82769: INC
82770: ST_TO_ADDR
82771: LD_INT 1
82773: PUSH
82774: FOR_DOWNTO
82775: IFFALSE 82852
// begin index := rand ( 1 , array ) ;
82777: LD_ADDR_VAR 0 4
82781: PUSH
82782: LD_INT 1
82784: PPUSH
82785: LD_VAR 0 1
82789: PPUSH
82790: CALL_OW 12
82794: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
82795: LD_ADDR_VAR 0 2
82799: PUSH
82800: LD_VAR 0 2
82804: PPUSH
82805: LD_VAR 0 2
82809: PUSH
82810: LD_INT 1
82812: PLUS
82813: PPUSH
82814: LD_VAR 0 1
82818: PUSH
82819: LD_VAR 0 4
82823: ARRAY
82824: PPUSH
82825: CALL_OW 2
82829: ST_TO_ADDR
// array := Delete ( array , index ) ;
82830: LD_ADDR_VAR 0 1
82834: PUSH
82835: LD_VAR 0 1
82839: PPUSH
82840: LD_VAR 0 4
82844: PPUSH
82845: CALL_OW 3
82849: ST_TO_ADDR
// end ;
82850: GO 82774
82852: POP
82853: POP
// end ; end_of_file end_of_file end_of_file
82854: LD_VAR 0 2
82858: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
82859: LD_INT 0
82861: PPUSH
82862: PPUSH
82863: PPUSH
82864: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
82865: LD_VAR 0 1
82869: PPUSH
82870: CALL_OW 264
82874: PUSH
82875: LD_EXP 53
82879: EQUAL
82880: IFFALSE 82952
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
82882: LD_INT 68
82884: PPUSH
82885: LD_VAR 0 1
82889: PPUSH
82890: CALL_OW 255
82894: PPUSH
82895: CALL_OW 321
82899: PUSH
82900: LD_INT 2
82902: EQUAL
82903: IFFALSE 82915
// eff := 70 else
82905: LD_ADDR_VAR 0 6
82909: PUSH
82910: LD_INT 70
82912: ST_TO_ADDR
82913: GO 82923
// eff := 30 ;
82915: LD_ADDR_VAR 0 6
82919: PUSH
82920: LD_INT 30
82922: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
82923: LD_VAR 0 1
82927: PPUSH
82928: CALL_OW 250
82932: PPUSH
82933: LD_VAR 0 1
82937: PPUSH
82938: CALL_OW 251
82942: PPUSH
82943: LD_VAR 0 6
82947: PPUSH
82948: CALL_OW 495
// end ; end ;
82952: LD_VAR 0 4
82956: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
82957: LD_INT 0
82959: PPUSH
82960: PPUSH
82961: PPUSH
82962: PPUSH
82963: PPUSH
82964: PPUSH
// if cmd = 124 then
82965: LD_VAR 0 1
82969: PUSH
82970: LD_INT 124
82972: EQUAL
82973: IFFALSE 83179
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
82975: LD_ADDR_VAR 0 5
82979: PUSH
82980: LD_INT 2
82982: PUSH
82983: LD_INT 34
82985: PUSH
82986: LD_INT 53
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 34
82995: PUSH
82996: LD_INT 14
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: LIST
83007: PPUSH
83008: CALL_OW 69
83012: ST_TO_ADDR
// if not tmp then
83013: LD_VAR 0 5
83017: NOT
83018: IFFALSE 83022
// exit ;
83020: GO 83179
// for i in tmp do
83022: LD_ADDR_VAR 0 3
83026: PUSH
83027: LD_VAR 0 5
83031: PUSH
83032: FOR_IN
83033: IFFALSE 83177
// begin taskList := GetTaskList ( i ) ;
83035: LD_ADDR_VAR 0 6
83039: PUSH
83040: LD_VAR 0 3
83044: PPUSH
83045: CALL_OW 437
83049: ST_TO_ADDR
// if not taskList then
83050: LD_VAR 0 6
83054: NOT
83055: IFFALSE 83059
// continue ;
83057: GO 83032
// for j = 1 to taskList do
83059: LD_ADDR_VAR 0 4
83063: PUSH
83064: DOUBLE
83065: LD_INT 1
83067: DEC
83068: ST_TO_ADDR
83069: LD_VAR 0 6
83073: PUSH
83074: FOR_TO
83075: IFFALSE 83173
// if taskList [ j ] [ 1 ] = | then
83077: LD_VAR 0 6
83081: PUSH
83082: LD_VAR 0 4
83086: ARRAY
83087: PUSH
83088: LD_INT 1
83090: ARRAY
83091: PUSH
83092: LD_STRING |
83094: EQUAL
83095: IFFALSE 83171
// begin _taskList := Delete ( taskList , 1 ) ;
83097: LD_ADDR_VAR 0 7
83101: PUSH
83102: LD_VAR 0 6
83106: PPUSH
83107: LD_INT 1
83109: PPUSH
83110: CALL_OW 3
83114: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
83115: LD_VAR 0 3
83119: PPUSH
83120: LD_VAR 0 7
83124: PPUSH
83125: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
83129: LD_VAR 0 3
83133: PPUSH
83134: LD_VAR 0 6
83138: PUSH
83139: LD_VAR 0 4
83143: ARRAY
83144: PUSH
83145: LD_INT 2
83147: ARRAY
83148: PPUSH
83149: LD_VAR 0 6
83153: PUSH
83154: LD_VAR 0 4
83158: ARRAY
83159: PUSH
83160: LD_INT 3
83162: ARRAY
83163: PPUSH
83164: LD_INT 8
83166: PPUSH
83167: CALL 83184 0 4
// end ;
83171: GO 83074
83173: POP
83174: POP
// end ;
83175: GO 83032
83177: POP
83178: POP
// end ; end ;
83179: LD_VAR 0 2
83183: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
83184: LD_INT 0
83186: PPUSH
83187: PPUSH
83188: PPUSH
83189: PPUSH
83190: PPUSH
83191: PPUSH
83192: PPUSH
83193: PPUSH
83194: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
83195: LD_VAR 0 1
83199: NOT
83200: PUSH
83201: LD_VAR 0 2
83205: PPUSH
83206: LD_VAR 0 3
83210: PPUSH
83211: CALL_OW 488
83215: NOT
83216: OR
83217: PUSH
83218: LD_VAR 0 4
83222: NOT
83223: OR
83224: IFFALSE 83228
// exit ;
83226: GO 83568
// list := [ ] ;
83228: LD_ADDR_VAR 0 13
83232: PUSH
83233: EMPTY
83234: ST_TO_ADDR
// if x - r < 0 then
83235: LD_VAR 0 2
83239: PUSH
83240: LD_VAR 0 4
83244: MINUS
83245: PUSH
83246: LD_INT 0
83248: LESS
83249: IFFALSE 83261
// min_x := 0 else
83251: LD_ADDR_VAR 0 7
83255: PUSH
83256: LD_INT 0
83258: ST_TO_ADDR
83259: GO 83277
// min_x := x - r ;
83261: LD_ADDR_VAR 0 7
83265: PUSH
83266: LD_VAR 0 2
83270: PUSH
83271: LD_VAR 0 4
83275: MINUS
83276: ST_TO_ADDR
// if y - r < 0 then
83277: LD_VAR 0 3
83281: PUSH
83282: LD_VAR 0 4
83286: MINUS
83287: PUSH
83288: LD_INT 0
83290: LESS
83291: IFFALSE 83303
// min_y := 0 else
83293: LD_ADDR_VAR 0 8
83297: PUSH
83298: LD_INT 0
83300: ST_TO_ADDR
83301: GO 83319
// min_y := y - r ;
83303: LD_ADDR_VAR 0 8
83307: PUSH
83308: LD_VAR 0 3
83312: PUSH
83313: LD_VAR 0 4
83317: MINUS
83318: ST_TO_ADDR
// max_x := x + r ;
83319: LD_ADDR_VAR 0 9
83323: PUSH
83324: LD_VAR 0 2
83328: PUSH
83329: LD_VAR 0 4
83333: PLUS
83334: ST_TO_ADDR
// max_y := y + r ;
83335: LD_ADDR_VAR 0 10
83339: PUSH
83340: LD_VAR 0 3
83344: PUSH
83345: LD_VAR 0 4
83349: PLUS
83350: ST_TO_ADDR
// for _x = min_x to max_x do
83351: LD_ADDR_VAR 0 11
83355: PUSH
83356: DOUBLE
83357: LD_VAR 0 7
83361: DEC
83362: ST_TO_ADDR
83363: LD_VAR 0 9
83367: PUSH
83368: FOR_TO
83369: IFFALSE 83486
// for _y = min_y to max_y do
83371: LD_ADDR_VAR 0 12
83375: PUSH
83376: DOUBLE
83377: LD_VAR 0 8
83381: DEC
83382: ST_TO_ADDR
83383: LD_VAR 0 10
83387: PUSH
83388: FOR_TO
83389: IFFALSE 83482
// begin if not ValidHex ( _x , _y ) then
83391: LD_VAR 0 11
83395: PPUSH
83396: LD_VAR 0 12
83400: PPUSH
83401: CALL_OW 488
83405: NOT
83406: IFFALSE 83410
// continue ;
83408: GO 83388
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
83410: LD_VAR 0 11
83414: PPUSH
83415: LD_VAR 0 12
83419: PPUSH
83420: CALL_OW 351
83424: PUSH
83425: LD_VAR 0 11
83429: PPUSH
83430: LD_VAR 0 12
83434: PPUSH
83435: CALL_OW 554
83439: AND
83440: IFFALSE 83480
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
83442: LD_ADDR_VAR 0 13
83446: PUSH
83447: LD_VAR 0 13
83451: PPUSH
83452: LD_VAR 0 13
83456: PUSH
83457: LD_INT 1
83459: PLUS
83460: PPUSH
83461: LD_VAR 0 11
83465: PUSH
83466: LD_VAR 0 12
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PPUSH
83475: CALL_OW 2
83479: ST_TO_ADDR
// end ;
83480: GO 83388
83482: POP
83483: POP
83484: GO 83368
83486: POP
83487: POP
// if not list then
83488: LD_VAR 0 13
83492: NOT
83493: IFFALSE 83497
// exit ;
83495: GO 83568
// for i in list do
83497: LD_ADDR_VAR 0 6
83501: PUSH
83502: LD_VAR 0 13
83506: PUSH
83507: FOR_IN
83508: IFFALSE 83566
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
83510: LD_VAR 0 1
83514: PPUSH
83515: LD_STRING M
83517: PUSH
83518: LD_VAR 0 6
83522: PUSH
83523: LD_INT 1
83525: ARRAY
83526: PUSH
83527: LD_VAR 0 6
83531: PUSH
83532: LD_INT 2
83534: ARRAY
83535: PUSH
83536: LD_INT 0
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: LD_INT 0
83544: PUSH
83545: LD_INT 0
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: PUSH
83557: EMPTY
83558: LIST
83559: PPUSH
83560: CALL_OW 447
83564: GO 83507
83566: POP
83567: POP
// end ;
83568: LD_VAR 0 5
83572: RET
