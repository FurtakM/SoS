// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20778 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22890 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 114
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 115
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44139 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45199 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45292 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 119
 338: PUSH
 339: LD_EXP 119
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44457 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44642 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45199 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45292 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44457 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44642 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45072 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44139 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45199 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45292 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 119
 826: PUSH
 827: LD_EXP 119
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44457 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44642 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45199 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45292 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45610 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45404 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44457 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44642 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45023 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 50868 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 50868 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 50868 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 50868 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 50868 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 50868 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 50868 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 50868 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 50868 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 50868 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 50868 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 50868 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 50868 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 50868 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 50868 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 50868 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 50868 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 50868 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 50868 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 50868 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 50868 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 50868 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 50868 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 50868 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 50868 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 50868 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 50868 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 50868 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 50868 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 50868 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 50868 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 50868 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 50868 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 50868 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 55692 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 55692 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 55692 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 55692 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 55692 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 55692 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 55692 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 55692 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 55692 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 55692 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 55692 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 55692 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 55692 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 267
4442: PPUSH
4443: LD_INT 226
4445: PPUSH
4446: LD_INT 5
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 55692 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 55692 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 50868 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 50868 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 50868 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 50868 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 50868 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 50868 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 50868 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 50868 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 50868 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 50868 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 90
5426: PUSH
5427: LD_EXP 90
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 45923 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44505 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44505 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 45923 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 45923 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 109
5909: PUSH
5910: LD_EXP 109
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 109
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44505 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59101 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 90
6683: PUSH
6684: LD_EXP 90
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 50868 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59101 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 90
7213: PUSH
7214: LD_EXP 90
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 45923 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44505 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44505 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 45923 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 45923 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 109
7862: PUSH
7863: LD_EXP 109
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 109
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59101 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 90
8824: PUSH
8825: LD_EXP 90
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 86857 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 86918 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 86918 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 45923 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44505 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44505 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44505 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 45923 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 45923 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 109
9864: PUSH
9865: LD_EXP 109
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 109
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44505 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 47916 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50250 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49318 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 58665 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49559 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47612 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47232 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 46822 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46660 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46435 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46320 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50511 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 50727 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46129 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 101210 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21013 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21013 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21013 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21013 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 83483 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 83483 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 83483 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 83483 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$50 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1750
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 87087 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 87087 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 87087 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// end ;
20765: LD_VAR 0 1
20769: RET
// every 1 do
20770: GO 20772
20772: DISABLE
// InitGlobalVariables ; end_of_file
20773: CALL 20634 0 0
20777: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20778: LD_INT 0
20780: PPUSH
20781: PPUSH
// skirmish := false ;
20782: LD_ADDR_EXP 88
20786: PUSH
20787: LD_INT 0
20789: ST_TO_ADDR
// debug_mc := false ;
20790: LD_ADDR_EXP 89
20794: PUSH
20795: LD_INT 0
20797: ST_TO_ADDR
// mc_bases := [ ] ;
20798: LD_ADDR_EXP 90
20802: PUSH
20803: EMPTY
20804: ST_TO_ADDR
// mc_sides := [ ] ;
20805: LD_ADDR_EXP 116
20809: PUSH
20810: EMPTY
20811: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20812: LD_ADDR_EXP 91
20816: PUSH
20817: EMPTY
20818: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20819: LD_ADDR_EXP 92
20823: PUSH
20824: EMPTY
20825: ST_TO_ADDR
// mc_need_heal := [ ] ;
20826: LD_ADDR_EXP 93
20830: PUSH
20831: EMPTY
20832: ST_TO_ADDR
// mc_healers := [ ] ;
20833: LD_ADDR_EXP 94
20837: PUSH
20838: EMPTY
20839: ST_TO_ADDR
// mc_build_list := [ ] ;
20840: LD_ADDR_EXP 95
20844: PUSH
20845: EMPTY
20846: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20847: LD_ADDR_EXP 122
20851: PUSH
20852: EMPTY
20853: ST_TO_ADDR
// mc_builders := [ ] ;
20854: LD_ADDR_EXP 96
20858: PUSH
20859: EMPTY
20860: ST_TO_ADDR
// mc_construct_list := [ ] ;
20861: LD_ADDR_EXP 97
20865: PUSH
20866: EMPTY
20867: ST_TO_ADDR
// mc_turret_list := [ ] ;
20868: LD_ADDR_EXP 98
20872: PUSH
20873: EMPTY
20874: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20875: LD_ADDR_EXP 99
20879: PUSH
20880: EMPTY
20881: ST_TO_ADDR
// mc_miners := [ ] ;
20882: LD_ADDR_EXP 104
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_mines := [ ] ;
20889: LD_ADDR_EXP 103
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_minefields := [ ] ;
20896: LD_ADDR_EXP 105
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_crates := [ ] ;
20903: LD_ADDR_EXP 106
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20910: LD_ADDR_EXP 107
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_crates_area := [ ] ;
20917: LD_ADDR_EXP 108
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_vehicles := [ ] ;
20924: LD_ADDR_EXP 109
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_attack := [ ] ;
20931: LD_ADDR_EXP 110
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_produce := [ ] ;
20938: LD_ADDR_EXP 111
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_defender := [ ] ;
20945: LD_ADDR_EXP 112
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_parking := [ ] ;
20952: LD_ADDR_EXP 114
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20959: LD_ADDR_EXP 100
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20966: LD_ADDR_EXP 102
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_scan := [ ] ;
20973: LD_ADDR_EXP 113
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_scan_area := [ ] ;
20980: LD_ADDR_EXP 115
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_tech := [ ] ;
20987: LD_ADDR_EXP 117
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_class := [ ] ;
20994: LD_ADDR_EXP 131
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21001: LD_ADDR_EXP 132
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// end ;
21008: LD_VAR 0 1
21012: RET
// export function MC_Kill ( base ) ; begin
21013: LD_INT 0
21015: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21016: LD_ADDR_EXP 90
21020: PUSH
21021: LD_EXP 90
21025: PPUSH
21026: LD_VAR 0 1
21030: PPUSH
21031: EMPTY
21032: PPUSH
21033: CALL_OW 1
21037: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21038: LD_ADDR_EXP 91
21042: PUSH
21043: LD_EXP 91
21047: PPUSH
21048: LD_VAR 0 1
21052: PPUSH
21053: EMPTY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21060: LD_ADDR_EXP 92
21064: PUSH
21065: LD_EXP 92
21069: PPUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: EMPTY
21076: PPUSH
21077: CALL_OW 1
21081: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21082: LD_ADDR_EXP 93
21086: PUSH
21087: LD_EXP 93
21091: PPUSH
21092: LD_VAR 0 1
21096: PPUSH
21097: EMPTY
21098: PPUSH
21099: CALL_OW 1
21103: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21104: LD_ADDR_EXP 94
21108: PUSH
21109: LD_EXP 94
21113: PPUSH
21114: LD_VAR 0 1
21118: PPUSH
21119: EMPTY
21120: PPUSH
21121: CALL_OW 1
21125: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21126: LD_ADDR_EXP 95
21130: PUSH
21131: LD_EXP 95
21135: PPUSH
21136: LD_VAR 0 1
21140: PPUSH
21141: EMPTY
21142: PPUSH
21143: CALL_OW 1
21147: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21148: LD_ADDR_EXP 96
21152: PUSH
21153: LD_EXP 96
21157: PPUSH
21158: LD_VAR 0 1
21162: PPUSH
21163: EMPTY
21164: PPUSH
21165: CALL_OW 1
21169: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21170: LD_ADDR_EXP 97
21174: PUSH
21175: LD_EXP 97
21179: PPUSH
21180: LD_VAR 0 1
21184: PPUSH
21185: EMPTY
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21192: LD_ADDR_EXP 98
21196: PUSH
21197: LD_EXP 98
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: EMPTY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21214: LD_ADDR_EXP 99
21218: PUSH
21219: LD_EXP 99
21223: PPUSH
21224: LD_VAR 0 1
21228: PPUSH
21229: EMPTY
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21236: LD_ADDR_EXP 100
21240: PUSH
21241: LD_EXP 100
21245: PPUSH
21246: LD_VAR 0 1
21250: PPUSH
21251: EMPTY
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21258: LD_ADDR_EXP 101
21262: PUSH
21263: LD_EXP 101
21267: PPUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: LD_INT 0
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21281: LD_ADDR_EXP 102
21285: PUSH
21286: LD_EXP 102
21290: PPUSH
21291: LD_VAR 0 1
21295: PPUSH
21296: EMPTY
21297: PPUSH
21298: CALL_OW 1
21302: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21303: LD_ADDR_EXP 103
21307: PUSH
21308: LD_EXP 103
21312: PPUSH
21313: LD_VAR 0 1
21317: PPUSH
21318: EMPTY
21319: PPUSH
21320: CALL_OW 1
21324: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21325: LD_ADDR_EXP 104
21329: PUSH
21330: LD_EXP 104
21334: PPUSH
21335: LD_VAR 0 1
21339: PPUSH
21340: EMPTY
21341: PPUSH
21342: CALL_OW 1
21346: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21347: LD_ADDR_EXP 105
21351: PUSH
21352: LD_EXP 105
21356: PPUSH
21357: LD_VAR 0 1
21361: PPUSH
21362: EMPTY
21363: PPUSH
21364: CALL_OW 1
21368: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21369: LD_ADDR_EXP 106
21373: PUSH
21374: LD_EXP 106
21378: PPUSH
21379: LD_VAR 0 1
21383: PPUSH
21384: EMPTY
21385: PPUSH
21386: CALL_OW 1
21390: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21391: LD_ADDR_EXP 107
21395: PUSH
21396: LD_EXP 107
21400: PPUSH
21401: LD_VAR 0 1
21405: PPUSH
21406: EMPTY
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21413: LD_ADDR_EXP 108
21417: PUSH
21418: LD_EXP 108
21422: PPUSH
21423: LD_VAR 0 1
21427: PPUSH
21428: EMPTY
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21435: LD_ADDR_EXP 109
21439: PUSH
21440: LD_EXP 109
21444: PPUSH
21445: LD_VAR 0 1
21449: PPUSH
21450: EMPTY
21451: PPUSH
21452: CALL_OW 1
21456: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21457: LD_ADDR_EXP 110
21461: PUSH
21462: LD_EXP 110
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: EMPTY
21473: PPUSH
21474: CALL_OW 1
21478: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21479: LD_ADDR_EXP 111
21483: PUSH
21484: LD_EXP 111
21488: PPUSH
21489: LD_VAR 0 1
21493: PPUSH
21494: EMPTY
21495: PPUSH
21496: CALL_OW 1
21500: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21501: LD_ADDR_EXP 112
21505: PUSH
21506: LD_EXP 112
21510: PPUSH
21511: LD_VAR 0 1
21515: PPUSH
21516: EMPTY
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21523: LD_ADDR_EXP 113
21527: PUSH
21528: LD_EXP 113
21532: PPUSH
21533: LD_VAR 0 1
21537: PPUSH
21538: EMPTY
21539: PPUSH
21540: CALL_OW 1
21544: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21545: LD_ADDR_EXP 114
21549: PUSH
21550: LD_EXP 114
21554: PPUSH
21555: LD_VAR 0 1
21559: PPUSH
21560: EMPTY
21561: PPUSH
21562: CALL_OW 1
21566: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21567: LD_ADDR_EXP 115
21571: PUSH
21572: LD_EXP 115
21576: PPUSH
21577: LD_VAR 0 1
21581: PPUSH
21582: EMPTY
21583: PPUSH
21584: CALL_OW 1
21588: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21589: LD_ADDR_EXP 117
21593: PUSH
21594: LD_EXP 117
21598: PPUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: EMPTY
21605: PPUSH
21606: CALL_OW 1
21610: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21611: LD_ADDR_EXP 119
21615: PUSH
21616: LD_EXP 119
21620: PPUSH
21621: LD_VAR 0 1
21625: PPUSH
21626: EMPTY
21627: PPUSH
21628: CALL_OW 1
21632: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21633: LD_ADDR_EXP 120
21637: PUSH
21638: LD_EXP 120
21642: PPUSH
21643: LD_VAR 0 1
21647: PPUSH
21648: EMPTY
21649: PPUSH
21650: CALL_OW 1
21654: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21655: LD_ADDR_EXP 121
21659: PUSH
21660: LD_EXP 121
21664: PPUSH
21665: LD_VAR 0 1
21669: PPUSH
21670: EMPTY
21671: PPUSH
21672: CALL_OW 1
21676: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21677: LD_ADDR_EXP 122
21681: PUSH
21682: LD_EXP 122
21686: PPUSH
21687: LD_VAR 0 1
21691: PPUSH
21692: EMPTY
21693: PPUSH
21694: CALL_OW 1
21698: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21699: LD_ADDR_EXP 123
21703: PUSH
21704: LD_EXP 123
21708: PPUSH
21709: LD_VAR 0 1
21713: PPUSH
21714: EMPTY
21715: PPUSH
21716: CALL_OW 1
21720: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21721: LD_ADDR_EXP 124
21725: PUSH
21726: LD_EXP 124
21730: PPUSH
21731: LD_VAR 0 1
21735: PPUSH
21736: EMPTY
21737: PPUSH
21738: CALL_OW 1
21742: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21743: LD_ADDR_EXP 125
21747: PUSH
21748: LD_EXP 125
21752: PPUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: EMPTY
21759: PPUSH
21760: CALL_OW 1
21764: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21765: LD_ADDR_EXP 126
21769: PUSH
21770: LD_EXP 126
21774: PPUSH
21775: LD_VAR 0 1
21779: PPUSH
21780: EMPTY
21781: PPUSH
21782: CALL_OW 1
21786: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21787: LD_ADDR_EXP 127
21791: PUSH
21792: LD_EXP 127
21796: PPUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: EMPTY
21803: PPUSH
21804: CALL_OW 1
21808: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21809: LD_ADDR_EXP 128
21813: PUSH
21814: LD_EXP 128
21818: PPUSH
21819: LD_VAR 0 1
21823: PPUSH
21824: EMPTY
21825: PPUSH
21826: CALL_OW 1
21830: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21831: LD_ADDR_EXP 129
21835: PUSH
21836: LD_EXP 129
21840: PPUSH
21841: LD_VAR 0 1
21845: PPUSH
21846: EMPTY
21847: PPUSH
21848: CALL_OW 1
21852: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21853: LD_ADDR_EXP 130
21857: PUSH
21858: LD_EXP 130
21862: PPUSH
21863: LD_VAR 0 1
21867: PPUSH
21868: EMPTY
21869: PPUSH
21870: CALL_OW 1
21874: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21875: LD_ADDR_EXP 131
21879: PUSH
21880: LD_EXP 131
21884: PPUSH
21885: LD_VAR 0 1
21889: PPUSH
21890: EMPTY
21891: PPUSH
21892: CALL_OW 1
21896: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21897: LD_ADDR_EXP 132
21901: PUSH
21902: LD_EXP 132
21906: PPUSH
21907: LD_VAR 0 1
21911: PPUSH
21912: LD_INT 0
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// end ;
21920: LD_VAR 0 2
21924: RET
// export function MC_Add ( side , units ) ; var base ; begin
21925: LD_INT 0
21927: PPUSH
21928: PPUSH
// base := mc_bases + 1 ;
21929: LD_ADDR_VAR 0 4
21933: PUSH
21934: LD_EXP 90
21938: PUSH
21939: LD_INT 1
21941: PLUS
21942: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21943: LD_ADDR_EXP 116
21947: PUSH
21948: LD_EXP 116
21952: PPUSH
21953: LD_VAR 0 4
21957: PPUSH
21958: LD_VAR 0 1
21962: PPUSH
21963: CALL_OW 1
21967: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21968: LD_ADDR_EXP 90
21972: PUSH
21973: LD_EXP 90
21977: PPUSH
21978: LD_VAR 0 4
21982: PPUSH
21983: LD_VAR 0 2
21987: PPUSH
21988: CALL_OW 1
21992: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21993: LD_ADDR_EXP 91
21997: PUSH
21998: LD_EXP 91
22002: PPUSH
22003: LD_VAR 0 4
22007: PPUSH
22008: EMPTY
22009: PPUSH
22010: CALL_OW 1
22014: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22015: LD_ADDR_EXP 92
22019: PUSH
22020: LD_EXP 92
22024: PPUSH
22025: LD_VAR 0 4
22029: PPUSH
22030: EMPTY
22031: PPUSH
22032: CALL_OW 1
22036: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22037: LD_ADDR_EXP 93
22041: PUSH
22042: LD_EXP 93
22046: PPUSH
22047: LD_VAR 0 4
22051: PPUSH
22052: EMPTY
22053: PPUSH
22054: CALL_OW 1
22058: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22059: LD_ADDR_EXP 94
22063: PUSH
22064: LD_EXP 94
22068: PPUSH
22069: LD_VAR 0 4
22073: PPUSH
22074: EMPTY
22075: PPUSH
22076: CALL_OW 1
22080: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22081: LD_ADDR_EXP 95
22085: PUSH
22086: LD_EXP 95
22090: PPUSH
22091: LD_VAR 0 4
22095: PPUSH
22096: EMPTY
22097: PPUSH
22098: CALL_OW 1
22102: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22103: LD_ADDR_EXP 96
22107: PUSH
22108: LD_EXP 96
22112: PPUSH
22113: LD_VAR 0 4
22117: PPUSH
22118: EMPTY
22119: PPUSH
22120: CALL_OW 1
22124: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22125: LD_ADDR_EXP 97
22129: PUSH
22130: LD_EXP 97
22134: PPUSH
22135: LD_VAR 0 4
22139: PPUSH
22140: EMPTY
22141: PPUSH
22142: CALL_OW 1
22146: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22147: LD_ADDR_EXP 98
22151: PUSH
22152: LD_EXP 98
22156: PPUSH
22157: LD_VAR 0 4
22161: PPUSH
22162: EMPTY
22163: PPUSH
22164: CALL_OW 1
22168: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22169: LD_ADDR_EXP 99
22173: PUSH
22174: LD_EXP 99
22178: PPUSH
22179: LD_VAR 0 4
22183: PPUSH
22184: EMPTY
22185: PPUSH
22186: CALL_OW 1
22190: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22191: LD_ADDR_EXP 100
22195: PUSH
22196: LD_EXP 100
22200: PPUSH
22201: LD_VAR 0 4
22205: PPUSH
22206: EMPTY
22207: PPUSH
22208: CALL_OW 1
22212: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22213: LD_ADDR_EXP 101
22217: PUSH
22218: LD_EXP 101
22222: PPUSH
22223: LD_VAR 0 4
22227: PPUSH
22228: LD_INT 0
22230: PPUSH
22231: CALL_OW 1
22235: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22236: LD_ADDR_EXP 102
22240: PUSH
22241: LD_EXP 102
22245: PPUSH
22246: LD_VAR 0 4
22250: PPUSH
22251: EMPTY
22252: PPUSH
22253: CALL_OW 1
22257: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22258: LD_ADDR_EXP 103
22262: PUSH
22263: LD_EXP 103
22267: PPUSH
22268: LD_VAR 0 4
22272: PPUSH
22273: EMPTY
22274: PPUSH
22275: CALL_OW 1
22279: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22280: LD_ADDR_EXP 104
22284: PUSH
22285: LD_EXP 104
22289: PPUSH
22290: LD_VAR 0 4
22294: PPUSH
22295: EMPTY
22296: PPUSH
22297: CALL_OW 1
22301: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22302: LD_ADDR_EXP 105
22306: PUSH
22307: LD_EXP 105
22311: PPUSH
22312: LD_VAR 0 4
22316: PPUSH
22317: EMPTY
22318: PPUSH
22319: CALL_OW 1
22323: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22324: LD_ADDR_EXP 106
22328: PUSH
22329: LD_EXP 106
22333: PPUSH
22334: LD_VAR 0 4
22338: PPUSH
22339: EMPTY
22340: PPUSH
22341: CALL_OW 1
22345: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22346: LD_ADDR_EXP 107
22350: PUSH
22351: LD_EXP 107
22355: PPUSH
22356: LD_VAR 0 4
22360: PPUSH
22361: EMPTY
22362: PPUSH
22363: CALL_OW 1
22367: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22368: LD_ADDR_EXP 108
22372: PUSH
22373: LD_EXP 108
22377: PPUSH
22378: LD_VAR 0 4
22382: PPUSH
22383: EMPTY
22384: PPUSH
22385: CALL_OW 1
22389: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22390: LD_ADDR_EXP 109
22394: PUSH
22395: LD_EXP 109
22399: PPUSH
22400: LD_VAR 0 4
22404: PPUSH
22405: EMPTY
22406: PPUSH
22407: CALL_OW 1
22411: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22412: LD_ADDR_EXP 110
22416: PUSH
22417: LD_EXP 110
22421: PPUSH
22422: LD_VAR 0 4
22426: PPUSH
22427: EMPTY
22428: PPUSH
22429: CALL_OW 1
22433: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22434: LD_ADDR_EXP 111
22438: PUSH
22439: LD_EXP 111
22443: PPUSH
22444: LD_VAR 0 4
22448: PPUSH
22449: EMPTY
22450: PPUSH
22451: CALL_OW 1
22455: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22456: LD_ADDR_EXP 112
22460: PUSH
22461: LD_EXP 112
22465: PPUSH
22466: LD_VAR 0 4
22470: PPUSH
22471: EMPTY
22472: PPUSH
22473: CALL_OW 1
22477: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22478: LD_ADDR_EXP 113
22482: PUSH
22483: LD_EXP 113
22487: PPUSH
22488: LD_VAR 0 4
22492: PPUSH
22493: EMPTY
22494: PPUSH
22495: CALL_OW 1
22499: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22500: LD_ADDR_EXP 114
22504: PUSH
22505: LD_EXP 114
22509: PPUSH
22510: LD_VAR 0 4
22514: PPUSH
22515: EMPTY
22516: PPUSH
22517: CALL_OW 1
22521: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22522: LD_ADDR_EXP 115
22526: PUSH
22527: LD_EXP 115
22531: PPUSH
22532: LD_VAR 0 4
22536: PPUSH
22537: EMPTY
22538: PPUSH
22539: CALL_OW 1
22543: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22544: LD_ADDR_EXP 117
22548: PUSH
22549: LD_EXP 117
22553: PPUSH
22554: LD_VAR 0 4
22558: PPUSH
22559: EMPTY
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22566: LD_ADDR_EXP 119
22570: PUSH
22571: LD_EXP 119
22575: PPUSH
22576: LD_VAR 0 4
22580: PPUSH
22581: EMPTY
22582: PPUSH
22583: CALL_OW 1
22587: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22588: LD_ADDR_EXP 120
22592: PUSH
22593: LD_EXP 120
22597: PPUSH
22598: LD_VAR 0 4
22602: PPUSH
22603: EMPTY
22604: PPUSH
22605: CALL_OW 1
22609: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22610: LD_ADDR_EXP 121
22614: PUSH
22615: LD_EXP 121
22619: PPUSH
22620: LD_VAR 0 4
22624: PPUSH
22625: EMPTY
22626: PPUSH
22627: CALL_OW 1
22631: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22632: LD_ADDR_EXP 122
22636: PUSH
22637: LD_EXP 122
22641: PPUSH
22642: LD_VAR 0 4
22646: PPUSH
22647: EMPTY
22648: PPUSH
22649: CALL_OW 1
22653: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22654: LD_ADDR_EXP 123
22658: PUSH
22659: LD_EXP 123
22663: PPUSH
22664: LD_VAR 0 4
22668: PPUSH
22669: EMPTY
22670: PPUSH
22671: CALL_OW 1
22675: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22676: LD_ADDR_EXP 124
22680: PUSH
22681: LD_EXP 124
22685: PPUSH
22686: LD_VAR 0 4
22690: PPUSH
22691: EMPTY
22692: PPUSH
22693: CALL_OW 1
22697: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22698: LD_ADDR_EXP 125
22702: PUSH
22703: LD_EXP 125
22707: PPUSH
22708: LD_VAR 0 4
22712: PPUSH
22713: EMPTY
22714: PPUSH
22715: CALL_OW 1
22719: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22720: LD_ADDR_EXP 126
22724: PUSH
22725: LD_EXP 126
22729: PPUSH
22730: LD_VAR 0 4
22734: PPUSH
22735: EMPTY
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22742: LD_ADDR_EXP 127
22746: PUSH
22747: LD_EXP 127
22751: PPUSH
22752: LD_VAR 0 4
22756: PPUSH
22757: EMPTY
22758: PPUSH
22759: CALL_OW 1
22763: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22764: LD_ADDR_EXP 128
22768: PUSH
22769: LD_EXP 128
22773: PPUSH
22774: LD_VAR 0 4
22778: PPUSH
22779: EMPTY
22780: PPUSH
22781: CALL_OW 1
22785: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22786: LD_ADDR_EXP 129
22790: PUSH
22791: LD_EXP 129
22795: PPUSH
22796: LD_VAR 0 4
22800: PPUSH
22801: EMPTY
22802: PPUSH
22803: CALL_OW 1
22807: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22808: LD_ADDR_EXP 130
22812: PUSH
22813: LD_EXP 130
22817: PPUSH
22818: LD_VAR 0 4
22822: PPUSH
22823: EMPTY
22824: PPUSH
22825: CALL_OW 1
22829: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22830: LD_ADDR_EXP 131
22834: PUSH
22835: LD_EXP 131
22839: PPUSH
22840: LD_VAR 0 4
22844: PPUSH
22845: EMPTY
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22852: LD_ADDR_EXP 132
22856: PUSH
22857: LD_EXP 132
22861: PPUSH
22862: LD_VAR 0 4
22866: PPUSH
22867: LD_INT 0
22869: PPUSH
22870: CALL_OW 1
22874: ST_TO_ADDR
// result := base ;
22875: LD_ADDR_VAR 0 3
22879: PUSH
22880: LD_VAR 0 4
22884: ST_TO_ADDR
// end ;
22885: LD_VAR 0 3
22889: RET
// export function MC_Start ( ) ; var i ; begin
22890: LD_INT 0
22892: PPUSH
22893: PPUSH
// for i = 1 to mc_bases do
22894: LD_ADDR_VAR 0 2
22898: PUSH
22899: DOUBLE
22900: LD_INT 1
22902: DEC
22903: ST_TO_ADDR
22904: LD_EXP 90
22908: PUSH
22909: FOR_TO
22910: IFFALSE 23987
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22912: LD_ADDR_EXP 90
22916: PUSH
22917: LD_EXP 90
22921: PPUSH
22922: LD_VAR 0 2
22926: PPUSH
22927: LD_EXP 90
22931: PUSH
22932: LD_VAR 0 2
22936: ARRAY
22937: PUSH
22938: LD_INT 0
22940: DIFF
22941: PPUSH
22942: CALL_OW 1
22946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22947: LD_ADDR_EXP 91
22951: PUSH
22952: LD_EXP 91
22956: PPUSH
22957: LD_VAR 0 2
22961: PPUSH
22962: EMPTY
22963: PPUSH
22964: CALL_OW 1
22968: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22969: LD_ADDR_EXP 92
22973: PUSH
22974: LD_EXP 92
22978: PPUSH
22979: LD_VAR 0 2
22983: PPUSH
22984: EMPTY
22985: PPUSH
22986: CALL_OW 1
22990: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22991: LD_ADDR_EXP 93
22995: PUSH
22996: LD_EXP 93
23000: PPUSH
23001: LD_VAR 0 2
23005: PPUSH
23006: EMPTY
23007: PPUSH
23008: CALL_OW 1
23012: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23013: LD_ADDR_EXP 94
23017: PUSH
23018: LD_EXP 94
23022: PPUSH
23023: LD_VAR 0 2
23027: PPUSH
23028: EMPTY
23029: PUSH
23030: EMPTY
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 1
23040: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23041: LD_ADDR_EXP 95
23045: PUSH
23046: LD_EXP 95
23050: PPUSH
23051: LD_VAR 0 2
23055: PPUSH
23056: EMPTY
23057: PPUSH
23058: CALL_OW 1
23062: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23063: LD_ADDR_EXP 122
23067: PUSH
23068: LD_EXP 122
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: EMPTY
23079: PPUSH
23080: CALL_OW 1
23084: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23085: LD_ADDR_EXP 96
23089: PUSH
23090: LD_EXP 96
23094: PPUSH
23095: LD_VAR 0 2
23099: PPUSH
23100: EMPTY
23101: PPUSH
23102: CALL_OW 1
23106: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23107: LD_ADDR_EXP 97
23111: PUSH
23112: LD_EXP 97
23116: PPUSH
23117: LD_VAR 0 2
23121: PPUSH
23122: EMPTY
23123: PPUSH
23124: CALL_OW 1
23128: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23129: LD_ADDR_EXP 98
23133: PUSH
23134: LD_EXP 98
23138: PPUSH
23139: LD_VAR 0 2
23143: PPUSH
23144: LD_EXP 90
23148: PUSH
23149: LD_VAR 0 2
23153: ARRAY
23154: PPUSH
23155: LD_INT 2
23157: PUSH
23158: LD_INT 30
23160: PUSH
23161: LD_INT 32
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: LD_INT 30
23170: PUSH
23171: LD_INT 33
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: PPUSH
23183: CALL_OW 72
23187: PPUSH
23188: CALL_OW 1
23192: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23193: LD_ADDR_EXP 99
23197: PUSH
23198: LD_EXP 99
23202: PPUSH
23203: LD_VAR 0 2
23207: PPUSH
23208: LD_EXP 90
23212: PUSH
23213: LD_VAR 0 2
23217: ARRAY
23218: PPUSH
23219: LD_INT 2
23221: PUSH
23222: LD_INT 30
23224: PUSH
23225: LD_INT 32
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: LD_INT 30
23234: PUSH
23235: LD_INT 31
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 58
23249: PUSH
23250: EMPTY
23251: LIST
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 72
23261: PPUSH
23262: CALL_OW 1
23266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23267: LD_ADDR_EXP 100
23271: PUSH
23272: LD_EXP 100
23276: PPUSH
23277: LD_VAR 0 2
23281: PPUSH
23282: EMPTY
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23289: LD_ADDR_EXP 104
23293: PUSH
23294: LD_EXP 104
23298: PPUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23311: LD_ADDR_EXP 103
23315: PUSH
23316: LD_EXP 103
23320: PPUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: EMPTY
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23333: LD_ADDR_EXP 105
23337: PUSH
23338: LD_EXP 105
23342: PPUSH
23343: LD_VAR 0 2
23347: PPUSH
23348: EMPTY
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23355: LD_ADDR_EXP 106
23359: PUSH
23360: LD_EXP 106
23364: PPUSH
23365: LD_VAR 0 2
23369: PPUSH
23370: EMPTY
23371: PPUSH
23372: CALL_OW 1
23376: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23377: LD_ADDR_EXP 107
23381: PUSH
23382: LD_EXP 107
23386: PPUSH
23387: LD_VAR 0 2
23391: PPUSH
23392: EMPTY
23393: PPUSH
23394: CALL_OW 1
23398: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23399: LD_ADDR_EXP 108
23403: PUSH
23404: LD_EXP 108
23408: PPUSH
23409: LD_VAR 0 2
23413: PPUSH
23414: EMPTY
23415: PPUSH
23416: CALL_OW 1
23420: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23421: LD_ADDR_EXP 109
23425: PUSH
23426: LD_EXP 109
23430: PPUSH
23431: LD_VAR 0 2
23435: PPUSH
23436: EMPTY
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23443: LD_ADDR_EXP 110
23447: PUSH
23448: LD_EXP 110
23452: PPUSH
23453: LD_VAR 0 2
23457: PPUSH
23458: EMPTY
23459: PPUSH
23460: CALL_OW 1
23464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23465: LD_ADDR_EXP 111
23469: PUSH
23470: LD_EXP 111
23474: PPUSH
23475: LD_VAR 0 2
23479: PPUSH
23480: EMPTY
23481: PPUSH
23482: CALL_OW 1
23486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23487: LD_ADDR_EXP 112
23491: PUSH
23492: LD_EXP 112
23496: PPUSH
23497: LD_VAR 0 2
23501: PPUSH
23502: EMPTY
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23509: LD_ADDR_EXP 101
23513: PUSH
23514: LD_EXP 101
23518: PPUSH
23519: LD_VAR 0 2
23523: PPUSH
23524: LD_INT 0
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23532: LD_ADDR_EXP 114
23536: PUSH
23537: LD_EXP 114
23541: PPUSH
23542: LD_VAR 0 2
23546: PPUSH
23547: LD_INT 0
23549: PPUSH
23550: CALL_OW 1
23554: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23555: LD_ADDR_EXP 102
23559: PUSH
23560: LD_EXP 102
23564: PPUSH
23565: LD_VAR 0 2
23569: PPUSH
23570: EMPTY
23571: PPUSH
23572: CALL_OW 1
23576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23577: LD_ADDR_EXP 113
23581: PUSH
23582: LD_EXP 113
23586: PPUSH
23587: LD_VAR 0 2
23591: PPUSH
23592: LD_INT 0
23594: PPUSH
23595: CALL_OW 1
23599: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23600: LD_ADDR_EXP 115
23604: PUSH
23605: LD_EXP 115
23609: PPUSH
23610: LD_VAR 0 2
23614: PPUSH
23615: EMPTY
23616: PPUSH
23617: CALL_OW 1
23621: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23622: LD_ADDR_EXP 118
23626: PUSH
23627: LD_EXP 118
23631: PPUSH
23632: LD_VAR 0 2
23636: PPUSH
23637: LD_INT 0
23639: PPUSH
23640: CALL_OW 1
23644: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23645: LD_ADDR_EXP 119
23649: PUSH
23650: LD_EXP 119
23654: PPUSH
23655: LD_VAR 0 2
23659: PPUSH
23660: EMPTY
23661: PPUSH
23662: CALL_OW 1
23666: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23667: LD_ADDR_EXP 120
23671: PUSH
23672: LD_EXP 120
23676: PPUSH
23677: LD_VAR 0 2
23681: PPUSH
23682: EMPTY
23683: PPUSH
23684: CALL_OW 1
23688: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23689: LD_ADDR_EXP 121
23693: PUSH
23694: LD_EXP 121
23698: PPUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: EMPTY
23705: PPUSH
23706: CALL_OW 1
23710: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23711: LD_ADDR_EXP 123
23715: PUSH
23716: LD_EXP 123
23720: PPUSH
23721: LD_VAR 0 2
23725: PPUSH
23726: LD_EXP 90
23730: PUSH
23731: LD_VAR 0 2
23735: ARRAY
23736: PPUSH
23737: LD_INT 2
23739: PUSH
23740: LD_INT 30
23742: PUSH
23743: LD_INT 6
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: LD_INT 30
23752: PUSH
23753: LD_INT 7
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: LD_INT 30
23762: PUSH
23763: LD_INT 8
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: PPUSH
23776: CALL_OW 72
23780: PPUSH
23781: CALL_OW 1
23785: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23786: LD_ADDR_EXP 124
23790: PUSH
23791: LD_EXP 124
23795: PPUSH
23796: LD_VAR 0 2
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23808: LD_ADDR_EXP 125
23812: PUSH
23813: LD_EXP 125
23817: PPUSH
23818: LD_VAR 0 2
23822: PPUSH
23823: EMPTY
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23830: LD_ADDR_EXP 126
23834: PUSH
23835: LD_EXP 126
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23852: LD_ADDR_EXP 127
23856: PUSH
23857: LD_EXP 127
23861: PPUSH
23862: LD_VAR 0 2
23866: PPUSH
23867: EMPTY
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23874: LD_ADDR_EXP 128
23878: PUSH
23879: LD_EXP 128
23883: PPUSH
23884: LD_VAR 0 2
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23896: LD_ADDR_EXP 129
23900: PUSH
23901: LD_EXP 129
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23918: LD_ADDR_EXP 130
23922: PUSH
23923: LD_EXP 130
23927: PPUSH
23928: LD_VAR 0 2
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23940: LD_ADDR_EXP 131
23944: PUSH
23945: LD_EXP 131
23949: PPUSH
23950: LD_VAR 0 2
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23962: LD_ADDR_EXP 132
23966: PUSH
23967: LD_EXP 132
23971: PPUSH
23972: LD_VAR 0 2
23976: PPUSH
23977: LD_INT 0
23979: PPUSH
23980: CALL_OW 1
23984: ST_TO_ADDR
// end ;
23985: GO 22909
23987: POP
23988: POP
// MC_InitSides ( ) ;
23989: CALL 24275 0 0
// MC_InitResearch ( ) ;
23993: CALL 24014 0 0
// CustomInitMacro ( ) ;
23997: CALL 217 0 0
// skirmish := true ;
24001: LD_ADDR_EXP 88
24005: PUSH
24006: LD_INT 1
24008: ST_TO_ADDR
// end ;
24009: LD_VAR 0 1
24013: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24014: LD_INT 0
24016: PPUSH
24017: PPUSH
24018: PPUSH
24019: PPUSH
24020: PPUSH
24021: PPUSH
// if not mc_bases then
24022: LD_EXP 90
24026: NOT
24027: IFFALSE 24031
// exit ;
24029: GO 24270
// for i = 1 to 8 do
24031: LD_ADDR_VAR 0 2
24035: PUSH
24036: DOUBLE
24037: LD_INT 1
24039: DEC
24040: ST_TO_ADDR
24041: LD_INT 8
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24071
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24047: LD_ADDR_EXP 117
24051: PUSH
24052: LD_EXP 117
24056: PPUSH
24057: LD_VAR 0 2
24061: PPUSH
24062: EMPTY
24063: PPUSH
24064: CALL_OW 1
24068: ST_TO_ADDR
24069: GO 24044
24071: POP
24072: POP
// tmp := [ ] ;
24073: LD_ADDR_VAR 0 5
24077: PUSH
24078: EMPTY
24079: ST_TO_ADDR
// for i = 1 to mc_sides do
24080: LD_ADDR_VAR 0 2
24084: PUSH
24085: DOUBLE
24086: LD_INT 1
24088: DEC
24089: ST_TO_ADDR
24090: LD_EXP 116
24094: PUSH
24095: FOR_TO
24096: IFFALSE 24154
// if not mc_sides [ i ] in tmp then
24098: LD_EXP 116
24102: PUSH
24103: LD_VAR 0 2
24107: ARRAY
24108: PUSH
24109: LD_VAR 0 5
24113: IN
24114: NOT
24115: IFFALSE 24152
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24117: LD_ADDR_VAR 0 5
24121: PUSH
24122: LD_VAR 0 5
24126: PPUSH
24127: LD_VAR 0 5
24131: PUSH
24132: LD_INT 1
24134: PLUS
24135: PPUSH
24136: LD_EXP 116
24140: PUSH
24141: LD_VAR 0 2
24145: ARRAY
24146: PPUSH
24147: CALL_OW 2
24151: ST_TO_ADDR
24152: GO 24095
24154: POP
24155: POP
// if not tmp then
24156: LD_VAR 0 5
24160: NOT
24161: IFFALSE 24165
// exit ;
24163: GO 24270
// for j in tmp do
24165: LD_ADDR_VAR 0 3
24169: PUSH
24170: LD_VAR 0 5
24174: PUSH
24175: FOR_IN
24176: IFFALSE 24268
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24178: LD_ADDR_VAR 0 6
24182: PUSH
24183: LD_INT 22
24185: PUSH
24186: LD_VAR 0 3
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PPUSH
24195: CALL_OW 69
24199: ST_TO_ADDR
// if not un then
24200: LD_VAR 0 6
24204: NOT
24205: IFFALSE 24209
// continue ;
24207: GO 24175
// nation := GetNation ( un [ 1 ] ) ;
24209: LD_ADDR_VAR 0 4
24213: PUSH
24214: LD_VAR 0 6
24218: PUSH
24219: LD_INT 1
24221: ARRAY
24222: PPUSH
24223: CALL_OW 248
24227: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24228: LD_ADDR_EXP 117
24232: PUSH
24233: LD_EXP 117
24237: PPUSH
24238: LD_VAR 0 3
24242: PPUSH
24243: LD_VAR 0 3
24247: PPUSH
24248: LD_VAR 0 4
24252: PPUSH
24253: LD_INT 1
24255: PPUSH
24256: CALL 50931 0 3
24260: PPUSH
24261: CALL_OW 1
24265: ST_TO_ADDR
// end ;
24266: GO 24175
24268: POP
24269: POP
// end ;
24270: LD_VAR 0 1
24274: RET
// export function MC_InitSides ( ) ; var i ; begin
24275: LD_INT 0
24277: PPUSH
24278: PPUSH
// if not mc_bases then
24279: LD_EXP 90
24283: NOT
24284: IFFALSE 24288
// exit ;
24286: GO 24362
// for i = 1 to mc_bases do
24288: LD_ADDR_VAR 0 2
24292: PUSH
24293: DOUBLE
24294: LD_INT 1
24296: DEC
24297: ST_TO_ADDR
24298: LD_EXP 90
24302: PUSH
24303: FOR_TO
24304: IFFALSE 24360
// if mc_bases [ i ] then
24306: LD_EXP 90
24310: PUSH
24311: LD_VAR 0 2
24315: ARRAY
24316: IFFALSE 24358
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24318: LD_ADDR_EXP 116
24322: PUSH
24323: LD_EXP 116
24327: PPUSH
24328: LD_VAR 0 2
24332: PPUSH
24333: LD_EXP 90
24337: PUSH
24338: LD_VAR 0 2
24342: ARRAY
24343: PUSH
24344: LD_INT 1
24346: ARRAY
24347: PPUSH
24348: CALL_OW 255
24352: PPUSH
24353: CALL_OW 1
24357: ST_TO_ADDR
24358: GO 24303
24360: POP
24361: POP
// end ;
24362: LD_VAR 0 1
24366: RET
// every 0 0$01 trigger skirmish do
24367: LD_EXP 88
24371: IFFALSE 24525
24373: GO 24375
24375: DISABLE
// begin enable ;
24376: ENABLE
// MC_CheckBuildings ( ) ;
24377: CALL 29023 0 0
// MC_CheckPeopleLife ( ) ;
24381: CALL 29148 0 0
// RaiseSailEvent ( 100 ) ;
24385: LD_INT 100
24387: PPUSH
24388: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24392: LD_INT 103
24394: PPUSH
24395: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24399: LD_INT 104
24401: PPUSH
24402: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24406: LD_INT 105
24408: PPUSH
24409: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24413: LD_INT 106
24415: PPUSH
24416: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24420: LD_INT 107
24422: PPUSH
24423: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24427: LD_INT 108
24429: PPUSH
24430: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24434: LD_INT 109
24436: PPUSH
24437: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24441: LD_INT 110
24443: PPUSH
24444: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24448: LD_INT 111
24450: PPUSH
24451: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24455: LD_INT 112
24457: PPUSH
24458: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24462: LD_INT 113
24464: PPUSH
24465: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24469: LD_INT 120
24471: PPUSH
24472: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24476: LD_INT 121
24478: PPUSH
24479: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24483: LD_INT 122
24485: PPUSH
24486: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24490: LD_INT 123
24492: PPUSH
24493: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24497: LD_INT 124
24499: PPUSH
24500: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24504: LD_INT 125
24506: PPUSH
24507: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24511: LD_INT 126
24513: PPUSH
24514: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24518: LD_INT 200
24520: PPUSH
24521: CALL_OW 427
// end ;
24525: END
// on SailEvent ( event ) do begin if event < 100 then
24526: LD_VAR 0 1
24530: PUSH
24531: LD_INT 100
24533: LESS
24534: IFFALSE 24545
// CustomEvent ( event ) ;
24536: LD_VAR 0 1
24540: PPUSH
24541: CALL 10417 0 1
// if event = 100 then
24545: LD_VAR 0 1
24549: PUSH
24550: LD_INT 100
24552: EQUAL
24553: IFFALSE 24559
// MC_ClassManager ( ) ;
24555: CALL 24951 0 0
// if event = 101 then
24559: LD_VAR 0 1
24563: PUSH
24564: LD_INT 101
24566: EQUAL
24567: IFFALSE 24573
// MC_RepairBuildings ( ) ;
24569: CALL 29733 0 0
// if event = 102 then
24573: LD_VAR 0 1
24577: PUSH
24578: LD_INT 102
24580: EQUAL
24581: IFFALSE 24587
// MC_Heal ( ) ;
24583: CALL 30618 0 0
// if event = 103 then
24587: LD_VAR 0 1
24591: PUSH
24592: LD_INT 103
24594: EQUAL
24595: IFFALSE 24601
// MC_Build ( ) ;
24597: CALL 31040 0 0
// if event = 104 then
24601: LD_VAR 0 1
24605: PUSH
24606: LD_INT 104
24608: EQUAL
24609: IFFALSE 24615
// MC_TurretWeapon ( ) ;
24611: CALL 32653 0 0
// if event = 105 then
24615: LD_VAR 0 1
24619: PUSH
24620: LD_INT 105
24622: EQUAL
24623: IFFALSE 24629
// MC_BuildUpgrade ( ) ;
24625: CALL 32204 0 0
// if event = 106 then
24629: LD_VAR 0 1
24633: PUSH
24634: LD_INT 106
24636: EQUAL
24637: IFFALSE 24643
// MC_PlantMines ( ) ;
24639: CALL 33083 0 0
// if event = 107 then
24643: LD_VAR 0 1
24647: PUSH
24648: LD_INT 107
24650: EQUAL
24651: IFFALSE 24657
// MC_CollectCrates ( ) ;
24653: CALL 33881 0 0
// if event = 108 then
24657: LD_VAR 0 1
24661: PUSH
24662: LD_INT 108
24664: EQUAL
24665: IFFALSE 24671
// MC_LinkRemoteControl ( ) ;
24667: CALL 35657 0 0
// if event = 109 then
24671: LD_VAR 0 1
24675: PUSH
24676: LD_INT 109
24678: EQUAL
24679: IFFALSE 24685
// MC_ProduceVehicle ( ) ;
24681: CALL 35838 0 0
// if event = 110 then
24685: LD_VAR 0 1
24689: PUSH
24690: LD_INT 110
24692: EQUAL
24693: IFFALSE 24699
// MC_SendAttack ( ) ;
24695: CALL 36304 0 0
// if event = 111 then
24699: LD_VAR 0 1
24703: PUSH
24704: LD_INT 111
24706: EQUAL
24707: IFFALSE 24713
// MC_Defend ( ) ;
24709: CALL 36412 0 0
// if event = 112 then
24713: LD_VAR 0 1
24717: PUSH
24718: LD_INT 112
24720: EQUAL
24721: IFFALSE 24727
// MC_Research ( ) ;
24723: CALL 37039 0 0
// if event = 113 then
24727: LD_VAR 0 1
24731: PUSH
24732: LD_INT 113
24734: EQUAL
24735: IFFALSE 24741
// MC_MinesTrigger ( ) ;
24737: CALL 38153 0 0
// if event = 120 then
24741: LD_VAR 0 1
24745: PUSH
24746: LD_INT 120
24748: EQUAL
24749: IFFALSE 24755
// MC_RepairVehicle ( ) ;
24751: CALL 38252 0 0
// if event = 121 then
24755: LD_VAR 0 1
24759: PUSH
24760: LD_INT 121
24762: EQUAL
24763: IFFALSE 24769
// MC_TameApe ( ) ;
24765: CALL 38982 0 0
// if event = 122 then
24769: LD_VAR 0 1
24773: PUSH
24774: LD_INT 122
24776: EQUAL
24777: IFFALSE 24783
// MC_ChangeApeClass ( ) ;
24779: CALL 39811 0 0
// if event = 123 then
24783: LD_VAR 0 1
24787: PUSH
24788: LD_INT 123
24790: EQUAL
24791: IFFALSE 24797
// MC_Bazooka ( ) ;
24793: CALL 40461 0 0
// if event = 124 then
24797: LD_VAR 0 1
24801: PUSH
24802: LD_INT 124
24804: EQUAL
24805: IFFALSE 24811
// MC_TeleportExit ( ) ;
24807: CALL 40659 0 0
// if event = 125 then
24811: LD_VAR 0 1
24815: PUSH
24816: LD_INT 125
24818: EQUAL
24819: IFFALSE 24825
// MC_Deposits ( ) ;
24821: CALL 41306 0 0
// if event = 126 then
24825: LD_VAR 0 1
24829: PUSH
24830: LD_INT 126
24832: EQUAL
24833: IFFALSE 24839
// MC_RemoteDriver ( ) ;
24835: CALL 41931 0 0
// if event = 200 then
24839: LD_VAR 0 1
24843: PUSH
24844: LD_INT 200
24846: EQUAL
24847: IFFALSE 24853
// MC_Idle ( ) ;
24849: CALL 43880 0 0
// end ;
24853: PPOPN 1
24855: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24856: LD_INT 0
24858: PPUSH
24859: PPUSH
// if not mc_bases [ base ] or not tag then
24860: LD_EXP 90
24864: PUSH
24865: LD_VAR 0 1
24869: ARRAY
24870: NOT
24871: PUSH
24872: LD_VAR 0 2
24876: NOT
24877: OR
24878: IFFALSE 24882
// exit ;
24880: GO 24946
// for i in mc_bases [ base ] union mc_ape [ base ] do
24882: LD_ADDR_VAR 0 4
24886: PUSH
24887: LD_EXP 90
24891: PUSH
24892: LD_VAR 0 1
24896: ARRAY
24897: PUSH
24898: LD_EXP 119
24902: PUSH
24903: LD_VAR 0 1
24907: ARRAY
24908: UNION
24909: PUSH
24910: FOR_IN
24911: IFFALSE 24944
// if GetTag ( i ) = tag then
24913: LD_VAR 0 4
24917: PPUSH
24918: CALL_OW 110
24922: PUSH
24923: LD_VAR 0 2
24927: EQUAL
24928: IFFALSE 24942
// SetTag ( i , 0 ) ;
24930: LD_VAR 0 4
24934: PPUSH
24935: LD_INT 0
24937: PPUSH
24938: CALL_OW 109
24942: GO 24910
24944: POP
24945: POP
// end ;
24946: LD_VAR 0 3
24950: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24951: LD_INT 0
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
// if not mc_bases then
24961: LD_EXP 90
24965: NOT
24966: IFFALSE 24970
// exit ;
24968: GO 25428
// for i = 1 to mc_bases do
24970: LD_ADDR_VAR 0 2
24974: PUSH
24975: DOUBLE
24976: LD_INT 1
24978: DEC
24979: ST_TO_ADDR
24980: LD_EXP 90
24984: PUSH
24985: FOR_TO
24986: IFFALSE 25426
// begin tmp := MC_ClassCheckReq ( i ) ;
24988: LD_ADDR_VAR 0 4
24992: PUSH
24993: LD_VAR 0 2
24997: PPUSH
24998: CALL 25433 0 1
25002: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25003: LD_ADDR_EXP 131
25007: PUSH
25008: LD_EXP 131
25012: PPUSH
25013: LD_VAR 0 2
25017: PPUSH
25018: LD_VAR 0 4
25022: PPUSH
25023: CALL_OW 1
25027: ST_TO_ADDR
// if not tmp then
25028: LD_VAR 0 4
25032: NOT
25033: IFFALSE 25037
// continue ;
25035: GO 24985
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25037: LD_ADDR_VAR 0 6
25041: PUSH
25042: LD_EXP 90
25046: PUSH
25047: LD_VAR 0 2
25051: ARRAY
25052: PPUSH
25053: LD_INT 2
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 4
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: LD_INT 30
25068: PUSH
25069: LD_INT 5
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: EMPTY
25077: LIST
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: PUSH
25086: LD_EXP 90
25090: PUSH
25091: LD_VAR 0 2
25095: ARRAY
25096: PPUSH
25097: LD_INT 2
25099: PUSH
25100: LD_INT 30
25102: PUSH
25103: LD_INT 0
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 30
25112: PUSH
25113: LD_INT 1
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: LIST
25124: PPUSH
25125: CALL_OW 72
25129: PUSH
25130: LD_EXP 90
25134: PUSH
25135: LD_VAR 0 2
25139: ARRAY
25140: PPUSH
25141: LD_INT 30
25143: PUSH
25144: LD_INT 3
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PPUSH
25151: CALL_OW 72
25155: PUSH
25156: LD_EXP 90
25160: PUSH
25161: LD_VAR 0 2
25165: ARRAY
25166: PPUSH
25167: LD_INT 2
25169: PUSH
25170: LD_INT 30
25172: PUSH
25173: LD_INT 6
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 30
25182: PUSH
25183: LD_INT 7
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: PPUSH
25206: CALL_OW 72
25210: PUSH
25211: EMPTY
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: ST_TO_ADDR
// for j = 1 to 4 do
25217: LD_ADDR_VAR 0 3
25221: PUSH
25222: DOUBLE
25223: LD_INT 1
25225: DEC
25226: ST_TO_ADDR
25227: LD_INT 4
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25422
// begin if not tmp [ j ] then
25233: LD_VAR 0 4
25237: PUSH
25238: LD_VAR 0 3
25242: ARRAY
25243: NOT
25244: IFFALSE 25248
// continue ;
25246: GO 25230
// for p in tmp [ j ] do
25248: LD_ADDR_VAR 0 5
25252: PUSH
25253: LD_VAR 0 4
25257: PUSH
25258: LD_VAR 0 3
25262: ARRAY
25263: PUSH
25264: FOR_IN
25265: IFFALSE 25418
// begin if not b [ j ] then
25267: LD_VAR 0 6
25271: PUSH
25272: LD_VAR 0 3
25276: ARRAY
25277: NOT
25278: IFFALSE 25282
// break ;
25280: GO 25418
// e := 0 ;
25282: LD_ADDR_VAR 0 7
25286: PUSH
25287: LD_INT 0
25289: ST_TO_ADDR
// for k in b [ j ] do
25290: LD_ADDR_VAR 0 8
25294: PUSH
25295: LD_VAR 0 6
25299: PUSH
25300: LD_VAR 0 3
25304: ARRAY
25305: PUSH
25306: FOR_IN
25307: IFFALSE 25334
// if IsNotFull ( k ) then
25309: LD_VAR 0 8
25313: PPUSH
25314: CALL 53080 0 1
25318: IFFALSE 25332
// begin e := k ;
25320: LD_ADDR_VAR 0 7
25324: PUSH
25325: LD_VAR 0 8
25329: ST_TO_ADDR
// break ;
25330: GO 25334
// end ;
25332: GO 25306
25334: POP
25335: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25336: LD_VAR 0 7
25340: PUSH
25341: LD_VAR 0 5
25345: PPUSH
25346: LD_VAR 0 7
25350: PPUSH
25351: CALL 85500 0 2
25355: NOT
25356: AND
25357: IFFALSE 25416
// begin if IsInUnit ( p ) then
25359: LD_VAR 0 5
25363: PPUSH
25364: CALL_OW 310
25368: IFFALSE 25379
// ComExitBuilding ( p ) ;
25370: LD_VAR 0 5
25374: PPUSH
25375: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25379: LD_VAR 0 5
25383: PPUSH
25384: LD_VAR 0 7
25388: PPUSH
25389: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25393: LD_VAR 0 5
25397: PPUSH
25398: LD_VAR 0 3
25402: PPUSH
25403: CALL_OW 183
// AddComExitBuilding ( p ) ;
25407: LD_VAR 0 5
25411: PPUSH
25412: CALL_OW 182
// end ; end ;
25416: GO 25264
25418: POP
25419: POP
// end ;
25420: GO 25230
25422: POP
25423: POP
// end ;
25424: GO 24985
25426: POP
25427: POP
// end ;
25428: LD_VAR 0 1
25432: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25433: LD_INT 0
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25447: LD_VAR 0 1
25451: NOT
25452: PUSH
25453: LD_EXP 90
25457: PUSH
25458: LD_VAR 0 1
25462: ARRAY
25463: NOT
25464: OR
25465: PUSH
25466: LD_EXP 90
25470: PUSH
25471: LD_VAR 0 1
25475: ARRAY
25476: PPUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 0
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 30
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PPUSH
25505: CALL_OW 72
25509: NOT
25510: OR
25511: IFFALSE 25515
// exit ;
25513: GO 29018
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25515: LD_ADDR_VAR 0 4
25519: PUSH
25520: LD_EXP 90
25524: PUSH
25525: LD_VAR 0 1
25529: ARRAY
25530: PPUSH
25531: LD_INT 2
25533: PUSH
25534: LD_INT 25
25536: PUSH
25537: LD_INT 1
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 25
25546: PUSH
25547: LD_INT 2
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 25
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 25
25566: PUSH
25567: LD_INT 4
25569: PUSH
25570: EMPTY
25571: LIST
25572: LIST
25573: PUSH
25574: LD_INT 25
25576: PUSH
25577: LD_INT 5
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: PUSH
25584: LD_INT 25
25586: PUSH
25587: LD_INT 8
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: PUSH
25594: LD_INT 25
25596: PUSH
25597: LD_INT 9
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: PPUSH
25614: CALL_OW 72
25618: ST_TO_ADDR
// if not tmp then
25619: LD_VAR 0 4
25623: NOT
25624: IFFALSE 25628
// exit ;
25626: GO 29018
// for i in tmp do
25628: LD_ADDR_VAR 0 3
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: FOR_IN
25639: IFFALSE 25670
// if GetTag ( i ) then
25641: LD_VAR 0 3
25645: PPUSH
25646: CALL_OW 110
25650: IFFALSE 25668
// tmp := tmp diff i ;
25652: LD_ADDR_VAR 0 4
25656: PUSH
25657: LD_VAR 0 4
25661: PUSH
25662: LD_VAR 0 3
25666: DIFF
25667: ST_TO_ADDR
25668: GO 25638
25670: POP
25671: POP
// if not tmp then
25672: LD_VAR 0 4
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 29018
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25681: LD_ADDR_VAR 0 5
25685: PUSH
25686: LD_EXP 90
25690: PUSH
25691: LD_VAR 0 1
25695: ARRAY
25696: PPUSH
25697: LD_INT 2
25699: PUSH
25700: LD_INT 25
25702: PUSH
25703: LD_INT 1
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 25
25712: PUSH
25713: LD_INT 5
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 25
25722: PUSH
25723: LD_INT 8
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 25
25732: PUSH
25733: LD_INT 9
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: PPUSH
25747: CALL_OW 72
25751: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25752: LD_ADDR_VAR 0 6
25756: PUSH
25757: LD_EXP 90
25761: PUSH
25762: LD_VAR 0 1
25766: ARRAY
25767: PPUSH
25768: LD_INT 25
25770: PUSH
25771: LD_INT 2
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PPUSH
25778: CALL_OW 72
25782: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25783: LD_ADDR_VAR 0 7
25787: PUSH
25788: LD_EXP 90
25792: PUSH
25793: LD_VAR 0 1
25797: ARRAY
25798: PPUSH
25799: LD_INT 25
25801: PUSH
25802: LD_INT 3
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PPUSH
25809: CALL_OW 72
25813: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25814: LD_ADDR_VAR 0 8
25818: PUSH
25819: LD_EXP 90
25823: PUSH
25824: LD_VAR 0 1
25828: ARRAY
25829: PPUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 4
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 24
25842: PUSH
25843: LD_INT 251
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PPUSH
25854: CALL_OW 72
25858: ST_TO_ADDR
// if mc_scan [ base ] then
25859: LD_EXP 113
25863: PUSH
25864: LD_VAR 0 1
25868: ARRAY
25869: IFFALSE 26330
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25871: LD_ADDR_EXP 132
25875: PUSH
25876: LD_EXP 132
25880: PPUSH
25881: LD_VAR 0 1
25885: PPUSH
25886: LD_INT 4
25888: PPUSH
25889: CALL_OW 1
25893: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25894: LD_ADDR_VAR 0 12
25898: PUSH
25899: LD_EXP 90
25903: PUSH
25904: LD_VAR 0 1
25908: ARRAY
25909: PPUSH
25910: LD_INT 2
25912: PUSH
25913: LD_INT 30
25915: PUSH
25916: LD_INT 4
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 30
25925: PUSH
25926: LD_INT 5
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// if not b then
25943: LD_VAR 0 12
25947: NOT
25948: IFFALSE 25952
// exit ;
25950: GO 29018
// p := [ ] ;
25952: LD_ADDR_VAR 0 11
25956: PUSH
25957: EMPTY
25958: ST_TO_ADDR
// if sci >= 2 then
25959: LD_VAR 0 8
25963: PUSH
25964: LD_INT 2
25966: GREATEREQUAL
25967: IFFALSE 25998
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25969: LD_ADDR_VAR 0 8
25973: PUSH
25974: LD_VAR 0 8
25978: PUSH
25979: LD_INT 1
25981: ARRAY
25982: PUSH
25983: LD_VAR 0 8
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: ST_TO_ADDR
25996: GO 26059
// if sci = 1 then
25998: LD_VAR 0 8
26002: PUSH
26003: LD_INT 1
26005: EQUAL
26006: IFFALSE 26027
// sci := [ sci [ 1 ] ] else
26008: LD_ADDR_VAR 0 8
26012: PUSH
26013: LD_VAR 0 8
26017: PUSH
26018: LD_INT 1
26020: ARRAY
26021: PUSH
26022: EMPTY
26023: LIST
26024: ST_TO_ADDR
26025: GO 26059
// if sci = 0 then
26027: LD_VAR 0 8
26031: PUSH
26032: LD_INT 0
26034: EQUAL
26035: IFFALSE 26059
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26037: LD_ADDR_VAR 0 11
26041: PUSH
26042: LD_VAR 0 4
26046: PPUSH
26047: LD_INT 4
26049: PPUSH
26050: CALL 85363 0 2
26054: PUSH
26055: LD_INT 1
26057: ARRAY
26058: ST_TO_ADDR
// if eng > 4 then
26059: LD_VAR 0 6
26063: PUSH
26064: LD_INT 4
26066: GREATER
26067: IFFALSE 26113
// for i = eng downto 4 do
26069: LD_ADDR_VAR 0 3
26073: PUSH
26074: DOUBLE
26075: LD_VAR 0 6
26079: INC
26080: ST_TO_ADDR
26081: LD_INT 4
26083: PUSH
26084: FOR_DOWNTO
26085: IFFALSE 26111
// eng := eng diff eng [ i ] ;
26087: LD_ADDR_VAR 0 6
26091: PUSH
26092: LD_VAR 0 6
26096: PUSH
26097: LD_VAR 0 6
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: DIFF
26108: ST_TO_ADDR
26109: GO 26084
26111: POP
26112: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 5
26127: PUSH
26128: LD_VAR 0 6
26132: UNION
26133: PUSH
26134: LD_VAR 0 7
26138: UNION
26139: PUSH
26140: LD_VAR 0 8
26144: UNION
26145: DIFF
26146: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26147: LD_ADDR_VAR 0 13
26151: PUSH
26152: LD_EXP 90
26156: PUSH
26157: LD_VAR 0 1
26161: ARRAY
26162: PPUSH
26163: LD_INT 2
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 32
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 30
26178: PUSH
26179: LD_INT 31
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL_OW 72
26195: PUSH
26196: LD_EXP 90
26200: PUSH
26201: LD_VAR 0 1
26205: ARRAY
26206: PPUSH
26207: LD_INT 2
26209: PUSH
26210: LD_INT 30
26212: PUSH
26213: LD_INT 4
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 5
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: LIST
26234: PPUSH
26235: CALL_OW 72
26239: PUSH
26240: LD_INT 6
26242: MUL
26243: PLUS
26244: ST_TO_ADDR
// if bcount < tmp then
26245: LD_VAR 0 13
26249: PUSH
26250: LD_VAR 0 4
26254: LESS
26255: IFFALSE 26301
// for i = tmp downto bcount do
26257: LD_ADDR_VAR 0 3
26261: PUSH
26262: DOUBLE
26263: LD_VAR 0 4
26267: INC
26268: ST_TO_ADDR
26269: LD_VAR 0 13
26273: PUSH
26274: FOR_DOWNTO
26275: IFFALSE 26299
// tmp := Delete ( tmp , tmp ) ;
26277: LD_ADDR_VAR 0 4
26281: PUSH
26282: LD_VAR 0 4
26286: PPUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: CALL_OW 3
26296: ST_TO_ADDR
26297: GO 26274
26299: POP
26300: POP
// result := [ tmp , 0 , 0 , p ] ;
26301: LD_ADDR_VAR 0 2
26305: PUSH
26306: LD_VAR 0 4
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: LD_VAR 0 11
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: LIST
26326: LIST
26327: ST_TO_ADDR
// exit ;
26328: GO 29018
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26330: LD_EXP 90
26334: PUSH
26335: LD_VAR 0 1
26339: ARRAY
26340: PPUSH
26341: LD_INT 2
26343: PUSH
26344: LD_INT 30
26346: PUSH
26347: LD_INT 6
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 30
26356: PUSH
26357: LD_INT 7
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 30
26366: PUSH
26367: LD_INT 8
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: LIST
26378: LIST
26379: PPUSH
26380: CALL_OW 72
26384: NOT
26385: PUSH
26386: LD_EXP 90
26390: PUSH
26391: LD_VAR 0 1
26395: ARRAY
26396: PPUSH
26397: LD_INT 30
26399: PUSH
26400: LD_INT 3
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PPUSH
26407: CALL_OW 72
26411: NOT
26412: AND
26413: IFFALSE 26485
// begin if eng = tmp then
26415: LD_VAR 0 6
26419: PUSH
26420: LD_VAR 0 4
26424: EQUAL
26425: IFFALSE 26429
// exit ;
26427: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26429: LD_ADDR_EXP 132
26433: PUSH
26434: LD_EXP 132
26438: PPUSH
26439: LD_VAR 0 1
26443: PPUSH
26444: LD_INT 1
26446: PPUSH
26447: CALL_OW 1
26451: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26452: LD_ADDR_VAR 0 2
26456: PUSH
26457: LD_INT 0
26459: PUSH
26460: LD_VAR 0 4
26464: PUSH
26465: LD_VAR 0 6
26469: DIFF
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: ST_TO_ADDR
// exit ;
26483: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26485: LD_EXP 117
26489: PUSH
26490: LD_EXP 116
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: ARRAY
26501: PUSH
26502: LD_EXP 90
26506: PUSH
26507: LD_VAR 0 1
26511: ARRAY
26512: PPUSH
26513: LD_INT 2
26515: PUSH
26516: LD_INT 30
26518: PUSH
26519: LD_INT 6
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 30
26528: PUSH
26529: LD_INT 7
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 30
26538: PUSH
26539: LD_INT 8
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL_OW 72
26556: AND
26557: PUSH
26558: LD_EXP 90
26562: PUSH
26563: LD_VAR 0 1
26567: ARRAY
26568: PPUSH
26569: LD_INT 30
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PPUSH
26579: CALL_OW 72
26583: NOT
26584: AND
26585: IFFALSE 26799
// begin if sci >= 6 then
26587: LD_VAR 0 8
26591: PUSH
26592: LD_INT 6
26594: GREATEREQUAL
26595: IFFALSE 26599
// exit ;
26597: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26599: LD_ADDR_EXP 132
26603: PUSH
26604: LD_EXP 132
26608: PPUSH
26609: LD_VAR 0 1
26613: PPUSH
26614: LD_INT 2
26616: PPUSH
26617: CALL_OW 1
26621: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26622: LD_ADDR_VAR 0 9
26626: PUSH
26627: LD_VAR 0 4
26631: PUSH
26632: LD_VAR 0 8
26636: DIFF
26637: PPUSH
26638: LD_INT 4
26640: PPUSH
26641: CALL 85363 0 2
26645: ST_TO_ADDR
// p := [ ] ;
26646: LD_ADDR_VAR 0 11
26650: PUSH
26651: EMPTY
26652: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26653: LD_VAR 0 8
26657: PUSH
26658: LD_INT 6
26660: LESS
26661: PUSH
26662: LD_VAR 0 9
26666: PUSH
26667: LD_INT 6
26669: GREATER
26670: AND
26671: IFFALSE 26752
// begin for i = 1 to 6 - sci do
26673: LD_ADDR_VAR 0 3
26677: PUSH
26678: DOUBLE
26679: LD_INT 1
26681: DEC
26682: ST_TO_ADDR
26683: LD_INT 6
26685: PUSH
26686: LD_VAR 0 8
26690: MINUS
26691: PUSH
26692: FOR_TO
26693: IFFALSE 26748
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26695: LD_ADDR_VAR 0 11
26699: PUSH
26700: LD_VAR 0 11
26704: PPUSH
26705: LD_VAR 0 11
26709: PUSH
26710: LD_INT 1
26712: PLUS
26713: PPUSH
26714: LD_VAR 0 9
26718: PUSH
26719: LD_INT 1
26721: ARRAY
26722: PPUSH
26723: CALL_OW 2
26727: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26728: LD_ADDR_VAR 0 9
26732: PUSH
26733: LD_VAR 0 9
26737: PPUSH
26738: LD_INT 1
26740: PPUSH
26741: CALL_OW 3
26745: ST_TO_ADDR
// end ;
26746: GO 26692
26748: POP
26749: POP
// end else
26750: GO 26772
// if sort then
26752: LD_VAR 0 9
26756: IFFALSE 26772
// p := sort [ 1 ] ;
26758: LD_ADDR_VAR 0 11
26762: PUSH
26763: LD_VAR 0 9
26767: PUSH
26768: LD_INT 1
26770: ARRAY
26771: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26772: LD_ADDR_VAR 0 2
26776: PUSH
26777: LD_INT 0
26779: PUSH
26780: LD_INT 0
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: LD_VAR 0 11
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: ST_TO_ADDR
// exit ;
26797: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26799: LD_EXP 117
26803: PUSH
26804: LD_EXP 116
26808: PUSH
26809: LD_VAR 0 1
26813: ARRAY
26814: ARRAY
26815: PUSH
26816: LD_EXP 90
26820: PUSH
26821: LD_VAR 0 1
26825: ARRAY
26826: PPUSH
26827: LD_INT 2
26829: PUSH
26830: LD_INT 30
26832: PUSH
26833: LD_INT 6
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 30
26842: PUSH
26843: LD_INT 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 30
26852: PUSH
26853: LD_INT 8
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: LIST
26865: PPUSH
26866: CALL_OW 72
26870: AND
26871: PUSH
26872: LD_EXP 90
26876: PUSH
26877: LD_VAR 0 1
26881: ARRAY
26882: PPUSH
26883: LD_INT 30
26885: PUSH
26886: LD_INT 3
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PPUSH
26893: CALL_OW 72
26897: AND
26898: IFFALSE 27632
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26900: LD_ADDR_EXP 132
26904: PUSH
26905: LD_EXP 132
26909: PPUSH
26910: LD_VAR 0 1
26914: PPUSH
26915: LD_INT 3
26917: PPUSH
26918: CALL_OW 1
26922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26923: LD_ADDR_VAR 0 2
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: LD_INT 0
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: ST_TO_ADDR
// if not eng then
26946: LD_VAR 0 6
26950: NOT
26951: IFFALSE 27014
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26953: LD_ADDR_VAR 0 11
26957: PUSH
26958: LD_VAR 0 4
26962: PPUSH
26963: LD_INT 2
26965: PPUSH
26966: CALL 85363 0 2
26970: PUSH
26971: LD_INT 1
26973: ARRAY
26974: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26975: LD_ADDR_VAR 0 2
26979: PUSH
26980: LD_VAR 0 2
26984: PPUSH
26985: LD_INT 2
26987: PPUSH
26988: LD_VAR 0 11
26992: PPUSH
26993: CALL_OW 1
26997: ST_TO_ADDR
// tmp := tmp diff p ;
26998: LD_ADDR_VAR 0 4
27002: PUSH
27003: LD_VAR 0 4
27007: PUSH
27008: LD_VAR 0 11
27012: DIFF
27013: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27014: LD_VAR 0 4
27018: PUSH
27019: LD_VAR 0 8
27023: PUSH
27024: LD_INT 6
27026: LESS
27027: AND
27028: IFFALSE 27216
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27030: LD_ADDR_VAR 0 9
27034: PUSH
27035: LD_VAR 0 4
27039: PUSH
27040: LD_VAR 0 8
27044: PUSH
27045: LD_VAR 0 7
27049: UNION
27050: DIFF
27051: PPUSH
27052: LD_INT 4
27054: PPUSH
27055: CALL 85363 0 2
27059: ST_TO_ADDR
// p := [ ] ;
27060: LD_ADDR_VAR 0 11
27064: PUSH
27065: EMPTY
27066: ST_TO_ADDR
// if sort then
27067: LD_VAR 0 9
27071: IFFALSE 27187
// for i = 1 to 6 - sci do
27073: LD_ADDR_VAR 0 3
27077: PUSH
27078: DOUBLE
27079: LD_INT 1
27081: DEC
27082: ST_TO_ADDR
27083: LD_INT 6
27085: PUSH
27086: LD_VAR 0 8
27090: MINUS
27091: PUSH
27092: FOR_TO
27093: IFFALSE 27185
// begin if i = sort then
27095: LD_VAR 0 3
27099: PUSH
27100: LD_VAR 0 9
27104: EQUAL
27105: IFFALSE 27109
// break ;
27107: GO 27185
// if GetClass ( i ) = 4 then
27109: LD_VAR 0 3
27113: PPUSH
27114: CALL_OW 257
27118: PUSH
27119: LD_INT 4
27121: EQUAL
27122: IFFALSE 27126
// continue ;
27124: GO 27092
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27126: LD_ADDR_VAR 0 11
27130: PUSH
27131: LD_VAR 0 11
27135: PPUSH
27136: LD_VAR 0 11
27140: PUSH
27141: LD_INT 1
27143: PLUS
27144: PPUSH
27145: LD_VAR 0 9
27149: PUSH
27150: LD_VAR 0 3
27154: ARRAY
27155: PPUSH
27156: CALL_OW 2
27160: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27161: LD_ADDR_VAR 0 4
27165: PUSH
27166: LD_VAR 0 4
27170: PUSH
27171: LD_VAR 0 9
27175: PUSH
27176: LD_VAR 0 3
27180: ARRAY
27181: DIFF
27182: ST_TO_ADDR
// end ;
27183: GO 27092
27185: POP
27186: POP
// if p then
27187: LD_VAR 0 11
27191: IFFALSE 27216
// result := Replace ( result , 4 , p ) ;
27193: LD_ADDR_VAR 0 2
27197: PUSH
27198: LD_VAR 0 2
27202: PPUSH
27203: LD_INT 4
27205: PPUSH
27206: LD_VAR 0 11
27210: PPUSH
27211: CALL_OW 1
27215: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27216: LD_VAR 0 4
27220: PUSH
27221: LD_VAR 0 7
27225: PUSH
27226: LD_INT 6
27228: LESS
27229: AND
27230: IFFALSE 27418
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27232: LD_ADDR_VAR 0 9
27236: PUSH
27237: LD_VAR 0 4
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_VAR 0 7
27251: UNION
27252: DIFF
27253: PPUSH
27254: LD_INT 3
27256: PPUSH
27257: CALL 85363 0 2
27261: ST_TO_ADDR
// p := [ ] ;
27262: LD_ADDR_VAR 0 11
27266: PUSH
27267: EMPTY
27268: ST_TO_ADDR
// if sort then
27269: LD_VAR 0 9
27273: IFFALSE 27389
// for i = 1 to 6 - mech do
27275: LD_ADDR_VAR 0 3
27279: PUSH
27280: DOUBLE
27281: LD_INT 1
27283: DEC
27284: ST_TO_ADDR
27285: LD_INT 6
27287: PUSH
27288: LD_VAR 0 7
27292: MINUS
27293: PUSH
27294: FOR_TO
27295: IFFALSE 27387
// begin if i = sort then
27297: LD_VAR 0 3
27301: PUSH
27302: LD_VAR 0 9
27306: EQUAL
27307: IFFALSE 27311
// break ;
27309: GO 27387
// if GetClass ( i ) = 3 then
27311: LD_VAR 0 3
27315: PPUSH
27316: CALL_OW 257
27320: PUSH
27321: LD_INT 3
27323: EQUAL
27324: IFFALSE 27328
// continue ;
27326: GO 27294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27328: LD_ADDR_VAR 0 11
27332: PUSH
27333: LD_VAR 0 11
27337: PPUSH
27338: LD_VAR 0 11
27342: PUSH
27343: LD_INT 1
27345: PLUS
27346: PPUSH
27347: LD_VAR 0 9
27351: PUSH
27352: LD_VAR 0 3
27356: ARRAY
27357: PPUSH
27358: CALL_OW 2
27362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27363: LD_ADDR_VAR 0 4
27367: PUSH
27368: LD_VAR 0 4
27372: PUSH
27373: LD_VAR 0 9
27377: PUSH
27378: LD_VAR 0 3
27382: ARRAY
27383: DIFF
27384: ST_TO_ADDR
// end ;
27385: GO 27294
27387: POP
27388: POP
// if p then
27389: LD_VAR 0 11
27393: IFFALSE 27418
// result := Replace ( result , 3 , p ) ;
27395: LD_ADDR_VAR 0 2
27399: PUSH
27400: LD_VAR 0 2
27404: PPUSH
27405: LD_INT 3
27407: PPUSH
27408: LD_VAR 0 11
27412: PPUSH
27413: CALL_OW 1
27417: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27418: LD_VAR 0 4
27422: PUSH
27423: LD_INT 6
27425: GREATER
27426: PUSH
27427: LD_VAR 0 6
27431: PUSH
27432: LD_INT 6
27434: LESS
27435: AND
27436: IFFALSE 27630
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27438: LD_ADDR_VAR 0 9
27442: PUSH
27443: LD_VAR 0 4
27447: PUSH
27448: LD_VAR 0 8
27452: PUSH
27453: LD_VAR 0 7
27457: UNION
27458: PUSH
27459: LD_VAR 0 6
27463: UNION
27464: DIFF
27465: PPUSH
27466: LD_INT 2
27468: PPUSH
27469: CALL 85363 0 2
27473: ST_TO_ADDR
// p := [ ] ;
27474: LD_ADDR_VAR 0 11
27478: PUSH
27479: EMPTY
27480: ST_TO_ADDR
// if sort then
27481: LD_VAR 0 9
27485: IFFALSE 27601
// for i = 1 to 6 - eng do
27487: LD_ADDR_VAR 0 3
27491: PUSH
27492: DOUBLE
27493: LD_INT 1
27495: DEC
27496: ST_TO_ADDR
27497: LD_INT 6
27499: PUSH
27500: LD_VAR 0 6
27504: MINUS
27505: PUSH
27506: FOR_TO
27507: IFFALSE 27599
// begin if i = sort then
27509: LD_VAR 0 3
27513: PUSH
27514: LD_VAR 0 9
27518: EQUAL
27519: IFFALSE 27523
// break ;
27521: GO 27599
// if GetClass ( i ) = 2 then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 257
27532: PUSH
27533: LD_INT 2
27535: EQUAL
27536: IFFALSE 27540
// continue ;
27538: GO 27506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 11
27549: PPUSH
27550: LD_VAR 0 11
27554: PUSH
27555: LD_INT 1
27557: PLUS
27558: PPUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 3
27568: ARRAY
27569: PPUSH
27570: CALL_OW 2
27574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27575: LD_ADDR_VAR 0 4
27579: PUSH
27580: LD_VAR 0 4
27584: PUSH
27585: LD_VAR 0 9
27589: PUSH
27590: LD_VAR 0 3
27594: ARRAY
27595: DIFF
27596: ST_TO_ADDR
// end ;
27597: GO 27506
27599: POP
27600: POP
// if p then
27601: LD_VAR 0 11
27605: IFFALSE 27630
// result := Replace ( result , 2 , p ) ;
27607: LD_ADDR_VAR 0 2
27611: PUSH
27612: LD_VAR 0 2
27616: PPUSH
27617: LD_INT 2
27619: PPUSH
27620: LD_VAR 0 11
27624: PPUSH
27625: CALL_OW 1
27629: ST_TO_ADDR
// end ; exit ;
27630: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27632: LD_EXP 117
27636: PUSH
27637: LD_EXP 116
27641: PUSH
27642: LD_VAR 0 1
27646: ARRAY
27647: ARRAY
27648: NOT
27649: PUSH
27650: LD_EXP 90
27654: PUSH
27655: LD_VAR 0 1
27659: ARRAY
27660: PPUSH
27661: LD_INT 30
27663: PUSH
27664: LD_INT 3
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PPUSH
27671: CALL_OW 72
27675: AND
27676: PUSH
27677: LD_EXP 95
27681: PUSH
27682: LD_VAR 0 1
27686: ARRAY
27687: AND
27688: IFFALSE 28296
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27690: LD_ADDR_EXP 132
27694: PUSH
27695: LD_EXP 132
27699: PPUSH
27700: LD_VAR 0 1
27704: PPUSH
27705: LD_INT 5
27707: PPUSH
27708: CALL_OW 1
27712: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27713: LD_ADDR_VAR 0 2
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: LD_INT 0
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: ST_TO_ADDR
// if sci > 1 then
27736: LD_VAR 0 8
27740: PUSH
27741: LD_INT 1
27743: GREATER
27744: IFFALSE 27772
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27746: LD_ADDR_VAR 0 4
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_VAR 0 8
27760: PUSH
27761: LD_VAR 0 8
27765: PUSH
27766: LD_INT 1
27768: ARRAY
27769: DIFF
27770: DIFF
27771: ST_TO_ADDR
// if tmp and not sci then
27772: LD_VAR 0 4
27776: PUSH
27777: LD_VAR 0 8
27781: NOT
27782: AND
27783: IFFALSE 27852
// begin sort := SortBySkill ( tmp , 4 ) ;
27785: LD_ADDR_VAR 0 9
27789: PUSH
27790: LD_VAR 0 4
27794: PPUSH
27795: LD_INT 4
27797: PPUSH
27798: CALL 85363 0 2
27802: ST_TO_ADDR
// if sort then
27803: LD_VAR 0 9
27807: IFFALSE 27823
// p := sort [ 1 ] ;
27809: LD_ADDR_VAR 0 11
27813: PUSH
27814: LD_VAR 0 9
27818: PUSH
27819: LD_INT 1
27821: ARRAY
27822: ST_TO_ADDR
// if p then
27823: LD_VAR 0 11
27827: IFFALSE 27852
// result := Replace ( result , 4 , p ) ;
27829: LD_ADDR_VAR 0 2
27833: PUSH
27834: LD_VAR 0 2
27838: PPUSH
27839: LD_INT 4
27841: PPUSH
27842: LD_VAR 0 11
27846: PPUSH
27847: CALL_OW 1
27851: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27852: LD_ADDR_VAR 0 4
27856: PUSH
27857: LD_VAR 0 4
27861: PUSH
27862: LD_VAR 0 7
27866: DIFF
27867: ST_TO_ADDR
// if tmp and mech < 6 then
27868: LD_VAR 0 4
27872: PUSH
27873: LD_VAR 0 7
27877: PUSH
27878: LD_INT 6
27880: LESS
27881: AND
27882: IFFALSE 28070
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27884: LD_ADDR_VAR 0 9
27888: PUSH
27889: LD_VAR 0 4
27893: PUSH
27894: LD_VAR 0 8
27898: PUSH
27899: LD_VAR 0 7
27903: UNION
27904: DIFF
27905: PPUSH
27906: LD_INT 3
27908: PPUSH
27909: CALL 85363 0 2
27913: ST_TO_ADDR
// p := [ ] ;
27914: LD_ADDR_VAR 0 11
27918: PUSH
27919: EMPTY
27920: ST_TO_ADDR
// if sort then
27921: LD_VAR 0 9
27925: IFFALSE 28041
// for i = 1 to 6 - mech do
27927: LD_ADDR_VAR 0 3
27931: PUSH
27932: DOUBLE
27933: LD_INT 1
27935: DEC
27936: ST_TO_ADDR
27937: LD_INT 6
27939: PUSH
27940: LD_VAR 0 7
27944: MINUS
27945: PUSH
27946: FOR_TO
27947: IFFALSE 28039
// begin if i = sort then
27949: LD_VAR 0 3
27953: PUSH
27954: LD_VAR 0 9
27958: EQUAL
27959: IFFALSE 27963
// break ;
27961: GO 28039
// if GetClass ( i ) = 3 then
27963: LD_VAR 0 3
27967: PPUSH
27968: CALL_OW 257
27972: PUSH
27973: LD_INT 3
27975: EQUAL
27976: IFFALSE 27980
// continue ;
27978: GO 27946
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27980: LD_ADDR_VAR 0 11
27984: PUSH
27985: LD_VAR 0 11
27989: PPUSH
27990: LD_VAR 0 11
27994: PUSH
27995: LD_INT 1
27997: PLUS
27998: PPUSH
27999: LD_VAR 0 9
28003: PUSH
28004: LD_VAR 0 3
28008: ARRAY
28009: PPUSH
28010: CALL_OW 2
28014: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28015: LD_ADDR_VAR 0 4
28019: PUSH
28020: LD_VAR 0 4
28024: PUSH
28025: LD_VAR 0 9
28029: PUSH
28030: LD_VAR 0 3
28034: ARRAY
28035: DIFF
28036: ST_TO_ADDR
// end ;
28037: GO 27946
28039: POP
28040: POP
// if p then
28041: LD_VAR 0 11
28045: IFFALSE 28070
// result := Replace ( result , 3 , p ) ;
28047: LD_ADDR_VAR 0 2
28051: PUSH
28052: LD_VAR 0 2
28056: PPUSH
28057: LD_INT 3
28059: PPUSH
28060: LD_VAR 0 11
28064: PPUSH
28065: CALL_OW 1
28069: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28070: LD_ADDR_VAR 0 4
28074: PUSH
28075: LD_VAR 0 4
28079: PUSH
28080: LD_VAR 0 6
28084: DIFF
28085: ST_TO_ADDR
// if tmp and eng < 6 then
28086: LD_VAR 0 4
28090: PUSH
28091: LD_VAR 0 6
28095: PUSH
28096: LD_INT 6
28098: LESS
28099: AND
28100: IFFALSE 28294
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28102: LD_ADDR_VAR 0 9
28106: PUSH
28107: LD_VAR 0 4
28111: PUSH
28112: LD_VAR 0 8
28116: PUSH
28117: LD_VAR 0 7
28121: UNION
28122: PUSH
28123: LD_VAR 0 6
28127: UNION
28128: DIFF
28129: PPUSH
28130: LD_INT 2
28132: PPUSH
28133: CALL 85363 0 2
28137: ST_TO_ADDR
// p := [ ] ;
28138: LD_ADDR_VAR 0 11
28142: PUSH
28143: EMPTY
28144: ST_TO_ADDR
// if sort then
28145: LD_VAR 0 9
28149: IFFALSE 28265
// for i = 1 to 6 - eng do
28151: LD_ADDR_VAR 0 3
28155: PUSH
28156: DOUBLE
28157: LD_INT 1
28159: DEC
28160: ST_TO_ADDR
28161: LD_INT 6
28163: PUSH
28164: LD_VAR 0 6
28168: MINUS
28169: PUSH
28170: FOR_TO
28171: IFFALSE 28263
// begin if i = sort then
28173: LD_VAR 0 3
28177: PUSH
28178: LD_VAR 0 9
28182: EQUAL
28183: IFFALSE 28187
// break ;
28185: GO 28263
// if GetClass ( i ) = 2 then
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL_OW 257
28196: PUSH
28197: LD_INT 2
28199: EQUAL
28200: IFFALSE 28204
// continue ;
28202: GO 28170
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28204: LD_ADDR_VAR 0 11
28208: PUSH
28209: LD_VAR 0 11
28213: PPUSH
28214: LD_VAR 0 11
28218: PUSH
28219: LD_INT 1
28221: PLUS
28222: PPUSH
28223: LD_VAR 0 9
28227: PUSH
28228: LD_VAR 0 3
28232: ARRAY
28233: PPUSH
28234: CALL_OW 2
28238: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28239: LD_ADDR_VAR 0 4
28243: PUSH
28244: LD_VAR 0 4
28248: PUSH
28249: LD_VAR 0 9
28253: PUSH
28254: LD_VAR 0 3
28258: ARRAY
28259: DIFF
28260: ST_TO_ADDR
// end ;
28261: GO 28170
28263: POP
28264: POP
// if p then
28265: LD_VAR 0 11
28269: IFFALSE 28294
// result := Replace ( result , 2 , p ) ;
28271: LD_ADDR_VAR 0 2
28275: PUSH
28276: LD_VAR 0 2
28280: PPUSH
28281: LD_INT 2
28283: PPUSH
28284: LD_VAR 0 11
28288: PPUSH
28289: CALL_OW 1
28293: ST_TO_ADDR
// end ; exit ;
28294: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28296: LD_EXP 117
28300: PUSH
28301: LD_EXP 116
28305: PUSH
28306: LD_VAR 0 1
28310: ARRAY
28311: ARRAY
28312: NOT
28313: PUSH
28314: LD_EXP 90
28318: PUSH
28319: LD_VAR 0 1
28323: ARRAY
28324: PPUSH
28325: LD_INT 30
28327: PUSH
28328: LD_INT 3
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PPUSH
28335: CALL_OW 72
28339: AND
28340: PUSH
28341: LD_EXP 95
28345: PUSH
28346: LD_VAR 0 1
28350: ARRAY
28351: NOT
28352: AND
28353: IFFALSE 29018
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28355: LD_ADDR_EXP 132
28359: PUSH
28360: LD_EXP 132
28364: PPUSH
28365: LD_VAR 0 1
28369: PPUSH
28370: LD_INT 6
28372: PPUSH
28373: CALL_OW 1
28377: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_INT 0
28385: PUSH
28386: LD_INT 0
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: ST_TO_ADDR
// if sci >= 1 then
28401: LD_VAR 0 8
28405: PUSH
28406: LD_INT 1
28408: GREATEREQUAL
28409: IFFALSE 28431
// tmp := tmp diff sci [ 1 ] ;
28411: LD_ADDR_VAR 0 4
28415: PUSH
28416: LD_VAR 0 4
28420: PUSH
28421: LD_VAR 0 8
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: DIFF
28430: ST_TO_ADDR
// if tmp and not sci then
28431: LD_VAR 0 4
28435: PUSH
28436: LD_VAR 0 8
28440: NOT
28441: AND
28442: IFFALSE 28511
// begin sort := SortBySkill ( tmp , 4 ) ;
28444: LD_ADDR_VAR 0 9
28448: PUSH
28449: LD_VAR 0 4
28453: PPUSH
28454: LD_INT 4
28456: PPUSH
28457: CALL 85363 0 2
28461: ST_TO_ADDR
// if sort then
28462: LD_VAR 0 9
28466: IFFALSE 28482
// p := sort [ 1 ] ;
28468: LD_ADDR_VAR 0 11
28472: PUSH
28473: LD_VAR 0 9
28477: PUSH
28478: LD_INT 1
28480: ARRAY
28481: ST_TO_ADDR
// if p then
28482: LD_VAR 0 11
28486: IFFALSE 28511
// result := Replace ( result , 4 , p ) ;
28488: LD_ADDR_VAR 0 2
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: LD_INT 4
28500: PPUSH
28501: LD_VAR 0 11
28505: PPUSH
28506: CALL_OW 1
28510: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 7
28525: DIFF
28526: ST_TO_ADDR
// if tmp and mech < 6 then
28527: LD_VAR 0 4
28531: PUSH
28532: LD_VAR 0 7
28536: PUSH
28537: LD_INT 6
28539: LESS
28540: AND
28541: IFFALSE 28723
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28543: LD_ADDR_VAR 0 9
28547: PUSH
28548: LD_VAR 0 4
28552: PUSH
28553: LD_VAR 0 7
28557: DIFF
28558: PPUSH
28559: LD_INT 3
28561: PPUSH
28562: CALL 85363 0 2
28566: ST_TO_ADDR
// p := [ ] ;
28567: LD_ADDR_VAR 0 11
28571: PUSH
28572: EMPTY
28573: ST_TO_ADDR
// if sort then
28574: LD_VAR 0 9
28578: IFFALSE 28694
// for i = 1 to 6 - mech do
28580: LD_ADDR_VAR 0 3
28584: PUSH
28585: DOUBLE
28586: LD_INT 1
28588: DEC
28589: ST_TO_ADDR
28590: LD_INT 6
28592: PUSH
28593: LD_VAR 0 7
28597: MINUS
28598: PUSH
28599: FOR_TO
28600: IFFALSE 28692
// begin if i = sort then
28602: LD_VAR 0 3
28606: PUSH
28607: LD_VAR 0 9
28611: EQUAL
28612: IFFALSE 28616
// break ;
28614: GO 28692
// if GetClass ( i ) = 3 then
28616: LD_VAR 0 3
28620: PPUSH
28621: CALL_OW 257
28625: PUSH
28626: LD_INT 3
28628: EQUAL
28629: IFFALSE 28633
// continue ;
28631: GO 28599
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28633: LD_ADDR_VAR 0 11
28637: PUSH
28638: LD_VAR 0 11
28642: PPUSH
28643: LD_VAR 0 11
28647: PUSH
28648: LD_INT 1
28650: PLUS
28651: PPUSH
28652: LD_VAR 0 9
28656: PUSH
28657: LD_VAR 0 3
28661: ARRAY
28662: PPUSH
28663: CALL_OW 2
28667: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28668: LD_ADDR_VAR 0 4
28672: PUSH
28673: LD_VAR 0 4
28677: PUSH
28678: LD_VAR 0 9
28682: PUSH
28683: LD_VAR 0 3
28687: ARRAY
28688: DIFF
28689: ST_TO_ADDR
// end ;
28690: GO 28599
28692: POP
28693: POP
// if p then
28694: LD_VAR 0 11
28698: IFFALSE 28723
// result := Replace ( result , 3 , p ) ;
28700: LD_ADDR_VAR 0 2
28704: PUSH
28705: LD_VAR 0 2
28709: PPUSH
28710: LD_INT 3
28712: PPUSH
28713: LD_VAR 0 11
28717: PPUSH
28718: CALL_OW 1
28722: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28723: LD_ADDR_VAR 0 4
28727: PUSH
28728: LD_VAR 0 4
28732: PUSH
28733: LD_VAR 0 6
28737: DIFF
28738: ST_TO_ADDR
// if tmp and eng < 4 then
28739: LD_VAR 0 4
28743: PUSH
28744: LD_VAR 0 6
28748: PUSH
28749: LD_INT 4
28751: LESS
28752: AND
28753: IFFALSE 28943
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28755: LD_ADDR_VAR 0 9
28759: PUSH
28760: LD_VAR 0 4
28764: PUSH
28765: LD_VAR 0 7
28769: PUSH
28770: LD_VAR 0 6
28774: UNION
28775: DIFF
28776: PPUSH
28777: LD_INT 2
28779: PPUSH
28780: CALL 85363 0 2
28784: ST_TO_ADDR
// p := [ ] ;
28785: LD_ADDR_VAR 0 11
28789: PUSH
28790: EMPTY
28791: ST_TO_ADDR
// if sort then
28792: LD_VAR 0 9
28796: IFFALSE 28912
// for i = 1 to 4 - eng do
28798: LD_ADDR_VAR 0 3
28802: PUSH
28803: DOUBLE
28804: LD_INT 1
28806: DEC
28807: ST_TO_ADDR
28808: LD_INT 4
28810: PUSH
28811: LD_VAR 0 6
28815: MINUS
28816: PUSH
28817: FOR_TO
28818: IFFALSE 28910
// begin if i = sort then
28820: LD_VAR 0 3
28824: PUSH
28825: LD_VAR 0 9
28829: EQUAL
28830: IFFALSE 28834
// break ;
28832: GO 28910
// if GetClass ( i ) = 2 then
28834: LD_VAR 0 3
28838: PPUSH
28839: CALL_OW 257
28843: PUSH
28844: LD_INT 2
28846: EQUAL
28847: IFFALSE 28851
// continue ;
28849: GO 28817
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28851: LD_ADDR_VAR 0 11
28855: PUSH
28856: LD_VAR 0 11
28860: PPUSH
28861: LD_VAR 0 11
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 9
28874: PUSH
28875: LD_VAR 0 3
28879: ARRAY
28880: PPUSH
28881: CALL_OW 2
28885: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28886: LD_ADDR_VAR 0 4
28890: PUSH
28891: LD_VAR 0 4
28895: PUSH
28896: LD_VAR 0 9
28900: PUSH
28901: LD_VAR 0 3
28905: ARRAY
28906: DIFF
28907: ST_TO_ADDR
// end ;
28908: GO 28817
28910: POP
28911: POP
// if p then
28912: LD_VAR 0 11
28916: IFFALSE 28941
// result := Replace ( result , 2 , p ) ;
28918: LD_ADDR_VAR 0 2
28922: PUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_INT 2
28930: PPUSH
28931: LD_VAR 0 11
28935: PPUSH
28936: CALL_OW 1
28940: ST_TO_ADDR
// end else
28941: GO 28987
// for i = eng downto 5 do
28943: LD_ADDR_VAR 0 3
28947: PUSH
28948: DOUBLE
28949: LD_VAR 0 6
28953: INC
28954: ST_TO_ADDR
28955: LD_INT 5
28957: PUSH
28958: FOR_DOWNTO
28959: IFFALSE 28985
// tmp := tmp union eng [ i ] ;
28961: LD_ADDR_VAR 0 4
28965: PUSH
28966: LD_VAR 0 4
28970: PUSH
28971: LD_VAR 0 6
28975: PUSH
28976: LD_VAR 0 3
28980: ARRAY
28981: UNION
28982: ST_TO_ADDR
28983: GO 28958
28985: POP
28986: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28987: LD_ADDR_VAR 0 2
28991: PUSH
28992: LD_VAR 0 2
28996: PPUSH
28997: LD_INT 1
28999: PPUSH
29000: LD_VAR 0 4
29004: PUSH
29005: LD_VAR 0 5
29009: DIFF
29010: PPUSH
29011: CALL_OW 1
29015: ST_TO_ADDR
// exit ;
29016: GO 29018
// end ; end ;
29018: LD_VAR 0 2
29022: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29023: LD_INT 0
29025: PPUSH
29026: PPUSH
29027: PPUSH
// if not mc_bases then
29028: LD_EXP 90
29032: NOT
29033: IFFALSE 29037
// exit ;
29035: GO 29143
// for i = 1 to mc_bases do
29037: LD_ADDR_VAR 0 2
29041: PUSH
29042: DOUBLE
29043: LD_INT 1
29045: DEC
29046: ST_TO_ADDR
29047: LD_EXP 90
29051: PUSH
29052: FOR_TO
29053: IFFALSE 29134
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29055: LD_ADDR_VAR 0 3
29059: PUSH
29060: LD_EXP 90
29064: PUSH
29065: LD_VAR 0 2
29069: ARRAY
29070: PPUSH
29071: LD_INT 21
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: LD_INT 3
29083: PUSH
29084: LD_INT 24
29086: PUSH
29087: LD_INT 1000
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PPUSH
29102: CALL_OW 72
29106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29107: LD_ADDR_EXP 91
29111: PUSH
29112: LD_EXP 91
29116: PPUSH
29117: LD_VAR 0 2
29121: PPUSH
29122: LD_VAR 0 3
29126: PPUSH
29127: CALL_OW 1
29131: ST_TO_ADDR
// end ;
29132: GO 29052
29134: POP
29135: POP
// RaiseSailEvent ( 101 ) ;
29136: LD_INT 101
29138: PPUSH
29139: CALL_OW 427
// end ;
29143: LD_VAR 0 1
29147: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29148: LD_INT 0
29150: PPUSH
29151: PPUSH
29152: PPUSH
29153: PPUSH
29154: PPUSH
29155: PPUSH
29156: PPUSH
// if not mc_bases then
29157: LD_EXP 90
29161: NOT
29162: IFFALSE 29166
// exit ;
29164: GO 29728
// for i = 1 to mc_bases do
29166: LD_ADDR_VAR 0 2
29170: PUSH
29171: DOUBLE
29172: LD_INT 1
29174: DEC
29175: ST_TO_ADDR
29176: LD_EXP 90
29180: PUSH
29181: FOR_TO
29182: IFFALSE 29719
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29184: LD_ADDR_VAR 0 5
29188: PUSH
29189: LD_EXP 90
29193: PUSH
29194: LD_VAR 0 2
29198: ARRAY
29199: PUSH
29200: LD_EXP 119
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: UNION
29211: PPUSH
29212: LD_INT 21
29214: PUSH
29215: LD_INT 1
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: LD_INT 3
29227: PUSH
29228: LD_INT 54
29230: PUSH
29231: EMPTY
29232: LIST
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 3
29240: PUSH
29241: LD_INT 24
29243: PUSH
29244: LD_INT 800
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PPUSH
29264: CALL_OW 72
29268: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29269: LD_ADDR_VAR 0 6
29273: PUSH
29274: LD_EXP 90
29278: PUSH
29279: LD_VAR 0 2
29283: ARRAY
29284: PPUSH
29285: LD_INT 21
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: PUSH
29298: LD_INT 3
29300: PUSH
29301: LD_INT 54
29303: PUSH
29304: EMPTY
29305: LIST
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 3
29313: PUSH
29314: LD_INT 24
29316: PUSH
29317: LD_INT 250
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: LIST
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29342: LD_ADDR_VAR 0 7
29346: PUSH
29347: LD_VAR 0 5
29351: PUSH
29352: LD_VAR 0 6
29356: DIFF
29357: ST_TO_ADDR
// if not need_heal_1 then
29358: LD_VAR 0 6
29362: NOT
29363: IFFALSE 29396
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29365: LD_ADDR_EXP 93
29369: PUSH
29370: LD_EXP 93
29374: PPUSH
29375: LD_VAR 0 2
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PPUSH
29387: EMPTY
29388: PPUSH
29389: CALL 55814 0 3
29393: ST_TO_ADDR
29394: GO 29466
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29396: LD_ADDR_EXP 93
29400: PUSH
29401: LD_EXP 93
29405: PPUSH
29406: LD_VAR 0 2
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PPUSH
29418: LD_EXP 93
29422: PUSH
29423: LD_VAR 0 2
29427: ARRAY
29428: PUSH
29429: LD_INT 1
29431: ARRAY
29432: PPUSH
29433: LD_INT 3
29435: PUSH
29436: LD_INT 24
29438: PUSH
29439: LD_INT 1000
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PPUSH
29450: CALL_OW 72
29454: PUSH
29455: LD_VAR 0 6
29459: UNION
29460: PPUSH
29461: CALL 55814 0 3
29465: ST_TO_ADDR
// if not need_heal_2 then
29466: LD_VAR 0 7
29470: NOT
29471: IFFALSE 29504
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29473: LD_ADDR_EXP 93
29477: PUSH
29478: LD_EXP 93
29482: PPUSH
29483: LD_VAR 0 2
29487: PUSH
29488: LD_INT 2
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PPUSH
29495: EMPTY
29496: PPUSH
29497: CALL 55814 0 3
29501: ST_TO_ADDR
29502: GO 29536
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29504: LD_ADDR_EXP 93
29508: PUSH
29509: LD_EXP 93
29513: PPUSH
29514: LD_VAR 0 2
29518: PUSH
29519: LD_INT 2
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PPUSH
29526: LD_VAR 0 7
29530: PPUSH
29531: CALL 55814 0 3
29535: ST_TO_ADDR
// if need_heal_2 then
29536: LD_VAR 0 7
29540: IFFALSE 29701
// for j in need_heal_2 do
29542: LD_ADDR_VAR 0 3
29546: PUSH
29547: LD_VAR 0 7
29551: PUSH
29552: FOR_IN
29553: IFFALSE 29699
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29555: LD_ADDR_VAR 0 5
29559: PUSH
29560: LD_EXP 90
29564: PUSH
29565: LD_VAR 0 2
29569: ARRAY
29570: PPUSH
29571: LD_INT 2
29573: PUSH
29574: LD_INT 30
29576: PUSH
29577: LD_INT 6
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 7
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 30
29596: PUSH
29597: LD_INT 8
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 0
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 30
29616: PUSH
29617: LD_INT 1
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: LIST
29628: LIST
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 72
29636: ST_TO_ADDR
// if tmp then
29637: LD_VAR 0 5
29641: IFFALSE 29697
// begin k := NearestUnitToUnit ( tmp , j ) ;
29643: LD_ADDR_VAR 0 4
29647: PUSH
29648: LD_VAR 0 5
29652: PPUSH
29653: LD_VAR 0 3
29657: PPUSH
29658: CALL_OW 74
29662: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29663: LD_VAR 0 3
29667: PPUSH
29668: LD_VAR 0 4
29672: PPUSH
29673: CALL_OW 296
29677: PUSH
29678: LD_INT 5
29680: GREATER
29681: IFFALSE 29697
// ComMoveToNearbyEntrance ( j , k ) ;
29683: LD_VAR 0 3
29687: PPUSH
29688: LD_VAR 0 4
29692: PPUSH
29693: CALL 87680 0 2
// end ; end ;
29697: GO 29552
29699: POP
29700: POP
// if not need_heal_1 and not need_heal_2 then
29701: LD_VAR 0 6
29705: NOT
29706: PUSH
29707: LD_VAR 0 7
29711: NOT
29712: AND
29713: IFFALSE 29717
// continue ;
29715: GO 29181
// end ;
29717: GO 29181
29719: POP
29720: POP
// RaiseSailEvent ( 102 ) ;
29721: LD_INT 102
29723: PPUSH
29724: CALL_OW 427
// end ;
29728: LD_VAR 0 1
29732: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29733: LD_INT 0
29735: PPUSH
29736: PPUSH
29737: PPUSH
29738: PPUSH
29739: PPUSH
29740: PPUSH
29741: PPUSH
29742: PPUSH
// if not mc_bases then
29743: LD_EXP 90
29747: NOT
29748: IFFALSE 29752
// exit ;
29750: GO 30613
// for i = 1 to mc_bases do
29752: LD_ADDR_VAR 0 2
29756: PUSH
29757: DOUBLE
29758: LD_INT 1
29760: DEC
29761: ST_TO_ADDR
29762: LD_EXP 90
29766: PUSH
29767: FOR_TO
29768: IFFALSE 30611
// begin if not mc_building_need_repair [ i ] then
29770: LD_EXP 91
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: NOT
29781: IFFALSE 29968
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29783: LD_ADDR_VAR 0 6
29787: PUSH
29788: LD_EXP 109
29792: PUSH
29793: LD_VAR 0 2
29797: ARRAY
29798: PPUSH
29799: LD_INT 3
29801: PUSH
29802: LD_INT 24
29804: PUSH
29805: LD_INT 1000
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 34
29821: PUSH
29822: LD_INT 13
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 34
29831: PUSH
29832: LD_INT 52
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 34
29841: PUSH
29842: LD_EXP 78
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PPUSH
29861: CALL_OW 72
29865: ST_TO_ADDR
// if cranes then
29866: LD_VAR 0 6
29870: IFFALSE 29932
// for j in cranes do
29872: LD_ADDR_VAR 0 3
29876: PUSH
29877: LD_VAR 0 6
29881: PUSH
29882: FOR_IN
29883: IFFALSE 29930
// if not IsInArea ( j , mc_parking [ i ] ) then
29885: LD_VAR 0 3
29889: PPUSH
29890: LD_EXP 114
29894: PUSH
29895: LD_VAR 0 2
29899: ARRAY
29900: PPUSH
29901: CALL_OW 308
29905: NOT
29906: IFFALSE 29928
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29908: LD_VAR 0 3
29912: PPUSH
29913: LD_EXP 114
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: PPUSH
29924: CALL_OW 113
29928: GO 29882
29930: POP
29931: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29932: LD_ADDR_EXP 92
29936: PUSH
29937: LD_EXP 92
29941: PPUSH
29942: LD_VAR 0 2
29946: PPUSH
29947: EMPTY
29948: PPUSH
29949: CALL_OW 1
29953: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29954: LD_VAR 0 2
29958: PPUSH
29959: LD_INT 101
29961: PPUSH
29962: CALL 24856 0 2
// continue ;
29966: GO 29767
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29968: LD_ADDR_EXP 96
29972: PUSH
29973: LD_EXP 96
29977: PPUSH
29978: LD_VAR 0 2
29982: PPUSH
29983: EMPTY
29984: PPUSH
29985: CALL_OW 1
29989: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29990: LD_VAR 0 2
29994: PPUSH
29995: LD_INT 103
29997: PPUSH
29998: CALL 24856 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30002: LD_ADDR_VAR 0 5
30006: PUSH
30007: LD_EXP 90
30011: PUSH
30012: LD_VAR 0 2
30016: ARRAY
30017: PUSH
30018: LD_EXP 119
30022: PUSH
30023: LD_VAR 0 2
30027: ARRAY
30028: UNION
30029: PPUSH
30030: LD_INT 2
30032: PUSH
30033: LD_INT 25
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 25
30045: PUSH
30046: LD_INT 16
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: LIST
30057: PUSH
30058: EMPTY
30059: LIST
30060: PPUSH
30061: CALL_OW 72
30065: PUSH
30066: LD_EXP 93
30070: PUSH
30071: LD_VAR 0 2
30075: ARRAY
30076: PUSH
30077: LD_INT 1
30079: ARRAY
30080: PUSH
30081: LD_EXP 93
30085: PUSH
30086: LD_VAR 0 2
30090: ARRAY
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: UNION
30096: DIFF
30097: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30098: LD_ADDR_VAR 0 6
30102: PUSH
30103: LD_EXP 109
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PPUSH
30114: LD_INT 2
30116: PUSH
30117: LD_INT 34
30119: PUSH
30120: LD_INT 13
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 34
30129: PUSH
30130: LD_INT 52
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 34
30139: PUSH
30140: LD_EXP 78
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: PPUSH
30155: CALL_OW 72
30159: ST_TO_ADDR
// if cranes then
30160: LD_VAR 0 6
30164: IFFALSE 30300
// begin for j in cranes do
30166: LD_ADDR_VAR 0 3
30170: PUSH
30171: LD_VAR 0 6
30175: PUSH
30176: FOR_IN
30177: IFFALSE 30298
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30179: LD_VAR 0 3
30183: PPUSH
30184: CALL_OW 256
30188: PUSH
30189: LD_INT 1000
30191: EQUAL
30192: PUSH
30193: LD_VAR 0 3
30197: PPUSH
30198: CALL_OW 314
30202: NOT
30203: AND
30204: IFFALSE 30238
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30206: LD_VAR 0 3
30210: PPUSH
30211: LD_EXP 91
30215: PUSH
30216: LD_VAR 0 2
30220: ARRAY
30221: PPUSH
30222: LD_VAR 0 3
30226: PPUSH
30227: CALL_OW 74
30231: PPUSH
30232: CALL_OW 130
30236: GO 30296
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30238: LD_VAR 0 3
30242: PPUSH
30243: CALL_OW 256
30247: PUSH
30248: LD_INT 500
30250: LESS
30251: PUSH
30252: LD_VAR 0 3
30256: PPUSH
30257: LD_EXP 114
30261: PUSH
30262: LD_VAR 0 2
30266: ARRAY
30267: PPUSH
30268: CALL_OW 308
30272: NOT
30273: AND
30274: IFFALSE 30296
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30276: LD_VAR 0 3
30280: PPUSH
30281: LD_EXP 114
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: PPUSH
30292: CALL_OW 113
// end ;
30296: GO 30176
30298: POP
30299: POP
// end ; if tmp > 3 then
30300: LD_VAR 0 5
30304: PUSH
30305: LD_INT 3
30307: GREATER
30308: IFFALSE 30328
// tmp := ShrinkArray ( tmp , 4 ) ;
30310: LD_ADDR_VAR 0 5
30314: PUSH
30315: LD_VAR 0 5
30319: PPUSH
30320: LD_INT 4
30322: PPUSH
30323: CALL 87172 0 2
30327: ST_TO_ADDR
// if not tmp then
30328: LD_VAR 0 5
30332: NOT
30333: IFFALSE 30337
// continue ;
30335: GO 29767
// for j in tmp do
30337: LD_ADDR_VAR 0 3
30341: PUSH
30342: LD_VAR 0 5
30346: PUSH
30347: FOR_IN
30348: IFFALSE 30607
// begin if IsInUnit ( j ) then
30350: LD_VAR 0 3
30354: PPUSH
30355: CALL_OW 310
30359: IFFALSE 30370
// ComExitBuilding ( j ) ;
30361: LD_VAR 0 3
30365: PPUSH
30366: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30370: LD_VAR 0 3
30374: PUSH
30375: LD_EXP 92
30379: PUSH
30380: LD_VAR 0 2
30384: ARRAY
30385: IN
30386: NOT
30387: IFFALSE 30445
// begin SetTag ( j , 101 ) ;
30389: LD_VAR 0 3
30393: PPUSH
30394: LD_INT 101
30396: PPUSH
30397: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30401: LD_ADDR_EXP 92
30405: PUSH
30406: LD_EXP 92
30410: PPUSH
30411: LD_VAR 0 2
30415: PUSH
30416: LD_EXP 92
30420: PUSH
30421: LD_VAR 0 2
30425: ARRAY
30426: PUSH
30427: LD_INT 1
30429: PLUS
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PPUSH
30435: LD_VAR 0 3
30439: PPUSH
30440: CALL 55814 0 3
30444: ST_TO_ADDR
// end ; wait ( 1 ) ;
30445: LD_INT 1
30447: PPUSH
30448: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30452: LD_ADDR_VAR 0 7
30456: PUSH
30457: LD_EXP 91
30461: PUSH
30462: LD_VAR 0 2
30466: ARRAY
30467: ST_TO_ADDR
// if mc_scan [ i ] then
30468: LD_EXP 113
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: IFFALSE 30540
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30480: LD_ADDR_VAR 0 7
30484: PUSH
30485: LD_EXP 91
30489: PUSH
30490: LD_VAR 0 2
30494: ARRAY
30495: PPUSH
30496: LD_INT 3
30498: PUSH
30499: LD_INT 30
30501: PUSH
30502: LD_INT 32
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 30
30511: PUSH
30512: LD_INT 33
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 30
30521: PUSH
30522: LD_INT 31
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: PPUSH
30535: CALL_OW 72
30539: ST_TO_ADDR
// if not to_repair_tmp then
30540: LD_VAR 0 7
30544: NOT
30545: IFFALSE 30549
// continue ;
30547: GO 30347
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30549: LD_ADDR_VAR 0 8
30553: PUSH
30554: LD_VAR 0 7
30558: PPUSH
30559: LD_VAR 0 3
30563: PPUSH
30564: CALL_OW 74
30568: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30569: LD_VAR 0 8
30573: PPUSH
30574: LD_INT 16
30576: PPUSH
30577: CALL 58407 0 2
30581: PUSH
30582: LD_INT 4
30584: ARRAY
30585: PUSH
30586: LD_INT 10
30588: LESS
30589: IFFALSE 30605
// ComRepairBuilding ( j , to_repair ) ;
30591: LD_VAR 0 3
30595: PPUSH
30596: LD_VAR 0 8
30600: PPUSH
30601: CALL_OW 130
// end ;
30605: GO 30347
30607: POP
30608: POP
// end ;
30609: GO 29767
30611: POP
30612: POP
// end ;
30613: LD_VAR 0 1
30617: RET
// export function MC_Heal ; var i , j , tmp ; begin
30618: LD_INT 0
30620: PPUSH
30621: PPUSH
30622: PPUSH
30623: PPUSH
// if not mc_bases then
30624: LD_EXP 90
30628: NOT
30629: IFFALSE 30633
// exit ;
30631: GO 31035
// for i = 1 to mc_bases do
30633: LD_ADDR_VAR 0 2
30637: PUSH
30638: DOUBLE
30639: LD_INT 1
30641: DEC
30642: ST_TO_ADDR
30643: LD_EXP 90
30647: PUSH
30648: FOR_TO
30649: IFFALSE 31033
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30651: LD_EXP 93
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: PUSH
30662: LD_INT 1
30664: ARRAY
30665: NOT
30666: PUSH
30667: LD_EXP 93
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: PUSH
30678: LD_INT 2
30680: ARRAY
30681: NOT
30682: AND
30683: IFFALSE 30721
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30685: LD_ADDR_EXP 94
30689: PUSH
30690: LD_EXP 94
30694: PPUSH
30695: LD_VAR 0 2
30699: PPUSH
30700: EMPTY
30701: PPUSH
30702: CALL_OW 1
30706: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30707: LD_VAR 0 2
30711: PPUSH
30712: LD_INT 102
30714: PPUSH
30715: CALL 24856 0 2
// continue ;
30719: GO 30648
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30721: LD_ADDR_VAR 0 4
30725: PUSH
30726: LD_EXP 90
30730: PUSH
30731: LD_VAR 0 2
30735: ARRAY
30736: PPUSH
30737: LD_INT 25
30739: PUSH
30740: LD_INT 4
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PPUSH
30747: CALL_OW 72
30751: ST_TO_ADDR
// if not tmp then
30752: LD_VAR 0 4
30756: NOT
30757: IFFALSE 30761
// continue ;
30759: GO 30648
// if mc_taming [ i ] then
30761: LD_EXP 121
30765: PUSH
30766: LD_VAR 0 2
30770: ARRAY
30771: IFFALSE 30795
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30773: LD_ADDR_EXP 121
30777: PUSH
30778: LD_EXP 121
30782: PPUSH
30783: LD_VAR 0 2
30787: PPUSH
30788: EMPTY
30789: PPUSH
30790: CALL_OW 1
30794: ST_TO_ADDR
// for j in tmp do
30795: LD_ADDR_VAR 0 3
30799: PUSH
30800: LD_VAR 0 4
30804: PUSH
30805: FOR_IN
30806: IFFALSE 31029
// begin if IsInUnit ( j ) then
30808: LD_VAR 0 3
30812: PPUSH
30813: CALL_OW 310
30817: IFFALSE 30828
// ComExitBuilding ( j ) ;
30819: LD_VAR 0 3
30823: PPUSH
30824: CALL_OW 122
// if not j in mc_healers [ i ] then
30828: LD_VAR 0 3
30832: PUSH
30833: LD_EXP 94
30837: PUSH
30838: LD_VAR 0 2
30842: ARRAY
30843: IN
30844: NOT
30845: IFFALSE 30891
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30847: LD_ADDR_EXP 94
30851: PUSH
30852: LD_EXP 94
30856: PPUSH
30857: LD_VAR 0 2
30861: PUSH
30862: LD_EXP 94
30866: PUSH
30867: LD_VAR 0 2
30871: ARRAY
30872: PUSH
30873: LD_INT 1
30875: PLUS
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PPUSH
30881: LD_VAR 0 3
30885: PPUSH
30886: CALL 55814 0 3
30890: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30891: LD_VAR 0 3
30895: PPUSH
30896: CALL_OW 110
30900: PUSH
30901: LD_INT 102
30903: NONEQUAL
30904: IFFALSE 30918
// SetTag ( j , 102 ) ;
30906: LD_VAR 0 3
30910: PPUSH
30911: LD_INT 102
30913: PPUSH
30914: CALL_OW 109
// Wait ( 3 ) ;
30918: LD_INT 3
30920: PPUSH
30921: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30925: LD_EXP 93
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PUSH
30936: LD_INT 1
30938: ARRAY
30939: IFFALSE 30971
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30941: LD_VAR 0 3
30945: PPUSH
30946: LD_EXP 93
30950: PUSH
30951: LD_VAR 0 2
30955: ARRAY
30956: PUSH
30957: LD_INT 1
30959: ARRAY
30960: PUSH
30961: LD_INT 1
30963: ARRAY
30964: PPUSH
30965: CALL_OW 128
30969: GO 31027
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30971: LD_VAR 0 3
30975: PPUSH
30976: CALL_OW 314
30980: NOT
30981: PUSH
30982: LD_EXP 93
30986: PUSH
30987: LD_VAR 0 2
30991: ARRAY
30992: PUSH
30993: LD_INT 2
30995: ARRAY
30996: AND
30997: IFFALSE 31027
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30999: LD_VAR 0 3
31003: PPUSH
31004: LD_EXP 93
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PUSH
31015: LD_INT 2
31017: ARRAY
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: PPUSH
31023: CALL_OW 128
// end ;
31027: GO 30805
31029: POP
31030: POP
// end ;
31031: GO 30648
31033: POP
31034: POP
// end ;
31035: LD_VAR 0 1
31039: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31040: LD_INT 0
31042: PPUSH
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
// if not mc_bases then
31047: LD_EXP 90
31051: NOT
31052: IFFALSE 31056
// exit ;
31054: GO 32199
// for i = 1 to mc_bases do
31056: LD_ADDR_VAR 0 2
31060: PUSH
31061: DOUBLE
31062: LD_INT 1
31064: DEC
31065: ST_TO_ADDR
31066: LD_EXP 90
31070: PUSH
31071: FOR_TO
31072: IFFALSE 32197
// begin if mc_scan [ i ] then
31074: LD_EXP 113
31078: PUSH
31079: LD_VAR 0 2
31083: ARRAY
31084: IFFALSE 31088
// continue ;
31086: GO 31071
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31088: LD_EXP 95
31092: PUSH
31093: LD_VAR 0 2
31097: ARRAY
31098: NOT
31099: PUSH
31100: LD_EXP 97
31104: PUSH
31105: LD_VAR 0 2
31109: ARRAY
31110: NOT
31111: AND
31112: PUSH
31113: LD_EXP 96
31117: PUSH
31118: LD_VAR 0 2
31122: ARRAY
31123: AND
31124: IFFALSE 31162
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31126: LD_ADDR_EXP 96
31130: PUSH
31131: LD_EXP 96
31135: PPUSH
31136: LD_VAR 0 2
31140: PPUSH
31141: EMPTY
31142: PPUSH
31143: CALL_OW 1
31147: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31148: LD_VAR 0 2
31152: PPUSH
31153: LD_INT 103
31155: PPUSH
31156: CALL 24856 0 2
// continue ;
31160: GO 31071
// end ; if mc_construct_list [ i ] then
31162: LD_EXP 97
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: IFFALSE 31392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31174: LD_ADDR_VAR 0 4
31178: PUSH
31179: LD_EXP 90
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PPUSH
31190: LD_INT 25
31192: PUSH
31193: LD_INT 2
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PPUSH
31200: CALL_OW 72
31204: PUSH
31205: LD_EXP 92
31209: PUSH
31210: LD_VAR 0 2
31214: ARRAY
31215: DIFF
31216: ST_TO_ADDR
// if not tmp then
31217: LD_VAR 0 4
31221: NOT
31222: IFFALSE 31226
// continue ;
31224: GO 31071
// for j in tmp do
31226: LD_ADDR_VAR 0 3
31230: PUSH
31231: LD_VAR 0 4
31235: PUSH
31236: FOR_IN
31237: IFFALSE 31388
// begin if not mc_builders [ i ] then
31239: LD_EXP 96
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: NOT
31250: IFFALSE 31308
// begin SetTag ( j , 103 ) ;
31252: LD_VAR 0 3
31256: PPUSH
31257: LD_INT 103
31259: PPUSH
31260: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31264: LD_ADDR_EXP 96
31268: PUSH
31269: LD_EXP 96
31273: PPUSH
31274: LD_VAR 0 2
31278: PUSH
31279: LD_EXP 96
31283: PUSH
31284: LD_VAR 0 2
31288: ARRAY
31289: PUSH
31290: LD_INT 1
31292: PLUS
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PPUSH
31298: LD_VAR 0 3
31302: PPUSH
31303: CALL 55814 0 3
31307: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31308: LD_VAR 0 3
31312: PPUSH
31313: CALL_OW 310
31317: IFFALSE 31328
// ComExitBuilding ( j ) ;
31319: LD_VAR 0 3
31323: PPUSH
31324: CALL_OW 122
// wait ( 3 ) ;
31328: LD_INT 3
31330: PPUSH
31331: CALL_OW 67
// if not mc_construct_list [ i ] then
31335: LD_EXP 97
31339: PUSH
31340: LD_VAR 0 2
31344: ARRAY
31345: NOT
31346: IFFALSE 31350
// break ;
31348: GO 31388
// if not HasTask ( j ) then
31350: LD_VAR 0 3
31354: PPUSH
31355: CALL_OW 314
31359: NOT
31360: IFFALSE 31386
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31362: LD_VAR 0 3
31366: PPUSH
31367: LD_EXP 97
31371: PUSH
31372: LD_VAR 0 2
31376: ARRAY
31377: PUSH
31378: LD_INT 1
31380: ARRAY
31381: PPUSH
31382: CALL 58665 0 2
// end ;
31386: GO 31236
31388: POP
31389: POP
// end else
31390: GO 32195
// if mc_build_list [ i ] then
31392: LD_EXP 95
31396: PUSH
31397: LD_VAR 0 2
31401: ARRAY
31402: IFFALSE 32195
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31404: LD_ADDR_VAR 0 5
31408: PUSH
31409: LD_EXP 90
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PPUSH
31420: LD_INT 2
31422: PUSH
31423: LD_INT 30
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 30
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: LIST
31447: PPUSH
31448: CALL_OW 72
31452: ST_TO_ADDR
// if depot then
31453: LD_VAR 0 5
31457: IFFALSE 31475
// depot := depot [ 1 ] else
31459: LD_ADDR_VAR 0 5
31463: PUSH
31464: LD_VAR 0 5
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: ST_TO_ADDR
31473: GO 31483
// depot := 0 ;
31475: LD_ADDR_VAR 0 5
31479: PUSH
31480: LD_INT 0
31482: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31483: LD_EXP 95
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: PUSH
31494: LD_INT 1
31496: ARRAY
31497: PUSH
31498: LD_INT 1
31500: ARRAY
31501: PPUSH
31502: CALL 58495 0 1
31506: PUSH
31507: LD_EXP 90
31511: PUSH
31512: LD_VAR 0 2
31516: ARRAY
31517: PPUSH
31518: LD_INT 2
31520: PUSH
31521: LD_INT 30
31523: PUSH
31524: LD_INT 2
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 30
31533: PUSH
31534: LD_INT 3
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: LIST
31545: PPUSH
31546: CALL_OW 72
31550: NOT
31551: AND
31552: IFFALSE 31657
// begin for j = 1 to mc_build_list [ i ] do
31554: LD_ADDR_VAR 0 3
31558: PUSH
31559: DOUBLE
31560: LD_INT 1
31562: DEC
31563: ST_TO_ADDR
31564: LD_EXP 95
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: FOR_TO
31576: IFFALSE 31655
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31578: LD_EXP 95
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 1
31597: ARRAY
31598: PUSH
31599: LD_INT 2
31601: EQUAL
31602: IFFALSE 31653
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31604: LD_ADDR_EXP 95
31608: PUSH
31609: LD_EXP 95
31613: PPUSH
31614: LD_VAR 0 2
31618: PPUSH
31619: LD_EXP 95
31623: PUSH
31624: LD_VAR 0 2
31628: ARRAY
31629: PPUSH
31630: LD_VAR 0 3
31634: PPUSH
31635: LD_INT 1
31637: PPUSH
31638: LD_INT 0
31640: PPUSH
31641: CALL 55232 0 4
31645: PPUSH
31646: CALL_OW 1
31650: ST_TO_ADDR
// break ;
31651: GO 31655
// end ;
31653: GO 31575
31655: POP
31656: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31657: LD_EXP 95
31661: PUSH
31662: LD_VAR 0 2
31666: ARRAY
31667: PUSH
31668: LD_INT 1
31670: ARRAY
31671: PUSH
31672: LD_INT 1
31674: ARRAY
31675: PUSH
31676: LD_INT 0
31678: EQUAL
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_VAR 0 5
31689: PPUSH
31690: LD_EXP 95
31694: PUSH
31695: LD_VAR 0 2
31699: ARRAY
31700: PUSH
31701: LD_INT 1
31703: ARRAY
31704: PUSH
31705: LD_INT 1
31707: ARRAY
31708: PPUSH
31709: LD_EXP 95
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: PUSH
31720: LD_INT 1
31722: ARRAY
31723: PUSH
31724: LD_INT 2
31726: ARRAY
31727: PPUSH
31728: LD_EXP 95
31732: PUSH
31733: LD_VAR 0 2
31737: ARRAY
31738: PUSH
31739: LD_INT 1
31741: ARRAY
31742: PUSH
31743: LD_INT 3
31745: ARRAY
31746: PPUSH
31747: LD_EXP 95
31751: PUSH
31752: LD_VAR 0 2
31756: ARRAY
31757: PUSH
31758: LD_INT 1
31760: ARRAY
31761: PUSH
31762: LD_INT 4
31764: ARRAY
31765: PPUSH
31766: CALL 63229 0 5
31770: AND
31771: OR
31772: IFFALSE 32053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31774: LD_ADDR_VAR 0 4
31778: PUSH
31779: LD_EXP 90
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: PPUSH
31790: LD_INT 25
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PPUSH
31800: CALL_OW 72
31804: PUSH
31805: LD_EXP 92
31809: PUSH
31810: LD_VAR 0 2
31814: ARRAY
31815: DIFF
31816: ST_TO_ADDR
// if not tmp then
31817: LD_VAR 0 4
31821: NOT
31822: IFFALSE 31826
// continue ;
31824: GO 31071
// for j in tmp do
31826: LD_ADDR_VAR 0 3
31830: PUSH
31831: LD_VAR 0 4
31835: PUSH
31836: FOR_IN
31837: IFFALSE 32049
// begin if not mc_builders [ i ] then
31839: LD_EXP 96
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: NOT
31850: IFFALSE 31908
// begin SetTag ( j , 103 ) ;
31852: LD_VAR 0 3
31856: PPUSH
31857: LD_INT 103
31859: PPUSH
31860: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31864: LD_ADDR_EXP 96
31868: PUSH
31869: LD_EXP 96
31873: PPUSH
31874: LD_VAR 0 2
31878: PUSH
31879: LD_EXP 96
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: PLUS
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PPUSH
31898: LD_VAR 0 3
31902: PPUSH
31903: CALL 55814 0 3
31907: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31908: LD_VAR 0 3
31912: PPUSH
31913: CALL_OW 310
31917: IFFALSE 31928
// ComExitBuilding ( j ) ;
31919: LD_VAR 0 3
31923: PPUSH
31924: CALL_OW 122
// wait ( 3 ) ;
31928: LD_INT 3
31930: PPUSH
31931: CALL_OW 67
// if not mc_build_list [ i ] then
31935: LD_EXP 95
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: NOT
31946: IFFALSE 31950
// break ;
31948: GO 32049
// if not HasTask ( j ) then
31950: LD_VAR 0 3
31954: PPUSH
31955: CALL_OW 314
31959: NOT
31960: IFFALSE 32047
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31962: LD_VAR 0 3
31966: PPUSH
31967: LD_EXP 95
31971: PUSH
31972: LD_VAR 0 2
31976: ARRAY
31977: PUSH
31978: LD_INT 1
31980: ARRAY
31981: PUSH
31982: LD_INT 1
31984: ARRAY
31985: PPUSH
31986: LD_EXP 95
31990: PUSH
31991: LD_VAR 0 2
31995: ARRAY
31996: PUSH
31997: LD_INT 1
31999: ARRAY
32000: PUSH
32001: LD_INT 2
32003: ARRAY
32004: PPUSH
32005: LD_EXP 95
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: PUSH
32016: LD_INT 1
32018: ARRAY
32019: PUSH
32020: LD_INT 3
32022: ARRAY
32023: PPUSH
32024: LD_EXP 95
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: PUSH
32035: LD_INT 1
32037: ARRAY
32038: PUSH
32039: LD_INT 4
32041: ARRAY
32042: PPUSH
32043: CALL_OW 145
// end ;
32047: GO 31836
32049: POP
32050: POP
// end else
32051: GO 32195
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32053: LD_EXP 90
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: PPUSH
32064: LD_EXP 95
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PUSH
32075: LD_INT 1
32077: ARRAY
32078: PUSH
32079: LD_INT 1
32081: ARRAY
32082: PPUSH
32083: LD_EXP 95
32087: PUSH
32088: LD_VAR 0 2
32092: ARRAY
32093: PUSH
32094: LD_INT 1
32096: ARRAY
32097: PUSH
32098: LD_INT 2
32100: ARRAY
32101: PPUSH
32102: LD_EXP 95
32106: PUSH
32107: LD_VAR 0 2
32111: ARRAY
32112: PUSH
32113: LD_INT 1
32115: ARRAY
32116: PUSH
32117: LD_INT 3
32119: ARRAY
32120: PPUSH
32121: LD_EXP 95
32125: PUSH
32126: LD_VAR 0 2
32130: ARRAY
32131: PUSH
32132: LD_INT 1
32134: ARRAY
32135: PUSH
32136: LD_INT 4
32138: ARRAY
32139: PPUSH
32140: CALL 62565 0 5
32144: NOT
32145: IFFALSE 32195
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32147: LD_ADDR_EXP 95
32151: PUSH
32152: LD_EXP 95
32156: PPUSH
32157: LD_VAR 0 2
32161: PPUSH
32162: LD_EXP 95
32166: PUSH
32167: LD_VAR 0 2
32171: ARRAY
32172: PPUSH
32173: LD_INT 1
32175: PPUSH
32176: LD_INT 1
32178: NEG
32179: PPUSH
32180: LD_INT 0
32182: PPUSH
32183: CALL 55232 0 4
32187: PPUSH
32188: CALL_OW 1
32192: ST_TO_ADDR
// continue ;
32193: GO 31071
// end ; end ; end ;
32195: GO 31071
32197: POP
32198: POP
// end ;
32199: LD_VAR 0 1
32203: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
32211: PPUSH
// if not mc_bases then
32212: LD_EXP 90
32216: NOT
32217: IFFALSE 32221
// exit ;
32219: GO 32648
// for i = 1 to mc_bases do
32221: LD_ADDR_VAR 0 2
32225: PUSH
32226: DOUBLE
32227: LD_INT 1
32229: DEC
32230: ST_TO_ADDR
32231: LD_EXP 90
32235: PUSH
32236: FOR_TO
32237: IFFALSE 32646
// begin tmp := mc_build_upgrade [ i ] ;
32239: LD_ADDR_VAR 0 4
32243: PUSH
32244: LD_EXP 122
32248: PUSH
32249: LD_VAR 0 2
32253: ARRAY
32254: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32255: LD_ADDR_VAR 0 6
32259: PUSH
32260: LD_EXP 123
32264: PUSH
32265: LD_VAR 0 2
32269: ARRAY
32270: PPUSH
32271: LD_INT 2
32273: PUSH
32274: LD_INT 30
32276: PUSH
32277: LD_INT 6
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 30
32286: PUSH
32287: LD_INT 7
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: LIST
32298: PPUSH
32299: CALL_OW 72
32303: ST_TO_ADDR
// if not tmp and not lab then
32304: LD_VAR 0 4
32308: NOT
32309: PUSH
32310: LD_VAR 0 6
32314: NOT
32315: AND
32316: IFFALSE 32320
// continue ;
32318: GO 32236
// if tmp then
32320: LD_VAR 0 4
32324: IFFALSE 32444
// for j in tmp do
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 4
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32442
// begin if UpgradeCost ( j ) then
32339: LD_VAR 0 3
32343: PPUSH
32344: CALL 62225 0 1
32348: IFFALSE 32440
// begin ComUpgrade ( j ) ;
32350: LD_VAR 0 3
32354: PPUSH
32355: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32359: LD_ADDR_EXP 122
32363: PUSH
32364: LD_EXP 122
32368: PPUSH
32369: LD_VAR 0 2
32373: PPUSH
32374: LD_EXP 122
32378: PUSH
32379: LD_VAR 0 2
32383: ARRAY
32384: PUSH
32385: LD_VAR 0 3
32389: DIFF
32390: PPUSH
32391: CALL_OW 1
32395: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32396: LD_ADDR_EXP 97
32400: PUSH
32401: LD_EXP 97
32405: PPUSH
32406: LD_VAR 0 2
32410: PUSH
32411: LD_EXP 97
32415: PUSH
32416: LD_VAR 0 2
32420: ARRAY
32421: PUSH
32422: LD_INT 1
32424: PLUS
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PPUSH
32430: LD_VAR 0 3
32434: PPUSH
32435: CALL 55814 0 3
32439: ST_TO_ADDR
// end ; end ;
32440: GO 32336
32442: POP
32443: POP
// if not lab or not mc_lab_upgrade [ i ] then
32444: LD_VAR 0 6
32448: NOT
32449: PUSH
32450: LD_EXP 124
32454: PUSH
32455: LD_VAR 0 2
32459: ARRAY
32460: NOT
32461: OR
32462: IFFALSE 32466
// continue ;
32464: GO 32236
// for j in lab do
32466: LD_ADDR_VAR 0 3
32470: PUSH
32471: LD_VAR 0 6
32475: PUSH
32476: FOR_IN
32477: IFFALSE 32642
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32479: LD_VAR 0 3
32483: PPUSH
32484: CALL_OW 266
32488: PUSH
32489: LD_INT 6
32491: PUSH
32492: LD_INT 7
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: IN
32499: PUSH
32500: LD_VAR 0 3
32504: PPUSH
32505: CALL_OW 461
32509: PUSH
32510: LD_INT 1
32512: NONEQUAL
32513: AND
32514: IFFALSE 32640
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32516: LD_VAR 0 3
32520: PPUSH
32521: LD_EXP 124
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PUSH
32532: LD_INT 1
32534: ARRAY
32535: PPUSH
32536: CALL 62430 0 2
32540: IFFALSE 32640
// begin ComCancel ( j ) ;
32542: LD_VAR 0 3
32546: PPUSH
32547: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32551: LD_VAR 0 3
32555: PPUSH
32556: LD_EXP 124
32560: PUSH
32561: LD_VAR 0 2
32565: ARRAY
32566: PUSH
32567: LD_INT 1
32569: ARRAY
32570: PPUSH
32571: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32575: LD_VAR 0 3
32579: PUSH
32580: LD_EXP 97
32584: PUSH
32585: LD_VAR 0 2
32589: ARRAY
32590: IN
32591: NOT
32592: IFFALSE 32638
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32594: LD_ADDR_EXP 97
32598: PUSH
32599: LD_EXP 97
32603: PPUSH
32604: LD_VAR 0 2
32608: PUSH
32609: LD_EXP 97
32613: PUSH
32614: LD_VAR 0 2
32618: ARRAY
32619: PUSH
32620: LD_INT 1
32622: PLUS
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: LD_VAR 0 3
32632: PPUSH
32633: CALL 55814 0 3
32637: ST_TO_ADDR
// break ;
32638: GO 32642
// end ; end ; end ;
32640: GO 32476
32642: POP
32643: POP
// end ;
32644: GO 32236
32646: POP
32647: POP
// end ;
32648: LD_VAR 0 1
32652: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32653: LD_INT 0
32655: PPUSH
32656: PPUSH
32657: PPUSH
32658: PPUSH
32659: PPUSH
32660: PPUSH
32661: PPUSH
32662: PPUSH
32663: PPUSH
// if not mc_bases then
32664: LD_EXP 90
32668: NOT
32669: IFFALSE 32673
// exit ;
32671: GO 33078
// for i = 1 to mc_bases do
32673: LD_ADDR_VAR 0 2
32677: PUSH
32678: DOUBLE
32679: LD_INT 1
32681: DEC
32682: ST_TO_ADDR
32683: LD_EXP 90
32687: PUSH
32688: FOR_TO
32689: IFFALSE 33076
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32691: LD_EXP 98
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: NOT
32702: PUSH
32703: LD_EXP 90
32707: PUSH
32708: LD_VAR 0 2
32712: ARRAY
32713: PPUSH
32714: LD_INT 30
32716: PUSH
32717: LD_INT 3
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PPUSH
32724: CALL_OW 72
32728: NOT
32729: OR
32730: IFFALSE 32734
// continue ;
32732: GO 32688
// busy := false ;
32734: LD_ADDR_VAR 0 8
32738: PUSH
32739: LD_INT 0
32741: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32742: LD_ADDR_VAR 0 4
32746: PUSH
32747: LD_EXP 90
32751: PUSH
32752: LD_VAR 0 2
32756: ARRAY
32757: PPUSH
32758: LD_INT 30
32760: PUSH
32761: LD_INT 3
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PPUSH
32768: CALL_OW 72
32772: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32773: LD_ADDR_VAR 0 6
32777: PUSH
32778: LD_EXP 98
32782: PUSH
32783: LD_VAR 0 2
32787: ARRAY
32788: PPUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 30
32794: PUSH
32795: LD_INT 32
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 30
32804: PUSH
32805: LD_INT 33
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: LIST
32816: PPUSH
32817: CALL_OW 72
32821: ST_TO_ADDR
// if not t then
32822: LD_VAR 0 6
32826: NOT
32827: IFFALSE 32831
// continue ;
32829: GO 32688
// for j in tmp do
32831: LD_ADDR_VAR 0 3
32835: PUSH
32836: LD_VAR 0 4
32840: PUSH
32841: FOR_IN
32842: IFFALSE 32872
// if not BuildingStatus ( j ) = bs_idle then
32844: LD_VAR 0 3
32848: PPUSH
32849: CALL_OW 461
32853: PUSH
32854: LD_INT 2
32856: EQUAL
32857: NOT
32858: IFFALSE 32870
// begin busy := true ;
32860: LD_ADDR_VAR 0 8
32864: PUSH
32865: LD_INT 1
32867: ST_TO_ADDR
// break ;
32868: GO 32872
// end ;
32870: GO 32841
32872: POP
32873: POP
// if busy then
32874: LD_VAR 0 8
32878: IFFALSE 32882
// continue ;
32880: GO 32688
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32882: LD_ADDR_VAR 0 7
32886: PUSH
32887: LD_VAR 0 6
32891: PPUSH
32892: LD_INT 35
32894: PUSH
32895: LD_INT 0
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PPUSH
32902: CALL_OW 72
32906: ST_TO_ADDR
// if tw then
32907: LD_VAR 0 7
32911: IFFALSE 32988
// begin tw := tw [ 1 ] ;
32913: LD_ADDR_VAR 0 7
32917: PUSH
32918: LD_VAR 0 7
32922: PUSH
32923: LD_INT 1
32925: ARRAY
32926: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32927: LD_ADDR_VAR 0 9
32931: PUSH
32932: LD_VAR 0 7
32936: PPUSH
32937: LD_EXP 115
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: PPUSH
32948: CALL 60784 0 2
32952: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32953: LD_EXP 129
32957: PUSH
32958: LD_VAR 0 2
32962: ARRAY
32963: IFFALSE 32986
// if not weapon in mc_allowed_tower_weapons [ i ] then
32965: LD_VAR 0 9
32969: PUSH
32970: LD_EXP 129
32974: PUSH
32975: LD_VAR 0 2
32979: ARRAY
32980: IN
32981: NOT
32982: IFFALSE 32986
// continue ;
32984: GO 32688
// end else
32986: GO 33051
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32988: LD_ADDR_VAR 0 5
32992: PUSH
32993: LD_EXP 98
32997: PUSH
32998: LD_VAR 0 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 4
33008: PPUSH
33009: CALL 86405 0 2
33013: ST_TO_ADDR
// if not tmp2 then
33014: LD_VAR 0 5
33018: NOT
33019: IFFALSE 33023
// continue ;
33021: GO 32688
// tw := tmp2 [ 1 ] ;
33023: LD_ADDR_VAR 0 7
33027: PUSH
33028: LD_VAR 0 5
33032: PUSH
33033: LD_INT 1
33035: ARRAY
33036: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33037: LD_ADDR_VAR 0 9
33041: PUSH
33042: LD_VAR 0 5
33046: PUSH
33047: LD_INT 2
33049: ARRAY
33050: ST_TO_ADDR
// end ; if not weapon then
33051: LD_VAR 0 9
33055: NOT
33056: IFFALSE 33060
// continue ;
33058: GO 32688
// ComPlaceWeapon ( tw , weapon ) ;
33060: LD_VAR 0 7
33064: PPUSH
33065: LD_VAR 0 9
33069: PPUSH
33070: CALL_OW 148
// end ;
33074: GO 32688
33076: POP
33077: POP
// end ;
33078: LD_VAR 0 1
33082: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
33083: LD_INT 0
33085: PPUSH
33086: PPUSH
33087: PPUSH
33088: PPUSH
33089: PPUSH
33090: PPUSH
// if not mc_bases then
33091: LD_EXP 90
33095: NOT
33096: IFFALSE 33100
// exit ;
33098: GO 33876
// for i = 1 to mc_bases do
33100: LD_ADDR_VAR 0 2
33104: PUSH
33105: DOUBLE
33106: LD_INT 1
33108: DEC
33109: ST_TO_ADDR
33110: LD_EXP 90
33114: PUSH
33115: FOR_TO
33116: IFFALSE 33874
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33118: LD_EXP 103
33122: PUSH
33123: LD_VAR 0 2
33127: ARRAY
33128: NOT
33129: PUSH
33130: LD_EXP 103
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PUSH
33141: LD_EXP 104
33145: PUSH
33146: LD_VAR 0 2
33150: ARRAY
33151: EQUAL
33152: OR
33153: PUSH
33154: LD_EXP 113
33158: PUSH
33159: LD_VAR 0 2
33163: ARRAY
33164: OR
33165: IFFALSE 33169
// continue ;
33167: GO 33115
// if mc_miners [ i ] then
33169: LD_EXP 104
33173: PUSH
33174: LD_VAR 0 2
33178: ARRAY
33179: IFFALSE 33561
// begin for j = mc_miners [ i ] downto 1 do
33181: LD_ADDR_VAR 0 3
33185: PUSH
33186: DOUBLE
33187: LD_EXP 104
33191: PUSH
33192: LD_VAR 0 2
33196: ARRAY
33197: INC
33198: ST_TO_ADDR
33199: LD_INT 1
33201: PUSH
33202: FOR_DOWNTO
33203: IFFALSE 33559
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33205: LD_EXP 104
33209: PUSH
33210: LD_VAR 0 2
33214: ARRAY
33215: PUSH
33216: LD_VAR 0 3
33220: ARRAY
33221: PPUSH
33222: CALL_OW 301
33226: PUSH
33227: LD_EXP 104
33231: PUSH
33232: LD_VAR 0 2
33236: ARRAY
33237: PUSH
33238: LD_VAR 0 3
33242: ARRAY
33243: PPUSH
33244: CALL_OW 257
33248: PUSH
33249: LD_INT 1
33251: NONEQUAL
33252: OR
33253: IFFALSE 33316
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33255: LD_ADDR_VAR 0 5
33259: PUSH
33260: LD_EXP 104
33264: PUSH
33265: LD_VAR 0 2
33269: ARRAY
33270: PUSH
33271: LD_EXP 104
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PUSH
33282: LD_VAR 0 3
33286: ARRAY
33287: DIFF
33288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33289: LD_ADDR_EXP 104
33293: PUSH
33294: LD_EXP 104
33298: PPUSH
33299: LD_VAR 0 2
33303: PPUSH
33304: LD_VAR 0 5
33308: PPUSH
33309: CALL_OW 1
33313: ST_TO_ADDR
// continue ;
33314: GO 33202
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33316: LD_EXP 104
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: PUSH
33327: LD_VAR 0 3
33331: ARRAY
33332: PPUSH
33333: CALL_OW 257
33337: PUSH
33338: LD_INT 1
33340: EQUAL
33341: PUSH
33342: LD_EXP 104
33346: PUSH
33347: LD_VAR 0 2
33351: ARRAY
33352: PUSH
33353: LD_VAR 0 3
33357: ARRAY
33358: PPUSH
33359: CALL_OW 459
33363: NOT
33364: AND
33365: PUSH
33366: LD_EXP 104
33370: PUSH
33371: LD_VAR 0 2
33375: ARRAY
33376: PUSH
33377: LD_VAR 0 3
33381: ARRAY
33382: PPUSH
33383: CALL_OW 314
33387: NOT
33388: AND
33389: IFFALSE 33557
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33391: LD_EXP 104
33395: PUSH
33396: LD_VAR 0 2
33400: ARRAY
33401: PUSH
33402: LD_VAR 0 3
33406: ARRAY
33407: PPUSH
33408: CALL_OW 310
33412: IFFALSE 33435
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33414: LD_EXP 104
33418: PUSH
33419: LD_VAR 0 2
33423: ARRAY
33424: PUSH
33425: LD_VAR 0 3
33429: ARRAY
33430: PPUSH
33431: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33435: LD_EXP 104
33439: PUSH
33440: LD_VAR 0 2
33444: ARRAY
33445: PUSH
33446: LD_VAR 0 3
33450: ARRAY
33451: PPUSH
33452: CALL_OW 314
33456: NOT
33457: IFFALSE 33557
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33459: LD_EXP 104
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: PUSH
33470: LD_VAR 0 3
33474: ARRAY
33475: PPUSH
33476: LD_EXP 103
33480: PUSH
33481: LD_VAR 0 2
33485: ARRAY
33486: PUSH
33487: LD_VAR 0 3
33491: PUSH
33492: LD_EXP 103
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: MOD
33503: PUSH
33504: LD_INT 1
33506: PLUS
33507: ARRAY
33508: PUSH
33509: LD_INT 1
33511: ARRAY
33512: PPUSH
33513: LD_EXP 103
33517: PUSH
33518: LD_VAR 0 2
33522: ARRAY
33523: PUSH
33524: LD_VAR 0 3
33528: PUSH
33529: LD_EXP 103
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: MOD
33540: PUSH
33541: LD_INT 1
33543: PLUS
33544: ARRAY
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PPUSH
33550: LD_INT 0
33552: PPUSH
33553: CALL_OW 193
// end ; end ;
33557: GO 33202
33559: POP
33560: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33561: LD_ADDR_VAR 0 5
33565: PUSH
33566: LD_EXP 90
33570: PUSH
33571: LD_VAR 0 2
33575: ARRAY
33576: PPUSH
33577: LD_INT 2
33579: PUSH
33580: LD_INT 30
33582: PUSH
33583: LD_INT 4
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 30
33592: PUSH
33593: LD_INT 5
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 30
33602: PUSH
33603: LD_INT 32
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 72
33620: ST_TO_ADDR
// if not tmp then
33621: LD_VAR 0 5
33625: NOT
33626: IFFALSE 33630
// continue ;
33628: GO 33115
// list := [ ] ;
33630: LD_ADDR_VAR 0 6
33634: PUSH
33635: EMPTY
33636: ST_TO_ADDR
// for j in tmp do
33637: LD_ADDR_VAR 0 3
33641: PUSH
33642: LD_VAR 0 5
33646: PUSH
33647: FOR_IN
33648: IFFALSE 33717
// begin for k in UnitsInside ( j ) do
33650: LD_ADDR_VAR 0 4
33654: PUSH
33655: LD_VAR 0 3
33659: PPUSH
33660: CALL_OW 313
33664: PUSH
33665: FOR_IN
33666: IFFALSE 33713
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33668: LD_VAR 0 4
33672: PPUSH
33673: CALL_OW 257
33677: PUSH
33678: LD_INT 1
33680: EQUAL
33681: PUSH
33682: LD_VAR 0 4
33686: PPUSH
33687: CALL_OW 459
33691: NOT
33692: AND
33693: IFFALSE 33711
// list := list ^ k ;
33695: LD_ADDR_VAR 0 6
33699: PUSH
33700: LD_VAR 0 6
33704: PUSH
33705: LD_VAR 0 4
33709: ADD
33710: ST_TO_ADDR
33711: GO 33665
33713: POP
33714: POP
// end ;
33715: GO 33647
33717: POP
33718: POP
// list := list diff mc_miners [ i ] ;
33719: LD_ADDR_VAR 0 6
33723: PUSH
33724: LD_VAR 0 6
33728: PUSH
33729: LD_EXP 104
33733: PUSH
33734: LD_VAR 0 2
33738: ARRAY
33739: DIFF
33740: ST_TO_ADDR
// if not list then
33741: LD_VAR 0 6
33745: NOT
33746: IFFALSE 33750
// continue ;
33748: GO 33115
// k := mc_mines [ i ] - mc_miners [ i ] ;
33750: LD_ADDR_VAR 0 4
33754: PUSH
33755: LD_EXP 103
33759: PUSH
33760: LD_VAR 0 2
33764: ARRAY
33765: PUSH
33766: LD_EXP 104
33770: PUSH
33771: LD_VAR 0 2
33775: ARRAY
33776: MINUS
33777: ST_TO_ADDR
// if k > list then
33778: LD_VAR 0 4
33782: PUSH
33783: LD_VAR 0 6
33787: GREATER
33788: IFFALSE 33800
// k := list ;
33790: LD_ADDR_VAR 0 4
33794: PUSH
33795: LD_VAR 0 6
33799: ST_TO_ADDR
// for j = 1 to k do
33800: LD_ADDR_VAR 0 3
33804: PUSH
33805: DOUBLE
33806: LD_INT 1
33808: DEC
33809: ST_TO_ADDR
33810: LD_VAR 0 4
33814: PUSH
33815: FOR_TO
33816: IFFALSE 33870
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33818: LD_ADDR_EXP 104
33822: PUSH
33823: LD_EXP 104
33827: PPUSH
33828: LD_VAR 0 2
33832: PUSH
33833: LD_EXP 104
33837: PUSH
33838: LD_VAR 0 2
33842: ARRAY
33843: PUSH
33844: LD_INT 1
33846: PLUS
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PPUSH
33852: LD_VAR 0 6
33856: PUSH
33857: LD_VAR 0 3
33861: ARRAY
33862: PPUSH
33863: CALL 55814 0 3
33867: ST_TO_ADDR
33868: GO 33815
33870: POP
33871: POP
// end ;
33872: GO 33115
33874: POP
33875: POP
// end ;
33876: LD_VAR 0 1
33880: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33881: LD_INT 0
33883: PPUSH
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
33888: PPUSH
33889: PPUSH
33890: PPUSH
33891: PPUSH
33892: PPUSH
// if not mc_bases then
33893: LD_EXP 90
33897: NOT
33898: IFFALSE 33902
// exit ;
33900: GO 35652
// for i = 1 to mc_bases do
33902: LD_ADDR_VAR 0 2
33906: PUSH
33907: DOUBLE
33908: LD_INT 1
33910: DEC
33911: ST_TO_ADDR
33912: LD_EXP 90
33916: PUSH
33917: FOR_TO
33918: IFFALSE 35650
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33920: LD_EXP 90
33924: PUSH
33925: LD_VAR 0 2
33929: ARRAY
33930: NOT
33931: PUSH
33932: LD_EXP 97
33936: PUSH
33937: LD_VAR 0 2
33941: ARRAY
33942: OR
33943: IFFALSE 33947
// continue ;
33945: GO 33917
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33947: LD_EXP 106
33951: PUSH
33952: LD_VAR 0 2
33956: ARRAY
33957: NOT
33958: PUSH
33959: LD_EXP 107
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: AND
33970: IFFALSE 34008
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33972: LD_ADDR_EXP 107
33976: PUSH
33977: LD_EXP 107
33981: PPUSH
33982: LD_VAR 0 2
33986: PPUSH
33987: EMPTY
33988: PPUSH
33989: CALL_OW 1
33993: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33994: LD_VAR 0 2
33998: PPUSH
33999: LD_INT 107
34001: PPUSH
34002: CALL 24856 0 2
// continue ;
34006: GO 33917
// end ; target := [ ] ;
34008: LD_ADDR_VAR 0 6
34012: PUSH
34013: EMPTY
34014: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34015: LD_ADDR_VAR 0 3
34019: PUSH
34020: DOUBLE
34021: LD_EXP 106
34025: PUSH
34026: LD_VAR 0 2
34030: ARRAY
34031: INC
34032: ST_TO_ADDR
34033: LD_INT 1
34035: PUSH
34036: FOR_DOWNTO
34037: IFFALSE 34297
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34039: LD_EXP 106
34043: PUSH
34044: LD_VAR 0 2
34048: ARRAY
34049: PUSH
34050: LD_VAR 0 3
34054: ARRAY
34055: PUSH
34056: LD_INT 2
34058: ARRAY
34059: PPUSH
34060: LD_EXP 106
34064: PUSH
34065: LD_VAR 0 2
34069: ARRAY
34070: PUSH
34071: LD_VAR 0 3
34075: ARRAY
34076: PUSH
34077: LD_INT 3
34079: ARRAY
34080: PPUSH
34081: CALL_OW 488
34085: PUSH
34086: LD_EXP 106
34090: PUSH
34091: LD_VAR 0 2
34095: ARRAY
34096: PUSH
34097: LD_VAR 0 3
34101: ARRAY
34102: PUSH
34103: LD_INT 2
34105: ARRAY
34106: PPUSH
34107: LD_EXP 106
34111: PUSH
34112: LD_VAR 0 2
34116: ARRAY
34117: PUSH
34118: LD_VAR 0 3
34122: ARRAY
34123: PUSH
34124: LD_INT 3
34126: ARRAY
34127: PPUSH
34128: CALL_OW 284
34132: PUSH
34133: LD_INT 0
34135: EQUAL
34136: AND
34137: IFFALSE 34192
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34139: LD_ADDR_VAR 0 5
34143: PUSH
34144: LD_EXP 106
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PPUSH
34155: LD_VAR 0 3
34159: PPUSH
34160: CALL_OW 3
34164: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34165: LD_ADDR_EXP 106
34169: PUSH
34170: LD_EXP 106
34174: PPUSH
34175: LD_VAR 0 2
34179: PPUSH
34180: LD_VAR 0 5
34184: PPUSH
34185: CALL_OW 1
34189: ST_TO_ADDR
// continue ;
34190: GO 34036
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34192: LD_EXP 90
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PUSH
34203: LD_INT 1
34205: ARRAY
34206: PPUSH
34207: CALL_OW 255
34211: PPUSH
34212: LD_EXP 106
34216: PUSH
34217: LD_VAR 0 2
34221: ARRAY
34222: PUSH
34223: LD_VAR 0 3
34227: ARRAY
34228: PUSH
34229: LD_INT 2
34231: ARRAY
34232: PPUSH
34233: LD_EXP 106
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PUSH
34244: LD_VAR 0 3
34248: ARRAY
34249: PUSH
34250: LD_INT 3
34252: ARRAY
34253: PPUSH
34254: LD_INT 30
34256: PPUSH
34257: CALL 56710 0 4
34261: PUSH
34262: LD_INT 4
34264: ARRAY
34265: PUSH
34266: LD_INT 0
34268: EQUAL
34269: IFFALSE 34295
// begin target := mc_crates [ i ] [ j ] ;
34271: LD_ADDR_VAR 0 6
34275: PUSH
34276: LD_EXP 106
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_VAR 0 3
34291: ARRAY
34292: ST_TO_ADDR
// break ;
34293: GO 34297
// end ; end ;
34295: GO 34036
34297: POP
34298: POP
// if not target then
34299: LD_VAR 0 6
34303: NOT
34304: IFFALSE 34308
// continue ;
34306: GO 33917
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34308: LD_ADDR_VAR 0 7
34312: PUSH
34313: LD_EXP 109
34317: PUSH
34318: LD_VAR 0 2
34322: ARRAY
34323: PPUSH
34324: LD_INT 2
34326: PUSH
34327: LD_INT 3
34329: PUSH
34330: LD_INT 58
34332: PUSH
34333: EMPTY
34334: LIST
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 61
34342: PUSH
34343: EMPTY
34344: LIST
34345: PUSH
34346: LD_INT 33
34348: PUSH
34349: LD_INT 5
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 33
34358: PUSH
34359: LD_INT 3
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 2
34375: PUSH
34376: LD_INT 34
34378: PUSH
34379: LD_INT 32
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 34
34388: PUSH
34389: LD_INT 51
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 34
34398: PUSH
34399: LD_INT 12
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PPUSH
34416: CALL_OW 72
34420: ST_TO_ADDR
// if not cargo then
34421: LD_VAR 0 7
34425: NOT
34426: IFFALSE 35069
// begin if mc_crates_collector [ i ] < 5 then
34428: LD_EXP 107
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PUSH
34439: LD_INT 5
34441: LESS
34442: IFFALSE 34808
// begin if mc_ape [ i ] then
34444: LD_EXP 119
34448: PUSH
34449: LD_VAR 0 2
34453: ARRAY
34454: IFFALSE 34501
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34456: LD_ADDR_VAR 0 5
34460: PUSH
34461: LD_EXP 119
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PPUSH
34472: LD_INT 25
34474: PUSH
34475: LD_INT 16
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 24
34484: PUSH
34485: LD_INT 750
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PPUSH
34496: CALL_OW 72
34500: ST_TO_ADDR
// if not tmp then
34501: LD_VAR 0 5
34505: NOT
34506: IFFALSE 34553
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34508: LD_ADDR_VAR 0 5
34512: PUSH
34513: LD_EXP 90
34517: PUSH
34518: LD_VAR 0 2
34522: ARRAY
34523: PPUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 2
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 24
34536: PUSH
34537: LD_INT 750
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34553: LD_EXP 119
34557: PUSH
34558: LD_VAR 0 2
34562: ARRAY
34563: PUSH
34564: LD_EXP 90
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: PPUSH
34575: LD_INT 25
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 24
34587: PUSH
34588: LD_INT 750
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PPUSH
34599: CALL_OW 72
34603: AND
34604: PUSH
34605: LD_VAR 0 5
34609: PUSH
34610: LD_INT 5
34612: LESS
34613: AND
34614: IFFALSE 34696
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34616: LD_ADDR_VAR 0 3
34620: PUSH
34621: LD_EXP 90
34625: PUSH
34626: LD_VAR 0 2
34630: ARRAY
34631: PPUSH
34632: LD_INT 25
34634: PUSH
34635: LD_INT 2
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 24
34644: PUSH
34645: LD_INT 750
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PPUSH
34656: CALL_OW 72
34660: PUSH
34661: FOR_IN
34662: IFFALSE 34694
// begin tmp := tmp union j ;
34664: LD_ADDR_VAR 0 5
34668: PUSH
34669: LD_VAR 0 5
34673: PUSH
34674: LD_VAR 0 3
34678: UNION
34679: ST_TO_ADDR
// if tmp >= 5 then
34680: LD_VAR 0 5
34684: PUSH
34685: LD_INT 5
34687: GREATEREQUAL
34688: IFFALSE 34692
// break ;
34690: GO 34694
// end ;
34692: GO 34661
34694: POP
34695: POP
// end ; if not tmp then
34696: LD_VAR 0 5
34700: NOT
34701: IFFALSE 34705
// continue ;
34703: GO 33917
// for j in tmp do
34705: LD_ADDR_VAR 0 3
34709: PUSH
34710: LD_VAR 0 5
34714: PUSH
34715: FOR_IN
34716: IFFALSE 34806
// if not GetTag ( j ) then
34718: LD_VAR 0 3
34722: PPUSH
34723: CALL_OW 110
34727: NOT
34728: IFFALSE 34804
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34730: LD_ADDR_EXP 107
34734: PUSH
34735: LD_EXP 107
34739: PPUSH
34740: LD_VAR 0 2
34744: PUSH
34745: LD_EXP 107
34749: PUSH
34750: LD_VAR 0 2
34754: ARRAY
34755: PUSH
34756: LD_INT 1
34758: PLUS
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PPUSH
34764: LD_VAR 0 3
34768: PPUSH
34769: CALL 55814 0 3
34773: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 107
34781: PPUSH
34782: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34786: LD_EXP 107
34790: PUSH
34791: LD_VAR 0 2
34795: ARRAY
34796: PUSH
34797: LD_INT 5
34799: GREATEREQUAL
34800: IFFALSE 34804
// break ;
34802: GO 34806
// end ;
34804: GO 34715
34806: POP
34807: POP
// end ; if mc_crates_collector [ i ] and target then
34808: LD_EXP 107
34812: PUSH
34813: LD_VAR 0 2
34817: ARRAY
34818: PUSH
34819: LD_VAR 0 6
34823: AND
34824: IFFALSE 35067
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34826: LD_EXP 107
34830: PUSH
34831: LD_VAR 0 2
34835: ARRAY
34836: PUSH
34837: LD_VAR 0 6
34841: PUSH
34842: LD_INT 1
34844: ARRAY
34845: LESS
34846: IFFALSE 34866
// tmp := mc_crates_collector [ i ] else
34848: LD_ADDR_VAR 0 5
34852: PUSH
34853: LD_EXP 107
34857: PUSH
34858: LD_VAR 0 2
34862: ARRAY
34863: ST_TO_ADDR
34864: GO 34880
// tmp := target [ 1 ] ;
34866: LD_ADDR_VAR 0 5
34870: PUSH
34871: LD_VAR 0 6
34875: PUSH
34876: LD_INT 1
34878: ARRAY
34879: ST_TO_ADDR
// k := 0 ;
34880: LD_ADDR_VAR 0 4
34884: PUSH
34885: LD_INT 0
34887: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34888: LD_ADDR_VAR 0 3
34892: PUSH
34893: LD_EXP 107
34897: PUSH
34898: LD_VAR 0 2
34902: ARRAY
34903: PUSH
34904: FOR_IN
34905: IFFALSE 35065
// begin k := k + 1 ;
34907: LD_ADDR_VAR 0 4
34911: PUSH
34912: LD_VAR 0 4
34916: PUSH
34917: LD_INT 1
34919: PLUS
34920: ST_TO_ADDR
// if k > tmp then
34921: LD_VAR 0 4
34925: PUSH
34926: LD_VAR 0 5
34930: GREATER
34931: IFFALSE 34935
// break ;
34933: GO 35065
// if not GetClass ( j ) in [ 2 , 16 ] then
34935: LD_VAR 0 3
34939: PPUSH
34940: CALL_OW 257
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 16
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: IN
34955: NOT
34956: IFFALSE 35009
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34958: LD_ADDR_EXP 107
34962: PUSH
34963: LD_EXP 107
34967: PPUSH
34968: LD_VAR 0 2
34972: PPUSH
34973: LD_EXP 107
34977: PUSH
34978: LD_VAR 0 2
34982: ARRAY
34983: PUSH
34984: LD_VAR 0 3
34988: DIFF
34989: PPUSH
34990: CALL_OW 1
34994: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34995: LD_VAR 0 3
34999: PPUSH
35000: LD_INT 0
35002: PPUSH
35003: CALL_OW 109
// continue ;
35007: GO 34904
// end ; if IsInUnit ( j ) then
35009: LD_VAR 0 3
35013: PPUSH
35014: CALL_OW 310
35018: IFFALSE 35029
// ComExitBuilding ( j ) ;
35020: LD_VAR 0 3
35024: PPUSH
35025: CALL_OW 122
// wait ( 3 ) ;
35029: LD_INT 3
35031: PPUSH
35032: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35036: LD_VAR 0 3
35040: PPUSH
35041: LD_VAR 0 6
35045: PUSH
35046: LD_INT 2
35048: ARRAY
35049: PPUSH
35050: LD_VAR 0 6
35054: PUSH
35055: LD_INT 3
35057: ARRAY
35058: PPUSH
35059: CALL_OW 117
// end ;
35063: GO 34904
35065: POP
35066: POP
// end ; end else
35067: GO 35648
// begin for j in cargo do
35069: LD_ADDR_VAR 0 3
35073: PUSH
35074: LD_VAR 0 7
35078: PUSH
35079: FOR_IN
35080: IFFALSE 35646
// begin if GetTag ( j ) <> 0 then
35082: LD_VAR 0 3
35086: PPUSH
35087: CALL_OW 110
35091: PUSH
35092: LD_INT 0
35094: NONEQUAL
35095: IFFALSE 35099
// continue ;
35097: GO 35079
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35099: LD_VAR 0 3
35103: PPUSH
35104: CALL_OW 256
35108: PUSH
35109: LD_INT 1000
35111: LESS
35112: PUSH
35113: LD_VAR 0 3
35117: PPUSH
35118: LD_EXP 114
35122: PUSH
35123: LD_VAR 0 2
35127: ARRAY
35128: PPUSH
35129: CALL_OW 308
35133: NOT
35134: AND
35135: IFFALSE 35157
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35137: LD_VAR 0 3
35141: PPUSH
35142: LD_EXP 114
35146: PUSH
35147: LD_VAR 0 2
35151: ARRAY
35152: PPUSH
35153: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35157: LD_VAR 0 3
35161: PPUSH
35162: CALL_OW 256
35166: PUSH
35167: LD_INT 1000
35169: LESS
35170: PUSH
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_EXP 114
35180: PUSH
35181: LD_VAR 0 2
35185: ARRAY
35186: PPUSH
35187: CALL_OW 308
35191: AND
35192: IFFALSE 35196
// continue ;
35194: GO 35079
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35196: LD_VAR 0 3
35200: PPUSH
35201: CALL_OW 262
35205: PUSH
35206: LD_INT 2
35208: EQUAL
35209: PUSH
35210: LD_VAR 0 3
35214: PPUSH
35215: CALL_OW 261
35219: PUSH
35220: LD_INT 15
35222: LESS
35223: AND
35224: IFFALSE 35228
// continue ;
35226: GO 35079
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35228: LD_VAR 0 3
35232: PPUSH
35233: CALL_OW 262
35237: PUSH
35238: LD_INT 1
35240: EQUAL
35241: PUSH
35242: LD_VAR 0 3
35246: PPUSH
35247: CALL_OW 261
35251: PUSH
35252: LD_INT 10
35254: LESS
35255: AND
35256: IFFALSE 35585
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35258: LD_ADDR_VAR 0 8
35262: PUSH
35263: LD_EXP 90
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PPUSH
35274: LD_INT 2
35276: PUSH
35277: LD_INT 30
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 30
35289: PUSH
35290: LD_INT 1
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: LIST
35301: PPUSH
35302: CALL_OW 72
35306: ST_TO_ADDR
// if not depot then
35307: LD_VAR 0 8
35311: NOT
35312: IFFALSE 35316
// continue ;
35314: GO 35079
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35316: LD_VAR 0 3
35320: PPUSH
35321: LD_VAR 0 8
35325: PPUSH
35326: LD_VAR 0 3
35330: PPUSH
35331: CALL_OW 74
35335: PPUSH
35336: CALL_OW 296
35340: PUSH
35341: LD_INT 6
35343: LESS
35344: IFFALSE 35360
// SetFuel ( j , 100 ) else
35346: LD_VAR 0 3
35350: PPUSH
35351: LD_INT 100
35353: PPUSH
35354: CALL_OW 240
35358: GO 35585
// if GetFuel ( j ) = 0 then
35360: LD_VAR 0 3
35364: PPUSH
35365: CALL_OW 261
35369: PUSH
35370: LD_INT 0
35372: EQUAL
35373: IFFALSE 35585
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35375: LD_ADDR_EXP 109
35379: PUSH
35380: LD_EXP 109
35384: PPUSH
35385: LD_VAR 0 2
35389: PPUSH
35390: LD_EXP 109
35394: PUSH
35395: LD_VAR 0 2
35399: ARRAY
35400: PUSH
35401: LD_VAR 0 3
35405: DIFF
35406: PPUSH
35407: CALL_OW 1
35411: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35412: LD_VAR 0 3
35416: PPUSH
35417: CALL_OW 263
35421: PUSH
35422: LD_INT 1
35424: EQUAL
35425: IFFALSE 35441
// ComExitVehicle ( IsInUnit ( j ) ) ;
35427: LD_VAR 0 3
35431: PPUSH
35432: CALL_OW 310
35436: PPUSH
35437: CALL_OW 121
// if GetControl ( j ) = control_remote then
35441: LD_VAR 0 3
35445: PPUSH
35446: CALL_OW 263
35450: PUSH
35451: LD_INT 2
35453: EQUAL
35454: IFFALSE 35465
// ComUnlink ( j ) ;
35456: LD_VAR 0 3
35460: PPUSH
35461: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35465: LD_ADDR_VAR 0 9
35469: PUSH
35470: LD_VAR 0 2
35474: PPUSH
35475: LD_INT 3
35477: PPUSH
35478: CALL 44960 0 2
35482: ST_TO_ADDR
// if fac then
35483: LD_VAR 0 9
35487: IFFALSE 35583
// begin for k in fac do
35489: LD_ADDR_VAR 0 4
35493: PUSH
35494: LD_VAR 0 9
35498: PUSH
35499: FOR_IN
35500: IFFALSE 35581
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35502: LD_ADDR_VAR 0 10
35506: PUSH
35507: LD_VAR 0 9
35511: PPUSH
35512: LD_VAR 0 3
35516: PPUSH
35517: CALL_OW 265
35521: PPUSH
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 262
35531: PPUSH
35532: LD_VAR 0 3
35536: PPUSH
35537: CALL_OW 263
35541: PPUSH
35542: LD_VAR 0 3
35546: PPUSH
35547: CALL_OW 264
35551: PPUSH
35552: CALL 53346 0 5
35556: ST_TO_ADDR
// if components then
35557: LD_VAR 0 10
35561: IFFALSE 35579
// begin MC_InsertProduceList ( i , components ) ;
35563: LD_VAR 0 2
35567: PPUSH
35568: LD_VAR 0 10
35572: PPUSH
35573: CALL 44505 0 2
// break ;
35577: GO 35581
// end ; end ;
35579: GO 35499
35581: POP
35582: POP
// end ; continue ;
35583: GO 35079
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35585: LD_VAR 0 3
35589: PPUSH
35590: LD_INT 1
35592: PPUSH
35593: CALL_OW 289
35597: PUSH
35598: LD_INT 100
35600: LESS
35601: PUSH
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 314
35611: NOT
35612: AND
35613: IFFALSE 35642
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35615: LD_VAR 0 3
35619: PPUSH
35620: LD_VAR 0 6
35624: PUSH
35625: LD_INT 2
35627: ARRAY
35628: PPUSH
35629: LD_VAR 0 6
35633: PUSH
35634: LD_INT 3
35636: ARRAY
35637: PPUSH
35638: CALL_OW 117
// break ;
35642: GO 35646
// end ;
35644: GO 35079
35646: POP
35647: POP
// end ; end ;
35648: GO 33917
35650: POP
35651: POP
// end ;
35652: LD_VAR 0 1
35656: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35657: LD_INT 0
35659: PPUSH
35660: PPUSH
35661: PPUSH
35662: PPUSH
// if not mc_bases then
35663: LD_EXP 90
35667: NOT
35668: IFFALSE 35672
// exit ;
35670: GO 35833
// for i = 1 to mc_bases do
35672: LD_ADDR_VAR 0 2
35676: PUSH
35677: DOUBLE
35678: LD_INT 1
35680: DEC
35681: ST_TO_ADDR
35682: LD_EXP 90
35686: PUSH
35687: FOR_TO
35688: IFFALSE 35831
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35690: LD_ADDR_VAR 0 4
35694: PUSH
35695: LD_EXP 109
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_EXP 112
35710: PUSH
35711: LD_VAR 0 2
35715: ARRAY
35716: UNION
35717: PPUSH
35718: LD_INT 33
35720: PUSH
35721: LD_INT 2
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PPUSH
35728: CALL_OW 72
35732: ST_TO_ADDR
// if tmp then
35733: LD_VAR 0 4
35737: IFFALSE 35829
// for j in tmp do
35739: LD_ADDR_VAR 0 3
35743: PUSH
35744: LD_VAR 0 4
35748: PUSH
35749: FOR_IN
35750: IFFALSE 35827
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35752: LD_VAR 0 3
35756: PPUSH
35757: CALL_OW 312
35761: NOT
35762: PUSH
35763: LD_VAR 0 3
35767: PPUSH
35768: CALL_OW 256
35772: PUSH
35773: LD_INT 250
35775: GREATEREQUAL
35776: AND
35777: IFFALSE 35790
// Connect ( j ) else
35779: LD_VAR 0 3
35783: PPUSH
35784: CALL 58747 0 1
35788: GO 35825
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35790: LD_VAR 0 3
35794: PPUSH
35795: CALL_OW 256
35799: PUSH
35800: LD_INT 250
35802: LESS
35803: PUSH
35804: LD_VAR 0 3
35808: PPUSH
35809: CALL_OW 312
35813: AND
35814: IFFALSE 35825
// ComUnlink ( j ) ;
35816: LD_VAR 0 3
35820: PPUSH
35821: CALL_OW 136
35825: GO 35749
35827: POP
35828: POP
// end ;
35829: GO 35687
35831: POP
35832: POP
// end ;
35833: LD_VAR 0 1
35837: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35838: LD_INT 0
35840: PPUSH
35841: PPUSH
35842: PPUSH
35843: PPUSH
35844: PPUSH
// if not mc_bases then
35845: LD_EXP 90
35849: NOT
35850: IFFALSE 35854
// exit ;
35852: GO 36299
// for i = 1 to mc_bases do
35854: LD_ADDR_VAR 0 2
35858: PUSH
35859: DOUBLE
35860: LD_INT 1
35862: DEC
35863: ST_TO_ADDR
35864: LD_EXP 90
35868: PUSH
35869: FOR_TO
35870: IFFALSE 36297
// begin if not mc_produce [ i ] then
35872: LD_EXP 111
35876: PUSH
35877: LD_VAR 0 2
35881: ARRAY
35882: NOT
35883: IFFALSE 35887
// continue ;
35885: GO 35869
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35887: LD_ADDR_VAR 0 5
35891: PUSH
35892: LD_EXP 90
35896: PUSH
35897: LD_VAR 0 2
35901: ARRAY
35902: PPUSH
35903: LD_INT 30
35905: PUSH
35906: LD_INT 3
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PPUSH
35913: CALL_OW 72
35917: ST_TO_ADDR
// if not fac then
35918: LD_VAR 0 5
35922: NOT
35923: IFFALSE 35927
// continue ;
35925: GO 35869
// for j in fac do
35927: LD_ADDR_VAR 0 3
35931: PUSH
35932: LD_VAR 0 5
35936: PUSH
35937: FOR_IN
35938: IFFALSE 36293
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35940: LD_VAR 0 3
35944: PPUSH
35945: CALL_OW 461
35949: PUSH
35950: LD_INT 2
35952: NONEQUAL
35953: PUSH
35954: LD_VAR 0 3
35958: PPUSH
35959: LD_INT 15
35961: PPUSH
35962: CALL 58407 0 2
35966: PUSH
35967: LD_INT 4
35969: ARRAY
35970: OR
35971: IFFALSE 35975
// continue ;
35973: GO 35937
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35975: LD_VAR 0 3
35979: PPUSH
35980: LD_EXP 111
35984: PUSH
35985: LD_VAR 0 2
35989: ARRAY
35990: PUSH
35991: LD_INT 1
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: LD_EXP 111
36003: PUSH
36004: LD_VAR 0 2
36008: ARRAY
36009: PUSH
36010: LD_INT 1
36012: ARRAY
36013: PUSH
36014: LD_INT 2
36016: ARRAY
36017: PPUSH
36018: LD_EXP 111
36022: PUSH
36023: LD_VAR 0 2
36027: ARRAY
36028: PUSH
36029: LD_INT 1
36031: ARRAY
36032: PUSH
36033: LD_INT 3
36035: ARRAY
36036: PPUSH
36037: LD_EXP 111
36041: PUSH
36042: LD_VAR 0 2
36046: ARRAY
36047: PUSH
36048: LD_INT 1
36050: ARRAY
36051: PUSH
36052: LD_INT 4
36054: ARRAY
36055: PPUSH
36056: CALL_OW 448
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: LD_EXP 111
36070: PUSH
36071: LD_VAR 0 2
36075: ARRAY
36076: PUSH
36077: LD_INT 1
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: PUSH
36085: LD_EXP 111
36089: PUSH
36090: LD_VAR 0 2
36094: ARRAY
36095: PUSH
36096: LD_INT 1
36098: ARRAY
36099: PUSH
36100: LD_INT 2
36102: ARRAY
36103: PUSH
36104: LD_EXP 111
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PUSH
36119: LD_INT 3
36121: ARRAY
36122: PUSH
36123: LD_EXP 111
36127: PUSH
36128: LD_VAR 0 2
36132: ARRAY
36133: PUSH
36134: LD_INT 1
36136: ARRAY
36137: PUSH
36138: LD_INT 4
36140: ARRAY
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: PPUSH
36148: CALL 62078 0 2
36152: AND
36153: IFFALSE 36291
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36155: LD_VAR 0 3
36159: PPUSH
36160: LD_EXP 111
36164: PUSH
36165: LD_VAR 0 2
36169: ARRAY
36170: PUSH
36171: LD_INT 1
36173: ARRAY
36174: PUSH
36175: LD_INT 1
36177: ARRAY
36178: PPUSH
36179: LD_EXP 111
36183: PUSH
36184: LD_VAR 0 2
36188: ARRAY
36189: PUSH
36190: LD_INT 1
36192: ARRAY
36193: PUSH
36194: LD_INT 2
36196: ARRAY
36197: PPUSH
36198: LD_EXP 111
36202: PUSH
36203: LD_VAR 0 2
36207: ARRAY
36208: PUSH
36209: LD_INT 1
36211: ARRAY
36212: PUSH
36213: LD_INT 3
36215: ARRAY
36216: PPUSH
36217: LD_EXP 111
36221: PUSH
36222: LD_VAR 0 2
36226: ARRAY
36227: PUSH
36228: LD_INT 1
36230: ARRAY
36231: PUSH
36232: LD_INT 4
36234: ARRAY
36235: PPUSH
36236: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36240: LD_ADDR_VAR 0 4
36244: PUSH
36245: LD_EXP 111
36249: PUSH
36250: LD_VAR 0 2
36254: ARRAY
36255: PPUSH
36256: LD_INT 1
36258: PPUSH
36259: CALL_OW 3
36263: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36264: LD_ADDR_EXP 111
36268: PUSH
36269: LD_EXP 111
36273: PPUSH
36274: LD_VAR 0 2
36278: PPUSH
36279: LD_VAR 0 4
36283: PPUSH
36284: CALL_OW 1
36288: ST_TO_ADDR
// break ;
36289: GO 36293
// end ; end ;
36291: GO 35937
36293: POP
36294: POP
// end ;
36295: GO 35869
36297: POP
36298: POP
// end ;
36299: LD_VAR 0 1
36303: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36304: LD_INT 0
36306: PPUSH
36307: PPUSH
36308: PPUSH
// if not mc_bases then
36309: LD_EXP 90
36313: NOT
36314: IFFALSE 36318
// exit ;
36316: GO 36407
// for i = 1 to mc_bases do
36318: LD_ADDR_VAR 0 2
36322: PUSH
36323: DOUBLE
36324: LD_INT 1
36326: DEC
36327: ST_TO_ADDR
36328: LD_EXP 90
36332: PUSH
36333: FOR_TO
36334: IFFALSE 36405
// begin if mc_attack [ i ] then
36336: LD_EXP 110
36340: PUSH
36341: LD_VAR 0 2
36345: ARRAY
36346: IFFALSE 36403
// begin tmp := mc_attack [ i ] [ 1 ] ;
36348: LD_ADDR_VAR 0 3
36352: PUSH
36353: LD_EXP 110
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36368: LD_ADDR_EXP 110
36372: PUSH
36373: LD_EXP 110
36377: PPUSH
36378: LD_VAR 0 2
36382: PPUSH
36383: EMPTY
36384: PPUSH
36385: CALL_OW 1
36389: ST_TO_ADDR
// Attack ( tmp ) ;
36390: LD_VAR 0 3
36394: PPUSH
36395: CALL 105093 0 1
// exit ;
36399: POP
36400: POP
36401: GO 36407
// end ; end ;
36403: GO 36333
36405: POP
36406: POP
// end ;
36407: LD_VAR 0 1
36411: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36412: LD_INT 0
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
36420: PPUSH
// if not mc_bases then
36421: LD_EXP 90
36425: NOT
36426: IFFALSE 36430
// exit ;
36428: GO 37034
// for i = 1 to mc_bases do
36430: LD_ADDR_VAR 0 2
36434: PUSH
36435: DOUBLE
36436: LD_INT 1
36438: DEC
36439: ST_TO_ADDR
36440: LD_EXP 90
36444: PUSH
36445: FOR_TO
36446: IFFALSE 37032
// begin if not mc_bases [ i ] then
36448: LD_EXP 90
36452: PUSH
36453: LD_VAR 0 2
36457: ARRAY
36458: NOT
36459: IFFALSE 36463
// continue ;
36461: GO 36445
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36463: LD_ADDR_VAR 0 7
36467: PUSH
36468: LD_EXP 90
36472: PUSH
36473: LD_VAR 0 2
36477: ARRAY
36478: PUSH
36479: LD_INT 1
36481: ARRAY
36482: PPUSH
36483: CALL 52650 0 1
36487: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36488: LD_ADDR_EXP 113
36492: PUSH
36493: LD_EXP 113
36497: PPUSH
36498: LD_VAR 0 2
36502: PPUSH
36503: LD_EXP 90
36507: PUSH
36508: LD_VAR 0 2
36512: ARRAY
36513: PUSH
36514: LD_INT 1
36516: ARRAY
36517: PPUSH
36518: CALL_OW 255
36522: PPUSH
36523: LD_EXP 115
36527: PUSH
36528: LD_VAR 0 2
36532: ARRAY
36533: PPUSH
36534: CALL 52615 0 2
36538: PPUSH
36539: CALL_OW 1
36543: ST_TO_ADDR
// if not mc_scan [ i ] then
36544: LD_EXP 113
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: NOT
36555: IFFALSE 36710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36557: LD_ADDR_VAR 0 4
36561: PUSH
36562: LD_EXP 90
36566: PUSH
36567: LD_VAR 0 2
36571: ARRAY
36572: PPUSH
36573: LD_INT 2
36575: PUSH
36576: LD_INT 25
36578: PUSH
36579: LD_INT 5
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 25
36588: PUSH
36589: LD_INT 8
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 25
36598: PUSH
36599: LD_INT 9
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: PPUSH
36612: CALL_OW 72
36616: ST_TO_ADDR
// if not tmp then
36617: LD_VAR 0 4
36621: NOT
36622: IFFALSE 36626
// continue ;
36624: GO 36445
// for j in tmp do
36626: LD_ADDR_VAR 0 3
36630: PUSH
36631: LD_VAR 0 4
36635: PUSH
36636: FOR_IN
36637: IFFALSE 36708
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36639: LD_VAR 0 3
36643: PPUSH
36644: CALL_OW 310
36648: PPUSH
36649: CALL_OW 266
36653: PUSH
36654: LD_INT 5
36656: EQUAL
36657: PUSH
36658: LD_VAR 0 3
36662: PPUSH
36663: CALL_OW 257
36667: PUSH
36668: LD_INT 1
36670: EQUAL
36671: AND
36672: PUSH
36673: LD_VAR 0 3
36677: PPUSH
36678: CALL_OW 459
36682: NOT
36683: AND
36684: PUSH
36685: LD_VAR 0 7
36689: AND
36690: IFFALSE 36706
// ComChangeProfession ( j , class ) ;
36692: LD_VAR 0 3
36696: PPUSH
36697: LD_VAR 0 7
36701: PPUSH
36702: CALL_OW 123
36706: GO 36636
36708: POP
36709: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36710: LD_EXP 113
36714: PUSH
36715: LD_VAR 0 2
36719: ARRAY
36720: PUSH
36721: LD_EXP 112
36725: PUSH
36726: LD_VAR 0 2
36730: ARRAY
36731: NOT
36732: AND
36733: PUSH
36734: LD_EXP 90
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: PPUSH
36745: LD_INT 30
36747: PUSH
36748: LD_INT 32
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PPUSH
36755: CALL_OW 72
36759: NOT
36760: AND
36761: PUSH
36762: LD_EXP 90
36766: PUSH
36767: LD_VAR 0 2
36771: ARRAY
36772: PPUSH
36773: LD_INT 2
36775: PUSH
36776: LD_INT 30
36778: PUSH
36779: LD_INT 4
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 30
36788: PUSH
36789: LD_INT 5
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: PPUSH
36801: CALL_OW 72
36805: NOT
36806: AND
36807: IFFALSE 36939
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36809: LD_ADDR_VAR 0 4
36813: PUSH
36814: LD_EXP 90
36818: PUSH
36819: LD_VAR 0 2
36823: ARRAY
36824: PPUSH
36825: LD_INT 2
36827: PUSH
36828: LD_INT 25
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 25
36840: PUSH
36841: LD_INT 5
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 25
36850: PUSH
36851: LD_INT 8
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 25
36860: PUSH
36861: LD_INT 9
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: PPUSH
36875: CALL_OW 72
36879: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36880: LD_ADDR_VAR 0 4
36884: PUSH
36885: LD_VAR 0 4
36889: PUSH
36890: LD_VAR 0 4
36894: PPUSH
36895: LD_INT 18
36897: PPUSH
36898: CALL 84375 0 2
36902: DIFF
36903: ST_TO_ADDR
// if tmp then
36904: LD_VAR 0 4
36908: IFFALSE 36939
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36910: LD_VAR 0 2
36914: PPUSH
36915: LD_VAR 0 4
36919: PPUSH
36920: LD_EXP 115
36924: PUSH
36925: LD_VAR 0 2
36929: ARRAY
36930: PPUSH
36931: CALL 109802 0 3
// exit ;
36935: POP
36936: POP
36937: GO 37034
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36939: LD_EXP 113
36943: PUSH
36944: LD_VAR 0 2
36948: ARRAY
36949: PUSH
36950: LD_EXP 112
36954: PUSH
36955: LD_VAR 0 2
36959: ARRAY
36960: AND
36961: IFFALSE 37030
// begin tmp := mc_defender [ i ] ;
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_EXP 112
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36979: LD_ADDR_EXP 112
36983: PUSH
36984: LD_EXP 112
36988: PPUSH
36989: LD_VAR 0 2
36993: PPUSH
36994: EMPTY
36995: PPUSH
36996: CALL_OW 1
37000: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
37001: LD_VAR 0 2
37005: PPUSH
37006: LD_VAR 0 4
37010: PPUSH
37011: LD_EXP 113
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PPUSH
37022: CALL 110363 0 3
// exit ;
37026: POP
37027: POP
37028: GO 37034
// end ; end ;
37030: GO 36445
37032: POP
37033: POP
// end ;
37034: LD_VAR 0 1
37038: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37039: LD_INT 0
37041: PPUSH
37042: PPUSH
37043: PPUSH
37044: PPUSH
37045: PPUSH
37046: PPUSH
37047: PPUSH
37048: PPUSH
37049: PPUSH
37050: PPUSH
37051: PPUSH
// if not mc_bases then
37052: LD_EXP 90
37056: NOT
37057: IFFALSE 37061
// exit ;
37059: GO 38148
// for i = 1 to mc_bases do
37061: LD_ADDR_VAR 0 2
37065: PUSH
37066: DOUBLE
37067: LD_INT 1
37069: DEC
37070: ST_TO_ADDR
37071: LD_EXP 90
37075: PUSH
37076: FOR_TO
37077: IFFALSE 38146
// begin tmp := mc_lab [ i ] ;
37079: LD_ADDR_VAR 0 6
37083: PUSH
37084: LD_EXP 123
37088: PUSH
37089: LD_VAR 0 2
37093: ARRAY
37094: ST_TO_ADDR
// if not tmp then
37095: LD_VAR 0 6
37099: NOT
37100: IFFALSE 37104
// continue ;
37102: GO 37076
// idle_lab := 0 ;
37104: LD_ADDR_VAR 0 11
37108: PUSH
37109: LD_INT 0
37111: ST_TO_ADDR
// for j in tmp do
37112: LD_ADDR_VAR 0 3
37116: PUSH
37117: LD_VAR 0 6
37121: PUSH
37122: FOR_IN
37123: IFFALSE 38142
// begin researching := false ;
37125: LD_ADDR_VAR 0 10
37129: PUSH
37130: LD_INT 0
37132: ST_TO_ADDR
// side := GetSide ( j ) ;
37133: LD_ADDR_VAR 0 4
37137: PUSH
37138: LD_VAR 0 3
37142: PPUSH
37143: CALL_OW 255
37147: ST_TO_ADDR
// if not mc_tech [ side ] then
37148: LD_EXP 117
37152: PUSH
37153: LD_VAR 0 4
37157: ARRAY
37158: NOT
37159: IFFALSE 37163
// continue ;
37161: GO 37122
// if BuildingStatus ( j ) = bs_idle then
37163: LD_VAR 0 3
37167: PPUSH
37168: CALL_OW 461
37172: PUSH
37173: LD_INT 2
37175: EQUAL
37176: IFFALSE 37364
// begin if idle_lab and UnitsInside ( j ) < 6 then
37178: LD_VAR 0 11
37182: PUSH
37183: LD_VAR 0 3
37187: PPUSH
37188: CALL_OW 313
37192: PUSH
37193: LD_INT 6
37195: LESS
37196: AND
37197: IFFALSE 37268
// begin tmp2 := UnitsInside ( idle_lab ) ;
37199: LD_ADDR_VAR 0 9
37203: PUSH
37204: LD_VAR 0 11
37208: PPUSH
37209: CALL_OW 313
37213: ST_TO_ADDR
// if tmp2 then
37214: LD_VAR 0 9
37218: IFFALSE 37260
// for x in tmp2 do
37220: LD_ADDR_VAR 0 7
37224: PUSH
37225: LD_VAR 0 9
37229: PUSH
37230: FOR_IN
37231: IFFALSE 37258
// begin ComExitBuilding ( x ) ;
37233: LD_VAR 0 7
37237: PPUSH
37238: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37242: LD_VAR 0 7
37246: PPUSH
37247: LD_VAR 0 3
37251: PPUSH
37252: CALL_OW 180
// end ;
37256: GO 37230
37258: POP
37259: POP
// idle_lab := 0 ;
37260: LD_ADDR_VAR 0 11
37264: PUSH
37265: LD_INT 0
37267: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37268: LD_ADDR_VAR 0 5
37272: PUSH
37273: LD_EXP 117
37277: PUSH
37278: LD_VAR 0 4
37282: ARRAY
37283: PUSH
37284: FOR_IN
37285: IFFALSE 37345
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37287: LD_VAR 0 3
37291: PPUSH
37292: LD_VAR 0 5
37296: PPUSH
37297: CALL_OW 430
37301: PUSH
37302: LD_VAR 0 4
37306: PPUSH
37307: LD_VAR 0 5
37311: PPUSH
37312: CALL 51720 0 2
37316: AND
37317: IFFALSE 37343
// begin researching := true ;
37319: LD_ADDR_VAR 0 10
37323: PUSH
37324: LD_INT 1
37326: ST_TO_ADDR
// ComResearch ( j , t ) ;
37327: LD_VAR 0 3
37331: PPUSH
37332: LD_VAR 0 5
37336: PPUSH
37337: CALL_OW 124
// break ;
37341: GO 37345
// end ;
37343: GO 37284
37345: POP
37346: POP
// if not researching then
37347: LD_VAR 0 10
37351: NOT
37352: IFFALSE 37364
// idle_lab := j ;
37354: LD_ADDR_VAR 0 11
37358: PUSH
37359: LD_VAR 0 3
37363: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37364: LD_VAR 0 3
37368: PPUSH
37369: CALL_OW 461
37373: PUSH
37374: LD_INT 10
37376: EQUAL
37377: IFFALSE 37965
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37379: LD_EXP 119
37383: PUSH
37384: LD_VAR 0 2
37388: ARRAY
37389: NOT
37390: PUSH
37391: LD_EXP 120
37395: PUSH
37396: LD_VAR 0 2
37400: ARRAY
37401: NOT
37402: AND
37403: PUSH
37404: LD_EXP 117
37408: PUSH
37409: LD_VAR 0 4
37413: ARRAY
37414: PUSH
37415: LD_INT 1
37417: GREATER
37418: AND
37419: IFFALSE 37550
// begin ComCancel ( j ) ;
37421: LD_VAR 0 3
37425: PPUSH
37426: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37430: LD_ADDR_EXP 117
37434: PUSH
37435: LD_EXP 117
37439: PPUSH
37440: LD_VAR 0 4
37444: PPUSH
37445: LD_EXP 117
37449: PUSH
37450: LD_VAR 0 4
37454: ARRAY
37455: PPUSH
37456: LD_EXP 117
37460: PUSH
37461: LD_VAR 0 4
37465: ARRAY
37466: PUSH
37467: LD_INT 1
37469: MINUS
37470: PPUSH
37471: LD_EXP 117
37475: PUSH
37476: LD_VAR 0 4
37480: ARRAY
37481: PPUSH
37482: LD_INT 0
37484: PPUSH
37485: CALL 55232 0 4
37489: PPUSH
37490: CALL_OW 1
37494: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37495: LD_ADDR_EXP 117
37499: PUSH
37500: LD_EXP 117
37504: PPUSH
37505: LD_VAR 0 4
37509: PPUSH
37510: LD_EXP 117
37514: PUSH
37515: LD_VAR 0 4
37519: ARRAY
37520: PPUSH
37521: LD_EXP 117
37525: PUSH
37526: LD_VAR 0 4
37530: ARRAY
37531: PPUSH
37532: LD_INT 1
37534: PPUSH
37535: LD_INT 0
37537: PPUSH
37538: CALL 55232 0 4
37542: PPUSH
37543: CALL_OW 1
37547: ST_TO_ADDR
// continue ;
37548: GO 37122
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37550: LD_EXP 119
37554: PUSH
37555: LD_VAR 0 2
37559: ARRAY
37560: PUSH
37561: LD_EXP 120
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: NOT
37572: AND
37573: IFFALSE 37700
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37575: LD_ADDR_EXP 120
37579: PUSH
37580: LD_EXP 120
37584: PPUSH
37585: LD_VAR 0 2
37589: PUSH
37590: LD_EXP 120
37594: PUSH
37595: LD_VAR 0 2
37599: ARRAY
37600: PUSH
37601: LD_INT 1
37603: PLUS
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PPUSH
37609: LD_EXP 119
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PUSH
37620: LD_INT 1
37622: ARRAY
37623: PPUSH
37624: CALL 55814 0 3
37628: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37629: LD_EXP 119
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PUSH
37640: LD_INT 1
37642: ARRAY
37643: PPUSH
37644: LD_INT 112
37646: PPUSH
37647: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37651: LD_ADDR_VAR 0 9
37655: PUSH
37656: LD_EXP 119
37660: PUSH
37661: LD_VAR 0 2
37665: ARRAY
37666: PPUSH
37667: LD_INT 1
37669: PPUSH
37670: CALL_OW 3
37674: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37675: LD_ADDR_EXP 119
37679: PUSH
37680: LD_EXP 119
37684: PPUSH
37685: LD_VAR 0 2
37689: PPUSH
37690: LD_VAR 0 9
37694: PPUSH
37695: CALL_OW 1
37699: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37700: LD_EXP 119
37704: PUSH
37705: LD_VAR 0 2
37709: ARRAY
37710: PUSH
37711: LD_EXP 120
37715: PUSH
37716: LD_VAR 0 2
37720: ARRAY
37721: AND
37722: PUSH
37723: LD_EXP 120
37727: PUSH
37728: LD_VAR 0 2
37732: ARRAY
37733: PUSH
37734: LD_INT 1
37736: ARRAY
37737: PPUSH
37738: CALL_OW 310
37742: NOT
37743: AND
37744: PUSH
37745: LD_VAR 0 3
37749: PPUSH
37750: CALL_OW 313
37754: PUSH
37755: LD_INT 6
37757: EQUAL
37758: AND
37759: IFFALSE 37815
// begin tmp2 := UnitsInside ( j ) ;
37761: LD_ADDR_VAR 0 9
37765: PUSH
37766: LD_VAR 0 3
37770: PPUSH
37771: CALL_OW 313
37775: ST_TO_ADDR
// if tmp2 = 6 then
37776: LD_VAR 0 9
37780: PUSH
37781: LD_INT 6
37783: EQUAL
37784: IFFALSE 37815
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37786: LD_VAR 0 9
37790: PUSH
37791: LD_INT 1
37793: ARRAY
37794: PPUSH
37795: LD_INT 112
37797: PPUSH
37798: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37802: LD_VAR 0 9
37806: PUSH
37807: LD_INT 1
37809: ARRAY
37810: PPUSH
37811: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37815: LD_EXP 120
37819: PUSH
37820: LD_VAR 0 2
37824: ARRAY
37825: PUSH
37826: LD_EXP 120
37830: PUSH
37831: LD_VAR 0 2
37835: ARRAY
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: PPUSH
37841: CALL_OW 314
37845: NOT
37846: AND
37847: PUSH
37848: LD_EXP 120
37852: PUSH
37853: LD_VAR 0 2
37857: ARRAY
37858: PUSH
37859: LD_INT 1
37861: ARRAY
37862: PPUSH
37863: CALL_OW 310
37867: NOT
37868: AND
37869: IFFALSE 37895
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37871: LD_EXP 120
37875: PUSH
37876: LD_VAR 0 2
37880: ARRAY
37881: PUSH
37882: LD_INT 1
37884: ARRAY
37885: PPUSH
37886: LD_VAR 0 3
37890: PPUSH
37891: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37895: LD_EXP 120
37899: PUSH
37900: LD_VAR 0 2
37904: ARRAY
37905: PUSH
37906: LD_INT 1
37908: ARRAY
37909: PPUSH
37910: CALL_OW 310
37914: PUSH
37915: LD_EXP 120
37919: PUSH
37920: LD_VAR 0 2
37924: ARRAY
37925: PUSH
37926: LD_INT 1
37928: ARRAY
37929: PPUSH
37930: CALL_OW 310
37934: PPUSH
37935: CALL_OW 461
37939: PUSH
37940: LD_INT 3
37942: NONEQUAL
37943: AND
37944: IFFALSE 37965
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37946: LD_EXP 120
37950: PUSH
37951: LD_VAR 0 2
37955: ARRAY
37956: PUSH
37957: LD_INT 1
37959: ARRAY
37960: PPUSH
37961: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37965: LD_VAR 0 3
37969: PPUSH
37970: CALL_OW 461
37974: PUSH
37975: LD_INT 6
37977: EQUAL
37978: PUSH
37979: LD_VAR 0 6
37983: PUSH
37984: LD_INT 1
37986: GREATER
37987: AND
37988: IFFALSE 38140
// begin sci := [ ] ;
37990: LD_ADDR_VAR 0 8
37994: PUSH
37995: EMPTY
37996: ST_TO_ADDR
// for x in ( tmp diff j ) do
37997: LD_ADDR_VAR 0 7
38001: PUSH
38002: LD_VAR 0 6
38006: PUSH
38007: LD_VAR 0 3
38011: DIFF
38012: PUSH
38013: FOR_IN
38014: IFFALSE 38066
// begin if sci = 6 then
38016: LD_VAR 0 8
38020: PUSH
38021: LD_INT 6
38023: EQUAL
38024: IFFALSE 38028
// break ;
38026: GO 38066
// if BuildingStatus ( x ) = bs_idle then
38028: LD_VAR 0 7
38032: PPUSH
38033: CALL_OW 461
38037: PUSH
38038: LD_INT 2
38040: EQUAL
38041: IFFALSE 38064
// sci := sci ^ UnitsInside ( x ) ;
38043: LD_ADDR_VAR 0 8
38047: PUSH
38048: LD_VAR 0 8
38052: PUSH
38053: LD_VAR 0 7
38057: PPUSH
38058: CALL_OW 313
38062: ADD
38063: ST_TO_ADDR
// end ;
38064: GO 38013
38066: POP
38067: POP
// if not sci then
38068: LD_VAR 0 8
38072: NOT
38073: IFFALSE 38077
// continue ;
38075: GO 37122
// for x in sci do
38077: LD_ADDR_VAR 0 7
38081: PUSH
38082: LD_VAR 0 8
38086: PUSH
38087: FOR_IN
38088: IFFALSE 38138
// if IsInUnit ( x ) and not HasTask ( x ) then
38090: LD_VAR 0 7
38094: PPUSH
38095: CALL_OW 310
38099: PUSH
38100: LD_VAR 0 7
38104: PPUSH
38105: CALL_OW 314
38109: NOT
38110: AND
38111: IFFALSE 38136
// begin ComExitBuilding ( x ) ;
38113: LD_VAR 0 7
38117: PPUSH
38118: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38122: LD_VAR 0 7
38126: PPUSH
38127: LD_VAR 0 3
38131: PPUSH
38132: CALL_OW 180
// end ;
38136: GO 38087
38138: POP
38139: POP
// end ; end ;
38140: GO 37122
38142: POP
38143: POP
// end ;
38144: GO 37076
38146: POP
38147: POP
// end ;
38148: LD_VAR 0 1
38152: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38153: LD_INT 0
38155: PPUSH
38156: PPUSH
// if not mc_bases then
38157: LD_EXP 90
38161: NOT
38162: IFFALSE 38166
// exit ;
38164: GO 38247
// for i = 1 to mc_bases do
38166: LD_ADDR_VAR 0 2
38170: PUSH
38171: DOUBLE
38172: LD_INT 1
38174: DEC
38175: ST_TO_ADDR
38176: LD_EXP 90
38180: PUSH
38181: FOR_TO
38182: IFFALSE 38245
// if mc_mines [ i ] and mc_miners [ i ] then
38184: LD_EXP 103
38188: PUSH
38189: LD_VAR 0 2
38193: ARRAY
38194: PUSH
38195: LD_EXP 104
38199: PUSH
38200: LD_VAR 0 2
38204: ARRAY
38205: AND
38206: IFFALSE 38243
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38208: LD_EXP 104
38212: PUSH
38213: LD_VAR 0 2
38217: ARRAY
38218: PUSH
38219: LD_INT 1
38221: ARRAY
38222: PPUSH
38223: CALL_OW 255
38227: PPUSH
38228: LD_EXP 103
38232: PUSH
38233: LD_VAR 0 2
38237: ARRAY
38238: PPUSH
38239: CALL 52803 0 2
38243: GO 38181
38245: POP
38246: POP
// end ;
38247: LD_VAR 0 1
38251: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38252: LD_INT 0
38254: PPUSH
38255: PPUSH
38256: PPUSH
38257: PPUSH
38258: PPUSH
38259: PPUSH
38260: PPUSH
38261: PPUSH
// if not mc_bases or not mc_parking then
38262: LD_EXP 90
38266: NOT
38267: PUSH
38268: LD_EXP 114
38272: NOT
38273: OR
38274: IFFALSE 38278
// exit ;
38276: GO 38977
// for i = 1 to mc_bases do
38278: LD_ADDR_VAR 0 2
38282: PUSH
38283: DOUBLE
38284: LD_INT 1
38286: DEC
38287: ST_TO_ADDR
38288: LD_EXP 90
38292: PUSH
38293: FOR_TO
38294: IFFALSE 38975
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38296: LD_EXP 90
38300: PUSH
38301: LD_VAR 0 2
38305: ARRAY
38306: NOT
38307: PUSH
38308: LD_EXP 114
38312: PUSH
38313: LD_VAR 0 2
38317: ARRAY
38318: NOT
38319: OR
38320: IFFALSE 38324
// continue ;
38322: GO 38293
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38324: LD_ADDR_VAR 0 5
38328: PUSH
38329: LD_EXP 90
38333: PUSH
38334: LD_VAR 0 2
38338: ARRAY
38339: PUSH
38340: LD_INT 1
38342: ARRAY
38343: PPUSH
38344: CALL_OW 255
38348: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38349: LD_ADDR_VAR 0 6
38353: PUSH
38354: LD_EXP 90
38358: PUSH
38359: LD_VAR 0 2
38363: ARRAY
38364: PPUSH
38365: LD_INT 30
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PPUSH
38375: CALL_OW 72
38379: ST_TO_ADDR
// if not fac then
38380: LD_VAR 0 6
38384: NOT
38385: IFFALSE 38436
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38387: LD_ADDR_VAR 0 6
38391: PUSH
38392: LD_EXP 90
38396: PUSH
38397: LD_VAR 0 2
38401: ARRAY
38402: PPUSH
38403: LD_INT 2
38405: PUSH
38406: LD_INT 30
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 30
38418: PUSH
38419: LD_INT 1
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: LIST
38430: PPUSH
38431: CALL_OW 72
38435: ST_TO_ADDR
// if not fac then
38436: LD_VAR 0 6
38440: NOT
38441: IFFALSE 38445
// continue ;
38443: GO 38293
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38445: LD_ADDR_VAR 0 7
38449: PUSH
38450: LD_EXP 114
38454: PUSH
38455: LD_VAR 0 2
38459: ARRAY
38460: PPUSH
38461: LD_INT 22
38463: PUSH
38464: LD_VAR 0 5
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 21
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 3
38485: PUSH
38486: LD_INT 24
38488: PUSH
38489: LD_INT 1000
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: LIST
38504: PPUSH
38505: CALL_OW 70
38509: ST_TO_ADDR
// for j in fac do
38510: LD_ADDR_VAR 0 3
38514: PUSH
38515: LD_VAR 0 6
38519: PUSH
38520: FOR_IN
38521: IFFALSE 38602
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38523: LD_ADDR_VAR 0 7
38527: PUSH
38528: LD_VAR 0 7
38532: PUSH
38533: LD_INT 22
38535: PUSH
38536: LD_VAR 0 5
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 91
38547: PUSH
38548: LD_VAR 0 3
38552: PUSH
38553: LD_INT 15
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 21
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 3
38573: PUSH
38574: LD_INT 24
38576: PUSH
38577: LD_INT 1000
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: PPUSH
38594: CALL_OW 69
38598: UNION
38599: ST_TO_ADDR
38600: GO 38520
38602: POP
38603: POP
// if not vehs then
38604: LD_VAR 0 7
38608: NOT
38609: IFFALSE 38635
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38611: LD_ADDR_EXP 102
38615: PUSH
38616: LD_EXP 102
38620: PPUSH
38621: LD_VAR 0 2
38625: PPUSH
38626: EMPTY
38627: PPUSH
38628: CALL_OW 1
38632: ST_TO_ADDR
// continue ;
38633: GO 38293
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38635: LD_ADDR_VAR 0 8
38639: PUSH
38640: LD_EXP 90
38644: PUSH
38645: LD_VAR 0 2
38649: ARRAY
38650: PPUSH
38651: LD_INT 30
38653: PUSH
38654: LD_INT 3
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PPUSH
38661: CALL_OW 72
38665: ST_TO_ADDR
// if tmp then
38666: LD_VAR 0 8
38670: IFFALSE 38773
// begin for j in tmp do
38672: LD_ADDR_VAR 0 3
38676: PUSH
38677: LD_VAR 0 8
38681: PUSH
38682: FOR_IN
38683: IFFALSE 38771
// for k in UnitsInside ( j ) do
38685: LD_ADDR_VAR 0 4
38689: PUSH
38690: LD_VAR 0 3
38694: PPUSH
38695: CALL_OW 313
38699: PUSH
38700: FOR_IN
38701: IFFALSE 38767
// if k then
38703: LD_VAR 0 4
38707: IFFALSE 38765
// if not k in mc_repair_vehicle [ i ] then
38709: LD_VAR 0 4
38713: PUSH
38714: LD_EXP 102
38718: PUSH
38719: LD_VAR 0 2
38723: ARRAY
38724: IN
38725: NOT
38726: IFFALSE 38765
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38728: LD_ADDR_EXP 102
38732: PUSH
38733: LD_EXP 102
38737: PPUSH
38738: LD_VAR 0 2
38742: PPUSH
38743: LD_EXP 102
38747: PUSH
38748: LD_VAR 0 2
38752: ARRAY
38753: PUSH
38754: LD_VAR 0 4
38758: UNION
38759: PPUSH
38760: CALL_OW 1
38764: ST_TO_ADDR
38765: GO 38700
38767: POP
38768: POP
38769: GO 38682
38771: POP
38772: POP
// end ; if not mc_repair_vehicle [ i ] then
38773: LD_EXP 102
38777: PUSH
38778: LD_VAR 0 2
38782: ARRAY
38783: NOT
38784: IFFALSE 38788
// continue ;
38786: GO 38293
// for j in mc_repair_vehicle [ i ] do
38788: LD_ADDR_VAR 0 3
38792: PUSH
38793: LD_EXP 102
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: FOR_IN
38805: IFFALSE 38971
// begin if GetClass ( j ) <> 3 then
38807: LD_VAR 0 3
38811: PPUSH
38812: CALL_OW 257
38816: PUSH
38817: LD_INT 3
38819: NONEQUAL
38820: IFFALSE 38861
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38822: LD_ADDR_EXP 102
38826: PUSH
38827: LD_EXP 102
38831: PPUSH
38832: LD_VAR 0 2
38836: PPUSH
38837: LD_EXP 102
38841: PUSH
38842: LD_VAR 0 2
38846: ARRAY
38847: PUSH
38848: LD_VAR 0 3
38852: DIFF
38853: PPUSH
38854: CALL_OW 1
38858: ST_TO_ADDR
// continue ;
38859: GO 38804
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38861: LD_VAR 0 3
38865: PPUSH
38866: CALL_OW 311
38870: NOT
38871: PUSH
38872: LD_VAR 0 3
38876: PUSH
38877: LD_EXP 93
38881: PUSH
38882: LD_VAR 0 2
38886: ARRAY
38887: PUSH
38888: LD_INT 1
38890: ARRAY
38891: IN
38892: NOT
38893: AND
38894: PUSH
38895: LD_VAR 0 3
38899: PUSH
38900: LD_EXP 93
38904: PUSH
38905: LD_VAR 0 2
38909: ARRAY
38910: PUSH
38911: LD_INT 2
38913: ARRAY
38914: IN
38915: NOT
38916: AND
38917: IFFALSE 38969
// begin if IsInUnit ( j ) then
38919: LD_VAR 0 3
38923: PPUSH
38924: CALL_OW 310
38928: IFFALSE 38939
// ComExitBuilding ( j ) ;
38930: LD_VAR 0 3
38934: PPUSH
38935: CALL_OW 122
// if not HasTask ( j ) then
38939: LD_VAR 0 3
38943: PPUSH
38944: CALL_OW 314
38948: NOT
38949: IFFALSE 38969
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38951: LD_VAR 0 3
38955: PPUSH
38956: LD_VAR 0 7
38960: PUSH
38961: LD_INT 1
38963: ARRAY
38964: PPUSH
38965: CALL_OW 189
// end ; end ;
38969: GO 38804
38971: POP
38972: POP
// end ;
38973: GO 38293
38975: POP
38976: POP
// end ;
38977: LD_VAR 0 1
38981: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38982: LD_INT 0
38984: PPUSH
38985: PPUSH
38986: PPUSH
38987: PPUSH
38988: PPUSH
38989: PPUSH
38990: PPUSH
38991: PPUSH
38992: PPUSH
38993: PPUSH
38994: PPUSH
// if not mc_bases then
38995: LD_EXP 90
38999: NOT
39000: IFFALSE 39004
// exit ;
39002: GO 39806
// for i = 1 to mc_bases do
39004: LD_ADDR_VAR 0 2
39008: PUSH
39009: DOUBLE
39010: LD_INT 1
39012: DEC
39013: ST_TO_ADDR
39014: LD_EXP 90
39018: PUSH
39019: FOR_TO
39020: IFFALSE 39804
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39022: LD_EXP 118
39026: PUSH
39027: LD_VAR 0 2
39031: ARRAY
39032: NOT
39033: PUSH
39034: LD_EXP 93
39038: PUSH
39039: LD_VAR 0 2
39043: ARRAY
39044: PUSH
39045: LD_INT 1
39047: ARRAY
39048: OR
39049: PUSH
39050: LD_EXP 93
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: PUSH
39061: LD_INT 2
39063: ARRAY
39064: OR
39065: PUSH
39066: LD_EXP 116
39070: PUSH
39071: LD_VAR 0 2
39075: ARRAY
39076: PPUSH
39077: LD_INT 1
39079: PPUSH
39080: CALL_OW 325
39084: NOT
39085: OR
39086: PUSH
39087: LD_EXP 113
39091: PUSH
39092: LD_VAR 0 2
39096: ARRAY
39097: OR
39098: IFFALSE 39102
// continue ;
39100: GO 39019
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39102: LD_ADDR_VAR 0 8
39106: PUSH
39107: LD_EXP 90
39111: PUSH
39112: LD_VAR 0 2
39116: ARRAY
39117: PPUSH
39118: LD_INT 25
39120: PUSH
39121: LD_INT 4
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 50
39130: PUSH
39131: EMPTY
39132: LIST
39133: PUSH
39134: LD_INT 3
39136: PUSH
39137: LD_INT 60
39139: PUSH
39140: EMPTY
39141: LIST
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: PPUSH
39152: CALL_OW 72
39156: PUSH
39157: LD_EXP 94
39161: PUSH
39162: LD_VAR 0 2
39166: ARRAY
39167: DIFF
39168: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39169: LD_ADDR_VAR 0 9
39173: PUSH
39174: LD_EXP 90
39178: PUSH
39179: LD_VAR 0 2
39183: ARRAY
39184: PPUSH
39185: LD_INT 2
39187: PUSH
39188: LD_INT 30
39190: PUSH
39191: LD_INT 0
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 30
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: LIST
39212: PPUSH
39213: CALL_OW 72
39217: ST_TO_ADDR
// if not tmp or not dep then
39218: LD_VAR 0 8
39222: NOT
39223: PUSH
39224: LD_VAR 0 9
39228: NOT
39229: OR
39230: IFFALSE 39234
// continue ;
39232: GO 39019
// side := GetSide ( tmp [ 1 ] ) ;
39234: LD_ADDR_VAR 0 11
39238: PUSH
39239: LD_VAR 0 8
39243: PUSH
39244: LD_INT 1
39246: ARRAY
39247: PPUSH
39248: CALL_OW 255
39252: ST_TO_ADDR
// dep := dep [ 1 ] ;
39253: LD_ADDR_VAR 0 9
39257: PUSH
39258: LD_VAR 0 9
39262: PUSH
39263: LD_INT 1
39265: ARRAY
39266: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39267: LD_ADDR_VAR 0 7
39271: PUSH
39272: LD_EXP 118
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: PPUSH
39283: LD_INT 22
39285: PUSH
39286: LD_INT 0
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 25
39295: PUSH
39296: LD_INT 12
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PPUSH
39307: CALL_OW 70
39311: PUSH
39312: LD_INT 22
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 25
39324: PUSH
39325: LD_INT 12
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 91
39334: PUSH
39335: LD_VAR 0 9
39339: PUSH
39340: LD_INT 20
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: LIST
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: LIST
39352: PPUSH
39353: CALL_OW 69
39357: UNION
39358: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39359: LD_ADDR_VAR 0 10
39363: PUSH
39364: LD_EXP 118
39368: PUSH
39369: LD_VAR 0 2
39373: ARRAY
39374: PPUSH
39375: LD_INT 81
39377: PUSH
39378: LD_VAR 0 11
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PPUSH
39387: CALL_OW 70
39391: ST_TO_ADDR
// if not apes or danger_at_area then
39392: LD_VAR 0 7
39396: NOT
39397: PUSH
39398: LD_VAR 0 10
39402: OR
39403: IFFALSE 39453
// begin if mc_taming [ i ] then
39405: LD_EXP 121
39409: PUSH
39410: LD_VAR 0 2
39414: ARRAY
39415: IFFALSE 39451
// begin MC_Reset ( i , 121 ) ;
39417: LD_VAR 0 2
39421: PPUSH
39422: LD_INT 121
39424: PPUSH
39425: CALL 24856 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39429: LD_ADDR_EXP 121
39433: PUSH
39434: LD_EXP 121
39438: PPUSH
39439: LD_VAR 0 2
39443: PPUSH
39444: EMPTY
39445: PPUSH
39446: CALL_OW 1
39450: ST_TO_ADDR
// end ; continue ;
39451: GO 39019
// end ; for j in tmp do
39453: LD_ADDR_VAR 0 3
39457: PUSH
39458: LD_VAR 0 8
39462: PUSH
39463: FOR_IN
39464: IFFALSE 39800
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39466: LD_VAR 0 3
39470: PUSH
39471: LD_EXP 121
39475: PUSH
39476: LD_VAR 0 2
39480: ARRAY
39481: IN
39482: NOT
39483: PUSH
39484: LD_EXP 121
39488: PUSH
39489: LD_VAR 0 2
39493: ARRAY
39494: PUSH
39495: LD_INT 3
39497: LESS
39498: AND
39499: IFFALSE 39557
// begin SetTag ( j , 121 ) ;
39501: LD_VAR 0 3
39505: PPUSH
39506: LD_INT 121
39508: PPUSH
39509: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39513: LD_ADDR_EXP 121
39517: PUSH
39518: LD_EXP 121
39522: PPUSH
39523: LD_VAR 0 2
39527: PUSH
39528: LD_EXP 121
39532: PUSH
39533: LD_VAR 0 2
39537: ARRAY
39538: PUSH
39539: LD_INT 1
39541: PLUS
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PPUSH
39547: LD_VAR 0 3
39551: PPUSH
39552: CALL 55814 0 3
39556: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39557: LD_VAR 0 3
39561: PUSH
39562: LD_EXP 121
39566: PUSH
39567: LD_VAR 0 2
39571: ARRAY
39572: IN
39573: IFFALSE 39798
// begin if GetClass ( j ) <> 4 then
39575: LD_VAR 0 3
39579: PPUSH
39580: CALL_OW 257
39584: PUSH
39585: LD_INT 4
39587: NONEQUAL
39588: IFFALSE 39641
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39590: LD_ADDR_EXP 121
39594: PUSH
39595: LD_EXP 121
39599: PPUSH
39600: LD_VAR 0 2
39604: PPUSH
39605: LD_EXP 121
39609: PUSH
39610: LD_VAR 0 2
39614: ARRAY
39615: PUSH
39616: LD_VAR 0 3
39620: DIFF
39621: PPUSH
39622: CALL_OW 1
39626: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39627: LD_VAR 0 3
39631: PPUSH
39632: LD_INT 0
39634: PPUSH
39635: CALL_OW 109
// continue ;
39639: GO 39463
// end ; if IsInUnit ( j ) then
39641: LD_VAR 0 3
39645: PPUSH
39646: CALL_OW 310
39650: IFFALSE 39661
// ComExitBuilding ( j ) ;
39652: LD_VAR 0 3
39656: PPUSH
39657: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39661: LD_ADDR_VAR 0 6
39665: PUSH
39666: LD_VAR 0 7
39670: PPUSH
39671: LD_VAR 0 3
39675: PPUSH
39676: CALL_OW 74
39680: ST_TO_ADDR
// if not ape then
39681: LD_VAR 0 6
39685: NOT
39686: IFFALSE 39690
// break ;
39688: GO 39800
// x := GetX ( ape ) ;
39690: LD_ADDR_VAR 0 4
39694: PUSH
39695: LD_VAR 0 6
39699: PPUSH
39700: CALL_OW 250
39704: ST_TO_ADDR
// y := GetY ( ape ) ;
39705: LD_ADDR_VAR 0 5
39709: PUSH
39710: LD_VAR 0 6
39714: PPUSH
39715: CALL_OW 251
39719: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39720: LD_VAR 0 4
39724: PPUSH
39725: LD_VAR 0 5
39729: PPUSH
39730: CALL_OW 488
39734: NOT
39735: PUSH
39736: LD_VAR 0 11
39740: PPUSH
39741: LD_VAR 0 4
39745: PPUSH
39746: LD_VAR 0 5
39750: PPUSH
39751: LD_INT 20
39753: PPUSH
39754: CALL 56710 0 4
39758: PUSH
39759: LD_INT 4
39761: ARRAY
39762: OR
39763: IFFALSE 39767
// break ;
39765: GO 39800
// if not HasTask ( j ) then
39767: LD_VAR 0 3
39771: PPUSH
39772: CALL_OW 314
39776: NOT
39777: IFFALSE 39798
// ComTameXY ( j , x , y ) ;
39779: LD_VAR 0 3
39783: PPUSH
39784: LD_VAR 0 4
39788: PPUSH
39789: LD_VAR 0 5
39793: PPUSH
39794: CALL_OW 131
// end ; end ;
39798: GO 39463
39800: POP
39801: POP
// end ;
39802: GO 39019
39804: POP
39805: POP
// end ;
39806: LD_VAR 0 1
39810: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39811: LD_INT 0
39813: PPUSH
39814: PPUSH
39815: PPUSH
39816: PPUSH
39817: PPUSH
39818: PPUSH
39819: PPUSH
39820: PPUSH
// if not mc_bases then
39821: LD_EXP 90
39825: NOT
39826: IFFALSE 39830
// exit ;
39828: GO 40456
// for i = 1 to mc_bases do
39830: LD_ADDR_VAR 0 2
39834: PUSH
39835: DOUBLE
39836: LD_INT 1
39838: DEC
39839: ST_TO_ADDR
39840: LD_EXP 90
39844: PUSH
39845: FOR_TO
39846: IFFALSE 40454
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39848: LD_EXP 119
39852: PUSH
39853: LD_VAR 0 2
39857: ARRAY
39858: NOT
39859: PUSH
39860: LD_EXP 119
39864: PUSH
39865: LD_VAR 0 2
39869: ARRAY
39870: PPUSH
39871: LD_INT 25
39873: PUSH
39874: LD_INT 12
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PPUSH
39881: CALL_OW 72
39885: NOT
39886: OR
39887: IFFALSE 39891
// continue ;
39889: GO 39845
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39891: LD_ADDR_VAR 0 5
39895: PUSH
39896: LD_EXP 119
39900: PUSH
39901: LD_VAR 0 2
39905: ARRAY
39906: PUSH
39907: LD_INT 1
39909: ARRAY
39910: PPUSH
39911: CALL_OW 255
39915: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39916: LD_VAR 0 5
39920: PPUSH
39921: LD_INT 2
39923: PPUSH
39924: CALL_OW 325
39928: IFFALSE 40181
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39930: LD_ADDR_VAR 0 4
39934: PUSH
39935: LD_EXP 119
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PPUSH
39946: LD_INT 25
39948: PUSH
39949: LD_INT 16
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PPUSH
39956: CALL_OW 72
39960: ST_TO_ADDR
// if tmp < 6 then
39961: LD_VAR 0 4
39965: PUSH
39966: LD_INT 6
39968: LESS
39969: IFFALSE 40181
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39971: LD_ADDR_VAR 0 6
39975: PUSH
39976: LD_EXP 90
39980: PUSH
39981: LD_VAR 0 2
39985: ARRAY
39986: PPUSH
39987: LD_INT 2
39989: PUSH
39990: LD_INT 30
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 30
40002: PUSH
40003: LD_INT 1
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: LIST
40014: PPUSH
40015: CALL_OW 72
40019: ST_TO_ADDR
// if depot then
40020: LD_VAR 0 6
40024: IFFALSE 40181
// begin selected := 0 ;
40026: LD_ADDR_VAR 0 7
40030: PUSH
40031: LD_INT 0
40033: ST_TO_ADDR
// for j in depot do
40034: LD_ADDR_VAR 0 3
40038: PUSH
40039: LD_VAR 0 6
40043: PUSH
40044: FOR_IN
40045: IFFALSE 40076
// begin if UnitsInside ( j ) < 6 then
40047: LD_VAR 0 3
40051: PPUSH
40052: CALL_OW 313
40056: PUSH
40057: LD_INT 6
40059: LESS
40060: IFFALSE 40074
// begin selected := j ;
40062: LD_ADDR_VAR 0 7
40066: PUSH
40067: LD_VAR 0 3
40071: ST_TO_ADDR
// break ;
40072: GO 40076
// end ; end ;
40074: GO 40044
40076: POP
40077: POP
// if selected then
40078: LD_VAR 0 7
40082: IFFALSE 40181
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40084: LD_ADDR_VAR 0 3
40088: PUSH
40089: LD_EXP 119
40093: PUSH
40094: LD_VAR 0 2
40098: ARRAY
40099: PPUSH
40100: LD_INT 25
40102: PUSH
40103: LD_INT 12
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PPUSH
40110: CALL_OW 72
40114: PUSH
40115: FOR_IN
40116: IFFALSE 40179
// if not HasTask ( j ) then
40118: LD_VAR 0 3
40122: PPUSH
40123: CALL_OW 314
40127: NOT
40128: IFFALSE 40177
// begin if not IsInUnit ( j ) then
40130: LD_VAR 0 3
40134: PPUSH
40135: CALL_OW 310
40139: NOT
40140: IFFALSE 40156
// ComEnterUnit ( j , selected ) ;
40142: LD_VAR 0 3
40146: PPUSH
40147: LD_VAR 0 7
40151: PPUSH
40152: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40156: LD_VAR 0 3
40160: PPUSH
40161: LD_INT 16
40163: PPUSH
40164: CALL_OW 183
// AddComExitBuilding ( j ) ;
40168: LD_VAR 0 3
40172: PPUSH
40173: CALL_OW 182
// end ;
40177: GO 40115
40179: POP
40180: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40181: LD_VAR 0 5
40185: PPUSH
40186: LD_INT 11
40188: PPUSH
40189: CALL_OW 325
40193: IFFALSE 40452
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40195: LD_ADDR_VAR 0 4
40199: PUSH
40200: LD_EXP 119
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PPUSH
40211: LD_INT 25
40213: PUSH
40214: LD_INT 16
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PPUSH
40221: CALL_OW 72
40225: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40226: LD_VAR 0 4
40230: PUSH
40231: LD_INT 6
40233: GREATEREQUAL
40234: PUSH
40235: LD_VAR 0 5
40239: PPUSH
40240: LD_INT 2
40242: PPUSH
40243: CALL_OW 325
40247: NOT
40248: OR
40249: IFFALSE 40452
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40251: LD_ADDR_VAR 0 8
40255: PUSH
40256: LD_EXP 90
40260: PUSH
40261: LD_VAR 0 2
40265: ARRAY
40266: PPUSH
40267: LD_INT 2
40269: PUSH
40270: LD_INT 30
40272: PUSH
40273: LD_INT 4
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 30
40282: PUSH
40283: LD_INT 5
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: LIST
40294: PPUSH
40295: CALL_OW 72
40299: ST_TO_ADDR
// if barracks then
40300: LD_VAR 0 8
40304: IFFALSE 40452
// begin selected := 0 ;
40306: LD_ADDR_VAR 0 7
40310: PUSH
40311: LD_INT 0
40313: ST_TO_ADDR
// for j in barracks do
40314: LD_ADDR_VAR 0 3
40318: PUSH
40319: LD_VAR 0 8
40323: PUSH
40324: FOR_IN
40325: IFFALSE 40356
// begin if UnitsInside ( j ) < 6 then
40327: LD_VAR 0 3
40331: PPUSH
40332: CALL_OW 313
40336: PUSH
40337: LD_INT 6
40339: LESS
40340: IFFALSE 40354
// begin selected := j ;
40342: LD_ADDR_VAR 0 7
40346: PUSH
40347: LD_VAR 0 3
40351: ST_TO_ADDR
// break ;
40352: GO 40356
// end ; end ;
40354: GO 40324
40356: POP
40357: POP
// if selected then
40358: LD_VAR 0 7
40362: IFFALSE 40452
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40364: LD_ADDR_VAR 0 3
40368: PUSH
40369: LD_EXP 119
40373: PUSH
40374: LD_VAR 0 2
40378: ARRAY
40379: PPUSH
40380: LD_INT 25
40382: PUSH
40383: LD_INT 12
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PPUSH
40390: CALL_OW 72
40394: PUSH
40395: FOR_IN
40396: IFFALSE 40450
// if not IsInUnit ( j ) and not HasTask ( j ) then
40398: LD_VAR 0 3
40402: PPUSH
40403: CALL_OW 310
40407: NOT
40408: PUSH
40409: LD_VAR 0 3
40413: PPUSH
40414: CALL_OW 314
40418: NOT
40419: AND
40420: IFFALSE 40448
// begin ComEnterUnit ( j , selected ) ;
40422: LD_VAR 0 3
40426: PPUSH
40427: LD_VAR 0 7
40431: PPUSH
40432: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40436: LD_VAR 0 3
40440: PPUSH
40441: LD_INT 15
40443: PPUSH
40444: CALL_OW 183
// end ;
40448: GO 40395
40450: POP
40451: POP
// end ; end ; end ; end ; end ;
40452: GO 39845
40454: POP
40455: POP
// end ;
40456: LD_VAR 0 1
40460: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40461: LD_INT 0
40463: PPUSH
40464: PPUSH
40465: PPUSH
40466: PPUSH
// if not mc_bases then
40467: LD_EXP 90
40471: NOT
40472: IFFALSE 40476
// exit ;
40474: GO 40654
// for i = 1 to mc_bases do
40476: LD_ADDR_VAR 0 2
40480: PUSH
40481: DOUBLE
40482: LD_INT 1
40484: DEC
40485: ST_TO_ADDR
40486: LD_EXP 90
40490: PUSH
40491: FOR_TO
40492: IFFALSE 40652
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40494: LD_ADDR_VAR 0 4
40498: PUSH
40499: LD_EXP 90
40503: PUSH
40504: LD_VAR 0 2
40508: ARRAY
40509: PPUSH
40510: LD_INT 25
40512: PUSH
40513: LD_INT 9
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PPUSH
40520: CALL_OW 72
40524: ST_TO_ADDR
// if not tmp then
40525: LD_VAR 0 4
40529: NOT
40530: IFFALSE 40534
// continue ;
40532: GO 40491
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40534: LD_EXP 116
40538: PUSH
40539: LD_VAR 0 2
40543: ARRAY
40544: PPUSH
40545: LD_INT 29
40547: PPUSH
40548: CALL_OW 325
40552: NOT
40553: PUSH
40554: LD_EXP 116
40558: PUSH
40559: LD_VAR 0 2
40563: ARRAY
40564: PPUSH
40565: LD_INT 28
40567: PPUSH
40568: CALL_OW 325
40572: NOT
40573: AND
40574: IFFALSE 40578
// continue ;
40576: GO 40491
// for j in tmp do
40578: LD_ADDR_VAR 0 3
40582: PUSH
40583: LD_VAR 0 4
40587: PUSH
40588: FOR_IN
40589: IFFALSE 40648
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40591: LD_VAR 0 3
40595: PUSH
40596: LD_EXP 93
40600: PUSH
40601: LD_VAR 0 2
40605: ARRAY
40606: PUSH
40607: LD_INT 1
40609: ARRAY
40610: IN
40611: NOT
40612: PUSH
40613: LD_VAR 0 3
40617: PUSH
40618: LD_EXP 93
40622: PUSH
40623: LD_VAR 0 2
40627: ARRAY
40628: PUSH
40629: LD_INT 2
40631: ARRAY
40632: IN
40633: NOT
40634: AND
40635: IFFALSE 40646
// ComSpaceTimeShoot ( j ) ;
40637: LD_VAR 0 3
40641: PPUSH
40642: CALL 51811 0 1
40646: GO 40588
40648: POP
40649: POP
// end ;
40650: GO 40491
40652: POP
40653: POP
// end ;
40654: LD_VAR 0 1
40658: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40659: LD_INT 0
40661: PPUSH
40662: PPUSH
40663: PPUSH
40664: PPUSH
40665: PPUSH
40666: PPUSH
40667: PPUSH
40668: PPUSH
40669: PPUSH
// if not mc_bases then
40670: LD_EXP 90
40674: NOT
40675: IFFALSE 40679
// exit ;
40677: GO 41301
// for i = 1 to mc_bases do
40679: LD_ADDR_VAR 0 2
40683: PUSH
40684: DOUBLE
40685: LD_INT 1
40687: DEC
40688: ST_TO_ADDR
40689: LD_EXP 90
40693: PUSH
40694: FOR_TO
40695: IFFALSE 41299
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40697: LD_EXP 125
40701: PUSH
40702: LD_VAR 0 2
40706: ARRAY
40707: NOT
40708: PUSH
40709: LD_INT 38
40711: PPUSH
40712: LD_EXP 116
40716: PUSH
40717: LD_VAR 0 2
40721: ARRAY
40722: PPUSH
40723: CALL_OW 321
40727: PUSH
40728: LD_INT 2
40730: NONEQUAL
40731: OR
40732: IFFALSE 40736
// continue ;
40734: GO 40694
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40736: LD_ADDR_VAR 0 8
40740: PUSH
40741: LD_EXP 90
40745: PUSH
40746: LD_VAR 0 2
40750: ARRAY
40751: PPUSH
40752: LD_INT 30
40754: PUSH
40755: LD_INT 34
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PPUSH
40762: CALL_OW 72
40766: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40767: LD_ADDR_VAR 0 9
40771: PUSH
40772: LD_EXP 90
40776: PUSH
40777: LD_VAR 0 2
40781: ARRAY
40782: PPUSH
40783: LD_INT 25
40785: PUSH
40786: LD_INT 4
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PPUSH
40793: CALL_OW 72
40797: PPUSH
40798: LD_INT 0
40800: PPUSH
40801: CALL 84375 0 2
40805: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40806: LD_VAR 0 9
40810: NOT
40811: PUSH
40812: LD_VAR 0 8
40816: NOT
40817: OR
40818: PUSH
40819: LD_EXP 90
40823: PUSH
40824: LD_VAR 0 2
40828: ARRAY
40829: PPUSH
40830: LD_INT 124
40832: PPUSH
40833: CALL 84375 0 2
40837: OR
40838: IFFALSE 40842
// continue ;
40840: GO 40694
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40842: LD_EXP 126
40846: PUSH
40847: LD_VAR 0 2
40851: ARRAY
40852: PUSH
40853: LD_EXP 125
40857: PUSH
40858: LD_VAR 0 2
40862: ARRAY
40863: LESS
40864: PUSH
40865: LD_EXP 126
40869: PUSH
40870: LD_VAR 0 2
40874: ARRAY
40875: PUSH
40876: LD_VAR 0 8
40880: LESS
40881: AND
40882: IFFALSE 41297
// begin tmp := sci [ 1 ] ;
40884: LD_ADDR_VAR 0 7
40888: PUSH
40889: LD_VAR 0 9
40893: PUSH
40894: LD_INT 1
40896: ARRAY
40897: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40898: LD_VAR 0 7
40902: PPUSH
40903: LD_INT 124
40905: PPUSH
40906: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40910: LD_ADDR_VAR 0 3
40914: PUSH
40915: DOUBLE
40916: LD_EXP 125
40920: PUSH
40921: LD_VAR 0 2
40925: ARRAY
40926: INC
40927: ST_TO_ADDR
40928: LD_EXP 125
40932: PUSH
40933: LD_VAR 0 2
40937: ARRAY
40938: PUSH
40939: FOR_DOWNTO
40940: IFFALSE 41283
// begin if IsInUnit ( tmp ) then
40942: LD_VAR 0 7
40946: PPUSH
40947: CALL_OW 310
40951: IFFALSE 40962
// ComExitBuilding ( tmp ) ;
40953: LD_VAR 0 7
40957: PPUSH
40958: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40962: LD_INT 35
40964: PPUSH
40965: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40969: LD_VAR 0 7
40973: PPUSH
40974: CALL_OW 310
40978: NOT
40979: PUSH
40980: LD_VAR 0 7
40984: PPUSH
40985: CALL_OW 314
40989: NOT
40990: AND
40991: IFFALSE 40962
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40993: LD_ADDR_VAR 0 6
40997: PUSH
40998: LD_VAR 0 7
41002: PPUSH
41003: CALL_OW 250
41007: PUSH
41008: LD_VAR 0 7
41012: PPUSH
41013: CALL_OW 251
41017: PUSH
41018: EMPTY
41019: LIST
41020: LIST
41021: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41022: LD_INT 35
41024: PPUSH
41025: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41029: LD_ADDR_VAR 0 4
41033: PUSH
41034: LD_EXP 125
41038: PUSH
41039: LD_VAR 0 2
41043: ARRAY
41044: PUSH
41045: LD_VAR 0 3
41049: ARRAY
41050: PUSH
41051: LD_INT 1
41053: ARRAY
41054: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41055: LD_ADDR_VAR 0 5
41059: PUSH
41060: LD_EXP 125
41064: PUSH
41065: LD_VAR 0 2
41069: ARRAY
41070: PUSH
41071: LD_VAR 0 3
41075: ARRAY
41076: PUSH
41077: LD_INT 2
41079: ARRAY
41080: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41081: LD_VAR 0 7
41085: PPUSH
41086: LD_INT 10
41088: PPUSH
41089: CALL 58407 0 2
41093: PUSH
41094: LD_INT 4
41096: ARRAY
41097: IFFALSE 41135
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41099: LD_VAR 0 7
41103: PPUSH
41104: LD_VAR 0 6
41108: PUSH
41109: LD_INT 1
41111: ARRAY
41112: PPUSH
41113: LD_VAR 0 6
41117: PUSH
41118: LD_INT 2
41120: ARRAY
41121: PPUSH
41122: CALL_OW 111
// wait ( 0 0$10 ) ;
41126: LD_INT 350
41128: PPUSH
41129: CALL_OW 67
// end else
41133: GO 41161
// begin ComMoveXY ( tmp , x , y ) ;
41135: LD_VAR 0 7
41139: PPUSH
41140: LD_VAR 0 4
41144: PPUSH
41145: LD_VAR 0 5
41149: PPUSH
41150: CALL_OW 111
// wait ( 0 0$3 ) ;
41154: LD_INT 105
41156: PPUSH
41157: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41161: LD_VAR 0 7
41165: PPUSH
41166: LD_VAR 0 4
41170: PPUSH
41171: LD_VAR 0 5
41175: PPUSH
41176: CALL_OW 307
41180: IFFALSE 41022
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41182: LD_VAR 0 7
41186: PPUSH
41187: LD_VAR 0 4
41191: PPUSH
41192: LD_VAR 0 5
41196: PPUSH
41197: LD_VAR 0 8
41201: PUSH
41202: LD_VAR 0 3
41206: ARRAY
41207: PPUSH
41208: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41212: LD_INT 35
41214: PPUSH
41215: CALL_OW 67
// until not HasTask ( tmp ) ;
41219: LD_VAR 0 7
41223: PPUSH
41224: CALL_OW 314
41228: NOT
41229: IFFALSE 41212
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41231: LD_ADDR_EXP 126
41235: PUSH
41236: LD_EXP 126
41240: PPUSH
41241: LD_VAR 0 2
41245: PUSH
41246: LD_EXP 126
41250: PUSH
41251: LD_VAR 0 2
41255: ARRAY
41256: PUSH
41257: LD_INT 1
41259: PLUS
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PPUSH
41265: LD_VAR 0 8
41269: PUSH
41270: LD_VAR 0 3
41274: ARRAY
41275: PPUSH
41276: CALL 55814 0 3
41280: ST_TO_ADDR
// end ;
41281: GO 40939
41283: POP
41284: POP
// MC_Reset ( i , 124 ) ;
41285: LD_VAR 0 2
41289: PPUSH
41290: LD_INT 124
41292: PPUSH
41293: CALL 24856 0 2
// end ; end ;
41297: GO 40694
41299: POP
41300: POP
// end ;
41301: LD_VAR 0 1
41305: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41306: LD_INT 0
41308: PPUSH
41309: PPUSH
41310: PPUSH
// if not mc_bases then
41311: LD_EXP 90
41315: NOT
41316: IFFALSE 41320
// exit ;
41318: GO 41926
// for i = 1 to mc_bases do
41320: LD_ADDR_VAR 0 2
41324: PUSH
41325: DOUBLE
41326: LD_INT 1
41328: DEC
41329: ST_TO_ADDR
41330: LD_EXP 90
41334: PUSH
41335: FOR_TO
41336: IFFALSE 41924
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41338: LD_ADDR_VAR 0 3
41342: PUSH
41343: LD_EXP 90
41347: PUSH
41348: LD_VAR 0 2
41352: ARRAY
41353: PPUSH
41354: LD_INT 25
41356: PUSH
41357: LD_INT 4
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PPUSH
41364: CALL_OW 72
41368: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41369: LD_VAR 0 3
41373: NOT
41374: PUSH
41375: LD_EXP 127
41379: PUSH
41380: LD_VAR 0 2
41384: ARRAY
41385: NOT
41386: OR
41387: PUSH
41388: LD_EXP 90
41392: PUSH
41393: LD_VAR 0 2
41397: ARRAY
41398: PPUSH
41399: LD_INT 2
41401: PUSH
41402: LD_INT 30
41404: PUSH
41405: LD_INT 0
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: LD_INT 30
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: LIST
41426: PPUSH
41427: CALL_OW 72
41431: NOT
41432: OR
41433: IFFALSE 41483
// begin if mc_deposits_finder [ i ] then
41435: LD_EXP 128
41439: PUSH
41440: LD_VAR 0 2
41444: ARRAY
41445: IFFALSE 41481
// begin MC_Reset ( i , 125 ) ;
41447: LD_VAR 0 2
41451: PPUSH
41452: LD_INT 125
41454: PPUSH
41455: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41459: LD_ADDR_EXP 128
41463: PUSH
41464: LD_EXP 128
41468: PPUSH
41469: LD_VAR 0 2
41473: PPUSH
41474: EMPTY
41475: PPUSH
41476: CALL_OW 1
41480: ST_TO_ADDR
// end ; continue ;
41481: GO 41335
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41483: LD_EXP 127
41487: PUSH
41488: LD_VAR 0 2
41492: ARRAY
41493: PUSH
41494: LD_INT 1
41496: ARRAY
41497: PUSH
41498: LD_INT 3
41500: ARRAY
41501: PUSH
41502: LD_INT 1
41504: EQUAL
41505: PUSH
41506: LD_INT 20
41508: PPUSH
41509: LD_EXP 116
41513: PUSH
41514: LD_VAR 0 2
41518: ARRAY
41519: PPUSH
41520: CALL_OW 321
41524: PUSH
41525: LD_INT 2
41527: NONEQUAL
41528: AND
41529: IFFALSE 41579
// begin if mc_deposits_finder [ i ] then
41531: LD_EXP 128
41535: PUSH
41536: LD_VAR 0 2
41540: ARRAY
41541: IFFALSE 41577
// begin MC_Reset ( i , 125 ) ;
41543: LD_VAR 0 2
41547: PPUSH
41548: LD_INT 125
41550: PPUSH
41551: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41555: LD_ADDR_EXP 128
41559: PUSH
41560: LD_EXP 128
41564: PPUSH
41565: LD_VAR 0 2
41569: PPUSH
41570: EMPTY
41571: PPUSH
41572: CALL_OW 1
41576: ST_TO_ADDR
// end ; continue ;
41577: GO 41335
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41579: LD_EXP 127
41583: PUSH
41584: LD_VAR 0 2
41588: ARRAY
41589: PUSH
41590: LD_INT 1
41592: ARRAY
41593: PUSH
41594: LD_INT 1
41596: ARRAY
41597: PPUSH
41598: LD_EXP 127
41602: PUSH
41603: LD_VAR 0 2
41607: ARRAY
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PUSH
41613: LD_INT 2
41615: ARRAY
41616: PPUSH
41617: LD_EXP 116
41621: PUSH
41622: LD_VAR 0 2
41626: ARRAY
41627: PPUSH
41628: CALL_OW 440
41632: IFFALSE 41675
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41634: LD_ADDR_EXP 127
41638: PUSH
41639: LD_EXP 127
41643: PPUSH
41644: LD_VAR 0 2
41648: PPUSH
41649: LD_EXP 127
41653: PUSH
41654: LD_VAR 0 2
41658: ARRAY
41659: PPUSH
41660: LD_INT 1
41662: PPUSH
41663: CALL_OW 3
41667: PPUSH
41668: CALL_OW 1
41672: ST_TO_ADDR
41673: GO 41922
// begin if not mc_deposits_finder [ i ] then
41675: LD_EXP 128
41679: PUSH
41680: LD_VAR 0 2
41684: ARRAY
41685: NOT
41686: IFFALSE 41738
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41688: LD_ADDR_EXP 128
41692: PUSH
41693: LD_EXP 128
41697: PPUSH
41698: LD_VAR 0 2
41702: PPUSH
41703: LD_VAR 0 3
41707: PUSH
41708: LD_INT 1
41710: ARRAY
41711: PUSH
41712: EMPTY
41713: LIST
41714: PPUSH
41715: CALL_OW 1
41719: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41720: LD_VAR 0 3
41724: PUSH
41725: LD_INT 1
41727: ARRAY
41728: PPUSH
41729: LD_INT 125
41731: PPUSH
41732: CALL_OW 109
// end else
41736: GO 41922
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41738: LD_EXP 128
41742: PUSH
41743: LD_VAR 0 2
41747: ARRAY
41748: PUSH
41749: LD_INT 1
41751: ARRAY
41752: PPUSH
41753: CALL_OW 310
41757: IFFALSE 41780
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41759: LD_EXP 128
41763: PUSH
41764: LD_VAR 0 2
41768: ARRAY
41769: PUSH
41770: LD_INT 1
41772: ARRAY
41773: PPUSH
41774: CALL_OW 122
41778: GO 41922
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41780: LD_EXP 128
41784: PUSH
41785: LD_VAR 0 2
41789: ARRAY
41790: PUSH
41791: LD_INT 1
41793: ARRAY
41794: PPUSH
41795: CALL_OW 314
41799: NOT
41800: PUSH
41801: LD_EXP 128
41805: PUSH
41806: LD_VAR 0 2
41810: ARRAY
41811: PUSH
41812: LD_INT 1
41814: ARRAY
41815: PPUSH
41816: LD_EXP 127
41820: PUSH
41821: LD_VAR 0 2
41825: ARRAY
41826: PUSH
41827: LD_INT 1
41829: ARRAY
41830: PUSH
41831: LD_INT 1
41833: ARRAY
41834: PPUSH
41835: LD_EXP 127
41839: PUSH
41840: LD_VAR 0 2
41844: ARRAY
41845: PUSH
41846: LD_INT 1
41848: ARRAY
41849: PUSH
41850: LD_INT 2
41852: ARRAY
41853: PPUSH
41854: CALL_OW 297
41858: PUSH
41859: LD_INT 6
41861: GREATER
41862: AND
41863: IFFALSE 41922
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41865: LD_EXP 128
41869: PUSH
41870: LD_VAR 0 2
41874: ARRAY
41875: PUSH
41876: LD_INT 1
41878: ARRAY
41879: PPUSH
41880: LD_EXP 127
41884: PUSH
41885: LD_VAR 0 2
41889: ARRAY
41890: PUSH
41891: LD_INT 1
41893: ARRAY
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: PPUSH
41899: LD_EXP 127
41903: PUSH
41904: LD_VAR 0 2
41908: ARRAY
41909: PUSH
41910: LD_INT 1
41912: ARRAY
41913: PUSH
41914: LD_INT 2
41916: ARRAY
41917: PPUSH
41918: CALL_OW 111
// end ; end ; end ;
41922: GO 41335
41924: POP
41925: POP
// end ;
41926: LD_VAR 0 1
41930: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41931: LD_INT 0
41933: PPUSH
41934: PPUSH
41935: PPUSH
41936: PPUSH
41937: PPUSH
41938: PPUSH
41939: PPUSH
41940: PPUSH
41941: PPUSH
41942: PPUSH
41943: PPUSH
// if not mc_bases then
41944: LD_EXP 90
41948: NOT
41949: IFFALSE 41953
// exit ;
41951: GO 42893
// for i = 1 to mc_bases do
41953: LD_ADDR_VAR 0 2
41957: PUSH
41958: DOUBLE
41959: LD_INT 1
41961: DEC
41962: ST_TO_ADDR
41963: LD_EXP 90
41967: PUSH
41968: FOR_TO
41969: IFFALSE 42891
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41971: LD_EXP 90
41975: PUSH
41976: LD_VAR 0 2
41980: ARRAY
41981: NOT
41982: PUSH
41983: LD_EXP 113
41987: PUSH
41988: LD_VAR 0 2
41992: ARRAY
41993: OR
41994: IFFALSE 41998
// continue ;
41996: GO 41968
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41998: LD_ADDR_VAR 0 7
42002: PUSH
42003: LD_EXP 90
42007: PUSH
42008: LD_VAR 0 2
42012: ARRAY
42013: PUSH
42014: LD_INT 1
42016: ARRAY
42017: PPUSH
42018: CALL_OW 248
42022: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42023: LD_VAR 0 7
42027: PUSH
42028: LD_INT 3
42030: EQUAL
42031: PUSH
42032: LD_EXP 109
42036: PUSH
42037: LD_VAR 0 2
42041: ARRAY
42042: PUSH
42043: LD_EXP 112
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: UNION
42054: PPUSH
42055: LD_INT 33
42057: PUSH
42058: LD_INT 2
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PPUSH
42065: CALL_OW 72
42069: NOT
42070: OR
42071: IFFALSE 42075
// continue ;
42073: GO 41968
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42075: LD_ADDR_VAR 0 9
42079: PUSH
42080: LD_EXP 90
42084: PUSH
42085: LD_VAR 0 2
42089: ARRAY
42090: PPUSH
42091: LD_INT 30
42093: PUSH
42094: LD_INT 36
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PPUSH
42101: CALL_OW 72
42105: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42106: LD_ADDR_VAR 0 10
42110: PUSH
42111: LD_EXP 109
42115: PUSH
42116: LD_VAR 0 2
42120: ARRAY
42121: PPUSH
42122: LD_INT 34
42124: PUSH
42125: LD_INT 31
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PPUSH
42132: CALL_OW 72
42136: ST_TO_ADDR
// if not cts and not mcts then
42137: LD_VAR 0 9
42141: NOT
42142: PUSH
42143: LD_VAR 0 10
42147: NOT
42148: AND
42149: IFFALSE 42153
// continue ;
42151: GO 41968
// x := cts ;
42153: LD_ADDR_VAR 0 11
42157: PUSH
42158: LD_VAR 0 9
42162: ST_TO_ADDR
// if not x then
42163: LD_VAR 0 11
42167: NOT
42168: IFFALSE 42180
// x := mcts ;
42170: LD_ADDR_VAR 0 11
42174: PUSH
42175: LD_VAR 0 10
42179: ST_TO_ADDR
// if not x then
42180: LD_VAR 0 11
42184: NOT
42185: IFFALSE 42189
// continue ;
42187: GO 41968
// if mc_remote_driver [ i ] then
42189: LD_EXP 130
42193: PUSH
42194: LD_VAR 0 2
42198: ARRAY
42199: IFFALSE 42586
// for j in mc_remote_driver [ i ] do
42201: LD_ADDR_VAR 0 3
42205: PUSH
42206: LD_EXP 130
42210: PUSH
42211: LD_VAR 0 2
42215: ARRAY
42216: PUSH
42217: FOR_IN
42218: IFFALSE 42584
// begin if GetClass ( j ) <> 3 then
42220: LD_VAR 0 3
42224: PPUSH
42225: CALL_OW 257
42229: PUSH
42230: LD_INT 3
42232: NONEQUAL
42233: IFFALSE 42286
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42235: LD_ADDR_EXP 130
42239: PUSH
42240: LD_EXP 130
42244: PPUSH
42245: LD_VAR 0 2
42249: PPUSH
42250: LD_EXP 130
42254: PUSH
42255: LD_VAR 0 2
42259: ARRAY
42260: PUSH
42261: LD_VAR 0 3
42265: DIFF
42266: PPUSH
42267: CALL_OW 1
42271: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42272: LD_VAR 0 3
42276: PPUSH
42277: LD_INT 0
42279: PPUSH
42280: CALL_OW 109
// continue ;
42284: GO 42217
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42286: LD_EXP 109
42290: PUSH
42291: LD_VAR 0 2
42295: ARRAY
42296: PPUSH
42297: LD_INT 34
42299: PUSH
42300: LD_INT 31
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 58
42309: PUSH
42310: EMPTY
42311: LIST
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PPUSH
42317: CALL_OW 72
42321: PUSH
42322: LD_VAR 0 3
42326: PPUSH
42327: CALL 84463 0 1
42331: NOT
42332: AND
42333: IFFALSE 42404
// begin if IsInUnit ( j ) then
42335: LD_VAR 0 3
42339: PPUSH
42340: CALL_OW 310
42344: IFFALSE 42355
// ComExitBuilding ( j ) ;
42346: LD_VAR 0 3
42350: PPUSH
42351: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42355: LD_VAR 0 3
42359: PPUSH
42360: LD_EXP 109
42364: PUSH
42365: LD_VAR 0 2
42369: ARRAY
42370: PPUSH
42371: LD_INT 34
42373: PUSH
42374: LD_INT 31
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 58
42383: PUSH
42384: EMPTY
42385: LIST
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PPUSH
42391: CALL_OW 72
42395: PUSH
42396: LD_INT 1
42398: ARRAY
42399: PPUSH
42400: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42404: LD_VAR 0 3
42408: PPUSH
42409: CALL_OW 310
42413: NOT
42414: PUSH
42415: LD_VAR 0 3
42419: PPUSH
42420: CALL_OW 310
42424: PPUSH
42425: CALL_OW 266
42429: PUSH
42430: LD_INT 36
42432: NONEQUAL
42433: PUSH
42434: LD_VAR 0 3
42438: PPUSH
42439: CALL 84463 0 1
42443: NOT
42444: AND
42445: OR
42446: IFFALSE 42582
// begin if IsInUnit ( j ) then
42448: LD_VAR 0 3
42452: PPUSH
42453: CALL_OW 310
42457: IFFALSE 42468
// ComExitBuilding ( j ) ;
42459: LD_VAR 0 3
42463: PPUSH
42464: CALL_OW 122
// ct := 0 ;
42468: LD_ADDR_VAR 0 8
42472: PUSH
42473: LD_INT 0
42475: ST_TO_ADDR
// for k in x do
42476: LD_ADDR_VAR 0 4
42480: PUSH
42481: LD_VAR 0 11
42485: PUSH
42486: FOR_IN
42487: IFFALSE 42560
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42489: LD_VAR 0 4
42493: PPUSH
42494: CALL_OW 264
42498: PUSH
42499: LD_INT 31
42501: EQUAL
42502: PUSH
42503: LD_VAR 0 4
42507: PPUSH
42508: CALL_OW 311
42512: NOT
42513: AND
42514: PUSH
42515: LD_VAR 0 4
42519: PPUSH
42520: CALL_OW 266
42524: PUSH
42525: LD_INT 36
42527: EQUAL
42528: PUSH
42529: LD_VAR 0 4
42533: PPUSH
42534: CALL_OW 313
42538: PUSH
42539: LD_INT 3
42541: LESS
42542: AND
42543: OR
42544: IFFALSE 42558
// begin ct := k ;
42546: LD_ADDR_VAR 0 8
42550: PUSH
42551: LD_VAR 0 4
42555: ST_TO_ADDR
// break ;
42556: GO 42560
// end ;
42558: GO 42486
42560: POP
42561: POP
// if ct then
42562: LD_VAR 0 8
42566: IFFALSE 42582
// ComEnterUnit ( j , ct ) ;
42568: LD_VAR 0 3
42572: PPUSH
42573: LD_VAR 0 8
42577: PPUSH
42578: CALL_OW 120
// end ; end ;
42582: GO 42217
42584: POP
42585: POP
// places := 0 ;
42586: LD_ADDR_VAR 0 5
42590: PUSH
42591: LD_INT 0
42593: ST_TO_ADDR
// for j = 1 to x do
42594: LD_ADDR_VAR 0 3
42598: PUSH
42599: DOUBLE
42600: LD_INT 1
42602: DEC
42603: ST_TO_ADDR
42604: LD_VAR 0 11
42608: PUSH
42609: FOR_TO
42610: IFFALSE 42686
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42612: LD_VAR 0 11
42616: PUSH
42617: LD_VAR 0 3
42621: ARRAY
42622: PPUSH
42623: CALL_OW 264
42627: PUSH
42628: LD_INT 31
42630: EQUAL
42631: IFFALSE 42649
// places := places + 1 else
42633: LD_ADDR_VAR 0 5
42637: PUSH
42638: LD_VAR 0 5
42642: PUSH
42643: LD_INT 1
42645: PLUS
42646: ST_TO_ADDR
42647: GO 42684
// if GetBType ( x [ j ] ) = b_control_tower then
42649: LD_VAR 0 11
42653: PUSH
42654: LD_VAR 0 3
42658: ARRAY
42659: PPUSH
42660: CALL_OW 266
42664: PUSH
42665: LD_INT 36
42667: EQUAL
42668: IFFALSE 42684
// places := places + 3 ;
42670: LD_ADDR_VAR 0 5
42674: PUSH
42675: LD_VAR 0 5
42679: PUSH
42680: LD_INT 3
42682: PLUS
42683: ST_TO_ADDR
42684: GO 42609
42686: POP
42687: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42688: LD_VAR 0 5
42692: PUSH
42693: LD_INT 0
42695: EQUAL
42696: PUSH
42697: LD_VAR 0 5
42701: PUSH
42702: LD_EXP 130
42706: PUSH
42707: LD_VAR 0 2
42711: ARRAY
42712: LESSEQUAL
42713: OR
42714: IFFALSE 42718
// continue ;
42716: GO 41968
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42718: LD_ADDR_VAR 0 6
42722: PUSH
42723: LD_EXP 90
42727: PUSH
42728: LD_VAR 0 2
42732: ARRAY
42733: PPUSH
42734: LD_INT 25
42736: PUSH
42737: LD_INT 3
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PPUSH
42744: CALL_OW 72
42748: PUSH
42749: LD_EXP 130
42753: PUSH
42754: LD_VAR 0 2
42758: ARRAY
42759: DIFF
42760: PPUSH
42761: LD_INT 3
42763: PPUSH
42764: CALL 85363 0 2
42768: ST_TO_ADDR
// for j in tmp do
42769: LD_ADDR_VAR 0 3
42773: PUSH
42774: LD_VAR 0 6
42778: PUSH
42779: FOR_IN
42780: IFFALSE 42815
// if GetTag ( j ) > 0 then
42782: LD_VAR 0 3
42786: PPUSH
42787: CALL_OW 110
42791: PUSH
42792: LD_INT 0
42794: GREATER
42795: IFFALSE 42813
// tmp := tmp diff j ;
42797: LD_ADDR_VAR 0 6
42801: PUSH
42802: LD_VAR 0 6
42806: PUSH
42807: LD_VAR 0 3
42811: DIFF
42812: ST_TO_ADDR
42813: GO 42779
42815: POP
42816: POP
// if not tmp then
42817: LD_VAR 0 6
42821: NOT
42822: IFFALSE 42826
// continue ;
42824: GO 41968
// if places then
42826: LD_VAR 0 5
42830: IFFALSE 42889
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42832: LD_ADDR_EXP 130
42836: PUSH
42837: LD_EXP 130
42841: PPUSH
42842: LD_VAR 0 2
42846: PPUSH
42847: LD_EXP 130
42851: PUSH
42852: LD_VAR 0 2
42856: ARRAY
42857: PUSH
42858: LD_VAR 0 6
42862: PUSH
42863: LD_INT 1
42865: ARRAY
42866: UNION
42867: PPUSH
42868: CALL_OW 1
42872: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42873: LD_VAR 0 6
42877: PUSH
42878: LD_INT 1
42880: ARRAY
42881: PPUSH
42882: LD_INT 126
42884: PPUSH
42885: CALL_OW 109
// end ; end ;
42889: GO 41968
42891: POP
42892: POP
// end ;
42893: LD_VAR 0 1
42897: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42898: LD_INT 0
42900: PPUSH
42901: PPUSH
42902: PPUSH
42903: PPUSH
42904: PPUSH
42905: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42906: LD_VAR 0 1
42910: NOT
42911: PUSH
42912: LD_VAR 0 2
42916: NOT
42917: OR
42918: PUSH
42919: LD_VAR 0 3
42923: NOT
42924: OR
42925: PUSH
42926: LD_VAR 0 4
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 2
42936: PUSH
42937: LD_INT 3
42939: PUSH
42940: LD_INT 4
42942: PUSH
42943: LD_INT 5
42945: PUSH
42946: LD_INT 8
42948: PUSH
42949: LD_INT 9
42951: PUSH
42952: LD_INT 15
42954: PUSH
42955: LD_INT 16
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: IN
42969: NOT
42970: OR
42971: IFFALSE 42975
// exit ;
42973: GO 43875
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42975: LD_ADDR_VAR 0 2
42979: PUSH
42980: LD_VAR 0 2
42984: PPUSH
42985: LD_INT 21
42987: PUSH
42988: LD_INT 3
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 24
42997: PUSH
42998: LD_INT 250
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PPUSH
43009: CALL_OW 72
43013: ST_TO_ADDR
// case class of 1 , 15 :
43014: LD_VAR 0 4
43018: PUSH
43019: LD_INT 1
43021: DOUBLE
43022: EQUAL
43023: IFTRUE 43033
43025: LD_INT 15
43027: DOUBLE
43028: EQUAL
43029: IFTRUE 43033
43031: GO 43118
43033: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43034: LD_ADDR_VAR 0 8
43038: PUSH
43039: LD_VAR 0 2
43043: PPUSH
43044: LD_INT 2
43046: PUSH
43047: LD_INT 30
43049: PUSH
43050: LD_INT 32
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 30
43059: PUSH
43060: LD_INT 31
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: LIST
43071: PPUSH
43072: CALL_OW 72
43076: PUSH
43077: LD_VAR 0 2
43081: PPUSH
43082: LD_INT 2
43084: PUSH
43085: LD_INT 30
43087: PUSH
43088: LD_INT 4
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 30
43097: PUSH
43098: LD_INT 5
43100: PUSH
43101: EMPTY
43102: LIST
43103: LIST
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: LIST
43109: PPUSH
43110: CALL_OW 72
43114: ADD
43115: ST_TO_ADDR
43116: GO 43364
43118: LD_INT 2
43120: DOUBLE
43121: EQUAL
43122: IFTRUE 43132
43124: LD_INT 16
43126: DOUBLE
43127: EQUAL
43128: IFTRUE 43132
43130: GO 43178
43132: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43133: LD_ADDR_VAR 0 8
43137: PUSH
43138: LD_VAR 0 2
43142: PPUSH
43143: LD_INT 2
43145: PUSH
43146: LD_INT 30
43148: PUSH
43149: LD_INT 0
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 30
43158: PUSH
43159: LD_INT 1
43161: PUSH
43162: EMPTY
43163: LIST
43164: LIST
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: LIST
43170: PPUSH
43171: CALL_OW 72
43175: ST_TO_ADDR
43176: GO 43364
43178: LD_INT 3
43180: DOUBLE
43181: EQUAL
43182: IFTRUE 43186
43184: GO 43232
43186: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43187: LD_ADDR_VAR 0 8
43191: PUSH
43192: LD_VAR 0 2
43196: PPUSH
43197: LD_INT 2
43199: PUSH
43200: LD_INT 30
43202: PUSH
43203: LD_INT 2
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 30
43212: PUSH
43213: LD_INT 3
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: LIST
43224: PPUSH
43225: CALL_OW 72
43229: ST_TO_ADDR
43230: GO 43364
43232: LD_INT 4
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43240
43238: GO 43297
43240: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43241: LD_ADDR_VAR 0 8
43245: PUSH
43246: LD_VAR 0 2
43250: PPUSH
43251: LD_INT 2
43253: PUSH
43254: LD_INT 30
43256: PUSH
43257: LD_INT 6
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: PUSH
43264: LD_INT 30
43266: PUSH
43267: LD_INT 7
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: LD_INT 30
43276: PUSH
43277: LD_INT 8
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: LIST
43288: LIST
43289: PPUSH
43290: CALL_OW 72
43294: ST_TO_ADDR
43295: GO 43364
43297: LD_INT 5
43299: DOUBLE
43300: EQUAL
43301: IFTRUE 43317
43303: LD_INT 8
43305: DOUBLE
43306: EQUAL
43307: IFTRUE 43317
43309: LD_INT 9
43311: DOUBLE
43312: EQUAL
43313: IFTRUE 43317
43315: GO 43363
43317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43318: LD_ADDR_VAR 0 8
43322: PUSH
43323: LD_VAR 0 2
43327: PPUSH
43328: LD_INT 2
43330: PUSH
43331: LD_INT 30
43333: PUSH
43334: LD_INT 4
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 30
43343: PUSH
43344: LD_INT 5
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: LIST
43355: PPUSH
43356: CALL_OW 72
43360: ST_TO_ADDR
43361: GO 43364
43363: POP
// if not tmp then
43364: LD_VAR 0 8
43368: NOT
43369: IFFALSE 43373
// exit ;
43371: GO 43875
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43373: LD_VAR 0 4
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: LD_INT 15
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: IN
43388: PUSH
43389: LD_EXP 99
43393: PUSH
43394: LD_VAR 0 1
43398: ARRAY
43399: AND
43400: IFFALSE 43556
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43402: LD_ADDR_VAR 0 9
43406: PUSH
43407: LD_EXP 99
43411: PUSH
43412: LD_VAR 0 1
43416: ARRAY
43417: PUSH
43418: LD_INT 1
43420: ARRAY
43421: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43422: LD_VAR 0 9
43426: PUSH
43427: LD_EXP 100
43431: PUSH
43432: LD_VAR 0 1
43436: ARRAY
43437: IN
43438: NOT
43439: IFFALSE 43554
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43441: LD_ADDR_EXP 100
43445: PUSH
43446: LD_EXP 100
43450: PPUSH
43451: LD_VAR 0 1
43455: PUSH
43456: LD_EXP 100
43460: PUSH
43461: LD_VAR 0 1
43465: ARRAY
43466: PUSH
43467: LD_INT 1
43469: PLUS
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PPUSH
43475: LD_VAR 0 9
43479: PPUSH
43480: CALL 55814 0 3
43484: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43485: LD_ADDR_EXP 99
43489: PUSH
43490: LD_EXP 99
43494: PPUSH
43495: LD_VAR 0 1
43499: PPUSH
43500: LD_EXP 99
43504: PUSH
43505: LD_VAR 0 1
43509: ARRAY
43510: PUSH
43511: LD_VAR 0 9
43515: DIFF
43516: PPUSH
43517: CALL_OW 1
43521: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43522: LD_VAR 0 3
43526: PPUSH
43527: LD_EXP 100
43531: PUSH
43532: LD_VAR 0 1
43536: ARRAY
43537: PUSH
43538: LD_EXP 100
43542: PUSH
43543: LD_VAR 0 1
43547: ARRAY
43548: ARRAY
43549: PPUSH
43550: CALL_OW 120
// end ; exit ;
43554: GO 43875
// end ; if tmp > 1 then
43556: LD_VAR 0 8
43560: PUSH
43561: LD_INT 1
43563: GREATER
43564: IFFALSE 43668
// for i = 2 to tmp do
43566: LD_ADDR_VAR 0 6
43570: PUSH
43571: DOUBLE
43572: LD_INT 2
43574: DEC
43575: ST_TO_ADDR
43576: LD_VAR 0 8
43580: PUSH
43581: FOR_TO
43582: IFFALSE 43666
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43584: LD_VAR 0 8
43588: PUSH
43589: LD_VAR 0 6
43593: ARRAY
43594: PPUSH
43595: CALL_OW 461
43599: PUSH
43600: LD_INT 6
43602: EQUAL
43603: IFFALSE 43664
// begin x := tmp [ i ] ;
43605: LD_ADDR_VAR 0 9
43609: PUSH
43610: LD_VAR 0 8
43614: PUSH
43615: LD_VAR 0 6
43619: ARRAY
43620: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43621: LD_ADDR_VAR 0 8
43625: PUSH
43626: LD_VAR 0 8
43630: PPUSH
43631: LD_VAR 0 6
43635: PPUSH
43636: CALL_OW 3
43640: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43641: LD_ADDR_VAR 0 8
43645: PUSH
43646: LD_VAR 0 8
43650: PPUSH
43651: LD_INT 1
43653: PPUSH
43654: LD_VAR 0 9
43658: PPUSH
43659: CALL_OW 2
43663: ST_TO_ADDR
// end ;
43664: GO 43581
43666: POP
43667: POP
// for i in tmp do
43668: LD_ADDR_VAR 0 6
43672: PUSH
43673: LD_VAR 0 8
43677: PUSH
43678: FOR_IN
43679: IFFALSE 43748
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43681: LD_VAR 0 6
43685: PPUSH
43686: CALL_OW 313
43690: PUSH
43691: LD_INT 6
43693: LESS
43694: PUSH
43695: LD_VAR 0 6
43699: PPUSH
43700: CALL_OW 266
43704: PUSH
43705: LD_INT 31
43707: PUSH
43708: LD_INT 32
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: IN
43715: NOT
43716: AND
43717: PUSH
43718: LD_VAR 0 6
43722: PPUSH
43723: CALL_OW 313
43727: PUSH
43728: LD_INT 0
43730: EQUAL
43731: OR
43732: IFFALSE 43746
// begin j := i ;
43734: LD_ADDR_VAR 0 7
43738: PUSH
43739: LD_VAR 0 6
43743: ST_TO_ADDR
// break ;
43744: GO 43748
// end ; end ;
43746: GO 43678
43748: POP
43749: POP
// if j then
43750: LD_VAR 0 7
43754: IFFALSE 43772
// ComEnterUnit ( unit , j ) else
43756: LD_VAR 0 3
43760: PPUSH
43761: LD_VAR 0 7
43765: PPUSH
43766: CALL_OW 120
43770: GO 43875
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43772: LD_ADDR_VAR 0 10
43776: PUSH
43777: LD_VAR 0 2
43781: PPUSH
43782: LD_INT 2
43784: PUSH
43785: LD_INT 30
43787: PUSH
43788: LD_INT 0
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 30
43797: PUSH
43798: LD_INT 1
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: LIST
43809: PPUSH
43810: CALL_OW 72
43814: ST_TO_ADDR
// if depot then
43815: LD_VAR 0 10
43819: IFFALSE 43875
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43821: LD_ADDR_VAR 0 10
43825: PUSH
43826: LD_VAR 0 10
43830: PPUSH
43831: LD_VAR 0 3
43835: PPUSH
43836: CALL_OW 74
43840: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43841: LD_VAR 0 3
43845: PPUSH
43846: LD_VAR 0 10
43850: PPUSH
43851: CALL_OW 296
43855: PUSH
43856: LD_INT 10
43858: GREATER
43859: IFFALSE 43875
// ComStandNearbyBuilding ( unit , depot ) ;
43861: LD_VAR 0 3
43865: PPUSH
43866: LD_VAR 0 10
43870: PPUSH
43871: CALL 52428 0 2
// end ; end ; end ;
43875: LD_VAR 0 5
43879: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43880: LD_INT 0
43882: PPUSH
43883: PPUSH
43884: PPUSH
43885: PPUSH
// if not mc_bases then
43886: LD_EXP 90
43890: NOT
43891: IFFALSE 43895
// exit ;
43893: GO 44134
// for i = 1 to mc_bases do
43895: LD_ADDR_VAR 0 2
43899: PUSH
43900: DOUBLE
43901: LD_INT 1
43903: DEC
43904: ST_TO_ADDR
43905: LD_EXP 90
43909: PUSH
43910: FOR_TO
43911: IFFALSE 44132
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43913: LD_ADDR_VAR 0 4
43917: PUSH
43918: LD_EXP 90
43922: PUSH
43923: LD_VAR 0 2
43927: ARRAY
43928: PPUSH
43929: LD_INT 21
43931: PUSH
43932: LD_INT 1
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PPUSH
43939: CALL_OW 72
43943: PUSH
43944: LD_EXP 119
43948: PUSH
43949: LD_VAR 0 2
43953: ARRAY
43954: UNION
43955: ST_TO_ADDR
// if not tmp then
43956: LD_VAR 0 4
43960: NOT
43961: IFFALSE 43965
// continue ;
43963: GO 43910
// for j in tmp do
43965: LD_ADDR_VAR 0 3
43969: PUSH
43970: LD_VAR 0 4
43974: PUSH
43975: FOR_IN
43976: IFFALSE 44128
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43978: LD_VAR 0 3
43982: PPUSH
43983: CALL_OW 110
43987: NOT
43988: PUSH
43989: LD_VAR 0 3
43993: PPUSH
43994: CALL_OW 314
43998: NOT
43999: AND
44000: PUSH
44001: LD_VAR 0 3
44005: PPUSH
44006: CALL_OW 311
44010: NOT
44011: AND
44012: PUSH
44013: LD_VAR 0 3
44017: PPUSH
44018: CALL_OW 310
44022: NOT
44023: AND
44024: PUSH
44025: LD_VAR 0 3
44029: PUSH
44030: LD_EXP 93
44034: PUSH
44035: LD_VAR 0 2
44039: ARRAY
44040: PUSH
44041: LD_INT 1
44043: ARRAY
44044: IN
44045: NOT
44046: AND
44047: PUSH
44048: LD_VAR 0 3
44052: PUSH
44053: LD_EXP 93
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: PUSH
44064: LD_INT 2
44066: ARRAY
44067: IN
44068: NOT
44069: AND
44070: PUSH
44071: LD_VAR 0 3
44075: PUSH
44076: LD_EXP 102
44080: PUSH
44081: LD_VAR 0 2
44085: ARRAY
44086: IN
44087: NOT
44088: AND
44089: IFFALSE 44126
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44091: LD_VAR 0 2
44095: PPUSH
44096: LD_EXP 90
44100: PUSH
44101: LD_VAR 0 2
44105: ARRAY
44106: PPUSH
44107: LD_VAR 0 3
44111: PPUSH
44112: LD_VAR 0 3
44116: PPUSH
44117: CALL_OW 257
44121: PPUSH
44122: CALL 42898 0 4
// end ;
44126: GO 43975
44128: POP
44129: POP
// end ;
44130: GO 43910
44132: POP
44133: POP
// end ;
44134: LD_VAR 0 1
44138: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44139: LD_INT 0
44141: PPUSH
44142: PPUSH
44143: PPUSH
44144: PPUSH
44145: PPUSH
44146: PPUSH
// if not mc_bases [ base ] then
44147: LD_EXP 90
44151: PUSH
44152: LD_VAR 0 1
44156: ARRAY
44157: NOT
44158: IFFALSE 44162
// exit ;
44160: GO 44344
// tmp := [ ] ;
44162: LD_ADDR_VAR 0 6
44166: PUSH
44167: EMPTY
44168: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44169: LD_ADDR_VAR 0 7
44173: PUSH
44174: LD_VAR 0 3
44178: PPUSH
44179: LD_INT 0
44181: PPUSH
44182: CALL_OW 517
44186: ST_TO_ADDR
// if not list then
44187: LD_VAR 0 7
44191: NOT
44192: IFFALSE 44196
// exit ;
44194: GO 44344
// for i = 1 to amount do
44196: LD_ADDR_VAR 0 5
44200: PUSH
44201: DOUBLE
44202: LD_INT 1
44204: DEC
44205: ST_TO_ADDR
44206: LD_VAR 0 2
44210: PUSH
44211: FOR_TO
44212: IFFALSE 44292
// begin x := rand ( 1 , list [ 1 ] ) ;
44214: LD_ADDR_VAR 0 8
44218: PUSH
44219: LD_INT 1
44221: PPUSH
44222: LD_VAR 0 7
44226: PUSH
44227: LD_INT 1
44229: ARRAY
44230: PPUSH
44231: CALL_OW 12
44235: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44236: LD_ADDR_VAR 0 6
44240: PUSH
44241: LD_VAR 0 6
44245: PPUSH
44246: LD_VAR 0 5
44250: PPUSH
44251: LD_VAR 0 7
44255: PUSH
44256: LD_INT 1
44258: ARRAY
44259: PUSH
44260: LD_VAR 0 8
44264: ARRAY
44265: PUSH
44266: LD_VAR 0 7
44270: PUSH
44271: LD_INT 2
44273: ARRAY
44274: PUSH
44275: LD_VAR 0 8
44279: ARRAY
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PPUSH
44285: CALL_OW 1
44289: ST_TO_ADDR
// end ;
44290: GO 44211
44292: POP
44293: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44294: LD_ADDR_EXP 103
44298: PUSH
44299: LD_EXP 103
44303: PPUSH
44304: LD_VAR 0 1
44308: PPUSH
44309: LD_VAR 0 6
44313: PPUSH
44314: CALL_OW 1
44318: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44319: LD_ADDR_EXP 105
44323: PUSH
44324: LD_EXP 105
44328: PPUSH
44329: LD_VAR 0 1
44333: PPUSH
44334: LD_VAR 0 3
44338: PPUSH
44339: CALL_OW 1
44343: ST_TO_ADDR
// end ;
44344: LD_VAR 0 4
44348: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44349: LD_INT 0
44351: PPUSH
// if not mc_bases [ base ] then
44352: LD_EXP 90
44356: PUSH
44357: LD_VAR 0 1
44361: ARRAY
44362: NOT
44363: IFFALSE 44367
// exit ;
44365: GO 44392
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44367: LD_ADDR_EXP 95
44371: PUSH
44372: LD_EXP 95
44376: PPUSH
44377: LD_VAR 0 1
44381: PPUSH
44382: LD_VAR 0 2
44386: PPUSH
44387: CALL_OW 1
44391: ST_TO_ADDR
// end ;
44392: LD_VAR 0 3
44396: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44397: LD_INT 0
44399: PPUSH
// if not mc_bases [ base ] then
44400: LD_EXP 90
44404: PUSH
44405: LD_VAR 0 1
44409: ARRAY
44410: NOT
44411: IFFALSE 44415
// exit ;
44413: GO 44452
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44415: LD_ADDR_EXP 95
44419: PUSH
44420: LD_EXP 95
44424: PPUSH
44425: LD_VAR 0 1
44429: PPUSH
44430: LD_EXP 95
44434: PUSH
44435: LD_VAR 0 1
44439: ARRAY
44440: PUSH
44441: LD_VAR 0 2
44445: UNION
44446: PPUSH
44447: CALL_OW 1
44451: ST_TO_ADDR
// end ;
44452: LD_VAR 0 3
44456: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44457: LD_INT 0
44459: PPUSH
// if not mc_bases [ base ] then
44460: LD_EXP 90
44464: PUSH
44465: LD_VAR 0 1
44469: ARRAY
44470: NOT
44471: IFFALSE 44475
// exit ;
44473: GO 44500
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44475: LD_ADDR_EXP 111
44479: PUSH
44480: LD_EXP 111
44484: PPUSH
44485: LD_VAR 0 1
44489: PPUSH
44490: LD_VAR 0 2
44494: PPUSH
44495: CALL_OW 1
44499: ST_TO_ADDR
// end ;
44500: LD_VAR 0 3
44504: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44505: LD_INT 0
44507: PPUSH
// if not mc_bases [ base ] then
44508: LD_EXP 90
44512: PUSH
44513: LD_VAR 0 1
44517: ARRAY
44518: NOT
44519: IFFALSE 44523
// exit ;
44521: GO 44560
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44523: LD_ADDR_EXP 111
44527: PUSH
44528: LD_EXP 111
44532: PPUSH
44533: LD_VAR 0 1
44537: PPUSH
44538: LD_EXP 111
44542: PUSH
44543: LD_VAR 0 1
44547: ARRAY
44548: PUSH
44549: LD_VAR 0 2
44553: ADD
44554: PPUSH
44555: CALL_OW 1
44559: ST_TO_ADDR
// end ;
44560: LD_VAR 0 3
44564: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44565: LD_INT 0
44567: PPUSH
// if not mc_bases [ base ] then
44568: LD_EXP 90
44572: PUSH
44573: LD_VAR 0 1
44577: ARRAY
44578: NOT
44579: IFFALSE 44583
// exit ;
44581: GO 44637
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44583: LD_ADDR_EXP 112
44587: PUSH
44588: LD_EXP 112
44592: PPUSH
44593: LD_VAR 0 1
44597: PPUSH
44598: LD_VAR 0 2
44602: PPUSH
44603: CALL_OW 1
44607: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44608: LD_ADDR_EXP 101
44612: PUSH
44613: LD_EXP 101
44617: PPUSH
44618: LD_VAR 0 1
44622: PPUSH
44623: LD_VAR 0 2
44627: PUSH
44628: LD_INT 0
44630: PLUS
44631: PPUSH
44632: CALL_OW 1
44636: ST_TO_ADDR
// end ;
44637: LD_VAR 0 3
44641: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44642: LD_INT 0
44644: PPUSH
// if not mc_bases [ base ] then
44645: LD_EXP 90
44649: PUSH
44650: LD_VAR 0 1
44654: ARRAY
44655: NOT
44656: IFFALSE 44660
// exit ;
44658: GO 44685
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44660: LD_ADDR_EXP 101
44664: PUSH
44665: LD_EXP 101
44669: PPUSH
44670: LD_VAR 0 1
44674: PPUSH
44675: LD_VAR 0 2
44679: PPUSH
44680: CALL_OW 1
44684: ST_TO_ADDR
// end ;
44685: LD_VAR 0 3
44689: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44690: LD_INT 0
44692: PPUSH
44693: PPUSH
44694: PPUSH
44695: PPUSH
// if not mc_bases [ base ] then
44696: LD_EXP 90
44700: PUSH
44701: LD_VAR 0 1
44705: ARRAY
44706: NOT
44707: IFFALSE 44711
// exit ;
44709: GO 44776
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44711: LD_ADDR_EXP 110
44715: PUSH
44716: LD_EXP 110
44720: PPUSH
44721: LD_VAR 0 1
44725: PUSH
44726: LD_EXP 110
44730: PUSH
44731: LD_VAR 0 1
44735: ARRAY
44736: PUSH
44737: LD_INT 1
44739: PLUS
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PPUSH
44745: LD_VAR 0 1
44749: PUSH
44750: LD_VAR 0 2
44754: PUSH
44755: LD_VAR 0 3
44759: PUSH
44760: LD_VAR 0 4
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: PPUSH
44771: CALL 55814 0 3
44775: ST_TO_ADDR
// end ;
44776: LD_VAR 0 5
44780: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44781: LD_INT 0
44783: PPUSH
// if not mc_bases [ base ] then
44784: LD_EXP 90
44788: PUSH
44789: LD_VAR 0 1
44793: ARRAY
44794: NOT
44795: IFFALSE 44799
// exit ;
44797: GO 44824
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44799: LD_ADDR_EXP 127
44803: PUSH
44804: LD_EXP 127
44808: PPUSH
44809: LD_VAR 0 1
44813: PPUSH
44814: LD_VAR 0 2
44818: PPUSH
44819: CALL_OW 1
44823: ST_TO_ADDR
// end ;
44824: LD_VAR 0 3
44828: RET
// export function MC_GetMinesField ( base ) ; begin
44829: LD_INT 0
44831: PPUSH
// result := mc_mines [ base ] ;
44832: LD_ADDR_VAR 0 2
44836: PUSH
44837: LD_EXP 103
44841: PUSH
44842: LD_VAR 0 1
44846: ARRAY
44847: ST_TO_ADDR
// end ;
44848: LD_VAR 0 2
44852: RET
// export function MC_GetProduceList ( base ) ; begin
44853: LD_INT 0
44855: PPUSH
// result := mc_produce [ base ] ;
44856: LD_ADDR_VAR 0 2
44860: PUSH
44861: LD_EXP 111
44865: PUSH
44866: LD_VAR 0 1
44870: ARRAY
44871: ST_TO_ADDR
// end ;
44872: LD_VAR 0 2
44876: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44877: LD_INT 0
44879: PPUSH
44880: PPUSH
// if not mc_bases then
44881: LD_EXP 90
44885: NOT
44886: IFFALSE 44890
// exit ;
44888: GO 44955
// if mc_bases [ base ] then
44890: LD_EXP 90
44894: PUSH
44895: LD_VAR 0 1
44899: ARRAY
44900: IFFALSE 44955
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44902: LD_ADDR_VAR 0 3
44906: PUSH
44907: LD_EXP 90
44911: PUSH
44912: LD_VAR 0 1
44916: ARRAY
44917: PPUSH
44918: LD_INT 30
44920: PUSH
44921: LD_VAR 0 2
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PPUSH
44930: CALL_OW 72
44934: ST_TO_ADDR
// if result then
44935: LD_VAR 0 3
44939: IFFALSE 44955
// result := result [ 1 ] ;
44941: LD_ADDR_VAR 0 3
44945: PUSH
44946: LD_VAR 0 3
44950: PUSH
44951: LD_INT 1
44953: ARRAY
44954: ST_TO_ADDR
// end ; end ;
44955: LD_VAR 0 3
44959: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44960: LD_INT 0
44962: PPUSH
44963: PPUSH
// if not mc_bases then
44964: LD_EXP 90
44968: NOT
44969: IFFALSE 44973
// exit ;
44971: GO 45018
// if mc_bases [ base ] then
44973: LD_EXP 90
44977: PUSH
44978: LD_VAR 0 1
44982: ARRAY
44983: IFFALSE 45018
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44985: LD_ADDR_VAR 0 3
44989: PUSH
44990: LD_EXP 90
44994: PUSH
44995: LD_VAR 0 1
44999: ARRAY
45000: PPUSH
45001: LD_INT 30
45003: PUSH
45004: LD_VAR 0 2
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PPUSH
45013: CALL_OW 72
45017: ST_TO_ADDR
// end ;
45018: LD_VAR 0 3
45022: RET
// export function MC_SetTame ( base , area ) ; begin
45023: LD_INT 0
45025: PPUSH
// if not mc_bases or not base then
45026: LD_EXP 90
45030: NOT
45031: PUSH
45032: LD_VAR 0 1
45036: NOT
45037: OR
45038: IFFALSE 45042
// exit ;
45040: GO 45067
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45042: LD_ADDR_EXP 118
45046: PUSH
45047: LD_EXP 118
45051: PPUSH
45052: LD_VAR 0 1
45056: PPUSH
45057: LD_VAR 0 2
45061: PPUSH
45062: CALL_OW 1
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 3
45071: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45072: LD_INT 0
45074: PPUSH
45075: PPUSH
// if not mc_bases or not base then
45076: LD_EXP 90
45080: NOT
45081: PUSH
45082: LD_VAR 0 1
45086: NOT
45087: OR
45088: IFFALSE 45092
// exit ;
45090: GO 45194
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45092: LD_ADDR_VAR 0 4
45096: PUSH
45097: LD_EXP 90
45101: PUSH
45102: LD_VAR 0 1
45106: ARRAY
45107: PPUSH
45108: LD_INT 30
45110: PUSH
45111: LD_VAR 0 2
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PPUSH
45120: CALL_OW 72
45124: ST_TO_ADDR
// if not tmp then
45125: LD_VAR 0 4
45129: NOT
45130: IFFALSE 45134
// exit ;
45132: GO 45194
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45134: LD_ADDR_EXP 122
45138: PUSH
45139: LD_EXP 122
45143: PPUSH
45144: LD_VAR 0 1
45148: PPUSH
45149: LD_EXP 122
45153: PUSH
45154: LD_VAR 0 1
45158: ARRAY
45159: PPUSH
45160: LD_EXP 122
45164: PUSH
45165: LD_VAR 0 1
45169: ARRAY
45170: PUSH
45171: LD_INT 1
45173: PLUS
45174: PPUSH
45175: LD_VAR 0 4
45179: PUSH
45180: LD_INT 1
45182: ARRAY
45183: PPUSH
45184: CALL_OW 2
45188: PPUSH
45189: CALL_OW 1
45193: ST_TO_ADDR
// end ;
45194: LD_VAR 0 3
45198: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45199: LD_INT 0
45201: PPUSH
45202: PPUSH
// if not mc_bases or not base or not kinds then
45203: LD_EXP 90
45207: NOT
45208: PUSH
45209: LD_VAR 0 1
45213: NOT
45214: OR
45215: PUSH
45216: LD_VAR 0 2
45220: NOT
45221: OR
45222: IFFALSE 45226
// exit ;
45224: GO 45287
// for i in kinds do
45226: LD_ADDR_VAR 0 4
45230: PUSH
45231: LD_VAR 0 2
45235: PUSH
45236: FOR_IN
45237: IFFALSE 45285
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45239: LD_ADDR_EXP 124
45243: PUSH
45244: LD_EXP 124
45248: PPUSH
45249: LD_VAR 0 1
45253: PUSH
45254: LD_EXP 124
45258: PUSH
45259: LD_VAR 0 1
45263: ARRAY
45264: PUSH
45265: LD_INT 1
45267: PLUS
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PPUSH
45273: LD_VAR 0 4
45277: PPUSH
45278: CALL 55814 0 3
45282: ST_TO_ADDR
45283: GO 45236
45285: POP
45286: POP
// end ;
45287: LD_VAR 0 3
45291: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45292: LD_INT 0
45294: PPUSH
// if not mc_bases or not base or not areas then
45295: LD_EXP 90
45299: NOT
45300: PUSH
45301: LD_VAR 0 1
45305: NOT
45306: OR
45307: PUSH
45308: LD_VAR 0 2
45312: NOT
45313: OR
45314: IFFALSE 45318
// exit ;
45316: GO 45343
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45318: LD_ADDR_EXP 108
45322: PUSH
45323: LD_EXP 108
45327: PPUSH
45328: LD_VAR 0 1
45332: PPUSH
45333: LD_VAR 0 2
45337: PPUSH
45338: CALL_OW 1
45342: ST_TO_ADDR
// end ;
45343: LD_VAR 0 3
45347: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45348: LD_INT 0
45350: PPUSH
// if not mc_bases or not base or not teleports_exit then
45351: LD_EXP 90
45355: NOT
45356: PUSH
45357: LD_VAR 0 1
45361: NOT
45362: OR
45363: PUSH
45364: LD_VAR 0 2
45368: NOT
45369: OR
45370: IFFALSE 45374
// exit ;
45372: GO 45399
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45374: LD_ADDR_EXP 125
45378: PUSH
45379: LD_EXP 125
45383: PPUSH
45384: LD_VAR 0 1
45388: PPUSH
45389: LD_VAR 0 2
45393: PPUSH
45394: CALL_OW 1
45398: ST_TO_ADDR
// end ;
45399: LD_VAR 0 3
45403: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45404: LD_INT 0
45406: PPUSH
45407: PPUSH
45408: PPUSH
// if not mc_bases or not base or not ext_list then
45409: LD_EXP 90
45413: NOT
45414: PUSH
45415: LD_VAR 0 1
45419: NOT
45420: OR
45421: PUSH
45422: LD_VAR 0 5
45426: NOT
45427: OR
45428: IFFALSE 45432
// exit ;
45430: GO 45605
// tmp := GetFacExtXYD ( x , y , d ) ;
45432: LD_ADDR_VAR 0 8
45436: PUSH
45437: LD_VAR 0 2
45441: PPUSH
45442: LD_VAR 0 3
45446: PPUSH
45447: LD_VAR 0 4
45451: PPUSH
45452: CALL 84493 0 3
45456: ST_TO_ADDR
// if not tmp then
45457: LD_VAR 0 8
45461: NOT
45462: IFFALSE 45466
// exit ;
45464: GO 45605
// for i in tmp do
45466: LD_ADDR_VAR 0 7
45470: PUSH
45471: LD_VAR 0 8
45475: PUSH
45476: FOR_IN
45477: IFFALSE 45603
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45479: LD_ADDR_EXP 95
45483: PUSH
45484: LD_EXP 95
45488: PPUSH
45489: LD_VAR 0 1
45493: PPUSH
45494: LD_EXP 95
45498: PUSH
45499: LD_VAR 0 1
45503: ARRAY
45504: PPUSH
45505: LD_EXP 95
45509: PUSH
45510: LD_VAR 0 1
45514: ARRAY
45515: PUSH
45516: LD_INT 1
45518: PLUS
45519: PPUSH
45520: LD_VAR 0 5
45524: PUSH
45525: LD_INT 1
45527: ARRAY
45528: PUSH
45529: LD_VAR 0 7
45533: PUSH
45534: LD_INT 1
45536: ARRAY
45537: PUSH
45538: LD_VAR 0 7
45542: PUSH
45543: LD_INT 2
45545: ARRAY
45546: PUSH
45547: LD_VAR 0 7
45551: PUSH
45552: LD_INT 3
45554: ARRAY
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: PPUSH
45562: CALL_OW 2
45566: PPUSH
45567: CALL_OW 1
45571: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45572: LD_ADDR_VAR 0 5
45576: PUSH
45577: LD_VAR 0 5
45581: PPUSH
45582: LD_INT 1
45584: PPUSH
45585: CALL_OW 3
45589: ST_TO_ADDR
// if not ext_list then
45590: LD_VAR 0 5
45594: NOT
45595: IFFALSE 45601
// exit ;
45597: POP
45598: POP
45599: GO 45605
// end ;
45601: GO 45476
45603: POP
45604: POP
// end ;
45605: LD_VAR 0 6
45609: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45610: LD_INT 0
45612: PPUSH
// if not mc_bases or not base or not weapon_list then
45613: LD_EXP 90
45617: NOT
45618: PUSH
45619: LD_VAR 0 1
45623: NOT
45624: OR
45625: PUSH
45626: LD_VAR 0 2
45630: NOT
45631: OR
45632: IFFALSE 45636
// exit ;
45634: GO 45661
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45636: LD_ADDR_EXP 129
45640: PUSH
45641: LD_EXP 129
45645: PPUSH
45646: LD_VAR 0 1
45650: PPUSH
45651: LD_VAR 0 2
45655: PPUSH
45656: CALL_OW 1
45660: ST_TO_ADDR
// end ;
45661: LD_VAR 0 3
45665: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45666: LD_INT 0
45668: PPUSH
// if not mc_bases or not base or not tech_list then
45669: LD_EXP 90
45673: NOT
45674: PUSH
45675: LD_VAR 0 1
45679: NOT
45680: OR
45681: PUSH
45682: LD_VAR 0 2
45686: NOT
45687: OR
45688: IFFALSE 45692
// exit ;
45690: GO 45717
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45692: LD_ADDR_EXP 117
45696: PUSH
45697: LD_EXP 117
45701: PPUSH
45702: LD_VAR 0 1
45706: PPUSH
45707: LD_VAR 0 2
45711: PPUSH
45712: CALL_OW 1
45716: ST_TO_ADDR
// end ;
45717: LD_VAR 0 3
45721: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45722: LD_INT 0
45724: PPUSH
// if not mc_bases or not parking_area or not base then
45725: LD_EXP 90
45729: NOT
45730: PUSH
45731: LD_VAR 0 2
45735: NOT
45736: OR
45737: PUSH
45738: LD_VAR 0 1
45742: NOT
45743: OR
45744: IFFALSE 45748
// exit ;
45746: GO 45773
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45748: LD_ADDR_EXP 114
45752: PUSH
45753: LD_EXP 114
45757: PPUSH
45758: LD_VAR 0 1
45762: PPUSH
45763: LD_VAR 0 2
45767: PPUSH
45768: CALL_OW 1
45772: ST_TO_ADDR
// end ;
45773: LD_VAR 0 3
45777: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45778: LD_INT 0
45780: PPUSH
// if not mc_bases or not base or not scan_area then
45781: LD_EXP 90
45785: NOT
45786: PUSH
45787: LD_VAR 0 1
45791: NOT
45792: OR
45793: PUSH
45794: LD_VAR 0 2
45798: NOT
45799: OR
45800: IFFALSE 45804
// exit ;
45802: GO 45829
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45804: LD_ADDR_EXP 115
45808: PUSH
45809: LD_EXP 115
45813: PPUSH
45814: LD_VAR 0 1
45818: PPUSH
45819: LD_VAR 0 2
45823: PPUSH
45824: CALL_OW 1
45828: ST_TO_ADDR
// end ;
45829: LD_VAR 0 3
45833: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45834: LD_INT 0
45836: PPUSH
45837: PPUSH
// if not mc_bases or not base then
45838: LD_EXP 90
45842: NOT
45843: PUSH
45844: LD_VAR 0 1
45848: NOT
45849: OR
45850: IFFALSE 45854
// exit ;
45852: GO 45918
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45854: LD_ADDR_VAR 0 3
45858: PUSH
45859: LD_INT 1
45861: PUSH
45862: LD_INT 2
45864: PUSH
45865: LD_INT 3
45867: PUSH
45868: LD_INT 4
45870: PUSH
45871: LD_INT 11
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45881: LD_ADDR_EXP 117
45885: PUSH
45886: LD_EXP 117
45890: PPUSH
45891: LD_VAR 0 1
45895: PPUSH
45896: LD_EXP 117
45900: PUSH
45901: LD_VAR 0 1
45905: ARRAY
45906: PUSH
45907: LD_VAR 0 3
45911: DIFF
45912: PPUSH
45913: CALL_OW 1
45917: ST_TO_ADDR
// end ;
45918: LD_VAR 0 2
45922: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45923: LD_INT 0
45925: PPUSH
// result := mc_vehicles [ base ] ;
45926: LD_ADDR_VAR 0 3
45930: PUSH
45931: LD_EXP 109
45935: PUSH
45936: LD_VAR 0 1
45940: ARRAY
45941: ST_TO_ADDR
// if onlyCombat then
45942: LD_VAR 0 2
45946: IFFALSE 46124
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45948: LD_ADDR_VAR 0 3
45952: PUSH
45953: LD_VAR 0 3
45957: PUSH
45958: LD_VAR 0 3
45962: PPUSH
45963: LD_INT 2
45965: PUSH
45966: LD_INT 34
45968: PUSH
45969: LD_INT 12
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 34
45978: PUSH
45979: LD_INT 51
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 34
45988: PUSH
45989: LD_EXP 73
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 34
46000: PUSH
46001: LD_INT 32
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 34
46010: PUSH
46011: LD_INT 13
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 34
46020: PUSH
46021: LD_INT 52
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: PUSH
46028: LD_INT 34
46030: PUSH
46031: LD_EXP 78
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 34
46042: PUSH
46043: LD_INT 14
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 34
46052: PUSH
46053: LD_INT 53
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 34
46062: PUSH
46063: LD_EXP 72
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 34
46074: PUSH
46075: LD_INT 31
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 34
46084: PUSH
46085: LD_INT 48
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 34
46094: PUSH
46095: LD_INT 8
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: LIST
46110: LIST
46111: LIST
46112: LIST
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: PPUSH
46118: CALL_OW 72
46122: DIFF
46123: ST_TO_ADDR
// end ; end_of_file
46124: LD_VAR 0 3
46128: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46129: LD_INT 0
46131: PPUSH
46132: PPUSH
46133: PPUSH
// if not mc_bases or not skirmish then
46134: LD_EXP 90
46138: NOT
46139: PUSH
46140: LD_EXP 88
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46315
// for i = 1 to mc_bases do
46150: LD_ADDR_VAR 0 4
46154: PUSH
46155: DOUBLE
46156: LD_INT 1
46158: DEC
46159: ST_TO_ADDR
46160: LD_EXP 90
46164: PUSH
46165: FOR_TO
46166: IFFALSE 46313
// begin if sci in mc_bases [ i ] then
46168: LD_VAR 0 2
46172: PUSH
46173: LD_EXP 90
46177: PUSH
46178: LD_VAR 0 4
46182: ARRAY
46183: IN
46184: IFFALSE 46311
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46186: LD_ADDR_EXP 119
46190: PUSH
46191: LD_EXP 119
46195: PPUSH
46196: LD_VAR 0 4
46200: PUSH
46201: LD_EXP 119
46205: PUSH
46206: LD_VAR 0 4
46210: ARRAY
46211: PUSH
46212: LD_INT 1
46214: PLUS
46215: PUSH
46216: EMPTY
46217: LIST
46218: LIST
46219: PPUSH
46220: LD_VAR 0 1
46224: PPUSH
46225: CALL 55814 0 3
46229: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46230: LD_ADDR_VAR 0 5
46234: PUSH
46235: LD_EXP 90
46239: PUSH
46240: LD_VAR 0 4
46244: ARRAY
46245: PPUSH
46246: LD_INT 2
46248: PUSH
46249: LD_INT 30
46251: PUSH
46252: LD_INT 0
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 30
46261: PUSH
46262: LD_INT 1
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: LIST
46273: PPUSH
46274: CALL_OW 72
46278: PPUSH
46279: LD_VAR 0 1
46283: PPUSH
46284: CALL_OW 74
46288: ST_TO_ADDR
// if tmp then
46289: LD_VAR 0 5
46293: IFFALSE 46309
// ComStandNearbyBuilding ( ape , tmp ) ;
46295: LD_VAR 0 1
46299: PPUSH
46300: LD_VAR 0 5
46304: PPUSH
46305: CALL 52428 0 2
// break ;
46309: GO 46313
// end ; end ;
46311: GO 46165
46313: POP
46314: POP
// end ;
46315: LD_VAR 0 3
46319: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46320: LD_INT 0
46322: PPUSH
46323: PPUSH
46324: PPUSH
// if not mc_bases or not skirmish then
46325: LD_EXP 90
46329: NOT
46330: PUSH
46331: LD_EXP 88
46335: NOT
46336: OR
46337: IFFALSE 46341
// exit ;
46339: GO 46430
// for i = 1 to mc_bases do
46341: LD_ADDR_VAR 0 4
46345: PUSH
46346: DOUBLE
46347: LD_INT 1
46349: DEC
46350: ST_TO_ADDR
46351: LD_EXP 90
46355: PUSH
46356: FOR_TO
46357: IFFALSE 46428
// begin if building in mc_busy_turret_list [ i ] then
46359: LD_VAR 0 1
46363: PUSH
46364: LD_EXP 100
46368: PUSH
46369: LD_VAR 0 4
46373: ARRAY
46374: IN
46375: IFFALSE 46426
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46377: LD_ADDR_VAR 0 5
46381: PUSH
46382: LD_EXP 100
46386: PUSH
46387: LD_VAR 0 4
46391: ARRAY
46392: PUSH
46393: LD_VAR 0 1
46397: DIFF
46398: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46399: LD_ADDR_EXP 100
46403: PUSH
46404: LD_EXP 100
46408: PPUSH
46409: LD_VAR 0 4
46413: PPUSH
46414: LD_VAR 0 5
46418: PPUSH
46419: CALL_OW 1
46423: ST_TO_ADDR
// break ;
46424: GO 46428
// end ; end ;
46426: GO 46356
46428: POP
46429: POP
// end ;
46430: LD_VAR 0 3
46434: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46435: LD_INT 0
46437: PPUSH
46438: PPUSH
46439: PPUSH
// if not mc_bases or not skirmish then
46440: LD_EXP 90
46444: NOT
46445: PUSH
46446: LD_EXP 88
46450: NOT
46451: OR
46452: IFFALSE 46456
// exit ;
46454: GO 46655
// for i = 1 to mc_bases do
46456: LD_ADDR_VAR 0 5
46460: PUSH
46461: DOUBLE
46462: LD_INT 1
46464: DEC
46465: ST_TO_ADDR
46466: LD_EXP 90
46470: PUSH
46471: FOR_TO
46472: IFFALSE 46653
// if building in mc_bases [ i ] then
46474: LD_VAR 0 1
46478: PUSH
46479: LD_EXP 90
46483: PUSH
46484: LD_VAR 0 5
46488: ARRAY
46489: IN
46490: IFFALSE 46651
// begin tmp := mc_bases [ i ] diff building ;
46492: LD_ADDR_VAR 0 6
46496: PUSH
46497: LD_EXP 90
46501: PUSH
46502: LD_VAR 0 5
46506: ARRAY
46507: PUSH
46508: LD_VAR 0 1
46512: DIFF
46513: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46514: LD_ADDR_EXP 90
46518: PUSH
46519: LD_EXP 90
46523: PPUSH
46524: LD_VAR 0 5
46528: PPUSH
46529: LD_VAR 0 6
46533: PPUSH
46534: CALL_OW 1
46538: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46539: LD_VAR 0 1
46543: PUSH
46544: LD_EXP 98
46548: PUSH
46549: LD_VAR 0 5
46553: ARRAY
46554: IN
46555: IFFALSE 46594
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46557: LD_ADDR_EXP 98
46561: PUSH
46562: LD_EXP 98
46566: PPUSH
46567: LD_VAR 0 5
46571: PPUSH
46572: LD_EXP 98
46576: PUSH
46577: LD_VAR 0 5
46581: ARRAY
46582: PUSH
46583: LD_VAR 0 1
46587: DIFF
46588: PPUSH
46589: CALL_OW 1
46593: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46594: LD_VAR 0 1
46598: PUSH
46599: LD_EXP 99
46603: PUSH
46604: LD_VAR 0 5
46608: ARRAY
46609: IN
46610: IFFALSE 46649
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46612: LD_ADDR_EXP 99
46616: PUSH
46617: LD_EXP 99
46621: PPUSH
46622: LD_VAR 0 5
46626: PPUSH
46627: LD_EXP 99
46631: PUSH
46632: LD_VAR 0 5
46636: ARRAY
46637: PUSH
46638: LD_VAR 0 1
46642: DIFF
46643: PPUSH
46644: CALL_OW 1
46648: ST_TO_ADDR
// break ;
46649: GO 46653
// end ;
46651: GO 46471
46653: POP
46654: POP
// end ;
46655: LD_VAR 0 4
46659: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46660: LD_INT 0
46662: PPUSH
46663: PPUSH
46664: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46665: LD_EXP 90
46669: NOT
46670: PUSH
46671: LD_EXP 88
46675: NOT
46676: OR
46677: PUSH
46678: LD_VAR 0 3
46682: PUSH
46683: LD_EXP 116
46687: IN
46688: NOT
46689: OR
46690: IFFALSE 46694
// exit ;
46692: GO 46817
// for i = 1 to mc_vehicles do
46694: LD_ADDR_VAR 0 6
46698: PUSH
46699: DOUBLE
46700: LD_INT 1
46702: DEC
46703: ST_TO_ADDR
46704: LD_EXP 109
46708: PUSH
46709: FOR_TO
46710: IFFALSE 46815
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46712: LD_VAR 0 2
46716: PUSH
46717: LD_EXP 109
46721: PUSH
46722: LD_VAR 0 6
46726: ARRAY
46727: IN
46728: PUSH
46729: LD_VAR 0 1
46733: PUSH
46734: LD_EXP 109
46738: PUSH
46739: LD_VAR 0 6
46743: ARRAY
46744: IN
46745: OR
46746: IFFALSE 46813
// begin tmp := mc_vehicles [ i ] diff old ;
46748: LD_ADDR_VAR 0 7
46752: PUSH
46753: LD_EXP 109
46757: PUSH
46758: LD_VAR 0 6
46762: ARRAY
46763: PUSH
46764: LD_VAR 0 2
46768: DIFF
46769: ST_TO_ADDR
// tmp := tmp diff new ;
46770: LD_ADDR_VAR 0 7
46774: PUSH
46775: LD_VAR 0 7
46779: PUSH
46780: LD_VAR 0 1
46784: DIFF
46785: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46786: LD_ADDR_EXP 109
46790: PUSH
46791: LD_EXP 109
46795: PPUSH
46796: LD_VAR 0 6
46800: PPUSH
46801: LD_VAR 0 7
46805: PPUSH
46806: CALL_OW 1
46810: ST_TO_ADDR
// break ;
46811: GO 46815
// end ;
46813: GO 46709
46815: POP
46816: POP
// end ;
46817: LD_VAR 0 5
46821: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46822: LD_INT 0
46824: PPUSH
46825: PPUSH
46826: PPUSH
46827: PPUSH
// if not mc_bases or not skirmish then
46828: LD_EXP 90
46832: NOT
46833: PUSH
46834: LD_EXP 88
46838: NOT
46839: OR
46840: IFFALSE 46844
// exit ;
46842: GO 47227
// side := GetSide ( vehicle ) ;
46844: LD_ADDR_VAR 0 5
46848: PUSH
46849: LD_VAR 0 1
46853: PPUSH
46854: CALL_OW 255
46858: ST_TO_ADDR
// for i = 1 to mc_bases do
46859: LD_ADDR_VAR 0 4
46863: PUSH
46864: DOUBLE
46865: LD_INT 1
46867: DEC
46868: ST_TO_ADDR
46869: LD_EXP 90
46873: PUSH
46874: FOR_TO
46875: IFFALSE 47225
// begin if factory in mc_bases [ i ] then
46877: LD_VAR 0 2
46881: PUSH
46882: LD_EXP 90
46886: PUSH
46887: LD_VAR 0 4
46891: ARRAY
46892: IN
46893: IFFALSE 47223
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
46895: LD_EXP 112
46899: PUSH
46900: LD_VAR 0 4
46904: ARRAY
46905: PUSH
46906: LD_EXP 101
46910: PUSH
46911: LD_VAR 0 4
46915: ARRAY
46916: LESS
46917: PUSH
46918: LD_VAR 0 1
46922: PPUSH
46923: CALL_OW 264
46927: PUSH
46928: LD_INT 31
46930: PUSH
46931: LD_INT 32
46933: PUSH
46934: LD_INT 51
46936: PUSH
46937: LD_EXP 73
46941: PUSH
46942: LD_INT 12
46944: PUSH
46945: LD_INT 30
46947: PUSH
46948: LD_EXP 72
46952: PUSH
46953: LD_INT 11
46955: PUSH
46956: LD_INT 53
46958: PUSH
46959: LD_INT 14
46961: PUSH
46962: LD_EXP 76
46966: PUSH
46967: LD_INT 29
46969: PUSH
46970: LD_EXP 74
46974: PUSH
46975: LD_INT 13
46977: PUSH
46978: LD_INT 52
46980: PUSH
46981: LD_EXP 78
46985: PUSH
46986: LD_INT 48
46988: PUSH
46989: LD_INT 8
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: IN
47012: NOT
47013: AND
47014: IFFALSE 47062
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47016: LD_ADDR_EXP 112
47020: PUSH
47021: LD_EXP 112
47025: PPUSH
47026: LD_VAR 0 4
47030: PUSH
47031: LD_EXP 112
47035: PUSH
47036: LD_VAR 0 4
47040: ARRAY
47041: PUSH
47042: LD_INT 1
47044: PLUS
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: PPUSH
47050: LD_VAR 0 1
47054: PPUSH
47055: CALL 55814 0 3
47059: ST_TO_ADDR
47060: GO 47106
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47062: LD_ADDR_EXP 109
47066: PUSH
47067: LD_EXP 109
47071: PPUSH
47072: LD_VAR 0 4
47076: PUSH
47077: LD_EXP 109
47081: PUSH
47082: LD_VAR 0 4
47086: ARRAY
47087: PUSH
47088: LD_INT 1
47090: PLUS
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: PPUSH
47096: LD_VAR 0 1
47100: PPUSH
47101: CALL 55814 0 3
47105: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47106: LD_VAR 0 1
47110: PPUSH
47111: CALL_OW 263
47115: PUSH
47116: LD_INT 2
47118: EQUAL
47119: IFFALSE 47139
// begin repeat wait ( 0 0$1 ) ;
47121: LD_INT 35
47123: PPUSH
47124: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47128: LD_VAR 0 1
47132: PPUSH
47133: CALL_OW 312
47137: IFFALSE 47121
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47139: LD_VAR 0 1
47143: PPUSH
47144: LD_EXP 114
47148: PUSH
47149: LD_VAR 0 4
47153: ARRAY
47154: PPUSH
47155: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47159: LD_VAR 0 1
47163: PPUSH
47164: CALL_OW 263
47168: PUSH
47169: LD_INT 1
47171: NONEQUAL
47172: IFFALSE 47176
// break ;
47174: GO 47225
// repeat wait ( 0 0$1 ) ;
47176: LD_INT 35
47178: PPUSH
47179: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47183: LD_VAR 0 1
47187: PPUSH
47188: LD_EXP 114
47192: PUSH
47193: LD_VAR 0 4
47197: ARRAY
47198: PPUSH
47199: CALL_OW 308
47203: IFFALSE 47176
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47205: LD_VAR 0 1
47209: PPUSH
47210: CALL_OW 311
47214: PPUSH
47215: CALL_OW 121
// exit ;
47219: POP
47220: POP
47221: GO 47227
// end ; end ;
47223: GO 46874
47225: POP
47226: POP
// end ;
47227: LD_VAR 0 3
47231: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47232: LD_INT 0
47234: PPUSH
47235: PPUSH
47236: PPUSH
47237: PPUSH
// if not mc_bases or not skirmish then
47238: LD_EXP 90
47242: NOT
47243: PUSH
47244: LD_EXP 88
47248: NOT
47249: OR
47250: IFFALSE 47254
// exit ;
47252: GO 47607
// repeat wait ( 0 0$1 ) ;
47254: LD_INT 35
47256: PPUSH
47257: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47261: LD_VAR 0 2
47265: PPUSH
47266: LD_VAR 0 3
47270: PPUSH
47271: CALL_OW 284
47275: IFFALSE 47254
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47277: LD_VAR 0 2
47281: PPUSH
47282: LD_VAR 0 3
47286: PPUSH
47287: CALL_OW 283
47291: PUSH
47292: LD_INT 4
47294: EQUAL
47295: IFFALSE 47299
// exit ;
47297: GO 47607
// for i = 1 to mc_bases do
47299: LD_ADDR_VAR 0 7
47303: PUSH
47304: DOUBLE
47305: LD_INT 1
47307: DEC
47308: ST_TO_ADDR
47309: LD_EXP 90
47313: PUSH
47314: FOR_TO
47315: IFFALSE 47605
// begin if mc_crates_area [ i ] then
47317: LD_EXP 108
47321: PUSH
47322: LD_VAR 0 7
47326: ARRAY
47327: IFFALSE 47438
// for j in mc_crates_area [ i ] do
47329: LD_ADDR_VAR 0 8
47333: PUSH
47334: LD_EXP 108
47338: PUSH
47339: LD_VAR 0 7
47343: ARRAY
47344: PUSH
47345: FOR_IN
47346: IFFALSE 47436
// if InArea ( x , y , j ) then
47348: LD_VAR 0 2
47352: PPUSH
47353: LD_VAR 0 3
47357: PPUSH
47358: LD_VAR 0 8
47362: PPUSH
47363: CALL_OW 309
47367: IFFALSE 47434
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47369: LD_ADDR_EXP 106
47373: PUSH
47374: LD_EXP 106
47378: PPUSH
47379: LD_VAR 0 7
47383: PUSH
47384: LD_EXP 106
47388: PUSH
47389: LD_VAR 0 7
47393: ARRAY
47394: PUSH
47395: LD_INT 1
47397: PLUS
47398: PUSH
47399: EMPTY
47400: LIST
47401: LIST
47402: PPUSH
47403: LD_VAR 0 4
47407: PUSH
47408: LD_VAR 0 2
47412: PUSH
47413: LD_VAR 0 3
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: LIST
47422: PPUSH
47423: CALL 55814 0 3
47427: ST_TO_ADDR
// exit ;
47428: POP
47429: POP
47430: POP
47431: POP
47432: GO 47607
// end ;
47434: GO 47345
47436: POP
47437: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47438: LD_ADDR_VAR 0 9
47442: PUSH
47443: LD_EXP 90
47447: PUSH
47448: LD_VAR 0 7
47452: ARRAY
47453: PPUSH
47454: LD_INT 2
47456: PUSH
47457: LD_INT 30
47459: PUSH
47460: LD_INT 0
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: PUSH
47467: LD_INT 30
47469: PUSH
47470: LD_INT 1
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: PUSH
47477: EMPTY
47478: LIST
47479: LIST
47480: LIST
47481: PPUSH
47482: CALL_OW 72
47486: ST_TO_ADDR
// if not depot then
47487: LD_VAR 0 9
47491: NOT
47492: IFFALSE 47496
// continue ;
47494: GO 47314
// for j in depot do
47496: LD_ADDR_VAR 0 8
47500: PUSH
47501: LD_VAR 0 9
47505: PUSH
47506: FOR_IN
47507: IFFALSE 47601
// if GetDistUnitXY ( j , x , y ) < 30 then
47509: LD_VAR 0 8
47513: PPUSH
47514: LD_VAR 0 2
47518: PPUSH
47519: LD_VAR 0 3
47523: PPUSH
47524: CALL_OW 297
47528: PUSH
47529: LD_INT 30
47531: LESS
47532: IFFALSE 47599
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47534: LD_ADDR_EXP 106
47538: PUSH
47539: LD_EXP 106
47543: PPUSH
47544: LD_VAR 0 7
47548: PUSH
47549: LD_EXP 106
47553: PUSH
47554: LD_VAR 0 7
47558: ARRAY
47559: PUSH
47560: LD_INT 1
47562: PLUS
47563: PUSH
47564: EMPTY
47565: LIST
47566: LIST
47567: PPUSH
47568: LD_VAR 0 4
47572: PUSH
47573: LD_VAR 0 2
47577: PUSH
47578: LD_VAR 0 3
47582: PUSH
47583: EMPTY
47584: LIST
47585: LIST
47586: LIST
47587: PPUSH
47588: CALL 55814 0 3
47592: ST_TO_ADDR
// exit ;
47593: POP
47594: POP
47595: POP
47596: POP
47597: GO 47607
// end ;
47599: GO 47506
47601: POP
47602: POP
// end ;
47603: GO 47314
47605: POP
47606: POP
// end ;
47607: LD_VAR 0 6
47611: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47612: LD_INT 0
47614: PPUSH
47615: PPUSH
47616: PPUSH
47617: PPUSH
// if not mc_bases or not skirmish then
47618: LD_EXP 90
47622: NOT
47623: PUSH
47624: LD_EXP 88
47628: NOT
47629: OR
47630: IFFALSE 47634
// exit ;
47632: GO 47911
// side := GetSide ( lab ) ;
47634: LD_ADDR_VAR 0 4
47638: PUSH
47639: LD_VAR 0 2
47643: PPUSH
47644: CALL_OW 255
47648: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47649: LD_VAR 0 4
47653: PUSH
47654: LD_EXP 116
47658: IN
47659: NOT
47660: PUSH
47661: LD_EXP 117
47665: NOT
47666: OR
47667: PUSH
47668: LD_EXP 90
47672: NOT
47673: OR
47674: IFFALSE 47678
// exit ;
47676: GO 47911
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47678: LD_ADDR_EXP 117
47682: PUSH
47683: LD_EXP 117
47687: PPUSH
47688: LD_VAR 0 4
47692: PPUSH
47693: LD_EXP 117
47697: PUSH
47698: LD_VAR 0 4
47702: ARRAY
47703: PUSH
47704: LD_VAR 0 1
47708: DIFF
47709: PPUSH
47710: CALL_OW 1
47714: ST_TO_ADDR
// for i = 1 to mc_bases do
47715: LD_ADDR_VAR 0 5
47719: PUSH
47720: DOUBLE
47721: LD_INT 1
47723: DEC
47724: ST_TO_ADDR
47725: LD_EXP 90
47729: PUSH
47730: FOR_TO
47731: IFFALSE 47909
// begin if lab in mc_bases [ i ] then
47733: LD_VAR 0 2
47737: PUSH
47738: LD_EXP 90
47742: PUSH
47743: LD_VAR 0 5
47747: ARRAY
47748: IN
47749: IFFALSE 47907
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47751: LD_VAR 0 1
47755: PUSH
47756: LD_INT 11
47758: PUSH
47759: LD_INT 4
47761: PUSH
47762: LD_INT 3
47764: PUSH
47765: LD_INT 2
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: IN
47774: PUSH
47775: LD_EXP 120
47779: PUSH
47780: LD_VAR 0 5
47784: ARRAY
47785: AND
47786: IFFALSE 47907
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47788: LD_ADDR_VAR 0 6
47792: PUSH
47793: LD_EXP 120
47797: PUSH
47798: LD_VAR 0 5
47802: ARRAY
47803: PUSH
47804: LD_INT 1
47806: ARRAY
47807: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47808: LD_ADDR_EXP 120
47812: PUSH
47813: LD_EXP 120
47817: PPUSH
47818: LD_VAR 0 5
47822: PPUSH
47823: EMPTY
47824: PPUSH
47825: CALL_OW 1
47829: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47830: LD_VAR 0 6
47834: PPUSH
47835: LD_INT 0
47837: PPUSH
47838: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47842: LD_VAR 0 6
47846: PPUSH
47847: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47851: LD_ADDR_EXP 119
47855: PUSH
47856: LD_EXP 119
47860: PPUSH
47861: LD_VAR 0 5
47865: PPUSH
47866: LD_EXP 119
47870: PUSH
47871: LD_VAR 0 5
47875: ARRAY
47876: PPUSH
47877: LD_INT 1
47879: PPUSH
47880: LD_VAR 0 6
47884: PPUSH
47885: CALL_OW 2
47889: PPUSH
47890: CALL_OW 1
47894: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47895: LD_VAR 0 5
47899: PPUSH
47900: LD_INT 112
47902: PPUSH
47903: CALL 24856 0 2
// end ; end ; end ;
47907: GO 47730
47909: POP
47910: POP
// end ;
47911: LD_VAR 0 3
47915: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47916: LD_INT 0
47918: PPUSH
47919: PPUSH
47920: PPUSH
47921: PPUSH
47922: PPUSH
47923: PPUSH
47924: PPUSH
47925: PPUSH
// if not mc_bases or not skirmish then
47926: LD_EXP 90
47930: NOT
47931: PUSH
47932: LD_EXP 88
47936: NOT
47937: OR
47938: IFFALSE 47942
// exit ;
47940: GO 49313
// for i = 1 to mc_bases do
47942: LD_ADDR_VAR 0 3
47946: PUSH
47947: DOUBLE
47948: LD_INT 1
47950: DEC
47951: ST_TO_ADDR
47952: LD_EXP 90
47956: PUSH
47957: FOR_TO
47958: IFFALSE 49311
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47960: LD_VAR 0 1
47964: PUSH
47965: LD_EXP 90
47969: PUSH
47970: LD_VAR 0 3
47974: ARRAY
47975: IN
47976: PUSH
47977: LD_VAR 0 1
47981: PUSH
47982: LD_EXP 97
47986: PUSH
47987: LD_VAR 0 3
47991: ARRAY
47992: IN
47993: OR
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_EXP 112
48004: PUSH
48005: LD_VAR 0 3
48009: ARRAY
48010: IN
48011: OR
48012: PUSH
48013: LD_VAR 0 1
48017: PUSH
48018: LD_EXP 109
48022: PUSH
48023: LD_VAR 0 3
48027: ARRAY
48028: IN
48029: OR
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_EXP 119
48040: PUSH
48041: LD_VAR 0 3
48045: ARRAY
48046: IN
48047: OR
48048: PUSH
48049: LD_VAR 0 1
48053: PUSH
48054: LD_EXP 120
48058: PUSH
48059: LD_VAR 0 3
48063: ARRAY
48064: IN
48065: OR
48066: IFFALSE 49309
// begin if un in mc_ape [ i ] then
48068: LD_VAR 0 1
48072: PUSH
48073: LD_EXP 119
48077: PUSH
48078: LD_VAR 0 3
48082: ARRAY
48083: IN
48084: IFFALSE 48123
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48086: LD_ADDR_EXP 119
48090: PUSH
48091: LD_EXP 119
48095: PPUSH
48096: LD_VAR 0 3
48100: PPUSH
48101: LD_EXP 119
48105: PUSH
48106: LD_VAR 0 3
48110: ARRAY
48111: PUSH
48112: LD_VAR 0 1
48116: DIFF
48117: PPUSH
48118: CALL_OW 1
48122: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48123: LD_VAR 0 1
48127: PUSH
48128: LD_EXP 120
48132: PUSH
48133: LD_VAR 0 3
48137: ARRAY
48138: IN
48139: IFFALSE 48163
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48141: LD_ADDR_EXP 120
48145: PUSH
48146: LD_EXP 120
48150: PPUSH
48151: LD_VAR 0 3
48155: PPUSH
48156: EMPTY
48157: PPUSH
48158: CALL_OW 1
48162: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48163: LD_VAR 0 1
48167: PPUSH
48168: CALL_OW 247
48172: PUSH
48173: LD_INT 2
48175: EQUAL
48176: PUSH
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 110
48186: PUSH
48187: LD_INT 20
48189: EQUAL
48190: PUSH
48191: LD_VAR 0 1
48195: PUSH
48196: LD_EXP 112
48200: PUSH
48201: LD_VAR 0 3
48205: ARRAY
48206: IN
48207: OR
48208: PUSH
48209: LD_VAR 0 1
48213: PPUSH
48214: CALL_OW 264
48218: PUSH
48219: LD_INT 12
48221: PUSH
48222: LD_INT 51
48224: PUSH
48225: LD_EXP 73
48229: PUSH
48230: LD_INT 32
48232: PUSH
48233: LD_INT 13
48235: PUSH
48236: LD_INT 52
48238: PUSH
48239: LD_INT 31
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: IN
48251: OR
48252: AND
48253: IFFALSE 48561
// begin if un in mc_defender [ i ] then
48255: LD_VAR 0 1
48259: PUSH
48260: LD_EXP 112
48264: PUSH
48265: LD_VAR 0 3
48269: ARRAY
48270: IN
48271: IFFALSE 48310
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48273: LD_ADDR_EXP 112
48277: PUSH
48278: LD_EXP 112
48282: PPUSH
48283: LD_VAR 0 3
48287: PPUSH
48288: LD_EXP 112
48292: PUSH
48293: LD_VAR 0 3
48297: ARRAY
48298: PUSH
48299: LD_VAR 0 1
48303: DIFF
48304: PPUSH
48305: CALL_OW 1
48309: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48310: LD_ADDR_VAR 0 8
48314: PUSH
48315: LD_VAR 0 3
48319: PPUSH
48320: LD_INT 3
48322: PPUSH
48323: CALL 44960 0 2
48327: ST_TO_ADDR
// if fac then
48328: LD_VAR 0 8
48332: IFFALSE 48561
// begin for j in fac do
48334: LD_ADDR_VAR 0 4
48338: PUSH
48339: LD_VAR 0 8
48343: PUSH
48344: FOR_IN
48345: IFFALSE 48559
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48347: LD_ADDR_VAR 0 9
48351: PUSH
48352: LD_VAR 0 8
48356: PPUSH
48357: LD_VAR 0 1
48361: PPUSH
48362: CALL_OW 265
48366: PPUSH
48367: LD_VAR 0 1
48371: PPUSH
48372: CALL_OW 262
48376: PPUSH
48377: LD_VAR 0 1
48381: PPUSH
48382: CALL_OW 263
48386: PPUSH
48387: LD_VAR 0 1
48391: PPUSH
48392: CALL_OW 264
48396: PPUSH
48397: CALL 53346 0 5
48401: ST_TO_ADDR
// if components then
48402: LD_VAR 0 9
48406: IFFALSE 48557
// begin if GetWeapon ( un ) = ar_control_tower then
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 264
48417: PUSH
48418: LD_INT 31
48420: EQUAL
48421: IFFALSE 48538
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL_OW 311
48432: PPUSH
48433: LD_INT 0
48435: PPUSH
48436: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48440: LD_ADDR_EXP 130
48444: PUSH
48445: LD_EXP 130
48449: PPUSH
48450: LD_VAR 0 3
48454: PPUSH
48455: LD_EXP 130
48459: PUSH
48460: LD_VAR 0 3
48464: ARRAY
48465: PUSH
48466: LD_VAR 0 1
48470: PPUSH
48471: CALL_OW 311
48475: DIFF
48476: PPUSH
48477: CALL_OW 1
48481: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48482: LD_ADDR_VAR 0 7
48486: PUSH
48487: LD_EXP 111
48491: PUSH
48492: LD_VAR 0 3
48496: ARRAY
48497: PPUSH
48498: LD_INT 1
48500: PPUSH
48501: LD_VAR 0 9
48505: PPUSH
48506: CALL_OW 2
48510: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48511: LD_ADDR_EXP 111
48515: PUSH
48516: LD_EXP 111
48520: PPUSH
48521: LD_VAR 0 3
48525: PPUSH
48526: LD_VAR 0 7
48530: PPUSH
48531: CALL_OW 1
48535: ST_TO_ADDR
// end else
48536: GO 48555
// MC_InsertProduceList ( i , [ components ] ) ;
48538: LD_VAR 0 3
48542: PPUSH
48543: LD_VAR 0 9
48547: PUSH
48548: EMPTY
48549: LIST
48550: PPUSH
48551: CALL 44505 0 2
// break ;
48555: GO 48559
// end ; end ;
48557: GO 48344
48559: POP
48560: POP
// end ; end ; if GetType ( un ) = unit_building then
48561: LD_VAR 0 1
48565: PPUSH
48566: CALL_OW 247
48570: PUSH
48571: LD_INT 3
48573: EQUAL
48574: IFFALSE 48977
// begin btype := GetBType ( un ) ;
48576: LD_ADDR_VAR 0 5
48580: PUSH
48581: LD_VAR 0 1
48585: PPUSH
48586: CALL_OW 266
48590: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48591: LD_VAR 0 5
48595: PUSH
48596: LD_INT 29
48598: PUSH
48599: LD_INT 30
48601: PUSH
48602: EMPTY
48603: LIST
48604: LIST
48605: IN
48606: IFFALSE 48679
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 250
48617: PPUSH
48618: LD_VAR 0 1
48622: PPUSH
48623: CALL_OW 251
48627: PPUSH
48628: LD_VAR 0 1
48632: PPUSH
48633: CALL_OW 255
48637: PPUSH
48638: CALL_OW 440
48642: NOT
48643: IFFALSE 48679
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48645: LD_VAR 0 1
48649: PPUSH
48650: CALL_OW 250
48654: PPUSH
48655: LD_VAR 0 1
48659: PPUSH
48660: CALL_OW 251
48664: PPUSH
48665: LD_VAR 0 1
48669: PPUSH
48670: CALL_OW 255
48674: PPUSH
48675: CALL_OW 441
// end ; if btype = b_warehouse then
48679: LD_VAR 0 5
48683: PUSH
48684: LD_INT 1
48686: EQUAL
48687: IFFALSE 48705
// begin btype := b_depot ;
48689: LD_ADDR_VAR 0 5
48693: PUSH
48694: LD_INT 0
48696: ST_TO_ADDR
// pos := 1 ;
48697: LD_ADDR_VAR 0 6
48701: PUSH
48702: LD_INT 1
48704: ST_TO_ADDR
// end ; if btype = b_factory then
48705: LD_VAR 0 5
48709: PUSH
48710: LD_INT 3
48712: EQUAL
48713: IFFALSE 48731
// begin btype := b_workshop ;
48715: LD_ADDR_VAR 0 5
48719: PUSH
48720: LD_INT 2
48722: ST_TO_ADDR
// pos := 1 ;
48723: LD_ADDR_VAR 0 6
48727: PUSH
48728: LD_INT 1
48730: ST_TO_ADDR
// end ; if btype = b_barracks then
48731: LD_VAR 0 5
48735: PUSH
48736: LD_INT 5
48738: EQUAL
48739: IFFALSE 48749
// btype := b_armoury ;
48741: LD_ADDR_VAR 0 5
48745: PUSH
48746: LD_INT 4
48748: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48749: LD_VAR 0 5
48753: PUSH
48754: LD_INT 7
48756: PUSH
48757: LD_INT 8
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: IN
48764: IFFALSE 48774
// btype := b_lab ;
48766: LD_ADDR_VAR 0 5
48770: PUSH
48771: LD_INT 6
48773: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48774: LD_ADDR_EXP 95
48778: PUSH
48779: LD_EXP 95
48783: PPUSH
48784: LD_VAR 0 3
48788: PUSH
48789: LD_EXP 95
48793: PUSH
48794: LD_VAR 0 3
48798: ARRAY
48799: PUSH
48800: LD_INT 1
48802: PLUS
48803: PUSH
48804: EMPTY
48805: LIST
48806: LIST
48807: PPUSH
48808: LD_VAR 0 5
48812: PUSH
48813: LD_VAR 0 1
48817: PPUSH
48818: CALL_OW 250
48822: PUSH
48823: LD_VAR 0 1
48827: PPUSH
48828: CALL_OW 251
48832: PUSH
48833: LD_VAR 0 1
48837: PPUSH
48838: CALL_OW 254
48842: PUSH
48843: EMPTY
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: PPUSH
48849: CALL 55814 0 3
48853: ST_TO_ADDR
// if pos = 1 then
48854: LD_VAR 0 6
48858: PUSH
48859: LD_INT 1
48861: EQUAL
48862: IFFALSE 48977
// begin tmp := mc_build_list [ i ] ;
48864: LD_ADDR_VAR 0 7
48868: PUSH
48869: LD_EXP 95
48873: PUSH
48874: LD_VAR 0 3
48878: ARRAY
48879: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48880: LD_VAR 0 7
48884: PPUSH
48885: LD_INT 2
48887: PUSH
48888: LD_INT 30
48890: PUSH
48891: LD_INT 0
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: LD_INT 30
48900: PUSH
48901: LD_INT 1
48903: PUSH
48904: EMPTY
48905: LIST
48906: LIST
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: LIST
48912: PPUSH
48913: CALL_OW 72
48917: IFFALSE 48927
// pos := 2 ;
48919: LD_ADDR_VAR 0 6
48923: PUSH
48924: LD_INT 2
48926: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48927: LD_ADDR_VAR 0 7
48931: PUSH
48932: LD_VAR 0 7
48936: PPUSH
48937: LD_VAR 0 6
48941: PPUSH
48942: LD_VAR 0 7
48946: PPUSH
48947: CALL 56140 0 3
48951: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48952: LD_ADDR_EXP 95
48956: PUSH
48957: LD_EXP 95
48961: PPUSH
48962: LD_VAR 0 3
48966: PPUSH
48967: LD_VAR 0 7
48971: PPUSH
48972: CALL_OW 1
48976: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48977: LD_VAR 0 1
48981: PUSH
48982: LD_EXP 90
48986: PUSH
48987: LD_VAR 0 3
48991: ARRAY
48992: IN
48993: IFFALSE 49032
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48995: LD_ADDR_EXP 90
48999: PUSH
49000: LD_EXP 90
49004: PPUSH
49005: LD_VAR 0 3
49009: PPUSH
49010: LD_EXP 90
49014: PUSH
49015: LD_VAR 0 3
49019: ARRAY
49020: PUSH
49021: LD_VAR 0 1
49025: DIFF
49026: PPUSH
49027: CALL_OW 1
49031: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49032: LD_VAR 0 1
49036: PUSH
49037: LD_EXP 97
49041: PUSH
49042: LD_VAR 0 3
49046: ARRAY
49047: IN
49048: IFFALSE 49087
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49050: LD_ADDR_EXP 97
49054: PUSH
49055: LD_EXP 97
49059: PPUSH
49060: LD_VAR 0 3
49064: PPUSH
49065: LD_EXP 97
49069: PUSH
49070: LD_VAR 0 3
49074: ARRAY
49075: PUSH
49076: LD_VAR 0 1
49080: DIFF
49081: PPUSH
49082: CALL_OW 1
49086: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49087: LD_VAR 0 1
49091: PUSH
49092: LD_EXP 109
49096: PUSH
49097: LD_VAR 0 3
49101: ARRAY
49102: IN
49103: IFFALSE 49142
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49105: LD_ADDR_EXP 109
49109: PUSH
49110: LD_EXP 109
49114: PPUSH
49115: LD_VAR 0 3
49119: PPUSH
49120: LD_EXP 109
49124: PUSH
49125: LD_VAR 0 3
49129: ARRAY
49130: PUSH
49131: LD_VAR 0 1
49135: DIFF
49136: PPUSH
49137: CALL_OW 1
49141: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49142: LD_VAR 0 1
49146: PUSH
49147: LD_EXP 112
49151: PUSH
49152: LD_VAR 0 3
49156: ARRAY
49157: IN
49158: IFFALSE 49197
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49160: LD_ADDR_EXP 112
49164: PUSH
49165: LD_EXP 112
49169: PPUSH
49170: LD_VAR 0 3
49174: PPUSH
49175: LD_EXP 112
49179: PUSH
49180: LD_VAR 0 3
49184: ARRAY
49185: PUSH
49186: LD_VAR 0 1
49190: DIFF
49191: PPUSH
49192: CALL_OW 1
49196: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49197: LD_VAR 0 1
49201: PUSH
49202: LD_EXP 99
49206: PUSH
49207: LD_VAR 0 3
49211: ARRAY
49212: IN
49213: IFFALSE 49252
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49215: LD_ADDR_EXP 99
49219: PUSH
49220: LD_EXP 99
49224: PPUSH
49225: LD_VAR 0 3
49229: PPUSH
49230: LD_EXP 99
49234: PUSH
49235: LD_VAR 0 3
49239: ARRAY
49240: PUSH
49241: LD_VAR 0 1
49245: DIFF
49246: PPUSH
49247: CALL_OW 1
49251: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49252: LD_VAR 0 1
49256: PUSH
49257: LD_EXP 98
49261: PUSH
49262: LD_VAR 0 3
49266: ARRAY
49267: IN
49268: IFFALSE 49307
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49270: LD_ADDR_EXP 98
49274: PUSH
49275: LD_EXP 98
49279: PPUSH
49280: LD_VAR 0 3
49284: PPUSH
49285: LD_EXP 98
49289: PUSH
49290: LD_VAR 0 3
49294: ARRAY
49295: PUSH
49296: LD_VAR 0 1
49300: DIFF
49301: PPUSH
49302: CALL_OW 1
49306: ST_TO_ADDR
// end ; break ;
49307: GO 49311
// end ;
49309: GO 47957
49311: POP
49312: POP
// end ;
49313: LD_VAR 0 2
49317: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49318: LD_INT 0
49320: PPUSH
49321: PPUSH
49322: PPUSH
// if not mc_bases or not skirmish then
49323: LD_EXP 90
49327: NOT
49328: PUSH
49329: LD_EXP 88
49333: NOT
49334: OR
49335: IFFALSE 49339
// exit ;
49337: GO 49554
// for i = 1 to mc_bases do
49339: LD_ADDR_VAR 0 3
49343: PUSH
49344: DOUBLE
49345: LD_INT 1
49347: DEC
49348: ST_TO_ADDR
49349: LD_EXP 90
49353: PUSH
49354: FOR_TO
49355: IFFALSE 49552
// begin if building in mc_construct_list [ i ] then
49357: LD_VAR 0 1
49361: PUSH
49362: LD_EXP 97
49366: PUSH
49367: LD_VAR 0 3
49371: ARRAY
49372: IN
49373: IFFALSE 49550
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49375: LD_ADDR_EXP 97
49379: PUSH
49380: LD_EXP 97
49384: PPUSH
49385: LD_VAR 0 3
49389: PPUSH
49390: LD_EXP 97
49394: PUSH
49395: LD_VAR 0 3
49399: ARRAY
49400: PUSH
49401: LD_VAR 0 1
49405: DIFF
49406: PPUSH
49407: CALL_OW 1
49411: ST_TO_ADDR
// if building in mc_lab [ i ] then
49412: LD_VAR 0 1
49416: PUSH
49417: LD_EXP 123
49421: PUSH
49422: LD_VAR 0 3
49426: ARRAY
49427: IN
49428: IFFALSE 49483
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49430: LD_ADDR_EXP 124
49434: PUSH
49435: LD_EXP 124
49439: PPUSH
49440: LD_VAR 0 3
49444: PPUSH
49445: LD_EXP 124
49449: PUSH
49450: LD_VAR 0 3
49454: ARRAY
49455: PPUSH
49456: LD_INT 1
49458: PPUSH
49459: LD_EXP 124
49463: PUSH
49464: LD_VAR 0 3
49468: ARRAY
49469: PPUSH
49470: LD_INT 0
49472: PPUSH
49473: CALL 55232 0 4
49477: PPUSH
49478: CALL_OW 1
49482: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49483: LD_VAR 0 1
49487: PUSH
49488: LD_EXP 90
49492: PUSH
49493: LD_VAR 0 3
49497: ARRAY
49498: IN
49499: NOT
49500: IFFALSE 49546
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49502: LD_ADDR_EXP 90
49506: PUSH
49507: LD_EXP 90
49511: PPUSH
49512: LD_VAR 0 3
49516: PUSH
49517: LD_EXP 90
49521: PUSH
49522: LD_VAR 0 3
49526: ARRAY
49527: PUSH
49528: LD_INT 1
49530: PLUS
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PPUSH
49536: LD_VAR 0 1
49540: PPUSH
49541: CALL 55814 0 3
49545: ST_TO_ADDR
// exit ;
49546: POP
49547: POP
49548: GO 49554
// end ; end ;
49550: GO 49354
49552: POP
49553: POP
// end ;
49554: LD_VAR 0 2
49558: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49559: LD_INT 0
49561: PPUSH
49562: PPUSH
49563: PPUSH
49564: PPUSH
49565: PPUSH
49566: PPUSH
49567: PPUSH
// if not mc_bases or not skirmish then
49568: LD_EXP 90
49572: NOT
49573: PUSH
49574: LD_EXP 88
49578: NOT
49579: OR
49580: IFFALSE 49584
// exit ;
49582: GO 50245
// for i = 1 to mc_bases do
49584: LD_ADDR_VAR 0 3
49588: PUSH
49589: DOUBLE
49590: LD_INT 1
49592: DEC
49593: ST_TO_ADDR
49594: LD_EXP 90
49598: PUSH
49599: FOR_TO
49600: IFFALSE 50243
// begin if building in mc_construct_list [ i ] then
49602: LD_VAR 0 1
49606: PUSH
49607: LD_EXP 97
49611: PUSH
49612: LD_VAR 0 3
49616: ARRAY
49617: IN
49618: IFFALSE 50241
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49620: LD_ADDR_EXP 97
49624: PUSH
49625: LD_EXP 97
49629: PPUSH
49630: LD_VAR 0 3
49634: PPUSH
49635: LD_EXP 97
49639: PUSH
49640: LD_VAR 0 3
49644: ARRAY
49645: PUSH
49646: LD_VAR 0 1
49650: DIFF
49651: PPUSH
49652: CALL_OW 1
49656: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49657: LD_ADDR_EXP 90
49661: PUSH
49662: LD_EXP 90
49666: PPUSH
49667: LD_VAR 0 3
49671: PUSH
49672: LD_EXP 90
49676: PUSH
49677: LD_VAR 0 3
49681: ARRAY
49682: PUSH
49683: LD_INT 1
49685: PLUS
49686: PUSH
49687: EMPTY
49688: LIST
49689: LIST
49690: PPUSH
49691: LD_VAR 0 1
49695: PPUSH
49696: CALL 55814 0 3
49700: ST_TO_ADDR
// btype := GetBType ( building ) ;
49701: LD_ADDR_VAR 0 5
49705: PUSH
49706: LD_VAR 0 1
49710: PPUSH
49711: CALL_OW 266
49715: ST_TO_ADDR
// side := GetSide ( building ) ;
49716: LD_ADDR_VAR 0 8
49720: PUSH
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL_OW 255
49730: ST_TO_ADDR
// if btype = b_lab then
49731: LD_VAR 0 5
49735: PUSH
49736: LD_INT 6
49738: EQUAL
49739: IFFALSE 49789
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49741: LD_ADDR_EXP 123
49745: PUSH
49746: LD_EXP 123
49750: PPUSH
49751: LD_VAR 0 3
49755: PUSH
49756: LD_EXP 123
49760: PUSH
49761: LD_VAR 0 3
49765: ARRAY
49766: PUSH
49767: LD_INT 1
49769: PLUS
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PPUSH
49775: LD_VAR 0 1
49779: PPUSH
49780: CALL 55814 0 3
49784: ST_TO_ADDR
// exit ;
49785: POP
49786: POP
49787: GO 50245
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49789: LD_VAR 0 5
49793: PUSH
49794: LD_INT 0
49796: PUSH
49797: LD_INT 2
49799: PUSH
49800: LD_INT 4
49802: PUSH
49803: EMPTY
49804: LIST
49805: LIST
49806: LIST
49807: IN
49808: IFFALSE 49932
// begin if btype = b_armoury then
49810: LD_VAR 0 5
49814: PUSH
49815: LD_INT 4
49817: EQUAL
49818: IFFALSE 49828
// btype := b_barracks ;
49820: LD_ADDR_VAR 0 5
49824: PUSH
49825: LD_INT 5
49827: ST_TO_ADDR
// if btype = b_depot then
49828: LD_VAR 0 5
49832: PUSH
49833: LD_INT 0
49835: EQUAL
49836: IFFALSE 49846
// btype := b_warehouse ;
49838: LD_ADDR_VAR 0 5
49842: PUSH
49843: LD_INT 1
49845: ST_TO_ADDR
// if btype = b_workshop then
49846: LD_VAR 0 5
49850: PUSH
49851: LD_INT 2
49853: EQUAL
49854: IFFALSE 49864
// btype := b_factory ;
49856: LD_ADDR_VAR 0 5
49860: PUSH
49861: LD_INT 3
49863: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49864: LD_VAR 0 5
49868: PPUSH
49869: LD_VAR 0 8
49873: PPUSH
49874: CALL_OW 323
49878: PUSH
49879: LD_INT 1
49881: EQUAL
49882: IFFALSE 49928
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49884: LD_ADDR_EXP 122
49888: PUSH
49889: LD_EXP 122
49893: PPUSH
49894: LD_VAR 0 3
49898: PUSH
49899: LD_EXP 122
49903: PUSH
49904: LD_VAR 0 3
49908: ARRAY
49909: PUSH
49910: LD_INT 1
49912: PLUS
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: PPUSH
49918: LD_VAR 0 1
49922: PPUSH
49923: CALL 55814 0 3
49927: ST_TO_ADDR
// exit ;
49928: POP
49929: POP
49930: GO 50245
// end ; if btype in [ b_bunker , b_turret ] then
49932: LD_VAR 0 5
49936: PUSH
49937: LD_INT 32
49939: PUSH
49940: LD_INT 33
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: IN
49947: IFFALSE 50237
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49949: LD_ADDR_EXP 98
49953: PUSH
49954: LD_EXP 98
49958: PPUSH
49959: LD_VAR 0 3
49963: PUSH
49964: LD_EXP 98
49968: PUSH
49969: LD_VAR 0 3
49973: ARRAY
49974: PUSH
49975: LD_INT 1
49977: PLUS
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: PPUSH
49983: LD_VAR 0 1
49987: PPUSH
49988: CALL 55814 0 3
49992: ST_TO_ADDR
// if btype = b_bunker then
49993: LD_VAR 0 5
49997: PUSH
49998: LD_INT 32
50000: EQUAL
50001: IFFALSE 50237
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50003: LD_ADDR_EXP 99
50007: PUSH
50008: LD_EXP 99
50012: PPUSH
50013: LD_VAR 0 3
50017: PUSH
50018: LD_EXP 99
50022: PUSH
50023: LD_VAR 0 3
50027: ARRAY
50028: PUSH
50029: LD_INT 1
50031: PLUS
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: PPUSH
50037: LD_VAR 0 1
50041: PPUSH
50042: CALL 55814 0 3
50046: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50047: LD_ADDR_VAR 0 6
50051: PUSH
50052: LD_EXP 90
50056: PUSH
50057: LD_VAR 0 3
50061: ARRAY
50062: PPUSH
50063: LD_INT 25
50065: PUSH
50066: LD_INT 1
50068: PUSH
50069: EMPTY
50070: LIST
50071: LIST
50072: PUSH
50073: LD_INT 3
50075: PUSH
50076: LD_INT 54
50078: PUSH
50079: EMPTY
50080: LIST
50081: PUSH
50082: EMPTY
50083: LIST
50084: LIST
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: PPUSH
50090: CALL_OW 72
50094: ST_TO_ADDR
// if tmp then
50095: LD_VAR 0 6
50099: IFFALSE 50105
// exit ;
50101: POP
50102: POP
50103: GO 50245
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50105: LD_ADDR_VAR 0 6
50109: PUSH
50110: LD_EXP 90
50114: PUSH
50115: LD_VAR 0 3
50119: ARRAY
50120: PPUSH
50121: LD_INT 2
50123: PUSH
50124: LD_INT 30
50126: PUSH
50127: LD_INT 4
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PUSH
50134: LD_INT 30
50136: PUSH
50137: LD_INT 5
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: LIST
50148: PPUSH
50149: CALL_OW 72
50153: ST_TO_ADDR
// if not tmp then
50154: LD_VAR 0 6
50158: NOT
50159: IFFALSE 50165
// exit ;
50161: POP
50162: POP
50163: GO 50245
// for j in tmp do
50165: LD_ADDR_VAR 0 4
50169: PUSH
50170: LD_VAR 0 6
50174: PUSH
50175: FOR_IN
50176: IFFALSE 50235
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50178: LD_ADDR_VAR 0 7
50182: PUSH
50183: LD_VAR 0 4
50187: PPUSH
50188: CALL_OW 313
50192: PPUSH
50193: LD_INT 25
50195: PUSH
50196: LD_INT 1
50198: PUSH
50199: EMPTY
50200: LIST
50201: LIST
50202: PPUSH
50203: CALL_OW 72
50207: ST_TO_ADDR
// if units then
50208: LD_VAR 0 7
50212: IFFALSE 50233
// begin ComExitBuilding ( units [ 1 ] ) ;
50214: LD_VAR 0 7
50218: PUSH
50219: LD_INT 1
50221: ARRAY
50222: PPUSH
50223: CALL_OW 122
// exit ;
50227: POP
50228: POP
50229: POP
50230: POP
50231: GO 50245
// end ; end ;
50233: GO 50175
50235: POP
50236: POP
// end ; end ; exit ;
50237: POP
50238: POP
50239: GO 50245
// end ; end ;
50241: GO 49599
50243: POP
50244: POP
// end ;
50245: LD_VAR 0 2
50249: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50250: LD_INT 0
50252: PPUSH
50253: PPUSH
50254: PPUSH
50255: PPUSH
50256: PPUSH
50257: PPUSH
50258: PPUSH
// if not mc_bases or not skirmish then
50259: LD_EXP 90
50263: NOT
50264: PUSH
50265: LD_EXP 88
50269: NOT
50270: OR
50271: IFFALSE 50275
// exit ;
50273: GO 50506
// btype := GetBType ( building ) ;
50275: LD_ADDR_VAR 0 6
50279: PUSH
50280: LD_VAR 0 1
50284: PPUSH
50285: CALL_OW 266
50289: ST_TO_ADDR
// x := GetX ( building ) ;
50290: LD_ADDR_VAR 0 7
50294: PUSH
50295: LD_VAR 0 1
50299: PPUSH
50300: CALL_OW 250
50304: ST_TO_ADDR
// y := GetY ( building ) ;
50305: LD_ADDR_VAR 0 8
50309: PUSH
50310: LD_VAR 0 1
50314: PPUSH
50315: CALL_OW 251
50319: ST_TO_ADDR
// d := GetDir ( building ) ;
50320: LD_ADDR_VAR 0 9
50324: PUSH
50325: LD_VAR 0 1
50329: PPUSH
50330: CALL_OW 254
50334: ST_TO_ADDR
// for i = 1 to mc_bases do
50335: LD_ADDR_VAR 0 4
50339: PUSH
50340: DOUBLE
50341: LD_INT 1
50343: DEC
50344: ST_TO_ADDR
50345: LD_EXP 90
50349: PUSH
50350: FOR_TO
50351: IFFALSE 50504
// begin if not mc_build_list [ i ] then
50353: LD_EXP 95
50357: PUSH
50358: LD_VAR 0 4
50362: ARRAY
50363: NOT
50364: IFFALSE 50368
// continue ;
50366: GO 50350
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50368: LD_VAR 0 6
50372: PUSH
50373: LD_VAR 0 7
50377: PUSH
50378: LD_VAR 0 8
50382: PUSH
50383: LD_VAR 0 9
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: LIST
50392: LIST
50393: PPUSH
50394: LD_EXP 95
50398: PUSH
50399: LD_VAR 0 4
50403: ARRAY
50404: PUSH
50405: LD_INT 1
50407: ARRAY
50408: PPUSH
50409: CALL 61983 0 2
50413: IFFALSE 50502
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50415: LD_ADDR_EXP 95
50419: PUSH
50420: LD_EXP 95
50424: PPUSH
50425: LD_VAR 0 4
50429: PPUSH
50430: LD_EXP 95
50434: PUSH
50435: LD_VAR 0 4
50439: ARRAY
50440: PPUSH
50441: LD_INT 1
50443: PPUSH
50444: CALL_OW 3
50448: PPUSH
50449: CALL_OW 1
50453: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50454: LD_ADDR_EXP 97
50458: PUSH
50459: LD_EXP 97
50463: PPUSH
50464: LD_VAR 0 4
50468: PUSH
50469: LD_EXP 97
50473: PUSH
50474: LD_VAR 0 4
50478: ARRAY
50479: PUSH
50480: LD_INT 1
50482: PLUS
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PPUSH
50488: LD_VAR 0 1
50492: PPUSH
50493: CALL 55814 0 3
50497: ST_TO_ADDR
// exit ;
50498: POP
50499: POP
50500: GO 50506
// end ; end ;
50502: GO 50350
50504: POP
50505: POP
// end ;
50506: LD_VAR 0 3
50510: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50511: LD_INT 0
50513: PPUSH
50514: PPUSH
50515: PPUSH
// if not mc_bases or not skirmish then
50516: LD_EXP 90
50520: NOT
50521: PUSH
50522: LD_EXP 88
50526: NOT
50527: OR
50528: IFFALSE 50532
// exit ;
50530: GO 50722
// for i = 1 to mc_bases do
50532: LD_ADDR_VAR 0 4
50536: PUSH
50537: DOUBLE
50538: LD_INT 1
50540: DEC
50541: ST_TO_ADDR
50542: LD_EXP 90
50546: PUSH
50547: FOR_TO
50548: IFFALSE 50635
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50550: LD_VAR 0 1
50554: PUSH
50555: LD_EXP 98
50559: PUSH
50560: LD_VAR 0 4
50564: ARRAY
50565: IN
50566: PUSH
50567: LD_VAR 0 1
50571: PUSH
50572: LD_EXP 99
50576: PUSH
50577: LD_VAR 0 4
50581: ARRAY
50582: IN
50583: NOT
50584: AND
50585: IFFALSE 50633
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50587: LD_ADDR_EXP 99
50591: PUSH
50592: LD_EXP 99
50596: PPUSH
50597: LD_VAR 0 4
50601: PUSH
50602: LD_EXP 99
50606: PUSH
50607: LD_VAR 0 4
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: PLUS
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: PPUSH
50621: LD_VAR 0 1
50625: PPUSH
50626: CALL 55814 0 3
50630: ST_TO_ADDR
// break ;
50631: GO 50635
// end ; end ;
50633: GO 50547
50635: POP
50636: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50637: LD_VAR 0 1
50641: PPUSH
50642: CALL_OW 257
50646: PUSH
50647: LD_EXP 116
50651: IN
50652: PUSH
50653: LD_VAR 0 1
50657: PPUSH
50658: CALL_OW 266
50662: PUSH
50663: LD_INT 5
50665: EQUAL
50666: AND
50667: PUSH
50668: LD_VAR 0 2
50672: PPUSH
50673: CALL_OW 110
50677: PUSH
50678: LD_INT 18
50680: NONEQUAL
50681: AND
50682: IFFALSE 50722
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50684: LD_VAR 0 2
50688: PPUSH
50689: CALL_OW 257
50693: PUSH
50694: LD_INT 5
50696: PUSH
50697: LD_INT 8
50699: PUSH
50700: LD_INT 9
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: LIST
50707: IN
50708: IFFALSE 50722
// SetClass ( unit , 1 ) ;
50710: LD_VAR 0 2
50714: PPUSH
50715: LD_INT 1
50717: PPUSH
50718: CALL_OW 336
// end ;
50722: LD_VAR 0 3
50726: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50727: LD_INT 0
50729: PPUSH
50730: PPUSH
// if not mc_bases or not skirmish then
50731: LD_EXP 90
50735: NOT
50736: PUSH
50737: LD_EXP 88
50741: NOT
50742: OR
50743: IFFALSE 50747
// exit ;
50745: GO 50863
// if GetLives ( abandoned_vehicle ) > 250 then
50747: LD_VAR 0 2
50751: PPUSH
50752: CALL_OW 256
50756: PUSH
50757: LD_INT 250
50759: GREATER
50760: IFFALSE 50764
// exit ;
50762: GO 50863
// for i = 1 to mc_bases do
50764: LD_ADDR_VAR 0 6
50768: PUSH
50769: DOUBLE
50770: LD_INT 1
50772: DEC
50773: ST_TO_ADDR
50774: LD_EXP 90
50778: PUSH
50779: FOR_TO
50780: IFFALSE 50861
// begin if driver in mc_bases [ i ] then
50782: LD_VAR 0 1
50786: PUSH
50787: LD_EXP 90
50791: PUSH
50792: LD_VAR 0 6
50796: ARRAY
50797: IN
50798: IFFALSE 50859
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50800: LD_VAR 0 1
50804: PPUSH
50805: LD_EXP 90
50809: PUSH
50810: LD_VAR 0 6
50814: ARRAY
50815: PPUSH
50816: LD_INT 2
50818: PUSH
50819: LD_INT 30
50821: PUSH
50822: LD_INT 0
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: PUSH
50829: LD_INT 30
50831: PUSH
50832: LD_INT 1
50834: PUSH
50835: EMPTY
50836: LIST
50837: LIST
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: LIST
50843: PPUSH
50844: CALL_OW 72
50848: PUSH
50849: LD_INT 1
50851: ARRAY
50852: PPUSH
50853: CALL 87680 0 2
// break ;
50857: GO 50861
// end ; end ;
50859: GO 50779
50861: POP
50862: POP
// end ; end_of_file
50863: LD_VAR 0 5
50867: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50868: LD_INT 0
50870: PPUSH
50871: PPUSH
// if exist_mode then
50872: LD_VAR 0 2
50876: IFFALSE 50901
// unit := CreateCharacter ( prefix & ident ) else
50878: LD_ADDR_VAR 0 5
50882: PUSH
50883: LD_VAR 0 3
50887: PUSH
50888: LD_VAR 0 1
50892: STR
50893: PPUSH
50894: CALL_OW 34
50898: ST_TO_ADDR
50899: GO 50916
// unit := NewCharacter ( ident ) ;
50901: LD_ADDR_VAR 0 5
50905: PUSH
50906: LD_VAR 0 1
50910: PPUSH
50911: CALL_OW 25
50915: ST_TO_ADDR
// result := unit ;
50916: LD_ADDR_VAR 0 4
50920: PUSH
50921: LD_VAR 0 5
50925: ST_TO_ADDR
// end ;
50926: LD_VAR 0 4
50930: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50931: LD_INT 0
50933: PPUSH
50934: PPUSH
// if not side or not nation then
50935: LD_VAR 0 1
50939: NOT
50940: PUSH
50941: LD_VAR 0 2
50945: NOT
50946: OR
50947: IFFALSE 50951
// exit ;
50949: GO 51715
// case nation of nation_american :
50951: LD_VAR 0 2
50955: PUSH
50956: LD_INT 1
50958: DOUBLE
50959: EQUAL
50960: IFTRUE 50964
50962: GO 51178
50964: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50965: LD_ADDR_VAR 0 4
50969: PUSH
50970: LD_INT 35
50972: PUSH
50973: LD_INT 45
50975: PUSH
50976: LD_INT 46
50978: PUSH
50979: LD_INT 47
50981: PUSH
50982: LD_INT 82
50984: PUSH
50985: LD_INT 83
50987: PUSH
50988: LD_INT 84
50990: PUSH
50991: LD_INT 85
50993: PUSH
50994: LD_INT 86
50996: PUSH
50997: LD_INT 1
50999: PUSH
51000: LD_INT 2
51002: PUSH
51003: LD_INT 6
51005: PUSH
51006: LD_INT 15
51008: PUSH
51009: LD_INT 16
51011: PUSH
51012: LD_INT 7
51014: PUSH
51015: LD_INT 12
51017: PUSH
51018: LD_INT 13
51020: PUSH
51021: LD_INT 10
51023: PUSH
51024: LD_INT 14
51026: PUSH
51027: LD_INT 20
51029: PUSH
51030: LD_INT 21
51032: PUSH
51033: LD_INT 22
51035: PUSH
51036: LD_INT 25
51038: PUSH
51039: LD_INT 32
51041: PUSH
51042: LD_INT 27
51044: PUSH
51045: LD_INT 36
51047: PUSH
51048: LD_INT 69
51050: PUSH
51051: LD_INT 39
51053: PUSH
51054: LD_INT 34
51056: PUSH
51057: LD_INT 40
51059: PUSH
51060: LD_INT 48
51062: PUSH
51063: LD_INT 49
51065: PUSH
51066: LD_INT 50
51068: PUSH
51069: LD_INT 51
51071: PUSH
51072: LD_INT 52
51074: PUSH
51075: LD_INT 53
51077: PUSH
51078: LD_INT 54
51080: PUSH
51081: LD_INT 55
51083: PUSH
51084: LD_INT 56
51086: PUSH
51087: LD_INT 57
51089: PUSH
51090: LD_INT 58
51092: PUSH
51093: LD_INT 59
51095: PUSH
51096: LD_INT 60
51098: PUSH
51099: LD_INT 61
51101: PUSH
51102: LD_INT 62
51104: PUSH
51105: LD_INT 80
51107: PUSH
51108: LD_INT 82
51110: PUSH
51111: LD_INT 83
51113: PUSH
51114: LD_INT 84
51116: PUSH
51117: LD_INT 85
51119: PUSH
51120: LD_INT 86
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: LIST
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: ST_TO_ADDR
51176: GO 51639
51178: LD_INT 2
51180: DOUBLE
51181: EQUAL
51182: IFTRUE 51186
51184: GO 51408
51186: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51187: LD_ADDR_VAR 0 4
51191: PUSH
51192: LD_INT 35
51194: PUSH
51195: LD_INT 45
51197: PUSH
51198: LD_INT 46
51200: PUSH
51201: LD_INT 47
51203: PUSH
51204: LD_INT 82
51206: PUSH
51207: LD_INT 83
51209: PUSH
51210: LD_INT 84
51212: PUSH
51213: LD_INT 85
51215: PUSH
51216: LD_INT 87
51218: PUSH
51219: LD_INT 70
51221: PUSH
51222: LD_INT 1
51224: PUSH
51225: LD_INT 11
51227: PUSH
51228: LD_INT 3
51230: PUSH
51231: LD_INT 4
51233: PUSH
51234: LD_INT 5
51236: PUSH
51237: LD_INT 6
51239: PUSH
51240: LD_INT 15
51242: PUSH
51243: LD_INT 18
51245: PUSH
51246: LD_INT 7
51248: PUSH
51249: LD_INT 17
51251: PUSH
51252: LD_INT 8
51254: PUSH
51255: LD_INT 20
51257: PUSH
51258: LD_INT 21
51260: PUSH
51261: LD_INT 22
51263: PUSH
51264: LD_INT 72
51266: PUSH
51267: LD_INT 26
51269: PUSH
51270: LD_INT 69
51272: PUSH
51273: LD_INT 39
51275: PUSH
51276: LD_INT 40
51278: PUSH
51279: LD_INT 41
51281: PUSH
51282: LD_INT 42
51284: PUSH
51285: LD_INT 43
51287: PUSH
51288: LD_INT 48
51290: PUSH
51291: LD_INT 49
51293: PUSH
51294: LD_INT 50
51296: PUSH
51297: LD_INT 51
51299: PUSH
51300: LD_INT 52
51302: PUSH
51303: LD_INT 53
51305: PUSH
51306: LD_INT 54
51308: PUSH
51309: LD_INT 55
51311: PUSH
51312: LD_INT 56
51314: PUSH
51315: LD_INT 60
51317: PUSH
51318: LD_INT 61
51320: PUSH
51321: LD_INT 62
51323: PUSH
51324: LD_INT 66
51326: PUSH
51327: LD_INT 67
51329: PUSH
51330: LD_INT 68
51332: PUSH
51333: LD_INT 81
51335: PUSH
51336: LD_INT 82
51338: PUSH
51339: LD_INT 83
51341: PUSH
51342: LD_INT 84
51344: PUSH
51345: LD_INT 85
51347: PUSH
51348: LD_INT 87
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: LIST
51358: LIST
51359: LIST
51360: LIST
51361: LIST
51362: LIST
51363: LIST
51364: LIST
51365: LIST
51366: LIST
51367: LIST
51368: LIST
51369: LIST
51370: LIST
51371: LIST
51372: LIST
51373: LIST
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: LIST
51402: LIST
51403: LIST
51404: LIST
51405: ST_TO_ADDR
51406: GO 51639
51408: LD_INT 3
51410: DOUBLE
51411: EQUAL
51412: IFTRUE 51416
51414: GO 51638
51416: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51417: LD_ADDR_VAR 0 4
51421: PUSH
51422: LD_INT 46
51424: PUSH
51425: LD_INT 47
51427: PUSH
51428: LD_INT 1
51430: PUSH
51431: LD_INT 2
51433: PUSH
51434: LD_INT 82
51436: PUSH
51437: LD_INT 83
51439: PUSH
51440: LD_INT 84
51442: PUSH
51443: LD_INT 85
51445: PUSH
51446: LD_INT 86
51448: PUSH
51449: LD_INT 11
51451: PUSH
51452: LD_INT 9
51454: PUSH
51455: LD_INT 20
51457: PUSH
51458: LD_INT 19
51460: PUSH
51461: LD_INT 21
51463: PUSH
51464: LD_INT 24
51466: PUSH
51467: LD_INT 22
51469: PUSH
51470: LD_INT 25
51472: PUSH
51473: LD_INT 28
51475: PUSH
51476: LD_INT 29
51478: PUSH
51479: LD_INT 30
51481: PUSH
51482: LD_INT 31
51484: PUSH
51485: LD_INT 37
51487: PUSH
51488: LD_INT 38
51490: PUSH
51491: LD_INT 32
51493: PUSH
51494: LD_INT 27
51496: PUSH
51497: LD_INT 33
51499: PUSH
51500: LD_INT 69
51502: PUSH
51503: LD_INT 39
51505: PUSH
51506: LD_INT 34
51508: PUSH
51509: LD_INT 40
51511: PUSH
51512: LD_INT 71
51514: PUSH
51515: LD_INT 23
51517: PUSH
51518: LD_INT 44
51520: PUSH
51521: LD_INT 48
51523: PUSH
51524: LD_INT 49
51526: PUSH
51527: LD_INT 50
51529: PUSH
51530: LD_INT 51
51532: PUSH
51533: LD_INT 52
51535: PUSH
51536: LD_INT 53
51538: PUSH
51539: LD_INT 54
51541: PUSH
51542: LD_INT 55
51544: PUSH
51545: LD_INT 56
51547: PUSH
51548: LD_INT 57
51550: PUSH
51551: LD_INT 58
51553: PUSH
51554: LD_INT 59
51556: PUSH
51557: LD_INT 63
51559: PUSH
51560: LD_INT 64
51562: PUSH
51563: LD_INT 65
51565: PUSH
51566: LD_INT 82
51568: PUSH
51569: LD_INT 83
51571: PUSH
51572: LD_INT 84
51574: PUSH
51575: LD_INT 85
51577: PUSH
51578: LD_INT 86
51580: PUSH
51581: EMPTY
51582: LIST
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: LIST
51589: LIST
51590: LIST
51591: LIST
51592: LIST
51593: LIST
51594: LIST
51595: LIST
51596: LIST
51597: LIST
51598: LIST
51599: LIST
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: ST_TO_ADDR
51636: GO 51639
51638: POP
// if state > - 1 and state < 3 then
51639: LD_VAR 0 3
51643: PUSH
51644: LD_INT 1
51646: NEG
51647: GREATER
51648: PUSH
51649: LD_VAR 0 3
51653: PUSH
51654: LD_INT 3
51656: LESS
51657: AND
51658: IFFALSE 51715
// for i in result do
51660: LD_ADDR_VAR 0 5
51664: PUSH
51665: LD_VAR 0 4
51669: PUSH
51670: FOR_IN
51671: IFFALSE 51713
// if GetTech ( i , side ) <> state then
51673: LD_VAR 0 5
51677: PPUSH
51678: LD_VAR 0 1
51682: PPUSH
51683: CALL_OW 321
51687: PUSH
51688: LD_VAR 0 3
51692: NONEQUAL
51693: IFFALSE 51711
// result := result diff i ;
51695: LD_ADDR_VAR 0 4
51699: PUSH
51700: LD_VAR 0 4
51704: PUSH
51705: LD_VAR 0 5
51709: DIFF
51710: ST_TO_ADDR
51711: GO 51670
51713: POP
51714: POP
// end ;
51715: LD_VAR 0 4
51719: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51720: LD_INT 0
51722: PPUSH
51723: PPUSH
51724: PPUSH
// result := true ;
51725: LD_ADDR_VAR 0 3
51729: PUSH
51730: LD_INT 1
51732: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51733: LD_ADDR_VAR 0 5
51737: PUSH
51738: LD_VAR 0 2
51742: PPUSH
51743: CALL_OW 480
51747: ST_TO_ADDR
// if not tmp then
51748: LD_VAR 0 5
51752: NOT
51753: IFFALSE 51757
// exit ;
51755: GO 51806
// for i in tmp do
51757: LD_ADDR_VAR 0 4
51761: PUSH
51762: LD_VAR 0 5
51766: PUSH
51767: FOR_IN
51768: IFFALSE 51804
// if GetTech ( i , side ) <> state_researched then
51770: LD_VAR 0 4
51774: PPUSH
51775: LD_VAR 0 1
51779: PPUSH
51780: CALL_OW 321
51784: PUSH
51785: LD_INT 2
51787: NONEQUAL
51788: IFFALSE 51802
// begin result := false ;
51790: LD_ADDR_VAR 0 3
51794: PUSH
51795: LD_INT 0
51797: ST_TO_ADDR
// exit ;
51798: POP
51799: POP
51800: GO 51806
// end ;
51802: GO 51767
51804: POP
51805: POP
// end ;
51806: LD_VAR 0 3
51810: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51811: LD_INT 0
51813: PPUSH
51814: PPUSH
51815: PPUSH
51816: PPUSH
51817: PPUSH
51818: PPUSH
51819: PPUSH
51820: PPUSH
51821: PPUSH
51822: PPUSH
51823: PPUSH
51824: PPUSH
51825: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51826: LD_VAR 0 1
51830: NOT
51831: PUSH
51832: LD_VAR 0 1
51836: PPUSH
51837: CALL_OW 257
51841: PUSH
51842: LD_INT 9
51844: NONEQUAL
51845: OR
51846: IFFALSE 51850
// exit ;
51848: GO 52423
// side := GetSide ( unit ) ;
51850: LD_ADDR_VAR 0 9
51854: PUSH
51855: LD_VAR 0 1
51859: PPUSH
51860: CALL_OW 255
51864: ST_TO_ADDR
// tech_space := tech_spacanom ;
51865: LD_ADDR_VAR 0 12
51869: PUSH
51870: LD_INT 29
51872: ST_TO_ADDR
// tech_time := tech_taurad ;
51873: LD_ADDR_VAR 0 13
51877: PUSH
51878: LD_INT 28
51880: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51881: LD_ADDR_VAR 0 11
51885: PUSH
51886: LD_VAR 0 1
51890: PPUSH
51891: CALL_OW 310
51895: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51896: LD_VAR 0 11
51900: PPUSH
51901: CALL_OW 247
51905: PUSH
51906: LD_INT 2
51908: EQUAL
51909: IFFALSE 51913
// exit ;
51911: GO 52423
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51913: LD_ADDR_VAR 0 8
51917: PUSH
51918: LD_INT 81
51920: PUSH
51921: LD_VAR 0 9
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: PUSH
51930: LD_INT 3
51932: PUSH
51933: LD_INT 21
51935: PUSH
51936: LD_INT 3
51938: PUSH
51939: EMPTY
51940: LIST
51941: LIST
51942: PUSH
51943: EMPTY
51944: LIST
51945: LIST
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: PPUSH
51951: CALL_OW 69
51955: ST_TO_ADDR
// if not tmp then
51956: LD_VAR 0 8
51960: NOT
51961: IFFALSE 51965
// exit ;
51963: GO 52423
// if in_unit then
51965: LD_VAR 0 11
51969: IFFALSE 51993
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51971: LD_ADDR_VAR 0 10
51975: PUSH
51976: LD_VAR 0 8
51980: PPUSH
51981: LD_VAR 0 11
51985: PPUSH
51986: CALL_OW 74
51990: ST_TO_ADDR
51991: GO 52013
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51993: LD_ADDR_VAR 0 10
51997: PUSH
51998: LD_VAR 0 8
52002: PPUSH
52003: LD_VAR 0 1
52007: PPUSH
52008: CALL_OW 74
52012: ST_TO_ADDR
// if not enemy then
52013: LD_VAR 0 10
52017: NOT
52018: IFFALSE 52022
// exit ;
52020: GO 52423
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52022: LD_VAR 0 11
52026: PUSH
52027: LD_VAR 0 11
52031: PPUSH
52032: LD_VAR 0 10
52036: PPUSH
52037: CALL_OW 296
52041: PUSH
52042: LD_INT 13
52044: GREATER
52045: AND
52046: PUSH
52047: LD_VAR 0 1
52051: PPUSH
52052: LD_VAR 0 10
52056: PPUSH
52057: CALL_OW 296
52061: PUSH
52062: LD_INT 12
52064: GREATER
52065: OR
52066: IFFALSE 52070
// exit ;
52068: GO 52423
// missile := [ 1 ] ;
52070: LD_ADDR_VAR 0 14
52074: PUSH
52075: LD_INT 1
52077: PUSH
52078: EMPTY
52079: LIST
52080: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52081: LD_VAR 0 9
52085: PPUSH
52086: LD_VAR 0 12
52090: PPUSH
52091: CALL_OW 325
52095: IFFALSE 52124
// missile := Insert ( missile , missile + 1 , 2 ) ;
52097: LD_ADDR_VAR 0 14
52101: PUSH
52102: LD_VAR 0 14
52106: PPUSH
52107: LD_VAR 0 14
52111: PUSH
52112: LD_INT 1
52114: PLUS
52115: PPUSH
52116: LD_INT 2
52118: PPUSH
52119: CALL_OW 2
52123: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52124: LD_VAR 0 9
52128: PPUSH
52129: LD_VAR 0 13
52133: PPUSH
52134: CALL_OW 325
52138: PUSH
52139: LD_VAR 0 10
52143: PPUSH
52144: CALL_OW 255
52148: PPUSH
52149: LD_VAR 0 13
52153: PPUSH
52154: CALL_OW 325
52158: NOT
52159: AND
52160: IFFALSE 52189
// missile := Insert ( missile , missile + 1 , 3 ) ;
52162: LD_ADDR_VAR 0 14
52166: PUSH
52167: LD_VAR 0 14
52171: PPUSH
52172: LD_VAR 0 14
52176: PUSH
52177: LD_INT 1
52179: PLUS
52180: PPUSH
52181: LD_INT 3
52183: PPUSH
52184: CALL_OW 2
52188: ST_TO_ADDR
// if missile < 2 then
52189: LD_VAR 0 14
52193: PUSH
52194: LD_INT 2
52196: LESS
52197: IFFALSE 52201
// exit ;
52199: GO 52423
// x := GetX ( enemy ) ;
52201: LD_ADDR_VAR 0 4
52205: PUSH
52206: LD_VAR 0 10
52210: PPUSH
52211: CALL_OW 250
52215: ST_TO_ADDR
// y := GetY ( enemy ) ;
52216: LD_ADDR_VAR 0 5
52220: PUSH
52221: LD_VAR 0 10
52225: PPUSH
52226: CALL_OW 251
52230: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52231: LD_ADDR_VAR 0 6
52235: PUSH
52236: LD_VAR 0 4
52240: PUSH
52241: LD_INT 1
52243: NEG
52244: PPUSH
52245: LD_INT 1
52247: PPUSH
52248: CALL_OW 12
52252: PLUS
52253: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52254: LD_ADDR_VAR 0 7
52258: PUSH
52259: LD_VAR 0 5
52263: PUSH
52264: LD_INT 1
52266: NEG
52267: PPUSH
52268: LD_INT 1
52270: PPUSH
52271: CALL_OW 12
52275: PLUS
52276: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52277: LD_VAR 0 6
52281: PPUSH
52282: LD_VAR 0 7
52286: PPUSH
52287: CALL_OW 488
52291: NOT
52292: IFFALSE 52314
// begin _x := x ;
52294: LD_ADDR_VAR 0 6
52298: PUSH
52299: LD_VAR 0 4
52303: ST_TO_ADDR
// _y := y ;
52304: LD_ADDR_VAR 0 7
52308: PUSH
52309: LD_VAR 0 5
52313: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52314: LD_ADDR_VAR 0 3
52318: PUSH
52319: LD_INT 1
52321: PPUSH
52322: LD_VAR 0 14
52326: PPUSH
52327: CALL_OW 12
52331: ST_TO_ADDR
// case i of 1 :
52332: LD_VAR 0 3
52336: PUSH
52337: LD_INT 1
52339: DOUBLE
52340: EQUAL
52341: IFTRUE 52345
52343: GO 52362
52345: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52346: LD_VAR 0 1
52350: PPUSH
52351: LD_VAR 0 10
52355: PPUSH
52356: CALL_OW 115
52360: GO 52423
52362: LD_INT 2
52364: DOUBLE
52365: EQUAL
52366: IFTRUE 52370
52368: GO 52392
52370: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52371: LD_VAR 0 1
52375: PPUSH
52376: LD_VAR 0 6
52380: PPUSH
52381: LD_VAR 0 7
52385: PPUSH
52386: CALL_OW 153
52390: GO 52423
52392: LD_INT 3
52394: DOUBLE
52395: EQUAL
52396: IFTRUE 52400
52398: GO 52422
52400: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52401: LD_VAR 0 1
52405: PPUSH
52406: LD_VAR 0 6
52410: PPUSH
52411: LD_VAR 0 7
52415: PPUSH
52416: CALL_OW 154
52420: GO 52423
52422: POP
// end ;
52423: LD_VAR 0 2
52427: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52428: LD_INT 0
52430: PPUSH
52431: PPUSH
52432: PPUSH
52433: PPUSH
52434: PPUSH
52435: PPUSH
// if not unit or not building then
52436: LD_VAR 0 1
52440: NOT
52441: PUSH
52442: LD_VAR 0 2
52446: NOT
52447: OR
52448: IFFALSE 52452
// exit ;
52450: GO 52610
// x := GetX ( building ) ;
52452: LD_ADDR_VAR 0 5
52456: PUSH
52457: LD_VAR 0 2
52461: PPUSH
52462: CALL_OW 250
52466: ST_TO_ADDR
// y := GetY ( building ) ;
52467: LD_ADDR_VAR 0 6
52471: PUSH
52472: LD_VAR 0 2
52476: PPUSH
52477: CALL_OW 251
52481: ST_TO_ADDR
// for i = 0 to 5 do
52482: LD_ADDR_VAR 0 4
52486: PUSH
52487: DOUBLE
52488: LD_INT 0
52490: DEC
52491: ST_TO_ADDR
52492: LD_INT 5
52494: PUSH
52495: FOR_TO
52496: IFFALSE 52608
// begin _x := ShiftX ( x , i , 3 ) ;
52498: LD_ADDR_VAR 0 7
52502: PUSH
52503: LD_VAR 0 5
52507: PPUSH
52508: LD_VAR 0 4
52512: PPUSH
52513: LD_INT 3
52515: PPUSH
52516: CALL_OW 272
52520: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52521: LD_ADDR_VAR 0 8
52525: PUSH
52526: LD_VAR 0 6
52530: PPUSH
52531: LD_VAR 0 4
52535: PPUSH
52536: LD_INT 3
52538: PPUSH
52539: CALL_OW 273
52543: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52544: LD_VAR 0 7
52548: PPUSH
52549: LD_VAR 0 8
52553: PPUSH
52554: CALL_OW 488
52558: NOT
52559: IFFALSE 52563
// continue ;
52561: GO 52495
// if HexInfo ( _x , _y ) = 0 then
52563: LD_VAR 0 7
52567: PPUSH
52568: LD_VAR 0 8
52572: PPUSH
52573: CALL_OW 428
52577: PUSH
52578: LD_INT 0
52580: EQUAL
52581: IFFALSE 52606
// begin ComMoveXY ( unit , _x , _y ) ;
52583: LD_VAR 0 1
52587: PPUSH
52588: LD_VAR 0 7
52592: PPUSH
52593: LD_VAR 0 8
52597: PPUSH
52598: CALL_OW 111
// exit ;
52602: POP
52603: POP
52604: GO 52610
// end ; end ;
52606: GO 52495
52608: POP
52609: POP
// end ;
52610: LD_VAR 0 3
52614: RET
// export function ScanBase ( side , base_area ) ; begin
52615: LD_INT 0
52617: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52618: LD_ADDR_VAR 0 3
52622: PUSH
52623: LD_VAR 0 2
52627: PPUSH
52628: LD_INT 81
52630: PUSH
52631: LD_VAR 0 1
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: PPUSH
52640: CALL_OW 70
52644: ST_TO_ADDR
// end ;
52645: LD_VAR 0 3
52649: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52650: LD_INT 0
52652: PPUSH
52653: PPUSH
52654: PPUSH
52655: PPUSH
// result := false ;
52656: LD_ADDR_VAR 0 2
52660: PUSH
52661: LD_INT 0
52663: ST_TO_ADDR
// side := GetSide ( unit ) ;
52664: LD_ADDR_VAR 0 3
52668: PUSH
52669: LD_VAR 0 1
52673: PPUSH
52674: CALL_OW 255
52678: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52679: LD_ADDR_VAR 0 4
52683: PUSH
52684: LD_VAR 0 1
52688: PPUSH
52689: CALL_OW 248
52693: ST_TO_ADDR
// case nat of 1 :
52694: LD_VAR 0 4
52698: PUSH
52699: LD_INT 1
52701: DOUBLE
52702: EQUAL
52703: IFTRUE 52707
52705: GO 52718
52707: POP
// tech := tech_lassight ; 2 :
52708: LD_ADDR_VAR 0 5
52712: PUSH
52713: LD_INT 12
52715: ST_TO_ADDR
52716: GO 52757
52718: LD_INT 2
52720: DOUBLE
52721: EQUAL
52722: IFTRUE 52726
52724: GO 52737
52726: POP
// tech := tech_mortar ; 3 :
52727: LD_ADDR_VAR 0 5
52731: PUSH
52732: LD_INT 41
52734: ST_TO_ADDR
52735: GO 52757
52737: LD_INT 3
52739: DOUBLE
52740: EQUAL
52741: IFTRUE 52745
52743: GO 52756
52745: POP
// tech := tech_bazooka ; end ;
52746: LD_ADDR_VAR 0 5
52750: PUSH
52751: LD_INT 44
52753: ST_TO_ADDR
52754: GO 52757
52756: POP
// if Researched ( side , tech ) then
52757: LD_VAR 0 3
52761: PPUSH
52762: LD_VAR 0 5
52766: PPUSH
52767: CALL_OW 325
52771: IFFALSE 52798
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52773: LD_ADDR_VAR 0 2
52777: PUSH
52778: LD_INT 5
52780: PUSH
52781: LD_INT 8
52783: PUSH
52784: LD_INT 9
52786: PUSH
52787: EMPTY
52788: LIST
52789: LIST
52790: LIST
52791: PUSH
52792: LD_VAR 0 4
52796: ARRAY
52797: ST_TO_ADDR
// end ;
52798: LD_VAR 0 2
52802: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52803: LD_INT 0
52805: PPUSH
52806: PPUSH
52807: PPUSH
// if not mines then
52808: LD_VAR 0 2
52812: NOT
52813: IFFALSE 52817
// exit ;
52815: GO 52961
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52817: LD_ADDR_VAR 0 5
52821: PUSH
52822: LD_INT 81
52824: PUSH
52825: LD_VAR 0 1
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: PUSH
52834: LD_INT 3
52836: PUSH
52837: LD_INT 21
52839: PUSH
52840: LD_INT 3
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: PPUSH
52855: CALL_OW 69
52859: ST_TO_ADDR
// for i in mines do
52860: LD_ADDR_VAR 0 4
52864: PUSH
52865: LD_VAR 0 2
52869: PUSH
52870: FOR_IN
52871: IFFALSE 52959
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52873: LD_VAR 0 4
52877: PUSH
52878: LD_INT 1
52880: ARRAY
52881: PPUSH
52882: LD_VAR 0 4
52886: PUSH
52887: LD_INT 2
52889: ARRAY
52890: PPUSH
52891: CALL_OW 458
52895: NOT
52896: IFFALSE 52900
// continue ;
52898: GO 52870
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52900: LD_VAR 0 4
52904: PUSH
52905: LD_INT 1
52907: ARRAY
52908: PPUSH
52909: LD_VAR 0 4
52913: PUSH
52914: LD_INT 2
52916: ARRAY
52917: PPUSH
52918: CALL_OW 428
52922: PUSH
52923: LD_VAR 0 5
52927: IN
52928: IFFALSE 52957
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52930: LD_VAR 0 4
52934: PUSH
52935: LD_INT 1
52937: ARRAY
52938: PPUSH
52939: LD_VAR 0 4
52943: PUSH
52944: LD_INT 2
52946: ARRAY
52947: PPUSH
52948: LD_VAR 0 1
52952: PPUSH
52953: CALL_OW 456
// end ;
52957: GO 52870
52959: POP
52960: POP
// end ;
52961: LD_VAR 0 3
52965: RET
// export function Count ( array ) ; var i ; begin
52966: LD_INT 0
52968: PPUSH
52969: PPUSH
// result := 0 ;
52970: LD_ADDR_VAR 0 2
52974: PUSH
52975: LD_INT 0
52977: ST_TO_ADDR
// for i in array do
52978: LD_ADDR_VAR 0 3
52982: PUSH
52983: LD_VAR 0 1
52987: PUSH
52988: FOR_IN
52989: IFFALSE 53013
// if i then
52991: LD_VAR 0 3
52995: IFFALSE 53011
// result := result + 1 ;
52997: LD_ADDR_VAR 0 2
53001: PUSH
53002: LD_VAR 0 2
53006: PUSH
53007: LD_INT 1
53009: PLUS
53010: ST_TO_ADDR
53011: GO 52988
53013: POP
53014: POP
// end ;
53015: LD_VAR 0 2
53019: RET
// export function IsEmpty ( building ) ; begin
53020: LD_INT 0
53022: PPUSH
// if not building then
53023: LD_VAR 0 1
53027: NOT
53028: IFFALSE 53032
// exit ;
53030: GO 53075
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53032: LD_ADDR_VAR 0 2
53036: PUSH
53037: LD_VAR 0 1
53041: PUSH
53042: LD_INT 22
53044: PUSH
53045: LD_VAR 0 1
53049: PPUSH
53050: CALL_OW 255
53054: PUSH
53055: EMPTY
53056: LIST
53057: LIST
53058: PUSH
53059: LD_INT 58
53061: PUSH
53062: EMPTY
53063: LIST
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: PPUSH
53069: CALL_OW 69
53073: IN
53074: ST_TO_ADDR
// end ;
53075: LD_VAR 0 2
53079: RET
// export function IsNotFull ( building ) ; begin
53080: LD_INT 0
53082: PPUSH
// if not building then
53083: LD_VAR 0 1
53087: NOT
53088: IFFALSE 53092
// exit ;
53090: GO 53111
// result := UnitsInside ( building ) < 6 ;
53092: LD_ADDR_VAR 0 2
53096: PUSH
53097: LD_VAR 0 1
53101: PPUSH
53102: CALL_OW 313
53106: PUSH
53107: LD_INT 6
53109: LESS
53110: ST_TO_ADDR
// end ;
53111: LD_VAR 0 2
53115: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
53120: PPUSH
53121: PPUSH
// tmp := [ ] ;
53122: LD_ADDR_VAR 0 3
53126: PUSH
53127: EMPTY
53128: ST_TO_ADDR
// list := [ ] ;
53129: LD_ADDR_VAR 0 5
53133: PUSH
53134: EMPTY
53135: ST_TO_ADDR
// for i = 16 to 25 do
53136: LD_ADDR_VAR 0 4
53140: PUSH
53141: DOUBLE
53142: LD_INT 16
53144: DEC
53145: ST_TO_ADDR
53146: LD_INT 25
53148: PUSH
53149: FOR_TO
53150: IFFALSE 53223
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53152: LD_ADDR_VAR 0 3
53156: PUSH
53157: LD_VAR 0 3
53161: PUSH
53162: LD_INT 22
53164: PUSH
53165: LD_VAR 0 1
53169: PPUSH
53170: CALL_OW 255
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: PUSH
53179: LD_INT 91
53181: PUSH
53182: LD_VAR 0 1
53186: PUSH
53187: LD_INT 6
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: LIST
53194: PUSH
53195: LD_INT 30
53197: PUSH
53198: LD_VAR 0 4
53202: PUSH
53203: EMPTY
53204: LIST
53205: LIST
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: LIST
53211: PUSH
53212: EMPTY
53213: LIST
53214: PPUSH
53215: CALL_OW 69
53219: ADD
53220: ST_TO_ADDR
53221: GO 53149
53223: POP
53224: POP
// for i = 1 to tmp do
53225: LD_ADDR_VAR 0 4
53229: PUSH
53230: DOUBLE
53231: LD_INT 1
53233: DEC
53234: ST_TO_ADDR
53235: LD_VAR 0 3
53239: PUSH
53240: FOR_TO
53241: IFFALSE 53329
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53243: LD_ADDR_VAR 0 5
53247: PUSH
53248: LD_VAR 0 5
53252: PUSH
53253: LD_VAR 0 3
53257: PUSH
53258: LD_VAR 0 4
53262: ARRAY
53263: PPUSH
53264: CALL_OW 266
53268: PUSH
53269: LD_VAR 0 3
53273: PUSH
53274: LD_VAR 0 4
53278: ARRAY
53279: PPUSH
53280: CALL_OW 250
53284: PUSH
53285: LD_VAR 0 3
53289: PUSH
53290: LD_VAR 0 4
53294: ARRAY
53295: PPUSH
53296: CALL_OW 251
53300: PUSH
53301: LD_VAR 0 3
53305: PUSH
53306: LD_VAR 0 4
53310: ARRAY
53311: PPUSH
53312: CALL_OW 254
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: LIST
53321: LIST
53322: PUSH
53323: EMPTY
53324: LIST
53325: ADD
53326: ST_TO_ADDR
53327: GO 53240
53329: POP
53330: POP
// result := list ;
53331: LD_ADDR_VAR 0 2
53335: PUSH
53336: LD_VAR 0 5
53340: ST_TO_ADDR
// end ;
53341: LD_VAR 0 2
53345: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53346: LD_INT 0
53348: PPUSH
53349: PPUSH
53350: PPUSH
53351: PPUSH
53352: PPUSH
53353: PPUSH
53354: PPUSH
// if not factory then
53355: LD_VAR 0 1
53359: NOT
53360: IFFALSE 53364
// exit ;
53362: GO 53957
// if control = control_apeman then
53364: LD_VAR 0 4
53368: PUSH
53369: LD_INT 5
53371: EQUAL
53372: IFFALSE 53481
// begin tmp := UnitsInside ( factory ) ;
53374: LD_ADDR_VAR 0 8
53378: PUSH
53379: LD_VAR 0 1
53383: PPUSH
53384: CALL_OW 313
53388: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53389: LD_VAR 0 8
53393: PPUSH
53394: LD_INT 25
53396: PUSH
53397: LD_INT 12
53399: PUSH
53400: EMPTY
53401: LIST
53402: LIST
53403: PPUSH
53404: CALL_OW 72
53408: NOT
53409: IFFALSE 53419
// control := control_manual ;
53411: LD_ADDR_VAR 0 4
53415: PUSH
53416: LD_INT 1
53418: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53419: LD_ADDR_VAR 0 8
53423: PUSH
53424: LD_VAR 0 1
53428: PPUSH
53429: CALL 53116 0 1
53433: ST_TO_ADDR
// if tmp then
53434: LD_VAR 0 8
53438: IFFALSE 53481
// begin for i in tmp do
53440: LD_ADDR_VAR 0 7
53444: PUSH
53445: LD_VAR 0 8
53449: PUSH
53450: FOR_IN
53451: IFFALSE 53479
// if i [ 1 ] = b_ext_radio then
53453: LD_VAR 0 7
53457: PUSH
53458: LD_INT 1
53460: ARRAY
53461: PUSH
53462: LD_INT 22
53464: EQUAL
53465: IFFALSE 53477
// begin control := control_remote ;
53467: LD_ADDR_VAR 0 4
53471: PUSH
53472: LD_INT 2
53474: ST_TO_ADDR
// break ;
53475: GO 53479
// end ;
53477: GO 53450
53479: POP
53480: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53481: LD_VAR 0 1
53485: PPUSH
53486: LD_VAR 0 2
53490: PPUSH
53491: LD_VAR 0 3
53495: PPUSH
53496: LD_VAR 0 4
53500: PPUSH
53501: LD_VAR 0 5
53505: PPUSH
53506: CALL_OW 448
53510: IFFALSE 53545
// begin result := [ chassis , engine , control , weapon ] ;
53512: LD_ADDR_VAR 0 6
53516: PUSH
53517: LD_VAR 0 2
53521: PUSH
53522: LD_VAR 0 3
53526: PUSH
53527: LD_VAR 0 4
53531: PUSH
53532: LD_VAR 0 5
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: LIST
53541: LIST
53542: ST_TO_ADDR
// exit ;
53543: GO 53957
// end ; _chassis := AvailableChassisList ( factory ) ;
53545: LD_ADDR_VAR 0 9
53549: PUSH
53550: LD_VAR 0 1
53554: PPUSH
53555: CALL_OW 475
53559: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53560: LD_ADDR_VAR 0 11
53564: PUSH
53565: LD_VAR 0 1
53569: PPUSH
53570: CALL_OW 476
53574: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53575: LD_ADDR_VAR 0 12
53579: PUSH
53580: LD_VAR 0 1
53584: PPUSH
53585: CALL_OW 477
53589: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53590: LD_ADDR_VAR 0 10
53594: PUSH
53595: LD_VAR 0 1
53599: PPUSH
53600: CALL_OW 478
53604: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53605: LD_VAR 0 9
53609: NOT
53610: PUSH
53611: LD_VAR 0 11
53615: NOT
53616: OR
53617: PUSH
53618: LD_VAR 0 12
53622: NOT
53623: OR
53624: PUSH
53625: LD_VAR 0 10
53629: NOT
53630: OR
53631: IFFALSE 53666
// begin result := [ chassis , engine , control , weapon ] ;
53633: LD_ADDR_VAR 0 6
53637: PUSH
53638: LD_VAR 0 2
53642: PUSH
53643: LD_VAR 0 3
53647: PUSH
53648: LD_VAR 0 4
53652: PUSH
53653: LD_VAR 0 5
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: LIST
53662: LIST
53663: ST_TO_ADDR
// exit ;
53664: GO 53957
// end ; if not chassis in _chassis then
53666: LD_VAR 0 2
53670: PUSH
53671: LD_VAR 0 9
53675: IN
53676: NOT
53677: IFFALSE 53703
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53679: LD_ADDR_VAR 0 2
53683: PUSH
53684: LD_VAR 0 9
53688: PUSH
53689: LD_INT 1
53691: PPUSH
53692: LD_VAR 0 9
53696: PPUSH
53697: CALL_OW 12
53701: ARRAY
53702: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53703: LD_VAR 0 2
53707: PPUSH
53708: LD_VAR 0 3
53712: PPUSH
53713: CALL 53962 0 2
53717: NOT
53718: IFFALSE 53777
// repeat engine := _engine [ 1 ] ;
53720: LD_ADDR_VAR 0 3
53724: PUSH
53725: LD_VAR 0 11
53729: PUSH
53730: LD_INT 1
53732: ARRAY
53733: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53734: LD_ADDR_VAR 0 11
53738: PUSH
53739: LD_VAR 0 11
53743: PPUSH
53744: LD_INT 1
53746: PPUSH
53747: CALL_OW 3
53751: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53752: LD_VAR 0 2
53756: PPUSH
53757: LD_VAR 0 3
53761: PPUSH
53762: CALL 53962 0 2
53766: PUSH
53767: LD_VAR 0 11
53771: PUSH
53772: EMPTY
53773: EQUAL
53774: OR
53775: IFFALSE 53720
// if not control in _control then
53777: LD_VAR 0 4
53781: PUSH
53782: LD_VAR 0 12
53786: IN
53787: NOT
53788: IFFALSE 53814
// control := _control [ rand ( 1 , _control ) ] ;
53790: LD_ADDR_VAR 0 4
53794: PUSH
53795: LD_VAR 0 12
53799: PUSH
53800: LD_INT 1
53802: PPUSH
53803: LD_VAR 0 12
53807: PPUSH
53808: CALL_OW 12
53812: ARRAY
53813: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53814: LD_VAR 0 2
53818: PPUSH
53819: LD_VAR 0 5
53823: PPUSH
53824: CALL 54182 0 2
53828: NOT
53829: IFFALSE 53888
// repeat weapon := _weapon [ 1 ] ;
53831: LD_ADDR_VAR 0 5
53835: PUSH
53836: LD_VAR 0 10
53840: PUSH
53841: LD_INT 1
53843: ARRAY
53844: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53845: LD_ADDR_VAR 0 10
53849: PUSH
53850: LD_VAR 0 10
53854: PPUSH
53855: LD_INT 1
53857: PPUSH
53858: CALL_OW 3
53862: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53863: LD_VAR 0 2
53867: PPUSH
53868: LD_VAR 0 5
53872: PPUSH
53873: CALL 54182 0 2
53877: PUSH
53878: LD_VAR 0 10
53882: PUSH
53883: EMPTY
53884: EQUAL
53885: OR
53886: IFFALSE 53831
// result := [ ] ;
53888: LD_ADDR_VAR 0 6
53892: PUSH
53893: EMPTY
53894: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53895: LD_VAR 0 1
53899: PPUSH
53900: LD_VAR 0 2
53904: PPUSH
53905: LD_VAR 0 3
53909: PPUSH
53910: LD_VAR 0 4
53914: PPUSH
53915: LD_VAR 0 5
53919: PPUSH
53920: CALL_OW 448
53924: IFFALSE 53957
// result := [ chassis , engine , control , weapon ] ;
53926: LD_ADDR_VAR 0 6
53930: PUSH
53931: LD_VAR 0 2
53935: PUSH
53936: LD_VAR 0 3
53940: PUSH
53941: LD_VAR 0 4
53945: PUSH
53946: LD_VAR 0 5
53950: PUSH
53951: EMPTY
53952: LIST
53953: LIST
53954: LIST
53955: LIST
53956: ST_TO_ADDR
// end ;
53957: LD_VAR 0 6
53961: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53962: LD_INT 0
53964: PPUSH
// if not chassis or not engine then
53965: LD_VAR 0 1
53969: NOT
53970: PUSH
53971: LD_VAR 0 2
53975: NOT
53976: OR
53977: IFFALSE 53981
// exit ;
53979: GO 54177
// case engine of engine_solar :
53981: LD_VAR 0 2
53985: PUSH
53986: LD_INT 2
53988: DOUBLE
53989: EQUAL
53990: IFTRUE 53994
53992: GO 54032
53994: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53995: LD_ADDR_VAR 0 3
53999: PUSH
54000: LD_INT 11
54002: PUSH
54003: LD_INT 12
54005: PUSH
54006: LD_INT 13
54008: PUSH
54009: LD_INT 14
54011: PUSH
54012: LD_INT 1
54014: PUSH
54015: LD_INT 2
54017: PUSH
54018: LD_INT 3
54020: PUSH
54021: EMPTY
54022: LIST
54023: LIST
54024: LIST
54025: LIST
54026: LIST
54027: LIST
54028: LIST
54029: ST_TO_ADDR
54030: GO 54161
54032: LD_INT 1
54034: DOUBLE
54035: EQUAL
54036: IFTRUE 54040
54038: GO 54102
54040: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54041: LD_ADDR_VAR 0 3
54045: PUSH
54046: LD_INT 11
54048: PUSH
54049: LD_INT 12
54051: PUSH
54052: LD_INT 13
54054: PUSH
54055: LD_INT 14
54057: PUSH
54058: LD_INT 1
54060: PUSH
54061: LD_INT 2
54063: PUSH
54064: LD_INT 3
54066: PUSH
54067: LD_INT 4
54069: PUSH
54070: LD_INT 5
54072: PUSH
54073: LD_INT 21
54075: PUSH
54076: LD_INT 23
54078: PUSH
54079: LD_INT 22
54081: PUSH
54082: LD_INT 24
54084: PUSH
54085: EMPTY
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: ST_TO_ADDR
54100: GO 54161
54102: LD_INT 3
54104: DOUBLE
54105: EQUAL
54106: IFTRUE 54110
54108: GO 54160
54110: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54111: LD_ADDR_VAR 0 3
54115: PUSH
54116: LD_INT 13
54118: PUSH
54119: LD_INT 14
54121: PUSH
54122: LD_INT 2
54124: PUSH
54125: LD_INT 3
54127: PUSH
54128: LD_INT 4
54130: PUSH
54131: LD_INT 5
54133: PUSH
54134: LD_INT 21
54136: PUSH
54137: LD_INT 22
54139: PUSH
54140: LD_INT 23
54142: PUSH
54143: LD_INT 24
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: LIST
54150: LIST
54151: LIST
54152: LIST
54153: LIST
54154: LIST
54155: LIST
54156: LIST
54157: ST_TO_ADDR
54158: GO 54161
54160: POP
// result := ( chassis in result ) ;
54161: LD_ADDR_VAR 0 3
54165: PUSH
54166: LD_VAR 0 1
54170: PUSH
54171: LD_VAR 0 3
54175: IN
54176: ST_TO_ADDR
// end ;
54177: LD_VAR 0 3
54181: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54182: LD_INT 0
54184: PPUSH
// if not chassis or not weapon then
54185: LD_VAR 0 1
54189: NOT
54190: PUSH
54191: LD_VAR 0 2
54195: NOT
54196: OR
54197: IFFALSE 54201
// exit ;
54199: GO 55227
// case weapon of us_machine_gun :
54201: LD_VAR 0 2
54205: PUSH
54206: LD_INT 2
54208: DOUBLE
54209: EQUAL
54210: IFTRUE 54214
54212: GO 54244
54214: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54215: LD_ADDR_VAR 0 3
54219: PUSH
54220: LD_INT 1
54222: PUSH
54223: LD_INT 2
54225: PUSH
54226: LD_INT 3
54228: PUSH
54229: LD_INT 4
54231: PUSH
54232: LD_INT 5
54234: PUSH
54235: EMPTY
54236: LIST
54237: LIST
54238: LIST
54239: LIST
54240: LIST
54241: ST_TO_ADDR
54242: GO 55211
54244: LD_INT 3
54246: DOUBLE
54247: EQUAL
54248: IFTRUE 54252
54250: GO 54282
54252: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54253: LD_ADDR_VAR 0 3
54257: PUSH
54258: LD_INT 1
54260: PUSH
54261: LD_INT 2
54263: PUSH
54264: LD_INT 3
54266: PUSH
54267: LD_INT 4
54269: PUSH
54270: LD_INT 5
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: LIST
54277: LIST
54278: LIST
54279: ST_TO_ADDR
54280: GO 55211
54282: LD_INT 11
54284: DOUBLE
54285: EQUAL
54286: IFTRUE 54290
54288: GO 54320
54290: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54291: LD_ADDR_VAR 0 3
54295: PUSH
54296: LD_INT 1
54298: PUSH
54299: LD_INT 2
54301: PUSH
54302: LD_INT 3
54304: PUSH
54305: LD_INT 4
54307: PUSH
54308: LD_INT 5
54310: PUSH
54311: EMPTY
54312: LIST
54313: LIST
54314: LIST
54315: LIST
54316: LIST
54317: ST_TO_ADDR
54318: GO 55211
54320: LD_INT 4
54322: DOUBLE
54323: EQUAL
54324: IFTRUE 54328
54326: GO 54354
54328: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54329: LD_ADDR_VAR 0 3
54333: PUSH
54334: LD_INT 2
54336: PUSH
54337: LD_INT 3
54339: PUSH
54340: LD_INT 4
54342: PUSH
54343: LD_INT 5
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: ST_TO_ADDR
54352: GO 55211
54354: LD_INT 5
54356: DOUBLE
54357: EQUAL
54358: IFTRUE 54362
54360: GO 54388
54362: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54363: LD_ADDR_VAR 0 3
54367: PUSH
54368: LD_INT 2
54370: PUSH
54371: LD_INT 3
54373: PUSH
54374: LD_INT 4
54376: PUSH
54377: LD_INT 5
54379: PUSH
54380: EMPTY
54381: LIST
54382: LIST
54383: LIST
54384: LIST
54385: ST_TO_ADDR
54386: GO 55211
54388: LD_INT 9
54390: DOUBLE
54391: EQUAL
54392: IFTRUE 54396
54394: GO 54422
54396: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54397: LD_ADDR_VAR 0 3
54401: PUSH
54402: LD_INT 2
54404: PUSH
54405: LD_INT 3
54407: PUSH
54408: LD_INT 4
54410: PUSH
54411: LD_INT 5
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: LIST
54418: LIST
54419: ST_TO_ADDR
54420: GO 55211
54422: LD_INT 7
54424: DOUBLE
54425: EQUAL
54426: IFTRUE 54430
54428: GO 54456
54430: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54431: LD_ADDR_VAR 0 3
54435: PUSH
54436: LD_INT 2
54438: PUSH
54439: LD_INT 3
54441: PUSH
54442: LD_INT 4
54444: PUSH
54445: LD_INT 5
54447: PUSH
54448: EMPTY
54449: LIST
54450: LIST
54451: LIST
54452: LIST
54453: ST_TO_ADDR
54454: GO 55211
54456: LD_INT 12
54458: DOUBLE
54459: EQUAL
54460: IFTRUE 54464
54462: GO 54490
54464: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54465: LD_ADDR_VAR 0 3
54469: PUSH
54470: LD_INT 2
54472: PUSH
54473: LD_INT 3
54475: PUSH
54476: LD_INT 4
54478: PUSH
54479: LD_INT 5
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: LIST
54486: LIST
54487: ST_TO_ADDR
54488: GO 55211
54490: LD_INT 13
54492: DOUBLE
54493: EQUAL
54494: IFTRUE 54498
54496: GO 54524
54498: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54499: LD_ADDR_VAR 0 3
54503: PUSH
54504: LD_INT 2
54506: PUSH
54507: LD_INT 3
54509: PUSH
54510: LD_INT 4
54512: PUSH
54513: LD_INT 5
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: LIST
54520: LIST
54521: ST_TO_ADDR
54522: GO 55211
54524: LD_INT 14
54526: DOUBLE
54527: EQUAL
54528: IFTRUE 54532
54530: GO 54550
54532: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54533: LD_ADDR_VAR 0 3
54537: PUSH
54538: LD_INT 4
54540: PUSH
54541: LD_INT 5
54543: PUSH
54544: EMPTY
54545: LIST
54546: LIST
54547: ST_TO_ADDR
54548: GO 55211
54550: LD_INT 6
54552: DOUBLE
54553: EQUAL
54554: IFTRUE 54558
54556: GO 54576
54558: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54559: LD_ADDR_VAR 0 3
54563: PUSH
54564: LD_INT 4
54566: PUSH
54567: LD_INT 5
54569: PUSH
54570: EMPTY
54571: LIST
54572: LIST
54573: ST_TO_ADDR
54574: GO 55211
54576: LD_INT 10
54578: DOUBLE
54579: EQUAL
54580: IFTRUE 54584
54582: GO 54602
54584: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54585: LD_ADDR_VAR 0 3
54589: PUSH
54590: LD_INT 4
54592: PUSH
54593: LD_INT 5
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: ST_TO_ADDR
54600: GO 55211
54602: LD_INT 22
54604: DOUBLE
54605: EQUAL
54606: IFTRUE 54610
54608: GO 54636
54610: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54611: LD_ADDR_VAR 0 3
54615: PUSH
54616: LD_INT 11
54618: PUSH
54619: LD_INT 12
54621: PUSH
54622: LD_INT 13
54624: PUSH
54625: LD_INT 14
54627: PUSH
54628: EMPTY
54629: LIST
54630: LIST
54631: LIST
54632: LIST
54633: ST_TO_ADDR
54634: GO 55211
54636: LD_INT 23
54638: DOUBLE
54639: EQUAL
54640: IFTRUE 54644
54642: GO 54670
54644: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54645: LD_ADDR_VAR 0 3
54649: PUSH
54650: LD_INT 11
54652: PUSH
54653: LD_INT 12
54655: PUSH
54656: LD_INT 13
54658: PUSH
54659: LD_INT 14
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: LIST
54666: LIST
54667: ST_TO_ADDR
54668: GO 55211
54670: LD_INT 24
54672: DOUBLE
54673: EQUAL
54674: IFTRUE 54678
54676: GO 54704
54678: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54679: LD_ADDR_VAR 0 3
54683: PUSH
54684: LD_INT 11
54686: PUSH
54687: LD_INT 12
54689: PUSH
54690: LD_INT 13
54692: PUSH
54693: LD_INT 14
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: LIST
54700: LIST
54701: ST_TO_ADDR
54702: GO 55211
54704: LD_INT 30
54706: DOUBLE
54707: EQUAL
54708: IFTRUE 54712
54710: GO 54738
54712: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54713: LD_ADDR_VAR 0 3
54717: PUSH
54718: LD_INT 11
54720: PUSH
54721: LD_INT 12
54723: PUSH
54724: LD_INT 13
54726: PUSH
54727: LD_INT 14
54729: PUSH
54730: EMPTY
54731: LIST
54732: LIST
54733: LIST
54734: LIST
54735: ST_TO_ADDR
54736: GO 55211
54738: LD_INT 25
54740: DOUBLE
54741: EQUAL
54742: IFTRUE 54746
54744: GO 54764
54746: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54747: LD_ADDR_VAR 0 3
54751: PUSH
54752: LD_INT 13
54754: PUSH
54755: LD_INT 14
54757: PUSH
54758: EMPTY
54759: LIST
54760: LIST
54761: ST_TO_ADDR
54762: GO 55211
54764: LD_INT 27
54766: DOUBLE
54767: EQUAL
54768: IFTRUE 54772
54770: GO 54790
54772: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54773: LD_ADDR_VAR 0 3
54777: PUSH
54778: LD_INT 13
54780: PUSH
54781: LD_INT 14
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: ST_TO_ADDR
54788: GO 55211
54790: LD_INT 28
54792: DOUBLE
54793: EQUAL
54794: IFTRUE 54798
54796: GO 54816
54798: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54799: LD_ADDR_VAR 0 3
54803: PUSH
54804: LD_INT 13
54806: PUSH
54807: LD_INT 14
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: ST_TO_ADDR
54814: GO 55211
54816: LD_INT 29
54818: DOUBLE
54819: EQUAL
54820: IFTRUE 54824
54822: GO 54842
54824: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54825: LD_ADDR_VAR 0 3
54829: PUSH
54830: LD_INT 13
54832: PUSH
54833: LD_INT 14
54835: PUSH
54836: EMPTY
54837: LIST
54838: LIST
54839: ST_TO_ADDR
54840: GO 55211
54842: LD_INT 31
54844: DOUBLE
54845: EQUAL
54846: IFTRUE 54850
54848: GO 54868
54850: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54851: LD_ADDR_VAR 0 3
54855: PUSH
54856: LD_INT 13
54858: PUSH
54859: LD_INT 14
54861: PUSH
54862: EMPTY
54863: LIST
54864: LIST
54865: ST_TO_ADDR
54866: GO 55211
54868: LD_INT 26
54870: DOUBLE
54871: EQUAL
54872: IFTRUE 54876
54874: GO 54894
54876: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54877: LD_ADDR_VAR 0 3
54881: PUSH
54882: LD_INT 13
54884: PUSH
54885: LD_INT 14
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: ST_TO_ADDR
54892: GO 55211
54894: LD_INT 42
54896: DOUBLE
54897: EQUAL
54898: IFTRUE 54902
54900: GO 54928
54902: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54903: LD_ADDR_VAR 0 3
54907: PUSH
54908: LD_INT 21
54910: PUSH
54911: LD_INT 22
54913: PUSH
54914: LD_INT 23
54916: PUSH
54917: LD_INT 24
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: LIST
54924: LIST
54925: ST_TO_ADDR
54926: GO 55211
54928: LD_INT 43
54930: DOUBLE
54931: EQUAL
54932: IFTRUE 54936
54934: GO 54962
54936: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54937: LD_ADDR_VAR 0 3
54941: PUSH
54942: LD_INT 21
54944: PUSH
54945: LD_INT 22
54947: PUSH
54948: LD_INT 23
54950: PUSH
54951: LD_INT 24
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: LIST
54958: LIST
54959: ST_TO_ADDR
54960: GO 55211
54962: LD_INT 44
54964: DOUBLE
54965: EQUAL
54966: IFTRUE 54970
54968: GO 54996
54970: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54971: LD_ADDR_VAR 0 3
54975: PUSH
54976: LD_INT 21
54978: PUSH
54979: LD_INT 22
54981: PUSH
54982: LD_INT 23
54984: PUSH
54985: LD_INT 24
54987: PUSH
54988: EMPTY
54989: LIST
54990: LIST
54991: LIST
54992: LIST
54993: ST_TO_ADDR
54994: GO 55211
54996: LD_INT 45
54998: DOUBLE
54999: EQUAL
55000: IFTRUE 55004
55002: GO 55030
55004: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55005: LD_ADDR_VAR 0 3
55009: PUSH
55010: LD_INT 21
55012: PUSH
55013: LD_INT 22
55015: PUSH
55016: LD_INT 23
55018: PUSH
55019: LD_INT 24
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: LIST
55026: LIST
55027: ST_TO_ADDR
55028: GO 55211
55030: LD_INT 49
55032: DOUBLE
55033: EQUAL
55034: IFTRUE 55038
55036: GO 55064
55038: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55039: LD_ADDR_VAR 0 3
55043: PUSH
55044: LD_INT 21
55046: PUSH
55047: LD_INT 22
55049: PUSH
55050: LD_INT 23
55052: PUSH
55053: LD_INT 24
55055: PUSH
55056: EMPTY
55057: LIST
55058: LIST
55059: LIST
55060: LIST
55061: ST_TO_ADDR
55062: GO 55211
55064: LD_INT 51
55066: DOUBLE
55067: EQUAL
55068: IFTRUE 55072
55070: GO 55098
55072: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55073: LD_ADDR_VAR 0 3
55077: PUSH
55078: LD_INT 21
55080: PUSH
55081: LD_INT 22
55083: PUSH
55084: LD_INT 23
55086: PUSH
55087: LD_INT 24
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: ST_TO_ADDR
55096: GO 55211
55098: LD_INT 52
55100: DOUBLE
55101: EQUAL
55102: IFTRUE 55106
55104: GO 55132
55106: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55107: LD_ADDR_VAR 0 3
55111: PUSH
55112: LD_INT 21
55114: PUSH
55115: LD_INT 22
55117: PUSH
55118: LD_INT 23
55120: PUSH
55121: LD_INT 24
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: LIST
55128: LIST
55129: ST_TO_ADDR
55130: GO 55211
55132: LD_INT 53
55134: DOUBLE
55135: EQUAL
55136: IFTRUE 55140
55138: GO 55158
55140: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55141: LD_ADDR_VAR 0 3
55145: PUSH
55146: LD_INT 23
55148: PUSH
55149: LD_INT 24
55151: PUSH
55152: EMPTY
55153: LIST
55154: LIST
55155: ST_TO_ADDR
55156: GO 55211
55158: LD_INT 46
55160: DOUBLE
55161: EQUAL
55162: IFTRUE 55166
55164: GO 55184
55166: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55167: LD_ADDR_VAR 0 3
55171: PUSH
55172: LD_INT 23
55174: PUSH
55175: LD_INT 24
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: ST_TO_ADDR
55182: GO 55211
55184: LD_INT 47
55186: DOUBLE
55187: EQUAL
55188: IFTRUE 55192
55190: GO 55210
55192: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55193: LD_ADDR_VAR 0 3
55197: PUSH
55198: LD_INT 23
55200: PUSH
55201: LD_INT 24
55203: PUSH
55204: EMPTY
55205: LIST
55206: LIST
55207: ST_TO_ADDR
55208: GO 55211
55210: POP
// result := ( chassis in result ) ;
55211: LD_ADDR_VAR 0 3
55215: PUSH
55216: LD_VAR 0 1
55220: PUSH
55221: LD_VAR 0 3
55225: IN
55226: ST_TO_ADDR
// end ;
55227: LD_VAR 0 3
55231: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55232: LD_INT 0
55234: PPUSH
55235: PPUSH
55236: PPUSH
55237: PPUSH
55238: PPUSH
55239: PPUSH
55240: PPUSH
// result := array ;
55241: LD_ADDR_VAR 0 5
55245: PUSH
55246: LD_VAR 0 1
55250: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55251: LD_VAR 0 1
55255: NOT
55256: PUSH
55257: LD_VAR 0 2
55261: NOT
55262: OR
55263: PUSH
55264: LD_VAR 0 3
55268: NOT
55269: OR
55270: PUSH
55271: LD_VAR 0 2
55275: PUSH
55276: LD_VAR 0 1
55280: GREATER
55281: OR
55282: PUSH
55283: LD_VAR 0 3
55287: PUSH
55288: LD_VAR 0 1
55292: GREATER
55293: OR
55294: IFFALSE 55298
// exit ;
55296: GO 55594
// if direction then
55298: LD_VAR 0 4
55302: IFFALSE 55366
// begin d := 1 ;
55304: LD_ADDR_VAR 0 9
55308: PUSH
55309: LD_INT 1
55311: ST_TO_ADDR
// if i_from > i_to then
55312: LD_VAR 0 2
55316: PUSH
55317: LD_VAR 0 3
55321: GREATER
55322: IFFALSE 55348
// length := ( array - i_from ) + i_to else
55324: LD_ADDR_VAR 0 11
55328: PUSH
55329: LD_VAR 0 1
55333: PUSH
55334: LD_VAR 0 2
55338: MINUS
55339: PUSH
55340: LD_VAR 0 3
55344: PLUS
55345: ST_TO_ADDR
55346: GO 55364
// length := i_to - i_from ;
55348: LD_ADDR_VAR 0 11
55352: PUSH
55353: LD_VAR 0 3
55357: PUSH
55358: LD_VAR 0 2
55362: MINUS
55363: ST_TO_ADDR
// end else
55364: GO 55427
// begin d := - 1 ;
55366: LD_ADDR_VAR 0 9
55370: PUSH
55371: LD_INT 1
55373: NEG
55374: ST_TO_ADDR
// if i_from > i_to then
55375: LD_VAR 0 2
55379: PUSH
55380: LD_VAR 0 3
55384: GREATER
55385: IFFALSE 55405
// length := i_from - i_to else
55387: LD_ADDR_VAR 0 11
55391: PUSH
55392: LD_VAR 0 2
55396: PUSH
55397: LD_VAR 0 3
55401: MINUS
55402: ST_TO_ADDR
55403: GO 55427
// length := ( array - i_to ) + i_from ;
55405: LD_ADDR_VAR 0 11
55409: PUSH
55410: LD_VAR 0 1
55414: PUSH
55415: LD_VAR 0 3
55419: MINUS
55420: PUSH
55421: LD_VAR 0 2
55425: PLUS
55426: ST_TO_ADDR
// end ; if not length then
55427: LD_VAR 0 11
55431: NOT
55432: IFFALSE 55436
// exit ;
55434: GO 55594
// tmp := array ;
55436: LD_ADDR_VAR 0 10
55440: PUSH
55441: LD_VAR 0 1
55445: ST_TO_ADDR
// for i = 1 to length do
55446: LD_ADDR_VAR 0 6
55450: PUSH
55451: DOUBLE
55452: LD_INT 1
55454: DEC
55455: ST_TO_ADDR
55456: LD_VAR 0 11
55460: PUSH
55461: FOR_TO
55462: IFFALSE 55582
// begin for j = 1 to array do
55464: LD_ADDR_VAR 0 7
55468: PUSH
55469: DOUBLE
55470: LD_INT 1
55472: DEC
55473: ST_TO_ADDR
55474: LD_VAR 0 1
55478: PUSH
55479: FOR_TO
55480: IFFALSE 55568
// begin k := j + d ;
55482: LD_ADDR_VAR 0 8
55486: PUSH
55487: LD_VAR 0 7
55491: PUSH
55492: LD_VAR 0 9
55496: PLUS
55497: ST_TO_ADDR
// if k > array then
55498: LD_VAR 0 8
55502: PUSH
55503: LD_VAR 0 1
55507: GREATER
55508: IFFALSE 55518
// k := 1 ;
55510: LD_ADDR_VAR 0 8
55514: PUSH
55515: LD_INT 1
55517: ST_TO_ADDR
// if not k then
55518: LD_VAR 0 8
55522: NOT
55523: IFFALSE 55535
// k := array ;
55525: LD_ADDR_VAR 0 8
55529: PUSH
55530: LD_VAR 0 1
55534: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55535: LD_ADDR_VAR 0 10
55539: PUSH
55540: LD_VAR 0 10
55544: PPUSH
55545: LD_VAR 0 8
55549: PPUSH
55550: LD_VAR 0 1
55554: PUSH
55555: LD_VAR 0 7
55559: ARRAY
55560: PPUSH
55561: CALL_OW 1
55565: ST_TO_ADDR
// end ;
55566: GO 55479
55568: POP
55569: POP
// array := tmp ;
55570: LD_ADDR_VAR 0 1
55574: PUSH
55575: LD_VAR 0 10
55579: ST_TO_ADDR
// end ;
55580: GO 55461
55582: POP
55583: POP
// result := array ;
55584: LD_ADDR_VAR 0 5
55588: PUSH
55589: LD_VAR 0 1
55593: ST_TO_ADDR
// end ;
55594: LD_VAR 0 5
55598: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55599: LD_INT 0
55601: PPUSH
55602: PPUSH
// result := 0 ;
55603: LD_ADDR_VAR 0 3
55607: PUSH
55608: LD_INT 0
55610: ST_TO_ADDR
// if not array or not value in array then
55611: LD_VAR 0 1
55615: NOT
55616: PUSH
55617: LD_VAR 0 2
55621: PUSH
55622: LD_VAR 0 1
55626: IN
55627: NOT
55628: OR
55629: IFFALSE 55633
// exit ;
55631: GO 55687
// for i = 1 to array do
55633: LD_ADDR_VAR 0 4
55637: PUSH
55638: DOUBLE
55639: LD_INT 1
55641: DEC
55642: ST_TO_ADDR
55643: LD_VAR 0 1
55647: PUSH
55648: FOR_TO
55649: IFFALSE 55685
// if value = array [ i ] then
55651: LD_VAR 0 2
55655: PUSH
55656: LD_VAR 0 1
55660: PUSH
55661: LD_VAR 0 4
55665: ARRAY
55666: EQUAL
55667: IFFALSE 55683
// begin result := i ;
55669: LD_ADDR_VAR 0 3
55673: PUSH
55674: LD_VAR 0 4
55678: ST_TO_ADDR
// exit ;
55679: POP
55680: POP
55681: GO 55687
// end ;
55683: GO 55648
55685: POP
55686: POP
// end ;
55687: LD_VAR 0 3
55691: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55692: LD_INT 0
55694: PPUSH
// vc_chassis := chassis ;
55695: LD_ADDR_OWVAR 37
55699: PUSH
55700: LD_VAR 0 1
55704: ST_TO_ADDR
// vc_engine := engine ;
55705: LD_ADDR_OWVAR 39
55709: PUSH
55710: LD_VAR 0 2
55714: ST_TO_ADDR
// vc_control := control ;
55715: LD_ADDR_OWVAR 38
55719: PUSH
55720: LD_VAR 0 3
55724: ST_TO_ADDR
// vc_weapon := weapon ;
55725: LD_ADDR_OWVAR 40
55729: PUSH
55730: LD_VAR 0 4
55734: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55735: LD_ADDR_OWVAR 41
55739: PUSH
55740: LD_VAR 0 5
55744: ST_TO_ADDR
// end ;
55745: LD_VAR 0 6
55749: RET
// export function WantPlant ( unit ) ; var task ; begin
55750: LD_INT 0
55752: PPUSH
55753: PPUSH
// result := false ;
55754: LD_ADDR_VAR 0 2
55758: PUSH
55759: LD_INT 0
55761: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55762: LD_ADDR_VAR 0 3
55766: PUSH
55767: LD_VAR 0 1
55771: PPUSH
55772: CALL_OW 437
55776: ST_TO_ADDR
// if task then
55777: LD_VAR 0 3
55781: IFFALSE 55809
// if task [ 1 ] [ 1 ] = p then
55783: LD_VAR 0 3
55787: PUSH
55788: LD_INT 1
55790: ARRAY
55791: PUSH
55792: LD_INT 1
55794: ARRAY
55795: PUSH
55796: LD_STRING p
55798: EQUAL
55799: IFFALSE 55809
// result := true ;
55801: LD_ADDR_VAR 0 2
55805: PUSH
55806: LD_INT 1
55808: ST_TO_ADDR
// end ;
55809: LD_VAR 0 2
55813: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55814: LD_INT 0
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
// if pos < 1 then
55820: LD_VAR 0 2
55824: PUSH
55825: LD_INT 1
55827: LESS
55828: IFFALSE 55832
// exit ;
55830: GO 56135
// if pos = 1 then
55832: LD_VAR 0 2
55836: PUSH
55837: LD_INT 1
55839: EQUAL
55840: IFFALSE 55873
// result := Replace ( arr , pos [ 1 ] , value ) else
55842: LD_ADDR_VAR 0 4
55846: PUSH
55847: LD_VAR 0 1
55851: PPUSH
55852: LD_VAR 0 2
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: LD_VAR 0 3
55865: PPUSH
55866: CALL_OW 1
55870: ST_TO_ADDR
55871: GO 56135
// begin tmp := arr ;
55873: LD_ADDR_VAR 0 6
55877: PUSH
55878: LD_VAR 0 1
55882: ST_TO_ADDR
// s_arr := [ tmp ] ;
55883: LD_ADDR_VAR 0 7
55887: PUSH
55888: LD_VAR 0 6
55892: PUSH
55893: EMPTY
55894: LIST
55895: ST_TO_ADDR
// for i = 1 to pos - 1 do
55896: LD_ADDR_VAR 0 5
55900: PUSH
55901: DOUBLE
55902: LD_INT 1
55904: DEC
55905: ST_TO_ADDR
55906: LD_VAR 0 2
55910: PUSH
55911: LD_INT 1
55913: MINUS
55914: PUSH
55915: FOR_TO
55916: IFFALSE 55961
// begin tmp := tmp [ pos [ i ] ] ;
55918: LD_ADDR_VAR 0 6
55922: PUSH
55923: LD_VAR 0 6
55927: PUSH
55928: LD_VAR 0 2
55932: PUSH
55933: LD_VAR 0 5
55937: ARRAY
55938: ARRAY
55939: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55940: LD_ADDR_VAR 0 7
55944: PUSH
55945: LD_VAR 0 7
55949: PUSH
55950: LD_VAR 0 6
55954: PUSH
55955: EMPTY
55956: LIST
55957: ADD
55958: ST_TO_ADDR
// end ;
55959: GO 55915
55961: POP
55962: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55963: LD_ADDR_VAR 0 6
55967: PUSH
55968: LD_VAR 0 6
55972: PPUSH
55973: LD_VAR 0 2
55977: PUSH
55978: LD_VAR 0 2
55982: ARRAY
55983: PPUSH
55984: LD_VAR 0 3
55988: PPUSH
55989: CALL_OW 1
55993: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55994: LD_ADDR_VAR 0 7
55998: PUSH
55999: LD_VAR 0 7
56003: PPUSH
56004: LD_VAR 0 7
56008: PPUSH
56009: LD_VAR 0 6
56013: PPUSH
56014: CALL_OW 1
56018: ST_TO_ADDR
// for i = s_arr downto 2 do
56019: LD_ADDR_VAR 0 5
56023: PUSH
56024: DOUBLE
56025: LD_VAR 0 7
56029: INC
56030: ST_TO_ADDR
56031: LD_INT 2
56033: PUSH
56034: FOR_DOWNTO
56035: IFFALSE 56119
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56037: LD_ADDR_VAR 0 6
56041: PUSH
56042: LD_VAR 0 7
56046: PUSH
56047: LD_VAR 0 5
56051: PUSH
56052: LD_INT 1
56054: MINUS
56055: ARRAY
56056: PPUSH
56057: LD_VAR 0 2
56061: PUSH
56062: LD_VAR 0 5
56066: PUSH
56067: LD_INT 1
56069: MINUS
56070: ARRAY
56071: PPUSH
56072: LD_VAR 0 7
56076: PUSH
56077: LD_VAR 0 5
56081: ARRAY
56082: PPUSH
56083: CALL_OW 1
56087: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56088: LD_ADDR_VAR 0 7
56092: PUSH
56093: LD_VAR 0 7
56097: PPUSH
56098: LD_VAR 0 5
56102: PUSH
56103: LD_INT 1
56105: MINUS
56106: PPUSH
56107: LD_VAR 0 6
56111: PPUSH
56112: CALL_OW 1
56116: ST_TO_ADDR
// end ;
56117: GO 56034
56119: POP
56120: POP
// result := s_arr [ 1 ] ;
56121: LD_ADDR_VAR 0 4
56125: PUSH
56126: LD_VAR 0 7
56130: PUSH
56131: LD_INT 1
56133: ARRAY
56134: ST_TO_ADDR
// end ; end ;
56135: LD_VAR 0 4
56139: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56140: LD_INT 0
56142: PPUSH
56143: PPUSH
// if not list then
56144: LD_VAR 0 1
56148: NOT
56149: IFFALSE 56153
// exit ;
56151: GO 56244
// i := list [ pos1 ] ;
56153: LD_ADDR_VAR 0 5
56157: PUSH
56158: LD_VAR 0 1
56162: PUSH
56163: LD_VAR 0 2
56167: ARRAY
56168: ST_TO_ADDR
// if not i then
56169: LD_VAR 0 5
56173: NOT
56174: IFFALSE 56178
// exit ;
56176: GO 56244
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56178: LD_ADDR_VAR 0 1
56182: PUSH
56183: LD_VAR 0 1
56187: PPUSH
56188: LD_VAR 0 2
56192: PPUSH
56193: LD_VAR 0 1
56197: PUSH
56198: LD_VAR 0 3
56202: ARRAY
56203: PPUSH
56204: CALL_OW 1
56208: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56209: LD_ADDR_VAR 0 1
56213: PUSH
56214: LD_VAR 0 1
56218: PPUSH
56219: LD_VAR 0 3
56223: PPUSH
56224: LD_VAR 0 5
56228: PPUSH
56229: CALL_OW 1
56233: ST_TO_ADDR
// result := list ;
56234: LD_ADDR_VAR 0 4
56238: PUSH
56239: LD_VAR 0 1
56243: ST_TO_ADDR
// end ;
56244: LD_VAR 0 4
56248: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56249: LD_INT 0
56251: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56252: LD_ADDR_VAR 0 5
56256: PUSH
56257: LD_VAR 0 1
56261: PPUSH
56262: CALL_OW 250
56266: PPUSH
56267: LD_VAR 0 1
56271: PPUSH
56272: CALL_OW 251
56276: PPUSH
56277: LD_VAR 0 2
56281: PPUSH
56282: LD_VAR 0 3
56286: PPUSH
56287: LD_VAR 0 4
56291: PPUSH
56292: CALL 56302 0 5
56296: ST_TO_ADDR
// end ;
56297: LD_VAR 0 5
56301: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56302: LD_INT 0
56304: PPUSH
56305: PPUSH
56306: PPUSH
56307: PPUSH
// if not list then
56308: LD_VAR 0 3
56312: NOT
56313: IFFALSE 56317
// exit ;
56315: GO 56705
// result := [ ] ;
56317: LD_ADDR_VAR 0 6
56321: PUSH
56322: EMPTY
56323: ST_TO_ADDR
// for i in list do
56324: LD_ADDR_VAR 0 7
56328: PUSH
56329: LD_VAR 0 3
56333: PUSH
56334: FOR_IN
56335: IFFALSE 56537
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56337: LD_ADDR_VAR 0 9
56341: PUSH
56342: LD_VAR 0 7
56346: PPUSH
56347: LD_VAR 0 1
56351: PPUSH
56352: LD_VAR 0 2
56356: PPUSH
56357: CALL_OW 297
56361: ST_TO_ADDR
// if not result then
56362: LD_VAR 0 6
56366: NOT
56367: IFFALSE 56393
// result := [ [ i , tmp ] ] else
56369: LD_ADDR_VAR 0 6
56373: PUSH
56374: LD_VAR 0 7
56378: PUSH
56379: LD_VAR 0 9
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: PUSH
56388: EMPTY
56389: LIST
56390: ST_TO_ADDR
56391: GO 56535
// begin if result [ result ] [ 2 ] < tmp then
56393: LD_VAR 0 6
56397: PUSH
56398: LD_VAR 0 6
56402: ARRAY
56403: PUSH
56404: LD_INT 2
56406: ARRAY
56407: PUSH
56408: LD_VAR 0 9
56412: LESS
56413: IFFALSE 56455
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56415: LD_ADDR_VAR 0 6
56419: PUSH
56420: LD_VAR 0 6
56424: PPUSH
56425: LD_VAR 0 6
56429: PUSH
56430: LD_INT 1
56432: PLUS
56433: PPUSH
56434: LD_VAR 0 7
56438: PUSH
56439: LD_VAR 0 9
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PPUSH
56448: CALL_OW 2
56452: ST_TO_ADDR
56453: GO 56535
// for j = 1 to result do
56455: LD_ADDR_VAR 0 8
56459: PUSH
56460: DOUBLE
56461: LD_INT 1
56463: DEC
56464: ST_TO_ADDR
56465: LD_VAR 0 6
56469: PUSH
56470: FOR_TO
56471: IFFALSE 56533
// begin if tmp < result [ j ] [ 2 ] then
56473: LD_VAR 0 9
56477: PUSH
56478: LD_VAR 0 6
56482: PUSH
56483: LD_VAR 0 8
56487: ARRAY
56488: PUSH
56489: LD_INT 2
56491: ARRAY
56492: LESS
56493: IFFALSE 56531
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56495: LD_ADDR_VAR 0 6
56499: PUSH
56500: LD_VAR 0 6
56504: PPUSH
56505: LD_VAR 0 8
56509: PPUSH
56510: LD_VAR 0 7
56514: PUSH
56515: LD_VAR 0 9
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PPUSH
56524: CALL_OW 2
56528: ST_TO_ADDR
// break ;
56529: GO 56533
// end ; end ;
56531: GO 56470
56533: POP
56534: POP
// end ; end ;
56535: GO 56334
56537: POP
56538: POP
// if result and not asc then
56539: LD_VAR 0 6
56543: PUSH
56544: LD_VAR 0 4
56548: NOT
56549: AND
56550: IFFALSE 56625
// begin tmp := result ;
56552: LD_ADDR_VAR 0 9
56556: PUSH
56557: LD_VAR 0 6
56561: ST_TO_ADDR
// for i = tmp downto 1 do
56562: LD_ADDR_VAR 0 7
56566: PUSH
56567: DOUBLE
56568: LD_VAR 0 9
56572: INC
56573: ST_TO_ADDR
56574: LD_INT 1
56576: PUSH
56577: FOR_DOWNTO
56578: IFFALSE 56623
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56580: LD_ADDR_VAR 0 6
56584: PUSH
56585: LD_VAR 0 6
56589: PPUSH
56590: LD_VAR 0 9
56594: PUSH
56595: LD_VAR 0 7
56599: MINUS
56600: PUSH
56601: LD_INT 1
56603: PLUS
56604: PPUSH
56605: LD_VAR 0 9
56609: PUSH
56610: LD_VAR 0 7
56614: ARRAY
56615: PPUSH
56616: CALL_OW 1
56620: ST_TO_ADDR
56621: GO 56577
56623: POP
56624: POP
// end ; tmp := [ ] ;
56625: LD_ADDR_VAR 0 9
56629: PUSH
56630: EMPTY
56631: ST_TO_ADDR
// if mode then
56632: LD_VAR 0 5
56636: IFFALSE 56705
// begin for i = 1 to result do
56638: LD_ADDR_VAR 0 7
56642: PUSH
56643: DOUBLE
56644: LD_INT 1
56646: DEC
56647: ST_TO_ADDR
56648: LD_VAR 0 6
56652: PUSH
56653: FOR_TO
56654: IFFALSE 56693
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56656: LD_ADDR_VAR 0 9
56660: PUSH
56661: LD_VAR 0 9
56665: PPUSH
56666: LD_VAR 0 7
56670: PPUSH
56671: LD_VAR 0 6
56675: PUSH
56676: LD_VAR 0 7
56680: ARRAY
56681: PUSH
56682: LD_INT 1
56684: ARRAY
56685: PPUSH
56686: CALL_OW 1
56690: ST_TO_ADDR
56691: GO 56653
56693: POP
56694: POP
// result := tmp ;
56695: LD_ADDR_VAR 0 6
56699: PUSH
56700: LD_VAR 0 9
56704: ST_TO_ADDR
// end ; end ;
56705: LD_VAR 0 6
56709: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56710: LD_INT 0
56712: PPUSH
56713: PPUSH
56714: PPUSH
56715: PPUSH
56716: PPUSH
56717: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56718: LD_ADDR_VAR 0 5
56722: PUSH
56723: LD_INT 0
56725: PUSH
56726: LD_INT 0
56728: PUSH
56729: LD_INT 0
56731: PUSH
56732: EMPTY
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: ST_TO_ADDR
// if not x or not y then
56740: LD_VAR 0 2
56744: NOT
56745: PUSH
56746: LD_VAR 0 3
56750: NOT
56751: OR
56752: IFFALSE 56756
// exit ;
56754: GO 58402
// if not range then
56756: LD_VAR 0 4
56760: NOT
56761: IFFALSE 56771
// range := 10 ;
56763: LD_ADDR_VAR 0 4
56767: PUSH
56768: LD_INT 10
56770: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56771: LD_ADDR_VAR 0 8
56775: PUSH
56776: LD_INT 81
56778: PUSH
56779: LD_VAR 0 1
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: PUSH
56788: LD_INT 92
56790: PUSH
56791: LD_VAR 0 2
56795: PUSH
56796: LD_VAR 0 3
56800: PUSH
56801: LD_VAR 0 4
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: PUSH
56812: LD_INT 3
56814: PUSH
56815: LD_INT 21
56817: PUSH
56818: LD_INT 3
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: PUSH
56829: EMPTY
56830: LIST
56831: LIST
56832: LIST
56833: PPUSH
56834: CALL_OW 69
56838: ST_TO_ADDR
// if not tmp then
56839: LD_VAR 0 8
56843: NOT
56844: IFFALSE 56848
// exit ;
56846: GO 58402
// for i in tmp do
56848: LD_ADDR_VAR 0 6
56852: PUSH
56853: LD_VAR 0 8
56857: PUSH
56858: FOR_IN
56859: IFFALSE 58377
// begin points := [ 0 , 0 , 0 ] ;
56861: LD_ADDR_VAR 0 9
56865: PUSH
56866: LD_INT 0
56868: PUSH
56869: LD_INT 0
56871: PUSH
56872: LD_INT 0
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: LIST
56879: ST_TO_ADDR
// bpoints := 1 ;
56880: LD_ADDR_VAR 0 10
56884: PUSH
56885: LD_INT 1
56887: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56888: LD_VAR 0 6
56892: PPUSH
56893: CALL_OW 247
56897: PUSH
56898: LD_INT 1
56900: DOUBLE
56901: EQUAL
56902: IFTRUE 56906
56904: GO 57484
56906: POP
// begin if GetClass ( i ) = 1 then
56907: LD_VAR 0 6
56911: PPUSH
56912: CALL_OW 257
56916: PUSH
56917: LD_INT 1
56919: EQUAL
56920: IFFALSE 56941
// points := [ 10 , 5 , 3 ] ;
56922: LD_ADDR_VAR 0 9
56926: PUSH
56927: LD_INT 10
56929: PUSH
56930: LD_INT 5
56932: PUSH
56933: LD_INT 3
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: LIST
56940: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56941: LD_VAR 0 6
56945: PPUSH
56946: CALL_OW 257
56950: PUSH
56951: LD_INT 2
56953: PUSH
56954: LD_INT 3
56956: PUSH
56957: LD_INT 4
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: LIST
56964: IN
56965: IFFALSE 56986
// points := [ 3 , 2 , 1 ] ;
56967: LD_ADDR_VAR 0 9
56971: PUSH
56972: LD_INT 3
56974: PUSH
56975: LD_INT 2
56977: PUSH
56978: LD_INT 1
56980: PUSH
56981: EMPTY
56982: LIST
56983: LIST
56984: LIST
56985: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56986: LD_VAR 0 6
56990: PPUSH
56991: CALL_OW 257
56995: PUSH
56996: LD_INT 5
56998: EQUAL
56999: IFFALSE 57020
// points := [ 130 , 5 , 2 ] ;
57001: LD_ADDR_VAR 0 9
57005: PUSH
57006: LD_INT 130
57008: PUSH
57009: LD_INT 5
57011: PUSH
57012: LD_INT 2
57014: PUSH
57015: EMPTY
57016: LIST
57017: LIST
57018: LIST
57019: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57020: LD_VAR 0 6
57024: PPUSH
57025: CALL_OW 257
57029: PUSH
57030: LD_INT 8
57032: EQUAL
57033: IFFALSE 57054
// points := [ 35 , 35 , 30 ] ;
57035: LD_ADDR_VAR 0 9
57039: PUSH
57040: LD_INT 35
57042: PUSH
57043: LD_INT 35
57045: PUSH
57046: LD_INT 30
57048: PUSH
57049: EMPTY
57050: LIST
57051: LIST
57052: LIST
57053: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57054: LD_VAR 0 6
57058: PPUSH
57059: CALL_OW 257
57063: PUSH
57064: LD_INT 9
57066: EQUAL
57067: IFFALSE 57088
// points := [ 20 , 55 , 40 ] ;
57069: LD_ADDR_VAR 0 9
57073: PUSH
57074: LD_INT 20
57076: PUSH
57077: LD_INT 55
57079: PUSH
57080: LD_INT 40
57082: PUSH
57083: EMPTY
57084: LIST
57085: LIST
57086: LIST
57087: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57088: LD_VAR 0 6
57092: PPUSH
57093: CALL_OW 257
57097: PUSH
57098: LD_INT 12
57100: PUSH
57101: LD_INT 16
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: IN
57108: IFFALSE 57129
// points := [ 5 , 3 , 2 ] ;
57110: LD_ADDR_VAR 0 9
57114: PUSH
57115: LD_INT 5
57117: PUSH
57118: LD_INT 3
57120: PUSH
57121: LD_INT 2
57123: PUSH
57124: EMPTY
57125: LIST
57126: LIST
57127: LIST
57128: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57129: LD_VAR 0 6
57133: PPUSH
57134: CALL_OW 257
57138: PUSH
57139: LD_INT 17
57141: EQUAL
57142: IFFALSE 57163
// points := [ 100 , 50 , 75 ] ;
57144: LD_ADDR_VAR 0 9
57148: PUSH
57149: LD_INT 100
57151: PUSH
57152: LD_INT 50
57154: PUSH
57155: LD_INT 75
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: LIST
57162: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57163: LD_VAR 0 6
57167: PPUSH
57168: CALL_OW 257
57172: PUSH
57173: LD_INT 15
57175: EQUAL
57176: IFFALSE 57197
// points := [ 10 , 5 , 3 ] ;
57178: LD_ADDR_VAR 0 9
57182: PUSH
57183: LD_INT 10
57185: PUSH
57186: LD_INT 5
57188: PUSH
57189: LD_INT 3
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: LIST
57196: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57197: LD_VAR 0 6
57201: PPUSH
57202: CALL_OW 257
57206: PUSH
57207: LD_INT 14
57209: EQUAL
57210: IFFALSE 57231
// points := [ 10 , 0 , 0 ] ;
57212: LD_ADDR_VAR 0 9
57216: PUSH
57217: LD_INT 10
57219: PUSH
57220: LD_INT 0
57222: PUSH
57223: LD_INT 0
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: LIST
57230: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57231: LD_VAR 0 6
57235: PPUSH
57236: CALL_OW 257
57240: PUSH
57241: LD_INT 11
57243: EQUAL
57244: IFFALSE 57265
// points := [ 30 , 10 , 5 ] ;
57246: LD_ADDR_VAR 0 9
57250: PUSH
57251: LD_INT 30
57253: PUSH
57254: LD_INT 10
57256: PUSH
57257: LD_INT 5
57259: PUSH
57260: EMPTY
57261: LIST
57262: LIST
57263: LIST
57264: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57265: LD_VAR 0 1
57269: PPUSH
57270: LD_INT 5
57272: PPUSH
57273: CALL_OW 321
57277: PUSH
57278: LD_INT 2
57280: EQUAL
57281: IFFALSE 57298
// bpoints := bpoints * 1.8 ;
57283: LD_ADDR_VAR 0 10
57287: PUSH
57288: LD_VAR 0 10
57292: PUSH
57293: LD_REAL  1.80000000000000E+0000
57296: MUL
57297: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57298: LD_VAR 0 6
57302: PPUSH
57303: CALL_OW 257
57307: PUSH
57308: LD_INT 1
57310: PUSH
57311: LD_INT 2
57313: PUSH
57314: LD_INT 3
57316: PUSH
57317: LD_INT 4
57319: PUSH
57320: EMPTY
57321: LIST
57322: LIST
57323: LIST
57324: LIST
57325: IN
57326: PUSH
57327: LD_VAR 0 1
57331: PPUSH
57332: LD_INT 51
57334: PPUSH
57335: CALL_OW 321
57339: PUSH
57340: LD_INT 2
57342: EQUAL
57343: AND
57344: IFFALSE 57361
// bpoints := bpoints * 1.2 ;
57346: LD_ADDR_VAR 0 10
57350: PUSH
57351: LD_VAR 0 10
57355: PUSH
57356: LD_REAL  1.20000000000000E+0000
57359: MUL
57360: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57361: LD_VAR 0 6
57365: PPUSH
57366: CALL_OW 257
57370: PUSH
57371: LD_INT 5
57373: PUSH
57374: LD_INT 7
57376: PUSH
57377: LD_INT 9
57379: PUSH
57380: EMPTY
57381: LIST
57382: LIST
57383: LIST
57384: IN
57385: PUSH
57386: LD_VAR 0 1
57390: PPUSH
57391: LD_INT 52
57393: PPUSH
57394: CALL_OW 321
57398: PUSH
57399: LD_INT 2
57401: EQUAL
57402: AND
57403: IFFALSE 57420
// bpoints := bpoints * 1.5 ;
57405: LD_ADDR_VAR 0 10
57409: PUSH
57410: LD_VAR 0 10
57414: PUSH
57415: LD_REAL  1.50000000000000E+0000
57418: MUL
57419: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57420: LD_VAR 0 1
57424: PPUSH
57425: LD_INT 66
57427: PPUSH
57428: CALL_OW 321
57432: PUSH
57433: LD_INT 2
57435: EQUAL
57436: IFFALSE 57453
// bpoints := bpoints * 1.1 ;
57438: LD_ADDR_VAR 0 10
57442: PUSH
57443: LD_VAR 0 10
57447: PUSH
57448: LD_REAL  1.10000000000000E+0000
57451: MUL
57452: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57453: LD_ADDR_VAR 0 10
57457: PUSH
57458: LD_VAR 0 10
57462: PUSH
57463: LD_VAR 0 6
57467: PPUSH
57468: LD_INT 1
57470: PPUSH
57471: CALL_OW 259
57475: PUSH
57476: LD_REAL  1.15000000000000E+0000
57479: MUL
57480: MUL
57481: ST_TO_ADDR
// end ; unit_vehicle :
57482: GO 58306
57484: LD_INT 2
57486: DOUBLE
57487: EQUAL
57488: IFTRUE 57492
57490: GO 58294
57492: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57493: LD_VAR 0 6
57497: PPUSH
57498: CALL_OW 264
57502: PUSH
57503: LD_INT 2
57505: PUSH
57506: LD_INT 42
57508: PUSH
57509: LD_INT 24
57511: PUSH
57512: EMPTY
57513: LIST
57514: LIST
57515: LIST
57516: IN
57517: IFFALSE 57538
// points := [ 25 , 5 , 3 ] ;
57519: LD_ADDR_VAR 0 9
57523: PUSH
57524: LD_INT 25
57526: PUSH
57527: LD_INT 5
57529: PUSH
57530: LD_INT 3
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: LIST
57537: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57538: LD_VAR 0 6
57542: PPUSH
57543: CALL_OW 264
57547: PUSH
57548: LD_INT 4
57550: PUSH
57551: LD_INT 43
57553: PUSH
57554: LD_INT 25
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: LIST
57561: IN
57562: IFFALSE 57583
// points := [ 40 , 15 , 5 ] ;
57564: LD_ADDR_VAR 0 9
57568: PUSH
57569: LD_INT 40
57571: PUSH
57572: LD_INT 15
57574: PUSH
57575: LD_INT 5
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: LIST
57582: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57583: LD_VAR 0 6
57587: PPUSH
57588: CALL_OW 264
57592: PUSH
57593: LD_INT 3
57595: PUSH
57596: LD_INT 23
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: IN
57603: IFFALSE 57624
// points := [ 7 , 25 , 8 ] ;
57605: LD_ADDR_VAR 0 9
57609: PUSH
57610: LD_INT 7
57612: PUSH
57613: LD_INT 25
57615: PUSH
57616: LD_INT 8
57618: PUSH
57619: EMPTY
57620: LIST
57621: LIST
57622: LIST
57623: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57624: LD_VAR 0 6
57628: PPUSH
57629: CALL_OW 264
57633: PUSH
57634: LD_INT 5
57636: PUSH
57637: LD_INT 27
57639: PUSH
57640: LD_INT 44
57642: PUSH
57643: EMPTY
57644: LIST
57645: LIST
57646: LIST
57647: IN
57648: IFFALSE 57669
// points := [ 14 , 50 , 16 ] ;
57650: LD_ADDR_VAR 0 9
57654: PUSH
57655: LD_INT 14
57657: PUSH
57658: LD_INT 50
57660: PUSH
57661: LD_INT 16
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: LIST
57668: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57669: LD_VAR 0 6
57673: PPUSH
57674: CALL_OW 264
57678: PUSH
57679: LD_INT 6
57681: PUSH
57682: LD_INT 46
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: IN
57689: IFFALSE 57710
// points := [ 32 , 120 , 70 ] ;
57691: LD_ADDR_VAR 0 9
57695: PUSH
57696: LD_INT 32
57698: PUSH
57699: LD_INT 120
57701: PUSH
57702: LD_INT 70
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: LIST
57709: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57710: LD_VAR 0 6
57714: PPUSH
57715: CALL_OW 264
57719: PUSH
57720: LD_INT 7
57722: PUSH
57723: LD_INT 28
57725: PUSH
57726: LD_INT 45
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: LIST
57733: IN
57734: IFFALSE 57755
// points := [ 35 , 20 , 45 ] ;
57736: LD_ADDR_VAR 0 9
57740: PUSH
57741: LD_INT 35
57743: PUSH
57744: LD_INT 20
57746: PUSH
57747: LD_INT 45
57749: PUSH
57750: EMPTY
57751: LIST
57752: LIST
57753: LIST
57754: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57755: LD_VAR 0 6
57759: PPUSH
57760: CALL_OW 264
57764: PUSH
57765: LD_INT 47
57767: PUSH
57768: EMPTY
57769: LIST
57770: IN
57771: IFFALSE 57792
// points := [ 67 , 45 , 75 ] ;
57773: LD_ADDR_VAR 0 9
57777: PUSH
57778: LD_INT 67
57780: PUSH
57781: LD_INT 45
57783: PUSH
57784: LD_INT 75
57786: PUSH
57787: EMPTY
57788: LIST
57789: LIST
57790: LIST
57791: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57792: LD_VAR 0 6
57796: PPUSH
57797: CALL_OW 264
57801: PUSH
57802: LD_INT 26
57804: PUSH
57805: EMPTY
57806: LIST
57807: IN
57808: IFFALSE 57829
// points := [ 120 , 30 , 80 ] ;
57810: LD_ADDR_VAR 0 9
57814: PUSH
57815: LD_INT 120
57817: PUSH
57818: LD_INT 30
57820: PUSH
57821: LD_INT 80
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: LIST
57828: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57829: LD_VAR 0 6
57833: PPUSH
57834: CALL_OW 264
57838: PUSH
57839: LD_INT 22
57841: PUSH
57842: EMPTY
57843: LIST
57844: IN
57845: IFFALSE 57866
// points := [ 40 , 1 , 1 ] ;
57847: LD_ADDR_VAR 0 9
57851: PUSH
57852: LD_INT 40
57854: PUSH
57855: LD_INT 1
57857: PUSH
57858: LD_INT 1
57860: PUSH
57861: EMPTY
57862: LIST
57863: LIST
57864: LIST
57865: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57866: LD_VAR 0 6
57870: PPUSH
57871: CALL_OW 264
57875: PUSH
57876: LD_INT 29
57878: PUSH
57879: EMPTY
57880: LIST
57881: IN
57882: IFFALSE 57903
// points := [ 70 , 200 , 400 ] ;
57884: LD_ADDR_VAR 0 9
57888: PUSH
57889: LD_INT 70
57891: PUSH
57892: LD_INT 200
57894: PUSH
57895: LD_INT 400
57897: PUSH
57898: EMPTY
57899: LIST
57900: LIST
57901: LIST
57902: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57903: LD_VAR 0 6
57907: PPUSH
57908: CALL_OW 264
57912: PUSH
57913: LD_INT 14
57915: PUSH
57916: LD_INT 53
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: IN
57923: IFFALSE 57944
// points := [ 40 , 10 , 20 ] ;
57925: LD_ADDR_VAR 0 9
57929: PUSH
57930: LD_INT 40
57932: PUSH
57933: LD_INT 10
57935: PUSH
57936: LD_INT 20
57938: PUSH
57939: EMPTY
57940: LIST
57941: LIST
57942: LIST
57943: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57944: LD_VAR 0 6
57948: PPUSH
57949: CALL_OW 264
57953: PUSH
57954: LD_INT 9
57956: PUSH
57957: EMPTY
57958: LIST
57959: IN
57960: IFFALSE 57981
// points := [ 5 , 70 , 20 ] ;
57962: LD_ADDR_VAR 0 9
57966: PUSH
57967: LD_INT 5
57969: PUSH
57970: LD_INT 70
57972: PUSH
57973: LD_INT 20
57975: PUSH
57976: EMPTY
57977: LIST
57978: LIST
57979: LIST
57980: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57981: LD_VAR 0 6
57985: PPUSH
57986: CALL_OW 264
57990: PUSH
57991: LD_INT 10
57993: PUSH
57994: EMPTY
57995: LIST
57996: IN
57997: IFFALSE 58018
// points := [ 35 , 110 , 70 ] ;
57999: LD_ADDR_VAR 0 9
58003: PUSH
58004: LD_INT 35
58006: PUSH
58007: LD_INT 110
58009: PUSH
58010: LD_INT 70
58012: PUSH
58013: EMPTY
58014: LIST
58015: LIST
58016: LIST
58017: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58018: LD_VAR 0 6
58022: PPUSH
58023: CALL_OW 265
58027: PUSH
58028: LD_INT 25
58030: EQUAL
58031: IFFALSE 58052
// points := [ 80 , 65 , 100 ] ;
58033: LD_ADDR_VAR 0 9
58037: PUSH
58038: LD_INT 80
58040: PUSH
58041: LD_INT 65
58043: PUSH
58044: LD_INT 100
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: LIST
58051: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58052: LD_VAR 0 6
58056: PPUSH
58057: CALL_OW 263
58061: PUSH
58062: LD_INT 1
58064: EQUAL
58065: IFFALSE 58100
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58067: LD_ADDR_VAR 0 10
58071: PUSH
58072: LD_VAR 0 10
58076: PUSH
58077: LD_VAR 0 6
58081: PPUSH
58082: CALL_OW 311
58086: PPUSH
58087: LD_INT 3
58089: PPUSH
58090: CALL_OW 259
58094: PUSH
58095: LD_INT 4
58097: MUL
58098: MUL
58099: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58100: LD_VAR 0 6
58104: PPUSH
58105: CALL_OW 263
58109: PUSH
58110: LD_INT 2
58112: EQUAL
58113: IFFALSE 58164
// begin j := IsControledBy ( i ) ;
58115: LD_ADDR_VAR 0 7
58119: PUSH
58120: LD_VAR 0 6
58124: PPUSH
58125: CALL_OW 312
58129: ST_TO_ADDR
// if j then
58130: LD_VAR 0 7
58134: IFFALSE 58164
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58136: LD_ADDR_VAR 0 10
58140: PUSH
58141: LD_VAR 0 10
58145: PUSH
58146: LD_VAR 0 7
58150: PPUSH
58151: LD_INT 3
58153: PPUSH
58154: CALL_OW 259
58158: PUSH
58159: LD_INT 3
58161: MUL
58162: MUL
58163: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58164: LD_VAR 0 6
58168: PPUSH
58169: CALL_OW 264
58173: PUSH
58174: LD_INT 5
58176: PUSH
58177: LD_INT 6
58179: PUSH
58180: LD_INT 46
58182: PUSH
58183: LD_INT 44
58185: PUSH
58186: LD_INT 47
58188: PUSH
58189: LD_INT 45
58191: PUSH
58192: LD_INT 28
58194: PUSH
58195: LD_INT 7
58197: PUSH
58198: LD_INT 27
58200: PUSH
58201: LD_INT 29
58203: PUSH
58204: EMPTY
58205: LIST
58206: LIST
58207: LIST
58208: LIST
58209: LIST
58210: LIST
58211: LIST
58212: LIST
58213: LIST
58214: LIST
58215: IN
58216: PUSH
58217: LD_VAR 0 1
58221: PPUSH
58222: LD_INT 52
58224: PPUSH
58225: CALL_OW 321
58229: PUSH
58230: LD_INT 2
58232: EQUAL
58233: AND
58234: IFFALSE 58251
// bpoints := bpoints * 1.2 ;
58236: LD_ADDR_VAR 0 10
58240: PUSH
58241: LD_VAR 0 10
58245: PUSH
58246: LD_REAL  1.20000000000000E+0000
58249: MUL
58250: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58251: LD_VAR 0 6
58255: PPUSH
58256: CALL_OW 264
58260: PUSH
58261: LD_INT 6
58263: PUSH
58264: LD_INT 46
58266: PUSH
58267: LD_INT 47
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: LIST
58274: IN
58275: IFFALSE 58292
// bpoints := bpoints * 1.2 ;
58277: LD_ADDR_VAR 0 10
58281: PUSH
58282: LD_VAR 0 10
58286: PUSH
58287: LD_REAL  1.20000000000000E+0000
58290: MUL
58291: ST_TO_ADDR
// end ; unit_building :
58292: GO 58306
58294: LD_INT 3
58296: DOUBLE
58297: EQUAL
58298: IFTRUE 58302
58300: GO 58305
58302: POP
// ; end ;
58303: GO 58306
58305: POP
// for j = 1 to 3 do
58306: LD_ADDR_VAR 0 7
58310: PUSH
58311: DOUBLE
58312: LD_INT 1
58314: DEC
58315: ST_TO_ADDR
58316: LD_INT 3
58318: PUSH
58319: FOR_TO
58320: IFFALSE 58373
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58322: LD_ADDR_VAR 0 5
58326: PUSH
58327: LD_VAR 0 5
58331: PPUSH
58332: LD_VAR 0 7
58336: PPUSH
58337: LD_VAR 0 5
58341: PUSH
58342: LD_VAR 0 7
58346: ARRAY
58347: PUSH
58348: LD_VAR 0 9
58352: PUSH
58353: LD_VAR 0 7
58357: ARRAY
58358: PUSH
58359: LD_VAR 0 10
58363: MUL
58364: PLUS
58365: PPUSH
58366: CALL_OW 1
58370: ST_TO_ADDR
58371: GO 58319
58373: POP
58374: POP
// end ;
58375: GO 56858
58377: POP
58378: POP
// result := Replace ( result , 4 , tmp ) ;
58379: LD_ADDR_VAR 0 5
58383: PUSH
58384: LD_VAR 0 5
58388: PPUSH
58389: LD_INT 4
58391: PPUSH
58392: LD_VAR 0 8
58396: PPUSH
58397: CALL_OW 1
58401: ST_TO_ADDR
// end ;
58402: LD_VAR 0 5
58406: RET
// export function DangerAtRange ( unit , range ) ; begin
58407: LD_INT 0
58409: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58410: LD_ADDR_VAR 0 3
58414: PUSH
58415: LD_VAR 0 1
58419: PPUSH
58420: CALL_OW 255
58424: PPUSH
58425: LD_VAR 0 1
58429: PPUSH
58430: CALL_OW 250
58434: PPUSH
58435: LD_VAR 0 1
58439: PPUSH
58440: CALL_OW 251
58444: PPUSH
58445: LD_VAR 0 2
58449: PPUSH
58450: CALL 56710 0 4
58454: ST_TO_ADDR
// end ;
58455: LD_VAR 0 3
58459: RET
// export function DangerInArea ( side , area ) ; begin
58460: LD_INT 0
58462: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58463: LD_ADDR_VAR 0 3
58467: PUSH
58468: LD_VAR 0 2
58472: PPUSH
58473: LD_INT 81
58475: PUSH
58476: LD_VAR 0 1
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: PPUSH
58485: CALL_OW 70
58489: ST_TO_ADDR
// end ;
58490: LD_VAR 0 3
58494: RET
// export function IsExtension ( b ) ; begin
58495: LD_INT 0
58497: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58498: LD_ADDR_VAR 0 2
58502: PUSH
58503: LD_VAR 0 1
58507: PUSH
58508: LD_INT 23
58510: PUSH
58511: LD_INT 20
58513: PUSH
58514: LD_INT 22
58516: PUSH
58517: LD_INT 17
58519: PUSH
58520: LD_INT 24
58522: PUSH
58523: LD_INT 21
58525: PUSH
58526: LD_INT 19
58528: PUSH
58529: LD_INT 16
58531: PUSH
58532: LD_INT 25
58534: PUSH
58535: LD_INT 18
58537: PUSH
58538: EMPTY
58539: LIST
58540: LIST
58541: LIST
58542: LIST
58543: LIST
58544: LIST
58545: LIST
58546: LIST
58547: LIST
58548: LIST
58549: IN
58550: ST_TO_ADDR
// end ;
58551: LD_VAR 0 2
58555: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58556: LD_INT 0
58558: PPUSH
58559: PPUSH
58560: PPUSH
// result := [ ] ;
58561: LD_ADDR_VAR 0 3
58565: PUSH
58566: EMPTY
58567: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58568: LD_ADDR_VAR 0 4
58572: PUSH
58573: LD_VAR 0 2
58577: PPUSH
58578: LD_INT 21
58580: PUSH
58581: LD_INT 3
58583: PUSH
58584: EMPTY
58585: LIST
58586: LIST
58587: PPUSH
58588: CALL_OW 70
58592: ST_TO_ADDR
// if not tmp then
58593: LD_VAR 0 4
58597: NOT
58598: IFFALSE 58602
// exit ;
58600: GO 58660
// for i in tmp do
58602: LD_ADDR_VAR 0 5
58606: PUSH
58607: LD_VAR 0 4
58611: PUSH
58612: FOR_IN
58613: IFFALSE 58648
// if GetBase ( i ) <> base then
58615: LD_VAR 0 5
58619: PPUSH
58620: CALL_OW 274
58624: PUSH
58625: LD_VAR 0 1
58629: NONEQUAL
58630: IFFALSE 58646
// ComLinkToBase ( base , i ) ;
58632: LD_VAR 0 1
58636: PPUSH
58637: LD_VAR 0 5
58641: PPUSH
58642: CALL_OW 169
58646: GO 58612
58648: POP
58649: POP
// result := tmp ;
58650: LD_ADDR_VAR 0 3
58654: PUSH
58655: LD_VAR 0 4
58659: ST_TO_ADDR
// end ;
58660: LD_VAR 0 3
58664: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58665: LD_INT 0
58667: PPUSH
58668: PPUSH
// if BuildingStatus ( b ) = bs_build then
58669: LD_VAR 0 2
58673: PPUSH
58674: CALL_OW 461
58678: PUSH
58679: LD_INT 1
58681: EQUAL
58682: IFFALSE 58742
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58684: LD_VAR 0 1
58688: PPUSH
58689: LD_STRING h
58691: PUSH
58692: LD_VAR 0 2
58696: PPUSH
58697: CALL_OW 250
58701: PUSH
58702: LD_VAR 0 2
58706: PPUSH
58707: CALL_OW 251
58711: PUSH
58712: LD_VAR 0 2
58716: PUSH
58717: LD_INT 0
58719: PUSH
58720: LD_INT 0
58722: PUSH
58723: LD_INT 0
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: LIST
58730: LIST
58731: LIST
58732: LIST
58733: LIST
58734: PUSH
58735: EMPTY
58736: LIST
58737: PPUSH
58738: CALL_OW 446
// end ;
58742: LD_VAR 0 3
58746: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58747: LD_INT 0
58749: PPUSH
58750: PPUSH
58751: PPUSH
58752: PPUSH
58753: PPUSH
58754: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58755: LD_VAR 0 1
58759: NOT
58760: PUSH
58761: LD_VAR 0 1
58765: PPUSH
58766: CALL_OW 263
58770: PUSH
58771: LD_INT 2
58773: EQUAL
58774: NOT
58775: OR
58776: IFFALSE 58780
// exit ;
58778: GO 59096
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58780: LD_ADDR_VAR 0 6
58784: PUSH
58785: LD_INT 22
58787: PUSH
58788: LD_VAR 0 1
58792: PPUSH
58793: CALL_OW 255
58797: PUSH
58798: EMPTY
58799: LIST
58800: LIST
58801: PUSH
58802: LD_INT 2
58804: PUSH
58805: LD_INT 30
58807: PUSH
58808: LD_INT 36
58810: PUSH
58811: EMPTY
58812: LIST
58813: LIST
58814: PUSH
58815: LD_INT 34
58817: PUSH
58818: LD_INT 31
58820: PUSH
58821: EMPTY
58822: LIST
58823: LIST
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: LIST
58829: PUSH
58830: EMPTY
58831: LIST
58832: LIST
58833: PPUSH
58834: CALL_OW 69
58838: ST_TO_ADDR
// if not tmp then
58839: LD_VAR 0 6
58843: NOT
58844: IFFALSE 58848
// exit ;
58846: GO 59096
// result := [ ] ;
58848: LD_ADDR_VAR 0 2
58852: PUSH
58853: EMPTY
58854: ST_TO_ADDR
// for i in tmp do
58855: LD_ADDR_VAR 0 3
58859: PUSH
58860: LD_VAR 0 6
58864: PUSH
58865: FOR_IN
58866: IFFALSE 58937
// begin t := UnitsInside ( i ) ;
58868: LD_ADDR_VAR 0 4
58872: PUSH
58873: LD_VAR 0 3
58877: PPUSH
58878: CALL_OW 313
58882: ST_TO_ADDR
// if t then
58883: LD_VAR 0 4
58887: IFFALSE 58935
// for j in t do
58889: LD_ADDR_VAR 0 7
58893: PUSH
58894: LD_VAR 0 4
58898: PUSH
58899: FOR_IN
58900: IFFALSE 58933
// result := Insert ( result , result + 1 , j ) ;
58902: LD_ADDR_VAR 0 2
58906: PUSH
58907: LD_VAR 0 2
58911: PPUSH
58912: LD_VAR 0 2
58916: PUSH
58917: LD_INT 1
58919: PLUS
58920: PPUSH
58921: LD_VAR 0 7
58925: PPUSH
58926: CALL_OW 2
58930: ST_TO_ADDR
58931: GO 58899
58933: POP
58934: POP
// end ;
58935: GO 58865
58937: POP
58938: POP
// if not result then
58939: LD_VAR 0 2
58943: NOT
58944: IFFALSE 58948
// exit ;
58946: GO 59096
// mech := result [ 1 ] ;
58948: LD_ADDR_VAR 0 5
58952: PUSH
58953: LD_VAR 0 2
58957: PUSH
58958: LD_INT 1
58960: ARRAY
58961: ST_TO_ADDR
// if result > 1 then
58962: LD_VAR 0 2
58966: PUSH
58967: LD_INT 1
58969: GREATER
58970: IFFALSE 59082
// for i = 2 to result do
58972: LD_ADDR_VAR 0 3
58976: PUSH
58977: DOUBLE
58978: LD_INT 2
58980: DEC
58981: ST_TO_ADDR
58982: LD_VAR 0 2
58986: PUSH
58987: FOR_TO
58988: IFFALSE 59080
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58990: LD_ADDR_VAR 0 4
58994: PUSH
58995: LD_VAR 0 2
58999: PUSH
59000: LD_VAR 0 3
59004: ARRAY
59005: PPUSH
59006: LD_INT 3
59008: PPUSH
59009: CALL_OW 259
59013: PUSH
59014: LD_VAR 0 2
59018: PUSH
59019: LD_VAR 0 3
59023: ARRAY
59024: PPUSH
59025: CALL_OW 432
59029: MINUS
59030: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59031: LD_VAR 0 4
59035: PUSH
59036: LD_VAR 0 5
59040: PPUSH
59041: LD_INT 3
59043: PPUSH
59044: CALL_OW 259
59048: PUSH
59049: LD_VAR 0 5
59053: PPUSH
59054: CALL_OW 432
59058: MINUS
59059: GREATEREQUAL
59060: IFFALSE 59078
// mech := result [ i ] ;
59062: LD_ADDR_VAR 0 5
59066: PUSH
59067: LD_VAR 0 2
59071: PUSH
59072: LD_VAR 0 3
59076: ARRAY
59077: ST_TO_ADDR
// end ;
59078: GO 58987
59080: POP
59081: POP
// ComLinkTo ( vehicle , mech ) ;
59082: LD_VAR 0 1
59086: PPUSH
59087: LD_VAR 0 5
59091: PPUSH
59092: CALL_OW 135
// end ;
59096: LD_VAR 0 2
59100: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59101: LD_INT 0
59103: PPUSH
59104: PPUSH
59105: PPUSH
59106: PPUSH
59107: PPUSH
59108: PPUSH
59109: PPUSH
59110: PPUSH
59111: PPUSH
59112: PPUSH
59113: PPUSH
59114: PPUSH
59115: PPUSH
// result := [ ] ;
59116: LD_ADDR_VAR 0 7
59120: PUSH
59121: EMPTY
59122: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59123: LD_VAR 0 1
59127: PPUSH
59128: CALL_OW 266
59132: PUSH
59133: LD_INT 0
59135: PUSH
59136: LD_INT 1
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: IN
59143: NOT
59144: IFFALSE 59148
// exit ;
59146: GO 60779
// if name then
59148: LD_VAR 0 3
59152: IFFALSE 59168
// SetBName ( base_dep , name ) ;
59154: LD_VAR 0 1
59158: PPUSH
59159: LD_VAR 0 3
59163: PPUSH
59164: CALL_OW 500
// base := GetBase ( base_dep ) ;
59168: LD_ADDR_VAR 0 15
59172: PUSH
59173: LD_VAR 0 1
59177: PPUSH
59178: CALL_OW 274
59182: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59183: LD_ADDR_VAR 0 16
59187: PUSH
59188: LD_VAR 0 1
59192: PPUSH
59193: CALL_OW 255
59197: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59198: LD_ADDR_VAR 0 17
59202: PUSH
59203: LD_VAR 0 1
59207: PPUSH
59208: CALL_OW 248
59212: ST_TO_ADDR
// if sources then
59213: LD_VAR 0 5
59217: IFFALSE 59264
// for i = 1 to 3 do
59219: LD_ADDR_VAR 0 8
59223: PUSH
59224: DOUBLE
59225: LD_INT 1
59227: DEC
59228: ST_TO_ADDR
59229: LD_INT 3
59231: PUSH
59232: FOR_TO
59233: IFFALSE 59262
// AddResourceType ( base , i , sources [ i ] ) ;
59235: LD_VAR 0 15
59239: PPUSH
59240: LD_VAR 0 8
59244: PPUSH
59245: LD_VAR 0 5
59249: PUSH
59250: LD_VAR 0 8
59254: ARRAY
59255: PPUSH
59256: CALL_OW 276
59260: GO 59232
59262: POP
59263: POP
// buildings := GetBaseBuildings ( base , area ) ;
59264: LD_ADDR_VAR 0 18
59268: PUSH
59269: LD_VAR 0 15
59273: PPUSH
59274: LD_VAR 0 2
59278: PPUSH
59279: CALL 58556 0 2
59283: ST_TO_ADDR
// InitHc ;
59284: CALL_OW 19
// InitUc ;
59288: CALL_OW 18
// uc_side := side ;
59292: LD_ADDR_OWVAR 20
59296: PUSH
59297: LD_VAR 0 16
59301: ST_TO_ADDR
// uc_nation := nation ;
59302: LD_ADDR_OWVAR 21
59306: PUSH
59307: LD_VAR 0 17
59311: ST_TO_ADDR
// if buildings then
59312: LD_VAR 0 18
59316: IFFALSE 60638
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59318: LD_ADDR_VAR 0 19
59322: PUSH
59323: LD_VAR 0 18
59327: PPUSH
59328: LD_INT 2
59330: PUSH
59331: LD_INT 30
59333: PUSH
59334: LD_INT 29
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: PUSH
59341: LD_INT 30
59343: PUSH
59344: LD_INT 30
59346: PUSH
59347: EMPTY
59348: LIST
59349: LIST
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: LIST
59355: PPUSH
59356: CALL_OW 72
59360: ST_TO_ADDR
// if tmp then
59361: LD_VAR 0 19
59365: IFFALSE 59413
// for i in tmp do
59367: LD_ADDR_VAR 0 8
59371: PUSH
59372: LD_VAR 0 19
59376: PUSH
59377: FOR_IN
59378: IFFALSE 59411
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59380: LD_VAR 0 8
59384: PPUSH
59385: CALL_OW 250
59389: PPUSH
59390: LD_VAR 0 8
59394: PPUSH
59395: CALL_OW 251
59399: PPUSH
59400: LD_VAR 0 16
59404: PPUSH
59405: CALL_OW 441
59409: GO 59377
59411: POP
59412: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59413: LD_VAR 0 18
59417: PPUSH
59418: LD_INT 2
59420: PUSH
59421: LD_INT 30
59423: PUSH
59424: LD_INT 32
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PUSH
59431: LD_INT 30
59433: PUSH
59434: LD_INT 33
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: LIST
59445: PPUSH
59446: CALL_OW 72
59450: IFFALSE 59538
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59452: LD_ADDR_VAR 0 8
59456: PUSH
59457: LD_VAR 0 18
59461: PPUSH
59462: LD_INT 2
59464: PUSH
59465: LD_INT 30
59467: PUSH
59468: LD_INT 32
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: PUSH
59475: LD_INT 30
59477: PUSH
59478: LD_INT 33
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: LIST
59489: PPUSH
59490: CALL_OW 72
59494: PUSH
59495: FOR_IN
59496: IFFALSE 59536
// begin if not GetBWeapon ( i ) then
59498: LD_VAR 0 8
59502: PPUSH
59503: CALL_OW 269
59507: NOT
59508: IFFALSE 59534
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59510: LD_VAR 0 8
59514: PPUSH
59515: LD_VAR 0 8
59519: PPUSH
59520: LD_VAR 0 2
59524: PPUSH
59525: CALL 60784 0 2
59529: PPUSH
59530: CALL_OW 431
// end ;
59534: GO 59495
59536: POP
59537: POP
// end ; for i = 1 to personel do
59538: LD_ADDR_VAR 0 8
59542: PUSH
59543: DOUBLE
59544: LD_INT 1
59546: DEC
59547: ST_TO_ADDR
59548: LD_VAR 0 6
59552: PUSH
59553: FOR_TO
59554: IFFALSE 60618
// begin if i > 4 then
59556: LD_VAR 0 8
59560: PUSH
59561: LD_INT 4
59563: GREATER
59564: IFFALSE 59568
// break ;
59566: GO 60618
// case i of 1 :
59568: LD_VAR 0 8
59572: PUSH
59573: LD_INT 1
59575: DOUBLE
59576: EQUAL
59577: IFTRUE 59581
59579: GO 59661
59581: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59582: LD_ADDR_VAR 0 12
59586: PUSH
59587: LD_VAR 0 18
59591: PPUSH
59592: LD_INT 22
59594: PUSH
59595: LD_VAR 0 16
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: PUSH
59604: LD_INT 58
59606: PUSH
59607: EMPTY
59608: LIST
59609: PUSH
59610: LD_INT 2
59612: PUSH
59613: LD_INT 30
59615: PUSH
59616: LD_INT 32
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: PUSH
59623: LD_INT 30
59625: PUSH
59626: LD_INT 4
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: PUSH
59633: LD_INT 30
59635: PUSH
59636: LD_INT 5
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: LIST
59647: LIST
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: PPUSH
59654: CALL_OW 72
59658: ST_TO_ADDR
59659: GO 59883
59661: LD_INT 2
59663: DOUBLE
59664: EQUAL
59665: IFTRUE 59669
59667: GO 59731
59669: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59670: LD_ADDR_VAR 0 12
59674: PUSH
59675: LD_VAR 0 18
59679: PPUSH
59680: LD_INT 22
59682: PUSH
59683: LD_VAR 0 16
59687: PUSH
59688: EMPTY
59689: LIST
59690: LIST
59691: PUSH
59692: LD_INT 2
59694: PUSH
59695: LD_INT 30
59697: PUSH
59698: LD_INT 0
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: LD_INT 30
59707: PUSH
59708: LD_INT 1
59710: PUSH
59711: EMPTY
59712: LIST
59713: LIST
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: LIST
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PPUSH
59724: CALL_OW 72
59728: ST_TO_ADDR
59729: GO 59883
59731: LD_INT 3
59733: DOUBLE
59734: EQUAL
59735: IFTRUE 59739
59737: GO 59801
59739: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59740: LD_ADDR_VAR 0 12
59744: PUSH
59745: LD_VAR 0 18
59749: PPUSH
59750: LD_INT 22
59752: PUSH
59753: LD_VAR 0 16
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PUSH
59762: LD_INT 2
59764: PUSH
59765: LD_INT 30
59767: PUSH
59768: LD_INT 2
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: LD_INT 30
59777: PUSH
59778: LD_INT 3
59780: PUSH
59781: EMPTY
59782: LIST
59783: LIST
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: LIST
59789: PUSH
59790: EMPTY
59791: LIST
59792: LIST
59793: PPUSH
59794: CALL_OW 72
59798: ST_TO_ADDR
59799: GO 59883
59801: LD_INT 4
59803: DOUBLE
59804: EQUAL
59805: IFTRUE 59809
59807: GO 59882
59809: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59810: LD_ADDR_VAR 0 12
59814: PUSH
59815: LD_VAR 0 18
59819: PPUSH
59820: LD_INT 22
59822: PUSH
59823: LD_VAR 0 16
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: PUSH
59832: LD_INT 2
59834: PUSH
59835: LD_INT 30
59837: PUSH
59838: LD_INT 6
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: PUSH
59845: LD_INT 30
59847: PUSH
59848: LD_INT 7
59850: PUSH
59851: EMPTY
59852: LIST
59853: LIST
59854: PUSH
59855: LD_INT 30
59857: PUSH
59858: LD_INT 8
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: LIST
59869: LIST
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PPUSH
59875: CALL_OW 72
59879: ST_TO_ADDR
59880: GO 59883
59882: POP
// if i = 1 then
59883: LD_VAR 0 8
59887: PUSH
59888: LD_INT 1
59890: EQUAL
59891: IFFALSE 60002
// begin tmp := [ ] ;
59893: LD_ADDR_VAR 0 19
59897: PUSH
59898: EMPTY
59899: ST_TO_ADDR
// for j in f do
59900: LD_ADDR_VAR 0 9
59904: PUSH
59905: LD_VAR 0 12
59909: PUSH
59910: FOR_IN
59911: IFFALSE 59984
// if GetBType ( j ) = b_bunker then
59913: LD_VAR 0 9
59917: PPUSH
59918: CALL_OW 266
59922: PUSH
59923: LD_INT 32
59925: EQUAL
59926: IFFALSE 59953
// tmp := Insert ( tmp , 1 , j ) else
59928: LD_ADDR_VAR 0 19
59932: PUSH
59933: LD_VAR 0 19
59937: PPUSH
59938: LD_INT 1
59940: PPUSH
59941: LD_VAR 0 9
59945: PPUSH
59946: CALL_OW 2
59950: ST_TO_ADDR
59951: GO 59982
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59953: LD_ADDR_VAR 0 19
59957: PUSH
59958: LD_VAR 0 19
59962: PPUSH
59963: LD_VAR 0 19
59967: PUSH
59968: LD_INT 1
59970: PLUS
59971: PPUSH
59972: LD_VAR 0 9
59976: PPUSH
59977: CALL_OW 2
59981: ST_TO_ADDR
59982: GO 59910
59984: POP
59985: POP
// if tmp then
59986: LD_VAR 0 19
59990: IFFALSE 60002
// f := tmp ;
59992: LD_ADDR_VAR 0 12
59996: PUSH
59997: LD_VAR 0 19
60001: ST_TO_ADDR
// end ; x := personel [ i ] ;
60002: LD_ADDR_VAR 0 13
60006: PUSH
60007: LD_VAR 0 6
60011: PUSH
60012: LD_VAR 0 8
60016: ARRAY
60017: ST_TO_ADDR
// if x = - 1 then
60018: LD_VAR 0 13
60022: PUSH
60023: LD_INT 1
60025: NEG
60026: EQUAL
60027: IFFALSE 60236
// begin for j in f do
60029: LD_ADDR_VAR 0 9
60033: PUSH
60034: LD_VAR 0 12
60038: PUSH
60039: FOR_IN
60040: IFFALSE 60232
// repeat InitHc ;
60042: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60046: LD_VAR 0 9
60050: PPUSH
60051: CALL_OW 266
60055: PUSH
60056: LD_INT 5
60058: EQUAL
60059: IFFALSE 60129
// begin if UnitsInside ( j ) < 3 then
60061: LD_VAR 0 9
60065: PPUSH
60066: CALL_OW 313
60070: PUSH
60071: LD_INT 3
60073: LESS
60074: IFFALSE 60110
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60076: LD_INT 0
60078: PPUSH
60079: LD_INT 5
60081: PUSH
60082: LD_INT 8
60084: PUSH
60085: LD_INT 9
60087: PUSH
60088: EMPTY
60089: LIST
60090: LIST
60091: LIST
60092: PUSH
60093: LD_VAR 0 17
60097: ARRAY
60098: PPUSH
60099: LD_VAR 0 4
60103: PPUSH
60104: CALL_OW 380
60108: GO 60127
// PrepareHuman ( false , i , skill ) ;
60110: LD_INT 0
60112: PPUSH
60113: LD_VAR 0 8
60117: PPUSH
60118: LD_VAR 0 4
60122: PPUSH
60123: CALL_OW 380
// end else
60127: GO 60146
// PrepareHuman ( false , i , skill ) ;
60129: LD_INT 0
60131: PPUSH
60132: LD_VAR 0 8
60136: PPUSH
60137: LD_VAR 0 4
60141: PPUSH
60142: CALL_OW 380
// un := CreateHuman ;
60146: LD_ADDR_VAR 0 14
60150: PUSH
60151: CALL_OW 44
60155: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60156: LD_ADDR_VAR 0 7
60160: PUSH
60161: LD_VAR 0 7
60165: PPUSH
60166: LD_INT 1
60168: PPUSH
60169: LD_VAR 0 14
60173: PPUSH
60174: CALL_OW 2
60178: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60179: LD_VAR 0 14
60183: PPUSH
60184: LD_VAR 0 9
60188: PPUSH
60189: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60193: LD_VAR 0 9
60197: PPUSH
60198: CALL_OW 313
60202: PUSH
60203: LD_INT 6
60205: EQUAL
60206: PUSH
60207: LD_VAR 0 9
60211: PPUSH
60212: CALL_OW 266
60216: PUSH
60217: LD_INT 32
60219: PUSH
60220: LD_INT 31
60222: PUSH
60223: EMPTY
60224: LIST
60225: LIST
60226: IN
60227: OR
60228: IFFALSE 60042
60230: GO 60039
60232: POP
60233: POP
// end else
60234: GO 60616
// for j = 1 to x do
60236: LD_ADDR_VAR 0 9
60240: PUSH
60241: DOUBLE
60242: LD_INT 1
60244: DEC
60245: ST_TO_ADDR
60246: LD_VAR 0 13
60250: PUSH
60251: FOR_TO
60252: IFFALSE 60614
// begin InitHc ;
60254: CALL_OW 19
// if not f then
60258: LD_VAR 0 12
60262: NOT
60263: IFFALSE 60352
// begin PrepareHuman ( false , i , skill ) ;
60265: LD_INT 0
60267: PPUSH
60268: LD_VAR 0 8
60272: PPUSH
60273: LD_VAR 0 4
60277: PPUSH
60278: CALL_OW 380
// un := CreateHuman ;
60282: LD_ADDR_VAR 0 14
60286: PUSH
60287: CALL_OW 44
60291: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60292: LD_ADDR_VAR 0 7
60296: PUSH
60297: LD_VAR 0 7
60301: PPUSH
60302: LD_INT 1
60304: PPUSH
60305: LD_VAR 0 14
60309: PPUSH
60310: CALL_OW 2
60314: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60315: LD_VAR 0 14
60319: PPUSH
60320: LD_VAR 0 1
60324: PPUSH
60325: CALL_OW 250
60329: PPUSH
60330: LD_VAR 0 1
60334: PPUSH
60335: CALL_OW 251
60339: PPUSH
60340: LD_INT 10
60342: PPUSH
60343: LD_INT 0
60345: PPUSH
60346: CALL_OW 50
// continue ;
60350: GO 60251
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60352: LD_VAR 0 12
60356: PUSH
60357: LD_INT 1
60359: ARRAY
60360: PPUSH
60361: CALL_OW 313
60365: PUSH
60366: LD_VAR 0 12
60370: PUSH
60371: LD_INT 1
60373: ARRAY
60374: PPUSH
60375: CALL_OW 266
60379: PUSH
60380: LD_INT 32
60382: PUSH
60383: LD_INT 31
60385: PUSH
60386: EMPTY
60387: LIST
60388: LIST
60389: IN
60390: AND
60391: PUSH
60392: LD_VAR 0 12
60396: PUSH
60397: LD_INT 1
60399: ARRAY
60400: PPUSH
60401: CALL_OW 313
60405: PUSH
60406: LD_INT 6
60408: EQUAL
60409: OR
60410: IFFALSE 60430
// f := Delete ( f , 1 ) ;
60412: LD_ADDR_VAR 0 12
60416: PUSH
60417: LD_VAR 0 12
60421: PPUSH
60422: LD_INT 1
60424: PPUSH
60425: CALL_OW 3
60429: ST_TO_ADDR
// if not f then
60430: LD_VAR 0 12
60434: NOT
60435: IFFALSE 60453
// begin x := x + 2 ;
60437: LD_ADDR_VAR 0 13
60441: PUSH
60442: LD_VAR 0 13
60446: PUSH
60447: LD_INT 2
60449: PLUS
60450: ST_TO_ADDR
// continue ;
60451: GO 60251
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60453: LD_VAR 0 12
60457: PUSH
60458: LD_INT 1
60460: ARRAY
60461: PPUSH
60462: CALL_OW 266
60466: PUSH
60467: LD_INT 5
60469: EQUAL
60470: IFFALSE 60544
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60472: LD_VAR 0 12
60476: PUSH
60477: LD_INT 1
60479: ARRAY
60480: PPUSH
60481: CALL_OW 313
60485: PUSH
60486: LD_INT 3
60488: LESS
60489: IFFALSE 60525
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60491: LD_INT 0
60493: PPUSH
60494: LD_INT 5
60496: PUSH
60497: LD_INT 8
60499: PUSH
60500: LD_INT 9
60502: PUSH
60503: EMPTY
60504: LIST
60505: LIST
60506: LIST
60507: PUSH
60508: LD_VAR 0 17
60512: ARRAY
60513: PPUSH
60514: LD_VAR 0 4
60518: PPUSH
60519: CALL_OW 380
60523: GO 60542
// PrepareHuman ( false , i , skill ) ;
60525: LD_INT 0
60527: PPUSH
60528: LD_VAR 0 8
60532: PPUSH
60533: LD_VAR 0 4
60537: PPUSH
60538: CALL_OW 380
// end else
60542: GO 60561
// PrepareHuman ( false , i , skill ) ;
60544: LD_INT 0
60546: PPUSH
60547: LD_VAR 0 8
60551: PPUSH
60552: LD_VAR 0 4
60556: PPUSH
60557: CALL_OW 380
// un := CreateHuman ;
60561: LD_ADDR_VAR 0 14
60565: PUSH
60566: CALL_OW 44
60570: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60571: LD_ADDR_VAR 0 7
60575: PUSH
60576: LD_VAR 0 7
60580: PPUSH
60581: LD_INT 1
60583: PPUSH
60584: LD_VAR 0 14
60588: PPUSH
60589: CALL_OW 2
60593: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60594: LD_VAR 0 14
60598: PPUSH
60599: LD_VAR 0 12
60603: PUSH
60604: LD_INT 1
60606: ARRAY
60607: PPUSH
60608: CALL_OW 52
// end ;
60612: GO 60251
60614: POP
60615: POP
// end ;
60616: GO 59553
60618: POP
60619: POP
// result := result ^ buildings ;
60620: LD_ADDR_VAR 0 7
60624: PUSH
60625: LD_VAR 0 7
60629: PUSH
60630: LD_VAR 0 18
60634: ADD
60635: ST_TO_ADDR
// end else
60636: GO 60779
// begin for i = 1 to personel do
60638: LD_ADDR_VAR 0 8
60642: PUSH
60643: DOUBLE
60644: LD_INT 1
60646: DEC
60647: ST_TO_ADDR
60648: LD_VAR 0 6
60652: PUSH
60653: FOR_TO
60654: IFFALSE 60777
// begin if i > 4 then
60656: LD_VAR 0 8
60660: PUSH
60661: LD_INT 4
60663: GREATER
60664: IFFALSE 60668
// break ;
60666: GO 60777
// x := personel [ i ] ;
60668: LD_ADDR_VAR 0 13
60672: PUSH
60673: LD_VAR 0 6
60677: PUSH
60678: LD_VAR 0 8
60682: ARRAY
60683: ST_TO_ADDR
// if x = - 1 then
60684: LD_VAR 0 13
60688: PUSH
60689: LD_INT 1
60691: NEG
60692: EQUAL
60693: IFFALSE 60697
// continue ;
60695: GO 60653
// PrepareHuman ( false , i , skill ) ;
60697: LD_INT 0
60699: PPUSH
60700: LD_VAR 0 8
60704: PPUSH
60705: LD_VAR 0 4
60709: PPUSH
60710: CALL_OW 380
// un := CreateHuman ;
60714: LD_ADDR_VAR 0 14
60718: PUSH
60719: CALL_OW 44
60723: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60724: LD_VAR 0 14
60728: PPUSH
60729: LD_VAR 0 1
60733: PPUSH
60734: CALL_OW 250
60738: PPUSH
60739: LD_VAR 0 1
60743: PPUSH
60744: CALL_OW 251
60748: PPUSH
60749: LD_INT 10
60751: PPUSH
60752: LD_INT 0
60754: PPUSH
60755: CALL_OW 50
// result := result ^ un ;
60759: LD_ADDR_VAR 0 7
60763: PUSH
60764: LD_VAR 0 7
60768: PUSH
60769: LD_VAR 0 14
60773: ADD
60774: ST_TO_ADDR
// end ;
60775: GO 60653
60777: POP
60778: POP
// end ; end ;
60779: LD_VAR 0 7
60783: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60784: LD_INT 0
60786: PPUSH
60787: PPUSH
60788: PPUSH
60789: PPUSH
60790: PPUSH
60791: PPUSH
60792: PPUSH
60793: PPUSH
60794: PPUSH
60795: PPUSH
60796: PPUSH
60797: PPUSH
60798: PPUSH
60799: PPUSH
60800: PPUSH
60801: PPUSH
// result := false ;
60802: LD_ADDR_VAR 0 3
60806: PUSH
60807: LD_INT 0
60809: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60810: LD_VAR 0 1
60814: NOT
60815: PUSH
60816: LD_VAR 0 1
60820: PPUSH
60821: CALL_OW 266
60825: PUSH
60826: LD_INT 32
60828: PUSH
60829: LD_INT 33
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: IN
60836: NOT
60837: OR
60838: IFFALSE 60842
// exit ;
60840: GO 61978
// nat := GetNation ( tower ) ;
60842: LD_ADDR_VAR 0 12
60846: PUSH
60847: LD_VAR 0 1
60851: PPUSH
60852: CALL_OW 248
60856: ST_TO_ADDR
// side := GetSide ( tower ) ;
60857: LD_ADDR_VAR 0 16
60861: PUSH
60862: LD_VAR 0 1
60866: PPUSH
60867: CALL_OW 255
60871: ST_TO_ADDR
// x := GetX ( tower ) ;
60872: LD_ADDR_VAR 0 10
60876: PUSH
60877: LD_VAR 0 1
60881: PPUSH
60882: CALL_OW 250
60886: ST_TO_ADDR
// y := GetY ( tower ) ;
60887: LD_ADDR_VAR 0 11
60891: PUSH
60892: LD_VAR 0 1
60896: PPUSH
60897: CALL_OW 251
60901: ST_TO_ADDR
// if not x or not y then
60902: LD_VAR 0 10
60906: NOT
60907: PUSH
60908: LD_VAR 0 11
60912: NOT
60913: OR
60914: IFFALSE 60918
// exit ;
60916: GO 61978
// weapon := 0 ;
60918: LD_ADDR_VAR 0 18
60922: PUSH
60923: LD_INT 0
60925: ST_TO_ADDR
// fac_list := [ ] ;
60926: LD_ADDR_VAR 0 17
60930: PUSH
60931: EMPTY
60932: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60933: LD_ADDR_VAR 0 6
60937: PUSH
60938: LD_VAR 0 1
60942: PPUSH
60943: CALL_OW 274
60947: PPUSH
60948: LD_VAR 0 2
60952: PPUSH
60953: CALL 58556 0 2
60957: PPUSH
60958: LD_INT 30
60960: PUSH
60961: LD_INT 3
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: PPUSH
60968: CALL_OW 72
60972: ST_TO_ADDR
// if not factories then
60973: LD_VAR 0 6
60977: NOT
60978: IFFALSE 60982
// exit ;
60980: GO 61978
// for i in factories do
60982: LD_ADDR_VAR 0 8
60986: PUSH
60987: LD_VAR 0 6
60991: PUSH
60992: FOR_IN
60993: IFFALSE 61018
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60995: LD_ADDR_VAR 0 17
60999: PUSH
61000: LD_VAR 0 17
61004: PUSH
61005: LD_VAR 0 8
61009: PPUSH
61010: CALL_OW 478
61014: UNION
61015: ST_TO_ADDR
61016: GO 60992
61018: POP
61019: POP
// if not fac_list then
61020: LD_VAR 0 17
61024: NOT
61025: IFFALSE 61029
// exit ;
61027: GO 61978
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61029: LD_ADDR_VAR 0 5
61033: PUSH
61034: LD_INT 4
61036: PUSH
61037: LD_INT 5
61039: PUSH
61040: LD_INT 9
61042: PUSH
61043: LD_INT 10
61045: PUSH
61046: LD_INT 6
61048: PUSH
61049: LD_INT 7
61051: PUSH
61052: LD_INT 11
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: LIST
61059: LIST
61060: LIST
61061: LIST
61062: LIST
61063: PUSH
61064: LD_INT 27
61066: PUSH
61067: LD_INT 28
61069: PUSH
61070: LD_INT 26
61072: PUSH
61073: LD_INT 30
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: LIST
61080: LIST
61081: PUSH
61082: LD_INT 43
61084: PUSH
61085: LD_INT 44
61087: PUSH
61088: LD_INT 46
61090: PUSH
61091: LD_INT 45
61093: PUSH
61094: LD_INT 47
61096: PUSH
61097: LD_INT 49
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: LIST
61104: LIST
61105: LIST
61106: LIST
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: LIST
61112: PUSH
61113: LD_VAR 0 12
61117: ARRAY
61118: ST_TO_ADDR
// for i in list do
61119: LD_ADDR_VAR 0 8
61123: PUSH
61124: LD_VAR 0 5
61128: PUSH
61129: FOR_IN
61130: IFFALSE 61163
// if not i in fac_list then
61132: LD_VAR 0 8
61136: PUSH
61137: LD_VAR 0 17
61141: IN
61142: NOT
61143: IFFALSE 61161
// list := list diff i ;
61145: LD_ADDR_VAR 0 5
61149: PUSH
61150: LD_VAR 0 5
61154: PUSH
61155: LD_VAR 0 8
61159: DIFF
61160: ST_TO_ADDR
61161: GO 61129
61163: POP
61164: POP
// if not list then
61165: LD_VAR 0 5
61169: NOT
61170: IFFALSE 61174
// exit ;
61172: GO 61978
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61174: LD_VAR 0 12
61178: PUSH
61179: LD_INT 3
61181: EQUAL
61182: PUSH
61183: LD_INT 49
61185: PUSH
61186: LD_VAR 0 5
61190: IN
61191: AND
61192: PUSH
61193: LD_INT 31
61195: PPUSH
61196: LD_VAR 0 16
61200: PPUSH
61201: CALL_OW 321
61205: PUSH
61206: LD_INT 2
61208: EQUAL
61209: AND
61210: IFFALSE 61270
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61212: LD_INT 22
61214: PUSH
61215: LD_VAR 0 16
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 35
61226: PUSH
61227: LD_INT 49
61229: PUSH
61230: EMPTY
61231: LIST
61232: LIST
61233: PUSH
61234: LD_INT 91
61236: PUSH
61237: LD_VAR 0 1
61241: PUSH
61242: LD_INT 10
61244: PUSH
61245: EMPTY
61246: LIST
61247: LIST
61248: LIST
61249: PUSH
61250: EMPTY
61251: LIST
61252: LIST
61253: LIST
61254: PPUSH
61255: CALL_OW 69
61259: NOT
61260: IFFALSE 61270
// weapon := ru_time_lapser ;
61262: LD_ADDR_VAR 0 18
61266: PUSH
61267: LD_INT 49
61269: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61270: LD_VAR 0 12
61274: PUSH
61275: LD_INT 1
61277: PUSH
61278: LD_INT 2
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: IN
61285: PUSH
61286: LD_INT 11
61288: PUSH
61289: LD_VAR 0 5
61293: IN
61294: PUSH
61295: LD_INT 30
61297: PUSH
61298: LD_VAR 0 5
61302: IN
61303: OR
61304: AND
61305: PUSH
61306: LD_INT 6
61308: PPUSH
61309: LD_VAR 0 16
61313: PPUSH
61314: CALL_OW 321
61318: PUSH
61319: LD_INT 2
61321: EQUAL
61322: AND
61323: IFFALSE 61488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61325: LD_INT 22
61327: PUSH
61328: LD_VAR 0 16
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: PUSH
61337: LD_INT 2
61339: PUSH
61340: LD_INT 35
61342: PUSH
61343: LD_INT 11
61345: PUSH
61346: EMPTY
61347: LIST
61348: LIST
61349: PUSH
61350: LD_INT 35
61352: PUSH
61353: LD_INT 30
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: LIST
61364: PUSH
61365: LD_INT 91
61367: PUSH
61368: LD_VAR 0 1
61372: PUSH
61373: LD_INT 18
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: LIST
61380: PUSH
61381: EMPTY
61382: LIST
61383: LIST
61384: LIST
61385: PPUSH
61386: CALL_OW 69
61390: NOT
61391: PUSH
61392: LD_INT 22
61394: PUSH
61395: LD_VAR 0 16
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 2
61406: PUSH
61407: LD_INT 30
61409: PUSH
61410: LD_INT 32
61412: PUSH
61413: EMPTY
61414: LIST
61415: LIST
61416: PUSH
61417: LD_INT 30
61419: PUSH
61420: LD_INT 33
61422: PUSH
61423: EMPTY
61424: LIST
61425: LIST
61426: PUSH
61427: EMPTY
61428: LIST
61429: LIST
61430: LIST
61431: PUSH
61432: LD_INT 91
61434: PUSH
61435: LD_VAR 0 1
61439: PUSH
61440: LD_INT 12
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: LIST
61447: PUSH
61448: EMPTY
61449: LIST
61450: LIST
61451: LIST
61452: PUSH
61453: EMPTY
61454: LIST
61455: PPUSH
61456: CALL_OW 69
61460: PUSH
61461: LD_INT 2
61463: GREATER
61464: AND
61465: IFFALSE 61488
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61467: LD_ADDR_VAR 0 18
61471: PUSH
61472: LD_INT 11
61474: PUSH
61475: LD_INT 30
61477: PUSH
61478: EMPTY
61479: LIST
61480: LIST
61481: PUSH
61482: LD_VAR 0 12
61486: ARRAY
61487: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61488: LD_VAR 0 18
61492: NOT
61493: PUSH
61494: LD_INT 40
61496: PPUSH
61497: LD_VAR 0 16
61501: PPUSH
61502: CALL_OW 321
61506: PUSH
61507: LD_INT 2
61509: EQUAL
61510: AND
61511: PUSH
61512: LD_INT 7
61514: PUSH
61515: LD_VAR 0 5
61519: IN
61520: PUSH
61521: LD_INT 28
61523: PUSH
61524: LD_VAR 0 5
61528: IN
61529: OR
61530: PUSH
61531: LD_INT 45
61533: PUSH
61534: LD_VAR 0 5
61538: IN
61539: OR
61540: AND
61541: IFFALSE 61795
// begin hex := GetHexInfo ( x , y ) ;
61543: LD_ADDR_VAR 0 4
61547: PUSH
61548: LD_VAR 0 10
61552: PPUSH
61553: LD_VAR 0 11
61557: PPUSH
61558: CALL_OW 546
61562: ST_TO_ADDR
// if hex [ 1 ] then
61563: LD_VAR 0 4
61567: PUSH
61568: LD_INT 1
61570: ARRAY
61571: IFFALSE 61575
// exit ;
61573: GO 61978
// height := hex [ 2 ] ;
61575: LD_ADDR_VAR 0 15
61579: PUSH
61580: LD_VAR 0 4
61584: PUSH
61585: LD_INT 2
61587: ARRAY
61588: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61589: LD_ADDR_VAR 0 14
61593: PUSH
61594: LD_INT 0
61596: PUSH
61597: LD_INT 2
61599: PUSH
61600: LD_INT 3
61602: PUSH
61603: LD_INT 5
61605: PUSH
61606: EMPTY
61607: LIST
61608: LIST
61609: LIST
61610: LIST
61611: ST_TO_ADDR
// for i in tmp do
61612: LD_ADDR_VAR 0 8
61616: PUSH
61617: LD_VAR 0 14
61621: PUSH
61622: FOR_IN
61623: IFFALSE 61793
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61625: LD_ADDR_VAR 0 9
61629: PUSH
61630: LD_VAR 0 10
61634: PPUSH
61635: LD_VAR 0 8
61639: PPUSH
61640: LD_INT 5
61642: PPUSH
61643: CALL_OW 272
61647: PUSH
61648: LD_VAR 0 11
61652: PPUSH
61653: LD_VAR 0 8
61657: PPUSH
61658: LD_INT 5
61660: PPUSH
61661: CALL_OW 273
61665: PUSH
61666: EMPTY
61667: LIST
61668: LIST
61669: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61670: LD_VAR 0 9
61674: PUSH
61675: LD_INT 1
61677: ARRAY
61678: PPUSH
61679: LD_VAR 0 9
61683: PUSH
61684: LD_INT 2
61686: ARRAY
61687: PPUSH
61688: CALL_OW 488
61692: IFFALSE 61791
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61694: LD_ADDR_VAR 0 4
61698: PUSH
61699: LD_VAR 0 9
61703: PUSH
61704: LD_INT 1
61706: ARRAY
61707: PPUSH
61708: LD_VAR 0 9
61712: PUSH
61713: LD_INT 2
61715: ARRAY
61716: PPUSH
61717: CALL_OW 546
61721: ST_TO_ADDR
// if hex [ 1 ] then
61722: LD_VAR 0 4
61726: PUSH
61727: LD_INT 1
61729: ARRAY
61730: IFFALSE 61734
// continue ;
61732: GO 61622
// h := hex [ 2 ] ;
61734: LD_ADDR_VAR 0 13
61738: PUSH
61739: LD_VAR 0 4
61743: PUSH
61744: LD_INT 2
61746: ARRAY
61747: ST_TO_ADDR
// if h + 7 < height then
61748: LD_VAR 0 13
61752: PUSH
61753: LD_INT 7
61755: PLUS
61756: PUSH
61757: LD_VAR 0 15
61761: LESS
61762: IFFALSE 61791
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61764: LD_ADDR_VAR 0 18
61768: PUSH
61769: LD_INT 7
61771: PUSH
61772: LD_INT 28
61774: PUSH
61775: LD_INT 45
61777: PUSH
61778: EMPTY
61779: LIST
61780: LIST
61781: LIST
61782: PUSH
61783: LD_VAR 0 12
61787: ARRAY
61788: ST_TO_ADDR
// break ;
61789: GO 61793
// end ; end ; end ;
61791: GO 61622
61793: POP
61794: POP
// end ; if not weapon then
61795: LD_VAR 0 18
61799: NOT
61800: IFFALSE 61860
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61802: LD_ADDR_VAR 0 5
61806: PUSH
61807: LD_VAR 0 5
61811: PUSH
61812: LD_INT 11
61814: PUSH
61815: LD_INT 30
61817: PUSH
61818: LD_INT 49
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: LIST
61825: DIFF
61826: ST_TO_ADDR
// if not list then
61827: LD_VAR 0 5
61831: NOT
61832: IFFALSE 61836
// exit ;
61834: GO 61978
// weapon := list [ rand ( 1 , list ) ] ;
61836: LD_ADDR_VAR 0 18
61840: PUSH
61841: LD_VAR 0 5
61845: PUSH
61846: LD_INT 1
61848: PPUSH
61849: LD_VAR 0 5
61853: PPUSH
61854: CALL_OW 12
61858: ARRAY
61859: ST_TO_ADDR
// end ; if weapon then
61860: LD_VAR 0 18
61864: IFFALSE 61978
// begin tmp := CostOfWeapon ( weapon ) ;
61866: LD_ADDR_VAR 0 14
61870: PUSH
61871: LD_VAR 0 18
61875: PPUSH
61876: CALL_OW 451
61880: ST_TO_ADDR
// j := GetBase ( tower ) ;
61881: LD_ADDR_VAR 0 9
61885: PUSH
61886: LD_VAR 0 1
61890: PPUSH
61891: CALL_OW 274
61895: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61896: LD_VAR 0 9
61900: PPUSH
61901: LD_INT 1
61903: PPUSH
61904: CALL_OW 275
61908: PUSH
61909: LD_VAR 0 14
61913: PUSH
61914: LD_INT 1
61916: ARRAY
61917: GREATEREQUAL
61918: PUSH
61919: LD_VAR 0 9
61923: PPUSH
61924: LD_INT 2
61926: PPUSH
61927: CALL_OW 275
61931: PUSH
61932: LD_VAR 0 14
61936: PUSH
61937: LD_INT 2
61939: ARRAY
61940: GREATEREQUAL
61941: AND
61942: PUSH
61943: LD_VAR 0 9
61947: PPUSH
61948: LD_INT 3
61950: PPUSH
61951: CALL_OW 275
61955: PUSH
61956: LD_VAR 0 14
61960: PUSH
61961: LD_INT 3
61963: ARRAY
61964: GREATEREQUAL
61965: AND
61966: IFFALSE 61978
// result := weapon ;
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: LD_VAR 0 18
61977: ST_TO_ADDR
// end ; end ;
61978: LD_VAR 0 3
61982: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61983: LD_INT 0
61985: PPUSH
61986: PPUSH
// result := true ;
61987: LD_ADDR_VAR 0 3
61991: PUSH
61992: LD_INT 1
61994: ST_TO_ADDR
// if array1 = array2 then
61995: LD_VAR 0 1
61999: PUSH
62000: LD_VAR 0 2
62004: EQUAL
62005: IFFALSE 62065
// begin for i = 1 to array1 do
62007: LD_ADDR_VAR 0 4
62011: PUSH
62012: DOUBLE
62013: LD_INT 1
62015: DEC
62016: ST_TO_ADDR
62017: LD_VAR 0 1
62021: PUSH
62022: FOR_TO
62023: IFFALSE 62061
// if array1 [ i ] <> array2 [ i ] then
62025: LD_VAR 0 1
62029: PUSH
62030: LD_VAR 0 4
62034: ARRAY
62035: PUSH
62036: LD_VAR 0 2
62040: PUSH
62041: LD_VAR 0 4
62045: ARRAY
62046: NONEQUAL
62047: IFFALSE 62059
// begin result := false ;
62049: LD_ADDR_VAR 0 3
62053: PUSH
62054: LD_INT 0
62056: ST_TO_ADDR
// break ;
62057: GO 62061
// end ;
62059: GO 62022
62061: POP
62062: POP
// end else
62063: GO 62073
// result := false ;
62065: LD_ADDR_VAR 0 3
62069: PUSH
62070: LD_INT 0
62072: ST_TO_ADDR
// end ;
62073: LD_VAR 0 3
62077: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62078: LD_INT 0
62080: PPUSH
62081: PPUSH
62082: PPUSH
// pom := GetBase ( fac ) ;
62083: LD_ADDR_VAR 0 5
62087: PUSH
62088: LD_VAR 0 1
62092: PPUSH
62093: CALL_OW 274
62097: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62098: LD_ADDR_VAR 0 4
62102: PUSH
62103: LD_VAR 0 2
62107: PUSH
62108: LD_INT 1
62110: ARRAY
62111: PPUSH
62112: LD_VAR 0 2
62116: PUSH
62117: LD_INT 2
62119: ARRAY
62120: PPUSH
62121: LD_VAR 0 2
62125: PUSH
62126: LD_INT 3
62128: ARRAY
62129: PPUSH
62130: LD_VAR 0 2
62134: PUSH
62135: LD_INT 4
62137: ARRAY
62138: PPUSH
62139: CALL_OW 449
62143: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62144: LD_ADDR_VAR 0 3
62148: PUSH
62149: LD_VAR 0 5
62153: PPUSH
62154: LD_INT 1
62156: PPUSH
62157: CALL_OW 275
62161: PUSH
62162: LD_VAR 0 4
62166: PUSH
62167: LD_INT 1
62169: ARRAY
62170: GREATEREQUAL
62171: PUSH
62172: LD_VAR 0 5
62176: PPUSH
62177: LD_INT 2
62179: PPUSH
62180: CALL_OW 275
62184: PUSH
62185: LD_VAR 0 4
62189: PUSH
62190: LD_INT 2
62192: ARRAY
62193: GREATEREQUAL
62194: AND
62195: PUSH
62196: LD_VAR 0 5
62200: PPUSH
62201: LD_INT 3
62203: PPUSH
62204: CALL_OW 275
62208: PUSH
62209: LD_VAR 0 4
62213: PUSH
62214: LD_INT 3
62216: ARRAY
62217: GREATEREQUAL
62218: AND
62219: ST_TO_ADDR
// end ;
62220: LD_VAR 0 3
62224: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62225: LD_INT 0
62227: PPUSH
62228: PPUSH
62229: PPUSH
62230: PPUSH
// pom := GetBase ( building ) ;
62231: LD_ADDR_VAR 0 3
62235: PUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: CALL_OW 274
62245: ST_TO_ADDR
// if not pom then
62246: LD_VAR 0 3
62250: NOT
62251: IFFALSE 62255
// exit ;
62253: GO 62425
// btype := GetBType ( building ) ;
62255: LD_ADDR_VAR 0 5
62259: PUSH
62260: LD_VAR 0 1
62264: PPUSH
62265: CALL_OW 266
62269: ST_TO_ADDR
// if btype = b_armoury then
62270: LD_VAR 0 5
62274: PUSH
62275: LD_INT 4
62277: EQUAL
62278: IFFALSE 62288
// btype := b_barracks ;
62280: LD_ADDR_VAR 0 5
62284: PUSH
62285: LD_INT 5
62287: ST_TO_ADDR
// if btype = b_depot then
62288: LD_VAR 0 5
62292: PUSH
62293: LD_INT 0
62295: EQUAL
62296: IFFALSE 62306
// btype := b_warehouse ;
62298: LD_ADDR_VAR 0 5
62302: PUSH
62303: LD_INT 1
62305: ST_TO_ADDR
// if btype = b_workshop then
62306: LD_VAR 0 5
62310: PUSH
62311: LD_INT 2
62313: EQUAL
62314: IFFALSE 62324
// btype := b_factory ;
62316: LD_ADDR_VAR 0 5
62320: PUSH
62321: LD_INT 3
62323: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62324: LD_ADDR_VAR 0 4
62328: PUSH
62329: LD_VAR 0 5
62333: PPUSH
62334: LD_VAR 0 1
62338: PPUSH
62339: CALL_OW 248
62343: PPUSH
62344: CALL_OW 450
62348: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62349: LD_ADDR_VAR 0 2
62353: PUSH
62354: LD_VAR 0 3
62358: PPUSH
62359: LD_INT 1
62361: PPUSH
62362: CALL_OW 275
62366: PUSH
62367: LD_VAR 0 4
62371: PUSH
62372: LD_INT 1
62374: ARRAY
62375: GREATEREQUAL
62376: PUSH
62377: LD_VAR 0 3
62381: PPUSH
62382: LD_INT 2
62384: PPUSH
62385: CALL_OW 275
62389: PUSH
62390: LD_VAR 0 4
62394: PUSH
62395: LD_INT 2
62397: ARRAY
62398: GREATEREQUAL
62399: AND
62400: PUSH
62401: LD_VAR 0 3
62405: PPUSH
62406: LD_INT 3
62408: PPUSH
62409: CALL_OW 275
62413: PUSH
62414: LD_VAR 0 4
62418: PUSH
62419: LD_INT 3
62421: ARRAY
62422: GREATEREQUAL
62423: AND
62424: ST_TO_ADDR
// end ;
62425: LD_VAR 0 2
62429: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62430: LD_INT 0
62432: PPUSH
62433: PPUSH
62434: PPUSH
// pom := GetBase ( building ) ;
62435: LD_ADDR_VAR 0 4
62439: PUSH
62440: LD_VAR 0 1
62444: PPUSH
62445: CALL_OW 274
62449: ST_TO_ADDR
// if not pom then
62450: LD_VAR 0 4
62454: NOT
62455: IFFALSE 62459
// exit ;
62457: GO 62560
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62459: LD_ADDR_VAR 0 5
62463: PUSH
62464: LD_VAR 0 2
62468: PPUSH
62469: LD_VAR 0 1
62473: PPUSH
62474: CALL_OW 248
62478: PPUSH
62479: CALL_OW 450
62483: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62484: LD_ADDR_VAR 0 3
62488: PUSH
62489: LD_VAR 0 4
62493: PPUSH
62494: LD_INT 1
62496: PPUSH
62497: CALL_OW 275
62501: PUSH
62502: LD_VAR 0 5
62506: PUSH
62507: LD_INT 1
62509: ARRAY
62510: GREATEREQUAL
62511: PUSH
62512: LD_VAR 0 4
62516: PPUSH
62517: LD_INT 2
62519: PPUSH
62520: CALL_OW 275
62524: PUSH
62525: LD_VAR 0 5
62529: PUSH
62530: LD_INT 2
62532: ARRAY
62533: GREATEREQUAL
62534: AND
62535: PUSH
62536: LD_VAR 0 4
62540: PPUSH
62541: LD_INT 3
62543: PPUSH
62544: CALL_OW 275
62548: PUSH
62549: LD_VAR 0 5
62553: PUSH
62554: LD_INT 3
62556: ARRAY
62557: GREATEREQUAL
62558: AND
62559: ST_TO_ADDR
// end ;
62560: LD_VAR 0 3
62564: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62565: LD_INT 0
62567: PPUSH
62568: PPUSH
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
62574: PPUSH
62575: PPUSH
62576: PPUSH
// result := false ;
62577: LD_ADDR_VAR 0 6
62581: PUSH
62582: LD_INT 0
62584: ST_TO_ADDR
// if not base or not btype or not x or not y then
62585: LD_VAR 0 1
62589: NOT
62590: PUSH
62591: LD_VAR 0 2
62595: NOT
62596: OR
62597: PUSH
62598: LD_VAR 0 3
62602: NOT
62603: OR
62604: PUSH
62605: LD_VAR 0 4
62609: NOT
62610: OR
62611: IFFALSE 62615
// exit ;
62613: GO 63224
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62615: LD_ADDR_VAR 0 12
62619: PUSH
62620: LD_VAR 0 2
62624: PPUSH
62625: LD_VAR 0 3
62629: PPUSH
62630: LD_VAR 0 4
62634: PPUSH
62635: LD_VAR 0 5
62639: PPUSH
62640: LD_VAR 0 1
62644: PUSH
62645: LD_INT 1
62647: ARRAY
62648: PPUSH
62649: CALL_OW 248
62653: PPUSH
62654: LD_INT 0
62656: PPUSH
62657: CALL 64061 0 6
62661: ST_TO_ADDR
// if not hexes then
62662: LD_VAR 0 12
62666: NOT
62667: IFFALSE 62671
// exit ;
62669: GO 63224
// for i = 1 to hexes do
62671: LD_ADDR_VAR 0 7
62675: PUSH
62676: DOUBLE
62677: LD_INT 1
62679: DEC
62680: ST_TO_ADDR
62681: LD_VAR 0 12
62685: PUSH
62686: FOR_TO
62687: IFFALSE 63222
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62689: LD_ADDR_VAR 0 11
62693: PUSH
62694: LD_VAR 0 12
62698: PUSH
62699: LD_VAR 0 7
62703: ARRAY
62704: PUSH
62705: LD_INT 1
62707: ARRAY
62708: PPUSH
62709: LD_VAR 0 12
62713: PUSH
62714: LD_VAR 0 7
62718: ARRAY
62719: PUSH
62720: LD_INT 2
62722: ARRAY
62723: PPUSH
62724: CALL_OW 428
62728: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62729: LD_VAR 0 12
62733: PUSH
62734: LD_VAR 0 7
62738: ARRAY
62739: PUSH
62740: LD_INT 1
62742: ARRAY
62743: PPUSH
62744: LD_VAR 0 12
62748: PUSH
62749: LD_VAR 0 7
62753: ARRAY
62754: PUSH
62755: LD_INT 2
62757: ARRAY
62758: PPUSH
62759: CALL_OW 351
62763: PUSH
62764: LD_VAR 0 12
62768: PUSH
62769: LD_VAR 0 7
62773: ARRAY
62774: PUSH
62775: LD_INT 1
62777: ARRAY
62778: PPUSH
62779: LD_VAR 0 12
62783: PUSH
62784: LD_VAR 0 7
62788: ARRAY
62789: PUSH
62790: LD_INT 2
62792: ARRAY
62793: PPUSH
62794: CALL_OW 488
62798: NOT
62799: OR
62800: PUSH
62801: LD_VAR 0 11
62805: PPUSH
62806: CALL_OW 247
62810: PUSH
62811: LD_INT 3
62813: EQUAL
62814: OR
62815: IFFALSE 62821
// exit ;
62817: POP
62818: POP
62819: GO 63224
// if not tmp or not tmp in base then
62821: LD_VAR 0 11
62825: NOT
62826: PUSH
62827: LD_VAR 0 11
62831: PUSH
62832: LD_VAR 0 1
62836: IN
62837: NOT
62838: OR
62839: IFFALSE 62843
// continue ;
62841: GO 62686
// result := true ;
62843: LD_ADDR_VAR 0 6
62847: PUSH
62848: LD_INT 1
62850: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62851: LD_ADDR_VAR 0 15
62855: PUSH
62856: LD_VAR 0 1
62860: PPUSH
62861: LD_INT 22
62863: PUSH
62864: LD_VAR 0 11
62868: PPUSH
62869: CALL_OW 255
62873: PUSH
62874: EMPTY
62875: LIST
62876: LIST
62877: PUSH
62878: LD_INT 2
62880: PUSH
62881: LD_INT 30
62883: PUSH
62884: LD_INT 0
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 30
62893: PUSH
62894: LD_INT 1
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: EMPTY
62902: LIST
62903: LIST
62904: LIST
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: PPUSH
62910: CALL_OW 72
62914: ST_TO_ADDR
// if dep then
62915: LD_VAR 0 15
62919: IFFALSE 63055
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62921: LD_ADDR_VAR 0 14
62925: PUSH
62926: LD_VAR 0 15
62930: PUSH
62931: LD_INT 1
62933: ARRAY
62934: PPUSH
62935: CALL_OW 250
62939: PPUSH
62940: LD_VAR 0 15
62944: PUSH
62945: LD_INT 1
62947: ARRAY
62948: PPUSH
62949: CALL_OW 254
62953: PPUSH
62954: LD_INT 5
62956: PPUSH
62957: CALL_OW 272
62961: PUSH
62962: LD_VAR 0 15
62966: PUSH
62967: LD_INT 1
62969: ARRAY
62970: PPUSH
62971: CALL_OW 251
62975: PPUSH
62976: LD_VAR 0 15
62980: PUSH
62981: LD_INT 1
62983: ARRAY
62984: PPUSH
62985: CALL_OW 254
62989: PPUSH
62990: LD_INT 5
62992: PPUSH
62993: CALL_OW 273
62997: PUSH
62998: EMPTY
62999: LIST
63000: LIST
63001: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63002: LD_VAR 0 14
63006: PUSH
63007: LD_INT 1
63009: ARRAY
63010: PPUSH
63011: LD_VAR 0 14
63015: PUSH
63016: LD_INT 2
63018: ARRAY
63019: PPUSH
63020: CALL_OW 488
63024: IFFALSE 63055
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63026: LD_VAR 0 11
63030: PPUSH
63031: LD_VAR 0 14
63035: PUSH
63036: LD_INT 1
63038: ARRAY
63039: PPUSH
63040: LD_VAR 0 14
63044: PUSH
63045: LD_INT 2
63047: ARRAY
63048: PPUSH
63049: CALL_OW 111
// continue ;
63053: GO 62686
// end ; end ; r := GetDir ( tmp ) ;
63055: LD_ADDR_VAR 0 13
63059: PUSH
63060: LD_VAR 0 11
63064: PPUSH
63065: CALL_OW 254
63069: ST_TO_ADDR
// if r = 5 then
63070: LD_VAR 0 13
63074: PUSH
63075: LD_INT 5
63077: EQUAL
63078: IFFALSE 63088
// r := 0 ;
63080: LD_ADDR_VAR 0 13
63084: PUSH
63085: LD_INT 0
63087: ST_TO_ADDR
// for j = r to 5 do
63088: LD_ADDR_VAR 0 8
63092: PUSH
63093: DOUBLE
63094: LD_VAR 0 13
63098: DEC
63099: ST_TO_ADDR
63100: LD_INT 5
63102: PUSH
63103: FOR_TO
63104: IFFALSE 63218
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63106: LD_ADDR_VAR 0 9
63110: PUSH
63111: LD_VAR 0 11
63115: PPUSH
63116: CALL_OW 250
63120: PPUSH
63121: LD_VAR 0 8
63125: PPUSH
63126: LD_INT 2
63128: PPUSH
63129: CALL_OW 272
63133: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63134: LD_ADDR_VAR 0 10
63138: PUSH
63139: LD_VAR 0 11
63143: PPUSH
63144: CALL_OW 251
63148: PPUSH
63149: LD_VAR 0 8
63153: PPUSH
63154: LD_INT 2
63156: PPUSH
63157: CALL_OW 273
63161: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63162: LD_VAR 0 9
63166: PPUSH
63167: LD_VAR 0 10
63171: PPUSH
63172: CALL_OW 488
63176: PUSH
63177: LD_VAR 0 9
63181: PPUSH
63182: LD_VAR 0 10
63186: PPUSH
63187: CALL_OW 428
63191: NOT
63192: AND
63193: IFFALSE 63216
// begin ComMoveXY ( tmp , _x , _y ) ;
63195: LD_VAR 0 11
63199: PPUSH
63200: LD_VAR 0 9
63204: PPUSH
63205: LD_VAR 0 10
63209: PPUSH
63210: CALL_OW 111
// break ;
63214: GO 63218
// end ; end ;
63216: GO 63103
63218: POP
63219: POP
// end ;
63220: GO 62686
63222: POP
63223: POP
// end ;
63224: LD_VAR 0 6
63228: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63229: LD_INT 0
63231: PPUSH
63232: PPUSH
63233: PPUSH
63234: PPUSH
63235: PPUSH
63236: PPUSH
63237: PPUSH
63238: PPUSH
63239: PPUSH
63240: PPUSH
// result := false ;
63241: LD_ADDR_VAR 0 6
63245: PUSH
63246: LD_INT 0
63248: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63249: LD_VAR 0 1
63253: NOT
63254: PUSH
63255: LD_VAR 0 1
63259: PPUSH
63260: CALL_OW 266
63264: PUSH
63265: LD_INT 0
63267: PUSH
63268: LD_INT 1
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: IN
63275: NOT
63276: OR
63277: PUSH
63278: LD_VAR 0 2
63282: NOT
63283: OR
63284: PUSH
63285: LD_VAR 0 5
63289: PUSH
63290: LD_INT 0
63292: PUSH
63293: LD_INT 1
63295: PUSH
63296: LD_INT 2
63298: PUSH
63299: LD_INT 3
63301: PUSH
63302: LD_INT 4
63304: PUSH
63305: LD_INT 5
63307: PUSH
63308: EMPTY
63309: LIST
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: IN
63316: NOT
63317: OR
63318: PUSH
63319: LD_VAR 0 3
63323: PPUSH
63324: LD_VAR 0 4
63328: PPUSH
63329: CALL_OW 488
63333: NOT
63334: OR
63335: IFFALSE 63339
// exit ;
63337: GO 64056
// pom := GetBase ( depot ) ;
63339: LD_ADDR_VAR 0 10
63343: PUSH
63344: LD_VAR 0 1
63348: PPUSH
63349: CALL_OW 274
63353: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63354: LD_ADDR_VAR 0 11
63358: PUSH
63359: LD_VAR 0 2
63363: PPUSH
63364: LD_VAR 0 1
63368: PPUSH
63369: CALL_OW 248
63373: PPUSH
63374: CALL_OW 450
63378: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63379: LD_VAR 0 10
63383: PPUSH
63384: LD_INT 1
63386: PPUSH
63387: CALL_OW 275
63391: PUSH
63392: LD_VAR 0 11
63396: PUSH
63397: LD_INT 1
63399: ARRAY
63400: GREATEREQUAL
63401: PUSH
63402: LD_VAR 0 10
63406: PPUSH
63407: LD_INT 2
63409: PPUSH
63410: CALL_OW 275
63414: PUSH
63415: LD_VAR 0 11
63419: PUSH
63420: LD_INT 2
63422: ARRAY
63423: GREATEREQUAL
63424: AND
63425: PUSH
63426: LD_VAR 0 10
63430: PPUSH
63431: LD_INT 3
63433: PPUSH
63434: CALL_OW 275
63438: PUSH
63439: LD_VAR 0 11
63443: PUSH
63444: LD_INT 3
63446: ARRAY
63447: GREATEREQUAL
63448: AND
63449: NOT
63450: IFFALSE 63454
// exit ;
63452: GO 64056
// if GetBType ( depot ) = b_depot then
63454: LD_VAR 0 1
63458: PPUSH
63459: CALL_OW 266
63463: PUSH
63464: LD_INT 0
63466: EQUAL
63467: IFFALSE 63479
// dist := 28 else
63469: LD_ADDR_VAR 0 14
63473: PUSH
63474: LD_INT 28
63476: ST_TO_ADDR
63477: GO 63487
// dist := 36 ;
63479: LD_ADDR_VAR 0 14
63483: PUSH
63484: LD_INT 36
63486: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63487: LD_VAR 0 1
63491: PPUSH
63492: LD_VAR 0 3
63496: PPUSH
63497: LD_VAR 0 4
63501: PPUSH
63502: CALL_OW 297
63506: PUSH
63507: LD_VAR 0 14
63511: GREATER
63512: IFFALSE 63516
// exit ;
63514: GO 64056
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63516: LD_ADDR_VAR 0 12
63520: PUSH
63521: LD_VAR 0 2
63525: PPUSH
63526: LD_VAR 0 3
63530: PPUSH
63531: LD_VAR 0 4
63535: PPUSH
63536: LD_VAR 0 5
63540: PPUSH
63541: LD_VAR 0 1
63545: PPUSH
63546: CALL_OW 248
63550: PPUSH
63551: LD_INT 0
63553: PPUSH
63554: CALL 64061 0 6
63558: ST_TO_ADDR
// if not hexes then
63559: LD_VAR 0 12
63563: NOT
63564: IFFALSE 63568
// exit ;
63566: GO 64056
// hex := GetHexInfo ( x , y ) ;
63568: LD_ADDR_VAR 0 15
63572: PUSH
63573: LD_VAR 0 3
63577: PPUSH
63578: LD_VAR 0 4
63582: PPUSH
63583: CALL_OW 546
63587: ST_TO_ADDR
// if hex [ 1 ] then
63588: LD_VAR 0 15
63592: PUSH
63593: LD_INT 1
63595: ARRAY
63596: IFFALSE 63600
// exit ;
63598: GO 64056
// height := hex [ 2 ] ;
63600: LD_ADDR_VAR 0 13
63604: PUSH
63605: LD_VAR 0 15
63609: PUSH
63610: LD_INT 2
63612: ARRAY
63613: ST_TO_ADDR
// for i = 1 to hexes do
63614: LD_ADDR_VAR 0 7
63618: PUSH
63619: DOUBLE
63620: LD_INT 1
63622: DEC
63623: ST_TO_ADDR
63624: LD_VAR 0 12
63628: PUSH
63629: FOR_TO
63630: IFFALSE 63960
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63632: LD_VAR 0 12
63636: PUSH
63637: LD_VAR 0 7
63641: ARRAY
63642: PUSH
63643: LD_INT 1
63645: ARRAY
63646: PPUSH
63647: LD_VAR 0 12
63651: PUSH
63652: LD_VAR 0 7
63656: ARRAY
63657: PUSH
63658: LD_INT 2
63660: ARRAY
63661: PPUSH
63662: CALL_OW 488
63666: NOT
63667: PUSH
63668: LD_VAR 0 12
63672: PUSH
63673: LD_VAR 0 7
63677: ARRAY
63678: PUSH
63679: LD_INT 1
63681: ARRAY
63682: PPUSH
63683: LD_VAR 0 12
63687: PUSH
63688: LD_VAR 0 7
63692: ARRAY
63693: PUSH
63694: LD_INT 2
63696: ARRAY
63697: PPUSH
63698: CALL_OW 428
63702: PUSH
63703: LD_INT 0
63705: GREATER
63706: OR
63707: PUSH
63708: LD_VAR 0 12
63712: PUSH
63713: LD_VAR 0 7
63717: ARRAY
63718: PUSH
63719: LD_INT 1
63721: ARRAY
63722: PPUSH
63723: LD_VAR 0 12
63727: PUSH
63728: LD_VAR 0 7
63732: ARRAY
63733: PUSH
63734: LD_INT 2
63736: ARRAY
63737: PPUSH
63738: CALL_OW 351
63742: OR
63743: IFFALSE 63749
// exit ;
63745: POP
63746: POP
63747: GO 64056
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63749: LD_ADDR_VAR 0 8
63753: PUSH
63754: LD_VAR 0 12
63758: PUSH
63759: LD_VAR 0 7
63763: ARRAY
63764: PUSH
63765: LD_INT 1
63767: ARRAY
63768: PPUSH
63769: LD_VAR 0 12
63773: PUSH
63774: LD_VAR 0 7
63778: ARRAY
63779: PUSH
63780: LD_INT 2
63782: ARRAY
63783: PPUSH
63784: CALL_OW 546
63788: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63789: LD_VAR 0 8
63793: PUSH
63794: LD_INT 1
63796: ARRAY
63797: PUSH
63798: LD_VAR 0 8
63802: PUSH
63803: LD_INT 2
63805: ARRAY
63806: PUSH
63807: LD_VAR 0 13
63811: PUSH
63812: LD_INT 2
63814: PLUS
63815: GREATER
63816: OR
63817: PUSH
63818: LD_VAR 0 8
63822: PUSH
63823: LD_INT 2
63825: ARRAY
63826: PUSH
63827: LD_VAR 0 13
63831: PUSH
63832: LD_INT 2
63834: MINUS
63835: LESS
63836: OR
63837: PUSH
63838: LD_VAR 0 8
63842: PUSH
63843: LD_INT 3
63845: ARRAY
63846: PUSH
63847: LD_INT 0
63849: PUSH
63850: LD_INT 8
63852: PUSH
63853: LD_INT 9
63855: PUSH
63856: LD_INT 10
63858: PUSH
63859: LD_INT 11
63861: PUSH
63862: LD_INT 12
63864: PUSH
63865: LD_INT 13
63867: PUSH
63868: LD_INT 16
63870: PUSH
63871: LD_INT 17
63873: PUSH
63874: LD_INT 18
63876: PUSH
63877: LD_INT 19
63879: PUSH
63880: LD_INT 20
63882: PUSH
63883: LD_INT 21
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: IN
63901: NOT
63902: OR
63903: PUSH
63904: LD_VAR 0 8
63908: PUSH
63909: LD_INT 5
63911: ARRAY
63912: NOT
63913: OR
63914: PUSH
63915: LD_VAR 0 8
63919: PUSH
63920: LD_INT 6
63922: ARRAY
63923: PUSH
63924: LD_INT 1
63926: PUSH
63927: LD_INT 2
63929: PUSH
63930: LD_INT 7
63932: PUSH
63933: LD_INT 9
63935: PUSH
63936: LD_INT 10
63938: PUSH
63939: LD_INT 11
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: IN
63950: NOT
63951: OR
63952: IFFALSE 63958
// exit ;
63954: POP
63955: POP
63956: GO 64056
// end ;
63958: GO 63629
63960: POP
63961: POP
// side := GetSide ( depot ) ;
63962: LD_ADDR_VAR 0 9
63966: PUSH
63967: LD_VAR 0 1
63971: PPUSH
63972: CALL_OW 255
63976: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63977: LD_VAR 0 9
63981: PPUSH
63982: LD_VAR 0 3
63986: PPUSH
63987: LD_VAR 0 4
63991: PPUSH
63992: LD_INT 20
63994: PPUSH
63995: CALL 56710 0 4
63999: PUSH
64000: LD_INT 4
64002: ARRAY
64003: IFFALSE 64007
// exit ;
64005: GO 64056
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64007: LD_VAR 0 2
64011: PUSH
64012: LD_INT 29
64014: PUSH
64015: LD_INT 30
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: IN
64022: PUSH
64023: LD_VAR 0 3
64027: PPUSH
64028: LD_VAR 0 4
64032: PPUSH
64033: LD_VAR 0 9
64037: PPUSH
64038: CALL_OW 440
64042: NOT
64043: AND
64044: IFFALSE 64048
// exit ;
64046: GO 64056
// result := true ;
64048: LD_ADDR_VAR 0 6
64052: PUSH
64053: LD_INT 1
64055: ST_TO_ADDR
// end ;
64056: LD_VAR 0 6
64060: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
64061: LD_INT 0
64063: PPUSH
64064: PPUSH
64065: PPUSH
64066: PPUSH
64067: PPUSH
64068: PPUSH
64069: PPUSH
64070: PPUSH
64071: PPUSH
64072: PPUSH
64073: PPUSH
64074: PPUSH
64075: PPUSH
64076: PPUSH
64077: PPUSH
64078: PPUSH
64079: PPUSH
64080: PPUSH
64081: PPUSH
64082: PPUSH
64083: PPUSH
64084: PPUSH
64085: PPUSH
64086: PPUSH
64087: PPUSH
64088: PPUSH
64089: PPUSH
64090: PPUSH
64091: PPUSH
64092: PPUSH
64093: PPUSH
64094: PPUSH
64095: PPUSH
64096: PPUSH
64097: PPUSH
64098: PPUSH
64099: PPUSH
64100: PPUSH
64101: PPUSH
64102: PPUSH
64103: PPUSH
64104: PPUSH
64105: PPUSH
64106: PPUSH
64107: PPUSH
64108: PPUSH
64109: PPUSH
64110: PPUSH
64111: PPUSH
64112: PPUSH
64113: PPUSH
64114: PPUSH
64115: PPUSH
64116: PPUSH
64117: PPUSH
64118: PPUSH
64119: PPUSH
64120: PPUSH
// result = [ ] ;
64121: LD_ADDR_VAR 0 7
64125: PUSH
64126: EMPTY
64127: ST_TO_ADDR
// temp_list = [ ] ;
64128: LD_ADDR_VAR 0 9
64132: PUSH
64133: EMPTY
64134: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64135: LD_VAR 0 4
64139: PUSH
64140: LD_INT 0
64142: PUSH
64143: LD_INT 1
64145: PUSH
64146: LD_INT 2
64148: PUSH
64149: LD_INT 3
64151: PUSH
64152: LD_INT 4
64154: PUSH
64155: LD_INT 5
64157: PUSH
64158: EMPTY
64159: LIST
64160: LIST
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: IN
64166: NOT
64167: PUSH
64168: LD_VAR 0 1
64172: PUSH
64173: LD_INT 0
64175: PUSH
64176: LD_INT 1
64178: PUSH
64179: EMPTY
64180: LIST
64181: LIST
64182: IN
64183: PUSH
64184: LD_VAR 0 5
64188: PUSH
64189: LD_INT 1
64191: PUSH
64192: LD_INT 2
64194: PUSH
64195: LD_INT 3
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: LIST
64202: IN
64203: NOT
64204: AND
64205: OR
64206: IFFALSE 64210
// exit ;
64208: GO 82601
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64210: LD_VAR 0 1
64214: PUSH
64215: LD_INT 6
64217: PUSH
64218: LD_INT 7
64220: PUSH
64221: LD_INT 8
64223: PUSH
64224: LD_INT 13
64226: PUSH
64227: LD_INT 12
64229: PUSH
64230: LD_INT 15
64232: PUSH
64233: LD_INT 11
64235: PUSH
64236: LD_INT 14
64238: PUSH
64239: LD_INT 10
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: IN
64253: IFFALSE 64263
// btype = b_lab ;
64255: LD_ADDR_VAR 0 1
64259: PUSH
64260: LD_INT 6
64262: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64263: LD_VAR 0 6
64267: PUSH
64268: LD_INT 0
64270: PUSH
64271: LD_INT 1
64273: PUSH
64274: LD_INT 2
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: LIST
64281: IN
64282: NOT
64283: PUSH
64284: LD_VAR 0 1
64288: PUSH
64289: LD_INT 0
64291: PUSH
64292: LD_INT 1
64294: PUSH
64295: LD_INT 2
64297: PUSH
64298: LD_INT 3
64300: PUSH
64301: LD_INT 6
64303: PUSH
64304: LD_INT 36
64306: PUSH
64307: LD_INT 4
64309: PUSH
64310: LD_INT 5
64312: PUSH
64313: LD_INT 31
64315: PUSH
64316: LD_INT 32
64318: PUSH
64319: LD_INT 33
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: IN
64335: NOT
64336: PUSH
64337: LD_VAR 0 6
64341: PUSH
64342: LD_INT 1
64344: EQUAL
64345: AND
64346: OR
64347: PUSH
64348: LD_VAR 0 1
64352: PUSH
64353: LD_INT 2
64355: PUSH
64356: LD_INT 3
64358: PUSH
64359: EMPTY
64360: LIST
64361: LIST
64362: IN
64363: NOT
64364: PUSH
64365: LD_VAR 0 6
64369: PUSH
64370: LD_INT 2
64372: EQUAL
64373: AND
64374: OR
64375: IFFALSE 64385
// mode = 0 ;
64377: LD_ADDR_VAR 0 6
64381: PUSH
64382: LD_INT 0
64384: ST_TO_ADDR
// case mode of 0 :
64385: LD_VAR 0 6
64389: PUSH
64390: LD_INT 0
64392: DOUBLE
64393: EQUAL
64394: IFTRUE 64398
64396: GO 75851
64398: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64399: LD_ADDR_VAR 0 11
64403: PUSH
64404: LD_INT 0
64406: PUSH
64407: LD_INT 0
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: PUSH
64414: LD_INT 0
64416: PUSH
64417: LD_INT 1
64419: NEG
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 1
64427: PUSH
64428: LD_INT 0
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 1
64437: PUSH
64438: LD_INT 1
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 0
64447: PUSH
64448: LD_INT 1
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 1
64457: NEG
64458: PUSH
64459: LD_INT 0
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 1
64468: NEG
64469: PUSH
64470: LD_INT 1
64472: NEG
64473: PUSH
64474: EMPTY
64475: LIST
64476: LIST
64477: PUSH
64478: LD_INT 1
64480: NEG
64481: PUSH
64482: LD_INT 2
64484: NEG
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 0
64492: PUSH
64493: LD_INT 2
64495: NEG
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: LD_INT 1
64503: PUSH
64504: LD_INT 1
64506: NEG
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: PUSH
64512: LD_INT 1
64514: PUSH
64515: LD_INT 2
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PUSH
64522: LD_INT 0
64524: PUSH
64525: LD_INT 2
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: PUSH
64532: LD_INT 1
64534: NEG
64535: PUSH
64536: LD_INT 1
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: PUSH
64546: LD_INT 3
64548: PUSH
64549: EMPTY
64550: LIST
64551: LIST
64552: PUSH
64553: LD_INT 0
64555: PUSH
64556: LD_INT 3
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: LD_INT 1
64565: NEG
64566: PUSH
64567: LD_INT 2
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: LIST
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: LIST
64590: LIST
64591: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64592: LD_ADDR_VAR 0 12
64596: PUSH
64597: LD_INT 0
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 0
64609: PUSH
64610: LD_INT 1
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 1
64620: PUSH
64621: LD_INT 0
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: PUSH
64628: LD_INT 1
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 0
64640: PUSH
64641: LD_INT 1
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: LD_INT 1
64650: NEG
64651: PUSH
64652: LD_INT 0
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PUSH
64659: LD_INT 1
64661: NEG
64662: PUSH
64663: LD_INT 1
64665: NEG
64666: PUSH
64667: EMPTY
64668: LIST
64669: LIST
64670: PUSH
64671: LD_INT 1
64673: PUSH
64674: LD_INT 1
64676: NEG
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 2
64684: PUSH
64685: LD_INT 0
64687: PUSH
64688: EMPTY
64689: LIST
64690: LIST
64691: PUSH
64692: LD_INT 2
64694: PUSH
64695: LD_INT 1
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: PUSH
64702: LD_INT 1
64704: NEG
64705: PUSH
64706: LD_INT 1
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 2
64715: NEG
64716: PUSH
64717: LD_INT 0
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PUSH
64724: LD_INT 2
64726: NEG
64727: PUSH
64728: LD_INT 1
64730: NEG
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 2
64738: NEG
64739: PUSH
64740: LD_INT 1
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: LD_INT 3
64749: NEG
64750: PUSH
64751: LD_INT 0
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 3
64760: NEG
64761: PUSH
64762: LD_INT 1
64764: NEG
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64788: LD_ADDR_VAR 0 13
64792: PUSH
64793: LD_INT 0
64795: PUSH
64796: LD_INT 0
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PUSH
64803: LD_INT 0
64805: PUSH
64806: LD_INT 1
64808: NEG
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: LD_INT 1
64816: PUSH
64817: LD_INT 0
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 1
64826: PUSH
64827: LD_INT 1
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 0
64836: PUSH
64837: LD_INT 1
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 1
64846: NEG
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 1
64857: NEG
64858: PUSH
64859: LD_INT 1
64861: NEG
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 1
64869: NEG
64870: PUSH
64871: LD_INT 2
64873: NEG
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 2
64881: PUSH
64882: LD_INT 1
64884: PUSH
64885: EMPTY
64886: LIST
64887: LIST
64888: PUSH
64889: LD_INT 2
64891: PUSH
64892: LD_INT 2
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 1
64901: PUSH
64902: LD_INT 2
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: PUSH
64909: LD_INT 2
64911: NEG
64912: PUSH
64913: LD_INT 1
64915: NEG
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: PUSH
64921: LD_INT 2
64923: NEG
64924: PUSH
64925: LD_INT 2
64927: NEG
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 2
64935: NEG
64936: PUSH
64937: LD_INT 3
64939: NEG
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 3
64947: NEG
64948: PUSH
64949: LD_INT 2
64951: NEG
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 3
64959: NEG
64960: PUSH
64961: LD_INT 3
64963: NEG
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64987: LD_ADDR_VAR 0 14
64991: PUSH
64992: LD_INT 0
64994: PUSH
64995: LD_INT 0
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: LD_INT 0
65004: PUSH
65005: LD_INT 1
65007: NEG
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PUSH
65013: LD_INT 1
65015: PUSH
65016: LD_INT 0
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: LD_INT 1
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 0
65035: PUSH
65036: LD_INT 1
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 1
65045: NEG
65046: PUSH
65047: LD_INT 0
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 1
65056: NEG
65057: PUSH
65058: LD_INT 1
65060: NEG
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 1
65068: NEG
65069: PUSH
65070: LD_INT 2
65072: NEG
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 0
65080: PUSH
65081: LD_INT 2
65083: NEG
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 1
65091: PUSH
65092: LD_INT 1
65094: NEG
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 1
65102: PUSH
65103: LD_INT 2
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 0
65112: PUSH
65113: LD_INT 2
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PUSH
65120: LD_INT 1
65122: NEG
65123: PUSH
65124: LD_INT 1
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PUSH
65131: LD_INT 1
65133: NEG
65134: PUSH
65135: LD_INT 3
65137: NEG
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: LD_INT 0
65145: PUSH
65146: LD_INT 3
65148: NEG
65149: PUSH
65150: EMPTY
65151: LIST
65152: LIST
65153: PUSH
65154: LD_INT 1
65156: PUSH
65157: LD_INT 2
65159: NEG
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: LIST
65182: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65183: LD_ADDR_VAR 0 15
65187: PUSH
65188: LD_INT 0
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 0
65200: PUSH
65201: LD_INT 1
65203: NEG
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: LD_INT 1
65211: PUSH
65212: LD_INT 0
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: PUSH
65219: LD_INT 1
65221: PUSH
65222: LD_INT 1
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 0
65231: PUSH
65232: LD_INT 1
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: PUSH
65239: LD_INT 1
65241: NEG
65242: PUSH
65243: LD_INT 0
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: LD_INT 1
65252: NEG
65253: PUSH
65254: LD_INT 1
65256: NEG
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: PUSH
65262: LD_INT 1
65264: PUSH
65265: LD_INT 1
65267: NEG
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PUSH
65273: LD_INT 2
65275: PUSH
65276: LD_INT 0
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 2
65285: PUSH
65286: LD_INT 1
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 1
65295: NEG
65296: PUSH
65297: LD_INT 1
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 2
65306: NEG
65307: PUSH
65308: LD_INT 0
65310: PUSH
65311: EMPTY
65312: LIST
65313: LIST
65314: PUSH
65315: LD_INT 2
65317: NEG
65318: PUSH
65319: LD_INT 1
65321: NEG
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 2
65329: PUSH
65330: LD_INT 1
65332: NEG
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 3
65340: PUSH
65341: LD_INT 0
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 3
65350: PUSH
65351: LD_INT 1
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65376: LD_ADDR_VAR 0 16
65380: PUSH
65381: LD_INT 0
65383: PUSH
65384: LD_INT 0
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 0
65393: PUSH
65394: LD_INT 1
65396: NEG
65397: PUSH
65398: EMPTY
65399: LIST
65400: LIST
65401: PUSH
65402: LD_INT 1
65404: PUSH
65405: LD_INT 0
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: PUSH
65412: LD_INT 1
65414: PUSH
65415: LD_INT 1
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 0
65424: PUSH
65425: LD_INT 1
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 1
65434: NEG
65435: PUSH
65436: LD_INT 0
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: NEG
65446: PUSH
65447: LD_INT 1
65449: NEG
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: LD_INT 2
65461: NEG
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 2
65469: PUSH
65470: LD_INT 1
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 2
65479: PUSH
65480: LD_INT 2
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: LD_INT 2
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 2
65499: NEG
65500: PUSH
65501: LD_INT 1
65503: NEG
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 2
65511: NEG
65512: PUSH
65513: LD_INT 2
65515: NEG
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: LD_INT 3
65523: PUSH
65524: LD_INT 2
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 3
65533: PUSH
65534: LD_INT 3
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 2
65543: PUSH
65544: LD_INT 3
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: LIST
65555: LIST
65556: LIST
65557: LIST
65558: LIST
65559: LIST
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65569: LD_ADDR_VAR 0 17
65573: PUSH
65574: LD_INT 0
65576: PUSH
65577: LD_INT 0
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 0
65586: PUSH
65587: LD_INT 1
65589: NEG
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 1
65597: PUSH
65598: LD_INT 0
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: PUSH
65608: LD_INT 1
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: PUSH
65615: LD_INT 0
65617: PUSH
65618: LD_INT 1
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PUSH
65625: LD_INT 1
65627: NEG
65628: PUSH
65629: LD_INT 0
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 1
65638: NEG
65639: PUSH
65640: LD_INT 1
65642: NEG
65643: PUSH
65644: EMPTY
65645: LIST
65646: LIST
65647: PUSH
65648: LD_INT 1
65650: NEG
65651: PUSH
65652: LD_INT 2
65654: NEG
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 0
65662: PUSH
65663: LD_INT 2
65665: NEG
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PUSH
65671: LD_INT 1
65673: PUSH
65674: LD_INT 1
65676: NEG
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 2
65684: PUSH
65685: LD_INT 0
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 2
65694: PUSH
65695: LD_INT 1
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 2
65704: PUSH
65705: LD_INT 2
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: LD_INT 2
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 0
65724: PUSH
65725: LD_INT 2
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PUSH
65732: LD_INT 1
65734: NEG
65735: PUSH
65736: LD_INT 1
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 2
65745: NEG
65746: PUSH
65747: LD_INT 0
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 2
65756: NEG
65757: PUSH
65758: LD_INT 1
65760: NEG
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 2
65768: NEG
65769: PUSH
65770: LD_INT 2
65772: NEG
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65799: LD_ADDR_VAR 0 18
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 0
65816: PUSH
65817: LD_INT 1
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 1
65827: PUSH
65828: LD_INT 0
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: LD_INT 1
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 0
65847: PUSH
65848: LD_INT 1
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 1
65857: NEG
65858: PUSH
65859: LD_INT 0
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: LD_INT 1
65872: NEG
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 1
65880: NEG
65881: PUSH
65882: LD_INT 2
65884: NEG
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 2
65895: NEG
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: LD_INT 1
65906: NEG
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: LD_INT 2
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 2
65924: PUSH
65925: LD_INT 1
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 2
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 2
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: LD_INT 2
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 1
65964: NEG
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 2
65975: NEG
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 2
65986: NEG
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 2
65998: NEG
65999: PUSH
66000: LD_INT 2
66002: NEG
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: LIST
66014: LIST
66015: LIST
66016: LIST
66017: LIST
66018: LIST
66019: LIST
66020: LIST
66021: LIST
66022: LIST
66023: LIST
66024: LIST
66025: LIST
66026: LIST
66027: LIST
66028: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66029: LD_ADDR_VAR 0 19
66033: PUSH
66034: LD_INT 0
66036: PUSH
66037: LD_INT 0
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 0
66046: PUSH
66047: LD_INT 1
66049: NEG
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 1
66057: PUSH
66058: LD_INT 0
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 1
66067: PUSH
66068: LD_INT 1
66070: PUSH
66071: EMPTY
66072: LIST
66073: LIST
66074: PUSH
66075: LD_INT 0
66077: PUSH
66078: LD_INT 1
66080: PUSH
66081: EMPTY
66082: LIST
66083: LIST
66084: PUSH
66085: LD_INT 1
66087: NEG
66088: PUSH
66089: LD_INT 0
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: LD_INT 1
66102: NEG
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 1
66110: NEG
66111: PUSH
66112: LD_INT 2
66114: NEG
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 0
66122: PUSH
66123: LD_INT 2
66125: NEG
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: PUSH
66131: LD_INT 1
66133: PUSH
66134: LD_INT 1
66136: NEG
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 2
66144: PUSH
66145: LD_INT 0
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 2
66154: PUSH
66155: LD_INT 1
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 2
66164: PUSH
66165: LD_INT 2
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 1
66174: PUSH
66175: LD_INT 2
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 0
66184: PUSH
66185: LD_INT 2
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 1
66194: NEG
66195: PUSH
66196: LD_INT 1
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 2
66205: NEG
66206: PUSH
66207: LD_INT 0
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 2
66216: NEG
66217: PUSH
66218: LD_INT 1
66220: NEG
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 2
66228: NEG
66229: PUSH
66230: LD_INT 2
66232: NEG
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66259: LD_ADDR_VAR 0 20
66263: PUSH
66264: LD_INT 0
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: LD_INT 1
66279: NEG
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: LD_INT 0
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 1
66297: PUSH
66298: LD_INT 1
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: LD_INT 1
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: NEG
66318: PUSH
66319: LD_INT 0
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 1
66328: NEG
66329: PUSH
66330: LD_INT 1
66332: NEG
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 1
66340: NEG
66341: PUSH
66342: LD_INT 2
66344: NEG
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: LD_INT 2
66355: NEG
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 1
66363: PUSH
66364: LD_INT 1
66366: NEG
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 2
66374: PUSH
66375: LD_INT 0
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 1
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 2
66394: PUSH
66395: LD_INT 2
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PUSH
66402: LD_INT 1
66404: PUSH
66405: LD_INT 2
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: LD_INT 2
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: NEG
66425: PUSH
66426: LD_INT 1
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 2
66435: NEG
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 2
66446: NEG
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 2
66458: NEG
66459: PUSH
66460: LD_INT 2
66462: NEG
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66489: LD_ADDR_VAR 0 21
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 0
66506: PUSH
66507: LD_INT 1
66509: NEG
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 1
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 1
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 1
66547: NEG
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 1
66558: NEG
66559: PUSH
66560: LD_INT 1
66562: NEG
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: LD_INT 2
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: LD_INT 2
66585: NEG
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: LD_INT 1
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 2
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: LD_INT 1
66634: PUSH
66635: LD_INT 2
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: LD_INT 2
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: LD_INT 1
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 2
66665: NEG
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 2
66676: NEG
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 2
66688: NEG
66689: PUSH
66690: LD_INT 2
66692: NEG
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66719: LD_ADDR_VAR 0 22
66723: PUSH
66724: LD_INT 0
66726: PUSH
66727: LD_INT 0
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: LD_INT 1
66739: NEG
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 1
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 1
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: LD_INT 1
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 1
66777: NEG
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: LD_INT 1
66792: NEG
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 1
66800: NEG
66801: PUSH
66802: LD_INT 2
66804: NEG
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 0
66812: PUSH
66813: LD_INT 2
66815: NEG
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PUSH
66821: LD_INT 1
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 2
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 2
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 2
66854: PUSH
66855: LD_INT 2
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 1
66864: PUSH
66865: LD_INT 2
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: LD_INT 2
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: LD_INT 1
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: NEG
66896: PUSH
66897: LD_INT 0
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: LD_INT 2
66906: NEG
66907: PUSH
66908: LD_INT 1
66910: NEG
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 2
66918: NEG
66919: PUSH
66920: LD_INT 2
66922: NEG
66923: PUSH
66924: EMPTY
66925: LIST
66926: LIST
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66949: LD_ADDR_VAR 0 23
66953: PUSH
66954: LD_INT 0
66956: PUSH
66957: LD_INT 0
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 1
66977: PUSH
66978: LD_INT 0
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: LD_INT 1
66987: PUSH
66988: LD_INT 1
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 0
66997: PUSH
66998: LD_INT 1
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: NEG
67008: PUSH
67009: LD_INT 0
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 1
67022: NEG
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 1
67030: NEG
67031: PUSH
67032: LD_INT 2
67034: NEG
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 0
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: LD_INT 1
67056: NEG
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 2
67064: PUSH
67065: LD_INT 0
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: LD_INT 2
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 2
67084: PUSH
67085: LD_INT 2
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 1
67094: PUSH
67095: LD_INT 2
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: LD_INT 2
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: LD_INT 1
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 2
67125: NEG
67126: PUSH
67127: LD_INT 0
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 1
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 2
67148: NEG
67149: PUSH
67150: LD_INT 2
67152: NEG
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 2
67160: NEG
67161: PUSH
67162: LD_INT 3
67164: NEG
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 1
67172: NEG
67173: PUSH
67174: LD_INT 3
67176: NEG
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: LD_INT 2
67187: NEG
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 2
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: LIST
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67229: LD_ADDR_VAR 0 24
67233: PUSH
67234: LD_INT 0
67236: PUSH
67237: LD_INT 0
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: LD_INT 1
67249: NEG
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 1
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 1
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: LD_INT 1
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PUSH
67289: LD_INT 0
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 1
67298: NEG
67299: PUSH
67300: LD_INT 1
67302: NEG
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 1
67310: NEG
67311: PUSH
67312: LD_INT 2
67314: NEG
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 2
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: LD_INT 1
67336: NEG
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 0
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 2
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 2
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: PUSH
67375: LD_INT 2
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 0
67384: PUSH
67385: LD_INT 2
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 1
67394: NEG
67395: PUSH
67396: LD_INT 1
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 2
67405: NEG
67406: PUSH
67407: LD_INT 0
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 2
67416: NEG
67417: PUSH
67418: LD_INT 1
67420: NEG
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 2
67428: NEG
67429: PUSH
67430: LD_INT 2
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: LD_INT 2
67443: NEG
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: LD_INT 1
67454: NEG
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 3
67462: PUSH
67463: LD_INT 1
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 3
67472: PUSH
67473: LD_INT 2
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67505: LD_ADDR_VAR 0 25
67509: PUSH
67510: LD_INT 0
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 0
67522: PUSH
67523: LD_INT 1
67525: NEG
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 1
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 0
67553: PUSH
67554: LD_INT 1
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 1
67563: NEG
67564: PUSH
67565: LD_INT 0
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: LD_INT 1
67578: NEG
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 1
67586: NEG
67587: PUSH
67588: LD_INT 2
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 0
67598: PUSH
67599: LD_INT 2
67601: NEG
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: LD_INT 1
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 2
67620: PUSH
67621: LD_INT 0
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 2
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 2
67640: PUSH
67641: LD_INT 2
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 1
67650: PUSH
67651: LD_INT 2
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: LD_INT 2
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 1
67670: NEG
67671: PUSH
67672: LD_INT 1
67674: PUSH
67675: EMPTY
67676: LIST
67677: LIST
67678: PUSH
67679: LD_INT 2
67681: NEG
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: EMPTY
67687: LIST
67688: LIST
67689: PUSH
67690: LD_INT 2
67692: NEG
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 2
67704: NEG
67705: PUSH
67706: LD_INT 2
67708: NEG
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 3
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 3
67726: PUSH
67727: LD_INT 2
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 2
67736: PUSH
67737: LD_INT 3
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 1
67746: PUSH
67747: LD_INT 3
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67779: LD_ADDR_VAR 0 26
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: LD_INT 0
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 0
67796: PUSH
67797: LD_INT 1
67799: NEG
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 1
67807: PUSH
67808: LD_INT 0
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: LD_INT 1
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 0
67827: PUSH
67828: LD_INT 1
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 1
67837: NEG
67838: PUSH
67839: LD_INT 0
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 1
67848: NEG
67849: PUSH
67850: LD_INT 1
67852: NEG
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 1
67860: NEG
67861: PUSH
67862: LD_INT 2
67864: NEG
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 0
67872: PUSH
67873: LD_INT 2
67875: NEG
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 1
67883: PUSH
67884: LD_INT 1
67886: NEG
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: PUSH
67892: LD_INT 2
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 2
67904: PUSH
67905: LD_INT 1
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 2
67914: PUSH
67915: LD_INT 2
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 1
67924: PUSH
67925: LD_INT 2
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 0
67934: PUSH
67935: LD_INT 2
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 2
67955: NEG
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 2
67966: NEG
67967: PUSH
67968: LD_INT 1
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: LD_INT 2
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 2
67990: PUSH
67991: LD_INT 3
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 1
68000: PUSH
68001: LD_INT 3
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 1
68010: NEG
68011: PUSH
68012: LD_INT 2
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 2
68021: NEG
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68055: LD_ADDR_VAR 0 27
68059: PUSH
68060: LD_INT 0
68062: PUSH
68063: LD_INT 0
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 0
68072: PUSH
68073: LD_INT 1
68075: NEG
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 1
68083: PUSH
68084: LD_INT 0
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 1
68093: PUSH
68094: LD_INT 1
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 1
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 1
68113: NEG
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: NEG
68125: PUSH
68126: LD_INT 1
68128: NEG
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: LD_INT 2
68140: NEG
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 1
68159: PUSH
68160: LD_INT 1
68162: NEG
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 2
68170: PUSH
68171: LD_INT 0
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 2
68180: PUSH
68181: LD_INT 1
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 2
68190: PUSH
68191: LD_INT 2
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 1
68200: PUSH
68201: LD_INT 2
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 2
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: NEG
68221: PUSH
68222: LD_INT 1
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 2
68231: NEG
68232: PUSH
68233: LD_INT 0
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 2
68242: NEG
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: NEG
68255: PUSH
68256: LD_INT 2
68258: NEG
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 1
68266: NEG
68267: PUSH
68268: LD_INT 2
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 2
68277: NEG
68278: PUSH
68279: LD_INT 1
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: PUSH
68286: LD_INT 3
68288: NEG
68289: PUSH
68290: LD_INT 1
68292: NEG
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 3
68300: NEG
68301: PUSH
68302: LD_INT 2
68304: NEG
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68335: LD_ADDR_VAR 0 28
68339: PUSH
68340: LD_INT 0
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 0
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: LD_INT 1
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: LD_INT 1
68408: NEG
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 1
68416: NEG
68417: PUSH
68418: LD_INT 2
68420: NEG
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: LD_INT 2
68431: NEG
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 1
68439: PUSH
68440: LD_INT 1
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 2
68450: PUSH
68451: LD_INT 0
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 2
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 2
68470: PUSH
68471: LD_INT 2
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 1
68480: PUSH
68481: LD_INT 2
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 0
68490: PUSH
68491: LD_INT 2
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 1
68500: NEG
68501: PUSH
68502: LD_INT 1
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 2
68511: NEG
68512: PUSH
68513: LD_INT 0
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: LD_INT 1
68526: NEG
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 2
68534: NEG
68535: PUSH
68536: LD_INT 2
68538: NEG
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: LD_INT 2
68546: NEG
68547: PUSH
68548: LD_INT 3
68550: NEG
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 1
68558: NEG
68559: PUSH
68560: LD_INT 3
68562: NEG
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PUSH
68568: LD_INT 3
68570: NEG
68571: PUSH
68572: LD_INT 1
68574: NEG
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 3
68582: NEG
68583: PUSH
68584: LD_INT 2
68586: NEG
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68617: LD_ADDR_VAR 0 29
68621: PUSH
68622: LD_INT 0
68624: PUSH
68625: LD_INT 0
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 0
68634: PUSH
68635: LD_INT 1
68637: NEG
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: PUSH
68646: LD_INT 0
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: LD_INT 1
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: PUSH
68663: LD_INT 0
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 1
68675: NEG
68676: PUSH
68677: LD_INT 0
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 1
68686: NEG
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: LD_INT 2
68702: NEG
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 0
68710: PUSH
68711: LD_INT 2
68713: NEG
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: PUSH
68722: LD_INT 1
68724: NEG
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 2
68732: PUSH
68733: LD_INT 0
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 2
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 2
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: LD_INT 2
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 2
68783: NEG
68784: PUSH
68785: LD_INT 1
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: LD_INT 2
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 2
68807: NEG
68808: PUSH
68809: LD_INT 3
68811: NEG
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 2
68819: PUSH
68820: LD_INT 1
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 3
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 1
68840: PUSH
68841: LD_INT 3
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 1
68850: NEG
68851: PUSH
68852: LD_INT 2
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 3
68861: NEG
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68896: LD_ADDR_VAR 0 30
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: LD_INT 0
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 0
68913: PUSH
68914: LD_INT 1
68916: NEG
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: LD_INT 0
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 1
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 0
68944: PUSH
68945: LD_INT 1
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 1
68954: NEG
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: LD_INT 1
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 2
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 0
68989: PUSH
68990: LD_INT 2
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 1
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 2
69031: PUSH
69032: LD_INT 2
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: LD_INT 2
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: LD_INT 1
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 2
69062: NEG
69063: PUSH
69064: LD_INT 0
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 2
69073: NEG
69074: PUSH
69075: LD_INT 1
69077: NEG
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: LD_INT 1
69085: NEG
69086: PUSH
69087: LD_INT 3
69089: NEG
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 2
69100: NEG
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 3
69108: PUSH
69109: LD_INT 2
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 2
69118: PUSH
69119: LD_INT 3
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 2
69128: NEG
69129: PUSH
69130: LD_INT 1
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 3
69139: NEG
69140: PUSH
69141: LD_INT 1
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69174: LD_ADDR_VAR 0 31
69178: PUSH
69179: LD_INT 0
69181: PUSH
69182: LD_INT 0
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: LD_INT 1
69194: NEG
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: PUSH
69200: LD_INT 1
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 1
69212: PUSH
69213: LD_INT 1
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: LD_INT 1
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 1
69232: NEG
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 1
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: NEG
69256: PUSH
69257: LD_INT 2
69259: NEG
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: PUSH
69268: LD_INT 1
69270: NEG
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 2
69278: PUSH
69279: LD_INT 0
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 2
69288: PUSH
69289: LD_INT 1
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 2
69298: PUSH
69299: LD_INT 2
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PUSH
69306: LD_INT 1
69308: PUSH
69309: LD_INT 2
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: LD_INT 2
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 2
69339: NEG
69340: PUSH
69341: LD_INT 1
69343: NEG
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 2
69351: NEG
69352: PUSH
69353: LD_INT 2
69355: NEG
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 2
69363: NEG
69364: PUSH
69365: LD_INT 3
69367: NEG
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 3
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: LD_INT 3
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: NEG
69407: PUSH
69408: LD_INT 2
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 3
69417: NEG
69418: PUSH
69419: LD_INT 2
69421: NEG
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69452: LD_ADDR_VAR 0 32
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 0
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: PUSH
69491: LD_INT 1
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 0
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: NEG
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 1
69521: NEG
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 1
69533: NEG
69534: PUSH
69535: LD_INT 2
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 2
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: LD_INT 1
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 2
69577: PUSH
69578: LD_INT 2
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 1
69587: PUSH
69588: LD_INT 2
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: LD_INT 2
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: LD_INT 1
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 2
69629: NEG
69630: PUSH
69631: LD_INT 1
69633: NEG
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: LD_INT 1
69641: NEG
69642: PUSH
69643: LD_INT 3
69645: NEG
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 1
69653: PUSH
69654: LD_INT 2
69656: NEG
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 3
69664: PUSH
69665: LD_INT 2
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: LD_INT 2
69674: PUSH
69675: LD_INT 3
69677: PUSH
69678: EMPTY
69679: LIST
69680: LIST
69681: PUSH
69682: LD_INT 2
69684: NEG
69685: PUSH
69686: LD_INT 1
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 3
69695: NEG
69696: PUSH
69697: LD_INT 1
69699: NEG
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69730: LD_ADDR_VAR 0 33
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: LD_INT 1
69750: NEG
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 1
69758: PUSH
69759: LD_INT 0
69761: PUSH
69762: EMPTY
69763: LIST
69764: LIST
69765: PUSH
69766: LD_INT 1
69768: PUSH
69769: LD_INT 1
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 1
69788: NEG
69789: PUSH
69790: LD_INT 0
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 1
69799: NEG
69800: PUSH
69801: LD_INT 1
69803: NEG
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 2
69815: NEG
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 1
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 2
69834: PUSH
69835: LD_INT 0
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PUSH
69842: LD_INT 2
69844: PUSH
69845: LD_INT 1
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 1
69854: PUSH
69855: LD_INT 2
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: LD_INT 2
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: LD_INT 1
69874: NEG
69875: PUSH
69876: LD_INT 1
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: LD_INT 2
69885: NEG
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 2
69896: NEG
69897: PUSH
69898: LD_INT 1
69900: NEG
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 2
69908: NEG
69909: PUSH
69910: LD_INT 2
69912: NEG
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 2
69920: NEG
69921: PUSH
69922: LD_INT 3
69924: NEG
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 2
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 3
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 1
69953: PUSH
69954: LD_INT 3
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: LD_INT 1
69963: NEG
69964: PUSH
69965: LD_INT 2
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 3
69974: NEG
69975: PUSH
69976: LD_INT 2
69978: NEG
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70009: LD_ADDR_VAR 0 34
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 0
70026: PUSH
70027: LD_INT 1
70029: NEG
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 0
70057: PUSH
70058: LD_INT 1
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 1
70067: NEG
70068: PUSH
70069: LD_INT 0
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 1
70078: NEG
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: NEG
70091: PUSH
70092: LD_INT 2
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 0
70102: PUSH
70103: LD_INT 2
70105: NEG
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 1
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 2
70124: PUSH
70125: LD_INT 1
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 2
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 1
70144: PUSH
70145: LD_INT 2
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 2
70165: NEG
70166: PUSH
70167: LD_INT 0
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: PUSH
70174: LD_INT 2
70176: NEG
70177: PUSH
70178: LD_INT 1
70180: NEG
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 2
70188: NEG
70189: PUSH
70190: LD_INT 2
70192: NEG
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 1
70200: NEG
70201: PUSH
70202: LD_INT 3
70204: NEG
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 1
70212: PUSH
70213: LD_INT 2
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 3
70223: PUSH
70224: LD_INT 2
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 2
70233: PUSH
70234: LD_INT 3
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 2
70243: NEG
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 3
70254: NEG
70255: PUSH
70256: LD_INT 1
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70289: LD_ADDR_VAR 0 35
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 0
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 0
70306: PUSH
70307: LD_INT 1
70309: NEG
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: PUSH
70328: LD_INT 1
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: LD_INT 1
70340: PUSH
70341: EMPTY
70342: LIST
70343: LIST
70344: PUSH
70345: LD_INT 1
70347: NEG
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: LD_INT 1
70362: NEG
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 2
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 2
70380: NEG
70381: PUSH
70382: LD_INT 1
70384: NEG
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70401: LD_ADDR_VAR 0 36
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: LD_INT 0
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: PUSH
70416: LD_INT 0
70418: PUSH
70419: LD_INT 1
70421: NEG
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 1
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 0
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 1
70459: NEG
70460: PUSH
70461: LD_INT 0
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 1
70470: NEG
70471: PUSH
70472: LD_INT 1
70474: NEG
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: NEG
70483: PUSH
70484: LD_INT 2
70486: NEG
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 1
70494: PUSH
70495: LD_INT 2
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70513: LD_ADDR_VAR 0 37
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: LD_INT 0
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: LD_INT 1
70533: NEG
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 1
70541: PUSH
70542: LD_INT 0
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: LD_INT 1
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 0
70561: PUSH
70562: LD_INT 1
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 1
70571: NEG
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 1
70582: NEG
70583: PUSH
70584: LD_INT 1
70586: NEG
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 1
70594: PUSH
70595: LD_INT 1
70597: NEG
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 1
70605: NEG
70606: PUSH
70607: LD_INT 1
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70625: LD_ADDR_VAR 0 38
70629: PUSH
70630: LD_INT 0
70632: PUSH
70633: LD_INT 0
70635: PUSH
70636: EMPTY
70637: LIST
70638: LIST
70639: PUSH
70640: LD_INT 0
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 1
70653: PUSH
70654: LD_INT 0
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: LD_INT 1
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 0
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: LD_INT 0
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: NEG
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70737: LD_ADDR_VAR 0 39
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: LD_INT 0
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 0
70754: PUSH
70755: LD_INT 1
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 1
70765: PUSH
70766: LD_INT 0
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 1
70775: PUSH
70776: LD_INT 1
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PUSH
70783: LD_INT 0
70785: PUSH
70786: LD_INT 1
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: LD_INT 0
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 1
70806: NEG
70807: PUSH
70808: LD_INT 1
70810: NEG
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 1
70818: NEG
70819: PUSH
70820: LD_INT 2
70822: NEG
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: LD_INT 2
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: LIST
70842: LIST
70843: LIST
70844: LIST
70845: LIST
70846: LIST
70847: LIST
70848: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70849: LD_ADDR_VAR 0 40
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: LD_INT 0
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 0
70866: PUSH
70867: LD_INT 1
70869: NEG
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 1
70877: PUSH
70878: LD_INT 0
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 1
70887: PUSH
70888: LD_INT 1
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: PUSH
70895: LD_INT 0
70897: PUSH
70898: LD_INT 1
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 1
70907: NEG
70908: PUSH
70909: LD_INT 0
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 1
70918: NEG
70919: PUSH
70920: LD_INT 1
70922: NEG
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 1
70930: PUSH
70931: LD_INT 1
70933: NEG
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 1
70941: NEG
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: LIST
70954: LIST
70955: LIST
70956: LIST
70957: LIST
70958: LIST
70959: LIST
70960: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70961: LD_ADDR_VAR 0 41
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: LD_INT 0
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 0
70978: PUSH
70979: LD_INT 1
70981: NEG
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 1
70989: PUSH
70990: LD_INT 0
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 1
70999: PUSH
71000: LD_INT 1
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 0
71009: PUSH
71010: LD_INT 1
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 1
71019: NEG
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 1
71030: NEG
71031: PUSH
71032: LD_INT 1
71034: NEG
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 1
71042: NEG
71043: PUSH
71044: LD_INT 2
71046: NEG
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 1
71054: PUSH
71055: LD_INT 1
71057: NEG
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 2
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 2
71075: PUSH
71076: LD_INT 1
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 2
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 1
71095: PUSH
71096: LD_INT 2
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 2
71116: NEG
71117: PUSH
71118: LD_INT 0
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 2
71127: NEG
71128: PUSH
71129: LD_INT 1
71131: NEG
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 2
71139: NEG
71140: PUSH
71141: LD_INT 2
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: NEG
71152: PUSH
71153: LD_INT 3
71155: NEG
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 2
71163: PUSH
71164: LD_INT 1
71166: NEG
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 3
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 3
71184: PUSH
71185: LD_INT 1
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 3
71194: PUSH
71195: LD_INT 2
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 3
71204: PUSH
71205: LD_INT 3
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 2
71214: PUSH
71215: LD_INT 3
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 2
71224: NEG
71225: PUSH
71226: LD_INT 1
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 3
71235: NEG
71236: PUSH
71237: LD_INT 0
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 3
71246: NEG
71247: PUSH
71248: LD_INT 1
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 3
71258: NEG
71259: PUSH
71260: LD_INT 2
71262: NEG
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PUSH
71268: LD_INT 3
71270: NEG
71271: PUSH
71272: LD_INT 3
71274: NEG
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71311: LD_ADDR_VAR 0 42
71315: PUSH
71316: LD_INT 0
71318: PUSH
71319: LD_INT 0
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 0
71328: PUSH
71329: LD_INT 1
71331: NEG
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: PUSH
71340: LD_INT 0
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 1
71349: PUSH
71350: LD_INT 1
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 0
71359: PUSH
71360: LD_INT 1
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 1
71369: NEG
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 1
71380: NEG
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 1
71392: NEG
71393: PUSH
71394: LD_INT 2
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 0
71404: PUSH
71405: LD_INT 2
71407: NEG
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: LD_INT 1
71418: NEG
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 2
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 2
71436: PUSH
71437: LD_INT 2
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 1
71446: PUSH
71447: LD_INT 2
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: LD_INT 2
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: NEG
71467: PUSH
71468: LD_INT 1
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: PUSH
71475: LD_INT 2
71477: NEG
71478: PUSH
71479: LD_INT 1
71481: NEG
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 2
71489: NEG
71490: PUSH
71491: LD_INT 2
71493: NEG
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 2
71501: NEG
71502: PUSH
71503: LD_INT 3
71505: NEG
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: LD_INT 3
71517: NEG
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 0
71525: PUSH
71526: LD_INT 3
71528: NEG
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 1
71536: PUSH
71537: LD_INT 2
71539: NEG
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 3
71547: PUSH
71548: LD_INT 2
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 3
71557: PUSH
71558: LD_INT 3
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PUSH
71565: LD_INT 2
71567: PUSH
71568: LD_INT 3
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 1
71577: PUSH
71578: LD_INT 3
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 3
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 1
71597: NEG
71598: PUSH
71599: LD_INT 2
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 3
71608: NEG
71609: PUSH
71610: LD_INT 2
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 3
71620: NEG
71621: PUSH
71622: LD_INT 3
71624: NEG
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71661: LD_ADDR_VAR 0 43
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: LD_INT 0
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: LD_INT 0
71678: PUSH
71679: LD_INT 1
71681: NEG
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 1
71689: PUSH
71690: LD_INT 0
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: LD_INT 1
71699: PUSH
71700: LD_INT 1
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: LD_INT 1
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 1
71719: NEG
71720: PUSH
71721: LD_INT 0
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: LD_INT 1
71734: NEG
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: LD_INT 2
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: LD_INT 2
71757: NEG
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 1
71768: NEG
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 2
71776: PUSH
71777: LD_INT 0
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 2
71786: PUSH
71787: LD_INT 1
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 1
71796: PUSH
71797: LD_INT 2
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: LD_INT 0
71806: PUSH
71807: LD_INT 2
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: LD_INT 1
71816: NEG
71817: PUSH
71818: LD_INT 1
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: LD_INT 0
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 2
71838: NEG
71839: PUSH
71840: LD_INT 1
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 3
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 0
71862: PUSH
71863: LD_INT 3
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 1
71873: PUSH
71874: LD_INT 2
71876: NEG
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 2
71884: PUSH
71885: LD_INT 1
71887: NEG
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 3
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 3
71905: PUSH
71906: LD_INT 1
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 1
71915: PUSH
71916: LD_INT 3
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 3
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: LD_INT 2
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 2
71946: NEG
71947: PUSH
71948: LD_INT 1
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 3
71957: NEG
71958: PUSH
71959: LD_INT 0
71961: PUSH
71962: EMPTY
71963: LIST
71964: LIST
71965: PUSH
71966: LD_INT 3
71968: NEG
71969: PUSH
71970: LD_INT 1
71972: NEG
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72009: LD_ADDR_VAR 0 44
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 0
72026: PUSH
72027: LD_INT 1
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 1
72037: PUSH
72038: LD_INT 0
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: LD_INT 1
72047: PUSH
72048: LD_INT 1
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 0
72057: PUSH
72058: LD_INT 1
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 1
72067: NEG
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: NEG
72079: PUSH
72080: LD_INT 1
72082: NEG
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: LD_INT 2
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: LD_INT 1
72105: NEG
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 2
72113: PUSH
72114: LD_INT 0
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 2
72123: PUSH
72124: LD_INT 1
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 2
72133: PUSH
72134: LD_INT 2
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: LD_INT 2
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: LD_INT 1
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: LD_INT 2
72164: NEG
72165: PUSH
72166: LD_INT 0
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 2
72175: NEG
72176: PUSH
72177: LD_INT 1
72179: NEG
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 2
72187: NEG
72188: PUSH
72189: LD_INT 2
72191: NEG
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 2
72199: NEG
72200: PUSH
72201: LD_INT 3
72203: NEG
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: LD_INT 1
72214: NEG
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 3
72222: PUSH
72223: LD_INT 0
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 3
72232: PUSH
72233: LD_INT 1
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 3
72242: PUSH
72243: LD_INT 2
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 3
72252: PUSH
72253: LD_INT 3
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 2
72262: PUSH
72263: LD_INT 3
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 2
72272: NEG
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 3
72283: NEG
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 3
72294: NEG
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 3
72306: NEG
72307: PUSH
72308: LD_INT 2
72310: NEG
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 3
72318: NEG
72319: PUSH
72320: LD_INT 3
72322: NEG
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72359: LD_ADDR_VAR 0 45
72363: PUSH
72364: LD_INT 0
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 0
72376: PUSH
72377: LD_INT 1
72379: NEG
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 1
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: LD_INT 1
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: NEG
72418: PUSH
72419: LD_INT 0
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 1
72428: NEG
72429: PUSH
72430: LD_INT 1
72432: NEG
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: LD_INT 2
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: LD_INT 2
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: LD_INT 1
72466: NEG
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 2
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 2
72484: PUSH
72485: LD_INT 2
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 1
72494: PUSH
72495: LD_INT 2
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: LD_INT 2
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 1
72514: NEG
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 2
72525: NEG
72526: PUSH
72527: LD_INT 1
72529: NEG
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 2
72537: NEG
72538: PUSH
72539: LD_INT 2
72541: NEG
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 2
72549: NEG
72550: PUSH
72551: LD_INT 3
72553: NEG
72554: PUSH
72555: EMPTY
72556: LIST
72557: LIST
72558: PUSH
72559: LD_INT 1
72561: NEG
72562: PUSH
72563: LD_INT 3
72565: NEG
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 0
72573: PUSH
72574: LD_INT 3
72576: NEG
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 1
72584: PUSH
72585: LD_INT 2
72587: NEG
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 3
72595: PUSH
72596: LD_INT 2
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 3
72605: PUSH
72606: LD_INT 3
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 2
72615: PUSH
72616: LD_INT 3
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: LD_INT 3
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 0
72635: PUSH
72636: LD_INT 3
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 1
72645: NEG
72646: PUSH
72647: LD_INT 2
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 3
72656: NEG
72657: PUSH
72658: LD_INT 2
72660: NEG
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 3
72668: NEG
72669: PUSH
72670: LD_INT 3
72672: NEG
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72709: LD_ADDR_VAR 0 46
72713: PUSH
72714: LD_INT 0
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 0
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: PUSH
72738: LD_INT 0
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 1
72747: PUSH
72748: LD_INT 1
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: LD_INT 1
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: LD_INT 1
72767: NEG
72768: PUSH
72769: LD_INT 0
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: NEG
72779: PUSH
72780: LD_INT 1
72782: NEG
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: LD_INT 1
72790: NEG
72791: PUSH
72792: LD_INT 2
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 0
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: LD_INT 1
72816: NEG
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 2
72824: PUSH
72825: LD_INT 0
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 2
72834: PUSH
72835: LD_INT 1
72837: PUSH
72838: EMPTY
72839: LIST
72840: LIST
72841: PUSH
72842: LD_INT 1
72844: PUSH
72845: LD_INT 2
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 0
72854: PUSH
72855: LD_INT 2
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: PUSH
72873: LD_INT 2
72875: NEG
72876: PUSH
72877: LD_INT 0
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: LD_INT 1
72890: NEG
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 3
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: LD_INT 3
72913: NEG
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 2
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 3
72943: PUSH
72944: LD_INT 0
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 3
72953: PUSH
72954: LD_INT 1
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 3
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: LD_INT 3
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: NEG
72984: PUSH
72985: LD_INT 2
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: NEG
72995: PUSH
72996: LD_INT 1
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 3
73005: NEG
73006: PUSH
73007: LD_INT 0
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 3
73016: NEG
73017: PUSH
73018: LD_INT 1
73020: NEG
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: LIST
73030: LIST
73031: LIST
73032: LIST
73033: LIST
73034: LIST
73035: LIST
73036: LIST
73037: LIST
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: LIST
73048: LIST
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73057: LD_ADDR_VAR 0 47
73061: PUSH
73062: LD_INT 0
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 0
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 1
73085: PUSH
73086: LD_INT 0
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 1
73095: PUSH
73096: LD_INT 1
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: LD_INT 1
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 1
73115: NEG
73116: PUSH
73117: LD_INT 0
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 1
73126: NEG
73127: PUSH
73128: LD_INT 1
73130: NEG
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 1
73138: NEG
73139: PUSH
73140: LD_INT 2
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: LD_INT 2
73153: NEG
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: LD_INT 1
73164: NEG
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 2
73172: NEG
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 2
73184: NEG
73185: PUSH
73186: LD_INT 2
73188: NEG
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73208: LD_ADDR_VAR 0 48
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 0
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 1
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: LD_INT 1
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 0
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 1
73277: NEG
73278: PUSH
73279: LD_INT 1
73281: NEG
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: LD_INT 1
73289: NEG
73290: PUSH
73291: LD_INT 2
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 0
73301: PUSH
73302: LD_INT 2
73304: NEG
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 1
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 2
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 2
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73355: LD_ADDR_VAR 0 49
73359: PUSH
73360: LD_INT 0
73362: PUSH
73363: LD_INT 0
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 0
73372: PUSH
73373: LD_INT 1
73375: NEG
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 1
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 1
73393: PUSH
73394: LD_INT 1
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: LD_INT 1
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 1
73413: NEG
73414: PUSH
73415: LD_INT 0
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: NEG
73425: PUSH
73426: LD_INT 1
73428: NEG
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 2
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 2
73457: PUSH
73458: LD_INT 1
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 2
73467: PUSH
73468: LD_INT 2
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: LD_INT 2
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: LIST
73498: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73499: LD_ADDR_VAR 0 50
73503: PUSH
73504: LD_INT 0
73506: PUSH
73507: LD_INT 0
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 0
73516: PUSH
73517: LD_INT 1
73519: NEG
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 1
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 1
73537: PUSH
73538: LD_INT 1
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 0
73547: PUSH
73548: LD_INT 1
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 1
73557: NEG
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 1
73568: NEG
73569: PUSH
73570: LD_INT 1
73572: NEG
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 2
73580: PUSH
73581: LD_INT 1
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 2
73590: PUSH
73591: LD_INT 2
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 1
73600: PUSH
73601: LD_INT 2
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 0
73610: PUSH
73611: LD_INT 2
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 1
73620: NEG
73621: PUSH
73622: LD_INT 1
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: LIST
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73643: LD_ADDR_VAR 0 51
73647: PUSH
73648: LD_INT 0
73650: PUSH
73651: LD_INT 0
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: LD_INT 1
73663: NEG
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: LD_INT 1
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 0
73691: PUSH
73692: LD_INT 1
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: PUSH
73699: LD_INT 1
73701: NEG
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 1
73712: NEG
73713: PUSH
73714: LD_INT 1
73716: NEG
73717: PUSH
73718: EMPTY
73719: LIST
73720: LIST
73721: PUSH
73722: LD_INT 1
73724: PUSH
73725: LD_INT 2
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: LD_INT 2
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 1
73744: NEG
73745: PUSH
73746: LD_INT 1
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 2
73755: NEG
73756: PUSH
73757: LD_INT 0
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 2
73766: NEG
73767: PUSH
73768: LD_INT 1
73770: NEG
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73790: LD_ADDR_VAR 0 52
73794: PUSH
73795: LD_INT 0
73797: PUSH
73798: LD_INT 0
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 0
73807: PUSH
73808: LD_INT 1
73810: NEG
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: LD_INT 0
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 1
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: LD_INT 1
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: LD_INT 0
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 1
73859: NEG
73860: PUSH
73861: LD_INT 1
73863: NEG
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: NEG
73872: PUSH
73873: LD_INT 2
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: LD_INT 1
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 2
73894: NEG
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 2
73905: NEG
73906: PUSH
73907: LD_INT 1
73909: NEG
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: LD_INT 2
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73941: LD_ADDR_VAR 0 53
73945: PUSH
73946: LD_INT 0
73948: PUSH
73949: LD_INT 0
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 0
73958: PUSH
73959: LD_INT 1
73961: NEG
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 1
73969: PUSH
73970: LD_INT 0
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 1
73979: PUSH
73980: LD_INT 1
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 0
73989: PUSH
73990: LD_INT 1
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: NEG
74000: PUSH
74001: LD_INT 0
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 1
74010: NEG
74011: PUSH
74012: LD_INT 1
74014: NEG
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: LD_INT 2
74026: NEG
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: LD_INT 2
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: LD_INT 1
74048: NEG
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 2
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 2
74066: PUSH
74067: LD_INT 1
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 2
74076: PUSH
74077: LD_INT 2
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: PUSH
74087: LD_INT 2
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 0
74096: PUSH
74097: LD_INT 2
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 1
74106: NEG
74107: PUSH
74108: LD_INT 1
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 2
74117: NEG
74118: PUSH
74119: LD_INT 0
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 2
74128: NEG
74129: PUSH
74130: LD_INT 1
74132: NEG
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: NEG
74141: PUSH
74142: LD_INT 2
74144: NEG
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: LIST
74157: LIST
74158: LIST
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74171: LD_ADDR_VAR 0 54
74175: PUSH
74176: LD_INT 0
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: LD_INT 1
74191: NEG
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 1
74199: PUSH
74200: LD_INT 0
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: LD_INT 1
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 1
74229: NEG
74230: PUSH
74231: LD_INT 0
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 1
74244: NEG
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 1
74252: NEG
74253: PUSH
74254: LD_INT 2
74256: NEG
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: LD_INT 0
74264: PUSH
74265: LD_INT 2
74267: NEG
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 1
74275: PUSH
74276: LD_INT 1
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 2
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 2
74296: PUSH
74297: LD_INT 1
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 2
74306: PUSH
74307: LD_INT 2
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 2
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 0
74326: PUSH
74327: LD_INT 2
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: NEG
74337: PUSH
74338: LD_INT 1
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 2
74347: NEG
74348: PUSH
74349: LD_INT 0
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 2
74358: NEG
74359: PUSH
74360: LD_INT 1
74362: NEG
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: LD_INT 2
74370: NEG
74371: PUSH
74372: LD_INT 2
74374: NEG
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: LIST
74384: LIST
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74401: LD_ADDR_VAR 0 55
74405: PUSH
74406: LD_INT 0
74408: PUSH
74409: LD_INT 0
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 0
74418: PUSH
74419: LD_INT 1
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 1
74429: PUSH
74430: LD_INT 0
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 1
74439: PUSH
74440: LD_INT 1
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: LD_INT 0
74449: PUSH
74450: LD_INT 1
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: LD_INT 1
74459: NEG
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: LD_INT 1
74474: NEG
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: LD_INT 2
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 0
74494: PUSH
74495: LD_INT 2
74497: NEG
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 1
74505: PUSH
74506: LD_INT 1
74508: NEG
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 2
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 2
74526: PUSH
74527: LD_INT 1
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 2
74536: PUSH
74537: LD_INT 2
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 1
74546: PUSH
74547: LD_INT 2
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: LD_INT 2
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 1
74566: NEG
74567: PUSH
74568: LD_INT 1
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 2
74577: NEG
74578: PUSH
74579: LD_INT 0
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: LD_INT 2
74588: NEG
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 2
74600: NEG
74601: PUSH
74602: LD_INT 2
74604: NEG
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74631: LD_ADDR_VAR 0 56
74635: PUSH
74636: LD_INT 0
74638: PUSH
74639: LD_INT 0
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: LD_INT 1
74651: NEG
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 1
74659: PUSH
74660: LD_INT 0
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 1
74669: PUSH
74670: LD_INT 1
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: LD_INT 1
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: LD_INT 1
74700: NEG
74701: PUSH
74702: LD_INT 1
74704: NEG
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: NEG
74713: PUSH
74714: LD_INT 2
74716: NEG
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 0
74724: PUSH
74725: LD_INT 2
74727: NEG
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 1
74735: PUSH
74736: LD_INT 1
74738: NEG
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 2
74746: PUSH
74747: LD_INT 0
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: LD_INT 2
74756: PUSH
74757: LD_INT 1
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 2
74766: PUSH
74767: LD_INT 2
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: PUSH
74774: LD_INT 1
74776: PUSH
74777: LD_INT 2
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 0
74786: PUSH
74787: LD_INT 2
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: LD_INT 1
74800: PUSH
74801: EMPTY
74802: LIST
74803: LIST
74804: PUSH
74805: LD_INT 2
74807: NEG
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 2
74818: NEG
74819: PUSH
74820: LD_INT 1
74822: NEG
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 2
74830: NEG
74831: PUSH
74832: LD_INT 2
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: LIST
74846: LIST
74847: LIST
74848: LIST
74849: LIST
74850: LIST
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74861: LD_ADDR_VAR 0 57
74865: PUSH
74866: LD_INT 0
74868: PUSH
74869: LD_INT 0
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 0
74878: PUSH
74879: LD_INT 1
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: PUSH
74890: LD_INT 0
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 1
74899: PUSH
74900: LD_INT 1
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: LD_INT 1
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 1
74919: NEG
74920: PUSH
74921: LD_INT 0
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 1
74930: NEG
74931: PUSH
74932: LD_INT 1
74934: NEG
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 1
74942: NEG
74943: PUSH
74944: LD_INT 2
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 0
74954: PUSH
74955: LD_INT 2
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 1
74965: PUSH
74966: LD_INT 1
74968: NEG
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 2
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 2
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 2
74996: PUSH
74997: LD_INT 2
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: PUSH
75007: LD_INT 2
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 0
75016: PUSH
75017: LD_INT 2
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 1
75026: NEG
75027: PUSH
75028: LD_INT 1
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 2
75037: NEG
75038: PUSH
75039: LD_INT 0
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: LD_INT 1
75052: NEG
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 2
75060: NEG
75061: PUSH
75062: LD_INT 2
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75091: LD_ADDR_VAR 0 58
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: LD_INT 0
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: LD_INT 0
75108: PUSH
75109: LD_INT 1
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 1
75119: PUSH
75120: LD_INT 0
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 1
75129: PUSH
75130: LD_INT 1
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 0
75139: PUSH
75140: LD_INT 1
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: LD_INT 1
75149: NEG
75150: PUSH
75151: LD_INT 0
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 1
75160: NEG
75161: PUSH
75162: LD_INT 1
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 2
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 2
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: LD_INT 1
75198: NEG
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 2
75206: PUSH
75207: LD_INT 0
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 2
75216: PUSH
75217: LD_INT 1
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: LD_INT 2
75226: PUSH
75227: LD_INT 2
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 1
75236: PUSH
75237: LD_INT 2
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 0
75246: PUSH
75247: LD_INT 2
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: NEG
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 2
75267: NEG
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: LD_INT 1
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 2
75290: NEG
75291: PUSH
75292: LD_INT 2
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: LIST
75309: LIST
75310: LIST
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75321: LD_ADDR_VAR 0 59
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: LD_INT 0
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: LD_INT 1
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 1
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 0
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 1
75379: NEG
75380: PUSH
75381: LD_INT 0
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: LD_INT 1
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75409: LD_ADDR_VAR 0 60
75413: PUSH
75414: LD_INT 0
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: LD_INT 1
75429: NEG
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: LD_INT 0
75440: PUSH
75441: EMPTY
75442: LIST
75443: LIST
75444: PUSH
75445: LD_INT 1
75447: PUSH
75448: LD_INT 1
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 0
75457: PUSH
75458: LD_INT 1
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 1
75467: NEG
75468: PUSH
75469: LD_INT 0
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: LD_INT 1
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75497: LD_ADDR_VAR 0 61
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: LD_INT 0
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 0
75514: PUSH
75515: LD_INT 1
75517: NEG
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 1
75525: PUSH
75526: LD_INT 0
75528: PUSH
75529: EMPTY
75530: LIST
75531: LIST
75532: PUSH
75533: LD_INT 1
75535: PUSH
75536: LD_INT 1
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: LD_INT 1
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 1
75555: NEG
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: LD_INT 1
75570: NEG
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75585: LD_ADDR_VAR 0 62
75589: PUSH
75590: LD_INT 0
75592: PUSH
75593: LD_INT 0
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 1
75605: NEG
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: LD_INT 1
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: LD_INT 1
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: LD_INT 0
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 1
75654: NEG
75655: PUSH
75656: LD_INT 1
75658: NEG
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75673: LD_ADDR_VAR 0 63
75677: PUSH
75678: LD_INT 0
75680: PUSH
75681: LD_INT 0
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 0
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: LD_INT 1
75701: PUSH
75702: LD_INT 0
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 1
75711: PUSH
75712: LD_INT 1
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 0
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 1
75731: NEG
75732: PUSH
75733: LD_INT 0
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: LD_INT 1
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75761: LD_ADDR_VAR 0 64
75765: PUSH
75766: LD_INT 0
75768: PUSH
75769: LD_INT 0
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: LD_INT 1
75781: NEG
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 1
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: LD_INT 1
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: LD_INT 0
75809: PUSH
75810: LD_INT 1
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 1
75819: NEG
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: ST_TO_ADDR
// end ; 1 :
75849: GO 81746
75851: LD_INT 1
75853: DOUBLE
75854: EQUAL
75855: IFTRUE 75859
75857: GO 78482
75859: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75860: LD_ADDR_VAR 0 11
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: LD_INT 3
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 0
75879: PUSH
75880: LD_INT 3
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 2
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: LIST
75903: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75904: LD_ADDR_VAR 0 12
75908: PUSH
75909: LD_INT 2
75911: PUSH
75912: LD_INT 1
75914: NEG
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 3
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 3
75932: PUSH
75933: LD_INT 1
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: LIST
75944: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75945: LD_ADDR_VAR 0 13
75949: PUSH
75950: LD_INT 3
75952: PUSH
75953: LD_INT 2
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 3
75962: PUSH
75963: LD_INT 3
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 2
75972: PUSH
75973: LD_INT 3
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: LIST
75984: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75985: LD_ADDR_VAR 0 14
75989: PUSH
75990: LD_INT 1
75992: PUSH
75993: LD_INT 3
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: LD_INT 3
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: LD_INT 2
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: LIST
76025: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76026: LD_ADDR_VAR 0 15
76030: PUSH
76031: LD_INT 2
76033: NEG
76034: PUSH
76035: LD_INT 1
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 3
76044: NEG
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 3
76055: NEG
76056: PUSH
76057: LD_INT 1
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: LIST
76069: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76070: LD_ADDR_VAR 0 16
76074: PUSH
76075: LD_INT 2
76077: NEG
76078: PUSH
76079: LD_INT 3
76081: NEG
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 3
76089: NEG
76090: PUSH
76091: LD_INT 2
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 3
76101: NEG
76102: PUSH
76103: LD_INT 3
76105: NEG
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: LIST
76115: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76116: LD_ADDR_VAR 0 17
76120: PUSH
76121: LD_INT 1
76123: NEG
76124: PUSH
76125: LD_INT 3
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 0
76135: PUSH
76136: LD_INT 3
76138: NEG
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: PUSH
76147: LD_INT 2
76149: NEG
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: LIST
76159: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76160: LD_ADDR_VAR 0 18
76164: PUSH
76165: LD_INT 2
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 3
76178: PUSH
76179: LD_INT 0
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 3
76188: PUSH
76189: LD_INT 1
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: LIST
76200: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76201: LD_ADDR_VAR 0 19
76205: PUSH
76206: LD_INT 3
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 3
76218: PUSH
76219: LD_INT 3
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 2
76228: PUSH
76229: LD_INT 3
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: LIST
76240: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76241: LD_ADDR_VAR 0 20
76245: PUSH
76246: LD_INT 1
76248: PUSH
76249: LD_INT 3
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 0
76258: PUSH
76259: LD_INT 3
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 1
76268: NEG
76269: PUSH
76270: LD_INT 2
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: EMPTY
76278: LIST
76279: LIST
76280: LIST
76281: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76282: LD_ADDR_VAR 0 21
76286: PUSH
76287: LD_INT 2
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 3
76300: NEG
76301: PUSH
76302: LD_INT 0
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 3
76311: NEG
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: LIST
76325: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76326: LD_ADDR_VAR 0 22
76330: PUSH
76331: LD_INT 2
76333: NEG
76334: PUSH
76335: LD_INT 3
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 3
76345: NEG
76346: PUSH
76347: LD_INT 2
76349: NEG
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 3
76357: NEG
76358: PUSH
76359: LD_INT 3
76361: NEG
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: LIST
76371: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76372: LD_ADDR_VAR 0 23
76376: PUSH
76377: LD_INT 0
76379: PUSH
76380: LD_INT 3
76382: NEG
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 1
76390: NEG
76391: PUSH
76392: LD_INT 4
76394: NEG
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 1
76402: PUSH
76403: LD_INT 3
76405: NEG
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: LIST
76415: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76416: LD_ADDR_VAR 0 24
76420: PUSH
76421: LD_INT 3
76423: PUSH
76424: LD_INT 0
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 3
76433: PUSH
76434: LD_INT 1
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 4
76444: PUSH
76445: LD_INT 1
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: LIST
76456: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76457: LD_ADDR_VAR 0 25
76461: PUSH
76462: LD_INT 3
76464: PUSH
76465: LD_INT 3
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 4
76474: PUSH
76475: LD_INT 3
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 3
76484: PUSH
76485: LD_INT 4
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: LIST
76496: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76497: LD_ADDR_VAR 0 26
76501: PUSH
76502: LD_INT 0
76504: PUSH
76505: LD_INT 3
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 1
76514: PUSH
76515: LD_INT 4
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 1
76524: NEG
76525: PUSH
76526: LD_INT 3
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: LIST
76537: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76538: LD_ADDR_VAR 0 27
76542: PUSH
76543: LD_INT 3
76545: NEG
76546: PUSH
76547: LD_INT 0
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 3
76556: NEG
76557: PUSH
76558: LD_INT 1
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 4
76567: NEG
76568: PUSH
76569: LD_INT 1
76571: NEG
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: LIST
76581: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76582: LD_ADDR_VAR 0 28
76586: PUSH
76587: LD_INT 3
76589: NEG
76590: PUSH
76591: LD_INT 3
76593: NEG
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 3
76601: NEG
76602: PUSH
76603: LD_INT 4
76605: NEG
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PUSH
76611: LD_INT 4
76613: NEG
76614: PUSH
76615: LD_INT 3
76617: NEG
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: LIST
76627: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76628: LD_ADDR_VAR 0 29
76632: PUSH
76633: LD_INT 1
76635: NEG
76636: PUSH
76637: LD_INT 3
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: LD_INT 3
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 1
76658: PUSH
76659: LD_INT 2
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: LD_INT 4
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 0
76681: PUSH
76682: LD_INT 4
76684: NEG
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 1
76692: PUSH
76693: LD_INT 3
76695: NEG
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 1
76703: NEG
76704: PUSH
76705: LD_INT 5
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 0
76715: PUSH
76716: LD_INT 5
76718: NEG
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 1
76726: PUSH
76727: LD_INT 4
76729: NEG
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 1
76737: NEG
76738: PUSH
76739: LD_INT 6
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 0
76749: PUSH
76750: LD_INT 6
76752: NEG
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 1
76760: PUSH
76761: LD_INT 5
76763: NEG
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: LIST
76779: LIST
76780: LIST
76781: LIST
76782: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76783: LD_ADDR_VAR 0 30
76787: PUSH
76788: LD_INT 2
76790: PUSH
76791: LD_INT 1
76793: NEG
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 3
76801: PUSH
76802: LD_INT 0
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 3
76811: PUSH
76812: LD_INT 1
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 3
76821: PUSH
76822: LD_INT 1
76824: NEG
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 4
76832: PUSH
76833: LD_INT 0
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 4
76842: PUSH
76843: LD_INT 1
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 4
76852: PUSH
76853: LD_INT 1
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 5
76863: PUSH
76864: LD_INT 0
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: PUSH
76871: LD_INT 5
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 5
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 6
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 6
76904: PUSH
76905: LD_INT 1
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76926: LD_ADDR_VAR 0 31
76930: PUSH
76931: LD_INT 3
76933: PUSH
76934: LD_INT 2
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 3
76943: PUSH
76944: LD_INT 3
76946: PUSH
76947: EMPTY
76948: LIST
76949: LIST
76950: PUSH
76951: LD_INT 2
76953: PUSH
76954: LD_INT 3
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 4
76963: PUSH
76964: LD_INT 3
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 4
76973: PUSH
76974: LD_INT 4
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 3
76983: PUSH
76984: LD_INT 4
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 5
76993: PUSH
76994: LD_INT 4
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 5
77003: PUSH
77004: LD_INT 5
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 4
77013: PUSH
77014: LD_INT 5
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 6
77023: PUSH
77024: LD_INT 5
77026: PUSH
77027: EMPTY
77028: LIST
77029: LIST
77030: PUSH
77031: LD_INT 6
77033: PUSH
77034: LD_INT 6
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 5
77043: PUSH
77044: LD_INT 6
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77065: LD_ADDR_VAR 0 32
77069: PUSH
77070: LD_INT 1
77072: PUSH
77073: LD_INT 3
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 0
77082: PUSH
77083: LD_INT 3
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 1
77092: NEG
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 1
77103: PUSH
77104: LD_INT 4
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 0
77113: PUSH
77114: LD_INT 4
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PUSH
77121: LD_INT 1
77123: NEG
77124: PUSH
77125: LD_INT 3
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 1
77134: PUSH
77135: LD_INT 5
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 0
77144: PUSH
77145: LD_INT 5
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: LD_INT 1
77154: NEG
77155: PUSH
77156: LD_INT 4
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 1
77165: PUSH
77166: LD_INT 6
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: LD_INT 6
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 1
77185: NEG
77186: PUSH
77187: LD_INT 5
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77208: LD_ADDR_VAR 0 33
77212: PUSH
77213: LD_INT 2
77215: NEG
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 3
77226: NEG
77227: PUSH
77228: LD_INT 0
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 3
77237: NEG
77238: PUSH
77239: LD_INT 1
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 3
77249: NEG
77250: PUSH
77251: LD_INT 1
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 4
77260: NEG
77261: PUSH
77262: LD_INT 0
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 4
77271: NEG
77272: PUSH
77273: LD_INT 1
77275: NEG
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 4
77283: NEG
77284: PUSH
77285: LD_INT 1
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 5
77294: NEG
77295: PUSH
77296: LD_INT 0
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 5
77305: NEG
77306: PUSH
77307: LD_INT 1
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 5
77317: NEG
77318: PUSH
77319: LD_INT 1
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 6
77328: NEG
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 6
77339: NEG
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77363: LD_ADDR_VAR 0 34
77367: PUSH
77368: LD_INT 2
77370: NEG
77371: PUSH
77372: LD_INT 3
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 3
77382: NEG
77383: PUSH
77384: LD_INT 2
77386: NEG
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: PUSH
77392: LD_INT 3
77394: NEG
77395: PUSH
77396: LD_INT 3
77398: NEG
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 3
77406: NEG
77407: PUSH
77408: LD_INT 4
77410: NEG
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 4
77418: NEG
77419: PUSH
77420: LD_INT 3
77422: NEG
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 4
77430: NEG
77431: PUSH
77432: LD_INT 4
77434: NEG
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 4
77442: NEG
77443: PUSH
77444: LD_INT 5
77446: NEG
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 5
77454: NEG
77455: PUSH
77456: LD_INT 4
77458: NEG
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 5
77466: NEG
77467: PUSH
77468: LD_INT 5
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 5
77478: NEG
77479: PUSH
77480: LD_INT 6
77482: NEG
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 6
77490: NEG
77491: PUSH
77492: LD_INT 5
77494: NEG
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 6
77502: NEG
77503: PUSH
77504: LD_INT 6
77506: NEG
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: LIST
77523: LIST
77524: LIST
77525: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77526: LD_ADDR_VAR 0 41
77530: PUSH
77531: LD_INT 0
77533: PUSH
77534: LD_INT 2
77536: NEG
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 1
77544: NEG
77545: PUSH
77546: LD_INT 3
77548: NEG
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 1
77556: PUSH
77557: LD_INT 2
77559: NEG
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: LIST
77569: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77570: LD_ADDR_VAR 0 42
77574: PUSH
77575: LD_INT 2
77577: PUSH
77578: LD_INT 0
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 2
77587: PUSH
77588: LD_INT 1
77590: NEG
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: PUSH
77596: LD_INT 3
77598: PUSH
77599: LD_INT 1
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: LIST
77610: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77611: LD_ADDR_VAR 0 43
77615: PUSH
77616: LD_INT 2
77618: PUSH
77619: LD_INT 2
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 3
77628: PUSH
77629: LD_INT 2
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 3
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: LIST
77650: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77651: LD_ADDR_VAR 0 44
77655: PUSH
77656: LD_INT 0
77658: PUSH
77659: LD_INT 2
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 1
77668: PUSH
77669: LD_INT 3
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 1
77678: NEG
77679: PUSH
77680: LD_INT 2
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: LIST
77691: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77692: LD_ADDR_VAR 0 45
77696: PUSH
77697: LD_INT 2
77699: NEG
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 2
77710: NEG
77711: PUSH
77712: LD_INT 1
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: PUSH
77719: LD_INT 3
77721: NEG
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: LIST
77735: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77736: LD_ADDR_VAR 0 46
77740: PUSH
77741: LD_INT 2
77743: NEG
77744: PUSH
77745: LD_INT 2
77747: NEG
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 2
77755: NEG
77756: PUSH
77757: LD_INT 3
77759: NEG
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 3
77767: NEG
77768: PUSH
77769: LD_INT 2
77771: NEG
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: LIST
77781: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77782: LD_ADDR_VAR 0 47
77786: PUSH
77787: LD_INT 2
77789: NEG
77790: PUSH
77791: LD_INT 3
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 1
77801: NEG
77802: PUSH
77803: LD_INT 3
77805: NEG
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77815: LD_ADDR_VAR 0 48
77819: PUSH
77820: LD_INT 1
77822: PUSH
77823: LD_INT 2
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 2
77833: PUSH
77834: LD_INT 1
77836: NEG
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77846: LD_ADDR_VAR 0 49
77850: PUSH
77851: LD_INT 3
77853: PUSH
77854: LD_INT 1
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: LD_INT 2
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77875: LD_ADDR_VAR 0 50
77879: PUSH
77880: LD_INT 2
77882: PUSH
77883: LD_INT 3
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: PUSH
77893: LD_INT 3
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77904: LD_ADDR_VAR 0 51
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: LD_INT 2
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 2
77922: NEG
77923: PUSH
77924: LD_INT 1
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77935: LD_ADDR_VAR 0 52
77939: PUSH
77940: LD_INT 3
77942: NEG
77943: PUSH
77944: LD_INT 1
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 3
77954: NEG
77955: PUSH
77956: LD_INT 2
77958: NEG
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77968: LD_ADDR_VAR 0 53
77972: PUSH
77973: LD_INT 1
77975: NEG
77976: PUSH
77977: LD_INT 3
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: LD_INT 3
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: LD_INT 2
78001: NEG
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: LIST
78011: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78012: LD_ADDR_VAR 0 54
78016: PUSH
78017: LD_INT 2
78019: PUSH
78020: LD_INT 1
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 3
78030: PUSH
78031: LD_INT 0
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 3
78040: PUSH
78041: LD_INT 1
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: LIST
78052: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78053: LD_ADDR_VAR 0 55
78057: PUSH
78058: LD_INT 3
78060: PUSH
78061: LD_INT 2
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: PUSH
78071: LD_INT 3
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 2
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: LIST
78092: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78093: LD_ADDR_VAR 0 56
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: LD_INT 3
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: LD_INT 3
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 1
78120: NEG
78121: PUSH
78122: LD_INT 2
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: LIST
78133: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78134: LD_ADDR_VAR 0 57
78138: PUSH
78139: LD_INT 2
78141: NEG
78142: PUSH
78143: LD_INT 1
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 3
78152: NEG
78153: PUSH
78154: LD_INT 0
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 3
78163: NEG
78164: PUSH
78165: LD_INT 1
78167: NEG
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: LIST
78177: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78178: LD_ADDR_VAR 0 58
78182: PUSH
78183: LD_INT 2
78185: NEG
78186: PUSH
78187: LD_INT 3
78189: NEG
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 3
78197: NEG
78198: PUSH
78199: LD_INT 2
78201: NEG
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 3
78209: NEG
78210: PUSH
78211: LD_INT 3
78213: NEG
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: LIST
78223: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78224: LD_ADDR_VAR 0 59
78228: PUSH
78229: LD_INT 1
78231: NEG
78232: PUSH
78233: LD_INT 2
78235: NEG
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 0
78243: PUSH
78244: LD_INT 2
78246: NEG
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: LD_INT 1
78254: PUSH
78255: LD_INT 1
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: LIST
78267: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78268: LD_ADDR_VAR 0 60
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: LD_INT 1
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 2
78286: PUSH
78287: LD_INT 0
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 2
78296: PUSH
78297: LD_INT 1
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: LIST
78308: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78309: LD_ADDR_VAR 0 61
78313: PUSH
78314: LD_INT 2
78316: PUSH
78317: LD_INT 1
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 2
78326: PUSH
78327: LD_INT 2
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 1
78336: PUSH
78337: LD_INT 2
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: LIST
78348: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78349: LD_ADDR_VAR 0 62
78353: PUSH
78354: LD_INT 1
78356: PUSH
78357: LD_INT 2
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: LD_INT 2
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: LIST
78389: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78390: LD_ADDR_VAR 0 63
78394: PUSH
78395: LD_INT 1
78397: NEG
78398: PUSH
78399: LD_INT 1
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 2
78408: NEG
78409: PUSH
78410: LD_INT 0
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: PUSH
78417: LD_INT 2
78419: NEG
78420: PUSH
78421: LD_INT 1
78423: NEG
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: LIST
78433: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78434: LD_ADDR_VAR 0 64
78438: PUSH
78439: LD_INT 1
78441: NEG
78442: PUSH
78443: LD_INT 2
78445: NEG
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 2
78453: NEG
78454: PUSH
78455: LD_INT 1
78457: NEG
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: LD_INT 2
78465: NEG
78466: PUSH
78467: LD_INT 2
78469: NEG
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: LIST
78479: ST_TO_ADDR
// end ; 2 :
78480: GO 81746
78482: LD_INT 2
78484: DOUBLE
78485: EQUAL
78486: IFTRUE 78490
78488: GO 81745
78490: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78491: LD_ADDR_VAR 0 29
78495: PUSH
78496: LD_INT 4
78498: PUSH
78499: LD_INT 0
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 4
78508: PUSH
78509: LD_INT 1
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 5
78519: PUSH
78520: LD_INT 0
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 5
78529: PUSH
78530: LD_INT 1
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 4
78539: PUSH
78540: LD_INT 1
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 3
78549: PUSH
78550: LD_INT 0
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 3
78559: PUSH
78560: LD_INT 1
78562: NEG
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 3
78570: PUSH
78571: LD_INT 2
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 5
78581: PUSH
78582: LD_INT 2
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 3
78591: PUSH
78592: LD_INT 3
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 3
78601: PUSH
78602: LD_INT 2
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 4
78611: PUSH
78612: LD_INT 3
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 4
78621: PUSH
78622: LD_INT 4
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 3
78631: PUSH
78632: LD_INT 4
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 2
78641: PUSH
78642: LD_INT 3
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 2
78651: PUSH
78652: LD_INT 2
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 4
78661: PUSH
78662: LD_INT 2
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 2
78671: PUSH
78672: LD_INT 4
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: LD_INT 4
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 0
78691: PUSH
78692: LD_INT 3
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 1
78701: PUSH
78702: LD_INT 4
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: LD_INT 5
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: LD_INT 5
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: LD_INT 4
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 1
78742: NEG
78743: PUSH
78744: LD_INT 3
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 2
78753: PUSH
78754: LD_INT 5
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 2
78763: NEG
78764: PUSH
78765: LD_INT 3
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 3
78785: NEG
78786: PUSH
78787: LD_INT 1
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 2
78797: NEG
78798: PUSH
78799: LD_INT 0
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 2
78808: NEG
78809: PUSH
78810: LD_INT 1
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 3
78819: NEG
78820: PUSH
78821: LD_INT 1
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 4
78830: NEG
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 4
78841: NEG
78842: PUSH
78843: LD_INT 1
78845: NEG
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 4
78853: NEG
78854: PUSH
78855: LD_INT 2
78857: NEG
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 2
78865: NEG
78866: PUSH
78867: LD_INT 2
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 4
78876: NEG
78877: PUSH
78878: LD_INT 4
78880: NEG
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 4
78888: NEG
78889: PUSH
78890: LD_INT 5
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 3
78900: NEG
78901: PUSH
78902: LD_INT 4
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: LD_INT 3
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 4
78924: NEG
78925: PUSH
78926: LD_INT 3
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 5
78936: NEG
78937: PUSH
78938: LD_INT 4
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 5
78948: NEG
78949: PUSH
78950: LD_INT 5
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 3
78960: NEG
78961: PUSH
78962: LD_INT 5
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 5
78972: NEG
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79029: LD_ADDR_VAR 0 30
79033: PUSH
79034: LD_INT 4
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 4
79046: PUSH
79047: LD_INT 3
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 5
79056: PUSH
79057: LD_INT 4
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 5
79066: PUSH
79067: LD_INT 5
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 4
79076: PUSH
79077: LD_INT 5
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 3
79086: PUSH
79087: LD_INT 4
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 3
79096: PUSH
79097: LD_INT 3
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 5
79106: PUSH
79107: LD_INT 3
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 3
79116: PUSH
79117: LD_INT 5
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: LD_INT 3
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: LD_INT 0
79136: PUSH
79137: LD_INT 2
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 1
79146: PUSH
79147: LD_INT 3
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 1
79156: PUSH
79157: LD_INT 4
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: LD_INT 4
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 1
79176: NEG
79177: PUSH
79178: LD_INT 3
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 1
79187: NEG
79188: PUSH
79189: LD_INT 2
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 2
79198: PUSH
79199: LD_INT 4
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 2
79208: NEG
79209: PUSH
79210: LD_INT 2
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 4
79219: NEG
79220: PUSH
79221: LD_INT 0
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: LD_INT 4
79230: NEG
79231: PUSH
79232: LD_INT 1
79234: NEG
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 3
79242: NEG
79243: PUSH
79244: LD_INT 0
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 3
79253: NEG
79254: PUSH
79255: LD_INT 1
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 4
79264: NEG
79265: PUSH
79266: LD_INT 1
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 5
79275: NEG
79276: PUSH
79277: LD_INT 0
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 5
79286: NEG
79287: PUSH
79288: LD_INT 1
79290: NEG
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 5
79298: NEG
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 3
79310: NEG
79311: PUSH
79312: LD_INT 2
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 3
79321: NEG
79322: PUSH
79323: LD_INT 3
79325: NEG
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 3
79333: NEG
79334: PUSH
79335: LD_INT 4
79337: NEG
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 2
79345: NEG
79346: PUSH
79347: LD_INT 3
79349: NEG
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 2
79357: NEG
79358: PUSH
79359: LD_INT 2
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 3
79369: NEG
79370: PUSH
79371: LD_INT 2
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 4
79381: NEG
79382: PUSH
79383: LD_INT 3
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 4
79393: NEG
79394: PUSH
79395: LD_INT 4
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 2
79405: NEG
79406: PUSH
79407: LD_INT 4
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 4
79417: NEG
79418: PUSH
79419: LD_INT 2
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 0
79429: PUSH
79430: LD_INT 4
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 5
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 1
79451: PUSH
79452: LD_INT 4
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: LD_INT 3
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 0
79473: PUSH
79474: LD_INT 3
79476: NEG
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: LD_INT 1
79484: NEG
79485: PUSH
79486: LD_INT 4
79488: NEG
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: LD_INT 5
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 2
79508: PUSH
79509: LD_INT 3
79511: NEG
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 2
79519: NEG
79520: PUSH
79521: LD_INT 5
79523: NEG
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79576: LD_ADDR_VAR 0 31
79580: PUSH
79581: LD_INT 0
79583: PUSH
79584: LD_INT 4
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 0
79593: PUSH
79594: LD_INT 3
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 1
79603: PUSH
79604: LD_INT 4
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 1
79613: PUSH
79614: LD_INT 5
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: LD_INT 5
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 1
79633: NEG
79634: PUSH
79635: LD_INT 4
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: LD_INT 3
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 2
79655: PUSH
79656: LD_INT 5
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 2
79665: NEG
79666: PUSH
79667: LD_INT 3
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 3
79676: NEG
79677: PUSH
79678: LD_INT 0
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 3
79687: NEG
79688: PUSH
79689: LD_INT 1
79691: NEG
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 2
79699: NEG
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 2
79710: NEG
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 3
79721: NEG
79722: PUSH
79723: LD_INT 1
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 4
79732: NEG
79733: PUSH
79734: LD_INT 0
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 4
79743: NEG
79744: PUSH
79745: LD_INT 1
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 4
79755: NEG
79756: PUSH
79757: LD_INT 2
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 2
79767: NEG
79768: PUSH
79769: LD_INT 2
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 4
79778: NEG
79779: PUSH
79780: LD_INT 4
79782: NEG
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 4
79790: NEG
79791: PUSH
79792: LD_INT 5
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 3
79802: NEG
79803: PUSH
79804: LD_INT 4
79806: NEG
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 3
79814: NEG
79815: PUSH
79816: LD_INT 3
79818: NEG
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 4
79826: NEG
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 5
79838: NEG
79839: PUSH
79840: LD_INT 4
79842: NEG
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 5
79850: NEG
79851: PUSH
79852: LD_INT 5
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 3
79862: NEG
79863: PUSH
79864: LD_INT 5
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 5
79874: NEG
79875: PUSH
79876: LD_INT 3
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 0
79886: PUSH
79887: LD_INT 3
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 0
79897: PUSH
79898: LD_INT 4
79900: NEG
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: LD_INT 3
79911: NEG
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 1
79919: PUSH
79920: LD_INT 2
79922: NEG
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 0
79930: PUSH
79931: LD_INT 2
79933: NEG
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: LD_INT 3
79945: NEG
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 1
79953: NEG
79954: PUSH
79955: LD_INT 4
79957: NEG
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 2
79965: PUSH
79966: LD_INT 2
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 2
79976: NEG
79977: PUSH
79978: LD_INT 4
79980: NEG
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 4
79988: PUSH
79989: LD_INT 0
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 4
79998: PUSH
79999: LD_INT 1
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 5
80009: PUSH
80010: LD_INT 0
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 5
80019: PUSH
80020: LD_INT 1
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 4
80029: PUSH
80030: LD_INT 1
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 3
80049: PUSH
80050: LD_INT 1
80052: NEG
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 3
80060: PUSH
80061: LD_INT 2
80063: NEG
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 5
80071: PUSH
80072: LD_INT 2
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80126: LD_ADDR_VAR 0 32
80130: PUSH
80131: LD_INT 4
80133: NEG
80134: PUSH
80135: LD_INT 0
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 4
80144: NEG
80145: PUSH
80146: LD_INT 1
80148: NEG
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 3
80156: NEG
80157: PUSH
80158: LD_INT 0
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 3
80167: NEG
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 4
80178: NEG
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 5
80189: NEG
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 5
80200: NEG
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 5
80212: NEG
80213: PUSH
80214: LD_INT 2
80216: NEG
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 3
80224: NEG
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 3
80235: NEG
80236: PUSH
80237: LD_INT 3
80239: NEG
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 3
80247: NEG
80248: PUSH
80249: LD_INT 4
80251: NEG
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_INT 2
80259: NEG
80260: PUSH
80261: LD_INT 3
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 2
80271: NEG
80272: PUSH
80273: LD_INT 2
80275: NEG
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 3
80283: NEG
80284: PUSH
80285: LD_INT 2
80287: NEG
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 4
80295: NEG
80296: PUSH
80297: LD_INT 3
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 4
80307: NEG
80308: PUSH
80309: LD_INT 4
80311: NEG
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 2
80319: NEG
80320: PUSH
80321: LD_INT 4
80323: NEG
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 4
80331: NEG
80332: PUSH
80333: LD_INT 2
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: LD_INT 4
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 0
80354: PUSH
80355: LD_INT 5
80357: NEG
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 1
80365: PUSH
80366: LD_INT 4
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 1
80376: PUSH
80377: LD_INT 3
80379: NEG
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 0
80387: PUSH
80388: LD_INT 3
80390: NEG
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 1
80398: NEG
80399: PUSH
80400: LD_INT 4
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: LD_INT 5
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: PUSH
80423: LD_INT 3
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 2
80433: NEG
80434: PUSH
80435: LD_INT 5
80437: NEG
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 3
80445: PUSH
80446: LD_INT 0
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: LD_INT 1
80458: NEG
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: PUSH
80464: LD_INT 4
80466: PUSH
80467: LD_INT 0
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 4
80476: PUSH
80477: LD_INT 1
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 3
80486: PUSH
80487: LD_INT 1
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 2
80496: PUSH
80497: LD_INT 0
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: PUSH
80507: LD_INT 1
80509: NEG
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 2
80517: PUSH
80518: LD_INT 2
80520: NEG
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 4
80528: PUSH
80529: LD_INT 2
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 4
80538: PUSH
80539: LD_INT 4
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 4
80548: PUSH
80549: LD_INT 3
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 5
80558: PUSH
80559: LD_INT 4
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 5
80568: PUSH
80569: LD_INT 5
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 4
80578: PUSH
80579: LD_INT 5
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 3
80588: PUSH
80589: LD_INT 4
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 3
80598: PUSH
80599: LD_INT 3
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 5
80608: PUSH
80609: LD_INT 3
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 3
80618: PUSH
80619: LD_INT 5
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80673: LD_ADDR_VAR 0 33
80677: PUSH
80678: LD_INT 4
80680: NEG
80681: PUSH
80682: LD_INT 4
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 4
80692: NEG
80693: PUSH
80694: LD_INT 5
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 3
80704: NEG
80705: PUSH
80706: LD_INT 4
80708: NEG
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 3
80716: NEG
80717: PUSH
80718: LD_INT 3
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 4
80728: NEG
80729: PUSH
80730: LD_INT 3
80732: NEG
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 5
80740: NEG
80741: PUSH
80742: LD_INT 4
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 5
80752: NEG
80753: PUSH
80754: LD_INT 5
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 3
80764: NEG
80765: PUSH
80766: LD_INT 5
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 5
80776: NEG
80777: PUSH
80778: LD_INT 3
80780: NEG
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 0
80788: PUSH
80789: LD_INT 3
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 0
80799: PUSH
80800: LD_INT 4
80802: NEG
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: LD_INT 3
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: LD_INT 2
80824: NEG
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: LD_INT 2
80835: NEG
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_INT 1
80843: NEG
80844: PUSH
80845: LD_INT 3
80847: NEG
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: LD_INT 4
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 2
80867: PUSH
80868: LD_INT 2
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 2
80878: NEG
80879: PUSH
80880: LD_INT 4
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 4
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 4
80900: PUSH
80901: LD_INT 1
80903: NEG
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 5
80911: PUSH
80912: LD_INT 0
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 5
80921: PUSH
80922: LD_INT 1
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 4
80931: PUSH
80932: LD_INT 1
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 3
80941: PUSH
80942: LD_INT 0
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 3
80951: PUSH
80952: LD_INT 1
80954: NEG
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 3
80962: PUSH
80963: LD_INT 2
80965: NEG
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 5
80973: PUSH
80974: LD_INT 2
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 3
80983: PUSH
80984: LD_INT 3
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 3
80993: PUSH
80994: LD_INT 2
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PUSH
81001: LD_INT 4
81003: PUSH
81004: LD_INT 3
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 4
81013: PUSH
81014: LD_INT 4
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 3
81023: PUSH
81024: LD_INT 4
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 2
81033: PUSH
81034: LD_INT 3
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 2
81043: PUSH
81044: LD_INT 2
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 4
81053: PUSH
81054: LD_INT 2
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: LD_INT 4
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 0
81073: PUSH
81074: LD_INT 4
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: LD_INT 3
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: LD_INT 4
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 1
81103: PUSH
81104: LD_INT 5
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 0
81113: PUSH
81114: LD_INT 5
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 1
81123: NEG
81124: PUSH
81125: LD_INT 4
81127: PUSH
81128: EMPTY
81129: LIST
81130: LIST
81131: PUSH
81132: LD_INT 1
81134: NEG
81135: PUSH
81136: LD_INT 3
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 2
81145: PUSH
81146: LD_INT 5
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: LD_INT 3
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: LIST
81208: LIST
81209: LIST
81210: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81211: LD_ADDR_VAR 0 34
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: LD_INT 4
81221: NEG
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 0
81229: PUSH
81230: LD_INT 5
81232: NEG
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 1
81240: PUSH
81241: LD_INT 4
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 1
81251: PUSH
81252: LD_INT 3
81254: NEG
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 0
81262: PUSH
81263: LD_INT 3
81265: NEG
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: LD_INT 4
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 1
81285: NEG
81286: PUSH
81287: LD_INT 5
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 2
81297: PUSH
81298: LD_INT 3
81300: NEG
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: NEG
81309: PUSH
81310: LD_INT 5
81312: NEG
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 3
81320: PUSH
81321: LD_INT 0
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 3
81330: PUSH
81331: LD_INT 1
81333: NEG
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 4
81341: PUSH
81342: LD_INT 0
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 4
81351: PUSH
81352: LD_INT 1
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 3
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: EMPTY
81366: LIST
81367: LIST
81368: PUSH
81369: LD_INT 2
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 2
81392: PUSH
81393: LD_INT 2
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 4
81403: PUSH
81404: LD_INT 2
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 4
81413: PUSH
81414: LD_INT 4
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 4
81423: PUSH
81424: LD_INT 3
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 5
81433: PUSH
81434: LD_INT 4
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 5
81443: PUSH
81444: LD_INT 5
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 4
81453: PUSH
81454: LD_INT 5
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 3
81463: PUSH
81464: LD_INT 4
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 3
81473: PUSH
81474: LD_INT 3
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 5
81483: PUSH
81484: LD_INT 3
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 3
81493: PUSH
81494: LD_INT 5
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 0
81503: PUSH
81504: LD_INT 3
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 0
81513: PUSH
81514: LD_INT 2
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 1
81523: PUSH
81524: LD_INT 3
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 4
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 0
81543: PUSH
81544: LD_INT 4
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 1
81553: NEG
81554: PUSH
81555: LD_INT 3
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 1
81564: NEG
81565: PUSH
81566: LD_INT 2
81568: PUSH
81569: EMPTY
81570: LIST
81571: LIST
81572: PUSH
81573: LD_INT 2
81575: PUSH
81576: LD_INT 4
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 2
81585: NEG
81586: PUSH
81587: LD_INT 2
81589: PUSH
81590: EMPTY
81591: LIST
81592: LIST
81593: PUSH
81594: LD_INT 4
81596: NEG
81597: PUSH
81598: LD_INT 0
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PUSH
81605: LD_INT 4
81607: NEG
81608: PUSH
81609: LD_INT 1
81611: NEG
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 3
81619: NEG
81620: PUSH
81621: LD_INT 0
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 3
81630: NEG
81631: PUSH
81632: LD_INT 1
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 4
81641: NEG
81642: PUSH
81643: LD_INT 1
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 5
81652: NEG
81653: PUSH
81654: LD_INT 0
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 5
81663: NEG
81664: PUSH
81665: LD_INT 1
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 5
81675: NEG
81676: PUSH
81677: LD_INT 2
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 3
81687: NEG
81688: PUSH
81689: LD_INT 2
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: ST_TO_ADDR
// end ; end ;
81743: GO 81746
81745: POP
// case btype of b_depot , b_warehouse :
81746: LD_VAR 0 1
81750: PUSH
81751: LD_INT 0
81753: DOUBLE
81754: EQUAL
81755: IFTRUE 81765
81757: LD_INT 1
81759: DOUBLE
81760: EQUAL
81761: IFTRUE 81765
81763: GO 81966
81765: POP
// case nation of nation_american :
81766: LD_VAR 0 5
81770: PUSH
81771: LD_INT 1
81773: DOUBLE
81774: EQUAL
81775: IFTRUE 81779
81777: GO 81835
81779: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81780: LD_ADDR_VAR 0 9
81784: PUSH
81785: LD_VAR 0 11
81789: PUSH
81790: LD_VAR 0 12
81794: PUSH
81795: LD_VAR 0 13
81799: PUSH
81800: LD_VAR 0 14
81804: PUSH
81805: LD_VAR 0 15
81809: PUSH
81810: LD_VAR 0 16
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: PUSH
81823: LD_VAR 0 4
81827: PUSH
81828: LD_INT 1
81830: PLUS
81831: ARRAY
81832: ST_TO_ADDR
81833: GO 81964
81835: LD_INT 2
81837: DOUBLE
81838: EQUAL
81839: IFTRUE 81843
81841: GO 81899
81843: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81844: LD_ADDR_VAR 0 9
81848: PUSH
81849: LD_VAR 0 17
81853: PUSH
81854: LD_VAR 0 18
81858: PUSH
81859: LD_VAR 0 19
81863: PUSH
81864: LD_VAR 0 20
81868: PUSH
81869: LD_VAR 0 21
81873: PUSH
81874: LD_VAR 0 22
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: PUSH
81887: LD_VAR 0 4
81891: PUSH
81892: LD_INT 1
81894: PLUS
81895: ARRAY
81896: ST_TO_ADDR
81897: GO 81964
81899: LD_INT 3
81901: DOUBLE
81902: EQUAL
81903: IFTRUE 81907
81905: GO 81963
81907: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81908: LD_ADDR_VAR 0 9
81912: PUSH
81913: LD_VAR 0 23
81917: PUSH
81918: LD_VAR 0 24
81922: PUSH
81923: LD_VAR 0 25
81927: PUSH
81928: LD_VAR 0 26
81932: PUSH
81933: LD_VAR 0 27
81937: PUSH
81938: LD_VAR 0 28
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: PUSH
81951: LD_VAR 0 4
81955: PUSH
81956: LD_INT 1
81958: PLUS
81959: ARRAY
81960: ST_TO_ADDR
81961: GO 81964
81963: POP
81964: GO 82519
81966: LD_INT 2
81968: DOUBLE
81969: EQUAL
81970: IFTRUE 81980
81972: LD_INT 3
81974: DOUBLE
81975: EQUAL
81976: IFTRUE 81980
81978: GO 82036
81980: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81981: LD_ADDR_VAR 0 9
81985: PUSH
81986: LD_VAR 0 29
81990: PUSH
81991: LD_VAR 0 30
81995: PUSH
81996: LD_VAR 0 31
82000: PUSH
82001: LD_VAR 0 32
82005: PUSH
82006: LD_VAR 0 33
82010: PUSH
82011: LD_VAR 0 34
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: PUSH
82024: LD_VAR 0 4
82028: PUSH
82029: LD_INT 1
82031: PLUS
82032: ARRAY
82033: ST_TO_ADDR
82034: GO 82519
82036: LD_INT 16
82038: DOUBLE
82039: EQUAL
82040: IFTRUE 82098
82042: LD_INT 17
82044: DOUBLE
82045: EQUAL
82046: IFTRUE 82098
82048: LD_INT 18
82050: DOUBLE
82051: EQUAL
82052: IFTRUE 82098
82054: LD_INT 19
82056: DOUBLE
82057: EQUAL
82058: IFTRUE 82098
82060: LD_INT 22
82062: DOUBLE
82063: EQUAL
82064: IFTRUE 82098
82066: LD_INT 20
82068: DOUBLE
82069: EQUAL
82070: IFTRUE 82098
82072: LD_INT 21
82074: DOUBLE
82075: EQUAL
82076: IFTRUE 82098
82078: LD_INT 23
82080: DOUBLE
82081: EQUAL
82082: IFTRUE 82098
82084: LD_INT 24
82086: DOUBLE
82087: EQUAL
82088: IFTRUE 82098
82090: LD_INT 25
82092: DOUBLE
82093: EQUAL
82094: IFTRUE 82098
82096: GO 82154
82098: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82099: LD_ADDR_VAR 0 9
82103: PUSH
82104: LD_VAR 0 35
82108: PUSH
82109: LD_VAR 0 36
82113: PUSH
82114: LD_VAR 0 37
82118: PUSH
82119: LD_VAR 0 38
82123: PUSH
82124: LD_VAR 0 39
82128: PUSH
82129: LD_VAR 0 40
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: PUSH
82142: LD_VAR 0 4
82146: PUSH
82147: LD_INT 1
82149: PLUS
82150: ARRAY
82151: ST_TO_ADDR
82152: GO 82519
82154: LD_INT 6
82156: DOUBLE
82157: EQUAL
82158: IFTRUE 82210
82160: LD_INT 7
82162: DOUBLE
82163: EQUAL
82164: IFTRUE 82210
82166: LD_INT 8
82168: DOUBLE
82169: EQUAL
82170: IFTRUE 82210
82172: LD_INT 13
82174: DOUBLE
82175: EQUAL
82176: IFTRUE 82210
82178: LD_INT 12
82180: DOUBLE
82181: EQUAL
82182: IFTRUE 82210
82184: LD_INT 15
82186: DOUBLE
82187: EQUAL
82188: IFTRUE 82210
82190: LD_INT 11
82192: DOUBLE
82193: EQUAL
82194: IFTRUE 82210
82196: LD_INT 14
82198: DOUBLE
82199: EQUAL
82200: IFTRUE 82210
82202: LD_INT 10
82204: DOUBLE
82205: EQUAL
82206: IFTRUE 82210
82208: GO 82266
82210: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82211: LD_ADDR_VAR 0 9
82215: PUSH
82216: LD_VAR 0 41
82220: PUSH
82221: LD_VAR 0 42
82225: PUSH
82226: LD_VAR 0 43
82230: PUSH
82231: LD_VAR 0 44
82235: PUSH
82236: LD_VAR 0 45
82240: PUSH
82241: LD_VAR 0 46
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: PUSH
82254: LD_VAR 0 4
82258: PUSH
82259: LD_INT 1
82261: PLUS
82262: ARRAY
82263: ST_TO_ADDR
82264: GO 82519
82266: LD_INT 36
82268: DOUBLE
82269: EQUAL
82270: IFTRUE 82274
82272: GO 82330
82274: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82275: LD_ADDR_VAR 0 9
82279: PUSH
82280: LD_VAR 0 47
82284: PUSH
82285: LD_VAR 0 48
82289: PUSH
82290: LD_VAR 0 49
82294: PUSH
82295: LD_VAR 0 50
82299: PUSH
82300: LD_VAR 0 51
82304: PUSH
82305: LD_VAR 0 52
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: PUSH
82318: LD_VAR 0 4
82322: PUSH
82323: LD_INT 1
82325: PLUS
82326: ARRAY
82327: ST_TO_ADDR
82328: GO 82519
82330: LD_INT 4
82332: DOUBLE
82333: EQUAL
82334: IFTRUE 82356
82336: LD_INT 5
82338: DOUBLE
82339: EQUAL
82340: IFTRUE 82356
82342: LD_INT 34
82344: DOUBLE
82345: EQUAL
82346: IFTRUE 82356
82348: LD_INT 37
82350: DOUBLE
82351: EQUAL
82352: IFTRUE 82356
82354: GO 82412
82356: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82357: LD_ADDR_VAR 0 9
82361: PUSH
82362: LD_VAR 0 53
82366: PUSH
82367: LD_VAR 0 54
82371: PUSH
82372: LD_VAR 0 55
82376: PUSH
82377: LD_VAR 0 56
82381: PUSH
82382: LD_VAR 0 57
82386: PUSH
82387: LD_VAR 0 58
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: PUSH
82400: LD_VAR 0 4
82404: PUSH
82405: LD_INT 1
82407: PLUS
82408: ARRAY
82409: ST_TO_ADDR
82410: GO 82519
82412: LD_INT 31
82414: DOUBLE
82415: EQUAL
82416: IFTRUE 82462
82418: LD_INT 32
82420: DOUBLE
82421: EQUAL
82422: IFTRUE 82462
82424: LD_INT 33
82426: DOUBLE
82427: EQUAL
82428: IFTRUE 82462
82430: LD_INT 27
82432: DOUBLE
82433: EQUAL
82434: IFTRUE 82462
82436: LD_INT 26
82438: DOUBLE
82439: EQUAL
82440: IFTRUE 82462
82442: LD_INT 28
82444: DOUBLE
82445: EQUAL
82446: IFTRUE 82462
82448: LD_INT 29
82450: DOUBLE
82451: EQUAL
82452: IFTRUE 82462
82454: LD_INT 30
82456: DOUBLE
82457: EQUAL
82458: IFTRUE 82462
82460: GO 82518
82462: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82463: LD_ADDR_VAR 0 9
82467: PUSH
82468: LD_VAR 0 59
82472: PUSH
82473: LD_VAR 0 60
82477: PUSH
82478: LD_VAR 0 61
82482: PUSH
82483: LD_VAR 0 62
82487: PUSH
82488: LD_VAR 0 63
82492: PUSH
82493: LD_VAR 0 64
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: PUSH
82506: LD_VAR 0 4
82510: PUSH
82511: LD_INT 1
82513: PLUS
82514: ARRAY
82515: ST_TO_ADDR
82516: GO 82519
82518: POP
// temp_list2 = [ ] ;
82519: LD_ADDR_VAR 0 10
82523: PUSH
82524: EMPTY
82525: ST_TO_ADDR
// for i in temp_list do
82526: LD_ADDR_VAR 0 8
82530: PUSH
82531: LD_VAR 0 9
82535: PUSH
82536: FOR_IN
82537: IFFALSE 82589
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82539: LD_ADDR_VAR 0 10
82543: PUSH
82544: LD_VAR 0 10
82548: PUSH
82549: LD_VAR 0 8
82553: PUSH
82554: LD_INT 1
82556: ARRAY
82557: PUSH
82558: LD_VAR 0 2
82562: PLUS
82563: PUSH
82564: LD_VAR 0 8
82568: PUSH
82569: LD_INT 2
82571: ARRAY
82572: PUSH
82573: LD_VAR 0 3
82577: PLUS
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: EMPTY
82584: LIST
82585: ADD
82586: ST_TO_ADDR
82587: GO 82536
82589: POP
82590: POP
// result = temp_list2 ;
82591: LD_ADDR_VAR 0 7
82595: PUSH
82596: LD_VAR 0 10
82600: ST_TO_ADDR
// end ;
82601: LD_VAR 0 7
82605: RET
// export function EnemyInRange ( unit , dist ) ; begin
82606: LD_INT 0
82608: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82609: LD_ADDR_VAR 0 3
82613: PUSH
82614: LD_VAR 0 1
82618: PPUSH
82619: CALL_OW 255
82623: PPUSH
82624: LD_VAR 0 1
82628: PPUSH
82629: CALL_OW 250
82633: PPUSH
82634: LD_VAR 0 1
82638: PPUSH
82639: CALL_OW 251
82643: PPUSH
82644: LD_VAR 0 2
82648: PPUSH
82649: CALL 56710 0 4
82653: PUSH
82654: LD_INT 4
82656: ARRAY
82657: ST_TO_ADDR
// end ;
82658: LD_VAR 0 3
82662: RET
// export function PlayerSeeMe ( unit ) ; begin
82663: LD_INT 0
82665: PPUSH
// result := See ( your_side , unit ) ;
82666: LD_ADDR_VAR 0 2
82670: PUSH
82671: LD_OWVAR 2
82675: PPUSH
82676: LD_VAR 0 1
82680: PPUSH
82681: CALL_OW 292
82685: ST_TO_ADDR
// end ;
82686: LD_VAR 0 2
82690: RET
// export function ReverseDir ( unit ) ; begin
82691: LD_INT 0
82693: PPUSH
// if not unit then
82694: LD_VAR 0 1
82698: NOT
82699: IFFALSE 82703
// exit ;
82701: GO 82726
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82703: LD_ADDR_VAR 0 2
82707: PUSH
82708: LD_VAR 0 1
82712: PPUSH
82713: CALL_OW 254
82717: PUSH
82718: LD_INT 3
82720: PLUS
82721: PUSH
82722: LD_INT 6
82724: MOD
82725: ST_TO_ADDR
// end ;
82726: LD_VAR 0 2
82730: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82731: LD_INT 0
82733: PPUSH
82734: PPUSH
82735: PPUSH
82736: PPUSH
82737: PPUSH
// if not hexes then
82738: LD_VAR 0 2
82742: NOT
82743: IFFALSE 82747
// exit ;
82745: GO 82895
// dist := 9999 ;
82747: LD_ADDR_VAR 0 5
82751: PUSH
82752: LD_INT 9999
82754: ST_TO_ADDR
// for i = 1 to hexes do
82755: LD_ADDR_VAR 0 4
82759: PUSH
82760: DOUBLE
82761: LD_INT 1
82763: DEC
82764: ST_TO_ADDR
82765: LD_VAR 0 2
82769: PUSH
82770: FOR_TO
82771: IFFALSE 82883
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82773: LD_VAR 0 1
82777: PPUSH
82778: LD_VAR 0 2
82782: PUSH
82783: LD_VAR 0 4
82787: ARRAY
82788: PUSH
82789: LD_INT 1
82791: ARRAY
82792: PPUSH
82793: LD_VAR 0 2
82797: PUSH
82798: LD_VAR 0 4
82802: ARRAY
82803: PUSH
82804: LD_INT 2
82806: ARRAY
82807: PPUSH
82808: CALL_OW 297
82812: PUSH
82813: LD_VAR 0 5
82817: LESS
82818: IFFALSE 82881
// begin hex := hexes [ i ] ;
82820: LD_ADDR_VAR 0 7
82824: PUSH
82825: LD_VAR 0 2
82829: PUSH
82830: LD_VAR 0 4
82834: ARRAY
82835: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82836: LD_ADDR_VAR 0 5
82840: PUSH
82841: LD_VAR 0 1
82845: PPUSH
82846: LD_VAR 0 2
82850: PUSH
82851: LD_VAR 0 4
82855: ARRAY
82856: PUSH
82857: LD_INT 1
82859: ARRAY
82860: PPUSH
82861: LD_VAR 0 2
82865: PUSH
82866: LD_VAR 0 4
82870: ARRAY
82871: PUSH
82872: LD_INT 2
82874: ARRAY
82875: PPUSH
82876: CALL_OW 297
82880: ST_TO_ADDR
// end ; end ;
82881: GO 82770
82883: POP
82884: POP
// result := hex ;
82885: LD_ADDR_VAR 0 3
82889: PUSH
82890: LD_VAR 0 7
82894: ST_TO_ADDR
// end ;
82895: LD_VAR 0 3
82899: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82900: LD_INT 0
82902: PPUSH
82903: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82904: LD_VAR 0 1
82908: NOT
82909: PUSH
82910: LD_VAR 0 1
82914: PUSH
82915: LD_INT 21
82917: PUSH
82918: LD_INT 2
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 23
82927: PUSH
82928: LD_INT 2
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PPUSH
82939: CALL_OW 69
82943: IN
82944: NOT
82945: OR
82946: IFFALSE 82950
// exit ;
82948: GO 82997
// for i = 1 to 3 do
82950: LD_ADDR_VAR 0 3
82954: PUSH
82955: DOUBLE
82956: LD_INT 1
82958: DEC
82959: ST_TO_ADDR
82960: LD_INT 3
82962: PUSH
82963: FOR_TO
82964: IFFALSE 82995
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82966: LD_VAR 0 1
82970: PPUSH
82971: CALL_OW 250
82975: PPUSH
82976: LD_VAR 0 1
82980: PPUSH
82981: CALL_OW 251
82985: PPUSH
82986: LD_INT 1
82988: PPUSH
82989: CALL_OW 453
82993: GO 82963
82995: POP
82996: POP
// end ;
82997: LD_VAR 0 2
83001: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83002: LD_INT 0
83004: PPUSH
83005: PPUSH
83006: PPUSH
83007: PPUSH
83008: PPUSH
83009: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83010: LD_VAR 0 1
83014: NOT
83015: PUSH
83016: LD_VAR 0 2
83020: NOT
83021: OR
83022: PUSH
83023: LD_VAR 0 1
83027: PPUSH
83028: CALL_OW 314
83032: OR
83033: IFFALSE 83037
// exit ;
83035: GO 83478
// x := GetX ( enemy_unit ) ;
83037: LD_ADDR_VAR 0 7
83041: PUSH
83042: LD_VAR 0 2
83046: PPUSH
83047: CALL_OW 250
83051: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83052: LD_ADDR_VAR 0 8
83056: PUSH
83057: LD_VAR 0 2
83061: PPUSH
83062: CALL_OW 251
83066: ST_TO_ADDR
// if not x or not y then
83067: LD_VAR 0 7
83071: NOT
83072: PUSH
83073: LD_VAR 0 8
83077: NOT
83078: OR
83079: IFFALSE 83083
// exit ;
83081: GO 83478
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83083: LD_ADDR_VAR 0 6
83087: PUSH
83088: LD_VAR 0 7
83092: PPUSH
83093: LD_INT 0
83095: PPUSH
83096: LD_INT 4
83098: PPUSH
83099: CALL_OW 272
83103: PUSH
83104: LD_VAR 0 8
83108: PPUSH
83109: LD_INT 0
83111: PPUSH
83112: LD_INT 4
83114: PPUSH
83115: CALL_OW 273
83119: PUSH
83120: EMPTY
83121: LIST
83122: LIST
83123: PUSH
83124: LD_VAR 0 7
83128: PPUSH
83129: LD_INT 1
83131: PPUSH
83132: LD_INT 4
83134: PPUSH
83135: CALL_OW 272
83139: PUSH
83140: LD_VAR 0 8
83144: PPUSH
83145: LD_INT 1
83147: PPUSH
83148: LD_INT 4
83150: PPUSH
83151: CALL_OW 273
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_VAR 0 7
83164: PPUSH
83165: LD_INT 2
83167: PPUSH
83168: LD_INT 4
83170: PPUSH
83171: CALL_OW 272
83175: PUSH
83176: LD_VAR 0 8
83180: PPUSH
83181: LD_INT 2
83183: PPUSH
83184: LD_INT 4
83186: PPUSH
83187: CALL_OW 273
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_VAR 0 7
83200: PPUSH
83201: LD_INT 3
83203: PPUSH
83204: LD_INT 4
83206: PPUSH
83207: CALL_OW 272
83211: PUSH
83212: LD_VAR 0 8
83216: PPUSH
83217: LD_INT 3
83219: PPUSH
83220: LD_INT 4
83222: PPUSH
83223: CALL_OW 273
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_VAR 0 7
83236: PPUSH
83237: LD_INT 4
83239: PPUSH
83240: LD_INT 4
83242: PPUSH
83243: CALL_OW 272
83247: PUSH
83248: LD_VAR 0 8
83252: PPUSH
83253: LD_INT 4
83255: PPUSH
83256: LD_INT 4
83258: PPUSH
83259: CALL_OW 273
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_VAR 0 7
83272: PPUSH
83273: LD_INT 5
83275: PPUSH
83276: LD_INT 4
83278: PPUSH
83279: CALL_OW 272
83283: PUSH
83284: LD_VAR 0 8
83288: PPUSH
83289: LD_INT 5
83291: PPUSH
83292: LD_INT 4
83294: PPUSH
83295: CALL_OW 273
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: ST_TO_ADDR
// for i = tmp downto 1 do
83312: LD_ADDR_VAR 0 4
83316: PUSH
83317: DOUBLE
83318: LD_VAR 0 6
83322: INC
83323: ST_TO_ADDR
83324: LD_INT 1
83326: PUSH
83327: FOR_DOWNTO
83328: IFFALSE 83429
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83330: LD_VAR 0 6
83334: PUSH
83335: LD_VAR 0 4
83339: ARRAY
83340: PUSH
83341: LD_INT 1
83343: ARRAY
83344: PPUSH
83345: LD_VAR 0 6
83349: PUSH
83350: LD_VAR 0 4
83354: ARRAY
83355: PUSH
83356: LD_INT 2
83358: ARRAY
83359: PPUSH
83360: CALL_OW 488
83364: NOT
83365: PUSH
83366: LD_VAR 0 6
83370: PUSH
83371: LD_VAR 0 4
83375: ARRAY
83376: PUSH
83377: LD_INT 1
83379: ARRAY
83380: PPUSH
83381: LD_VAR 0 6
83385: PUSH
83386: LD_VAR 0 4
83390: ARRAY
83391: PUSH
83392: LD_INT 2
83394: ARRAY
83395: PPUSH
83396: CALL_OW 428
83400: PUSH
83401: LD_INT 0
83403: NONEQUAL
83404: OR
83405: IFFALSE 83427
// tmp := Delete ( tmp , i ) ;
83407: LD_ADDR_VAR 0 6
83411: PUSH
83412: LD_VAR 0 6
83416: PPUSH
83417: LD_VAR 0 4
83421: PPUSH
83422: CALL_OW 3
83426: ST_TO_ADDR
83427: GO 83327
83429: POP
83430: POP
// j := GetClosestHex ( unit , tmp ) ;
83431: LD_ADDR_VAR 0 5
83435: PUSH
83436: LD_VAR 0 1
83440: PPUSH
83441: LD_VAR 0 6
83445: PPUSH
83446: CALL 82731 0 2
83450: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83451: LD_VAR 0 1
83455: PPUSH
83456: LD_VAR 0 5
83460: PUSH
83461: LD_INT 1
83463: ARRAY
83464: PPUSH
83465: LD_VAR 0 5
83469: PUSH
83470: LD_INT 2
83472: ARRAY
83473: PPUSH
83474: CALL_OW 111
// end ;
83478: LD_VAR 0 3
83482: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83483: LD_INT 0
83485: PPUSH
83486: PPUSH
83487: PPUSH
// uc_side = 0 ;
83488: LD_ADDR_OWVAR 20
83492: PUSH
83493: LD_INT 0
83495: ST_TO_ADDR
// uc_nation = 0 ;
83496: LD_ADDR_OWVAR 21
83500: PUSH
83501: LD_INT 0
83503: ST_TO_ADDR
// InitHc_All ( ) ;
83504: CALL_OW 584
// InitVc ;
83508: CALL_OW 20
// if mastodonts then
83512: LD_VAR 0 6
83516: IFFALSE 83583
// for i = 1 to mastodonts do
83518: LD_ADDR_VAR 0 11
83522: PUSH
83523: DOUBLE
83524: LD_INT 1
83526: DEC
83527: ST_TO_ADDR
83528: LD_VAR 0 6
83532: PUSH
83533: FOR_TO
83534: IFFALSE 83581
// begin vc_chassis := 31 ;
83536: LD_ADDR_OWVAR 37
83540: PUSH
83541: LD_INT 31
83543: ST_TO_ADDR
// vc_control := control_rider ;
83544: LD_ADDR_OWVAR 38
83548: PUSH
83549: LD_INT 4
83551: ST_TO_ADDR
// animal := CreateVehicle ;
83552: LD_ADDR_VAR 0 12
83556: PUSH
83557: CALL_OW 45
83561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83562: LD_VAR 0 12
83566: PPUSH
83567: LD_VAR 0 8
83571: PPUSH
83572: LD_INT 0
83574: PPUSH
83575: CALL 85771 0 3
// end ;
83579: GO 83533
83581: POP
83582: POP
// if horses then
83583: LD_VAR 0 5
83587: IFFALSE 83654
// for i = 1 to horses do
83589: LD_ADDR_VAR 0 11
83593: PUSH
83594: DOUBLE
83595: LD_INT 1
83597: DEC
83598: ST_TO_ADDR
83599: LD_VAR 0 5
83603: PUSH
83604: FOR_TO
83605: IFFALSE 83652
// begin hc_class := 21 ;
83607: LD_ADDR_OWVAR 28
83611: PUSH
83612: LD_INT 21
83614: ST_TO_ADDR
// hc_gallery :=  ;
83615: LD_ADDR_OWVAR 33
83619: PUSH
83620: LD_STRING 
83622: ST_TO_ADDR
// animal := CreateHuman ;
83623: LD_ADDR_VAR 0 12
83627: PUSH
83628: CALL_OW 44
83632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83633: LD_VAR 0 12
83637: PPUSH
83638: LD_VAR 0 8
83642: PPUSH
83643: LD_INT 0
83645: PPUSH
83646: CALL 85771 0 3
// end ;
83650: GO 83604
83652: POP
83653: POP
// if birds then
83654: LD_VAR 0 1
83658: IFFALSE 83725
// for i = 1 to birds do
83660: LD_ADDR_VAR 0 11
83664: PUSH
83665: DOUBLE
83666: LD_INT 1
83668: DEC
83669: ST_TO_ADDR
83670: LD_VAR 0 1
83674: PUSH
83675: FOR_TO
83676: IFFALSE 83723
// begin hc_class = 18 ;
83678: LD_ADDR_OWVAR 28
83682: PUSH
83683: LD_INT 18
83685: ST_TO_ADDR
// hc_gallery =  ;
83686: LD_ADDR_OWVAR 33
83690: PUSH
83691: LD_STRING 
83693: ST_TO_ADDR
// animal := CreateHuman ;
83694: LD_ADDR_VAR 0 12
83698: PUSH
83699: CALL_OW 44
83703: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83704: LD_VAR 0 12
83708: PPUSH
83709: LD_VAR 0 8
83713: PPUSH
83714: LD_INT 0
83716: PPUSH
83717: CALL 85771 0 3
// end ;
83721: GO 83675
83723: POP
83724: POP
// if tigers then
83725: LD_VAR 0 2
83729: IFFALSE 83813
// for i = 1 to tigers do
83731: LD_ADDR_VAR 0 11
83735: PUSH
83736: DOUBLE
83737: LD_INT 1
83739: DEC
83740: ST_TO_ADDR
83741: LD_VAR 0 2
83745: PUSH
83746: FOR_TO
83747: IFFALSE 83811
// begin hc_class = class_tiger ;
83749: LD_ADDR_OWVAR 28
83753: PUSH
83754: LD_INT 14
83756: ST_TO_ADDR
// hc_gallery =  ;
83757: LD_ADDR_OWVAR 33
83761: PUSH
83762: LD_STRING 
83764: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83765: LD_ADDR_OWVAR 35
83769: PUSH
83770: LD_INT 7
83772: NEG
83773: PPUSH
83774: LD_INT 7
83776: PPUSH
83777: CALL_OW 12
83781: ST_TO_ADDR
// animal := CreateHuman ;
83782: LD_ADDR_VAR 0 12
83786: PUSH
83787: CALL_OW 44
83791: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83792: LD_VAR 0 12
83796: PPUSH
83797: LD_VAR 0 8
83801: PPUSH
83802: LD_INT 0
83804: PPUSH
83805: CALL 85771 0 3
// end ;
83809: GO 83746
83811: POP
83812: POP
// if apemans then
83813: LD_VAR 0 3
83817: IFFALSE 83940
// for i = 1 to apemans do
83819: LD_ADDR_VAR 0 11
83823: PUSH
83824: DOUBLE
83825: LD_INT 1
83827: DEC
83828: ST_TO_ADDR
83829: LD_VAR 0 3
83833: PUSH
83834: FOR_TO
83835: IFFALSE 83938
// begin hc_class = class_apeman ;
83837: LD_ADDR_OWVAR 28
83841: PUSH
83842: LD_INT 12
83844: ST_TO_ADDR
// hc_gallery =  ;
83845: LD_ADDR_OWVAR 33
83849: PUSH
83850: LD_STRING 
83852: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83853: LD_ADDR_OWVAR 35
83857: PUSH
83858: LD_INT 5
83860: NEG
83861: PPUSH
83862: LD_INT 5
83864: PPUSH
83865: CALL_OW 12
83869: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83870: LD_ADDR_OWVAR 31
83874: PUSH
83875: LD_INT 1
83877: PPUSH
83878: LD_INT 3
83880: PPUSH
83881: CALL_OW 12
83885: PUSH
83886: LD_INT 1
83888: PPUSH
83889: LD_INT 3
83891: PPUSH
83892: CALL_OW 12
83896: PUSH
83897: LD_INT 0
83899: PUSH
83900: LD_INT 0
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: LIST
83907: LIST
83908: ST_TO_ADDR
// animal := CreateHuman ;
83909: LD_ADDR_VAR 0 12
83913: PUSH
83914: CALL_OW 44
83918: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83919: LD_VAR 0 12
83923: PPUSH
83924: LD_VAR 0 8
83928: PPUSH
83929: LD_INT 0
83931: PPUSH
83932: CALL 85771 0 3
// end ;
83936: GO 83834
83938: POP
83939: POP
// if enchidnas then
83940: LD_VAR 0 4
83944: IFFALSE 84011
// for i = 1 to enchidnas do
83946: LD_ADDR_VAR 0 11
83950: PUSH
83951: DOUBLE
83952: LD_INT 1
83954: DEC
83955: ST_TO_ADDR
83956: LD_VAR 0 4
83960: PUSH
83961: FOR_TO
83962: IFFALSE 84009
// begin hc_class = 13 ;
83964: LD_ADDR_OWVAR 28
83968: PUSH
83969: LD_INT 13
83971: ST_TO_ADDR
// hc_gallery =  ;
83972: LD_ADDR_OWVAR 33
83976: PUSH
83977: LD_STRING 
83979: ST_TO_ADDR
// animal := CreateHuman ;
83980: LD_ADDR_VAR 0 12
83984: PUSH
83985: CALL_OW 44
83989: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83990: LD_VAR 0 12
83994: PPUSH
83995: LD_VAR 0 8
83999: PPUSH
84000: LD_INT 0
84002: PPUSH
84003: CALL 85771 0 3
// end ;
84007: GO 83961
84009: POP
84010: POP
// if fishes then
84011: LD_VAR 0 7
84015: IFFALSE 84082
// for i = 1 to fishes do
84017: LD_ADDR_VAR 0 11
84021: PUSH
84022: DOUBLE
84023: LD_INT 1
84025: DEC
84026: ST_TO_ADDR
84027: LD_VAR 0 7
84031: PUSH
84032: FOR_TO
84033: IFFALSE 84080
// begin hc_class = 20 ;
84035: LD_ADDR_OWVAR 28
84039: PUSH
84040: LD_INT 20
84042: ST_TO_ADDR
// hc_gallery =  ;
84043: LD_ADDR_OWVAR 33
84047: PUSH
84048: LD_STRING 
84050: ST_TO_ADDR
// animal := CreateHuman ;
84051: LD_ADDR_VAR 0 12
84055: PUSH
84056: CALL_OW 44
84060: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84061: LD_VAR 0 12
84065: PPUSH
84066: LD_VAR 0 9
84070: PPUSH
84071: LD_INT 0
84073: PPUSH
84074: CALL 85771 0 3
// end ;
84078: GO 84032
84080: POP
84081: POP
// end ;
84082: LD_VAR 0 10
84086: RET
// export function WantHeal ( sci , unit ) ; begin
84087: LD_INT 0
84089: PPUSH
// if GetTaskList ( sci ) > 0 then
84090: LD_VAR 0 1
84094: PPUSH
84095: CALL_OW 437
84099: PUSH
84100: LD_INT 0
84102: GREATER
84103: IFFALSE 84173
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84105: LD_VAR 0 1
84109: PPUSH
84110: CALL_OW 437
84114: PUSH
84115: LD_INT 1
84117: ARRAY
84118: PUSH
84119: LD_INT 1
84121: ARRAY
84122: PUSH
84123: LD_STRING l
84125: EQUAL
84126: PUSH
84127: LD_VAR 0 1
84131: PPUSH
84132: CALL_OW 437
84136: PUSH
84137: LD_INT 1
84139: ARRAY
84140: PUSH
84141: LD_INT 4
84143: ARRAY
84144: PUSH
84145: LD_VAR 0 2
84149: EQUAL
84150: AND
84151: IFFALSE 84163
// result := true else
84153: LD_ADDR_VAR 0 3
84157: PUSH
84158: LD_INT 1
84160: ST_TO_ADDR
84161: GO 84171
// result := false ;
84163: LD_ADDR_VAR 0 3
84167: PUSH
84168: LD_INT 0
84170: ST_TO_ADDR
// end else
84171: GO 84181
// result := false ;
84173: LD_ADDR_VAR 0 3
84177: PUSH
84178: LD_INT 0
84180: ST_TO_ADDR
// end ;
84181: LD_VAR 0 3
84185: RET
// export function HealTarget ( sci ) ; begin
84186: LD_INT 0
84188: PPUSH
// if not sci then
84189: LD_VAR 0 1
84193: NOT
84194: IFFALSE 84198
// exit ;
84196: GO 84263
// result := 0 ;
84198: LD_ADDR_VAR 0 2
84202: PUSH
84203: LD_INT 0
84205: ST_TO_ADDR
// if GetTaskList ( sci ) then
84206: LD_VAR 0 1
84210: PPUSH
84211: CALL_OW 437
84215: IFFALSE 84263
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84217: LD_VAR 0 1
84221: PPUSH
84222: CALL_OW 437
84226: PUSH
84227: LD_INT 1
84229: ARRAY
84230: PUSH
84231: LD_INT 1
84233: ARRAY
84234: PUSH
84235: LD_STRING l
84237: EQUAL
84238: IFFALSE 84263
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84240: LD_ADDR_VAR 0 2
84244: PUSH
84245: LD_VAR 0 1
84249: PPUSH
84250: CALL_OW 437
84254: PUSH
84255: LD_INT 1
84257: ARRAY
84258: PUSH
84259: LD_INT 4
84261: ARRAY
84262: ST_TO_ADDR
// end ;
84263: LD_VAR 0 2
84267: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84268: LD_INT 0
84270: PPUSH
84271: PPUSH
84272: PPUSH
84273: PPUSH
// if not base_units then
84274: LD_VAR 0 1
84278: NOT
84279: IFFALSE 84283
// exit ;
84281: GO 84370
// result := false ;
84283: LD_ADDR_VAR 0 2
84287: PUSH
84288: LD_INT 0
84290: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84291: LD_ADDR_VAR 0 5
84295: PUSH
84296: LD_VAR 0 1
84300: PPUSH
84301: LD_INT 21
84303: PUSH
84304: LD_INT 3
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PPUSH
84311: CALL_OW 72
84315: ST_TO_ADDR
// if not tmp then
84316: LD_VAR 0 5
84320: NOT
84321: IFFALSE 84325
// exit ;
84323: GO 84370
// for i in tmp do
84325: LD_ADDR_VAR 0 3
84329: PUSH
84330: LD_VAR 0 5
84334: PUSH
84335: FOR_IN
84336: IFFALSE 84368
// begin result := EnemyInRange ( i , 22 ) ;
84338: LD_ADDR_VAR 0 2
84342: PUSH
84343: LD_VAR 0 3
84347: PPUSH
84348: LD_INT 22
84350: PPUSH
84351: CALL 82606 0 2
84355: ST_TO_ADDR
// if result then
84356: LD_VAR 0 2
84360: IFFALSE 84366
// exit ;
84362: POP
84363: POP
84364: GO 84370
// end ;
84366: GO 84335
84368: POP
84369: POP
// end ;
84370: LD_VAR 0 2
84374: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84375: LD_INT 0
84377: PPUSH
84378: PPUSH
// if not units then
84379: LD_VAR 0 1
84383: NOT
84384: IFFALSE 84388
// exit ;
84386: GO 84458
// result := [ ] ;
84388: LD_ADDR_VAR 0 3
84392: PUSH
84393: EMPTY
84394: ST_TO_ADDR
// for i in units do
84395: LD_ADDR_VAR 0 4
84399: PUSH
84400: LD_VAR 0 1
84404: PUSH
84405: FOR_IN
84406: IFFALSE 84456
// if GetTag ( i ) = tag then
84408: LD_VAR 0 4
84412: PPUSH
84413: CALL_OW 110
84417: PUSH
84418: LD_VAR 0 2
84422: EQUAL
84423: IFFALSE 84454
// result := Insert ( result , result + 1 , i ) ;
84425: LD_ADDR_VAR 0 3
84429: PUSH
84430: LD_VAR 0 3
84434: PPUSH
84435: LD_VAR 0 3
84439: PUSH
84440: LD_INT 1
84442: PLUS
84443: PPUSH
84444: LD_VAR 0 4
84448: PPUSH
84449: CALL_OW 2
84453: ST_TO_ADDR
84454: GO 84405
84456: POP
84457: POP
// end ;
84458: LD_VAR 0 3
84462: RET
// export function IsDriver ( un ) ; begin
84463: LD_INT 0
84465: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84466: LD_ADDR_VAR 0 2
84470: PUSH
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 55
84478: PUSH
84479: EMPTY
84480: LIST
84481: PPUSH
84482: CALL_OW 69
84486: IN
84487: ST_TO_ADDR
// end ;
84488: LD_VAR 0 2
84492: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84493: LD_INT 0
84495: PPUSH
84496: PPUSH
// list := [ ] ;
84497: LD_ADDR_VAR 0 5
84501: PUSH
84502: EMPTY
84503: ST_TO_ADDR
// case d of 0 :
84504: LD_VAR 0 3
84508: PUSH
84509: LD_INT 0
84511: DOUBLE
84512: EQUAL
84513: IFTRUE 84517
84515: GO 84650
84517: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84518: LD_ADDR_VAR 0 5
84522: PUSH
84523: LD_VAR 0 1
84527: PUSH
84528: LD_INT 4
84530: MINUS
84531: PUSH
84532: LD_VAR 0 2
84536: PUSH
84537: LD_INT 4
84539: MINUS
84540: PUSH
84541: LD_INT 2
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: LIST
84548: PUSH
84549: LD_VAR 0 1
84553: PUSH
84554: LD_INT 3
84556: MINUS
84557: PUSH
84558: LD_VAR 0 2
84562: PUSH
84563: LD_INT 1
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: LIST
84570: PUSH
84571: LD_VAR 0 1
84575: PUSH
84576: LD_INT 4
84578: PLUS
84579: PUSH
84580: LD_VAR 0 2
84584: PUSH
84585: LD_INT 4
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: LIST
84592: PUSH
84593: LD_VAR 0 1
84597: PUSH
84598: LD_INT 3
84600: PLUS
84601: PUSH
84602: LD_VAR 0 2
84606: PUSH
84607: LD_INT 3
84609: PLUS
84610: PUSH
84611: LD_INT 5
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: LIST
84618: PUSH
84619: LD_VAR 0 1
84623: PUSH
84624: LD_VAR 0 2
84628: PUSH
84629: LD_INT 4
84631: PLUS
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: LIST
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: ST_TO_ADDR
// end ; 1 :
84648: GO 85348
84650: LD_INT 1
84652: DOUBLE
84653: EQUAL
84654: IFTRUE 84658
84656: GO 84791
84658: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84659: LD_ADDR_VAR 0 5
84663: PUSH
84664: LD_VAR 0 1
84668: PUSH
84669: LD_VAR 0 2
84673: PUSH
84674: LD_INT 4
84676: MINUS
84677: PUSH
84678: LD_INT 3
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: LIST
84685: PUSH
84686: LD_VAR 0 1
84690: PUSH
84691: LD_INT 3
84693: MINUS
84694: PUSH
84695: LD_VAR 0 2
84699: PUSH
84700: LD_INT 3
84702: MINUS
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: LIST
84711: PUSH
84712: LD_VAR 0 1
84716: PUSH
84717: LD_INT 4
84719: MINUS
84720: PUSH
84721: LD_VAR 0 2
84725: PUSH
84726: LD_INT 1
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: LIST
84733: PUSH
84734: LD_VAR 0 1
84738: PUSH
84739: LD_VAR 0 2
84743: PUSH
84744: LD_INT 3
84746: PLUS
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: LIST
84755: PUSH
84756: LD_VAR 0 1
84760: PUSH
84761: LD_INT 4
84763: PLUS
84764: PUSH
84765: LD_VAR 0 2
84769: PUSH
84770: LD_INT 4
84772: PLUS
84773: PUSH
84774: LD_INT 5
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: LIST
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: ST_TO_ADDR
// end ; 2 :
84789: GO 85348
84791: LD_INT 2
84793: DOUBLE
84794: EQUAL
84795: IFTRUE 84799
84797: GO 84928
84799: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84800: LD_ADDR_VAR 0 5
84804: PUSH
84805: LD_VAR 0 1
84809: PUSH
84810: LD_VAR 0 2
84814: PUSH
84815: LD_INT 3
84817: MINUS
84818: PUSH
84819: LD_INT 3
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: LIST
84826: PUSH
84827: LD_VAR 0 1
84831: PUSH
84832: LD_INT 4
84834: PLUS
84835: PUSH
84836: LD_VAR 0 2
84840: PUSH
84841: LD_INT 4
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: LIST
84848: PUSH
84849: LD_VAR 0 1
84853: PUSH
84854: LD_VAR 0 2
84858: PUSH
84859: LD_INT 4
84861: PLUS
84862: PUSH
84863: LD_INT 0
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: LIST
84870: PUSH
84871: LD_VAR 0 1
84875: PUSH
84876: LD_INT 3
84878: MINUS
84879: PUSH
84880: LD_VAR 0 2
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: LIST
84892: PUSH
84893: LD_VAR 0 1
84897: PUSH
84898: LD_INT 4
84900: MINUS
84901: PUSH
84902: LD_VAR 0 2
84906: PUSH
84907: LD_INT 4
84909: MINUS
84910: PUSH
84911: LD_INT 2
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: LIST
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: ST_TO_ADDR
// end ; 3 :
84926: GO 85348
84928: LD_INT 3
84930: DOUBLE
84931: EQUAL
84932: IFTRUE 84936
84934: GO 85069
84936: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84937: LD_ADDR_VAR 0 5
84941: PUSH
84942: LD_VAR 0 1
84946: PUSH
84947: LD_INT 3
84949: PLUS
84950: PUSH
84951: LD_VAR 0 2
84955: PUSH
84956: LD_INT 4
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: LIST
84963: PUSH
84964: LD_VAR 0 1
84968: PUSH
84969: LD_INT 4
84971: PLUS
84972: PUSH
84973: LD_VAR 0 2
84977: PUSH
84978: LD_INT 4
84980: PLUS
84981: PUSH
84982: LD_INT 5
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: LIST
84989: PUSH
84990: LD_VAR 0 1
84994: PUSH
84995: LD_INT 4
84997: MINUS
84998: PUSH
84999: LD_VAR 0 2
85003: PUSH
85004: LD_INT 1
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: LIST
85011: PUSH
85012: LD_VAR 0 1
85016: PUSH
85017: LD_VAR 0 2
85021: PUSH
85022: LD_INT 4
85024: MINUS
85025: PUSH
85026: LD_INT 3
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: LIST
85033: PUSH
85034: LD_VAR 0 1
85038: PUSH
85039: LD_INT 3
85041: MINUS
85042: PUSH
85043: LD_VAR 0 2
85047: PUSH
85048: LD_INT 3
85050: MINUS
85051: PUSH
85052: LD_INT 2
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: LIST
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: ST_TO_ADDR
// end ; 4 :
85067: GO 85348
85069: LD_INT 4
85071: DOUBLE
85072: EQUAL
85073: IFTRUE 85077
85075: GO 85210
85077: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85078: LD_ADDR_VAR 0 5
85082: PUSH
85083: LD_VAR 0 1
85087: PUSH
85088: LD_VAR 0 2
85092: PUSH
85093: LD_INT 4
85095: PLUS
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: LIST
85104: PUSH
85105: LD_VAR 0 1
85109: PUSH
85110: LD_INT 3
85112: PLUS
85113: PUSH
85114: LD_VAR 0 2
85118: PUSH
85119: LD_INT 3
85121: PLUS
85122: PUSH
85123: LD_INT 5
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: LIST
85130: PUSH
85131: LD_VAR 0 1
85135: PUSH
85136: LD_INT 4
85138: PLUS
85139: PUSH
85140: LD_VAR 0 2
85144: PUSH
85145: LD_INT 4
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: PUSH
85153: LD_VAR 0 1
85157: PUSH
85158: LD_VAR 0 2
85162: PUSH
85163: LD_INT 3
85165: MINUS
85166: PUSH
85167: LD_INT 3
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: LIST
85174: PUSH
85175: LD_VAR 0 1
85179: PUSH
85180: LD_INT 4
85182: MINUS
85183: PUSH
85184: LD_VAR 0 2
85188: PUSH
85189: LD_INT 4
85191: MINUS
85192: PUSH
85193: LD_INT 2
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: LIST
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: ST_TO_ADDR
// end ; 5 :
85208: GO 85348
85210: LD_INT 5
85212: DOUBLE
85213: EQUAL
85214: IFTRUE 85218
85216: GO 85347
85218: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85219: LD_ADDR_VAR 0 5
85223: PUSH
85224: LD_VAR 0 1
85228: PUSH
85229: LD_INT 4
85231: MINUS
85232: PUSH
85233: LD_VAR 0 2
85237: PUSH
85238: LD_INT 1
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: LIST
85245: PUSH
85246: LD_VAR 0 1
85250: PUSH
85251: LD_VAR 0 2
85255: PUSH
85256: LD_INT 4
85258: MINUS
85259: PUSH
85260: LD_INT 3
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: LIST
85267: PUSH
85268: LD_VAR 0 1
85272: PUSH
85273: LD_INT 4
85275: PLUS
85276: PUSH
85277: LD_VAR 0 2
85281: PUSH
85282: LD_INT 4
85284: PLUS
85285: PUSH
85286: LD_INT 5
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: LIST
85293: PUSH
85294: LD_VAR 0 1
85298: PUSH
85299: LD_INT 3
85301: PLUS
85302: PUSH
85303: LD_VAR 0 2
85307: PUSH
85308: LD_INT 4
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: LIST
85315: PUSH
85316: LD_VAR 0 1
85320: PUSH
85321: LD_VAR 0 2
85325: PUSH
85326: LD_INT 3
85328: PLUS
85329: PUSH
85330: LD_INT 0
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: LIST
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: ST_TO_ADDR
// end ; end ;
85345: GO 85348
85347: POP
// result := list ;
85348: LD_ADDR_VAR 0 4
85352: PUSH
85353: LD_VAR 0 5
85357: ST_TO_ADDR
// end ;
85358: LD_VAR 0 4
85362: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85363: LD_INT 0
85365: PPUSH
85366: PPUSH
85367: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85368: LD_VAR 0 1
85372: NOT
85373: PUSH
85374: LD_VAR 0 2
85378: PUSH
85379: LD_INT 1
85381: PUSH
85382: LD_INT 2
85384: PUSH
85385: LD_INT 3
85387: PUSH
85388: LD_INT 4
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: IN
85397: NOT
85398: OR
85399: IFFALSE 85403
// exit ;
85401: GO 85495
// tmp := [ ] ;
85403: LD_ADDR_VAR 0 5
85407: PUSH
85408: EMPTY
85409: ST_TO_ADDR
// for i in units do
85410: LD_ADDR_VAR 0 4
85414: PUSH
85415: LD_VAR 0 1
85419: PUSH
85420: FOR_IN
85421: IFFALSE 85464
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85423: LD_ADDR_VAR 0 5
85427: PUSH
85428: LD_VAR 0 5
85432: PPUSH
85433: LD_VAR 0 5
85437: PUSH
85438: LD_INT 1
85440: PLUS
85441: PPUSH
85442: LD_VAR 0 4
85446: PPUSH
85447: LD_VAR 0 2
85451: PPUSH
85452: CALL_OW 259
85456: PPUSH
85457: CALL_OW 2
85461: ST_TO_ADDR
85462: GO 85420
85464: POP
85465: POP
// if not tmp then
85466: LD_VAR 0 5
85470: NOT
85471: IFFALSE 85475
// exit ;
85473: GO 85495
// result := SortListByListDesc ( units , tmp ) ;
85475: LD_ADDR_VAR 0 3
85479: PUSH
85480: LD_VAR 0 1
85484: PPUSH
85485: LD_VAR 0 5
85489: PPUSH
85490: CALL_OW 77
85494: ST_TO_ADDR
// end ;
85495: LD_VAR 0 3
85499: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85500: LD_INT 0
85502: PPUSH
85503: PPUSH
85504: PPUSH
// result := false ;
85505: LD_ADDR_VAR 0 3
85509: PUSH
85510: LD_INT 0
85512: ST_TO_ADDR
// x := GetX ( building ) ;
85513: LD_ADDR_VAR 0 4
85517: PUSH
85518: LD_VAR 0 2
85522: PPUSH
85523: CALL_OW 250
85527: ST_TO_ADDR
// y := GetY ( building ) ;
85528: LD_ADDR_VAR 0 5
85532: PUSH
85533: LD_VAR 0 2
85537: PPUSH
85538: CALL_OW 251
85542: ST_TO_ADDR
// if not building or not x or not y then
85543: LD_VAR 0 2
85547: NOT
85548: PUSH
85549: LD_VAR 0 4
85553: NOT
85554: OR
85555: PUSH
85556: LD_VAR 0 5
85560: NOT
85561: OR
85562: IFFALSE 85566
// exit ;
85564: GO 85658
// if GetTaskList ( unit ) then
85566: LD_VAR 0 1
85570: PPUSH
85571: CALL_OW 437
85575: IFFALSE 85658
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85577: LD_STRING e
85579: PUSH
85580: LD_VAR 0 1
85584: PPUSH
85585: CALL_OW 437
85589: PUSH
85590: LD_INT 1
85592: ARRAY
85593: PUSH
85594: LD_INT 1
85596: ARRAY
85597: EQUAL
85598: PUSH
85599: LD_VAR 0 4
85603: PUSH
85604: LD_VAR 0 1
85608: PPUSH
85609: CALL_OW 437
85613: PUSH
85614: LD_INT 1
85616: ARRAY
85617: PUSH
85618: LD_INT 2
85620: ARRAY
85621: EQUAL
85622: AND
85623: PUSH
85624: LD_VAR 0 5
85628: PUSH
85629: LD_VAR 0 1
85633: PPUSH
85634: CALL_OW 437
85638: PUSH
85639: LD_INT 1
85641: ARRAY
85642: PUSH
85643: LD_INT 3
85645: ARRAY
85646: EQUAL
85647: AND
85648: IFFALSE 85658
// result := true end ;
85650: LD_ADDR_VAR 0 3
85654: PUSH
85655: LD_INT 1
85657: ST_TO_ADDR
// end ;
85658: LD_VAR 0 3
85662: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85663: LD_INT 0
85665: PPUSH
// result := false ;
85666: LD_ADDR_VAR 0 4
85670: PUSH
85671: LD_INT 0
85673: ST_TO_ADDR
// if GetTaskList ( unit ) then
85674: LD_VAR 0 1
85678: PPUSH
85679: CALL_OW 437
85683: IFFALSE 85766
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85685: LD_STRING M
85687: PUSH
85688: LD_VAR 0 1
85692: PPUSH
85693: CALL_OW 437
85697: PUSH
85698: LD_INT 1
85700: ARRAY
85701: PUSH
85702: LD_INT 1
85704: ARRAY
85705: EQUAL
85706: PUSH
85707: LD_VAR 0 2
85711: PUSH
85712: LD_VAR 0 1
85716: PPUSH
85717: CALL_OW 437
85721: PUSH
85722: LD_INT 1
85724: ARRAY
85725: PUSH
85726: LD_INT 2
85728: ARRAY
85729: EQUAL
85730: AND
85731: PUSH
85732: LD_VAR 0 3
85736: PUSH
85737: LD_VAR 0 1
85741: PPUSH
85742: CALL_OW 437
85746: PUSH
85747: LD_INT 1
85749: ARRAY
85750: PUSH
85751: LD_INT 3
85753: ARRAY
85754: EQUAL
85755: AND
85756: IFFALSE 85766
// result := true ;
85758: LD_ADDR_VAR 0 4
85762: PUSH
85763: LD_INT 1
85765: ST_TO_ADDR
// end ; end ;
85766: LD_VAR 0 4
85770: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85771: LD_INT 0
85773: PPUSH
85774: PPUSH
85775: PPUSH
85776: PPUSH
// if not unit or not area then
85777: LD_VAR 0 1
85781: NOT
85782: PUSH
85783: LD_VAR 0 2
85787: NOT
85788: OR
85789: IFFALSE 85793
// exit ;
85791: GO 85957
// tmp := AreaToList ( area , i ) ;
85793: LD_ADDR_VAR 0 6
85797: PUSH
85798: LD_VAR 0 2
85802: PPUSH
85803: LD_VAR 0 5
85807: PPUSH
85808: CALL_OW 517
85812: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85813: LD_ADDR_VAR 0 5
85817: PUSH
85818: DOUBLE
85819: LD_INT 1
85821: DEC
85822: ST_TO_ADDR
85823: LD_VAR 0 6
85827: PUSH
85828: LD_INT 1
85830: ARRAY
85831: PUSH
85832: FOR_TO
85833: IFFALSE 85955
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85835: LD_ADDR_VAR 0 7
85839: PUSH
85840: LD_VAR 0 6
85844: PUSH
85845: LD_INT 1
85847: ARRAY
85848: PUSH
85849: LD_VAR 0 5
85853: ARRAY
85854: PUSH
85855: LD_VAR 0 6
85859: PUSH
85860: LD_INT 2
85862: ARRAY
85863: PUSH
85864: LD_VAR 0 5
85868: ARRAY
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85874: LD_VAR 0 7
85878: PUSH
85879: LD_INT 1
85881: ARRAY
85882: PPUSH
85883: LD_VAR 0 7
85887: PUSH
85888: LD_INT 2
85890: ARRAY
85891: PPUSH
85892: CALL_OW 428
85896: PUSH
85897: LD_INT 0
85899: EQUAL
85900: IFFALSE 85953
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85902: LD_VAR 0 1
85906: PPUSH
85907: LD_VAR 0 7
85911: PUSH
85912: LD_INT 1
85914: ARRAY
85915: PPUSH
85916: LD_VAR 0 7
85920: PUSH
85921: LD_INT 2
85923: ARRAY
85924: PPUSH
85925: LD_VAR 0 3
85929: PPUSH
85930: CALL_OW 48
// result := IsPlaced ( unit ) ;
85934: LD_ADDR_VAR 0 4
85938: PUSH
85939: LD_VAR 0 1
85943: PPUSH
85944: CALL_OW 305
85948: ST_TO_ADDR
// exit ;
85949: POP
85950: POP
85951: GO 85957
// end ; end ;
85953: GO 85832
85955: POP
85956: POP
// end ;
85957: LD_VAR 0 4
85961: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85962: LD_INT 0
85964: PPUSH
85965: PPUSH
85966: PPUSH
// if not side or side > 8 then
85967: LD_VAR 0 1
85971: NOT
85972: PUSH
85973: LD_VAR 0 1
85977: PUSH
85978: LD_INT 8
85980: GREATER
85981: OR
85982: IFFALSE 85986
// exit ;
85984: GO 86173
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85986: LD_ADDR_VAR 0 4
85990: PUSH
85991: LD_INT 22
85993: PUSH
85994: LD_VAR 0 1
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 21
86005: PUSH
86006: LD_INT 3
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PPUSH
86017: CALL_OW 69
86021: ST_TO_ADDR
// if not tmp then
86022: LD_VAR 0 4
86026: NOT
86027: IFFALSE 86031
// exit ;
86029: GO 86173
// enable_addtolog := true ;
86031: LD_ADDR_OWVAR 81
86035: PUSH
86036: LD_INT 1
86038: ST_TO_ADDR
// AddToLog ( [ ) ;
86039: LD_STRING [
86041: PPUSH
86042: CALL_OW 561
// for i in tmp do
86046: LD_ADDR_VAR 0 3
86050: PUSH
86051: LD_VAR 0 4
86055: PUSH
86056: FOR_IN
86057: IFFALSE 86164
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86059: LD_STRING [
86061: PUSH
86062: LD_VAR 0 3
86066: PPUSH
86067: CALL_OW 266
86071: STR
86072: PUSH
86073: LD_STRING , 
86075: STR
86076: PUSH
86077: LD_VAR 0 3
86081: PPUSH
86082: CALL_OW 250
86086: STR
86087: PUSH
86088: LD_STRING , 
86090: STR
86091: PUSH
86092: LD_VAR 0 3
86096: PPUSH
86097: CALL_OW 251
86101: STR
86102: PUSH
86103: LD_STRING , 
86105: STR
86106: PUSH
86107: LD_VAR 0 3
86111: PPUSH
86112: CALL_OW 254
86116: STR
86117: PUSH
86118: LD_STRING , 
86120: STR
86121: PUSH
86122: LD_VAR 0 3
86126: PPUSH
86127: LD_INT 1
86129: PPUSH
86130: CALL_OW 268
86134: STR
86135: PUSH
86136: LD_STRING , 
86138: STR
86139: PUSH
86140: LD_VAR 0 3
86144: PPUSH
86145: LD_INT 2
86147: PPUSH
86148: CALL_OW 268
86152: STR
86153: PUSH
86154: LD_STRING ],
86156: STR
86157: PPUSH
86158: CALL_OW 561
// end ;
86162: GO 86056
86164: POP
86165: POP
// AddToLog ( ]; ) ;
86166: LD_STRING ];
86168: PPUSH
86169: CALL_OW 561
// end ;
86173: LD_VAR 0 2
86177: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86178: LD_INT 0
86180: PPUSH
86181: PPUSH
86182: PPUSH
86183: PPUSH
86184: PPUSH
// if not area or not rate or not max then
86185: LD_VAR 0 1
86189: NOT
86190: PUSH
86191: LD_VAR 0 2
86195: NOT
86196: OR
86197: PUSH
86198: LD_VAR 0 4
86202: NOT
86203: OR
86204: IFFALSE 86208
// exit ;
86206: GO 86400
// while 1 do
86208: LD_INT 1
86210: IFFALSE 86400
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86212: LD_ADDR_VAR 0 9
86216: PUSH
86217: LD_VAR 0 1
86221: PPUSH
86222: LD_INT 1
86224: PPUSH
86225: CALL_OW 287
86229: PUSH
86230: LD_INT 10
86232: MUL
86233: ST_TO_ADDR
// r := rate / 10 ;
86234: LD_ADDR_VAR 0 7
86238: PUSH
86239: LD_VAR 0 2
86243: PUSH
86244: LD_INT 10
86246: DIVREAL
86247: ST_TO_ADDR
// time := 1 1$00 ;
86248: LD_ADDR_VAR 0 8
86252: PUSH
86253: LD_INT 2100
86255: ST_TO_ADDR
// if amount < min then
86256: LD_VAR 0 9
86260: PUSH
86261: LD_VAR 0 3
86265: LESS
86266: IFFALSE 86284
// r := r * 2 else
86268: LD_ADDR_VAR 0 7
86272: PUSH
86273: LD_VAR 0 7
86277: PUSH
86278: LD_INT 2
86280: MUL
86281: ST_TO_ADDR
86282: GO 86310
// if amount > max then
86284: LD_VAR 0 9
86288: PUSH
86289: LD_VAR 0 4
86293: GREATER
86294: IFFALSE 86310
// r := r / 2 ;
86296: LD_ADDR_VAR 0 7
86300: PUSH
86301: LD_VAR 0 7
86305: PUSH
86306: LD_INT 2
86308: DIVREAL
86309: ST_TO_ADDR
// time := time / r ;
86310: LD_ADDR_VAR 0 8
86314: PUSH
86315: LD_VAR 0 8
86319: PUSH
86320: LD_VAR 0 7
86324: DIVREAL
86325: ST_TO_ADDR
// if time < 0 then
86326: LD_VAR 0 8
86330: PUSH
86331: LD_INT 0
86333: LESS
86334: IFFALSE 86351
// time := time * - 1 ;
86336: LD_ADDR_VAR 0 8
86340: PUSH
86341: LD_VAR 0 8
86345: PUSH
86346: LD_INT 1
86348: NEG
86349: MUL
86350: ST_TO_ADDR
// wait ( time ) ;
86351: LD_VAR 0 8
86355: PPUSH
86356: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86360: LD_INT 35
86362: PPUSH
86363: LD_INT 875
86365: PPUSH
86366: CALL_OW 12
86370: PPUSH
86371: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86375: LD_INT 1
86377: PPUSH
86378: LD_INT 5
86380: PPUSH
86381: CALL_OW 12
86385: PPUSH
86386: LD_VAR 0 1
86390: PPUSH
86391: LD_INT 1
86393: PPUSH
86394: CALL_OW 55
// end ;
86398: GO 86208
// end ;
86400: LD_VAR 0 5
86404: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86405: LD_INT 0
86407: PPUSH
86408: PPUSH
86409: PPUSH
86410: PPUSH
86411: PPUSH
86412: PPUSH
86413: PPUSH
86414: PPUSH
// if not turrets or not factories then
86415: LD_VAR 0 1
86419: NOT
86420: PUSH
86421: LD_VAR 0 2
86425: NOT
86426: OR
86427: IFFALSE 86431
// exit ;
86429: GO 86738
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86431: LD_ADDR_VAR 0 10
86435: PUSH
86436: LD_INT 5
86438: PUSH
86439: LD_INT 6
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 2
86448: PUSH
86449: LD_INT 4
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 3
86458: PUSH
86459: LD_INT 5
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 24
86473: PUSH
86474: LD_INT 25
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 23
86483: PUSH
86484: LD_INT 27
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 42
86497: PUSH
86498: LD_INT 43
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 44
86507: PUSH
86508: LD_INT 46
86510: PUSH
86511: EMPTY
86512: LIST
86513: LIST
86514: PUSH
86515: LD_INT 45
86517: PUSH
86518: LD_INT 47
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: LIST
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: LIST
86534: ST_TO_ADDR
// result := [ ] ;
86535: LD_ADDR_VAR 0 3
86539: PUSH
86540: EMPTY
86541: ST_TO_ADDR
// for i in turrets do
86542: LD_ADDR_VAR 0 4
86546: PUSH
86547: LD_VAR 0 1
86551: PUSH
86552: FOR_IN
86553: IFFALSE 86736
// begin nat := GetNation ( i ) ;
86555: LD_ADDR_VAR 0 7
86559: PUSH
86560: LD_VAR 0 4
86564: PPUSH
86565: CALL_OW 248
86569: ST_TO_ADDR
// weapon := 0 ;
86570: LD_ADDR_VAR 0 8
86574: PUSH
86575: LD_INT 0
86577: ST_TO_ADDR
// if not nat then
86578: LD_VAR 0 7
86582: NOT
86583: IFFALSE 86587
// continue ;
86585: GO 86552
// for j in list [ nat ] do
86587: LD_ADDR_VAR 0 5
86591: PUSH
86592: LD_VAR 0 10
86596: PUSH
86597: LD_VAR 0 7
86601: ARRAY
86602: PUSH
86603: FOR_IN
86604: IFFALSE 86645
// if GetBWeapon ( i ) = j [ 1 ] then
86606: LD_VAR 0 4
86610: PPUSH
86611: CALL_OW 269
86615: PUSH
86616: LD_VAR 0 5
86620: PUSH
86621: LD_INT 1
86623: ARRAY
86624: EQUAL
86625: IFFALSE 86643
// begin weapon := j [ 2 ] ;
86627: LD_ADDR_VAR 0 8
86631: PUSH
86632: LD_VAR 0 5
86636: PUSH
86637: LD_INT 2
86639: ARRAY
86640: ST_TO_ADDR
// break ;
86641: GO 86645
// end ;
86643: GO 86603
86645: POP
86646: POP
// if not weapon then
86647: LD_VAR 0 8
86651: NOT
86652: IFFALSE 86656
// continue ;
86654: GO 86552
// for k in factories do
86656: LD_ADDR_VAR 0 6
86660: PUSH
86661: LD_VAR 0 2
86665: PUSH
86666: FOR_IN
86667: IFFALSE 86732
// begin weapons := AvailableWeaponList ( k ) ;
86669: LD_ADDR_VAR 0 9
86673: PUSH
86674: LD_VAR 0 6
86678: PPUSH
86679: CALL_OW 478
86683: ST_TO_ADDR
// if not weapons then
86684: LD_VAR 0 9
86688: NOT
86689: IFFALSE 86693
// continue ;
86691: GO 86666
// if weapon in weapons then
86693: LD_VAR 0 8
86697: PUSH
86698: LD_VAR 0 9
86702: IN
86703: IFFALSE 86730
// begin result := [ i , weapon ] ;
86705: LD_ADDR_VAR 0 3
86709: PUSH
86710: LD_VAR 0 4
86714: PUSH
86715: LD_VAR 0 8
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: ST_TO_ADDR
// exit ;
86724: POP
86725: POP
86726: POP
86727: POP
86728: GO 86738
// end ; end ;
86730: GO 86666
86732: POP
86733: POP
// end ;
86734: GO 86552
86736: POP
86737: POP
// end ;
86738: LD_VAR 0 3
86742: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86743: LD_INT 0
86745: PPUSH
// if not side or side > 8 then
86746: LD_VAR 0 3
86750: NOT
86751: PUSH
86752: LD_VAR 0 3
86756: PUSH
86757: LD_INT 8
86759: GREATER
86760: OR
86761: IFFALSE 86765
// exit ;
86763: GO 86824
// if not range then
86765: LD_VAR 0 4
86769: NOT
86770: IFFALSE 86781
// range := - 12 ;
86772: LD_ADDR_VAR 0 4
86776: PUSH
86777: LD_INT 12
86779: NEG
86780: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86781: LD_VAR 0 1
86785: PPUSH
86786: LD_VAR 0 2
86790: PPUSH
86791: LD_VAR 0 3
86795: PPUSH
86796: LD_VAR 0 4
86800: PPUSH
86801: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86805: LD_VAR 0 1
86809: PPUSH
86810: LD_VAR 0 2
86814: PPUSH
86815: LD_VAR 0 3
86819: PPUSH
86820: CALL_OW 331
// end ;
86824: LD_VAR 0 5
86828: RET
// export function Video ( mode ) ; begin
86829: LD_INT 0
86831: PPUSH
// ingame_video = mode ;
86832: LD_ADDR_OWVAR 52
86836: PUSH
86837: LD_VAR 0 1
86841: ST_TO_ADDR
// interface_hidden = mode ;
86842: LD_ADDR_OWVAR 54
86846: PUSH
86847: LD_VAR 0 1
86851: ST_TO_ADDR
// end ;
86852: LD_VAR 0 2
86856: RET
// export function Join ( array , element ) ; begin
86857: LD_INT 0
86859: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86860: LD_ADDR_VAR 0 3
86864: PUSH
86865: LD_VAR 0 1
86869: PPUSH
86870: LD_VAR 0 1
86874: PUSH
86875: LD_INT 1
86877: PLUS
86878: PPUSH
86879: LD_VAR 0 2
86883: PPUSH
86884: CALL_OW 1
86888: ST_TO_ADDR
// end ;
86889: LD_VAR 0 3
86893: RET
// export function JoinUnion ( array , element ) ; begin
86894: LD_INT 0
86896: PPUSH
// result := array union element ;
86897: LD_ADDR_VAR 0 3
86901: PUSH
86902: LD_VAR 0 1
86906: PUSH
86907: LD_VAR 0 2
86911: UNION
86912: ST_TO_ADDR
// end ;
86913: LD_VAR 0 3
86917: RET
// export function GetBehemoths ( side ) ; begin
86918: LD_INT 0
86920: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86921: LD_ADDR_VAR 0 2
86925: PUSH
86926: LD_INT 22
86928: PUSH
86929: LD_VAR 0 1
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 31
86940: PUSH
86941: LD_INT 25
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PPUSH
86952: CALL_OW 69
86956: ST_TO_ADDR
// end ;
86957: LD_VAR 0 2
86961: RET
// export function Shuffle ( array ) ; var i , index ; begin
86962: LD_INT 0
86964: PPUSH
86965: PPUSH
86966: PPUSH
// result := [ ] ;
86967: LD_ADDR_VAR 0 2
86971: PUSH
86972: EMPTY
86973: ST_TO_ADDR
// if not array then
86974: LD_VAR 0 1
86978: NOT
86979: IFFALSE 86983
// exit ;
86981: GO 87082
// Randomize ;
86983: CALL_OW 10
// for i = array downto 1 do
86987: LD_ADDR_VAR 0 3
86991: PUSH
86992: DOUBLE
86993: LD_VAR 0 1
86997: INC
86998: ST_TO_ADDR
86999: LD_INT 1
87001: PUSH
87002: FOR_DOWNTO
87003: IFFALSE 87080
// begin index := rand ( 1 , array ) ;
87005: LD_ADDR_VAR 0 4
87009: PUSH
87010: LD_INT 1
87012: PPUSH
87013: LD_VAR 0 1
87017: PPUSH
87018: CALL_OW 12
87022: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87023: LD_ADDR_VAR 0 2
87027: PUSH
87028: LD_VAR 0 2
87032: PPUSH
87033: LD_VAR 0 2
87037: PUSH
87038: LD_INT 1
87040: PLUS
87041: PPUSH
87042: LD_VAR 0 1
87046: PUSH
87047: LD_VAR 0 4
87051: ARRAY
87052: PPUSH
87053: CALL_OW 2
87057: ST_TO_ADDR
// array := Delete ( array , index ) ;
87058: LD_ADDR_VAR 0 1
87062: PUSH
87063: LD_VAR 0 1
87067: PPUSH
87068: LD_VAR 0 4
87072: PPUSH
87073: CALL_OW 3
87077: ST_TO_ADDR
// end ;
87078: GO 87002
87080: POP
87081: POP
// end ;
87082: LD_VAR 0 2
87086: RET
// export function GetBaseMaterials ( base ) ; begin
87087: LD_INT 0
87089: PPUSH
// result := [ 0 , 0 , 0 ] ;
87090: LD_ADDR_VAR 0 2
87094: PUSH
87095: LD_INT 0
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: LD_INT 0
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: LIST
87108: ST_TO_ADDR
// if not base then
87109: LD_VAR 0 1
87113: NOT
87114: IFFALSE 87118
// exit ;
87116: GO 87167
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87118: LD_ADDR_VAR 0 2
87122: PUSH
87123: LD_VAR 0 1
87127: PPUSH
87128: LD_INT 1
87130: PPUSH
87131: CALL_OW 275
87135: PUSH
87136: LD_VAR 0 1
87140: PPUSH
87141: LD_INT 2
87143: PPUSH
87144: CALL_OW 275
87148: PUSH
87149: LD_VAR 0 1
87153: PPUSH
87154: LD_INT 3
87156: PPUSH
87157: CALL_OW 275
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: LIST
87166: ST_TO_ADDR
// end ;
87167: LD_VAR 0 2
87171: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87172: LD_INT 0
87174: PPUSH
87175: PPUSH
// result := array ;
87176: LD_ADDR_VAR 0 3
87180: PUSH
87181: LD_VAR 0 1
87185: ST_TO_ADDR
// if size > 0 then
87186: LD_VAR 0 2
87190: PUSH
87191: LD_INT 0
87193: GREATER
87194: IFFALSE 87240
// for i := array downto size do
87196: LD_ADDR_VAR 0 4
87200: PUSH
87201: DOUBLE
87202: LD_VAR 0 1
87206: INC
87207: ST_TO_ADDR
87208: LD_VAR 0 2
87212: PUSH
87213: FOR_DOWNTO
87214: IFFALSE 87238
// result := Delete ( result , result ) ;
87216: LD_ADDR_VAR 0 3
87220: PUSH
87221: LD_VAR 0 3
87225: PPUSH
87226: LD_VAR 0 3
87230: PPUSH
87231: CALL_OW 3
87235: ST_TO_ADDR
87236: GO 87213
87238: POP
87239: POP
// end ;
87240: LD_VAR 0 3
87244: RET
// export function ComExit ( unit ) ; var tmp ; begin
87245: LD_INT 0
87247: PPUSH
87248: PPUSH
// if not IsInUnit ( unit ) then
87249: LD_VAR 0 1
87253: PPUSH
87254: CALL_OW 310
87258: NOT
87259: IFFALSE 87263
// exit ;
87261: GO 87323
// tmp := IsInUnit ( unit ) ;
87263: LD_ADDR_VAR 0 3
87267: PUSH
87268: LD_VAR 0 1
87272: PPUSH
87273: CALL_OW 310
87277: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87278: LD_VAR 0 3
87282: PPUSH
87283: CALL_OW 247
87287: PUSH
87288: LD_INT 2
87290: EQUAL
87291: IFFALSE 87304
// ComExitVehicle ( unit ) else
87293: LD_VAR 0 1
87297: PPUSH
87298: CALL_OW 121
87302: GO 87313
// ComExitBuilding ( unit ) ;
87304: LD_VAR 0 1
87308: PPUSH
87309: CALL_OW 122
// result := tmp ;
87313: LD_ADDR_VAR 0 2
87317: PUSH
87318: LD_VAR 0 3
87322: ST_TO_ADDR
// end ;
87323: LD_VAR 0 2
87327: RET
// export function ResetHc ; begin
87328: LD_INT 0
87330: PPUSH
// InitHc ;
87331: CALL_OW 19
// hc_importance := 0 ;
87335: LD_ADDR_OWVAR 32
87339: PUSH
87340: LD_INT 0
87342: ST_TO_ADDR
// end ;
87343: LD_VAR 0 1
87347: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87348: LD_INT 0
87350: PPUSH
87351: PPUSH
87352: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87353: LD_ADDR_VAR 0 6
87357: PUSH
87358: LD_VAR 0 1
87362: PUSH
87363: LD_VAR 0 3
87367: PLUS
87368: PUSH
87369: LD_INT 2
87371: DIV
87372: ST_TO_ADDR
// if _x < 0 then
87373: LD_VAR 0 6
87377: PUSH
87378: LD_INT 0
87380: LESS
87381: IFFALSE 87398
// _x := _x * - 1 ;
87383: LD_ADDR_VAR 0 6
87387: PUSH
87388: LD_VAR 0 6
87392: PUSH
87393: LD_INT 1
87395: NEG
87396: MUL
87397: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87398: LD_ADDR_VAR 0 7
87402: PUSH
87403: LD_VAR 0 2
87407: PUSH
87408: LD_VAR 0 4
87412: PLUS
87413: PUSH
87414: LD_INT 2
87416: DIV
87417: ST_TO_ADDR
// if _y < 0 then
87418: LD_VAR 0 7
87422: PUSH
87423: LD_INT 0
87425: LESS
87426: IFFALSE 87443
// _y := _y * - 1 ;
87428: LD_ADDR_VAR 0 7
87432: PUSH
87433: LD_VAR 0 7
87437: PUSH
87438: LD_INT 1
87440: NEG
87441: MUL
87442: ST_TO_ADDR
// result := [ _x , _y ] ;
87443: LD_ADDR_VAR 0 5
87447: PUSH
87448: LD_VAR 0 6
87452: PUSH
87453: LD_VAR 0 7
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: ST_TO_ADDR
// end ;
87462: LD_VAR 0 5
87466: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87467: LD_INT 0
87469: PPUSH
87470: PPUSH
87471: PPUSH
87472: PPUSH
// task := GetTaskList ( unit ) ;
87473: LD_ADDR_VAR 0 7
87477: PUSH
87478: LD_VAR 0 1
87482: PPUSH
87483: CALL_OW 437
87487: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87488: LD_VAR 0 7
87492: NOT
87493: PUSH
87494: LD_VAR 0 1
87498: PPUSH
87499: LD_VAR 0 2
87503: PPUSH
87504: CALL_OW 308
87508: NOT
87509: AND
87510: IFFALSE 87514
// exit ;
87512: GO 87632
// if IsInArea ( unit , area ) then
87514: LD_VAR 0 1
87518: PPUSH
87519: LD_VAR 0 2
87523: PPUSH
87524: CALL_OW 308
87528: IFFALSE 87546
// begin ComMoveToArea ( unit , goAway ) ;
87530: LD_VAR 0 1
87534: PPUSH
87535: LD_VAR 0 3
87539: PPUSH
87540: CALL_OW 113
// exit ;
87544: GO 87632
// end ; if task [ 1 ] [ 1 ] <> M then
87546: LD_VAR 0 7
87550: PUSH
87551: LD_INT 1
87553: ARRAY
87554: PUSH
87555: LD_INT 1
87557: ARRAY
87558: PUSH
87559: LD_STRING M
87561: NONEQUAL
87562: IFFALSE 87566
// exit ;
87564: GO 87632
// x := task [ 1 ] [ 2 ] ;
87566: LD_ADDR_VAR 0 5
87570: PUSH
87571: LD_VAR 0 7
87575: PUSH
87576: LD_INT 1
87578: ARRAY
87579: PUSH
87580: LD_INT 2
87582: ARRAY
87583: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87584: LD_ADDR_VAR 0 6
87588: PUSH
87589: LD_VAR 0 7
87593: PUSH
87594: LD_INT 1
87596: ARRAY
87597: PUSH
87598: LD_INT 3
87600: ARRAY
87601: ST_TO_ADDR
// if InArea ( x , y , area ) then
87602: LD_VAR 0 5
87606: PPUSH
87607: LD_VAR 0 6
87611: PPUSH
87612: LD_VAR 0 2
87616: PPUSH
87617: CALL_OW 309
87621: IFFALSE 87632
// ComStop ( unit ) ;
87623: LD_VAR 0 1
87627: PPUSH
87628: CALL_OW 141
// end ;
87632: LD_VAR 0 4
87636: RET
// export function Abs ( value ) ; begin
87637: LD_INT 0
87639: PPUSH
// result := value ;
87640: LD_ADDR_VAR 0 2
87644: PUSH
87645: LD_VAR 0 1
87649: ST_TO_ADDR
// if value < 0 then
87650: LD_VAR 0 1
87654: PUSH
87655: LD_INT 0
87657: LESS
87658: IFFALSE 87675
// result := value * - 1 ;
87660: LD_ADDR_VAR 0 2
87664: PUSH
87665: LD_VAR 0 1
87669: PUSH
87670: LD_INT 1
87672: NEG
87673: MUL
87674: ST_TO_ADDR
// end ;
87675: LD_VAR 0 2
87679: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87680: LD_INT 0
87682: PPUSH
87683: PPUSH
87684: PPUSH
87685: PPUSH
87686: PPUSH
87687: PPUSH
87688: PPUSH
87689: PPUSH
// if not unit or not building then
87690: LD_VAR 0 1
87694: NOT
87695: PUSH
87696: LD_VAR 0 2
87700: NOT
87701: OR
87702: IFFALSE 87706
// exit ;
87704: GO 87932
// x := GetX ( building ) ;
87706: LD_ADDR_VAR 0 4
87710: PUSH
87711: LD_VAR 0 2
87715: PPUSH
87716: CALL_OW 250
87720: ST_TO_ADDR
// y := GetY ( building ) ;
87721: LD_ADDR_VAR 0 6
87725: PUSH
87726: LD_VAR 0 2
87730: PPUSH
87731: CALL_OW 251
87735: ST_TO_ADDR
// d := GetDir ( building ) ;
87736: LD_ADDR_VAR 0 8
87740: PUSH
87741: LD_VAR 0 2
87745: PPUSH
87746: CALL_OW 254
87750: ST_TO_ADDR
// r := 4 ;
87751: LD_ADDR_VAR 0 9
87755: PUSH
87756: LD_INT 4
87758: ST_TO_ADDR
// for i := 1 to 5 do
87759: LD_ADDR_VAR 0 10
87763: PUSH
87764: DOUBLE
87765: LD_INT 1
87767: DEC
87768: ST_TO_ADDR
87769: LD_INT 5
87771: PUSH
87772: FOR_TO
87773: IFFALSE 87930
// begin _x := ShiftX ( x , d , r + i ) ;
87775: LD_ADDR_VAR 0 5
87779: PUSH
87780: LD_VAR 0 4
87784: PPUSH
87785: LD_VAR 0 8
87789: PPUSH
87790: LD_VAR 0 9
87794: PUSH
87795: LD_VAR 0 10
87799: PLUS
87800: PPUSH
87801: CALL_OW 272
87805: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87806: LD_ADDR_VAR 0 7
87810: PUSH
87811: LD_VAR 0 6
87815: PPUSH
87816: LD_VAR 0 8
87820: PPUSH
87821: LD_VAR 0 9
87825: PUSH
87826: LD_VAR 0 10
87830: PLUS
87831: PPUSH
87832: CALL_OW 273
87836: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87837: LD_VAR 0 5
87841: PPUSH
87842: LD_VAR 0 7
87846: PPUSH
87847: CALL_OW 488
87851: PUSH
87852: LD_VAR 0 5
87856: PPUSH
87857: LD_VAR 0 7
87861: PPUSH
87862: CALL_OW 428
87866: PPUSH
87867: CALL_OW 247
87871: PUSH
87872: LD_INT 3
87874: PUSH
87875: LD_INT 2
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: IN
87882: NOT
87883: AND
87884: IFFALSE 87928
// begin ComMoveXY ( unit , _x , _y ) ;
87886: LD_VAR 0 1
87890: PPUSH
87891: LD_VAR 0 5
87895: PPUSH
87896: LD_VAR 0 7
87900: PPUSH
87901: CALL_OW 111
// result := [ _x , _y ] ;
87905: LD_ADDR_VAR 0 3
87909: PUSH
87910: LD_VAR 0 5
87914: PUSH
87915: LD_VAR 0 7
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: ST_TO_ADDR
// exit ;
87924: POP
87925: POP
87926: GO 87932
// end ; end ;
87928: GO 87772
87930: POP
87931: POP
// end ; end_of_file end_of_file
87932: LD_VAR 0 3
87936: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
87937: LD_VAR 0 2
87941: PUSH
87942: LD_INT 100
87944: EQUAL
87945: IFFALSE 88894
// begin if not StreamModeActive then
87947: LD_EXP 133
87951: NOT
87952: IFFALSE 87962
// StreamModeActive := true ;
87954: LD_ADDR_EXP 133
87958: PUSH
87959: LD_INT 1
87961: ST_TO_ADDR
// if p3 = 0 then
87962: LD_VAR 0 3
87966: PUSH
87967: LD_INT 0
87969: EQUAL
87970: IFFALSE 87976
// InitStreamMode ;
87972: CALL 89052 0 0
// if p3 = 1 then
87976: LD_VAR 0 3
87980: PUSH
87981: LD_INT 1
87983: EQUAL
87984: IFFALSE 87994
// sRocket := true ;
87986: LD_ADDR_EXP 138
87990: PUSH
87991: LD_INT 1
87993: ST_TO_ADDR
// if p3 = 2 then
87994: LD_VAR 0 3
87998: PUSH
87999: LD_INT 2
88001: EQUAL
88002: IFFALSE 88012
// sSpeed := true ;
88004: LD_ADDR_EXP 137
88008: PUSH
88009: LD_INT 1
88011: ST_TO_ADDR
// if p3 = 3 then
88012: LD_VAR 0 3
88016: PUSH
88017: LD_INT 3
88019: EQUAL
88020: IFFALSE 88030
// sEngine := true ;
88022: LD_ADDR_EXP 139
88026: PUSH
88027: LD_INT 1
88029: ST_TO_ADDR
// if p3 = 4 then
88030: LD_VAR 0 3
88034: PUSH
88035: LD_INT 4
88037: EQUAL
88038: IFFALSE 88048
// sSpec := true ;
88040: LD_ADDR_EXP 136
88044: PUSH
88045: LD_INT 1
88047: ST_TO_ADDR
// if p3 = 5 then
88048: LD_VAR 0 3
88052: PUSH
88053: LD_INT 5
88055: EQUAL
88056: IFFALSE 88066
// sLevel := true ;
88058: LD_ADDR_EXP 140
88062: PUSH
88063: LD_INT 1
88065: ST_TO_ADDR
// if p3 = 6 then
88066: LD_VAR 0 3
88070: PUSH
88071: LD_INT 6
88073: EQUAL
88074: IFFALSE 88084
// sArmoury := true ;
88076: LD_ADDR_EXP 141
88080: PUSH
88081: LD_INT 1
88083: ST_TO_ADDR
// if p3 = 7 then
88084: LD_VAR 0 3
88088: PUSH
88089: LD_INT 7
88091: EQUAL
88092: IFFALSE 88102
// sRadar := true ;
88094: LD_ADDR_EXP 142
88098: PUSH
88099: LD_INT 1
88101: ST_TO_ADDR
// if p3 = 8 then
88102: LD_VAR 0 3
88106: PUSH
88107: LD_INT 8
88109: EQUAL
88110: IFFALSE 88120
// sBunker := true ;
88112: LD_ADDR_EXP 143
88116: PUSH
88117: LD_INT 1
88119: ST_TO_ADDR
// if p3 = 9 then
88120: LD_VAR 0 3
88124: PUSH
88125: LD_INT 9
88127: EQUAL
88128: IFFALSE 88138
// sHack := true ;
88130: LD_ADDR_EXP 144
88134: PUSH
88135: LD_INT 1
88137: ST_TO_ADDR
// if p3 = 10 then
88138: LD_VAR 0 3
88142: PUSH
88143: LD_INT 10
88145: EQUAL
88146: IFFALSE 88156
// sFire := true ;
88148: LD_ADDR_EXP 145
88152: PUSH
88153: LD_INT 1
88155: ST_TO_ADDR
// if p3 = 11 then
88156: LD_VAR 0 3
88160: PUSH
88161: LD_INT 11
88163: EQUAL
88164: IFFALSE 88174
// sRefresh := true ;
88166: LD_ADDR_EXP 146
88170: PUSH
88171: LD_INT 1
88173: ST_TO_ADDR
// if p3 = 12 then
88174: LD_VAR 0 3
88178: PUSH
88179: LD_INT 12
88181: EQUAL
88182: IFFALSE 88192
// sExp := true ;
88184: LD_ADDR_EXP 147
88188: PUSH
88189: LD_INT 1
88191: ST_TO_ADDR
// if p3 = 13 then
88192: LD_VAR 0 3
88196: PUSH
88197: LD_INT 13
88199: EQUAL
88200: IFFALSE 88210
// sDepot := true ;
88202: LD_ADDR_EXP 148
88206: PUSH
88207: LD_INT 1
88209: ST_TO_ADDR
// if p3 = 14 then
88210: LD_VAR 0 3
88214: PUSH
88215: LD_INT 14
88217: EQUAL
88218: IFFALSE 88228
// sFlag := true ;
88220: LD_ADDR_EXP 149
88224: PUSH
88225: LD_INT 1
88227: ST_TO_ADDR
// if p3 = 15 then
88228: LD_VAR 0 3
88232: PUSH
88233: LD_INT 15
88235: EQUAL
88236: IFFALSE 88246
// sKamikadze := true ;
88238: LD_ADDR_EXP 157
88242: PUSH
88243: LD_INT 1
88245: ST_TO_ADDR
// if p3 = 16 then
88246: LD_VAR 0 3
88250: PUSH
88251: LD_INT 16
88253: EQUAL
88254: IFFALSE 88264
// sTroll := true ;
88256: LD_ADDR_EXP 158
88260: PUSH
88261: LD_INT 1
88263: ST_TO_ADDR
// if p3 = 17 then
88264: LD_VAR 0 3
88268: PUSH
88269: LD_INT 17
88271: EQUAL
88272: IFFALSE 88282
// sSlow := true ;
88274: LD_ADDR_EXP 159
88278: PUSH
88279: LD_INT 1
88281: ST_TO_ADDR
// if p3 = 18 then
88282: LD_VAR 0 3
88286: PUSH
88287: LD_INT 18
88289: EQUAL
88290: IFFALSE 88300
// sLack := true ;
88292: LD_ADDR_EXP 160
88296: PUSH
88297: LD_INT 1
88299: ST_TO_ADDR
// if p3 = 19 then
88300: LD_VAR 0 3
88304: PUSH
88305: LD_INT 19
88307: EQUAL
88308: IFFALSE 88318
// sTank := true ;
88310: LD_ADDR_EXP 162
88314: PUSH
88315: LD_INT 1
88317: ST_TO_ADDR
// if p3 = 20 then
88318: LD_VAR 0 3
88322: PUSH
88323: LD_INT 20
88325: EQUAL
88326: IFFALSE 88336
// sRemote := true ;
88328: LD_ADDR_EXP 163
88332: PUSH
88333: LD_INT 1
88335: ST_TO_ADDR
// if p3 = 21 then
88336: LD_VAR 0 3
88340: PUSH
88341: LD_INT 21
88343: EQUAL
88344: IFFALSE 88354
// sPowell := true ;
88346: LD_ADDR_EXP 164
88350: PUSH
88351: LD_INT 1
88353: ST_TO_ADDR
// if p3 = 22 then
88354: LD_VAR 0 3
88358: PUSH
88359: LD_INT 22
88361: EQUAL
88362: IFFALSE 88372
// sTeleport := true ;
88364: LD_ADDR_EXP 167
88368: PUSH
88369: LD_INT 1
88371: ST_TO_ADDR
// if p3 = 23 then
88372: LD_VAR 0 3
88376: PUSH
88377: LD_INT 23
88379: EQUAL
88380: IFFALSE 88390
// sOilTower := true ;
88382: LD_ADDR_EXP 169
88386: PUSH
88387: LD_INT 1
88389: ST_TO_ADDR
// if p3 = 24 then
88390: LD_VAR 0 3
88394: PUSH
88395: LD_INT 24
88397: EQUAL
88398: IFFALSE 88408
// sShovel := true ;
88400: LD_ADDR_EXP 170
88404: PUSH
88405: LD_INT 1
88407: ST_TO_ADDR
// if p3 = 25 then
88408: LD_VAR 0 3
88412: PUSH
88413: LD_INT 25
88415: EQUAL
88416: IFFALSE 88426
// sSheik := true ;
88418: LD_ADDR_EXP 171
88422: PUSH
88423: LD_INT 1
88425: ST_TO_ADDR
// if p3 = 26 then
88426: LD_VAR 0 3
88430: PUSH
88431: LD_INT 26
88433: EQUAL
88434: IFFALSE 88444
// sEarthquake := true ;
88436: LD_ADDR_EXP 173
88440: PUSH
88441: LD_INT 1
88443: ST_TO_ADDR
// if p3 = 27 then
88444: LD_VAR 0 3
88448: PUSH
88449: LD_INT 27
88451: EQUAL
88452: IFFALSE 88462
// sAI := true ;
88454: LD_ADDR_EXP 174
88458: PUSH
88459: LD_INT 1
88461: ST_TO_ADDR
// if p3 = 28 then
88462: LD_VAR 0 3
88466: PUSH
88467: LD_INT 28
88469: EQUAL
88470: IFFALSE 88480
// sCargo := true ;
88472: LD_ADDR_EXP 177
88476: PUSH
88477: LD_INT 1
88479: ST_TO_ADDR
// if p3 = 29 then
88480: LD_VAR 0 3
88484: PUSH
88485: LD_INT 29
88487: EQUAL
88488: IFFALSE 88498
// sDLaser := true ;
88490: LD_ADDR_EXP 178
88494: PUSH
88495: LD_INT 1
88497: ST_TO_ADDR
// if p3 = 30 then
88498: LD_VAR 0 3
88502: PUSH
88503: LD_INT 30
88505: EQUAL
88506: IFFALSE 88516
// sExchange := true ;
88508: LD_ADDR_EXP 179
88512: PUSH
88513: LD_INT 1
88515: ST_TO_ADDR
// if p3 = 31 then
88516: LD_VAR 0 3
88520: PUSH
88521: LD_INT 31
88523: EQUAL
88524: IFFALSE 88534
// sFac := true ;
88526: LD_ADDR_EXP 180
88530: PUSH
88531: LD_INT 1
88533: ST_TO_ADDR
// if p3 = 32 then
88534: LD_VAR 0 3
88538: PUSH
88539: LD_INT 32
88541: EQUAL
88542: IFFALSE 88552
// sPower := true ;
88544: LD_ADDR_EXP 181
88548: PUSH
88549: LD_INT 1
88551: ST_TO_ADDR
// if p3 = 33 then
88552: LD_VAR 0 3
88556: PUSH
88557: LD_INT 33
88559: EQUAL
88560: IFFALSE 88570
// sRandom := true ;
88562: LD_ADDR_EXP 182
88566: PUSH
88567: LD_INT 1
88569: ST_TO_ADDR
// if p3 = 34 then
88570: LD_VAR 0 3
88574: PUSH
88575: LD_INT 34
88577: EQUAL
88578: IFFALSE 88588
// sShield := true ;
88580: LD_ADDR_EXP 183
88584: PUSH
88585: LD_INT 1
88587: ST_TO_ADDR
// if p3 = 35 then
88588: LD_VAR 0 3
88592: PUSH
88593: LD_INT 35
88595: EQUAL
88596: IFFALSE 88606
// sTime := true ;
88598: LD_ADDR_EXP 184
88602: PUSH
88603: LD_INT 1
88605: ST_TO_ADDR
// if p3 = 36 then
88606: LD_VAR 0 3
88610: PUSH
88611: LD_INT 36
88613: EQUAL
88614: IFFALSE 88624
// sTools := true ;
88616: LD_ADDR_EXP 185
88620: PUSH
88621: LD_INT 1
88623: ST_TO_ADDR
// if p3 = 101 then
88624: LD_VAR 0 3
88628: PUSH
88629: LD_INT 101
88631: EQUAL
88632: IFFALSE 88642
// sSold := true ;
88634: LD_ADDR_EXP 150
88638: PUSH
88639: LD_INT 1
88641: ST_TO_ADDR
// if p3 = 102 then
88642: LD_VAR 0 3
88646: PUSH
88647: LD_INT 102
88649: EQUAL
88650: IFFALSE 88660
// sDiff := true ;
88652: LD_ADDR_EXP 151
88656: PUSH
88657: LD_INT 1
88659: ST_TO_ADDR
// if p3 = 103 then
88660: LD_VAR 0 3
88664: PUSH
88665: LD_INT 103
88667: EQUAL
88668: IFFALSE 88678
// sFog := true ;
88670: LD_ADDR_EXP 154
88674: PUSH
88675: LD_INT 1
88677: ST_TO_ADDR
// if p3 = 104 then
88678: LD_VAR 0 3
88682: PUSH
88683: LD_INT 104
88685: EQUAL
88686: IFFALSE 88696
// sReset := true ;
88688: LD_ADDR_EXP 155
88692: PUSH
88693: LD_INT 1
88695: ST_TO_ADDR
// if p3 = 105 then
88696: LD_VAR 0 3
88700: PUSH
88701: LD_INT 105
88703: EQUAL
88704: IFFALSE 88714
// sSun := true ;
88706: LD_ADDR_EXP 156
88710: PUSH
88711: LD_INT 1
88713: ST_TO_ADDR
// if p3 = 106 then
88714: LD_VAR 0 3
88718: PUSH
88719: LD_INT 106
88721: EQUAL
88722: IFFALSE 88732
// sTiger := true ;
88724: LD_ADDR_EXP 152
88728: PUSH
88729: LD_INT 1
88731: ST_TO_ADDR
// if p3 = 107 then
88732: LD_VAR 0 3
88736: PUSH
88737: LD_INT 107
88739: EQUAL
88740: IFFALSE 88750
// sBomb := true ;
88742: LD_ADDR_EXP 153
88746: PUSH
88747: LD_INT 1
88749: ST_TO_ADDR
// if p3 = 108 then
88750: LD_VAR 0 3
88754: PUSH
88755: LD_INT 108
88757: EQUAL
88758: IFFALSE 88768
// sWound := true ;
88760: LD_ADDR_EXP 161
88764: PUSH
88765: LD_INT 1
88767: ST_TO_ADDR
// if p3 = 109 then
88768: LD_VAR 0 3
88772: PUSH
88773: LD_INT 109
88775: EQUAL
88776: IFFALSE 88786
// sBetray := true ;
88778: LD_ADDR_EXP 165
88782: PUSH
88783: LD_INT 1
88785: ST_TO_ADDR
// if p3 = 110 then
88786: LD_VAR 0 3
88790: PUSH
88791: LD_INT 110
88793: EQUAL
88794: IFFALSE 88804
// sContamin := true ;
88796: LD_ADDR_EXP 166
88800: PUSH
88801: LD_INT 1
88803: ST_TO_ADDR
// if p3 = 111 then
88804: LD_VAR 0 3
88808: PUSH
88809: LD_INT 111
88811: EQUAL
88812: IFFALSE 88822
// sOil := true ;
88814: LD_ADDR_EXP 168
88818: PUSH
88819: LD_INT 1
88821: ST_TO_ADDR
// if p3 = 112 then
88822: LD_VAR 0 3
88826: PUSH
88827: LD_INT 112
88829: EQUAL
88830: IFFALSE 88840
// sStu := true ;
88832: LD_ADDR_EXP 172
88836: PUSH
88837: LD_INT 1
88839: ST_TO_ADDR
// if p3 = 113 then
88840: LD_VAR 0 3
88844: PUSH
88845: LD_INT 113
88847: EQUAL
88848: IFFALSE 88858
// sBazooka := true ;
88850: LD_ADDR_EXP 175
88854: PUSH
88855: LD_INT 1
88857: ST_TO_ADDR
// if p3 = 114 then
88858: LD_VAR 0 3
88862: PUSH
88863: LD_INT 114
88865: EQUAL
88866: IFFALSE 88876
// sMortar := true ;
88868: LD_ADDR_EXP 176
88872: PUSH
88873: LD_INT 1
88875: ST_TO_ADDR
// if p3 = 115 then
88876: LD_VAR 0 3
88880: PUSH
88881: LD_INT 115
88883: EQUAL
88884: IFFALSE 88894
// sRanger := true ;
88886: LD_ADDR_EXP 186
88890: PUSH
88891: LD_INT 1
88893: ST_TO_ADDR
// end ; if p2 = 101 then
88894: LD_VAR 0 2
88898: PUSH
88899: LD_INT 101
88901: EQUAL
88902: IFFALSE 89030
// begin case p3 of 1 :
88904: LD_VAR 0 3
88908: PUSH
88909: LD_INT 1
88911: DOUBLE
88912: EQUAL
88913: IFTRUE 88917
88915: GO 88924
88917: POP
// hHackUnlimitedResources ; 2 :
88918: CALL 100065 0 0
88922: GO 89030
88924: LD_INT 2
88926: DOUBLE
88927: EQUAL
88928: IFTRUE 88932
88930: GO 88939
88932: POP
// hHackSetLevel10 ; 3 :
88933: CALL 100198 0 0
88937: GO 89030
88939: LD_INT 3
88941: DOUBLE
88942: EQUAL
88943: IFTRUE 88947
88945: GO 88954
88947: POP
// hHackSetLevel10YourUnits ; 4 :
88948: CALL 100283 0 0
88952: GO 89030
88954: LD_INT 4
88956: DOUBLE
88957: EQUAL
88958: IFTRUE 88962
88960: GO 88969
88962: POP
// hHackInvincible ; 5 :
88963: CALL 100731 0 0
88967: GO 89030
88969: LD_INT 5
88971: DOUBLE
88972: EQUAL
88973: IFTRUE 88977
88975: GO 88984
88977: POP
// hHackInvisible ; 6 :
88978: CALL 100842 0 0
88982: GO 89030
88984: LD_INT 6
88986: DOUBLE
88987: EQUAL
88988: IFTRUE 88992
88990: GO 88999
88992: POP
// hHackChangeYourSide ; 7 :
88993: CALL 100899 0 0
88997: GO 89030
88999: LD_INT 7
89001: DOUBLE
89002: EQUAL
89003: IFTRUE 89007
89005: GO 89014
89007: POP
// hHackChangeUnitSide ; 8 :
89008: CALL 100941 0 0
89012: GO 89030
89014: LD_INT 8
89016: DOUBLE
89017: EQUAL
89018: IFTRUE 89022
89020: GO 89029
89022: POP
// hHackFog ; end ;
89023: CALL 101042 0 0
89027: GO 89030
89029: POP
// end ; end ;
89030: PPOPN 6
89032: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89033: GO 89035
89035: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89036: LD_STRING initStreamRollete();
89038: PPUSH
89039: CALL_OW 559
// InitStreamMode ;
89043: CALL 89052 0 0
// DefineStreamItems ( ) ;
89047: CALL 89492 0 0
// end ;
89051: END
// function InitStreamMode ; begin
89052: LD_INT 0
89054: PPUSH
// streamModeActive := false ;
89055: LD_ADDR_EXP 133
89059: PUSH
89060: LD_INT 0
89062: ST_TO_ADDR
// normalCounter := 36 ;
89063: LD_ADDR_EXP 134
89067: PUSH
89068: LD_INT 36
89070: ST_TO_ADDR
// hardcoreCounter := 16 ;
89071: LD_ADDR_EXP 135
89075: PUSH
89076: LD_INT 16
89078: ST_TO_ADDR
// sRocket := false ;
89079: LD_ADDR_EXP 138
89083: PUSH
89084: LD_INT 0
89086: ST_TO_ADDR
// sSpeed := false ;
89087: LD_ADDR_EXP 137
89091: PUSH
89092: LD_INT 0
89094: ST_TO_ADDR
// sEngine := false ;
89095: LD_ADDR_EXP 139
89099: PUSH
89100: LD_INT 0
89102: ST_TO_ADDR
// sSpec := false ;
89103: LD_ADDR_EXP 136
89107: PUSH
89108: LD_INT 0
89110: ST_TO_ADDR
// sLevel := false ;
89111: LD_ADDR_EXP 140
89115: PUSH
89116: LD_INT 0
89118: ST_TO_ADDR
// sArmoury := false ;
89119: LD_ADDR_EXP 141
89123: PUSH
89124: LD_INT 0
89126: ST_TO_ADDR
// sRadar := false ;
89127: LD_ADDR_EXP 142
89131: PUSH
89132: LD_INT 0
89134: ST_TO_ADDR
// sBunker := false ;
89135: LD_ADDR_EXP 143
89139: PUSH
89140: LD_INT 0
89142: ST_TO_ADDR
// sHack := false ;
89143: LD_ADDR_EXP 144
89147: PUSH
89148: LD_INT 0
89150: ST_TO_ADDR
// sFire := false ;
89151: LD_ADDR_EXP 145
89155: PUSH
89156: LD_INT 0
89158: ST_TO_ADDR
// sRefresh := false ;
89159: LD_ADDR_EXP 146
89163: PUSH
89164: LD_INT 0
89166: ST_TO_ADDR
// sExp := false ;
89167: LD_ADDR_EXP 147
89171: PUSH
89172: LD_INT 0
89174: ST_TO_ADDR
// sDepot := false ;
89175: LD_ADDR_EXP 148
89179: PUSH
89180: LD_INT 0
89182: ST_TO_ADDR
// sFlag := false ;
89183: LD_ADDR_EXP 149
89187: PUSH
89188: LD_INT 0
89190: ST_TO_ADDR
// sKamikadze := false ;
89191: LD_ADDR_EXP 157
89195: PUSH
89196: LD_INT 0
89198: ST_TO_ADDR
// sTroll := false ;
89199: LD_ADDR_EXP 158
89203: PUSH
89204: LD_INT 0
89206: ST_TO_ADDR
// sSlow := false ;
89207: LD_ADDR_EXP 159
89211: PUSH
89212: LD_INT 0
89214: ST_TO_ADDR
// sLack := false ;
89215: LD_ADDR_EXP 160
89219: PUSH
89220: LD_INT 0
89222: ST_TO_ADDR
// sTank := false ;
89223: LD_ADDR_EXP 162
89227: PUSH
89228: LD_INT 0
89230: ST_TO_ADDR
// sRemote := false ;
89231: LD_ADDR_EXP 163
89235: PUSH
89236: LD_INT 0
89238: ST_TO_ADDR
// sPowell := false ;
89239: LD_ADDR_EXP 164
89243: PUSH
89244: LD_INT 0
89246: ST_TO_ADDR
// sTeleport := false ;
89247: LD_ADDR_EXP 167
89251: PUSH
89252: LD_INT 0
89254: ST_TO_ADDR
// sOilTower := false ;
89255: LD_ADDR_EXP 169
89259: PUSH
89260: LD_INT 0
89262: ST_TO_ADDR
// sShovel := false ;
89263: LD_ADDR_EXP 170
89267: PUSH
89268: LD_INT 0
89270: ST_TO_ADDR
// sSheik := false ;
89271: LD_ADDR_EXP 171
89275: PUSH
89276: LD_INT 0
89278: ST_TO_ADDR
// sEarthquake := false ;
89279: LD_ADDR_EXP 173
89283: PUSH
89284: LD_INT 0
89286: ST_TO_ADDR
// sAI := false ;
89287: LD_ADDR_EXP 174
89291: PUSH
89292: LD_INT 0
89294: ST_TO_ADDR
// sCargo := false ;
89295: LD_ADDR_EXP 177
89299: PUSH
89300: LD_INT 0
89302: ST_TO_ADDR
// sDLaser := false ;
89303: LD_ADDR_EXP 178
89307: PUSH
89308: LD_INT 0
89310: ST_TO_ADDR
// sExchange := false ;
89311: LD_ADDR_EXP 179
89315: PUSH
89316: LD_INT 0
89318: ST_TO_ADDR
// sFac := false ;
89319: LD_ADDR_EXP 180
89323: PUSH
89324: LD_INT 0
89326: ST_TO_ADDR
// sPower := false ;
89327: LD_ADDR_EXP 181
89331: PUSH
89332: LD_INT 0
89334: ST_TO_ADDR
// sRandom := false ;
89335: LD_ADDR_EXP 182
89339: PUSH
89340: LD_INT 0
89342: ST_TO_ADDR
// sShield := false ;
89343: LD_ADDR_EXP 183
89347: PUSH
89348: LD_INT 0
89350: ST_TO_ADDR
// sTime := false ;
89351: LD_ADDR_EXP 184
89355: PUSH
89356: LD_INT 0
89358: ST_TO_ADDR
// sTools := false ;
89359: LD_ADDR_EXP 185
89363: PUSH
89364: LD_INT 0
89366: ST_TO_ADDR
// sSold := false ;
89367: LD_ADDR_EXP 150
89371: PUSH
89372: LD_INT 0
89374: ST_TO_ADDR
// sDiff := false ;
89375: LD_ADDR_EXP 151
89379: PUSH
89380: LD_INT 0
89382: ST_TO_ADDR
// sFog := false ;
89383: LD_ADDR_EXP 154
89387: PUSH
89388: LD_INT 0
89390: ST_TO_ADDR
// sReset := false ;
89391: LD_ADDR_EXP 155
89395: PUSH
89396: LD_INT 0
89398: ST_TO_ADDR
// sSun := false ;
89399: LD_ADDR_EXP 156
89403: PUSH
89404: LD_INT 0
89406: ST_TO_ADDR
// sTiger := false ;
89407: LD_ADDR_EXP 152
89411: PUSH
89412: LD_INT 0
89414: ST_TO_ADDR
// sBomb := false ;
89415: LD_ADDR_EXP 153
89419: PUSH
89420: LD_INT 0
89422: ST_TO_ADDR
// sWound := false ;
89423: LD_ADDR_EXP 161
89427: PUSH
89428: LD_INT 0
89430: ST_TO_ADDR
// sBetray := false ;
89431: LD_ADDR_EXP 165
89435: PUSH
89436: LD_INT 0
89438: ST_TO_ADDR
// sContamin := false ;
89439: LD_ADDR_EXP 166
89443: PUSH
89444: LD_INT 0
89446: ST_TO_ADDR
// sOil := false ;
89447: LD_ADDR_EXP 168
89451: PUSH
89452: LD_INT 0
89454: ST_TO_ADDR
// sStu := false ;
89455: LD_ADDR_EXP 172
89459: PUSH
89460: LD_INT 0
89462: ST_TO_ADDR
// sBazooka := false ;
89463: LD_ADDR_EXP 175
89467: PUSH
89468: LD_INT 0
89470: ST_TO_ADDR
// sMortar := false ;
89471: LD_ADDR_EXP 176
89475: PUSH
89476: LD_INT 0
89478: ST_TO_ADDR
// sRanger := false ;
89479: LD_ADDR_EXP 186
89483: PUSH
89484: LD_INT 0
89486: ST_TO_ADDR
// end ;
89487: LD_VAR 0 1
89491: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
89492: LD_INT 0
89494: PPUSH
89495: PPUSH
89496: PPUSH
89497: PPUSH
89498: PPUSH
// result := [ ] ;
89499: LD_ADDR_VAR 0 1
89503: PUSH
89504: EMPTY
89505: ST_TO_ADDR
// if campaign_id = 1 then
89506: LD_OWVAR 69
89510: PUSH
89511: LD_INT 1
89513: EQUAL
89514: IFFALSE 92452
// begin case mission_number of 1 :
89516: LD_OWVAR 70
89520: PUSH
89521: LD_INT 1
89523: DOUBLE
89524: EQUAL
89525: IFTRUE 89529
89527: GO 89593
89529: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
89530: LD_ADDR_VAR 0 1
89534: PUSH
89535: LD_INT 2
89537: PUSH
89538: LD_INT 4
89540: PUSH
89541: LD_INT 11
89543: PUSH
89544: LD_INT 12
89546: PUSH
89547: LD_INT 15
89549: PUSH
89550: LD_INT 16
89552: PUSH
89553: LD_INT 22
89555: PUSH
89556: LD_INT 23
89558: PUSH
89559: LD_INT 26
89561: PUSH
89562: EMPTY
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 101
89575: PUSH
89576: LD_INT 102
89578: PUSH
89579: LD_INT 106
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: LIST
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: ST_TO_ADDR
89591: GO 92450
89593: LD_INT 2
89595: DOUBLE
89596: EQUAL
89597: IFTRUE 89601
89599: GO 89673
89601: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
89602: LD_ADDR_VAR 0 1
89606: PUSH
89607: LD_INT 2
89609: PUSH
89610: LD_INT 4
89612: PUSH
89613: LD_INT 11
89615: PUSH
89616: LD_INT 12
89618: PUSH
89619: LD_INT 15
89621: PUSH
89622: LD_INT 16
89624: PUSH
89625: LD_INT 22
89627: PUSH
89628: LD_INT 23
89630: PUSH
89631: LD_INT 26
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 101
89647: PUSH
89648: LD_INT 102
89650: PUSH
89651: LD_INT 105
89653: PUSH
89654: LD_INT 106
89656: PUSH
89657: LD_INT 108
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: ST_TO_ADDR
89671: GO 92450
89673: LD_INT 3
89675: DOUBLE
89676: EQUAL
89677: IFTRUE 89681
89679: GO 89757
89681: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
89682: LD_ADDR_VAR 0 1
89686: PUSH
89687: LD_INT 2
89689: PUSH
89690: LD_INT 4
89692: PUSH
89693: LD_INT 5
89695: PUSH
89696: LD_INT 11
89698: PUSH
89699: LD_INT 12
89701: PUSH
89702: LD_INT 15
89704: PUSH
89705: LD_INT 16
89707: PUSH
89708: LD_INT 22
89710: PUSH
89711: LD_INT 26
89713: PUSH
89714: LD_INT 36
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 101
89731: PUSH
89732: LD_INT 102
89734: PUSH
89735: LD_INT 105
89737: PUSH
89738: LD_INT 106
89740: PUSH
89741: LD_INT 108
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: ST_TO_ADDR
89755: GO 92450
89757: LD_INT 4
89759: DOUBLE
89760: EQUAL
89761: IFTRUE 89765
89763: GO 89849
89765: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89766: LD_ADDR_VAR 0 1
89770: PUSH
89771: LD_INT 2
89773: PUSH
89774: LD_INT 4
89776: PUSH
89777: LD_INT 5
89779: PUSH
89780: LD_INT 8
89782: PUSH
89783: LD_INT 11
89785: PUSH
89786: LD_INT 12
89788: PUSH
89789: LD_INT 15
89791: PUSH
89792: LD_INT 16
89794: PUSH
89795: LD_INT 22
89797: PUSH
89798: LD_INT 23
89800: PUSH
89801: LD_INT 26
89803: PUSH
89804: LD_INT 36
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 101
89823: PUSH
89824: LD_INT 102
89826: PUSH
89827: LD_INT 105
89829: PUSH
89830: LD_INT 106
89832: PUSH
89833: LD_INT 108
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: ST_TO_ADDR
89847: GO 92450
89849: LD_INT 5
89851: DOUBLE
89852: EQUAL
89853: IFTRUE 89857
89855: GO 89957
89857: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89858: LD_ADDR_VAR 0 1
89862: PUSH
89863: LD_INT 2
89865: PUSH
89866: LD_INT 4
89868: PUSH
89869: LD_INT 5
89871: PUSH
89872: LD_INT 6
89874: PUSH
89875: LD_INT 8
89877: PUSH
89878: LD_INT 11
89880: PUSH
89881: LD_INT 12
89883: PUSH
89884: LD_INT 15
89886: PUSH
89887: LD_INT 16
89889: PUSH
89890: LD_INT 22
89892: PUSH
89893: LD_INT 23
89895: PUSH
89896: LD_INT 25
89898: PUSH
89899: LD_INT 26
89901: PUSH
89902: LD_INT 36
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: PUSH
89921: LD_INT 101
89923: PUSH
89924: LD_INT 102
89926: PUSH
89927: LD_INT 105
89929: PUSH
89930: LD_INT 106
89932: PUSH
89933: LD_INT 108
89935: PUSH
89936: LD_INT 109
89938: PUSH
89939: LD_INT 112
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: ST_TO_ADDR
89955: GO 92450
89957: LD_INT 6
89959: DOUBLE
89960: EQUAL
89961: IFTRUE 89965
89963: GO 90085
89965: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89966: LD_ADDR_VAR 0 1
89970: PUSH
89971: LD_INT 2
89973: PUSH
89974: LD_INT 4
89976: PUSH
89977: LD_INT 5
89979: PUSH
89980: LD_INT 6
89982: PUSH
89983: LD_INT 8
89985: PUSH
89986: LD_INT 11
89988: PUSH
89989: LD_INT 12
89991: PUSH
89992: LD_INT 15
89994: PUSH
89995: LD_INT 16
89997: PUSH
89998: LD_INT 20
90000: PUSH
90001: LD_INT 21
90003: PUSH
90004: LD_INT 22
90006: PUSH
90007: LD_INT 23
90009: PUSH
90010: LD_INT 25
90012: PUSH
90013: LD_INT 26
90015: PUSH
90016: LD_INT 30
90018: PUSH
90019: LD_INT 31
90021: PUSH
90022: LD_INT 32
90024: PUSH
90025: LD_INT 36
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 101
90051: PUSH
90052: LD_INT 102
90054: PUSH
90055: LD_INT 105
90057: PUSH
90058: LD_INT 106
90060: PUSH
90061: LD_INT 108
90063: PUSH
90064: LD_INT 109
90066: PUSH
90067: LD_INT 112
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: ST_TO_ADDR
90083: GO 92450
90085: LD_INT 7
90087: DOUBLE
90088: EQUAL
90089: IFTRUE 90093
90091: GO 90193
90093: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90094: LD_ADDR_VAR 0 1
90098: PUSH
90099: LD_INT 2
90101: PUSH
90102: LD_INT 4
90104: PUSH
90105: LD_INT 5
90107: PUSH
90108: LD_INT 7
90110: PUSH
90111: LD_INT 11
90113: PUSH
90114: LD_INT 12
90116: PUSH
90117: LD_INT 15
90119: PUSH
90120: LD_INT 16
90122: PUSH
90123: LD_INT 20
90125: PUSH
90126: LD_INT 21
90128: PUSH
90129: LD_INT 22
90131: PUSH
90132: LD_INT 23
90134: PUSH
90135: LD_INT 25
90137: PUSH
90138: LD_INT 26
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 101
90159: PUSH
90160: LD_INT 102
90162: PUSH
90163: LD_INT 103
90165: PUSH
90166: LD_INT 105
90168: PUSH
90169: LD_INT 106
90171: PUSH
90172: LD_INT 108
90174: PUSH
90175: LD_INT 112
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: ST_TO_ADDR
90191: GO 92450
90193: LD_INT 8
90195: DOUBLE
90196: EQUAL
90197: IFTRUE 90201
90199: GO 90329
90201: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90202: LD_ADDR_VAR 0 1
90206: PUSH
90207: LD_INT 2
90209: PUSH
90210: LD_INT 4
90212: PUSH
90213: LD_INT 5
90215: PUSH
90216: LD_INT 6
90218: PUSH
90219: LD_INT 7
90221: PUSH
90222: LD_INT 8
90224: PUSH
90225: LD_INT 11
90227: PUSH
90228: LD_INT 12
90230: PUSH
90231: LD_INT 15
90233: PUSH
90234: LD_INT 16
90236: PUSH
90237: LD_INT 20
90239: PUSH
90240: LD_INT 21
90242: PUSH
90243: LD_INT 22
90245: PUSH
90246: LD_INT 23
90248: PUSH
90249: LD_INT 25
90251: PUSH
90252: LD_INT 26
90254: PUSH
90255: LD_INT 30
90257: PUSH
90258: LD_INT 31
90260: PUSH
90261: LD_INT 32
90263: PUSH
90264: LD_INT 36
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 101
90291: PUSH
90292: LD_INT 102
90294: PUSH
90295: LD_INT 103
90297: PUSH
90298: LD_INT 105
90300: PUSH
90301: LD_INT 106
90303: PUSH
90304: LD_INT 108
90306: PUSH
90307: LD_INT 109
90309: PUSH
90310: LD_INT 112
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: ST_TO_ADDR
90327: GO 92450
90329: LD_INT 9
90331: DOUBLE
90332: EQUAL
90333: IFTRUE 90337
90335: GO 90473
90337: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
90338: LD_ADDR_VAR 0 1
90342: PUSH
90343: LD_INT 2
90345: PUSH
90346: LD_INT 4
90348: PUSH
90349: LD_INT 5
90351: PUSH
90352: LD_INT 6
90354: PUSH
90355: LD_INT 7
90357: PUSH
90358: LD_INT 8
90360: PUSH
90361: LD_INT 11
90363: PUSH
90364: LD_INT 12
90366: PUSH
90367: LD_INT 15
90369: PUSH
90370: LD_INT 16
90372: PUSH
90373: LD_INT 20
90375: PUSH
90376: LD_INT 21
90378: PUSH
90379: LD_INT 22
90381: PUSH
90382: LD_INT 23
90384: PUSH
90385: LD_INT 25
90387: PUSH
90388: LD_INT 26
90390: PUSH
90391: LD_INT 28
90393: PUSH
90394: LD_INT 30
90396: PUSH
90397: LD_INT 31
90399: PUSH
90400: LD_INT 32
90402: PUSH
90403: LD_INT 36
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 101
90431: PUSH
90432: LD_INT 102
90434: PUSH
90435: LD_INT 103
90437: PUSH
90438: LD_INT 105
90440: PUSH
90441: LD_INT 106
90443: PUSH
90444: LD_INT 108
90446: PUSH
90447: LD_INT 109
90449: PUSH
90450: LD_INT 112
90452: PUSH
90453: LD_INT 114
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: ST_TO_ADDR
90471: GO 92450
90473: LD_INT 10
90475: DOUBLE
90476: EQUAL
90477: IFTRUE 90481
90479: GO 90665
90481: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
90482: LD_ADDR_VAR 0 1
90486: PUSH
90487: LD_INT 2
90489: PUSH
90490: LD_INT 4
90492: PUSH
90493: LD_INT 5
90495: PUSH
90496: LD_INT 6
90498: PUSH
90499: LD_INT 7
90501: PUSH
90502: LD_INT 8
90504: PUSH
90505: LD_INT 9
90507: PUSH
90508: LD_INT 10
90510: PUSH
90511: LD_INT 11
90513: PUSH
90514: LD_INT 12
90516: PUSH
90517: LD_INT 13
90519: PUSH
90520: LD_INT 14
90522: PUSH
90523: LD_INT 15
90525: PUSH
90526: LD_INT 16
90528: PUSH
90529: LD_INT 17
90531: PUSH
90532: LD_INT 18
90534: PUSH
90535: LD_INT 19
90537: PUSH
90538: LD_INT 20
90540: PUSH
90541: LD_INT 21
90543: PUSH
90544: LD_INT 22
90546: PUSH
90547: LD_INT 23
90549: PUSH
90550: LD_INT 24
90552: PUSH
90553: LD_INT 25
90555: PUSH
90556: LD_INT 26
90558: PUSH
90559: LD_INT 28
90561: PUSH
90562: LD_INT 30
90564: PUSH
90565: LD_INT 31
90567: PUSH
90568: LD_INT 32
90570: PUSH
90571: LD_INT 36
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: PUSH
90605: LD_INT 101
90607: PUSH
90608: LD_INT 102
90610: PUSH
90611: LD_INT 103
90613: PUSH
90614: LD_INT 104
90616: PUSH
90617: LD_INT 105
90619: PUSH
90620: LD_INT 106
90622: PUSH
90623: LD_INT 107
90625: PUSH
90626: LD_INT 108
90628: PUSH
90629: LD_INT 109
90631: PUSH
90632: LD_INT 110
90634: PUSH
90635: LD_INT 111
90637: PUSH
90638: LD_INT 112
90640: PUSH
90641: LD_INT 114
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: ST_TO_ADDR
90663: GO 92450
90665: LD_INT 11
90667: DOUBLE
90668: EQUAL
90669: IFTRUE 90673
90671: GO 90865
90673: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
90674: LD_ADDR_VAR 0 1
90678: PUSH
90679: LD_INT 2
90681: PUSH
90682: LD_INT 3
90684: PUSH
90685: LD_INT 4
90687: PUSH
90688: LD_INT 5
90690: PUSH
90691: LD_INT 6
90693: PUSH
90694: LD_INT 7
90696: PUSH
90697: LD_INT 8
90699: PUSH
90700: LD_INT 9
90702: PUSH
90703: LD_INT 10
90705: PUSH
90706: LD_INT 11
90708: PUSH
90709: LD_INT 12
90711: PUSH
90712: LD_INT 13
90714: PUSH
90715: LD_INT 14
90717: PUSH
90718: LD_INT 15
90720: PUSH
90721: LD_INT 16
90723: PUSH
90724: LD_INT 17
90726: PUSH
90727: LD_INT 18
90729: PUSH
90730: LD_INT 19
90732: PUSH
90733: LD_INT 20
90735: PUSH
90736: LD_INT 21
90738: PUSH
90739: LD_INT 22
90741: PUSH
90742: LD_INT 23
90744: PUSH
90745: LD_INT 24
90747: PUSH
90748: LD_INT 25
90750: PUSH
90751: LD_INT 26
90753: PUSH
90754: LD_INT 28
90756: PUSH
90757: LD_INT 30
90759: PUSH
90760: LD_INT 31
90762: PUSH
90763: LD_INT 32
90765: PUSH
90766: LD_INT 34
90768: PUSH
90769: LD_INT 36
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 101
90807: PUSH
90808: LD_INT 102
90810: PUSH
90811: LD_INT 103
90813: PUSH
90814: LD_INT 104
90816: PUSH
90817: LD_INT 105
90819: PUSH
90820: LD_INT 106
90822: PUSH
90823: LD_INT 107
90825: PUSH
90826: LD_INT 108
90828: PUSH
90829: LD_INT 109
90831: PUSH
90832: LD_INT 110
90834: PUSH
90835: LD_INT 111
90837: PUSH
90838: LD_INT 112
90840: PUSH
90841: LD_INT 114
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: ST_TO_ADDR
90863: GO 92450
90865: LD_INT 12
90867: DOUBLE
90868: EQUAL
90869: IFTRUE 90873
90871: GO 91081
90873: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90874: LD_ADDR_VAR 0 1
90878: PUSH
90879: LD_INT 1
90881: PUSH
90882: LD_INT 2
90884: PUSH
90885: LD_INT 3
90887: PUSH
90888: LD_INT 4
90890: PUSH
90891: LD_INT 5
90893: PUSH
90894: LD_INT 6
90896: PUSH
90897: LD_INT 7
90899: PUSH
90900: LD_INT 8
90902: PUSH
90903: LD_INT 9
90905: PUSH
90906: LD_INT 10
90908: PUSH
90909: LD_INT 11
90911: PUSH
90912: LD_INT 12
90914: PUSH
90915: LD_INT 13
90917: PUSH
90918: LD_INT 14
90920: PUSH
90921: LD_INT 15
90923: PUSH
90924: LD_INT 16
90926: PUSH
90927: LD_INT 17
90929: PUSH
90930: LD_INT 18
90932: PUSH
90933: LD_INT 19
90935: PUSH
90936: LD_INT 20
90938: PUSH
90939: LD_INT 21
90941: PUSH
90942: LD_INT 22
90944: PUSH
90945: LD_INT 23
90947: PUSH
90948: LD_INT 24
90950: PUSH
90951: LD_INT 25
90953: PUSH
90954: LD_INT 26
90956: PUSH
90957: LD_INT 27
90959: PUSH
90960: LD_INT 28
90962: PUSH
90963: LD_INT 30
90965: PUSH
90966: LD_INT 31
90968: PUSH
90969: LD_INT 32
90971: PUSH
90972: LD_INT 33
90974: PUSH
90975: LD_INT 34
90977: PUSH
90978: LD_INT 36
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 101
91019: PUSH
91020: LD_INT 102
91022: PUSH
91023: LD_INT 103
91025: PUSH
91026: LD_INT 104
91028: PUSH
91029: LD_INT 105
91031: PUSH
91032: LD_INT 106
91034: PUSH
91035: LD_INT 107
91037: PUSH
91038: LD_INT 108
91040: PUSH
91041: LD_INT 109
91043: PUSH
91044: LD_INT 110
91046: PUSH
91047: LD_INT 111
91049: PUSH
91050: LD_INT 112
91052: PUSH
91053: LD_INT 113
91055: PUSH
91056: LD_INT 114
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: ST_TO_ADDR
91079: GO 92450
91081: LD_INT 13
91083: DOUBLE
91084: EQUAL
91085: IFTRUE 91089
91087: GO 91285
91089: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91090: LD_ADDR_VAR 0 1
91094: PUSH
91095: LD_INT 1
91097: PUSH
91098: LD_INT 2
91100: PUSH
91101: LD_INT 3
91103: PUSH
91104: LD_INT 4
91106: PUSH
91107: LD_INT 5
91109: PUSH
91110: LD_INT 8
91112: PUSH
91113: LD_INT 9
91115: PUSH
91116: LD_INT 10
91118: PUSH
91119: LD_INT 11
91121: PUSH
91122: LD_INT 12
91124: PUSH
91125: LD_INT 14
91127: PUSH
91128: LD_INT 15
91130: PUSH
91131: LD_INT 16
91133: PUSH
91134: LD_INT 17
91136: PUSH
91137: LD_INT 18
91139: PUSH
91140: LD_INT 19
91142: PUSH
91143: LD_INT 20
91145: PUSH
91146: LD_INT 21
91148: PUSH
91149: LD_INT 22
91151: PUSH
91152: LD_INT 23
91154: PUSH
91155: LD_INT 24
91157: PUSH
91158: LD_INT 25
91160: PUSH
91161: LD_INT 26
91163: PUSH
91164: LD_INT 27
91166: PUSH
91167: LD_INT 28
91169: PUSH
91170: LD_INT 30
91172: PUSH
91173: LD_INT 31
91175: PUSH
91176: LD_INT 32
91178: PUSH
91179: LD_INT 33
91181: PUSH
91182: LD_INT 34
91184: PUSH
91185: LD_INT 36
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 101
91223: PUSH
91224: LD_INT 102
91226: PUSH
91227: LD_INT 103
91229: PUSH
91230: LD_INT 104
91232: PUSH
91233: LD_INT 105
91235: PUSH
91236: LD_INT 106
91238: PUSH
91239: LD_INT 107
91241: PUSH
91242: LD_INT 108
91244: PUSH
91245: LD_INT 109
91247: PUSH
91248: LD_INT 110
91250: PUSH
91251: LD_INT 111
91253: PUSH
91254: LD_INT 112
91256: PUSH
91257: LD_INT 113
91259: PUSH
91260: LD_INT 114
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: ST_TO_ADDR
91283: GO 92450
91285: LD_INT 14
91287: DOUBLE
91288: EQUAL
91289: IFTRUE 91293
91291: GO 91505
91293: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
91294: LD_ADDR_VAR 0 1
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: LD_INT 2
91304: PUSH
91305: LD_INT 3
91307: PUSH
91308: LD_INT 4
91310: PUSH
91311: LD_INT 5
91313: PUSH
91314: LD_INT 6
91316: PUSH
91317: LD_INT 7
91319: PUSH
91320: LD_INT 8
91322: PUSH
91323: LD_INT 9
91325: PUSH
91326: LD_INT 10
91328: PUSH
91329: LD_INT 11
91331: PUSH
91332: LD_INT 12
91334: PUSH
91335: LD_INT 13
91337: PUSH
91338: LD_INT 14
91340: PUSH
91341: LD_INT 15
91343: PUSH
91344: LD_INT 16
91346: PUSH
91347: LD_INT 17
91349: PUSH
91350: LD_INT 18
91352: PUSH
91353: LD_INT 19
91355: PUSH
91356: LD_INT 20
91358: PUSH
91359: LD_INT 21
91361: PUSH
91362: LD_INT 22
91364: PUSH
91365: LD_INT 23
91367: PUSH
91368: LD_INT 24
91370: PUSH
91371: LD_INT 25
91373: PUSH
91374: LD_INT 26
91376: PUSH
91377: LD_INT 27
91379: PUSH
91380: LD_INT 28
91382: PUSH
91383: LD_INT 29
91385: PUSH
91386: LD_INT 30
91388: PUSH
91389: LD_INT 31
91391: PUSH
91392: LD_INT 32
91394: PUSH
91395: LD_INT 33
91397: PUSH
91398: LD_INT 34
91400: PUSH
91401: LD_INT 36
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 101
91443: PUSH
91444: LD_INT 102
91446: PUSH
91447: LD_INT 103
91449: PUSH
91450: LD_INT 104
91452: PUSH
91453: LD_INT 105
91455: PUSH
91456: LD_INT 106
91458: PUSH
91459: LD_INT 107
91461: PUSH
91462: LD_INT 108
91464: PUSH
91465: LD_INT 109
91467: PUSH
91468: LD_INT 110
91470: PUSH
91471: LD_INT 111
91473: PUSH
91474: LD_INT 112
91476: PUSH
91477: LD_INT 113
91479: PUSH
91480: LD_INT 114
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: ST_TO_ADDR
91503: GO 92450
91505: LD_INT 15
91507: DOUBLE
91508: EQUAL
91509: IFTRUE 91513
91511: GO 91725
91513: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
91514: LD_ADDR_VAR 0 1
91518: PUSH
91519: LD_INT 1
91521: PUSH
91522: LD_INT 2
91524: PUSH
91525: LD_INT 3
91527: PUSH
91528: LD_INT 4
91530: PUSH
91531: LD_INT 5
91533: PUSH
91534: LD_INT 6
91536: PUSH
91537: LD_INT 7
91539: PUSH
91540: LD_INT 8
91542: PUSH
91543: LD_INT 9
91545: PUSH
91546: LD_INT 10
91548: PUSH
91549: LD_INT 11
91551: PUSH
91552: LD_INT 12
91554: PUSH
91555: LD_INT 13
91557: PUSH
91558: LD_INT 14
91560: PUSH
91561: LD_INT 15
91563: PUSH
91564: LD_INT 16
91566: PUSH
91567: LD_INT 17
91569: PUSH
91570: LD_INT 18
91572: PUSH
91573: LD_INT 19
91575: PUSH
91576: LD_INT 20
91578: PUSH
91579: LD_INT 21
91581: PUSH
91582: LD_INT 22
91584: PUSH
91585: LD_INT 23
91587: PUSH
91588: LD_INT 24
91590: PUSH
91591: LD_INT 25
91593: PUSH
91594: LD_INT 26
91596: PUSH
91597: LD_INT 27
91599: PUSH
91600: LD_INT 28
91602: PUSH
91603: LD_INT 29
91605: PUSH
91606: LD_INT 30
91608: PUSH
91609: LD_INT 31
91611: PUSH
91612: LD_INT 32
91614: PUSH
91615: LD_INT 33
91617: PUSH
91618: LD_INT 34
91620: PUSH
91621: LD_INT 36
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 101
91663: PUSH
91664: LD_INT 102
91666: PUSH
91667: LD_INT 103
91669: PUSH
91670: LD_INT 104
91672: PUSH
91673: LD_INT 105
91675: PUSH
91676: LD_INT 106
91678: PUSH
91679: LD_INT 107
91681: PUSH
91682: LD_INT 108
91684: PUSH
91685: LD_INT 109
91687: PUSH
91688: LD_INT 110
91690: PUSH
91691: LD_INT 111
91693: PUSH
91694: LD_INT 112
91696: PUSH
91697: LD_INT 113
91699: PUSH
91700: LD_INT 114
91702: PUSH
91703: EMPTY
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: ST_TO_ADDR
91723: GO 92450
91725: LD_INT 16
91727: DOUBLE
91728: EQUAL
91729: IFTRUE 91733
91731: GO 91857
91733: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91734: LD_ADDR_VAR 0 1
91738: PUSH
91739: LD_INT 2
91741: PUSH
91742: LD_INT 4
91744: PUSH
91745: LD_INT 5
91747: PUSH
91748: LD_INT 7
91750: PUSH
91751: LD_INT 11
91753: PUSH
91754: LD_INT 12
91756: PUSH
91757: LD_INT 15
91759: PUSH
91760: LD_INT 16
91762: PUSH
91763: LD_INT 20
91765: PUSH
91766: LD_INT 21
91768: PUSH
91769: LD_INT 22
91771: PUSH
91772: LD_INT 23
91774: PUSH
91775: LD_INT 25
91777: PUSH
91778: LD_INT 26
91780: PUSH
91781: LD_INT 30
91783: PUSH
91784: LD_INT 31
91786: PUSH
91787: LD_INT 32
91789: PUSH
91790: LD_INT 33
91792: PUSH
91793: LD_INT 34
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 101
91819: PUSH
91820: LD_INT 102
91822: PUSH
91823: LD_INT 103
91825: PUSH
91826: LD_INT 106
91828: PUSH
91829: LD_INT 108
91831: PUSH
91832: LD_INT 112
91834: PUSH
91835: LD_INT 113
91837: PUSH
91838: LD_INT 114
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: ST_TO_ADDR
91855: GO 92450
91857: LD_INT 17
91859: DOUBLE
91860: EQUAL
91861: IFTRUE 91865
91863: GO 92077
91865: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91866: LD_ADDR_VAR 0 1
91870: PUSH
91871: LD_INT 1
91873: PUSH
91874: LD_INT 2
91876: PUSH
91877: LD_INT 3
91879: PUSH
91880: LD_INT 4
91882: PUSH
91883: LD_INT 5
91885: PUSH
91886: LD_INT 6
91888: PUSH
91889: LD_INT 7
91891: PUSH
91892: LD_INT 8
91894: PUSH
91895: LD_INT 9
91897: PUSH
91898: LD_INT 10
91900: PUSH
91901: LD_INT 11
91903: PUSH
91904: LD_INT 12
91906: PUSH
91907: LD_INT 13
91909: PUSH
91910: LD_INT 14
91912: PUSH
91913: LD_INT 15
91915: PUSH
91916: LD_INT 16
91918: PUSH
91919: LD_INT 17
91921: PUSH
91922: LD_INT 18
91924: PUSH
91925: LD_INT 19
91927: PUSH
91928: LD_INT 20
91930: PUSH
91931: LD_INT 21
91933: PUSH
91934: LD_INT 22
91936: PUSH
91937: LD_INT 23
91939: PUSH
91940: LD_INT 24
91942: PUSH
91943: LD_INT 25
91945: PUSH
91946: LD_INT 26
91948: PUSH
91949: LD_INT 27
91951: PUSH
91952: LD_INT 28
91954: PUSH
91955: LD_INT 29
91957: PUSH
91958: LD_INT 30
91960: PUSH
91961: LD_INT 31
91963: PUSH
91964: LD_INT 32
91966: PUSH
91967: LD_INT 33
91969: PUSH
91970: LD_INT 34
91972: PUSH
91973: LD_INT 36
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 101
92015: PUSH
92016: LD_INT 102
92018: PUSH
92019: LD_INT 103
92021: PUSH
92022: LD_INT 104
92024: PUSH
92025: LD_INT 105
92027: PUSH
92028: LD_INT 106
92030: PUSH
92031: LD_INT 107
92033: PUSH
92034: LD_INT 108
92036: PUSH
92037: LD_INT 109
92039: PUSH
92040: LD_INT 110
92042: PUSH
92043: LD_INT 111
92045: PUSH
92046: LD_INT 112
92048: PUSH
92049: LD_INT 113
92051: PUSH
92052: LD_INT 114
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: ST_TO_ADDR
92075: GO 92450
92077: LD_INT 18
92079: DOUBLE
92080: EQUAL
92081: IFTRUE 92085
92083: GO 92221
92085: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92086: LD_ADDR_VAR 0 1
92090: PUSH
92091: LD_INT 2
92093: PUSH
92094: LD_INT 4
92096: PUSH
92097: LD_INT 5
92099: PUSH
92100: LD_INT 7
92102: PUSH
92103: LD_INT 11
92105: PUSH
92106: LD_INT 12
92108: PUSH
92109: LD_INT 15
92111: PUSH
92112: LD_INT 16
92114: PUSH
92115: LD_INT 20
92117: PUSH
92118: LD_INT 21
92120: PUSH
92121: LD_INT 22
92123: PUSH
92124: LD_INT 23
92126: PUSH
92127: LD_INT 25
92129: PUSH
92130: LD_INT 26
92132: PUSH
92133: LD_INT 30
92135: PUSH
92136: LD_INT 31
92138: PUSH
92139: LD_INT 32
92141: PUSH
92142: LD_INT 33
92144: PUSH
92145: LD_INT 34
92147: PUSH
92148: LD_INT 35
92150: PUSH
92151: LD_INT 36
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: PUSH
92177: LD_INT 101
92179: PUSH
92180: LD_INT 102
92182: PUSH
92183: LD_INT 103
92185: PUSH
92186: LD_INT 106
92188: PUSH
92189: LD_INT 108
92191: PUSH
92192: LD_INT 112
92194: PUSH
92195: LD_INT 113
92197: PUSH
92198: LD_INT 114
92200: PUSH
92201: LD_INT 115
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: ST_TO_ADDR
92219: GO 92450
92221: LD_INT 19
92223: DOUBLE
92224: EQUAL
92225: IFTRUE 92229
92227: GO 92449
92229: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92230: LD_ADDR_VAR 0 1
92234: PUSH
92235: LD_INT 1
92237: PUSH
92238: LD_INT 2
92240: PUSH
92241: LD_INT 3
92243: PUSH
92244: LD_INT 4
92246: PUSH
92247: LD_INT 5
92249: PUSH
92250: LD_INT 6
92252: PUSH
92253: LD_INT 7
92255: PUSH
92256: LD_INT 8
92258: PUSH
92259: LD_INT 9
92261: PUSH
92262: LD_INT 10
92264: PUSH
92265: LD_INT 11
92267: PUSH
92268: LD_INT 12
92270: PUSH
92271: LD_INT 13
92273: PUSH
92274: LD_INT 14
92276: PUSH
92277: LD_INT 15
92279: PUSH
92280: LD_INT 16
92282: PUSH
92283: LD_INT 17
92285: PUSH
92286: LD_INT 18
92288: PUSH
92289: LD_INT 19
92291: PUSH
92292: LD_INT 20
92294: PUSH
92295: LD_INT 21
92297: PUSH
92298: LD_INT 22
92300: PUSH
92301: LD_INT 23
92303: PUSH
92304: LD_INT 24
92306: PUSH
92307: LD_INT 25
92309: PUSH
92310: LD_INT 26
92312: PUSH
92313: LD_INT 27
92315: PUSH
92316: LD_INT 28
92318: PUSH
92319: LD_INT 29
92321: PUSH
92322: LD_INT 30
92324: PUSH
92325: LD_INT 31
92327: PUSH
92328: LD_INT 32
92330: PUSH
92331: LD_INT 33
92333: PUSH
92334: LD_INT 34
92336: PUSH
92337: LD_INT 35
92339: PUSH
92340: LD_INT 36
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 101
92383: PUSH
92384: LD_INT 102
92386: PUSH
92387: LD_INT 103
92389: PUSH
92390: LD_INT 104
92392: PUSH
92393: LD_INT 105
92395: PUSH
92396: LD_INT 106
92398: PUSH
92399: LD_INT 107
92401: PUSH
92402: LD_INT 108
92404: PUSH
92405: LD_INT 109
92407: PUSH
92408: LD_INT 110
92410: PUSH
92411: LD_INT 111
92413: PUSH
92414: LD_INT 112
92416: PUSH
92417: LD_INT 113
92419: PUSH
92420: LD_INT 114
92422: PUSH
92423: LD_INT 115
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: ST_TO_ADDR
92447: GO 92450
92449: POP
// end else
92450: GO 92669
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
92452: LD_ADDR_VAR 0 1
92456: PUSH
92457: LD_INT 1
92459: PUSH
92460: LD_INT 2
92462: PUSH
92463: LD_INT 3
92465: PUSH
92466: LD_INT 4
92468: PUSH
92469: LD_INT 5
92471: PUSH
92472: LD_INT 6
92474: PUSH
92475: LD_INT 7
92477: PUSH
92478: LD_INT 8
92480: PUSH
92481: LD_INT 9
92483: PUSH
92484: LD_INT 10
92486: PUSH
92487: LD_INT 11
92489: PUSH
92490: LD_INT 12
92492: PUSH
92493: LD_INT 13
92495: PUSH
92496: LD_INT 14
92498: PUSH
92499: LD_INT 15
92501: PUSH
92502: LD_INT 16
92504: PUSH
92505: LD_INT 17
92507: PUSH
92508: LD_INT 18
92510: PUSH
92511: LD_INT 19
92513: PUSH
92514: LD_INT 20
92516: PUSH
92517: LD_INT 21
92519: PUSH
92520: LD_INT 22
92522: PUSH
92523: LD_INT 23
92525: PUSH
92526: LD_INT 24
92528: PUSH
92529: LD_INT 25
92531: PUSH
92532: LD_INT 26
92534: PUSH
92535: LD_INT 27
92537: PUSH
92538: LD_INT 28
92540: PUSH
92541: LD_INT 29
92543: PUSH
92544: LD_INT 30
92546: PUSH
92547: LD_INT 31
92549: PUSH
92550: LD_INT 32
92552: PUSH
92553: LD_INT 33
92555: PUSH
92556: LD_INT 34
92558: PUSH
92559: LD_INT 35
92561: PUSH
92562: LD_INT 36
92564: PUSH
92565: EMPTY
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 101
92605: PUSH
92606: LD_INT 102
92608: PUSH
92609: LD_INT 103
92611: PUSH
92612: LD_INT 104
92614: PUSH
92615: LD_INT 105
92617: PUSH
92618: LD_INT 106
92620: PUSH
92621: LD_INT 107
92623: PUSH
92624: LD_INT 108
92626: PUSH
92627: LD_INT 109
92629: PUSH
92630: LD_INT 110
92632: PUSH
92633: LD_INT 111
92635: PUSH
92636: LD_INT 112
92638: PUSH
92639: LD_INT 113
92641: PUSH
92642: LD_INT 114
92644: PUSH
92645: LD_INT 115
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: ST_TO_ADDR
// if result then
92669: LD_VAR 0 1
92673: IFFALSE 92962
// begin normal :=  ;
92675: LD_ADDR_VAR 0 3
92679: PUSH
92680: LD_STRING 
92682: ST_TO_ADDR
// hardcore :=  ;
92683: LD_ADDR_VAR 0 4
92687: PUSH
92688: LD_STRING 
92690: ST_TO_ADDR
// for i = 1 to normalCounter do
92691: LD_ADDR_VAR 0 5
92695: PUSH
92696: DOUBLE
92697: LD_INT 1
92699: DEC
92700: ST_TO_ADDR
92701: LD_EXP 134
92705: PUSH
92706: FOR_TO
92707: IFFALSE 92808
// begin tmp := 0 ;
92709: LD_ADDR_VAR 0 2
92713: PUSH
92714: LD_STRING 0
92716: ST_TO_ADDR
// if result [ 1 ] then
92717: LD_VAR 0 1
92721: PUSH
92722: LD_INT 1
92724: ARRAY
92725: IFFALSE 92790
// if result [ 1 ] [ 1 ] = i then
92727: LD_VAR 0 1
92731: PUSH
92732: LD_INT 1
92734: ARRAY
92735: PUSH
92736: LD_INT 1
92738: ARRAY
92739: PUSH
92740: LD_VAR 0 5
92744: EQUAL
92745: IFFALSE 92790
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92747: LD_ADDR_VAR 0 1
92751: PUSH
92752: LD_VAR 0 1
92756: PPUSH
92757: LD_INT 1
92759: PPUSH
92760: LD_VAR 0 1
92764: PUSH
92765: LD_INT 1
92767: ARRAY
92768: PPUSH
92769: LD_INT 1
92771: PPUSH
92772: CALL_OW 3
92776: PPUSH
92777: CALL_OW 1
92781: ST_TO_ADDR
// tmp := 1 ;
92782: LD_ADDR_VAR 0 2
92786: PUSH
92787: LD_STRING 1
92789: ST_TO_ADDR
// end ; normal := normal & tmp ;
92790: LD_ADDR_VAR 0 3
92794: PUSH
92795: LD_VAR 0 3
92799: PUSH
92800: LD_VAR 0 2
92804: STR
92805: ST_TO_ADDR
// end ;
92806: GO 92706
92808: POP
92809: POP
// for i = 1 to hardcoreCounter do
92810: LD_ADDR_VAR 0 5
92814: PUSH
92815: DOUBLE
92816: LD_INT 1
92818: DEC
92819: ST_TO_ADDR
92820: LD_EXP 135
92824: PUSH
92825: FOR_TO
92826: IFFALSE 92931
// begin tmp := 0 ;
92828: LD_ADDR_VAR 0 2
92832: PUSH
92833: LD_STRING 0
92835: ST_TO_ADDR
// if result [ 2 ] then
92836: LD_VAR 0 1
92840: PUSH
92841: LD_INT 2
92843: ARRAY
92844: IFFALSE 92913
// if result [ 2 ] [ 1 ] = 100 + i then
92846: LD_VAR 0 1
92850: PUSH
92851: LD_INT 2
92853: ARRAY
92854: PUSH
92855: LD_INT 1
92857: ARRAY
92858: PUSH
92859: LD_INT 100
92861: PUSH
92862: LD_VAR 0 5
92866: PLUS
92867: EQUAL
92868: IFFALSE 92913
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92870: LD_ADDR_VAR 0 1
92874: PUSH
92875: LD_VAR 0 1
92879: PPUSH
92880: LD_INT 2
92882: PPUSH
92883: LD_VAR 0 1
92887: PUSH
92888: LD_INT 2
92890: ARRAY
92891: PPUSH
92892: LD_INT 1
92894: PPUSH
92895: CALL_OW 3
92899: PPUSH
92900: CALL_OW 1
92904: ST_TO_ADDR
// tmp := 1 ;
92905: LD_ADDR_VAR 0 2
92909: PUSH
92910: LD_STRING 1
92912: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92913: LD_ADDR_VAR 0 4
92917: PUSH
92918: LD_VAR 0 4
92922: PUSH
92923: LD_VAR 0 2
92927: STR
92928: ST_TO_ADDR
// end ;
92929: GO 92825
92931: POP
92932: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92933: LD_STRING getStreamItemsFromMission("
92935: PUSH
92936: LD_VAR 0 3
92940: STR
92941: PUSH
92942: LD_STRING ","
92944: STR
92945: PUSH
92946: LD_VAR 0 4
92950: STR
92951: PUSH
92952: LD_STRING ")
92954: STR
92955: PPUSH
92956: CALL_OW 559
// end else
92960: GO 92969
// ToLua ( getStreamItemsFromMission("","") ) ;
92962: LD_STRING getStreamItemsFromMission("","")
92964: PPUSH
92965: CALL_OW 559
// end ;
92969: LD_VAR 0 1
92973: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92974: LD_EXP 133
92978: PUSH
92979: LD_EXP 138
92983: AND
92984: IFFALSE 93108
92986: GO 92988
92988: DISABLE
92989: LD_INT 0
92991: PPUSH
92992: PPUSH
// begin enable ;
92993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92994: LD_ADDR_VAR 0 2
92998: PUSH
92999: LD_INT 22
93001: PUSH
93002: LD_OWVAR 2
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 2
93013: PUSH
93014: LD_INT 34
93016: PUSH
93017: LD_INT 7
93019: PUSH
93020: EMPTY
93021: LIST
93022: LIST
93023: PUSH
93024: LD_INT 34
93026: PUSH
93027: LD_INT 45
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 34
93036: PUSH
93037: LD_INT 28
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 34
93046: PUSH
93047: LD_INT 47
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PPUSH
93065: CALL_OW 69
93069: ST_TO_ADDR
// if not tmp then
93070: LD_VAR 0 2
93074: NOT
93075: IFFALSE 93079
// exit ;
93077: GO 93108
// for i in tmp do
93079: LD_ADDR_VAR 0 1
93083: PUSH
93084: LD_VAR 0 2
93088: PUSH
93089: FOR_IN
93090: IFFALSE 93106
// begin SetLives ( i , 0 ) ;
93092: LD_VAR 0 1
93096: PPUSH
93097: LD_INT 0
93099: PPUSH
93100: CALL_OW 234
// end ;
93104: GO 93089
93106: POP
93107: POP
// end ;
93108: PPOPN 2
93110: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93111: LD_EXP 133
93115: PUSH
93116: LD_EXP 139
93120: AND
93121: IFFALSE 93205
93123: GO 93125
93125: DISABLE
93126: LD_INT 0
93128: PPUSH
93129: PPUSH
// begin enable ;
93130: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93131: LD_ADDR_VAR 0 2
93135: PUSH
93136: LD_INT 22
93138: PUSH
93139: LD_OWVAR 2
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 32
93150: PUSH
93151: LD_INT 3
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PPUSH
93162: CALL_OW 69
93166: ST_TO_ADDR
// if not tmp then
93167: LD_VAR 0 2
93171: NOT
93172: IFFALSE 93176
// exit ;
93174: GO 93205
// for i in tmp do
93176: LD_ADDR_VAR 0 1
93180: PUSH
93181: LD_VAR 0 2
93185: PUSH
93186: FOR_IN
93187: IFFALSE 93203
// begin SetLives ( i , 0 ) ;
93189: LD_VAR 0 1
93193: PPUSH
93194: LD_INT 0
93196: PPUSH
93197: CALL_OW 234
// end ;
93201: GO 93186
93203: POP
93204: POP
// end ;
93205: PPOPN 2
93207: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93208: LD_EXP 133
93212: PUSH
93213: LD_EXP 136
93217: AND
93218: IFFALSE 93311
93220: GO 93222
93222: DISABLE
93223: LD_INT 0
93225: PPUSH
// begin enable ;
93226: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93227: LD_ADDR_VAR 0 1
93231: PUSH
93232: LD_INT 22
93234: PUSH
93235: LD_OWVAR 2
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 2
93246: PUSH
93247: LD_INT 25
93249: PUSH
93250: LD_INT 5
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: LD_INT 25
93259: PUSH
93260: LD_INT 9
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: LD_INT 25
93269: PUSH
93270: LD_INT 8
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PPUSH
93287: CALL_OW 69
93291: PUSH
93292: FOR_IN
93293: IFFALSE 93309
// begin SetClass ( i , 1 ) ;
93295: LD_VAR 0 1
93299: PPUSH
93300: LD_INT 1
93302: PPUSH
93303: CALL_OW 336
// end ;
93307: GO 93292
93309: POP
93310: POP
// end ;
93311: PPOPN 1
93313: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93314: LD_EXP 133
93318: PUSH
93319: LD_EXP 137
93323: AND
93324: PUSH
93325: LD_OWVAR 65
93329: PUSH
93330: LD_INT 7
93332: LESS
93333: AND
93334: IFFALSE 93348
93336: GO 93338
93338: DISABLE
// begin enable ;
93339: ENABLE
// game_speed := 7 ;
93340: LD_ADDR_OWVAR 65
93344: PUSH
93345: LD_INT 7
93347: ST_TO_ADDR
// end ;
93348: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93349: LD_EXP 133
93353: PUSH
93354: LD_EXP 140
93358: AND
93359: IFFALSE 93561
93361: GO 93363
93363: DISABLE
93364: LD_INT 0
93366: PPUSH
93367: PPUSH
93368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93369: LD_ADDR_VAR 0 3
93373: PUSH
93374: LD_INT 81
93376: PUSH
93377: LD_OWVAR 2
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: LD_INT 21
93388: PUSH
93389: LD_INT 1
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PPUSH
93400: CALL_OW 69
93404: ST_TO_ADDR
// if not tmp then
93405: LD_VAR 0 3
93409: NOT
93410: IFFALSE 93414
// exit ;
93412: GO 93561
// if tmp > 5 then
93414: LD_VAR 0 3
93418: PUSH
93419: LD_INT 5
93421: GREATER
93422: IFFALSE 93434
// k := 5 else
93424: LD_ADDR_VAR 0 2
93428: PUSH
93429: LD_INT 5
93431: ST_TO_ADDR
93432: GO 93444
// k := tmp ;
93434: LD_ADDR_VAR 0 2
93438: PUSH
93439: LD_VAR 0 3
93443: ST_TO_ADDR
// for i := 1 to k do
93444: LD_ADDR_VAR 0 1
93448: PUSH
93449: DOUBLE
93450: LD_INT 1
93452: DEC
93453: ST_TO_ADDR
93454: LD_VAR 0 2
93458: PUSH
93459: FOR_TO
93460: IFFALSE 93559
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93462: LD_VAR 0 3
93466: PUSH
93467: LD_VAR 0 1
93471: ARRAY
93472: PPUSH
93473: LD_VAR 0 1
93477: PUSH
93478: LD_INT 4
93480: MOD
93481: PUSH
93482: LD_INT 1
93484: PLUS
93485: PPUSH
93486: CALL_OW 259
93490: PUSH
93491: LD_INT 10
93493: LESS
93494: IFFALSE 93557
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93496: LD_VAR 0 3
93500: PUSH
93501: LD_VAR 0 1
93505: ARRAY
93506: PPUSH
93507: LD_VAR 0 1
93511: PUSH
93512: LD_INT 4
93514: MOD
93515: PUSH
93516: LD_INT 1
93518: PLUS
93519: PPUSH
93520: LD_VAR 0 3
93524: PUSH
93525: LD_VAR 0 1
93529: ARRAY
93530: PPUSH
93531: LD_VAR 0 1
93535: PUSH
93536: LD_INT 4
93538: MOD
93539: PUSH
93540: LD_INT 1
93542: PLUS
93543: PPUSH
93544: CALL_OW 259
93548: PUSH
93549: LD_INT 1
93551: PLUS
93552: PPUSH
93553: CALL_OW 237
93557: GO 93459
93559: POP
93560: POP
// end ;
93561: PPOPN 3
93563: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93564: LD_EXP 133
93568: PUSH
93569: LD_EXP 141
93573: AND
93574: IFFALSE 93594
93576: GO 93578
93578: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93579: LD_INT 4
93581: PPUSH
93582: LD_OWVAR 2
93586: PPUSH
93587: LD_INT 0
93589: PPUSH
93590: CALL_OW 324
93594: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93595: LD_EXP 133
93599: PUSH
93600: LD_EXP 170
93604: AND
93605: IFFALSE 93625
93607: GO 93609
93609: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93610: LD_INT 19
93612: PPUSH
93613: LD_OWVAR 2
93617: PPUSH
93618: LD_INT 0
93620: PPUSH
93621: CALL_OW 324
93625: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93626: LD_EXP 133
93630: PUSH
93631: LD_EXP 142
93635: AND
93636: IFFALSE 93738
93638: GO 93640
93640: DISABLE
93641: LD_INT 0
93643: PPUSH
93644: PPUSH
// begin enable ;
93645: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93646: LD_ADDR_VAR 0 2
93650: PUSH
93651: LD_INT 22
93653: PUSH
93654: LD_OWVAR 2
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 2
93665: PUSH
93666: LD_INT 34
93668: PUSH
93669: LD_INT 11
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: LD_INT 34
93678: PUSH
93679: LD_INT 30
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: LIST
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PPUSH
93695: CALL_OW 69
93699: ST_TO_ADDR
// if not tmp then
93700: LD_VAR 0 2
93704: NOT
93705: IFFALSE 93709
// exit ;
93707: GO 93738
// for i in tmp do
93709: LD_ADDR_VAR 0 1
93713: PUSH
93714: LD_VAR 0 2
93718: PUSH
93719: FOR_IN
93720: IFFALSE 93736
// begin SetLives ( i , 0 ) ;
93722: LD_VAR 0 1
93726: PPUSH
93727: LD_INT 0
93729: PPUSH
93730: CALL_OW 234
// end ;
93734: GO 93719
93736: POP
93737: POP
// end ;
93738: PPOPN 2
93740: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93741: LD_EXP 133
93745: PUSH
93746: LD_EXP 143
93750: AND
93751: IFFALSE 93771
93753: GO 93755
93755: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93756: LD_INT 32
93758: PPUSH
93759: LD_OWVAR 2
93763: PPUSH
93764: LD_INT 0
93766: PPUSH
93767: CALL_OW 324
93771: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93772: LD_EXP 133
93776: PUSH
93777: LD_EXP 144
93781: AND
93782: IFFALSE 93963
93784: GO 93786
93786: DISABLE
93787: LD_INT 0
93789: PPUSH
93790: PPUSH
93791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93792: LD_ADDR_VAR 0 2
93796: PUSH
93797: LD_INT 22
93799: PUSH
93800: LD_OWVAR 2
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 33
93811: PUSH
93812: LD_INT 3
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PPUSH
93823: CALL_OW 69
93827: ST_TO_ADDR
// if not tmp then
93828: LD_VAR 0 2
93832: NOT
93833: IFFALSE 93837
// exit ;
93835: GO 93963
// side := 0 ;
93837: LD_ADDR_VAR 0 3
93841: PUSH
93842: LD_INT 0
93844: ST_TO_ADDR
// for i := 1 to 8 do
93845: LD_ADDR_VAR 0 1
93849: PUSH
93850: DOUBLE
93851: LD_INT 1
93853: DEC
93854: ST_TO_ADDR
93855: LD_INT 8
93857: PUSH
93858: FOR_TO
93859: IFFALSE 93907
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93861: LD_OWVAR 2
93865: PUSH
93866: LD_VAR 0 1
93870: NONEQUAL
93871: PUSH
93872: LD_OWVAR 2
93876: PPUSH
93877: LD_VAR 0 1
93881: PPUSH
93882: CALL_OW 81
93886: PUSH
93887: LD_INT 2
93889: EQUAL
93890: AND
93891: IFFALSE 93905
// begin side := i ;
93893: LD_ADDR_VAR 0 3
93897: PUSH
93898: LD_VAR 0 1
93902: ST_TO_ADDR
// break ;
93903: GO 93907
// end ;
93905: GO 93858
93907: POP
93908: POP
// if not side then
93909: LD_VAR 0 3
93913: NOT
93914: IFFALSE 93918
// exit ;
93916: GO 93963
// for i := 1 to tmp do
93918: LD_ADDR_VAR 0 1
93922: PUSH
93923: DOUBLE
93924: LD_INT 1
93926: DEC
93927: ST_TO_ADDR
93928: LD_VAR 0 2
93932: PUSH
93933: FOR_TO
93934: IFFALSE 93961
// if Prob ( 60 ) then
93936: LD_INT 60
93938: PPUSH
93939: CALL_OW 13
93943: IFFALSE 93959
// SetSide ( i , side ) ;
93945: LD_VAR 0 1
93949: PPUSH
93950: LD_VAR 0 3
93954: PPUSH
93955: CALL_OW 235
93959: GO 93933
93961: POP
93962: POP
// end ;
93963: PPOPN 3
93965: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93966: LD_EXP 133
93970: PUSH
93971: LD_EXP 146
93975: AND
93976: IFFALSE 94095
93978: GO 93980
93980: DISABLE
93981: LD_INT 0
93983: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93984: LD_ADDR_VAR 0 1
93988: PUSH
93989: LD_INT 22
93991: PUSH
93992: LD_OWVAR 2
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 21
94003: PUSH
94004: LD_INT 1
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 3
94013: PUSH
94014: LD_INT 23
94016: PUSH
94017: LD_INT 0
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: LIST
94032: PPUSH
94033: CALL_OW 69
94037: PUSH
94038: FOR_IN
94039: IFFALSE 94093
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94041: LD_VAR 0 1
94045: PPUSH
94046: CALL_OW 257
94050: PUSH
94051: LD_INT 1
94053: PUSH
94054: LD_INT 2
94056: PUSH
94057: LD_INT 3
94059: PUSH
94060: LD_INT 4
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: IN
94069: IFFALSE 94091
// SetClass ( un , rand ( 1 , 4 ) ) ;
94071: LD_VAR 0 1
94075: PPUSH
94076: LD_INT 1
94078: PPUSH
94079: LD_INT 4
94081: PPUSH
94082: CALL_OW 12
94086: PPUSH
94087: CALL_OW 336
94091: GO 94038
94093: POP
94094: POP
// end ;
94095: PPOPN 1
94097: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94098: LD_EXP 133
94102: PUSH
94103: LD_EXP 145
94107: AND
94108: IFFALSE 94187
94110: GO 94112
94112: DISABLE
94113: LD_INT 0
94115: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94116: LD_ADDR_VAR 0 1
94120: PUSH
94121: LD_INT 22
94123: PUSH
94124: LD_OWVAR 2
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 21
94135: PUSH
94136: LD_INT 3
94138: PUSH
94139: EMPTY
94140: LIST
94141: LIST
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PPUSH
94147: CALL_OW 69
94151: ST_TO_ADDR
// if not tmp then
94152: LD_VAR 0 1
94156: NOT
94157: IFFALSE 94161
// exit ;
94159: GO 94187
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94161: LD_VAR 0 1
94165: PUSH
94166: LD_INT 1
94168: PPUSH
94169: LD_VAR 0 1
94173: PPUSH
94174: CALL_OW 12
94178: ARRAY
94179: PPUSH
94180: LD_INT 100
94182: PPUSH
94183: CALL_OW 234
// end ;
94187: PPOPN 1
94189: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94190: LD_EXP 133
94194: PUSH
94195: LD_EXP 147
94199: AND
94200: IFFALSE 94298
94202: GO 94204
94204: DISABLE
94205: LD_INT 0
94207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94208: LD_ADDR_VAR 0 1
94212: PUSH
94213: LD_INT 22
94215: PUSH
94216: LD_OWVAR 2
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 21
94227: PUSH
94228: LD_INT 1
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PPUSH
94239: CALL_OW 69
94243: ST_TO_ADDR
// if not tmp then
94244: LD_VAR 0 1
94248: NOT
94249: IFFALSE 94253
// exit ;
94251: GO 94298
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94253: LD_VAR 0 1
94257: PUSH
94258: LD_INT 1
94260: PPUSH
94261: LD_VAR 0 1
94265: PPUSH
94266: CALL_OW 12
94270: ARRAY
94271: PPUSH
94272: LD_INT 1
94274: PPUSH
94275: LD_INT 4
94277: PPUSH
94278: CALL_OW 12
94282: PPUSH
94283: LD_INT 3000
94285: PPUSH
94286: LD_INT 9000
94288: PPUSH
94289: CALL_OW 12
94293: PPUSH
94294: CALL_OW 492
// end ;
94298: PPOPN 1
94300: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94301: LD_EXP 133
94305: PUSH
94306: LD_EXP 148
94310: AND
94311: IFFALSE 94331
94313: GO 94315
94315: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94316: LD_INT 1
94318: PPUSH
94319: LD_OWVAR 2
94323: PPUSH
94324: LD_INT 0
94326: PPUSH
94327: CALL_OW 324
94331: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94332: LD_EXP 133
94336: PUSH
94337: LD_EXP 149
94341: AND
94342: IFFALSE 94425
94344: GO 94346
94346: DISABLE
94347: LD_INT 0
94349: PPUSH
94350: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94351: LD_ADDR_VAR 0 2
94355: PUSH
94356: LD_INT 22
94358: PUSH
94359: LD_OWVAR 2
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 21
94370: PUSH
94371: LD_INT 3
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PPUSH
94382: CALL_OW 69
94386: ST_TO_ADDR
// if not tmp then
94387: LD_VAR 0 2
94391: NOT
94392: IFFALSE 94396
// exit ;
94394: GO 94425
// for i in tmp do
94396: LD_ADDR_VAR 0 1
94400: PUSH
94401: LD_VAR 0 2
94405: PUSH
94406: FOR_IN
94407: IFFALSE 94423
// SetBLevel ( i , 10 ) ;
94409: LD_VAR 0 1
94413: PPUSH
94414: LD_INT 10
94416: PPUSH
94417: CALL_OW 241
94421: GO 94406
94423: POP
94424: POP
// end ;
94425: PPOPN 2
94427: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94428: LD_EXP 133
94432: PUSH
94433: LD_EXP 150
94437: AND
94438: IFFALSE 94549
94440: GO 94442
94442: DISABLE
94443: LD_INT 0
94445: PPUSH
94446: PPUSH
94447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94448: LD_ADDR_VAR 0 3
94452: PUSH
94453: LD_INT 22
94455: PUSH
94456: LD_OWVAR 2
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 25
94467: PUSH
94468: LD_INT 1
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PPUSH
94479: CALL_OW 69
94483: ST_TO_ADDR
// if not tmp then
94484: LD_VAR 0 3
94488: NOT
94489: IFFALSE 94493
// exit ;
94491: GO 94549
// un := tmp [ rand ( 1 , tmp ) ] ;
94493: LD_ADDR_VAR 0 2
94497: PUSH
94498: LD_VAR 0 3
94502: PUSH
94503: LD_INT 1
94505: PPUSH
94506: LD_VAR 0 3
94510: PPUSH
94511: CALL_OW 12
94515: ARRAY
94516: ST_TO_ADDR
// if Crawls ( un ) then
94517: LD_VAR 0 2
94521: PPUSH
94522: CALL_OW 318
94526: IFFALSE 94537
// ComWalk ( un ) ;
94528: LD_VAR 0 2
94532: PPUSH
94533: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94537: LD_VAR 0 2
94541: PPUSH
94542: LD_INT 5
94544: PPUSH
94545: CALL_OW 336
// end ;
94549: PPOPN 3
94551: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
94552: LD_EXP 133
94556: PUSH
94557: LD_EXP 151
94561: AND
94562: PUSH
94563: LD_OWVAR 67
94567: PUSH
94568: LD_INT 3
94570: LESS
94571: AND
94572: IFFALSE 94591
94574: GO 94576
94576: DISABLE
// Difficulty := Difficulty + 1 ;
94577: LD_ADDR_OWVAR 67
94581: PUSH
94582: LD_OWVAR 67
94586: PUSH
94587: LD_INT 1
94589: PLUS
94590: ST_TO_ADDR
94591: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94592: LD_EXP 133
94596: PUSH
94597: LD_EXP 152
94601: AND
94602: IFFALSE 94705
94604: GO 94606
94606: DISABLE
94607: LD_INT 0
94609: PPUSH
// begin for i := 1 to 5 do
94610: LD_ADDR_VAR 0 1
94614: PUSH
94615: DOUBLE
94616: LD_INT 1
94618: DEC
94619: ST_TO_ADDR
94620: LD_INT 5
94622: PUSH
94623: FOR_TO
94624: IFFALSE 94703
// begin uc_nation := nation_nature ;
94626: LD_ADDR_OWVAR 21
94630: PUSH
94631: LD_INT 0
94633: ST_TO_ADDR
// uc_side := 0 ;
94634: LD_ADDR_OWVAR 20
94638: PUSH
94639: LD_INT 0
94641: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94642: LD_ADDR_OWVAR 29
94646: PUSH
94647: LD_INT 12
94649: PUSH
94650: LD_INT 12
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: ST_TO_ADDR
// hc_agressivity := 20 ;
94657: LD_ADDR_OWVAR 35
94661: PUSH
94662: LD_INT 20
94664: ST_TO_ADDR
// hc_class := class_tiger ;
94665: LD_ADDR_OWVAR 28
94669: PUSH
94670: LD_INT 14
94672: ST_TO_ADDR
// hc_gallery :=  ;
94673: LD_ADDR_OWVAR 33
94677: PUSH
94678: LD_STRING 
94680: ST_TO_ADDR
// hc_name :=  ;
94681: LD_ADDR_OWVAR 26
94685: PUSH
94686: LD_STRING 
94688: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94689: CALL_OW 44
94693: PPUSH
94694: LD_INT 0
94696: PPUSH
94697: CALL_OW 51
// end ;
94701: GO 94623
94703: POP
94704: POP
// end ;
94705: PPOPN 1
94707: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94708: LD_EXP 133
94712: PUSH
94713: LD_EXP 153
94717: AND
94718: IFFALSE 94727
94720: GO 94722
94722: DISABLE
// StreamSibBomb ;
94723: CALL 94728 0 0
94727: END
// export function StreamSibBomb ; var i , x , y ; begin
94728: LD_INT 0
94730: PPUSH
94731: PPUSH
94732: PPUSH
94733: PPUSH
// result := false ;
94734: LD_ADDR_VAR 0 1
94738: PUSH
94739: LD_INT 0
94741: ST_TO_ADDR
// for i := 1 to 16 do
94742: LD_ADDR_VAR 0 2
94746: PUSH
94747: DOUBLE
94748: LD_INT 1
94750: DEC
94751: ST_TO_ADDR
94752: LD_INT 16
94754: PUSH
94755: FOR_TO
94756: IFFALSE 94955
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94758: LD_ADDR_VAR 0 3
94762: PUSH
94763: LD_INT 10
94765: PUSH
94766: LD_INT 20
94768: PUSH
94769: LD_INT 30
94771: PUSH
94772: LD_INT 40
94774: PUSH
94775: LD_INT 50
94777: PUSH
94778: LD_INT 60
94780: PUSH
94781: LD_INT 70
94783: PUSH
94784: LD_INT 80
94786: PUSH
94787: LD_INT 90
94789: PUSH
94790: LD_INT 100
94792: PUSH
94793: LD_INT 110
94795: PUSH
94796: LD_INT 120
94798: PUSH
94799: LD_INT 130
94801: PUSH
94802: LD_INT 140
94804: PUSH
94805: LD_INT 150
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 1
94827: PPUSH
94828: LD_INT 15
94830: PPUSH
94831: CALL_OW 12
94835: ARRAY
94836: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94837: LD_ADDR_VAR 0 4
94841: PUSH
94842: LD_INT 10
94844: PUSH
94845: LD_INT 20
94847: PUSH
94848: LD_INT 30
94850: PUSH
94851: LD_INT 40
94853: PUSH
94854: LD_INT 50
94856: PUSH
94857: LD_INT 60
94859: PUSH
94860: LD_INT 70
94862: PUSH
94863: LD_INT 80
94865: PUSH
94866: LD_INT 90
94868: PUSH
94869: LD_INT 100
94871: PUSH
94872: LD_INT 110
94874: PUSH
94875: LD_INT 120
94877: PUSH
94878: LD_INT 130
94880: PUSH
94881: LD_INT 140
94883: PUSH
94884: LD_INT 150
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 1
94906: PPUSH
94907: LD_INT 15
94909: PPUSH
94910: CALL_OW 12
94914: ARRAY
94915: ST_TO_ADDR
// if ValidHex ( x , y ) then
94916: LD_VAR 0 3
94920: PPUSH
94921: LD_VAR 0 4
94925: PPUSH
94926: CALL_OW 488
94930: IFFALSE 94953
// begin result := [ x , y ] ;
94932: LD_ADDR_VAR 0 1
94936: PUSH
94937: LD_VAR 0 3
94941: PUSH
94942: LD_VAR 0 4
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: ST_TO_ADDR
// break ;
94951: GO 94955
// end ; end ;
94953: GO 94755
94955: POP
94956: POP
// if result then
94957: LD_VAR 0 1
94961: IFFALSE 95021
// begin ToLua ( playSibBomb() ) ;
94963: LD_STRING playSibBomb()
94965: PPUSH
94966: CALL_OW 559
// wait ( 0 0$14 ) ;
94970: LD_INT 490
94972: PPUSH
94973: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94977: LD_VAR 0 1
94981: PUSH
94982: LD_INT 1
94984: ARRAY
94985: PPUSH
94986: LD_VAR 0 1
94990: PUSH
94991: LD_INT 2
94993: ARRAY
94994: PPUSH
94995: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94999: LD_VAR 0 1
95003: PUSH
95004: LD_INT 1
95006: ARRAY
95007: PPUSH
95008: LD_VAR 0 1
95012: PUSH
95013: LD_INT 2
95015: ARRAY
95016: PPUSH
95017: CALL_OW 429
// end ; end ;
95021: LD_VAR 0 1
95025: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95026: LD_EXP 133
95030: PUSH
95031: LD_EXP 155
95035: AND
95036: IFFALSE 95048
95038: GO 95040
95040: DISABLE
// YouLost (  ) ;
95041: LD_STRING 
95043: PPUSH
95044: CALL_OW 104
95048: END
// every 0 0$1 trigger StreamModeActive and sFog do
95049: LD_EXP 133
95053: PUSH
95054: LD_EXP 154
95058: AND
95059: IFFALSE 95073
95061: GO 95063
95063: DISABLE
// FogOff ( your_side ) ;
95064: LD_OWVAR 2
95068: PPUSH
95069: CALL_OW 344
95073: END
// every 0 0$1 trigger StreamModeActive and sSun do
95074: LD_EXP 133
95078: PUSH
95079: LD_EXP 156
95083: AND
95084: IFFALSE 95112
95086: GO 95088
95088: DISABLE
// begin solar_recharge_percent := 0 ;
95089: LD_ADDR_OWVAR 79
95093: PUSH
95094: LD_INT 0
95096: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95097: LD_INT 10500
95099: PPUSH
95100: CALL_OW 67
// solar_recharge_percent := 100 ;
95104: LD_ADDR_OWVAR 79
95108: PUSH
95109: LD_INT 100
95111: ST_TO_ADDR
// end ;
95112: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95113: LD_EXP 133
95117: PUSH
95118: LD_EXP 157
95122: AND
95123: IFFALSE 95362
95125: GO 95127
95127: DISABLE
95128: LD_INT 0
95130: PPUSH
95131: PPUSH
95132: PPUSH
// begin tmp := [ ] ;
95133: LD_ADDR_VAR 0 3
95137: PUSH
95138: EMPTY
95139: ST_TO_ADDR
// for i := 1 to 6 do
95140: LD_ADDR_VAR 0 1
95144: PUSH
95145: DOUBLE
95146: LD_INT 1
95148: DEC
95149: ST_TO_ADDR
95150: LD_INT 6
95152: PUSH
95153: FOR_TO
95154: IFFALSE 95259
// begin uc_nation := nation_nature ;
95156: LD_ADDR_OWVAR 21
95160: PUSH
95161: LD_INT 0
95163: ST_TO_ADDR
// uc_side := 0 ;
95164: LD_ADDR_OWVAR 20
95168: PUSH
95169: LD_INT 0
95171: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95172: LD_ADDR_OWVAR 29
95176: PUSH
95177: LD_INT 12
95179: PUSH
95180: LD_INT 12
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: ST_TO_ADDR
// hc_agressivity := 20 ;
95187: LD_ADDR_OWVAR 35
95191: PUSH
95192: LD_INT 20
95194: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95195: LD_ADDR_OWVAR 28
95199: PUSH
95200: LD_INT 17
95202: ST_TO_ADDR
// hc_gallery :=  ;
95203: LD_ADDR_OWVAR 33
95207: PUSH
95208: LD_STRING 
95210: ST_TO_ADDR
// hc_name :=  ;
95211: LD_ADDR_OWVAR 26
95215: PUSH
95216: LD_STRING 
95218: ST_TO_ADDR
// un := CreateHuman ;
95219: LD_ADDR_VAR 0 2
95223: PUSH
95224: CALL_OW 44
95228: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95229: LD_VAR 0 2
95233: PPUSH
95234: LD_INT 1
95236: PPUSH
95237: CALL_OW 51
// tmp := tmp ^ un ;
95241: LD_ADDR_VAR 0 3
95245: PUSH
95246: LD_VAR 0 3
95250: PUSH
95251: LD_VAR 0 2
95255: ADD
95256: ST_TO_ADDR
// end ;
95257: GO 95153
95259: POP
95260: POP
// repeat wait ( 0 0$1 ) ;
95261: LD_INT 35
95263: PPUSH
95264: CALL_OW 67
// for un in tmp do
95268: LD_ADDR_VAR 0 2
95272: PUSH
95273: LD_VAR 0 3
95277: PUSH
95278: FOR_IN
95279: IFFALSE 95353
// begin if IsDead ( un ) then
95281: LD_VAR 0 2
95285: PPUSH
95286: CALL_OW 301
95290: IFFALSE 95310
// begin tmp := tmp diff un ;
95292: LD_ADDR_VAR 0 3
95296: PUSH
95297: LD_VAR 0 3
95301: PUSH
95302: LD_VAR 0 2
95306: DIFF
95307: ST_TO_ADDR
// continue ;
95308: GO 95278
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95310: LD_VAR 0 2
95314: PPUSH
95315: LD_INT 3
95317: PUSH
95318: LD_INT 22
95320: PUSH
95321: LD_INT 0
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PPUSH
95332: CALL_OW 69
95336: PPUSH
95337: LD_VAR 0 2
95341: PPUSH
95342: CALL_OW 74
95346: PPUSH
95347: CALL_OW 115
// end ;
95351: GO 95278
95353: POP
95354: POP
// until not tmp ;
95355: LD_VAR 0 3
95359: NOT
95360: IFFALSE 95261
// end ;
95362: PPOPN 3
95364: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95365: LD_EXP 133
95369: PUSH
95370: LD_EXP 158
95374: AND
95375: IFFALSE 95429
95377: GO 95379
95379: DISABLE
// begin ToLua ( displayTroll(); ) ;
95380: LD_STRING displayTroll();
95382: PPUSH
95383: CALL_OW 559
// wait ( 3 3$00 ) ;
95387: LD_INT 6300
95389: PPUSH
95390: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95394: LD_STRING hideTroll();
95396: PPUSH
95397: CALL_OW 559
// wait ( 1 1$00 ) ;
95401: LD_INT 2100
95403: PPUSH
95404: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95408: LD_STRING displayTroll();
95410: PPUSH
95411: CALL_OW 559
// wait ( 1 1$00 ) ;
95415: LD_INT 2100
95417: PPUSH
95418: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95422: LD_STRING hideTroll();
95424: PPUSH
95425: CALL_OW 559
// end ;
95429: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95430: LD_EXP 133
95434: PUSH
95435: LD_EXP 159
95439: AND
95440: IFFALSE 95503
95442: GO 95444
95444: DISABLE
95445: LD_INT 0
95447: PPUSH
// begin p := 0 ;
95448: LD_ADDR_VAR 0 1
95452: PUSH
95453: LD_INT 0
95455: ST_TO_ADDR
// repeat game_speed := 1 ;
95456: LD_ADDR_OWVAR 65
95460: PUSH
95461: LD_INT 1
95463: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95464: LD_INT 35
95466: PPUSH
95467: CALL_OW 67
// p := p + 1 ;
95471: LD_ADDR_VAR 0 1
95475: PUSH
95476: LD_VAR 0 1
95480: PUSH
95481: LD_INT 1
95483: PLUS
95484: ST_TO_ADDR
// until p >= 60 ;
95485: LD_VAR 0 1
95489: PUSH
95490: LD_INT 60
95492: GREATEREQUAL
95493: IFFALSE 95456
// game_speed := 4 ;
95495: LD_ADDR_OWVAR 65
95499: PUSH
95500: LD_INT 4
95502: ST_TO_ADDR
// end ;
95503: PPOPN 1
95505: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95506: LD_EXP 133
95510: PUSH
95511: LD_EXP 160
95515: AND
95516: IFFALSE 95662
95518: GO 95520
95520: DISABLE
95521: LD_INT 0
95523: PPUSH
95524: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95525: LD_ADDR_VAR 0 1
95529: PUSH
95530: LD_INT 22
95532: PUSH
95533: LD_OWVAR 2
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 2
95544: PUSH
95545: LD_INT 30
95547: PUSH
95548: LD_INT 0
95550: PUSH
95551: EMPTY
95552: LIST
95553: LIST
95554: PUSH
95555: LD_INT 30
95557: PUSH
95558: LD_INT 1
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: LIST
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PPUSH
95574: CALL_OW 69
95578: ST_TO_ADDR
// if not depot then
95579: LD_VAR 0 1
95583: NOT
95584: IFFALSE 95588
// exit ;
95586: GO 95662
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95588: LD_ADDR_VAR 0 2
95592: PUSH
95593: LD_VAR 0 1
95597: PUSH
95598: LD_INT 1
95600: PPUSH
95601: LD_VAR 0 1
95605: PPUSH
95606: CALL_OW 12
95610: ARRAY
95611: PPUSH
95612: CALL_OW 274
95616: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95617: LD_VAR 0 2
95621: PPUSH
95622: LD_INT 1
95624: PPUSH
95625: LD_INT 0
95627: PPUSH
95628: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95632: LD_VAR 0 2
95636: PPUSH
95637: LD_INT 2
95639: PPUSH
95640: LD_INT 0
95642: PPUSH
95643: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95647: LD_VAR 0 2
95651: PPUSH
95652: LD_INT 3
95654: PPUSH
95655: LD_INT 0
95657: PPUSH
95658: CALL_OW 277
// end ;
95662: PPOPN 2
95664: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95665: LD_EXP 133
95669: PUSH
95670: LD_EXP 161
95674: AND
95675: IFFALSE 95772
95677: GO 95679
95679: DISABLE
95680: LD_INT 0
95682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95683: LD_ADDR_VAR 0 1
95687: PUSH
95688: LD_INT 22
95690: PUSH
95691: LD_OWVAR 2
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 21
95702: PUSH
95703: LD_INT 1
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: LD_INT 3
95712: PUSH
95713: LD_INT 23
95715: PUSH
95716: LD_INT 0
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: LIST
95731: PPUSH
95732: CALL_OW 69
95736: ST_TO_ADDR
// if not tmp then
95737: LD_VAR 0 1
95741: NOT
95742: IFFALSE 95746
// exit ;
95744: GO 95772
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95746: LD_VAR 0 1
95750: PUSH
95751: LD_INT 1
95753: PPUSH
95754: LD_VAR 0 1
95758: PPUSH
95759: CALL_OW 12
95763: ARRAY
95764: PPUSH
95765: LD_INT 200
95767: PPUSH
95768: CALL_OW 234
// end ;
95772: PPOPN 1
95774: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95775: LD_EXP 133
95779: PUSH
95780: LD_EXP 162
95784: AND
95785: IFFALSE 95864
95787: GO 95789
95789: DISABLE
95790: LD_INT 0
95792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95793: LD_ADDR_VAR 0 1
95797: PUSH
95798: LD_INT 22
95800: PUSH
95801: LD_OWVAR 2
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: LD_INT 21
95812: PUSH
95813: LD_INT 2
95815: PUSH
95816: EMPTY
95817: LIST
95818: LIST
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: PPUSH
95824: CALL_OW 69
95828: ST_TO_ADDR
// if not tmp then
95829: LD_VAR 0 1
95833: NOT
95834: IFFALSE 95838
// exit ;
95836: GO 95864
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95838: LD_VAR 0 1
95842: PUSH
95843: LD_INT 1
95845: PPUSH
95846: LD_VAR 0 1
95850: PPUSH
95851: CALL_OW 12
95855: ARRAY
95856: PPUSH
95857: LD_INT 60
95859: PPUSH
95860: CALL_OW 234
// end ;
95864: PPOPN 1
95866: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95867: LD_EXP 133
95871: PUSH
95872: LD_EXP 163
95876: AND
95877: IFFALSE 95976
95879: GO 95881
95881: DISABLE
95882: LD_INT 0
95884: PPUSH
95885: PPUSH
// begin enable ;
95886: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95887: LD_ADDR_VAR 0 1
95891: PUSH
95892: LD_INT 22
95894: PUSH
95895: LD_OWVAR 2
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 61
95906: PUSH
95907: EMPTY
95908: LIST
95909: PUSH
95910: LD_INT 33
95912: PUSH
95913: LD_INT 2
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: LIST
95924: PPUSH
95925: CALL_OW 69
95929: ST_TO_ADDR
// if not tmp then
95930: LD_VAR 0 1
95934: NOT
95935: IFFALSE 95939
// exit ;
95937: GO 95976
// for i in tmp do
95939: LD_ADDR_VAR 0 2
95943: PUSH
95944: LD_VAR 0 1
95948: PUSH
95949: FOR_IN
95950: IFFALSE 95974
// if IsControledBy ( i ) then
95952: LD_VAR 0 2
95956: PPUSH
95957: CALL_OW 312
95961: IFFALSE 95972
// ComUnlink ( i ) ;
95963: LD_VAR 0 2
95967: PPUSH
95968: CALL_OW 136
95972: GO 95949
95974: POP
95975: POP
// end ;
95976: PPOPN 2
95978: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95979: LD_EXP 133
95983: PUSH
95984: LD_EXP 164
95988: AND
95989: IFFALSE 96129
95991: GO 95993
95993: DISABLE
95994: LD_INT 0
95996: PPUSH
95997: PPUSH
// begin ToLua ( displayPowell(); ) ;
95998: LD_STRING displayPowell();
96000: PPUSH
96001: CALL_OW 559
// uc_side := 0 ;
96005: LD_ADDR_OWVAR 20
96009: PUSH
96010: LD_INT 0
96012: ST_TO_ADDR
// uc_nation := 2 ;
96013: LD_ADDR_OWVAR 21
96017: PUSH
96018: LD_INT 2
96020: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96021: LD_ADDR_OWVAR 37
96025: PUSH
96026: LD_INT 14
96028: ST_TO_ADDR
// vc_engine := engine_siberite ;
96029: LD_ADDR_OWVAR 39
96033: PUSH
96034: LD_INT 3
96036: ST_TO_ADDR
// vc_control := control_apeman ;
96037: LD_ADDR_OWVAR 38
96041: PUSH
96042: LD_INT 5
96044: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96045: LD_ADDR_OWVAR 40
96049: PUSH
96050: LD_INT 29
96052: ST_TO_ADDR
// un := CreateVehicle ;
96053: LD_ADDR_VAR 0 2
96057: PUSH
96058: CALL_OW 45
96062: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96063: LD_VAR 0 2
96067: PPUSH
96068: LD_INT 1
96070: PPUSH
96071: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96075: LD_INT 35
96077: PPUSH
96078: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96082: LD_VAR 0 2
96086: PPUSH
96087: LD_INT 22
96089: PUSH
96090: LD_OWVAR 2
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PPUSH
96099: CALL_OW 69
96103: PPUSH
96104: LD_VAR 0 2
96108: PPUSH
96109: CALL_OW 74
96113: PPUSH
96114: CALL_OW 115
// until IsDead ( un ) ;
96118: LD_VAR 0 2
96122: PPUSH
96123: CALL_OW 301
96127: IFFALSE 96075
// end ;
96129: PPOPN 2
96131: END
// every 0 0$1 trigger StreamModeActive and sStu do
96132: LD_EXP 133
96136: PUSH
96137: LD_EXP 172
96141: AND
96142: IFFALSE 96158
96144: GO 96146
96146: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96147: LD_STRING displayStucuk();
96149: PPUSH
96150: CALL_OW 559
// ResetFog ;
96154: CALL_OW 335
// end ;
96158: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96159: LD_EXP 133
96163: PUSH
96164: LD_EXP 165
96168: AND
96169: IFFALSE 96310
96171: GO 96173
96173: DISABLE
96174: LD_INT 0
96176: PPUSH
96177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96178: LD_ADDR_VAR 0 2
96182: PUSH
96183: LD_INT 22
96185: PUSH
96186: LD_OWVAR 2
96190: PUSH
96191: EMPTY
96192: LIST
96193: LIST
96194: PUSH
96195: LD_INT 21
96197: PUSH
96198: LD_INT 1
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: PUSH
96205: EMPTY
96206: LIST
96207: LIST
96208: PPUSH
96209: CALL_OW 69
96213: ST_TO_ADDR
// if not tmp then
96214: LD_VAR 0 2
96218: NOT
96219: IFFALSE 96223
// exit ;
96221: GO 96310
// un := tmp [ rand ( 1 , tmp ) ] ;
96223: LD_ADDR_VAR 0 1
96227: PUSH
96228: LD_VAR 0 2
96232: PUSH
96233: LD_INT 1
96235: PPUSH
96236: LD_VAR 0 2
96240: PPUSH
96241: CALL_OW 12
96245: ARRAY
96246: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96247: LD_VAR 0 1
96251: PPUSH
96252: LD_INT 0
96254: PPUSH
96255: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96259: LD_VAR 0 1
96263: PPUSH
96264: LD_OWVAR 3
96268: PUSH
96269: LD_VAR 0 1
96273: DIFF
96274: PPUSH
96275: LD_VAR 0 1
96279: PPUSH
96280: CALL_OW 74
96284: PPUSH
96285: CALL_OW 115
// wait ( 0 0$20 ) ;
96289: LD_INT 700
96291: PPUSH
96292: CALL_OW 67
// SetSide ( un , your_side ) ;
96296: LD_VAR 0 1
96300: PPUSH
96301: LD_OWVAR 2
96305: PPUSH
96306: CALL_OW 235
// end ;
96310: PPOPN 2
96312: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96313: LD_EXP 133
96317: PUSH
96318: LD_EXP 166
96322: AND
96323: IFFALSE 96429
96325: GO 96327
96327: DISABLE
96328: LD_INT 0
96330: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96331: LD_ADDR_VAR 0 1
96335: PUSH
96336: LD_INT 22
96338: PUSH
96339: LD_OWVAR 2
96343: PUSH
96344: EMPTY
96345: LIST
96346: LIST
96347: PUSH
96348: LD_INT 2
96350: PUSH
96351: LD_INT 30
96353: PUSH
96354: LD_INT 0
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 30
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: LIST
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: PPUSH
96380: CALL_OW 69
96384: ST_TO_ADDR
// if not depot then
96385: LD_VAR 0 1
96389: NOT
96390: IFFALSE 96394
// exit ;
96392: GO 96429
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96394: LD_VAR 0 1
96398: PUSH
96399: LD_INT 1
96401: ARRAY
96402: PPUSH
96403: CALL_OW 250
96407: PPUSH
96408: LD_VAR 0 1
96412: PUSH
96413: LD_INT 1
96415: ARRAY
96416: PPUSH
96417: CALL_OW 251
96421: PPUSH
96422: LD_INT 70
96424: PPUSH
96425: CALL_OW 495
// end ;
96429: PPOPN 1
96431: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96432: LD_EXP 133
96436: PUSH
96437: LD_EXP 167
96441: AND
96442: IFFALSE 96653
96444: GO 96446
96446: DISABLE
96447: LD_INT 0
96449: PPUSH
96450: PPUSH
96451: PPUSH
96452: PPUSH
96453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96454: LD_ADDR_VAR 0 5
96458: PUSH
96459: LD_INT 22
96461: PUSH
96462: LD_OWVAR 2
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 21
96473: PUSH
96474: LD_INT 1
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PPUSH
96485: CALL_OW 69
96489: ST_TO_ADDR
// if not tmp then
96490: LD_VAR 0 5
96494: NOT
96495: IFFALSE 96499
// exit ;
96497: GO 96653
// for i in tmp do
96499: LD_ADDR_VAR 0 1
96503: PUSH
96504: LD_VAR 0 5
96508: PUSH
96509: FOR_IN
96510: IFFALSE 96651
// begin d := rand ( 0 , 5 ) ;
96512: LD_ADDR_VAR 0 4
96516: PUSH
96517: LD_INT 0
96519: PPUSH
96520: LD_INT 5
96522: PPUSH
96523: CALL_OW 12
96527: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96528: LD_ADDR_VAR 0 2
96532: PUSH
96533: LD_VAR 0 1
96537: PPUSH
96538: CALL_OW 250
96542: PPUSH
96543: LD_VAR 0 4
96547: PPUSH
96548: LD_INT 3
96550: PPUSH
96551: LD_INT 12
96553: PPUSH
96554: CALL_OW 12
96558: PPUSH
96559: CALL_OW 272
96563: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96564: LD_ADDR_VAR 0 3
96568: PUSH
96569: LD_VAR 0 1
96573: PPUSH
96574: CALL_OW 251
96578: PPUSH
96579: LD_VAR 0 4
96583: PPUSH
96584: LD_INT 3
96586: PPUSH
96587: LD_INT 12
96589: PPUSH
96590: CALL_OW 12
96594: PPUSH
96595: CALL_OW 273
96599: ST_TO_ADDR
// if ValidHex ( x , y ) then
96600: LD_VAR 0 2
96604: PPUSH
96605: LD_VAR 0 3
96609: PPUSH
96610: CALL_OW 488
96614: IFFALSE 96649
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96616: LD_VAR 0 1
96620: PPUSH
96621: LD_VAR 0 2
96625: PPUSH
96626: LD_VAR 0 3
96630: PPUSH
96631: LD_INT 3
96633: PPUSH
96634: LD_INT 6
96636: PPUSH
96637: CALL_OW 12
96641: PPUSH
96642: LD_INT 1
96644: PPUSH
96645: CALL_OW 483
// end ;
96649: GO 96509
96651: POP
96652: POP
// end ;
96653: PPOPN 5
96655: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96656: LD_EXP 133
96660: PUSH
96661: LD_EXP 168
96665: AND
96666: IFFALSE 96760
96668: GO 96670
96670: DISABLE
96671: LD_INT 0
96673: PPUSH
96674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96675: LD_ADDR_VAR 0 2
96679: PUSH
96680: LD_INT 22
96682: PUSH
96683: LD_OWVAR 2
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 32
96694: PUSH
96695: LD_INT 1
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 21
96704: PUSH
96705: LD_INT 2
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: LIST
96716: PPUSH
96717: CALL_OW 69
96721: ST_TO_ADDR
// if not tmp then
96722: LD_VAR 0 2
96726: NOT
96727: IFFALSE 96731
// exit ;
96729: GO 96760
// for i in tmp do
96731: LD_ADDR_VAR 0 1
96735: PUSH
96736: LD_VAR 0 2
96740: PUSH
96741: FOR_IN
96742: IFFALSE 96758
// SetFuel ( i , 0 ) ;
96744: LD_VAR 0 1
96748: PPUSH
96749: LD_INT 0
96751: PPUSH
96752: CALL_OW 240
96756: GO 96741
96758: POP
96759: POP
// end ;
96760: PPOPN 2
96762: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96763: LD_EXP 133
96767: PUSH
96768: LD_EXP 169
96772: AND
96773: IFFALSE 96839
96775: GO 96777
96777: DISABLE
96778: LD_INT 0
96780: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96781: LD_ADDR_VAR 0 1
96785: PUSH
96786: LD_INT 22
96788: PUSH
96789: LD_OWVAR 2
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 30
96800: PUSH
96801: LD_INT 29
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: EMPTY
96809: LIST
96810: LIST
96811: PPUSH
96812: CALL_OW 69
96816: ST_TO_ADDR
// if not tmp then
96817: LD_VAR 0 1
96821: NOT
96822: IFFALSE 96826
// exit ;
96824: GO 96839
// DestroyUnit ( tmp [ 1 ] ) ;
96826: LD_VAR 0 1
96830: PUSH
96831: LD_INT 1
96833: ARRAY
96834: PPUSH
96835: CALL_OW 65
// end ;
96839: PPOPN 1
96841: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96842: LD_EXP 133
96846: PUSH
96847: LD_EXP 171
96851: AND
96852: IFFALSE 96981
96854: GO 96856
96856: DISABLE
96857: LD_INT 0
96859: PPUSH
// begin uc_side := 0 ;
96860: LD_ADDR_OWVAR 20
96864: PUSH
96865: LD_INT 0
96867: ST_TO_ADDR
// uc_nation := nation_arabian ;
96868: LD_ADDR_OWVAR 21
96872: PUSH
96873: LD_INT 2
96875: ST_TO_ADDR
// hc_gallery :=  ;
96876: LD_ADDR_OWVAR 33
96880: PUSH
96881: LD_STRING 
96883: ST_TO_ADDR
// hc_name :=  ;
96884: LD_ADDR_OWVAR 26
96888: PUSH
96889: LD_STRING 
96891: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96892: LD_INT 1
96894: PPUSH
96895: LD_INT 11
96897: PPUSH
96898: LD_INT 10
96900: PPUSH
96901: CALL_OW 380
// un := CreateHuman ;
96905: LD_ADDR_VAR 0 1
96909: PUSH
96910: CALL_OW 44
96914: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96915: LD_VAR 0 1
96919: PPUSH
96920: LD_INT 1
96922: PPUSH
96923: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96927: LD_INT 35
96929: PPUSH
96930: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96934: LD_VAR 0 1
96938: PPUSH
96939: LD_INT 22
96941: PUSH
96942: LD_OWVAR 2
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PPUSH
96951: CALL_OW 69
96955: PPUSH
96956: LD_VAR 0 1
96960: PPUSH
96961: CALL_OW 74
96965: PPUSH
96966: CALL_OW 115
// until IsDead ( un ) ;
96970: LD_VAR 0 1
96974: PPUSH
96975: CALL_OW 301
96979: IFFALSE 96927
// end ;
96981: PPOPN 1
96983: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96984: LD_EXP 133
96988: PUSH
96989: LD_EXP 173
96993: AND
96994: IFFALSE 97006
96996: GO 96998
96998: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96999: LD_STRING earthquake(getX(game), 0, 32)
97001: PPUSH
97002: CALL_OW 559
97006: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97007: LD_EXP 133
97011: PUSH
97012: LD_EXP 174
97016: AND
97017: IFFALSE 97108
97019: GO 97021
97021: DISABLE
97022: LD_INT 0
97024: PPUSH
// begin enable ;
97025: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97026: LD_ADDR_VAR 0 1
97030: PUSH
97031: LD_INT 22
97033: PUSH
97034: LD_OWVAR 2
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 21
97045: PUSH
97046: LD_INT 2
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: PUSH
97053: LD_INT 33
97055: PUSH
97056: LD_INT 3
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: LIST
97067: PPUSH
97068: CALL_OW 69
97072: ST_TO_ADDR
// if not tmp then
97073: LD_VAR 0 1
97077: NOT
97078: IFFALSE 97082
// exit ;
97080: GO 97108
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97082: LD_VAR 0 1
97086: PUSH
97087: LD_INT 1
97089: PPUSH
97090: LD_VAR 0 1
97094: PPUSH
97095: CALL_OW 12
97099: ARRAY
97100: PPUSH
97101: LD_INT 1
97103: PPUSH
97104: CALL_OW 234
// end ;
97108: PPOPN 1
97110: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97111: LD_EXP 133
97115: PUSH
97116: LD_EXP 175
97120: AND
97121: IFFALSE 97262
97123: GO 97125
97125: DISABLE
97126: LD_INT 0
97128: PPUSH
97129: PPUSH
97130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97131: LD_ADDR_VAR 0 3
97135: PUSH
97136: LD_INT 22
97138: PUSH
97139: LD_OWVAR 2
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: LD_INT 25
97150: PUSH
97151: LD_INT 1
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PPUSH
97162: CALL_OW 69
97166: ST_TO_ADDR
// if not tmp then
97167: LD_VAR 0 3
97171: NOT
97172: IFFALSE 97176
// exit ;
97174: GO 97262
// un := tmp [ rand ( 1 , tmp ) ] ;
97176: LD_ADDR_VAR 0 2
97180: PUSH
97181: LD_VAR 0 3
97185: PUSH
97186: LD_INT 1
97188: PPUSH
97189: LD_VAR 0 3
97193: PPUSH
97194: CALL_OW 12
97198: ARRAY
97199: ST_TO_ADDR
// if Crawls ( un ) then
97200: LD_VAR 0 2
97204: PPUSH
97205: CALL_OW 318
97209: IFFALSE 97220
// ComWalk ( un ) ;
97211: LD_VAR 0 2
97215: PPUSH
97216: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97220: LD_VAR 0 2
97224: PPUSH
97225: LD_INT 9
97227: PPUSH
97228: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97232: LD_INT 28
97234: PPUSH
97235: LD_OWVAR 2
97239: PPUSH
97240: LD_INT 2
97242: PPUSH
97243: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97247: LD_INT 29
97249: PPUSH
97250: LD_OWVAR 2
97254: PPUSH
97255: LD_INT 2
97257: PPUSH
97258: CALL_OW 322
// end ;
97262: PPOPN 3
97264: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97265: LD_EXP 133
97269: PUSH
97270: LD_EXP 176
97274: AND
97275: IFFALSE 97386
97277: GO 97279
97279: DISABLE
97280: LD_INT 0
97282: PPUSH
97283: PPUSH
97284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97285: LD_ADDR_VAR 0 3
97289: PUSH
97290: LD_INT 22
97292: PUSH
97293: LD_OWVAR 2
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 25
97304: PUSH
97305: LD_INT 1
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PPUSH
97316: CALL_OW 69
97320: ST_TO_ADDR
// if not tmp then
97321: LD_VAR 0 3
97325: NOT
97326: IFFALSE 97330
// exit ;
97328: GO 97386
// un := tmp [ rand ( 1 , tmp ) ] ;
97330: LD_ADDR_VAR 0 2
97334: PUSH
97335: LD_VAR 0 3
97339: PUSH
97340: LD_INT 1
97342: PPUSH
97343: LD_VAR 0 3
97347: PPUSH
97348: CALL_OW 12
97352: ARRAY
97353: ST_TO_ADDR
// if Crawls ( un ) then
97354: LD_VAR 0 2
97358: PPUSH
97359: CALL_OW 318
97363: IFFALSE 97374
// ComWalk ( un ) ;
97365: LD_VAR 0 2
97369: PPUSH
97370: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97374: LD_VAR 0 2
97378: PPUSH
97379: LD_INT 8
97381: PPUSH
97382: CALL_OW 336
// end ;
97386: PPOPN 3
97388: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97389: LD_EXP 133
97393: PUSH
97394: LD_EXP 177
97398: AND
97399: IFFALSE 97543
97401: GO 97403
97403: DISABLE
97404: LD_INT 0
97406: PPUSH
97407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97408: LD_ADDR_VAR 0 2
97412: PUSH
97413: LD_INT 22
97415: PUSH
97416: LD_OWVAR 2
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: PUSH
97425: LD_INT 21
97427: PUSH
97428: LD_INT 2
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 2
97437: PUSH
97438: LD_INT 34
97440: PUSH
97441: LD_INT 12
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: PUSH
97448: LD_INT 34
97450: PUSH
97451: LD_INT 51
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 34
97460: PUSH
97461: LD_INT 32
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: LIST
97478: PPUSH
97479: CALL_OW 69
97483: ST_TO_ADDR
// if not tmp then
97484: LD_VAR 0 2
97488: NOT
97489: IFFALSE 97493
// exit ;
97491: GO 97543
// for i in tmp do
97493: LD_ADDR_VAR 0 1
97497: PUSH
97498: LD_VAR 0 2
97502: PUSH
97503: FOR_IN
97504: IFFALSE 97541
// if GetCargo ( i , mat_artifact ) = 0 then
97506: LD_VAR 0 1
97510: PPUSH
97511: LD_INT 4
97513: PPUSH
97514: CALL_OW 289
97518: PUSH
97519: LD_INT 0
97521: EQUAL
97522: IFFALSE 97539
// SetCargo ( i , mat_siberit , 100 ) ;
97524: LD_VAR 0 1
97528: PPUSH
97529: LD_INT 3
97531: PPUSH
97532: LD_INT 100
97534: PPUSH
97535: CALL_OW 290
97539: GO 97503
97541: POP
97542: POP
// end ;
97543: PPOPN 2
97545: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97546: LD_EXP 133
97550: PUSH
97551: LD_EXP 178
97555: AND
97556: IFFALSE 97739
97558: GO 97560
97560: DISABLE
97561: LD_INT 0
97563: PPUSH
97564: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97565: LD_ADDR_VAR 0 2
97569: PUSH
97570: LD_INT 22
97572: PUSH
97573: LD_OWVAR 2
97577: PUSH
97578: EMPTY
97579: LIST
97580: LIST
97581: PPUSH
97582: CALL_OW 69
97586: ST_TO_ADDR
// if not tmp then
97587: LD_VAR 0 2
97591: NOT
97592: IFFALSE 97596
// exit ;
97594: GO 97739
// for i := 1 to 2 do
97596: LD_ADDR_VAR 0 1
97600: PUSH
97601: DOUBLE
97602: LD_INT 1
97604: DEC
97605: ST_TO_ADDR
97606: LD_INT 2
97608: PUSH
97609: FOR_TO
97610: IFFALSE 97737
// begin uc_side := your_side ;
97612: LD_ADDR_OWVAR 20
97616: PUSH
97617: LD_OWVAR 2
97621: ST_TO_ADDR
// uc_nation := nation_american ;
97622: LD_ADDR_OWVAR 21
97626: PUSH
97627: LD_INT 1
97629: ST_TO_ADDR
// vc_chassis := us_morphling ;
97630: LD_ADDR_OWVAR 37
97634: PUSH
97635: LD_INT 5
97637: ST_TO_ADDR
// vc_engine := engine_siberite ;
97638: LD_ADDR_OWVAR 39
97642: PUSH
97643: LD_INT 3
97645: ST_TO_ADDR
// vc_control := control_computer ;
97646: LD_ADDR_OWVAR 38
97650: PUSH
97651: LD_INT 3
97653: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97654: LD_ADDR_OWVAR 40
97658: PUSH
97659: LD_INT 10
97661: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97662: LD_VAR 0 2
97666: PUSH
97667: LD_INT 1
97669: ARRAY
97670: PPUSH
97671: CALL_OW 310
97675: NOT
97676: IFFALSE 97723
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97678: CALL_OW 45
97682: PPUSH
97683: LD_VAR 0 2
97687: PUSH
97688: LD_INT 1
97690: ARRAY
97691: PPUSH
97692: CALL_OW 250
97696: PPUSH
97697: LD_VAR 0 2
97701: PUSH
97702: LD_INT 1
97704: ARRAY
97705: PPUSH
97706: CALL_OW 251
97710: PPUSH
97711: LD_INT 12
97713: PPUSH
97714: LD_INT 1
97716: PPUSH
97717: CALL_OW 50
97721: GO 97735
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97723: CALL_OW 45
97727: PPUSH
97728: LD_INT 1
97730: PPUSH
97731: CALL_OW 51
// end ;
97735: GO 97609
97737: POP
97738: POP
// end ;
97739: PPOPN 2
97741: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97742: LD_EXP 133
97746: PUSH
97747: LD_EXP 179
97751: AND
97752: IFFALSE 97974
97754: GO 97756
97756: DISABLE
97757: LD_INT 0
97759: PPUSH
97760: PPUSH
97761: PPUSH
97762: PPUSH
97763: PPUSH
97764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97765: LD_ADDR_VAR 0 6
97769: PUSH
97770: LD_INT 22
97772: PUSH
97773: LD_OWVAR 2
97777: PUSH
97778: EMPTY
97779: LIST
97780: LIST
97781: PUSH
97782: LD_INT 21
97784: PUSH
97785: LD_INT 1
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: PUSH
97792: LD_INT 3
97794: PUSH
97795: LD_INT 23
97797: PUSH
97798: LD_INT 0
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: LIST
97813: PPUSH
97814: CALL_OW 69
97818: ST_TO_ADDR
// if not tmp then
97819: LD_VAR 0 6
97823: NOT
97824: IFFALSE 97828
// exit ;
97826: GO 97974
// s1 := rand ( 1 , 4 ) ;
97828: LD_ADDR_VAR 0 2
97832: PUSH
97833: LD_INT 1
97835: PPUSH
97836: LD_INT 4
97838: PPUSH
97839: CALL_OW 12
97843: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97844: LD_ADDR_VAR 0 4
97848: PUSH
97849: LD_VAR 0 6
97853: PUSH
97854: LD_INT 1
97856: ARRAY
97857: PPUSH
97858: LD_VAR 0 2
97862: PPUSH
97863: CALL_OW 259
97867: ST_TO_ADDR
// if s1 = 1 then
97868: LD_VAR 0 2
97872: PUSH
97873: LD_INT 1
97875: EQUAL
97876: IFFALSE 97896
// s2 := rand ( 2 , 4 ) else
97878: LD_ADDR_VAR 0 3
97882: PUSH
97883: LD_INT 2
97885: PPUSH
97886: LD_INT 4
97888: PPUSH
97889: CALL_OW 12
97893: ST_TO_ADDR
97894: GO 97904
// s2 := 1 ;
97896: LD_ADDR_VAR 0 3
97900: PUSH
97901: LD_INT 1
97903: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97904: LD_ADDR_VAR 0 5
97908: PUSH
97909: LD_VAR 0 6
97913: PUSH
97914: LD_INT 1
97916: ARRAY
97917: PPUSH
97918: LD_VAR 0 3
97922: PPUSH
97923: CALL_OW 259
97927: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97928: LD_VAR 0 6
97932: PUSH
97933: LD_INT 1
97935: ARRAY
97936: PPUSH
97937: LD_VAR 0 2
97941: PPUSH
97942: LD_VAR 0 5
97946: PPUSH
97947: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97951: LD_VAR 0 6
97955: PUSH
97956: LD_INT 1
97958: ARRAY
97959: PPUSH
97960: LD_VAR 0 3
97964: PPUSH
97965: LD_VAR 0 4
97969: PPUSH
97970: CALL_OW 237
// end ;
97974: PPOPN 6
97976: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97977: LD_EXP 133
97981: PUSH
97982: LD_EXP 180
97986: AND
97987: IFFALSE 98066
97989: GO 97991
97991: DISABLE
97992: LD_INT 0
97994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97995: LD_ADDR_VAR 0 1
97999: PUSH
98000: LD_INT 22
98002: PUSH
98003: LD_OWVAR 2
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: PUSH
98012: LD_INT 30
98014: PUSH
98015: LD_INT 3
98017: PUSH
98018: EMPTY
98019: LIST
98020: LIST
98021: PUSH
98022: EMPTY
98023: LIST
98024: LIST
98025: PPUSH
98026: CALL_OW 69
98030: ST_TO_ADDR
// if not tmp then
98031: LD_VAR 0 1
98035: NOT
98036: IFFALSE 98040
// exit ;
98038: GO 98066
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98040: LD_VAR 0 1
98044: PUSH
98045: LD_INT 1
98047: PPUSH
98048: LD_VAR 0 1
98052: PPUSH
98053: CALL_OW 12
98057: ARRAY
98058: PPUSH
98059: LD_INT 1
98061: PPUSH
98062: CALL_OW 234
// end ;
98066: PPOPN 1
98068: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98069: LD_EXP 133
98073: PUSH
98074: LD_EXP 181
98078: AND
98079: IFFALSE 98191
98081: GO 98083
98083: DISABLE
98084: LD_INT 0
98086: PPUSH
98087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98088: LD_ADDR_VAR 0 2
98092: PUSH
98093: LD_INT 22
98095: PUSH
98096: LD_OWVAR 2
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: PUSH
98105: LD_INT 2
98107: PUSH
98108: LD_INT 30
98110: PUSH
98111: LD_INT 27
98113: PUSH
98114: EMPTY
98115: LIST
98116: LIST
98117: PUSH
98118: LD_INT 30
98120: PUSH
98121: LD_INT 26
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 30
98130: PUSH
98131: LD_INT 28
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: PPUSH
98148: CALL_OW 69
98152: ST_TO_ADDR
// if not tmp then
98153: LD_VAR 0 2
98157: NOT
98158: IFFALSE 98162
// exit ;
98160: GO 98191
// for i in tmp do
98162: LD_ADDR_VAR 0 1
98166: PUSH
98167: LD_VAR 0 2
98171: PUSH
98172: FOR_IN
98173: IFFALSE 98189
// SetLives ( i , 1 ) ;
98175: LD_VAR 0 1
98179: PPUSH
98180: LD_INT 1
98182: PPUSH
98183: CALL_OW 234
98187: GO 98172
98189: POP
98190: POP
// end ;
98191: PPOPN 2
98193: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98194: LD_EXP 133
98198: PUSH
98199: LD_EXP 182
98203: AND
98204: IFFALSE 98478
98206: GO 98208
98208: DISABLE
98209: LD_INT 0
98211: PPUSH
98212: PPUSH
98213: PPUSH
// begin i := rand ( 1 , 7 ) ;
98214: LD_ADDR_VAR 0 1
98218: PUSH
98219: LD_INT 1
98221: PPUSH
98222: LD_INT 7
98224: PPUSH
98225: CALL_OW 12
98229: ST_TO_ADDR
// case i of 1 :
98230: LD_VAR 0 1
98234: PUSH
98235: LD_INT 1
98237: DOUBLE
98238: EQUAL
98239: IFTRUE 98243
98241: GO 98253
98243: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98244: LD_STRING earthquake(getX(game), 0, 32)
98246: PPUSH
98247: CALL_OW 559
98251: GO 98478
98253: LD_INT 2
98255: DOUBLE
98256: EQUAL
98257: IFTRUE 98261
98259: GO 98275
98261: POP
// begin ToLua ( displayStucuk(); ) ;
98262: LD_STRING displayStucuk();
98264: PPUSH
98265: CALL_OW 559
// ResetFog ;
98269: CALL_OW 335
// end ; 3 :
98273: GO 98478
98275: LD_INT 3
98277: DOUBLE
98278: EQUAL
98279: IFTRUE 98283
98281: GO 98387
98283: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98284: LD_ADDR_VAR 0 2
98288: PUSH
98289: LD_INT 22
98291: PUSH
98292: LD_OWVAR 2
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: PUSH
98301: LD_INT 25
98303: PUSH
98304: LD_INT 1
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PUSH
98311: EMPTY
98312: LIST
98313: LIST
98314: PPUSH
98315: CALL_OW 69
98319: ST_TO_ADDR
// if not tmp then
98320: LD_VAR 0 2
98324: NOT
98325: IFFALSE 98329
// exit ;
98327: GO 98478
// un := tmp [ rand ( 1 , tmp ) ] ;
98329: LD_ADDR_VAR 0 3
98333: PUSH
98334: LD_VAR 0 2
98338: PUSH
98339: LD_INT 1
98341: PPUSH
98342: LD_VAR 0 2
98346: PPUSH
98347: CALL_OW 12
98351: ARRAY
98352: ST_TO_ADDR
// if Crawls ( un ) then
98353: LD_VAR 0 3
98357: PPUSH
98358: CALL_OW 318
98362: IFFALSE 98373
// ComWalk ( un ) ;
98364: LD_VAR 0 3
98368: PPUSH
98369: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98373: LD_VAR 0 3
98377: PPUSH
98378: LD_INT 8
98380: PPUSH
98381: CALL_OW 336
// end ; 4 :
98385: GO 98478
98387: LD_INT 4
98389: DOUBLE
98390: EQUAL
98391: IFTRUE 98395
98393: GO 98456
98395: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98396: LD_ADDR_VAR 0 2
98400: PUSH
98401: LD_INT 22
98403: PUSH
98404: LD_OWVAR 2
98408: PUSH
98409: EMPTY
98410: LIST
98411: LIST
98412: PUSH
98413: LD_INT 30
98415: PUSH
98416: LD_INT 29
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: PUSH
98423: EMPTY
98424: LIST
98425: LIST
98426: PPUSH
98427: CALL_OW 69
98431: ST_TO_ADDR
// if not tmp then
98432: LD_VAR 0 2
98436: NOT
98437: IFFALSE 98441
// exit ;
98439: GO 98478
// DestroyUnit ( tmp [ 1 ] ) ;
98441: LD_VAR 0 2
98445: PUSH
98446: LD_INT 1
98448: ARRAY
98449: PPUSH
98450: CALL_OW 65
// end ; 5 .. 7 :
98454: GO 98478
98456: LD_INT 5
98458: DOUBLE
98459: GREATEREQUAL
98460: IFFALSE 98468
98462: LD_INT 7
98464: DOUBLE
98465: LESSEQUAL
98466: IFTRUE 98470
98468: GO 98477
98470: POP
// StreamSibBomb ; end ;
98471: CALL 94728 0 0
98475: GO 98478
98477: POP
// end ;
98478: PPOPN 3
98480: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98481: LD_EXP 133
98485: PUSH
98486: LD_EXP 183
98490: AND
98491: IFFALSE 98647
98493: GO 98495
98495: DISABLE
98496: LD_INT 0
98498: PPUSH
98499: PPUSH
98500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98501: LD_ADDR_VAR 0 2
98505: PUSH
98506: LD_INT 81
98508: PUSH
98509: LD_OWVAR 2
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: PUSH
98518: LD_INT 2
98520: PUSH
98521: LD_INT 21
98523: PUSH
98524: LD_INT 1
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: PUSH
98531: LD_INT 21
98533: PUSH
98534: LD_INT 2
98536: PUSH
98537: EMPTY
98538: LIST
98539: LIST
98540: PUSH
98541: EMPTY
98542: LIST
98543: LIST
98544: LIST
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PPUSH
98550: CALL_OW 69
98554: ST_TO_ADDR
// if not tmp then
98555: LD_VAR 0 2
98559: NOT
98560: IFFALSE 98564
// exit ;
98562: GO 98647
// p := 0 ;
98564: LD_ADDR_VAR 0 3
98568: PUSH
98569: LD_INT 0
98571: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98572: LD_INT 35
98574: PPUSH
98575: CALL_OW 67
// p := p + 1 ;
98579: LD_ADDR_VAR 0 3
98583: PUSH
98584: LD_VAR 0 3
98588: PUSH
98589: LD_INT 1
98591: PLUS
98592: ST_TO_ADDR
// for i in tmp do
98593: LD_ADDR_VAR 0 1
98597: PUSH
98598: LD_VAR 0 2
98602: PUSH
98603: FOR_IN
98604: IFFALSE 98635
// if GetLives ( i ) < 1000 then
98606: LD_VAR 0 1
98610: PPUSH
98611: CALL_OW 256
98615: PUSH
98616: LD_INT 1000
98618: LESS
98619: IFFALSE 98633
// SetLives ( i , 1000 ) ;
98621: LD_VAR 0 1
98625: PPUSH
98626: LD_INT 1000
98628: PPUSH
98629: CALL_OW 234
98633: GO 98603
98635: POP
98636: POP
// until p > 20 ;
98637: LD_VAR 0 3
98641: PUSH
98642: LD_INT 20
98644: GREATER
98645: IFFALSE 98572
// end ;
98647: PPOPN 3
98649: END
// every 0 0$1 trigger StreamModeActive and sTime do
98650: LD_EXP 133
98654: PUSH
98655: LD_EXP 184
98659: AND
98660: IFFALSE 98695
98662: GO 98664
98664: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98665: LD_INT 28
98667: PPUSH
98668: LD_OWVAR 2
98672: PPUSH
98673: LD_INT 2
98675: PPUSH
98676: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98680: LD_INT 30
98682: PPUSH
98683: LD_OWVAR 2
98687: PPUSH
98688: LD_INT 2
98690: PPUSH
98691: CALL_OW 322
// end ;
98695: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98696: LD_EXP 133
98700: PUSH
98701: LD_EXP 185
98705: AND
98706: IFFALSE 98827
98708: GO 98710
98710: DISABLE
98711: LD_INT 0
98713: PPUSH
98714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98715: LD_ADDR_VAR 0 2
98719: PUSH
98720: LD_INT 22
98722: PUSH
98723: LD_OWVAR 2
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: PUSH
98732: LD_INT 21
98734: PUSH
98735: LD_INT 1
98737: PUSH
98738: EMPTY
98739: LIST
98740: LIST
98741: PUSH
98742: LD_INT 3
98744: PUSH
98745: LD_INT 23
98747: PUSH
98748: LD_INT 0
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PUSH
98759: EMPTY
98760: LIST
98761: LIST
98762: LIST
98763: PPUSH
98764: CALL_OW 69
98768: ST_TO_ADDR
// if not tmp then
98769: LD_VAR 0 2
98773: NOT
98774: IFFALSE 98778
// exit ;
98776: GO 98827
// for i in tmp do
98778: LD_ADDR_VAR 0 1
98782: PUSH
98783: LD_VAR 0 2
98787: PUSH
98788: FOR_IN
98789: IFFALSE 98825
// begin if Crawls ( i ) then
98791: LD_VAR 0 1
98795: PPUSH
98796: CALL_OW 318
98800: IFFALSE 98811
// ComWalk ( i ) ;
98802: LD_VAR 0 1
98806: PPUSH
98807: CALL_OW 138
// SetClass ( i , 2 ) ;
98811: LD_VAR 0 1
98815: PPUSH
98816: LD_INT 2
98818: PPUSH
98819: CALL_OW 336
// end ;
98823: GO 98788
98825: POP
98826: POP
// end ;
98827: PPOPN 2
98829: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98830: LD_EXP 133
98834: PUSH
98835: LD_EXP 186
98839: AND
98840: IFFALSE 99121
98842: GO 98844
98844: DISABLE
98845: LD_INT 0
98847: PPUSH
98848: PPUSH
98849: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98850: LD_OWVAR 2
98854: PPUSH
98855: LD_INT 9
98857: PPUSH
98858: LD_INT 1
98860: PPUSH
98861: LD_INT 1
98863: PPUSH
98864: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98868: LD_INT 9
98870: PPUSH
98871: LD_OWVAR 2
98875: PPUSH
98876: CALL_OW 343
// uc_side := 9 ;
98880: LD_ADDR_OWVAR 20
98884: PUSH
98885: LD_INT 9
98887: ST_TO_ADDR
// uc_nation := 2 ;
98888: LD_ADDR_OWVAR 21
98892: PUSH
98893: LD_INT 2
98895: ST_TO_ADDR
// hc_name := Dark Warrior ;
98896: LD_ADDR_OWVAR 26
98900: PUSH
98901: LD_STRING Dark Warrior
98903: ST_TO_ADDR
// hc_gallery :=  ;
98904: LD_ADDR_OWVAR 33
98908: PUSH
98909: LD_STRING 
98911: ST_TO_ADDR
// hc_noskilllimit := true ;
98912: LD_ADDR_OWVAR 76
98916: PUSH
98917: LD_INT 1
98919: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98920: LD_ADDR_OWVAR 31
98924: PUSH
98925: LD_INT 30
98927: PUSH
98928: LD_INT 30
98930: PUSH
98931: LD_INT 30
98933: PUSH
98934: LD_INT 30
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: ST_TO_ADDR
// un := CreateHuman ;
98943: LD_ADDR_VAR 0 3
98947: PUSH
98948: CALL_OW 44
98952: ST_TO_ADDR
// hc_noskilllimit := false ;
98953: LD_ADDR_OWVAR 76
98957: PUSH
98958: LD_INT 0
98960: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98961: LD_VAR 0 3
98965: PPUSH
98966: LD_INT 1
98968: PPUSH
98969: CALL_OW 51
// p := 0 ;
98973: LD_ADDR_VAR 0 2
98977: PUSH
98978: LD_INT 0
98980: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98981: LD_INT 35
98983: PPUSH
98984: CALL_OW 67
// p := p + 1 ;
98988: LD_ADDR_VAR 0 2
98992: PUSH
98993: LD_VAR 0 2
98997: PUSH
98998: LD_INT 1
99000: PLUS
99001: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99002: LD_VAR 0 3
99006: PPUSH
99007: CALL_OW 256
99011: PUSH
99012: LD_INT 1000
99014: LESS
99015: IFFALSE 99029
// SetLives ( un , 1000 ) ;
99017: LD_VAR 0 3
99021: PPUSH
99022: LD_INT 1000
99024: PPUSH
99025: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99029: LD_VAR 0 3
99033: PPUSH
99034: LD_INT 81
99036: PUSH
99037: LD_OWVAR 2
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 91
99048: PUSH
99049: LD_VAR 0 3
99053: PUSH
99054: LD_INT 30
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: LIST
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PPUSH
99066: CALL_OW 69
99070: PPUSH
99071: LD_VAR 0 3
99075: PPUSH
99076: CALL_OW 74
99080: PPUSH
99081: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99085: LD_VAR 0 2
99089: PUSH
99090: LD_INT 60
99092: GREATER
99093: PUSH
99094: LD_VAR 0 3
99098: PPUSH
99099: CALL_OW 301
99103: OR
99104: IFFALSE 98981
// if un then
99106: LD_VAR 0 3
99110: IFFALSE 99121
// RemoveUnit ( un ) ;
99112: LD_VAR 0 3
99116: PPUSH
99117: CALL_OW 64
// end ;
99121: PPOPN 3
99123: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99124: LD_INT 0
99126: PPUSH
// case cmd of 301 :
99127: LD_VAR 0 1
99131: PUSH
99132: LD_INT 301
99134: DOUBLE
99135: EQUAL
99136: IFTRUE 99140
99138: GO 99172
99140: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99141: LD_VAR 0 6
99145: PPUSH
99146: LD_VAR 0 7
99150: PPUSH
99151: LD_VAR 0 8
99155: PPUSH
99156: LD_VAR 0 4
99160: PPUSH
99161: LD_VAR 0 5
99165: PPUSH
99166: CALL 100373 0 5
99170: GO 99293
99172: LD_INT 302
99174: DOUBLE
99175: EQUAL
99176: IFTRUE 99180
99178: GO 99217
99180: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99181: LD_VAR 0 6
99185: PPUSH
99186: LD_VAR 0 7
99190: PPUSH
99191: LD_VAR 0 8
99195: PPUSH
99196: LD_VAR 0 9
99200: PPUSH
99201: LD_VAR 0 4
99205: PPUSH
99206: LD_VAR 0 5
99210: PPUSH
99211: CALL 100464 0 6
99215: GO 99293
99217: LD_INT 303
99219: DOUBLE
99220: EQUAL
99221: IFTRUE 99225
99223: GO 99262
99225: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99226: LD_VAR 0 6
99230: PPUSH
99231: LD_VAR 0 7
99235: PPUSH
99236: LD_VAR 0 8
99240: PPUSH
99241: LD_VAR 0 9
99245: PPUSH
99246: LD_VAR 0 4
99250: PPUSH
99251: LD_VAR 0 5
99255: PPUSH
99256: CALL 99298 0 6
99260: GO 99293
99262: LD_INT 304
99264: DOUBLE
99265: EQUAL
99266: IFTRUE 99270
99268: GO 99292
99270: POP
// hHackTeleport ( unit , x , y ) ; end ;
99271: LD_VAR 0 2
99275: PPUSH
99276: LD_VAR 0 4
99280: PPUSH
99281: LD_VAR 0 5
99285: PPUSH
99286: CALL 101057 0 3
99290: GO 99293
99292: POP
// end ;
99293: LD_VAR 0 12
99297: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99298: LD_INT 0
99300: PPUSH
99301: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99302: LD_VAR 0 1
99306: PUSH
99307: LD_INT 1
99309: LESS
99310: PUSH
99311: LD_VAR 0 1
99315: PUSH
99316: LD_INT 3
99318: GREATER
99319: OR
99320: PUSH
99321: LD_VAR 0 5
99325: PPUSH
99326: LD_VAR 0 6
99330: PPUSH
99331: CALL_OW 428
99335: OR
99336: IFFALSE 99340
// exit ;
99338: GO 100060
// uc_side := your_side ;
99340: LD_ADDR_OWVAR 20
99344: PUSH
99345: LD_OWVAR 2
99349: ST_TO_ADDR
// uc_nation := nation ;
99350: LD_ADDR_OWVAR 21
99354: PUSH
99355: LD_VAR 0 1
99359: ST_TO_ADDR
// bc_level = 1 ;
99360: LD_ADDR_OWVAR 43
99364: PUSH
99365: LD_INT 1
99367: ST_TO_ADDR
// case btype of 1 :
99368: LD_VAR 0 2
99372: PUSH
99373: LD_INT 1
99375: DOUBLE
99376: EQUAL
99377: IFTRUE 99381
99379: GO 99392
99381: POP
// bc_type := b_depot ; 2 :
99382: LD_ADDR_OWVAR 42
99386: PUSH
99387: LD_INT 0
99389: ST_TO_ADDR
99390: GO 100004
99392: LD_INT 2
99394: DOUBLE
99395: EQUAL
99396: IFTRUE 99400
99398: GO 99411
99400: POP
// bc_type := b_warehouse ; 3 :
99401: LD_ADDR_OWVAR 42
99405: PUSH
99406: LD_INT 1
99408: ST_TO_ADDR
99409: GO 100004
99411: LD_INT 3
99413: DOUBLE
99414: EQUAL
99415: IFTRUE 99419
99417: GO 99430
99419: POP
// bc_type := b_lab ; 4 .. 9 :
99420: LD_ADDR_OWVAR 42
99424: PUSH
99425: LD_INT 6
99427: ST_TO_ADDR
99428: GO 100004
99430: LD_INT 4
99432: DOUBLE
99433: GREATEREQUAL
99434: IFFALSE 99442
99436: LD_INT 9
99438: DOUBLE
99439: LESSEQUAL
99440: IFTRUE 99444
99442: GO 99496
99444: POP
// begin bc_type := b_lab_half ;
99445: LD_ADDR_OWVAR 42
99449: PUSH
99450: LD_INT 7
99452: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99453: LD_ADDR_OWVAR 44
99457: PUSH
99458: LD_INT 10
99460: PUSH
99461: LD_INT 11
99463: PUSH
99464: LD_INT 12
99466: PUSH
99467: LD_INT 15
99469: PUSH
99470: LD_INT 14
99472: PUSH
99473: LD_INT 13
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: PUSH
99484: LD_VAR 0 2
99488: PUSH
99489: LD_INT 3
99491: MINUS
99492: ARRAY
99493: ST_TO_ADDR
// end ; 10 .. 13 :
99494: GO 100004
99496: LD_INT 10
99498: DOUBLE
99499: GREATEREQUAL
99500: IFFALSE 99508
99502: LD_INT 13
99504: DOUBLE
99505: LESSEQUAL
99506: IFTRUE 99510
99508: GO 99587
99510: POP
// begin bc_type := b_lab_full ;
99511: LD_ADDR_OWVAR 42
99515: PUSH
99516: LD_INT 8
99518: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99519: LD_ADDR_OWVAR 44
99523: PUSH
99524: LD_INT 10
99526: PUSH
99527: LD_INT 12
99529: PUSH
99530: LD_INT 14
99532: PUSH
99533: LD_INT 13
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: PUSH
99542: LD_VAR 0 2
99546: PUSH
99547: LD_INT 9
99549: MINUS
99550: ARRAY
99551: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99552: LD_ADDR_OWVAR 45
99556: PUSH
99557: LD_INT 11
99559: PUSH
99560: LD_INT 15
99562: PUSH
99563: LD_INT 12
99565: PUSH
99566: LD_INT 15
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: PUSH
99575: LD_VAR 0 2
99579: PUSH
99580: LD_INT 9
99582: MINUS
99583: ARRAY
99584: ST_TO_ADDR
// end ; 14 :
99585: GO 100004
99587: LD_INT 14
99589: DOUBLE
99590: EQUAL
99591: IFTRUE 99595
99593: GO 99606
99595: POP
// bc_type := b_workshop ; 15 :
99596: LD_ADDR_OWVAR 42
99600: PUSH
99601: LD_INT 2
99603: ST_TO_ADDR
99604: GO 100004
99606: LD_INT 15
99608: DOUBLE
99609: EQUAL
99610: IFTRUE 99614
99612: GO 99625
99614: POP
// bc_type := b_factory ; 16 :
99615: LD_ADDR_OWVAR 42
99619: PUSH
99620: LD_INT 3
99622: ST_TO_ADDR
99623: GO 100004
99625: LD_INT 16
99627: DOUBLE
99628: EQUAL
99629: IFTRUE 99633
99631: GO 99644
99633: POP
// bc_type := b_ext_gun ; 17 :
99634: LD_ADDR_OWVAR 42
99638: PUSH
99639: LD_INT 17
99641: ST_TO_ADDR
99642: GO 100004
99644: LD_INT 17
99646: DOUBLE
99647: EQUAL
99648: IFTRUE 99652
99650: GO 99680
99652: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99653: LD_ADDR_OWVAR 42
99657: PUSH
99658: LD_INT 19
99660: PUSH
99661: LD_INT 23
99663: PUSH
99664: LD_INT 19
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: LIST
99671: PUSH
99672: LD_VAR 0 1
99676: ARRAY
99677: ST_TO_ADDR
99678: GO 100004
99680: LD_INT 18
99682: DOUBLE
99683: EQUAL
99684: IFTRUE 99688
99686: GO 99699
99688: POP
// bc_type := b_ext_radar ; 19 :
99689: LD_ADDR_OWVAR 42
99693: PUSH
99694: LD_INT 20
99696: ST_TO_ADDR
99697: GO 100004
99699: LD_INT 19
99701: DOUBLE
99702: EQUAL
99703: IFTRUE 99707
99705: GO 99718
99707: POP
// bc_type := b_ext_radio ; 20 :
99708: LD_ADDR_OWVAR 42
99712: PUSH
99713: LD_INT 22
99715: ST_TO_ADDR
99716: GO 100004
99718: LD_INT 20
99720: DOUBLE
99721: EQUAL
99722: IFTRUE 99726
99724: GO 99737
99726: POP
// bc_type := b_ext_siberium ; 21 :
99727: LD_ADDR_OWVAR 42
99731: PUSH
99732: LD_INT 21
99734: ST_TO_ADDR
99735: GO 100004
99737: LD_INT 21
99739: DOUBLE
99740: EQUAL
99741: IFTRUE 99745
99743: GO 99756
99745: POP
// bc_type := b_ext_computer ; 22 :
99746: LD_ADDR_OWVAR 42
99750: PUSH
99751: LD_INT 24
99753: ST_TO_ADDR
99754: GO 100004
99756: LD_INT 22
99758: DOUBLE
99759: EQUAL
99760: IFTRUE 99764
99762: GO 99775
99764: POP
// bc_type := b_ext_track ; 23 :
99765: LD_ADDR_OWVAR 42
99769: PUSH
99770: LD_INT 16
99772: ST_TO_ADDR
99773: GO 100004
99775: LD_INT 23
99777: DOUBLE
99778: EQUAL
99779: IFTRUE 99783
99781: GO 99794
99783: POP
// bc_type := b_ext_laser ; 24 :
99784: LD_ADDR_OWVAR 42
99788: PUSH
99789: LD_INT 25
99791: ST_TO_ADDR
99792: GO 100004
99794: LD_INT 24
99796: DOUBLE
99797: EQUAL
99798: IFTRUE 99802
99800: GO 99813
99802: POP
// bc_type := b_control_tower ; 25 :
99803: LD_ADDR_OWVAR 42
99807: PUSH
99808: LD_INT 36
99810: ST_TO_ADDR
99811: GO 100004
99813: LD_INT 25
99815: DOUBLE
99816: EQUAL
99817: IFTRUE 99821
99819: GO 99832
99821: POP
// bc_type := b_breastwork ; 26 :
99822: LD_ADDR_OWVAR 42
99826: PUSH
99827: LD_INT 31
99829: ST_TO_ADDR
99830: GO 100004
99832: LD_INT 26
99834: DOUBLE
99835: EQUAL
99836: IFTRUE 99840
99838: GO 99851
99840: POP
// bc_type := b_bunker ; 27 :
99841: LD_ADDR_OWVAR 42
99845: PUSH
99846: LD_INT 32
99848: ST_TO_ADDR
99849: GO 100004
99851: LD_INT 27
99853: DOUBLE
99854: EQUAL
99855: IFTRUE 99859
99857: GO 99870
99859: POP
// bc_type := b_turret ; 28 :
99860: LD_ADDR_OWVAR 42
99864: PUSH
99865: LD_INT 33
99867: ST_TO_ADDR
99868: GO 100004
99870: LD_INT 28
99872: DOUBLE
99873: EQUAL
99874: IFTRUE 99878
99876: GO 99889
99878: POP
// bc_type := b_armoury ; 29 :
99879: LD_ADDR_OWVAR 42
99883: PUSH
99884: LD_INT 4
99886: ST_TO_ADDR
99887: GO 100004
99889: LD_INT 29
99891: DOUBLE
99892: EQUAL
99893: IFTRUE 99897
99895: GO 99908
99897: POP
// bc_type := b_barracks ; 30 :
99898: LD_ADDR_OWVAR 42
99902: PUSH
99903: LD_INT 5
99905: ST_TO_ADDR
99906: GO 100004
99908: LD_INT 30
99910: DOUBLE
99911: EQUAL
99912: IFTRUE 99916
99914: GO 99927
99916: POP
// bc_type := b_solar_power ; 31 :
99917: LD_ADDR_OWVAR 42
99921: PUSH
99922: LD_INT 27
99924: ST_TO_ADDR
99925: GO 100004
99927: LD_INT 31
99929: DOUBLE
99930: EQUAL
99931: IFTRUE 99935
99933: GO 99946
99935: POP
// bc_type := b_oil_power ; 32 :
99936: LD_ADDR_OWVAR 42
99940: PUSH
99941: LD_INT 26
99943: ST_TO_ADDR
99944: GO 100004
99946: LD_INT 32
99948: DOUBLE
99949: EQUAL
99950: IFTRUE 99954
99952: GO 99965
99954: POP
// bc_type := b_siberite_power ; 33 :
99955: LD_ADDR_OWVAR 42
99959: PUSH
99960: LD_INT 28
99962: ST_TO_ADDR
99963: GO 100004
99965: LD_INT 33
99967: DOUBLE
99968: EQUAL
99969: IFTRUE 99973
99971: GO 99984
99973: POP
// bc_type := b_oil_mine ; 34 :
99974: LD_ADDR_OWVAR 42
99978: PUSH
99979: LD_INT 29
99981: ST_TO_ADDR
99982: GO 100004
99984: LD_INT 34
99986: DOUBLE
99987: EQUAL
99988: IFTRUE 99992
99990: GO 100003
99992: POP
// bc_type := b_siberite_mine ; end ;
99993: LD_ADDR_OWVAR 42
99997: PUSH
99998: LD_INT 30
100000: ST_TO_ADDR
100001: GO 100004
100003: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100004: LD_ADDR_VAR 0 8
100008: PUSH
100009: LD_VAR 0 5
100013: PPUSH
100014: LD_VAR 0 6
100018: PPUSH
100019: LD_VAR 0 3
100023: PPUSH
100024: CALL_OW 47
100028: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100029: LD_OWVAR 42
100033: PUSH
100034: LD_INT 32
100036: PUSH
100037: LD_INT 33
100039: PUSH
100040: EMPTY
100041: LIST
100042: LIST
100043: IN
100044: IFFALSE 100060
// PlaceWeaponTurret ( b , weapon ) ;
100046: LD_VAR 0 8
100050: PPUSH
100051: LD_VAR 0 4
100055: PPUSH
100056: CALL_OW 431
// end ;
100060: LD_VAR 0 7
100064: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100065: LD_INT 0
100067: PPUSH
100068: PPUSH
100069: PPUSH
100070: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100071: LD_ADDR_VAR 0 4
100075: PUSH
100076: LD_INT 22
100078: PUSH
100079: LD_OWVAR 2
100083: PUSH
100084: EMPTY
100085: LIST
100086: LIST
100087: PUSH
100088: LD_INT 2
100090: PUSH
100091: LD_INT 30
100093: PUSH
100094: LD_INT 0
100096: PUSH
100097: EMPTY
100098: LIST
100099: LIST
100100: PUSH
100101: LD_INT 30
100103: PUSH
100104: LD_INT 1
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: PUSH
100111: EMPTY
100112: LIST
100113: LIST
100114: LIST
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PPUSH
100120: CALL_OW 69
100124: ST_TO_ADDR
// if not tmp then
100125: LD_VAR 0 4
100129: NOT
100130: IFFALSE 100134
// exit ;
100132: GO 100193
// for i in tmp do
100134: LD_ADDR_VAR 0 2
100138: PUSH
100139: LD_VAR 0 4
100143: PUSH
100144: FOR_IN
100145: IFFALSE 100191
// for j = 1 to 3 do
100147: LD_ADDR_VAR 0 3
100151: PUSH
100152: DOUBLE
100153: LD_INT 1
100155: DEC
100156: ST_TO_ADDR
100157: LD_INT 3
100159: PUSH
100160: FOR_TO
100161: IFFALSE 100187
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100163: LD_VAR 0 2
100167: PPUSH
100168: CALL_OW 274
100172: PPUSH
100173: LD_VAR 0 3
100177: PPUSH
100178: LD_INT 99999
100180: PPUSH
100181: CALL_OW 277
100185: GO 100160
100187: POP
100188: POP
100189: GO 100144
100191: POP
100192: POP
// end ;
100193: LD_VAR 0 1
100197: RET
// export function hHackSetLevel10 ; var i , j ; begin
100198: LD_INT 0
100200: PPUSH
100201: PPUSH
100202: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100203: LD_ADDR_VAR 0 2
100207: PUSH
100208: LD_INT 21
100210: PUSH
100211: LD_INT 1
100213: PUSH
100214: EMPTY
100215: LIST
100216: LIST
100217: PPUSH
100218: CALL_OW 69
100222: PUSH
100223: FOR_IN
100224: IFFALSE 100276
// if IsSelected ( i ) then
100226: LD_VAR 0 2
100230: PPUSH
100231: CALL_OW 306
100235: IFFALSE 100274
// begin for j := 1 to 4 do
100237: LD_ADDR_VAR 0 3
100241: PUSH
100242: DOUBLE
100243: LD_INT 1
100245: DEC
100246: ST_TO_ADDR
100247: LD_INT 4
100249: PUSH
100250: FOR_TO
100251: IFFALSE 100272
// SetSkill ( i , j , 10 ) ;
100253: LD_VAR 0 2
100257: PPUSH
100258: LD_VAR 0 3
100262: PPUSH
100263: LD_INT 10
100265: PPUSH
100266: CALL_OW 237
100270: GO 100250
100272: POP
100273: POP
// end ;
100274: GO 100223
100276: POP
100277: POP
// end ;
100278: LD_VAR 0 1
100282: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100283: LD_INT 0
100285: PPUSH
100286: PPUSH
100287: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100288: LD_ADDR_VAR 0 2
100292: PUSH
100293: LD_INT 22
100295: PUSH
100296: LD_OWVAR 2
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 21
100307: PUSH
100308: LD_INT 1
100310: PUSH
100311: EMPTY
100312: LIST
100313: LIST
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: PPUSH
100319: CALL_OW 69
100323: PUSH
100324: FOR_IN
100325: IFFALSE 100366
// begin for j := 1 to 4 do
100327: LD_ADDR_VAR 0 3
100331: PUSH
100332: DOUBLE
100333: LD_INT 1
100335: DEC
100336: ST_TO_ADDR
100337: LD_INT 4
100339: PUSH
100340: FOR_TO
100341: IFFALSE 100362
// SetSkill ( i , j , 10 ) ;
100343: LD_VAR 0 2
100347: PPUSH
100348: LD_VAR 0 3
100352: PPUSH
100353: LD_INT 10
100355: PPUSH
100356: CALL_OW 237
100360: GO 100340
100362: POP
100363: POP
// end ;
100364: GO 100324
100366: POP
100367: POP
// end ;
100368: LD_VAR 0 1
100372: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100373: LD_INT 0
100375: PPUSH
// uc_side := your_side ;
100376: LD_ADDR_OWVAR 20
100380: PUSH
100381: LD_OWVAR 2
100385: ST_TO_ADDR
// uc_nation := nation ;
100386: LD_ADDR_OWVAR 21
100390: PUSH
100391: LD_VAR 0 1
100395: ST_TO_ADDR
// InitHc ;
100396: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100400: LD_INT 0
100402: PPUSH
100403: LD_VAR 0 2
100407: PPUSH
100408: LD_VAR 0 3
100412: PPUSH
100413: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100417: LD_VAR 0 4
100421: PPUSH
100422: LD_VAR 0 5
100426: PPUSH
100427: CALL_OW 428
100431: PUSH
100432: LD_INT 0
100434: EQUAL
100435: IFFALSE 100459
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100437: CALL_OW 44
100441: PPUSH
100442: LD_VAR 0 4
100446: PPUSH
100447: LD_VAR 0 5
100451: PPUSH
100452: LD_INT 1
100454: PPUSH
100455: CALL_OW 48
// end ;
100459: LD_VAR 0 6
100463: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100464: LD_INT 0
100466: PPUSH
100467: PPUSH
// uc_side := your_side ;
100468: LD_ADDR_OWVAR 20
100472: PUSH
100473: LD_OWVAR 2
100477: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100478: LD_VAR 0 1
100482: PUSH
100483: LD_INT 1
100485: PUSH
100486: LD_INT 2
100488: PUSH
100489: LD_INT 3
100491: PUSH
100492: LD_INT 4
100494: PUSH
100495: LD_INT 5
100497: PUSH
100498: EMPTY
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: IN
100505: IFFALSE 100517
// uc_nation := nation_american else
100507: LD_ADDR_OWVAR 21
100511: PUSH
100512: LD_INT 1
100514: ST_TO_ADDR
100515: GO 100560
// if chassis in [ 11 , 12 , 13 , 14 ] then
100517: LD_VAR 0 1
100521: PUSH
100522: LD_INT 11
100524: PUSH
100525: LD_INT 12
100527: PUSH
100528: LD_INT 13
100530: PUSH
100531: LD_INT 14
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: LIST
100538: LIST
100539: IN
100540: IFFALSE 100552
// uc_nation := nation_arabian else
100542: LD_ADDR_OWVAR 21
100546: PUSH
100547: LD_INT 2
100549: ST_TO_ADDR
100550: GO 100560
// uc_nation := nation_russian ;
100552: LD_ADDR_OWVAR 21
100556: PUSH
100557: LD_INT 3
100559: ST_TO_ADDR
// vc_chassis := chassis ;
100560: LD_ADDR_OWVAR 37
100564: PUSH
100565: LD_VAR 0 1
100569: ST_TO_ADDR
// vc_engine := engine ;
100570: LD_ADDR_OWVAR 39
100574: PUSH
100575: LD_VAR 0 2
100579: ST_TO_ADDR
// vc_control := control ;
100580: LD_ADDR_OWVAR 38
100584: PUSH
100585: LD_VAR 0 3
100589: ST_TO_ADDR
// vc_weapon := weapon ;
100590: LD_ADDR_OWVAR 40
100594: PUSH
100595: LD_VAR 0 4
100599: ST_TO_ADDR
// un := CreateVehicle ;
100600: LD_ADDR_VAR 0 8
100604: PUSH
100605: CALL_OW 45
100609: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100610: LD_VAR 0 8
100614: PPUSH
100615: LD_INT 0
100617: PPUSH
100618: LD_INT 5
100620: PPUSH
100621: CALL_OW 12
100625: PPUSH
100626: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100630: LD_VAR 0 8
100634: PPUSH
100635: LD_VAR 0 5
100639: PPUSH
100640: LD_VAR 0 6
100644: PPUSH
100645: LD_INT 1
100647: PPUSH
100648: CALL_OW 48
// end ;
100652: LD_VAR 0 7
100656: RET
// export hInvincible ; every 1 do
100657: GO 100659
100659: DISABLE
// hInvincible := [ ] ;
100660: LD_ADDR_EXP 187
100664: PUSH
100665: EMPTY
100666: ST_TO_ADDR
100667: END
// every 10 do var i ;
100668: GO 100670
100670: DISABLE
100671: LD_INT 0
100673: PPUSH
// begin enable ;
100674: ENABLE
// if not hInvincible then
100675: LD_EXP 187
100679: NOT
100680: IFFALSE 100684
// exit ;
100682: GO 100728
// for i in hInvincible do
100684: LD_ADDR_VAR 0 1
100688: PUSH
100689: LD_EXP 187
100693: PUSH
100694: FOR_IN
100695: IFFALSE 100726
// if GetLives ( i ) < 1000 then
100697: LD_VAR 0 1
100701: PPUSH
100702: CALL_OW 256
100706: PUSH
100707: LD_INT 1000
100709: LESS
100710: IFFALSE 100724
// SetLives ( i , 1000 ) ;
100712: LD_VAR 0 1
100716: PPUSH
100717: LD_INT 1000
100719: PPUSH
100720: CALL_OW 234
100724: GO 100694
100726: POP
100727: POP
// end ;
100728: PPOPN 1
100730: END
// export function hHackInvincible ; var i ; begin
100731: LD_INT 0
100733: PPUSH
100734: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100735: LD_ADDR_VAR 0 2
100739: PUSH
100740: LD_INT 2
100742: PUSH
100743: LD_INT 21
100745: PUSH
100746: LD_INT 1
100748: PUSH
100749: EMPTY
100750: LIST
100751: LIST
100752: PUSH
100753: LD_INT 21
100755: PUSH
100756: LD_INT 2
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: LIST
100767: PPUSH
100768: CALL_OW 69
100772: PUSH
100773: FOR_IN
100774: IFFALSE 100835
// if IsSelected ( i ) then
100776: LD_VAR 0 2
100780: PPUSH
100781: CALL_OW 306
100785: IFFALSE 100833
// begin if i in hInvincible then
100787: LD_VAR 0 2
100791: PUSH
100792: LD_EXP 187
100796: IN
100797: IFFALSE 100817
// hInvincible := hInvincible diff i else
100799: LD_ADDR_EXP 187
100803: PUSH
100804: LD_EXP 187
100808: PUSH
100809: LD_VAR 0 2
100813: DIFF
100814: ST_TO_ADDR
100815: GO 100833
// hInvincible := hInvincible union i ;
100817: LD_ADDR_EXP 187
100821: PUSH
100822: LD_EXP 187
100826: PUSH
100827: LD_VAR 0 2
100831: UNION
100832: ST_TO_ADDR
// end ;
100833: GO 100773
100835: POP
100836: POP
// end ;
100837: LD_VAR 0 1
100841: RET
// export function hHackInvisible ; var i , j ; begin
100842: LD_INT 0
100844: PPUSH
100845: PPUSH
100846: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100847: LD_ADDR_VAR 0 2
100851: PUSH
100852: LD_INT 21
100854: PUSH
100855: LD_INT 1
100857: PUSH
100858: EMPTY
100859: LIST
100860: LIST
100861: PPUSH
100862: CALL_OW 69
100866: PUSH
100867: FOR_IN
100868: IFFALSE 100892
// if IsSelected ( i ) then
100870: LD_VAR 0 2
100874: PPUSH
100875: CALL_OW 306
100879: IFFALSE 100890
// ComForceInvisible ( i ) ;
100881: LD_VAR 0 2
100885: PPUSH
100886: CALL_OW 496
100890: GO 100867
100892: POP
100893: POP
// end ;
100894: LD_VAR 0 1
100898: RET
// export function hHackChangeYourSide ; begin
100899: LD_INT 0
100901: PPUSH
// if your_side = 8 then
100902: LD_OWVAR 2
100906: PUSH
100907: LD_INT 8
100909: EQUAL
100910: IFFALSE 100922
// your_side := 0 else
100912: LD_ADDR_OWVAR 2
100916: PUSH
100917: LD_INT 0
100919: ST_TO_ADDR
100920: GO 100936
// your_side := your_side + 1 ;
100922: LD_ADDR_OWVAR 2
100926: PUSH
100927: LD_OWVAR 2
100931: PUSH
100932: LD_INT 1
100934: PLUS
100935: ST_TO_ADDR
// end ;
100936: LD_VAR 0 1
100940: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100941: LD_INT 0
100943: PPUSH
100944: PPUSH
100945: PPUSH
// for i in all_units do
100946: LD_ADDR_VAR 0 2
100950: PUSH
100951: LD_OWVAR 3
100955: PUSH
100956: FOR_IN
100957: IFFALSE 101035
// if IsSelected ( i ) then
100959: LD_VAR 0 2
100963: PPUSH
100964: CALL_OW 306
100968: IFFALSE 101033
// begin j := GetSide ( i ) ;
100970: LD_ADDR_VAR 0 3
100974: PUSH
100975: LD_VAR 0 2
100979: PPUSH
100980: CALL_OW 255
100984: ST_TO_ADDR
// if j = 8 then
100985: LD_VAR 0 3
100989: PUSH
100990: LD_INT 8
100992: EQUAL
100993: IFFALSE 101005
// j := 0 else
100995: LD_ADDR_VAR 0 3
100999: PUSH
101000: LD_INT 0
101002: ST_TO_ADDR
101003: GO 101019
// j := j + 1 ;
101005: LD_ADDR_VAR 0 3
101009: PUSH
101010: LD_VAR 0 3
101014: PUSH
101015: LD_INT 1
101017: PLUS
101018: ST_TO_ADDR
// SetSide ( i , j ) ;
101019: LD_VAR 0 2
101023: PPUSH
101024: LD_VAR 0 3
101028: PPUSH
101029: CALL_OW 235
// end ;
101033: GO 100956
101035: POP
101036: POP
// end ;
101037: LD_VAR 0 1
101041: RET
// export function hHackFog ; begin
101042: LD_INT 0
101044: PPUSH
// FogOff ( true ) ;
101045: LD_INT 1
101047: PPUSH
101048: CALL_OW 344
// end ;
101052: LD_VAR 0 1
101056: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101057: LD_INT 0
101059: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101060: LD_VAR 0 1
101064: PPUSH
101065: LD_VAR 0 2
101069: PPUSH
101070: LD_VAR 0 3
101074: PPUSH
101075: LD_INT 1
101077: PPUSH
101078: LD_INT 1
101080: PPUSH
101081: CALL_OW 483
// CenterOnXY ( x , y ) ;
101085: LD_VAR 0 2
101089: PPUSH
101090: LD_VAR 0 3
101094: PPUSH
101095: CALL_OW 84
// end ; end_of_file
101099: LD_VAR 0 4
101103: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101104: LD_INT 0
101106: PPUSH
101107: PPUSH
101108: PPUSH
101109: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101110: LD_VAR 0 1
101114: PPUSH
101115: CALL_OW 264
101119: PUSH
101120: LD_EXP 76
101124: EQUAL
101125: IFFALSE 101197
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101127: LD_INT 68
101129: PPUSH
101130: LD_VAR 0 1
101134: PPUSH
101135: CALL_OW 255
101139: PPUSH
101140: CALL_OW 321
101144: PUSH
101145: LD_INT 2
101147: EQUAL
101148: IFFALSE 101160
// eff := 70 else
101150: LD_ADDR_VAR 0 4
101154: PUSH
101155: LD_INT 70
101157: ST_TO_ADDR
101158: GO 101168
// eff := 30 ;
101160: LD_ADDR_VAR 0 4
101164: PUSH
101165: LD_INT 30
101167: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101168: LD_VAR 0 1
101172: PPUSH
101173: CALL_OW 250
101177: PPUSH
101178: LD_VAR 0 1
101182: PPUSH
101183: CALL_OW 251
101187: PPUSH
101188: LD_VAR 0 4
101192: PPUSH
101193: CALL_OW 495
// end ; end ;
101197: LD_VAR 0 2
101201: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101202: LD_INT 0
101204: PPUSH
// end ;
101205: LD_VAR 0 4
101209: RET
// export function SOS_Command ( cmd ) ; begin
101210: LD_INT 0
101212: PPUSH
// end ;
101213: LD_VAR 0 2
101217: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101218: LD_INT 0
101220: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101221: LD_VAR 0 1
101225: PUSH
101226: LD_INT 250
101228: EQUAL
101229: PUSH
101230: LD_VAR 0 2
101234: PPUSH
101235: CALL_OW 264
101239: PUSH
101240: LD_EXP 79
101244: EQUAL
101245: AND
101246: IFFALSE 101267
// MinerPlaceMine ( unit , x , y ) ;
101248: LD_VAR 0 2
101252: PPUSH
101253: LD_VAR 0 4
101257: PPUSH
101258: LD_VAR 0 5
101262: PPUSH
101263: CALL 103608 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101267: LD_VAR 0 1
101271: PUSH
101272: LD_INT 251
101274: EQUAL
101275: PUSH
101276: LD_VAR 0 2
101280: PPUSH
101281: CALL_OW 264
101285: PUSH
101286: LD_EXP 79
101290: EQUAL
101291: AND
101292: IFFALSE 101313
// MinerDetonateMine ( unit , x , y ) ;
101294: LD_VAR 0 2
101298: PPUSH
101299: LD_VAR 0 4
101303: PPUSH
101304: LD_VAR 0 5
101308: PPUSH
101309: CALL 103885 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101313: LD_VAR 0 1
101317: PUSH
101318: LD_INT 252
101320: EQUAL
101321: PUSH
101322: LD_VAR 0 2
101326: PPUSH
101327: CALL_OW 264
101331: PUSH
101332: LD_EXP 79
101336: EQUAL
101337: AND
101338: IFFALSE 101359
// MinerCreateMinefield ( unit , x , y ) ;
101340: LD_VAR 0 2
101344: PPUSH
101345: LD_VAR 0 4
101349: PPUSH
101350: LD_VAR 0 5
101354: PPUSH
101355: CALL 104302 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101359: LD_VAR 0 1
101363: PUSH
101364: LD_INT 253
101366: EQUAL
101367: PUSH
101368: LD_VAR 0 2
101372: PPUSH
101373: CALL_OW 257
101377: PUSH
101378: LD_INT 5
101380: EQUAL
101381: AND
101382: IFFALSE 101403
// ComBinocular ( unit , x , y ) ;
101384: LD_VAR 0 2
101388: PPUSH
101389: LD_VAR 0 4
101393: PPUSH
101394: LD_VAR 0 5
101398: PPUSH
101399: CALL 104673 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101403: LD_VAR 0 1
101407: PUSH
101408: LD_INT 254
101410: EQUAL
101411: PUSH
101412: LD_VAR 0 2
101416: PPUSH
101417: CALL_OW 264
101421: PUSH
101422: LD_EXP 74
101426: EQUAL
101427: AND
101428: PUSH
101429: LD_VAR 0 3
101433: PPUSH
101434: CALL_OW 263
101438: PUSH
101439: LD_INT 3
101441: EQUAL
101442: AND
101443: IFFALSE 101459
// HackDestroyVehicle ( unit , selectedUnit ) ;
101445: LD_VAR 0 2
101449: PPUSH
101450: LD_VAR 0 3
101454: PPUSH
101455: CALL 102968 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101459: LD_VAR 0 1
101463: PUSH
101464: LD_INT 255
101466: EQUAL
101467: PUSH
101468: LD_VAR 0 2
101472: PPUSH
101473: CALL_OW 264
101477: PUSH
101478: LD_INT 14
101480: PUSH
101481: LD_INT 53
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: IN
101488: AND
101489: PUSH
101490: LD_VAR 0 4
101494: PPUSH
101495: LD_VAR 0 5
101499: PPUSH
101500: CALL_OW 488
101504: AND
101505: IFFALSE 101529
// CutTreeXYR ( unit , x , y , 12 ) ;
101507: LD_VAR 0 2
101511: PPUSH
101512: LD_VAR 0 4
101516: PPUSH
101517: LD_VAR 0 5
101521: PPUSH
101522: LD_INT 12
101524: PPUSH
101525: CALL 101534 0 4
// end ;
101529: LD_VAR 0 6
101533: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101534: LD_INT 0
101536: PPUSH
101537: PPUSH
101538: PPUSH
101539: PPUSH
101540: PPUSH
101541: PPUSH
101542: PPUSH
101543: PPUSH
101544: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101545: LD_VAR 0 1
101549: NOT
101550: PUSH
101551: LD_VAR 0 2
101555: PPUSH
101556: LD_VAR 0 3
101560: PPUSH
101561: CALL_OW 488
101565: NOT
101566: OR
101567: PUSH
101568: LD_VAR 0 4
101572: NOT
101573: OR
101574: IFFALSE 101578
// exit ;
101576: GO 101918
// list := [ ] ;
101578: LD_ADDR_VAR 0 13
101582: PUSH
101583: EMPTY
101584: ST_TO_ADDR
// if x - r < 0 then
101585: LD_VAR 0 2
101589: PUSH
101590: LD_VAR 0 4
101594: MINUS
101595: PUSH
101596: LD_INT 0
101598: LESS
101599: IFFALSE 101611
// min_x := 0 else
101601: LD_ADDR_VAR 0 7
101605: PUSH
101606: LD_INT 0
101608: ST_TO_ADDR
101609: GO 101627
// min_x := x - r ;
101611: LD_ADDR_VAR 0 7
101615: PUSH
101616: LD_VAR 0 2
101620: PUSH
101621: LD_VAR 0 4
101625: MINUS
101626: ST_TO_ADDR
// if y - r < 0 then
101627: LD_VAR 0 3
101631: PUSH
101632: LD_VAR 0 4
101636: MINUS
101637: PUSH
101638: LD_INT 0
101640: LESS
101641: IFFALSE 101653
// min_y := 0 else
101643: LD_ADDR_VAR 0 8
101647: PUSH
101648: LD_INT 0
101650: ST_TO_ADDR
101651: GO 101669
// min_y := y - r ;
101653: LD_ADDR_VAR 0 8
101657: PUSH
101658: LD_VAR 0 3
101662: PUSH
101663: LD_VAR 0 4
101667: MINUS
101668: ST_TO_ADDR
// max_x := x + r ;
101669: LD_ADDR_VAR 0 9
101673: PUSH
101674: LD_VAR 0 2
101678: PUSH
101679: LD_VAR 0 4
101683: PLUS
101684: ST_TO_ADDR
// max_y := y + r ;
101685: LD_ADDR_VAR 0 10
101689: PUSH
101690: LD_VAR 0 3
101694: PUSH
101695: LD_VAR 0 4
101699: PLUS
101700: ST_TO_ADDR
// for _x = min_x to max_x do
101701: LD_ADDR_VAR 0 11
101705: PUSH
101706: DOUBLE
101707: LD_VAR 0 7
101711: DEC
101712: ST_TO_ADDR
101713: LD_VAR 0 9
101717: PUSH
101718: FOR_TO
101719: IFFALSE 101836
// for _y = min_y to max_y do
101721: LD_ADDR_VAR 0 12
101725: PUSH
101726: DOUBLE
101727: LD_VAR 0 8
101731: DEC
101732: ST_TO_ADDR
101733: LD_VAR 0 10
101737: PUSH
101738: FOR_TO
101739: IFFALSE 101832
// begin if not ValidHex ( _x , _y ) then
101741: LD_VAR 0 11
101745: PPUSH
101746: LD_VAR 0 12
101750: PPUSH
101751: CALL_OW 488
101755: NOT
101756: IFFALSE 101760
// continue ;
101758: GO 101738
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101760: LD_VAR 0 11
101764: PPUSH
101765: LD_VAR 0 12
101769: PPUSH
101770: CALL_OW 351
101774: PUSH
101775: LD_VAR 0 11
101779: PPUSH
101780: LD_VAR 0 12
101784: PPUSH
101785: CALL_OW 554
101789: AND
101790: IFFALSE 101830
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101792: LD_ADDR_VAR 0 13
101796: PUSH
101797: LD_VAR 0 13
101801: PPUSH
101802: LD_VAR 0 13
101806: PUSH
101807: LD_INT 1
101809: PLUS
101810: PPUSH
101811: LD_VAR 0 11
101815: PUSH
101816: LD_VAR 0 12
101820: PUSH
101821: EMPTY
101822: LIST
101823: LIST
101824: PPUSH
101825: CALL_OW 2
101829: ST_TO_ADDR
// end ;
101830: GO 101738
101832: POP
101833: POP
101834: GO 101718
101836: POP
101837: POP
// if not list then
101838: LD_VAR 0 13
101842: NOT
101843: IFFALSE 101847
// exit ;
101845: GO 101918
// for i in list do
101847: LD_ADDR_VAR 0 6
101851: PUSH
101852: LD_VAR 0 13
101856: PUSH
101857: FOR_IN
101858: IFFALSE 101916
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101860: LD_VAR 0 1
101864: PPUSH
101865: LD_STRING M
101867: PUSH
101868: LD_VAR 0 6
101872: PUSH
101873: LD_INT 1
101875: ARRAY
101876: PUSH
101877: LD_VAR 0 6
101881: PUSH
101882: LD_INT 2
101884: ARRAY
101885: PUSH
101886: LD_INT 0
101888: PUSH
101889: LD_INT 0
101891: PUSH
101892: LD_INT 0
101894: PUSH
101895: LD_INT 0
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: LIST
101902: LIST
101903: LIST
101904: LIST
101905: LIST
101906: PUSH
101907: EMPTY
101908: LIST
101909: PPUSH
101910: CALL_OW 447
101914: GO 101857
101916: POP
101917: POP
// end ;
101918: LD_VAR 0 5
101922: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101923: LD_EXP 188
101927: NOT
101928: IFFALSE 101978
101930: GO 101932
101932: DISABLE
// begin initHack := true ;
101933: LD_ADDR_EXP 188
101937: PUSH
101938: LD_INT 1
101940: ST_TO_ADDR
// hackTanks := [ ] ;
101941: LD_ADDR_EXP 189
101945: PUSH
101946: EMPTY
101947: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101948: LD_ADDR_EXP 190
101952: PUSH
101953: EMPTY
101954: ST_TO_ADDR
// hackLimit := 3 ;
101955: LD_ADDR_EXP 191
101959: PUSH
101960: LD_INT 3
101962: ST_TO_ADDR
// hackDist := 12 ;
101963: LD_ADDR_EXP 192
101967: PUSH
101968: LD_INT 12
101970: ST_TO_ADDR
// hackCounter := [ ] ;
101971: LD_ADDR_EXP 193
101975: PUSH
101976: EMPTY
101977: ST_TO_ADDR
// end ;
101978: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101979: LD_EXP 188
101983: PUSH
101984: LD_INT 34
101986: PUSH
101987: LD_EXP 74
101991: PUSH
101992: EMPTY
101993: LIST
101994: LIST
101995: PPUSH
101996: CALL_OW 69
102000: AND
102001: IFFALSE 102256
102003: GO 102005
102005: DISABLE
102006: LD_INT 0
102008: PPUSH
102009: PPUSH
// begin enable ;
102010: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102011: LD_ADDR_VAR 0 1
102015: PUSH
102016: LD_INT 34
102018: PUSH
102019: LD_EXP 74
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PPUSH
102028: CALL_OW 69
102032: PUSH
102033: FOR_IN
102034: IFFALSE 102254
// begin if not i in hackTanks then
102036: LD_VAR 0 1
102040: PUSH
102041: LD_EXP 189
102045: IN
102046: NOT
102047: IFFALSE 102130
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102049: LD_ADDR_EXP 189
102053: PUSH
102054: LD_EXP 189
102058: PPUSH
102059: LD_EXP 189
102063: PUSH
102064: LD_INT 1
102066: PLUS
102067: PPUSH
102068: LD_VAR 0 1
102072: PPUSH
102073: CALL_OW 1
102077: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102078: LD_ADDR_EXP 190
102082: PUSH
102083: LD_EXP 190
102087: PPUSH
102088: LD_EXP 190
102092: PUSH
102093: LD_INT 1
102095: PLUS
102096: PPUSH
102097: EMPTY
102098: PPUSH
102099: CALL_OW 1
102103: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102104: LD_ADDR_EXP 193
102108: PUSH
102109: LD_EXP 193
102113: PPUSH
102114: LD_EXP 193
102118: PUSH
102119: LD_INT 1
102121: PLUS
102122: PPUSH
102123: EMPTY
102124: PPUSH
102125: CALL_OW 1
102129: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102130: LD_VAR 0 1
102134: PPUSH
102135: CALL_OW 302
102139: NOT
102140: IFFALSE 102153
// begin HackUnlinkAll ( i ) ;
102142: LD_VAR 0 1
102146: PPUSH
102147: CALL 102259 0 1
// continue ;
102151: GO 102033
// end ; HackCheckCapturedStatus ( i ) ;
102153: LD_VAR 0 1
102157: PPUSH
102158: CALL 102702 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102162: LD_ADDR_VAR 0 2
102166: PUSH
102167: LD_INT 81
102169: PUSH
102170: LD_VAR 0 1
102174: PPUSH
102175: CALL_OW 255
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: PUSH
102184: LD_INT 33
102186: PUSH
102187: LD_INT 3
102189: PUSH
102190: EMPTY
102191: LIST
102192: LIST
102193: PUSH
102194: LD_INT 91
102196: PUSH
102197: LD_VAR 0 1
102201: PUSH
102202: LD_EXP 192
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: LIST
102211: PUSH
102212: LD_INT 50
102214: PUSH
102215: EMPTY
102216: LIST
102217: PUSH
102218: EMPTY
102219: LIST
102220: LIST
102221: LIST
102222: LIST
102223: PPUSH
102224: CALL_OW 69
102228: ST_TO_ADDR
// if not tmp then
102229: LD_VAR 0 2
102233: NOT
102234: IFFALSE 102238
// continue ;
102236: GO 102033
// HackLink ( i , tmp ) ;
102238: LD_VAR 0 1
102242: PPUSH
102243: LD_VAR 0 2
102247: PPUSH
102248: CALL 102395 0 2
// end ;
102252: GO 102033
102254: POP
102255: POP
// end ;
102256: PPOPN 2
102258: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102259: LD_INT 0
102261: PPUSH
102262: PPUSH
102263: PPUSH
// if not hack in hackTanks then
102264: LD_VAR 0 1
102268: PUSH
102269: LD_EXP 189
102273: IN
102274: NOT
102275: IFFALSE 102279
// exit ;
102277: GO 102390
// index := GetElementIndex ( hackTanks , hack ) ;
102279: LD_ADDR_VAR 0 4
102283: PUSH
102284: LD_EXP 189
102288: PPUSH
102289: LD_VAR 0 1
102293: PPUSH
102294: CALL 55599 0 2
102298: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102299: LD_EXP 190
102303: PUSH
102304: LD_VAR 0 4
102308: ARRAY
102309: IFFALSE 102390
// begin for i in hackTanksCaptured [ index ] do
102311: LD_ADDR_VAR 0 3
102315: PUSH
102316: LD_EXP 190
102320: PUSH
102321: LD_VAR 0 4
102325: ARRAY
102326: PUSH
102327: FOR_IN
102328: IFFALSE 102354
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102330: LD_VAR 0 3
102334: PUSH
102335: LD_INT 1
102337: ARRAY
102338: PPUSH
102339: LD_VAR 0 3
102343: PUSH
102344: LD_INT 2
102346: ARRAY
102347: PPUSH
102348: CALL_OW 235
102352: GO 102327
102354: POP
102355: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102356: LD_ADDR_EXP 190
102360: PUSH
102361: LD_EXP 190
102365: PPUSH
102366: LD_VAR 0 4
102370: PPUSH
102371: EMPTY
102372: PPUSH
102373: CALL_OW 1
102377: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102378: LD_VAR 0 1
102382: PPUSH
102383: LD_INT 0
102385: PPUSH
102386: CALL_OW 505
// end ; end ;
102390: LD_VAR 0 2
102394: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102395: LD_INT 0
102397: PPUSH
102398: PPUSH
102399: PPUSH
// if not hack in hackTanks or not vehicles then
102400: LD_VAR 0 1
102404: PUSH
102405: LD_EXP 189
102409: IN
102410: NOT
102411: PUSH
102412: LD_VAR 0 2
102416: NOT
102417: OR
102418: IFFALSE 102422
// exit ;
102420: GO 102697
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102422: LD_ADDR_VAR 0 2
102426: PUSH
102427: LD_VAR 0 1
102431: PPUSH
102432: LD_VAR 0 2
102436: PPUSH
102437: LD_INT 1
102439: PPUSH
102440: LD_INT 1
102442: PPUSH
102443: CALL 56249 0 4
102447: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102448: LD_ADDR_VAR 0 5
102452: PUSH
102453: LD_EXP 189
102457: PPUSH
102458: LD_VAR 0 1
102462: PPUSH
102463: CALL 55599 0 2
102467: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102468: LD_EXP 190
102472: PUSH
102473: LD_VAR 0 5
102477: ARRAY
102478: PUSH
102479: LD_EXP 191
102483: LESS
102484: IFFALSE 102673
// begin for i := 1 to vehicles do
102486: LD_ADDR_VAR 0 4
102490: PUSH
102491: DOUBLE
102492: LD_INT 1
102494: DEC
102495: ST_TO_ADDR
102496: LD_VAR 0 2
102500: PUSH
102501: FOR_TO
102502: IFFALSE 102671
// begin if hackTanksCaptured [ index ] = hackLimit then
102504: LD_EXP 190
102508: PUSH
102509: LD_VAR 0 5
102513: ARRAY
102514: PUSH
102515: LD_EXP 191
102519: EQUAL
102520: IFFALSE 102524
// break ;
102522: GO 102671
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102524: LD_ADDR_EXP 193
102528: PUSH
102529: LD_EXP 193
102533: PPUSH
102534: LD_VAR 0 5
102538: PPUSH
102539: LD_EXP 193
102543: PUSH
102544: LD_VAR 0 5
102548: ARRAY
102549: PUSH
102550: LD_INT 1
102552: PLUS
102553: PPUSH
102554: CALL_OW 1
102558: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102559: LD_ADDR_EXP 190
102563: PUSH
102564: LD_EXP 190
102568: PPUSH
102569: LD_VAR 0 5
102573: PUSH
102574: LD_EXP 190
102578: PUSH
102579: LD_VAR 0 5
102583: ARRAY
102584: PUSH
102585: LD_INT 1
102587: PLUS
102588: PUSH
102589: EMPTY
102590: LIST
102591: LIST
102592: PPUSH
102593: LD_VAR 0 2
102597: PUSH
102598: LD_VAR 0 4
102602: ARRAY
102603: PUSH
102604: LD_VAR 0 2
102608: PUSH
102609: LD_VAR 0 4
102613: ARRAY
102614: PPUSH
102615: CALL_OW 255
102619: PUSH
102620: EMPTY
102621: LIST
102622: LIST
102623: PPUSH
102624: CALL 55814 0 3
102628: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102629: LD_VAR 0 2
102633: PUSH
102634: LD_VAR 0 4
102638: ARRAY
102639: PPUSH
102640: LD_VAR 0 1
102644: PPUSH
102645: CALL_OW 255
102649: PPUSH
102650: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102654: LD_VAR 0 2
102658: PUSH
102659: LD_VAR 0 4
102663: ARRAY
102664: PPUSH
102665: CALL_OW 141
// end ;
102669: GO 102501
102671: POP
102672: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102673: LD_VAR 0 1
102677: PPUSH
102678: LD_EXP 190
102682: PUSH
102683: LD_VAR 0 5
102687: ARRAY
102688: PUSH
102689: LD_INT 0
102691: PLUS
102692: PPUSH
102693: CALL_OW 505
// end ;
102697: LD_VAR 0 3
102701: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102702: LD_INT 0
102704: PPUSH
102705: PPUSH
102706: PPUSH
102707: PPUSH
// if not hack in hackTanks then
102708: LD_VAR 0 1
102712: PUSH
102713: LD_EXP 189
102717: IN
102718: NOT
102719: IFFALSE 102723
// exit ;
102721: GO 102963
// index := GetElementIndex ( hackTanks , hack ) ;
102723: LD_ADDR_VAR 0 4
102727: PUSH
102728: LD_EXP 189
102732: PPUSH
102733: LD_VAR 0 1
102737: PPUSH
102738: CALL 55599 0 2
102742: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102743: LD_ADDR_VAR 0 3
102747: PUSH
102748: DOUBLE
102749: LD_EXP 190
102753: PUSH
102754: LD_VAR 0 4
102758: ARRAY
102759: INC
102760: ST_TO_ADDR
102761: LD_INT 1
102763: PUSH
102764: FOR_DOWNTO
102765: IFFALSE 102937
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102767: LD_ADDR_VAR 0 5
102771: PUSH
102772: LD_EXP 190
102776: PUSH
102777: LD_VAR 0 4
102781: ARRAY
102782: PUSH
102783: LD_VAR 0 3
102787: ARRAY
102788: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102789: LD_VAR 0 5
102793: PUSH
102794: LD_INT 1
102796: ARRAY
102797: PPUSH
102798: CALL_OW 302
102802: NOT
102803: PUSH
102804: LD_VAR 0 5
102808: PUSH
102809: LD_INT 1
102811: ARRAY
102812: PPUSH
102813: CALL_OW 255
102817: PUSH
102818: LD_VAR 0 1
102822: PPUSH
102823: CALL_OW 255
102827: NONEQUAL
102828: OR
102829: IFFALSE 102935
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102831: LD_VAR 0 5
102835: PUSH
102836: LD_INT 1
102838: ARRAY
102839: PPUSH
102840: CALL_OW 305
102844: PUSH
102845: LD_VAR 0 5
102849: PUSH
102850: LD_INT 1
102852: ARRAY
102853: PPUSH
102854: CALL_OW 255
102858: PUSH
102859: LD_VAR 0 1
102863: PPUSH
102864: CALL_OW 255
102868: EQUAL
102869: AND
102870: IFFALSE 102894
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102872: LD_VAR 0 5
102876: PUSH
102877: LD_INT 1
102879: ARRAY
102880: PPUSH
102881: LD_VAR 0 5
102885: PUSH
102886: LD_INT 2
102888: ARRAY
102889: PPUSH
102890: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102894: LD_ADDR_EXP 190
102898: PUSH
102899: LD_EXP 190
102903: PPUSH
102904: LD_VAR 0 4
102908: PPUSH
102909: LD_EXP 190
102913: PUSH
102914: LD_VAR 0 4
102918: ARRAY
102919: PPUSH
102920: LD_VAR 0 3
102924: PPUSH
102925: CALL_OW 3
102929: PPUSH
102930: CALL_OW 1
102934: ST_TO_ADDR
// end ; end ;
102935: GO 102764
102937: POP
102938: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102939: LD_VAR 0 1
102943: PPUSH
102944: LD_EXP 190
102948: PUSH
102949: LD_VAR 0 4
102953: ARRAY
102954: PUSH
102955: LD_INT 0
102957: PLUS
102958: PPUSH
102959: CALL_OW 505
// end ;
102963: LD_VAR 0 2
102967: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102968: LD_INT 0
102970: PPUSH
102971: PPUSH
102972: PPUSH
102973: PPUSH
// if not hack in hackTanks then
102974: LD_VAR 0 1
102978: PUSH
102979: LD_EXP 189
102983: IN
102984: NOT
102985: IFFALSE 102989
// exit ;
102987: GO 103074
// index := GetElementIndex ( hackTanks , hack ) ;
102989: LD_ADDR_VAR 0 5
102993: PUSH
102994: LD_EXP 189
102998: PPUSH
102999: LD_VAR 0 1
103003: PPUSH
103004: CALL 55599 0 2
103008: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103009: LD_ADDR_VAR 0 4
103013: PUSH
103014: DOUBLE
103015: LD_INT 1
103017: DEC
103018: ST_TO_ADDR
103019: LD_EXP 190
103023: PUSH
103024: LD_VAR 0 5
103028: ARRAY
103029: PUSH
103030: FOR_TO
103031: IFFALSE 103072
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103033: LD_EXP 190
103037: PUSH
103038: LD_VAR 0 5
103042: ARRAY
103043: PUSH
103044: LD_VAR 0 4
103048: ARRAY
103049: PUSH
103050: LD_INT 1
103052: ARRAY
103053: PUSH
103054: LD_VAR 0 2
103058: EQUAL
103059: IFFALSE 103070
// KillUnit ( vehicle ) ;
103061: LD_VAR 0 2
103065: PPUSH
103066: CALL_OW 66
103070: GO 103030
103072: POP
103073: POP
// end ;
103074: LD_VAR 0 3
103078: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103079: LD_EXP 194
103083: NOT
103084: IFFALSE 103119
103086: GO 103088
103088: DISABLE
// begin initMiner := true ;
103089: LD_ADDR_EXP 194
103093: PUSH
103094: LD_INT 1
103096: ST_TO_ADDR
// minersList := [ ] ;
103097: LD_ADDR_EXP 195
103101: PUSH
103102: EMPTY
103103: ST_TO_ADDR
// minerMinesList := [ ] ;
103104: LD_ADDR_EXP 196
103108: PUSH
103109: EMPTY
103110: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103111: LD_ADDR_EXP 197
103115: PUSH
103116: LD_INT 5
103118: ST_TO_ADDR
// end ;
103119: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103120: LD_EXP 194
103124: PUSH
103125: LD_INT 34
103127: PUSH
103128: LD_EXP 79
103132: PUSH
103133: EMPTY
103134: LIST
103135: LIST
103136: PPUSH
103137: CALL_OW 69
103141: AND
103142: IFFALSE 103605
103144: GO 103146
103146: DISABLE
103147: LD_INT 0
103149: PPUSH
103150: PPUSH
103151: PPUSH
103152: PPUSH
// begin enable ;
103153: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103154: LD_ADDR_VAR 0 1
103158: PUSH
103159: LD_INT 34
103161: PUSH
103162: LD_EXP 79
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: PPUSH
103171: CALL_OW 69
103175: PUSH
103176: FOR_IN
103177: IFFALSE 103249
// begin if not i in minersList then
103179: LD_VAR 0 1
103183: PUSH
103184: LD_EXP 195
103188: IN
103189: NOT
103190: IFFALSE 103247
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103192: LD_ADDR_EXP 195
103196: PUSH
103197: LD_EXP 195
103201: PPUSH
103202: LD_EXP 195
103206: PUSH
103207: LD_INT 1
103209: PLUS
103210: PPUSH
103211: LD_VAR 0 1
103215: PPUSH
103216: CALL_OW 1
103220: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103221: LD_ADDR_EXP 196
103225: PUSH
103226: LD_EXP 196
103230: PPUSH
103231: LD_EXP 196
103235: PUSH
103236: LD_INT 1
103238: PLUS
103239: PPUSH
103240: EMPTY
103241: PPUSH
103242: CALL_OW 1
103246: ST_TO_ADDR
// end end ;
103247: GO 103176
103249: POP
103250: POP
// for i := minerMinesList downto 1 do
103251: LD_ADDR_VAR 0 1
103255: PUSH
103256: DOUBLE
103257: LD_EXP 196
103261: INC
103262: ST_TO_ADDR
103263: LD_INT 1
103265: PUSH
103266: FOR_DOWNTO
103267: IFFALSE 103603
// begin if IsLive ( minersList [ i ] ) then
103269: LD_EXP 195
103273: PUSH
103274: LD_VAR 0 1
103278: ARRAY
103279: PPUSH
103280: CALL_OW 300
103284: IFFALSE 103312
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103286: LD_EXP 195
103290: PUSH
103291: LD_VAR 0 1
103295: ARRAY
103296: PPUSH
103297: LD_EXP 196
103301: PUSH
103302: LD_VAR 0 1
103306: ARRAY
103307: PPUSH
103308: CALL_OW 505
// if not minerMinesList [ i ] then
103312: LD_EXP 196
103316: PUSH
103317: LD_VAR 0 1
103321: ARRAY
103322: NOT
103323: IFFALSE 103327
// continue ;
103325: GO 103266
// for j := minerMinesList [ i ] downto 1 do
103327: LD_ADDR_VAR 0 2
103331: PUSH
103332: DOUBLE
103333: LD_EXP 196
103337: PUSH
103338: LD_VAR 0 1
103342: ARRAY
103343: INC
103344: ST_TO_ADDR
103345: LD_INT 1
103347: PUSH
103348: FOR_DOWNTO
103349: IFFALSE 103599
// begin side := GetSide ( minersList [ i ] ) ;
103351: LD_ADDR_VAR 0 3
103355: PUSH
103356: LD_EXP 195
103360: PUSH
103361: LD_VAR 0 1
103365: ARRAY
103366: PPUSH
103367: CALL_OW 255
103371: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103372: LD_ADDR_VAR 0 4
103376: PUSH
103377: LD_EXP 196
103381: PUSH
103382: LD_VAR 0 1
103386: ARRAY
103387: PUSH
103388: LD_VAR 0 2
103392: ARRAY
103393: PUSH
103394: LD_INT 1
103396: ARRAY
103397: PPUSH
103398: LD_EXP 196
103402: PUSH
103403: LD_VAR 0 1
103407: ARRAY
103408: PUSH
103409: LD_VAR 0 2
103413: ARRAY
103414: PUSH
103415: LD_INT 2
103417: ARRAY
103418: PPUSH
103419: CALL_OW 428
103423: ST_TO_ADDR
// if not tmp then
103424: LD_VAR 0 4
103428: NOT
103429: IFFALSE 103433
// continue ;
103431: GO 103348
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103433: LD_VAR 0 4
103437: PUSH
103438: LD_INT 81
103440: PUSH
103441: LD_VAR 0 3
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: PPUSH
103450: CALL_OW 69
103454: IN
103455: PUSH
103456: LD_EXP 196
103460: PUSH
103461: LD_VAR 0 1
103465: ARRAY
103466: PUSH
103467: LD_VAR 0 2
103471: ARRAY
103472: PUSH
103473: LD_INT 1
103475: ARRAY
103476: PPUSH
103477: LD_EXP 196
103481: PUSH
103482: LD_VAR 0 1
103486: ARRAY
103487: PUSH
103488: LD_VAR 0 2
103492: ARRAY
103493: PUSH
103494: LD_INT 2
103496: ARRAY
103497: PPUSH
103498: CALL_OW 458
103502: AND
103503: IFFALSE 103597
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103505: LD_EXP 196
103509: PUSH
103510: LD_VAR 0 1
103514: ARRAY
103515: PUSH
103516: LD_VAR 0 2
103520: ARRAY
103521: PUSH
103522: LD_INT 1
103524: ARRAY
103525: PPUSH
103526: LD_EXP 196
103530: PUSH
103531: LD_VAR 0 1
103535: ARRAY
103536: PUSH
103537: LD_VAR 0 2
103541: ARRAY
103542: PUSH
103543: LD_INT 2
103545: ARRAY
103546: PPUSH
103547: LD_VAR 0 3
103551: PPUSH
103552: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103556: LD_ADDR_EXP 196
103560: PUSH
103561: LD_EXP 196
103565: PPUSH
103566: LD_VAR 0 1
103570: PPUSH
103571: LD_EXP 196
103575: PUSH
103576: LD_VAR 0 1
103580: ARRAY
103581: PPUSH
103582: LD_VAR 0 2
103586: PPUSH
103587: CALL_OW 3
103591: PPUSH
103592: CALL_OW 1
103596: ST_TO_ADDR
// end ; end ;
103597: GO 103348
103599: POP
103600: POP
// end ;
103601: GO 103266
103603: POP
103604: POP
// end ;
103605: PPOPN 4
103607: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103608: LD_INT 0
103610: PPUSH
103611: PPUSH
// result := false ;
103612: LD_ADDR_VAR 0 4
103616: PUSH
103617: LD_INT 0
103619: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103620: LD_VAR 0 1
103624: PPUSH
103625: CALL_OW 264
103629: PUSH
103630: LD_EXP 79
103634: EQUAL
103635: NOT
103636: IFFALSE 103640
// exit ;
103638: GO 103880
// index := GetElementIndex ( minersList , unit ) ;
103640: LD_ADDR_VAR 0 5
103644: PUSH
103645: LD_EXP 195
103649: PPUSH
103650: LD_VAR 0 1
103654: PPUSH
103655: CALL 55599 0 2
103659: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103660: LD_EXP 196
103664: PUSH
103665: LD_VAR 0 5
103669: ARRAY
103670: PUSH
103671: LD_EXP 197
103675: GREATEREQUAL
103676: IFFALSE 103680
// exit ;
103678: GO 103880
// ComMoveXY ( unit , x , y ) ;
103680: LD_VAR 0 1
103684: PPUSH
103685: LD_VAR 0 2
103689: PPUSH
103690: LD_VAR 0 3
103694: PPUSH
103695: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103699: LD_INT 35
103701: PPUSH
103702: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103706: LD_VAR 0 1
103710: PPUSH
103711: LD_VAR 0 2
103715: PPUSH
103716: LD_VAR 0 3
103720: PPUSH
103721: CALL 85663 0 3
103725: NOT
103726: PUSH
103727: LD_VAR 0 1
103731: PPUSH
103732: CALL_OW 314
103736: AND
103737: IFFALSE 103741
// exit ;
103739: GO 103880
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103741: LD_VAR 0 2
103745: PPUSH
103746: LD_VAR 0 3
103750: PPUSH
103751: CALL_OW 428
103755: PUSH
103756: LD_VAR 0 1
103760: EQUAL
103761: PUSH
103762: LD_VAR 0 1
103766: PPUSH
103767: CALL_OW 314
103771: NOT
103772: AND
103773: IFFALSE 103699
// PlaySoundXY ( x , y , PlantMine ) ;
103775: LD_VAR 0 2
103779: PPUSH
103780: LD_VAR 0 3
103784: PPUSH
103785: LD_STRING PlantMine
103787: PPUSH
103788: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103792: LD_VAR 0 2
103796: PPUSH
103797: LD_VAR 0 3
103801: PPUSH
103802: LD_VAR 0 1
103806: PPUSH
103807: CALL_OW 255
103811: PPUSH
103812: LD_INT 0
103814: PPUSH
103815: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103819: LD_ADDR_EXP 196
103823: PUSH
103824: LD_EXP 196
103828: PPUSH
103829: LD_VAR 0 5
103833: PUSH
103834: LD_EXP 196
103838: PUSH
103839: LD_VAR 0 5
103843: ARRAY
103844: PUSH
103845: LD_INT 1
103847: PLUS
103848: PUSH
103849: EMPTY
103850: LIST
103851: LIST
103852: PPUSH
103853: LD_VAR 0 2
103857: PUSH
103858: LD_VAR 0 3
103862: PUSH
103863: EMPTY
103864: LIST
103865: LIST
103866: PPUSH
103867: CALL 55814 0 3
103871: ST_TO_ADDR
// result := true ;
103872: LD_ADDR_VAR 0 4
103876: PUSH
103877: LD_INT 1
103879: ST_TO_ADDR
// end ;
103880: LD_VAR 0 4
103884: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103885: LD_INT 0
103887: PPUSH
103888: PPUSH
103889: PPUSH
// if not unit in minersList then
103890: LD_VAR 0 1
103894: PUSH
103895: LD_EXP 195
103899: IN
103900: NOT
103901: IFFALSE 103905
// exit ;
103903: GO 104297
// index := GetElementIndex ( minersList , unit ) ;
103905: LD_ADDR_VAR 0 6
103909: PUSH
103910: LD_EXP 195
103914: PPUSH
103915: LD_VAR 0 1
103919: PPUSH
103920: CALL 55599 0 2
103924: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103925: LD_ADDR_VAR 0 5
103929: PUSH
103930: DOUBLE
103931: LD_EXP 196
103935: PUSH
103936: LD_VAR 0 6
103940: ARRAY
103941: INC
103942: ST_TO_ADDR
103943: LD_INT 1
103945: PUSH
103946: FOR_DOWNTO
103947: IFFALSE 104108
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103949: LD_EXP 196
103953: PUSH
103954: LD_VAR 0 6
103958: ARRAY
103959: PUSH
103960: LD_VAR 0 5
103964: ARRAY
103965: PUSH
103966: LD_INT 1
103968: ARRAY
103969: PUSH
103970: LD_VAR 0 2
103974: EQUAL
103975: PUSH
103976: LD_EXP 196
103980: PUSH
103981: LD_VAR 0 6
103985: ARRAY
103986: PUSH
103987: LD_VAR 0 5
103991: ARRAY
103992: PUSH
103993: LD_INT 2
103995: ARRAY
103996: PUSH
103997: LD_VAR 0 3
104001: EQUAL
104002: AND
104003: IFFALSE 104106
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104005: LD_EXP 196
104009: PUSH
104010: LD_VAR 0 6
104014: ARRAY
104015: PUSH
104016: LD_VAR 0 5
104020: ARRAY
104021: PUSH
104022: LD_INT 1
104024: ARRAY
104025: PPUSH
104026: LD_EXP 196
104030: PUSH
104031: LD_VAR 0 6
104035: ARRAY
104036: PUSH
104037: LD_VAR 0 5
104041: ARRAY
104042: PUSH
104043: LD_INT 2
104045: ARRAY
104046: PPUSH
104047: LD_VAR 0 1
104051: PPUSH
104052: CALL_OW 255
104056: PPUSH
104057: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104061: LD_ADDR_EXP 196
104065: PUSH
104066: LD_EXP 196
104070: PPUSH
104071: LD_VAR 0 6
104075: PPUSH
104076: LD_EXP 196
104080: PUSH
104081: LD_VAR 0 6
104085: ARRAY
104086: PPUSH
104087: LD_VAR 0 5
104091: PPUSH
104092: CALL_OW 3
104096: PPUSH
104097: CALL_OW 1
104101: ST_TO_ADDR
// exit ;
104102: POP
104103: POP
104104: GO 104297
// end ; end ;
104106: GO 103946
104108: POP
104109: POP
// for i := minerMinesList [ index ] downto 1 do
104110: LD_ADDR_VAR 0 5
104114: PUSH
104115: DOUBLE
104116: LD_EXP 196
104120: PUSH
104121: LD_VAR 0 6
104125: ARRAY
104126: INC
104127: ST_TO_ADDR
104128: LD_INT 1
104130: PUSH
104131: FOR_DOWNTO
104132: IFFALSE 104295
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104134: LD_EXP 196
104138: PUSH
104139: LD_VAR 0 6
104143: ARRAY
104144: PUSH
104145: LD_VAR 0 5
104149: ARRAY
104150: PUSH
104151: LD_INT 1
104153: ARRAY
104154: PPUSH
104155: LD_EXP 196
104159: PUSH
104160: LD_VAR 0 6
104164: ARRAY
104165: PUSH
104166: LD_VAR 0 5
104170: ARRAY
104171: PUSH
104172: LD_INT 2
104174: ARRAY
104175: PPUSH
104176: LD_VAR 0 2
104180: PPUSH
104181: LD_VAR 0 3
104185: PPUSH
104186: CALL_OW 298
104190: PUSH
104191: LD_INT 6
104193: LESS
104194: IFFALSE 104293
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104196: LD_EXP 196
104200: PUSH
104201: LD_VAR 0 6
104205: ARRAY
104206: PUSH
104207: LD_VAR 0 5
104211: ARRAY
104212: PUSH
104213: LD_INT 1
104215: ARRAY
104216: PPUSH
104217: LD_EXP 196
104221: PUSH
104222: LD_VAR 0 6
104226: ARRAY
104227: PUSH
104228: LD_VAR 0 5
104232: ARRAY
104233: PUSH
104234: LD_INT 2
104236: ARRAY
104237: PPUSH
104238: LD_VAR 0 1
104242: PPUSH
104243: CALL_OW 255
104247: PPUSH
104248: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104252: LD_ADDR_EXP 196
104256: PUSH
104257: LD_EXP 196
104261: PPUSH
104262: LD_VAR 0 6
104266: PPUSH
104267: LD_EXP 196
104271: PUSH
104272: LD_VAR 0 6
104276: ARRAY
104277: PPUSH
104278: LD_VAR 0 5
104282: PPUSH
104283: CALL_OW 3
104287: PPUSH
104288: CALL_OW 1
104292: ST_TO_ADDR
// end ; end ;
104293: GO 104131
104295: POP
104296: POP
// end ;
104297: LD_VAR 0 4
104301: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104302: LD_INT 0
104304: PPUSH
104305: PPUSH
104306: PPUSH
104307: PPUSH
104308: PPUSH
104309: PPUSH
104310: PPUSH
104311: PPUSH
104312: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104313: LD_VAR 0 1
104317: PPUSH
104318: CALL_OW 264
104322: PUSH
104323: LD_EXP 79
104327: EQUAL
104328: NOT
104329: PUSH
104330: LD_VAR 0 1
104334: PUSH
104335: LD_EXP 195
104339: IN
104340: NOT
104341: OR
104342: IFFALSE 104346
// exit ;
104344: GO 104668
// index := GetElementIndex ( minersList , unit ) ;
104346: LD_ADDR_VAR 0 6
104350: PUSH
104351: LD_EXP 195
104355: PPUSH
104356: LD_VAR 0 1
104360: PPUSH
104361: CALL 55599 0 2
104365: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104366: LD_ADDR_VAR 0 8
104370: PUSH
104371: LD_EXP 197
104375: PUSH
104376: LD_EXP 196
104380: PUSH
104381: LD_VAR 0 6
104385: ARRAY
104386: MINUS
104387: ST_TO_ADDR
// if not minesFreeAmount then
104388: LD_VAR 0 8
104392: NOT
104393: IFFALSE 104397
// exit ;
104395: GO 104668
// tmp := [ ] ;
104397: LD_ADDR_VAR 0 7
104401: PUSH
104402: EMPTY
104403: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104404: LD_ADDR_VAR 0 5
104408: PUSH
104409: DOUBLE
104410: LD_INT 1
104412: DEC
104413: ST_TO_ADDR
104414: LD_VAR 0 8
104418: PUSH
104419: FOR_TO
104420: IFFALSE 104615
// begin _d := rand ( 0 , 5 ) ;
104422: LD_ADDR_VAR 0 11
104426: PUSH
104427: LD_INT 0
104429: PPUSH
104430: LD_INT 5
104432: PPUSH
104433: CALL_OW 12
104437: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104438: LD_ADDR_VAR 0 12
104442: PUSH
104443: LD_INT 2
104445: PPUSH
104446: LD_INT 6
104448: PPUSH
104449: CALL_OW 12
104453: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104454: LD_ADDR_VAR 0 9
104458: PUSH
104459: LD_VAR 0 2
104463: PPUSH
104464: LD_VAR 0 11
104468: PPUSH
104469: LD_VAR 0 12
104473: PPUSH
104474: CALL_OW 272
104478: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104479: LD_ADDR_VAR 0 10
104483: PUSH
104484: LD_VAR 0 3
104488: PPUSH
104489: LD_VAR 0 11
104493: PPUSH
104494: LD_VAR 0 12
104498: PPUSH
104499: CALL_OW 273
104503: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104504: LD_VAR 0 9
104508: PPUSH
104509: LD_VAR 0 10
104513: PPUSH
104514: CALL_OW 488
104518: PUSH
104519: LD_VAR 0 9
104523: PUSH
104524: LD_VAR 0 10
104528: PUSH
104529: EMPTY
104530: LIST
104531: LIST
104532: PUSH
104533: LD_VAR 0 7
104537: IN
104538: NOT
104539: AND
104540: PUSH
104541: LD_VAR 0 9
104545: PPUSH
104546: LD_VAR 0 10
104550: PPUSH
104551: CALL_OW 458
104555: NOT
104556: AND
104557: IFFALSE 104599
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104559: LD_ADDR_VAR 0 7
104563: PUSH
104564: LD_VAR 0 7
104568: PPUSH
104569: LD_VAR 0 7
104573: PUSH
104574: LD_INT 1
104576: PLUS
104577: PPUSH
104578: LD_VAR 0 9
104582: PUSH
104583: LD_VAR 0 10
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: PPUSH
104592: CALL_OW 1
104596: ST_TO_ADDR
104597: GO 104613
// i := i - 1 ;
104599: LD_ADDR_VAR 0 5
104603: PUSH
104604: LD_VAR 0 5
104608: PUSH
104609: LD_INT 1
104611: MINUS
104612: ST_TO_ADDR
// end ;
104613: GO 104419
104615: POP
104616: POP
// for i in tmp do
104617: LD_ADDR_VAR 0 5
104621: PUSH
104622: LD_VAR 0 7
104626: PUSH
104627: FOR_IN
104628: IFFALSE 104666
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104630: LD_VAR 0 1
104634: PPUSH
104635: LD_VAR 0 5
104639: PUSH
104640: LD_INT 1
104642: ARRAY
104643: PPUSH
104644: LD_VAR 0 5
104648: PUSH
104649: LD_INT 2
104651: ARRAY
104652: PPUSH
104653: CALL 103608 0 3
104657: NOT
104658: IFFALSE 104664
// exit ;
104660: POP
104661: POP
104662: GO 104668
104664: GO 104627
104666: POP
104667: POP
// end ;
104668: LD_VAR 0 4
104672: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104673: LD_INT 0
104675: PPUSH
104676: PPUSH
104677: PPUSH
104678: PPUSH
104679: PPUSH
104680: PPUSH
104681: PPUSH
// if not GetClass ( unit ) = class_sniper then
104682: LD_VAR 0 1
104686: PPUSH
104687: CALL_OW 257
104691: PUSH
104692: LD_INT 5
104694: EQUAL
104695: NOT
104696: IFFALSE 104700
// exit ;
104698: GO 105088
// dist := 8 ;
104700: LD_ADDR_VAR 0 5
104704: PUSH
104705: LD_INT 8
104707: ST_TO_ADDR
// viewRange := 12 ;
104708: LD_ADDR_VAR 0 7
104712: PUSH
104713: LD_INT 12
104715: ST_TO_ADDR
// side := GetSide ( unit ) ;
104716: LD_ADDR_VAR 0 6
104720: PUSH
104721: LD_VAR 0 1
104725: PPUSH
104726: CALL_OW 255
104730: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104731: LD_INT 61
104733: PPUSH
104734: LD_VAR 0 6
104738: PPUSH
104739: CALL_OW 321
104743: PUSH
104744: LD_INT 2
104746: EQUAL
104747: IFFALSE 104757
// viewRange := 16 ;
104749: LD_ADDR_VAR 0 7
104753: PUSH
104754: LD_INT 16
104756: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104757: LD_VAR 0 1
104761: PPUSH
104762: LD_VAR 0 2
104766: PPUSH
104767: LD_VAR 0 3
104771: PPUSH
104772: CALL_OW 297
104776: PUSH
104777: LD_VAR 0 5
104781: GREATER
104782: IFFALSE 104861
// begin ComMoveXY ( unit , x , y ) ;
104784: LD_VAR 0 1
104788: PPUSH
104789: LD_VAR 0 2
104793: PPUSH
104794: LD_VAR 0 3
104798: PPUSH
104799: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104803: LD_INT 35
104805: PPUSH
104806: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104810: LD_VAR 0 1
104814: PPUSH
104815: LD_VAR 0 2
104819: PPUSH
104820: LD_VAR 0 3
104824: PPUSH
104825: CALL 85663 0 3
104829: NOT
104830: IFFALSE 104834
// exit ;
104832: GO 105088
// until GetDistUnitXY ( unit , x , y ) < dist ;
104834: LD_VAR 0 1
104838: PPUSH
104839: LD_VAR 0 2
104843: PPUSH
104844: LD_VAR 0 3
104848: PPUSH
104849: CALL_OW 297
104853: PUSH
104854: LD_VAR 0 5
104858: LESS
104859: IFFALSE 104803
// end ; ComTurnXY ( unit , x , y ) ;
104861: LD_VAR 0 1
104865: PPUSH
104866: LD_VAR 0 2
104870: PPUSH
104871: LD_VAR 0 3
104875: PPUSH
104876: CALL_OW 118
// wait ( 5 ) ;
104880: LD_INT 5
104882: PPUSH
104883: CALL_OW 67
// _d := GetDir ( unit ) ;
104887: LD_ADDR_VAR 0 10
104891: PUSH
104892: LD_VAR 0 1
104896: PPUSH
104897: CALL_OW 254
104901: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104902: LD_ADDR_VAR 0 8
104906: PUSH
104907: LD_VAR 0 1
104911: PPUSH
104912: CALL_OW 250
104916: PPUSH
104917: LD_VAR 0 10
104921: PPUSH
104922: LD_VAR 0 5
104926: PPUSH
104927: CALL_OW 272
104931: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104932: LD_ADDR_VAR 0 9
104936: PUSH
104937: LD_VAR 0 1
104941: PPUSH
104942: CALL_OW 251
104946: PPUSH
104947: LD_VAR 0 10
104951: PPUSH
104952: LD_VAR 0 5
104956: PPUSH
104957: CALL_OW 273
104961: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104962: LD_VAR 0 8
104966: PPUSH
104967: LD_VAR 0 9
104971: PPUSH
104972: CALL_OW 488
104976: NOT
104977: IFFALSE 104981
// exit ;
104979: GO 105088
// ComAnimCustom ( unit , 1 ) ;
104981: LD_VAR 0 1
104985: PPUSH
104986: LD_INT 1
104988: PPUSH
104989: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104993: LD_VAR 0 8
104997: PPUSH
104998: LD_VAR 0 9
105002: PPUSH
105003: LD_VAR 0 6
105007: PPUSH
105008: LD_VAR 0 7
105012: PPUSH
105013: CALL_OW 330
// repeat wait ( 1 ) ;
105017: LD_INT 1
105019: PPUSH
105020: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105024: LD_VAR 0 1
105028: PPUSH
105029: CALL_OW 316
105033: PUSH
105034: LD_VAR 0 1
105038: PPUSH
105039: CALL_OW 314
105043: OR
105044: PUSH
105045: LD_VAR 0 1
105049: PPUSH
105050: CALL_OW 302
105054: NOT
105055: OR
105056: PUSH
105057: LD_VAR 0 1
105061: PPUSH
105062: CALL_OW 301
105066: OR
105067: IFFALSE 105017
// RemoveSeeing ( _x , _y , side ) ;
105069: LD_VAR 0 8
105073: PPUSH
105074: LD_VAR 0 9
105078: PPUSH
105079: LD_VAR 0 6
105083: PPUSH
105084: CALL_OW 331
// end ; end_of_file
105088: LD_VAR 0 4
105092: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105093: LD_INT 0
105095: PPUSH
105096: PPUSH
105097: PPUSH
105098: PPUSH
105099: PPUSH
105100: PPUSH
105101: PPUSH
105102: PPUSH
105103: PPUSH
105104: PPUSH
105105: PPUSH
105106: PPUSH
105107: PPUSH
105108: PPUSH
105109: PPUSH
105110: PPUSH
105111: PPUSH
105112: PPUSH
105113: PPUSH
105114: PPUSH
105115: PPUSH
105116: PPUSH
105117: PPUSH
105118: PPUSH
105119: PPUSH
105120: PPUSH
105121: PPUSH
105122: PPUSH
105123: PPUSH
105124: PPUSH
105125: PPUSH
105126: PPUSH
105127: PPUSH
105128: PPUSH
// if not list then
105129: LD_VAR 0 1
105133: NOT
105134: IFFALSE 105138
// exit ;
105136: GO 109797
// base := list [ 1 ] ;
105138: LD_ADDR_VAR 0 3
105142: PUSH
105143: LD_VAR 0 1
105147: PUSH
105148: LD_INT 1
105150: ARRAY
105151: ST_TO_ADDR
// group := list [ 2 ] ;
105152: LD_ADDR_VAR 0 4
105156: PUSH
105157: LD_VAR 0 1
105161: PUSH
105162: LD_INT 2
105164: ARRAY
105165: ST_TO_ADDR
// path := list [ 3 ] ;
105166: LD_ADDR_VAR 0 5
105170: PUSH
105171: LD_VAR 0 1
105175: PUSH
105176: LD_INT 3
105178: ARRAY
105179: ST_TO_ADDR
// flags := list [ 4 ] ;
105180: LD_ADDR_VAR 0 6
105184: PUSH
105185: LD_VAR 0 1
105189: PUSH
105190: LD_INT 4
105192: ARRAY
105193: ST_TO_ADDR
// mined := [ ] ;
105194: LD_ADDR_VAR 0 27
105198: PUSH
105199: EMPTY
105200: ST_TO_ADDR
// bombed := [ ] ;
105201: LD_ADDR_VAR 0 28
105205: PUSH
105206: EMPTY
105207: ST_TO_ADDR
// healers := [ ] ;
105208: LD_ADDR_VAR 0 31
105212: PUSH
105213: EMPTY
105214: ST_TO_ADDR
// to_heal := [ ] ;
105215: LD_ADDR_VAR 0 30
105219: PUSH
105220: EMPTY
105221: ST_TO_ADDR
// repairs := [ ] ;
105222: LD_ADDR_VAR 0 33
105226: PUSH
105227: EMPTY
105228: ST_TO_ADDR
// to_repair := [ ] ;
105229: LD_ADDR_VAR 0 32
105233: PUSH
105234: EMPTY
105235: ST_TO_ADDR
// if not group or not path then
105236: LD_VAR 0 4
105240: NOT
105241: PUSH
105242: LD_VAR 0 5
105246: NOT
105247: OR
105248: IFFALSE 105252
// exit ;
105250: GO 109797
// side := GetSide ( group [ 1 ] ) ;
105252: LD_ADDR_VAR 0 35
105256: PUSH
105257: LD_VAR 0 4
105261: PUSH
105262: LD_INT 1
105264: ARRAY
105265: PPUSH
105266: CALL_OW 255
105270: ST_TO_ADDR
// if flags then
105271: LD_VAR 0 6
105275: IFFALSE 105419
// begin f_ignore_area := flags [ 1 ] ;
105277: LD_ADDR_VAR 0 17
105281: PUSH
105282: LD_VAR 0 6
105286: PUSH
105287: LD_INT 1
105289: ARRAY
105290: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105291: LD_ADDR_VAR 0 18
105295: PUSH
105296: LD_VAR 0 6
105300: PUSH
105301: LD_INT 2
105303: ARRAY
105304: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105305: LD_ADDR_VAR 0 19
105309: PUSH
105310: LD_VAR 0 6
105314: PUSH
105315: LD_INT 3
105317: ARRAY
105318: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105319: LD_ADDR_VAR 0 20
105323: PUSH
105324: LD_VAR 0 6
105328: PUSH
105329: LD_INT 4
105331: ARRAY
105332: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105333: LD_ADDR_VAR 0 21
105337: PUSH
105338: LD_VAR 0 6
105342: PUSH
105343: LD_INT 5
105345: ARRAY
105346: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105347: LD_ADDR_VAR 0 22
105351: PUSH
105352: LD_VAR 0 6
105356: PUSH
105357: LD_INT 6
105359: ARRAY
105360: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105361: LD_ADDR_VAR 0 23
105365: PUSH
105366: LD_VAR 0 6
105370: PUSH
105371: LD_INT 7
105373: ARRAY
105374: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105375: LD_ADDR_VAR 0 24
105379: PUSH
105380: LD_VAR 0 6
105384: PUSH
105385: LD_INT 8
105387: ARRAY
105388: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105389: LD_ADDR_VAR 0 25
105393: PUSH
105394: LD_VAR 0 6
105398: PUSH
105399: LD_INT 9
105401: ARRAY
105402: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105403: LD_ADDR_VAR 0 26
105407: PUSH
105408: LD_VAR 0 6
105412: PUSH
105413: LD_INT 10
105415: ARRAY
105416: ST_TO_ADDR
// end else
105417: GO 105499
// begin f_ignore_area := false ;
105419: LD_ADDR_VAR 0 17
105423: PUSH
105424: LD_INT 0
105426: ST_TO_ADDR
// f_capture := false ;
105427: LD_ADDR_VAR 0 18
105431: PUSH
105432: LD_INT 0
105434: ST_TO_ADDR
// f_ignore_civ := false ;
105435: LD_ADDR_VAR 0 19
105439: PUSH
105440: LD_INT 0
105442: ST_TO_ADDR
// f_murder := false ;
105443: LD_ADDR_VAR 0 20
105447: PUSH
105448: LD_INT 0
105450: ST_TO_ADDR
// f_mines := false ;
105451: LD_ADDR_VAR 0 21
105455: PUSH
105456: LD_INT 0
105458: ST_TO_ADDR
// f_repair := false ;
105459: LD_ADDR_VAR 0 22
105463: PUSH
105464: LD_INT 0
105466: ST_TO_ADDR
// f_heal := false ;
105467: LD_ADDR_VAR 0 23
105471: PUSH
105472: LD_INT 0
105474: ST_TO_ADDR
// f_spacetime := false ;
105475: LD_ADDR_VAR 0 24
105479: PUSH
105480: LD_INT 0
105482: ST_TO_ADDR
// f_attack_depot := false ;
105483: LD_ADDR_VAR 0 25
105487: PUSH
105488: LD_INT 0
105490: ST_TO_ADDR
// f_crawl := false ;
105491: LD_ADDR_VAR 0 26
105495: PUSH
105496: LD_INT 0
105498: ST_TO_ADDR
// end ; if f_heal then
105499: LD_VAR 0 23
105503: IFFALSE 105530
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105505: LD_ADDR_VAR 0 31
105509: PUSH
105510: LD_VAR 0 4
105514: PPUSH
105515: LD_INT 25
105517: PUSH
105518: LD_INT 4
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PPUSH
105525: CALL_OW 72
105529: ST_TO_ADDR
// if f_repair then
105530: LD_VAR 0 22
105534: IFFALSE 105561
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105536: LD_ADDR_VAR 0 33
105540: PUSH
105541: LD_VAR 0 4
105545: PPUSH
105546: LD_INT 25
105548: PUSH
105549: LD_INT 3
105551: PUSH
105552: EMPTY
105553: LIST
105554: LIST
105555: PPUSH
105556: CALL_OW 72
105560: ST_TO_ADDR
// units_path := [ ] ;
105561: LD_ADDR_VAR 0 16
105565: PUSH
105566: EMPTY
105567: ST_TO_ADDR
// for i = 1 to group do
105568: LD_ADDR_VAR 0 7
105572: PUSH
105573: DOUBLE
105574: LD_INT 1
105576: DEC
105577: ST_TO_ADDR
105578: LD_VAR 0 4
105582: PUSH
105583: FOR_TO
105584: IFFALSE 105613
// units_path := Replace ( units_path , i , path ) ;
105586: LD_ADDR_VAR 0 16
105590: PUSH
105591: LD_VAR 0 16
105595: PPUSH
105596: LD_VAR 0 7
105600: PPUSH
105601: LD_VAR 0 5
105605: PPUSH
105606: CALL_OW 1
105610: ST_TO_ADDR
105611: GO 105583
105613: POP
105614: POP
// repeat for i = group downto 1 do
105615: LD_ADDR_VAR 0 7
105619: PUSH
105620: DOUBLE
105621: LD_VAR 0 4
105625: INC
105626: ST_TO_ADDR
105627: LD_INT 1
105629: PUSH
105630: FOR_DOWNTO
105631: IFFALSE 109753
// begin wait ( 5 ) ;
105633: LD_INT 5
105635: PPUSH
105636: CALL_OW 67
// tmp := [ ] ;
105640: LD_ADDR_VAR 0 14
105644: PUSH
105645: EMPTY
105646: ST_TO_ADDR
// attacking := false ;
105647: LD_ADDR_VAR 0 29
105651: PUSH
105652: LD_INT 0
105654: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105655: LD_VAR 0 4
105659: PUSH
105660: LD_VAR 0 7
105664: ARRAY
105665: PPUSH
105666: CALL_OW 301
105670: PUSH
105671: LD_VAR 0 4
105675: PUSH
105676: LD_VAR 0 7
105680: ARRAY
105681: NOT
105682: OR
105683: IFFALSE 105792
// begin if GetType ( group [ i ] ) = unit_human then
105685: LD_VAR 0 4
105689: PUSH
105690: LD_VAR 0 7
105694: ARRAY
105695: PPUSH
105696: CALL_OW 247
105700: PUSH
105701: LD_INT 1
105703: EQUAL
105704: IFFALSE 105750
// begin to_heal := to_heal diff group [ i ] ;
105706: LD_ADDR_VAR 0 30
105710: PUSH
105711: LD_VAR 0 30
105715: PUSH
105716: LD_VAR 0 4
105720: PUSH
105721: LD_VAR 0 7
105725: ARRAY
105726: DIFF
105727: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105728: LD_ADDR_VAR 0 31
105732: PUSH
105733: LD_VAR 0 31
105737: PUSH
105738: LD_VAR 0 4
105742: PUSH
105743: LD_VAR 0 7
105747: ARRAY
105748: DIFF
105749: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105750: LD_ADDR_VAR 0 4
105754: PUSH
105755: LD_VAR 0 4
105759: PPUSH
105760: LD_VAR 0 7
105764: PPUSH
105765: CALL_OW 3
105769: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105770: LD_ADDR_VAR 0 16
105774: PUSH
105775: LD_VAR 0 16
105779: PPUSH
105780: LD_VAR 0 7
105784: PPUSH
105785: CALL_OW 3
105789: ST_TO_ADDR
// continue ;
105790: GO 105630
// end ; if f_repair then
105792: LD_VAR 0 22
105796: IFFALSE 106285
// begin if GetType ( group [ i ] ) = unit_vehicle then
105798: LD_VAR 0 4
105802: PUSH
105803: LD_VAR 0 7
105807: ARRAY
105808: PPUSH
105809: CALL_OW 247
105813: PUSH
105814: LD_INT 2
105816: EQUAL
105817: IFFALSE 106007
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105819: LD_VAR 0 4
105823: PUSH
105824: LD_VAR 0 7
105828: ARRAY
105829: PPUSH
105830: CALL_OW 256
105834: PUSH
105835: LD_INT 700
105837: LESS
105838: PUSH
105839: LD_VAR 0 4
105843: PUSH
105844: LD_VAR 0 7
105848: ARRAY
105849: PUSH
105850: LD_VAR 0 32
105854: IN
105855: NOT
105856: AND
105857: IFFALSE 105881
// to_repair := to_repair union group [ i ] ;
105859: LD_ADDR_VAR 0 32
105863: PUSH
105864: LD_VAR 0 32
105868: PUSH
105869: LD_VAR 0 4
105873: PUSH
105874: LD_VAR 0 7
105878: ARRAY
105879: UNION
105880: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105881: LD_VAR 0 4
105885: PUSH
105886: LD_VAR 0 7
105890: ARRAY
105891: PPUSH
105892: CALL_OW 256
105896: PUSH
105897: LD_INT 1000
105899: EQUAL
105900: PUSH
105901: LD_VAR 0 4
105905: PUSH
105906: LD_VAR 0 7
105910: ARRAY
105911: PUSH
105912: LD_VAR 0 32
105916: IN
105917: AND
105918: IFFALSE 105942
// to_repair := to_repair diff group [ i ] ;
105920: LD_ADDR_VAR 0 32
105924: PUSH
105925: LD_VAR 0 32
105929: PUSH
105930: LD_VAR 0 4
105934: PUSH
105935: LD_VAR 0 7
105939: ARRAY
105940: DIFF
105941: ST_TO_ADDR
// if group [ i ] in to_repair then
105942: LD_VAR 0 4
105946: PUSH
105947: LD_VAR 0 7
105951: ARRAY
105952: PUSH
105953: LD_VAR 0 32
105957: IN
105958: IFFALSE 106005
// begin if not IsInArea ( group [ i ] , f_repair ) then
105960: LD_VAR 0 4
105964: PUSH
105965: LD_VAR 0 7
105969: ARRAY
105970: PPUSH
105971: LD_VAR 0 22
105975: PPUSH
105976: CALL_OW 308
105980: NOT
105981: IFFALSE 106003
// ComMoveToArea ( group [ i ] , f_repair ) ;
105983: LD_VAR 0 4
105987: PUSH
105988: LD_VAR 0 7
105992: ARRAY
105993: PPUSH
105994: LD_VAR 0 22
105998: PPUSH
105999: CALL_OW 113
// continue ;
106003: GO 105630
// end ; end else
106005: GO 106285
// if group [ i ] in repairs then
106007: LD_VAR 0 4
106011: PUSH
106012: LD_VAR 0 7
106016: ARRAY
106017: PUSH
106018: LD_VAR 0 33
106022: IN
106023: IFFALSE 106285
// begin if IsInUnit ( group [ i ] ) then
106025: LD_VAR 0 4
106029: PUSH
106030: LD_VAR 0 7
106034: ARRAY
106035: PPUSH
106036: CALL_OW 310
106040: IFFALSE 106108
// begin z := IsInUnit ( group [ i ] ) ;
106042: LD_ADDR_VAR 0 13
106046: PUSH
106047: LD_VAR 0 4
106051: PUSH
106052: LD_VAR 0 7
106056: ARRAY
106057: PPUSH
106058: CALL_OW 310
106062: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106063: LD_VAR 0 13
106067: PUSH
106068: LD_VAR 0 32
106072: IN
106073: PUSH
106074: LD_VAR 0 13
106078: PPUSH
106079: LD_VAR 0 22
106083: PPUSH
106084: CALL_OW 308
106088: AND
106089: IFFALSE 106106
// ComExitVehicle ( group [ i ] ) ;
106091: LD_VAR 0 4
106095: PUSH
106096: LD_VAR 0 7
106100: ARRAY
106101: PPUSH
106102: CALL_OW 121
// end else
106106: GO 106285
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106108: LD_ADDR_VAR 0 13
106112: PUSH
106113: LD_VAR 0 4
106117: PPUSH
106118: LD_INT 95
106120: PUSH
106121: LD_VAR 0 22
106125: PUSH
106126: EMPTY
106127: LIST
106128: LIST
106129: PUSH
106130: LD_INT 58
106132: PUSH
106133: EMPTY
106134: LIST
106135: PUSH
106136: EMPTY
106137: LIST
106138: LIST
106139: PPUSH
106140: CALL_OW 72
106144: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106145: LD_VAR 0 4
106149: PUSH
106150: LD_VAR 0 7
106154: ARRAY
106155: PPUSH
106156: CALL_OW 314
106160: NOT
106161: IFFALSE 106283
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106163: LD_ADDR_VAR 0 10
106167: PUSH
106168: LD_VAR 0 13
106172: PPUSH
106173: LD_VAR 0 4
106177: PUSH
106178: LD_VAR 0 7
106182: ARRAY
106183: PPUSH
106184: CALL_OW 74
106188: ST_TO_ADDR
// if not x then
106189: LD_VAR 0 10
106193: NOT
106194: IFFALSE 106198
// continue ;
106196: GO 105630
// if GetLives ( x ) < 1000 then
106198: LD_VAR 0 10
106202: PPUSH
106203: CALL_OW 256
106207: PUSH
106208: LD_INT 1000
106210: LESS
106211: IFFALSE 106235
// ComRepairVehicle ( group [ i ] , x ) else
106213: LD_VAR 0 4
106217: PUSH
106218: LD_VAR 0 7
106222: ARRAY
106223: PPUSH
106224: LD_VAR 0 10
106228: PPUSH
106229: CALL_OW 129
106233: GO 106283
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106235: LD_VAR 0 23
106239: PUSH
106240: LD_VAR 0 4
106244: PUSH
106245: LD_VAR 0 7
106249: ARRAY
106250: PPUSH
106251: CALL_OW 256
106255: PUSH
106256: LD_INT 1000
106258: LESS
106259: AND
106260: NOT
106261: IFFALSE 106283
// ComEnterUnit ( group [ i ] , x ) ;
106263: LD_VAR 0 4
106267: PUSH
106268: LD_VAR 0 7
106272: ARRAY
106273: PPUSH
106274: LD_VAR 0 10
106278: PPUSH
106279: CALL_OW 120
// end ; continue ;
106283: GO 105630
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106285: LD_VAR 0 23
106289: PUSH
106290: LD_VAR 0 4
106294: PUSH
106295: LD_VAR 0 7
106299: ARRAY
106300: PPUSH
106301: CALL_OW 247
106305: PUSH
106306: LD_INT 1
106308: EQUAL
106309: AND
106310: IFFALSE 106788
// begin if group [ i ] in healers then
106312: LD_VAR 0 4
106316: PUSH
106317: LD_VAR 0 7
106321: ARRAY
106322: PUSH
106323: LD_VAR 0 31
106327: IN
106328: IFFALSE 106601
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106330: LD_VAR 0 4
106334: PUSH
106335: LD_VAR 0 7
106339: ARRAY
106340: PPUSH
106341: LD_VAR 0 23
106345: PPUSH
106346: CALL_OW 308
106350: NOT
106351: PUSH
106352: LD_VAR 0 4
106356: PUSH
106357: LD_VAR 0 7
106361: ARRAY
106362: PPUSH
106363: CALL_OW 314
106367: NOT
106368: AND
106369: IFFALSE 106393
// ComMoveToArea ( group [ i ] , f_heal ) else
106371: LD_VAR 0 4
106375: PUSH
106376: LD_VAR 0 7
106380: ARRAY
106381: PPUSH
106382: LD_VAR 0 23
106386: PPUSH
106387: CALL_OW 113
106391: GO 106599
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106393: LD_VAR 0 4
106397: PUSH
106398: LD_VAR 0 7
106402: ARRAY
106403: PPUSH
106404: CALL 84186 0 1
106408: PPUSH
106409: CALL_OW 256
106413: PUSH
106414: LD_INT 1000
106416: EQUAL
106417: IFFALSE 106436
// ComStop ( group [ i ] ) else
106419: LD_VAR 0 4
106423: PUSH
106424: LD_VAR 0 7
106428: ARRAY
106429: PPUSH
106430: CALL_OW 141
106434: GO 106599
// if not HasTask ( group [ i ] ) and to_heal then
106436: LD_VAR 0 4
106440: PUSH
106441: LD_VAR 0 7
106445: ARRAY
106446: PPUSH
106447: CALL_OW 314
106451: NOT
106452: PUSH
106453: LD_VAR 0 30
106457: AND
106458: IFFALSE 106599
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106460: LD_ADDR_VAR 0 13
106464: PUSH
106465: LD_VAR 0 30
106469: PPUSH
106470: LD_INT 3
106472: PUSH
106473: LD_INT 54
106475: PUSH
106476: EMPTY
106477: LIST
106478: PUSH
106479: EMPTY
106480: LIST
106481: LIST
106482: PPUSH
106483: CALL_OW 72
106487: PPUSH
106488: LD_VAR 0 4
106492: PUSH
106493: LD_VAR 0 7
106497: ARRAY
106498: PPUSH
106499: CALL_OW 74
106503: ST_TO_ADDR
// if z then
106504: LD_VAR 0 13
106508: IFFALSE 106599
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106510: LD_INT 91
106512: PUSH
106513: LD_VAR 0 13
106517: PUSH
106518: LD_INT 10
106520: PUSH
106521: EMPTY
106522: LIST
106523: LIST
106524: LIST
106525: PUSH
106526: LD_INT 81
106528: PUSH
106529: LD_VAR 0 13
106533: PPUSH
106534: CALL_OW 255
106538: PUSH
106539: EMPTY
106540: LIST
106541: LIST
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: PPUSH
106547: CALL_OW 69
106551: PUSH
106552: LD_INT 0
106554: EQUAL
106555: IFFALSE 106579
// ComHeal ( group [ i ] , z ) else
106557: LD_VAR 0 4
106561: PUSH
106562: LD_VAR 0 7
106566: ARRAY
106567: PPUSH
106568: LD_VAR 0 13
106572: PPUSH
106573: CALL_OW 128
106577: GO 106599
// ComMoveToArea ( group [ i ] , f_heal ) ;
106579: LD_VAR 0 4
106583: PUSH
106584: LD_VAR 0 7
106588: ARRAY
106589: PPUSH
106590: LD_VAR 0 23
106594: PPUSH
106595: CALL_OW 113
// end ; continue ;
106599: GO 105630
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106601: LD_VAR 0 4
106605: PUSH
106606: LD_VAR 0 7
106610: ARRAY
106611: PPUSH
106612: CALL_OW 256
106616: PUSH
106617: LD_INT 700
106619: LESS
106620: PUSH
106621: LD_VAR 0 4
106625: PUSH
106626: LD_VAR 0 7
106630: ARRAY
106631: PUSH
106632: LD_VAR 0 30
106636: IN
106637: NOT
106638: AND
106639: IFFALSE 106663
// to_heal := to_heal union group [ i ] ;
106641: LD_ADDR_VAR 0 30
106645: PUSH
106646: LD_VAR 0 30
106650: PUSH
106651: LD_VAR 0 4
106655: PUSH
106656: LD_VAR 0 7
106660: ARRAY
106661: UNION
106662: ST_TO_ADDR
// if group [ i ] in to_heal then
106663: LD_VAR 0 4
106667: PUSH
106668: LD_VAR 0 7
106672: ARRAY
106673: PUSH
106674: LD_VAR 0 30
106678: IN
106679: IFFALSE 106788
// begin if GetLives ( group [ i ] ) = 1000 then
106681: LD_VAR 0 4
106685: PUSH
106686: LD_VAR 0 7
106690: ARRAY
106691: PPUSH
106692: CALL_OW 256
106696: PUSH
106697: LD_INT 1000
106699: EQUAL
106700: IFFALSE 106726
// to_heal := to_heal diff group [ i ] else
106702: LD_ADDR_VAR 0 30
106706: PUSH
106707: LD_VAR 0 30
106711: PUSH
106712: LD_VAR 0 4
106716: PUSH
106717: LD_VAR 0 7
106721: ARRAY
106722: DIFF
106723: ST_TO_ADDR
106724: GO 106788
// begin if not IsInArea ( group [ i ] , to_heal ) then
106726: LD_VAR 0 4
106730: PUSH
106731: LD_VAR 0 7
106735: ARRAY
106736: PPUSH
106737: LD_VAR 0 30
106741: PPUSH
106742: CALL_OW 308
106746: NOT
106747: IFFALSE 106771
// ComMoveToArea ( group [ i ] , f_heal ) else
106749: LD_VAR 0 4
106753: PUSH
106754: LD_VAR 0 7
106758: ARRAY
106759: PPUSH
106760: LD_VAR 0 23
106764: PPUSH
106765: CALL_OW 113
106769: GO 106786
// ComHold ( group [ i ] ) ;
106771: LD_VAR 0 4
106775: PUSH
106776: LD_VAR 0 7
106780: ARRAY
106781: PPUSH
106782: CALL_OW 140
// continue ;
106786: GO 105630
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106788: LD_VAR 0 4
106792: PUSH
106793: LD_VAR 0 7
106797: ARRAY
106798: PPUSH
106799: LD_INT 10
106801: PPUSH
106802: CALL 82606 0 2
106806: NOT
106807: PUSH
106808: LD_VAR 0 16
106812: PUSH
106813: LD_VAR 0 7
106817: ARRAY
106818: PUSH
106819: EMPTY
106820: EQUAL
106821: NOT
106822: AND
106823: IFFALSE 107089
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106825: LD_VAR 0 4
106829: PUSH
106830: LD_VAR 0 7
106834: ARRAY
106835: PPUSH
106836: CALL_OW 262
106840: PUSH
106841: LD_INT 1
106843: PUSH
106844: LD_INT 2
106846: PUSH
106847: EMPTY
106848: LIST
106849: LIST
106850: IN
106851: IFFALSE 106892
// if GetFuel ( group [ i ] ) < 10 then
106853: LD_VAR 0 4
106857: PUSH
106858: LD_VAR 0 7
106862: ARRAY
106863: PPUSH
106864: CALL_OW 261
106868: PUSH
106869: LD_INT 10
106871: LESS
106872: IFFALSE 106892
// SetFuel ( group [ i ] , 12 ) ;
106874: LD_VAR 0 4
106878: PUSH
106879: LD_VAR 0 7
106883: ARRAY
106884: PPUSH
106885: LD_INT 12
106887: PPUSH
106888: CALL_OW 240
// if units_path [ i ] then
106892: LD_VAR 0 16
106896: PUSH
106897: LD_VAR 0 7
106901: ARRAY
106902: IFFALSE 107087
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106904: LD_VAR 0 4
106908: PUSH
106909: LD_VAR 0 7
106913: ARRAY
106914: PPUSH
106915: LD_VAR 0 16
106919: PUSH
106920: LD_VAR 0 7
106924: ARRAY
106925: PUSH
106926: LD_INT 1
106928: ARRAY
106929: PUSH
106930: LD_INT 1
106932: ARRAY
106933: PPUSH
106934: LD_VAR 0 16
106938: PUSH
106939: LD_VAR 0 7
106943: ARRAY
106944: PUSH
106945: LD_INT 1
106947: ARRAY
106948: PUSH
106949: LD_INT 2
106951: ARRAY
106952: PPUSH
106953: CALL_OW 297
106957: PUSH
106958: LD_INT 6
106960: GREATER
106961: IFFALSE 107036
// begin if not HasTask ( group [ i ] ) then
106963: LD_VAR 0 4
106967: PUSH
106968: LD_VAR 0 7
106972: ARRAY
106973: PPUSH
106974: CALL_OW 314
106978: NOT
106979: IFFALSE 107034
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106981: LD_VAR 0 4
106985: PUSH
106986: LD_VAR 0 7
106990: ARRAY
106991: PPUSH
106992: LD_VAR 0 16
106996: PUSH
106997: LD_VAR 0 7
107001: ARRAY
107002: PUSH
107003: LD_INT 1
107005: ARRAY
107006: PUSH
107007: LD_INT 1
107009: ARRAY
107010: PPUSH
107011: LD_VAR 0 16
107015: PUSH
107016: LD_VAR 0 7
107020: ARRAY
107021: PUSH
107022: LD_INT 1
107024: ARRAY
107025: PUSH
107026: LD_INT 2
107028: ARRAY
107029: PPUSH
107030: CALL_OW 114
// end else
107034: GO 107087
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107036: LD_ADDR_VAR 0 15
107040: PUSH
107041: LD_VAR 0 16
107045: PUSH
107046: LD_VAR 0 7
107050: ARRAY
107051: PPUSH
107052: LD_INT 1
107054: PPUSH
107055: CALL_OW 3
107059: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107060: LD_ADDR_VAR 0 16
107064: PUSH
107065: LD_VAR 0 16
107069: PPUSH
107070: LD_VAR 0 7
107074: PPUSH
107075: LD_VAR 0 15
107079: PPUSH
107080: CALL_OW 1
107084: ST_TO_ADDR
// continue ;
107085: GO 105630
// end ; end ; end else
107087: GO 109751
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107089: LD_ADDR_VAR 0 14
107093: PUSH
107094: LD_INT 81
107096: PUSH
107097: LD_VAR 0 4
107101: PUSH
107102: LD_VAR 0 7
107106: ARRAY
107107: PPUSH
107108: CALL_OW 255
107112: PUSH
107113: EMPTY
107114: LIST
107115: LIST
107116: PPUSH
107117: CALL_OW 69
107121: ST_TO_ADDR
// if not tmp then
107122: LD_VAR 0 14
107126: NOT
107127: IFFALSE 107131
// continue ;
107129: GO 105630
// if f_ignore_area then
107131: LD_VAR 0 17
107135: IFFALSE 107223
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107137: LD_ADDR_VAR 0 15
107141: PUSH
107142: LD_VAR 0 14
107146: PPUSH
107147: LD_INT 3
107149: PUSH
107150: LD_INT 92
107152: PUSH
107153: LD_VAR 0 17
107157: PUSH
107158: LD_INT 1
107160: ARRAY
107161: PUSH
107162: LD_VAR 0 17
107166: PUSH
107167: LD_INT 2
107169: ARRAY
107170: PUSH
107171: LD_VAR 0 17
107175: PUSH
107176: LD_INT 3
107178: ARRAY
107179: PUSH
107180: EMPTY
107181: LIST
107182: LIST
107183: LIST
107184: LIST
107185: PUSH
107186: EMPTY
107187: LIST
107188: LIST
107189: PPUSH
107190: CALL_OW 72
107194: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107195: LD_VAR 0 14
107199: PUSH
107200: LD_VAR 0 15
107204: DIFF
107205: IFFALSE 107223
// tmp := tmp diff tmp2 ;
107207: LD_ADDR_VAR 0 14
107211: PUSH
107212: LD_VAR 0 14
107216: PUSH
107217: LD_VAR 0 15
107221: DIFF
107222: ST_TO_ADDR
// end ; if not f_murder then
107223: LD_VAR 0 20
107227: NOT
107228: IFFALSE 107286
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107230: LD_ADDR_VAR 0 15
107234: PUSH
107235: LD_VAR 0 14
107239: PPUSH
107240: LD_INT 3
107242: PUSH
107243: LD_INT 50
107245: PUSH
107246: EMPTY
107247: LIST
107248: PUSH
107249: EMPTY
107250: LIST
107251: LIST
107252: PPUSH
107253: CALL_OW 72
107257: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107258: LD_VAR 0 14
107262: PUSH
107263: LD_VAR 0 15
107267: DIFF
107268: IFFALSE 107286
// tmp := tmp diff tmp2 ;
107270: LD_ADDR_VAR 0 14
107274: PUSH
107275: LD_VAR 0 14
107279: PUSH
107280: LD_VAR 0 15
107284: DIFF
107285: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107286: LD_ADDR_VAR 0 14
107290: PUSH
107291: LD_VAR 0 4
107295: PUSH
107296: LD_VAR 0 7
107300: ARRAY
107301: PPUSH
107302: LD_VAR 0 14
107306: PPUSH
107307: LD_INT 1
107309: PPUSH
107310: LD_INT 1
107312: PPUSH
107313: CALL 56249 0 4
107317: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107318: LD_VAR 0 4
107322: PUSH
107323: LD_VAR 0 7
107327: ARRAY
107328: PPUSH
107329: CALL_OW 257
107333: PUSH
107334: LD_INT 1
107336: EQUAL
107337: IFFALSE 107785
// begin if WantPlant ( group [ i ] ) then
107339: LD_VAR 0 4
107343: PUSH
107344: LD_VAR 0 7
107348: ARRAY
107349: PPUSH
107350: CALL 55750 0 1
107354: IFFALSE 107358
// continue ;
107356: GO 105630
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107358: LD_VAR 0 18
107362: PUSH
107363: LD_VAR 0 4
107367: PUSH
107368: LD_VAR 0 7
107372: ARRAY
107373: PPUSH
107374: CALL_OW 310
107378: NOT
107379: AND
107380: PUSH
107381: LD_VAR 0 14
107385: PUSH
107386: LD_INT 1
107388: ARRAY
107389: PUSH
107390: LD_VAR 0 14
107394: PPUSH
107395: LD_INT 21
107397: PUSH
107398: LD_INT 2
107400: PUSH
107401: EMPTY
107402: LIST
107403: LIST
107404: PUSH
107405: LD_INT 58
107407: PUSH
107408: EMPTY
107409: LIST
107410: PUSH
107411: EMPTY
107412: LIST
107413: LIST
107414: PPUSH
107415: CALL_OW 72
107419: IN
107420: AND
107421: IFFALSE 107457
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107423: LD_VAR 0 4
107427: PUSH
107428: LD_VAR 0 7
107432: ARRAY
107433: PPUSH
107434: LD_VAR 0 14
107438: PUSH
107439: LD_INT 1
107441: ARRAY
107442: PPUSH
107443: CALL_OW 120
// attacking := true ;
107447: LD_ADDR_VAR 0 29
107451: PUSH
107452: LD_INT 1
107454: ST_TO_ADDR
// continue ;
107455: GO 105630
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107457: LD_VAR 0 26
107461: PUSH
107462: LD_VAR 0 4
107466: PUSH
107467: LD_VAR 0 7
107471: ARRAY
107472: PPUSH
107473: CALL_OW 257
107477: PUSH
107478: LD_INT 1
107480: EQUAL
107481: AND
107482: PUSH
107483: LD_VAR 0 4
107487: PUSH
107488: LD_VAR 0 7
107492: ARRAY
107493: PPUSH
107494: CALL_OW 256
107498: PUSH
107499: LD_INT 800
107501: LESS
107502: AND
107503: PUSH
107504: LD_VAR 0 4
107508: PUSH
107509: LD_VAR 0 7
107513: ARRAY
107514: PPUSH
107515: CALL_OW 318
107519: NOT
107520: AND
107521: IFFALSE 107538
// ComCrawl ( group [ i ] ) ;
107523: LD_VAR 0 4
107527: PUSH
107528: LD_VAR 0 7
107532: ARRAY
107533: PPUSH
107534: CALL_OW 137
// if f_mines then
107538: LD_VAR 0 21
107542: IFFALSE 107785
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107544: LD_VAR 0 14
107548: PUSH
107549: LD_INT 1
107551: ARRAY
107552: PPUSH
107553: CALL_OW 247
107557: PUSH
107558: LD_INT 3
107560: EQUAL
107561: PUSH
107562: LD_VAR 0 14
107566: PUSH
107567: LD_INT 1
107569: ARRAY
107570: PUSH
107571: LD_VAR 0 27
107575: IN
107576: NOT
107577: AND
107578: IFFALSE 107785
// begin x := GetX ( tmp [ 1 ] ) ;
107580: LD_ADDR_VAR 0 10
107584: PUSH
107585: LD_VAR 0 14
107589: PUSH
107590: LD_INT 1
107592: ARRAY
107593: PPUSH
107594: CALL_OW 250
107598: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107599: LD_ADDR_VAR 0 11
107603: PUSH
107604: LD_VAR 0 14
107608: PUSH
107609: LD_INT 1
107611: ARRAY
107612: PPUSH
107613: CALL_OW 251
107617: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107618: LD_ADDR_VAR 0 12
107622: PUSH
107623: LD_VAR 0 4
107627: PUSH
107628: LD_VAR 0 7
107632: ARRAY
107633: PPUSH
107634: CALL 82691 0 1
107638: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107639: LD_VAR 0 4
107643: PUSH
107644: LD_VAR 0 7
107648: ARRAY
107649: PPUSH
107650: LD_VAR 0 10
107654: PPUSH
107655: LD_VAR 0 11
107659: PPUSH
107660: LD_VAR 0 14
107664: PUSH
107665: LD_INT 1
107667: ARRAY
107668: PPUSH
107669: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107673: LD_VAR 0 4
107677: PUSH
107678: LD_VAR 0 7
107682: ARRAY
107683: PPUSH
107684: LD_VAR 0 10
107688: PPUSH
107689: LD_VAR 0 12
107693: PPUSH
107694: LD_INT 7
107696: PPUSH
107697: CALL_OW 272
107701: PPUSH
107702: LD_VAR 0 11
107706: PPUSH
107707: LD_VAR 0 12
107711: PPUSH
107712: LD_INT 7
107714: PPUSH
107715: CALL_OW 273
107719: PPUSH
107720: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107724: LD_VAR 0 4
107728: PUSH
107729: LD_VAR 0 7
107733: ARRAY
107734: PPUSH
107735: LD_INT 71
107737: PPUSH
107738: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107742: LD_ADDR_VAR 0 27
107746: PUSH
107747: LD_VAR 0 27
107751: PPUSH
107752: LD_VAR 0 27
107756: PUSH
107757: LD_INT 1
107759: PLUS
107760: PPUSH
107761: LD_VAR 0 14
107765: PUSH
107766: LD_INT 1
107768: ARRAY
107769: PPUSH
107770: CALL_OW 1
107774: ST_TO_ADDR
// attacking := true ;
107775: LD_ADDR_VAR 0 29
107779: PUSH
107780: LD_INT 1
107782: ST_TO_ADDR
// continue ;
107783: GO 105630
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107785: LD_VAR 0 4
107789: PUSH
107790: LD_VAR 0 7
107794: ARRAY
107795: PPUSH
107796: CALL_OW 257
107800: PUSH
107801: LD_INT 17
107803: EQUAL
107804: PUSH
107805: LD_VAR 0 4
107809: PUSH
107810: LD_VAR 0 7
107814: ARRAY
107815: PPUSH
107816: CALL_OW 110
107820: PUSH
107821: LD_INT 71
107823: EQUAL
107824: NOT
107825: AND
107826: IFFALSE 107972
// begin attacking := false ;
107828: LD_ADDR_VAR 0 29
107832: PUSH
107833: LD_INT 0
107835: ST_TO_ADDR
// k := 5 ;
107836: LD_ADDR_VAR 0 9
107840: PUSH
107841: LD_INT 5
107843: ST_TO_ADDR
// if tmp < k then
107844: LD_VAR 0 14
107848: PUSH
107849: LD_VAR 0 9
107853: LESS
107854: IFFALSE 107866
// k := tmp ;
107856: LD_ADDR_VAR 0 9
107860: PUSH
107861: LD_VAR 0 14
107865: ST_TO_ADDR
// for j = 1 to k do
107866: LD_ADDR_VAR 0 8
107870: PUSH
107871: DOUBLE
107872: LD_INT 1
107874: DEC
107875: ST_TO_ADDR
107876: LD_VAR 0 9
107880: PUSH
107881: FOR_TO
107882: IFFALSE 107970
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107884: LD_VAR 0 14
107888: PUSH
107889: LD_VAR 0 8
107893: ARRAY
107894: PUSH
107895: LD_VAR 0 14
107899: PPUSH
107900: LD_INT 58
107902: PUSH
107903: EMPTY
107904: LIST
107905: PPUSH
107906: CALL_OW 72
107910: IN
107911: NOT
107912: IFFALSE 107968
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107914: LD_VAR 0 4
107918: PUSH
107919: LD_VAR 0 7
107923: ARRAY
107924: PPUSH
107925: LD_VAR 0 14
107929: PUSH
107930: LD_VAR 0 8
107934: ARRAY
107935: PPUSH
107936: CALL_OW 115
// attacking := true ;
107940: LD_ADDR_VAR 0 29
107944: PUSH
107945: LD_INT 1
107947: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107948: LD_VAR 0 4
107952: PUSH
107953: LD_VAR 0 7
107957: ARRAY
107958: PPUSH
107959: LD_INT 71
107961: PPUSH
107962: CALL_OW 109
// continue ;
107966: GO 107881
// end ; end ;
107968: GO 107881
107970: POP
107971: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107972: LD_VAR 0 4
107976: PUSH
107977: LD_VAR 0 7
107981: ARRAY
107982: PPUSH
107983: CALL_OW 257
107987: PUSH
107988: LD_INT 8
107990: EQUAL
107991: PUSH
107992: LD_VAR 0 4
107996: PUSH
107997: LD_VAR 0 7
108001: ARRAY
108002: PPUSH
108003: CALL_OW 264
108007: PUSH
108008: LD_INT 28
108010: PUSH
108011: LD_INT 45
108013: PUSH
108014: LD_INT 7
108016: PUSH
108017: LD_INT 47
108019: PUSH
108020: EMPTY
108021: LIST
108022: LIST
108023: LIST
108024: LIST
108025: IN
108026: OR
108027: IFFALSE 108283
// begin attacking := false ;
108029: LD_ADDR_VAR 0 29
108033: PUSH
108034: LD_INT 0
108036: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108037: LD_VAR 0 14
108041: PUSH
108042: LD_INT 1
108044: ARRAY
108045: PPUSH
108046: CALL_OW 266
108050: PUSH
108051: LD_INT 32
108053: PUSH
108054: LD_INT 31
108056: PUSH
108057: LD_INT 33
108059: PUSH
108060: LD_INT 4
108062: PUSH
108063: LD_INT 5
108065: PUSH
108066: EMPTY
108067: LIST
108068: LIST
108069: LIST
108070: LIST
108071: LIST
108072: IN
108073: IFFALSE 108259
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108075: LD_ADDR_VAR 0 9
108079: PUSH
108080: LD_VAR 0 14
108084: PUSH
108085: LD_INT 1
108087: ARRAY
108088: PPUSH
108089: CALL_OW 266
108093: PPUSH
108094: LD_VAR 0 14
108098: PUSH
108099: LD_INT 1
108101: ARRAY
108102: PPUSH
108103: CALL_OW 250
108107: PPUSH
108108: LD_VAR 0 14
108112: PUSH
108113: LD_INT 1
108115: ARRAY
108116: PPUSH
108117: CALL_OW 251
108121: PPUSH
108122: LD_VAR 0 14
108126: PUSH
108127: LD_INT 1
108129: ARRAY
108130: PPUSH
108131: CALL_OW 254
108135: PPUSH
108136: LD_VAR 0 14
108140: PUSH
108141: LD_INT 1
108143: ARRAY
108144: PPUSH
108145: CALL_OW 248
108149: PPUSH
108150: LD_INT 0
108152: PPUSH
108153: CALL 64061 0 6
108157: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108158: LD_ADDR_VAR 0 8
108162: PUSH
108163: LD_VAR 0 4
108167: PUSH
108168: LD_VAR 0 7
108172: ARRAY
108173: PPUSH
108174: LD_VAR 0 9
108178: PPUSH
108179: CALL 82731 0 2
108183: ST_TO_ADDR
// if j then
108184: LD_VAR 0 8
108188: IFFALSE 108257
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108190: LD_VAR 0 8
108194: PUSH
108195: LD_INT 1
108197: ARRAY
108198: PPUSH
108199: LD_VAR 0 8
108203: PUSH
108204: LD_INT 2
108206: ARRAY
108207: PPUSH
108208: CALL_OW 488
108212: IFFALSE 108257
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108214: LD_VAR 0 4
108218: PUSH
108219: LD_VAR 0 7
108223: ARRAY
108224: PPUSH
108225: LD_VAR 0 8
108229: PUSH
108230: LD_INT 1
108232: ARRAY
108233: PPUSH
108234: LD_VAR 0 8
108238: PUSH
108239: LD_INT 2
108241: ARRAY
108242: PPUSH
108243: CALL_OW 116
// attacking := true ;
108247: LD_ADDR_VAR 0 29
108251: PUSH
108252: LD_INT 1
108254: ST_TO_ADDR
// continue ;
108255: GO 105630
// end ; end else
108257: GO 108283
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108259: LD_VAR 0 4
108263: PUSH
108264: LD_VAR 0 7
108268: ARRAY
108269: PPUSH
108270: LD_VAR 0 14
108274: PUSH
108275: LD_INT 1
108277: ARRAY
108278: PPUSH
108279: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108283: LD_VAR 0 4
108287: PUSH
108288: LD_VAR 0 7
108292: ARRAY
108293: PPUSH
108294: CALL_OW 265
108298: PUSH
108299: LD_INT 11
108301: EQUAL
108302: IFFALSE 108580
// begin k := 10 ;
108304: LD_ADDR_VAR 0 9
108308: PUSH
108309: LD_INT 10
108311: ST_TO_ADDR
// x := 0 ;
108312: LD_ADDR_VAR 0 10
108316: PUSH
108317: LD_INT 0
108319: ST_TO_ADDR
// if tmp < k then
108320: LD_VAR 0 14
108324: PUSH
108325: LD_VAR 0 9
108329: LESS
108330: IFFALSE 108342
// k := tmp ;
108332: LD_ADDR_VAR 0 9
108336: PUSH
108337: LD_VAR 0 14
108341: ST_TO_ADDR
// for j = k downto 1 do
108342: LD_ADDR_VAR 0 8
108346: PUSH
108347: DOUBLE
108348: LD_VAR 0 9
108352: INC
108353: ST_TO_ADDR
108354: LD_INT 1
108356: PUSH
108357: FOR_DOWNTO
108358: IFFALSE 108433
// begin if GetType ( tmp [ j ] ) = unit_human then
108360: LD_VAR 0 14
108364: PUSH
108365: LD_VAR 0 8
108369: ARRAY
108370: PPUSH
108371: CALL_OW 247
108375: PUSH
108376: LD_INT 1
108378: EQUAL
108379: IFFALSE 108431
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108381: LD_VAR 0 4
108385: PUSH
108386: LD_VAR 0 7
108390: ARRAY
108391: PPUSH
108392: LD_VAR 0 14
108396: PUSH
108397: LD_VAR 0 8
108401: ARRAY
108402: PPUSH
108403: CALL 83002 0 2
// x := tmp [ j ] ;
108407: LD_ADDR_VAR 0 10
108411: PUSH
108412: LD_VAR 0 14
108416: PUSH
108417: LD_VAR 0 8
108421: ARRAY
108422: ST_TO_ADDR
// attacking := true ;
108423: LD_ADDR_VAR 0 29
108427: PUSH
108428: LD_INT 1
108430: ST_TO_ADDR
// end ; end ;
108431: GO 108357
108433: POP
108434: POP
// if not x then
108435: LD_VAR 0 10
108439: NOT
108440: IFFALSE 108580
// begin attacking := true ;
108442: LD_ADDR_VAR 0 29
108446: PUSH
108447: LD_INT 1
108449: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108450: LD_VAR 0 4
108454: PUSH
108455: LD_VAR 0 7
108459: ARRAY
108460: PPUSH
108461: CALL_OW 250
108465: PPUSH
108466: LD_VAR 0 4
108470: PUSH
108471: LD_VAR 0 7
108475: ARRAY
108476: PPUSH
108477: CALL_OW 251
108481: PPUSH
108482: CALL_OW 546
108486: PUSH
108487: LD_INT 2
108489: ARRAY
108490: PUSH
108491: LD_VAR 0 14
108495: PUSH
108496: LD_INT 1
108498: ARRAY
108499: PPUSH
108500: CALL_OW 250
108504: PPUSH
108505: LD_VAR 0 14
108509: PUSH
108510: LD_INT 1
108512: ARRAY
108513: PPUSH
108514: CALL_OW 251
108518: PPUSH
108519: CALL_OW 546
108523: PUSH
108524: LD_INT 2
108526: ARRAY
108527: EQUAL
108528: IFFALSE 108556
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108530: LD_VAR 0 4
108534: PUSH
108535: LD_VAR 0 7
108539: ARRAY
108540: PPUSH
108541: LD_VAR 0 14
108545: PUSH
108546: LD_INT 1
108548: ARRAY
108549: PPUSH
108550: CALL 83002 0 2
108554: GO 108580
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108556: LD_VAR 0 4
108560: PUSH
108561: LD_VAR 0 7
108565: ARRAY
108566: PPUSH
108567: LD_VAR 0 14
108571: PUSH
108572: LD_INT 1
108574: ARRAY
108575: PPUSH
108576: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108580: LD_VAR 0 4
108584: PUSH
108585: LD_VAR 0 7
108589: ARRAY
108590: PPUSH
108591: CALL_OW 264
108595: PUSH
108596: LD_INT 29
108598: EQUAL
108599: IFFALSE 108965
// begin if WantsToAttack ( group [ i ] ) in bombed then
108601: LD_VAR 0 4
108605: PUSH
108606: LD_VAR 0 7
108610: ARRAY
108611: PPUSH
108612: CALL_OW 319
108616: PUSH
108617: LD_VAR 0 28
108621: IN
108622: IFFALSE 108626
// continue ;
108624: GO 105630
// k := 8 ;
108626: LD_ADDR_VAR 0 9
108630: PUSH
108631: LD_INT 8
108633: ST_TO_ADDR
// x := 0 ;
108634: LD_ADDR_VAR 0 10
108638: PUSH
108639: LD_INT 0
108641: ST_TO_ADDR
// if tmp < k then
108642: LD_VAR 0 14
108646: PUSH
108647: LD_VAR 0 9
108651: LESS
108652: IFFALSE 108664
// k := tmp ;
108654: LD_ADDR_VAR 0 9
108658: PUSH
108659: LD_VAR 0 14
108663: ST_TO_ADDR
// for j = 1 to k do
108664: LD_ADDR_VAR 0 8
108668: PUSH
108669: DOUBLE
108670: LD_INT 1
108672: DEC
108673: ST_TO_ADDR
108674: LD_VAR 0 9
108678: PUSH
108679: FOR_TO
108680: IFFALSE 108812
// begin if GetType ( tmp [ j ] ) = unit_building then
108682: LD_VAR 0 14
108686: PUSH
108687: LD_VAR 0 8
108691: ARRAY
108692: PPUSH
108693: CALL_OW 247
108697: PUSH
108698: LD_INT 3
108700: EQUAL
108701: IFFALSE 108810
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108703: LD_VAR 0 14
108707: PUSH
108708: LD_VAR 0 8
108712: ARRAY
108713: PUSH
108714: LD_VAR 0 28
108718: IN
108719: NOT
108720: PUSH
108721: LD_VAR 0 14
108725: PUSH
108726: LD_VAR 0 8
108730: ARRAY
108731: PPUSH
108732: CALL_OW 313
108736: AND
108737: IFFALSE 108810
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108739: LD_VAR 0 4
108743: PUSH
108744: LD_VAR 0 7
108748: ARRAY
108749: PPUSH
108750: LD_VAR 0 14
108754: PUSH
108755: LD_VAR 0 8
108759: ARRAY
108760: PPUSH
108761: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108765: LD_ADDR_VAR 0 28
108769: PUSH
108770: LD_VAR 0 28
108774: PPUSH
108775: LD_VAR 0 28
108779: PUSH
108780: LD_INT 1
108782: PLUS
108783: PPUSH
108784: LD_VAR 0 14
108788: PUSH
108789: LD_VAR 0 8
108793: ARRAY
108794: PPUSH
108795: CALL_OW 1
108799: ST_TO_ADDR
// attacking := true ;
108800: LD_ADDR_VAR 0 29
108804: PUSH
108805: LD_INT 1
108807: ST_TO_ADDR
// break ;
108808: GO 108812
// end ; end ;
108810: GO 108679
108812: POP
108813: POP
// if not attacking and f_attack_depot then
108814: LD_VAR 0 29
108818: NOT
108819: PUSH
108820: LD_VAR 0 25
108824: AND
108825: IFFALSE 108920
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108827: LD_ADDR_VAR 0 13
108831: PUSH
108832: LD_VAR 0 14
108836: PPUSH
108837: LD_INT 2
108839: PUSH
108840: LD_INT 30
108842: PUSH
108843: LD_INT 0
108845: PUSH
108846: EMPTY
108847: LIST
108848: LIST
108849: PUSH
108850: LD_INT 30
108852: PUSH
108853: LD_INT 1
108855: PUSH
108856: EMPTY
108857: LIST
108858: LIST
108859: PUSH
108860: EMPTY
108861: LIST
108862: LIST
108863: LIST
108864: PPUSH
108865: CALL_OW 72
108869: ST_TO_ADDR
// if z then
108870: LD_VAR 0 13
108874: IFFALSE 108920
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108876: LD_VAR 0 4
108880: PUSH
108881: LD_VAR 0 7
108885: ARRAY
108886: PPUSH
108887: LD_VAR 0 13
108891: PPUSH
108892: LD_VAR 0 4
108896: PUSH
108897: LD_VAR 0 7
108901: ARRAY
108902: PPUSH
108903: CALL_OW 74
108907: PPUSH
108908: CALL_OW 115
// attacking := true ;
108912: LD_ADDR_VAR 0 29
108916: PUSH
108917: LD_INT 1
108919: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108920: LD_VAR 0 4
108924: PUSH
108925: LD_VAR 0 7
108929: ARRAY
108930: PPUSH
108931: CALL_OW 256
108935: PUSH
108936: LD_INT 500
108938: LESS
108939: IFFALSE 108965
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108941: LD_VAR 0 4
108945: PUSH
108946: LD_VAR 0 7
108950: ARRAY
108951: PPUSH
108952: LD_VAR 0 14
108956: PUSH
108957: LD_INT 1
108959: ARRAY
108960: PPUSH
108961: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108965: LD_VAR 0 4
108969: PUSH
108970: LD_VAR 0 7
108974: ARRAY
108975: PPUSH
108976: CALL_OW 264
108980: PUSH
108981: LD_INT 49
108983: EQUAL
108984: IFFALSE 109105
// begin if not HasTask ( group [ i ] ) then
108986: LD_VAR 0 4
108990: PUSH
108991: LD_VAR 0 7
108995: ARRAY
108996: PPUSH
108997: CALL_OW 314
109001: NOT
109002: IFFALSE 109105
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109004: LD_ADDR_VAR 0 9
109008: PUSH
109009: LD_INT 81
109011: PUSH
109012: LD_VAR 0 4
109016: PUSH
109017: LD_VAR 0 7
109021: ARRAY
109022: PPUSH
109023: CALL_OW 255
109027: PUSH
109028: EMPTY
109029: LIST
109030: LIST
109031: PPUSH
109032: CALL_OW 69
109036: PPUSH
109037: LD_VAR 0 4
109041: PUSH
109042: LD_VAR 0 7
109046: ARRAY
109047: PPUSH
109048: CALL_OW 74
109052: ST_TO_ADDR
// if k then
109053: LD_VAR 0 9
109057: IFFALSE 109105
// if GetDistUnits ( group [ i ] , k ) > 10 then
109059: LD_VAR 0 4
109063: PUSH
109064: LD_VAR 0 7
109068: ARRAY
109069: PPUSH
109070: LD_VAR 0 9
109074: PPUSH
109075: CALL_OW 296
109079: PUSH
109080: LD_INT 10
109082: GREATER
109083: IFFALSE 109105
// ComMoveUnit ( group [ i ] , k ) ;
109085: LD_VAR 0 4
109089: PUSH
109090: LD_VAR 0 7
109094: ARRAY
109095: PPUSH
109096: LD_VAR 0 9
109100: PPUSH
109101: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109105: LD_VAR 0 4
109109: PUSH
109110: LD_VAR 0 7
109114: ARRAY
109115: PPUSH
109116: CALL_OW 256
109120: PUSH
109121: LD_INT 250
109123: LESS
109124: PUSH
109125: LD_VAR 0 4
109129: PUSH
109130: LD_VAR 0 7
109134: ARRAY
109135: PUSH
109136: LD_INT 21
109138: PUSH
109139: LD_INT 2
109141: PUSH
109142: EMPTY
109143: LIST
109144: LIST
109145: PUSH
109146: LD_INT 23
109148: PUSH
109149: LD_INT 2
109151: PUSH
109152: EMPTY
109153: LIST
109154: LIST
109155: PUSH
109156: EMPTY
109157: LIST
109158: LIST
109159: PPUSH
109160: CALL_OW 69
109164: IN
109165: AND
109166: IFFALSE 109291
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109168: LD_ADDR_VAR 0 9
109172: PUSH
109173: LD_OWVAR 3
109177: PUSH
109178: LD_VAR 0 4
109182: PUSH
109183: LD_VAR 0 7
109187: ARRAY
109188: DIFF
109189: PPUSH
109190: LD_VAR 0 4
109194: PUSH
109195: LD_VAR 0 7
109199: ARRAY
109200: PPUSH
109201: CALL_OW 74
109205: ST_TO_ADDR
// if not k then
109206: LD_VAR 0 9
109210: NOT
109211: IFFALSE 109215
// continue ;
109213: GO 105630
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109215: LD_VAR 0 9
109219: PUSH
109220: LD_INT 81
109222: PUSH
109223: LD_VAR 0 4
109227: PUSH
109228: LD_VAR 0 7
109232: ARRAY
109233: PPUSH
109234: CALL_OW 255
109238: PUSH
109239: EMPTY
109240: LIST
109241: LIST
109242: PPUSH
109243: CALL_OW 69
109247: IN
109248: PUSH
109249: LD_VAR 0 9
109253: PPUSH
109254: LD_VAR 0 4
109258: PUSH
109259: LD_VAR 0 7
109263: ARRAY
109264: PPUSH
109265: CALL_OW 296
109269: PUSH
109270: LD_INT 5
109272: LESS
109273: AND
109274: IFFALSE 109291
// ComAutodestruct ( group [ i ] ) ;
109276: LD_VAR 0 4
109280: PUSH
109281: LD_VAR 0 7
109285: ARRAY
109286: PPUSH
109287: CALL 82900 0 1
// end ; if f_attack_depot then
109291: LD_VAR 0 25
109295: IFFALSE 109407
// begin k := 6 ;
109297: LD_ADDR_VAR 0 9
109301: PUSH
109302: LD_INT 6
109304: ST_TO_ADDR
// if tmp < k then
109305: LD_VAR 0 14
109309: PUSH
109310: LD_VAR 0 9
109314: LESS
109315: IFFALSE 109327
// k := tmp ;
109317: LD_ADDR_VAR 0 9
109321: PUSH
109322: LD_VAR 0 14
109326: ST_TO_ADDR
// for j = 1 to k do
109327: LD_ADDR_VAR 0 8
109331: PUSH
109332: DOUBLE
109333: LD_INT 1
109335: DEC
109336: ST_TO_ADDR
109337: LD_VAR 0 9
109341: PUSH
109342: FOR_TO
109343: IFFALSE 109405
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109345: LD_VAR 0 8
109349: PPUSH
109350: CALL_OW 266
109354: PUSH
109355: LD_INT 0
109357: PUSH
109358: LD_INT 1
109360: PUSH
109361: EMPTY
109362: LIST
109363: LIST
109364: IN
109365: IFFALSE 109403
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109367: LD_VAR 0 4
109371: PUSH
109372: LD_VAR 0 7
109376: ARRAY
109377: PPUSH
109378: LD_VAR 0 14
109382: PUSH
109383: LD_VAR 0 8
109387: ARRAY
109388: PPUSH
109389: CALL_OW 115
// attacking := true ;
109393: LD_ADDR_VAR 0 29
109397: PUSH
109398: LD_INT 1
109400: ST_TO_ADDR
// break ;
109401: GO 109405
// end ;
109403: GO 109342
109405: POP
109406: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109407: LD_VAR 0 4
109411: PUSH
109412: LD_VAR 0 7
109416: ARRAY
109417: PPUSH
109418: CALL_OW 302
109422: PUSH
109423: LD_VAR 0 29
109427: NOT
109428: AND
109429: IFFALSE 109751
// begin if GetTag ( group [ i ] ) = 71 then
109431: LD_VAR 0 4
109435: PUSH
109436: LD_VAR 0 7
109440: ARRAY
109441: PPUSH
109442: CALL_OW 110
109446: PUSH
109447: LD_INT 71
109449: EQUAL
109450: IFFALSE 109491
// begin if HasTask ( group [ i ] ) then
109452: LD_VAR 0 4
109456: PUSH
109457: LD_VAR 0 7
109461: ARRAY
109462: PPUSH
109463: CALL_OW 314
109467: IFFALSE 109473
// continue else
109469: GO 105630
109471: GO 109491
// SetTag ( group [ i ] , 0 ) ;
109473: LD_VAR 0 4
109477: PUSH
109478: LD_VAR 0 7
109482: ARRAY
109483: PPUSH
109484: LD_INT 0
109486: PPUSH
109487: CALL_OW 109
// end ; k := 8 ;
109491: LD_ADDR_VAR 0 9
109495: PUSH
109496: LD_INT 8
109498: ST_TO_ADDR
// x := 0 ;
109499: LD_ADDR_VAR 0 10
109503: PUSH
109504: LD_INT 0
109506: ST_TO_ADDR
// if tmp < k then
109507: LD_VAR 0 14
109511: PUSH
109512: LD_VAR 0 9
109516: LESS
109517: IFFALSE 109529
// k := tmp ;
109519: LD_ADDR_VAR 0 9
109523: PUSH
109524: LD_VAR 0 14
109528: ST_TO_ADDR
// for j = 1 to k do
109529: LD_ADDR_VAR 0 8
109533: PUSH
109534: DOUBLE
109535: LD_INT 1
109537: DEC
109538: ST_TO_ADDR
109539: LD_VAR 0 9
109543: PUSH
109544: FOR_TO
109545: IFFALSE 109643
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109547: LD_VAR 0 14
109551: PUSH
109552: LD_VAR 0 8
109556: ARRAY
109557: PPUSH
109558: CALL_OW 247
109562: PUSH
109563: LD_INT 1
109565: EQUAL
109566: PUSH
109567: LD_VAR 0 14
109571: PUSH
109572: LD_VAR 0 8
109576: ARRAY
109577: PPUSH
109578: CALL_OW 256
109582: PUSH
109583: LD_INT 250
109585: LESS
109586: PUSH
109587: LD_VAR 0 20
109591: AND
109592: PUSH
109593: LD_VAR 0 20
109597: NOT
109598: PUSH
109599: LD_VAR 0 14
109603: PUSH
109604: LD_VAR 0 8
109608: ARRAY
109609: PPUSH
109610: CALL_OW 256
109614: PUSH
109615: LD_INT 250
109617: GREATEREQUAL
109618: AND
109619: OR
109620: AND
109621: IFFALSE 109641
// begin x := tmp [ j ] ;
109623: LD_ADDR_VAR 0 10
109627: PUSH
109628: LD_VAR 0 14
109632: PUSH
109633: LD_VAR 0 8
109637: ARRAY
109638: ST_TO_ADDR
// break ;
109639: GO 109643
// end ;
109641: GO 109544
109643: POP
109644: POP
// if x then
109645: LD_VAR 0 10
109649: IFFALSE 109673
// ComAttackUnit ( group [ i ] , x ) else
109651: LD_VAR 0 4
109655: PUSH
109656: LD_VAR 0 7
109660: ARRAY
109661: PPUSH
109662: LD_VAR 0 10
109666: PPUSH
109667: CALL_OW 115
109671: GO 109697
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109673: LD_VAR 0 4
109677: PUSH
109678: LD_VAR 0 7
109682: ARRAY
109683: PPUSH
109684: LD_VAR 0 14
109688: PUSH
109689: LD_INT 1
109691: ARRAY
109692: PPUSH
109693: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109697: LD_VAR 0 4
109701: PUSH
109702: LD_VAR 0 7
109706: ARRAY
109707: PPUSH
109708: CALL_OW 314
109712: NOT
109713: IFFALSE 109751
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109715: LD_VAR 0 4
109719: PUSH
109720: LD_VAR 0 7
109724: ARRAY
109725: PPUSH
109726: LD_VAR 0 14
109730: PPUSH
109731: LD_VAR 0 4
109735: PUSH
109736: LD_VAR 0 7
109740: ARRAY
109741: PPUSH
109742: CALL_OW 74
109746: PPUSH
109747: CALL_OW 115
// end ; end ; end ;
109751: GO 105630
109753: POP
109754: POP
// wait ( 0 0$2 ) ;
109755: LD_INT 70
109757: PPUSH
109758: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109762: LD_VAR 0 4
109766: NOT
109767: PUSH
109768: LD_VAR 0 4
109772: PUSH
109773: EMPTY
109774: EQUAL
109775: OR
109776: PUSH
109777: LD_INT 81
109779: PUSH
109780: LD_VAR 0 35
109784: PUSH
109785: EMPTY
109786: LIST
109787: LIST
109788: PPUSH
109789: CALL_OW 69
109793: NOT
109794: OR
109795: IFFALSE 105615
// end ;
109797: LD_VAR 0 2
109801: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
109802: LD_INT 0
109804: PPUSH
109805: PPUSH
109806: PPUSH
109807: PPUSH
109808: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
109809: LD_VAR 0 1
109813: NOT
109814: PUSH
109815: LD_EXP 90
109819: PUSH
109820: LD_VAR 0 1
109824: ARRAY
109825: NOT
109826: OR
109827: PUSH
109828: LD_VAR 0 2
109832: NOT
109833: OR
109834: PUSH
109835: LD_VAR 0 3
109839: NOT
109840: OR
109841: IFFALSE 109845
// exit ;
109843: GO 110358
// side := mc_sides [ base ] ;
109845: LD_ADDR_VAR 0 6
109849: PUSH
109850: LD_EXP 116
109854: PUSH
109855: LD_VAR 0 1
109859: ARRAY
109860: ST_TO_ADDR
// if not side then
109861: LD_VAR 0 6
109865: NOT
109866: IFFALSE 109870
// exit ;
109868: GO 110358
// for i in solds do
109870: LD_ADDR_VAR 0 7
109874: PUSH
109875: LD_VAR 0 2
109879: PUSH
109880: FOR_IN
109881: IFFALSE 109942
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109883: LD_VAR 0 7
109887: PPUSH
109888: CALL_OW 310
109892: PPUSH
109893: CALL_OW 266
109897: PUSH
109898: LD_INT 32
109900: PUSH
109901: LD_INT 31
109903: PUSH
109904: EMPTY
109905: LIST
109906: LIST
109907: IN
109908: IFFALSE 109928
// solds := solds diff i else
109910: LD_ADDR_VAR 0 2
109914: PUSH
109915: LD_VAR 0 2
109919: PUSH
109920: LD_VAR 0 7
109924: DIFF
109925: ST_TO_ADDR
109926: GO 109940
// SetTag ( i , 18 ) ;
109928: LD_VAR 0 7
109932: PPUSH
109933: LD_INT 18
109935: PPUSH
109936: CALL_OW 109
109940: GO 109880
109942: POP
109943: POP
// if not solds then
109944: LD_VAR 0 2
109948: NOT
109949: IFFALSE 109953
// exit ;
109951: GO 110358
// repeat wait ( 0 0$2 ) ;
109953: LD_INT 70
109955: PPUSH
109956: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
109960: LD_ADDR_VAR 0 5
109964: PUSH
109965: LD_VAR 0 6
109969: PPUSH
109970: LD_VAR 0 3
109974: PPUSH
109975: CALL 52615 0 2
109979: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109980: LD_EXP 90
109984: PUSH
109985: LD_VAR 0 1
109989: ARRAY
109990: NOT
109991: PUSH
109992: LD_EXP 90
109996: PUSH
109997: LD_VAR 0 1
110001: ARRAY
110002: PUSH
110003: EMPTY
110004: EQUAL
110005: OR
110006: IFFALSE 110043
// begin for i in solds do
110008: LD_ADDR_VAR 0 7
110012: PUSH
110013: LD_VAR 0 2
110017: PUSH
110018: FOR_IN
110019: IFFALSE 110032
// ComStop ( i ) ;
110021: LD_VAR 0 7
110025: PPUSH
110026: CALL_OW 141
110030: GO 110018
110032: POP
110033: POP
// solds := [ ] ;
110034: LD_ADDR_VAR 0 2
110038: PUSH
110039: EMPTY
110040: ST_TO_ADDR
// exit ;
110041: GO 110358
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
110043: LD_VAR 0 5
110047: NOT
110048: PUSH
110049: LD_VAR 0 5
110053: PUSH
110054: LD_INT 3
110056: GREATER
110057: OR
110058: PUSH
110059: LD_EXP 112
110063: PUSH
110064: LD_VAR 0 1
110068: ARRAY
110069: OR
110070: IFFALSE 110111
// begin for i in solds do
110072: LD_ADDR_VAR 0 7
110076: PUSH
110077: LD_VAR 0 2
110081: PUSH
110082: FOR_IN
110083: IFFALSE 110107
// if HasTask ( i ) then
110085: LD_VAR 0 7
110089: PPUSH
110090: CALL_OW 314
110094: IFFALSE 110105
// ComStop ( i ) ;
110096: LD_VAR 0 7
110100: PPUSH
110101: CALL_OW 141
110105: GO 110082
110107: POP
110108: POP
// break ;
110109: GO 110346
// end ; for i in solds do
110111: LD_ADDR_VAR 0 7
110115: PUSH
110116: LD_VAR 0 2
110120: PUSH
110121: FOR_IN
110122: IFFALSE 110338
// begin if IsInUnit ( i ) then
110124: LD_VAR 0 7
110128: PPUSH
110129: CALL_OW 310
110133: IFFALSE 110144
// ComExitBuilding ( i ) ;
110135: LD_VAR 0 7
110139: PPUSH
110140: CALL_OW 122
// if GetLives ( i ) > 333 then
110144: LD_VAR 0 7
110148: PPUSH
110149: CALL_OW 256
110153: PUSH
110154: LD_INT 333
110156: GREATER
110157: IFFALSE 110185
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110159: LD_VAR 0 7
110163: PPUSH
110164: LD_VAR 0 5
110168: PPUSH
110169: LD_VAR 0 7
110173: PPUSH
110174: CALL_OW 74
110178: PPUSH
110179: CALL_OW 115
110183: GO 110336
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110185: LD_ADDR_VAR 0 8
110189: PUSH
110190: LD_EXP 90
110194: PUSH
110195: LD_VAR 0 1
110199: ARRAY
110200: PPUSH
110201: LD_INT 2
110203: PUSH
110204: LD_INT 30
110206: PUSH
110207: LD_INT 0
110209: PUSH
110210: EMPTY
110211: LIST
110212: LIST
110213: PUSH
110214: LD_INT 30
110216: PUSH
110217: LD_INT 1
110219: PUSH
110220: EMPTY
110221: LIST
110222: LIST
110223: PUSH
110224: LD_INT 30
110226: PUSH
110227: LD_INT 6
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: PUSH
110234: EMPTY
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: PPUSH
110240: CALL_OW 72
110244: PPUSH
110245: LD_VAR 0 7
110249: PPUSH
110250: CALL_OW 74
110254: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110255: LD_VAR 0 7
110259: PPUSH
110260: LD_VAR 0 8
110264: PPUSH
110265: CALL_OW 250
110269: PPUSH
110270: LD_INT 3
110272: PPUSH
110273: LD_INT 5
110275: PPUSH
110276: CALL_OW 272
110280: PPUSH
110281: LD_VAR 0 8
110285: PPUSH
110286: CALL_OW 251
110290: PPUSH
110291: LD_INT 3
110293: PPUSH
110294: LD_INT 5
110296: PPUSH
110297: CALL_OW 273
110301: PPUSH
110302: CALL_OW 111
// SetTag ( i , 0 ) ;
110306: LD_VAR 0 7
110310: PPUSH
110311: LD_INT 0
110313: PPUSH
110314: CALL_OW 109
// solds := solds diff i ;
110318: LD_ADDR_VAR 0 2
110322: PUSH
110323: LD_VAR 0 2
110327: PUSH
110328: LD_VAR 0 7
110332: DIFF
110333: ST_TO_ADDR
// continue ;
110334: GO 110121
// end ; end ;
110336: GO 110121
110338: POP
110339: POP
// until solds ;
110340: LD_VAR 0 2
110344: IFFALSE 109953
// MC_Reset ( base , 18 ) ;
110346: LD_VAR 0 1
110350: PPUSH
110351: LD_INT 18
110353: PPUSH
110354: CALL 24856 0 2
// end ;
110358: LD_VAR 0 4
110362: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
110363: LD_INT 0
110365: PPUSH
110366: PPUSH
110367: PPUSH
110368: PPUSH
110369: PPUSH
110370: PPUSH
110371: PPUSH
110372: PPUSH
110373: PPUSH
110374: PPUSH
110375: PPUSH
110376: PPUSH
110377: PPUSH
110378: PPUSH
110379: PPUSH
110380: PPUSH
110381: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110382: LD_ADDR_VAR 0 13
110386: PUSH
110387: LD_EXP 90
110391: PUSH
110392: LD_VAR 0 1
110396: ARRAY
110397: PPUSH
110398: LD_INT 25
110400: PUSH
110401: LD_INT 3
110403: PUSH
110404: EMPTY
110405: LIST
110406: LIST
110407: PPUSH
110408: CALL_OW 72
110412: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110413: LD_EXP 130
110417: PUSH
110418: LD_VAR 0 1
110422: ARRAY
110423: IFFALSE 110447
// mechs := mechs diff mc_remote_driver [ base ] ;
110425: LD_ADDR_VAR 0 13
110429: PUSH
110430: LD_VAR 0 13
110434: PUSH
110435: LD_EXP 130
110439: PUSH
110440: LD_VAR 0 1
110444: ARRAY
110445: DIFF
110446: ST_TO_ADDR
// for i in mechs do
110447: LD_ADDR_VAR 0 5
110451: PUSH
110452: LD_VAR 0 13
110456: PUSH
110457: FOR_IN
110458: IFFALSE 110493
// if GetTag ( i ) > 0 then
110460: LD_VAR 0 5
110464: PPUSH
110465: CALL_OW 110
110469: PUSH
110470: LD_INT 0
110472: GREATER
110473: IFFALSE 110491
// mechs := mechs diff i ;
110475: LD_ADDR_VAR 0 13
110479: PUSH
110480: LD_VAR 0 13
110484: PUSH
110485: LD_VAR 0 5
110489: DIFF
110490: ST_TO_ADDR
110491: GO 110457
110493: POP
110494: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110495: LD_ADDR_VAR 0 9
110499: PUSH
110500: LD_EXP 90
110504: PUSH
110505: LD_VAR 0 1
110509: ARRAY
110510: PPUSH
110511: LD_INT 2
110513: PUSH
110514: LD_INT 25
110516: PUSH
110517: LD_INT 1
110519: PUSH
110520: EMPTY
110521: LIST
110522: LIST
110523: PUSH
110524: LD_INT 25
110526: PUSH
110527: LD_INT 5
110529: PUSH
110530: EMPTY
110531: LIST
110532: LIST
110533: PUSH
110534: LD_INT 25
110536: PUSH
110537: LD_INT 8
110539: PUSH
110540: EMPTY
110541: LIST
110542: LIST
110543: PUSH
110544: LD_INT 25
110546: PUSH
110547: LD_INT 9
110549: PUSH
110550: EMPTY
110551: LIST
110552: LIST
110553: PUSH
110554: EMPTY
110555: LIST
110556: LIST
110557: LIST
110558: LIST
110559: LIST
110560: PPUSH
110561: CALL_OW 72
110565: ST_TO_ADDR
// if not defenders and not solds then
110566: LD_VAR 0 2
110570: NOT
110571: PUSH
110572: LD_VAR 0 9
110576: NOT
110577: AND
110578: IFFALSE 110582
// exit ;
110580: GO 112272
// depot_under_attack := false ;
110582: LD_ADDR_VAR 0 17
110586: PUSH
110587: LD_INT 0
110589: ST_TO_ADDR
// sold_defenders := [ ] ;
110590: LD_ADDR_VAR 0 18
110594: PUSH
110595: EMPTY
110596: ST_TO_ADDR
// if mechs then
110597: LD_VAR 0 13
110601: IFFALSE 110754
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110603: LD_ADDR_VAR 0 5
110607: PUSH
110608: LD_VAR 0 2
110612: PPUSH
110613: LD_INT 21
110615: PUSH
110616: LD_INT 2
110618: PUSH
110619: EMPTY
110620: LIST
110621: LIST
110622: PPUSH
110623: CALL_OW 72
110627: PUSH
110628: FOR_IN
110629: IFFALSE 110752
// begin if GetTag ( i ) <> 20 then
110631: LD_VAR 0 5
110635: PPUSH
110636: CALL_OW 110
110640: PUSH
110641: LD_INT 20
110643: NONEQUAL
110644: IFFALSE 110658
// SetTag ( i , 20 ) ;
110646: LD_VAR 0 5
110650: PPUSH
110651: LD_INT 20
110653: PPUSH
110654: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110658: LD_VAR 0 5
110662: PPUSH
110663: CALL_OW 263
110667: PUSH
110668: LD_INT 1
110670: EQUAL
110671: PUSH
110672: LD_VAR 0 5
110676: PPUSH
110677: CALL_OW 311
110681: NOT
110682: AND
110683: IFFALSE 110750
// begin un := mechs [ 1 ] ;
110685: LD_ADDR_VAR 0 11
110689: PUSH
110690: LD_VAR 0 13
110694: PUSH
110695: LD_INT 1
110697: ARRAY
110698: ST_TO_ADDR
// ComExit ( un ) ;
110699: LD_VAR 0 11
110703: PPUSH
110704: CALL 87245 0 1
// AddComEnterUnit ( un , i ) ;
110708: LD_VAR 0 11
110712: PPUSH
110713: LD_VAR 0 5
110717: PPUSH
110718: CALL_OW 180
// SetTag ( un , 19 ) ;
110722: LD_VAR 0 11
110726: PPUSH
110727: LD_INT 19
110729: PPUSH
110730: CALL_OW 109
// mechs := mechs diff un ;
110734: LD_ADDR_VAR 0 13
110738: PUSH
110739: LD_VAR 0 13
110743: PUSH
110744: LD_VAR 0 11
110748: DIFF
110749: ST_TO_ADDR
// end ; end ;
110750: GO 110628
110752: POP
110753: POP
// if solds then
110754: LD_VAR 0 9
110758: IFFALSE 110817
// for i in solds do
110760: LD_ADDR_VAR 0 5
110764: PUSH
110765: LD_VAR 0 9
110769: PUSH
110770: FOR_IN
110771: IFFALSE 110815
// if not GetTag ( i ) then
110773: LD_VAR 0 5
110777: PPUSH
110778: CALL_OW 110
110782: NOT
110783: IFFALSE 110813
// begin defenders := defenders union i ;
110785: LD_ADDR_VAR 0 2
110789: PUSH
110790: LD_VAR 0 2
110794: PUSH
110795: LD_VAR 0 5
110799: UNION
110800: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110801: LD_VAR 0 5
110805: PPUSH
110806: LD_INT 18
110808: PPUSH
110809: CALL_OW 109
// end ;
110813: GO 110770
110815: POP
110816: POP
// repeat wait ( 0 0$2 ) ;
110817: LD_INT 70
110819: PPUSH
110820: CALL_OW 67
// enemy := mc_scan [ base ] ;
110824: LD_ADDR_VAR 0 3
110828: PUSH
110829: LD_EXP 113
110833: PUSH
110834: LD_VAR 0 1
110838: ARRAY
110839: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110840: LD_EXP 90
110844: PUSH
110845: LD_VAR 0 1
110849: ARRAY
110850: NOT
110851: PUSH
110852: LD_EXP 90
110856: PUSH
110857: LD_VAR 0 1
110861: ARRAY
110862: PUSH
110863: EMPTY
110864: EQUAL
110865: OR
110866: IFFALSE 110903
// begin for i in defenders do
110868: LD_ADDR_VAR 0 5
110872: PUSH
110873: LD_VAR 0 2
110877: PUSH
110878: FOR_IN
110879: IFFALSE 110892
// ComStop ( i ) ;
110881: LD_VAR 0 5
110885: PPUSH
110886: CALL_OW 141
110890: GO 110878
110892: POP
110893: POP
// defenders := [ ] ;
110894: LD_ADDR_VAR 0 2
110898: PUSH
110899: EMPTY
110900: ST_TO_ADDR
// exit ;
110901: GO 112272
// end ; for i in defenders do
110903: LD_ADDR_VAR 0 5
110907: PUSH
110908: LD_VAR 0 2
110912: PUSH
110913: FOR_IN
110914: IFFALSE 111732
// begin e := NearestUnitToUnit ( enemy , i ) ;
110916: LD_ADDR_VAR 0 14
110920: PUSH
110921: LD_VAR 0 3
110925: PPUSH
110926: LD_VAR 0 5
110930: PPUSH
110931: CALL_OW 74
110935: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110936: LD_ADDR_VAR 0 8
110940: PUSH
110941: LD_EXP 90
110945: PUSH
110946: LD_VAR 0 1
110950: ARRAY
110951: PPUSH
110952: LD_INT 2
110954: PUSH
110955: LD_INT 30
110957: PUSH
110958: LD_INT 0
110960: PUSH
110961: EMPTY
110962: LIST
110963: LIST
110964: PUSH
110965: LD_INT 30
110967: PUSH
110968: LD_INT 1
110970: PUSH
110971: EMPTY
110972: LIST
110973: LIST
110974: PUSH
110975: EMPTY
110976: LIST
110977: LIST
110978: LIST
110979: PPUSH
110980: CALL_OW 72
110984: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110985: LD_ADDR_VAR 0 17
110989: PUSH
110990: LD_VAR 0 8
110994: NOT
110995: PUSH
110996: LD_VAR 0 8
111000: PPUSH
111001: LD_INT 3
111003: PUSH
111004: LD_INT 24
111006: PUSH
111007: LD_INT 600
111009: PUSH
111010: EMPTY
111011: LIST
111012: LIST
111013: PUSH
111014: EMPTY
111015: LIST
111016: LIST
111017: PPUSH
111018: CALL_OW 72
111022: OR
111023: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111024: LD_VAR 0 5
111028: PPUSH
111029: CALL_OW 247
111033: PUSH
111034: LD_INT 2
111036: DOUBLE
111037: EQUAL
111038: IFTRUE 111042
111040: GO 111438
111042: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111043: LD_VAR 0 5
111047: PPUSH
111048: CALL_OW 256
111052: PUSH
111053: LD_INT 650
111055: GREATER
111056: PUSH
111057: LD_VAR 0 5
111061: PPUSH
111062: LD_VAR 0 14
111066: PPUSH
111067: CALL_OW 296
111071: PUSH
111072: LD_INT 40
111074: LESS
111075: PUSH
111076: LD_VAR 0 14
111080: PPUSH
111081: LD_EXP 115
111085: PUSH
111086: LD_VAR 0 1
111090: ARRAY
111091: PPUSH
111092: CALL_OW 308
111096: OR
111097: AND
111098: IFFALSE 111220
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111100: LD_VAR 0 5
111104: PPUSH
111105: CALL_OW 262
111109: PUSH
111110: LD_INT 1
111112: EQUAL
111113: PUSH
111114: LD_VAR 0 5
111118: PPUSH
111119: CALL_OW 261
111123: PUSH
111124: LD_INT 30
111126: LESS
111127: AND
111128: PUSH
111129: LD_VAR 0 8
111133: AND
111134: IFFALSE 111204
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111136: LD_VAR 0 5
111140: PPUSH
111141: LD_VAR 0 8
111145: PPUSH
111146: LD_VAR 0 5
111150: PPUSH
111151: CALL_OW 74
111155: PPUSH
111156: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111160: LD_VAR 0 5
111164: PPUSH
111165: LD_VAR 0 8
111169: PPUSH
111170: LD_VAR 0 5
111174: PPUSH
111175: CALL_OW 74
111179: PPUSH
111180: CALL_OW 296
111184: PUSH
111185: LD_INT 6
111187: LESS
111188: IFFALSE 111202
// SetFuel ( i , 100 ) ;
111190: LD_VAR 0 5
111194: PPUSH
111195: LD_INT 100
111197: PPUSH
111198: CALL_OW 240
// end else
111202: GO 111218
// ComAttackUnit ( i , e ) ;
111204: LD_VAR 0 5
111208: PPUSH
111209: LD_VAR 0 14
111213: PPUSH
111214: CALL_OW 115
// end else
111218: GO 111321
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111220: LD_VAR 0 14
111224: PPUSH
111225: LD_EXP 115
111229: PUSH
111230: LD_VAR 0 1
111234: ARRAY
111235: PPUSH
111236: CALL_OW 308
111240: NOT
111241: PUSH
111242: LD_VAR 0 5
111246: PPUSH
111247: LD_VAR 0 14
111251: PPUSH
111252: CALL_OW 296
111256: PUSH
111257: LD_INT 40
111259: GREATEREQUAL
111260: AND
111261: PUSH
111262: LD_VAR 0 5
111266: PPUSH
111267: CALL_OW 256
111271: PUSH
111272: LD_INT 650
111274: LESSEQUAL
111275: OR
111276: PUSH
111277: LD_VAR 0 5
111281: PPUSH
111282: LD_EXP 114
111286: PUSH
111287: LD_VAR 0 1
111291: ARRAY
111292: PPUSH
111293: CALL_OW 308
111297: NOT
111298: AND
111299: IFFALSE 111321
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111301: LD_VAR 0 5
111305: PPUSH
111306: LD_EXP 114
111310: PUSH
111311: LD_VAR 0 1
111315: ARRAY
111316: PPUSH
111317: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111321: LD_VAR 0 5
111325: PPUSH
111326: CALL_OW 256
111330: PUSH
111331: LD_INT 998
111333: LESS
111334: PUSH
111335: LD_VAR 0 5
111339: PPUSH
111340: CALL_OW 263
111344: PUSH
111345: LD_INT 1
111347: EQUAL
111348: AND
111349: PUSH
111350: LD_VAR 0 5
111354: PPUSH
111355: CALL_OW 311
111359: AND
111360: PUSH
111361: LD_VAR 0 5
111365: PPUSH
111366: LD_EXP 114
111370: PUSH
111371: LD_VAR 0 1
111375: ARRAY
111376: PPUSH
111377: CALL_OW 308
111381: AND
111382: IFFALSE 111436
// begin mech := IsDrivenBy ( i ) ;
111384: LD_ADDR_VAR 0 10
111388: PUSH
111389: LD_VAR 0 5
111393: PPUSH
111394: CALL_OW 311
111398: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111399: LD_VAR 0 10
111403: PPUSH
111404: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111408: LD_VAR 0 10
111412: PPUSH
111413: LD_VAR 0 5
111417: PPUSH
111418: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111422: LD_VAR 0 10
111426: PPUSH
111427: LD_VAR 0 5
111431: PPUSH
111432: CALL_OW 180
// end ; end ; unit_human :
111436: GO 111703
111438: LD_INT 1
111440: DOUBLE
111441: EQUAL
111442: IFTRUE 111446
111444: GO 111702
111446: POP
// begin b := IsInUnit ( i ) ;
111447: LD_ADDR_VAR 0 19
111451: PUSH
111452: LD_VAR 0 5
111456: PPUSH
111457: CALL_OW 310
111461: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111462: LD_ADDR_VAR 0 20
111466: PUSH
111467: LD_VAR 0 19
111471: NOT
111472: PUSH
111473: LD_VAR 0 19
111477: PPUSH
111478: CALL_OW 266
111482: PUSH
111483: LD_INT 32
111485: PUSH
111486: LD_INT 31
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: IN
111493: OR
111494: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111495: LD_VAR 0 17
111499: PUSH
111500: LD_VAR 0 2
111504: PPUSH
111505: LD_INT 21
111507: PUSH
111508: LD_INT 2
111510: PUSH
111511: EMPTY
111512: LIST
111513: LIST
111514: PPUSH
111515: CALL_OW 72
111519: PUSH
111520: LD_INT 1
111522: LESSEQUAL
111523: OR
111524: PUSH
111525: LD_VAR 0 20
111529: AND
111530: PUSH
111531: LD_VAR 0 5
111535: PUSH
111536: LD_VAR 0 18
111540: IN
111541: NOT
111542: AND
111543: IFFALSE 111636
// begin if b then
111545: LD_VAR 0 19
111549: IFFALSE 111598
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111551: LD_VAR 0 19
111555: PPUSH
111556: LD_VAR 0 3
111560: PPUSH
111561: LD_VAR 0 19
111565: PPUSH
111566: CALL_OW 74
111570: PPUSH
111571: CALL_OW 296
111575: PUSH
111576: LD_INT 10
111578: LESS
111579: PUSH
111580: LD_VAR 0 19
111584: PPUSH
111585: CALL_OW 461
111589: PUSH
111590: LD_INT 7
111592: NONEQUAL
111593: AND
111594: IFFALSE 111598
// continue ;
111596: GO 110913
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111598: LD_ADDR_VAR 0 18
111602: PUSH
111603: LD_VAR 0 18
111607: PPUSH
111608: LD_VAR 0 18
111612: PUSH
111613: LD_INT 1
111615: PLUS
111616: PPUSH
111617: LD_VAR 0 5
111621: PPUSH
111622: CALL_OW 1
111626: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111627: LD_VAR 0 5
111631: PPUSH
111632: CALL_OW 122
// end ; if sold_defenders then
111636: LD_VAR 0 18
111640: IFFALSE 111700
// if i in sold_defenders then
111642: LD_VAR 0 5
111646: PUSH
111647: LD_VAR 0 18
111651: IN
111652: IFFALSE 111700
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111654: LD_VAR 0 5
111658: PPUSH
111659: CALL_OW 314
111663: NOT
111664: PUSH
111665: LD_VAR 0 5
111669: PPUSH
111670: LD_VAR 0 14
111674: PPUSH
111675: CALL_OW 296
111679: PUSH
111680: LD_INT 30
111682: LESS
111683: AND
111684: IFFALSE 111700
// ComAttackUnit ( i , e ) ;
111686: LD_VAR 0 5
111690: PPUSH
111691: LD_VAR 0 14
111695: PPUSH
111696: CALL_OW 115
// end ; end ; end ;
111700: GO 111703
111702: POP
// if IsDead ( i ) then
111703: LD_VAR 0 5
111707: PPUSH
111708: CALL_OW 301
111712: IFFALSE 111730
// defenders := defenders diff i ;
111714: LD_ADDR_VAR 0 2
111718: PUSH
111719: LD_VAR 0 2
111723: PUSH
111724: LD_VAR 0 5
111728: DIFF
111729: ST_TO_ADDR
// end ;
111730: GO 110913
111732: POP
111733: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111734: LD_VAR 0 3
111738: NOT
111739: PUSH
111740: LD_VAR 0 2
111744: NOT
111745: OR
111746: PUSH
111747: LD_EXP 90
111751: PUSH
111752: LD_VAR 0 1
111756: ARRAY
111757: NOT
111758: OR
111759: IFFALSE 110817
// MC_Reset ( base , 18 ) ;
111761: LD_VAR 0 1
111765: PPUSH
111766: LD_INT 18
111768: PPUSH
111769: CALL 24856 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111773: LD_ADDR_VAR 0 2
111777: PUSH
111778: LD_VAR 0 2
111782: PUSH
111783: LD_VAR 0 2
111787: PPUSH
111788: LD_INT 2
111790: PUSH
111791: LD_INT 25
111793: PUSH
111794: LD_INT 1
111796: PUSH
111797: EMPTY
111798: LIST
111799: LIST
111800: PUSH
111801: LD_INT 25
111803: PUSH
111804: LD_INT 5
111806: PUSH
111807: EMPTY
111808: LIST
111809: LIST
111810: PUSH
111811: LD_INT 25
111813: PUSH
111814: LD_INT 8
111816: PUSH
111817: EMPTY
111818: LIST
111819: LIST
111820: PUSH
111821: LD_INT 25
111823: PUSH
111824: LD_INT 9
111826: PUSH
111827: EMPTY
111828: LIST
111829: LIST
111830: PUSH
111831: EMPTY
111832: LIST
111833: LIST
111834: LIST
111835: LIST
111836: LIST
111837: PPUSH
111838: CALL_OW 72
111842: DIFF
111843: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111844: LD_VAR 0 3
111848: NOT
111849: PUSH
111850: LD_VAR 0 2
111854: PPUSH
111855: LD_INT 21
111857: PUSH
111858: LD_INT 2
111860: PUSH
111861: EMPTY
111862: LIST
111863: LIST
111864: PPUSH
111865: CALL_OW 72
111869: AND
111870: IFFALSE 112208
// begin tmp := FilterByTag ( defenders , 19 ) ;
111872: LD_ADDR_VAR 0 12
111876: PUSH
111877: LD_VAR 0 2
111881: PPUSH
111882: LD_INT 19
111884: PPUSH
111885: CALL 84375 0 2
111889: ST_TO_ADDR
// if tmp then
111890: LD_VAR 0 12
111894: IFFALSE 111964
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111896: LD_ADDR_VAR 0 12
111900: PUSH
111901: LD_VAR 0 12
111905: PPUSH
111906: LD_INT 25
111908: PUSH
111909: LD_INT 3
111911: PUSH
111912: EMPTY
111913: LIST
111914: LIST
111915: PPUSH
111916: CALL_OW 72
111920: ST_TO_ADDR
// if tmp then
111921: LD_VAR 0 12
111925: IFFALSE 111964
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111927: LD_ADDR_EXP 102
111931: PUSH
111932: LD_EXP 102
111936: PPUSH
111937: LD_VAR 0 1
111941: PPUSH
111942: LD_EXP 102
111946: PUSH
111947: LD_VAR 0 1
111951: ARRAY
111952: PUSH
111953: LD_VAR 0 12
111957: UNION
111958: PPUSH
111959: CALL_OW 1
111963: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111964: LD_VAR 0 1
111968: PPUSH
111969: LD_INT 19
111971: PPUSH
111972: CALL 24856 0 2
// repeat wait ( 0 0$1 ) ;
111976: LD_INT 35
111978: PPUSH
111979: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111983: LD_EXP 90
111987: PUSH
111988: LD_VAR 0 1
111992: ARRAY
111993: NOT
111994: PUSH
111995: LD_EXP 90
111999: PUSH
112000: LD_VAR 0 1
112004: ARRAY
112005: PUSH
112006: EMPTY
112007: EQUAL
112008: OR
112009: IFFALSE 112046
// begin for i in defenders do
112011: LD_ADDR_VAR 0 5
112015: PUSH
112016: LD_VAR 0 2
112020: PUSH
112021: FOR_IN
112022: IFFALSE 112035
// ComStop ( i ) ;
112024: LD_VAR 0 5
112028: PPUSH
112029: CALL_OW 141
112033: GO 112021
112035: POP
112036: POP
// defenders := [ ] ;
112037: LD_ADDR_VAR 0 2
112041: PUSH
112042: EMPTY
112043: ST_TO_ADDR
// exit ;
112044: GO 112272
// end ; for i in defenders do
112046: LD_ADDR_VAR 0 5
112050: PUSH
112051: LD_VAR 0 2
112055: PUSH
112056: FOR_IN
112057: IFFALSE 112146
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112059: LD_VAR 0 5
112063: PPUSH
112064: LD_EXP 114
112068: PUSH
112069: LD_VAR 0 1
112073: ARRAY
112074: PPUSH
112075: CALL_OW 308
112079: NOT
112080: IFFALSE 112104
// ComMoveToArea ( i , mc_parking [ base ] ) else
112082: LD_VAR 0 5
112086: PPUSH
112087: LD_EXP 114
112091: PUSH
112092: LD_VAR 0 1
112096: ARRAY
112097: PPUSH
112098: CALL_OW 113
112102: GO 112144
// if GetControl ( i ) = control_manual then
112104: LD_VAR 0 5
112108: PPUSH
112109: CALL_OW 263
112113: PUSH
112114: LD_INT 1
112116: EQUAL
112117: IFFALSE 112144
// if IsDrivenBy ( i ) then
112119: LD_VAR 0 5
112123: PPUSH
112124: CALL_OW 311
112128: IFFALSE 112144
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112130: LD_VAR 0 5
112134: PPUSH
112135: CALL_OW 311
112139: PPUSH
112140: CALL_OW 121
// end ;
112144: GO 112056
112146: POP
112147: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112148: LD_VAR 0 2
112152: PPUSH
112153: LD_INT 95
112155: PUSH
112156: LD_EXP 114
112160: PUSH
112161: LD_VAR 0 1
112165: ARRAY
112166: PUSH
112167: EMPTY
112168: LIST
112169: LIST
112170: PPUSH
112171: CALL_OW 72
112175: PUSH
112176: LD_VAR 0 2
112180: EQUAL
112181: PUSH
112182: LD_EXP 113
112186: PUSH
112187: LD_VAR 0 1
112191: ARRAY
112192: OR
112193: PUSH
112194: LD_EXP 90
112198: PUSH
112199: LD_VAR 0 1
112203: ARRAY
112204: NOT
112205: OR
112206: IFFALSE 111976
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112208: LD_ADDR_EXP 112
112212: PUSH
112213: LD_EXP 112
112217: PPUSH
112218: LD_VAR 0 1
112222: PPUSH
112223: LD_VAR 0 2
112227: PPUSH
112228: LD_INT 21
112230: PUSH
112231: LD_INT 2
112233: PUSH
112234: EMPTY
112235: LIST
112236: LIST
112237: PPUSH
112238: CALL_OW 72
112242: PPUSH
112243: CALL_OW 1
112247: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112248: LD_VAR 0 1
112252: PPUSH
112253: LD_INT 19
112255: PPUSH
112256: CALL 24856 0 2
// MC_Reset ( base , 20 ) ;
112260: LD_VAR 0 1
112264: PPUSH
112265: LD_INT 20
112267: PPUSH
112268: CALL 24856 0 2
// end ; end_of_file
112272: LD_VAR 0 4
112276: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112277: LD_VAR 0 1
112281: PUSH
112282: LD_INT 200
112284: DOUBLE
112285: GREATEREQUAL
112286: IFFALSE 112294
112288: LD_INT 299
112290: DOUBLE
112291: LESSEQUAL
112292: IFTRUE 112296
112294: GO 112328
112296: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112297: LD_VAR 0 1
112301: PPUSH
112302: LD_VAR 0 2
112306: PPUSH
112307: LD_VAR 0 3
112311: PPUSH
112312: LD_VAR 0 4
112316: PPUSH
112317: LD_VAR 0 5
112321: PPUSH
112322: CALL 101218 0 5
112326: GO 112405
112328: LD_INT 300
112330: DOUBLE
112331: GREATEREQUAL
112332: IFFALSE 112340
112334: LD_INT 399
112336: DOUBLE
112337: LESSEQUAL
112338: IFTRUE 112342
112340: GO 112404
112342: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112343: LD_VAR 0 1
112347: PPUSH
112348: LD_VAR 0 2
112352: PPUSH
112353: LD_VAR 0 3
112357: PPUSH
112358: LD_VAR 0 4
112362: PPUSH
112363: LD_VAR 0 5
112367: PPUSH
112368: LD_VAR 0 6
112372: PPUSH
112373: LD_VAR 0 7
112377: PPUSH
112378: LD_VAR 0 8
112382: PPUSH
112383: LD_VAR 0 9
112387: PPUSH
112388: LD_VAR 0 10
112392: PPUSH
112393: LD_VAR 0 11
112397: PPUSH
112398: CALL 99124 0 11
112402: GO 112405
112404: POP
// end ;
112405: PPOPN 11
112407: END
