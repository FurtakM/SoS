// export JMM , Bobby , Cyrus ; export Lisa , Khatam , Brian , Jerry , Mikhail ; export Powell ; export hpJMM , hpBobby , hpCyrus ; export RuSoldMinLevel , RuSoldMaxLevel ; export cargo1 , cargo2 ; export driver1 , driver2 ; export Natasza ; export cargoEscape ; export mikhailStatus , mikhailInBase , mikhailDepot ; export northBaseDefenders , southBaseDefenders , attackGroup ; export lastBattle ; export cargoRespawn , cargoSee ; export tigersRespawn ; export deadsCounter ; export spotCorpses ; export mission_prefix ; starting begin mission_prefix := 02_ ;
   0: LD_ADDR_EXP 33
   4: PUSH
   5: LD_STRING 02_
   7: ST_TO_ADDR
// RuSoldMinLevel = 0 ;
   8: LD_ADDR_EXP 13
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// RuSoldMaxLevel = 0 ;
  16: LD_ADDR_EXP 14
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// hpJMM = 0 ;
  24: LD_ADDR_EXP 10
  28: PUSH
  29: LD_INT 0
  31: ST_TO_ADDR
// hpBobby = 0 ;
  32: LD_ADDR_EXP 11
  36: PUSH
  37: LD_INT 0
  39: ST_TO_ADDR
// hpCyrus = 0 ;
  40: LD_ADDR_EXP 12
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// cargoEscape = 0 ;
  48: LD_ADDR_EXP 20
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mikhailStatus = 0 ;
  56: LD_ADDR_EXP 21
  60: PUSH
  61: LD_INT 0
  63: ST_TO_ADDR
// mikhailInBase = 0 ;
  64: LD_ADDR_EXP 22
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// mikhailDepot = 0 ;
  72: LD_ADDR_EXP 23
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// tigersRespawn = 0 ;
  80: LD_ADDR_EXP 30
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// cargoRespawn = 0 ;
  88: LD_ADDR_EXP 28
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// cargoSee = 0 ;
  96: LD_ADDR_EXP 29
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// lastBattle = 0 ;
 104: LD_ADDR_EXP 27
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// deadsCounter = 0 ;
 112: LD_ADDR_EXP 31
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// spotCorpses = 0 ;
 120: LD_ADDR_EXP 32
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// southBaseDefenders = [ ] ;
 128: LD_ADDR_EXP 25
 132: PUSH
 133: EMPTY
 134: ST_TO_ADDR
// northBaseDefenders = [ ] ;
 135: LD_ADDR_EXP 24
 139: PUSH
 140: EMPTY
 141: ST_TO_ADDR
// attackGroup = [ ] ;
 142: LD_ADDR_EXP 26
 146: PUSH
 147: EMPTY
 148: ST_TO_ADDR
// RandomizeAll ;
 149: CALL_OW 11
// InGameOn ;
 153: CALL_OW 8
// Resetfog ;
 157: CALL_OW 335
// AnimateTrees ( true ) ;
 161: LD_INT 1
 163: PPUSH
 164: CALL_OW 573
// PrepareDifficulty ;
 168: CALL 10287 0 0
// PrepareRussianCommander ;
 172: CALL 11743 0 0
// PrepareSouthBase ;
 176: CALL 11826 0 0
// PrepareNorthBase ;
 180: CALL 12165 0 0
// PrepareOtherRussians ;
 184: CALL 12531 0 0
// PrepareHeroes ;
 188: CALL 10602 0 0
// PrepareLisSquad ;
 192: CALL 10930 0 0
// PrepareOtherAmericans ;
 196: CALL 11275 0 0
// end ; end_of_file
 200: END
// every 1 do var tmp ;
 201: GO 203
 203: DISABLE
 204: LD_INT 0
 206: PPUSH
// begin CenterNowOnUnits ( JMM ) ;
 207: LD_EXP 1
 211: PPUSH
 212: CALL_OW 87
// tmp = FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff [ Lisa ] ;
 216: LD_ADDR_VAR 0 1
 220: PUSH
 221: LD_INT 22
 223: PUSH
 224: LD_INT 4
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: PUSH
 231: LD_INT 21
 233: PUSH
 234: LD_INT 1
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PPUSH
 245: CALL_OW 69
 249: PUSH
 250: LD_EXP 4
 254: PUSH
 255: EMPTY
 256: LIST
 257: DIFF
 258: ST_TO_ADDR
// if Cyrus and Bobby then
 259: LD_EXP 3
 263: PUSH
 264: LD_EXP 2
 268: AND
 269: IFFALSE 599
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 271: LD_EXP 3
 275: PPUSH
 276: LD_INT 43
 278: PPUSH
 279: LD_INT 72
 281: PPUSH
 282: CALL_OW 111
// ComMoveXY ( Bobby , 44 , 70 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_INT 44
 293: PPUSH
 294: LD_INT 70
 296: PPUSH
 297: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 301: LD_EXP 1
 305: PPUSH
 306: LD_INT 46
 308: PPUSH
 309: LD_INT 73
 311: PPUSH
 312: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 316: LD_EXP 3
 320: PPUSH
 321: LD_STRING D1a-Cyrus-1
 323: PPUSH
 324: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 328: LD_EXP 1
 332: PPUSH
 333: LD_STRING D1a-JMM-1
 335: PPUSH
 336: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 340: LD_EXP 3
 344: PPUSH
 345: LD_INT 37
 347: PPUSH
 348: LD_INT 66
 350: PPUSH
 351: CALL_OW 171
// AddComMoveXY ( Bobby , 41 , 67 ) ;
 355: LD_EXP 2
 359: PPUSH
 360: LD_INT 41
 362: PPUSH
 363: LD_INT 67
 365: PPUSH
 366: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 370: LD_EXP 1
 374: PPUSH
 375: LD_INT 38
 377: PPUSH
 378: LD_INT 64
 380: PPUSH
 381: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 385: LD_EXP 2
 389: PPUSH
 390: LD_STRING D1a-Bobby-2
 392: PPUSH
 393: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 397: LD_EXP 3
 401: PPUSH
 402: LD_INT 35
 404: PPUSH
 405: LD_INT 62
 407: PPUSH
 408: CALL_OW 171
// AddComMoveXY ( Bobby , 32 , 60 ) ;
 412: LD_EXP 2
 416: PPUSH
 417: LD_INT 32
 419: PPUSH
 420: LD_INT 60
 422: PPUSH
 423: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 427: LD_EXP 1
 431: PPUSH
 432: LD_INT 35
 434: PPUSH
 435: LD_INT 60
 437: PPUSH
 438: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 442: LD_EXP 1
 446: PPUSH
 447: LD_STRING D1a-JMM-2
 449: PPUSH
 450: CALL_OW 88
// ComWalk ( Lisa ) ;
 454: LD_EXP 4
 458: PPUSH
 459: CALL_OW 138
// wait ( 0 0$1 ) ;
 463: LD_INT 35
 465: PPUSH
 466: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 470: LD_EXP 4
 474: PPUSH
 475: LD_EXP 1
 479: PPUSH
 480: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus , Bobby ] , Lisa ) ;
 484: LD_EXP 1
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_EXP 2
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PPUSH
 504: LD_EXP 4
 508: PPUSH
 509: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
 513: LD_VAR 0 1
 517: PUSH
 518: LD_INT 1
 520: ARRAY
 521: PPUSH
 522: LD_INT 33
 524: PPUSH
 525: LD_INT 55
 527: PPUSH
 528: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
 532: LD_VAR 0 1
 536: PUSH
 537: LD_INT 2
 539: ARRAY
 540: PPUSH
 541: LD_INT 30
 543: PPUSH
 544: LD_INT 54
 546: PPUSH
 547: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
 551: LD_VAR 0 1
 555: PUSH
 556: LD_INT 1
 558: ARRAY
 559: PPUSH
 560: LD_EXP 1
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
 569: LD_VAR 0 1
 573: PUSH
 574: LD_INT 2
 576: ARRAY
 577: PPUSH
 578: LD_EXP 1
 582: PPUSH
 583: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 587: LD_EXP 4
 591: PPUSH
 592: LD_STRING D1a-Lisa-2
 594: PPUSH
 595: CALL_OW 88
// end ; if Cyrus and not Bobby then
 599: LD_EXP 3
 603: PUSH
 604: LD_EXP 2
 608: NOT
 609: AND
 610: IFFALSE 815
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 612: LD_EXP 3
 616: PPUSH
 617: LD_INT 43
 619: PPUSH
 620: LD_INT 72
 622: PPUSH
 623: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 627: LD_EXP 1
 631: PPUSH
 632: LD_INT 46
 634: PPUSH
 635: LD_INT 73
 637: PPUSH
 638: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 642: LD_EXP 3
 646: PPUSH
 647: LD_STRING D1a-Cyrus-1
 649: PPUSH
 650: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 654: LD_EXP 1
 658: PPUSH
 659: LD_STRING D1a-JMM-1
 661: PPUSH
 662: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 666: LD_EXP 3
 670: PPUSH
 671: LD_INT 37
 673: PPUSH
 674: LD_INT 66
 676: PPUSH
 677: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 681: LD_EXP 1
 685: PPUSH
 686: LD_INT 38
 688: PPUSH
 689: LD_INT 64
 691: PPUSH
 692: CALL_OW 171
// Say ( Cyrus , D1a-Cyrus-2 ) ;
 696: LD_EXP 3
 700: PPUSH
 701: LD_STRING D1a-Cyrus-2
 703: PPUSH
 704: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 708: LD_EXP 3
 712: PPUSH
 713: LD_INT 35
 715: PPUSH
 716: LD_INT 62
 718: PPUSH
 719: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 723: LD_EXP 1
 727: PPUSH
 728: LD_INT 35
 730: PPUSH
 731: LD_INT 60
 733: PPUSH
 734: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 738: LD_EXP 1
 742: PPUSH
 743: LD_STRING D1a-JMM-2
 745: PPUSH
 746: CALL_OW 88
// ComWalk ( Lisa ) ;
 750: LD_EXP 4
 754: PPUSH
 755: CALL_OW 138
// wait ( 0 0$1 ) ;
 759: LD_INT 35
 761: PPUSH
 762: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 766: LD_EXP 4
 770: PPUSH
 771: LD_EXP 1
 775: PPUSH
 776: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 780: LD_EXP 4
 784: PPUSH
 785: LD_STRING D1a-Lisa-2
 787: PPUSH
 788: CALL_OW 88
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 792: LD_EXP 1
 796: PUSH
 797: LD_EXP 3
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: LD_EXP 4
 810: PPUSH
 811: CALL_OW 119
// end ; if not Cyrus and Bobby then
 815: LD_EXP 3
 819: NOT
 820: PUSH
 821: LD_EXP 2
 825: AND
 826: IFFALSE 1105
// begin ComMoveXY ( Bobby , 44 , 70 ) ;
 828: LD_EXP 2
 832: PPUSH
 833: LD_INT 44
 835: PPUSH
 836: LD_INT 70
 838: PPUSH
 839: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 843: LD_EXP 1
 847: PPUSH
 848: LD_INT 46
 850: PPUSH
 851: LD_INT 73
 853: PPUSH
 854: CALL_OW 111
// Say ( Bobby , D1a-Bobby-1 ) ;
 858: LD_EXP 2
 862: PPUSH
 863: LD_STRING D1a-Bobby-1
 865: PPUSH
 866: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 870: LD_EXP 1
 874: PPUSH
 875: LD_STRING D1a-JMM-1
 877: PPUSH
 878: CALL_OW 88
// AddComMoveXY ( Bobby , 37 , 66 ) ;
 882: LD_EXP 2
 886: PPUSH
 887: LD_INT 37
 889: PPUSH
 890: LD_INT 66
 892: PPUSH
 893: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 897: LD_EXP 1
 901: PPUSH
 902: LD_INT 38
 904: PPUSH
 905: LD_INT 64
 907: PPUSH
 908: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 912: LD_EXP 2
 916: PPUSH
 917: LD_STRING D1a-Bobby-2
 919: PPUSH
 920: CALL_OW 88
// AddComMoveXY ( Bobby , 35 , 62 ) ;
 924: LD_EXP 2
 928: PPUSH
 929: LD_INT 35
 931: PPUSH
 932: LD_INT 62
 934: PPUSH
 935: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 939: LD_EXP 1
 943: PPUSH
 944: LD_INT 35
 946: PPUSH
 947: LD_INT 60
 949: PPUSH
 950: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 954: LD_EXP 1
 958: PPUSH
 959: LD_STRING D1a-JMM-2
 961: PPUSH
 962: CALL_OW 88
// ComWalk ( Lisa ) ;
 966: LD_EXP 4
 970: PPUSH
 971: CALL_OW 138
// wait ( 0 0$1 ) ;
 975: LD_INT 35
 977: PPUSH
 978: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 982: LD_EXP 4
 986: PPUSH
 987: LD_EXP 1
 991: PPUSH
 992: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 996: LD_EXP 1
1000: PUSH
1001: LD_EXP 3
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: LD_EXP 4
1014: PPUSH
1015: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 1
1026: ARRAY
1027: PPUSH
1028: LD_INT 33
1030: PPUSH
1031: LD_INT 55
1033: PPUSH
1034: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1038: LD_VAR 0 1
1042: PUSH
1043: LD_INT 2
1045: ARRAY
1046: PPUSH
1047: LD_INT 30
1049: PPUSH
1050: LD_INT 54
1052: PPUSH
1053: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1057: LD_VAR 0 1
1061: PUSH
1062: LD_INT 1
1064: ARRAY
1065: PPUSH
1066: LD_EXP 1
1070: PPUSH
1071: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1075: LD_VAR 0 1
1079: PUSH
1080: LD_INT 2
1082: ARRAY
1083: PPUSH
1084: LD_EXP 1
1088: PPUSH
1089: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
1093: LD_EXP 4
1097: PPUSH
1098: LD_STRING D1a-Lisa-2
1100: PPUSH
1101: CALL_OW 88
// end ; if not Cyrus and not Bobby then
1105: LD_EXP 3
1109: NOT
1110: PUSH
1111: LD_EXP 2
1115: NOT
1116: AND
1117: IFFALSE 1331
// begin ComMoveXY ( JMM , 37 , 66 ) ;
1119: LD_EXP 1
1123: PPUSH
1124: LD_INT 37
1126: PPUSH
1127: LD_INT 66
1129: PPUSH
1130: CALL_OW 111
// Say ( JMM , D1b-JMM-1 ) ;
1134: LD_EXP 1
1138: PPUSH
1139: LD_STRING D1b-JMM-1
1141: PPUSH
1142: CALL_OW 88
// ComCrawl ( JMM ) ;
1146: LD_EXP 1
1150: PPUSH
1151: CALL_OW 137
// AddComMoveXY ( JMM , 35 , 60 ) ;
1155: LD_EXP 1
1159: PPUSH
1160: LD_INT 35
1162: PPUSH
1163: LD_INT 60
1165: PPUSH
1166: CALL_OW 171
// wait ( 0 0$8 ) ;
1170: LD_INT 280
1172: PPUSH
1173: CALL_OW 67
// Say ( JMM , D1b-JMM-1a ) ;
1177: LD_EXP 1
1181: PPUSH
1182: LD_STRING D1b-JMM-1a
1184: PPUSH
1185: CALL_OW 88
// ComWalk ( [ JMM , Lisa ] ) ;
1189: LD_EXP 1
1193: PUSH
1194: LD_EXP 4
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 138
// wait ( 0 0$1 ) ;
1207: LD_INT 35
1209: PPUSH
1210: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
1214: LD_EXP 4
1218: PPUSH
1219: LD_EXP 1
1223: PPUSH
1224: CALL_OW 179
// AddComTurnUnit ( [ JMM ] , Lisa ) ;
1228: LD_EXP 1
1232: PUSH
1233: EMPTY
1234: LIST
1235: PPUSH
1236: LD_EXP 4
1240: PPUSH
1241: CALL_OW 179
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1245: LD_VAR 0 1
1249: PUSH
1250: LD_INT 1
1252: ARRAY
1253: PPUSH
1254: LD_INT 33
1256: PPUSH
1257: LD_INT 55
1259: PPUSH
1260: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1264: LD_VAR 0 1
1268: PUSH
1269: LD_INT 2
1271: ARRAY
1272: PPUSH
1273: LD_INT 30
1275: PPUSH
1276: LD_INT 54
1278: PPUSH
1279: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1283: LD_VAR 0 1
1287: PUSH
1288: LD_INT 1
1290: ARRAY
1291: PPUSH
1292: LD_EXP 1
1296: PPUSH
1297: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1301: LD_VAR 0 1
1305: PUSH
1306: LD_INT 2
1308: ARRAY
1309: PPUSH
1310: LD_EXP 1
1314: PPUSH
1315: CALL_OW 179
// Say ( Lisa , D1b-Lisa-1 ) ;
1319: LD_EXP 4
1323: PPUSH
1324: LD_STRING D1b-Lisa-1
1326: PPUSH
1327: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
1331: LD_EXP 1
1335: PPUSH
1336: LD_STRING D1-JMM-1
1338: PPUSH
1339: CALL_OW 88
// Say ( Lisa , D1-Lisa-1 ) ;
1343: LD_EXP 4
1347: PPUSH
1348: LD_STRING D1-Lisa-1
1350: PPUSH
1351: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
1355: LD_EXP 1
1359: PPUSH
1360: LD_STRING D1-JMM-2
1362: PPUSH
1363: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
1367: LD_EXP 9
1371: PPUSH
1372: LD_STRING D1-Pow-2
1374: PPUSH
1375: CALL_OW 94
// if Cyrus then
1379: LD_EXP 3
1383: IFFALSE 1409
// begin Say ( Cyrus , D1-Cyrus-2 ) ;
1385: LD_EXP 3
1389: PPUSH
1390: LD_STRING D1-Cyrus-2
1392: PPUSH
1393: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
1397: LD_EXP 1
1401: PPUSH
1402: LD_STRING D1-JMM-3
1404: PPUSH
1405: CALL_OW 88
// end ; SayRadio ( Powell , D1-Pow-3 ) ;
1409: LD_EXP 9
1413: PPUSH
1414: LD_STRING D1-Pow-3
1416: PPUSH
1417: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
1421: LD_EXP 1
1425: PPUSH
1426: LD_STRING D1-JMM-4
1428: PPUSH
1429: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
1433: LD_EXP 9
1437: PPUSH
1438: LD_STRING D1-Pow-4
1440: PPUSH
1441: CALL_OW 94
// SayRadio ( Powell , D1-Pow-4a ) ;
1445: LD_EXP 9
1449: PPUSH
1450: LD_STRING D1-Pow-4a
1452: PPUSH
1453: CALL_OW 94
// if Cyrus then
1457: LD_EXP 3
1461: IFFALSE 1475
// Say ( Cyrus , D1-Cyrus-4 ) ;
1463: LD_EXP 3
1467: PPUSH
1468: LD_STRING D1-Cyrus-4
1470: PPUSH
1471: CALL_OW 88
// if Bobby then
1475: LD_EXP 2
1479: IFFALSE 1517
// begin Say ( Bobby , D1-Bobby-4 ) ;
1481: LD_EXP 2
1485: PPUSH
1486: LD_STRING D1-Bobby-4
1488: PPUSH
1489: CALL_OW 88
// Say ( Lisa , D1-Lisa-4 ) ;
1493: LD_EXP 4
1497: PPUSH
1498: LD_STRING D1-Lisa-4
1500: PPUSH
1501: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
1505: LD_EXP 1
1509: PPUSH
1510: LD_STRING D1-JMM-5
1512: PPUSH
1513: CALL_OW 88
// end ; InGameOff ;
1517: CALL_OW 9
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) diff [ Brian , Jerry ] , 1 ) ;
1521: LD_INT 22
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: PPUSH
1531: CALL_OW 69
1535: PUSH
1536: LD_EXP 6
1540: PUSH
1541: LD_EXP 7
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: DIFF
1550: PPUSH
1551: LD_INT 1
1553: PPUSH
1554: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
1558: LD_STRING M1
1560: PPUSH
1561: CALL_OW 337
// SaveForQuickRestart ;
1565: CALL_OW 22
// end ;
1569: PPOPN 1
1571: END
// every 0 0$1 trigger FilterUnitsInArea ( PaulTriggerArea , [ f_side , 1 ] ) > 0 do
1572: LD_INT 7
1574: PPUSH
1575: LD_INT 22
1577: PUSH
1578: LD_INT 1
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PPUSH
1585: CALL_OW 70
1589: PUSH
1590: LD_INT 0
1592: GREATER
1593: IFFALSE 2010
1595: GO 1597
1597: DISABLE
// begin InGameOn ;
1598: CALL_OW 8
// ComHold ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
1602: LD_INT 22
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 21
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PPUSH
1626: CALL_OW 69
1630: PPUSH
1631: CALL_OW 140
// CenterOnXY ( 24 , 32 ) ;
1635: LD_INT 24
1637: PPUSH
1638: LD_INT 32
1640: PPUSH
1641: CALL_OW 84
// PlaceUnitArea ( Khatam , PaulSpawn , true ) ;
1645: LD_EXP 5
1649: PPUSH
1650: LD_INT 4
1652: PPUSH
1653: LD_INT 1
1655: PPUSH
1656: CALL_OW 49
// SetClass ( Khatam , 4 ) ;
1660: LD_EXP 5
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 336
// wait ( 0 0$1 ) ;
1672: LD_INT 35
1674: PPUSH
1675: CALL_OW 67
// ComMoveXY ( Khatam , 27 , 38 ) ;
1679: LD_EXP 5
1683: PPUSH
1684: LD_INT 27
1686: PPUSH
1687: LD_INT 38
1689: PPUSH
1690: CALL_OW 111
// AddComTurnUnit ( Khatam , JMM ) ;
1694: LD_EXP 5
1698: PPUSH
1699: LD_EXP 1
1703: PPUSH
1704: CALL_OW 179
// ComTurnUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ Khatam ] , Khatam ) ;
1708: LD_INT 22
1710: PUSH
1711: LD_INT 1
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: PUSH
1718: LD_INT 21
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PPUSH
1732: CALL_OW 69
1736: PUSH
1737: LD_EXP 5
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: PPUSH
1746: LD_EXP 5
1750: PPUSH
1751: CALL_OW 119
// wait ( 0 0$1 ) ;
1755: LD_INT 35
1757: PPUSH
1758: CALL_OW 67
// Say ( Khatam , D2a-Khat-1 ) ;
1762: LD_EXP 5
1766: PPUSH
1767: LD_STRING D2a-Khat-1
1769: PPUSH
1770: CALL_OW 88
// Say ( JMM , D2a-JMM-1 ) ;
1774: LD_EXP 1
1778: PPUSH
1779: LD_STRING D2a-JMM-1
1781: PPUSH
1782: CALL_OW 88
// Say ( Khatam , D2a-Khat-2 ) ;
1786: LD_EXP 5
1790: PPUSH
1791: LD_STRING D2a-Khat-2
1793: PPUSH
1794: CALL_OW 88
// Say ( JMM , D2a-JMM-2 ) ;
1798: LD_EXP 1
1802: PPUSH
1803: LD_STRING D2a-JMM-2
1805: PPUSH
1806: CALL_OW 88
// Say ( Khatam , D2a-Khat-3 ) ;
1810: LD_EXP 5
1814: PPUSH
1815: LD_STRING D2a-Khat-3
1817: PPUSH
1818: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
1822: LD_EXP 1
1826: PPUSH
1827: LD_STRING D2a-JMM-3
1829: PPUSH
1830: CALL_OW 88
// Say ( Khatam , D2a-Khat-4 ) ;
1834: LD_EXP 5
1838: PPUSH
1839: LD_STRING D2a-Khat-4
1841: PPUSH
1842: CALL_OW 88
// Say ( JMM , D2a-JMM-4 ) ;
1846: LD_EXP 1
1850: PPUSH
1851: LD_STRING D2a-JMM-4
1853: PPUSH
1854: CALL_OW 88
// Say ( Khatam , D2a-Khat-5 ) ;
1858: LD_EXP 5
1862: PPUSH
1863: LD_STRING D2a-Khat-5
1865: PPUSH
1866: CALL_OW 88
// Say ( JMM , D2a-JMM-5 ) ;
1870: LD_EXP 1
1874: PPUSH
1875: LD_STRING D2a-JMM-5
1877: PPUSH
1878: CALL_OW 88
// InGameOff ;
1882: CALL_OW 9
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 800 ] ] ] ) > 0 then
1886: LD_INT 22
1888: PUSH
1889: LD_INT 1
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: LD_INT 21
1898: PUSH
1899: LD_INT 1
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 3
1908: PUSH
1909: LD_INT 24
1911: PUSH
1912: LD_INT 800
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: EMPTY
1924: LIST
1925: LIST
1926: LIST
1927: PPUSH
1928: CALL_OW 69
1932: PUSH
1933: LD_INT 0
1935: GREATER
1936: IFFALSE 2010
// begin ComHeal ( Khatam , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ) ;
1938: LD_EXP 5
1942: PPUSH
1943: LD_INT 22
1945: PUSH
1946: LD_INT 1
1948: PUSH
1949: EMPTY
1950: LIST
1951: LIST
1952: PUSH
1953: LD_INT 21
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: EMPTY
1960: LIST
1961: LIST
1962: PUSH
1963: LD_INT 3
1965: PUSH
1966: LD_INT 24
1968: PUSH
1969: LD_INT 1000
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PPUSH
1985: CALL_OW 69
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: CALL_OW 128
// Say ( Khatam , D2b-Khat-1 ) ;
1998: LD_EXP 5
2002: PPUSH
2003: LD_STRING D2b-Khat-1
2005: PPUSH
2006: CALL_OW 88
// end ; end ;
2010: END
// every 0 0$1 trigger FilterUnitsInArea ( DeadTriggerArea , [ f_side , 1 ] ) > 0 do var i , distanceTab , min , tmp , p ;
2011: LD_INT 15
2013: PPUSH
2014: LD_INT 22
2016: PUSH
2017: LD_INT 1
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: PPUSH
2024: CALL_OW 70
2028: PUSH
2029: LD_INT 0
2031: GREATER
2032: IFFALSE 3229
2034: GO 2036
2036: DISABLE
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
// begin distanceTab = [ [ 999 , 999 ] ] ;
2044: LD_ADDR_VAR 0 2
2048: PUSH
2049: LD_INT 999
2051: PUSH
2052: LD_INT 999
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: PUSH
2059: EMPTY
2060: LIST
2061: ST_TO_ADDR
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam ] ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: LD_INT 22
2069: PUSH
2070: LD_INT 1
2072: PUSH
2073: EMPTY
2074: LIST
2075: LIST
2076: PUSH
2077: LD_INT 21
2079: PUSH
2080: LD_INT 1
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: PPUSH
2091: CALL_OW 69
2095: PUSH
2096: LD_EXP 1
2100: PUSH
2101: LD_EXP 2
2105: PUSH
2106: LD_EXP 3
2110: PUSH
2111: LD_EXP 4
2115: PUSH
2116: LD_EXP 5
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: DIFF
2128: ST_TO_ADDR
// PrepareDeadSoldiers ;
2129: CALL 11433 0 0
// spotCorpses = 1 ;
2133: LD_ADDR_EXP 32
2137: PUSH
2138: LD_INT 1
2140: ST_TO_ADDR
// wait ( 0 0$2 ) ;
2141: LD_INT 70
2143: PPUSH
2144: CALL_OW 67
// InGameOn ;
2148: CALL_OW 8
// CenterOnXY ( 23 , 12 ) ;
2152: LD_INT 23
2154: PPUSH
2155: LD_INT 12
2157: PPUSH
2158: CALL_OW 84
// min = distanceTab [ 1 ] [ 2 ] ;
2162: LD_ADDR_VAR 0 3
2166: PUSH
2167: LD_VAR 0 2
2171: PUSH
2172: LD_INT 1
2174: ARRAY
2175: PUSH
2176: LD_INT 2
2178: ARRAY
2179: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Khatam ] do
2180: LD_ADDR_VAR 0 1
2184: PUSH
2185: LD_INT 22
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 21
2197: PUSH
2198: LD_INT 1
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: CALL_OW 69
2213: PUSH
2214: LD_EXP 1
2218: PUSH
2219: LD_EXP 5
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: DIFF
2228: PUSH
2229: FOR_IN
2230: IFFALSE 2281
// if IsOK ( i ) then
2232: LD_VAR 0 1
2236: PPUSH
2237: CALL_OW 302
2241: IFFALSE 2279
// distanceTab = distanceTab ^ [ [ i , GetDistUnitArea ( i , DeadsSpawn ) ] ] ;
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 2
2252: PUSH
2253: LD_VAR 0 1
2257: PUSH
2258: LD_VAR 0 1
2262: PPUSH
2263: LD_INT 16
2265: PPUSH
2266: CALL_OW 299
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: ADD
2278: ST_TO_ADDR
2279: GO 2229
2281: POP
2282: POP
// for i = 2 to distanceTab do
2283: LD_ADDR_VAR 0 1
2287: PUSH
2288: DOUBLE
2289: LD_INT 2
2291: DEC
2292: ST_TO_ADDR
2293: LD_VAR 0 2
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2345
// if distanceTab [ i ] [ 2 ] < min then
2301: LD_VAR 0 2
2305: PUSH
2306: LD_VAR 0 1
2310: ARRAY
2311: PUSH
2312: LD_INT 2
2314: ARRAY
2315: PUSH
2316: LD_VAR 0 3
2320: LESS
2321: IFFALSE 2343
// min = distanceTab [ i ] [ 2 ] ;
2323: LD_ADDR_VAR 0 3
2327: PUSH
2328: LD_VAR 0 2
2332: PUSH
2333: LD_VAR 0 1
2337: ARRAY
2338: PUSH
2339: LD_INT 2
2341: ARRAY
2342: ST_TO_ADDR
2343: GO 2298
2345: POP
2346: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2347: LD_ADDR_VAR 0 1
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: LD_INT 1
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 21
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PPUSH
2376: CALL_OW 69
2380: PUSH
2381: LD_EXP 1
2385: PUSH
2386: EMPTY
2387: LIST
2388: DIFF
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2461
// begin ComMoveToArea ( i , DeadCutscene ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 28
2400: PPUSH
2401: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2405: LD_EXP 1
2409: PPUSH
2410: LD_INT 30
2412: PPUSH
2413: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2417: LD_VAR 0 1
2421: PPUSH
2422: LD_INT 23
2424: PPUSH
2425: LD_INT 11
2427: PPUSH
2428: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2432: LD_EXP 1
2436: PPUSH
2437: LD_INT 23
2439: PPUSH
2440: LD_INT 11
2442: PPUSH
2443: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2447: LD_EXP 34
2451: PPUSH
2452: LD_INT 250
2454: PPUSH
2455: CALL_OW 234
// end ;
2459: GO 2390
2461: POP
2462: POP
// for i = 2 to distanceTab do
2463: LD_ADDR_VAR 0 1
2467: PUSH
2468: DOUBLE
2469: LD_INT 2
2471: DEC
2472: ST_TO_ADDR
2473: LD_VAR 0 2
2477: PUSH
2478: FOR_TO
2479: IFFALSE 2865
// begin if distanceTab [ i ] [ 2 ] = min then
2481: LD_VAR 0 2
2485: PUSH
2486: LD_VAR 0 1
2490: ARRAY
2491: PUSH
2492: LD_INT 2
2494: ARRAY
2495: PUSH
2496: LD_VAR 0 3
2500: EQUAL
2501: IFFALSE 2863
// begin if distanceTab [ i ] [ 1 ] = Bobby then
2503: LD_VAR 0 2
2507: PUSH
2508: LD_VAR 0 1
2512: ARRAY
2513: PUSH
2514: LD_INT 1
2516: ARRAY
2517: PUSH
2518: LD_EXP 2
2522: EQUAL
2523: IFFALSE 2537
// Say ( Bobby , DCorpses-Bobby-1 ) ;
2525: LD_EXP 2
2529: PPUSH
2530: LD_STRING DCorpses-Bobby-1
2532: PPUSH
2533: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Cyrus then
2537: LD_VAR 0 2
2541: PUSH
2542: LD_VAR 0 1
2546: ARRAY
2547: PUSH
2548: LD_INT 1
2550: ARRAY
2551: PUSH
2552: LD_EXP 3
2556: EQUAL
2557: IFFALSE 2571
// Say ( Cyrus , DCorpses-Cyrus-1 ) ;
2559: LD_EXP 3
2563: PPUSH
2564: LD_STRING DCorpses-Cyrus-1
2566: PPUSH
2567: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Lisa then
2571: LD_VAR 0 2
2575: PUSH
2576: LD_VAR 0 1
2580: ARRAY
2581: PUSH
2582: LD_INT 1
2584: ARRAY
2585: PUSH
2586: LD_EXP 4
2590: EQUAL
2591: IFFALSE 2605
// Say ( Lisa , DCorpses-Lisa-1 ) ;
2593: LD_EXP 4
2597: PPUSH
2598: LD_STRING DCorpses-Lisa-1
2600: PPUSH
2601: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 1 then
2605: LD_VAR 0 2
2609: PUSH
2610: LD_VAR 0 1
2614: ARRAY
2615: PUSH
2616: LD_INT 1
2618: ARRAY
2619: PUSH
2620: LD_VAR 0 4
2624: PUSH
2625: LD_INT 1
2627: ARRAY
2628: EQUAL
2629: PUSH
2630: LD_VAR 0 4
2634: PUSH
2635: LD_INT 1
2637: ARRAY
2638: PPUSH
2639: CALL_OW 258
2643: PUSH
2644: LD_INT 1
2646: EQUAL
2647: AND
2648: IFFALSE 2666
// Say ( tmp [ 1 ] , DCorpses-Sol1-1 ) ;
2650: LD_VAR 0 4
2654: PUSH
2655: LD_INT 1
2657: ARRAY
2658: PPUSH
2659: LD_STRING DCorpses-Sol1-1
2661: PPUSH
2662: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 2 then
2666: LD_VAR 0 2
2670: PUSH
2671: LD_VAR 0 1
2675: ARRAY
2676: PUSH
2677: LD_INT 1
2679: ARRAY
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_INT 1
2688: ARRAY
2689: EQUAL
2690: PUSH
2691: LD_VAR 0 4
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 258
2704: PUSH
2705: LD_INT 2
2707: EQUAL
2708: AND
2709: IFFALSE 2727
// Say ( tmp [ 1 ] , DCorpses-FSol1-1 ) ;
2711: LD_VAR 0 4
2715: PUSH
2716: LD_INT 1
2718: ARRAY
2719: PPUSH
2720: LD_STRING DCorpses-FSol1-1
2722: PPUSH
2723: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 1 then
2727: LD_VAR 0 2
2731: PUSH
2732: LD_VAR 0 1
2736: ARRAY
2737: PUSH
2738: LD_INT 1
2740: ARRAY
2741: PUSH
2742: LD_VAR 0 4
2746: PUSH
2747: LD_INT 2
2749: ARRAY
2750: EQUAL
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 2
2759: ARRAY
2760: PPUSH
2761: CALL_OW 258
2765: PUSH
2766: LD_INT 1
2768: EQUAL
2769: AND
2770: IFFALSE 2788
// Say ( tmp [ 2 ] , DCorpses-Sol1-1 ) ;
2772: LD_VAR 0 4
2776: PUSH
2777: LD_INT 2
2779: ARRAY
2780: PPUSH
2781: LD_STRING DCorpses-Sol1-1
2783: PPUSH
2784: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 2 then
2788: LD_VAR 0 2
2792: PUSH
2793: LD_VAR 0 1
2797: ARRAY
2798: PUSH
2799: LD_INT 1
2801: ARRAY
2802: PUSH
2803: LD_VAR 0 4
2807: PUSH
2808: LD_INT 2
2810: ARRAY
2811: EQUAL
2812: PUSH
2813: LD_VAR 0 4
2817: PUSH
2818: LD_INT 2
2820: ARRAY
2821: PPUSH
2822: CALL_OW 258
2826: PUSH
2827: LD_INT 2
2829: EQUAL
2830: AND
2831: IFFALSE 2849
// Say ( tmp [ 2 ] , DCorpses-FSol1-1 ) ;
2833: LD_VAR 0 4
2837: PUSH
2838: LD_INT 2
2840: ARRAY
2841: PPUSH
2842: LD_STRING DCorpses-FSol1-1
2844: PPUSH
2845: CALL_OW 88
// SetLives ( DyingSold , 150 ) ;
2849: LD_EXP 34
2853: PPUSH
2854: LD_INT 150
2856: PPUSH
2857: CALL_OW 234
// break ;
2861: GO 2865
// end ; end ;
2863: GO 2478
2865: POP
2866: POP
// p := 0 ;
2867: LD_ADDR_VAR 0 5
2871: PUSH
2872: LD_INT 0
2874: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2875: LD_INT 35
2877: PPUSH
2878: CALL_OW 67
// p := p + 1 ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_INT 1
2894: PLUS
2895: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_INT 22
2903: PUSH
2904: LD_INT 1
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PUSH
2911: LD_INT 21
2913: PUSH
2914: LD_INT 1
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: PPUSH
2925: CALL_OW 69
2929: PUSH
2930: LD_EXP 1
2934: PUSH
2935: EMPTY
2936: LIST
2937: DIFF
2938: PUSH
2939: FOR_IN
2940: IFFALSE 3010
// begin ComMoveToArea ( i , DeadCutscene ) ;
2942: LD_VAR 0 1
2946: PPUSH
2947: LD_INT 28
2949: PPUSH
2950: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2954: LD_EXP 1
2958: PPUSH
2959: LD_INT 30
2961: PPUSH
2962: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2966: LD_VAR 0 1
2970: PPUSH
2971: LD_INT 23
2973: PPUSH
2974: LD_INT 11
2976: PPUSH
2977: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2981: LD_EXP 1
2985: PPUSH
2986: LD_INT 23
2988: PPUSH
2989: LD_INT 11
2991: PPUSH
2992: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2996: LD_EXP 34
3000: PPUSH
3001: LD_INT 250
3003: PPUSH
3004: CALL_OW 234
// end ;
3008: GO 2939
3010: POP
3011: POP
// until IsInArea ( JMM , JMMAreaCutscene ) or p >= 16 ;
3012: LD_EXP 1
3016: PPUSH
3017: LD_INT 30
3019: PPUSH
3020: CALL_OW 308
3024: PUSH
3025: LD_VAR 0 5
3029: PUSH
3030: LD_INT 16
3032: GREATEREQUAL
3033: OR
3034: IFFALSE 2875
// wait ( 0 0$1 ) ;
3036: LD_INT 35
3038: PPUSH
3039: CALL_OW 67
// Say ( JMM , DCorpses-JMM-1 ) ;
3043: LD_EXP 1
3047: PPUSH
3048: LD_STRING DCorpses-JMM-1
3050: PPUSH
3051: CALL_OW 88
// SetLives ( DyingSold , 100 ) ;
3055: LD_EXP 34
3059: PPUSH
3060: LD_INT 100
3062: PPUSH
3063: CALL_OW 234
// if IsOK ( Khatam ) then
3067: LD_EXP 5
3071: PPUSH
3072: CALL_OW 302
3076: IFFALSE 3213
// begin repeat wait ( 0 0$1 ) ;
3078: LD_INT 35
3080: PPUSH
3081: CALL_OW 67
// ComHeal ( Khatam , DyingSold ) ;
3085: LD_EXP 5
3089: PPUSH
3090: LD_EXP 34
3094: PPUSH
3095: CALL_OW 128
// until GetDistUnits ( Khatam , DyingSold ) < 2 ;
3099: LD_EXP 5
3103: PPUSH
3104: LD_EXP 34
3108: PPUSH
3109: CALL_OW 296
3113: PUSH
3114: LD_INT 2
3116: LESS
3117: IFFALSE 3078
// spotCorpses = 0 ;
3119: LD_ADDR_EXP 32
3123: PUSH
3124: LD_INT 0
3126: ST_TO_ADDR
// SetLives ( DyingSold , 10 ) ;
3127: LD_EXP 34
3131: PPUSH
3132: LD_INT 10
3134: PPUSH
3135: CALL_OW 234
// wait ( 0 0$3 ) ;
3139: LD_INT 105
3141: PPUSH
3142: CALL_OW 67
// KillUnit ( DyingSold ) ;
3146: LD_EXP 34
3150: PPUSH
3151: CALL_OW 66
// wait ( 0 0$1 ) ;
3155: LD_INT 35
3157: PPUSH
3158: CALL_OW 67
// CenterNowOnUnits ( [ JMM , Khatam ] ) ;
3162: LD_EXP 1
3166: PUSH
3167: LD_EXP 5
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 87
// ComTurnUnit ( Khatam , JMM ) ;
3180: LD_EXP 5
3184: PPUSH
3185: LD_EXP 1
3189: PPUSH
3190: CALL_OW 119
// wait ( 0 0$1 ) ;
3194: LD_INT 35
3196: PPUSH
3197: CALL_OW 67
// Say ( Khatam , DCorpses-Khat-1 ) ;
3201: LD_EXP 5
3205: PPUSH
3206: LD_STRING DCorpses-Khat-1
3208: PPUSH
3209: CALL_OW 88
// end ; InGameOff ;
3213: CALL_OW 9
// Say ( JMM , DCorpses-JMM-2 ) ;
3217: LD_EXP 1
3221: PPUSH
3222: LD_STRING DCorpses-JMM-2
3224: PPUSH
3225: CALL_OW 88
// end ;
3229: PPOPN 5
3231: END
// every 0 0$1 trigger spotCorpses = 1 do
3232: LD_EXP 32
3236: PUSH
3237: LD_INT 1
3239: EQUAL
3240: IFFALSE 3258
3242: GO 3244
3244: DISABLE
// begin enable ;
3245: ENABLE
// SetLives ( DyingSold , 10 ) ;
3246: LD_EXP 34
3250: PPUSH
3251: LD_INT 10
3253: PPUSH
3254: CALL_OW 234
// end ;
3258: END
// every 1 trigger ( FilterUnitsInArea ( WaterScene , [ f_side , 1 ] ) > 0 or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Jerry ) , Jerry ) < 13 ) do var i ;
3259: LD_INT 8
3261: PPUSH
3262: LD_INT 22
3264: PUSH
3265: LD_INT 1
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 70
3276: PUSH
3277: LD_INT 0
3279: GREATER
3280: PUSH
3281: LD_INT 22
3283: PUSH
3284: LD_INT 1
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PPUSH
3291: CALL_OW 69
3295: PPUSH
3296: LD_EXP 7
3300: PPUSH
3301: CALL_OW 74
3305: PPUSH
3306: LD_EXP 7
3310: PPUSH
3311: CALL_OW 296
3315: PUSH
3316: LD_INT 13
3318: LESS
3319: OR
3320: IFFALSE 3517
3322: GO 3324
3324: DISABLE
3325: LD_INT 0
3327: PPUSH
// begin InGameOn ;
3328: CALL_OW 8
// SetLives ( Jerry , 250 ) ;
3332: LD_EXP 7
3336: PPUSH
3337: LD_INT 250
3339: PPUSH
3340: CALL_OW 234
// SetLives ( Brian , [ 1000 , 800 , 750 ] [ Difficulty ] ) ;
3344: LD_EXP 6
3348: PPUSH
3349: LD_INT 1000
3351: PUSH
3352: LD_INT 800
3354: PUSH
3355: LD_INT 750
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_OWVAR 67
3367: ARRAY
3368: PPUSH
3369: CALL_OW 234
// SetAttitude ( 3 , 4 , att_enemy , true ) ;
3373: LD_INT 3
3375: PPUSH
3376: LD_INT 4
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: LD_INT 1
3384: PPUSH
3385: CALL_OW 80
// CenterOnUnits ( [ Brian , Jerry ] ) ;
3389: LD_EXP 6
3393: PUSH
3394: LD_EXP 7
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: PPUSH
3403: CALL_OW 85
// for i in FilterUnitsInArea ( RussiansWaterSpawn , [ f_side , 3 ] ) do
3407: LD_ADDR_VAR 0 1
3411: PUSH
3412: LD_INT 9
3414: PPUSH
3415: LD_INT 22
3417: PUSH
3418: LD_INT 3
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PPUSH
3425: CALL_OW 70
3429: PUSH
3430: FOR_IN
3431: IFFALSE 3444
// ComFree ( i ) ;
3433: LD_VAR 0 1
3437: PPUSH
3438: CALL_OW 139
3442: GO 3430
3444: POP
3445: POP
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3446: LD_ADDR_VAR 0 1
3450: PUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 4
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// ComFree ( i ) ;
3469: LD_VAR 0 1
3473: PPUSH
3474: CALL_OW 139
3478: GO 3466
3480: POP
3481: POP
// wait ( 0 0$1 ) ;
3482: LD_INT 35
3484: PPUSH
3485: CALL_OW 67
// InGameOff ;
3489: CALL_OW 9
// Say ( Brian , DF-Sol1-1 ) ;
3493: LD_EXP 6
3497: PPUSH
3498: LD_STRING DF-Sol1-1
3500: PPUSH
3501: CALL_OW 88
// Say ( JMM , DF-JMM-1 ) ;
3505: LD_EXP 1
3509: PPUSH
3510: LD_STRING DF-JMM-1
3512: PPUSH
3513: CALL_OW 88
// end ;
3517: PPOPN 1
3519: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 do
3520: LD_INT 19
3522: PPUSH
3523: LD_INT 22
3525: PUSH
3526: LD_INT 3
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 70
3537: PUSH
3538: LD_INT 0
3540: EQUAL
3541: IFFALSE 3650
3543: GO 3545
3545: DISABLE
// begin if not IsDead ( Brian ) then
3546: LD_EXP 6
3550: PPUSH
3551: CALL_OW 301
3555: NOT
3556: IFFALSE 3570
// SetSide ( Brian , 1 ) ;
3558: LD_EXP 6
3562: PPUSH
3563: LD_INT 1
3565: PPUSH
3566: CALL_OW 235
// if not IsDead ( Jerry ) then
3570: LD_EXP 7
3574: PPUSH
3575: CALL_OW 301
3579: NOT
3580: IFFALSE 3594
// SetSide ( Jerry , 1 ) ;
3582: LD_EXP 7
3586: PPUSH
3587: LD_INT 1
3589: PPUSH
3590: CALL_OW 235
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) then
3594: LD_INT 22
3596: PUSH
3597: LD_INT 1
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 25
3606: PUSH
3607: LD_INT 4
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PPUSH
3618: CALL_OW 69
3622: IFFALSE 3638
// Say ( JMM , DFa-JMM-1 ) else
3624: LD_EXP 1
3628: PPUSH
3629: LD_STRING DFa-JMM-1
3631: PPUSH
3632: CALL_OW 88
3636: GO 3650
// Say ( JMM , DFa-JMM-1a ) ;
3638: LD_EXP 1
3642: PPUSH
3643: LD_STRING DFa-JMM-1a
3645: PPUSH
3646: CALL_OW 88
// end ;
3650: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 and not IsOk ( Brian ) do
3651: LD_INT 19
3653: PPUSH
3654: LD_INT 22
3656: PUSH
3657: LD_INT 3
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PPUSH
3664: CALL_OW 70
3668: PUSH
3669: LD_INT 0
3671: EQUAL
3672: PUSH
3673: LD_EXP 6
3677: PPUSH
3678: CALL_OW 302
3682: NOT
3683: AND
3684: IFFALSE 3770
3686: GO 3688
3688: DISABLE
// begin repeat wait ( 0 0$1 ) ;
3689: LD_INT 35
3691: PPUSH
3692: CALL_OW 67
// until GetLives ( Brian ) > 250 ;
3696: LD_EXP 6
3700: PPUSH
3701: CALL_OW 256
3705: PUSH
3706: LD_INT 250
3708: GREATER
3709: IFFALSE 3689
// Say ( Brian , DFb-Sol1-1 ) ;
3711: LD_EXP 6
3715: PPUSH
3716: LD_STRING DFb-Sol1-1
3718: PPUSH
3719: CALL_OW 88
// ComMoveXY ( Brian , 78 , 74 ) ;
3723: LD_EXP 6
3727: PPUSH
3728: LD_INT 78
3730: PPUSH
3731: LD_INT 74
3733: PPUSH
3734: CALL_OW 111
// if IsDead ( Jerry ) then
3738: LD_EXP 7
3742: PPUSH
3743: CALL_OW 301
3747: IFFALSE 3763
// Say ( Brian , DFb-Sol1-1a ) else
3749: LD_EXP 6
3753: PPUSH
3754: LD_STRING DFb-Sol1-1a
3756: PPUSH
3757: CALL_OW 88
3761: GO 3770
// SetAchievement ( ACH_JERRY ) ;
3763: LD_STRING ACH_JERRY
3765: PPUSH
3766: CALL_OW 543
// end ;
3770: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) = 0 do var i ;
3771: LD_INT 22
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: PUSH
3781: LD_INT 21
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 0
3802: EQUAL
3803: IFFALSE 3891
3805: GO 3807
3807: DISABLE
3808: LD_INT 0
3810: PPUSH
// begin enable ;
3811: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_btype , 31 ] ] ) do
3812: LD_ADDR_VAR 0 1
3816: PUSH
3817: LD_INT 22
3819: PUSH
3820: LD_INT 3
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 21
3829: PUSH
3830: LD_INT 3
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: LD_INT 30
3839: PUSH
3840: LD_INT 31
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 69
3856: PUSH
3857: FOR_IN
3858: IFFALSE 3889
// begin if See ( 1 , i ) then
3860: LD_INT 1
3862: PPUSH
3863: LD_VAR 0 1
3867: PPUSH
3868: CALL_OW 292
3872: IFFALSE 3887
// begin disable ;
3874: DISABLE
// Say ( JMM , DX1-JMM-1 ) ;
3875: LD_EXP 1
3879: PPUSH
3880: LD_STRING DX1-JMM-1
3882: PPUSH
3883: CALL_OW 88
// end ; end ;
3887: GO 3857
3889: POP
3890: POP
// end ;
3891: PPOPN 1
3893: END
// every 0 0$1 trigger SeeArea ( 1 , SouthBaseRussianSpawn1 ) do var i , j , mech ;
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 11
3899: PPUSH
3900: CALL_OW 294
3904: IFFALSE 4163
3906: GO 3908
3908: DISABLE
3909: LD_INT 0
3911: PPUSH
3912: PPUSH
3913: PPUSH
// begin DialogueOn ;
3914: CALL_OW 6
// Say ( FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) [ 1 ] , DX3-Rus1-1 ) ;
3918: LD_INT 11
3920: PPUSH
3921: LD_INT 22
3923: PUSH
3924: LD_INT 3
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: PUSH
3931: LD_INT 21
3933: PUSH
3934: LD_INT 1
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PPUSH
3945: CALL_OW 70
3949: PUSH
3950: LD_INT 1
3952: ARRAY
3953: PPUSH
3954: LD_STRING DX3-Rus1-1
3956: PPUSH
3957: CALL_OW 88
// Say ( JMM , DX3-JMM-1 ) ;
3961: LD_EXP 1
3965: PPUSH
3966: LD_STRING DX3-JMM-1
3968: PPUSH
3969: CALL_OW 88
// DialogueOff ;
3973: CALL_OW 7
// for i in FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
3977: LD_ADDR_VAR 0 1
3981: PUSH
3982: LD_INT 11
3984: PPUSH
3985: LD_INT 22
3987: PUSH
3988: LD_INT 3
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: LD_INT 25
3997: PUSH
3998: LD_INT 1
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 70
4013: PUSH
4014: FOR_IN
4015: IFFALSE 4035
// southBaseDefenders = southBaseDefenders ^ i ;
4017: LD_ADDR_EXP 25
4021: PUSH
4022: LD_EXP 25
4026: PUSH
4027: LD_VAR 0 1
4031: ADD
4032: ST_TO_ADDR
4033: GO 4014
4035: POP
4036: POP
// wait ( [ 0 0$5 , 0 0$4 , 0 0$3 ] [ Difficulty ] ) ;
4037: LD_INT 175
4039: PUSH
4040: LD_INT 140
4042: PUSH
4043: LD_INT 105
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: LD_OWVAR 67
4055: ARRAY
4056: PPUSH
4057: CALL_OW 67
// mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , 3 ] ] ) ;
4061: LD_ADDR_VAR 0 3
4065: PUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 3
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 21
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 25
4088: PUSH
4089: LD_INT 3
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 69
4105: ST_TO_ADDR
// if not mech then
4106: LD_VAR 0 3
4110: NOT
4111: IFFALSE 4115
// exit ;
4113: GO 4163
// ComExitBuilding ( mech ) ;
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL_OW 122
// wait ( 0 0$1 ) ;
4124: LD_INT 35
4126: PPUSH
4127: CALL_OW 67
// AddComEnterUnit ( mech [ 1 ] , vehicle1 ) ;
4131: LD_VAR 0 3
4135: PUSH
4136: LD_INT 1
4138: ARRAY
4139: PPUSH
4140: LD_INT 5
4142: PPUSH
4143: CALL_OW 180
// AddComEnterUnit ( mech [ 2 ] , vehicle2 ) ;
4147: LD_VAR 0 3
4151: PUSH
4152: LD_INT 2
4154: ARRAY
4155: PPUSH
4156: LD_INT 4
4158: PPUSH
4159: CALL_OW 180
// end ;
4163: PPOPN 3
4165: END
// every 0 0$1 trigger See ( 1 , vehicle1 ) or See ( 1 , vehicle2 ) do
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 5
4171: PPUSH
4172: CALL_OW 292
4176: PUSH
4177: LD_INT 1
4179: PPUSH
4180: LD_INT 4
4182: PPUSH
4183: CALL_OW 292
4187: OR
4188: IFFALSE 4272
4190: GO 4192
4192: DISABLE
// begin CenterOnUnits ( [ vehicle1 , vehicle2 ] ) ;
4193: LD_INT 5
4195: PUSH
4196: LD_INT 4
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PPUSH
4203: CALL_OW 85
// if IsOK ( Bobby ) then
4207: LD_EXP 2
4211: PPUSH
4212: CALL_OW 302
4216: IFFALSE 4252
// begin DialogueOn ;
4218: CALL_OW 6
// Say ( Bobby , DX2-Bobby-1 ) ;
4222: LD_EXP 2
4226: PPUSH
4227: LD_STRING DX2-Bobby-1
4229: PPUSH
4230: CALL_OW 88
// Say ( JMM , DX2-JMM-1a ) ;
4234: LD_EXP 1
4238: PPUSH
4239: LD_STRING DX2-JMM-1a
4241: PPUSH
4242: CALL_OW 88
// DialogueOff ;
4246: CALL_OW 7
// end else
4250: GO 4272
// begin DialogueOn ;
4252: CALL_OW 6
// Say ( JMM , DX2-JMM-1 ) ;
4256: LD_EXP 1
4260: PPUSH
4261: LD_STRING DX2-JMM-1
4263: PPUSH
4264: CALL_OW 88
// DialogueOff ;
4268: CALL_OW 7
// end ; end ;
4272: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) do var tmp , speaker , temp1 , temp2 , i ;
4273: LD_INT 22
4275: PUSH
4276: LD_INT 1
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 23
4285: PUSH
4286: LD_INT 3
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 2
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: LD_INT 34
4305: PUSH
4306: LD_INT 42
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PPUSH
4319: CALL_OW 69
4323: IFFALSE 4744
4325: GO 4327
4327: DISABLE
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
4333: PPUSH
4334: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) ;
4335: LD_ADDR_VAR 0 1
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 1
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 23
4352: PUSH
4353: LD_INT 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 21
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 34
4372: PUSH
4373: LD_INT 42
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: PPUSH
4386: CALL_OW 69
4390: ST_TO_ADDR
// temp1 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Cyrus , Bobby ] ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: LD_INT 22
4398: PUSH
4399: LD_INT 1
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 26
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL_OW 69
4435: PUSH
4436: LD_EXP 1
4440: PUSH
4441: LD_EXP 3
4445: PUSH
4446: LD_EXP 2
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: DIFF
4456: ST_TO_ADDR
// temp2 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_female ] ] ) diff [ Lisa ] ;
4457: LD_ADDR_VAR 0 4
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 26
4484: PUSH
4485: LD_INT 2
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: DIFF
4510: ST_TO_ADDR
// if not tmp then
4511: LD_VAR 0 1
4515: NOT
4516: IFFALSE 4520
// exit ;
4518: GO 4744
// speaker := IsDrivenBy ( tmp [ 1 ] ) ;
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: LD_VAR 0 1
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PPUSH
4534: CALL_OW 311
4538: ST_TO_ADDR
// if not speaker then
4539: LD_VAR 0 2
4543: NOT
4544: IFFALSE 4548
// exit ;
4546: GO 4744
// DialogueOn ;
4548: CALL_OW 6
// if speaker = JMM then
4552: LD_VAR 0 2
4556: PUSH
4557: LD_EXP 1
4561: EQUAL
4562: IFFALSE 4596
// begin if Lisa then
4564: LD_EXP 4
4568: IFFALSE 4582
// Say ( Lisa , DX2b-Lisa-1 ) ;
4570: LD_EXP 4
4574: PPUSH
4575: LD_STRING DX2b-Lisa-1
4577: PPUSH
4578: CALL_OW 88
// Say ( JMM , DX2b-JMM-1 ) ;
4582: LD_EXP 1
4586: PPUSH
4587: LD_STRING DX2b-JMM-1
4589: PPUSH
4590: CALL_OW 88
// end else
4594: GO 4740
// begin Say ( JMM , DX2a-JMM-1 ) ;
4596: LD_EXP 1
4600: PPUSH
4601: LD_STRING DX2a-JMM-1
4603: PPUSH
4604: CALL_OW 88
// if speaker = Bobby then
4608: LD_VAR 0 2
4612: PUSH
4613: LD_EXP 2
4617: EQUAL
4618: IFFALSE 4632
// Say ( Bobby , DX2a-Bobby-1 ) ;
4620: LD_EXP 2
4624: PPUSH
4625: LD_STRING DX2a-Bobby-1
4627: PPUSH
4628: CALL_OW 88
// if speaker = Cyrus then
4632: LD_VAR 0 2
4636: PUSH
4637: LD_EXP 3
4641: EQUAL
4642: IFFALSE 4656
// Say ( Cyrus , DX2a-Cyrus-1 ) ;
4644: LD_EXP 3
4648: PPUSH
4649: LD_STRING DX2a-Cyrus-1
4651: PPUSH
4652: CALL_OW 88
// if speaker = Lisa then
4656: LD_VAR 0 2
4660: PUSH
4661: LD_EXP 4
4665: EQUAL
4666: IFFALSE 4680
// Say ( Lisa , DX2a-Lisa-1 ) ;
4668: LD_EXP 4
4672: PPUSH
4673: LD_STRING DX2a-Lisa-1
4675: PPUSH
4676: CALL_OW 88
// if speaker in temp1 then
4680: LD_VAR 0 2
4684: PUSH
4685: LD_VAR 0 3
4689: IN
4690: IFFALSE 4704
// Say ( speaker , DX2a-Sol1-1 ) ;
4692: LD_VAR 0 2
4696: PPUSH
4697: LD_STRING DX2a-Sol1-1
4699: PPUSH
4700: CALL_OW 88
// if speaker in temp2 then
4704: LD_VAR 0 2
4708: PUSH
4709: LD_VAR 0 4
4713: IN
4714: IFFALSE 4728
// Say ( speaker , DX2a-FSol1-1 ) ;
4716: LD_VAR 0 2
4720: PPUSH
4721: LD_STRING DX2a-FSol1-1
4723: PPUSH
4724: CALL_OW 88
// Say ( JMM , DX2a-JMM-2 ) ;
4728: LD_EXP 1
4732: PPUSH
4733: LD_STRING DX2a-JMM-2
4735: PPUSH
4736: CALL_OW 88
// end ; DialogueOff ;
4740: CALL_OW 7
// end ;
4744: PPOPN 5
4746: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 or GetSide ( dep2 ) = 1 do
4747: LD_INT 1
4749: PPUSH
4750: CALL_OW 255
4754: PUSH
4755: LD_INT 1
4757: EQUAL
4758: PUSH
4759: LD_INT 10
4761: PPUSH
4762: CALL_OW 255
4766: PUSH
4767: LD_INT 1
4769: EQUAL
4770: OR
4771: IFFALSE 4831
4773: GO 4775
4775: DISABLE
// begin DialogueOn ;
4776: CALL_OW 6
// Say ( JMM , D3-JMM-1 ) ;
4780: LD_EXP 1
4784: PPUSH
4785: LD_STRING D3-JMM-1
4787: PPUSH
4788: CALL_OW 88
// SayRadio ( Powell , D3-Pow-1 ) ;
4792: LD_EXP 9
4796: PPUSH
4797: LD_STRING D3-Pow-1
4799: PPUSH
4800: CALL_OW 94
// if IsOK ( Cyrus ) then
4804: LD_EXP 3
4808: PPUSH
4809: CALL_OW 302
4813: IFFALSE 4827
// Say ( Cyrus , D3-Cyrus-1 ) ;
4815: LD_EXP 3
4819: PPUSH
4820: LD_STRING D3-Cyrus-1
4822: PPUSH
4823: CALL_OW 88
// DialogueOff ;
4827: CALL_OW 7
// end ;
4831: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 do var temp , tmp , i ;
4832: LD_INT 1
4834: PPUSH
4835: CALL_OW 255
4839: PUSH
4840: LD_INT 1
4842: EQUAL
4843: PUSH
4844: LD_INT 10
4846: PPUSH
4847: CALL_OW 255
4851: PUSH
4852: LD_INT 1
4854: EQUAL
4855: AND
4856: IFFALSE 6239
4858: GO 4860
4860: DISABLE
4861: LD_INT 0
4863: PPUSH
4864: PPUSH
4865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4866: LD_ADDR_VAR 0 2
4870: PUSH
4871: LD_INT 22
4873: PUSH
4874: LD_INT 3
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 21
4883: PUSH
4884: LD_INT 1
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 69
4899: ST_TO_ADDR
// if tmp then
4900: LD_VAR 0 2
4904: IFFALSE 4965
// begin for i in tmp do
4906: LD_ADDR_VAR 0 3
4910: PUSH
4911: LD_VAR 0 2
4915: PUSH
4916: FOR_IN
4917: IFFALSE 4963
// begin if IsInUnit ( i ) then
4919: LD_VAR 0 3
4923: PPUSH
4924: CALL_OW 310
4928: IFFALSE 4939
// ComExitBuilding ( i ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: CALL_OW 122
// wait ( 0 0$1 ) ;
4939: LD_INT 35
4941: PPUSH
4942: CALL_OW 67
// AddComAgressiveMove ( i , 54 , 17 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 54
4953: PPUSH
4954: LD_INT 17
4956: PPUSH
4957: CALL_OW 174
// end ;
4961: GO 4916
4963: POP
4964: POP
// end ; wait ( 0 0$03 ) ;
4965: LD_INT 105
4967: PPUSH
4968: CALL_OW 67
// DialogueOn ;
4972: CALL_OW 6
// Say ( JMM , D3a-JMM-1 ) ;
4976: LD_EXP 1
4980: PPUSH
4981: LD_STRING D3a-JMM-1
4983: PPUSH
4984: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-1 ) ;
4988: LD_EXP 9
4992: PPUSH
4993: LD_STRING D3a-Pow-1
4995: PPUSH
4996: CALL_OW 94
// Say ( JMM , D3a-JMM-2 ) ;
5000: LD_EXP 1
5004: PPUSH
5005: LD_STRING D3a-JMM-2
5007: PPUSH
5008: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-2 ) ;
5012: LD_EXP 9
5016: PPUSH
5017: LD_STRING D3a-Pow-2
5019: PPUSH
5020: CALL_OW 94
// Say ( JMM , D3a-JMM-3 ) ;
5024: LD_EXP 1
5028: PPUSH
5029: LD_STRING D3a-JMM-3
5031: PPUSH
5032: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-3 ) ;
5036: LD_EXP 9
5040: PPUSH
5041: LD_STRING D3a-Pow-3
5043: PPUSH
5044: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
5048: LD_EXP 1
5052: PPUSH
5053: LD_STRING D3a-JMM-4
5055: PPUSH
5056: CALL_OW 88
// DialogueOff ;
5060: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5064: LD_STRING M2
5066: PPUSH
5067: CALL_OW 337
// Say ( JMM , D3b-JMM-1 ) ;
5071: LD_EXP 1
5075: PPUSH
5076: LD_STRING D3b-JMM-1
5078: PPUSH
5079: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// until FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_class , 2 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
5090: LD_INT 22
5092: PPUSH
5093: LD_INT 22
5095: PUSH
5096: LD_INT 1
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 25
5105: PUSH
5106: LD_INT 2
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PPUSH
5117: CALL_OW 70
5121: PUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 3
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 21
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: NOT
5151: AND
5152: IFFALSE 5083
// repeat temp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Khatam ] ;
5154: LD_ADDR_VAR 0 1
5158: PUSH
5159: LD_INT 22
5161: PUSH
5162: LD_INT 1
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: LD_INT 23
5171: PUSH
5172: LD_INT 1
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: PUSH
5179: LD_INT 25
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PUSH
5189: LD_INT 50
5191: PUSH
5192: EMPTY
5193: LIST
5194: PUSH
5195: LD_INT 56
5197: PUSH
5198: EMPTY
5199: LIST
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: PUSH
5213: LD_EXP 1
5217: PUSH
5218: LD_EXP 5
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: DIFF
5227: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until temp > 0 ;
5235: LD_VAR 0 1
5239: PUSH
5240: LD_INT 0
5242: GREATER
5243: IFFALSE 5154
// wait ( 0 0$5 ) ;
5245: LD_INT 175
5247: PPUSH
5248: CALL_OW 67
// PrepareRussianHeroes ;
5252: CALL 11590 0 0
// InGameOn ;
5256: CALL_OW 8
// CenterNowOnUnits ( Mikhail ) ;
5260: LD_EXP 8
5264: PPUSH
5265: CALL_OW 87
// ComTurnUnit ( [ JMM , temp [ 1 ] ] , Mikhail ) ;
5269: LD_EXP 1
5273: PUSH
5274: LD_VAR 0 1
5278: PUSH
5279: LD_INT 1
5281: ARRAY
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PPUSH
5287: LD_EXP 8
5291: PPUSH
5292: CALL_OW 119
// ComTurnUnit ( Mikhail , temp [ 1 ] ) ;
5296: LD_EXP 8
5300: PPUSH
5301: LD_VAR 0 1
5305: PUSH
5306: LD_INT 1
5308: ARRAY
5309: PPUSH
5310: CALL_OW 119
// Wait ( 0 0$02 ) ;
5314: LD_INT 70
5316: PPUSH
5317: CALL_OW 67
// Say ( Mikhail , D4-Mikh-1 ) ;
5321: LD_EXP 8
5325: PPUSH
5326: LD_STRING D4-Mikh-1
5328: PPUSH
5329: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5333: LD_VAR 0 1
5337: PUSH
5338: LD_INT 1
5340: ARRAY
5341: PPUSH
5342: CALL_OW 258
5346: PUSH
5347: LD_INT 1
5349: EQUAL
5350: IFFALSE 5368
// Say ( temp [ 1 ] , D4-Sol1-1 ) ;
5352: LD_VAR 0 1
5356: PUSH
5357: LD_INT 1
5359: ARRAY
5360: PPUSH
5361: LD_STRING D4-Sol1-1
5363: PPUSH
5364: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: CALL_OW 258
5381: PUSH
5382: LD_INT 2
5384: EQUAL
5385: IFFALSE 5403
// Say ( temp [ 1 ] , D4-FSol1-1 ) ;
5387: LD_VAR 0 1
5391: PUSH
5392: LD_INT 1
5394: ARRAY
5395: PPUSH
5396: LD_STRING D4-FSol1-1
5398: PPUSH
5399: CALL_OW 88
// Say ( Mikhail , D4-Mikh-2 ) ;
5403: LD_EXP 8
5407: PPUSH
5408: LD_STRING D4-Mikh-2
5410: PPUSH
5411: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5415: LD_VAR 0 1
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: CALL_OW 258
5428: PUSH
5429: LD_INT 1
5431: EQUAL
5432: IFFALSE 5450
// Say ( temp [ 1 ] , D4-Sol1-2 ) ;
5434: LD_VAR 0 1
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: LD_STRING D4-Sol1-2
5445: PPUSH
5446: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5450: LD_VAR 0 1
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: CALL_OW 258
5463: PUSH
5464: LD_INT 2
5466: EQUAL
5467: IFFALSE 5485
// Say ( temp [ 1 ] , D4-FSol1-2 ) ;
5469: LD_VAR 0 1
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PPUSH
5478: LD_STRING D4-FSol1-2
5480: PPUSH
5481: CALL_OW 88
// Say ( Mikhail , D4-Mikh-3 ) ;
5485: LD_EXP 8
5489: PPUSH
5490: LD_STRING D4-Mikh-3
5492: PPUSH
5493: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: CALL_OW 258
5510: PUSH
5511: LD_INT 1
5513: EQUAL
5514: IFFALSE 5532
// Say ( temp [ 1 ] , D4-Sol1-3 ) ;
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 1
5523: ARRAY
5524: PPUSH
5525: LD_STRING D4-Sol1-3
5527: PPUSH
5528: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5532: LD_VAR 0 1
5536: PUSH
5537: LD_INT 1
5539: ARRAY
5540: PPUSH
5541: CALL_OW 258
5545: PUSH
5546: LD_INT 2
5548: EQUAL
5549: IFFALSE 5567
// Say ( temp [ 1 ] , D4-FSol1-3 ) ;
5551: LD_VAR 0 1
5555: PUSH
5556: LD_INT 1
5558: ARRAY
5559: PPUSH
5560: LD_STRING D4-FSol1-3
5562: PPUSH
5563: CALL_OW 88
// Say ( Mikhail , D4-Mikh-4 ) ;
5567: LD_EXP 8
5571: PPUSH
5572: LD_STRING D4-Mikh-4
5574: PPUSH
5575: CALL_OW 88
// case query ( Qs1 ) of 1 :
5579: LD_STRING Qs1
5581: PPUSH
5582: CALL_OW 97
5586: PUSH
5587: LD_INT 1
5589: DOUBLE
5590: EQUAL
5591: IFTRUE 5595
5593: GO 5630
5595: POP
// begin InGameOff ;
5596: CALL_OW 9
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
5600: LD_INT 1
5602: PPUSH
5603: LD_INT 6
5605: PPUSH
5606: LD_INT 2
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: CALL_OW 80
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
5616: LD_EXP 8
5620: PPUSH
5621: LD_INT 17
5623: PPUSH
5624: CALL_OW 113
// end ; 2 :
5628: GO 6223
5630: LD_INT 2
5632: DOUBLE
5633: EQUAL
5634: IFTRUE 5638
5636: GO 6188
5638: POP
// begin repeat wait ( 0 0$1 ) ;
5639: LD_INT 35
5641: PPUSH
5642: CALL_OW 67
// CenterNowOnUnits ( temp [ 1 ] ) ;
5646: LD_VAR 0 1
5650: PUSH
5651: LD_INT 1
5653: ARRAY
5654: PPUSH
5655: CALL_OW 87
// ComMoveUnit ( temp [ 1 ] , JMM ) ;
5659: LD_VAR 0 1
5663: PUSH
5664: LD_INT 1
5666: ARRAY
5667: PPUSH
5668: LD_EXP 1
5672: PPUSH
5673: CALL_OW 112
// ComMoveUnit ( Mikhail , JMM ) ;
5677: LD_EXP 8
5681: PPUSH
5682: LD_EXP 1
5686: PPUSH
5687: CALL_OW 112
// until ( GetDistUnits ( JMM , Mikhail ) < 5 ) ;
5691: LD_EXP 1
5695: PPUSH
5696: LD_EXP 8
5700: PPUSH
5701: CALL_OW 296
5705: PUSH
5706: LD_INT 5
5708: LESS
5709: IFFALSE 5639
// ComTurnUnit ( Mikhail , JMM ) ;
5711: LD_EXP 8
5715: PPUSH
5716: LD_EXP 1
5720: PPUSH
5721: CALL_OW 119
// Say ( JMM , D4b-JMM-1 ) ;
5725: LD_EXP 1
5729: PPUSH
5730: LD_STRING D4b-JMM-1
5732: PPUSH
5733: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-1 ) ;
5737: LD_EXP 8
5741: PPUSH
5742: LD_STRING D4b-Mikh-1
5744: PPUSH
5745: CALL_OW 88
// Say ( JMM , D4b-JMM-2 ) ;
5749: LD_EXP 1
5753: PPUSH
5754: LD_STRING D4b-JMM-2
5756: PPUSH
5757: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-2 ) ;
5761: LD_EXP 8
5765: PPUSH
5766: LD_STRING D4b-Mikh-2
5768: PPUSH
5769: CALL_OW 88
// Say ( JMM , D4b-JMM-3 ) ;
5773: LD_EXP 1
5777: PPUSH
5778: LD_STRING D4b-JMM-3
5780: PPUSH
5781: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-3 ) ;
5785: LD_EXP 8
5789: PPUSH
5790: LD_STRING D4b-Mikh-3
5792: PPUSH
5793: CALL_OW 88
// Say ( JMM , D4b-JMM-4 ) ;
5797: LD_EXP 1
5801: PPUSH
5802: LD_STRING D4b-JMM-4
5804: PPUSH
5805: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-4 ) ;
5809: LD_EXP 8
5813: PPUSH
5814: LD_STRING D4b-Mikh-4
5816: PPUSH
5817: CALL_OW 88
// Say ( JMM , D4b-JMM-5 ) ;
5821: LD_EXP 1
5825: PPUSH
5826: LD_STRING D4b-JMM-5
5828: PPUSH
5829: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-5 ) ;
5833: LD_EXP 8
5837: PPUSH
5838: LD_STRING D4b-Mikh-5
5840: PPUSH
5841: CALL_OW 88
// Say ( JMM , D4b-JMM-6 ) ;
5845: LD_EXP 1
5849: PPUSH
5850: LD_STRING D4b-JMM-6
5852: PPUSH
5853: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-6 ) ;
5857: LD_EXP 8
5861: PPUSH
5862: LD_STRING D4b-Mikh-6
5864: PPUSH
5865: CALL_OW 88
// Say ( JMM , D4b-JMM-7 ) ;
5869: LD_EXP 1
5873: PPUSH
5874: LD_STRING D4b-JMM-7
5876: PPUSH
5877: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-7 ) ;
5881: LD_EXP 8
5885: PPUSH
5886: LD_STRING D4b-Mikh-7
5888: PPUSH
5889: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5893: LD_VAR 0 1
5897: PUSH
5898: LD_INT 1
5900: ARRAY
5901: PPUSH
5902: CALL_OW 258
5906: PUSH
5907: LD_INT 1
5909: EQUAL
5910: IFFALSE 5928
// Say ( temp [ 1 ] , D4b-Sol1-7 ) ;
5912: LD_VAR 0 1
5916: PUSH
5917: LD_INT 1
5919: ARRAY
5920: PPUSH
5921: LD_STRING D4b-Sol1-7
5923: PPUSH
5924: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5928: LD_VAR 0 1
5932: PUSH
5933: LD_INT 1
5935: ARRAY
5936: PPUSH
5937: CALL_OW 258
5941: PUSH
5942: LD_INT 2
5944: EQUAL
5945: IFFALSE 5963
// Say ( temp [ 1 ] , D4b-FSol1-7 ) ;
5947: LD_VAR 0 1
5951: PUSH
5952: LD_INT 1
5954: ARRAY
5955: PPUSH
5956: LD_STRING D4b-FSol1-7
5958: PPUSH
5959: CALL_OW 88
// Say ( JMM , D4b-JMM-8 ) ;
5963: LD_EXP 1
5967: PPUSH
5968: LD_STRING D4b-JMM-8
5970: PPUSH
5971: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5975: LD_VAR 0 1
5979: PUSH
5980: LD_INT 1
5982: ARRAY
5983: PPUSH
5984: CALL_OW 258
5988: PUSH
5989: LD_INT 1
5991: EQUAL
5992: IFFALSE 6010
// Say ( temp [ 1 ] , D4b-Sol1-8 ) ;
5994: LD_VAR 0 1
5998: PUSH
5999: LD_INT 1
6001: ARRAY
6002: PPUSH
6003: LD_STRING D4b-Sol1-8
6005: PPUSH
6006: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
6010: LD_VAR 0 1
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PPUSH
6019: CALL_OW 258
6023: PUSH
6024: LD_INT 2
6026: EQUAL
6027: IFFALSE 6045
// Say ( temp [ 1 ] , D4b-FSol1-8 ) ;
6029: LD_VAR 0 1
6033: PUSH
6034: LD_INT 1
6036: ARRAY
6037: PPUSH
6038: LD_STRING D4b-FSol1-8
6040: PPUSH
6041: CALL_OW 88
// Say ( JMM , D4b-JMM-9 ) ;
6045: LD_EXP 1
6049: PPUSH
6050: LD_STRING D4b-JMM-9
6052: PPUSH
6053: CALL_OW 88
// SetSide ( Mikhail , 1 ) ;
6057: LD_EXP 8
6061: PPUSH
6062: LD_INT 1
6064: PPUSH
6065: CALL_OW 235
// for i in FilterAllUnits ( [ [ f_side , 1 ] ] ) do
6069: LD_ADDR_VAR 0 3
6073: PUSH
6074: LD_INT 22
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: PPUSH
6087: CALL_OW 69
6091: PUSH
6092: FOR_IN
6093: IFFALSE 6106
// ComFree ( i ) ;
6095: LD_VAR 0 3
6099: PPUSH
6100: CALL_OW 139
6104: GO 6092
6106: POP
6107: POP
// repeat wait ( 0 0$1 ) ;
6108: LD_INT 35
6110: PPUSH
6111: CALL_OW 67
// CenterNowOnUnits ( Mikhail ) ;
6115: LD_EXP 8
6119: PPUSH
6120: CALL_OW 87
// ComEnterUnit ( [ Mikhail , temp [ 1 ] ] , dep1 ) ;
6124: LD_EXP 8
6128: PUSH
6129: LD_VAR 0 1
6133: PUSH
6134: LD_INT 1
6136: ARRAY
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: CALL_OW 120
// until IsInUnit ( Mikhail ) ;
6149: LD_EXP 8
6153: PPUSH
6154: CALL_OW 310
6158: IFFALSE 6108
// mikhailDepot = IsInUnit ( Mikhail ) ;
6160: LD_ADDR_EXP 23
6164: PUSH
6165: LD_EXP 8
6169: PPUSH
6170: CALL_OW 310
6174: ST_TO_ADDR
// InGameOff ;
6175: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
6179: LD_STRING M3
6181: PPUSH
6182: CALL_OW 337
// end ; 3 :
6186: GO 6223
6188: LD_INT 3
6190: DOUBLE
6191: EQUAL
6192: IFTRUE 6196
6194: GO 6222
6196: POP
// begin ComMoveToArea ( Mikhail , MikhailEscape ) ;
6197: LD_EXP 8
6201: PPUSH
6202: LD_INT 17
6204: PPUSH
6205: CALL_OW 113
// wait ( 0 0$3 ) ;
6209: LD_INT 105
6211: PPUSH
6212: CALL_OW 67
// InGameOff ;
6216: CALL_OW 9
// end ; end ;
6220: GO 6223
6222: POP
// PrepareTigers ;
6223: CALL 14440 0 0
// RussianTrap ;
6227: CALL 9986 0 0
// tigersRespawn = 1 ;
6231: LD_ADDR_EXP 30
6235: PUSH
6236: LD_INT 1
6238: ST_TO_ADDR
// end ;
6239: PPOPN 3
6241: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and GetResourceType ( GetBase ( dep1 ) , 1 ) >= 100 do var tmp ;
6242: LD_INT 1
6244: PPUSH
6245: CALL_OW 255
6249: PUSH
6250: LD_INT 1
6252: EQUAL
6253: PUSH
6254: LD_INT 10
6256: PPUSH
6257: CALL_OW 255
6261: PUSH
6262: LD_INT 1
6264: EQUAL
6265: AND
6266: PUSH
6267: LD_INT 1
6269: PPUSH
6270: CALL_OW 274
6274: PPUSH
6275: LD_INT 1
6277: PPUSH
6278: CALL_OW 275
6282: PUSH
6283: LD_INT 100
6285: GREATEREQUAL
6286: AND
6287: IFFALSE 6436
6289: GO 6291
6291: DISABLE
6292: LD_INT 0
6294: PPUSH
// begin wait ( rand ( 1 1$0 , 2 2$0 ) + 0 0$30 ) ;
6295: LD_INT 2100
6297: PPUSH
6298: LD_INT 4200
6300: PPUSH
6301: CALL_OW 12
6305: PUSH
6306: LD_INT 1050
6308: PLUS
6309: PPUSH
6310: CALL_OW 67
// PrepareCargoBays ;
6314: CALL 12723 0 0
// cargoRespawn = 1 ;
6318: LD_ADDR_EXP 28
6322: PUSH
6323: LD_INT 1
6325: ST_TO_ADDR
// tmp := [ cargo1 , cargo2 , driver1 , driver2 ] ;
6326: LD_ADDR_VAR 0 1
6330: PUSH
6331: LD_EXP 15
6335: PUSH
6336: LD_EXP 16
6340: PUSH
6341: LD_EXP 17
6345: PUSH
6346: LD_EXP 18
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: ST_TO_ADDR
// ComMoveXY ( tmp , 17 , 10 ) ;
6357: LD_VAR 0 1
6361: PPUSH
6362: LD_INT 17
6364: PPUSH
6365: LD_INT 10
6367: PPUSH
6368: CALL_OW 111
// AddComMoveXY ( tmp , 36 , 13 ) ;
6372: LD_VAR 0 1
6376: PPUSH
6377: LD_INT 36
6379: PPUSH
6380: LD_INT 13
6382: PPUSH
6383: CALL_OW 171
// AddComMoveXY ( tmp , 40 , 20 ) ;
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 40
6394: PPUSH
6395: LD_INT 20
6397: PPUSH
6398: CALL_OW 171
// AddComMoveXY ( tmp , 53 , 16 ) ;
6402: LD_VAR 0 1
6406: PPUSH
6407: LD_INT 53
6409: PPUSH
6410: LD_INT 16
6412: PPUSH
6413: CALL_OW 171
// wait ( 0 0$5 ) ;
6417: LD_INT 175
6419: PPUSH
6420: CALL_OW 67
// Say ( driver1 , D5-Rus2-1 ) ;
6424: LD_EXP 17
6428: PPUSH
6429: LD_STRING D5-Rus2-1
6431: PPUSH
6432: CALL_OW 88
// end ;
6436: PPOPN 1
6438: END
// every 0 0$1 trigger cargoRespawn = 1 do var cargos ;
6439: LD_EXP 28
6443: PUSH
6444: LD_INT 1
6446: EQUAL
6447: IFFALSE 6602
6449: GO 6451
6451: DISABLE
6452: LD_INT 0
6454: PPUSH
// begin cargos = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
6455: LD_ADDR_VAR 0 1
6459: PUSH
6460: LD_INT 22
6462: PUSH
6463: LD_INT 3
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 21
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: LD_INT 34
6482: PUSH
6483: LD_INT 51
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
6500: LD_INT 105
6502: PPUSH
6503: CALL_OW 67
// until UnitFilter ( cargos , [ f_not , [ f_hastask ] ] ) or UnitFilter ( cargos , [ f_not , [ f_lives , 980 ] ] ) ;
6507: LD_VAR 0 1
6511: PPUSH
6512: LD_INT 3
6514: PUSH
6515: LD_INT 60
6517: PUSH
6518: EMPTY
6519: LIST
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PPUSH
6525: CALL_OW 72
6529: PUSH
6530: LD_VAR 0 1
6534: PPUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 980
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PPUSH
6552: CALL_OW 72
6556: OR
6557: IFFALSE 6500
// ComMoveXY ( cargos , 7 , 9 ) ;
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 7
6566: PPUSH
6567: LD_INT 9
6569: PPUSH
6570: CALL_OW 111
// cargoSee = 1 ;
6574: LD_ADDR_EXP 29
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// cargoEscape = 1 ;
6582: LD_ADDR_EXP 20
6586: PUSH
6587: LD_INT 1
6589: ST_TO_ADDR
// Say ( driver1 , D5-Rus2-1a ) ;
6590: LD_EXP 17
6594: PPUSH
6595: LD_STRING D5-Rus2-1a
6597: PPUSH
6598: CALL_OW 88
// end ;
6602: PPOPN 1
6604: END
// every 0 0$1 trigger cargoEscape > 0 do
6605: LD_EXP 20
6609: PUSH
6610: LD_INT 0
6612: GREATER
6613: IFFALSE 6760
6615: GO 6617
6617: DISABLE
// begin enable ;
6618: ENABLE
// ComMoveToArea ( [ cargo1 , cargo2 ] , RussianAttack ) ;
6619: LD_EXP 15
6623: PUSH
6624: LD_EXP 16
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PPUSH
6633: LD_INT 13
6635: PPUSH
6636: CALL_OW 113
// if IsInArea ( cargo1 , RussianAttack ) or IsInArea ( driver1 , RussianAttack ) then
6640: LD_EXP 15
6644: PPUSH
6645: LD_INT 13
6647: PPUSH
6648: CALL_OW 308
6652: PUSH
6653: LD_EXP 17
6657: PPUSH
6658: LD_INT 13
6660: PPUSH
6661: CALL_OW 308
6665: OR
6666: IFFALSE 6700
// begin RemoveUnit ( cargo1 ) ;
6668: LD_EXP 15
6672: PPUSH
6673: CALL_OW 64
// RemoveUnit ( driver1 ) ;
6677: LD_EXP 17
6681: PPUSH
6682: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6686: LD_ADDR_EXP 20
6690: PUSH
6691: LD_EXP 20
6695: PUSH
6696: LD_INT 1
6698: PLUS
6699: ST_TO_ADDR
// end ; if IsInArea ( cargo2 , RussianAttack ) or IsInArea ( driver2 , RussianAttack ) then
6700: LD_EXP 16
6704: PPUSH
6705: LD_INT 13
6707: PPUSH
6708: CALL_OW 308
6712: PUSH
6713: LD_EXP 18
6717: PPUSH
6718: LD_INT 13
6720: PPUSH
6721: CALL_OW 308
6725: OR
6726: IFFALSE 6760
// begin RemoveUnit ( cargo2 ) ;
6728: LD_EXP 16
6732: PPUSH
6733: CALL_OW 64
// RemoveUnit ( driver2 ) ;
6737: LD_EXP 18
6741: PPUSH
6742: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6746: LD_ADDR_EXP 20
6750: PUSH
6751: LD_EXP 20
6755: PUSH
6756: LD_INT 1
6758: PLUS
6759: ST_TO_ADDR
// end ; end ;
6760: END
// every 0 0$1 trigger cargoEscape > 1 do var speaker ;
6761: LD_EXP 20
6765: PUSH
6766: LD_INT 1
6768: GREATER
6769: IFFALSE 6926
6771: GO 6773
6773: DISABLE
6774: LD_INT 0
6776: PPUSH
// begin SetRestrict ( b_armoury , 1 , true ) ;
6777: LD_INT 4
6779: PPUSH
6780: LD_INT 1
6782: PPUSH
6783: LD_INT 1
6785: PPUSH
6786: CALL_OW 324
// SetRestrict ( 31 , 1 , true ) ;
6790: LD_INT 31
6792: PPUSH
6793: LD_INT 1
6795: PPUSH
6796: LD_INT 1
6798: PPUSH
6799: CALL_OW 324
// if IsOK ( Jerry ) then
6803: LD_EXP 7
6807: PPUSH
6808: CALL_OW 302
6812: IFFALSE 6828
// Say ( Jerry , D5a-Sol1-1 ) else
6814: LD_EXP 7
6818: PPUSH
6819: LD_STRING D5a-Sol1-1
6821: PPUSH
6822: CALL_OW 88
6826: GO 6914
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Khatam ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 22
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 26
6845: PUSH
6846: LD_INT 1
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PPUSH
6857: CALL_OW 69
6861: PUSH
6862: LD_EXP 1
6866: PUSH
6867: LD_EXP 2
6871: PUSH
6872: LD_EXP 3
6876: PUSH
6877: LD_EXP 5
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: LIST
6886: LIST
6887: DIFF
6888: ST_TO_ADDR
// if not speaker then
6889: LD_VAR 0 1
6893: NOT
6894: IFFALSE 6898
// exit ;
6896: GO 6926
// Say ( speaker [ 1 ] , D5a-Sol1-1 ) ;
6898: LD_VAR 0 1
6902: PUSH
6903: LD_INT 1
6905: ARRAY
6906: PPUSH
6907: LD_STRING D5a-Sol1-1
6909: PPUSH
6910: CALL_OW 88
// end ; Say ( JMM , D5a-JMM-1 ) ;
6914: LD_EXP 1
6918: PPUSH
6919: LD_STRING D5a-JMM-1
6921: PPUSH
6922: CALL_OW 88
// end ;
6926: PPOPN 1
6928: END
// every 0 0$1 trigger ( GetSide ( dep1 ) = 3 and GetLives ( dep1 ) < 1000 ) or ( GetSide ( dep2 ) = 3 and GetLives ( dep2 ) < 1000 ) do
6929: LD_INT 1
6931: PPUSH
6932: CALL_OW 255
6936: PUSH
6937: LD_INT 3
6939: EQUAL
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: CALL_OW 256
6948: PUSH
6949: LD_INT 1000
6951: LESS
6952: AND
6953: PUSH
6954: LD_INT 10
6956: PPUSH
6957: CALL_OW 255
6961: PUSH
6962: LD_INT 3
6964: EQUAL
6965: PUSH
6966: LD_INT 10
6968: PPUSH
6969: CALL_OW 256
6973: PUSH
6974: LD_INT 1000
6976: LESS
6977: AND
6978: OR
6979: IFFALSE 6996
6981: GO 6983
6983: DISABLE
// begin Say ( JMM , D8-JMM-1 ) ;
6984: LD_EXP 1
6988: PPUSH
6989: LD_STRING D8-JMM-1
6991: PPUSH
6992: CALL_OW 88
// end ;
6996: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) = dep1 and not mikhailInbase = 3 do
6997: LD_EXP 8
7001: PPUSH
7002: CALL_OW 310
7006: PUSH
7007: LD_INT 1
7009: EQUAL
7010: PUSH
7011: LD_EXP 22
7015: PUSH
7016: LD_INT 3
7018: EQUAL
7019: NOT
7020: AND
7021: IFFALSE 7043
7023: GO 7025
7025: DISABLE
// begin mikhailInBase = 1 ;
7026: LD_ADDR_EXP 22
7030: PUSH
7031: LD_INT 1
7033: ST_TO_ADDR
// mikhailStatus = 1 ;
7034: LD_ADDR_EXP 21
7038: PUSH
7039: LD_INT 1
7041: ST_TO_ADDR
// enable ;
7042: ENABLE
// end ;
7043: END
// export function AskMikhail ; begin
7044: LD_INT 0
7046: PPUSH
// case query ( QMikh2 ) of 1 :
7047: LD_STRING QMikh2
7049: PPUSH
7050: CALL_OW 97
7054: PUSH
7055: LD_INT 1
7057: DOUBLE
7058: EQUAL
7059: IFTRUE 7063
7061: GO 7130
7063: POP
// begin SetAttitude ( 1 , 6 , att_enemy , true ) ;
7064: LD_INT 1
7066: PPUSH
7067: LD_INT 6
7069: PPUSH
7070: LD_INT 2
7072: PPUSH
7073: LD_INT 1
7075: PPUSH
7076: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7080: LD_EXP 8
7084: PPUSH
7085: LD_INT 6
7087: PPUSH
7088: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7092: LD_EXP 8
7096: PPUSH
7097: CALL_OW 122
// wait ( 0 0$1 ) ;
7101: LD_INT 35
7103: PPUSH
7104: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7108: LD_EXP 8
7112: PPUSH
7113: LD_INT 17
7115: PPUSH
7116: CALL_OW 113
// mikhailInbase = 0 ;
7120: LD_ADDR_EXP 22
7124: PUSH
7125: LD_INT 0
7127: ST_TO_ADDR
// end ; 2 :
7128: GO 7371
7130: LD_INT 2
7132: DOUBLE
7133: EQUAL
7134: IFTRUE 7138
7136: GO 7311
7138: POP
// begin mikhailInBase = 2 ;
7139: LD_ADDR_EXP 22
7143: PUSH
7144: LD_INT 2
7146: ST_TO_ADDR
// SetSide ( Mikhail , 6 ) ;
7147: LD_EXP 8
7151: PPUSH
7152: LD_INT 6
7154: PPUSH
7155: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7159: LD_EXP 8
7163: PPUSH
7164: CALL_OW 122
// wait ( 0 0$1 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// ComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) + 2 ) ;
7175: LD_EXP 8
7179: PPUSH
7180: LD_EXP 8
7184: PPUSH
7185: CALL_OW 250
7189: PUSH
7190: LD_INT 2
7192: PLUS
7193: PPUSH
7194: LD_EXP 8
7198: PPUSH
7199: CALL_OW 251
7203: PUSH
7204: LD_INT 2
7206: PLUS
7207: PPUSH
7208: CALL_OW 111
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 1 , GetY ( Mikhail ) + 2 ) ;
7212: LD_EXP 8
7216: PPUSH
7217: LD_EXP 8
7221: PPUSH
7222: CALL_OW 250
7226: PUSH
7227: LD_INT 1
7229: PLUS
7230: PPUSH
7231: LD_EXP 8
7235: PPUSH
7236: CALL_OW 251
7240: PUSH
7241: LD_INT 2
7243: PLUS
7244: PPUSH
7245: CALL_OW 171
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) ) ;
7249: LD_EXP 8
7253: PPUSH
7254: LD_EXP 8
7258: PPUSH
7259: CALL_OW 250
7263: PUSH
7264: LD_INT 2
7266: PLUS
7267: PPUSH
7268: LD_EXP 8
7272: PPUSH
7273: CALL_OW 251
7277: PPUSH
7278: CALL_OW 171
// wait ( 0 0$5 ) ;
7282: LD_INT 175
7284: PPUSH
7285: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEnter ) ;
7289: LD_EXP 8
7293: PPUSH
7294: LD_INT 25
7296: PPUSH
7297: CALL_OW 113
// mikhailInBase = 4 ;
7301: LD_ADDR_EXP 22
7305: PUSH
7306: LD_INT 4
7308: ST_TO_ADDR
// end ; 3 :
7309: GO 7371
7311: LD_INT 3
7313: DOUBLE
7314: EQUAL
7315: IFTRUE 7319
7317: GO 7370
7319: POP
// begin SetSide ( Mikhail , 6 ) ;
7320: LD_EXP 8
7324: PPUSH
7325: LD_INT 6
7327: PPUSH
7328: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7332: LD_EXP 8
7336: PPUSH
7337: CALL_OW 122
// wait ( 0 0$1 ) ;
7341: LD_INT 35
7343: PPUSH
7344: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7348: LD_EXP 8
7352: PPUSH
7353: LD_INT 17
7355: PPUSH
7356: CALL_OW 113
// mikhailInbase = 3 ;
7360: LD_ADDR_EXP 22
7364: PUSH
7365: LD_INT 3
7367: ST_TO_ADDR
// end ; end ;
7368: GO 7371
7370: POP
// end ;
7371: LD_VAR 0 1
7375: RET
// every 1 trigger IsInArea ( Mikhail , MikhailEnter ) and mikhailInBase = 4 do
7376: LD_EXP 8
7380: PPUSH
7381: LD_INT 25
7383: PPUSH
7384: CALL_OW 308
7388: PUSH
7389: LD_EXP 22
7393: PUSH
7394: LD_INT 4
7396: EQUAL
7397: AND
7398: IFFALSE 7502
7400: GO 7402
7402: DISABLE
// begin enable ;
7403: ENABLE
// mikhailInBase = 1 ;
7404: LD_ADDR_EXP 22
7408: PUSH
7409: LD_INT 1
7411: ST_TO_ADDR
// InGameOn ;
7412: CALL_OW 8
// SetSide ( dep1 , 6 ) ;
7416: LD_INT 1
7418: PPUSH
7419: LD_INT 6
7421: PPUSH
7422: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
7426: LD_INT 35
7428: PPUSH
7429: CALL_OW 67
// if Carry ( Mikhail ) then
7433: LD_EXP 8
7437: PPUSH
7438: CALL_OW 281
7442: IFFALSE 7453
// ComUnload ( Mikhail ) ;
7444: LD_EXP 8
7448: PPUSH
7449: CALL_OW 159
// AddComEnterUnit ( Mikhail , dep1 ) ;
7453: LD_EXP 8
7457: PPUSH
7458: LD_INT 1
7460: PPUSH
7461: CALL_OW 180
// until IsInUnit ( Mikhail ) ;
7465: LD_EXP 8
7469: PPUSH
7470: CALL_OW 310
7474: IFFALSE 7426
// SetSide ( dep1 , 1 ) ;
7476: LD_INT 1
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: CALL_OW 235
// SetSide ( Mikhail , 1 ) ;
7486: LD_EXP 8
7490: PPUSH
7491: LD_INT 1
7493: PPUSH
7494: CALL_OW 235
// InGameOff ;
7498: CALL_OW 9
// end ;
7502: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) and not mikhailInBase = 3 do
7503: LD_EXP 8
7507: PPUSH
7508: CALL_OW 310
7512: PUSH
7513: LD_EXP 22
7517: PUSH
7518: LD_INT 3
7520: EQUAL
7521: NOT
7522: AND
7523: IFFALSE 7658
7525: GO 7527
7527: DISABLE
// begin enable ;
7528: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , IsInUnit ( Mikhail ) , 10 ] ] ) = 1 then
7529: LD_INT 22
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PUSH
7539: LD_INT 21
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 91
7551: PUSH
7552: LD_EXP 8
7556: PPUSH
7557: CALL_OW 310
7561: PUSH
7562: LD_INT 10
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PPUSH
7575: CALL_OW 69
7579: PUSH
7580: LD_INT 1
7582: EQUAL
7583: IFFALSE 7658
// begin mikhailStatus = 4 ;
7585: LD_ADDR_EXP 21
7589: PUSH
7590: LD_INT 4
7592: ST_TO_ADDR
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
7593: LD_INT 1
7595: PPUSH
7596: LD_INT 6
7598: PPUSH
7599: LD_INT 2
7601: PPUSH
7602: LD_INT 1
7604: PPUSH
7605: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7609: LD_EXP 8
7613: PPUSH
7614: LD_INT 6
7616: PPUSH
7617: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7621: LD_EXP 8
7625: PPUSH
7626: CALL_OW 122
// wait ( 0 0$1 ) ;
7630: LD_INT 35
7632: PPUSH
7633: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7637: LD_EXP 8
7641: PPUSH
7642: LD_INT 17
7644: PPUSH
7645: CALL_OW 113
// mikhailStatus = 3 ;
7649: LD_ADDR_EXP 21
7653: PUSH
7654: LD_INT 3
7656: ST_TO_ADDR
// disable ;
7657: DISABLE
// end ; end ;
7658: END
// every 0 0$1 trigger GetDistUnits ( JMM , mikhailDepot ) < 5 and mikhailStatus = 3 and not mikhailInBase = 3 do var tmp ;
7659: LD_EXP 1
7663: PPUSH
7664: LD_EXP 23
7668: PPUSH
7669: CALL_OW 296
7673: PUSH
7674: LD_INT 5
7676: LESS
7677: PUSH
7678: LD_EXP 21
7682: PUSH
7683: LD_INT 3
7685: EQUAL
7686: AND
7687: PUSH
7688: LD_EXP 22
7692: PUSH
7693: LD_INT 3
7695: EQUAL
7696: NOT
7697: AND
7698: IFFALSE 7920
7700: GO 7702
7702: DISABLE
7703: LD_INT 0
7705: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Khatam ] ;
7706: LD_ADDR_VAR 0 1
7710: PUSH
7711: LD_INT 22
7713: PUSH
7714: LD_INT 1
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: LD_INT 21
7723: PUSH
7724: LD_INT 1
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 26
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: LIST
7745: PPUSH
7746: CALL_OW 69
7750: PUSH
7751: LD_EXP 1
7755: PUSH
7756: LD_EXP 5
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: DIFF
7765: ST_TO_ADDR
// DialogueOn ;
7766: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
7770: LD_EXP 1
7774: PPUSH
7775: LD_STRING D7-JMM-1
7777: PPUSH
7778: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-1 ) ;
7782: LD_VAR 0 1
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: PPUSH
7791: LD_STRING D7-Sol1-1
7793: PPUSH
7794: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
7798: LD_EXP 1
7802: PPUSH
7803: LD_STRING D7-JMM-2
7805: PPUSH
7806: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-2 ) ;
7810: LD_VAR 0 1
7814: PUSH
7815: LD_INT 1
7817: ARRAY
7818: PPUSH
7819: LD_STRING D7-Sol1-2
7821: PPUSH
7822: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
7826: LD_EXP 1
7830: PPUSH
7831: LD_STRING D7-JMM-3
7833: PPUSH
7834: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-3 ) ;
7838: LD_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PPUSH
7847: LD_STRING D7-Sol1-3
7849: PPUSH
7850: CALL_OW 88
// if IsOK ( Cyrus ) and IsOK ( Lisa ) then
7854: LD_EXP 3
7858: PPUSH
7859: CALL_OW 302
7863: PUSH
7864: LD_EXP 4
7868: PPUSH
7869: CALL_OW 302
7873: AND
7874: IFFALSE 7916
// begin Say ( Cyrus , D7-Cyrus-3 ) ;
7876: LD_EXP 3
7880: PPUSH
7881: LD_STRING D7-Cyrus-3
7883: PPUSH
7884: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-4 ) ;
7888: LD_VAR 0 1
7892: PUSH
7893: LD_INT 1
7895: ARRAY
7896: PPUSH
7897: LD_STRING D7-Sol1-4
7899: PPUSH
7900: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
7904: LD_EXP 4
7908: PPUSH
7909: LD_STRING D7-Lisa-4
7911: PPUSH
7912: CALL_OW 88
// end ; DialogueOff ;
7916: CALL_OW 7
// end ;
7920: PPOPN 1
7922: END
// every 0 0$1 trigger IsDying ( Mikhail ) and mikhailStatus = 3 do
7923: LD_EXP 8
7927: PPUSH
7928: CALL_OW 303
7932: PUSH
7933: LD_EXP 21
7937: PUSH
7938: LD_INT 3
7940: EQUAL
7941: AND
7942: IFFALSE 7956
7944: GO 7946
7946: DISABLE
// begin enable ;
7947: ENABLE
// mikhailStatus = 2 ;
7948: LD_ADDR_EXP 21
7952: PUSH
7953: LD_INT 2
7955: ST_TO_ADDR
// end ;
7956: END
// every 0 0$1 trigger IsInArea ( Mikhail , MikhailEscape ) and GetSide ( Mikhail ) = 6 do
7957: LD_EXP 8
7961: PPUSH
7962: LD_INT 17
7964: PPUSH
7965: CALL_OW 308
7969: PUSH
7970: LD_EXP 8
7974: PPUSH
7975: CALL_OW 255
7979: PUSH
7980: LD_INT 6
7982: EQUAL
7983: AND
7984: IFFALSE 8017
7986: GO 7988
7988: DISABLE
// begin if not mikhailInBase = 3 then
7989: LD_EXP 22
7993: PUSH
7994: LD_INT 3
7996: EQUAL
7997: NOT
7998: IFFALSE 8008
// mikhailStatus = 3 ;
8000: LD_ADDR_EXP 21
8004: PUSH
8005: LD_INT 3
8007: ST_TO_ADDR
// RemoveUnit ( Mikhail ) ;
8008: LD_EXP 8
8012: PPUSH
8013: CALL_OW 64
// end ;
8017: END
// every 0 0$1 trigger mikhailStatus = 3 and GetSide ( Mikhail ) = 6 do var i , attacker ;
8018: LD_EXP 21
8022: PUSH
8023: LD_INT 3
8025: EQUAL
8026: PUSH
8027: LD_EXP 8
8031: PPUSH
8032: CALL_OW 255
8036: PUSH
8037: LD_INT 6
8039: EQUAL
8040: AND
8041: IFFALSE 8207
8043: GO 8045
8045: DISABLE
8046: LD_INT 0
8048: PPUSH
8049: PPUSH
// begin enable ;
8050: ENABLE
// if IsOk ( Mikhail ) then
8051: LD_EXP 8
8055: PPUSH
8056: CALL_OW 302
8060: IFFALSE 8207
// begin attacker = Nearest ( Mikhail , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
8062: LD_ADDR_VAR 0 2
8066: PUSH
8067: LD_EXP 8
8071: PPUSH
8072: LD_INT 22
8074: PUSH
8075: LD_INT 1
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 21
8084: PUSH
8085: LD_INT 1
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: PPUSH
8101: CALL 10178 0 2
8105: ST_TO_ADDR
// if GetDistUnits ( attacker , Mikhail ) < 8 then
8106: LD_VAR 0 2
8110: PPUSH
8111: LD_EXP 8
8115: PPUSH
8116: CALL_OW 296
8120: PUSH
8121: LD_INT 8
8123: LESS
8124: IFFALSE 8207
// begin if GetSex ( attacker ) = sex_male then
8126: LD_VAR 0 2
8130: PPUSH
8131: CALL_OW 258
8135: PUSH
8136: LD_INT 1
8138: EQUAL
8139: IFFALSE 8175
// begin disable ;
8141: DISABLE
// Say ( attacker , D7a-Sol1-1 ) ;
8142: LD_VAR 0 2
8146: PPUSH
8147: LD_STRING D7a-Sol1-1
8149: PPUSH
8150: CALL_OW 88
// wait ( 0 0$2 ) ;
8154: LD_INT 70
8156: PPUSH
8157: CALL_OW 67
// Say ( attacker , D7a-Sol1-1a ) ;
8161: LD_VAR 0 2
8165: PPUSH
8166: LD_STRING D7a-Sol1-1a
8168: PPUSH
8169: CALL_OW 88
// end else
8173: GO 8207
// begin disable ;
8175: DISABLE
// Say ( attacker , D7a-FSol1-1 ) ;
8176: LD_VAR 0 2
8180: PPUSH
8181: LD_STRING D7a-FSol1-1
8183: PPUSH
8184: CALL_OW 88
// wait ( 0 0$2 ) ;
8188: LD_INT 70
8190: PPUSH
8191: CALL_OW 67
// Say ( attacker , D7a-FSol1-1a ) ;
8195: LD_VAR 0 2
8199: PPUSH
8200: LD_STRING D7a-FSol1-1a
8202: PPUSH
8203: CALL_OW 88
// end ; end ; end ; end ;
8207: PPOPN 2
8209: END
// every 0 0$1 trigger LastBattle = 1 and FilterUnitsInArea ( NorthBase , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 2 and FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_occupied ] ] ] ) = 0 do
8210: LD_EXP 27
8214: PUSH
8215: LD_INT 1
8217: EQUAL
8218: PUSH
8219: LD_INT 22
8221: PPUSH
8222: LD_INT 22
8224: PUSH
8225: LD_INT 3
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 21
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: EMPTY
8243: LIST
8244: LIST
8245: PPUSH
8246: CALL_OW 70
8250: PUSH
8251: LD_INT 2
8253: GREATER
8254: AND
8255: PUSH
8256: LD_INT 22
8258: PPUSH
8259: LD_INT 22
8261: PUSH
8262: LD_INT 1
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 2
8271: PUSH
8272: LD_INT 21
8274: PUSH
8275: LD_INT 1
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: PUSH
8282: LD_INT 59
8284: PUSH
8285: EMPTY
8286: LIST
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: LIST
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PPUSH
8297: CALL_OW 70
8301: PUSH
8302: LD_INT 0
8304: EQUAL
8305: AND
8306: IFFALSE 8321
8308: GO 8310
8310: DISABLE
// begin SetSide ( dep1 , 3 ) ;
8311: LD_INT 1
8313: PPUSH
8314: LD_INT 3
8316: PPUSH
8317: CALL_OW 235
// end ;
8321: END
// every 0 0$1 trigger tigersRespawn = 1 and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , 14 ] ] ) = 0 do var i , tmp ;
8322: LD_EXP 30
8326: PUSH
8327: LD_INT 1
8329: EQUAL
8330: PUSH
8331: LD_INT 22
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: EMPTY
8338: LIST
8339: LIST
8340: PUSH
8341: LD_INT 25
8343: PUSH
8344: LD_INT 14
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PPUSH
8355: CALL_OW 69
8359: PUSH
8360: LD_INT 0
8362: EQUAL
8363: AND
8364: IFFALSE 8465
8366: GO 8368
8368: DISABLE
8369: LD_INT 0
8371: PPUSH
8372: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) ;
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 21
8390: PUSH
8391: LD_INT 1
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 23
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: PPUSH
8413: CALL_OW 69
8417: ST_TO_ADDR
// for i in tmp do
8418: LD_ADDR_VAR 0 1
8422: PUSH
8423: LD_VAR 0 2
8427: PUSH
8428: FOR_IN
8429: IFFALSE 8456
// AddExperience ( i , rand ( 1 , 4 ) , 300 ) ;
8431: LD_VAR 0 1
8435: PPUSH
8436: LD_INT 1
8438: PPUSH
8439: LD_INT 4
8441: PPUSH
8442: CALL_OW 12
8446: PPUSH
8447: LD_INT 300
8449: PPUSH
8450: CALL_OW 492
8454: GO 8428
8456: POP
8457: POP
// SetAchievement ( ACH_TIGER ) ;
8458: LD_STRING ACH_TIGER
8460: PPUSH
8461: CALL_OW 543
// end ;
8465: PPOPN 2
8467: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] ] ) >= 2 do
8468: LD_INT 22
8470: PUSH
8471: LD_INT 1
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PUSH
8478: LD_INT 34
8480: PUSH
8481: LD_INT 51
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PPUSH
8492: CALL_OW 69
8496: PUSH
8497: LD_INT 2
8499: GREATEREQUAL
8500: IFFALSE 8512
8502: GO 8504
8504: DISABLE
// SetAchievement ( ACH_CARGO ) ; end_of_file
8505: LD_STRING ACH_CARGO
8507: PPUSH
8508: CALL_OW 543
8512: END
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
8513: LD_INT 0
8515: PPUSH
8516: PPUSH
8517: PPUSH
8518: PPUSH
// for i = 1 to count do
8519: LD_ADDR_VAR 0 8
8523: PUSH
8524: DOUBLE
8525: LD_INT 1
8527: DEC
8528: ST_TO_ADDR
8529: LD_VAR 0 6
8533: PUSH
8534: FOR_TO
8535: IFFALSE 8616
// begin uc_side = side ;
8537: LD_ADDR_OWVAR 20
8541: PUSH
8542: LD_VAR 0 1
8546: ST_TO_ADDR
// uc_nation = nation ;
8547: LD_ADDR_OWVAR 21
8551: PUSH
8552: LD_VAR 0 2
8556: ST_TO_ADDR
// hc_gallery =  ;
8557: LD_ADDR_OWVAR 33
8561: PUSH
8562: LD_STRING 
8564: ST_TO_ADDR
// hc_name =  ;
8565: LD_ADDR_OWVAR 26
8569: PUSH
8570: LD_STRING 
8572: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_VAR 0 5
8580: PPUSH
8581: LD_VAR 0 4
8585: PPUSH
8586: CALL_OW 380
// un = CreateHuman ;
8590: LD_ADDR_VAR 0 10
8594: PUSH
8595: CALL_OW 44
8599: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
8600: LD_VAR 0 10
8604: PPUSH
8605: LD_VAR 0 3
8609: PPUSH
8610: CALL_OW 52
// end ;
8614: GO 8534
8616: POP
8617: POP
// end ;
8618: LD_VAR 0 7
8622: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
8623: LD_INT 0
8625: PPUSH
8626: PPUSH
8627: PPUSH
// uc_side := GetSide ( b ) ;
8628: LD_ADDR_OWVAR 20
8632: PUSH
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 255
8642: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_VAR 0 2
8652: PPUSH
8653: CALL_OW 248
8657: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
8658: LD_INT 0
8660: PPUSH
8661: LD_INT 1
8663: PPUSH
8664: LD_VAR 0 1
8668: PPUSH
8669: CALL_OW 380
// un = CreateHuman ;
8673: LD_ADDR_VAR 0 4
8677: PUSH
8678: CALL_OW 44
8682: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 254
8697: PUSH
8698: LD_INT 3
8700: MINUS
8701: ST_TO_ADDR
// if dir < 0 then
8702: LD_VAR 0 5
8706: PUSH
8707: LD_INT 0
8709: LESS
8710: IFFALSE 8726
// dir := 6 + dir ;
8712: LD_ADDR_VAR 0 5
8716: PUSH
8717: LD_INT 6
8719: PUSH
8720: LD_VAR 0 5
8724: PLUS
8725: ST_TO_ADDR
// SetDir ( un , dir ) ;
8726: LD_VAR 0 4
8730: PPUSH
8731: LD_VAR 0 5
8735: PPUSH
8736: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_VAR 0 2
8749: PPUSH
8750: CALL_OW 52
// end ;
8754: LD_VAR 0 3
8758: RET
// export function RepairBuilding ( side , building , area ) ; var buildings_list , i , engineerOk_list , j ; begin
8759: LD_INT 0
8761: PPUSH
8762: PPUSH
8763: PPUSH
8764: PPUSH
8765: PPUSH
// engineerOk_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
8766: LD_ADDR_VAR 0 7
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_VAR 0 1
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PUSH
8783: LD_INT 25
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PUSH
8793: LD_INT 24
8795: PUSH
8796: LD_INT 1000
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: LIST
8807: PPUSH
8808: CALL_OW 69
8812: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( area , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
8813: LD_ADDR_VAR 0 5
8817: PUSH
8818: LD_VAR 0 3
8822: PPUSH
8823: LD_INT 22
8825: PUSH
8826: LD_VAR 0 1
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 21
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: LD_INT 3
8847: PUSH
8848: LD_INT 24
8850: PUSH
8851: LD_INT 1000
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: PPUSH
8870: CALL_OW 70
8874: ST_TO_ADDR
// if buildings_list > 0 and engineerOk_list > 0 then
8875: LD_VAR 0 5
8879: PUSH
8880: LD_INT 0
8882: GREATER
8883: PUSH
8884: LD_VAR 0 7
8888: PUSH
8889: LD_INT 0
8891: GREATER
8892: AND
8893: IFFALSE 8959
// begin for i in engineerOk_list do
8895: LD_ADDR_VAR 0 6
8899: PUSH
8900: LD_VAR 0 7
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8957
// begin for j in buildings_list do
8908: LD_ADDR_VAR 0 8
8912: PUSH
8913: LD_VAR 0 5
8917: PUSH
8918: FOR_IN
8919: IFFALSE 8953
// begin AddComExitBuilding ( i ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 182
// wait ( 0 0$1 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// AddComRepairBuilding ( i , j ) ;
8937: LD_VAR 0 6
8941: PPUSH
8942: LD_VAR 0 8
8946: PPUSH
8947: CALL_OW 190
// end ;
8951: GO 8918
8953: POP
8954: POP
// end ;
8955: GO 8905
8957: POP
8958: POP
// end ; if buildings_list = 0 then
8959: LD_VAR 0 5
8963: PUSH
8964: LD_INT 0
8966: EQUAL
8967: IFFALSE 9000
// begin for i in engineerOK_list do
8969: LD_ADDR_VAR 0 6
8973: PUSH
8974: LD_VAR 0 7
8978: PUSH
8979: FOR_IN
8980: IFFALSE 8998
// begin ComEnterUnit ( i , building ) ;
8982: LD_VAR 0 6
8986: PPUSH
8987: LD_VAR 0 2
8991: PPUSH
8992: CALL_OW 120
// end ;
8996: GO 8979
8998: POP
8999: POP
// end ; end ;
9000: LD_VAR 0 4
9004: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , i , j , damageUnits ; begin
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
9010: PPUSH
9011: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 250 ] ] ) ;
9012: LD_ADDR_VAR 0 6
9016: PUSH
9017: LD_INT 22
9019: PUSH
9020: LD_VAR 0 1
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: PUSH
9029: LD_INT 25
9031: PUSH
9032: LD_INT 4
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PUSH
9039: LD_INT 24
9041: PUSH
9042: LD_INT 250
9044: PUSH
9045: EMPTY
9046: LIST
9047: LIST
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: PPUSH
9054: CALL_OW 69
9058: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
9059: LD_ADDR_VAR 0 9
9063: PUSH
9064: LD_VAR 0 3
9068: PPUSH
9069: LD_INT 22
9071: PUSH
9072: LD_VAR 0 1
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PUSH
9081: LD_INT 21
9083: PUSH
9084: LD_INT 1
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: PUSH
9091: LD_INT 3
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: LD_INT 650
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: PPUSH
9113: CALL_OW 70
9117: ST_TO_ADDR
// if damageUnits > 0 and sci_list > 0 then
9118: LD_VAR 0 9
9122: PUSH
9123: LD_INT 0
9125: GREATER
9126: PUSH
9127: LD_VAR 0 6
9131: PUSH
9132: LD_INT 0
9134: GREATER
9135: AND
9136: IFFALSE 9263
// begin for i = 1 to damageUnits do
9138: LD_ADDR_VAR 0 7
9142: PUSH
9143: DOUBLE
9144: LD_INT 1
9146: DEC
9147: ST_TO_ADDR
9148: LD_VAR 0 9
9152: PUSH
9153: FOR_TO
9154: IFFALSE 9178
// ComMoveToArea ( damageUnits [ i ] , healArea ) ;
9156: LD_VAR 0 9
9160: PUSH
9161: LD_VAR 0 7
9165: ARRAY
9166: PPUSH
9167: LD_VAR 0 2
9171: PPUSH
9172: CALL_OW 113
9176: GO 9153
9178: POP
9179: POP
// for i in sci_list do
9180: LD_ADDR_VAR 0 7
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: FOR_IN
9191: IFFALSE 9259
// begin ComExitBuilding ( i ) ;
9193: LD_VAR 0 7
9197: PPUSH
9198: CALL_OW 122
// for j in FilterUnitsInArea ( healArea , [ f_side , side ] ) do
9202: LD_ADDR_VAR 0 8
9206: PUSH
9207: LD_VAR 0 2
9211: PPUSH
9212: LD_INT 22
9214: PUSH
9215: LD_VAR 0 1
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: PPUSH
9224: CALL_OW 70
9228: PUSH
9229: FOR_IN
9230: IFFALSE 9255
// begin AddComHeal ( i , j ) ;
9232: LD_VAR 0 7
9236: PPUSH
9237: LD_VAR 0 8
9241: PPUSH
9242: CALL_OW 188
// wait ( 1 1$0 ) ;
9246: LD_INT 2100
9248: PPUSH
9249: CALL_OW 67
// end ;
9253: GO 9229
9255: POP
9256: POP
// end ;
9257: GO 9190
9259: POP
9260: POP
// end else
9261: GO 9277
// begin AddComEnterUnit ( sci_list , build ) ;
9263: LD_VAR 0 6
9267: PPUSH
9268: LD_VAR 0 4
9272: PPUSH
9273: CALL_OW 180
// end ; end ;
9277: LD_VAR 0 5
9281: RET
// export function RepairVehicle ( side , repairArea , area ) ; var i , j , vehicleOK_list , damageVehicle_list , emptyVehicle_list , mechanicInside_list , mechanicOutside_list ; begin
9282: LD_INT 0
9284: PPUSH
9285: PPUSH
9286: PPUSH
9287: PPUSH
9288: PPUSH
9289: PPUSH
9290: PPUSH
9291: PPUSH
// vehicleOK_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 550 ] , [ f_weapon , 46 ] ] ) ;
9292: LD_ADDR_VAR 0 7
9296: PUSH
9297: LD_VAR 0 3
9301: PPUSH
9302: LD_INT 22
9304: PUSH
9305: LD_VAR 0 1
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 21
9316: PUSH
9317: LD_INT 2
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 24
9326: PUSH
9327: LD_INT 550
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 34
9336: PUSH
9337: LD_INT 46
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 70
9354: ST_TO_ADDR
// damageVehicle_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_not , [ f_lives , 550 ] ] ] ) ;
9355: LD_ADDR_VAR 0 8
9359: PUSH
9360: LD_VAR 0 3
9364: PPUSH
9365: LD_INT 22
9367: PUSH
9368: LD_VAR 0 1
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: LD_INT 34
9389: PUSH
9390: LD_INT 46
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: PUSH
9397: LD_INT 3
9399: PUSH
9400: LD_INT 24
9402: PUSH
9403: LD_INT 550
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 70
9424: ST_TO_ADDR
// emptyVehicle_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
9425: LD_ADDR_VAR 0 9
9429: PUSH
9430: LD_VAR 0 2
9434: PPUSH
9435: LD_INT 22
9437: PUSH
9438: LD_VAR 0 1
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: LD_INT 21
9449: PUSH
9450: LD_INT 2
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: PUSH
9457: LD_INT 34
9459: PUSH
9460: LD_INT 46
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PUSH
9467: LD_INT 24
9469: PUSH
9470: LD_INT 1000
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 58
9479: PUSH
9480: EMPTY
9481: LIST
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: PPUSH
9490: CALL_OW 70
9494: ST_TO_ADDR
// for i in damageVehicle_list do
9495: LD_ADDR_VAR 0 5
9499: PUSH
9500: LD_VAR 0 8
9504: PUSH
9505: FOR_IN
9506: IFFALSE 9525
// mechanicInside_list = UnitsInside ( i ) ;
9508: LD_ADDR_VAR 0 10
9512: PUSH
9513: LD_VAR 0 5
9517: PPUSH
9518: CALL_OW 313
9522: ST_TO_ADDR
9523: GO 9505
9525: POP
9526: POP
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
9527: LD_ADDR_VAR 0 11
9531: PUSH
9532: LD_VAR 0 2
9536: PPUSH
9537: LD_INT 22
9539: PUSH
9540: LD_VAR 0 1
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 25
9551: PUSH
9552: LD_INT 3
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PPUSH
9563: CALL_OW 70
9567: ST_TO_ADDR
// if damageVehicle_list > 0 then
9568: LD_VAR 0 8
9572: PUSH
9573: LD_INT 0
9575: GREATER
9576: IFFALSE 9649
// begin for i in damageVehicle_list do
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_VAR 0 8
9587: PUSH
9588: FOR_IN
9589: IFFALSE 9647
// begin for j in mechanicInside_list do
9591: LD_ADDR_VAR 0 6
9595: PUSH
9596: LD_VAR 0 10
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9643
// begin ComMoveToArea ( damageVehicle_list , repairArea ) ;
9604: LD_VAR 0 8
9608: PPUSH
9609: LD_VAR 0 2
9613: PPUSH
9614: CALL_OW 113
// AddComExitVehicle ( j ) ;
9618: LD_VAR 0 6
9622: PPUSH
9623: CALL_OW 181
// AddComRepairVehicle ( j , i ) ;
9627: LD_VAR 0 6
9631: PPUSH
9632: LD_VAR 0 5
9636: PPUSH
9637: CALL_OW 189
// end ;
9641: GO 9601
9643: POP
9644: POP
// end ;
9645: GO 9588
9647: POP
9648: POP
// end ; if emptyVehicle_list > 0 then
9649: LD_VAR 0 9
9653: PUSH
9654: LD_INT 0
9656: GREATER
9657: IFFALSE 9707
// begin for i in emptyVehicle_list do
9659: LD_ADDR_VAR 0 5
9663: PUSH
9664: LD_VAR 0 9
9668: PUSH
9669: FOR_IN
9670: IFFALSE 9705
// begin for j in mechanicOutside_list do
9672: LD_ADDR_VAR 0 6
9676: PUSH
9677: LD_VAR 0 11
9681: PUSH
9682: FOR_IN
9683: IFFALSE 9701
// begin AddComEnterUnit ( j , i ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: CALL_OW 180
// end ;
9699: GO 9682
9701: POP
9702: POP
// end ;
9703: GO 9669
9705: POP
9706: POP
// end ; if VehicleOK_list > 0 then
9707: LD_VAR 0 7
9711: PUSH
9712: LD_INT 0
9714: GREATER
9715: IFFALSE 9749
// begin for i in VehicleOK_list do
9717: LD_ADDR_VAR 0 5
9721: PUSH
9722: LD_VAR 0 7
9726: PUSH
9727: FOR_IN
9728: IFFALSE 9747
// ComAgressiveMove ( i , 110 , 29 ) ;
9730: LD_VAR 0 5
9734: PPUSH
9735: LD_INT 110
9737: PPUSH
9738: LD_INT 29
9740: PPUSH
9741: CALL_OW 114
9745: GO 9727
9747: POP
9748: POP
// end ; end ;
9749: LD_VAR 0 4
9753: RET
// export function DefendBases ( area , enemySide , defendersList , build , count ) ; var i , j ; begin
9754: LD_INT 0
9756: PPUSH
9757: PPUSH
9758: PPUSH
// if FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) > count then
9759: LD_VAR 0 1
9763: PPUSH
9764: LD_INT 22
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 2
9778: PUSH
9779: LD_INT 21
9781: PUSH
9782: LD_INT 2
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PUSH
9789: LD_INT 21
9791: PUSH
9792: LD_INT 1
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 70
9812: PUSH
9813: LD_VAR 0 5
9817: GREATER
9818: IFFALSE 9950
// begin for i in defendersList do
9820: LD_ADDR_VAR 0 7
9824: PUSH
9825: LD_VAR 0 3
9829: PUSH
9830: FOR_IN
9831: IFFALSE 9946
// begin AddComExitBuilding ( i ) ;
9833: LD_VAR 0 7
9837: PPUSH
9838: CALL_OW 182
// wait ( 0 0$1 ) ;
9842: LD_INT 35
9844: PPUSH
9845: CALL_OW 67
// for j in FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) do
9849: LD_ADDR_VAR 0 8
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: LD_INT 22
9861: PUSH
9862: LD_VAR 0 2
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 2
9873: PUSH
9874: LD_INT 21
9876: PUSH
9877: LD_INT 2
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PUSH
9884: LD_INT 21
9886: PUSH
9887: LD_INT 1
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 70
9907: PUSH
9908: FOR_IN
9909: IFFALSE 9942
// AddComAgressiveMove ( i , GetX ( j ) , GetY ( j ) ) ;
9911: LD_VAR 0 7
9915: PPUSH
9916: LD_VAR 0 8
9920: PPUSH
9921: CALL_OW 250
9925: PPUSH
9926: LD_VAR 0 8
9930: PPUSH
9931: CALL_OW 251
9935: PPUSH
9936: CALL_OW 174
9940: GO 9908
9942: POP
9943: POP
// end ;
9944: GO 9830
9946: POP
9947: POP
// end else
9948: GO 9981
// begin for i in defendersList do
9950: LD_ADDR_VAR 0 7
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 9979
// ComEnterUnit ( i , build ) ;
9963: LD_VAR 0 7
9967: PPUSH
9968: LD_VAR 0 4
9972: PPUSH
9973: CALL_OW 120
9977: GO 9960
9979: POP
9980: POP
// end ; end ;
9981: LD_VAR 0 6
9985: RET
// export function RussianTrap ; var i ; begin
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
// if GetSide ( Brian ) = 4 then
9990: LD_EXP 6
9994: PPUSH
9995: CALL_OW 255
9999: PUSH
10000: LD_INT 4
10002: EQUAL
10003: IFFALSE 10026
// SetLives ( [ Brian , Jerry ] , 0 ) ;
10005: LD_EXP 6
10009: PUSH
10010: LD_EXP 7
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PPUSH
10019: LD_INT 0
10021: PPUSH
10022: CALL_OW 234
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
10026: LD_ADDR_VAR 0 2
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 21
10043: PUSH
10044: LD_INT 1
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: PUSH
10060: FOR_IN
10061: IFFALSE 10171
// begin ComExitBuilding ( i ) ;
10063: LD_VAR 0 2
10067: PPUSH
10068: CALL_OW 122
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: CALL_OW 67
// AddComAgressiveMove ( i , 120 , 56 ) ;
10079: LD_VAR 0 2
10083: PPUSH
10084: LD_INT 120
10086: PPUSH
10087: LD_INT 56
10089: PPUSH
10090: CALL_OW 174
// AddComAgressiveMove ( i , 111 , 37 ) ;
10094: LD_VAR 0 2
10098: PPUSH
10099: LD_INT 111
10101: PPUSH
10102: LD_INT 37
10104: PPUSH
10105: CALL_OW 174
// if GetSide ( arm2 ) = 3 and IsOk ( arm2 ) then
10109: LD_INT 33
10111: PPUSH
10112: CALL_OW 255
10116: PUSH
10117: LD_INT 3
10119: EQUAL
10120: PUSH
10121: LD_INT 33
10123: PPUSH
10124: CALL_OW 302
10128: AND
10129: IFFALSE 10145
// begin AddComEnterUnit ( i , arm2 ) ;
10131: LD_VAR 0 2
10135: PPUSH
10136: LD_INT 33
10138: PPUSH
10139: CALL_OW 180
// end else
10143: GO 10169
// begin AddComCrawl ( i ) ;
10145: LD_VAR 0 2
10149: PPUSH
10150: CALL_OW 197
// AddComAgressiveMove ( i , 109 , 30 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 109
10161: PPUSH
10162: LD_INT 30
10164: PPUSH
10165: CALL_OW 174
// end ; end ;
10169: GO 10060
10171: POP
10172: POP
// end ;
10173: LD_VAR 0 1
10177: RET
// export function Nearest ( un , units ) ; var nearest_dist , nearest_un , sold , dist ; begin
10178: LD_INT 0
10180: PPUSH
10181: PPUSH
10182: PPUSH
10183: PPUSH
10184: PPUSH
// nearest_dist = 1000 ;
10185: LD_ADDR_VAR 0 4
10189: PUSH
10190: LD_INT 1000
10192: ST_TO_ADDR
// nearest_un = un ;
10193: LD_ADDR_VAR 0 5
10197: PUSH
10198: LD_VAR 0 1
10202: ST_TO_ADDR
// for sold in units do
10203: LD_ADDR_VAR 0 6
10207: PUSH
10208: LD_VAR 0 2
10212: PUSH
10213: FOR_IN
10214: IFFALSE 10270
// begin dist = GetDistUnits ( un , sold ) ;
10216: LD_ADDR_VAR 0 7
10220: PUSH
10221: LD_VAR 0 1
10225: PPUSH
10226: LD_VAR 0 6
10230: PPUSH
10231: CALL_OW 296
10235: ST_TO_ADDR
// if dist < nearest_dist then
10236: LD_VAR 0 7
10240: PUSH
10241: LD_VAR 0 4
10245: LESS
10246: IFFALSE 10268
// begin nearest_un = sold ;
10248: LD_ADDR_VAR 0 5
10252: PUSH
10253: LD_VAR 0 6
10257: ST_TO_ADDR
// nearest_dist = dist ;
10258: LD_ADDR_VAR 0 4
10262: PUSH
10263: LD_VAR 0 7
10267: ST_TO_ADDR
// end ; end ;
10268: GO 10213
10270: POP
10271: POP
// result := nearest_un ;
10272: LD_ADDR_VAR 0 3
10276: PUSH
10277: LD_VAR 0 5
10281: ST_TO_ADDR
// end ;
10282: LD_VAR 0 3
10286: RET
// export function PrepareDifficulty ; begin
10287: LD_INT 0
10289: PPUSH
// if Difficulty = 1 then
10290: LD_OWVAR 67
10294: PUSH
10295: LD_INT 1
10297: EQUAL
10298: IFFALSE 10361
// begin RemoveUnit ( brw2 ) ;
10300: LD_INT 9
10302: PPUSH
10303: CALL_OW 64
// RemoveUnit ( brw3 ) ;
10307: LD_INT 30
10309: PPUSH
10310: CALL_OW 64
// RemoveUnit ( brw4 ) ;
10314: LD_INT 52
10316: PPUSH
10317: CALL_OW 64
// RemoveUnit ( brw5 ) ;
10321: LD_INT 63
10323: PPUSH
10324: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 60 ) ;
10328: LD_INT 5
10330: PUSH
10331: LD_INT 4
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PPUSH
10338: LD_INT 60
10340: PPUSH
10341: CALL_OW 240
// RuSoldMinLevel = 0 ;
10345: LD_ADDR_EXP 13
10349: PUSH
10350: LD_INT 0
10352: ST_TO_ADDR
// RuSoldMaxLevel = 1 ;
10353: LD_ADDR_EXP 14
10357: PUSH
10358: LD_INT 1
10360: ST_TO_ADDR
// end ; if Difficulty = 2 then
10361: LD_OWVAR 67
10365: PUSH
10366: LD_INT 2
10368: EQUAL
10369: IFFALSE 10411
// begin RemoveUnit ( brw4 ) ;
10371: LD_INT 52
10373: PPUSH
10374: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 50 ) ;
10378: LD_INT 5
10380: PUSH
10381: LD_INT 4
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: PPUSH
10388: LD_INT 50
10390: PPUSH
10391: CALL_OW 240
// RuSoldMinLevel = 1 ;
10395: LD_ADDR_EXP 13
10399: PUSH
10400: LD_INT 1
10402: ST_TO_ADDR
// RuSoldMaxLevel = 2 ;
10403: LD_ADDR_EXP 14
10407: PUSH
10408: LD_INT 2
10410: ST_TO_ADDR
// end ; if Difficulty = 3 then
10411: LD_OWVAR 67
10415: PUSH
10416: LD_INT 3
10418: EQUAL
10419: IFFALSE 10454
// begin SetFuel ( [ vehicle1 , vehicle2 ] , 40 ) ;
10421: LD_INT 5
10423: PUSH
10424: LD_INT 4
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: PPUSH
10431: LD_INT 40
10433: PPUSH
10434: CALL_OW 240
// RuSoldMinLevel = 2 ;
10438: LD_ADDR_EXP 13
10442: PUSH
10443: LD_INT 2
10445: ST_TO_ADDR
// RuSoldMaxLevel = 3 ;
10446: LD_ADDR_EXP 14
10450: PUSH
10451: LD_INT 3
10453: ST_TO_ADDR
// end ; end ;
10454: LD_VAR 0 1
10458: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
10459: LD_INT 0
10461: PPUSH
10462: PPUSH
10463: PPUSH
// tmp = [ ] ;
10464: LD_ADDR_VAR 0 5
10468: PUSH
10469: EMPTY
10470: ST_TO_ADDR
// if not vehicles then
10471: LD_VAR 0 1
10475: NOT
10476: IFFALSE 10480
// exit ;
10478: GO 10597
// for i in vehicles do
10480: LD_ADDR_VAR 0 4
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: FOR_IN
10491: IFFALSE 10581
// begin tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
10493: LD_ADDR_VAR 0 5
10497: PUSH
10498: LD_VAR 0 5
10502: PPUSH
10503: LD_INT 1
10505: PPUSH
10506: LD_VAR 0 4
10510: PPUSH
10511: CALL_OW 265
10515: PUSH
10516: LD_VAR 0 4
10520: PPUSH
10521: CALL_OW 262
10525: PUSH
10526: LD_VAR 0 4
10530: PPUSH
10531: CALL_OW 263
10535: PUSH
10536: LD_VAR 0 4
10540: PPUSH
10541: CALL_OW 264
10545: PUSH
10546: LD_VAR 0 4
10550: PPUSH
10551: CALL_OW 261
10555: PUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL_OW 256
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PPUSH
10574: CALL_OW 2
10578: ST_TO_ADDR
// end ;
10579: GO 10490
10581: POP
10582: POP
// SaveVariable ( tmp , ident ) ;
10583: LD_VAR 0 5
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 39
// end ; end_of_file
10597: LD_VAR 0 3
10601: RET
// export function PrepareHeroes ; var plive ; begin
10602: LD_INT 0
10604: PPUSH
10605: PPUSH
// uc_side = 1 ;
10606: LD_ADDR_OWVAR 20
10610: PUSH
10611: LD_INT 1
10613: ST_TO_ADDR
// JMM = CreateCharacter ( 01_JMM ) ;
10614: LD_ADDR_EXP 1
10618: PUSH
10619: LD_STRING 01_JMM
10621: PPUSH
10622: CALL_OW 34
10626: ST_TO_ADDR
// plive := LoadVariable ( 01_JMMLifePoints_1 , 1000 ) ;
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_STRING 01_JMMLifePoints_1
10634: PPUSH
10635: LD_INT 1000
10637: PPUSH
10638: CALL_OW 30
10642: ST_TO_ADDR
// if plive < 250 then
10643: LD_VAR 0 2
10647: PUSH
10648: LD_INT 250
10650: LESS
10651: IFFALSE 10661
// plive := 300 ;
10653: LD_ADDR_VAR 0 2
10657: PUSH
10658: LD_INT 300
10660: ST_TO_ADDR
// SetLives ( JMM , plive ) ;
10661: LD_EXP 1
10665: PPUSH
10666: LD_VAR 0 2
10670: PPUSH
10671: CALL_OW 234
// Powell = NewCharacter ( Powell ) ;
10675: LD_ADDR_EXP 9
10679: PUSH
10680: LD_STRING Powell
10682: PPUSH
10683: CALL_OW 25
10687: ST_TO_ADDR
// Bobby = CreateCharacter ( 01_Bobby ) ;
10688: LD_ADDR_EXP 2
10692: PUSH
10693: LD_STRING 01_Bobby
10695: PPUSH
10696: CALL_OW 34
10700: ST_TO_ADDR
// if Bobby then
10701: LD_EXP 2
10705: IFFALSE 10755
// begin plive := LoadVariable ( 01_BobbyLifePoints_1 , 1000 ) ;
10707: LD_ADDR_VAR 0 2
10711: PUSH
10712: LD_STRING 01_BobbyLifePoints_1
10714: PPUSH
10715: LD_INT 1000
10717: PPUSH
10718: CALL_OW 30
10722: ST_TO_ADDR
// if plive < 250 then
10723: LD_VAR 0 2
10727: PUSH
10728: LD_INT 250
10730: LESS
10731: IFFALSE 10741
// plive := 300 ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 300
10740: ST_TO_ADDR
// SetLives ( Bobby , plive ) ;
10741: LD_EXP 2
10745: PPUSH
10746: LD_VAR 0 2
10750: PPUSH
10751: CALL_OW 234
// end ; Cyrus = CreateCharacter ( 01_Cyrus ) ;
10755: LD_ADDR_EXP 3
10759: PUSH
10760: LD_STRING 01_Cyrus
10762: PPUSH
10763: CALL_OW 34
10767: ST_TO_ADDR
// if Cyrus then
10768: LD_EXP 3
10772: IFFALSE 10822
// begin plive := LoadVariable ( 01_CyrusLifePoints_1 , 1000 ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_STRING 01_CyrusLifePoints_1
10781: PPUSH
10782: LD_INT 1000
10784: PPUSH
10785: CALL_OW 30
10789: ST_TO_ADDR
// if plive < 250 then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_INT 250
10797: LESS
10798: IFFALSE 10808
// plive := 300 ;
10800: LD_ADDR_VAR 0 2
10804: PUSH
10805: LD_INT 300
10807: ST_TO_ADDR
// SetLives ( Cyrus , plive ) ;
10808: LD_EXP 3
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 234
// end ; Khatam = NewCharacter ( Khatam ) ;
10822: LD_ADDR_EXP 5
10826: PUSH
10827: LD_STRING Khatam
10829: PPUSH
10830: CALL_OW 25
10834: ST_TO_ADDR
// uc_side = 4 ;
10835: LD_ADDR_OWVAR 20
10839: PUSH
10840: LD_INT 4
10842: ST_TO_ADDR
// Lisa = NewCharacter ( Lisa ) ;
10843: LD_ADDR_EXP 4
10847: PUSH
10848: LD_STRING Lisa
10850: PPUSH
10851: CALL_OW 25
10855: ST_TO_ADDR
// PlaceUnitArea ( JMM , StartArea , false ) ;
10856: LD_EXP 1
10860: PPUSH
10861: LD_INT 3
10863: PPUSH
10864: LD_INT 0
10866: PPUSH
10867: CALL_OW 49
// PlaceUnitArea ( Bobby , StartArea , false ) ;
10871: LD_EXP 2
10875: PPUSH
10876: LD_INT 3
10878: PPUSH
10879: LD_INT 0
10881: PPUSH
10882: CALL_OW 49
// PlaceUnitArea ( Cyrus , StartArea , false ) ;
10886: LD_EXP 3
10890: PPUSH
10891: LD_INT 3
10893: PPUSH
10894: LD_INT 0
10896: PPUSH
10897: CALL_OW 49
// PlaceUnitArea ( Lisa , LisaSpawn , false ) ;
10901: LD_EXP 4
10905: PPUSH
10906: LD_INT 5
10908: PPUSH
10909: LD_INT 0
10911: PPUSH
10912: CALL_OW 49
// ComCrawl ( Lisa ) ;
10916: LD_EXP 4
10920: PPUSH
10921: CALL_OW 137
// end ;
10925: LD_VAR 0 1
10929: RET
// export function PrepareLisSquad ; var i , un ; begin
10930: LD_INT 0
10932: PPUSH
10933: PPUSH
10934: PPUSH
// uc_side = 4 ;
10935: LD_ADDR_OWVAR 20
10939: PUSH
10940: LD_INT 4
10942: ST_TO_ADDR
// uc_nation = 1 ;
10943: LD_ADDR_OWVAR 21
10947: PUSH
10948: LD_INT 1
10950: ST_TO_ADDR
// hc_class := 2 ;
10951: LD_ADDR_OWVAR 28
10955: PUSH
10956: LD_INT 2
10958: ST_TO_ADDR
// hc_sex := sex_male ;
10959: LD_ADDR_OWVAR 27
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// hc_gallery :=  ;
10967: LD_ADDR_OWVAR 33
10971: PUSH
10972: LD_STRING 
10974: ST_TO_ADDR
// hc_name :=  ;
10975: LD_ADDR_OWVAR 26
10979: PUSH
10980: LD_STRING 
10982: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 0 , 0 ] ;
10983: LD_ADDR_OWVAR 30
10987: PUSH
10988: LD_INT 0
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: LD_INT 0
10996: PUSH
10997: LD_INT 0
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: ST_TO_ADDR
// hc_skills := [ 1 , 2 , 0 , 0 ] ;
11006: LD_ADDR_OWVAR 31
11010: PUSH
11011: LD_INT 1
11013: PUSH
11014: LD_INT 2
11016: PUSH
11017: LD_INT 0
11019: PUSH
11020: LD_INT 0
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: ST_TO_ADDR
// un := CreateHuman ;
11029: LD_ADDR_VAR 0 3
11033: PUSH
11034: CALL_OW 44
11038: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11039: LD_VAR 0 3
11043: PPUSH
11044: LD_INT 6
11046: PPUSH
11047: LD_INT 0
11049: PPUSH
11050: CALL_OW 49
// hc_sex := sex_female ;
11054: LD_ADDR_OWVAR 27
11058: PUSH
11059: LD_INT 2
11061: ST_TO_ADDR
// hc_gallery :=  ;
11062: LD_ADDR_OWVAR 33
11066: PUSH
11067: LD_STRING 
11069: ST_TO_ADDR
// hc_name :=  ;
11070: LD_ADDR_OWVAR 26
11074: PUSH
11075: LD_STRING 
11077: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 1 ] ;
11078: LD_ADDR_OWVAR 30
11082: PUSH
11083: LD_INT 0
11085: PUSH
11086: LD_INT 0
11088: PUSH
11089: LD_INT 0
11091: PUSH
11092: LD_INT 1
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: ST_TO_ADDR
// hc_skills := [ 0 , 1 , 0 , 1 ] ;
11101: LD_ADDR_OWVAR 31
11105: PUSH
11106: LD_INT 0
11108: PUSH
11109: LD_INT 1
11111: PUSH
11112: LD_INT 0
11114: PUSH
11115: LD_INT 1
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: ST_TO_ADDR
// un := CreateHuman ;
11124: LD_ADDR_VAR 0 3
11128: PUSH
11129: CALL_OW 44
11133: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11134: LD_VAR 0 3
11138: PPUSH
11139: LD_INT 6
11141: PPUSH
11142: LD_INT 0
11144: PPUSH
11145: CALL_OW 49
// if not Bobby and not Cyrus then
11149: LD_EXP 2
11153: NOT
11154: PUSH
11155: LD_EXP 3
11159: NOT
11160: AND
11161: IFFALSE 11266
// begin hc_class := 1 ;
11163: LD_ADDR_OWVAR 28
11167: PUSH
11168: LD_INT 1
11170: ST_TO_ADDR
// hc_sex := sex_male ;
11171: LD_ADDR_OWVAR 27
11175: PUSH
11176: LD_INT 1
11178: ST_TO_ADDR
// hc_gallery :=  ;
11179: LD_ADDR_OWVAR 33
11183: PUSH
11184: LD_STRING 
11186: ST_TO_ADDR
// hc_name :=  ;
11187: LD_ADDR_OWVAR 26
11191: PUSH
11192: LD_STRING 
11194: ST_TO_ADDR
// hc_basic_skills := [ 2 , 3 , 1 , 0 ] ;
11195: LD_ADDR_OWVAR 30
11199: PUSH
11200: LD_INT 2
11202: PUSH
11203: LD_INT 3
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: LD_INT 0
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: ST_TO_ADDR
// hc_skills := [ 2 , 3 , 1 , 0 ] ;
11218: LD_ADDR_OWVAR 31
11222: PUSH
11223: LD_INT 2
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 1
11231: PUSH
11232: LD_INT 0
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: ST_TO_ADDR
// un := CreateHuman ;
11241: LD_ADDR_VAR 0 3
11245: PUSH
11246: CALL_OW 44
11250: ST_TO_ADDR
// PlaceUnitArea ( un , AmNewSpawn , false ) ;
11251: LD_VAR 0 3
11255: PPUSH
11256: LD_INT 31
11258: PPUSH
11259: LD_INT 0
11261: PPUSH
11262: CALL_OW 49
// end ; InitHc ;
11266: CALL_OW 19
// end ;
11270: LD_VAR 0 1
11274: RET
// export function PrepareOtherAmericans ; begin
11275: LD_INT 0
11277: PPUSH
// uc_side = 4 ;
11278: LD_ADDR_OWVAR 20
11282: PUSH
11283: LD_INT 4
11285: ST_TO_ADDR
// uc_nation = 1 ;
11286: LD_ADDR_OWVAR 21
11290: PUSH
11291: LD_INT 1
11293: ST_TO_ADDR
// hc_gallery =  ;
11294: LD_ADDR_OWVAR 33
11298: PUSH
11299: LD_STRING 
11301: ST_TO_ADDR
// hc_name = Tom Garvin ;
11302: LD_ADDR_OWVAR 26
11306: PUSH
11307: LD_STRING Tom Garvin
11309: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( 1 , 2 ) ) ;
11310: LD_INT 1
11312: PPUSH
11313: LD_INT 1
11315: PPUSH
11316: LD_INT 1
11318: PPUSH
11319: LD_INT 2
11321: PPUSH
11322: CALL_OW 12
11326: PPUSH
11327: CALL_OW 380
// Brian = CreateHuman ;
11331: LD_ADDR_EXP 6
11335: PUSH
11336: CALL_OW 44
11340: ST_TO_ADDR
// PlaceUnitArea ( Brian , OtherAmericanSpawn , false ) ;
11341: LD_EXP 6
11345: PPUSH
11346: LD_INT 10
11348: PPUSH
11349: LD_INT 0
11351: PPUSH
11352: CALL_OW 49
// hc_name = Jerry White ;
11356: LD_ADDR_OWVAR 26
11360: PUSH
11361: LD_STRING Jerry White
11363: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
11364: LD_INT 1
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 1
11372: PPUSH
11373: LD_INT 2
11375: PPUSH
11376: CALL_OW 12
11380: PPUSH
11381: CALL_OW 380
// Jerry = CreateHuman ;
11385: LD_ADDR_EXP 7
11389: PUSH
11390: CALL_OW 44
11394: ST_TO_ADDR
// PlaceUnitArea ( Jerry , OtherAmericanSpawn , false ) ;
11395: LD_EXP 7
11399: PPUSH
11400: LD_INT 10
11402: PPUSH
11403: LD_INT 0
11405: PPUSH
11406: CALL_OW 49
// ComHold ( [ Brian , Jerry ] ) ;
11410: LD_EXP 6
11414: PUSH
11415: LD_EXP 7
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PPUSH
11424: CALL_OW 140
// end ;
11428: LD_VAR 0 1
11432: RET
// export DyingSold ; export function PrepareDeadSoldiers ; var i , un ; begin
11433: LD_INT 0
11435: PPUSH
11436: PPUSH
11437: PPUSH
// for i = 1 to 6 do
11438: LD_ADDR_VAR 0 2
11442: PUSH
11443: DOUBLE
11444: LD_INT 1
11446: DEC
11447: ST_TO_ADDR
11448: LD_INT 6
11450: PUSH
11451: FOR_TO
11452: IFFALSE 11546
// begin uc_side = 4 ;
11454: LD_ADDR_OWVAR 20
11458: PUSH
11459: LD_INT 4
11461: ST_TO_ADDR
// uc_nation = 1 ;
11462: LD_ADDR_OWVAR 21
11466: PUSH
11467: LD_INT 1
11469: ST_TO_ADDR
// hc_gallery =  ;
11470: LD_ADDR_OWVAR 33
11474: PUSH
11475: LD_STRING 
11477: ST_TO_ADDR
// hc_name =  ;
11478: LD_ADDR_OWVAR 26
11482: PUSH
11483: LD_STRING 
11485: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 1 ) ;
11486: LD_INT 0
11488: PPUSH
11489: LD_INT 1
11491: PPUSH
11492: LD_INT 4
11494: PPUSH
11495: CALL_OW 12
11499: PPUSH
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 380
// un = CreateHuman ;
11507: LD_ADDR_VAR 0 3
11511: PUSH
11512: CALL_OW 44
11516: ST_TO_ADDR
// PlaceUnitArea ( un , DeadsSpawn , false ) ;
11517: LD_VAR 0 3
11521: PPUSH
11522: LD_INT 16
11524: PPUSH
11525: LD_INT 0
11527: PPUSH
11528: CALL_OW 49
// SetLives ( un , 1 ) ;
11532: LD_VAR 0 3
11536: PPUSH
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 234
// end ;
11544: GO 11451
11546: POP
11547: POP
// DyingSold = CreateHuman ;
11548: LD_ADDR_EXP 34
11552: PUSH
11553: CALL_OW 44
11557: ST_TO_ADDR
// PlaceUnitArea ( DyingSold , DeadsSpawn , false ) ;
11558: LD_EXP 34
11562: PPUSH
11563: LD_INT 16
11565: PPUSH
11566: LD_INT 0
11568: PPUSH
11569: CALL_OW 49
// SetLives ( DyingSold , 250 ) ;
11573: LD_EXP 34
11577: PPUSH
11578: LD_INT 250
11580: PPUSH
11581: CALL_OW 234
// end ; end_of_file
11585: LD_VAR 0 1
11589: RET
// export function PrepareRussianHeroes ; var tmp ; begin
11590: LD_INT 0
11592: PPUSH
11593: PPUSH
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM ] ;
11594: LD_ADDR_VAR 0 2
11598: PUSH
11599: LD_INT 22
11601: PUSH
11602: LD_INT 1
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 23
11611: PUSH
11612: LD_INT 1
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 25
11621: PUSH
11622: LD_INT 2
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 50
11631: PUSH
11632: EMPTY
11633: LIST
11634: PUSH
11635: LD_INT 56
11637: PUSH
11638: EMPTY
11639: LIST
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: PPUSH
11648: CALL_OW 69
11652: PUSH
11653: LD_EXP 1
11657: PUSH
11658: EMPTY
11659: LIST
11660: DIFF
11661: ST_TO_ADDR
// uc_side = 6 ;
11662: LD_ADDR_OWVAR 20
11666: PUSH
11667: LD_INT 6
11669: ST_TO_ADDR
// Mikhail = NewCharacter ( Mikhail ) ;
11670: LD_ADDR_EXP 8
11674: PUSH
11675: LD_STRING Mikhail
11677: PPUSH
11678: CALL_OW 25
11682: ST_TO_ADDR
// SetClass ( Mikhail , 3 ) ;
11683: LD_EXP 8
11687: PPUSH
11688: LD_INT 3
11690: PPUSH
11691: CALL_OW 336
// PlaceUnitXYR ( Mikhail , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 5 , true ) ;
11695: LD_EXP 8
11699: PPUSH
11700: LD_VAR 0 2
11704: PUSH
11705: LD_INT 1
11707: ARRAY
11708: PPUSH
11709: CALL_OW 250
11713: PPUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_INT 1
11721: ARRAY
11722: PPUSH
11723: CALL_OW 251
11727: PPUSH
11728: LD_INT 5
11730: PPUSH
11731: LD_INT 1
11733: PPUSH
11734: CALL_OW 50
// end ;
11738: LD_VAR 0 1
11742: RET
// export function PrepareRussianCommander ; begin
11743: LD_INT 0
11745: PPUSH
// uc_side = 3 ;
11746: LD_ADDR_OWVAR 20
11750: PUSH
11751: LD_INT 3
11753: ST_TO_ADDR
// uc_nation = 3 ;
11754: LD_ADDR_OWVAR 21
11758: PUSH
11759: LD_INT 3
11761: ST_TO_ADDR
// Natasza = NewCharacter ( Natasza ) ;
11762: LD_ADDR_EXP 19
11766: PUSH
11767: LD_STRING Natasza
11769: PPUSH
11770: CALL_OW 25
11774: ST_TO_ADDR
// PlaceUnitArea ( Natasza , NataszaSpawn , false ) ;
11775: LD_EXP 19
11779: PPUSH
11780: LD_INT 24
11782: PPUSH
11783: LD_INT 0
11785: PPUSH
11786: CALL_OW 49
// ComTurnXY ( Natasza , 56 , 16 ) ;
11790: LD_EXP 19
11794: PPUSH
11795: LD_INT 56
11797: PPUSH
11798: LD_INT 16
11800: PPUSH
11801: CALL_OW 118
// northBaseDefenders = northBaseDefenders ^ Natasza ;
11805: LD_ADDR_EXP 24
11809: PUSH
11810: LD_EXP 24
11814: PUSH
11815: LD_EXP 19
11819: ADD
11820: ST_TO_ADDR
// end ;
11821: LD_VAR 0 1
11825: RET
// export function PrepareSouthBase ; var i , un ; begin
11826: LD_INT 0
11828: PPUSH
11829: PPUSH
11830: PPUSH
// for i = 1 to 2 do
11831: LD_ADDR_VAR 0 2
11835: PUSH
11836: DOUBLE
11837: LD_INT 1
11839: DEC
11840: ST_TO_ADDR
11841: LD_INT 2
11843: PUSH
11844: FOR_TO
11845: IFFALSE 11954
// begin uc_side = 3 ;
11847: LD_ADDR_OWVAR 20
11851: PUSH
11852: LD_INT 3
11854: ST_TO_ADDR
// uc_nation = 3 ;
11855: LD_ADDR_OWVAR 21
11859: PUSH
11860: LD_INT 3
11862: ST_TO_ADDR
// hc_gallery =  ;
11863: LD_ADDR_OWVAR 33
11867: PUSH
11868: LD_STRING 
11870: ST_TO_ADDR
// hc_name =  ;
11871: LD_ADDR_OWVAR 26
11875: PUSH
11876: LD_STRING 
11878: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
11879: LD_INT 1
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: LD_EXP 13
11889: PPUSH
11890: LD_EXP 14
11894: PPUSH
11895: CALL_OW 12
11899: PPUSH
11900: CALL_OW 380
// hc_importance = 0 ;
11904: LD_ADDR_OWVAR 32
11908: PUSH
11909: LD_INT 0
11911: ST_TO_ADDR
// un = CreateHuman ;
11912: LD_ADDR_VAR 0 3
11916: PUSH
11917: CALL_OW 44
11921: ST_TO_ADDR
// PlaceUnitArea ( un , SouthBaseRussianSpawn1 , false ) ;
11922: LD_VAR 0 3
11926: PPUSH
11927: LD_INT 11
11929: PPUSH
11930: LD_INT 0
11932: PPUSH
11933: CALL_OW 49
// ComTurnXY ( un , 111 , 38 ) ;
11937: LD_VAR 0 3
11941: PPUSH
11942: LD_INT 111
11944: PPUSH
11945: LD_INT 38
11947: PPUSH
11948: CALL_OW 118
// end ;
11952: GO 11844
11954: POP
11955: POP
// for i = 1 to Difficulty do
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: DOUBLE
11962: LD_INT 1
11964: DEC
11965: ST_TO_ADDR
11966: LD_OWVAR 67
11970: PUSH
11971: FOR_TO
11972: IFFALSE 12055
// begin uc_side = 3 ;
11974: LD_ADDR_OWVAR 20
11978: PUSH
11979: LD_INT 3
11981: ST_TO_ADDR
// uc_nation = 3 ;
11982: LD_ADDR_OWVAR 21
11986: PUSH
11987: LD_INT 3
11989: ST_TO_ADDR
// hc_gallery =  ;
11990: LD_ADDR_OWVAR 33
11994: PUSH
11995: LD_STRING 
11997: ST_TO_ADDR
// hc_name =  ;
11998: LD_ADDR_OWVAR 26
12002: PUSH
12003: LD_STRING 
12005: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12006: LD_INT 0
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_EXP 13
12016: PPUSH
12017: LD_EXP 14
12021: PPUSH
12022: CALL_OW 12
12026: PPUSH
12027: CALL_OW 380
// un = CreateHuman ;
12031: LD_ADDR_VAR 0 3
12035: PUSH
12036: CALL_OW 44
12040: ST_TO_ADDR
// PlaceHumanInUnit ( un , dep2 ) ;
12041: LD_VAR 0 3
12045: PPUSH
12046: LD_INT 10
12048: PPUSH
12049: CALL_OW 52
// end ;
12053: GO 11971
12055: POP
12056: POP
// RespawnInside ( 3 , 3 , arm2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ 1 , rand ( 1 , 2 ) , rand ( 1 , 2 ) ] [ Difficulty ] ) ;
12057: LD_INT 3
12059: PPUSH
12060: LD_INT 3
12062: PPUSH
12063: LD_INT 33
12065: PPUSH
12066: LD_EXP 13
12070: PPUSH
12071: LD_EXP 14
12075: PPUSH
12076: CALL_OW 12
12080: PPUSH
12081: LD_INT 1
12083: PPUSH
12084: LD_INT 1
12086: PUSH
12087: LD_INT 1
12089: PPUSH
12090: LD_INT 2
12092: PPUSH
12093: CALL_OW 12
12097: PUSH
12098: LD_INT 1
12100: PPUSH
12101: LD_INT 2
12103: PPUSH
12104: CALL_OW 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: LIST
12113: PUSH
12114: LD_OWVAR 67
12118: ARRAY
12119: PPUSH
12120: CALL 8513 0 6
// for i in UnitsInside ( arm2 ) do
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_INT 33
12131: PPUSH
12132: CALL_OW 313
12136: PUSH
12137: FOR_IN
12138: IFFALSE 12158
// southBaseDefenders = southBaseDefenders ^ i ;
12140: LD_ADDR_EXP 25
12144: PUSH
12145: LD_EXP 25
12149: PUSH
12150: LD_VAR 0 2
12154: ADD
12155: ST_TO_ADDR
12156: GO 12137
12158: POP
12159: POP
// end ;
12160: LD_VAR 0 1
12164: RET
// export function PrepareNorthBase ; var i , un ; begin
12165: LD_INT 0
12167: PPUSH
12168: PPUSH
12169: PPUSH
// for i = 1 to [ rand ( 1 , 2 ) , rand ( 2 , 3 ) , rand ( 3 , 4 ) ] [ Difficulty ] do
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_INT 1
12182: PPUSH
12183: LD_INT 2
12185: PPUSH
12186: CALL_OW 12
12190: PUSH
12191: LD_INT 2
12193: PPUSH
12194: LD_INT 3
12196: PPUSH
12197: CALL_OW 12
12201: PUSH
12202: LD_INT 3
12204: PPUSH
12205: LD_INT 4
12207: PPUSH
12208: CALL_OW 12
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: LIST
12217: PUSH
12218: LD_OWVAR 67
12222: ARRAY
12223: PUSH
12224: FOR_TO
12225: IFFALSE 12311
// begin uc_side = 3 ;
12227: LD_ADDR_OWVAR 20
12231: PUSH
12232: LD_INT 3
12234: ST_TO_ADDR
// uc_nation = 3 ;
12235: LD_ADDR_OWVAR 21
12239: PUSH
12240: LD_INT 3
12242: ST_TO_ADDR
// hc_gallery =  ;
12243: LD_ADDR_OWVAR 33
12247: PUSH
12248: LD_STRING 
12250: ST_TO_ADDR
// hc_name =  ;
12251: LD_ADDR_OWVAR 26
12255: PUSH
12256: LD_STRING 
12258: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12259: LD_INT 0
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: LD_EXP 13
12269: PPUSH
12270: LD_EXP 14
12274: PPUSH
12275: CALL_OW 12
12279: PPUSH
12280: CALL_OW 380
// un = CreateHuman ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: CALL_OW 44
12293: ST_TO_ADDR
// PlaceUnitArea ( un , NorthBaseRussianSpawn1 , false ) ;
12294: LD_VAR 0 3
12298: PPUSH
12299: LD_INT 14
12301: PPUSH
12302: LD_INT 0
12304: PPUSH
12305: CALL_OW 49
// end ;
12309: GO 12224
12311: POP
12312: POP
// RespawnInside ( 3 , 3 , arm1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ Rand ( 1 , 2 ) , Rand ( 1 , 3 ) , Rand ( 1 , 3 ) ] [ Difficulty ] ) ;
12313: LD_INT 3
12315: PPUSH
12316: LD_INT 3
12318: PPUSH
12319: LD_INT 2
12321: PPUSH
12322: LD_EXP 13
12326: PPUSH
12327: LD_EXP 14
12331: PPUSH
12332: CALL_OW 12
12336: PPUSH
12337: LD_INT 1
12339: PPUSH
12340: LD_INT 1
12342: PPUSH
12343: LD_INT 2
12345: PPUSH
12346: CALL_OW 12
12350: PUSH
12351: LD_INT 1
12353: PPUSH
12354: LD_INT 3
12356: PPUSH
12357: CALL_OW 12
12361: PUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 3
12367: PPUSH
12368: CALL_OW 12
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: LIST
12377: PUSH
12378: LD_OWVAR 67
12382: ARRAY
12383: PPUSH
12384: CALL 8513 0 6
// RespawnInside ( 3 , 3 , lab1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 4 , [ 0 , 1 , 2 ] [ Difficulty ] ) ;
12388: LD_INT 3
12390: PPUSH
12391: LD_INT 3
12393: PPUSH
12394: LD_INT 23
12396: PPUSH
12397: LD_EXP 13
12401: PPUSH
12402: LD_EXP 14
12406: PPUSH
12407: CALL_OW 12
12411: PPUSH
12412: LD_INT 4
12414: PPUSH
12415: LD_INT 0
12417: PUSH
12418: LD_INT 1
12420: PUSH
12421: LD_INT 2
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: LIST
12428: PUSH
12429: LD_OWVAR 67
12433: ARRAY
12434: PPUSH
12435: CALL 8513 0 6
// RespawnInside ( 3 , 3 , dep1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
12439: LD_INT 3
12441: PPUSH
12442: LD_INT 3
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: LD_EXP 13
12452: PPUSH
12453: LD_EXP 14
12457: PPUSH
12458: CALL_OW 12
12462: PPUSH
12463: LD_INT 2
12465: PPUSH
12466: LD_INT 1
12468: PUSH
12469: LD_INT 2
12471: PUSH
12472: LD_INT 2
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: LIST
12479: PUSH
12480: LD_OWVAR 67
12484: ARRAY
12485: PPUSH
12486: CALL 8513 0 6
// for i in UnitsInside ( arm1 ) do
12490: LD_ADDR_VAR 0 2
12494: PUSH
12495: LD_INT 2
12497: PPUSH
12498: CALL_OW 313
12502: PUSH
12503: FOR_IN
12504: IFFALSE 12524
// northBaseDefenders = northBaseDefenders ^ i ;
12506: LD_ADDR_EXP 24
12510: PUSH
12511: LD_EXP 24
12515: PUSH
12516: LD_VAR 0 2
12520: ADD
12521: ST_TO_ADDR
12522: GO 12503
12524: POP
12525: POP
// end ;
12526: LD_VAR 0 1
12530: RET
// export function PrepareOtherRussians ; var i , un ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// for i = 1 to 2 do
12536: LD_ADDR_VAR 0 2
12540: PUSH
12541: DOUBLE
12542: LD_INT 1
12544: DEC
12545: ST_TO_ADDR
12546: LD_INT 2
12548: PUSH
12549: FOR_TO
12550: IFFALSE 12651
// begin uc_side = 3 ;
12552: LD_ADDR_OWVAR 20
12556: PUSH
12557: LD_INT 3
12559: ST_TO_ADDR
// uc_nation = 3 ;
12560: LD_ADDR_OWVAR 21
12564: PUSH
12565: LD_INT 3
12567: ST_TO_ADDR
// hc_gallery =  ;
12568: LD_ADDR_OWVAR 33
12572: PUSH
12573: LD_STRING 
12575: ST_TO_ADDR
// hc_name =  ;
12576: LD_ADDR_OWVAR 26
12580: PUSH
12581: LD_STRING 
12583: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12584: LD_INT 0
12586: PPUSH
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 13
12594: PPUSH
12595: LD_EXP 14
12599: PPUSH
12600: CALL_OW 12
12604: PPUSH
12605: CALL_OW 380
// un = CreateHuman ;
12609: LD_ADDR_VAR 0 3
12613: PUSH
12614: CALL_OW 44
12618: ST_TO_ADDR
// PlaceUnitArea ( un , RussiansWaterSpawn , false ) ;
12619: LD_VAR 0 3
12623: PPUSH
12624: LD_INT 9
12626: PPUSH
12627: LD_INT 0
12629: PPUSH
12630: CALL_OW 49
// ComTurnXY ( un , 80 , 73 ) ;
12634: LD_VAR 0 3
12638: PPUSH
12639: LD_INT 80
12641: PPUSH
12642: LD_INT 73
12644: PPUSH
12645: CALL_OW 118
// end ;
12649: GO 12549
12651: POP
12652: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , 31 ] ] ) do
12653: LD_ADDR_VAR 0 2
12657: PUSH
12658: LD_INT 22
12660: PUSH
12661: LD_INT 3
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 30
12670: PUSH
12671: LD_INT 31
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: EMPTY
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: PUSH
12687: FOR_IN
12688: IFFALSE 12716
// PrepareSolBun ( rand ( RuSoldMinLevel , RuSoldMaxLevel ) , i ) ;
12690: LD_EXP 13
12694: PPUSH
12695: LD_EXP 14
12699: PPUSH
12700: CALL_OW 12
12704: PPUSH
12705: LD_VAR 0 2
12709: PPUSH
12710: CALL 8623 0 2
12714: GO 12687
12716: POP
12717: POP
// end ;
12718: LD_VAR 0 1
12722: RET
// export function PrepareCargoBays ; begin
12723: LD_INT 0
12725: PPUSH
// uc_side = 3 ;
12726: LD_ADDR_OWVAR 20
12730: PUSH
12731: LD_INT 3
12733: ST_TO_ADDR
// uc_nation = 3 ;
12734: LD_ADDR_OWVAR 21
12738: PUSH
12739: LD_INT 3
12741: ST_TO_ADDR
// vc_engine = 1 ;
12742: LD_ADDR_OWVAR 39
12746: PUSH
12747: LD_INT 1
12749: ST_TO_ADDR
// vc_control = 1 ;
12750: LD_ADDR_OWVAR 38
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// vc_weapon = 51 ;
12758: LD_ADDR_OWVAR 40
12762: PUSH
12763: LD_INT 51
12765: ST_TO_ADDR
// vc_chassis = 22 ;
12766: LD_ADDR_OWVAR 37
12770: PUSH
12771: LD_INT 22
12773: ST_TO_ADDR
// cargo1 = CreateVehicle ;
12774: LD_ADDR_EXP 15
12778: PUSH
12779: CALL_OW 45
12783: ST_TO_ADDR
// cargo2 = CreateVehicle ;
12784: LD_ADDR_EXP 16
12788: PUSH
12789: CALL_OW 45
12793: ST_TO_ADDR
// PlaceUnitArea ( cargo1 , RussianAttack , false ) ;
12794: LD_EXP 15
12798: PPUSH
12799: LD_INT 13
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceUnitArea ( cargo2 , RussianAttack , false ) ;
12809: LD_EXP 16
12813: PPUSH
12814: LD_INT 13
12816: PPUSH
12817: LD_INT 0
12819: PPUSH
12820: CALL_OW 49
// AddCargo ( cargo1 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12824: LD_EXP 15
12828: PPUSH
12829: LD_INT 2
12831: PPUSH
12832: LD_INT 70
12834: PUSH
12835: LD_INT 50
12837: PUSH
12838: LD_INT 30
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: LIST
12845: PUSH
12846: LD_OWVAR 67
12850: ARRAY
12851: PPUSH
12852: CALL_OW 291
// AddCargo ( cargo2 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12856: LD_EXP 16
12860: PPUSH
12861: LD_INT 2
12863: PPUSH
12864: LD_INT 70
12866: PUSH
12867: LD_INT 50
12869: PUSH
12870: LD_INT 30
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: PUSH
12878: LD_OWVAR 67
12882: ARRAY
12883: PPUSH
12884: CALL_OW 291
// hc_gallery =  ;
12888: LD_ADDR_OWVAR 33
12892: PUSH
12893: LD_STRING 
12895: ST_TO_ADDR
// hc_name =  ;
12896: LD_ADDR_OWVAR 26
12900: PUSH
12901: LD_STRING 
12903: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
12904: LD_INT 1
12906: PPUSH
12907: LD_INT 3
12909: PPUSH
12910: LD_INT 1
12912: PPUSH
12913: LD_INT 2
12915: PPUSH
12916: CALL_OW 12
12920: PPUSH
12921: CALL_OW 380
// driver1 = CreateHuman ;
12925: LD_ADDR_EXP 17
12929: PUSH
12930: CALL_OW 44
12934: ST_TO_ADDR
// PlaceHumanInUnit ( driver1 , cargo1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_EXP 15
12944: PPUSH
12945: CALL_OW 52
// hc_name = Nikolai Andreyev ;
12949: LD_ADDR_OWVAR 26
12953: PUSH
12954: LD_STRING Nikolai Andreyev
12956: ST_TO_ADDR
// driver2 = CreateHuman ;
12957: LD_ADDR_EXP 18
12961: PUSH
12962: CALL_OW 44
12966: ST_TO_ADDR
// PlaceHumanInUnit ( driver2 , cargo2 ) ;
12967: LD_EXP 18
12971: PPUSH
12972: LD_EXP 16
12976: PPUSH
12977: CALL_OW 52
// end ;
12981: LD_VAR 0 1
12985: RET
// export function PrepareRussianAttack ( count , area ) ; var i , veh , un , tmp , target1 , target2 ; begin
12986: LD_INT 0
12988: PPUSH
12989: PPUSH
12990: PPUSH
12991: PPUSH
12992: PPUSH
12993: PPUSH
12994: PPUSH
// uc_side = 3 ;
12995: LD_ADDR_OWVAR 20
12999: PUSH
13000: LD_INT 3
13002: ST_TO_ADDR
// uc_nation = 3 ;
13003: LD_ADDR_OWVAR 21
13007: PUSH
13008: LD_INT 3
13010: ST_TO_ADDR
// for i := 1 to count + rand ( 1 , 3 ) do
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: DOUBLE
13017: LD_INT 1
13019: DEC
13020: ST_TO_ADDR
13021: LD_VAR 0 1
13025: PUSH
13026: LD_INT 1
13028: PPUSH
13029: LD_INT 3
13031: PPUSH
13032: CALL_OW 12
13036: PLUS
13037: PUSH
13038: FOR_TO
13039: IFFALSE 13216
// begin vc_engine = 1 ;
13041: LD_ADDR_OWVAR 39
13045: PUSH
13046: LD_INT 1
13048: ST_TO_ADDR
// vc_control = 1 ;
13049: LD_ADDR_OWVAR 38
13053: PUSH
13054: LD_INT 1
13056: ST_TO_ADDR
// vc_weapon = 42 ;
13057: LD_ADDR_OWVAR 40
13061: PUSH
13062: LD_INT 42
13064: ST_TO_ADDR
// vc_chassis = [ 21 , 22 , 22 ] [ Difficulty ] ;
13065: LD_ADDR_OWVAR 37
13069: PUSH
13070: LD_INT 21
13072: PUSH
13073: LD_INT 22
13075: PUSH
13076: LD_INT 22
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: LIST
13083: PUSH
13084: LD_OWVAR 67
13088: ARRAY
13089: ST_TO_ADDR
// veh = CreateVehicle ;
13090: LD_ADDR_VAR 0 5
13094: PUSH
13095: CALL_OW 45
13099: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
13100: LD_VAR 0 5
13104: PPUSH
13105: LD_VAR 0 2
13109: PPUSH
13110: LD_INT 0
13112: PPUSH
13113: CALL_OW 49
// attackGroup = attackGroup ^ veh ;
13117: LD_ADDR_EXP 26
13121: PUSH
13122: LD_EXP 26
13126: PUSH
13127: LD_VAR 0 5
13131: ADD
13132: ST_TO_ADDR
// hc_gallery =  ;
13133: LD_ADDR_OWVAR 33
13137: PUSH
13138: LD_STRING 
13140: ST_TO_ADDR
// hc_name =  ;
13141: LD_ADDR_OWVAR 26
13145: PUSH
13146: LD_STRING 
13148: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13149: LD_INT 0
13151: PPUSH
13152: LD_INT 3
13154: PPUSH
13155: LD_EXP 13
13159: PPUSH
13160: LD_EXP 14
13164: PPUSH
13165: CALL_OW 12
13169: PPUSH
13170: CALL_OW 380
// un = CreateHuman ;
13174: LD_ADDR_VAR 0 6
13178: PUSH
13179: CALL_OW 44
13183: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
13184: LD_VAR 0 6
13188: PPUSH
13189: LD_VAR 0 5
13193: PPUSH
13194: CALL_OW 52
// attackGroup = attackGroup ^ un ;
13198: LD_ADDR_EXP 26
13202: PUSH
13203: LD_EXP 26
13207: PUSH
13208: LD_VAR 0 6
13212: ADD
13213: ST_TO_ADDR
// end ;
13214: GO 13038
13216: POP
13217: POP
// PrepareHuman ( false , 2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13218: LD_INT 0
13220: PPUSH
13221: LD_INT 2
13223: PPUSH
13224: LD_EXP 13
13228: PPUSH
13229: LD_EXP 14
13233: PPUSH
13234: CALL_OW 12
13238: PPUSH
13239: CALL_OW 380
// un = CreateHuman ;
13243: LD_ADDR_VAR 0 6
13247: PUSH
13248: CALL_OW 44
13252: ST_TO_ADDR
// for i := 1 to count + 2 * 2 do
13253: LD_ADDR_VAR 0 4
13257: PUSH
13258: DOUBLE
13259: LD_INT 1
13261: DEC
13262: ST_TO_ADDR
13263: LD_VAR 0 1
13267: PUSH
13268: LD_INT 2
13270: PUSH
13271: LD_INT 2
13273: MUL
13274: PLUS
13275: PUSH
13276: FOR_TO
13277: IFFALSE 13365
// begin hc_gallery =  ;
13279: LD_ADDR_OWVAR 33
13283: PUSH
13284: LD_STRING 
13286: ST_TO_ADDR
// hc_name =  ;
13287: LD_ADDR_OWVAR 26
13291: PUSH
13292: LD_STRING 
13294: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13295: LD_INT 1
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: LD_EXP 13
13305: PPUSH
13306: LD_EXP 14
13310: PPUSH
13311: CALL_OW 12
13315: PPUSH
13316: CALL_OW 380
// un = CreateHuman ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: CALL_OW 44
13329: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
13330: LD_VAR 0 6
13334: PPUSH
13335: LD_VAR 0 2
13339: PPUSH
13340: LD_INT 0
13342: PPUSH
13343: CALL_OW 49
// attackGroup = attackGroup ^ un ;
13347: LD_ADDR_EXP 26
13351: PUSH
13352: LD_EXP 26
13356: PUSH
13357: LD_VAR 0 6
13361: ADD
13362: ST_TO_ADDR
// end ;
13363: GO 13276
13365: POP
13366: POP
// tmp = FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) ;
13367: LD_ADDR_VAR 0 7
13371: PUSH
13372: LD_INT 26
13374: PPUSH
13375: LD_INT 22
13377: PUSH
13378: LD_INT 3
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: LD_INT 21
13387: PUSH
13388: LD_INT 1
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PUSH
13395: LD_INT 26
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: PPUSH
13410: CALL_OW 70
13414: ST_TO_ADDR
// Say ( tmp [ 1 ] , D9-Rus3-1 ) ;
13415: LD_VAR 0 7
13419: PUSH
13420: LD_INT 1
13422: ARRAY
13423: PPUSH
13424: LD_STRING D9-Rus3-1
13426: PPUSH
13427: CALL_OW 88
// Say ( tmp [ 2 ] , D9-Russ-1 ) ;
13431: LD_VAR 0 7
13435: PUSH
13436: LD_INT 2
13438: ARRAY
13439: PPUSH
13440: LD_STRING D9-Russ-1
13442: PPUSH
13443: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13447: LD_INT 35
13449: PPUSH
13450: CALL_OW 67
// for i in FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] ] ) do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: LD_INT 26
13461: PPUSH
13462: LD_INT 22
13464: PUSH
13465: LD_INT 3
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: EMPTY
13473: LIST
13474: PPUSH
13475: CALL_OW 70
13479: PUSH
13480: FOR_IN
13481: IFFALSE 13653
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ;
13483: LD_ADDR_VAR 0 8
13487: PUSH
13488: LD_INT 22
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PPUSH
13498: CALL_OW 69
13502: PPUSH
13503: LD_VAR 0 4
13507: PPUSH
13508: CALL_OW 74
13512: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
13513: LD_ADDR_VAR 0 9
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 1
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 2
13530: PUSH
13531: LD_INT 59
13533: PUSH
13534: EMPTY
13535: LIST
13536: PUSH
13537: LD_INT 21
13539: PUSH
13540: LD_INT 1
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 21
13549: PUSH
13550: LD_INT 2
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: EMPTY
13568: LIST
13569: PPUSH
13570: CALL_OW 69
13574: PPUSH
13575: LD_VAR 0 4
13579: PPUSH
13580: CALL_OW 74
13584: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
13585: LD_VAR 0 4
13589: PPUSH
13590: LD_VAR 0 8
13594: PPUSH
13595: CALL_OW 296
13599: PUSH
13600: LD_INT 8
13602: PLUS
13603: PUSH
13604: LD_VAR 0 4
13608: PPUSH
13609: LD_VAR 0 9
13613: PPUSH
13614: CALL_OW 296
13618: LESS
13619: IFFALSE 13637
// begin ComAttackUnit ( i , target1 ) ;
13621: LD_VAR 0 4
13625: PPUSH
13626: LD_VAR 0 8
13630: PPUSH
13631: CALL_OW 115
// end else
13635: GO 13651
// begin ComAttackUnit ( i , target2 ) ;
13637: LD_VAR 0 4
13641: PPUSH
13642: LD_VAR 0 9
13646: PPUSH
13647: CALL_OW 115
// end ; end ;
13651: GO 13480
13653: POP
13654: POP
// until FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ) = 0 ;
13655: LD_INT 26
13657: PPUSH
13658: LD_INT 22
13660: PUSH
13661: LD_INT 3
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: LD_INT 2
13670: PUSH
13671: LD_INT 21
13673: PUSH
13674: LD_INT 1
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 2
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: LD_INT 59
13693: PUSH
13694: EMPTY
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 70
13711: PUSH
13712: LD_INT 0
13714: EQUAL
13715: IFFALSE 13447
// end ; end_of_file
13717: LD_VAR 0 3
13721: RET
// every 0 0$1 do
13722: GO 13724
13724: DISABLE
// begin enable ;
13725: ENABLE
// RepairBuilding ( 3 , dep1 , NorthBase ) ;
13726: LD_INT 3
13728: PPUSH
13729: LD_INT 1
13731: PPUSH
13732: LD_INT 22
13734: PPUSH
13735: CALL 8759 0 3
// HealUnitInBase ( 3 , NorthBaseHealArea , NorthBase , lab1 ) ;
13739: LD_INT 3
13741: PPUSH
13742: LD_INT 20
13744: PPUSH
13745: LD_INT 22
13747: PPUSH
13748: LD_INT 23
13750: PPUSH
13751: CALL 9005 0 4
// RepairVehicle ( 3 , SouthBaseRepairArea , SouthBase ) ;
13755: LD_INT 3
13757: PPUSH
13758: LD_INT 21
13760: PPUSH
13761: LD_INT 23
13763: PPUSH
13764: CALL 9282 0 3
// DefendBases ( NorthBase , 1 , northBaseDefenders , arm1 , 3 ) ;
13768: LD_INT 22
13770: PPUSH
13771: LD_INT 1
13773: PPUSH
13774: LD_EXP 24
13778: PPUSH
13779: LD_INT 2
13781: PPUSH
13782: LD_INT 3
13784: PPUSH
13785: CALL 9754 0 5
// DefendBases ( SouthBase , 1 , southBaseDefenders , arm2 , 1 ) ;
13789: LD_INT 23
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_EXP 25
13799: PPUSH
13800: LD_INT 33
13802: PPUSH
13803: LD_INT 1
13805: PPUSH
13806: CALL 9754 0 5
// end ; end_of_file
13810: END
// on UnitDestroyed ( unit ) do begin if GetBType ( unit ) = b_depot then
13811: LD_VAR 0 1
13815: PPUSH
13816: CALL_OW 266
13820: PUSH
13821: LD_INT 0
13823: EQUAL
13824: IFFALSE 13833
// YouLost ( DepotDestroyed ) ;
13826: LD_STRING DepotDestroyed
13828: PPUSH
13829: CALL_OW 104
// if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
13833: LD_VAR 0 1
13837: PPUSH
13838: CALL_OW 255
13842: PUSH
13843: LD_INT 1
13845: EQUAL
13846: PUSH
13847: LD_VAR 0 1
13851: PPUSH
13852: CALL_OW 247
13856: PUSH
13857: LD_INT 1
13859: EQUAL
13860: AND
13861: IFFALSE 13877
// deadsCounter = deadsCounter + 1 ;
13863: LD_ADDR_EXP 31
13867: PUSH
13868: LD_EXP 31
13872: PUSH
13873: LD_INT 1
13875: PLUS
13876: ST_TO_ADDR
// end ;
13877: PPOPN 1
13879: END
// on Command ( comandid ) do var i , j , tmp ;
13880: LD_INT 0
13882: PPUSH
13883: PPUSH
13884: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 22
13892: PUSH
13893: LD_INT 1
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: LD_INT 21
13902: PUSH
13903: LD_INT 2
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PPUSH
13914: CALL_OW 69
13918: PUSH
13919: FOR_IN
13920: IFFALSE 14045
// begin if GetTaskList ( i ) > 0 then
13922: LD_VAR 0 2
13926: PPUSH
13927: CALL_OW 437
13931: PUSH
13932: LD_INT 0
13934: GREATER
13935: IFFALSE 14043
// begin for j = 1 to GetTaskList ( i ) do
13937: LD_ADDR_VAR 0 3
13941: PUSH
13942: DOUBLE
13943: LD_INT 1
13945: DEC
13946: ST_TO_ADDR
13947: LD_VAR 0 2
13951: PPUSH
13952: CALL_OW 437
13956: PUSH
13957: FOR_TO
13958: IFFALSE 14041
// begin tmp = GetTaskList ( i ) [ j ] [ 4 ] ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: LD_VAR 0 2
13969: PPUSH
13970: CALL_OW 437
13974: PUSH
13975: LD_VAR 0 3
13979: ARRAY
13980: PUSH
13981: LD_INT 4
13983: ARRAY
13984: ST_TO_ADDR
// if ( GetSide ( tmp ) = 3 and GetType ( tmp ) = unit_vehicle and GetWeapon ( tmp ) = ru_cargo_bay ) then
13985: LD_VAR 0 4
13989: PPUSH
13990: CALL_OW 255
13994: PUSH
13995: LD_INT 3
13997: EQUAL
13998: PUSH
13999: LD_VAR 0 4
14003: PPUSH
14004: CALL_OW 247
14008: PUSH
14009: LD_INT 2
14011: EQUAL
14012: AND
14013: PUSH
14014: LD_VAR 0 4
14018: PPUSH
14019: CALL_OW 264
14023: PUSH
14024: LD_INT 51
14026: EQUAL
14027: AND
14028: IFFALSE 14039
// ComStop ( i ) ;
14030: LD_VAR 0 2
14034: PPUSH
14035: CALL_OW 141
// end ;
14039: GO 13957
14041: POP
14042: POP
// end ; end ;
14043: GO 13919
14045: POP
14046: POP
// end ;
14047: PPOPN 4
14049: END
// on LeaveBuilding ( b , un ) do begin if un = Mikhail and mikhailStatus <> 4 then
14050: LD_VAR 0 2
14054: PUSH
14055: LD_EXP 8
14059: EQUAL
14060: PUSH
14061: LD_EXP 21
14065: PUSH
14066: LD_INT 4
14068: NONEQUAL
14069: AND
14070: IFFALSE 14222
// begin if IsOk ( Mikhail ) then
14072: LD_EXP 8
14076: PPUSH
14077: CALL_OW 302
14081: IFFALSE 14089
// AskMikhail else
14083: CALL 7044 0 0
14087: GO 14222
// if IsOk ( lab1 ) then
14089: LD_INT 23
14091: PPUSH
14092: CALL_OW 302
14096: IFFALSE 14185
// begin InGameOn ;
14098: CALL_OW 8
// SetSide ( Mikhail , 6 ) ;
14102: LD_EXP 8
14106: PPUSH
14107: LD_INT 6
14109: PPUSH
14110: CALL_OW 235
// SetSide ( lab1 , 6 ) ;
14114: LD_INT 23
14116: PPUSH
14117: LD_INT 6
14119: PPUSH
14120: CALL_OW 235
// ComEnterUnit ( Mikhail , lab1 ) ;
14124: LD_EXP 8
14128: PPUSH
14129: LD_INT 23
14131: PPUSH
14132: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
14136: LD_INT 35
14138: PPUSH
14139: CALL_OW 67
// until IsInUnit ( Mikhail ) = lab1 or IsDead ( Mikhail ) ;
14143: LD_EXP 8
14147: PPUSH
14148: CALL_OW 310
14152: PUSH
14153: LD_INT 23
14155: EQUAL
14156: PUSH
14157: LD_EXP 8
14161: PPUSH
14162: CALL_OW 301
14166: OR
14167: IFFALSE 14136
// SetSide ( lab1 , 1 ) ;
14169: LD_INT 23
14171: PPUSH
14172: LD_INT 1
14174: PPUSH
14175: CALL_OW 235
// InGameOff ;
14179: CALL_OW 9
// end else
14183: GO 14222
// begin SetAttitude ( 3 , 6 , att_enemy , true ) ;
14185: LD_INT 3
14187: PPUSH
14188: LD_INT 6
14190: PPUSH
14191: LD_INT 2
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
14201: LD_EXP 8
14205: PPUSH
14206: LD_INT 6
14208: PPUSH
14209: CALL_OW 235
// ComHold ( Mikhail ) ;
14213: LD_EXP 8
14217: PPUSH
14218: CALL_OW 140
// end ; end ; end ;
14222: PPOPN 2
14224: END
// every 3 trigger GetClass ( Mikhail ) <> 3 do
14225: LD_EXP 8
14229: PPUSH
14230: CALL_OW 257
14234: PUSH
14235: LD_INT 3
14237: NONEQUAL
14238: IFFALSE 14256
14240: GO 14242
14242: DISABLE
// begin enable ;
14243: ENABLE
// SetClass ( Mikhail , 3 ) ;
14244: LD_EXP 8
14248: PPUSH
14249: LD_INT 3
14251: PPUSH
14252: CALL_OW 336
// end ; end_of_file
14256: END
// every 0 0$1 trigger IsDead ( JMM ) do
14257: LD_EXP 1
14261: PPUSH
14262: CALL_OW 301
14266: IFFALSE 14278
14268: GO 14270
14270: DISABLE
// YouLost ( JMM ) ;
14271: LD_STRING JMM
14273: PPUSH
14274: CALL_OW 104
14278: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and GetSide ( dep1 ) = 3 and GetSide ( dep2 ) = 3 do
14279: LD_INT 22
14281: PUSH
14282: LD_INT 1
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PUSH
14289: LD_INT 21
14291: PUSH
14292: LD_INT 1
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: LD_INT 2
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: LIST
14313: PPUSH
14314: CALL_OW 69
14318: PUSH
14319: LD_INT 0
14321: EQUAL
14322: PUSH
14323: LD_INT 22
14325: PUSH
14326: LD_INT 4
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 21
14335: PUSH
14336: LD_INT 1
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 25
14345: PUSH
14346: LD_INT 2
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: LIST
14357: PPUSH
14358: CALL_OW 69
14362: PUSH
14363: LD_INT 0
14365: EQUAL
14366: AND
14367: PUSH
14368: LD_INT 1
14370: PPUSH
14371: CALL_OW 255
14375: PUSH
14376: LD_INT 3
14378: EQUAL
14379: AND
14380: PUSH
14381: LD_INT 10
14383: PPUSH
14384: CALL_OW 255
14388: PUSH
14389: LD_INT 3
14391: EQUAL
14392: AND
14393: IFFALSE 14405
14395: GO 14397
14397: DISABLE
// YouLost ( Engineer ) ;
14398: LD_STRING Engineer
14400: PPUSH
14401: CALL_OW 104
14405: END
// every 0 0$1 trigger GetSide ( dep1 ) = 3 and LastBattle = 1 do
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 255
14413: PUSH
14414: LD_INT 3
14416: EQUAL
14417: PUSH
14418: LD_EXP 27
14422: PUSH
14423: LD_INT 1
14425: EQUAL
14426: AND
14427: IFFALSE 14439
14429: GO 14431
14431: DISABLE
// YouLost ( DepotCaptured ) ; end_of_file
14432: LD_STRING DepotCaptured
14434: PPUSH
14435: CALL_OW 104
14439: END
// export function PrepareTigers ; var i , un ; begin
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
14444: PPUSH
// for i = 1 to Difficulty do
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: DOUBLE
14451: LD_INT 1
14453: DEC
14454: ST_TO_ADDR
14455: LD_OWVAR 67
14459: PUSH
14460: FOR_TO
14461: IFFALSE 14596
// begin hc_sex = sex_male ;
14463: LD_ADDR_OWVAR 27
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// uc_side = 0 ;
14471: LD_ADDR_OWVAR 20
14475: PUSH
14476: LD_INT 0
14478: ST_TO_ADDR
// uc_nation = nation_nature ;
14479: LD_ADDR_OWVAR 21
14483: PUSH
14484: LD_INT 0
14486: ST_TO_ADDR
// hc_class = class_tiger ;
14487: LD_ADDR_OWVAR 28
14491: PUSH
14492: LD_INT 14
14494: ST_TO_ADDR
// hc_skills = [ RuSoldMaxLevel , 0 , 0 , 0 ] ;
14495: LD_ADDR_OWVAR 31
14499: PUSH
14500: LD_EXP 14
14504: PUSH
14505: LD_INT 0
14507: PUSH
14508: LD_INT 0
14510: PUSH
14511: LD_INT 0
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: ST_TO_ADDR
// hc_agressivity = [ rand ( 30 , 40 ) , rand ( 40 , 50 ) , rand ( 50 , 60 ) ] [ Difficulty ] ;
14520: LD_ADDR_OWVAR 35
14524: PUSH
14525: LD_INT 30
14527: PPUSH
14528: LD_INT 40
14530: PPUSH
14531: CALL_OW 12
14535: PUSH
14536: LD_INT 40
14538: PPUSH
14539: LD_INT 50
14541: PPUSH
14542: CALL_OW 12
14546: PUSH
14547: LD_INT 50
14549: PPUSH
14550: LD_INT 60
14552: PPUSH
14553: CALL_OW 12
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: LIST
14562: PUSH
14563: LD_OWVAR 67
14567: ARRAY
14568: ST_TO_ADDR
// un = CreateHuman ;
14569: LD_ADDR_VAR 0 3
14573: PUSH
14574: CALL_OW 44
14578: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
14579: LD_VAR 0 3
14583: PPUSH
14584: LD_INT 27
14586: PPUSH
14587: LD_INT 0
14589: PPUSH
14590: CALL_OW 49
// end ;
14594: GO 14460
14596: POP
14597: POP
// end ; end_of_file
14598: LD_VAR 0 1
14602: RET
// every 0 0$01 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape = 1 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 51 ] , [ f_not , [ f_empty ] ] ] ) = 0 do
14603: LD_INT 1
14605: PPUSH
14606: CALL_OW 255
14610: PUSH
14611: LD_INT 1
14613: EQUAL
14614: PUSH
14615: LD_INT 10
14617: PPUSH
14618: CALL_OW 255
14622: PUSH
14623: LD_INT 1
14625: EQUAL
14626: AND
14627: PUSH
14628: LD_EXP 20
14632: PUSH
14633: LD_INT 1
14635: EQUAL
14636: AND
14637: PUSH
14638: LD_INT 22
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 21
14650: PUSH
14651: LD_INT 2
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 34
14660: PUSH
14661: LD_INT 51
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 58
14673: PUSH
14674: EMPTY
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_INT 0
14694: EQUAL
14695: AND
14696: IFFALSE 14787
14698: GO 14700
14700: DISABLE
// begin wait ( [ 4 4$30 , 4 4$0 , 3 3$0 ] [ Difficulty ] ) ;
14701: LD_INT 9450
14703: PUSH
14704: LD_INT 8400
14706: PUSH
14707: LD_INT 6300
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_OWVAR 67
14719: ARRAY
14720: PPUSH
14721: CALL_OW 67
// if cargoEscape = 1 then
14725: LD_EXP 20
14729: PUSH
14730: LD_INT 1
14732: EQUAL
14733: IFFALSE 14787
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14735: LD_EXP 9
14739: PPUSH
14740: LD_STRING D6-Pow-1
14742: PPUSH
14743: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14747: LD_EXP 1
14751: PPUSH
14752: LD_STRING D6-JMM-1
14754: PPUSH
14755: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14759: LD_EXP 9
14763: PPUSH
14764: LD_STRING D6-Pow-2
14766: PPUSH
14767: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14771: LD_EXP 1
14775: PPUSH
14776: LD_STRING D6-JMM-2
14778: PPUSH
14779: CALL_OW 88
// FinishMission ;
14783: CALL 14995 0 0
// end ; end ;
14787: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape > 1 do var tmp ;
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 255
14795: PUSH
14796: LD_INT 1
14798: EQUAL
14799: PUSH
14800: LD_INT 10
14802: PPUSH
14803: CALL_OW 255
14807: PUSH
14808: LD_INT 1
14810: EQUAL
14811: AND
14812: PUSH
14813: LD_EXP 20
14817: PUSH
14818: LD_INT 1
14820: GREATER
14821: AND
14822: IFFALSE 14889
14824: GO 14826
14826: DISABLE
14827: LD_INT 0
14829: PPUSH
// begin wait ( [ 5 5$30 , 5 5$0 , 4 4$30 ] [ Difficulty ] ) ;
14830: LD_INT 11550
14832: PUSH
14833: LD_INT 10500
14835: PUSH
14836: LD_INT 9450
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: PUSH
14844: LD_OWVAR 67
14848: ARRAY
14849: PPUSH
14850: CALL_OW 67
// PrepareRussianAttack ( [ 1 , 2 , 3 ] [ Difficulty ] , RussianAttack ) ;
14854: LD_INT 1
14856: PUSH
14857: LD_INT 2
14859: PUSH
14860: LD_INT 3
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PUSH
14868: LD_OWVAR 67
14872: ARRAY
14873: PPUSH
14874: LD_INT 13
14876: PPUSH
14877: CALL 12986 0 2
// lastBattle = 1 ;
14881: LD_ADDR_EXP 27
14885: PUSH
14886: LD_INT 1
14888: ST_TO_ADDR
// end ;
14889: PPOPN 1
14891: END
// every 0 0$7 trigger LastBattle = 1 and FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
14892: LD_EXP 27
14896: PUSH
14897: LD_INT 1
14899: EQUAL
14900: PUSH
14901: LD_INT 26
14903: PPUSH
14904: LD_INT 22
14906: PUSH
14907: LD_INT 3
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: LD_INT 21
14916: PUSH
14917: LD_INT 1
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PPUSH
14928: CALL_OW 70
14932: PUSH
14933: LD_INT 0
14935: EQUAL
14936: AND
14937: IFFALSE 14994
14939: GO 14941
14941: DISABLE
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14942: LD_EXP 9
14946: PPUSH
14947: LD_STRING D6-Pow-1
14949: PPUSH
14950: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14954: LD_EXP 1
14958: PPUSH
14959: LD_STRING D6-JMM-1
14961: PPUSH
14962: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14966: LD_EXP 9
14970: PPUSH
14971: LD_STRING D6-Pow-2
14973: PPUSH
14974: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14978: LD_EXP 1
14982: PPUSH
14983: LD_STRING D6-JMM-2
14985: PPUSH
14986: CALL_OW 88
// FinishMission ;
14990: CALL 14995 0 0
// end ;
14994: END
// export function FinishMission ; var tmp , m1 , m2 , m3 ; begin
14995: LD_INT 0
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// if tick <= 18 18$00 then
15002: LD_OWVAR 1
15006: PUSH
15007: LD_INT 37800
15009: LESSEQUAL
15010: IFFALSE 15019
// SetAchievement ( ACH_ASPEED_2 ) ;
15012: LD_STRING ACH_ASPEED_2
15014: PPUSH
15015: CALL_OW 543
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_lives , 251 ] ] ) ;
15019: LD_ADDR_VAR 0 2
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 1
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 21
15036: PUSH
15037: LD_INT 2
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PUSH
15044: LD_INT 24
15046: PUSH
15047: LD_INT 251
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: LIST
15058: PPUSH
15059: CALL_OW 69
15063: ST_TO_ADDR
// if tmp then
15064: LD_VAR 0 2
15068: IFFALSE 15082
// SaveVehicles ( tmp , 02_tanks_1 ) ;
15070: LD_VAR 0 2
15074: PPUSH
15075: LD_STRING 02_tanks_1
15077: PPUSH
15078: CALL 10459 0 2
// if mikhailStatus = 1 and IsLive ( Mikhail ) then
15082: LD_EXP 21
15086: PUSH
15087: LD_INT 1
15089: EQUAL
15090: PUSH
15091: LD_EXP 8
15095: PPUSH
15096: CALL_OW 300
15100: AND
15101: IFFALSE 15115
// SaveVariable ( mikhailStatus , 02_mikhailStatus_1 ) ;
15103: LD_EXP 21
15107: PPUSH
15108: LD_STRING 02_mikhailStatus_1
15110: PPUSH
15111: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( dep1 ) , 1 ) , 02_resources_4 ) ;
15115: LD_INT 1
15117: PPUSH
15118: CALL_OW 274
15122: PPUSH
15123: LD_INT 1
15125: PPUSH
15126: CALL_OW 275
15130: PPUSH
15131: LD_STRING 02_resources_4
15133: PPUSH
15134: CALL_OW 39
// m1 := false ;
15138: LD_ADDR_VAR 0 3
15142: PUSH
15143: LD_INT 0
15145: ST_TO_ADDR
// m2 := false ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: LD_INT 0
15153: ST_TO_ADDR
// m3 := false ;
15154: LD_ADDR_VAR 0 5
15158: PUSH
15159: LD_INT 0
15161: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep1 ) , 1 ) >= 200 then
15162: LD_INT 1
15164: PPUSH
15165: CALL_OW 274
15169: PPUSH
15170: LD_INT 1
15172: PPUSH
15173: CALL_OW 275
15177: PUSH
15178: LD_INT 200
15180: GREATEREQUAL
15181: IFFALSE 15203
// begin AddMedal ( Cans , 1 ) ;
15183: LD_STRING Cans
15185: PPUSH
15186: LD_INT 1
15188: PPUSH
15189: CALL_OW 101
// m1 := true ;
15193: LD_ADDR_VAR 0 3
15197: PUSH
15198: LD_INT 1
15200: ST_TO_ADDR
// end else
15201: GO 15214
// begin AddMedal ( Cans , - 1 ) ;
15203: LD_STRING Cans
15205: PPUSH
15206: LD_INT 1
15208: NEG
15209: PPUSH
15210: CALL_OW 101
// end ; if deadsCounter < 2 then
15214: LD_EXP 31
15218: PUSH
15219: LD_INT 2
15221: LESS
15222: IFFALSE 15244
// begin AddMedal ( Deaths , 1 ) ;
15224: LD_STRING Deaths
15226: PPUSH
15227: LD_INT 1
15229: PPUSH
15230: CALL_OW 101
// m2 := true ;
15234: LD_ADDR_VAR 0 4
15238: PUSH
15239: LD_INT 1
15241: ST_TO_ADDR
// end else
15242: GO 15255
// begin AddMedal ( Deaths , - 1 ) ;
15244: LD_STRING Deaths
15246: PPUSH
15247: LD_INT 1
15249: NEG
15250: PPUSH
15251: CALL_OW 101
// end ; if mikhailStatus = 0 then
15255: LD_EXP 21
15259: PUSH
15260: LD_INT 0
15262: EQUAL
15263: IFFALSE 15276
// AddMedal ( Prisoner , - 1 ) ;
15265: LD_STRING Prisoner
15267: PPUSH
15268: LD_INT 1
15270: NEG
15271: PPUSH
15272: CALL_OW 101
// if mikhailStatus = 1 then
15276: LD_EXP 21
15280: PUSH
15281: LD_INT 1
15283: EQUAL
15284: IFFALSE 15304
// begin AddMedal ( Prisoner , 1 ) ;
15286: LD_STRING Prisoner
15288: PPUSH
15289: LD_INT 1
15291: PPUSH
15292: CALL_OW 101
// m3 := true ;
15296: LD_ADDR_VAR 0 5
15300: PUSH
15301: LD_INT 1
15303: ST_TO_ADDR
// end ; if mikhailStatus = 2 then
15304: LD_EXP 21
15308: PUSH
15309: LD_INT 2
15311: EQUAL
15312: IFFALSE 15332
// begin AddMedal ( Prisoner , 2 ) ;
15314: LD_STRING Prisoner
15316: PPUSH
15317: LD_INT 2
15319: PPUSH
15320: CALL_OW 101
// m3 := true ;
15324: LD_ADDR_VAR 0 5
15328: PUSH
15329: LD_INT 1
15331: ST_TO_ADDR
// end ; if mikhailStatus = 3 then
15332: LD_EXP 21
15336: PUSH
15337: LD_INT 3
15339: EQUAL
15340: IFFALSE 15353
// AddMedal ( Prisoner , - 2 ) ;
15342: LD_STRING Prisoner
15344: PPUSH
15345: LD_INT 2
15347: NEG
15348: PPUSH
15349: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
15353: LD_OWVAR 67
15357: PUSH
15358: LD_INT 3
15360: EQUAL
15361: PUSH
15362: LD_VAR 0 3
15366: AND
15367: PUSH
15368: LD_VAR 0 4
15372: AND
15373: PUSH
15374: LD_VAR 0 5
15378: AND
15379: IFFALSE 15391
// SetAchievementEX ( ACH_AMER , 2 ) ;
15381: LD_STRING ACH_AMER
15383: PPUSH
15384: LD_INT 2
15386: PPUSH
15387: CALL_OW 564
// GiveMedals ( MAIN ) ;
15391: LD_STRING MAIN
15393: PPUSH
15394: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) ) ;
15398: LD_INT 22
15400: PUSH
15401: LD_INT 1
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 23
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 21
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: LIST
15432: PPUSH
15433: CALL_OW 69
15437: PPUSH
15438: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15442: LD_EXP 1
15446: PPUSH
15447: LD_EXP 33
15451: PUSH
15452: LD_STRING JMM
15454: STR
15455: PPUSH
15456: CALL_OW 38
// if IsOK ( Bobby ) then
15460: LD_EXP 2
15464: PPUSH
15465: CALL_OW 302
15469: IFFALSE 15489
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15471: LD_EXP 2
15475: PPUSH
15476: LD_EXP 33
15480: PUSH
15481: LD_STRING Bobby
15483: STR
15484: PPUSH
15485: CALL_OW 38
// if IsOK ( Cyrus ) then
15489: LD_EXP 3
15493: PPUSH
15494: CALL_OW 302
15498: IFFALSE 15518
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15500: LD_EXP 3
15504: PPUSH
15505: LD_EXP 33
15509: PUSH
15510: LD_STRING Cyrus
15512: STR
15513: PPUSH
15514: CALL_OW 38
// if IsOK ( Lisa ) then
15518: LD_EXP 4
15522: PPUSH
15523: CALL_OW 302
15527: IFFALSE 15547
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15529: LD_EXP 4
15533: PPUSH
15534: LD_EXP 33
15538: PUSH
15539: LD_STRING Lisa
15541: STR
15542: PPUSH
15543: CALL_OW 38
// if IsOK ( Khatam ) then
15547: LD_EXP 5
15551: PPUSH
15552: CALL_OW 302
15556: IFFALSE 15576
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
15558: LD_EXP 5
15562: PPUSH
15563: LD_EXP 33
15567: PUSH
15568: LD_STRING Khatam
15570: STR
15571: PPUSH
15572: CALL_OW 38
// if IsOK ( Brian ) then
15576: LD_EXP 6
15580: PPUSH
15581: CALL_OW 302
15585: IFFALSE 15605
// SaveCharacters ( Brian , mission_prefix & Brian ) ;
15587: LD_EXP 6
15591: PPUSH
15592: LD_EXP 33
15596: PUSH
15597: LD_STRING Brian
15599: STR
15600: PPUSH
15601: CALL_OW 38
// if IsOk ( Jerry ) then
15605: LD_EXP 7
15609: PPUSH
15610: CALL_OW 302
15614: IFFALSE 15634
// SaveCharacters ( Jerry , mission_prefix & Jerry ) ;
15616: LD_EXP 7
15620: PPUSH
15621: LD_EXP 33
15625: PUSH
15626: LD_STRING Jerry
15628: STR
15629: PPUSH
15630: CALL_OW 38
// if mikhailStatus = 1 and GetSide ( Mikhail ) = 1 and IsOk ( Mikhail ) then
15634: LD_EXP 21
15638: PUSH
15639: LD_INT 1
15641: EQUAL
15642: PUSH
15643: LD_EXP 8
15647: PPUSH
15648: CALL_OW 255
15652: PUSH
15653: LD_INT 1
15655: EQUAL
15656: AND
15657: PUSH
15658: LD_EXP 8
15662: PPUSH
15663: CALL_OW 302
15667: AND
15668: IFFALSE 15688
// SaveCharacters ( Mikhail , mission_prefix & Mikhail ) ;
15670: LD_EXP 8
15674: PPUSH
15675: LD_EXP 33
15679: PUSH
15680: LD_STRING Mikhail
15682: STR
15683: PPUSH
15684: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Mikhail ] , 02_other_survivors ) ;
15688: LD_INT 50
15690: PUSH
15691: EMPTY
15692: LIST
15693: PUSH
15694: LD_INT 22
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 21
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_EXP 1
15728: PUSH
15729: LD_EXP 2
15733: PUSH
15734: LD_EXP 3
15738: PUSH
15739: LD_EXP 4
15743: PUSH
15744: LD_EXP 5
15748: PUSH
15749: LD_EXP 6
15753: PUSH
15754: LD_EXP 7
15758: PUSH
15759: LD_EXP 8
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: DIFF
15774: PPUSH
15775: LD_STRING 02_other_survivors
15777: PPUSH
15778: CALL_OW 38
// YouWin ;
15782: CALL_OW 103
// end ; end_of_file
15786: LD_VAR 0 1
15790: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
15791: GO 15793
15793: DISABLE
// begin ru_radar := 98 ;
15794: LD_ADDR_EXP 35
15798: PUSH
15799: LD_INT 98
15801: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
15802: LD_ADDR_EXP 36
15806: PUSH
15807: LD_INT 89
15809: ST_TO_ADDR
// us_hack := 99 ;
15810: LD_ADDR_EXP 37
15814: PUSH
15815: LD_INT 99
15817: ST_TO_ADDR
// us_artillery := 97 ;
15818: LD_ADDR_EXP 38
15822: PUSH
15823: LD_INT 97
15825: ST_TO_ADDR
// ar_bio_bomb := 91 ;
15826: LD_ADDR_EXP 39
15830: PUSH
15831: LD_INT 91
15833: ST_TO_ADDR
// end ; end_of_file end_of_file
15834: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
15835: GO 15837
15837: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
15838: LD_STRING initStreamRollete();
15840: PPUSH
15841: CALL_OW 559
// InitStreamMode ;
15845: CALL 15854 0 0
// DefineStreamItems ( ) ;
15849: CALL 16294 0 0
// end ;
15853: END
// function InitStreamMode ; begin
15854: LD_INT 0
15856: PPUSH
// streamModeActive := false ;
15857: LD_ADDR_EXP 40
15861: PUSH
15862: LD_INT 0
15864: ST_TO_ADDR
// normalCounter := 26 ;
15865: LD_ADDR_EXP 41
15869: PUSH
15870: LD_INT 26
15872: ST_TO_ADDR
// hardcoreCounter := 12 ;
15873: LD_ADDR_EXP 42
15877: PUSH
15878: LD_INT 12
15880: ST_TO_ADDR
// sRocket := false ;
15881: LD_ADDR_EXP 45
15885: PUSH
15886: LD_INT 0
15888: ST_TO_ADDR
// sSpeed := false ;
15889: LD_ADDR_EXP 44
15893: PUSH
15894: LD_INT 0
15896: ST_TO_ADDR
// sEngine := false ;
15897: LD_ADDR_EXP 46
15901: PUSH
15902: LD_INT 0
15904: ST_TO_ADDR
// sSpec := false ;
15905: LD_ADDR_EXP 43
15909: PUSH
15910: LD_INT 0
15912: ST_TO_ADDR
// sLevel := false ;
15913: LD_ADDR_EXP 47
15917: PUSH
15918: LD_INT 0
15920: ST_TO_ADDR
// sArmoury := false ;
15921: LD_ADDR_EXP 48
15925: PUSH
15926: LD_INT 0
15928: ST_TO_ADDR
// sRadar := false ;
15929: LD_ADDR_EXP 49
15933: PUSH
15934: LD_INT 0
15936: ST_TO_ADDR
// sBunker := false ;
15937: LD_ADDR_EXP 50
15941: PUSH
15942: LD_INT 0
15944: ST_TO_ADDR
// sHack := false ;
15945: LD_ADDR_EXP 51
15949: PUSH
15950: LD_INT 0
15952: ST_TO_ADDR
// sFire := false ;
15953: LD_ADDR_EXP 52
15957: PUSH
15958: LD_INT 0
15960: ST_TO_ADDR
// sRefresh := false ;
15961: LD_ADDR_EXP 53
15965: PUSH
15966: LD_INT 0
15968: ST_TO_ADDR
// sExp := false ;
15969: LD_ADDR_EXP 54
15973: PUSH
15974: LD_INT 0
15976: ST_TO_ADDR
// sDepot := false ;
15977: LD_ADDR_EXP 55
15981: PUSH
15982: LD_INT 0
15984: ST_TO_ADDR
// sFlag := false ;
15985: LD_ADDR_EXP 56
15989: PUSH
15990: LD_INT 0
15992: ST_TO_ADDR
// sKamikadze := false ;
15993: LD_ADDR_EXP 64
15997: PUSH
15998: LD_INT 0
16000: ST_TO_ADDR
// sTroll := false ;
16001: LD_ADDR_EXP 65
16005: PUSH
16006: LD_INT 0
16008: ST_TO_ADDR
// sSlow := false ;
16009: LD_ADDR_EXP 66
16013: PUSH
16014: LD_INT 0
16016: ST_TO_ADDR
// sLack := false ;
16017: LD_ADDR_EXP 67
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// sTank := false ;
16025: LD_ADDR_EXP 69
16029: PUSH
16030: LD_INT 0
16032: ST_TO_ADDR
// sRemote := false ;
16033: LD_ADDR_EXP 70
16037: PUSH
16038: LD_INT 0
16040: ST_TO_ADDR
// sPowell := false ;
16041: LD_ADDR_EXP 71
16045: PUSH
16046: LD_INT 0
16048: ST_TO_ADDR
// sTeleport := false ;
16049: LD_ADDR_EXP 74
16053: PUSH
16054: LD_INT 0
16056: ST_TO_ADDR
// sOilTower := false ;
16057: LD_ADDR_EXP 76
16061: PUSH
16062: LD_INT 0
16064: ST_TO_ADDR
// sShovel := false ;
16065: LD_ADDR_EXP 77
16069: PUSH
16070: LD_INT 0
16072: ST_TO_ADDR
// sSheik := false ;
16073: LD_ADDR_EXP 78
16077: PUSH
16078: LD_INT 0
16080: ST_TO_ADDR
// sEarthquake := false ;
16081: LD_ADDR_EXP 80
16085: PUSH
16086: LD_INT 0
16088: ST_TO_ADDR
// sAI := false ;
16089: LD_ADDR_EXP 81
16093: PUSH
16094: LD_INT 0
16096: ST_TO_ADDR
// sCargo := false ;
16097: LD_ADDR_EXP 84
16101: PUSH
16102: LD_INT 0
16104: ST_TO_ADDR
// sDLaser := false ;
16105: LD_ADDR_EXP 85
16109: PUSH
16110: LD_INT 0
16112: ST_TO_ADDR
// sExchange := false ;
16113: LD_ADDR_EXP 86
16117: PUSH
16118: LD_INT 0
16120: ST_TO_ADDR
// sFac := false ;
16121: LD_ADDR_EXP 87
16125: PUSH
16126: LD_INT 0
16128: ST_TO_ADDR
// sPower := false ;
16129: LD_ADDR_EXP 88
16133: PUSH
16134: LD_INT 0
16136: ST_TO_ADDR
// sRandom := false ;
16137: LD_ADDR_EXP 89
16141: PUSH
16142: LD_INT 0
16144: ST_TO_ADDR
// sShield := false ;
16145: LD_ADDR_EXP 90
16149: PUSH
16150: LD_INT 0
16152: ST_TO_ADDR
// sTime := false ;
16153: LD_ADDR_EXP 91
16157: PUSH
16158: LD_INT 0
16160: ST_TO_ADDR
// sTools := false ;
16161: LD_ADDR_EXP 92
16165: PUSH
16166: LD_INT 0
16168: ST_TO_ADDR
// sSold := false ;
16169: LD_ADDR_EXP 57
16173: PUSH
16174: LD_INT 0
16176: ST_TO_ADDR
// sDiff := false ;
16177: LD_ADDR_EXP 58
16181: PUSH
16182: LD_INT 0
16184: ST_TO_ADDR
// sFog := false ;
16185: LD_ADDR_EXP 61
16189: PUSH
16190: LD_INT 0
16192: ST_TO_ADDR
// sReset := false ;
16193: LD_ADDR_EXP 62
16197: PUSH
16198: LD_INT 0
16200: ST_TO_ADDR
// sSun := false ;
16201: LD_ADDR_EXP 63
16205: PUSH
16206: LD_INT 0
16208: ST_TO_ADDR
// sTiger := false ;
16209: LD_ADDR_EXP 59
16213: PUSH
16214: LD_INT 0
16216: ST_TO_ADDR
// sBomb := false ;
16217: LD_ADDR_EXP 60
16221: PUSH
16222: LD_INT 0
16224: ST_TO_ADDR
// sWound := false ;
16225: LD_ADDR_EXP 68
16229: PUSH
16230: LD_INT 0
16232: ST_TO_ADDR
// sBetray := false ;
16233: LD_ADDR_EXP 72
16237: PUSH
16238: LD_INT 0
16240: ST_TO_ADDR
// sContamin := false ;
16241: LD_ADDR_EXP 73
16245: PUSH
16246: LD_INT 0
16248: ST_TO_ADDR
// sOil := false ;
16249: LD_ADDR_EXP 75
16253: PUSH
16254: LD_INT 0
16256: ST_TO_ADDR
// sStu := false ;
16257: LD_ADDR_EXP 79
16261: PUSH
16262: LD_INT 0
16264: ST_TO_ADDR
// sBazooka := false ;
16265: LD_ADDR_EXP 82
16269: PUSH
16270: LD_INT 0
16272: ST_TO_ADDR
// sMortar := false ;
16273: LD_ADDR_EXP 83
16277: PUSH
16278: LD_INT 0
16280: ST_TO_ADDR
// sRanger := false ;
16281: LD_ADDR_EXP 93
16285: PUSH
16286: LD_INT 0
16288: ST_TO_ADDR
// end ;
16289: LD_VAR 0 1
16293: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
16294: LD_INT 0
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
// result := [ ] ;
16301: LD_ADDR_VAR 0 1
16305: PUSH
16306: EMPTY
16307: ST_TO_ADDR
// if campaign_id = 1 then
16308: LD_OWVAR 69
16312: PUSH
16313: LD_INT 1
16315: EQUAL
16316: IFFALSE 19264
// begin case mission_number of 1 :
16318: LD_OWVAR 70
16322: PUSH
16323: LD_INT 1
16325: DOUBLE
16326: EQUAL
16327: IFTRUE 16331
16329: GO 16395
16331: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
16332: LD_ADDR_VAR 0 1
16336: PUSH
16337: LD_INT 2
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: LD_INT 11
16345: PUSH
16346: LD_INT 12
16348: PUSH
16349: LD_INT 15
16351: PUSH
16352: LD_INT 16
16354: PUSH
16355: LD_INT 22
16357: PUSH
16358: LD_INT 23
16360: PUSH
16361: LD_INT 26
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: PUSH
16375: LD_INT 101
16377: PUSH
16378: LD_INT 102
16380: PUSH
16381: LD_INT 106
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: LIST
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: ST_TO_ADDR
16393: GO 19264
16395: LD_INT 2
16397: DOUBLE
16398: EQUAL
16399: IFTRUE 16403
16401: GO 16475
16403: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
16404: LD_ADDR_VAR 0 1
16408: PUSH
16409: LD_INT 2
16411: PUSH
16412: LD_INT 4
16414: PUSH
16415: LD_INT 11
16417: PUSH
16418: LD_INT 12
16420: PUSH
16421: LD_INT 15
16423: PUSH
16424: LD_INT 16
16426: PUSH
16427: LD_INT 22
16429: PUSH
16430: LD_INT 23
16432: PUSH
16433: LD_INT 26
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: LIST
16446: PUSH
16447: LD_INT 101
16449: PUSH
16450: LD_INT 102
16452: PUSH
16453: LD_INT 105
16455: PUSH
16456: LD_INT 106
16458: PUSH
16459: LD_INT 108
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: LIST
16467: LIST
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: ST_TO_ADDR
16473: GO 19264
16475: LD_INT 3
16477: DOUBLE
16478: EQUAL
16479: IFTRUE 16483
16481: GO 16559
16483: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
16484: LD_ADDR_VAR 0 1
16488: PUSH
16489: LD_INT 2
16491: PUSH
16492: LD_INT 4
16494: PUSH
16495: LD_INT 5
16497: PUSH
16498: LD_INT 11
16500: PUSH
16501: LD_INT 12
16503: PUSH
16504: LD_INT 15
16506: PUSH
16507: LD_INT 16
16509: PUSH
16510: LD_INT 22
16512: PUSH
16513: LD_INT 26
16515: PUSH
16516: LD_INT 36
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 101
16533: PUSH
16534: LD_INT 102
16536: PUSH
16537: LD_INT 105
16539: PUSH
16540: LD_INT 106
16542: PUSH
16543: LD_INT 108
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: LIST
16550: LIST
16551: LIST
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: ST_TO_ADDR
16557: GO 19264
16559: LD_INT 4
16561: DOUBLE
16562: EQUAL
16563: IFTRUE 16567
16565: GO 16651
16567: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
16568: LD_ADDR_VAR 0 1
16572: PUSH
16573: LD_INT 2
16575: PUSH
16576: LD_INT 4
16578: PUSH
16579: LD_INT 5
16581: PUSH
16582: LD_INT 8
16584: PUSH
16585: LD_INT 11
16587: PUSH
16588: LD_INT 12
16590: PUSH
16591: LD_INT 15
16593: PUSH
16594: LD_INT 16
16596: PUSH
16597: LD_INT 22
16599: PUSH
16600: LD_INT 23
16602: PUSH
16603: LD_INT 26
16605: PUSH
16606: LD_INT 36
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: LIST
16621: LIST
16622: PUSH
16623: LD_INT 101
16625: PUSH
16626: LD_INT 102
16628: PUSH
16629: LD_INT 105
16631: PUSH
16632: LD_INT 106
16634: PUSH
16635: LD_INT 108
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: LIST
16642: LIST
16643: LIST
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: ST_TO_ADDR
16649: GO 19264
16651: LD_INT 5
16653: DOUBLE
16654: EQUAL
16655: IFTRUE 16659
16657: GO 16759
16659: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
16660: LD_ADDR_VAR 0 1
16664: PUSH
16665: LD_INT 2
16667: PUSH
16668: LD_INT 4
16670: PUSH
16671: LD_INT 5
16673: PUSH
16674: LD_INT 6
16676: PUSH
16677: LD_INT 8
16679: PUSH
16680: LD_INT 11
16682: PUSH
16683: LD_INT 12
16685: PUSH
16686: LD_INT 15
16688: PUSH
16689: LD_INT 16
16691: PUSH
16692: LD_INT 22
16694: PUSH
16695: LD_INT 23
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 26
16703: PUSH
16704: LD_INT 36
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 101
16725: PUSH
16726: LD_INT 102
16728: PUSH
16729: LD_INT 105
16731: PUSH
16732: LD_INT 106
16734: PUSH
16735: LD_INT 108
16737: PUSH
16738: LD_INT 109
16740: PUSH
16741: LD_INT 112
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: ST_TO_ADDR
16757: GO 19264
16759: LD_INT 6
16761: DOUBLE
16762: EQUAL
16763: IFTRUE 16767
16765: GO 16887
16767: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_INT 2
16775: PUSH
16776: LD_INT 4
16778: PUSH
16779: LD_INT 5
16781: PUSH
16782: LD_INT 6
16784: PUSH
16785: LD_INT 8
16787: PUSH
16788: LD_INT 11
16790: PUSH
16791: LD_INT 12
16793: PUSH
16794: LD_INT 15
16796: PUSH
16797: LD_INT 16
16799: PUSH
16800: LD_INT 20
16802: PUSH
16803: LD_INT 21
16805: PUSH
16806: LD_INT 22
16808: PUSH
16809: LD_INT 23
16811: PUSH
16812: LD_INT 25
16814: PUSH
16815: LD_INT 26
16817: PUSH
16818: LD_INT 30
16820: PUSH
16821: LD_INT 31
16823: PUSH
16824: LD_INT 32
16826: PUSH
16827: LD_INT 36
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: LIST
16850: PUSH
16851: LD_INT 101
16853: PUSH
16854: LD_INT 102
16856: PUSH
16857: LD_INT 105
16859: PUSH
16860: LD_INT 106
16862: PUSH
16863: LD_INT 108
16865: PUSH
16866: LD_INT 109
16868: PUSH
16869: LD_INT 112
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: LIST
16878: LIST
16879: LIST
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: ST_TO_ADDR
16885: GO 19264
16887: LD_INT 7
16889: DOUBLE
16890: EQUAL
16891: IFTRUE 16895
16893: GO 16995
16895: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
16896: LD_ADDR_VAR 0 1
16900: PUSH
16901: LD_INT 2
16903: PUSH
16904: LD_INT 4
16906: PUSH
16907: LD_INT 5
16909: PUSH
16910: LD_INT 7
16912: PUSH
16913: LD_INT 11
16915: PUSH
16916: LD_INT 12
16918: PUSH
16919: LD_INT 15
16921: PUSH
16922: LD_INT 16
16924: PUSH
16925: LD_INT 20
16927: PUSH
16928: LD_INT 21
16930: PUSH
16931: LD_INT 22
16933: PUSH
16934: LD_INT 23
16936: PUSH
16937: LD_INT 25
16939: PUSH
16940: LD_INT 26
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 101
16961: PUSH
16962: LD_INT 102
16964: PUSH
16965: LD_INT 103
16967: PUSH
16968: LD_INT 105
16970: PUSH
16971: LD_INT 106
16973: PUSH
16974: LD_INT 108
16976: PUSH
16977: LD_INT 112
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: ST_TO_ADDR
16993: GO 19264
16995: LD_INT 8
16997: DOUBLE
16998: EQUAL
16999: IFTRUE 17003
17001: GO 17131
17003: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
17004: LD_ADDR_VAR 0 1
17008: PUSH
17009: LD_INT 2
17011: PUSH
17012: LD_INT 4
17014: PUSH
17015: LD_INT 5
17017: PUSH
17018: LD_INT 6
17020: PUSH
17021: LD_INT 7
17023: PUSH
17024: LD_INT 8
17026: PUSH
17027: LD_INT 11
17029: PUSH
17030: LD_INT 12
17032: PUSH
17033: LD_INT 15
17035: PUSH
17036: LD_INT 16
17038: PUSH
17039: LD_INT 20
17041: PUSH
17042: LD_INT 21
17044: PUSH
17045: LD_INT 22
17047: PUSH
17048: LD_INT 23
17050: PUSH
17051: LD_INT 25
17053: PUSH
17054: LD_INT 26
17056: PUSH
17057: LD_INT 30
17059: PUSH
17060: LD_INT 31
17062: PUSH
17063: LD_INT 32
17065: PUSH
17066: LD_INT 36
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: LIST
17090: PUSH
17091: LD_INT 101
17093: PUSH
17094: LD_INT 102
17096: PUSH
17097: LD_INT 103
17099: PUSH
17100: LD_INT 105
17102: PUSH
17103: LD_INT 106
17105: PUSH
17106: LD_INT 108
17108: PUSH
17109: LD_INT 109
17111: PUSH
17112: LD_INT 112
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: ST_TO_ADDR
17129: GO 19264
17131: LD_INT 9
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17139
17137: GO 17275
17139: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
17140: LD_ADDR_VAR 0 1
17144: PUSH
17145: LD_INT 2
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: LD_INT 7
17159: PUSH
17160: LD_INT 8
17162: PUSH
17163: LD_INT 11
17165: PUSH
17166: LD_INT 12
17168: PUSH
17169: LD_INT 15
17171: PUSH
17172: LD_INT 16
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: LD_INT 21
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 23
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 26
17192: PUSH
17193: LD_INT 28
17195: PUSH
17196: LD_INT 30
17198: PUSH
17199: LD_INT 31
17201: PUSH
17202: LD_INT 32
17204: PUSH
17205: LD_INT 36
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 101
17233: PUSH
17234: LD_INT 102
17236: PUSH
17237: LD_INT 103
17239: PUSH
17240: LD_INT 105
17242: PUSH
17243: LD_INT 106
17245: PUSH
17246: LD_INT 108
17248: PUSH
17249: LD_INT 109
17251: PUSH
17252: LD_INT 112
17254: PUSH
17255: LD_INT 114
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: LIST
17267: LIST
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: ST_TO_ADDR
17273: GO 19264
17275: LD_INT 10
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17467
17283: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
17284: LD_ADDR_VAR 0 1
17288: PUSH
17289: LD_INT 2
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: LD_INT 5
17297: PUSH
17298: LD_INT 6
17300: PUSH
17301: LD_INT 7
17303: PUSH
17304: LD_INT 8
17306: PUSH
17307: LD_INT 9
17309: PUSH
17310: LD_INT 10
17312: PUSH
17313: LD_INT 11
17315: PUSH
17316: LD_INT 12
17318: PUSH
17319: LD_INT 13
17321: PUSH
17322: LD_INT 14
17324: PUSH
17325: LD_INT 15
17327: PUSH
17328: LD_INT 16
17330: PUSH
17331: LD_INT 17
17333: PUSH
17334: LD_INT 18
17336: PUSH
17337: LD_INT 19
17339: PUSH
17340: LD_INT 20
17342: PUSH
17343: LD_INT 21
17345: PUSH
17346: LD_INT 22
17348: PUSH
17349: LD_INT 23
17351: PUSH
17352: LD_INT 24
17354: PUSH
17355: LD_INT 25
17357: PUSH
17358: LD_INT 26
17360: PUSH
17361: LD_INT 28
17363: PUSH
17364: LD_INT 30
17366: PUSH
17367: LD_INT 31
17369: PUSH
17370: LD_INT 32
17372: PUSH
17373: LD_INT 36
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: LIST
17406: PUSH
17407: LD_INT 101
17409: PUSH
17410: LD_INT 102
17412: PUSH
17413: LD_INT 103
17415: PUSH
17416: LD_INT 104
17418: PUSH
17419: LD_INT 105
17421: PUSH
17422: LD_INT 106
17424: PUSH
17425: LD_INT 107
17427: PUSH
17428: LD_INT 108
17430: PUSH
17431: LD_INT 109
17433: PUSH
17434: LD_INT 110
17436: PUSH
17437: LD_INT 111
17439: PUSH
17440: LD_INT 112
17442: PUSH
17443: LD_INT 114
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: LIST
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: ST_TO_ADDR
17465: GO 19264
17467: LD_INT 11
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17667
17475: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
17476: LD_ADDR_VAR 0 1
17480: PUSH
17481: LD_INT 2
17483: PUSH
17484: LD_INT 3
17486: PUSH
17487: LD_INT 4
17489: PUSH
17490: LD_INT 5
17492: PUSH
17493: LD_INT 6
17495: PUSH
17496: LD_INT 7
17498: PUSH
17499: LD_INT 8
17501: PUSH
17502: LD_INT 9
17504: PUSH
17505: LD_INT 10
17507: PUSH
17508: LD_INT 11
17510: PUSH
17511: LD_INT 12
17513: PUSH
17514: LD_INT 13
17516: PUSH
17517: LD_INT 14
17519: PUSH
17520: LD_INT 15
17522: PUSH
17523: LD_INT 16
17525: PUSH
17526: LD_INT 17
17528: PUSH
17529: LD_INT 18
17531: PUSH
17532: LD_INT 19
17534: PUSH
17535: LD_INT 20
17537: PUSH
17538: LD_INT 21
17540: PUSH
17541: LD_INT 22
17543: PUSH
17544: LD_INT 23
17546: PUSH
17547: LD_INT 24
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 26
17555: PUSH
17556: LD_INT 28
17558: PUSH
17559: LD_INT 30
17561: PUSH
17562: LD_INT 31
17564: PUSH
17565: LD_INT 32
17567: PUSH
17568: LD_INT 34
17570: PUSH
17571: LD_INT 36
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: LIST
17593: LIST
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 101
17609: PUSH
17610: LD_INT 102
17612: PUSH
17613: LD_INT 103
17615: PUSH
17616: LD_INT 104
17618: PUSH
17619: LD_INT 105
17621: PUSH
17622: LD_INT 106
17624: PUSH
17625: LD_INT 107
17627: PUSH
17628: LD_INT 108
17630: PUSH
17631: LD_INT 109
17633: PUSH
17634: LD_INT 110
17636: PUSH
17637: LD_INT 111
17639: PUSH
17640: LD_INT 112
17642: PUSH
17643: LD_INT 114
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: LIST
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: ST_TO_ADDR
17665: GO 19264
17667: LD_INT 12
17669: DOUBLE
17670: EQUAL
17671: IFTRUE 17675
17673: GO 17883
17675: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
17676: LD_ADDR_VAR 0 1
17680: PUSH
17681: LD_INT 1
17683: PUSH
17684: LD_INT 2
17686: PUSH
17687: LD_INT 3
17689: PUSH
17690: LD_INT 4
17692: PUSH
17693: LD_INT 5
17695: PUSH
17696: LD_INT 6
17698: PUSH
17699: LD_INT 7
17701: PUSH
17702: LD_INT 8
17704: PUSH
17705: LD_INT 9
17707: PUSH
17708: LD_INT 10
17710: PUSH
17711: LD_INT 11
17713: PUSH
17714: LD_INT 12
17716: PUSH
17717: LD_INT 13
17719: PUSH
17720: LD_INT 14
17722: PUSH
17723: LD_INT 15
17725: PUSH
17726: LD_INT 16
17728: PUSH
17729: LD_INT 17
17731: PUSH
17732: LD_INT 18
17734: PUSH
17735: LD_INT 19
17737: PUSH
17738: LD_INT 20
17740: PUSH
17741: LD_INT 21
17743: PUSH
17744: LD_INT 22
17746: PUSH
17747: LD_INT 23
17749: PUSH
17750: LD_INT 24
17752: PUSH
17753: LD_INT 25
17755: PUSH
17756: LD_INT 26
17758: PUSH
17759: LD_INT 27
17761: PUSH
17762: LD_INT 28
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 31
17770: PUSH
17771: LD_INT 32
17773: PUSH
17774: LD_INT 33
17776: PUSH
17777: LD_INT 34
17779: PUSH
17780: LD_INT 36
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 101
17821: PUSH
17822: LD_INT 102
17824: PUSH
17825: LD_INT 103
17827: PUSH
17828: LD_INT 104
17830: PUSH
17831: LD_INT 105
17833: PUSH
17834: LD_INT 106
17836: PUSH
17837: LD_INT 107
17839: PUSH
17840: LD_INT 108
17842: PUSH
17843: LD_INT 109
17845: PUSH
17846: LD_INT 110
17848: PUSH
17849: LD_INT 111
17851: PUSH
17852: LD_INT 112
17854: PUSH
17855: LD_INT 113
17857: PUSH
17858: LD_INT 114
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: LIST
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: ST_TO_ADDR
17881: GO 19264
17883: LD_INT 13
17885: DOUBLE
17886: EQUAL
17887: IFTRUE 17891
17889: GO 18099
17891: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
17892: LD_ADDR_VAR 0 1
17896: PUSH
17897: LD_INT 1
17899: PUSH
17900: LD_INT 2
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 4
17908: PUSH
17909: LD_INT 5
17911: PUSH
17912: LD_INT 6
17914: PUSH
17915: LD_INT 7
17917: PUSH
17918: LD_INT 8
17920: PUSH
17921: LD_INT 9
17923: PUSH
17924: LD_INT 10
17926: PUSH
17927: LD_INT 11
17929: PUSH
17930: LD_INT 12
17932: PUSH
17933: LD_INT 13
17935: PUSH
17936: LD_INT 14
17938: PUSH
17939: LD_INT 15
17941: PUSH
17942: LD_INT 16
17944: PUSH
17945: LD_INT 17
17947: PUSH
17948: LD_INT 18
17950: PUSH
17951: LD_INT 19
17953: PUSH
17954: LD_INT 20
17956: PUSH
17957: LD_INT 21
17959: PUSH
17960: LD_INT 22
17962: PUSH
17963: LD_INT 23
17965: PUSH
17966: LD_INT 24
17968: PUSH
17969: LD_INT 25
17971: PUSH
17972: LD_INT 26
17974: PUSH
17975: LD_INT 27
17977: PUSH
17978: LD_INT 28
17980: PUSH
17981: LD_INT 30
17983: PUSH
17984: LD_INT 31
17986: PUSH
17987: LD_INT 32
17989: PUSH
17990: LD_INT 33
17992: PUSH
17993: LD_INT 34
17995: PUSH
17996: LD_INT 36
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: PUSH
18035: LD_INT 101
18037: PUSH
18038: LD_INT 102
18040: PUSH
18041: LD_INT 103
18043: PUSH
18044: LD_INT 104
18046: PUSH
18047: LD_INT 105
18049: PUSH
18050: LD_INT 106
18052: PUSH
18053: LD_INT 107
18055: PUSH
18056: LD_INT 108
18058: PUSH
18059: LD_INT 109
18061: PUSH
18062: LD_INT 110
18064: PUSH
18065: LD_INT 111
18067: PUSH
18068: LD_INT 112
18070: PUSH
18071: LD_INT 113
18073: PUSH
18074: LD_INT 114
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: ST_TO_ADDR
18097: GO 19264
18099: LD_INT 14
18101: DOUBLE
18102: EQUAL
18103: IFTRUE 18107
18105: GO 18319
18107: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
18108: LD_ADDR_VAR 0 1
18112: PUSH
18113: LD_INT 1
18115: PUSH
18116: LD_INT 2
18118: PUSH
18119: LD_INT 3
18121: PUSH
18122: LD_INT 4
18124: PUSH
18125: LD_INT 5
18127: PUSH
18128: LD_INT 6
18130: PUSH
18131: LD_INT 7
18133: PUSH
18134: LD_INT 8
18136: PUSH
18137: LD_INT 9
18139: PUSH
18140: LD_INT 10
18142: PUSH
18143: LD_INT 11
18145: PUSH
18146: LD_INT 12
18148: PUSH
18149: LD_INT 13
18151: PUSH
18152: LD_INT 14
18154: PUSH
18155: LD_INT 15
18157: PUSH
18158: LD_INT 16
18160: PUSH
18161: LD_INT 17
18163: PUSH
18164: LD_INT 18
18166: PUSH
18167: LD_INT 19
18169: PUSH
18170: LD_INT 20
18172: PUSH
18173: LD_INT 21
18175: PUSH
18176: LD_INT 22
18178: PUSH
18179: LD_INT 23
18181: PUSH
18182: LD_INT 24
18184: PUSH
18185: LD_INT 25
18187: PUSH
18188: LD_INT 26
18190: PUSH
18191: LD_INT 27
18193: PUSH
18194: LD_INT 28
18196: PUSH
18197: LD_INT 29
18199: PUSH
18200: LD_INT 30
18202: PUSH
18203: LD_INT 31
18205: PUSH
18206: LD_INT 32
18208: PUSH
18209: LD_INT 33
18211: PUSH
18212: LD_INT 34
18214: PUSH
18215: LD_INT 36
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: PUSH
18255: LD_INT 101
18257: PUSH
18258: LD_INT 102
18260: PUSH
18261: LD_INT 103
18263: PUSH
18264: LD_INT 104
18266: PUSH
18267: LD_INT 105
18269: PUSH
18270: LD_INT 106
18272: PUSH
18273: LD_INT 107
18275: PUSH
18276: LD_INT 108
18278: PUSH
18279: LD_INT 109
18281: PUSH
18282: LD_INT 110
18284: PUSH
18285: LD_INT 111
18287: PUSH
18288: LD_INT 112
18290: PUSH
18291: LD_INT 113
18293: PUSH
18294: LD_INT 114
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: LIST
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: LIST
18308: LIST
18309: LIST
18310: LIST
18311: LIST
18312: PUSH
18313: EMPTY
18314: LIST
18315: LIST
18316: ST_TO_ADDR
18317: GO 19264
18319: LD_INT 15
18321: DOUBLE
18322: EQUAL
18323: IFTRUE 18327
18325: GO 18539
18327: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
18328: LD_ADDR_VAR 0 1
18332: PUSH
18333: LD_INT 1
18335: PUSH
18336: LD_INT 2
18338: PUSH
18339: LD_INT 3
18341: PUSH
18342: LD_INT 4
18344: PUSH
18345: LD_INT 5
18347: PUSH
18348: LD_INT 6
18350: PUSH
18351: LD_INT 7
18353: PUSH
18354: LD_INT 8
18356: PUSH
18357: LD_INT 9
18359: PUSH
18360: LD_INT 10
18362: PUSH
18363: LD_INT 11
18365: PUSH
18366: LD_INT 12
18368: PUSH
18369: LD_INT 13
18371: PUSH
18372: LD_INT 14
18374: PUSH
18375: LD_INT 15
18377: PUSH
18378: LD_INT 16
18380: PUSH
18381: LD_INT 17
18383: PUSH
18384: LD_INT 18
18386: PUSH
18387: LD_INT 19
18389: PUSH
18390: LD_INT 20
18392: PUSH
18393: LD_INT 21
18395: PUSH
18396: LD_INT 22
18398: PUSH
18399: LD_INT 23
18401: PUSH
18402: LD_INT 24
18404: PUSH
18405: LD_INT 25
18407: PUSH
18408: LD_INT 26
18410: PUSH
18411: LD_INT 27
18413: PUSH
18414: LD_INT 28
18416: PUSH
18417: LD_INT 29
18419: PUSH
18420: LD_INT 30
18422: PUSH
18423: LD_INT 31
18425: PUSH
18426: LD_INT 32
18428: PUSH
18429: LD_INT 33
18431: PUSH
18432: LD_INT 34
18434: PUSH
18435: LD_INT 36
18437: PUSH
18438: EMPTY
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: PUSH
18475: LD_INT 101
18477: PUSH
18478: LD_INT 102
18480: PUSH
18481: LD_INT 103
18483: PUSH
18484: LD_INT 104
18486: PUSH
18487: LD_INT 105
18489: PUSH
18490: LD_INT 106
18492: PUSH
18493: LD_INT 107
18495: PUSH
18496: LD_INT 108
18498: PUSH
18499: LD_INT 109
18501: PUSH
18502: LD_INT 110
18504: PUSH
18505: LD_INT 111
18507: PUSH
18508: LD_INT 112
18510: PUSH
18511: LD_INT 113
18513: PUSH
18514: LD_INT 114
18516: PUSH
18517: EMPTY
18518: LIST
18519: LIST
18520: LIST
18521: LIST
18522: LIST
18523: LIST
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: ST_TO_ADDR
18537: GO 19264
18539: LD_INT 16
18541: DOUBLE
18542: EQUAL
18543: IFTRUE 18547
18545: GO 18671
18547: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
18548: LD_ADDR_VAR 0 1
18552: PUSH
18553: LD_INT 2
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: LD_INT 5
18561: PUSH
18562: LD_INT 7
18564: PUSH
18565: LD_INT 11
18567: PUSH
18568: LD_INT 12
18570: PUSH
18571: LD_INT 15
18573: PUSH
18574: LD_INT 16
18576: PUSH
18577: LD_INT 20
18579: PUSH
18580: LD_INT 21
18582: PUSH
18583: LD_INT 22
18585: PUSH
18586: LD_INT 23
18588: PUSH
18589: LD_INT 25
18591: PUSH
18592: LD_INT 26
18594: PUSH
18595: LD_INT 30
18597: PUSH
18598: LD_INT 31
18600: PUSH
18601: LD_INT 32
18603: PUSH
18604: LD_INT 33
18606: PUSH
18607: LD_INT 34
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: PUSH
18631: LD_INT 101
18633: PUSH
18634: LD_INT 102
18636: PUSH
18637: LD_INT 103
18639: PUSH
18640: LD_INT 106
18642: PUSH
18643: LD_INT 108
18645: PUSH
18646: LD_INT 112
18648: PUSH
18649: LD_INT 113
18651: PUSH
18652: LD_INT 114
18654: PUSH
18655: EMPTY
18656: LIST
18657: LIST
18658: LIST
18659: LIST
18660: LIST
18661: LIST
18662: LIST
18663: LIST
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: ST_TO_ADDR
18669: GO 19264
18671: LD_INT 17
18673: DOUBLE
18674: EQUAL
18675: IFTRUE 18679
18677: GO 18891
18679: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
18680: LD_ADDR_VAR 0 1
18684: PUSH
18685: LD_INT 1
18687: PUSH
18688: LD_INT 2
18690: PUSH
18691: LD_INT 3
18693: PUSH
18694: LD_INT 4
18696: PUSH
18697: LD_INT 5
18699: PUSH
18700: LD_INT 6
18702: PUSH
18703: LD_INT 7
18705: PUSH
18706: LD_INT 8
18708: PUSH
18709: LD_INT 9
18711: PUSH
18712: LD_INT 10
18714: PUSH
18715: LD_INT 11
18717: PUSH
18718: LD_INT 12
18720: PUSH
18721: LD_INT 13
18723: PUSH
18724: LD_INT 14
18726: PUSH
18727: LD_INT 15
18729: PUSH
18730: LD_INT 16
18732: PUSH
18733: LD_INT 17
18735: PUSH
18736: LD_INT 18
18738: PUSH
18739: LD_INT 19
18741: PUSH
18742: LD_INT 20
18744: PUSH
18745: LD_INT 21
18747: PUSH
18748: LD_INT 22
18750: PUSH
18751: LD_INT 23
18753: PUSH
18754: LD_INT 24
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 26
18762: PUSH
18763: LD_INT 27
18765: PUSH
18766: LD_INT 28
18768: PUSH
18769: LD_INT 29
18771: PUSH
18772: LD_INT 30
18774: PUSH
18775: LD_INT 31
18777: PUSH
18778: LD_INT 32
18780: PUSH
18781: LD_INT 33
18783: PUSH
18784: LD_INT 34
18786: PUSH
18787: LD_INT 36
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 101
18829: PUSH
18830: LD_INT 102
18832: PUSH
18833: LD_INT 103
18835: PUSH
18836: LD_INT 104
18838: PUSH
18839: LD_INT 105
18841: PUSH
18842: LD_INT 106
18844: PUSH
18845: LD_INT 107
18847: PUSH
18848: LD_INT 108
18850: PUSH
18851: LD_INT 109
18853: PUSH
18854: LD_INT 110
18856: PUSH
18857: LD_INT 111
18859: PUSH
18860: LD_INT 112
18862: PUSH
18863: LD_INT 113
18865: PUSH
18866: LD_INT 114
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: LIST
18881: LIST
18882: LIST
18883: LIST
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: ST_TO_ADDR
18889: GO 19264
18891: LD_INT 18
18893: DOUBLE
18894: EQUAL
18895: IFTRUE 18899
18897: GO 19035
18899: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
18900: LD_ADDR_VAR 0 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: LD_INT 4
18910: PUSH
18911: LD_INT 5
18913: PUSH
18914: LD_INT 7
18916: PUSH
18917: LD_INT 11
18919: PUSH
18920: LD_INT 12
18922: PUSH
18923: LD_INT 15
18925: PUSH
18926: LD_INT 16
18928: PUSH
18929: LD_INT 20
18931: PUSH
18932: LD_INT 21
18934: PUSH
18935: LD_INT 22
18937: PUSH
18938: LD_INT 23
18940: PUSH
18941: LD_INT 25
18943: PUSH
18944: LD_INT 26
18946: PUSH
18947: LD_INT 30
18949: PUSH
18950: LD_INT 31
18952: PUSH
18953: LD_INT 32
18955: PUSH
18956: LD_INT 33
18958: PUSH
18959: LD_INT 34
18961: PUSH
18962: LD_INT 35
18964: PUSH
18965: LD_INT 36
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: LIST
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: LIST
18987: LIST
18988: LIST
18989: LIST
18990: PUSH
18991: LD_INT 101
18993: PUSH
18994: LD_INT 102
18996: PUSH
18997: LD_INT 103
18999: PUSH
19000: LD_INT 106
19002: PUSH
19003: LD_INT 108
19005: PUSH
19006: LD_INT 112
19008: PUSH
19009: LD_INT 113
19011: PUSH
19012: LD_INT 114
19014: PUSH
19015: LD_INT 115
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: LIST
19023: LIST
19024: LIST
19025: LIST
19026: LIST
19027: LIST
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: ST_TO_ADDR
19033: GO 19264
19035: LD_INT 19
19037: DOUBLE
19038: EQUAL
19039: IFTRUE 19043
19041: GO 19263
19043: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
19044: LD_ADDR_VAR 0 1
19048: PUSH
19049: LD_INT 1
19051: PUSH
19052: LD_INT 2
19054: PUSH
19055: LD_INT 3
19057: PUSH
19058: LD_INT 4
19060: PUSH
19061: LD_INT 5
19063: PUSH
19064: LD_INT 6
19066: PUSH
19067: LD_INT 7
19069: PUSH
19070: LD_INT 8
19072: PUSH
19073: LD_INT 9
19075: PUSH
19076: LD_INT 10
19078: PUSH
19079: LD_INT 11
19081: PUSH
19082: LD_INT 12
19084: PUSH
19085: LD_INT 13
19087: PUSH
19088: LD_INT 14
19090: PUSH
19091: LD_INT 15
19093: PUSH
19094: LD_INT 16
19096: PUSH
19097: LD_INT 17
19099: PUSH
19100: LD_INT 18
19102: PUSH
19103: LD_INT 19
19105: PUSH
19106: LD_INT 20
19108: PUSH
19109: LD_INT 21
19111: PUSH
19112: LD_INT 22
19114: PUSH
19115: LD_INT 23
19117: PUSH
19118: LD_INT 24
19120: PUSH
19121: LD_INT 25
19123: PUSH
19124: LD_INT 26
19126: PUSH
19127: LD_INT 27
19129: PUSH
19130: LD_INT 28
19132: PUSH
19133: LD_INT 29
19135: PUSH
19136: LD_INT 30
19138: PUSH
19139: LD_INT 31
19141: PUSH
19142: LD_INT 32
19144: PUSH
19145: LD_INT 33
19147: PUSH
19148: LD_INT 34
19150: PUSH
19151: LD_INT 35
19153: PUSH
19154: LD_INT 36
19156: PUSH
19157: EMPTY
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: LIST
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: LIST
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: LIST
19194: PUSH
19195: LD_INT 101
19197: PUSH
19198: LD_INT 102
19200: PUSH
19201: LD_INT 103
19203: PUSH
19204: LD_INT 104
19206: PUSH
19207: LD_INT 105
19209: PUSH
19210: LD_INT 106
19212: PUSH
19213: LD_INT 107
19215: PUSH
19216: LD_INT 108
19218: PUSH
19219: LD_INT 109
19221: PUSH
19222: LD_INT 110
19224: PUSH
19225: LD_INT 111
19227: PUSH
19228: LD_INT 112
19230: PUSH
19231: LD_INT 113
19233: PUSH
19234: LD_INT 114
19236: PUSH
19237: LD_INT 115
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: LIST
19250: LIST
19251: LIST
19252: LIST
19253: LIST
19254: LIST
19255: LIST
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: ST_TO_ADDR
19261: GO 19264
19263: POP
// end ; if result then
19264: LD_VAR 0 1
19268: IFFALSE 19557
// begin normal :=  ;
19270: LD_ADDR_VAR 0 3
19274: PUSH
19275: LD_STRING 
19277: ST_TO_ADDR
// hardcore :=  ;
19278: LD_ADDR_VAR 0 4
19282: PUSH
19283: LD_STRING 
19285: ST_TO_ADDR
// for i = 1 to normalCounter do
19286: LD_ADDR_VAR 0 5
19290: PUSH
19291: DOUBLE
19292: LD_INT 1
19294: DEC
19295: ST_TO_ADDR
19296: LD_EXP 41
19300: PUSH
19301: FOR_TO
19302: IFFALSE 19403
// begin tmp := 0 ;
19304: LD_ADDR_VAR 0 2
19308: PUSH
19309: LD_STRING 0
19311: ST_TO_ADDR
// if result [ 1 ] then
19312: LD_VAR 0 1
19316: PUSH
19317: LD_INT 1
19319: ARRAY
19320: IFFALSE 19385
// if result [ 1 ] [ 1 ] = i then
19322: LD_VAR 0 1
19326: PUSH
19327: LD_INT 1
19329: ARRAY
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: PUSH
19335: LD_VAR 0 5
19339: EQUAL
19340: IFFALSE 19385
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
19342: LD_ADDR_VAR 0 1
19346: PUSH
19347: LD_VAR 0 1
19351: PPUSH
19352: LD_INT 1
19354: PPUSH
19355: LD_VAR 0 1
19359: PUSH
19360: LD_INT 1
19362: ARRAY
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 3
19371: PPUSH
19372: CALL_OW 1
19376: ST_TO_ADDR
// tmp := 1 ;
19377: LD_ADDR_VAR 0 2
19381: PUSH
19382: LD_STRING 1
19384: ST_TO_ADDR
// end ; normal := normal & tmp ;
19385: LD_ADDR_VAR 0 3
19389: PUSH
19390: LD_VAR 0 3
19394: PUSH
19395: LD_VAR 0 2
19399: STR
19400: ST_TO_ADDR
// end ;
19401: GO 19301
19403: POP
19404: POP
// for i = 1 to hardcoreCounter do
19405: LD_ADDR_VAR 0 5
19409: PUSH
19410: DOUBLE
19411: LD_INT 1
19413: DEC
19414: ST_TO_ADDR
19415: LD_EXP 42
19419: PUSH
19420: FOR_TO
19421: IFFALSE 19526
// begin tmp := 0 ;
19423: LD_ADDR_VAR 0 2
19427: PUSH
19428: LD_STRING 0
19430: ST_TO_ADDR
// if result [ 2 ] then
19431: LD_VAR 0 1
19435: PUSH
19436: LD_INT 2
19438: ARRAY
19439: IFFALSE 19508
// if result [ 2 ] [ 1 ] = 100 + i then
19441: LD_VAR 0 1
19445: PUSH
19446: LD_INT 2
19448: ARRAY
19449: PUSH
19450: LD_INT 1
19452: ARRAY
19453: PUSH
19454: LD_INT 100
19456: PUSH
19457: LD_VAR 0 5
19461: PLUS
19462: EQUAL
19463: IFFALSE 19508
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
19465: LD_ADDR_VAR 0 1
19469: PUSH
19470: LD_VAR 0 1
19474: PPUSH
19475: LD_INT 2
19477: PPUSH
19478: LD_VAR 0 1
19482: PUSH
19483: LD_INT 2
19485: ARRAY
19486: PPUSH
19487: LD_INT 1
19489: PPUSH
19490: CALL_OW 3
19494: PPUSH
19495: CALL_OW 1
19499: ST_TO_ADDR
// tmp := 1 ;
19500: LD_ADDR_VAR 0 2
19504: PUSH
19505: LD_STRING 1
19507: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
19508: LD_ADDR_VAR 0 4
19512: PUSH
19513: LD_VAR 0 4
19517: PUSH
19518: LD_VAR 0 2
19522: STR
19523: ST_TO_ADDR
// end ;
19524: GO 19420
19526: POP
19527: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
19528: LD_STRING getStreamItemsFromMission("
19530: PUSH
19531: LD_VAR 0 3
19535: STR
19536: PUSH
19537: LD_STRING ","
19539: STR
19540: PUSH
19541: LD_VAR 0 4
19545: STR
19546: PUSH
19547: LD_STRING ")
19549: STR
19550: PPUSH
19551: CALL_OW 559
// end else
19555: GO 19564
// ToLua ( getStreamItemsFromMission("","") ) ;
19557: LD_STRING getStreamItemsFromMission("","")
19559: PPUSH
19560: CALL_OW 559
// end ;
19564: LD_VAR 0 1
19568: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19569: LD_VAR 0 2
19573: PUSH
19574: LD_INT 100
19576: EQUAL
19577: IFFALSE 20526
// begin if not StreamModeActive then
19579: LD_EXP 40
19583: NOT
19584: IFFALSE 19594
// StreamModeActive := true ;
19586: LD_ADDR_EXP 40
19590: PUSH
19591: LD_INT 1
19593: ST_TO_ADDR
// if p3 = 0 then
19594: LD_VAR 0 3
19598: PUSH
19599: LD_INT 0
19601: EQUAL
19602: IFFALSE 19608
// InitStreamMode ;
19604: CALL 15854 0 0
// if p3 = 1 then
19608: LD_VAR 0 3
19612: PUSH
19613: LD_INT 1
19615: EQUAL
19616: IFFALSE 19626
// sRocket := true ;
19618: LD_ADDR_EXP 45
19622: PUSH
19623: LD_INT 1
19625: ST_TO_ADDR
// if p3 = 2 then
19626: LD_VAR 0 3
19630: PUSH
19631: LD_INT 2
19633: EQUAL
19634: IFFALSE 19644
// sSpeed := true ;
19636: LD_ADDR_EXP 44
19640: PUSH
19641: LD_INT 1
19643: ST_TO_ADDR
// if p3 = 3 then
19644: LD_VAR 0 3
19648: PUSH
19649: LD_INT 3
19651: EQUAL
19652: IFFALSE 19662
// sEngine := true ;
19654: LD_ADDR_EXP 46
19658: PUSH
19659: LD_INT 1
19661: ST_TO_ADDR
// if p3 = 4 then
19662: LD_VAR 0 3
19666: PUSH
19667: LD_INT 4
19669: EQUAL
19670: IFFALSE 19680
// sSpec := true ;
19672: LD_ADDR_EXP 43
19676: PUSH
19677: LD_INT 1
19679: ST_TO_ADDR
// if p3 = 5 then
19680: LD_VAR 0 3
19684: PUSH
19685: LD_INT 5
19687: EQUAL
19688: IFFALSE 19698
// sLevel := true ;
19690: LD_ADDR_EXP 47
19694: PUSH
19695: LD_INT 1
19697: ST_TO_ADDR
// if p3 = 6 then
19698: LD_VAR 0 3
19702: PUSH
19703: LD_INT 6
19705: EQUAL
19706: IFFALSE 19716
// sArmoury := true ;
19708: LD_ADDR_EXP 48
19712: PUSH
19713: LD_INT 1
19715: ST_TO_ADDR
// if p3 = 7 then
19716: LD_VAR 0 3
19720: PUSH
19721: LD_INT 7
19723: EQUAL
19724: IFFALSE 19734
// sRadar := true ;
19726: LD_ADDR_EXP 49
19730: PUSH
19731: LD_INT 1
19733: ST_TO_ADDR
// if p3 = 8 then
19734: LD_VAR 0 3
19738: PUSH
19739: LD_INT 8
19741: EQUAL
19742: IFFALSE 19752
// sBunker := true ;
19744: LD_ADDR_EXP 50
19748: PUSH
19749: LD_INT 1
19751: ST_TO_ADDR
// if p3 = 9 then
19752: LD_VAR 0 3
19756: PUSH
19757: LD_INT 9
19759: EQUAL
19760: IFFALSE 19770
// sHack := true ;
19762: LD_ADDR_EXP 51
19766: PUSH
19767: LD_INT 1
19769: ST_TO_ADDR
// if p3 = 10 then
19770: LD_VAR 0 3
19774: PUSH
19775: LD_INT 10
19777: EQUAL
19778: IFFALSE 19788
// sFire := true ;
19780: LD_ADDR_EXP 52
19784: PUSH
19785: LD_INT 1
19787: ST_TO_ADDR
// if p3 = 11 then
19788: LD_VAR 0 3
19792: PUSH
19793: LD_INT 11
19795: EQUAL
19796: IFFALSE 19806
// sRefresh := true ;
19798: LD_ADDR_EXP 53
19802: PUSH
19803: LD_INT 1
19805: ST_TO_ADDR
// if p3 = 12 then
19806: LD_VAR 0 3
19810: PUSH
19811: LD_INT 12
19813: EQUAL
19814: IFFALSE 19824
// sExp := true ;
19816: LD_ADDR_EXP 54
19820: PUSH
19821: LD_INT 1
19823: ST_TO_ADDR
// if p3 = 13 then
19824: LD_VAR 0 3
19828: PUSH
19829: LD_INT 13
19831: EQUAL
19832: IFFALSE 19842
// sDepot := true ;
19834: LD_ADDR_EXP 55
19838: PUSH
19839: LD_INT 1
19841: ST_TO_ADDR
// if p3 = 14 then
19842: LD_VAR 0 3
19846: PUSH
19847: LD_INT 14
19849: EQUAL
19850: IFFALSE 19860
// sFlag := true ;
19852: LD_ADDR_EXP 56
19856: PUSH
19857: LD_INT 1
19859: ST_TO_ADDR
// if p3 = 15 then
19860: LD_VAR 0 3
19864: PUSH
19865: LD_INT 15
19867: EQUAL
19868: IFFALSE 19878
// sKamikadze := true ;
19870: LD_ADDR_EXP 64
19874: PUSH
19875: LD_INT 1
19877: ST_TO_ADDR
// if p3 = 16 then
19878: LD_VAR 0 3
19882: PUSH
19883: LD_INT 16
19885: EQUAL
19886: IFFALSE 19896
// sTroll := true ;
19888: LD_ADDR_EXP 65
19892: PUSH
19893: LD_INT 1
19895: ST_TO_ADDR
// if p3 = 17 then
19896: LD_VAR 0 3
19900: PUSH
19901: LD_INT 17
19903: EQUAL
19904: IFFALSE 19914
// sSlow := true ;
19906: LD_ADDR_EXP 66
19910: PUSH
19911: LD_INT 1
19913: ST_TO_ADDR
// if p3 = 18 then
19914: LD_VAR 0 3
19918: PUSH
19919: LD_INT 18
19921: EQUAL
19922: IFFALSE 19932
// sLack := true ;
19924: LD_ADDR_EXP 67
19928: PUSH
19929: LD_INT 1
19931: ST_TO_ADDR
// if p3 = 19 then
19932: LD_VAR 0 3
19936: PUSH
19937: LD_INT 19
19939: EQUAL
19940: IFFALSE 19950
// sTank := true ;
19942: LD_ADDR_EXP 69
19946: PUSH
19947: LD_INT 1
19949: ST_TO_ADDR
// if p3 = 20 then
19950: LD_VAR 0 3
19954: PUSH
19955: LD_INT 20
19957: EQUAL
19958: IFFALSE 19968
// sRemote := true ;
19960: LD_ADDR_EXP 70
19964: PUSH
19965: LD_INT 1
19967: ST_TO_ADDR
// if p3 = 21 then
19968: LD_VAR 0 3
19972: PUSH
19973: LD_INT 21
19975: EQUAL
19976: IFFALSE 19986
// sPowell := true ;
19978: LD_ADDR_EXP 71
19982: PUSH
19983: LD_INT 1
19985: ST_TO_ADDR
// if p3 = 22 then
19986: LD_VAR 0 3
19990: PUSH
19991: LD_INT 22
19993: EQUAL
19994: IFFALSE 20004
// sTeleport := true ;
19996: LD_ADDR_EXP 74
20000: PUSH
20001: LD_INT 1
20003: ST_TO_ADDR
// if p3 = 23 then
20004: LD_VAR 0 3
20008: PUSH
20009: LD_INT 23
20011: EQUAL
20012: IFFALSE 20022
// sOilTower := true ;
20014: LD_ADDR_EXP 76
20018: PUSH
20019: LD_INT 1
20021: ST_TO_ADDR
// if p3 = 24 then
20022: LD_VAR 0 3
20026: PUSH
20027: LD_INT 24
20029: EQUAL
20030: IFFALSE 20040
// sShovel := true ;
20032: LD_ADDR_EXP 77
20036: PUSH
20037: LD_INT 1
20039: ST_TO_ADDR
// if p3 = 25 then
20040: LD_VAR 0 3
20044: PUSH
20045: LD_INT 25
20047: EQUAL
20048: IFFALSE 20058
// sSheik := true ;
20050: LD_ADDR_EXP 78
20054: PUSH
20055: LD_INT 1
20057: ST_TO_ADDR
// if p3 = 26 then
20058: LD_VAR 0 3
20062: PUSH
20063: LD_INT 26
20065: EQUAL
20066: IFFALSE 20076
// sEarthquake := true ;
20068: LD_ADDR_EXP 80
20072: PUSH
20073: LD_INT 1
20075: ST_TO_ADDR
// if p3 = 27 then
20076: LD_VAR 0 3
20080: PUSH
20081: LD_INT 27
20083: EQUAL
20084: IFFALSE 20094
// sAI := true ;
20086: LD_ADDR_EXP 81
20090: PUSH
20091: LD_INT 1
20093: ST_TO_ADDR
// if p3 = 28 then
20094: LD_VAR 0 3
20098: PUSH
20099: LD_INT 28
20101: EQUAL
20102: IFFALSE 20112
// sCargo := true ;
20104: LD_ADDR_EXP 84
20108: PUSH
20109: LD_INT 1
20111: ST_TO_ADDR
// if p3 = 29 then
20112: LD_VAR 0 3
20116: PUSH
20117: LD_INT 29
20119: EQUAL
20120: IFFALSE 20130
// sDLaser := true ;
20122: LD_ADDR_EXP 85
20126: PUSH
20127: LD_INT 1
20129: ST_TO_ADDR
// if p3 = 30 then
20130: LD_VAR 0 3
20134: PUSH
20135: LD_INT 30
20137: EQUAL
20138: IFFALSE 20148
// sExchange := true ;
20140: LD_ADDR_EXP 86
20144: PUSH
20145: LD_INT 1
20147: ST_TO_ADDR
// if p3 = 31 then
20148: LD_VAR 0 3
20152: PUSH
20153: LD_INT 31
20155: EQUAL
20156: IFFALSE 20166
// sFac := true ;
20158: LD_ADDR_EXP 87
20162: PUSH
20163: LD_INT 1
20165: ST_TO_ADDR
// if p3 = 32 then
20166: LD_VAR 0 3
20170: PUSH
20171: LD_INT 32
20173: EQUAL
20174: IFFALSE 20184
// sPower := true ;
20176: LD_ADDR_EXP 88
20180: PUSH
20181: LD_INT 1
20183: ST_TO_ADDR
// if p3 = 33 then
20184: LD_VAR 0 3
20188: PUSH
20189: LD_INT 33
20191: EQUAL
20192: IFFALSE 20202
// sRandom := true ;
20194: LD_ADDR_EXP 89
20198: PUSH
20199: LD_INT 1
20201: ST_TO_ADDR
// if p3 = 34 then
20202: LD_VAR 0 3
20206: PUSH
20207: LD_INT 34
20209: EQUAL
20210: IFFALSE 20220
// sShield := true ;
20212: LD_ADDR_EXP 90
20216: PUSH
20217: LD_INT 1
20219: ST_TO_ADDR
// if p3 = 35 then
20220: LD_VAR 0 3
20224: PUSH
20225: LD_INT 35
20227: EQUAL
20228: IFFALSE 20238
// sTime := true ;
20230: LD_ADDR_EXP 91
20234: PUSH
20235: LD_INT 1
20237: ST_TO_ADDR
// if p3 = 36 then
20238: LD_VAR 0 3
20242: PUSH
20243: LD_INT 36
20245: EQUAL
20246: IFFALSE 20256
// sTools := true ;
20248: LD_ADDR_EXP 92
20252: PUSH
20253: LD_INT 1
20255: ST_TO_ADDR
// if p3 = 101 then
20256: LD_VAR 0 3
20260: PUSH
20261: LD_INT 101
20263: EQUAL
20264: IFFALSE 20274
// sSold := true ;
20266: LD_ADDR_EXP 57
20270: PUSH
20271: LD_INT 1
20273: ST_TO_ADDR
// if p3 = 102 then
20274: LD_VAR 0 3
20278: PUSH
20279: LD_INT 102
20281: EQUAL
20282: IFFALSE 20292
// sDiff := true ;
20284: LD_ADDR_EXP 58
20288: PUSH
20289: LD_INT 1
20291: ST_TO_ADDR
// if p3 = 103 then
20292: LD_VAR 0 3
20296: PUSH
20297: LD_INT 103
20299: EQUAL
20300: IFFALSE 20310
// sFog := true ;
20302: LD_ADDR_EXP 61
20306: PUSH
20307: LD_INT 1
20309: ST_TO_ADDR
// if p3 = 104 then
20310: LD_VAR 0 3
20314: PUSH
20315: LD_INT 104
20317: EQUAL
20318: IFFALSE 20328
// sReset := true ;
20320: LD_ADDR_EXP 62
20324: PUSH
20325: LD_INT 1
20327: ST_TO_ADDR
// if p3 = 105 then
20328: LD_VAR 0 3
20332: PUSH
20333: LD_INT 105
20335: EQUAL
20336: IFFALSE 20346
// sSun := true ;
20338: LD_ADDR_EXP 63
20342: PUSH
20343: LD_INT 1
20345: ST_TO_ADDR
// if p3 = 106 then
20346: LD_VAR 0 3
20350: PUSH
20351: LD_INT 106
20353: EQUAL
20354: IFFALSE 20364
// sTiger := true ;
20356: LD_ADDR_EXP 59
20360: PUSH
20361: LD_INT 1
20363: ST_TO_ADDR
// if p3 = 107 then
20364: LD_VAR 0 3
20368: PUSH
20369: LD_INT 107
20371: EQUAL
20372: IFFALSE 20382
// sBomb := true ;
20374: LD_ADDR_EXP 60
20378: PUSH
20379: LD_INT 1
20381: ST_TO_ADDR
// if p3 = 108 then
20382: LD_VAR 0 3
20386: PUSH
20387: LD_INT 108
20389: EQUAL
20390: IFFALSE 20400
// sWound := true ;
20392: LD_ADDR_EXP 68
20396: PUSH
20397: LD_INT 1
20399: ST_TO_ADDR
// if p3 = 109 then
20400: LD_VAR 0 3
20404: PUSH
20405: LD_INT 109
20407: EQUAL
20408: IFFALSE 20418
// sBetray := true ;
20410: LD_ADDR_EXP 72
20414: PUSH
20415: LD_INT 1
20417: ST_TO_ADDR
// if p3 = 110 then
20418: LD_VAR 0 3
20422: PUSH
20423: LD_INT 110
20425: EQUAL
20426: IFFALSE 20436
// sContamin := true ;
20428: LD_ADDR_EXP 73
20432: PUSH
20433: LD_INT 1
20435: ST_TO_ADDR
// if p3 = 111 then
20436: LD_VAR 0 3
20440: PUSH
20441: LD_INT 111
20443: EQUAL
20444: IFFALSE 20454
// sOil := true ;
20446: LD_ADDR_EXP 75
20450: PUSH
20451: LD_INT 1
20453: ST_TO_ADDR
// if p3 = 112 then
20454: LD_VAR 0 3
20458: PUSH
20459: LD_INT 112
20461: EQUAL
20462: IFFALSE 20472
// sStu := true ;
20464: LD_ADDR_EXP 79
20468: PUSH
20469: LD_INT 1
20471: ST_TO_ADDR
// if p3 = 113 then
20472: LD_VAR 0 3
20476: PUSH
20477: LD_INT 113
20479: EQUAL
20480: IFFALSE 20490
// sBazooka := true ;
20482: LD_ADDR_EXP 82
20486: PUSH
20487: LD_INT 1
20489: ST_TO_ADDR
// if p3 = 114 then
20490: LD_VAR 0 3
20494: PUSH
20495: LD_INT 114
20497: EQUAL
20498: IFFALSE 20508
// sMortar := true ;
20500: LD_ADDR_EXP 83
20504: PUSH
20505: LD_INT 1
20507: ST_TO_ADDR
// if p3 = 115 then
20508: LD_VAR 0 3
20512: PUSH
20513: LD_INT 115
20515: EQUAL
20516: IFFALSE 20526
// sRanger := true ;
20518: LD_ADDR_EXP 93
20522: PUSH
20523: LD_INT 1
20525: ST_TO_ADDR
// end ; end ;
20526: PPOPN 6
20528: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
20529: LD_EXP 40
20533: PUSH
20534: LD_EXP 45
20538: AND
20539: IFFALSE 20663
20541: GO 20543
20543: DISABLE
20544: LD_INT 0
20546: PPUSH
20547: PPUSH
// begin enable ;
20548: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
20549: LD_ADDR_VAR 0 2
20553: PUSH
20554: LD_INT 22
20556: PUSH
20557: LD_OWVAR 2
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: LD_INT 2
20568: PUSH
20569: LD_INT 34
20571: PUSH
20572: LD_INT 7
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: PUSH
20579: LD_INT 34
20581: PUSH
20582: LD_INT 45
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: PUSH
20589: LD_INT 34
20591: PUSH
20592: LD_INT 28
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: PUSH
20599: LD_INT 34
20601: PUSH
20602: LD_INT 47
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: PUSH
20609: EMPTY
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: LIST
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PPUSH
20620: CALL_OW 69
20624: ST_TO_ADDR
// if not tmp then
20625: LD_VAR 0 2
20629: NOT
20630: IFFALSE 20634
// exit ;
20632: GO 20663
// for i in tmp do
20634: LD_ADDR_VAR 0 1
20638: PUSH
20639: LD_VAR 0 2
20643: PUSH
20644: FOR_IN
20645: IFFALSE 20661
// begin SetLives ( i , 0 ) ;
20647: LD_VAR 0 1
20651: PPUSH
20652: LD_INT 0
20654: PPUSH
20655: CALL_OW 234
// end ;
20659: GO 20644
20661: POP
20662: POP
// end ;
20663: PPOPN 2
20665: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
20666: LD_EXP 40
20670: PUSH
20671: LD_EXP 46
20675: AND
20676: IFFALSE 20760
20678: GO 20680
20680: DISABLE
20681: LD_INT 0
20683: PPUSH
20684: PPUSH
// begin enable ;
20685: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
20686: LD_ADDR_VAR 0 2
20690: PUSH
20691: LD_INT 22
20693: PUSH
20694: LD_OWVAR 2
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PUSH
20703: LD_INT 32
20705: PUSH
20706: LD_INT 3
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PUSH
20713: EMPTY
20714: LIST
20715: LIST
20716: PPUSH
20717: CALL_OW 69
20721: ST_TO_ADDR
// if not tmp then
20722: LD_VAR 0 2
20726: NOT
20727: IFFALSE 20731
// exit ;
20729: GO 20760
// for i in tmp do
20731: LD_ADDR_VAR 0 1
20735: PUSH
20736: LD_VAR 0 2
20740: PUSH
20741: FOR_IN
20742: IFFALSE 20758
// begin SetLives ( i , 0 ) ;
20744: LD_VAR 0 1
20748: PPUSH
20749: LD_INT 0
20751: PPUSH
20752: CALL_OW 234
// end ;
20756: GO 20741
20758: POP
20759: POP
// end ;
20760: PPOPN 2
20762: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
20763: LD_EXP 40
20767: PUSH
20768: LD_EXP 43
20772: AND
20773: IFFALSE 20866
20775: GO 20777
20777: DISABLE
20778: LD_INT 0
20780: PPUSH
// begin enable ;
20781: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
20782: LD_ADDR_VAR 0 1
20786: PUSH
20787: LD_INT 22
20789: PUSH
20790: LD_OWVAR 2
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PUSH
20799: LD_INT 2
20801: PUSH
20802: LD_INT 25
20804: PUSH
20805: LD_INT 5
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PUSH
20812: LD_INT 25
20814: PUSH
20815: LD_INT 9
20817: PUSH
20818: EMPTY
20819: LIST
20820: LIST
20821: PUSH
20822: LD_INT 25
20824: PUSH
20825: LD_INT 8
20827: PUSH
20828: EMPTY
20829: LIST
20830: LIST
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: LIST
20836: LIST
20837: PUSH
20838: EMPTY
20839: LIST
20840: LIST
20841: PPUSH
20842: CALL_OW 69
20846: PUSH
20847: FOR_IN
20848: IFFALSE 20864
// begin SetClass ( i , 1 ) ;
20850: LD_VAR 0 1
20854: PPUSH
20855: LD_INT 1
20857: PPUSH
20858: CALL_OW 336
// end ;
20862: GO 20847
20864: POP
20865: POP
// end ;
20866: PPOPN 1
20868: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
20869: LD_EXP 40
20873: PUSH
20874: LD_EXP 44
20878: AND
20879: PUSH
20880: LD_OWVAR 65
20884: PUSH
20885: LD_INT 7
20887: LESS
20888: AND
20889: IFFALSE 20903
20891: GO 20893
20893: DISABLE
// begin enable ;
20894: ENABLE
// game_speed := 7 ;
20895: LD_ADDR_OWVAR 65
20899: PUSH
20900: LD_INT 7
20902: ST_TO_ADDR
// end ;
20903: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
20904: LD_EXP 40
20908: PUSH
20909: LD_EXP 47
20913: AND
20914: IFFALSE 21116
20916: GO 20918
20918: DISABLE
20919: LD_INT 0
20921: PPUSH
20922: PPUSH
20923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
20924: LD_ADDR_VAR 0 3
20928: PUSH
20929: LD_INT 81
20931: PUSH
20932: LD_OWVAR 2
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PUSH
20941: LD_INT 21
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PPUSH
20955: CALL_OW 69
20959: ST_TO_ADDR
// if not tmp then
20960: LD_VAR 0 3
20964: NOT
20965: IFFALSE 20969
// exit ;
20967: GO 21116
// if tmp > 5 then
20969: LD_VAR 0 3
20973: PUSH
20974: LD_INT 5
20976: GREATER
20977: IFFALSE 20989
// k := 5 else
20979: LD_ADDR_VAR 0 2
20983: PUSH
20984: LD_INT 5
20986: ST_TO_ADDR
20987: GO 20999
// k := tmp ;
20989: LD_ADDR_VAR 0 2
20993: PUSH
20994: LD_VAR 0 3
20998: ST_TO_ADDR
// for i := 1 to k do
20999: LD_ADDR_VAR 0 1
21003: PUSH
21004: DOUBLE
21005: LD_INT 1
21007: DEC
21008: ST_TO_ADDR
21009: LD_VAR 0 2
21013: PUSH
21014: FOR_TO
21015: IFFALSE 21114
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
21017: LD_VAR 0 3
21021: PUSH
21022: LD_VAR 0 1
21026: ARRAY
21027: PPUSH
21028: LD_VAR 0 1
21032: PUSH
21033: LD_INT 4
21035: MOD
21036: PUSH
21037: LD_INT 1
21039: PLUS
21040: PPUSH
21041: CALL_OW 259
21045: PUSH
21046: LD_INT 10
21048: LESS
21049: IFFALSE 21112
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
21051: LD_VAR 0 3
21055: PUSH
21056: LD_VAR 0 1
21060: ARRAY
21061: PPUSH
21062: LD_VAR 0 1
21066: PUSH
21067: LD_INT 4
21069: MOD
21070: PUSH
21071: LD_INT 1
21073: PLUS
21074: PPUSH
21075: LD_VAR 0 3
21079: PUSH
21080: LD_VAR 0 1
21084: ARRAY
21085: PPUSH
21086: LD_VAR 0 1
21090: PUSH
21091: LD_INT 4
21093: MOD
21094: PUSH
21095: LD_INT 1
21097: PLUS
21098: PPUSH
21099: CALL_OW 259
21103: PUSH
21104: LD_INT 1
21106: PLUS
21107: PPUSH
21108: CALL_OW 237
21112: GO 21014
21114: POP
21115: POP
// end ;
21116: PPOPN 3
21118: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
21119: LD_EXP 40
21123: PUSH
21124: LD_EXP 48
21128: AND
21129: IFFALSE 21149
21131: GO 21133
21133: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
21134: LD_INT 4
21136: PPUSH
21137: LD_OWVAR 2
21141: PPUSH
21142: LD_INT 0
21144: PPUSH
21145: CALL_OW 324
21149: END
// every 0 0$1 trigger StreamModeActive and sShovel do
21150: LD_EXP 40
21154: PUSH
21155: LD_EXP 77
21159: AND
21160: IFFALSE 21180
21162: GO 21164
21164: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
21165: LD_INT 19
21167: PPUSH
21168: LD_OWVAR 2
21172: PPUSH
21173: LD_INT 0
21175: PPUSH
21176: CALL_OW 324
21180: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
21181: LD_EXP 40
21185: PUSH
21186: LD_EXP 49
21190: AND
21191: IFFALSE 21293
21193: GO 21195
21195: DISABLE
21196: LD_INT 0
21198: PPUSH
21199: PPUSH
// begin enable ;
21200: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
21201: LD_ADDR_VAR 0 2
21205: PUSH
21206: LD_INT 22
21208: PUSH
21209: LD_OWVAR 2
21213: PUSH
21214: EMPTY
21215: LIST
21216: LIST
21217: PUSH
21218: LD_INT 2
21220: PUSH
21221: LD_INT 34
21223: PUSH
21224: LD_INT 11
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: LD_INT 34
21233: PUSH
21234: LD_INT 30
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: PUSH
21241: EMPTY
21242: LIST
21243: LIST
21244: LIST
21245: PUSH
21246: EMPTY
21247: LIST
21248: LIST
21249: PPUSH
21250: CALL_OW 69
21254: ST_TO_ADDR
// if not tmp then
21255: LD_VAR 0 2
21259: NOT
21260: IFFALSE 21264
// exit ;
21262: GO 21293
// for i in tmp do
21264: LD_ADDR_VAR 0 1
21268: PUSH
21269: LD_VAR 0 2
21273: PUSH
21274: FOR_IN
21275: IFFALSE 21291
// begin SetLives ( i , 0 ) ;
21277: LD_VAR 0 1
21281: PPUSH
21282: LD_INT 0
21284: PPUSH
21285: CALL_OW 234
// end ;
21289: GO 21274
21291: POP
21292: POP
// end ;
21293: PPOPN 2
21295: END
// every 0 0$1 trigger StreamModeActive and sBunker do
21296: LD_EXP 40
21300: PUSH
21301: LD_EXP 50
21305: AND
21306: IFFALSE 21326
21308: GO 21310
21310: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
21311: LD_INT 32
21313: PPUSH
21314: LD_OWVAR 2
21318: PPUSH
21319: LD_INT 0
21321: PPUSH
21322: CALL_OW 324
21326: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
21327: LD_EXP 40
21331: PUSH
21332: LD_EXP 51
21336: AND
21337: IFFALSE 21518
21339: GO 21341
21341: DISABLE
21342: LD_INT 0
21344: PPUSH
21345: PPUSH
21346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
21347: LD_ADDR_VAR 0 2
21351: PUSH
21352: LD_INT 22
21354: PUSH
21355: LD_OWVAR 2
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: LD_INT 33
21366: PUSH
21367: LD_INT 3
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: PUSH
21374: EMPTY
21375: LIST
21376: LIST
21377: PPUSH
21378: CALL_OW 69
21382: ST_TO_ADDR
// if not tmp then
21383: LD_VAR 0 2
21387: NOT
21388: IFFALSE 21392
// exit ;
21390: GO 21518
// side := 0 ;
21392: LD_ADDR_VAR 0 3
21396: PUSH
21397: LD_INT 0
21399: ST_TO_ADDR
// for i := 1 to 8 do
21400: LD_ADDR_VAR 0 1
21404: PUSH
21405: DOUBLE
21406: LD_INT 1
21408: DEC
21409: ST_TO_ADDR
21410: LD_INT 8
21412: PUSH
21413: FOR_TO
21414: IFFALSE 21462
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
21416: LD_OWVAR 2
21420: PUSH
21421: LD_VAR 0 1
21425: NONEQUAL
21426: PUSH
21427: LD_OWVAR 2
21431: PPUSH
21432: LD_VAR 0 1
21436: PPUSH
21437: CALL_OW 81
21441: PUSH
21442: LD_INT 2
21444: EQUAL
21445: AND
21446: IFFALSE 21460
// begin side := i ;
21448: LD_ADDR_VAR 0 3
21452: PUSH
21453: LD_VAR 0 1
21457: ST_TO_ADDR
// break ;
21458: GO 21462
// end ;
21460: GO 21413
21462: POP
21463: POP
// if not side then
21464: LD_VAR 0 3
21468: NOT
21469: IFFALSE 21473
// exit ;
21471: GO 21518
// for i := 1 to tmp do
21473: LD_ADDR_VAR 0 1
21477: PUSH
21478: DOUBLE
21479: LD_INT 1
21481: DEC
21482: ST_TO_ADDR
21483: LD_VAR 0 2
21487: PUSH
21488: FOR_TO
21489: IFFALSE 21516
// if Prob ( 30 ) then
21491: LD_INT 30
21493: PPUSH
21494: CALL_OW 13
21498: IFFALSE 21514
// SetSide ( i , side ) ;
21500: LD_VAR 0 1
21504: PPUSH
21505: LD_VAR 0 3
21509: PPUSH
21510: CALL_OW 235
21514: GO 21488
21516: POP
21517: POP
// end ;
21518: PPOPN 3
21520: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
21521: LD_EXP 40
21525: PUSH
21526: LD_EXP 53
21530: AND
21531: IFFALSE 21650
21533: GO 21535
21535: DISABLE
21536: LD_INT 0
21538: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
21539: LD_ADDR_VAR 0 1
21543: PUSH
21544: LD_INT 22
21546: PUSH
21547: LD_OWVAR 2
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: PUSH
21556: LD_INT 21
21558: PUSH
21559: LD_INT 1
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: PUSH
21566: LD_INT 3
21568: PUSH
21569: LD_INT 23
21571: PUSH
21572: LD_INT 0
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: LIST
21587: PPUSH
21588: CALL_OW 69
21592: PUSH
21593: FOR_IN
21594: IFFALSE 21648
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
21596: LD_VAR 0 1
21600: PPUSH
21601: CALL_OW 257
21605: PUSH
21606: LD_INT 1
21608: PUSH
21609: LD_INT 2
21611: PUSH
21612: LD_INT 3
21614: PUSH
21615: LD_INT 4
21617: PUSH
21618: EMPTY
21619: LIST
21620: LIST
21621: LIST
21622: LIST
21623: IN
21624: IFFALSE 21646
// SetClass ( un , rand ( 1 , 4 ) ) ;
21626: LD_VAR 0 1
21630: PPUSH
21631: LD_INT 1
21633: PPUSH
21634: LD_INT 4
21636: PPUSH
21637: CALL_OW 12
21641: PPUSH
21642: CALL_OW 336
21646: GO 21593
21648: POP
21649: POP
// end ;
21650: PPOPN 1
21652: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
21653: LD_EXP 40
21657: PUSH
21658: LD_EXP 52
21662: AND
21663: IFFALSE 21742
21665: GO 21667
21667: DISABLE
21668: LD_INT 0
21670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21671: LD_ADDR_VAR 0 1
21675: PUSH
21676: LD_INT 22
21678: PUSH
21679: LD_OWVAR 2
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: PUSH
21688: LD_INT 21
21690: PUSH
21691: LD_INT 3
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: PPUSH
21702: CALL_OW 69
21706: ST_TO_ADDR
// if not tmp then
21707: LD_VAR 0 1
21711: NOT
21712: IFFALSE 21716
// exit ;
21714: GO 21742
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
21716: LD_VAR 0 1
21720: PUSH
21721: LD_INT 1
21723: PPUSH
21724: LD_VAR 0 1
21728: PPUSH
21729: CALL_OW 12
21733: ARRAY
21734: PPUSH
21735: LD_INT 100
21737: PPUSH
21738: CALL_OW 234
// end ;
21742: PPOPN 1
21744: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
21745: LD_EXP 40
21749: PUSH
21750: LD_EXP 54
21754: AND
21755: IFFALSE 21853
21757: GO 21759
21759: DISABLE
21760: LD_INT 0
21762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
21763: LD_ADDR_VAR 0 1
21767: PUSH
21768: LD_INT 22
21770: PUSH
21771: LD_OWVAR 2
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: LD_INT 21
21782: PUSH
21783: LD_INT 1
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PPUSH
21794: CALL_OW 69
21798: ST_TO_ADDR
// if not tmp then
21799: LD_VAR 0 1
21803: NOT
21804: IFFALSE 21808
// exit ;
21806: GO 21853
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 1
21815: PPUSH
21816: LD_VAR 0 1
21820: PPUSH
21821: CALL_OW 12
21825: ARRAY
21826: PPUSH
21827: LD_INT 1
21829: PPUSH
21830: LD_INT 4
21832: PPUSH
21833: CALL_OW 12
21837: PPUSH
21838: LD_INT 3000
21840: PPUSH
21841: LD_INT 9000
21843: PPUSH
21844: CALL_OW 12
21848: PPUSH
21849: CALL_OW 492
// end ;
21853: PPOPN 1
21855: END
// every 0 0$1 trigger StreamModeActive and sDepot do
21856: LD_EXP 40
21860: PUSH
21861: LD_EXP 55
21865: AND
21866: IFFALSE 21886
21868: GO 21870
21870: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
21871: LD_INT 1
21873: PPUSH
21874: LD_OWVAR 2
21878: PPUSH
21879: LD_INT 0
21881: PPUSH
21882: CALL_OW 324
21886: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
21887: LD_EXP 40
21891: PUSH
21892: LD_EXP 56
21896: AND
21897: IFFALSE 21980
21899: GO 21901
21901: DISABLE
21902: LD_INT 0
21904: PPUSH
21905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21906: LD_ADDR_VAR 0 2
21910: PUSH
21911: LD_INT 22
21913: PUSH
21914: LD_OWVAR 2
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: LD_INT 21
21925: PUSH
21926: LD_INT 3
21928: PUSH
21929: EMPTY
21930: LIST
21931: LIST
21932: PUSH
21933: EMPTY
21934: LIST
21935: LIST
21936: PPUSH
21937: CALL_OW 69
21941: ST_TO_ADDR
// if not tmp then
21942: LD_VAR 0 2
21946: NOT
21947: IFFALSE 21951
// exit ;
21949: GO 21980
// for i in tmp do
21951: LD_ADDR_VAR 0 1
21955: PUSH
21956: LD_VAR 0 2
21960: PUSH
21961: FOR_IN
21962: IFFALSE 21978
// SetBLevel ( i , 10 ) ;
21964: LD_VAR 0 1
21968: PPUSH
21969: LD_INT 10
21971: PPUSH
21972: CALL_OW 241
21976: GO 21961
21978: POP
21979: POP
// end ;
21980: PPOPN 2
21982: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
21983: LD_EXP 40
21987: PUSH
21988: LD_EXP 57
21992: AND
21993: IFFALSE 22104
21995: GO 21997
21997: DISABLE
21998: LD_INT 0
22000: PPUSH
22001: PPUSH
22002: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22003: LD_ADDR_VAR 0 3
22007: PUSH
22008: LD_INT 22
22010: PUSH
22011: LD_OWVAR 2
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: PUSH
22020: LD_INT 25
22022: PUSH
22023: LD_INT 1
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: PUSH
22030: EMPTY
22031: LIST
22032: LIST
22033: PPUSH
22034: CALL_OW 69
22038: ST_TO_ADDR
// if not tmp then
22039: LD_VAR 0 3
22043: NOT
22044: IFFALSE 22048
// exit ;
22046: GO 22104
// un := tmp [ rand ( 1 , tmp ) ] ;
22048: LD_ADDR_VAR 0 2
22052: PUSH
22053: LD_VAR 0 3
22057: PUSH
22058: LD_INT 1
22060: PPUSH
22061: LD_VAR 0 3
22065: PPUSH
22066: CALL_OW 12
22070: ARRAY
22071: ST_TO_ADDR
// if Crawls ( un ) then
22072: LD_VAR 0 2
22076: PPUSH
22077: CALL_OW 318
22081: IFFALSE 22092
// ComWalk ( un ) ;
22083: LD_VAR 0 2
22087: PPUSH
22088: CALL_OW 138
// SetClass ( un , class_sniper ) ;
22092: LD_VAR 0 2
22096: PPUSH
22097: LD_INT 5
22099: PPUSH
22100: CALL_OW 336
// end ;
22104: PPOPN 3
22106: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
22107: LD_EXP 40
22111: PUSH
22112: LD_EXP 58
22116: AND
22117: PUSH
22118: LD_OWVAR 67
22122: PUSH
22123: LD_INT 3
22125: LESS
22126: AND
22127: IFFALSE 22146
22129: GO 22131
22131: DISABLE
// Difficulty := Difficulty + 1 ;
22132: LD_ADDR_OWVAR 67
22136: PUSH
22137: LD_OWVAR 67
22141: PUSH
22142: LD_INT 1
22144: PLUS
22145: ST_TO_ADDR
22146: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
22147: LD_EXP 40
22151: PUSH
22152: LD_EXP 59
22156: AND
22157: IFFALSE 22260
22159: GO 22161
22161: DISABLE
22162: LD_INT 0
22164: PPUSH
// begin for i := 1 to 5 do
22165: LD_ADDR_VAR 0 1
22169: PUSH
22170: DOUBLE
22171: LD_INT 1
22173: DEC
22174: ST_TO_ADDR
22175: LD_INT 5
22177: PUSH
22178: FOR_TO
22179: IFFALSE 22258
// begin uc_nation := nation_nature ;
22181: LD_ADDR_OWVAR 21
22185: PUSH
22186: LD_INT 0
22188: ST_TO_ADDR
// uc_side := 0 ;
22189: LD_ADDR_OWVAR 20
22193: PUSH
22194: LD_INT 0
22196: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22197: LD_ADDR_OWVAR 29
22201: PUSH
22202: LD_INT 12
22204: PUSH
22205: LD_INT 12
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: ST_TO_ADDR
// hc_agressivity := 20 ;
22212: LD_ADDR_OWVAR 35
22216: PUSH
22217: LD_INT 20
22219: ST_TO_ADDR
// hc_class := class_tiger ;
22220: LD_ADDR_OWVAR 28
22224: PUSH
22225: LD_INT 14
22227: ST_TO_ADDR
// hc_gallery :=  ;
22228: LD_ADDR_OWVAR 33
22232: PUSH
22233: LD_STRING 
22235: ST_TO_ADDR
// hc_name :=  ;
22236: LD_ADDR_OWVAR 26
22240: PUSH
22241: LD_STRING 
22243: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
22244: CALL_OW 44
22248: PPUSH
22249: LD_INT 0
22251: PPUSH
22252: CALL_OW 51
// end ;
22256: GO 22178
22258: POP
22259: POP
// end ;
22260: PPOPN 1
22262: END
// every 0 0$1 trigger StreamModeActive and sBomb do
22263: LD_EXP 40
22267: PUSH
22268: LD_EXP 60
22272: AND
22273: IFFALSE 22282
22275: GO 22277
22277: DISABLE
// StreamSibBomb ;
22278: CALL 22283 0 0
22282: END
// export function StreamSibBomb ; var i , x , y ; begin
22283: LD_INT 0
22285: PPUSH
22286: PPUSH
22287: PPUSH
22288: PPUSH
// result := false ;
22289: LD_ADDR_VAR 0 1
22293: PUSH
22294: LD_INT 0
22296: ST_TO_ADDR
// for i := 1 to 16 do
22297: LD_ADDR_VAR 0 2
22301: PUSH
22302: DOUBLE
22303: LD_INT 1
22305: DEC
22306: ST_TO_ADDR
22307: LD_INT 16
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22510
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22313: LD_ADDR_VAR 0 3
22317: PUSH
22318: LD_INT 10
22320: PUSH
22321: LD_INT 20
22323: PUSH
22324: LD_INT 30
22326: PUSH
22327: LD_INT 40
22329: PUSH
22330: LD_INT 50
22332: PUSH
22333: LD_INT 60
22335: PUSH
22336: LD_INT 70
22338: PUSH
22339: LD_INT 80
22341: PUSH
22342: LD_INT 90
22344: PUSH
22345: LD_INT 100
22347: PUSH
22348: LD_INT 110
22350: PUSH
22351: LD_INT 120
22353: PUSH
22354: LD_INT 130
22356: PUSH
22357: LD_INT 140
22359: PUSH
22360: LD_INT 150
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: LIST
22368: LIST
22369: LIST
22370: LIST
22371: LIST
22372: LIST
22373: LIST
22374: LIST
22375: LIST
22376: LIST
22377: LIST
22378: LIST
22379: PUSH
22380: LD_INT 1
22382: PPUSH
22383: LD_INT 15
22385: PPUSH
22386: CALL_OW 12
22390: ARRAY
22391: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22392: LD_ADDR_VAR 0 4
22396: PUSH
22397: LD_INT 10
22399: PUSH
22400: LD_INT 20
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 40
22408: PUSH
22409: LD_INT 50
22411: PUSH
22412: LD_INT 60
22414: PUSH
22415: LD_INT 70
22417: PUSH
22418: LD_INT 80
22420: PUSH
22421: LD_INT 90
22423: PUSH
22424: LD_INT 100
22426: PUSH
22427: LD_INT 110
22429: PUSH
22430: LD_INT 120
22432: PUSH
22433: LD_INT 130
22435: PUSH
22436: LD_INT 140
22438: PUSH
22439: LD_INT 150
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: LIST
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: PUSH
22459: LD_INT 1
22461: PPUSH
22462: LD_INT 15
22464: PPUSH
22465: CALL_OW 12
22469: ARRAY
22470: ST_TO_ADDR
// if ValidHex ( x , y ) then
22471: LD_VAR 0 3
22475: PPUSH
22476: LD_VAR 0 4
22480: PPUSH
22481: CALL_OW 488
22485: IFFALSE 22508
// begin result := [ x , y ] ;
22487: LD_ADDR_VAR 0 1
22491: PUSH
22492: LD_VAR 0 3
22496: PUSH
22497: LD_VAR 0 4
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: ST_TO_ADDR
// break ;
22506: GO 22510
// end ; end ;
22508: GO 22310
22510: POP
22511: POP
// if result then
22512: LD_VAR 0 1
22516: IFFALSE 22576
// begin ToLua ( playSibBomb() ) ;
22518: LD_STRING playSibBomb()
22520: PPUSH
22521: CALL_OW 559
// wait ( 0 0$14 ) ;
22525: LD_INT 490
22527: PPUSH
22528: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
22532: LD_VAR 0 1
22536: PUSH
22537: LD_INT 1
22539: ARRAY
22540: PPUSH
22541: LD_VAR 0 1
22545: PUSH
22546: LD_INT 2
22548: ARRAY
22549: PPUSH
22550: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
22554: LD_VAR 0 1
22558: PUSH
22559: LD_INT 1
22561: ARRAY
22562: PPUSH
22563: LD_VAR 0 1
22567: PUSH
22568: LD_INT 2
22570: ARRAY
22571: PPUSH
22572: CALL_OW 429
// end ; end ;
22576: LD_VAR 0 1
22580: RET
// every 0 0$1 trigger StreamModeActive and sReset do
22581: LD_EXP 40
22585: PUSH
22586: LD_EXP 62
22590: AND
22591: IFFALSE 22603
22593: GO 22595
22595: DISABLE
// YouLost (  ) ;
22596: LD_STRING 
22598: PPUSH
22599: CALL_OW 104
22603: END
// every 0 0$1 trigger StreamModeActive and sFog do
22604: LD_EXP 40
22608: PUSH
22609: LD_EXP 61
22613: AND
22614: IFFALSE 22628
22616: GO 22618
22618: DISABLE
// FogOff ( your_side ) ;
22619: LD_OWVAR 2
22623: PPUSH
22624: CALL_OW 344
22628: END
// every 0 0$1 trigger StreamModeActive and sSun do
22629: LD_EXP 40
22633: PUSH
22634: LD_EXP 63
22638: AND
22639: IFFALSE 22667
22641: GO 22643
22643: DISABLE
// begin solar_recharge_percent := 0 ;
22644: LD_ADDR_OWVAR 79
22648: PUSH
22649: LD_INT 0
22651: ST_TO_ADDR
// wait ( 5 5$00 ) ;
22652: LD_INT 10500
22654: PPUSH
22655: CALL_OW 67
// solar_recharge_percent := 100 ;
22659: LD_ADDR_OWVAR 79
22663: PUSH
22664: LD_INT 100
22666: ST_TO_ADDR
// end ;
22667: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
22668: LD_EXP 40
22672: PUSH
22673: LD_EXP 64
22677: AND
22678: IFFALSE 22917
22680: GO 22682
22682: DISABLE
22683: LD_INT 0
22685: PPUSH
22686: PPUSH
22687: PPUSH
// begin tmp := [ ] ;
22688: LD_ADDR_VAR 0 3
22692: PUSH
22693: EMPTY
22694: ST_TO_ADDR
// for i := 1 to 6 do
22695: LD_ADDR_VAR 0 1
22699: PUSH
22700: DOUBLE
22701: LD_INT 1
22703: DEC
22704: ST_TO_ADDR
22705: LD_INT 6
22707: PUSH
22708: FOR_TO
22709: IFFALSE 22814
// begin uc_nation := nation_nature ;
22711: LD_ADDR_OWVAR 21
22715: PUSH
22716: LD_INT 0
22718: ST_TO_ADDR
// uc_side := 0 ;
22719: LD_ADDR_OWVAR 20
22723: PUSH
22724: LD_INT 0
22726: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22727: LD_ADDR_OWVAR 29
22731: PUSH
22732: LD_INT 12
22734: PUSH
22735: LD_INT 12
22737: PUSH
22738: EMPTY
22739: LIST
22740: LIST
22741: ST_TO_ADDR
// hc_agressivity := 20 ;
22742: LD_ADDR_OWVAR 35
22746: PUSH
22747: LD_INT 20
22749: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
22750: LD_ADDR_OWVAR 28
22754: PUSH
22755: LD_INT 17
22757: ST_TO_ADDR
// hc_gallery :=  ;
22758: LD_ADDR_OWVAR 33
22762: PUSH
22763: LD_STRING 
22765: ST_TO_ADDR
// hc_name :=  ;
22766: LD_ADDR_OWVAR 26
22770: PUSH
22771: LD_STRING 
22773: ST_TO_ADDR
// un := CreateHuman ;
22774: LD_ADDR_VAR 0 2
22778: PUSH
22779: CALL_OW 44
22783: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
22784: LD_VAR 0 2
22788: PPUSH
22789: LD_INT 1
22791: PPUSH
22792: CALL_OW 51
// tmp := tmp ^ un ;
22796: LD_ADDR_VAR 0 3
22800: PUSH
22801: LD_VAR 0 3
22805: PUSH
22806: LD_VAR 0 2
22810: ADD
22811: ST_TO_ADDR
// end ;
22812: GO 22708
22814: POP
22815: POP
// repeat wait ( 0 0$1 ) ;
22816: LD_INT 35
22818: PPUSH
22819: CALL_OW 67
// for un in tmp do
22823: LD_ADDR_VAR 0 2
22827: PUSH
22828: LD_VAR 0 3
22832: PUSH
22833: FOR_IN
22834: IFFALSE 22908
// begin if IsDead ( un ) then
22836: LD_VAR 0 2
22840: PPUSH
22841: CALL_OW 301
22845: IFFALSE 22865
// begin tmp := tmp diff un ;
22847: LD_ADDR_VAR 0 3
22851: PUSH
22852: LD_VAR 0 3
22856: PUSH
22857: LD_VAR 0 2
22861: DIFF
22862: ST_TO_ADDR
// continue ;
22863: GO 22833
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
22865: LD_VAR 0 2
22869: PPUSH
22870: LD_INT 3
22872: PUSH
22873: LD_INT 22
22875: PUSH
22876: LD_INT 0
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PPUSH
22887: CALL_OW 69
22891: PPUSH
22892: LD_VAR 0 2
22896: PPUSH
22897: CALL_OW 74
22901: PPUSH
22902: CALL_OW 115
// end ;
22906: GO 22833
22908: POP
22909: POP
// until not tmp ;
22910: LD_VAR 0 3
22914: NOT
22915: IFFALSE 22816
// end ;
22917: PPOPN 3
22919: END
// every 0 0$1 trigger StreamModeActive and sTroll do
22920: LD_EXP 40
22924: PUSH
22925: LD_EXP 65
22929: AND
22930: IFFALSE 22984
22932: GO 22934
22934: DISABLE
// begin ToLua ( displayTroll(); ) ;
22935: LD_STRING displayTroll();
22937: PPUSH
22938: CALL_OW 559
// wait ( 3 3$00 ) ;
22942: LD_INT 6300
22944: PPUSH
22945: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22949: LD_STRING hideTroll();
22951: PPUSH
22952: CALL_OW 559
// wait ( 1 1$00 ) ;
22956: LD_INT 2100
22958: PPUSH
22959: CALL_OW 67
// ToLua ( displayTroll(); ) ;
22963: LD_STRING displayTroll();
22965: PPUSH
22966: CALL_OW 559
// wait ( 1 1$00 ) ;
22970: LD_INT 2100
22972: PPUSH
22973: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22977: LD_STRING hideTroll();
22979: PPUSH
22980: CALL_OW 559
// end ;
22984: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
22985: LD_EXP 40
22989: PUSH
22990: LD_EXP 66
22994: AND
22995: IFFALSE 23058
22997: GO 22999
22999: DISABLE
23000: LD_INT 0
23002: PPUSH
// begin p := 0 ;
23003: LD_ADDR_VAR 0 1
23007: PUSH
23008: LD_INT 0
23010: ST_TO_ADDR
// repeat game_speed := 1 ;
23011: LD_ADDR_OWVAR 65
23015: PUSH
23016: LD_INT 1
23018: ST_TO_ADDR
// wait ( 0 0$1 ) ;
23019: LD_INT 35
23021: PPUSH
23022: CALL_OW 67
// p := p + 1 ;
23026: LD_ADDR_VAR 0 1
23030: PUSH
23031: LD_VAR 0 1
23035: PUSH
23036: LD_INT 1
23038: PLUS
23039: ST_TO_ADDR
// until p >= 60 ;
23040: LD_VAR 0 1
23044: PUSH
23045: LD_INT 60
23047: GREATEREQUAL
23048: IFFALSE 23011
// game_speed := 4 ;
23050: LD_ADDR_OWVAR 65
23054: PUSH
23055: LD_INT 4
23057: ST_TO_ADDR
// end ;
23058: PPOPN 1
23060: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
23061: LD_EXP 40
23065: PUSH
23066: LD_EXP 67
23070: AND
23071: IFFALSE 23217
23073: GO 23075
23075: DISABLE
23076: LD_INT 0
23078: PPUSH
23079: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23080: LD_ADDR_VAR 0 1
23084: PUSH
23085: LD_INT 22
23087: PUSH
23088: LD_OWVAR 2
23092: PUSH
23093: EMPTY
23094: LIST
23095: LIST
23096: PUSH
23097: LD_INT 2
23099: PUSH
23100: LD_INT 30
23102: PUSH
23103: LD_INT 0
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: PUSH
23110: LD_INT 30
23112: PUSH
23113: LD_INT 1
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: PUSH
23120: EMPTY
23121: LIST
23122: LIST
23123: LIST
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PPUSH
23129: CALL_OW 69
23133: ST_TO_ADDR
// if not depot then
23134: LD_VAR 0 1
23138: NOT
23139: IFFALSE 23143
// exit ;
23141: GO 23217
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
23143: LD_ADDR_VAR 0 2
23147: PUSH
23148: LD_VAR 0 1
23152: PUSH
23153: LD_INT 1
23155: PPUSH
23156: LD_VAR 0 1
23160: PPUSH
23161: CALL_OW 12
23165: ARRAY
23166: PPUSH
23167: CALL_OW 274
23171: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
23172: LD_VAR 0 2
23176: PPUSH
23177: LD_INT 1
23179: PPUSH
23180: LD_INT 0
23182: PPUSH
23183: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
23187: LD_VAR 0 2
23191: PPUSH
23192: LD_INT 2
23194: PPUSH
23195: LD_INT 0
23197: PPUSH
23198: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
23202: LD_VAR 0 2
23206: PPUSH
23207: LD_INT 3
23209: PPUSH
23210: LD_INT 0
23212: PPUSH
23213: CALL_OW 277
// end ;
23217: PPOPN 2
23219: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
23220: LD_EXP 40
23224: PUSH
23225: LD_EXP 68
23229: AND
23230: IFFALSE 23327
23232: GO 23234
23234: DISABLE
23235: LD_INT 0
23237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
23238: LD_ADDR_VAR 0 1
23242: PUSH
23243: LD_INT 22
23245: PUSH
23246: LD_OWVAR 2
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: LD_INT 21
23257: PUSH
23258: LD_INT 1
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: LD_INT 3
23267: PUSH
23268: LD_INT 23
23270: PUSH
23271: LD_INT 0
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PUSH
23278: EMPTY
23279: LIST
23280: LIST
23281: PUSH
23282: EMPTY
23283: LIST
23284: LIST
23285: LIST
23286: PPUSH
23287: CALL_OW 69
23291: ST_TO_ADDR
// if not tmp then
23292: LD_VAR 0 1
23296: NOT
23297: IFFALSE 23301
// exit ;
23299: GO 23327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
23301: LD_VAR 0 1
23305: PUSH
23306: LD_INT 1
23308: PPUSH
23309: LD_VAR 0 1
23313: PPUSH
23314: CALL_OW 12
23318: ARRAY
23319: PPUSH
23320: LD_INT 200
23322: PPUSH
23323: CALL_OW 234
// end ;
23327: PPOPN 1
23329: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
23330: LD_EXP 40
23334: PUSH
23335: LD_EXP 69
23339: AND
23340: IFFALSE 23419
23342: GO 23344
23344: DISABLE
23345: LD_INT 0
23347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
23348: LD_ADDR_VAR 0 1
23352: PUSH
23353: LD_INT 22
23355: PUSH
23356: LD_OWVAR 2
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 21
23367: PUSH
23368: LD_INT 2
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PPUSH
23379: CALL_OW 69
23383: ST_TO_ADDR
// if not tmp then
23384: LD_VAR 0 1
23388: NOT
23389: IFFALSE 23393
// exit ;
23391: GO 23419
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
23393: LD_VAR 0 1
23397: PUSH
23398: LD_INT 1
23400: PPUSH
23401: LD_VAR 0 1
23405: PPUSH
23406: CALL_OW 12
23410: ARRAY
23411: PPUSH
23412: LD_INT 60
23414: PPUSH
23415: CALL_OW 234
// end ;
23419: PPOPN 1
23421: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
23422: LD_EXP 40
23426: PUSH
23427: LD_EXP 70
23431: AND
23432: IFFALSE 23531
23434: GO 23436
23436: DISABLE
23437: LD_INT 0
23439: PPUSH
23440: PPUSH
// begin enable ;
23441: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
23442: LD_ADDR_VAR 0 1
23446: PUSH
23447: LD_INT 22
23449: PUSH
23450: LD_OWVAR 2
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: PUSH
23459: LD_INT 61
23461: PUSH
23462: EMPTY
23463: LIST
23464: PUSH
23465: LD_INT 33
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: LIST
23479: PPUSH
23480: CALL_OW 69
23484: ST_TO_ADDR
// if not tmp then
23485: LD_VAR 0 1
23489: NOT
23490: IFFALSE 23494
// exit ;
23492: GO 23531
// for i in tmp do
23494: LD_ADDR_VAR 0 2
23498: PUSH
23499: LD_VAR 0 1
23503: PUSH
23504: FOR_IN
23505: IFFALSE 23529
// if IsControledBy ( i ) then
23507: LD_VAR 0 2
23511: PPUSH
23512: CALL_OW 312
23516: IFFALSE 23527
// ComUnlink ( i ) ;
23518: LD_VAR 0 2
23522: PPUSH
23523: CALL_OW 136
23527: GO 23504
23529: POP
23530: POP
// end ;
23531: PPOPN 2
23533: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
23534: LD_EXP 40
23538: PUSH
23539: LD_EXP 71
23543: AND
23544: IFFALSE 23678
23546: GO 23548
23548: DISABLE
23549: LD_INT 0
23551: PPUSH
23552: PPUSH
// begin ToLua ( displayPowell(); ) ;
23553: LD_STRING displayPowell();
23555: PPUSH
23556: CALL_OW 559
// uc_side := 0 ;
23560: LD_ADDR_OWVAR 20
23564: PUSH
23565: LD_INT 0
23567: ST_TO_ADDR
// uc_nation := 2 ;
23568: LD_ADDR_OWVAR 21
23572: PUSH
23573: LD_INT 2
23575: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
23576: LD_ADDR_OWVAR 37
23580: PUSH
23581: LD_INT 14
23583: ST_TO_ADDR
// vc_engine := engine_siberite ;
23584: LD_ADDR_OWVAR 39
23588: PUSH
23589: LD_INT 3
23591: ST_TO_ADDR
// vc_control := control_apeman ;
23592: LD_ADDR_OWVAR 38
23596: PUSH
23597: LD_INT 5
23599: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
23600: LD_ADDR_OWVAR 40
23604: PUSH
23605: LD_INT 29
23607: ST_TO_ADDR
// un := CreateVehicle ;
23608: LD_ADDR_VAR 0 2
23612: PUSH
23613: CALL_OW 45
23617: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23618: LD_VAR 0 2
23622: PPUSH
23623: LD_INT 1
23625: PPUSH
23626: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23630: LD_INT 35
23632: PPUSH
23633: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
23637: LD_VAR 0 2
23641: PPUSH
23642: LD_OWVAR 3
23646: PUSH
23647: LD_VAR 0 2
23651: DIFF
23652: PPUSH
23653: LD_VAR 0 2
23657: PPUSH
23658: CALL_OW 74
23662: PPUSH
23663: CALL_OW 115
// until IsOk ( un ) ;
23667: LD_VAR 0 2
23671: PPUSH
23672: CALL_OW 302
23676: IFFALSE 23630
// end ;
23678: PPOPN 2
23680: END
// every 0 0$1 trigger StreamModeActive and sStu do
23681: LD_EXP 40
23685: PUSH
23686: LD_EXP 79
23690: AND
23691: IFFALSE 23703
23693: GO 23695
23695: DISABLE
// begin ToLua ( displayStucuk(); ) ;
23696: LD_STRING displayStucuk();
23698: PPUSH
23699: CALL_OW 559
// end ;
23703: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
23704: LD_EXP 40
23708: PUSH
23709: LD_EXP 72
23713: AND
23714: IFFALSE 23855
23716: GO 23718
23718: DISABLE
23719: LD_INT 0
23721: PPUSH
23722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23723: LD_ADDR_VAR 0 2
23727: PUSH
23728: LD_INT 22
23730: PUSH
23731: LD_OWVAR 2
23735: PUSH
23736: EMPTY
23737: LIST
23738: LIST
23739: PUSH
23740: LD_INT 21
23742: PUSH
23743: LD_INT 1
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: EMPTY
23751: LIST
23752: LIST
23753: PPUSH
23754: CALL_OW 69
23758: ST_TO_ADDR
// if not tmp then
23759: LD_VAR 0 2
23763: NOT
23764: IFFALSE 23768
// exit ;
23766: GO 23855
// un := tmp [ rand ( 1 , tmp ) ] ;
23768: LD_ADDR_VAR 0 1
23772: PUSH
23773: LD_VAR 0 2
23777: PUSH
23778: LD_INT 1
23780: PPUSH
23781: LD_VAR 0 2
23785: PPUSH
23786: CALL_OW 12
23790: ARRAY
23791: ST_TO_ADDR
// SetSide ( un , 0 ) ;
23792: LD_VAR 0 1
23796: PPUSH
23797: LD_INT 0
23799: PPUSH
23800: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
23804: LD_VAR 0 1
23808: PPUSH
23809: LD_OWVAR 3
23813: PUSH
23814: LD_VAR 0 1
23818: DIFF
23819: PPUSH
23820: LD_VAR 0 1
23824: PPUSH
23825: CALL_OW 74
23829: PPUSH
23830: CALL_OW 115
// wait ( 0 0$20 ) ;
23834: LD_INT 700
23836: PPUSH
23837: CALL_OW 67
// SetSide ( un , your_side ) ;
23841: LD_VAR 0 1
23845: PPUSH
23846: LD_OWVAR 2
23850: PPUSH
23851: CALL_OW 235
// end ;
23855: PPOPN 2
23857: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
23858: LD_EXP 40
23862: PUSH
23863: LD_EXP 73
23867: AND
23868: IFFALSE 23974
23870: GO 23872
23872: DISABLE
23873: LD_INT 0
23875: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23876: LD_ADDR_VAR 0 1
23880: PUSH
23881: LD_INT 22
23883: PUSH
23884: LD_OWVAR 2
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: PUSH
23893: LD_INT 2
23895: PUSH
23896: LD_INT 30
23898: PUSH
23899: LD_INT 0
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: PUSH
23906: LD_INT 30
23908: PUSH
23909: LD_INT 1
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: LIST
23920: PUSH
23921: EMPTY
23922: LIST
23923: LIST
23924: PPUSH
23925: CALL_OW 69
23929: ST_TO_ADDR
// if not depot then
23930: LD_VAR 0 1
23934: NOT
23935: IFFALSE 23939
// exit ;
23937: GO 23974
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
23939: LD_VAR 0 1
23943: PUSH
23944: LD_INT 1
23946: ARRAY
23947: PPUSH
23948: CALL_OW 250
23952: PPUSH
23953: LD_VAR 0 1
23957: PUSH
23958: LD_INT 1
23960: ARRAY
23961: PPUSH
23962: CALL_OW 251
23966: PPUSH
23967: LD_INT 70
23969: PPUSH
23970: CALL_OW 495
// end ;
23974: PPOPN 1
23976: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
23977: LD_EXP 40
23981: PUSH
23982: LD_EXP 74
23986: AND
23987: IFFALSE 24198
23989: GO 23991
23991: DISABLE
23992: LD_INT 0
23994: PPUSH
23995: PPUSH
23996: PPUSH
23997: PPUSH
23998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23999: LD_ADDR_VAR 0 5
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_OWVAR 2
24011: PUSH
24012: EMPTY
24013: LIST
24014: LIST
24015: PUSH
24016: LD_INT 21
24018: PUSH
24019: LD_INT 1
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: PPUSH
24030: CALL_OW 69
24034: ST_TO_ADDR
// if not tmp then
24035: LD_VAR 0 5
24039: NOT
24040: IFFALSE 24044
// exit ;
24042: GO 24198
// for i in tmp do
24044: LD_ADDR_VAR 0 1
24048: PUSH
24049: LD_VAR 0 5
24053: PUSH
24054: FOR_IN
24055: IFFALSE 24196
// begin d := rand ( 0 , 5 ) ;
24057: LD_ADDR_VAR 0 4
24061: PUSH
24062: LD_INT 0
24064: PPUSH
24065: LD_INT 5
24067: PPUSH
24068: CALL_OW 12
24072: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
24073: LD_ADDR_VAR 0 2
24077: PUSH
24078: LD_VAR 0 1
24082: PPUSH
24083: CALL_OW 250
24087: PPUSH
24088: LD_VAR 0 4
24092: PPUSH
24093: LD_INT 3
24095: PPUSH
24096: LD_INT 12
24098: PPUSH
24099: CALL_OW 12
24103: PPUSH
24104: CALL_OW 272
24108: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
24109: LD_ADDR_VAR 0 3
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: CALL_OW 251
24123: PPUSH
24124: LD_VAR 0 4
24128: PPUSH
24129: LD_INT 3
24131: PPUSH
24132: LD_INT 12
24134: PPUSH
24135: CALL_OW 12
24139: PPUSH
24140: CALL_OW 273
24144: ST_TO_ADDR
// if ValidHex ( x , y ) then
24145: LD_VAR 0 2
24149: PPUSH
24150: LD_VAR 0 3
24154: PPUSH
24155: CALL_OW 488
24159: IFFALSE 24194
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
24161: LD_VAR 0 1
24165: PPUSH
24166: LD_VAR 0 2
24170: PPUSH
24171: LD_VAR 0 3
24175: PPUSH
24176: LD_INT 3
24178: PPUSH
24179: LD_INT 6
24181: PPUSH
24182: CALL_OW 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: CALL_OW 483
// end ;
24194: GO 24054
24196: POP
24197: POP
// end ;
24198: PPOPN 5
24200: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
24201: LD_EXP 40
24205: PUSH
24206: LD_EXP 75
24210: AND
24211: IFFALSE 24305
24213: GO 24215
24215: DISABLE
24216: LD_INT 0
24218: PPUSH
24219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
24220: LD_ADDR_VAR 0 2
24224: PUSH
24225: LD_INT 22
24227: PUSH
24228: LD_OWVAR 2
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: PUSH
24237: LD_INT 32
24239: PUSH
24240: LD_INT 1
24242: PUSH
24243: EMPTY
24244: LIST
24245: LIST
24246: PUSH
24247: LD_INT 21
24249: PUSH
24250: LD_INT 2
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: LIST
24261: PPUSH
24262: CALL_OW 69
24266: ST_TO_ADDR
// if not tmp then
24267: LD_VAR 0 2
24271: NOT
24272: IFFALSE 24276
// exit ;
24274: GO 24305
// for i in tmp do
24276: LD_ADDR_VAR 0 1
24280: PUSH
24281: LD_VAR 0 2
24285: PUSH
24286: FOR_IN
24287: IFFALSE 24303
// SetFuel ( i , 0 ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 0
24296: PPUSH
24297: CALL_OW 240
24301: GO 24286
24303: POP
24304: POP
// end ;
24305: PPOPN 2
24307: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
24308: LD_EXP 40
24312: PUSH
24313: LD_EXP 76
24317: AND
24318: IFFALSE 24384
24320: GO 24322
24322: DISABLE
24323: LD_INT 0
24325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
24326: LD_ADDR_VAR 0 1
24330: PUSH
24331: LD_INT 22
24333: PUSH
24334: LD_OWVAR 2
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: PUSH
24343: LD_INT 30
24345: PUSH
24346: LD_INT 29
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PPUSH
24357: CALL_OW 69
24361: ST_TO_ADDR
// if not tmp then
24362: LD_VAR 0 1
24366: NOT
24367: IFFALSE 24371
// exit ;
24369: GO 24384
// DestroyUnit ( tmp [ 1 ] ) ;
24371: LD_VAR 0 1
24375: PUSH
24376: LD_INT 1
24378: ARRAY
24379: PPUSH
24380: CALL_OW 65
// end ;
24384: PPOPN 1
24386: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
24387: LD_EXP 40
24391: PUSH
24392: LD_EXP 78
24396: AND
24397: IFFALSE 24526
24399: GO 24401
24401: DISABLE
24402: LD_INT 0
24404: PPUSH
// begin uc_side := 0 ;
24405: LD_ADDR_OWVAR 20
24409: PUSH
24410: LD_INT 0
24412: ST_TO_ADDR
// uc_nation := nation_arabian ;
24413: LD_ADDR_OWVAR 21
24417: PUSH
24418: LD_INT 2
24420: ST_TO_ADDR
// hc_gallery :=  ;
24421: LD_ADDR_OWVAR 33
24425: PUSH
24426: LD_STRING 
24428: ST_TO_ADDR
// hc_name :=  ;
24429: LD_ADDR_OWVAR 26
24433: PUSH
24434: LD_STRING 
24436: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
24437: LD_INT 1
24439: PPUSH
24440: LD_INT 11
24442: PPUSH
24443: LD_INT 10
24445: PPUSH
24446: CALL_OW 380
// un := CreateHuman ;
24450: LD_ADDR_VAR 0 1
24454: PUSH
24455: CALL_OW 44
24459: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
24460: LD_VAR 0 1
24464: PPUSH
24465: LD_INT 1
24467: PPUSH
24468: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
24472: LD_INT 35
24474: PPUSH
24475: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
24479: LD_VAR 0 1
24483: PPUSH
24484: LD_INT 22
24486: PUSH
24487: LD_OWVAR 2
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PPUSH
24496: CALL_OW 69
24500: PPUSH
24501: LD_VAR 0 1
24505: PPUSH
24506: CALL_OW 74
24510: PPUSH
24511: CALL_OW 115
// until IsDead ( un ) ;
24515: LD_VAR 0 1
24519: PPUSH
24520: CALL_OW 301
24524: IFFALSE 24472
// end ;
24526: PPOPN 1
24528: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
24529: LD_EXP 40
24533: PUSH
24534: LD_EXP 80
24538: AND
24539: IFFALSE 24551
24541: GO 24543
24543: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
24544: LD_STRING earthquake(getX(game), 0, 32)
24546: PPUSH
24547: CALL_OW 559
24551: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
24552: LD_EXP 40
24556: PUSH
24557: LD_EXP 81
24561: AND
24562: IFFALSE 24653
24564: GO 24566
24566: DISABLE
24567: LD_INT 0
24569: PPUSH
// begin enable ;
24570: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
24571: LD_ADDR_VAR 0 1
24575: PUSH
24576: LD_INT 22
24578: PUSH
24579: LD_OWVAR 2
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: LD_INT 21
24590: PUSH
24591: LD_INT 2
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: LD_INT 33
24600: PUSH
24601: LD_INT 3
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: LIST
24612: PPUSH
24613: CALL_OW 69
24617: ST_TO_ADDR
// if not tmp then
24618: LD_VAR 0 1
24622: NOT
24623: IFFALSE 24627
// exit ;
24625: GO 24653
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
24627: LD_VAR 0 1
24631: PUSH
24632: LD_INT 1
24634: PPUSH
24635: LD_VAR 0 1
24639: PPUSH
24640: CALL_OW 12
24644: ARRAY
24645: PPUSH
24646: LD_INT 1
24648: PPUSH
24649: CALL_OW 234
// end ;
24653: PPOPN 1
24655: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
24656: LD_EXP 40
24660: PUSH
24661: LD_EXP 82
24665: AND
24666: IFFALSE 24807
24668: GO 24670
24670: DISABLE
24671: LD_INT 0
24673: PPUSH
24674: PPUSH
24675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24676: LD_ADDR_VAR 0 3
24680: PUSH
24681: LD_INT 22
24683: PUSH
24684: LD_OWVAR 2
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: LD_INT 25
24695: PUSH
24696: LD_INT 1
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PPUSH
24707: CALL_OW 69
24711: ST_TO_ADDR
// if not tmp then
24712: LD_VAR 0 3
24716: NOT
24717: IFFALSE 24721
// exit ;
24719: GO 24807
// un := tmp [ rand ( 1 , tmp ) ] ;
24721: LD_ADDR_VAR 0 2
24725: PUSH
24726: LD_VAR 0 3
24730: PUSH
24731: LD_INT 1
24733: PPUSH
24734: LD_VAR 0 3
24738: PPUSH
24739: CALL_OW 12
24743: ARRAY
24744: ST_TO_ADDR
// if Crawls ( un ) then
24745: LD_VAR 0 2
24749: PPUSH
24750: CALL_OW 318
24754: IFFALSE 24765
// ComWalk ( un ) ;
24756: LD_VAR 0 2
24760: PPUSH
24761: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
24765: LD_VAR 0 2
24769: PPUSH
24770: LD_INT 9
24772: PPUSH
24773: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
24777: LD_INT 28
24779: PPUSH
24780: LD_OWVAR 2
24784: PPUSH
24785: LD_INT 2
24787: PPUSH
24788: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
24792: LD_INT 29
24794: PPUSH
24795: LD_OWVAR 2
24799: PPUSH
24800: LD_INT 2
24802: PPUSH
24803: CALL_OW 322
// end ;
24807: PPOPN 3
24809: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
24810: LD_EXP 40
24814: PUSH
24815: LD_EXP 83
24819: AND
24820: IFFALSE 24931
24822: GO 24824
24824: DISABLE
24825: LD_INT 0
24827: PPUSH
24828: PPUSH
24829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24830: LD_ADDR_VAR 0 3
24834: PUSH
24835: LD_INT 22
24837: PUSH
24838: LD_OWVAR 2
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PUSH
24847: LD_INT 25
24849: PUSH
24850: LD_INT 1
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: EMPTY
24858: LIST
24859: LIST
24860: PPUSH
24861: CALL_OW 69
24865: ST_TO_ADDR
// if not tmp then
24866: LD_VAR 0 3
24870: NOT
24871: IFFALSE 24875
// exit ;
24873: GO 24931
// un := tmp [ rand ( 1 , tmp ) ] ;
24875: LD_ADDR_VAR 0 2
24879: PUSH
24880: LD_VAR 0 3
24884: PUSH
24885: LD_INT 1
24887: PPUSH
24888: LD_VAR 0 3
24892: PPUSH
24893: CALL_OW 12
24897: ARRAY
24898: ST_TO_ADDR
// if Crawls ( un ) then
24899: LD_VAR 0 2
24903: PPUSH
24904: CALL_OW 318
24908: IFFALSE 24919
// ComWalk ( un ) ;
24910: LD_VAR 0 2
24914: PPUSH
24915: CALL_OW 138
// SetClass ( un , class_mortar ) ;
24919: LD_VAR 0 2
24923: PPUSH
24924: LD_INT 8
24926: PPUSH
24927: CALL_OW 336
// end ;
24931: PPOPN 3
24933: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
24934: LD_EXP 40
24938: PUSH
24939: LD_EXP 84
24943: AND
24944: IFFALSE 25088
24946: GO 24948
24948: DISABLE
24949: LD_INT 0
24951: PPUSH
24952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
24953: LD_ADDR_VAR 0 2
24957: PUSH
24958: LD_INT 22
24960: PUSH
24961: LD_OWVAR 2
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 21
24972: PUSH
24973: LD_INT 2
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 2
24982: PUSH
24983: LD_INT 34
24985: PUSH
24986: LD_INT 12
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 34
24995: PUSH
24996: LD_INT 51
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 34
25005: PUSH
25006: LD_INT 32
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: EMPTY
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 69
25028: ST_TO_ADDR
// if not tmp then
25029: LD_VAR 0 2
25033: NOT
25034: IFFALSE 25038
// exit ;
25036: GO 25088
// for i in tmp do
25038: LD_ADDR_VAR 0 1
25042: PUSH
25043: LD_VAR 0 2
25047: PUSH
25048: FOR_IN
25049: IFFALSE 25086
// if GetCargo ( i , mat_artifact ) = 0 then
25051: LD_VAR 0 1
25055: PPUSH
25056: LD_INT 4
25058: PPUSH
25059: CALL_OW 289
25063: PUSH
25064: LD_INT 0
25066: EQUAL
25067: IFFALSE 25084
// SetCargo ( i , mat_siberit , 100 ) ;
25069: LD_VAR 0 1
25073: PPUSH
25074: LD_INT 3
25076: PPUSH
25077: LD_INT 100
25079: PPUSH
25080: CALL_OW 290
25084: GO 25048
25086: POP
25087: POP
// end ;
25088: PPOPN 2
25090: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
25091: LD_EXP 40
25095: PUSH
25096: LD_EXP 85
25100: AND
25101: IFFALSE 25254
25103: GO 25105
25105: DISABLE
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
25110: LD_ADDR_VAR 0 2
25114: PUSH
25115: LD_INT 22
25117: PUSH
25118: LD_OWVAR 2
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PPUSH
25127: CALL_OW 69
25131: ST_TO_ADDR
// if not tmp then
25132: LD_VAR 0 2
25136: NOT
25137: IFFALSE 25141
// exit ;
25139: GO 25254
// for i := 1 to 2 do
25141: LD_ADDR_VAR 0 1
25145: PUSH
25146: DOUBLE
25147: LD_INT 1
25149: DEC
25150: ST_TO_ADDR
25151: LD_INT 2
25153: PUSH
25154: FOR_TO
25155: IFFALSE 25252
// begin uc_side := your_side ;
25157: LD_ADDR_OWVAR 20
25161: PUSH
25162: LD_OWVAR 2
25166: ST_TO_ADDR
// uc_nation := nation_american ;
25167: LD_ADDR_OWVAR 21
25171: PUSH
25172: LD_INT 1
25174: ST_TO_ADDR
// vc_chassis := us_morphling ;
25175: LD_ADDR_OWVAR 37
25179: PUSH
25180: LD_INT 5
25182: ST_TO_ADDR
// vc_engine := engine_siberite ;
25183: LD_ADDR_OWVAR 39
25187: PUSH
25188: LD_INT 3
25190: ST_TO_ADDR
// vc_control := control_computer ;
25191: LD_ADDR_OWVAR 38
25195: PUSH
25196: LD_INT 3
25198: ST_TO_ADDR
// vc_weapon := us_double_laser ;
25199: LD_ADDR_OWVAR 40
25203: PUSH
25204: LD_INT 10
25206: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
25207: CALL_OW 45
25211: PPUSH
25212: LD_VAR 0 2
25216: PUSH
25217: LD_INT 1
25219: ARRAY
25220: PPUSH
25221: CALL_OW 250
25225: PPUSH
25226: LD_VAR 0 2
25230: PUSH
25231: LD_INT 1
25233: ARRAY
25234: PPUSH
25235: CALL_OW 251
25239: PPUSH
25240: LD_INT 12
25242: PPUSH
25243: LD_INT 1
25245: PPUSH
25246: CALL_OW 50
// end ;
25250: GO 25154
25252: POP
25253: POP
// end ;
25254: PPOPN 2
25256: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
25257: LD_EXP 40
25261: PUSH
25262: LD_EXP 86
25266: AND
25267: IFFALSE 25489
25269: GO 25271
25271: DISABLE
25272: LD_INT 0
25274: PPUSH
25275: PPUSH
25276: PPUSH
25277: PPUSH
25278: PPUSH
25279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25280: LD_ADDR_VAR 0 6
25284: PUSH
25285: LD_INT 22
25287: PUSH
25288: LD_OWVAR 2
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: PUSH
25297: LD_INT 21
25299: PUSH
25300: LD_INT 1
25302: PUSH
25303: EMPTY
25304: LIST
25305: LIST
25306: PUSH
25307: LD_INT 3
25309: PUSH
25310: LD_INT 23
25312: PUSH
25313: LD_INT 0
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: LIST
25328: PPUSH
25329: CALL_OW 69
25333: ST_TO_ADDR
// if not tmp then
25334: LD_VAR 0 6
25338: NOT
25339: IFFALSE 25343
// exit ;
25341: GO 25489
// s1 := rand ( 1 , 4 ) ;
25343: LD_ADDR_VAR 0 2
25347: PUSH
25348: LD_INT 1
25350: PPUSH
25351: LD_INT 4
25353: PPUSH
25354: CALL_OW 12
25358: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
25359: LD_ADDR_VAR 0 4
25363: PUSH
25364: LD_VAR 0 6
25368: PUSH
25369: LD_INT 1
25371: ARRAY
25372: PPUSH
25373: LD_VAR 0 2
25377: PPUSH
25378: CALL_OW 259
25382: ST_TO_ADDR
// if s1 = 1 then
25383: LD_VAR 0 2
25387: PUSH
25388: LD_INT 1
25390: EQUAL
25391: IFFALSE 25411
// s2 := rand ( 2 , 4 ) else
25393: LD_ADDR_VAR 0 3
25397: PUSH
25398: LD_INT 2
25400: PPUSH
25401: LD_INT 4
25403: PPUSH
25404: CALL_OW 12
25408: ST_TO_ADDR
25409: GO 25419
// s2 := 1 ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
25419: LD_ADDR_VAR 0 5
25423: PUSH
25424: LD_VAR 0 6
25428: PUSH
25429: LD_INT 1
25431: ARRAY
25432: PPUSH
25433: LD_VAR 0 3
25437: PPUSH
25438: CALL_OW 259
25442: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
25443: LD_VAR 0 6
25447: PUSH
25448: LD_INT 1
25450: ARRAY
25451: PPUSH
25452: LD_VAR 0 2
25456: PPUSH
25457: LD_VAR 0 5
25461: PPUSH
25462: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
25466: LD_VAR 0 6
25470: PUSH
25471: LD_INT 1
25473: ARRAY
25474: PPUSH
25475: LD_VAR 0 3
25479: PPUSH
25480: LD_VAR 0 4
25484: PPUSH
25485: CALL_OW 237
// end ;
25489: PPOPN 6
25491: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
25492: LD_EXP 40
25496: PUSH
25497: LD_EXP 87
25501: AND
25502: IFFALSE 25581
25504: GO 25506
25506: DISABLE
25507: LD_INT 0
25509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
25510: LD_ADDR_VAR 0 1
25514: PUSH
25515: LD_INT 22
25517: PUSH
25518: LD_OWVAR 2
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PUSH
25527: LD_INT 30
25529: PUSH
25530: LD_INT 3
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PPUSH
25541: CALL_OW 69
25545: ST_TO_ADDR
// if not tmp then
25546: LD_VAR 0 1
25550: NOT
25551: IFFALSE 25555
// exit ;
25553: GO 25581
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
25555: LD_VAR 0 1
25559: PUSH
25560: LD_INT 1
25562: PPUSH
25563: LD_VAR 0 1
25567: PPUSH
25568: CALL_OW 12
25572: ARRAY
25573: PPUSH
25574: LD_INT 1
25576: PPUSH
25577: CALL_OW 234
// end ;
25581: PPOPN 1
25583: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
25584: LD_EXP 40
25588: PUSH
25589: LD_EXP 88
25593: AND
25594: IFFALSE 25706
25596: GO 25598
25598: DISABLE
25599: LD_INT 0
25601: PPUSH
25602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
25603: LD_ADDR_VAR 0 2
25607: PUSH
25608: LD_INT 22
25610: PUSH
25611: LD_OWVAR 2
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: PUSH
25623: LD_INT 30
25625: PUSH
25626: LD_INT 27
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 30
25635: PUSH
25636: LD_INT 26
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 30
25645: PUSH
25646: LD_INT 28
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: LIST
25657: LIST
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PPUSH
25663: CALL_OW 69
25667: ST_TO_ADDR
// if not tmp then
25668: LD_VAR 0 2
25672: NOT
25673: IFFALSE 25677
// exit ;
25675: GO 25706
// for i in tmp do
25677: LD_ADDR_VAR 0 1
25681: PUSH
25682: LD_VAR 0 2
25686: PUSH
25687: FOR_IN
25688: IFFALSE 25704
// SetLives ( i , 1 ) ;
25690: LD_VAR 0 1
25694: PPUSH
25695: LD_INT 1
25697: PPUSH
25698: CALL_OW 234
25702: GO 25687
25704: POP
25705: POP
// end ;
25706: PPOPN 2
25708: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
25709: LD_EXP 40
25713: PUSH
25714: LD_EXP 89
25718: AND
25719: IFFALSE 25989
25721: GO 25723
25723: DISABLE
25724: LD_INT 0
25726: PPUSH
25727: PPUSH
25728: PPUSH
// begin i := rand ( 1 , 7 ) ;
25729: LD_ADDR_VAR 0 1
25733: PUSH
25734: LD_INT 1
25736: PPUSH
25737: LD_INT 7
25739: PPUSH
25740: CALL_OW 12
25744: ST_TO_ADDR
// case i of 1 :
25745: LD_VAR 0 1
25749: PUSH
25750: LD_INT 1
25752: DOUBLE
25753: EQUAL
25754: IFTRUE 25758
25756: GO 25768
25758: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
25759: LD_STRING earthquake(getX(game), 0, 32)
25761: PPUSH
25762: CALL_OW 559
25766: GO 25989
25768: LD_INT 2
25770: DOUBLE
25771: EQUAL
25772: IFTRUE 25776
25774: GO 25786
25776: POP
// ToLua ( displayStucuk(); ) ; 3 :
25777: LD_STRING displayStucuk();
25779: PPUSH
25780: CALL_OW 559
25784: GO 25989
25786: LD_INT 3
25788: DOUBLE
25789: EQUAL
25790: IFTRUE 25794
25792: GO 25898
25794: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25795: LD_ADDR_VAR 0 2
25799: PUSH
25800: LD_INT 22
25802: PUSH
25803: LD_OWVAR 2
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: PUSH
25812: LD_INT 25
25814: PUSH
25815: LD_INT 1
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 69
25830: ST_TO_ADDR
// if not tmp then
25831: LD_VAR 0 2
25835: NOT
25836: IFFALSE 25840
// exit ;
25838: GO 25989
// un := tmp [ rand ( 1 , tmp ) ] ;
25840: LD_ADDR_VAR 0 3
25844: PUSH
25845: LD_VAR 0 2
25849: PUSH
25850: LD_INT 1
25852: PPUSH
25853: LD_VAR 0 2
25857: PPUSH
25858: CALL_OW 12
25862: ARRAY
25863: ST_TO_ADDR
// if Crawls ( un ) then
25864: LD_VAR 0 3
25868: PPUSH
25869: CALL_OW 318
25873: IFFALSE 25884
// ComWalk ( un ) ;
25875: LD_VAR 0 3
25879: PPUSH
25880: CALL_OW 138
// SetClass ( un , class_mortar ) ;
25884: LD_VAR 0 3
25888: PPUSH
25889: LD_INT 8
25891: PPUSH
25892: CALL_OW 336
// end ; 4 :
25896: GO 25989
25898: LD_INT 4
25900: DOUBLE
25901: EQUAL
25902: IFTRUE 25906
25904: GO 25967
25906: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
25907: LD_ADDR_VAR 0 2
25911: PUSH
25912: LD_INT 22
25914: PUSH
25915: LD_OWVAR 2
25919: PUSH
25920: EMPTY
25921: LIST
25922: LIST
25923: PUSH
25924: LD_INT 30
25926: PUSH
25927: LD_INT 29
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 69
25942: ST_TO_ADDR
// if not tmp then
25943: LD_VAR 0 2
25947: NOT
25948: IFFALSE 25952
// exit ;
25950: GO 25989
// DestroyUnit ( tmp [ 1 ] ) ;
25952: LD_VAR 0 2
25956: PUSH
25957: LD_INT 1
25959: ARRAY
25960: PPUSH
25961: CALL_OW 65
// end ; 5 .. 7 :
25965: GO 25989
25967: LD_INT 5
25969: DOUBLE
25970: GREATEREQUAL
25971: IFFALSE 25979
25973: LD_INT 7
25975: DOUBLE
25976: LESSEQUAL
25977: IFTRUE 25981
25979: GO 25988
25981: POP
// StreamSibBomb ; end ;
25982: CALL 22283 0 0
25986: GO 25989
25988: POP
// end ;
25989: PPOPN 3
25991: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
25992: LD_EXP 40
25996: PUSH
25997: LD_EXP 90
26001: AND
26002: IFFALSE 26158
26004: GO 26006
26006: DISABLE
26007: LD_INT 0
26009: PPUSH
26010: PPUSH
26011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
26012: LD_ADDR_VAR 0 2
26016: PUSH
26017: LD_INT 81
26019: PUSH
26020: LD_OWVAR 2
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 2
26031: PUSH
26032: LD_INT 21
26034: PUSH
26035: LD_INT 1
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: LD_INT 21
26044: PUSH
26045: LD_INT 2
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: LIST
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PPUSH
26061: CALL_OW 69
26065: ST_TO_ADDR
// if not tmp then
26066: LD_VAR 0 2
26070: NOT
26071: IFFALSE 26075
// exit ;
26073: GO 26158
// p := 0 ;
26075: LD_ADDR_VAR 0 3
26079: PUSH
26080: LD_INT 0
26082: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// p := p + 1 ;
26090: LD_ADDR_VAR 0 3
26094: PUSH
26095: LD_VAR 0 3
26099: PUSH
26100: LD_INT 1
26102: PLUS
26103: ST_TO_ADDR
// for i in tmp do
26104: LD_ADDR_VAR 0 1
26108: PUSH
26109: LD_VAR 0 2
26113: PUSH
26114: FOR_IN
26115: IFFALSE 26146
// if GetLives ( i ) < 1000 then
26117: LD_VAR 0 1
26121: PPUSH
26122: CALL_OW 256
26126: PUSH
26127: LD_INT 1000
26129: LESS
26130: IFFALSE 26144
// SetLives ( i , 1000 ) ;
26132: LD_VAR 0 1
26136: PPUSH
26137: LD_INT 1000
26139: PPUSH
26140: CALL_OW 234
26144: GO 26114
26146: POP
26147: POP
// until p > 20 ;
26148: LD_VAR 0 3
26152: PUSH
26153: LD_INT 20
26155: GREATER
26156: IFFALSE 26083
// end ;
26158: PPOPN 3
26160: END
// every 0 0$1 trigger StreamModeActive and sTime do
26161: LD_EXP 40
26165: PUSH
26166: LD_EXP 91
26170: AND
26171: IFFALSE 26206
26173: GO 26175
26175: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
26176: LD_INT 28
26178: PPUSH
26179: LD_OWVAR 2
26183: PPUSH
26184: LD_INT 2
26186: PPUSH
26187: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
26191: LD_INT 30
26193: PPUSH
26194: LD_OWVAR 2
26198: PPUSH
26199: LD_INT 2
26201: PPUSH
26202: CALL_OW 322
// end ;
26206: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
26207: LD_EXP 40
26211: PUSH
26212: LD_EXP 92
26216: AND
26217: IFFALSE 26338
26219: GO 26221
26221: DISABLE
26222: LD_INT 0
26224: PPUSH
26225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26226: LD_ADDR_VAR 0 2
26230: PUSH
26231: LD_INT 22
26233: PUSH
26234: LD_OWVAR 2
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 21
26245: PUSH
26246: LD_INT 1
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: LD_INT 3
26255: PUSH
26256: LD_INT 23
26258: PUSH
26259: LD_INT 0
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: LIST
26274: PPUSH
26275: CALL_OW 69
26279: ST_TO_ADDR
// if not tmp then
26280: LD_VAR 0 2
26284: NOT
26285: IFFALSE 26289
// exit ;
26287: GO 26338
// for i in tmp do
26289: LD_ADDR_VAR 0 1
26293: PUSH
26294: LD_VAR 0 2
26298: PUSH
26299: FOR_IN
26300: IFFALSE 26336
// begin if Crawls ( i ) then
26302: LD_VAR 0 1
26306: PPUSH
26307: CALL_OW 318
26311: IFFALSE 26322
// ComWalk ( i ) ;
26313: LD_VAR 0 1
26317: PPUSH
26318: CALL_OW 138
// SetClass ( i , 2 ) ;
26322: LD_VAR 0 1
26326: PPUSH
26327: LD_INT 2
26329: PPUSH
26330: CALL_OW 336
// end ;
26334: GO 26299
26336: POP
26337: POP
// end ;
26338: PPOPN 2
26340: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
26341: LD_EXP 40
26345: PUSH
26346: LD_EXP 93
26350: AND
26351: IFFALSE 26556
26353: GO 26355
26355: DISABLE
26356: LD_INT 0
26358: PPUSH
26359: PPUSH
26360: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
26361: LD_OWVAR 2
26365: PPUSH
26366: LD_INT 9
26368: PPUSH
26369: LD_INT 1
26371: PPUSH
26372: LD_INT 1
26374: PPUSH
26375: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
26379: LD_INT 9
26381: PPUSH
26382: LD_OWVAR 2
26386: PPUSH
26387: CALL_OW 343
// hc_name := Dark Warrior ;
26391: LD_ADDR_OWVAR 26
26395: PUSH
26396: LD_STRING Dark Warrior
26398: ST_TO_ADDR
// hc_gallery :=  ;
26399: LD_ADDR_OWVAR 33
26403: PUSH
26404: LD_STRING 
26406: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
26407: LD_INT 1
26409: PPUSH
26410: LD_INT 1
26412: PPUSH
26413: LD_INT 10
26415: PPUSH
26416: CALL_OW 380
// un := CreateHuman ;
26420: LD_ADDR_VAR 0 3
26424: PUSH
26425: CALL_OW 44
26429: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26430: LD_VAR 0 3
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: CALL_OW 51
// p := 0 ;
26442: LD_ADDR_VAR 0 2
26446: PUSH
26447: LD_INT 0
26449: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26450: LD_INT 35
26452: PPUSH
26453: CALL_OW 67
// if GetLives ( un ) < 1000 then
26457: LD_VAR 0 3
26461: PPUSH
26462: CALL_OW 256
26466: PUSH
26467: LD_INT 1000
26469: LESS
26470: IFFALSE 26484
// SetLives ( un , 1000 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1000
26479: PPUSH
26480: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 81
26491: PUSH
26492: LD_OWVAR 2
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PPUSH
26501: CALL_OW 69
26505: PPUSH
26506: LD_VAR 0 3
26510: PPUSH
26511: CALL_OW 74
26515: PPUSH
26516: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
26520: LD_VAR 0 2
26524: PUSH
26525: LD_INT 60
26527: GREATER
26528: PUSH
26529: LD_VAR 0 3
26533: PPUSH
26534: CALL_OW 301
26538: OR
26539: IFFALSE 26450
// if un then
26541: LD_VAR 0 3
26545: IFFALSE 26556
// RemoveUnit ( un ) ;
26547: LD_VAR 0 3
26551: PPUSH
26552: CALL_OW 64
// end ; end_of_file
26556: PPOPN 3
26558: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
26559: LD_INT 0
26561: PPUSH
26562: PPUSH
26563: PPUSH
26564: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
26565: LD_VAR 0 1
26569: PPUSH
26570: CALL_OW 264
26574: PUSH
26575: LD_EXP 39
26579: EQUAL
26580: IFFALSE 26652
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
26582: LD_INT 68
26584: PPUSH
26585: LD_VAR 0 1
26589: PPUSH
26590: CALL_OW 255
26594: PPUSH
26595: CALL_OW 321
26599: PUSH
26600: LD_INT 2
26602: EQUAL
26603: IFFALSE 26615
// eff := 70 else
26605: LD_ADDR_VAR 0 6
26609: PUSH
26610: LD_INT 70
26612: ST_TO_ADDR
26613: GO 26623
// eff := 30 ;
26615: LD_ADDR_VAR 0 6
26619: PUSH
26620: LD_INT 30
26622: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
26623: LD_VAR 0 1
26627: PPUSH
26628: CALL_OW 250
26632: PPUSH
26633: LD_VAR 0 1
26637: PPUSH
26638: CALL_OW 251
26642: PPUSH
26643: LD_VAR 0 6
26647: PPUSH
26648: CALL_OW 495
// end ; end ;
26652: LD_VAR 0 4
26656: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
26657: LD_INT 0
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
// if cmd = 124 then
26665: LD_VAR 0 1
26669: PUSH
26670: LD_INT 124
26672: EQUAL
26673: IFFALSE 26879
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
26675: LD_ADDR_VAR 0 5
26679: PUSH
26680: LD_INT 2
26682: PUSH
26683: LD_INT 34
26685: PUSH
26686: LD_INT 53
26688: PUSH
26689: EMPTY
26690: LIST
26691: LIST
26692: PUSH
26693: LD_INT 34
26695: PUSH
26696: LD_INT 14
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: EMPTY
26704: LIST
26705: LIST
26706: LIST
26707: PPUSH
26708: CALL_OW 69
26712: ST_TO_ADDR
// if not tmp then
26713: LD_VAR 0 5
26717: NOT
26718: IFFALSE 26722
// exit ;
26720: GO 26879
// for i in tmp do
26722: LD_ADDR_VAR 0 3
26726: PUSH
26727: LD_VAR 0 5
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26877
// begin taskList := GetTaskList ( i ) ;
26735: LD_ADDR_VAR 0 6
26739: PUSH
26740: LD_VAR 0 3
26744: PPUSH
26745: CALL_OW 437
26749: ST_TO_ADDR
// if not taskList then
26750: LD_VAR 0 6
26754: NOT
26755: IFFALSE 26759
// continue ;
26757: GO 26732
// for j = 1 to taskList do
26759: LD_ADDR_VAR 0 4
26763: PUSH
26764: DOUBLE
26765: LD_INT 1
26767: DEC
26768: ST_TO_ADDR
26769: LD_VAR 0 6
26773: PUSH
26774: FOR_TO
26775: IFFALSE 26873
// if taskList [ j ] [ 1 ] = | then
26777: LD_VAR 0 6
26781: PUSH
26782: LD_VAR 0 4
26786: ARRAY
26787: PUSH
26788: LD_INT 1
26790: ARRAY
26791: PUSH
26792: LD_STRING |
26794: EQUAL
26795: IFFALSE 26871
// begin _taskList := Delete ( taskList , 1 ) ;
26797: LD_ADDR_VAR 0 7
26801: PUSH
26802: LD_VAR 0 6
26806: PPUSH
26807: LD_INT 1
26809: PPUSH
26810: CALL_OW 3
26814: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
26815: LD_VAR 0 3
26819: PPUSH
26820: LD_VAR 0 7
26824: PPUSH
26825: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
26829: LD_VAR 0 3
26833: PPUSH
26834: LD_VAR 0 6
26838: PUSH
26839: LD_VAR 0 4
26843: ARRAY
26844: PUSH
26845: LD_INT 2
26847: ARRAY
26848: PPUSH
26849: LD_VAR 0 6
26853: PUSH
26854: LD_VAR 0 4
26858: ARRAY
26859: PUSH
26860: LD_INT 3
26862: ARRAY
26863: PPUSH
26864: LD_INT 8
26866: PPUSH
26867: CALL 26884 0 4
// end ;
26871: GO 26774
26873: POP
26874: POP
// end ;
26875: GO 26732
26877: POP
26878: POP
// end ; end ;
26879: LD_VAR 0 2
26883: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
26884: LD_INT 0
26886: PPUSH
26887: PPUSH
26888: PPUSH
26889: PPUSH
26890: PPUSH
26891: PPUSH
26892: PPUSH
26893: PPUSH
26894: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
26895: LD_VAR 0 1
26899: NOT
26900: PUSH
26901: LD_VAR 0 2
26905: PPUSH
26906: LD_VAR 0 3
26910: PPUSH
26911: CALL_OW 488
26915: NOT
26916: OR
26917: PUSH
26918: LD_VAR 0 4
26922: NOT
26923: OR
26924: IFFALSE 26928
// exit ;
26926: GO 27268
// list := [ ] ;
26928: LD_ADDR_VAR 0 13
26932: PUSH
26933: EMPTY
26934: ST_TO_ADDR
// if x - r < 0 then
26935: LD_VAR 0 2
26939: PUSH
26940: LD_VAR 0 4
26944: MINUS
26945: PUSH
26946: LD_INT 0
26948: LESS
26949: IFFALSE 26961
// min_x := 0 else
26951: LD_ADDR_VAR 0 7
26955: PUSH
26956: LD_INT 0
26958: ST_TO_ADDR
26959: GO 26977
// min_x := x - r ;
26961: LD_ADDR_VAR 0 7
26965: PUSH
26966: LD_VAR 0 2
26970: PUSH
26971: LD_VAR 0 4
26975: MINUS
26976: ST_TO_ADDR
// if y - r < 0 then
26977: LD_VAR 0 3
26981: PUSH
26982: LD_VAR 0 4
26986: MINUS
26987: PUSH
26988: LD_INT 0
26990: LESS
26991: IFFALSE 27003
// min_y := 0 else
26993: LD_ADDR_VAR 0 8
26997: PUSH
26998: LD_INT 0
27000: ST_TO_ADDR
27001: GO 27019
// min_y := y - r ;
27003: LD_ADDR_VAR 0 8
27007: PUSH
27008: LD_VAR 0 3
27012: PUSH
27013: LD_VAR 0 4
27017: MINUS
27018: ST_TO_ADDR
// max_x := x + r ;
27019: LD_ADDR_VAR 0 9
27023: PUSH
27024: LD_VAR 0 2
27028: PUSH
27029: LD_VAR 0 4
27033: PLUS
27034: ST_TO_ADDR
// max_y := y + r ;
27035: LD_ADDR_VAR 0 10
27039: PUSH
27040: LD_VAR 0 3
27044: PUSH
27045: LD_VAR 0 4
27049: PLUS
27050: ST_TO_ADDR
// for _x = min_x to max_x do
27051: LD_ADDR_VAR 0 11
27055: PUSH
27056: DOUBLE
27057: LD_VAR 0 7
27061: DEC
27062: ST_TO_ADDR
27063: LD_VAR 0 9
27067: PUSH
27068: FOR_TO
27069: IFFALSE 27186
// for _y = min_y to max_y do
27071: LD_ADDR_VAR 0 12
27075: PUSH
27076: DOUBLE
27077: LD_VAR 0 8
27081: DEC
27082: ST_TO_ADDR
27083: LD_VAR 0 10
27087: PUSH
27088: FOR_TO
27089: IFFALSE 27182
// begin if not ValidHex ( _x , _y ) then
27091: LD_VAR 0 11
27095: PPUSH
27096: LD_VAR 0 12
27100: PPUSH
27101: CALL_OW 488
27105: NOT
27106: IFFALSE 27110
// continue ;
27108: GO 27088
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
27110: LD_VAR 0 11
27114: PPUSH
27115: LD_VAR 0 12
27119: PPUSH
27120: CALL_OW 351
27124: PUSH
27125: LD_VAR 0 11
27129: PPUSH
27130: LD_VAR 0 12
27134: PPUSH
27135: CALL_OW 554
27139: AND
27140: IFFALSE 27180
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
27142: LD_ADDR_VAR 0 13
27146: PUSH
27147: LD_VAR 0 13
27151: PPUSH
27152: LD_VAR 0 13
27156: PUSH
27157: LD_INT 1
27159: PLUS
27160: PPUSH
27161: LD_VAR 0 11
27165: PUSH
27166: LD_VAR 0 12
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: PPUSH
27175: CALL_OW 2
27179: ST_TO_ADDR
// end ;
27180: GO 27088
27182: POP
27183: POP
27184: GO 27068
27186: POP
27187: POP
// if not list then
27188: LD_VAR 0 13
27192: NOT
27193: IFFALSE 27197
// exit ;
27195: GO 27268
// for i in list do
27197: LD_ADDR_VAR 0 6
27201: PUSH
27202: LD_VAR 0 13
27206: PUSH
27207: FOR_IN
27208: IFFALSE 27266
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
27210: LD_VAR 0 1
27214: PPUSH
27215: LD_STRING M
27217: PUSH
27218: LD_VAR 0 6
27222: PUSH
27223: LD_INT 1
27225: ARRAY
27226: PUSH
27227: LD_VAR 0 6
27231: PUSH
27232: LD_INT 2
27234: ARRAY
27235: PUSH
27236: LD_INT 0
27238: PUSH
27239: LD_INT 0
27241: PUSH
27242: LD_INT 0
27244: PUSH
27245: LD_INT 0
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: LIST
27256: PUSH
27257: EMPTY
27258: LIST
27259: PPUSH
27260: CALL_OW 447
27264: GO 27207
27266: POP
27267: POP
// end ;
27268: LD_VAR 0 5
27272: RET
