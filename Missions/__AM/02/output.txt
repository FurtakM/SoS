// export JMM , Bobby , Cyrus ; export Lisa , Khatam , Brian , Jerry , Mikhail ; export Powell ; export hpJMM , hpBobby , hpCyrus ; export RuSoldMinLevel , RuSoldMaxLevel ; export cargo1 , cargo2 ; export driver1 , driver2 ; export Natasza ; export cargoEscape ; export mikhailStatus , mikhailInBase , mikhailDepot ; export northBaseDefenders , southBaseDefenders , attackGroup ; export lastBattle ; export cargoRespawn , cargoSee ; export tigersRespawn ; export deadsCounter ; export spotCorpses ; export mission_prefix ; starting begin mission_prefix := 02_ ;
   0: LD_ADDR_EXP 33
   4: PUSH
   5: LD_STRING 02_
   7: ST_TO_ADDR
// RuSoldMinLevel = 0 ;
   8: LD_ADDR_EXP 13
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// RuSoldMaxLevel = 0 ;
  16: LD_ADDR_EXP 14
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// hpJMM = 0 ;
  24: LD_ADDR_EXP 10
  28: PUSH
  29: LD_INT 0
  31: ST_TO_ADDR
// hpBobby = 0 ;
  32: LD_ADDR_EXP 11
  36: PUSH
  37: LD_INT 0
  39: ST_TO_ADDR
// hpCyrus = 0 ;
  40: LD_ADDR_EXP 12
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// cargoEscape = 0 ;
  48: LD_ADDR_EXP 20
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mikhailStatus = 0 ;
  56: LD_ADDR_EXP 21
  60: PUSH
  61: LD_INT 0
  63: ST_TO_ADDR
// mikhailInBase = 0 ;
  64: LD_ADDR_EXP 22
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// mikhailDepot = 0 ;
  72: LD_ADDR_EXP 23
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// tigersRespawn = 0 ;
  80: LD_ADDR_EXP 30
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// cargoRespawn = 0 ;
  88: LD_ADDR_EXP 28
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// cargoSee = 0 ;
  96: LD_ADDR_EXP 29
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// lastBattle = 0 ;
 104: LD_ADDR_EXP 27
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// deadsCounter = 0 ;
 112: LD_ADDR_EXP 31
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// spotCorpses = 0 ;
 120: LD_ADDR_EXP 32
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// southBaseDefenders = [ ] ;
 128: LD_ADDR_EXP 25
 132: PUSH
 133: EMPTY
 134: ST_TO_ADDR
// northBaseDefenders = [ ] ;
 135: LD_ADDR_EXP 24
 139: PUSH
 140: EMPTY
 141: ST_TO_ADDR
// attackGroup = [ ] ;
 142: LD_ADDR_EXP 26
 146: PUSH
 147: EMPTY
 148: ST_TO_ADDR
// RandomizeAll ;
 149: CALL_OW 11
// InGameOn ;
 153: CALL_OW 8
// Resetfog ;
 157: CALL_OW 335
// AnimateTrees ( true ) ;
 161: LD_INT 1
 163: PPUSH
 164: CALL_OW 573
// PrepareDifficulty ;
 168: CALL 10287 0 0
// PrepareRussianCommander ;
 172: CALL 11743 0 0
// PrepareSouthBase ;
 176: CALL 11826 0 0
// PrepareNorthBase ;
 180: CALL 12165 0 0
// PrepareOtherRussians ;
 184: CALL 12531 0 0
// PrepareHeroes ;
 188: CALL 10602 0 0
// PrepareLisSquad ;
 192: CALL 10930 0 0
// PrepareOtherAmericans ;
 196: CALL 11275 0 0
// end ; end_of_file
 200: END
// every 1 do var tmp ;
 201: GO 203
 203: DISABLE
 204: LD_INT 0
 206: PPUSH
// begin CenterNowOnUnits ( JMM ) ;
 207: LD_EXP 1
 211: PPUSH
 212: CALL_OW 87
// tmp = FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff [ Lisa ] ;
 216: LD_ADDR_VAR 0 1
 220: PUSH
 221: LD_INT 22
 223: PUSH
 224: LD_INT 4
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: PUSH
 231: LD_INT 21
 233: PUSH
 234: LD_INT 1
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PPUSH
 245: CALL_OW 69
 249: PUSH
 250: LD_EXP 4
 254: PUSH
 255: EMPTY
 256: LIST
 257: DIFF
 258: ST_TO_ADDR
// if Cyrus and Bobby then
 259: LD_EXP 3
 263: PUSH
 264: LD_EXP 2
 268: AND
 269: IFFALSE 599
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 271: LD_EXP 3
 275: PPUSH
 276: LD_INT 43
 278: PPUSH
 279: LD_INT 72
 281: PPUSH
 282: CALL_OW 111
// ComMoveXY ( Bobby , 44 , 70 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_INT 44
 293: PPUSH
 294: LD_INT 70
 296: PPUSH
 297: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 301: LD_EXP 1
 305: PPUSH
 306: LD_INT 46
 308: PPUSH
 309: LD_INT 73
 311: PPUSH
 312: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 316: LD_EXP 3
 320: PPUSH
 321: LD_STRING D1a-Cyrus-1
 323: PPUSH
 324: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 328: LD_EXP 1
 332: PPUSH
 333: LD_STRING D1a-JMM-1
 335: PPUSH
 336: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 340: LD_EXP 3
 344: PPUSH
 345: LD_INT 37
 347: PPUSH
 348: LD_INT 66
 350: PPUSH
 351: CALL_OW 171
// AddComMoveXY ( Bobby , 41 , 67 ) ;
 355: LD_EXP 2
 359: PPUSH
 360: LD_INT 41
 362: PPUSH
 363: LD_INT 67
 365: PPUSH
 366: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 370: LD_EXP 1
 374: PPUSH
 375: LD_INT 38
 377: PPUSH
 378: LD_INT 64
 380: PPUSH
 381: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 385: LD_EXP 2
 389: PPUSH
 390: LD_STRING D1a-Bobby-2
 392: PPUSH
 393: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 397: LD_EXP 3
 401: PPUSH
 402: LD_INT 35
 404: PPUSH
 405: LD_INT 62
 407: PPUSH
 408: CALL_OW 171
// AddComMoveXY ( Bobby , 32 , 60 ) ;
 412: LD_EXP 2
 416: PPUSH
 417: LD_INT 32
 419: PPUSH
 420: LD_INT 60
 422: PPUSH
 423: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 427: LD_EXP 1
 431: PPUSH
 432: LD_INT 35
 434: PPUSH
 435: LD_INT 60
 437: PPUSH
 438: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 442: LD_EXP 1
 446: PPUSH
 447: LD_STRING D1a-JMM-2
 449: PPUSH
 450: CALL_OW 88
// ComWalk ( Lisa ) ;
 454: LD_EXP 4
 458: PPUSH
 459: CALL_OW 138
// wait ( 0 0$1 ) ;
 463: LD_INT 35
 465: PPUSH
 466: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 470: LD_EXP 4
 474: PPUSH
 475: LD_EXP 1
 479: PPUSH
 480: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus , Bobby ] , Lisa ) ;
 484: LD_EXP 1
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_EXP 2
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PPUSH
 504: LD_EXP 4
 508: PPUSH
 509: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
 513: LD_VAR 0 1
 517: PUSH
 518: LD_INT 1
 520: ARRAY
 521: PPUSH
 522: LD_INT 33
 524: PPUSH
 525: LD_INT 55
 527: PPUSH
 528: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
 532: LD_VAR 0 1
 536: PUSH
 537: LD_INT 2
 539: ARRAY
 540: PPUSH
 541: LD_INT 30
 543: PPUSH
 544: LD_INT 54
 546: PPUSH
 547: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
 551: LD_VAR 0 1
 555: PUSH
 556: LD_INT 1
 558: ARRAY
 559: PPUSH
 560: LD_EXP 1
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
 569: LD_VAR 0 1
 573: PUSH
 574: LD_INT 2
 576: ARRAY
 577: PPUSH
 578: LD_EXP 1
 582: PPUSH
 583: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 587: LD_EXP 4
 591: PPUSH
 592: LD_STRING D1a-Lisa-2
 594: PPUSH
 595: CALL_OW 88
// end ; if Cyrus and not Bobby then
 599: LD_EXP 3
 603: PUSH
 604: LD_EXP 2
 608: NOT
 609: AND
 610: IFFALSE 815
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 612: LD_EXP 3
 616: PPUSH
 617: LD_INT 43
 619: PPUSH
 620: LD_INT 72
 622: PPUSH
 623: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 627: LD_EXP 1
 631: PPUSH
 632: LD_INT 46
 634: PPUSH
 635: LD_INT 73
 637: PPUSH
 638: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 642: LD_EXP 3
 646: PPUSH
 647: LD_STRING D1a-Cyrus-1
 649: PPUSH
 650: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 654: LD_EXP 1
 658: PPUSH
 659: LD_STRING D1a-JMM-1
 661: PPUSH
 662: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 666: LD_EXP 3
 670: PPUSH
 671: LD_INT 37
 673: PPUSH
 674: LD_INT 66
 676: PPUSH
 677: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 681: LD_EXP 1
 685: PPUSH
 686: LD_INT 38
 688: PPUSH
 689: LD_INT 64
 691: PPUSH
 692: CALL_OW 171
// Say ( Cyrus , D1a-Cyrus-2 ) ;
 696: LD_EXP 3
 700: PPUSH
 701: LD_STRING D1a-Cyrus-2
 703: PPUSH
 704: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 708: LD_EXP 3
 712: PPUSH
 713: LD_INT 35
 715: PPUSH
 716: LD_INT 62
 718: PPUSH
 719: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 723: LD_EXP 1
 727: PPUSH
 728: LD_INT 35
 730: PPUSH
 731: LD_INT 60
 733: PPUSH
 734: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 738: LD_EXP 1
 742: PPUSH
 743: LD_STRING D1a-JMM-2
 745: PPUSH
 746: CALL_OW 88
// ComWalk ( Lisa ) ;
 750: LD_EXP 4
 754: PPUSH
 755: CALL_OW 138
// wait ( 0 0$1 ) ;
 759: LD_INT 35
 761: PPUSH
 762: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 766: LD_EXP 4
 770: PPUSH
 771: LD_EXP 1
 775: PPUSH
 776: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 780: LD_EXP 4
 784: PPUSH
 785: LD_STRING D1a-Lisa-2
 787: PPUSH
 788: CALL_OW 88
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 792: LD_EXP 1
 796: PUSH
 797: LD_EXP 3
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: LD_EXP 4
 810: PPUSH
 811: CALL_OW 119
// end ; if not Cyrus and Bobby then
 815: LD_EXP 3
 819: NOT
 820: PUSH
 821: LD_EXP 2
 825: AND
 826: IFFALSE 1105
// begin ComMoveXY ( Bobby , 44 , 70 ) ;
 828: LD_EXP 2
 832: PPUSH
 833: LD_INT 44
 835: PPUSH
 836: LD_INT 70
 838: PPUSH
 839: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 843: LD_EXP 1
 847: PPUSH
 848: LD_INT 46
 850: PPUSH
 851: LD_INT 73
 853: PPUSH
 854: CALL_OW 111
// Say ( Bobby , D1a-Bobby-1 ) ;
 858: LD_EXP 2
 862: PPUSH
 863: LD_STRING D1a-Bobby-1
 865: PPUSH
 866: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 870: LD_EXP 1
 874: PPUSH
 875: LD_STRING D1a-JMM-1
 877: PPUSH
 878: CALL_OW 88
// AddComMoveXY ( Bobby , 37 , 66 ) ;
 882: LD_EXP 2
 886: PPUSH
 887: LD_INT 37
 889: PPUSH
 890: LD_INT 66
 892: PPUSH
 893: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 897: LD_EXP 1
 901: PPUSH
 902: LD_INT 38
 904: PPUSH
 905: LD_INT 64
 907: PPUSH
 908: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 912: LD_EXP 2
 916: PPUSH
 917: LD_STRING D1a-Bobby-2
 919: PPUSH
 920: CALL_OW 88
// AddComMoveXY ( Bobby , 35 , 62 ) ;
 924: LD_EXP 2
 928: PPUSH
 929: LD_INT 35
 931: PPUSH
 932: LD_INT 62
 934: PPUSH
 935: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 939: LD_EXP 1
 943: PPUSH
 944: LD_INT 35
 946: PPUSH
 947: LD_INT 60
 949: PPUSH
 950: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 954: LD_EXP 1
 958: PPUSH
 959: LD_STRING D1a-JMM-2
 961: PPUSH
 962: CALL_OW 88
// ComWalk ( Lisa ) ;
 966: LD_EXP 4
 970: PPUSH
 971: CALL_OW 138
// wait ( 0 0$1 ) ;
 975: LD_INT 35
 977: PPUSH
 978: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 982: LD_EXP 4
 986: PPUSH
 987: LD_EXP 1
 991: PPUSH
 992: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 996: LD_EXP 1
1000: PUSH
1001: LD_EXP 3
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: LD_EXP 4
1014: PPUSH
1015: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 1
1026: ARRAY
1027: PPUSH
1028: LD_INT 33
1030: PPUSH
1031: LD_INT 55
1033: PPUSH
1034: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1038: LD_VAR 0 1
1042: PUSH
1043: LD_INT 2
1045: ARRAY
1046: PPUSH
1047: LD_INT 30
1049: PPUSH
1050: LD_INT 54
1052: PPUSH
1053: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1057: LD_VAR 0 1
1061: PUSH
1062: LD_INT 1
1064: ARRAY
1065: PPUSH
1066: LD_EXP 1
1070: PPUSH
1071: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1075: LD_VAR 0 1
1079: PUSH
1080: LD_INT 2
1082: ARRAY
1083: PPUSH
1084: LD_EXP 1
1088: PPUSH
1089: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
1093: LD_EXP 4
1097: PPUSH
1098: LD_STRING D1a-Lisa-2
1100: PPUSH
1101: CALL_OW 88
// end ; if not Cyrus and not Bobby then
1105: LD_EXP 3
1109: NOT
1110: PUSH
1111: LD_EXP 2
1115: NOT
1116: AND
1117: IFFALSE 1331
// begin ComMoveXY ( JMM , 37 , 66 ) ;
1119: LD_EXP 1
1123: PPUSH
1124: LD_INT 37
1126: PPUSH
1127: LD_INT 66
1129: PPUSH
1130: CALL_OW 111
// Say ( JMM , D1b-JMM-1 ) ;
1134: LD_EXP 1
1138: PPUSH
1139: LD_STRING D1b-JMM-1
1141: PPUSH
1142: CALL_OW 88
// ComCrawl ( JMM ) ;
1146: LD_EXP 1
1150: PPUSH
1151: CALL_OW 137
// AddComMoveXY ( JMM , 35 , 60 ) ;
1155: LD_EXP 1
1159: PPUSH
1160: LD_INT 35
1162: PPUSH
1163: LD_INT 60
1165: PPUSH
1166: CALL_OW 171
// wait ( 0 0$8 ) ;
1170: LD_INT 280
1172: PPUSH
1173: CALL_OW 67
// Say ( JMM , D1b-JMM-1a ) ;
1177: LD_EXP 1
1181: PPUSH
1182: LD_STRING D1b-JMM-1a
1184: PPUSH
1185: CALL_OW 88
// ComWalk ( [ JMM , Lisa ] ) ;
1189: LD_EXP 1
1193: PUSH
1194: LD_EXP 4
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 138
// wait ( 0 0$1 ) ;
1207: LD_INT 35
1209: PPUSH
1210: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
1214: LD_EXP 4
1218: PPUSH
1219: LD_EXP 1
1223: PPUSH
1224: CALL_OW 179
// AddComTurnUnit ( [ JMM ] , Lisa ) ;
1228: LD_EXP 1
1232: PUSH
1233: EMPTY
1234: LIST
1235: PPUSH
1236: LD_EXP 4
1240: PPUSH
1241: CALL_OW 179
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1245: LD_VAR 0 1
1249: PUSH
1250: LD_INT 1
1252: ARRAY
1253: PPUSH
1254: LD_INT 33
1256: PPUSH
1257: LD_INT 55
1259: PPUSH
1260: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1264: LD_VAR 0 1
1268: PUSH
1269: LD_INT 2
1271: ARRAY
1272: PPUSH
1273: LD_INT 30
1275: PPUSH
1276: LD_INT 54
1278: PPUSH
1279: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1283: LD_VAR 0 1
1287: PUSH
1288: LD_INT 1
1290: ARRAY
1291: PPUSH
1292: LD_EXP 1
1296: PPUSH
1297: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1301: LD_VAR 0 1
1305: PUSH
1306: LD_INT 2
1308: ARRAY
1309: PPUSH
1310: LD_EXP 1
1314: PPUSH
1315: CALL_OW 179
// Say ( Lisa , D1b-Lisa-1 ) ;
1319: LD_EXP 4
1323: PPUSH
1324: LD_STRING D1b-Lisa-1
1326: PPUSH
1327: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
1331: LD_EXP 1
1335: PPUSH
1336: LD_STRING D1-JMM-1
1338: PPUSH
1339: CALL_OW 88
// Say ( Lisa , D1-Lisa-1 ) ;
1343: LD_EXP 4
1347: PPUSH
1348: LD_STRING D1-Lisa-1
1350: PPUSH
1351: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
1355: LD_EXP 1
1359: PPUSH
1360: LD_STRING D1-JMM-2
1362: PPUSH
1363: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
1367: LD_EXP 9
1371: PPUSH
1372: LD_STRING D1-Pow-2
1374: PPUSH
1375: CALL_OW 94
// if Cyrus then
1379: LD_EXP 3
1383: IFFALSE 1409
// begin Say ( Cyrus , D1-Cyrus-2 ) ;
1385: LD_EXP 3
1389: PPUSH
1390: LD_STRING D1-Cyrus-2
1392: PPUSH
1393: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
1397: LD_EXP 1
1401: PPUSH
1402: LD_STRING D1-JMM-3
1404: PPUSH
1405: CALL_OW 88
// end ; SayRadio ( Powell , D1-Pow-3 ) ;
1409: LD_EXP 9
1413: PPUSH
1414: LD_STRING D1-Pow-3
1416: PPUSH
1417: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
1421: LD_EXP 1
1425: PPUSH
1426: LD_STRING D1-JMM-4
1428: PPUSH
1429: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
1433: LD_EXP 9
1437: PPUSH
1438: LD_STRING D1-Pow-4
1440: PPUSH
1441: CALL_OW 94
// SayRadio ( Powell , D1-Pow-4a ) ;
1445: LD_EXP 9
1449: PPUSH
1450: LD_STRING D1-Pow-4a
1452: PPUSH
1453: CALL_OW 94
// if Cyrus then
1457: LD_EXP 3
1461: IFFALSE 1475
// Say ( Cyrus , D1-Cyrus-4 ) ;
1463: LD_EXP 3
1467: PPUSH
1468: LD_STRING D1-Cyrus-4
1470: PPUSH
1471: CALL_OW 88
// if Bobby then
1475: LD_EXP 2
1479: IFFALSE 1517
// begin Say ( Bobby , D1-Bobby-4 ) ;
1481: LD_EXP 2
1485: PPUSH
1486: LD_STRING D1-Bobby-4
1488: PPUSH
1489: CALL_OW 88
// Say ( Lisa , D1-Lisa-4 ) ;
1493: LD_EXP 4
1497: PPUSH
1498: LD_STRING D1-Lisa-4
1500: PPUSH
1501: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
1505: LD_EXP 1
1509: PPUSH
1510: LD_STRING D1-JMM-5
1512: PPUSH
1513: CALL_OW 88
// end ; InGameOff ;
1517: CALL_OW 9
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) diff [ Brian , Jerry ] , 1 ) ;
1521: LD_INT 22
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: PPUSH
1531: CALL_OW 69
1535: PUSH
1536: LD_EXP 6
1540: PUSH
1541: LD_EXP 7
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: DIFF
1550: PPUSH
1551: LD_INT 1
1553: PPUSH
1554: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
1558: LD_STRING M1
1560: PPUSH
1561: CALL_OW 337
// SaveForQuickRestart ;
1565: CALL_OW 22
// end ;
1569: PPOPN 1
1571: END
// every 0 0$1 trigger FilterUnitsInArea ( PaulTriggerArea , [ f_side , 1 ] ) > 0 do
1572: LD_INT 7
1574: PPUSH
1575: LD_INT 22
1577: PUSH
1578: LD_INT 1
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PPUSH
1585: CALL_OW 70
1589: PUSH
1590: LD_INT 0
1592: GREATER
1593: IFFALSE 2010
1595: GO 1597
1597: DISABLE
// begin InGameOn ;
1598: CALL_OW 8
// ComHold ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
1602: LD_INT 22
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 21
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PPUSH
1626: CALL_OW 69
1630: PPUSH
1631: CALL_OW 140
// CenterOnXY ( 24 , 32 ) ;
1635: LD_INT 24
1637: PPUSH
1638: LD_INT 32
1640: PPUSH
1641: CALL_OW 84
// PlaceUnitArea ( Khatam , PaulSpawn , true ) ;
1645: LD_EXP 5
1649: PPUSH
1650: LD_INT 4
1652: PPUSH
1653: LD_INT 1
1655: PPUSH
1656: CALL_OW 49
// SetClass ( Khatam , 4 ) ;
1660: LD_EXP 5
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 336
// wait ( 0 0$1 ) ;
1672: LD_INT 35
1674: PPUSH
1675: CALL_OW 67
// ComMoveXY ( Khatam , 27 , 38 ) ;
1679: LD_EXP 5
1683: PPUSH
1684: LD_INT 27
1686: PPUSH
1687: LD_INT 38
1689: PPUSH
1690: CALL_OW 111
// AddComTurnUnit ( Khatam , JMM ) ;
1694: LD_EXP 5
1698: PPUSH
1699: LD_EXP 1
1703: PPUSH
1704: CALL_OW 179
// ComTurnUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ Khatam ] , Khatam ) ;
1708: LD_INT 22
1710: PUSH
1711: LD_INT 1
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: PUSH
1718: LD_INT 21
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PPUSH
1732: CALL_OW 69
1736: PUSH
1737: LD_EXP 5
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: PPUSH
1746: LD_EXP 5
1750: PPUSH
1751: CALL_OW 119
// wait ( 0 0$1 ) ;
1755: LD_INT 35
1757: PPUSH
1758: CALL_OW 67
// Say ( Khatam , D2a-Khat-1 ) ;
1762: LD_EXP 5
1766: PPUSH
1767: LD_STRING D2a-Khat-1
1769: PPUSH
1770: CALL_OW 88
// Say ( JMM , D2a-JMM-1 ) ;
1774: LD_EXP 1
1778: PPUSH
1779: LD_STRING D2a-JMM-1
1781: PPUSH
1782: CALL_OW 88
// Say ( Khatam , D2a-Khat-2 ) ;
1786: LD_EXP 5
1790: PPUSH
1791: LD_STRING D2a-Khat-2
1793: PPUSH
1794: CALL_OW 88
// Say ( JMM , D2a-JMM-2 ) ;
1798: LD_EXP 1
1802: PPUSH
1803: LD_STRING D2a-JMM-2
1805: PPUSH
1806: CALL_OW 88
// Say ( Khatam , D2a-Khat-3 ) ;
1810: LD_EXP 5
1814: PPUSH
1815: LD_STRING D2a-Khat-3
1817: PPUSH
1818: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
1822: LD_EXP 1
1826: PPUSH
1827: LD_STRING D2a-JMM-3
1829: PPUSH
1830: CALL_OW 88
// Say ( Khatam , D2a-Khat-4 ) ;
1834: LD_EXP 5
1838: PPUSH
1839: LD_STRING D2a-Khat-4
1841: PPUSH
1842: CALL_OW 88
// Say ( JMM , D2a-JMM-4 ) ;
1846: LD_EXP 1
1850: PPUSH
1851: LD_STRING D2a-JMM-4
1853: PPUSH
1854: CALL_OW 88
// Say ( Khatam , D2a-Khat-5 ) ;
1858: LD_EXP 5
1862: PPUSH
1863: LD_STRING D2a-Khat-5
1865: PPUSH
1866: CALL_OW 88
// Say ( JMM , D2a-JMM-5 ) ;
1870: LD_EXP 1
1874: PPUSH
1875: LD_STRING D2a-JMM-5
1877: PPUSH
1878: CALL_OW 88
// InGameOff ;
1882: CALL_OW 9
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 800 ] ] ] ) > 0 then
1886: LD_INT 22
1888: PUSH
1889: LD_INT 1
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: LD_INT 21
1898: PUSH
1899: LD_INT 1
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 3
1908: PUSH
1909: LD_INT 24
1911: PUSH
1912: LD_INT 800
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: EMPTY
1924: LIST
1925: LIST
1926: LIST
1927: PPUSH
1928: CALL_OW 69
1932: PUSH
1933: LD_INT 0
1935: GREATER
1936: IFFALSE 2010
// begin ComHeal ( Khatam , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ) ;
1938: LD_EXP 5
1942: PPUSH
1943: LD_INT 22
1945: PUSH
1946: LD_INT 1
1948: PUSH
1949: EMPTY
1950: LIST
1951: LIST
1952: PUSH
1953: LD_INT 21
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: EMPTY
1960: LIST
1961: LIST
1962: PUSH
1963: LD_INT 3
1965: PUSH
1966: LD_INT 24
1968: PUSH
1969: LD_INT 1000
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PPUSH
1985: CALL_OW 69
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: CALL_OW 128
// Say ( Khatam , D2b-Khat-1 ) ;
1998: LD_EXP 5
2002: PPUSH
2003: LD_STRING D2b-Khat-1
2005: PPUSH
2006: CALL_OW 88
// end ; end ;
2010: END
// every 0 0$1 trigger FilterUnitsInArea ( DeadTriggerArea , [ f_side , 1 ] ) > 0 do var i , distanceTab , min , tmp , p ;
2011: LD_INT 15
2013: PPUSH
2014: LD_INT 22
2016: PUSH
2017: LD_INT 1
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: PPUSH
2024: CALL_OW 70
2028: PUSH
2029: LD_INT 0
2031: GREATER
2032: IFFALSE 3229
2034: GO 2036
2036: DISABLE
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
// begin distanceTab = [ [ 999 , 999 ] ] ;
2044: LD_ADDR_VAR 0 2
2048: PUSH
2049: LD_INT 999
2051: PUSH
2052: LD_INT 999
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: PUSH
2059: EMPTY
2060: LIST
2061: ST_TO_ADDR
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam ] ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: LD_INT 22
2069: PUSH
2070: LD_INT 1
2072: PUSH
2073: EMPTY
2074: LIST
2075: LIST
2076: PUSH
2077: LD_INT 21
2079: PUSH
2080: LD_INT 1
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: PPUSH
2091: CALL_OW 69
2095: PUSH
2096: LD_EXP 1
2100: PUSH
2101: LD_EXP 2
2105: PUSH
2106: LD_EXP 3
2110: PUSH
2111: LD_EXP 4
2115: PUSH
2116: LD_EXP 5
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: DIFF
2128: ST_TO_ADDR
// PrepareDeadSoldiers ;
2129: CALL 11433 0 0
// spotCorpses = 1 ;
2133: LD_ADDR_EXP 32
2137: PUSH
2138: LD_INT 1
2140: ST_TO_ADDR
// wait ( 0 0$2 ) ;
2141: LD_INT 70
2143: PPUSH
2144: CALL_OW 67
// InGameOn ;
2148: CALL_OW 8
// CenterOnXY ( 23 , 12 ) ;
2152: LD_INT 23
2154: PPUSH
2155: LD_INT 12
2157: PPUSH
2158: CALL_OW 84
// min = distanceTab [ 1 ] [ 2 ] ;
2162: LD_ADDR_VAR 0 3
2166: PUSH
2167: LD_VAR 0 2
2171: PUSH
2172: LD_INT 1
2174: ARRAY
2175: PUSH
2176: LD_INT 2
2178: ARRAY
2179: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Khatam ] do
2180: LD_ADDR_VAR 0 1
2184: PUSH
2185: LD_INT 22
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 21
2197: PUSH
2198: LD_INT 1
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: CALL_OW 69
2213: PUSH
2214: LD_EXP 1
2218: PUSH
2219: LD_EXP 5
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: DIFF
2228: PUSH
2229: FOR_IN
2230: IFFALSE 2281
// if IsOK ( i ) then
2232: LD_VAR 0 1
2236: PPUSH
2237: CALL_OW 302
2241: IFFALSE 2279
// distanceTab = distanceTab ^ [ [ i , GetDistUnitArea ( i , DeadsSpawn ) ] ] ;
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 2
2252: PUSH
2253: LD_VAR 0 1
2257: PUSH
2258: LD_VAR 0 1
2262: PPUSH
2263: LD_INT 16
2265: PPUSH
2266: CALL_OW 299
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: ADD
2278: ST_TO_ADDR
2279: GO 2229
2281: POP
2282: POP
// for i = 2 to distanceTab do
2283: LD_ADDR_VAR 0 1
2287: PUSH
2288: DOUBLE
2289: LD_INT 2
2291: DEC
2292: ST_TO_ADDR
2293: LD_VAR 0 2
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2345
// if distanceTab [ i ] [ 2 ] < min then
2301: LD_VAR 0 2
2305: PUSH
2306: LD_VAR 0 1
2310: ARRAY
2311: PUSH
2312: LD_INT 2
2314: ARRAY
2315: PUSH
2316: LD_VAR 0 3
2320: LESS
2321: IFFALSE 2343
// min = distanceTab [ i ] [ 2 ] ;
2323: LD_ADDR_VAR 0 3
2327: PUSH
2328: LD_VAR 0 2
2332: PUSH
2333: LD_VAR 0 1
2337: ARRAY
2338: PUSH
2339: LD_INT 2
2341: ARRAY
2342: ST_TO_ADDR
2343: GO 2298
2345: POP
2346: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2347: LD_ADDR_VAR 0 1
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: LD_INT 1
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 21
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PPUSH
2376: CALL_OW 69
2380: PUSH
2381: LD_EXP 1
2385: PUSH
2386: EMPTY
2387: LIST
2388: DIFF
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2461
// begin ComMoveToArea ( i , DeadCutscene ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 28
2400: PPUSH
2401: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2405: LD_EXP 1
2409: PPUSH
2410: LD_INT 30
2412: PPUSH
2413: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2417: LD_VAR 0 1
2421: PPUSH
2422: LD_INT 23
2424: PPUSH
2425: LD_INT 11
2427: PPUSH
2428: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2432: LD_EXP 1
2436: PPUSH
2437: LD_INT 23
2439: PPUSH
2440: LD_INT 11
2442: PPUSH
2443: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2447: LD_EXP 34
2451: PPUSH
2452: LD_INT 250
2454: PPUSH
2455: CALL_OW 234
// end ;
2459: GO 2390
2461: POP
2462: POP
// for i = 2 to distanceTab do
2463: LD_ADDR_VAR 0 1
2467: PUSH
2468: DOUBLE
2469: LD_INT 2
2471: DEC
2472: ST_TO_ADDR
2473: LD_VAR 0 2
2477: PUSH
2478: FOR_TO
2479: IFFALSE 2865
// begin if distanceTab [ i ] [ 2 ] = min then
2481: LD_VAR 0 2
2485: PUSH
2486: LD_VAR 0 1
2490: ARRAY
2491: PUSH
2492: LD_INT 2
2494: ARRAY
2495: PUSH
2496: LD_VAR 0 3
2500: EQUAL
2501: IFFALSE 2863
// begin if distanceTab [ i ] [ 1 ] = Bobby then
2503: LD_VAR 0 2
2507: PUSH
2508: LD_VAR 0 1
2512: ARRAY
2513: PUSH
2514: LD_INT 1
2516: ARRAY
2517: PUSH
2518: LD_EXP 2
2522: EQUAL
2523: IFFALSE 2537
// Say ( Bobby , DCorpses-Bobby-1 ) ;
2525: LD_EXP 2
2529: PPUSH
2530: LD_STRING DCorpses-Bobby-1
2532: PPUSH
2533: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Cyrus then
2537: LD_VAR 0 2
2541: PUSH
2542: LD_VAR 0 1
2546: ARRAY
2547: PUSH
2548: LD_INT 1
2550: ARRAY
2551: PUSH
2552: LD_EXP 3
2556: EQUAL
2557: IFFALSE 2571
// Say ( Cyrus , DCorpses-Cyrus-1 ) ;
2559: LD_EXP 3
2563: PPUSH
2564: LD_STRING DCorpses-Cyrus-1
2566: PPUSH
2567: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Lisa then
2571: LD_VAR 0 2
2575: PUSH
2576: LD_VAR 0 1
2580: ARRAY
2581: PUSH
2582: LD_INT 1
2584: ARRAY
2585: PUSH
2586: LD_EXP 4
2590: EQUAL
2591: IFFALSE 2605
// Say ( Lisa , DCorpses-Lisa-1 ) ;
2593: LD_EXP 4
2597: PPUSH
2598: LD_STRING DCorpses-Lisa-1
2600: PPUSH
2601: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 1 then
2605: LD_VAR 0 2
2609: PUSH
2610: LD_VAR 0 1
2614: ARRAY
2615: PUSH
2616: LD_INT 1
2618: ARRAY
2619: PUSH
2620: LD_VAR 0 4
2624: PUSH
2625: LD_INT 1
2627: ARRAY
2628: EQUAL
2629: PUSH
2630: LD_VAR 0 4
2634: PUSH
2635: LD_INT 1
2637: ARRAY
2638: PPUSH
2639: CALL_OW 258
2643: PUSH
2644: LD_INT 1
2646: EQUAL
2647: AND
2648: IFFALSE 2666
// Say ( tmp [ 1 ] , DCorpses-Sol1-1 ) ;
2650: LD_VAR 0 4
2654: PUSH
2655: LD_INT 1
2657: ARRAY
2658: PPUSH
2659: LD_STRING DCorpses-Sol1-1
2661: PPUSH
2662: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 2 then
2666: LD_VAR 0 2
2670: PUSH
2671: LD_VAR 0 1
2675: ARRAY
2676: PUSH
2677: LD_INT 1
2679: ARRAY
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_INT 1
2688: ARRAY
2689: EQUAL
2690: PUSH
2691: LD_VAR 0 4
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 258
2704: PUSH
2705: LD_INT 2
2707: EQUAL
2708: AND
2709: IFFALSE 2727
// Say ( tmp [ 1 ] , DCorpses-FSol1-1 ) ;
2711: LD_VAR 0 4
2715: PUSH
2716: LD_INT 1
2718: ARRAY
2719: PPUSH
2720: LD_STRING DCorpses-FSol1-1
2722: PPUSH
2723: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 1 then
2727: LD_VAR 0 2
2731: PUSH
2732: LD_VAR 0 1
2736: ARRAY
2737: PUSH
2738: LD_INT 1
2740: ARRAY
2741: PUSH
2742: LD_VAR 0 4
2746: PUSH
2747: LD_INT 2
2749: ARRAY
2750: EQUAL
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 2
2759: ARRAY
2760: PPUSH
2761: CALL_OW 258
2765: PUSH
2766: LD_INT 1
2768: EQUAL
2769: AND
2770: IFFALSE 2788
// Say ( tmp [ 2 ] , DCorpses-Sol1-1 ) ;
2772: LD_VAR 0 4
2776: PUSH
2777: LD_INT 2
2779: ARRAY
2780: PPUSH
2781: LD_STRING DCorpses-Sol1-1
2783: PPUSH
2784: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 2 then
2788: LD_VAR 0 2
2792: PUSH
2793: LD_VAR 0 1
2797: ARRAY
2798: PUSH
2799: LD_INT 1
2801: ARRAY
2802: PUSH
2803: LD_VAR 0 4
2807: PUSH
2808: LD_INT 2
2810: ARRAY
2811: EQUAL
2812: PUSH
2813: LD_VAR 0 4
2817: PUSH
2818: LD_INT 2
2820: ARRAY
2821: PPUSH
2822: CALL_OW 258
2826: PUSH
2827: LD_INT 2
2829: EQUAL
2830: AND
2831: IFFALSE 2849
// Say ( tmp [ 2 ] , DCorpses-FSol1-1 ) ;
2833: LD_VAR 0 4
2837: PUSH
2838: LD_INT 2
2840: ARRAY
2841: PPUSH
2842: LD_STRING DCorpses-FSol1-1
2844: PPUSH
2845: CALL_OW 88
// SetLives ( DyingSold , 150 ) ;
2849: LD_EXP 34
2853: PPUSH
2854: LD_INT 150
2856: PPUSH
2857: CALL_OW 234
// break ;
2861: GO 2865
// end ; end ;
2863: GO 2478
2865: POP
2866: POP
// p := 0 ;
2867: LD_ADDR_VAR 0 5
2871: PUSH
2872: LD_INT 0
2874: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2875: LD_INT 35
2877: PPUSH
2878: CALL_OW 67
// p := p + 1 ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_INT 1
2894: PLUS
2895: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_INT 22
2903: PUSH
2904: LD_INT 1
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PUSH
2911: LD_INT 21
2913: PUSH
2914: LD_INT 1
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: PPUSH
2925: CALL_OW 69
2929: PUSH
2930: LD_EXP 1
2934: PUSH
2935: EMPTY
2936: LIST
2937: DIFF
2938: PUSH
2939: FOR_IN
2940: IFFALSE 3010
// begin ComMoveToArea ( i , DeadCutscene ) ;
2942: LD_VAR 0 1
2946: PPUSH
2947: LD_INT 28
2949: PPUSH
2950: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2954: LD_EXP 1
2958: PPUSH
2959: LD_INT 30
2961: PPUSH
2962: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2966: LD_VAR 0 1
2970: PPUSH
2971: LD_INT 23
2973: PPUSH
2974: LD_INT 11
2976: PPUSH
2977: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2981: LD_EXP 1
2985: PPUSH
2986: LD_INT 23
2988: PPUSH
2989: LD_INT 11
2991: PPUSH
2992: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2996: LD_EXP 34
3000: PPUSH
3001: LD_INT 250
3003: PPUSH
3004: CALL_OW 234
// end ;
3008: GO 2939
3010: POP
3011: POP
// until IsInArea ( JMM , JMMAreaCutscene ) or p >= 16 ;
3012: LD_EXP 1
3016: PPUSH
3017: LD_INT 30
3019: PPUSH
3020: CALL_OW 308
3024: PUSH
3025: LD_VAR 0 5
3029: PUSH
3030: LD_INT 16
3032: GREATEREQUAL
3033: OR
3034: IFFALSE 2875
// wait ( 0 0$1 ) ;
3036: LD_INT 35
3038: PPUSH
3039: CALL_OW 67
// Say ( JMM , DCorpses-JMM-1 ) ;
3043: LD_EXP 1
3047: PPUSH
3048: LD_STRING DCorpses-JMM-1
3050: PPUSH
3051: CALL_OW 88
// SetLives ( DyingSold , 100 ) ;
3055: LD_EXP 34
3059: PPUSH
3060: LD_INT 100
3062: PPUSH
3063: CALL_OW 234
// if IsOK ( Khatam ) then
3067: LD_EXP 5
3071: PPUSH
3072: CALL_OW 302
3076: IFFALSE 3213
// begin repeat wait ( 0 0$1 ) ;
3078: LD_INT 35
3080: PPUSH
3081: CALL_OW 67
// ComHeal ( Khatam , DyingSold ) ;
3085: LD_EXP 5
3089: PPUSH
3090: LD_EXP 34
3094: PPUSH
3095: CALL_OW 128
// until GetDistUnits ( Khatam , DyingSold ) < 2 ;
3099: LD_EXP 5
3103: PPUSH
3104: LD_EXP 34
3108: PPUSH
3109: CALL_OW 296
3113: PUSH
3114: LD_INT 2
3116: LESS
3117: IFFALSE 3078
// spotCorpses = 0 ;
3119: LD_ADDR_EXP 32
3123: PUSH
3124: LD_INT 0
3126: ST_TO_ADDR
// SetLives ( DyingSold , 10 ) ;
3127: LD_EXP 34
3131: PPUSH
3132: LD_INT 10
3134: PPUSH
3135: CALL_OW 234
// wait ( 0 0$3 ) ;
3139: LD_INT 105
3141: PPUSH
3142: CALL_OW 67
// KillUnit ( DyingSold ) ;
3146: LD_EXP 34
3150: PPUSH
3151: CALL_OW 66
// wait ( 0 0$1 ) ;
3155: LD_INT 35
3157: PPUSH
3158: CALL_OW 67
// CenterNowOnUnits ( [ JMM , Khatam ] ) ;
3162: LD_EXP 1
3166: PUSH
3167: LD_EXP 5
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 87
// ComTurnUnit ( Khatam , JMM ) ;
3180: LD_EXP 5
3184: PPUSH
3185: LD_EXP 1
3189: PPUSH
3190: CALL_OW 119
// wait ( 0 0$1 ) ;
3194: LD_INT 35
3196: PPUSH
3197: CALL_OW 67
// Say ( Khatam , DCorpses-Khat-1 ) ;
3201: LD_EXP 5
3205: PPUSH
3206: LD_STRING DCorpses-Khat-1
3208: PPUSH
3209: CALL_OW 88
// end ; InGameOff ;
3213: CALL_OW 9
// Say ( JMM , DCorpses-JMM-2 ) ;
3217: LD_EXP 1
3221: PPUSH
3222: LD_STRING DCorpses-JMM-2
3224: PPUSH
3225: CALL_OW 88
// end ;
3229: PPOPN 5
3231: END
// every 0 0$1 trigger spotCorpses = 1 do
3232: LD_EXP 32
3236: PUSH
3237: LD_INT 1
3239: EQUAL
3240: IFFALSE 3258
3242: GO 3244
3244: DISABLE
// begin enable ;
3245: ENABLE
// SetLives ( DyingSold , 10 ) ;
3246: LD_EXP 34
3250: PPUSH
3251: LD_INT 10
3253: PPUSH
3254: CALL_OW 234
// end ;
3258: END
// every 1 trigger ( FilterUnitsInArea ( WaterScene , [ f_side , 1 ] ) > 0 or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Jerry ) , Jerry ) < 13 ) do var i ;
3259: LD_INT 8
3261: PPUSH
3262: LD_INT 22
3264: PUSH
3265: LD_INT 1
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 70
3276: PUSH
3277: LD_INT 0
3279: GREATER
3280: PUSH
3281: LD_INT 22
3283: PUSH
3284: LD_INT 1
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PPUSH
3291: CALL_OW 69
3295: PPUSH
3296: LD_EXP 7
3300: PPUSH
3301: CALL_OW 74
3305: PPUSH
3306: LD_EXP 7
3310: PPUSH
3311: CALL_OW 296
3315: PUSH
3316: LD_INT 13
3318: LESS
3319: OR
3320: IFFALSE 3517
3322: GO 3324
3324: DISABLE
3325: LD_INT 0
3327: PPUSH
// begin InGameOn ;
3328: CALL_OW 8
// SetLives ( Jerry , 250 ) ;
3332: LD_EXP 7
3336: PPUSH
3337: LD_INT 250
3339: PPUSH
3340: CALL_OW 234
// SetLives ( Brian , [ 1000 , 800 , 750 ] [ Difficulty ] ) ;
3344: LD_EXP 6
3348: PPUSH
3349: LD_INT 1000
3351: PUSH
3352: LD_INT 800
3354: PUSH
3355: LD_INT 750
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_OWVAR 67
3367: ARRAY
3368: PPUSH
3369: CALL_OW 234
// SetAttitude ( 3 , 4 , att_enemy , true ) ;
3373: LD_INT 3
3375: PPUSH
3376: LD_INT 4
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: LD_INT 1
3384: PPUSH
3385: CALL_OW 80
// CenterOnUnits ( [ Brian , Jerry ] ) ;
3389: LD_EXP 6
3393: PUSH
3394: LD_EXP 7
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: PPUSH
3403: CALL_OW 85
// for i in FilterUnitsInArea ( RussiansWaterSpawn , [ f_side , 3 ] ) do
3407: LD_ADDR_VAR 0 1
3411: PUSH
3412: LD_INT 9
3414: PPUSH
3415: LD_INT 22
3417: PUSH
3418: LD_INT 3
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PPUSH
3425: CALL_OW 70
3429: PUSH
3430: FOR_IN
3431: IFFALSE 3444
// ComFree ( i ) ;
3433: LD_VAR 0 1
3437: PPUSH
3438: CALL_OW 139
3442: GO 3430
3444: POP
3445: POP
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3446: LD_ADDR_VAR 0 1
3450: PUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 4
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// ComFree ( i ) ;
3469: LD_VAR 0 1
3473: PPUSH
3474: CALL_OW 139
3478: GO 3466
3480: POP
3481: POP
// wait ( 0 0$1 ) ;
3482: LD_INT 35
3484: PPUSH
3485: CALL_OW 67
// InGameOff ;
3489: CALL_OW 9
// Say ( Brian , DF-Sol1-1 ) ;
3493: LD_EXP 6
3497: PPUSH
3498: LD_STRING DF-Sol1-1
3500: PPUSH
3501: CALL_OW 88
// Say ( JMM , DF-JMM-1 ) ;
3505: LD_EXP 1
3509: PPUSH
3510: LD_STRING DF-JMM-1
3512: PPUSH
3513: CALL_OW 88
// end ;
3517: PPOPN 1
3519: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 do
3520: LD_INT 19
3522: PPUSH
3523: LD_INT 22
3525: PUSH
3526: LD_INT 3
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 70
3537: PUSH
3538: LD_INT 0
3540: EQUAL
3541: IFFALSE 3650
3543: GO 3545
3545: DISABLE
// begin if not IsDead ( Brian ) then
3546: LD_EXP 6
3550: PPUSH
3551: CALL_OW 301
3555: NOT
3556: IFFALSE 3570
// SetSide ( Brian , 1 ) ;
3558: LD_EXP 6
3562: PPUSH
3563: LD_INT 1
3565: PPUSH
3566: CALL_OW 235
// if not IsDead ( Jerry ) then
3570: LD_EXP 7
3574: PPUSH
3575: CALL_OW 301
3579: NOT
3580: IFFALSE 3594
// SetSide ( Jerry , 1 ) ;
3582: LD_EXP 7
3586: PPUSH
3587: LD_INT 1
3589: PPUSH
3590: CALL_OW 235
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) then
3594: LD_INT 22
3596: PUSH
3597: LD_INT 1
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 25
3606: PUSH
3607: LD_INT 4
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PPUSH
3618: CALL_OW 69
3622: IFFALSE 3638
// Say ( JMM , DFa-JMM-1 ) else
3624: LD_EXP 1
3628: PPUSH
3629: LD_STRING DFa-JMM-1
3631: PPUSH
3632: CALL_OW 88
3636: GO 3650
// Say ( JMM , DFa-JMM-1a ) ;
3638: LD_EXP 1
3642: PPUSH
3643: LD_STRING DFa-JMM-1a
3645: PPUSH
3646: CALL_OW 88
// end ;
3650: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 and not IsOk ( Brian ) do
3651: LD_INT 19
3653: PPUSH
3654: LD_INT 22
3656: PUSH
3657: LD_INT 3
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PPUSH
3664: CALL_OW 70
3668: PUSH
3669: LD_INT 0
3671: EQUAL
3672: PUSH
3673: LD_EXP 6
3677: PPUSH
3678: CALL_OW 302
3682: NOT
3683: AND
3684: IFFALSE 3770
3686: GO 3688
3688: DISABLE
// begin repeat wait ( 0 0$1 ) ;
3689: LD_INT 35
3691: PPUSH
3692: CALL_OW 67
// until GetLives ( Brian ) > 250 ;
3696: LD_EXP 6
3700: PPUSH
3701: CALL_OW 256
3705: PUSH
3706: LD_INT 250
3708: GREATER
3709: IFFALSE 3689
// Say ( Brian , DFb-Sol1-1 ) ;
3711: LD_EXP 6
3715: PPUSH
3716: LD_STRING DFb-Sol1-1
3718: PPUSH
3719: CALL_OW 88
// ComMoveXY ( Brian , 78 , 74 ) ;
3723: LD_EXP 6
3727: PPUSH
3728: LD_INT 78
3730: PPUSH
3731: LD_INT 74
3733: PPUSH
3734: CALL_OW 111
// if IsDead ( Jerry ) then
3738: LD_EXP 7
3742: PPUSH
3743: CALL_OW 301
3747: IFFALSE 3763
// Say ( Brian , DFb-Sol1-1a ) else
3749: LD_EXP 6
3753: PPUSH
3754: LD_STRING DFb-Sol1-1a
3756: PPUSH
3757: CALL_OW 88
3761: GO 3770
// SetAchievement ( ACH_JERRY ) ;
3763: LD_STRING ACH_JERRY
3765: PPUSH
3766: CALL_OW 543
// end ;
3770: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) = 0 do var i ;
3771: LD_INT 22
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: PUSH
3781: LD_INT 21
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 0
3802: EQUAL
3803: IFFALSE 3891
3805: GO 3807
3807: DISABLE
3808: LD_INT 0
3810: PPUSH
// begin enable ;
3811: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_btype , 31 ] ] ) do
3812: LD_ADDR_VAR 0 1
3816: PUSH
3817: LD_INT 22
3819: PUSH
3820: LD_INT 3
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 21
3829: PUSH
3830: LD_INT 3
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: LD_INT 30
3839: PUSH
3840: LD_INT 31
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 69
3856: PUSH
3857: FOR_IN
3858: IFFALSE 3889
// begin if See ( 1 , i ) then
3860: LD_INT 1
3862: PPUSH
3863: LD_VAR 0 1
3867: PPUSH
3868: CALL_OW 292
3872: IFFALSE 3887
// begin disable ;
3874: DISABLE
// Say ( JMM , DX1-JMM-1 ) ;
3875: LD_EXP 1
3879: PPUSH
3880: LD_STRING DX1-JMM-1
3882: PPUSH
3883: CALL_OW 88
// end ; end ;
3887: GO 3857
3889: POP
3890: POP
// end ;
3891: PPOPN 1
3893: END
// every 0 0$1 trigger SeeArea ( 1 , SouthBaseRussianSpawn1 ) do var i , j , mech ;
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 11
3899: PPUSH
3900: CALL_OW 294
3904: IFFALSE 4163
3906: GO 3908
3908: DISABLE
3909: LD_INT 0
3911: PPUSH
3912: PPUSH
3913: PPUSH
// begin DialogueOn ;
3914: CALL_OW 6
// Say ( FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) [ 1 ] , DX3-Rus1-1 ) ;
3918: LD_INT 11
3920: PPUSH
3921: LD_INT 22
3923: PUSH
3924: LD_INT 3
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: PUSH
3931: LD_INT 21
3933: PUSH
3934: LD_INT 1
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PPUSH
3945: CALL_OW 70
3949: PUSH
3950: LD_INT 1
3952: ARRAY
3953: PPUSH
3954: LD_STRING DX3-Rus1-1
3956: PPUSH
3957: CALL_OW 88
// Say ( JMM , DX3-JMM-1 ) ;
3961: LD_EXP 1
3965: PPUSH
3966: LD_STRING DX3-JMM-1
3968: PPUSH
3969: CALL_OW 88
// DialogueOff ;
3973: CALL_OW 7
// for i in FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
3977: LD_ADDR_VAR 0 1
3981: PUSH
3982: LD_INT 11
3984: PPUSH
3985: LD_INT 22
3987: PUSH
3988: LD_INT 3
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: LD_INT 25
3997: PUSH
3998: LD_INT 1
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 70
4013: PUSH
4014: FOR_IN
4015: IFFALSE 4035
// southBaseDefenders = southBaseDefenders ^ i ;
4017: LD_ADDR_EXP 25
4021: PUSH
4022: LD_EXP 25
4026: PUSH
4027: LD_VAR 0 1
4031: ADD
4032: ST_TO_ADDR
4033: GO 4014
4035: POP
4036: POP
// wait ( [ 0 0$5 , 0 0$4 , 0 0$3 ] [ Difficulty ] ) ;
4037: LD_INT 175
4039: PUSH
4040: LD_INT 140
4042: PUSH
4043: LD_INT 105
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: LD_OWVAR 67
4055: ARRAY
4056: PPUSH
4057: CALL_OW 67
// mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , 3 ] ] ) ;
4061: LD_ADDR_VAR 0 3
4065: PUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 3
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 21
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 25
4088: PUSH
4089: LD_INT 3
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 69
4105: ST_TO_ADDR
// if not mech then
4106: LD_VAR 0 3
4110: NOT
4111: IFFALSE 4115
// exit ;
4113: GO 4163
// ComExitBuilding ( mech ) ;
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL_OW 122
// wait ( 0 0$1 ) ;
4124: LD_INT 35
4126: PPUSH
4127: CALL_OW 67
// AddComEnterUnit ( mech [ 1 ] , vehicle1 ) ;
4131: LD_VAR 0 3
4135: PUSH
4136: LD_INT 1
4138: ARRAY
4139: PPUSH
4140: LD_INT 5
4142: PPUSH
4143: CALL_OW 180
// AddComEnterUnit ( mech [ 2 ] , vehicle2 ) ;
4147: LD_VAR 0 3
4151: PUSH
4152: LD_INT 2
4154: ARRAY
4155: PPUSH
4156: LD_INT 4
4158: PPUSH
4159: CALL_OW 180
// end ;
4163: PPOPN 3
4165: END
// every 0 0$1 trigger See ( 1 , vehicle1 ) or See ( 1 , vehicle2 ) do
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 5
4171: PPUSH
4172: CALL_OW 292
4176: PUSH
4177: LD_INT 1
4179: PPUSH
4180: LD_INT 4
4182: PPUSH
4183: CALL_OW 292
4187: OR
4188: IFFALSE 4272
4190: GO 4192
4192: DISABLE
// begin CenterOnUnits ( [ vehicle1 , vehicle2 ] ) ;
4193: LD_INT 5
4195: PUSH
4196: LD_INT 4
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PPUSH
4203: CALL_OW 85
// if IsOK ( Bobby ) then
4207: LD_EXP 2
4211: PPUSH
4212: CALL_OW 302
4216: IFFALSE 4252
// begin DialogueOn ;
4218: CALL_OW 6
// Say ( Bobby , DX2-Bobby-1 ) ;
4222: LD_EXP 2
4226: PPUSH
4227: LD_STRING DX2-Bobby-1
4229: PPUSH
4230: CALL_OW 88
// Say ( JMM , DX2-JMM-1a ) ;
4234: LD_EXP 1
4238: PPUSH
4239: LD_STRING DX2-JMM-1a
4241: PPUSH
4242: CALL_OW 88
// DialogueOff ;
4246: CALL_OW 7
// end else
4250: GO 4272
// begin DialogueOn ;
4252: CALL_OW 6
// Say ( JMM , DX2-JMM-1 ) ;
4256: LD_EXP 1
4260: PPUSH
4261: LD_STRING DX2-JMM-1
4263: PPUSH
4264: CALL_OW 88
// DialogueOff ;
4268: CALL_OW 7
// end ; end ;
4272: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) do var tmp , speaker , temp1 , temp2 , i ;
4273: LD_INT 22
4275: PUSH
4276: LD_INT 1
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 23
4285: PUSH
4286: LD_INT 3
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 2
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: LD_INT 34
4305: PUSH
4306: LD_INT 42
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PPUSH
4319: CALL_OW 69
4323: IFFALSE 4744
4325: GO 4327
4327: DISABLE
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
4333: PPUSH
4334: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) ;
4335: LD_ADDR_VAR 0 1
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 1
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 23
4352: PUSH
4353: LD_INT 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 21
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 34
4372: PUSH
4373: LD_INT 42
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: PPUSH
4386: CALL_OW 69
4390: ST_TO_ADDR
// temp1 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Cyrus , Bobby ] ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: LD_INT 22
4398: PUSH
4399: LD_INT 1
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 26
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL_OW 69
4435: PUSH
4436: LD_EXP 1
4440: PUSH
4441: LD_EXP 3
4445: PUSH
4446: LD_EXP 2
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: DIFF
4456: ST_TO_ADDR
// temp2 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_female ] ] ) diff [ Lisa ] ;
4457: LD_ADDR_VAR 0 4
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 26
4484: PUSH
4485: LD_INT 2
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: DIFF
4510: ST_TO_ADDR
// if not tmp then
4511: LD_VAR 0 1
4515: NOT
4516: IFFALSE 4520
// exit ;
4518: GO 4744
// speaker := IsDrivenBy ( tmp [ 1 ] ) ;
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: LD_VAR 0 1
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PPUSH
4534: CALL_OW 311
4538: ST_TO_ADDR
// if not speaker then
4539: LD_VAR 0 2
4543: NOT
4544: IFFALSE 4548
// exit ;
4546: GO 4744
// DialogueOn ;
4548: CALL_OW 6
// if speaker = JMM then
4552: LD_VAR 0 2
4556: PUSH
4557: LD_EXP 1
4561: EQUAL
4562: IFFALSE 4596
// begin if Lisa then
4564: LD_EXP 4
4568: IFFALSE 4582
// Say ( Lisa , DX2b-Lisa-1 ) ;
4570: LD_EXP 4
4574: PPUSH
4575: LD_STRING DX2b-Lisa-1
4577: PPUSH
4578: CALL_OW 88
// Say ( JMM , DX2b-JMM-1 ) ;
4582: LD_EXP 1
4586: PPUSH
4587: LD_STRING DX2b-JMM-1
4589: PPUSH
4590: CALL_OW 88
// end else
4594: GO 4740
// begin Say ( JMM , DX2a-JMM-1 ) ;
4596: LD_EXP 1
4600: PPUSH
4601: LD_STRING DX2a-JMM-1
4603: PPUSH
4604: CALL_OW 88
// if speaker = Bobby then
4608: LD_VAR 0 2
4612: PUSH
4613: LD_EXP 2
4617: EQUAL
4618: IFFALSE 4632
// Say ( Bobby , DX2a-Bobby-1 ) ;
4620: LD_EXP 2
4624: PPUSH
4625: LD_STRING DX2a-Bobby-1
4627: PPUSH
4628: CALL_OW 88
// if speaker = Cyrus then
4632: LD_VAR 0 2
4636: PUSH
4637: LD_EXP 3
4641: EQUAL
4642: IFFALSE 4656
// Say ( Cyrus , DX2a-Cyrus-1 ) ;
4644: LD_EXP 3
4648: PPUSH
4649: LD_STRING DX2a-Cyrus-1
4651: PPUSH
4652: CALL_OW 88
// if speaker = Lisa then
4656: LD_VAR 0 2
4660: PUSH
4661: LD_EXP 4
4665: EQUAL
4666: IFFALSE 4680
// Say ( Lisa , DX2a-Lisa-1 ) ;
4668: LD_EXP 4
4672: PPUSH
4673: LD_STRING DX2a-Lisa-1
4675: PPUSH
4676: CALL_OW 88
// if speaker in temp1 then
4680: LD_VAR 0 2
4684: PUSH
4685: LD_VAR 0 3
4689: IN
4690: IFFALSE 4704
// Say ( speaker , DX2a-Sol1-1 ) ;
4692: LD_VAR 0 2
4696: PPUSH
4697: LD_STRING DX2a-Sol1-1
4699: PPUSH
4700: CALL_OW 88
// if speaker in temp2 then
4704: LD_VAR 0 2
4708: PUSH
4709: LD_VAR 0 4
4713: IN
4714: IFFALSE 4728
// Say ( speaker , DX2a-FSol1-1 ) ;
4716: LD_VAR 0 2
4720: PPUSH
4721: LD_STRING DX2a-FSol1-1
4723: PPUSH
4724: CALL_OW 88
// Say ( JMM , DX2a-JMM-2 ) ;
4728: LD_EXP 1
4732: PPUSH
4733: LD_STRING DX2a-JMM-2
4735: PPUSH
4736: CALL_OW 88
// end ; DialogueOff ;
4740: CALL_OW 7
// end ;
4744: PPOPN 5
4746: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 or GetSide ( dep2 ) = 1 do
4747: LD_INT 1
4749: PPUSH
4750: CALL_OW 255
4754: PUSH
4755: LD_INT 1
4757: EQUAL
4758: PUSH
4759: LD_INT 10
4761: PPUSH
4762: CALL_OW 255
4766: PUSH
4767: LD_INT 1
4769: EQUAL
4770: OR
4771: IFFALSE 4831
4773: GO 4775
4775: DISABLE
// begin DialogueOn ;
4776: CALL_OW 6
// Say ( JMM , D3-JMM-1 ) ;
4780: LD_EXP 1
4784: PPUSH
4785: LD_STRING D3-JMM-1
4787: PPUSH
4788: CALL_OW 88
// SayRadio ( Powell , D3-Pow-1 ) ;
4792: LD_EXP 9
4796: PPUSH
4797: LD_STRING D3-Pow-1
4799: PPUSH
4800: CALL_OW 94
// if IsOK ( Cyrus ) then
4804: LD_EXP 3
4808: PPUSH
4809: CALL_OW 302
4813: IFFALSE 4827
// Say ( Cyrus , D3-Cyrus-1 ) ;
4815: LD_EXP 3
4819: PPUSH
4820: LD_STRING D3-Cyrus-1
4822: PPUSH
4823: CALL_OW 88
// DialogueOff ;
4827: CALL_OW 7
// end ;
4831: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 do var temp , tmp , i ;
4832: LD_INT 1
4834: PPUSH
4835: CALL_OW 255
4839: PUSH
4840: LD_INT 1
4842: EQUAL
4843: PUSH
4844: LD_INT 10
4846: PPUSH
4847: CALL_OW 255
4851: PUSH
4852: LD_INT 1
4854: EQUAL
4855: AND
4856: IFFALSE 6239
4858: GO 4860
4860: DISABLE
4861: LD_INT 0
4863: PPUSH
4864: PPUSH
4865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4866: LD_ADDR_VAR 0 2
4870: PUSH
4871: LD_INT 22
4873: PUSH
4874: LD_INT 3
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 21
4883: PUSH
4884: LD_INT 1
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 69
4899: ST_TO_ADDR
// if tmp then
4900: LD_VAR 0 2
4904: IFFALSE 4965
// begin for i in tmp do
4906: LD_ADDR_VAR 0 3
4910: PUSH
4911: LD_VAR 0 2
4915: PUSH
4916: FOR_IN
4917: IFFALSE 4963
// begin if IsInUnit ( i ) then
4919: LD_VAR 0 3
4923: PPUSH
4924: CALL_OW 310
4928: IFFALSE 4939
// ComExitBuilding ( i ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: CALL_OW 122
// wait ( 0 0$1 ) ;
4939: LD_INT 35
4941: PPUSH
4942: CALL_OW 67
// AddComAgressiveMove ( i , 54 , 17 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 54
4953: PPUSH
4954: LD_INT 17
4956: PPUSH
4957: CALL_OW 174
// end ;
4961: GO 4916
4963: POP
4964: POP
// end ; wait ( 0 0$03 ) ;
4965: LD_INT 105
4967: PPUSH
4968: CALL_OW 67
// DialogueOn ;
4972: CALL_OW 6
// Say ( JMM , D3a-JMM-1 ) ;
4976: LD_EXP 1
4980: PPUSH
4981: LD_STRING D3a-JMM-1
4983: PPUSH
4984: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-1 ) ;
4988: LD_EXP 9
4992: PPUSH
4993: LD_STRING D3a-Pow-1
4995: PPUSH
4996: CALL_OW 94
// Say ( JMM , D3a-JMM-2 ) ;
5000: LD_EXP 1
5004: PPUSH
5005: LD_STRING D3a-JMM-2
5007: PPUSH
5008: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-2 ) ;
5012: LD_EXP 9
5016: PPUSH
5017: LD_STRING D3a-Pow-2
5019: PPUSH
5020: CALL_OW 94
// Say ( JMM , D3a-JMM-3 ) ;
5024: LD_EXP 1
5028: PPUSH
5029: LD_STRING D3a-JMM-3
5031: PPUSH
5032: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-3 ) ;
5036: LD_EXP 9
5040: PPUSH
5041: LD_STRING D3a-Pow-3
5043: PPUSH
5044: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
5048: LD_EXP 1
5052: PPUSH
5053: LD_STRING D3a-JMM-4
5055: PPUSH
5056: CALL_OW 88
// DialogueOff ;
5060: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5064: LD_STRING M2
5066: PPUSH
5067: CALL_OW 337
// Say ( JMM , D3b-JMM-1 ) ;
5071: LD_EXP 1
5075: PPUSH
5076: LD_STRING D3b-JMM-1
5078: PPUSH
5079: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// until FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_class , 2 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
5090: LD_INT 22
5092: PPUSH
5093: LD_INT 22
5095: PUSH
5096: LD_INT 1
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 25
5105: PUSH
5106: LD_INT 2
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PPUSH
5117: CALL_OW 70
5121: PUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 3
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 21
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: NOT
5151: AND
5152: IFFALSE 5083
// repeat temp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Khatam ] ;
5154: LD_ADDR_VAR 0 1
5158: PUSH
5159: LD_INT 22
5161: PUSH
5162: LD_INT 1
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: LD_INT 23
5171: PUSH
5172: LD_INT 1
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: PUSH
5179: LD_INT 25
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PUSH
5189: LD_INT 50
5191: PUSH
5192: EMPTY
5193: LIST
5194: PUSH
5195: LD_INT 56
5197: PUSH
5198: EMPTY
5199: LIST
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: PUSH
5213: LD_EXP 1
5217: PUSH
5218: LD_EXP 5
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: DIFF
5227: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until temp > 0 ;
5235: LD_VAR 0 1
5239: PUSH
5240: LD_INT 0
5242: GREATER
5243: IFFALSE 5154
// wait ( 0 0$5 ) ;
5245: LD_INT 175
5247: PPUSH
5248: CALL_OW 67
// PrepareRussianHeroes ;
5252: CALL 11590 0 0
// InGameOn ;
5256: CALL_OW 8
// CenterNowOnUnits ( Mikhail ) ;
5260: LD_EXP 8
5264: PPUSH
5265: CALL_OW 87
// ComTurnUnit ( [ JMM , temp [ 1 ] ] , Mikhail ) ;
5269: LD_EXP 1
5273: PUSH
5274: LD_VAR 0 1
5278: PUSH
5279: LD_INT 1
5281: ARRAY
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PPUSH
5287: LD_EXP 8
5291: PPUSH
5292: CALL_OW 119
// ComTurnUnit ( Mikhail , temp [ 1 ] ) ;
5296: LD_EXP 8
5300: PPUSH
5301: LD_VAR 0 1
5305: PUSH
5306: LD_INT 1
5308: ARRAY
5309: PPUSH
5310: CALL_OW 119
// Wait ( 0 0$02 ) ;
5314: LD_INT 70
5316: PPUSH
5317: CALL_OW 67
// Say ( Mikhail , D4-Mikh-1 ) ;
5321: LD_EXP 8
5325: PPUSH
5326: LD_STRING D4-Mikh-1
5328: PPUSH
5329: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5333: LD_VAR 0 1
5337: PUSH
5338: LD_INT 1
5340: ARRAY
5341: PPUSH
5342: CALL_OW 258
5346: PUSH
5347: LD_INT 1
5349: EQUAL
5350: IFFALSE 5368
// Say ( temp [ 1 ] , D4-Sol1-1 ) ;
5352: LD_VAR 0 1
5356: PUSH
5357: LD_INT 1
5359: ARRAY
5360: PPUSH
5361: LD_STRING D4-Sol1-1
5363: PPUSH
5364: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: CALL_OW 258
5381: PUSH
5382: LD_INT 2
5384: EQUAL
5385: IFFALSE 5403
// Say ( temp [ 1 ] , D4-FSol1-1 ) ;
5387: LD_VAR 0 1
5391: PUSH
5392: LD_INT 1
5394: ARRAY
5395: PPUSH
5396: LD_STRING D4-FSol1-1
5398: PPUSH
5399: CALL_OW 88
// Say ( Mikhail , D4-Mikh-2 ) ;
5403: LD_EXP 8
5407: PPUSH
5408: LD_STRING D4-Mikh-2
5410: PPUSH
5411: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5415: LD_VAR 0 1
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: CALL_OW 258
5428: PUSH
5429: LD_INT 1
5431: EQUAL
5432: IFFALSE 5450
// Say ( temp [ 1 ] , D4-Sol1-2 ) ;
5434: LD_VAR 0 1
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: LD_STRING D4-Sol1-2
5445: PPUSH
5446: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5450: LD_VAR 0 1
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: CALL_OW 258
5463: PUSH
5464: LD_INT 2
5466: EQUAL
5467: IFFALSE 5485
// Say ( temp [ 1 ] , D4-FSol1-2 ) ;
5469: LD_VAR 0 1
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PPUSH
5478: LD_STRING D4-FSol1-2
5480: PPUSH
5481: CALL_OW 88
// Say ( Mikhail , D4-Mikh-3 ) ;
5485: LD_EXP 8
5489: PPUSH
5490: LD_STRING D4-Mikh-3
5492: PPUSH
5493: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: CALL_OW 258
5510: PUSH
5511: LD_INT 1
5513: EQUAL
5514: IFFALSE 5532
// Say ( temp [ 1 ] , D4-Sol1-3 ) ;
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 1
5523: ARRAY
5524: PPUSH
5525: LD_STRING D4-Sol1-3
5527: PPUSH
5528: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5532: LD_VAR 0 1
5536: PUSH
5537: LD_INT 1
5539: ARRAY
5540: PPUSH
5541: CALL_OW 258
5545: PUSH
5546: LD_INT 2
5548: EQUAL
5549: IFFALSE 5567
// Say ( temp [ 1 ] , D4-FSol1-3 ) ;
5551: LD_VAR 0 1
5555: PUSH
5556: LD_INT 1
5558: ARRAY
5559: PPUSH
5560: LD_STRING D4-FSol1-3
5562: PPUSH
5563: CALL_OW 88
// Say ( Mikhail , D4-Mikh-4 ) ;
5567: LD_EXP 8
5571: PPUSH
5572: LD_STRING D4-Mikh-4
5574: PPUSH
5575: CALL_OW 88
// case query ( Qs1 ) of 1 :
5579: LD_STRING Qs1
5581: PPUSH
5582: CALL_OW 97
5586: PUSH
5587: LD_INT 1
5589: DOUBLE
5590: EQUAL
5591: IFTRUE 5595
5593: GO 5630
5595: POP
// begin InGameOff ;
5596: CALL_OW 9
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
5600: LD_INT 1
5602: PPUSH
5603: LD_INT 6
5605: PPUSH
5606: LD_INT 2
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: CALL_OW 80
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
5616: LD_EXP 8
5620: PPUSH
5621: LD_INT 17
5623: PPUSH
5624: CALL_OW 113
// end ; 2 :
5628: GO 6223
5630: LD_INT 2
5632: DOUBLE
5633: EQUAL
5634: IFTRUE 5638
5636: GO 6188
5638: POP
// begin repeat wait ( 0 0$1 ) ;
5639: LD_INT 35
5641: PPUSH
5642: CALL_OW 67
// CenterNowOnUnits ( temp [ 1 ] ) ;
5646: LD_VAR 0 1
5650: PUSH
5651: LD_INT 1
5653: ARRAY
5654: PPUSH
5655: CALL_OW 87
// ComMoveUnit ( temp [ 1 ] , JMM ) ;
5659: LD_VAR 0 1
5663: PUSH
5664: LD_INT 1
5666: ARRAY
5667: PPUSH
5668: LD_EXP 1
5672: PPUSH
5673: CALL_OW 112
// ComMoveUnit ( Mikhail , JMM ) ;
5677: LD_EXP 8
5681: PPUSH
5682: LD_EXP 1
5686: PPUSH
5687: CALL_OW 112
// until ( GetDistUnits ( JMM , Mikhail ) < 5 ) ;
5691: LD_EXP 1
5695: PPUSH
5696: LD_EXP 8
5700: PPUSH
5701: CALL_OW 296
5705: PUSH
5706: LD_INT 5
5708: LESS
5709: IFFALSE 5639
// ComTurnUnit ( Mikhail , JMM ) ;
5711: LD_EXP 8
5715: PPUSH
5716: LD_EXP 1
5720: PPUSH
5721: CALL_OW 119
// Say ( JMM , D4b-JMM-1 ) ;
5725: LD_EXP 1
5729: PPUSH
5730: LD_STRING D4b-JMM-1
5732: PPUSH
5733: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-1 ) ;
5737: LD_EXP 8
5741: PPUSH
5742: LD_STRING D4b-Mikh-1
5744: PPUSH
5745: CALL_OW 88
// Say ( JMM , D4b-JMM-2 ) ;
5749: LD_EXP 1
5753: PPUSH
5754: LD_STRING D4b-JMM-2
5756: PPUSH
5757: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-2 ) ;
5761: LD_EXP 8
5765: PPUSH
5766: LD_STRING D4b-Mikh-2
5768: PPUSH
5769: CALL_OW 88
// Say ( JMM , D4b-JMM-3 ) ;
5773: LD_EXP 1
5777: PPUSH
5778: LD_STRING D4b-JMM-3
5780: PPUSH
5781: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-3 ) ;
5785: LD_EXP 8
5789: PPUSH
5790: LD_STRING D4b-Mikh-3
5792: PPUSH
5793: CALL_OW 88
// Say ( JMM , D4b-JMM-4 ) ;
5797: LD_EXP 1
5801: PPUSH
5802: LD_STRING D4b-JMM-4
5804: PPUSH
5805: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-4 ) ;
5809: LD_EXP 8
5813: PPUSH
5814: LD_STRING D4b-Mikh-4
5816: PPUSH
5817: CALL_OW 88
// Say ( JMM , D4b-JMM-5 ) ;
5821: LD_EXP 1
5825: PPUSH
5826: LD_STRING D4b-JMM-5
5828: PPUSH
5829: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-5 ) ;
5833: LD_EXP 8
5837: PPUSH
5838: LD_STRING D4b-Mikh-5
5840: PPUSH
5841: CALL_OW 88
// Say ( JMM , D4b-JMM-6 ) ;
5845: LD_EXP 1
5849: PPUSH
5850: LD_STRING D4b-JMM-6
5852: PPUSH
5853: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-6 ) ;
5857: LD_EXP 8
5861: PPUSH
5862: LD_STRING D4b-Mikh-6
5864: PPUSH
5865: CALL_OW 88
// Say ( JMM , D4b-JMM-7 ) ;
5869: LD_EXP 1
5873: PPUSH
5874: LD_STRING D4b-JMM-7
5876: PPUSH
5877: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-7 ) ;
5881: LD_EXP 8
5885: PPUSH
5886: LD_STRING D4b-Mikh-7
5888: PPUSH
5889: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5893: LD_VAR 0 1
5897: PUSH
5898: LD_INT 1
5900: ARRAY
5901: PPUSH
5902: CALL_OW 258
5906: PUSH
5907: LD_INT 1
5909: EQUAL
5910: IFFALSE 5928
// Say ( temp [ 1 ] , D4b-Sol1-7 ) ;
5912: LD_VAR 0 1
5916: PUSH
5917: LD_INT 1
5919: ARRAY
5920: PPUSH
5921: LD_STRING D4b-Sol1-7
5923: PPUSH
5924: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5928: LD_VAR 0 1
5932: PUSH
5933: LD_INT 1
5935: ARRAY
5936: PPUSH
5937: CALL_OW 258
5941: PUSH
5942: LD_INT 2
5944: EQUAL
5945: IFFALSE 5963
// Say ( temp [ 1 ] , D4b-FSol1-7 ) ;
5947: LD_VAR 0 1
5951: PUSH
5952: LD_INT 1
5954: ARRAY
5955: PPUSH
5956: LD_STRING D4b-FSol1-7
5958: PPUSH
5959: CALL_OW 88
// Say ( JMM , D4b-JMM-8 ) ;
5963: LD_EXP 1
5967: PPUSH
5968: LD_STRING D4b-JMM-8
5970: PPUSH
5971: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5975: LD_VAR 0 1
5979: PUSH
5980: LD_INT 1
5982: ARRAY
5983: PPUSH
5984: CALL_OW 258
5988: PUSH
5989: LD_INT 1
5991: EQUAL
5992: IFFALSE 6010
// Say ( temp [ 1 ] , D4b-Sol1-8 ) ;
5994: LD_VAR 0 1
5998: PUSH
5999: LD_INT 1
6001: ARRAY
6002: PPUSH
6003: LD_STRING D4b-Sol1-8
6005: PPUSH
6006: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
6010: LD_VAR 0 1
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PPUSH
6019: CALL_OW 258
6023: PUSH
6024: LD_INT 2
6026: EQUAL
6027: IFFALSE 6045
// Say ( temp [ 1 ] , D4b-FSol1-8 ) ;
6029: LD_VAR 0 1
6033: PUSH
6034: LD_INT 1
6036: ARRAY
6037: PPUSH
6038: LD_STRING D4b-FSol1-8
6040: PPUSH
6041: CALL_OW 88
// Say ( JMM , D4b-JMM-9 ) ;
6045: LD_EXP 1
6049: PPUSH
6050: LD_STRING D4b-JMM-9
6052: PPUSH
6053: CALL_OW 88
// SetSide ( Mikhail , 1 ) ;
6057: LD_EXP 8
6061: PPUSH
6062: LD_INT 1
6064: PPUSH
6065: CALL_OW 235
// for i in FilterAllUnits ( [ [ f_side , 1 ] ] ) do
6069: LD_ADDR_VAR 0 3
6073: PUSH
6074: LD_INT 22
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: PPUSH
6087: CALL_OW 69
6091: PUSH
6092: FOR_IN
6093: IFFALSE 6106
// ComFree ( i ) ;
6095: LD_VAR 0 3
6099: PPUSH
6100: CALL_OW 139
6104: GO 6092
6106: POP
6107: POP
// repeat wait ( 0 0$1 ) ;
6108: LD_INT 35
6110: PPUSH
6111: CALL_OW 67
// CenterNowOnUnits ( Mikhail ) ;
6115: LD_EXP 8
6119: PPUSH
6120: CALL_OW 87
// ComEnterUnit ( [ Mikhail , temp [ 1 ] ] , dep1 ) ;
6124: LD_EXP 8
6128: PUSH
6129: LD_VAR 0 1
6133: PUSH
6134: LD_INT 1
6136: ARRAY
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: CALL_OW 120
// until IsInUnit ( Mikhail ) ;
6149: LD_EXP 8
6153: PPUSH
6154: CALL_OW 310
6158: IFFALSE 6108
// mikhailDepot = IsInUnit ( Mikhail ) ;
6160: LD_ADDR_EXP 23
6164: PUSH
6165: LD_EXP 8
6169: PPUSH
6170: CALL_OW 310
6174: ST_TO_ADDR
// InGameOff ;
6175: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
6179: LD_STRING M3
6181: PPUSH
6182: CALL_OW 337
// end ; 3 :
6186: GO 6223
6188: LD_INT 3
6190: DOUBLE
6191: EQUAL
6192: IFTRUE 6196
6194: GO 6222
6196: POP
// begin ComMoveToArea ( Mikhail , MikhailEscape ) ;
6197: LD_EXP 8
6201: PPUSH
6202: LD_INT 17
6204: PPUSH
6205: CALL_OW 113
// wait ( 0 0$3 ) ;
6209: LD_INT 105
6211: PPUSH
6212: CALL_OW 67
// InGameOff ;
6216: CALL_OW 9
// end ; end ;
6220: GO 6223
6222: POP
// PrepareTigers ;
6223: CALL 14440 0 0
// RussianTrap ;
6227: CALL 9986 0 0
// tigersRespawn = 1 ;
6231: LD_ADDR_EXP 30
6235: PUSH
6236: LD_INT 1
6238: ST_TO_ADDR
// end ;
6239: PPOPN 3
6241: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and GetResourceType ( GetBase ( dep1 ) , 1 ) >= 100 do var tmp ;
6242: LD_INT 1
6244: PPUSH
6245: CALL_OW 255
6249: PUSH
6250: LD_INT 1
6252: EQUAL
6253: PUSH
6254: LD_INT 10
6256: PPUSH
6257: CALL_OW 255
6261: PUSH
6262: LD_INT 1
6264: EQUAL
6265: AND
6266: PUSH
6267: LD_INT 1
6269: PPUSH
6270: CALL_OW 274
6274: PPUSH
6275: LD_INT 1
6277: PPUSH
6278: CALL_OW 275
6282: PUSH
6283: LD_INT 100
6285: GREATEREQUAL
6286: AND
6287: IFFALSE 6436
6289: GO 6291
6291: DISABLE
6292: LD_INT 0
6294: PPUSH
// begin wait ( rand ( 1 1$0 , 2 2$0 ) + 0 0$30 ) ;
6295: LD_INT 2100
6297: PPUSH
6298: LD_INT 4200
6300: PPUSH
6301: CALL_OW 12
6305: PUSH
6306: LD_INT 1050
6308: PLUS
6309: PPUSH
6310: CALL_OW 67
// PrepareCargoBays ;
6314: CALL 12723 0 0
// cargoRespawn = 1 ;
6318: LD_ADDR_EXP 28
6322: PUSH
6323: LD_INT 1
6325: ST_TO_ADDR
// tmp := [ cargo1 , cargo2 , driver1 , driver2 ] ;
6326: LD_ADDR_VAR 0 1
6330: PUSH
6331: LD_EXP 15
6335: PUSH
6336: LD_EXP 16
6340: PUSH
6341: LD_EXP 17
6345: PUSH
6346: LD_EXP 18
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: ST_TO_ADDR
// ComMoveXY ( tmp , 17 , 10 ) ;
6357: LD_VAR 0 1
6361: PPUSH
6362: LD_INT 17
6364: PPUSH
6365: LD_INT 10
6367: PPUSH
6368: CALL_OW 111
// AddComMoveXY ( tmp , 36 , 13 ) ;
6372: LD_VAR 0 1
6376: PPUSH
6377: LD_INT 36
6379: PPUSH
6380: LD_INT 13
6382: PPUSH
6383: CALL_OW 171
// AddComMoveXY ( tmp , 40 , 20 ) ;
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 40
6394: PPUSH
6395: LD_INT 20
6397: PPUSH
6398: CALL_OW 171
// AddComMoveXY ( tmp , 53 , 16 ) ;
6402: LD_VAR 0 1
6406: PPUSH
6407: LD_INT 53
6409: PPUSH
6410: LD_INT 16
6412: PPUSH
6413: CALL_OW 171
// wait ( 0 0$5 ) ;
6417: LD_INT 175
6419: PPUSH
6420: CALL_OW 67
// Say ( driver1 , D5-Rus2-1 ) ;
6424: LD_EXP 17
6428: PPUSH
6429: LD_STRING D5-Rus2-1
6431: PPUSH
6432: CALL_OW 88
// end ;
6436: PPOPN 1
6438: END
// every 0 0$1 trigger cargoRespawn = 1 do var cargos ;
6439: LD_EXP 28
6443: PUSH
6444: LD_INT 1
6446: EQUAL
6447: IFFALSE 6602
6449: GO 6451
6451: DISABLE
6452: LD_INT 0
6454: PPUSH
// begin cargos = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
6455: LD_ADDR_VAR 0 1
6459: PUSH
6460: LD_INT 22
6462: PUSH
6463: LD_INT 3
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 21
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: LD_INT 34
6482: PUSH
6483: LD_INT 51
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
6500: LD_INT 105
6502: PPUSH
6503: CALL_OW 67
// until UnitFilter ( cargos , [ f_not , [ f_hastask ] ] ) or UnitFilter ( cargos , [ f_not , [ f_lives , 980 ] ] ) ;
6507: LD_VAR 0 1
6511: PPUSH
6512: LD_INT 3
6514: PUSH
6515: LD_INT 60
6517: PUSH
6518: EMPTY
6519: LIST
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PPUSH
6525: CALL_OW 72
6529: PUSH
6530: LD_VAR 0 1
6534: PPUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 980
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PPUSH
6552: CALL_OW 72
6556: OR
6557: IFFALSE 6500
// ComMoveXY ( cargos , 7 , 9 ) ;
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 7
6566: PPUSH
6567: LD_INT 9
6569: PPUSH
6570: CALL_OW 111
// cargoSee = 1 ;
6574: LD_ADDR_EXP 29
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// cargoEscape = 1 ;
6582: LD_ADDR_EXP 20
6586: PUSH
6587: LD_INT 1
6589: ST_TO_ADDR
// Say ( driver1 , D5-Rus2-1a ) ;
6590: LD_EXP 17
6594: PPUSH
6595: LD_STRING D5-Rus2-1a
6597: PPUSH
6598: CALL_OW 88
// end ;
6602: PPOPN 1
6604: END
// every 0 0$1 trigger cargoEscape > 0 do
6605: LD_EXP 20
6609: PUSH
6610: LD_INT 0
6612: GREATER
6613: IFFALSE 6760
6615: GO 6617
6617: DISABLE
// begin enable ;
6618: ENABLE
// ComMoveToArea ( [ cargo1 , cargo2 ] , RussianAttack ) ;
6619: LD_EXP 15
6623: PUSH
6624: LD_EXP 16
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PPUSH
6633: LD_INT 13
6635: PPUSH
6636: CALL_OW 113
// if IsInArea ( cargo1 , RussianAttack ) or IsInArea ( driver1 , RussianAttack ) then
6640: LD_EXP 15
6644: PPUSH
6645: LD_INT 13
6647: PPUSH
6648: CALL_OW 308
6652: PUSH
6653: LD_EXP 17
6657: PPUSH
6658: LD_INT 13
6660: PPUSH
6661: CALL_OW 308
6665: OR
6666: IFFALSE 6700
// begin RemoveUnit ( cargo1 ) ;
6668: LD_EXP 15
6672: PPUSH
6673: CALL_OW 64
// RemoveUnit ( driver1 ) ;
6677: LD_EXP 17
6681: PPUSH
6682: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6686: LD_ADDR_EXP 20
6690: PUSH
6691: LD_EXP 20
6695: PUSH
6696: LD_INT 1
6698: PLUS
6699: ST_TO_ADDR
// end ; if IsInArea ( cargo2 , RussianAttack ) or IsInArea ( driver2 , RussianAttack ) then
6700: LD_EXP 16
6704: PPUSH
6705: LD_INT 13
6707: PPUSH
6708: CALL_OW 308
6712: PUSH
6713: LD_EXP 18
6717: PPUSH
6718: LD_INT 13
6720: PPUSH
6721: CALL_OW 308
6725: OR
6726: IFFALSE 6760
// begin RemoveUnit ( cargo2 ) ;
6728: LD_EXP 16
6732: PPUSH
6733: CALL_OW 64
// RemoveUnit ( driver2 ) ;
6737: LD_EXP 18
6741: PPUSH
6742: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6746: LD_ADDR_EXP 20
6750: PUSH
6751: LD_EXP 20
6755: PUSH
6756: LD_INT 1
6758: PLUS
6759: ST_TO_ADDR
// end ; end ;
6760: END
// every 0 0$1 trigger cargoEscape > 1 do var speaker ;
6761: LD_EXP 20
6765: PUSH
6766: LD_INT 1
6768: GREATER
6769: IFFALSE 6926
6771: GO 6773
6773: DISABLE
6774: LD_INT 0
6776: PPUSH
// begin SetRestrict ( b_armoury , 1 , true ) ;
6777: LD_INT 4
6779: PPUSH
6780: LD_INT 1
6782: PPUSH
6783: LD_INT 1
6785: PPUSH
6786: CALL_OW 324
// SetRestrict ( 31 , 1 , true ) ;
6790: LD_INT 31
6792: PPUSH
6793: LD_INT 1
6795: PPUSH
6796: LD_INT 1
6798: PPUSH
6799: CALL_OW 324
// if IsOK ( Jerry ) then
6803: LD_EXP 7
6807: PPUSH
6808: CALL_OW 302
6812: IFFALSE 6828
// Say ( Jerry , D5a-Sol1-1 ) else
6814: LD_EXP 7
6818: PPUSH
6819: LD_STRING D5a-Sol1-1
6821: PPUSH
6822: CALL_OW 88
6826: GO 6914
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Khatam ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 22
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 26
6845: PUSH
6846: LD_INT 1
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PPUSH
6857: CALL_OW 69
6861: PUSH
6862: LD_EXP 1
6866: PUSH
6867: LD_EXP 2
6871: PUSH
6872: LD_EXP 3
6876: PUSH
6877: LD_EXP 5
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: LIST
6886: LIST
6887: DIFF
6888: ST_TO_ADDR
// if not speaker then
6889: LD_VAR 0 1
6893: NOT
6894: IFFALSE 6898
// exit ;
6896: GO 6926
// Say ( speaker [ 1 ] , D5a-Sol1-1 ) ;
6898: LD_VAR 0 1
6902: PUSH
6903: LD_INT 1
6905: ARRAY
6906: PPUSH
6907: LD_STRING D5a-Sol1-1
6909: PPUSH
6910: CALL_OW 88
// end ; Say ( JMM , D5a-JMM-1 ) ;
6914: LD_EXP 1
6918: PPUSH
6919: LD_STRING D5a-JMM-1
6921: PPUSH
6922: CALL_OW 88
// end ;
6926: PPOPN 1
6928: END
// every 0 0$1 trigger ( GetSide ( dep1 ) = 3 and GetLives ( dep1 ) < 1000 ) or ( GetSide ( dep2 ) = 3 and GetLives ( dep2 ) < 1000 ) do
6929: LD_INT 1
6931: PPUSH
6932: CALL_OW 255
6936: PUSH
6937: LD_INT 3
6939: EQUAL
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: CALL_OW 256
6948: PUSH
6949: LD_INT 1000
6951: LESS
6952: AND
6953: PUSH
6954: LD_INT 10
6956: PPUSH
6957: CALL_OW 255
6961: PUSH
6962: LD_INT 3
6964: EQUAL
6965: PUSH
6966: LD_INT 10
6968: PPUSH
6969: CALL_OW 256
6973: PUSH
6974: LD_INT 1000
6976: LESS
6977: AND
6978: OR
6979: IFFALSE 6996
6981: GO 6983
6983: DISABLE
// begin Say ( JMM , D8-JMM-1 ) ;
6984: LD_EXP 1
6988: PPUSH
6989: LD_STRING D8-JMM-1
6991: PPUSH
6992: CALL_OW 88
// end ;
6996: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) = dep1 and not mikhailInbase = 3 do
6997: LD_EXP 8
7001: PPUSH
7002: CALL_OW 310
7006: PUSH
7007: LD_INT 1
7009: EQUAL
7010: PUSH
7011: LD_EXP 22
7015: PUSH
7016: LD_INT 3
7018: EQUAL
7019: NOT
7020: AND
7021: IFFALSE 7043
7023: GO 7025
7025: DISABLE
// begin mikhailInBase = 1 ;
7026: LD_ADDR_EXP 22
7030: PUSH
7031: LD_INT 1
7033: ST_TO_ADDR
// mikhailStatus = 1 ;
7034: LD_ADDR_EXP 21
7038: PUSH
7039: LD_INT 1
7041: ST_TO_ADDR
// enable ;
7042: ENABLE
// end ;
7043: END
// export function AskMikhail ; begin
7044: LD_INT 0
7046: PPUSH
// case query ( QMikh2 ) of 1 :
7047: LD_STRING QMikh2
7049: PPUSH
7050: CALL_OW 97
7054: PUSH
7055: LD_INT 1
7057: DOUBLE
7058: EQUAL
7059: IFTRUE 7063
7061: GO 7130
7063: POP
// begin SetAttitude ( 1 , 6 , att_enemy , true ) ;
7064: LD_INT 1
7066: PPUSH
7067: LD_INT 6
7069: PPUSH
7070: LD_INT 2
7072: PPUSH
7073: LD_INT 1
7075: PPUSH
7076: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7080: LD_EXP 8
7084: PPUSH
7085: LD_INT 6
7087: PPUSH
7088: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7092: LD_EXP 8
7096: PPUSH
7097: CALL_OW 122
// wait ( 0 0$1 ) ;
7101: LD_INT 35
7103: PPUSH
7104: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7108: LD_EXP 8
7112: PPUSH
7113: LD_INT 17
7115: PPUSH
7116: CALL_OW 113
// mikhailInbase = 0 ;
7120: LD_ADDR_EXP 22
7124: PUSH
7125: LD_INT 0
7127: ST_TO_ADDR
// end ; 2 :
7128: GO 7371
7130: LD_INT 2
7132: DOUBLE
7133: EQUAL
7134: IFTRUE 7138
7136: GO 7311
7138: POP
// begin mikhailInBase = 2 ;
7139: LD_ADDR_EXP 22
7143: PUSH
7144: LD_INT 2
7146: ST_TO_ADDR
// SetSide ( Mikhail , 6 ) ;
7147: LD_EXP 8
7151: PPUSH
7152: LD_INT 6
7154: PPUSH
7155: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7159: LD_EXP 8
7163: PPUSH
7164: CALL_OW 122
// wait ( 0 0$1 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// ComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) + 2 ) ;
7175: LD_EXP 8
7179: PPUSH
7180: LD_EXP 8
7184: PPUSH
7185: CALL_OW 250
7189: PUSH
7190: LD_INT 2
7192: PLUS
7193: PPUSH
7194: LD_EXP 8
7198: PPUSH
7199: CALL_OW 251
7203: PUSH
7204: LD_INT 2
7206: PLUS
7207: PPUSH
7208: CALL_OW 111
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 1 , GetY ( Mikhail ) + 2 ) ;
7212: LD_EXP 8
7216: PPUSH
7217: LD_EXP 8
7221: PPUSH
7222: CALL_OW 250
7226: PUSH
7227: LD_INT 1
7229: PLUS
7230: PPUSH
7231: LD_EXP 8
7235: PPUSH
7236: CALL_OW 251
7240: PUSH
7241: LD_INT 2
7243: PLUS
7244: PPUSH
7245: CALL_OW 171
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) ) ;
7249: LD_EXP 8
7253: PPUSH
7254: LD_EXP 8
7258: PPUSH
7259: CALL_OW 250
7263: PUSH
7264: LD_INT 2
7266: PLUS
7267: PPUSH
7268: LD_EXP 8
7272: PPUSH
7273: CALL_OW 251
7277: PPUSH
7278: CALL_OW 171
// wait ( 0 0$5 ) ;
7282: LD_INT 175
7284: PPUSH
7285: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEnter ) ;
7289: LD_EXP 8
7293: PPUSH
7294: LD_INT 25
7296: PPUSH
7297: CALL_OW 113
// mikhailInBase = 4 ;
7301: LD_ADDR_EXP 22
7305: PUSH
7306: LD_INT 4
7308: ST_TO_ADDR
// end ; 3 :
7309: GO 7371
7311: LD_INT 3
7313: DOUBLE
7314: EQUAL
7315: IFTRUE 7319
7317: GO 7370
7319: POP
// begin SetSide ( Mikhail , 6 ) ;
7320: LD_EXP 8
7324: PPUSH
7325: LD_INT 6
7327: PPUSH
7328: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7332: LD_EXP 8
7336: PPUSH
7337: CALL_OW 122
// wait ( 0 0$1 ) ;
7341: LD_INT 35
7343: PPUSH
7344: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7348: LD_EXP 8
7352: PPUSH
7353: LD_INT 17
7355: PPUSH
7356: CALL_OW 113
// mikhailInbase = 3 ;
7360: LD_ADDR_EXP 22
7364: PUSH
7365: LD_INT 3
7367: ST_TO_ADDR
// end ; end ;
7368: GO 7371
7370: POP
// end ;
7371: LD_VAR 0 1
7375: RET
// every 1 trigger IsInArea ( Mikhail , MikhailEnter ) and mikhailInBase = 4 do
7376: LD_EXP 8
7380: PPUSH
7381: LD_INT 25
7383: PPUSH
7384: CALL_OW 308
7388: PUSH
7389: LD_EXP 22
7393: PUSH
7394: LD_INT 4
7396: EQUAL
7397: AND
7398: IFFALSE 7502
7400: GO 7402
7402: DISABLE
// begin enable ;
7403: ENABLE
// mikhailInBase = 1 ;
7404: LD_ADDR_EXP 22
7408: PUSH
7409: LD_INT 1
7411: ST_TO_ADDR
// InGameOn ;
7412: CALL_OW 8
// SetSide ( dep1 , 6 ) ;
7416: LD_INT 1
7418: PPUSH
7419: LD_INT 6
7421: PPUSH
7422: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
7426: LD_INT 35
7428: PPUSH
7429: CALL_OW 67
// if Carry ( Mikhail ) then
7433: LD_EXP 8
7437: PPUSH
7438: CALL_OW 281
7442: IFFALSE 7453
// ComUnload ( Mikhail ) ;
7444: LD_EXP 8
7448: PPUSH
7449: CALL_OW 159
// AddComEnterUnit ( Mikhail , dep1 ) ;
7453: LD_EXP 8
7457: PPUSH
7458: LD_INT 1
7460: PPUSH
7461: CALL_OW 180
// until IsInUnit ( Mikhail ) ;
7465: LD_EXP 8
7469: PPUSH
7470: CALL_OW 310
7474: IFFALSE 7426
// SetSide ( dep1 , 1 ) ;
7476: LD_INT 1
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: CALL_OW 235
// SetSide ( Mikhail , 1 ) ;
7486: LD_EXP 8
7490: PPUSH
7491: LD_INT 1
7493: PPUSH
7494: CALL_OW 235
// InGameOff ;
7498: CALL_OW 9
// end ;
7502: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) and not mikhailInBase = 3 do
7503: LD_EXP 8
7507: PPUSH
7508: CALL_OW 310
7512: PUSH
7513: LD_EXP 22
7517: PUSH
7518: LD_INT 3
7520: EQUAL
7521: NOT
7522: AND
7523: IFFALSE 7658
7525: GO 7527
7527: DISABLE
// begin enable ;
7528: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , IsInUnit ( Mikhail ) , 10 ] ] ) = 1 then
7529: LD_INT 22
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PUSH
7539: LD_INT 21
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 91
7551: PUSH
7552: LD_EXP 8
7556: PPUSH
7557: CALL_OW 310
7561: PUSH
7562: LD_INT 10
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PPUSH
7575: CALL_OW 69
7579: PUSH
7580: LD_INT 1
7582: EQUAL
7583: IFFALSE 7658
// begin mikhailStatus = 4 ;
7585: LD_ADDR_EXP 21
7589: PUSH
7590: LD_INT 4
7592: ST_TO_ADDR
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
7593: LD_INT 1
7595: PPUSH
7596: LD_INT 6
7598: PPUSH
7599: LD_INT 2
7601: PPUSH
7602: LD_INT 1
7604: PPUSH
7605: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7609: LD_EXP 8
7613: PPUSH
7614: LD_INT 6
7616: PPUSH
7617: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7621: LD_EXP 8
7625: PPUSH
7626: CALL_OW 122
// wait ( 0 0$1 ) ;
7630: LD_INT 35
7632: PPUSH
7633: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7637: LD_EXP 8
7641: PPUSH
7642: LD_INT 17
7644: PPUSH
7645: CALL_OW 113
// mikhailStatus = 3 ;
7649: LD_ADDR_EXP 21
7653: PUSH
7654: LD_INT 3
7656: ST_TO_ADDR
// disable ;
7657: DISABLE
// end ; end ;
7658: END
// every 0 0$1 trigger GetDistUnits ( JMM , mikhailDepot ) < 5 and mikhailStatus = 3 and not mikhailInBase = 3 do var tmp ;
7659: LD_EXP 1
7663: PPUSH
7664: LD_EXP 23
7668: PPUSH
7669: CALL_OW 296
7673: PUSH
7674: LD_INT 5
7676: LESS
7677: PUSH
7678: LD_EXP 21
7682: PUSH
7683: LD_INT 3
7685: EQUAL
7686: AND
7687: PUSH
7688: LD_EXP 22
7692: PUSH
7693: LD_INT 3
7695: EQUAL
7696: NOT
7697: AND
7698: IFFALSE 7920
7700: GO 7702
7702: DISABLE
7703: LD_INT 0
7705: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Khatam ] ;
7706: LD_ADDR_VAR 0 1
7710: PUSH
7711: LD_INT 22
7713: PUSH
7714: LD_INT 1
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: LD_INT 21
7723: PUSH
7724: LD_INT 1
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 26
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: LIST
7745: PPUSH
7746: CALL_OW 69
7750: PUSH
7751: LD_EXP 1
7755: PUSH
7756: LD_EXP 5
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: DIFF
7765: ST_TO_ADDR
// DialogueOn ;
7766: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
7770: LD_EXP 1
7774: PPUSH
7775: LD_STRING D7-JMM-1
7777: PPUSH
7778: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-1 ) ;
7782: LD_VAR 0 1
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: PPUSH
7791: LD_STRING D7-Sol1-1
7793: PPUSH
7794: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
7798: LD_EXP 1
7802: PPUSH
7803: LD_STRING D7-JMM-2
7805: PPUSH
7806: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-2 ) ;
7810: LD_VAR 0 1
7814: PUSH
7815: LD_INT 1
7817: ARRAY
7818: PPUSH
7819: LD_STRING D7-Sol1-2
7821: PPUSH
7822: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
7826: LD_EXP 1
7830: PPUSH
7831: LD_STRING D7-JMM-3
7833: PPUSH
7834: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-3 ) ;
7838: LD_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PPUSH
7847: LD_STRING D7-Sol1-3
7849: PPUSH
7850: CALL_OW 88
// if IsOK ( Cyrus ) and IsOK ( Lisa ) then
7854: LD_EXP 3
7858: PPUSH
7859: CALL_OW 302
7863: PUSH
7864: LD_EXP 4
7868: PPUSH
7869: CALL_OW 302
7873: AND
7874: IFFALSE 7916
// begin Say ( Cyrus , D7-Cyrus-3 ) ;
7876: LD_EXP 3
7880: PPUSH
7881: LD_STRING D7-Cyrus-3
7883: PPUSH
7884: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-4 ) ;
7888: LD_VAR 0 1
7892: PUSH
7893: LD_INT 1
7895: ARRAY
7896: PPUSH
7897: LD_STRING D7-Sol1-4
7899: PPUSH
7900: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
7904: LD_EXP 4
7908: PPUSH
7909: LD_STRING D7-Lisa-4
7911: PPUSH
7912: CALL_OW 88
// end ; DialogueOff ;
7916: CALL_OW 7
// end ;
7920: PPOPN 1
7922: END
// every 0 0$1 trigger IsDying ( Mikhail ) and mikhailStatus = 3 do
7923: LD_EXP 8
7927: PPUSH
7928: CALL_OW 303
7932: PUSH
7933: LD_EXP 21
7937: PUSH
7938: LD_INT 3
7940: EQUAL
7941: AND
7942: IFFALSE 7956
7944: GO 7946
7946: DISABLE
// begin enable ;
7947: ENABLE
// mikhailStatus = 2 ;
7948: LD_ADDR_EXP 21
7952: PUSH
7953: LD_INT 2
7955: ST_TO_ADDR
// end ;
7956: END
// every 0 0$1 trigger IsInArea ( Mikhail , MikhailEscape ) and GetSide ( Mikhail ) = 6 do
7957: LD_EXP 8
7961: PPUSH
7962: LD_INT 17
7964: PPUSH
7965: CALL_OW 308
7969: PUSH
7970: LD_EXP 8
7974: PPUSH
7975: CALL_OW 255
7979: PUSH
7980: LD_INT 6
7982: EQUAL
7983: AND
7984: IFFALSE 8017
7986: GO 7988
7988: DISABLE
// begin if not mikhailInBase = 3 then
7989: LD_EXP 22
7993: PUSH
7994: LD_INT 3
7996: EQUAL
7997: NOT
7998: IFFALSE 8008
// mikhailStatus = 3 ;
8000: LD_ADDR_EXP 21
8004: PUSH
8005: LD_INT 3
8007: ST_TO_ADDR
// RemoveUnit ( Mikhail ) ;
8008: LD_EXP 8
8012: PPUSH
8013: CALL_OW 64
// end ;
8017: END
// every 0 0$1 trigger mikhailStatus = 3 and GetSide ( Mikhail ) = 6 do var i , attacker ;
8018: LD_EXP 21
8022: PUSH
8023: LD_INT 3
8025: EQUAL
8026: PUSH
8027: LD_EXP 8
8031: PPUSH
8032: CALL_OW 255
8036: PUSH
8037: LD_INT 6
8039: EQUAL
8040: AND
8041: IFFALSE 8207
8043: GO 8045
8045: DISABLE
8046: LD_INT 0
8048: PPUSH
8049: PPUSH
// begin enable ;
8050: ENABLE
// if IsOk ( Mikhail ) then
8051: LD_EXP 8
8055: PPUSH
8056: CALL_OW 302
8060: IFFALSE 8207
// begin attacker = Nearest ( Mikhail , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
8062: LD_ADDR_VAR 0 2
8066: PUSH
8067: LD_EXP 8
8071: PPUSH
8072: LD_INT 22
8074: PUSH
8075: LD_INT 1
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 21
8084: PUSH
8085: LD_INT 1
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: PPUSH
8101: CALL 10178 0 2
8105: ST_TO_ADDR
// if GetDistUnits ( attacker , Mikhail ) < 8 then
8106: LD_VAR 0 2
8110: PPUSH
8111: LD_EXP 8
8115: PPUSH
8116: CALL_OW 296
8120: PUSH
8121: LD_INT 8
8123: LESS
8124: IFFALSE 8207
// begin if GetSex ( attacker ) = sex_male then
8126: LD_VAR 0 2
8130: PPUSH
8131: CALL_OW 258
8135: PUSH
8136: LD_INT 1
8138: EQUAL
8139: IFFALSE 8175
// begin disable ;
8141: DISABLE
// Say ( attacker , D7a-Sol1-1 ) ;
8142: LD_VAR 0 2
8146: PPUSH
8147: LD_STRING D7a-Sol1-1
8149: PPUSH
8150: CALL_OW 88
// wait ( 0 0$2 ) ;
8154: LD_INT 70
8156: PPUSH
8157: CALL_OW 67
// Say ( attacker , D7a-Sol1-1a ) ;
8161: LD_VAR 0 2
8165: PPUSH
8166: LD_STRING D7a-Sol1-1a
8168: PPUSH
8169: CALL_OW 88
// end else
8173: GO 8207
// begin disable ;
8175: DISABLE
// Say ( attacker , D7a-FSol1-1 ) ;
8176: LD_VAR 0 2
8180: PPUSH
8181: LD_STRING D7a-FSol1-1
8183: PPUSH
8184: CALL_OW 88
// wait ( 0 0$2 ) ;
8188: LD_INT 70
8190: PPUSH
8191: CALL_OW 67
// Say ( attacker , D7a-FSol1-1a ) ;
8195: LD_VAR 0 2
8199: PPUSH
8200: LD_STRING D7a-FSol1-1a
8202: PPUSH
8203: CALL_OW 88
// end ; end ; end ; end ;
8207: PPOPN 2
8209: END
// every 0 0$1 trigger LastBattle = 1 and FilterUnitsInArea ( NorthBase , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 2 and FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_occupied ] ] ] ) = 0 do
8210: LD_EXP 27
8214: PUSH
8215: LD_INT 1
8217: EQUAL
8218: PUSH
8219: LD_INT 22
8221: PPUSH
8222: LD_INT 22
8224: PUSH
8225: LD_INT 3
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 21
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: EMPTY
8243: LIST
8244: LIST
8245: PPUSH
8246: CALL_OW 70
8250: PUSH
8251: LD_INT 2
8253: GREATER
8254: AND
8255: PUSH
8256: LD_INT 22
8258: PPUSH
8259: LD_INT 22
8261: PUSH
8262: LD_INT 1
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 2
8271: PUSH
8272: LD_INT 21
8274: PUSH
8275: LD_INT 1
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: PUSH
8282: LD_INT 59
8284: PUSH
8285: EMPTY
8286: LIST
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: LIST
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PPUSH
8297: CALL_OW 70
8301: PUSH
8302: LD_INT 0
8304: EQUAL
8305: AND
8306: IFFALSE 8321
8308: GO 8310
8310: DISABLE
// begin SetSide ( dep1 , 3 ) ;
8311: LD_INT 1
8313: PPUSH
8314: LD_INT 3
8316: PPUSH
8317: CALL_OW 235
// end ;
8321: END
// every 0 0$1 trigger tigersRespawn = 1 and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , 14 ] ] ) = 0 do var i , tmp ;
8322: LD_EXP 30
8326: PUSH
8327: LD_INT 1
8329: EQUAL
8330: PUSH
8331: LD_INT 22
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: EMPTY
8338: LIST
8339: LIST
8340: PUSH
8341: LD_INT 25
8343: PUSH
8344: LD_INT 14
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PPUSH
8355: CALL_OW 69
8359: PUSH
8360: LD_INT 0
8362: EQUAL
8363: AND
8364: IFFALSE 8465
8366: GO 8368
8368: DISABLE
8369: LD_INT 0
8371: PPUSH
8372: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) ;
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 21
8390: PUSH
8391: LD_INT 1
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 23
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: PPUSH
8413: CALL_OW 69
8417: ST_TO_ADDR
// for i in tmp do
8418: LD_ADDR_VAR 0 1
8422: PUSH
8423: LD_VAR 0 2
8427: PUSH
8428: FOR_IN
8429: IFFALSE 8456
// AddExperience ( i , rand ( 1 , 4 ) , 300 ) ;
8431: LD_VAR 0 1
8435: PPUSH
8436: LD_INT 1
8438: PPUSH
8439: LD_INT 4
8441: PPUSH
8442: CALL_OW 12
8446: PPUSH
8447: LD_INT 300
8449: PPUSH
8450: CALL_OW 492
8454: GO 8428
8456: POP
8457: POP
// SetAchievement ( ACH_TIGER ) ;
8458: LD_STRING ACH_TIGER
8460: PPUSH
8461: CALL_OW 543
// end ;
8465: PPOPN 2
8467: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] ] ) >= 2 do
8468: LD_INT 22
8470: PUSH
8471: LD_INT 1
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PUSH
8478: LD_INT 34
8480: PUSH
8481: LD_INT 51
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PPUSH
8492: CALL_OW 69
8496: PUSH
8497: LD_INT 2
8499: GREATEREQUAL
8500: IFFALSE 8512
8502: GO 8504
8504: DISABLE
// SetAchievement ( ACH_CARGO ) ; end_of_file
8505: LD_STRING ACH_CARGO
8507: PPUSH
8508: CALL_OW 543
8512: END
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
8513: LD_INT 0
8515: PPUSH
8516: PPUSH
8517: PPUSH
8518: PPUSH
// for i = 1 to count do
8519: LD_ADDR_VAR 0 8
8523: PUSH
8524: DOUBLE
8525: LD_INT 1
8527: DEC
8528: ST_TO_ADDR
8529: LD_VAR 0 6
8533: PUSH
8534: FOR_TO
8535: IFFALSE 8616
// begin uc_side = side ;
8537: LD_ADDR_OWVAR 20
8541: PUSH
8542: LD_VAR 0 1
8546: ST_TO_ADDR
// uc_nation = nation ;
8547: LD_ADDR_OWVAR 21
8551: PUSH
8552: LD_VAR 0 2
8556: ST_TO_ADDR
// hc_gallery =  ;
8557: LD_ADDR_OWVAR 33
8561: PUSH
8562: LD_STRING 
8564: ST_TO_ADDR
// hc_name =  ;
8565: LD_ADDR_OWVAR 26
8569: PUSH
8570: LD_STRING 
8572: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_VAR 0 5
8580: PPUSH
8581: LD_VAR 0 4
8585: PPUSH
8586: CALL_OW 380
// un = CreateHuman ;
8590: LD_ADDR_VAR 0 10
8594: PUSH
8595: CALL_OW 44
8599: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
8600: LD_VAR 0 10
8604: PPUSH
8605: LD_VAR 0 3
8609: PPUSH
8610: CALL_OW 52
// end ;
8614: GO 8534
8616: POP
8617: POP
// end ;
8618: LD_VAR 0 7
8622: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
8623: LD_INT 0
8625: PPUSH
8626: PPUSH
8627: PPUSH
// uc_side := GetSide ( b ) ;
8628: LD_ADDR_OWVAR 20
8632: PUSH
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 255
8642: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_VAR 0 2
8652: PPUSH
8653: CALL_OW 248
8657: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
8658: LD_INT 0
8660: PPUSH
8661: LD_INT 1
8663: PPUSH
8664: LD_VAR 0 1
8668: PPUSH
8669: CALL_OW 380
// un = CreateHuman ;
8673: LD_ADDR_VAR 0 4
8677: PUSH
8678: CALL_OW 44
8682: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 254
8697: PUSH
8698: LD_INT 3
8700: MINUS
8701: ST_TO_ADDR
// if dir < 0 then
8702: LD_VAR 0 5
8706: PUSH
8707: LD_INT 0
8709: LESS
8710: IFFALSE 8726
// dir := 6 + dir ;
8712: LD_ADDR_VAR 0 5
8716: PUSH
8717: LD_INT 6
8719: PUSH
8720: LD_VAR 0 5
8724: PLUS
8725: ST_TO_ADDR
// SetDir ( un , dir ) ;
8726: LD_VAR 0 4
8730: PPUSH
8731: LD_VAR 0 5
8735: PPUSH
8736: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_VAR 0 2
8749: PPUSH
8750: CALL_OW 52
// end ;
8754: LD_VAR 0 3
8758: RET
// export function RepairBuilding ( side , building , area ) ; var buildings_list , i , engineerOk_list , j ; begin
8759: LD_INT 0
8761: PPUSH
8762: PPUSH
8763: PPUSH
8764: PPUSH
8765: PPUSH
// engineerOk_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
8766: LD_ADDR_VAR 0 7
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_VAR 0 1
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PUSH
8783: LD_INT 25
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PUSH
8793: LD_INT 24
8795: PUSH
8796: LD_INT 1000
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: LIST
8807: PPUSH
8808: CALL_OW 69
8812: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( area , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
8813: LD_ADDR_VAR 0 5
8817: PUSH
8818: LD_VAR 0 3
8822: PPUSH
8823: LD_INT 22
8825: PUSH
8826: LD_VAR 0 1
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 21
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: LD_INT 3
8847: PUSH
8848: LD_INT 24
8850: PUSH
8851: LD_INT 1000
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: PPUSH
8870: CALL_OW 70
8874: ST_TO_ADDR
// if buildings_list > 0 and engineerOk_list > 0 then
8875: LD_VAR 0 5
8879: PUSH
8880: LD_INT 0
8882: GREATER
8883: PUSH
8884: LD_VAR 0 7
8888: PUSH
8889: LD_INT 0
8891: GREATER
8892: AND
8893: IFFALSE 8959
// begin for i in engineerOk_list do
8895: LD_ADDR_VAR 0 6
8899: PUSH
8900: LD_VAR 0 7
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8957
// begin for j in buildings_list do
8908: LD_ADDR_VAR 0 8
8912: PUSH
8913: LD_VAR 0 5
8917: PUSH
8918: FOR_IN
8919: IFFALSE 8953
// begin AddComExitBuilding ( i ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 182
// wait ( 0 0$1 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// AddComRepairBuilding ( i , j ) ;
8937: LD_VAR 0 6
8941: PPUSH
8942: LD_VAR 0 8
8946: PPUSH
8947: CALL_OW 190
// end ;
8951: GO 8918
8953: POP
8954: POP
// end ;
8955: GO 8905
8957: POP
8958: POP
// end ; if buildings_list = 0 then
8959: LD_VAR 0 5
8963: PUSH
8964: LD_INT 0
8966: EQUAL
8967: IFFALSE 9000
// begin for i in engineerOK_list do
8969: LD_ADDR_VAR 0 6
8973: PUSH
8974: LD_VAR 0 7
8978: PUSH
8979: FOR_IN
8980: IFFALSE 8998
// begin ComEnterUnit ( i , building ) ;
8982: LD_VAR 0 6
8986: PPUSH
8987: LD_VAR 0 2
8991: PPUSH
8992: CALL_OW 120
// end ;
8996: GO 8979
8998: POP
8999: POP
// end ; end ;
9000: LD_VAR 0 4
9004: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , i , j , damageUnits ; begin
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
9010: PPUSH
9011: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 250 ] ] ) ;
9012: LD_ADDR_VAR 0 6
9016: PUSH
9017: LD_INT 22
9019: PUSH
9020: LD_VAR 0 1
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: PUSH
9029: LD_INT 25
9031: PUSH
9032: LD_INT 4
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PUSH
9039: LD_INT 24
9041: PUSH
9042: LD_INT 250
9044: PUSH
9045: EMPTY
9046: LIST
9047: LIST
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: PPUSH
9054: CALL_OW 69
9058: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
9059: LD_ADDR_VAR 0 9
9063: PUSH
9064: LD_VAR 0 3
9068: PPUSH
9069: LD_INT 22
9071: PUSH
9072: LD_VAR 0 1
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PUSH
9081: LD_INT 21
9083: PUSH
9084: LD_INT 1
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: PUSH
9091: LD_INT 3
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: LD_INT 650
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: PPUSH
9113: CALL_OW 70
9117: ST_TO_ADDR
// if damageUnits > 0 and sci_list > 0 then
9118: LD_VAR 0 9
9122: PUSH
9123: LD_INT 0
9125: GREATER
9126: PUSH
9127: LD_VAR 0 6
9131: PUSH
9132: LD_INT 0
9134: GREATER
9135: AND
9136: IFFALSE 9263
// begin for i = 1 to damageUnits do
9138: LD_ADDR_VAR 0 7
9142: PUSH
9143: DOUBLE
9144: LD_INT 1
9146: DEC
9147: ST_TO_ADDR
9148: LD_VAR 0 9
9152: PUSH
9153: FOR_TO
9154: IFFALSE 9178
// ComMoveToArea ( damageUnits [ i ] , healArea ) ;
9156: LD_VAR 0 9
9160: PUSH
9161: LD_VAR 0 7
9165: ARRAY
9166: PPUSH
9167: LD_VAR 0 2
9171: PPUSH
9172: CALL_OW 113
9176: GO 9153
9178: POP
9179: POP
// for i in sci_list do
9180: LD_ADDR_VAR 0 7
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: FOR_IN
9191: IFFALSE 9259
// begin ComExitBuilding ( i ) ;
9193: LD_VAR 0 7
9197: PPUSH
9198: CALL_OW 122
// for j in FilterUnitsInArea ( healArea , [ f_side , side ] ) do
9202: LD_ADDR_VAR 0 8
9206: PUSH
9207: LD_VAR 0 2
9211: PPUSH
9212: LD_INT 22
9214: PUSH
9215: LD_VAR 0 1
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: PPUSH
9224: CALL_OW 70
9228: PUSH
9229: FOR_IN
9230: IFFALSE 9255
// begin AddComHeal ( i , j ) ;
9232: LD_VAR 0 7
9236: PPUSH
9237: LD_VAR 0 8
9241: PPUSH
9242: CALL_OW 188
// wait ( 1 1$0 ) ;
9246: LD_INT 2100
9248: PPUSH
9249: CALL_OW 67
// end ;
9253: GO 9229
9255: POP
9256: POP
// end ;
9257: GO 9190
9259: POP
9260: POP
// end else
9261: GO 9277
// begin AddComEnterUnit ( sci_list , build ) ;
9263: LD_VAR 0 6
9267: PPUSH
9268: LD_VAR 0 4
9272: PPUSH
9273: CALL_OW 180
// end ; end ;
9277: LD_VAR 0 5
9281: RET
// export function RepairVehicle ( side , repairArea , area ) ; var i , j , vehicleOK_list , damageVehicle_list , emptyVehicle_list , mechanicInside_list , mechanicOutside_list ; begin
9282: LD_INT 0
9284: PPUSH
9285: PPUSH
9286: PPUSH
9287: PPUSH
9288: PPUSH
9289: PPUSH
9290: PPUSH
9291: PPUSH
// vehicleOK_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 550 ] , [ f_weapon , 46 ] ] ) ;
9292: LD_ADDR_VAR 0 7
9296: PUSH
9297: LD_VAR 0 3
9301: PPUSH
9302: LD_INT 22
9304: PUSH
9305: LD_VAR 0 1
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 21
9316: PUSH
9317: LD_INT 2
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 24
9326: PUSH
9327: LD_INT 550
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 34
9336: PUSH
9337: LD_INT 46
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 70
9354: ST_TO_ADDR
// damageVehicle_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_not , [ f_lives , 550 ] ] ] ) ;
9355: LD_ADDR_VAR 0 8
9359: PUSH
9360: LD_VAR 0 3
9364: PPUSH
9365: LD_INT 22
9367: PUSH
9368: LD_VAR 0 1
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: LD_INT 34
9389: PUSH
9390: LD_INT 46
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: PUSH
9397: LD_INT 3
9399: PUSH
9400: LD_INT 24
9402: PUSH
9403: LD_INT 550
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 70
9424: ST_TO_ADDR
// emptyVehicle_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
9425: LD_ADDR_VAR 0 9
9429: PUSH
9430: LD_VAR 0 2
9434: PPUSH
9435: LD_INT 22
9437: PUSH
9438: LD_VAR 0 1
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: LD_INT 21
9449: PUSH
9450: LD_INT 2
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: PUSH
9457: LD_INT 34
9459: PUSH
9460: LD_INT 46
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PUSH
9467: LD_INT 24
9469: PUSH
9470: LD_INT 1000
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 58
9479: PUSH
9480: EMPTY
9481: LIST
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: PPUSH
9490: CALL_OW 70
9494: ST_TO_ADDR
// for i in damageVehicle_list do
9495: LD_ADDR_VAR 0 5
9499: PUSH
9500: LD_VAR 0 8
9504: PUSH
9505: FOR_IN
9506: IFFALSE 9525
// mechanicInside_list = UnitsInside ( i ) ;
9508: LD_ADDR_VAR 0 10
9512: PUSH
9513: LD_VAR 0 5
9517: PPUSH
9518: CALL_OW 313
9522: ST_TO_ADDR
9523: GO 9505
9525: POP
9526: POP
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
9527: LD_ADDR_VAR 0 11
9531: PUSH
9532: LD_VAR 0 2
9536: PPUSH
9537: LD_INT 22
9539: PUSH
9540: LD_VAR 0 1
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 25
9551: PUSH
9552: LD_INT 3
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PPUSH
9563: CALL_OW 70
9567: ST_TO_ADDR
// if damageVehicle_list > 0 then
9568: LD_VAR 0 8
9572: PUSH
9573: LD_INT 0
9575: GREATER
9576: IFFALSE 9649
// begin for i in damageVehicle_list do
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_VAR 0 8
9587: PUSH
9588: FOR_IN
9589: IFFALSE 9647
// begin for j in mechanicInside_list do
9591: LD_ADDR_VAR 0 6
9595: PUSH
9596: LD_VAR 0 10
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9643
// begin ComMoveToArea ( damageVehicle_list , repairArea ) ;
9604: LD_VAR 0 8
9608: PPUSH
9609: LD_VAR 0 2
9613: PPUSH
9614: CALL_OW 113
// AddComExitVehicle ( j ) ;
9618: LD_VAR 0 6
9622: PPUSH
9623: CALL_OW 181
// AddComRepairVehicle ( j , i ) ;
9627: LD_VAR 0 6
9631: PPUSH
9632: LD_VAR 0 5
9636: PPUSH
9637: CALL_OW 189
// end ;
9641: GO 9601
9643: POP
9644: POP
// end ;
9645: GO 9588
9647: POP
9648: POP
// end ; if emptyVehicle_list > 0 then
9649: LD_VAR 0 9
9653: PUSH
9654: LD_INT 0
9656: GREATER
9657: IFFALSE 9707
// begin for i in emptyVehicle_list do
9659: LD_ADDR_VAR 0 5
9663: PUSH
9664: LD_VAR 0 9
9668: PUSH
9669: FOR_IN
9670: IFFALSE 9705
// begin for j in mechanicOutside_list do
9672: LD_ADDR_VAR 0 6
9676: PUSH
9677: LD_VAR 0 11
9681: PUSH
9682: FOR_IN
9683: IFFALSE 9701
// begin AddComEnterUnit ( j , i ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: CALL_OW 180
// end ;
9699: GO 9682
9701: POP
9702: POP
// end ;
9703: GO 9669
9705: POP
9706: POP
// end ; if VehicleOK_list > 0 then
9707: LD_VAR 0 7
9711: PUSH
9712: LD_INT 0
9714: GREATER
9715: IFFALSE 9749
// begin for i in VehicleOK_list do
9717: LD_ADDR_VAR 0 5
9721: PUSH
9722: LD_VAR 0 7
9726: PUSH
9727: FOR_IN
9728: IFFALSE 9747
// ComAgressiveMove ( i , 110 , 29 ) ;
9730: LD_VAR 0 5
9734: PPUSH
9735: LD_INT 110
9737: PPUSH
9738: LD_INT 29
9740: PPUSH
9741: CALL_OW 114
9745: GO 9727
9747: POP
9748: POP
// end ; end ;
9749: LD_VAR 0 4
9753: RET
// export function DefendBases ( area , enemySide , defendersList , build , count ) ; var i , j ; begin
9754: LD_INT 0
9756: PPUSH
9757: PPUSH
9758: PPUSH
// if FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) > count then
9759: LD_VAR 0 1
9763: PPUSH
9764: LD_INT 22
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 2
9778: PUSH
9779: LD_INT 21
9781: PUSH
9782: LD_INT 2
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PUSH
9789: LD_INT 21
9791: PUSH
9792: LD_INT 1
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 70
9812: PUSH
9813: LD_VAR 0 5
9817: GREATER
9818: IFFALSE 9950
// begin for i in defendersList do
9820: LD_ADDR_VAR 0 7
9824: PUSH
9825: LD_VAR 0 3
9829: PUSH
9830: FOR_IN
9831: IFFALSE 9946
// begin AddComExitBuilding ( i ) ;
9833: LD_VAR 0 7
9837: PPUSH
9838: CALL_OW 182
// wait ( 0 0$1 ) ;
9842: LD_INT 35
9844: PPUSH
9845: CALL_OW 67
// for j in FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) do
9849: LD_ADDR_VAR 0 8
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: LD_INT 22
9861: PUSH
9862: LD_VAR 0 2
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 2
9873: PUSH
9874: LD_INT 21
9876: PUSH
9877: LD_INT 2
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PUSH
9884: LD_INT 21
9886: PUSH
9887: LD_INT 1
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 70
9907: PUSH
9908: FOR_IN
9909: IFFALSE 9942
// AddComAgressiveMove ( i , GetX ( j ) , GetY ( j ) ) ;
9911: LD_VAR 0 7
9915: PPUSH
9916: LD_VAR 0 8
9920: PPUSH
9921: CALL_OW 250
9925: PPUSH
9926: LD_VAR 0 8
9930: PPUSH
9931: CALL_OW 251
9935: PPUSH
9936: CALL_OW 174
9940: GO 9908
9942: POP
9943: POP
// end ;
9944: GO 9830
9946: POP
9947: POP
// end else
9948: GO 9981
// begin for i in defendersList do
9950: LD_ADDR_VAR 0 7
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 9979
// ComEnterUnit ( i , build ) ;
9963: LD_VAR 0 7
9967: PPUSH
9968: LD_VAR 0 4
9972: PPUSH
9973: CALL_OW 120
9977: GO 9960
9979: POP
9980: POP
// end ; end ;
9981: LD_VAR 0 6
9985: RET
// export function RussianTrap ; var i ; begin
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
// if GetSide ( Brian ) = 4 then
9990: LD_EXP 6
9994: PPUSH
9995: CALL_OW 255
9999: PUSH
10000: LD_INT 4
10002: EQUAL
10003: IFFALSE 10026
// SetLives ( [ Brian , Jerry ] , 0 ) ;
10005: LD_EXP 6
10009: PUSH
10010: LD_EXP 7
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PPUSH
10019: LD_INT 0
10021: PPUSH
10022: CALL_OW 234
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
10026: LD_ADDR_VAR 0 2
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 21
10043: PUSH
10044: LD_INT 1
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: PUSH
10060: FOR_IN
10061: IFFALSE 10171
// begin ComExitBuilding ( i ) ;
10063: LD_VAR 0 2
10067: PPUSH
10068: CALL_OW 122
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: CALL_OW 67
// AddComAgressiveMove ( i , 120 , 56 ) ;
10079: LD_VAR 0 2
10083: PPUSH
10084: LD_INT 120
10086: PPUSH
10087: LD_INT 56
10089: PPUSH
10090: CALL_OW 174
// AddComAgressiveMove ( i , 111 , 37 ) ;
10094: LD_VAR 0 2
10098: PPUSH
10099: LD_INT 111
10101: PPUSH
10102: LD_INT 37
10104: PPUSH
10105: CALL_OW 174
// if GetSide ( arm2 ) = 3 and IsOk ( arm2 ) then
10109: LD_INT 33
10111: PPUSH
10112: CALL_OW 255
10116: PUSH
10117: LD_INT 3
10119: EQUAL
10120: PUSH
10121: LD_INT 33
10123: PPUSH
10124: CALL_OW 302
10128: AND
10129: IFFALSE 10145
// begin AddComEnterUnit ( i , arm2 ) ;
10131: LD_VAR 0 2
10135: PPUSH
10136: LD_INT 33
10138: PPUSH
10139: CALL_OW 180
// end else
10143: GO 10169
// begin AddComCrawl ( i ) ;
10145: LD_VAR 0 2
10149: PPUSH
10150: CALL_OW 197
// AddComAgressiveMove ( i , 109 , 30 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 109
10161: PPUSH
10162: LD_INT 30
10164: PPUSH
10165: CALL_OW 174
// end ; end ;
10169: GO 10060
10171: POP
10172: POP
// end ;
10173: LD_VAR 0 1
10177: RET
// export function Nearest ( un , units ) ; var nearest_dist , nearest_un , sold , dist ; begin
10178: LD_INT 0
10180: PPUSH
10181: PPUSH
10182: PPUSH
10183: PPUSH
10184: PPUSH
// nearest_dist = 1000 ;
10185: LD_ADDR_VAR 0 4
10189: PUSH
10190: LD_INT 1000
10192: ST_TO_ADDR
// nearest_un = un ;
10193: LD_ADDR_VAR 0 5
10197: PUSH
10198: LD_VAR 0 1
10202: ST_TO_ADDR
// for sold in units do
10203: LD_ADDR_VAR 0 6
10207: PUSH
10208: LD_VAR 0 2
10212: PUSH
10213: FOR_IN
10214: IFFALSE 10270
// begin dist = GetDistUnits ( un , sold ) ;
10216: LD_ADDR_VAR 0 7
10220: PUSH
10221: LD_VAR 0 1
10225: PPUSH
10226: LD_VAR 0 6
10230: PPUSH
10231: CALL_OW 296
10235: ST_TO_ADDR
// if dist < nearest_dist then
10236: LD_VAR 0 7
10240: PUSH
10241: LD_VAR 0 4
10245: LESS
10246: IFFALSE 10268
// begin nearest_un = sold ;
10248: LD_ADDR_VAR 0 5
10252: PUSH
10253: LD_VAR 0 6
10257: ST_TO_ADDR
// nearest_dist = dist ;
10258: LD_ADDR_VAR 0 4
10262: PUSH
10263: LD_VAR 0 7
10267: ST_TO_ADDR
// end ; end ;
10268: GO 10213
10270: POP
10271: POP
// result := nearest_un ;
10272: LD_ADDR_VAR 0 3
10276: PUSH
10277: LD_VAR 0 5
10281: ST_TO_ADDR
// end ;
10282: LD_VAR 0 3
10286: RET
// export function PrepareDifficulty ; begin
10287: LD_INT 0
10289: PPUSH
// if Difficulty = 1 then
10290: LD_OWVAR 67
10294: PUSH
10295: LD_INT 1
10297: EQUAL
10298: IFFALSE 10361
// begin RemoveUnit ( brw2 ) ;
10300: LD_INT 9
10302: PPUSH
10303: CALL_OW 64
// RemoveUnit ( brw3 ) ;
10307: LD_INT 30
10309: PPUSH
10310: CALL_OW 64
// RemoveUnit ( brw4 ) ;
10314: LD_INT 52
10316: PPUSH
10317: CALL_OW 64
// RemoveUnit ( brw5 ) ;
10321: LD_INT 63
10323: PPUSH
10324: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 60 ) ;
10328: LD_INT 5
10330: PUSH
10331: LD_INT 4
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PPUSH
10338: LD_INT 60
10340: PPUSH
10341: CALL_OW 240
// RuSoldMinLevel = 0 ;
10345: LD_ADDR_EXP 13
10349: PUSH
10350: LD_INT 0
10352: ST_TO_ADDR
// RuSoldMaxLevel = 1 ;
10353: LD_ADDR_EXP 14
10357: PUSH
10358: LD_INT 1
10360: ST_TO_ADDR
// end ; if Difficulty = 2 then
10361: LD_OWVAR 67
10365: PUSH
10366: LD_INT 2
10368: EQUAL
10369: IFFALSE 10411
// begin RemoveUnit ( brw4 ) ;
10371: LD_INT 52
10373: PPUSH
10374: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 50 ) ;
10378: LD_INT 5
10380: PUSH
10381: LD_INT 4
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: PPUSH
10388: LD_INT 50
10390: PPUSH
10391: CALL_OW 240
// RuSoldMinLevel = 1 ;
10395: LD_ADDR_EXP 13
10399: PUSH
10400: LD_INT 1
10402: ST_TO_ADDR
// RuSoldMaxLevel = 2 ;
10403: LD_ADDR_EXP 14
10407: PUSH
10408: LD_INT 2
10410: ST_TO_ADDR
// end ; if Difficulty = 3 then
10411: LD_OWVAR 67
10415: PUSH
10416: LD_INT 3
10418: EQUAL
10419: IFFALSE 10454
// begin SetFuel ( [ vehicle1 , vehicle2 ] , 40 ) ;
10421: LD_INT 5
10423: PUSH
10424: LD_INT 4
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: PPUSH
10431: LD_INT 40
10433: PPUSH
10434: CALL_OW 240
// RuSoldMinLevel = 2 ;
10438: LD_ADDR_EXP 13
10442: PUSH
10443: LD_INT 2
10445: ST_TO_ADDR
// RuSoldMaxLevel = 3 ;
10446: LD_ADDR_EXP 14
10450: PUSH
10451: LD_INT 3
10453: ST_TO_ADDR
// end ; end ;
10454: LD_VAR 0 1
10458: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
10459: LD_INT 0
10461: PPUSH
10462: PPUSH
10463: PPUSH
// tmp = [ ] ;
10464: LD_ADDR_VAR 0 5
10468: PUSH
10469: EMPTY
10470: ST_TO_ADDR
// if not vehicles then
10471: LD_VAR 0 1
10475: NOT
10476: IFFALSE 10480
// exit ;
10478: GO 10597
// for i in vehicles do
10480: LD_ADDR_VAR 0 4
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: FOR_IN
10491: IFFALSE 10581
// begin tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
10493: LD_ADDR_VAR 0 5
10497: PUSH
10498: LD_VAR 0 5
10502: PPUSH
10503: LD_INT 1
10505: PPUSH
10506: LD_VAR 0 4
10510: PPUSH
10511: CALL_OW 265
10515: PUSH
10516: LD_VAR 0 4
10520: PPUSH
10521: CALL_OW 262
10525: PUSH
10526: LD_VAR 0 4
10530: PPUSH
10531: CALL_OW 263
10535: PUSH
10536: LD_VAR 0 4
10540: PPUSH
10541: CALL_OW 264
10545: PUSH
10546: LD_VAR 0 4
10550: PPUSH
10551: CALL_OW 261
10555: PUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL_OW 256
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PPUSH
10574: CALL_OW 2
10578: ST_TO_ADDR
// end ;
10579: GO 10490
10581: POP
10582: POP
// SaveVariable ( tmp , ident ) ;
10583: LD_VAR 0 5
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 39
// end ; end_of_file
10597: LD_VAR 0 3
10601: RET
// export function PrepareHeroes ; var plive ; begin
10602: LD_INT 0
10604: PPUSH
10605: PPUSH
// uc_side = 1 ;
10606: LD_ADDR_OWVAR 20
10610: PUSH
10611: LD_INT 1
10613: ST_TO_ADDR
// JMM = CreateCharacter ( 01_JMM ) ;
10614: LD_ADDR_EXP 1
10618: PUSH
10619: LD_STRING 01_JMM
10621: PPUSH
10622: CALL_OW 34
10626: ST_TO_ADDR
// plive := LoadVariable ( 01_JMMLifePoints_1 , 1000 ) ;
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_STRING 01_JMMLifePoints_1
10634: PPUSH
10635: LD_INT 1000
10637: PPUSH
10638: CALL_OW 30
10642: ST_TO_ADDR
// if plive < 250 then
10643: LD_VAR 0 2
10647: PUSH
10648: LD_INT 250
10650: LESS
10651: IFFALSE 10661
// plive := 300 ;
10653: LD_ADDR_VAR 0 2
10657: PUSH
10658: LD_INT 300
10660: ST_TO_ADDR
// SetLives ( JMM , plive ) ;
10661: LD_EXP 1
10665: PPUSH
10666: LD_VAR 0 2
10670: PPUSH
10671: CALL_OW 234
// Powell = NewCharacter ( Powell ) ;
10675: LD_ADDR_EXP 9
10679: PUSH
10680: LD_STRING Powell
10682: PPUSH
10683: CALL_OW 25
10687: ST_TO_ADDR
// Bobby = CreateCharacter ( 01_Bobby ) ;
10688: LD_ADDR_EXP 2
10692: PUSH
10693: LD_STRING 01_Bobby
10695: PPUSH
10696: CALL_OW 34
10700: ST_TO_ADDR
// if Bobby then
10701: LD_EXP 2
10705: IFFALSE 10755
// begin plive := LoadVariable ( 01_BobbyLifePoints_1 , 1000 ) ;
10707: LD_ADDR_VAR 0 2
10711: PUSH
10712: LD_STRING 01_BobbyLifePoints_1
10714: PPUSH
10715: LD_INT 1000
10717: PPUSH
10718: CALL_OW 30
10722: ST_TO_ADDR
// if plive < 250 then
10723: LD_VAR 0 2
10727: PUSH
10728: LD_INT 250
10730: LESS
10731: IFFALSE 10741
// plive := 300 ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 300
10740: ST_TO_ADDR
// SetLives ( Bobby , plive ) ;
10741: LD_EXP 2
10745: PPUSH
10746: LD_VAR 0 2
10750: PPUSH
10751: CALL_OW 234
// end ; Cyrus = CreateCharacter ( 01_Cyrus ) ;
10755: LD_ADDR_EXP 3
10759: PUSH
10760: LD_STRING 01_Cyrus
10762: PPUSH
10763: CALL_OW 34
10767: ST_TO_ADDR
// if Cyrus then
10768: LD_EXP 3
10772: IFFALSE 10822
// begin plive := LoadVariable ( 01_CyrusLifePoints_1 , 1000 ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_STRING 01_CyrusLifePoints_1
10781: PPUSH
10782: LD_INT 1000
10784: PPUSH
10785: CALL_OW 30
10789: ST_TO_ADDR
// if plive < 250 then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_INT 250
10797: LESS
10798: IFFALSE 10808
// plive := 300 ;
10800: LD_ADDR_VAR 0 2
10804: PUSH
10805: LD_INT 300
10807: ST_TO_ADDR
// SetLives ( Cyrus , plive ) ;
10808: LD_EXP 3
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 234
// end ; Khatam = NewCharacter ( Khatam ) ;
10822: LD_ADDR_EXP 5
10826: PUSH
10827: LD_STRING Khatam
10829: PPUSH
10830: CALL_OW 25
10834: ST_TO_ADDR
// uc_side = 4 ;
10835: LD_ADDR_OWVAR 20
10839: PUSH
10840: LD_INT 4
10842: ST_TO_ADDR
// Lisa = NewCharacter ( Lisa ) ;
10843: LD_ADDR_EXP 4
10847: PUSH
10848: LD_STRING Lisa
10850: PPUSH
10851: CALL_OW 25
10855: ST_TO_ADDR
// PlaceUnitArea ( JMM , StartArea , false ) ;
10856: LD_EXP 1
10860: PPUSH
10861: LD_INT 3
10863: PPUSH
10864: LD_INT 0
10866: PPUSH
10867: CALL_OW 49
// PlaceUnitArea ( Bobby , StartArea , false ) ;
10871: LD_EXP 2
10875: PPUSH
10876: LD_INT 3
10878: PPUSH
10879: LD_INT 0
10881: PPUSH
10882: CALL_OW 49
// PlaceUnitArea ( Cyrus , StartArea , false ) ;
10886: LD_EXP 3
10890: PPUSH
10891: LD_INT 3
10893: PPUSH
10894: LD_INT 0
10896: PPUSH
10897: CALL_OW 49
// PlaceUnitArea ( Lisa , LisaSpawn , false ) ;
10901: LD_EXP 4
10905: PPUSH
10906: LD_INT 5
10908: PPUSH
10909: LD_INT 0
10911: PPUSH
10912: CALL_OW 49
// ComCrawl ( Lisa ) ;
10916: LD_EXP 4
10920: PPUSH
10921: CALL_OW 137
// end ;
10925: LD_VAR 0 1
10929: RET
// export function PrepareLisSquad ; var i , un ; begin
10930: LD_INT 0
10932: PPUSH
10933: PPUSH
10934: PPUSH
// uc_side = 4 ;
10935: LD_ADDR_OWVAR 20
10939: PUSH
10940: LD_INT 4
10942: ST_TO_ADDR
// uc_nation = 1 ;
10943: LD_ADDR_OWVAR 21
10947: PUSH
10948: LD_INT 1
10950: ST_TO_ADDR
// hc_class := 2 ;
10951: LD_ADDR_OWVAR 28
10955: PUSH
10956: LD_INT 2
10958: ST_TO_ADDR
// hc_sex := sex_male ;
10959: LD_ADDR_OWVAR 27
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// hc_gallery :=  ;
10967: LD_ADDR_OWVAR 33
10971: PUSH
10972: LD_STRING 
10974: ST_TO_ADDR
// hc_name :=  ;
10975: LD_ADDR_OWVAR 26
10979: PUSH
10980: LD_STRING 
10982: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 0 , 0 ] ;
10983: LD_ADDR_OWVAR 30
10987: PUSH
10988: LD_INT 0
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: LD_INT 0
10996: PUSH
10997: LD_INT 0
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: ST_TO_ADDR
// hc_skills := [ 1 , 2 , 0 , 0 ] ;
11006: LD_ADDR_OWVAR 31
11010: PUSH
11011: LD_INT 1
11013: PUSH
11014: LD_INT 2
11016: PUSH
11017: LD_INT 0
11019: PUSH
11020: LD_INT 0
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: ST_TO_ADDR
// un := CreateHuman ;
11029: LD_ADDR_VAR 0 3
11033: PUSH
11034: CALL_OW 44
11038: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11039: LD_VAR 0 3
11043: PPUSH
11044: LD_INT 6
11046: PPUSH
11047: LD_INT 0
11049: PPUSH
11050: CALL_OW 49
// hc_sex := sex_female ;
11054: LD_ADDR_OWVAR 27
11058: PUSH
11059: LD_INT 2
11061: ST_TO_ADDR
// hc_gallery :=  ;
11062: LD_ADDR_OWVAR 33
11066: PUSH
11067: LD_STRING 
11069: ST_TO_ADDR
// hc_name :=  ;
11070: LD_ADDR_OWVAR 26
11074: PUSH
11075: LD_STRING 
11077: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 1 ] ;
11078: LD_ADDR_OWVAR 30
11082: PUSH
11083: LD_INT 0
11085: PUSH
11086: LD_INT 0
11088: PUSH
11089: LD_INT 0
11091: PUSH
11092: LD_INT 1
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: ST_TO_ADDR
// hc_skills := [ 0 , 1 , 0 , 1 ] ;
11101: LD_ADDR_OWVAR 31
11105: PUSH
11106: LD_INT 0
11108: PUSH
11109: LD_INT 1
11111: PUSH
11112: LD_INT 0
11114: PUSH
11115: LD_INT 1
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: ST_TO_ADDR
// un := CreateHuman ;
11124: LD_ADDR_VAR 0 3
11128: PUSH
11129: CALL_OW 44
11133: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11134: LD_VAR 0 3
11138: PPUSH
11139: LD_INT 6
11141: PPUSH
11142: LD_INT 0
11144: PPUSH
11145: CALL_OW 49
// if not Bobby and not Cyrus then
11149: LD_EXP 2
11153: NOT
11154: PUSH
11155: LD_EXP 3
11159: NOT
11160: AND
11161: IFFALSE 11266
// begin hc_class := 1 ;
11163: LD_ADDR_OWVAR 28
11167: PUSH
11168: LD_INT 1
11170: ST_TO_ADDR
// hc_sex := sex_male ;
11171: LD_ADDR_OWVAR 27
11175: PUSH
11176: LD_INT 1
11178: ST_TO_ADDR
// hc_gallery :=  ;
11179: LD_ADDR_OWVAR 33
11183: PUSH
11184: LD_STRING 
11186: ST_TO_ADDR
// hc_name :=  ;
11187: LD_ADDR_OWVAR 26
11191: PUSH
11192: LD_STRING 
11194: ST_TO_ADDR
// hc_basic_skills := [ 2 , 3 , 1 , 0 ] ;
11195: LD_ADDR_OWVAR 30
11199: PUSH
11200: LD_INT 2
11202: PUSH
11203: LD_INT 3
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: LD_INT 0
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: ST_TO_ADDR
// hc_skills := [ 2 , 3 , 1 , 0 ] ;
11218: LD_ADDR_OWVAR 31
11222: PUSH
11223: LD_INT 2
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 1
11231: PUSH
11232: LD_INT 0
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: ST_TO_ADDR
// un := CreateHuman ;
11241: LD_ADDR_VAR 0 3
11245: PUSH
11246: CALL_OW 44
11250: ST_TO_ADDR
// PlaceUnitArea ( un , AmNewSpawn , false ) ;
11251: LD_VAR 0 3
11255: PPUSH
11256: LD_INT 31
11258: PPUSH
11259: LD_INT 0
11261: PPUSH
11262: CALL_OW 49
// end ; InitHc ;
11266: CALL_OW 19
// end ;
11270: LD_VAR 0 1
11274: RET
// export function PrepareOtherAmericans ; begin
11275: LD_INT 0
11277: PPUSH
// uc_side = 4 ;
11278: LD_ADDR_OWVAR 20
11282: PUSH
11283: LD_INT 4
11285: ST_TO_ADDR
// uc_nation = 1 ;
11286: LD_ADDR_OWVAR 21
11290: PUSH
11291: LD_INT 1
11293: ST_TO_ADDR
// hc_gallery =  ;
11294: LD_ADDR_OWVAR 33
11298: PUSH
11299: LD_STRING 
11301: ST_TO_ADDR
// hc_name = Tom Garvin ;
11302: LD_ADDR_OWVAR 26
11306: PUSH
11307: LD_STRING Tom Garvin
11309: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( 1 , 2 ) ) ;
11310: LD_INT 1
11312: PPUSH
11313: LD_INT 1
11315: PPUSH
11316: LD_INT 1
11318: PPUSH
11319: LD_INT 2
11321: PPUSH
11322: CALL_OW 12
11326: PPUSH
11327: CALL_OW 380
// Brian = CreateHuman ;
11331: LD_ADDR_EXP 6
11335: PUSH
11336: CALL_OW 44
11340: ST_TO_ADDR
// PlaceUnitArea ( Brian , OtherAmericanSpawn , false ) ;
11341: LD_EXP 6
11345: PPUSH
11346: LD_INT 10
11348: PPUSH
11349: LD_INT 0
11351: PPUSH
11352: CALL_OW 49
// hc_name = Jerry White ;
11356: LD_ADDR_OWVAR 26
11360: PUSH
11361: LD_STRING Jerry White
11363: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
11364: LD_INT 1
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 1
11372: PPUSH
11373: LD_INT 2
11375: PPUSH
11376: CALL_OW 12
11380: PPUSH
11381: CALL_OW 380
// Jerry = CreateHuman ;
11385: LD_ADDR_EXP 7
11389: PUSH
11390: CALL_OW 44
11394: ST_TO_ADDR
// PlaceUnitArea ( Jerry , OtherAmericanSpawn , false ) ;
11395: LD_EXP 7
11399: PPUSH
11400: LD_INT 10
11402: PPUSH
11403: LD_INT 0
11405: PPUSH
11406: CALL_OW 49
// ComHold ( [ Brian , Jerry ] ) ;
11410: LD_EXP 6
11414: PUSH
11415: LD_EXP 7
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PPUSH
11424: CALL_OW 140
// end ;
11428: LD_VAR 0 1
11432: RET
// export DyingSold ; export function PrepareDeadSoldiers ; var i , un ; begin
11433: LD_INT 0
11435: PPUSH
11436: PPUSH
11437: PPUSH
// for i = 1 to 6 do
11438: LD_ADDR_VAR 0 2
11442: PUSH
11443: DOUBLE
11444: LD_INT 1
11446: DEC
11447: ST_TO_ADDR
11448: LD_INT 6
11450: PUSH
11451: FOR_TO
11452: IFFALSE 11546
// begin uc_side = 4 ;
11454: LD_ADDR_OWVAR 20
11458: PUSH
11459: LD_INT 4
11461: ST_TO_ADDR
// uc_nation = 1 ;
11462: LD_ADDR_OWVAR 21
11466: PUSH
11467: LD_INT 1
11469: ST_TO_ADDR
// hc_gallery =  ;
11470: LD_ADDR_OWVAR 33
11474: PUSH
11475: LD_STRING 
11477: ST_TO_ADDR
// hc_name =  ;
11478: LD_ADDR_OWVAR 26
11482: PUSH
11483: LD_STRING 
11485: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 1 ) ;
11486: LD_INT 0
11488: PPUSH
11489: LD_INT 1
11491: PPUSH
11492: LD_INT 4
11494: PPUSH
11495: CALL_OW 12
11499: PPUSH
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 380
// un = CreateHuman ;
11507: LD_ADDR_VAR 0 3
11511: PUSH
11512: CALL_OW 44
11516: ST_TO_ADDR
// PlaceUnitArea ( un , DeadsSpawn , false ) ;
11517: LD_VAR 0 3
11521: PPUSH
11522: LD_INT 16
11524: PPUSH
11525: LD_INT 0
11527: PPUSH
11528: CALL_OW 49
// SetLives ( un , 1 ) ;
11532: LD_VAR 0 3
11536: PPUSH
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 234
// end ;
11544: GO 11451
11546: POP
11547: POP
// DyingSold = CreateHuman ;
11548: LD_ADDR_EXP 34
11552: PUSH
11553: CALL_OW 44
11557: ST_TO_ADDR
// PlaceUnitArea ( DyingSold , DeadsSpawn , false ) ;
11558: LD_EXP 34
11562: PPUSH
11563: LD_INT 16
11565: PPUSH
11566: LD_INT 0
11568: PPUSH
11569: CALL_OW 49
// SetLives ( DyingSold , 250 ) ;
11573: LD_EXP 34
11577: PPUSH
11578: LD_INT 250
11580: PPUSH
11581: CALL_OW 234
// end ; end_of_file
11585: LD_VAR 0 1
11589: RET
// export function PrepareRussianHeroes ; var tmp ; begin
11590: LD_INT 0
11592: PPUSH
11593: PPUSH
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM ] ;
11594: LD_ADDR_VAR 0 2
11598: PUSH
11599: LD_INT 22
11601: PUSH
11602: LD_INT 1
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 23
11611: PUSH
11612: LD_INT 1
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 25
11621: PUSH
11622: LD_INT 2
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 50
11631: PUSH
11632: EMPTY
11633: LIST
11634: PUSH
11635: LD_INT 56
11637: PUSH
11638: EMPTY
11639: LIST
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: PPUSH
11648: CALL_OW 69
11652: PUSH
11653: LD_EXP 1
11657: PUSH
11658: EMPTY
11659: LIST
11660: DIFF
11661: ST_TO_ADDR
// uc_side = 6 ;
11662: LD_ADDR_OWVAR 20
11666: PUSH
11667: LD_INT 6
11669: ST_TO_ADDR
// Mikhail = NewCharacter ( Mikhail ) ;
11670: LD_ADDR_EXP 8
11674: PUSH
11675: LD_STRING Mikhail
11677: PPUSH
11678: CALL_OW 25
11682: ST_TO_ADDR
// SetClass ( Mikhail , 3 ) ;
11683: LD_EXP 8
11687: PPUSH
11688: LD_INT 3
11690: PPUSH
11691: CALL_OW 336
// PlaceUnitXYR ( Mikhail , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 5 , true ) ;
11695: LD_EXP 8
11699: PPUSH
11700: LD_VAR 0 2
11704: PUSH
11705: LD_INT 1
11707: ARRAY
11708: PPUSH
11709: CALL_OW 250
11713: PPUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_INT 1
11721: ARRAY
11722: PPUSH
11723: CALL_OW 251
11727: PPUSH
11728: LD_INT 5
11730: PPUSH
11731: LD_INT 1
11733: PPUSH
11734: CALL_OW 50
// end ;
11738: LD_VAR 0 1
11742: RET
// export function PrepareRussianCommander ; begin
11743: LD_INT 0
11745: PPUSH
// uc_side = 3 ;
11746: LD_ADDR_OWVAR 20
11750: PUSH
11751: LD_INT 3
11753: ST_TO_ADDR
// uc_nation = 3 ;
11754: LD_ADDR_OWVAR 21
11758: PUSH
11759: LD_INT 3
11761: ST_TO_ADDR
// Natasza = NewCharacter ( Natasza ) ;
11762: LD_ADDR_EXP 19
11766: PUSH
11767: LD_STRING Natasza
11769: PPUSH
11770: CALL_OW 25
11774: ST_TO_ADDR
// PlaceUnitArea ( Natasza , NataszaSpawn , false ) ;
11775: LD_EXP 19
11779: PPUSH
11780: LD_INT 24
11782: PPUSH
11783: LD_INT 0
11785: PPUSH
11786: CALL_OW 49
// ComTurnXY ( Natasza , 56 , 16 ) ;
11790: LD_EXP 19
11794: PPUSH
11795: LD_INT 56
11797: PPUSH
11798: LD_INT 16
11800: PPUSH
11801: CALL_OW 118
// northBaseDefenders = northBaseDefenders ^ Natasza ;
11805: LD_ADDR_EXP 24
11809: PUSH
11810: LD_EXP 24
11814: PUSH
11815: LD_EXP 19
11819: ADD
11820: ST_TO_ADDR
// end ;
11821: LD_VAR 0 1
11825: RET
// export function PrepareSouthBase ; var i , un ; begin
11826: LD_INT 0
11828: PPUSH
11829: PPUSH
11830: PPUSH
// for i = 1 to 2 do
11831: LD_ADDR_VAR 0 2
11835: PUSH
11836: DOUBLE
11837: LD_INT 1
11839: DEC
11840: ST_TO_ADDR
11841: LD_INT 2
11843: PUSH
11844: FOR_TO
11845: IFFALSE 11954
// begin uc_side = 3 ;
11847: LD_ADDR_OWVAR 20
11851: PUSH
11852: LD_INT 3
11854: ST_TO_ADDR
// uc_nation = 3 ;
11855: LD_ADDR_OWVAR 21
11859: PUSH
11860: LD_INT 3
11862: ST_TO_ADDR
// hc_gallery =  ;
11863: LD_ADDR_OWVAR 33
11867: PUSH
11868: LD_STRING 
11870: ST_TO_ADDR
// hc_name =  ;
11871: LD_ADDR_OWVAR 26
11875: PUSH
11876: LD_STRING 
11878: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
11879: LD_INT 1
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: LD_EXP 13
11889: PPUSH
11890: LD_EXP 14
11894: PPUSH
11895: CALL_OW 12
11899: PPUSH
11900: CALL_OW 380
// hc_importance = 0 ;
11904: LD_ADDR_OWVAR 32
11908: PUSH
11909: LD_INT 0
11911: ST_TO_ADDR
// un = CreateHuman ;
11912: LD_ADDR_VAR 0 3
11916: PUSH
11917: CALL_OW 44
11921: ST_TO_ADDR
// PlaceUnitArea ( un , SouthBaseRussianSpawn1 , false ) ;
11922: LD_VAR 0 3
11926: PPUSH
11927: LD_INT 11
11929: PPUSH
11930: LD_INT 0
11932: PPUSH
11933: CALL_OW 49
// ComTurnXY ( un , 111 , 38 ) ;
11937: LD_VAR 0 3
11941: PPUSH
11942: LD_INT 111
11944: PPUSH
11945: LD_INT 38
11947: PPUSH
11948: CALL_OW 118
// end ;
11952: GO 11844
11954: POP
11955: POP
// for i = 1 to Difficulty do
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: DOUBLE
11962: LD_INT 1
11964: DEC
11965: ST_TO_ADDR
11966: LD_OWVAR 67
11970: PUSH
11971: FOR_TO
11972: IFFALSE 12055
// begin uc_side = 3 ;
11974: LD_ADDR_OWVAR 20
11978: PUSH
11979: LD_INT 3
11981: ST_TO_ADDR
// uc_nation = 3 ;
11982: LD_ADDR_OWVAR 21
11986: PUSH
11987: LD_INT 3
11989: ST_TO_ADDR
// hc_gallery =  ;
11990: LD_ADDR_OWVAR 33
11994: PUSH
11995: LD_STRING 
11997: ST_TO_ADDR
// hc_name =  ;
11998: LD_ADDR_OWVAR 26
12002: PUSH
12003: LD_STRING 
12005: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12006: LD_INT 0
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_EXP 13
12016: PPUSH
12017: LD_EXP 14
12021: PPUSH
12022: CALL_OW 12
12026: PPUSH
12027: CALL_OW 380
// un = CreateHuman ;
12031: LD_ADDR_VAR 0 3
12035: PUSH
12036: CALL_OW 44
12040: ST_TO_ADDR
// PlaceHumanInUnit ( un , dep2 ) ;
12041: LD_VAR 0 3
12045: PPUSH
12046: LD_INT 10
12048: PPUSH
12049: CALL_OW 52
// end ;
12053: GO 11971
12055: POP
12056: POP
// RespawnInside ( 3 , 3 , arm2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ 1 , rand ( 1 , 2 ) , rand ( 1 , 2 ) ] [ Difficulty ] ) ;
12057: LD_INT 3
12059: PPUSH
12060: LD_INT 3
12062: PPUSH
12063: LD_INT 33
12065: PPUSH
12066: LD_EXP 13
12070: PPUSH
12071: LD_EXP 14
12075: PPUSH
12076: CALL_OW 12
12080: PPUSH
12081: LD_INT 1
12083: PPUSH
12084: LD_INT 1
12086: PUSH
12087: LD_INT 1
12089: PPUSH
12090: LD_INT 2
12092: PPUSH
12093: CALL_OW 12
12097: PUSH
12098: LD_INT 1
12100: PPUSH
12101: LD_INT 2
12103: PPUSH
12104: CALL_OW 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: LIST
12113: PUSH
12114: LD_OWVAR 67
12118: ARRAY
12119: PPUSH
12120: CALL 8513 0 6
// for i in UnitsInside ( arm2 ) do
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_INT 33
12131: PPUSH
12132: CALL_OW 313
12136: PUSH
12137: FOR_IN
12138: IFFALSE 12158
// southBaseDefenders = southBaseDefenders ^ i ;
12140: LD_ADDR_EXP 25
12144: PUSH
12145: LD_EXP 25
12149: PUSH
12150: LD_VAR 0 2
12154: ADD
12155: ST_TO_ADDR
12156: GO 12137
12158: POP
12159: POP
// end ;
12160: LD_VAR 0 1
12164: RET
// export function PrepareNorthBase ; var i , un ; begin
12165: LD_INT 0
12167: PPUSH
12168: PPUSH
12169: PPUSH
// for i = 1 to [ rand ( 1 , 2 ) , rand ( 2 , 3 ) , rand ( 3 , 4 ) ] [ Difficulty ] do
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_INT 1
12182: PPUSH
12183: LD_INT 2
12185: PPUSH
12186: CALL_OW 12
12190: PUSH
12191: LD_INT 2
12193: PPUSH
12194: LD_INT 3
12196: PPUSH
12197: CALL_OW 12
12201: PUSH
12202: LD_INT 3
12204: PPUSH
12205: LD_INT 4
12207: PPUSH
12208: CALL_OW 12
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: LIST
12217: PUSH
12218: LD_OWVAR 67
12222: ARRAY
12223: PUSH
12224: FOR_TO
12225: IFFALSE 12311
// begin uc_side = 3 ;
12227: LD_ADDR_OWVAR 20
12231: PUSH
12232: LD_INT 3
12234: ST_TO_ADDR
// uc_nation = 3 ;
12235: LD_ADDR_OWVAR 21
12239: PUSH
12240: LD_INT 3
12242: ST_TO_ADDR
// hc_gallery =  ;
12243: LD_ADDR_OWVAR 33
12247: PUSH
12248: LD_STRING 
12250: ST_TO_ADDR
// hc_name =  ;
12251: LD_ADDR_OWVAR 26
12255: PUSH
12256: LD_STRING 
12258: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12259: LD_INT 0
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: LD_EXP 13
12269: PPUSH
12270: LD_EXP 14
12274: PPUSH
12275: CALL_OW 12
12279: PPUSH
12280: CALL_OW 380
// un = CreateHuman ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: CALL_OW 44
12293: ST_TO_ADDR
// PlaceUnitArea ( un , NorthBaseRussianSpawn1 , false ) ;
12294: LD_VAR 0 3
12298: PPUSH
12299: LD_INT 14
12301: PPUSH
12302: LD_INT 0
12304: PPUSH
12305: CALL_OW 49
// end ;
12309: GO 12224
12311: POP
12312: POP
// RespawnInside ( 3 , 3 , arm1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ Rand ( 1 , 2 ) , Rand ( 1 , 3 ) , Rand ( 1 , 3 ) ] [ Difficulty ] ) ;
12313: LD_INT 3
12315: PPUSH
12316: LD_INT 3
12318: PPUSH
12319: LD_INT 2
12321: PPUSH
12322: LD_EXP 13
12326: PPUSH
12327: LD_EXP 14
12331: PPUSH
12332: CALL_OW 12
12336: PPUSH
12337: LD_INT 1
12339: PPUSH
12340: LD_INT 1
12342: PPUSH
12343: LD_INT 2
12345: PPUSH
12346: CALL_OW 12
12350: PUSH
12351: LD_INT 1
12353: PPUSH
12354: LD_INT 3
12356: PPUSH
12357: CALL_OW 12
12361: PUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 3
12367: PPUSH
12368: CALL_OW 12
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: LIST
12377: PUSH
12378: LD_OWVAR 67
12382: ARRAY
12383: PPUSH
12384: CALL 8513 0 6
// RespawnInside ( 3 , 3 , lab1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 4 , [ 0 , 1 , 2 ] [ Difficulty ] ) ;
12388: LD_INT 3
12390: PPUSH
12391: LD_INT 3
12393: PPUSH
12394: LD_INT 23
12396: PPUSH
12397: LD_EXP 13
12401: PPUSH
12402: LD_EXP 14
12406: PPUSH
12407: CALL_OW 12
12411: PPUSH
12412: LD_INT 4
12414: PPUSH
12415: LD_INT 0
12417: PUSH
12418: LD_INT 1
12420: PUSH
12421: LD_INT 2
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: LIST
12428: PUSH
12429: LD_OWVAR 67
12433: ARRAY
12434: PPUSH
12435: CALL 8513 0 6
// RespawnInside ( 3 , 3 , dep1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
12439: LD_INT 3
12441: PPUSH
12442: LD_INT 3
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: LD_EXP 13
12452: PPUSH
12453: LD_EXP 14
12457: PPUSH
12458: CALL_OW 12
12462: PPUSH
12463: LD_INT 2
12465: PPUSH
12466: LD_INT 1
12468: PUSH
12469: LD_INT 2
12471: PUSH
12472: LD_INT 2
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: LIST
12479: PUSH
12480: LD_OWVAR 67
12484: ARRAY
12485: PPUSH
12486: CALL 8513 0 6
// for i in UnitsInside ( arm1 ) do
12490: LD_ADDR_VAR 0 2
12494: PUSH
12495: LD_INT 2
12497: PPUSH
12498: CALL_OW 313
12502: PUSH
12503: FOR_IN
12504: IFFALSE 12524
// northBaseDefenders = northBaseDefenders ^ i ;
12506: LD_ADDR_EXP 24
12510: PUSH
12511: LD_EXP 24
12515: PUSH
12516: LD_VAR 0 2
12520: ADD
12521: ST_TO_ADDR
12522: GO 12503
12524: POP
12525: POP
// end ;
12526: LD_VAR 0 1
12530: RET
// export function PrepareOtherRussians ; var i , un ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// for i = 1 to 2 do
12536: LD_ADDR_VAR 0 2
12540: PUSH
12541: DOUBLE
12542: LD_INT 1
12544: DEC
12545: ST_TO_ADDR
12546: LD_INT 2
12548: PUSH
12549: FOR_TO
12550: IFFALSE 12651
// begin uc_side = 3 ;
12552: LD_ADDR_OWVAR 20
12556: PUSH
12557: LD_INT 3
12559: ST_TO_ADDR
// uc_nation = 3 ;
12560: LD_ADDR_OWVAR 21
12564: PUSH
12565: LD_INT 3
12567: ST_TO_ADDR
// hc_gallery =  ;
12568: LD_ADDR_OWVAR 33
12572: PUSH
12573: LD_STRING 
12575: ST_TO_ADDR
// hc_name =  ;
12576: LD_ADDR_OWVAR 26
12580: PUSH
12581: LD_STRING 
12583: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12584: LD_INT 0
12586: PPUSH
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 13
12594: PPUSH
12595: LD_EXP 14
12599: PPUSH
12600: CALL_OW 12
12604: PPUSH
12605: CALL_OW 380
// un = CreateHuman ;
12609: LD_ADDR_VAR 0 3
12613: PUSH
12614: CALL_OW 44
12618: ST_TO_ADDR
// PlaceUnitArea ( un , RussiansWaterSpawn , false ) ;
12619: LD_VAR 0 3
12623: PPUSH
12624: LD_INT 9
12626: PPUSH
12627: LD_INT 0
12629: PPUSH
12630: CALL_OW 49
// ComTurnXY ( un , 80 , 73 ) ;
12634: LD_VAR 0 3
12638: PPUSH
12639: LD_INT 80
12641: PPUSH
12642: LD_INT 73
12644: PPUSH
12645: CALL_OW 118
// end ;
12649: GO 12549
12651: POP
12652: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , 31 ] ] ) do
12653: LD_ADDR_VAR 0 2
12657: PUSH
12658: LD_INT 22
12660: PUSH
12661: LD_INT 3
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 30
12670: PUSH
12671: LD_INT 31
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: EMPTY
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: PUSH
12687: FOR_IN
12688: IFFALSE 12716
// PrepareSolBun ( rand ( RuSoldMinLevel , RuSoldMaxLevel ) , i ) ;
12690: LD_EXP 13
12694: PPUSH
12695: LD_EXP 14
12699: PPUSH
12700: CALL_OW 12
12704: PPUSH
12705: LD_VAR 0 2
12709: PPUSH
12710: CALL 8623 0 2
12714: GO 12687
12716: POP
12717: POP
// end ;
12718: LD_VAR 0 1
12722: RET
// export function PrepareCargoBays ; begin
12723: LD_INT 0
12725: PPUSH
// uc_side = 3 ;
12726: LD_ADDR_OWVAR 20
12730: PUSH
12731: LD_INT 3
12733: ST_TO_ADDR
// uc_nation = 3 ;
12734: LD_ADDR_OWVAR 21
12738: PUSH
12739: LD_INT 3
12741: ST_TO_ADDR
// vc_engine = 1 ;
12742: LD_ADDR_OWVAR 39
12746: PUSH
12747: LD_INT 1
12749: ST_TO_ADDR
// vc_control = 1 ;
12750: LD_ADDR_OWVAR 38
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// vc_weapon = 51 ;
12758: LD_ADDR_OWVAR 40
12762: PUSH
12763: LD_INT 51
12765: ST_TO_ADDR
// vc_chassis = 22 ;
12766: LD_ADDR_OWVAR 37
12770: PUSH
12771: LD_INT 22
12773: ST_TO_ADDR
// cargo1 = CreateVehicle ;
12774: LD_ADDR_EXP 15
12778: PUSH
12779: CALL_OW 45
12783: ST_TO_ADDR
// cargo2 = CreateVehicle ;
12784: LD_ADDR_EXP 16
12788: PUSH
12789: CALL_OW 45
12793: ST_TO_ADDR
// PlaceUnitArea ( cargo1 , RussianAttack , false ) ;
12794: LD_EXP 15
12798: PPUSH
12799: LD_INT 13
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceUnitArea ( cargo2 , RussianAttack , false ) ;
12809: LD_EXP 16
12813: PPUSH
12814: LD_INT 13
12816: PPUSH
12817: LD_INT 0
12819: PPUSH
12820: CALL_OW 49
// AddCargo ( cargo1 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12824: LD_EXP 15
12828: PPUSH
12829: LD_INT 2
12831: PPUSH
12832: LD_INT 70
12834: PUSH
12835: LD_INT 50
12837: PUSH
12838: LD_INT 30
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: LIST
12845: PUSH
12846: LD_OWVAR 67
12850: ARRAY
12851: PPUSH
12852: CALL_OW 291
// AddCargo ( cargo2 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12856: LD_EXP 16
12860: PPUSH
12861: LD_INT 2
12863: PPUSH
12864: LD_INT 70
12866: PUSH
12867: LD_INT 50
12869: PUSH
12870: LD_INT 30
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: PUSH
12878: LD_OWVAR 67
12882: ARRAY
12883: PPUSH
12884: CALL_OW 291
// hc_gallery =  ;
12888: LD_ADDR_OWVAR 33
12892: PUSH
12893: LD_STRING 
12895: ST_TO_ADDR
// hc_name =  ;
12896: LD_ADDR_OWVAR 26
12900: PUSH
12901: LD_STRING 
12903: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
12904: LD_INT 1
12906: PPUSH
12907: LD_INT 3
12909: PPUSH
12910: LD_INT 1
12912: PPUSH
12913: LD_INT 2
12915: PPUSH
12916: CALL_OW 12
12920: PPUSH
12921: CALL_OW 380
// driver1 = CreateHuman ;
12925: LD_ADDR_EXP 17
12929: PUSH
12930: CALL_OW 44
12934: ST_TO_ADDR
// PlaceHumanInUnit ( driver1 , cargo1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_EXP 15
12944: PPUSH
12945: CALL_OW 52
// hc_name = Nikolai Andreyev ;
12949: LD_ADDR_OWVAR 26
12953: PUSH
12954: LD_STRING Nikolai Andreyev
12956: ST_TO_ADDR
// driver2 = CreateHuman ;
12957: LD_ADDR_EXP 18
12961: PUSH
12962: CALL_OW 44
12966: ST_TO_ADDR
// PlaceHumanInUnit ( driver2 , cargo2 ) ;
12967: LD_EXP 18
12971: PPUSH
12972: LD_EXP 16
12976: PPUSH
12977: CALL_OW 52
// end ;
12981: LD_VAR 0 1
12985: RET
// export function PrepareRussianAttack ( count , area ) ; var i , veh , un , tmp , target1 , target2 ; begin
12986: LD_INT 0
12988: PPUSH
12989: PPUSH
12990: PPUSH
12991: PPUSH
12992: PPUSH
12993: PPUSH
12994: PPUSH
// uc_side = 3 ;
12995: LD_ADDR_OWVAR 20
12999: PUSH
13000: LD_INT 3
13002: ST_TO_ADDR
// uc_nation = 3 ;
13003: LD_ADDR_OWVAR 21
13007: PUSH
13008: LD_INT 3
13010: ST_TO_ADDR
// for i := 1 to count + rand ( 1 , 3 ) do
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: DOUBLE
13017: LD_INT 1
13019: DEC
13020: ST_TO_ADDR
13021: LD_VAR 0 1
13025: PUSH
13026: LD_INT 1
13028: PPUSH
13029: LD_INT 3
13031: PPUSH
13032: CALL_OW 12
13036: PLUS
13037: PUSH
13038: FOR_TO
13039: IFFALSE 13216
// begin vc_engine = 1 ;
13041: LD_ADDR_OWVAR 39
13045: PUSH
13046: LD_INT 1
13048: ST_TO_ADDR
// vc_control = 1 ;
13049: LD_ADDR_OWVAR 38
13053: PUSH
13054: LD_INT 1
13056: ST_TO_ADDR
// vc_weapon = 42 ;
13057: LD_ADDR_OWVAR 40
13061: PUSH
13062: LD_INT 42
13064: ST_TO_ADDR
// vc_chassis = [ 21 , 22 , 22 ] [ Difficulty ] ;
13065: LD_ADDR_OWVAR 37
13069: PUSH
13070: LD_INT 21
13072: PUSH
13073: LD_INT 22
13075: PUSH
13076: LD_INT 22
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: LIST
13083: PUSH
13084: LD_OWVAR 67
13088: ARRAY
13089: ST_TO_ADDR
// veh = CreateVehicle ;
13090: LD_ADDR_VAR 0 5
13094: PUSH
13095: CALL_OW 45
13099: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
13100: LD_VAR 0 5
13104: PPUSH
13105: LD_VAR 0 2
13109: PPUSH
13110: LD_INT 0
13112: PPUSH
13113: CALL_OW 49
// attackGroup = attackGroup ^ veh ;
13117: LD_ADDR_EXP 26
13121: PUSH
13122: LD_EXP 26
13126: PUSH
13127: LD_VAR 0 5
13131: ADD
13132: ST_TO_ADDR
// hc_gallery =  ;
13133: LD_ADDR_OWVAR 33
13137: PUSH
13138: LD_STRING 
13140: ST_TO_ADDR
// hc_name =  ;
13141: LD_ADDR_OWVAR 26
13145: PUSH
13146: LD_STRING 
13148: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13149: LD_INT 0
13151: PPUSH
13152: LD_INT 3
13154: PPUSH
13155: LD_EXP 13
13159: PPUSH
13160: LD_EXP 14
13164: PPUSH
13165: CALL_OW 12
13169: PPUSH
13170: CALL_OW 380
// un = CreateHuman ;
13174: LD_ADDR_VAR 0 6
13178: PUSH
13179: CALL_OW 44
13183: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
13184: LD_VAR 0 6
13188: PPUSH
13189: LD_VAR 0 5
13193: PPUSH
13194: CALL_OW 52
// attackGroup = attackGroup ^ un ;
13198: LD_ADDR_EXP 26
13202: PUSH
13203: LD_EXP 26
13207: PUSH
13208: LD_VAR 0 6
13212: ADD
13213: ST_TO_ADDR
// end ;
13214: GO 13038
13216: POP
13217: POP
// PrepareHuman ( false , 2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13218: LD_INT 0
13220: PPUSH
13221: LD_INT 2
13223: PPUSH
13224: LD_EXP 13
13228: PPUSH
13229: LD_EXP 14
13233: PPUSH
13234: CALL_OW 12
13238: PPUSH
13239: CALL_OW 380
// un = CreateHuman ;
13243: LD_ADDR_VAR 0 6
13247: PUSH
13248: CALL_OW 44
13252: ST_TO_ADDR
// for i := 1 to count + 2 * 2 do
13253: LD_ADDR_VAR 0 4
13257: PUSH
13258: DOUBLE
13259: LD_INT 1
13261: DEC
13262: ST_TO_ADDR
13263: LD_VAR 0 1
13267: PUSH
13268: LD_INT 2
13270: PUSH
13271: LD_INT 2
13273: MUL
13274: PLUS
13275: PUSH
13276: FOR_TO
13277: IFFALSE 13365
// begin hc_gallery =  ;
13279: LD_ADDR_OWVAR 33
13283: PUSH
13284: LD_STRING 
13286: ST_TO_ADDR
// hc_name =  ;
13287: LD_ADDR_OWVAR 26
13291: PUSH
13292: LD_STRING 
13294: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13295: LD_INT 1
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: LD_EXP 13
13305: PPUSH
13306: LD_EXP 14
13310: PPUSH
13311: CALL_OW 12
13315: PPUSH
13316: CALL_OW 380
// un = CreateHuman ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: CALL_OW 44
13329: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
13330: LD_VAR 0 6
13334: PPUSH
13335: LD_VAR 0 2
13339: PPUSH
13340: LD_INT 0
13342: PPUSH
13343: CALL_OW 49
// attackGroup = attackGroup ^ un ;
13347: LD_ADDR_EXP 26
13351: PUSH
13352: LD_EXP 26
13356: PUSH
13357: LD_VAR 0 6
13361: ADD
13362: ST_TO_ADDR
// end ;
13363: GO 13276
13365: POP
13366: POP
// tmp = FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) ;
13367: LD_ADDR_VAR 0 7
13371: PUSH
13372: LD_INT 26
13374: PPUSH
13375: LD_INT 22
13377: PUSH
13378: LD_INT 3
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: LD_INT 21
13387: PUSH
13388: LD_INT 1
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PUSH
13395: LD_INT 26
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: PPUSH
13410: CALL_OW 70
13414: ST_TO_ADDR
// Say ( tmp [ 1 ] , D9-Rus3-1 ) ;
13415: LD_VAR 0 7
13419: PUSH
13420: LD_INT 1
13422: ARRAY
13423: PPUSH
13424: LD_STRING D9-Rus3-1
13426: PPUSH
13427: CALL_OW 88
// Say ( tmp [ 2 ] , D9-Russ-1 ) ;
13431: LD_VAR 0 7
13435: PUSH
13436: LD_INT 2
13438: ARRAY
13439: PPUSH
13440: LD_STRING D9-Russ-1
13442: PPUSH
13443: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13447: LD_INT 35
13449: PPUSH
13450: CALL_OW 67
// for i in FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] ] ) do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: LD_INT 26
13461: PPUSH
13462: LD_INT 22
13464: PUSH
13465: LD_INT 3
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: EMPTY
13473: LIST
13474: PPUSH
13475: CALL_OW 70
13479: PUSH
13480: FOR_IN
13481: IFFALSE 13653
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ;
13483: LD_ADDR_VAR 0 8
13487: PUSH
13488: LD_INT 22
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PPUSH
13498: CALL_OW 69
13502: PPUSH
13503: LD_VAR 0 4
13507: PPUSH
13508: CALL_OW 74
13512: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
13513: LD_ADDR_VAR 0 9
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 1
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 2
13530: PUSH
13531: LD_INT 59
13533: PUSH
13534: EMPTY
13535: LIST
13536: PUSH
13537: LD_INT 21
13539: PUSH
13540: LD_INT 1
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 21
13549: PUSH
13550: LD_INT 2
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: EMPTY
13568: LIST
13569: PPUSH
13570: CALL_OW 69
13574: PPUSH
13575: LD_VAR 0 4
13579: PPUSH
13580: CALL_OW 74
13584: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
13585: LD_VAR 0 4
13589: PPUSH
13590: LD_VAR 0 8
13594: PPUSH
13595: CALL_OW 296
13599: PUSH
13600: LD_INT 8
13602: PLUS
13603: PUSH
13604: LD_VAR 0 4
13608: PPUSH
13609: LD_VAR 0 9
13613: PPUSH
13614: CALL_OW 296
13618: LESS
13619: IFFALSE 13637
// begin ComAttackUnit ( i , target1 ) ;
13621: LD_VAR 0 4
13625: PPUSH
13626: LD_VAR 0 8
13630: PPUSH
13631: CALL_OW 115
// end else
13635: GO 13651
// begin ComAttackUnit ( i , target2 ) ;
13637: LD_VAR 0 4
13641: PPUSH
13642: LD_VAR 0 9
13646: PPUSH
13647: CALL_OW 115
// end ; end ;
13651: GO 13480
13653: POP
13654: POP
// until FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ) = 0 ;
13655: LD_INT 26
13657: PPUSH
13658: LD_INT 22
13660: PUSH
13661: LD_INT 3
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: LD_INT 2
13670: PUSH
13671: LD_INT 21
13673: PUSH
13674: LD_INT 1
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 2
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: LD_INT 59
13693: PUSH
13694: EMPTY
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 70
13711: PUSH
13712: LD_INT 0
13714: EQUAL
13715: IFFALSE 13447
// end ; end_of_file
13717: LD_VAR 0 3
13721: RET
// every 0 0$1 do
13722: GO 13724
13724: DISABLE
// begin enable ;
13725: ENABLE
// RepairBuilding ( 3 , dep1 , NorthBase ) ;
13726: LD_INT 3
13728: PPUSH
13729: LD_INT 1
13731: PPUSH
13732: LD_INT 22
13734: PPUSH
13735: CALL 8759 0 3
// HealUnitInBase ( 3 , NorthBaseHealArea , NorthBase , lab1 ) ;
13739: LD_INT 3
13741: PPUSH
13742: LD_INT 20
13744: PPUSH
13745: LD_INT 22
13747: PPUSH
13748: LD_INT 23
13750: PPUSH
13751: CALL 9005 0 4
// RepairVehicle ( 3 , SouthBaseRepairArea , SouthBase ) ;
13755: LD_INT 3
13757: PPUSH
13758: LD_INT 21
13760: PPUSH
13761: LD_INT 23
13763: PPUSH
13764: CALL 9282 0 3
// DefendBases ( NorthBase , 1 , northBaseDefenders , arm1 , 3 ) ;
13768: LD_INT 22
13770: PPUSH
13771: LD_INT 1
13773: PPUSH
13774: LD_EXP 24
13778: PPUSH
13779: LD_INT 2
13781: PPUSH
13782: LD_INT 3
13784: PPUSH
13785: CALL 9754 0 5
// DefendBases ( SouthBase , 1 , southBaseDefenders , arm2 , 1 ) ;
13789: LD_INT 23
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_EXP 25
13799: PPUSH
13800: LD_INT 33
13802: PPUSH
13803: LD_INT 1
13805: PPUSH
13806: CALL 9754 0 5
// end ; end_of_file
13810: END
// on UnitDestroyed ( unit ) do begin if GetBType ( unit ) = b_depot then
13811: LD_VAR 0 1
13815: PPUSH
13816: CALL_OW 266
13820: PUSH
13821: LD_INT 0
13823: EQUAL
13824: IFFALSE 13833
// YouLost ( DepotDestroyed ) ;
13826: LD_STRING DepotDestroyed
13828: PPUSH
13829: CALL_OW 104
// if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
13833: LD_VAR 0 1
13837: PPUSH
13838: CALL_OW 255
13842: PUSH
13843: LD_INT 1
13845: EQUAL
13846: PUSH
13847: LD_VAR 0 1
13851: PPUSH
13852: CALL_OW 247
13856: PUSH
13857: LD_INT 1
13859: EQUAL
13860: AND
13861: IFFALSE 13877
// deadsCounter = deadsCounter + 1 ;
13863: LD_ADDR_EXP 31
13867: PUSH
13868: LD_EXP 31
13872: PUSH
13873: LD_INT 1
13875: PLUS
13876: ST_TO_ADDR
// end ;
13877: PPOPN 1
13879: END
// on Command ( comandid ) do var i , j , tmp ;
13880: LD_INT 0
13882: PPUSH
13883: PPUSH
13884: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 22
13892: PUSH
13893: LD_INT 1
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: LD_INT 21
13902: PUSH
13903: LD_INT 2
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PPUSH
13914: CALL_OW 69
13918: PUSH
13919: FOR_IN
13920: IFFALSE 14045
// begin if GetTaskList ( i ) > 0 then
13922: LD_VAR 0 2
13926: PPUSH
13927: CALL_OW 437
13931: PUSH
13932: LD_INT 0
13934: GREATER
13935: IFFALSE 14043
// begin for j = 1 to GetTaskList ( i ) do
13937: LD_ADDR_VAR 0 3
13941: PUSH
13942: DOUBLE
13943: LD_INT 1
13945: DEC
13946: ST_TO_ADDR
13947: LD_VAR 0 2
13951: PPUSH
13952: CALL_OW 437
13956: PUSH
13957: FOR_TO
13958: IFFALSE 14041
// begin tmp = GetTaskList ( i ) [ j ] [ 4 ] ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: LD_VAR 0 2
13969: PPUSH
13970: CALL_OW 437
13974: PUSH
13975: LD_VAR 0 3
13979: ARRAY
13980: PUSH
13981: LD_INT 4
13983: ARRAY
13984: ST_TO_ADDR
// if ( GetSide ( tmp ) = 3 and GetType ( tmp ) = unit_vehicle and GetWeapon ( tmp ) = ru_cargo_bay ) then
13985: LD_VAR 0 4
13989: PPUSH
13990: CALL_OW 255
13994: PUSH
13995: LD_INT 3
13997: EQUAL
13998: PUSH
13999: LD_VAR 0 4
14003: PPUSH
14004: CALL_OW 247
14008: PUSH
14009: LD_INT 2
14011: EQUAL
14012: AND
14013: PUSH
14014: LD_VAR 0 4
14018: PPUSH
14019: CALL_OW 264
14023: PUSH
14024: LD_INT 51
14026: EQUAL
14027: AND
14028: IFFALSE 14039
// ComStop ( i ) ;
14030: LD_VAR 0 2
14034: PPUSH
14035: CALL_OW 141
// end ;
14039: GO 13957
14041: POP
14042: POP
// end ; end ;
14043: GO 13919
14045: POP
14046: POP
// end ;
14047: PPOPN 4
14049: END
// on LeaveBuilding ( b , un ) do begin if un = Mikhail and mikhailStatus <> 4 then
14050: LD_VAR 0 2
14054: PUSH
14055: LD_EXP 8
14059: EQUAL
14060: PUSH
14061: LD_EXP 21
14065: PUSH
14066: LD_INT 4
14068: NONEQUAL
14069: AND
14070: IFFALSE 14222
// begin if IsOk ( Mikhail ) then
14072: LD_EXP 8
14076: PPUSH
14077: CALL_OW 302
14081: IFFALSE 14089
// AskMikhail else
14083: CALL 7044 0 0
14087: GO 14222
// if IsOk ( lab1 ) then
14089: LD_INT 23
14091: PPUSH
14092: CALL_OW 302
14096: IFFALSE 14185
// begin InGameOn ;
14098: CALL_OW 8
// SetSide ( Mikhail , 6 ) ;
14102: LD_EXP 8
14106: PPUSH
14107: LD_INT 6
14109: PPUSH
14110: CALL_OW 235
// SetSide ( lab1 , 6 ) ;
14114: LD_INT 23
14116: PPUSH
14117: LD_INT 6
14119: PPUSH
14120: CALL_OW 235
// ComEnterUnit ( Mikhail , lab1 ) ;
14124: LD_EXP 8
14128: PPUSH
14129: LD_INT 23
14131: PPUSH
14132: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
14136: LD_INT 35
14138: PPUSH
14139: CALL_OW 67
// until IsInUnit ( Mikhail ) = lab1 or IsDead ( Mikhail ) ;
14143: LD_EXP 8
14147: PPUSH
14148: CALL_OW 310
14152: PUSH
14153: LD_INT 23
14155: EQUAL
14156: PUSH
14157: LD_EXP 8
14161: PPUSH
14162: CALL_OW 301
14166: OR
14167: IFFALSE 14136
// SetSide ( lab1 , 1 ) ;
14169: LD_INT 23
14171: PPUSH
14172: LD_INT 1
14174: PPUSH
14175: CALL_OW 235
// InGameOff ;
14179: CALL_OW 9
// end else
14183: GO 14222
// begin SetAttitude ( 3 , 6 , att_enemy , true ) ;
14185: LD_INT 3
14187: PPUSH
14188: LD_INT 6
14190: PPUSH
14191: LD_INT 2
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
14201: LD_EXP 8
14205: PPUSH
14206: LD_INT 6
14208: PPUSH
14209: CALL_OW 235
// ComHold ( Mikhail ) ;
14213: LD_EXP 8
14217: PPUSH
14218: CALL_OW 140
// end ; end ; end ;
14222: PPOPN 2
14224: END
// every 3 trigger GetClass ( Mikhail ) <> 3 do
14225: LD_EXP 8
14229: PPUSH
14230: CALL_OW 257
14234: PUSH
14235: LD_INT 3
14237: NONEQUAL
14238: IFFALSE 14256
14240: GO 14242
14242: DISABLE
// begin enable ;
14243: ENABLE
// SetClass ( Mikhail , 3 ) ;
14244: LD_EXP 8
14248: PPUSH
14249: LD_INT 3
14251: PPUSH
14252: CALL_OW 336
// end ; end_of_file
14256: END
// every 0 0$1 trigger IsDead ( JMM ) do
14257: LD_EXP 1
14261: PPUSH
14262: CALL_OW 301
14266: IFFALSE 14278
14268: GO 14270
14270: DISABLE
// YouLost ( JMM ) ;
14271: LD_STRING JMM
14273: PPUSH
14274: CALL_OW 104
14278: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and GetSide ( dep1 ) = 3 and GetSide ( dep2 ) = 3 do
14279: LD_INT 22
14281: PUSH
14282: LD_INT 1
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PUSH
14289: LD_INT 21
14291: PUSH
14292: LD_INT 1
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: LD_INT 2
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: LIST
14313: PPUSH
14314: CALL_OW 69
14318: PUSH
14319: LD_INT 0
14321: EQUAL
14322: PUSH
14323: LD_INT 22
14325: PUSH
14326: LD_INT 4
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 21
14335: PUSH
14336: LD_INT 1
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 25
14345: PUSH
14346: LD_INT 2
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: LIST
14357: PPUSH
14358: CALL_OW 69
14362: PUSH
14363: LD_INT 0
14365: EQUAL
14366: AND
14367: PUSH
14368: LD_INT 1
14370: PPUSH
14371: CALL_OW 255
14375: PUSH
14376: LD_INT 3
14378: EQUAL
14379: AND
14380: PUSH
14381: LD_INT 10
14383: PPUSH
14384: CALL_OW 255
14388: PUSH
14389: LD_INT 3
14391: EQUAL
14392: AND
14393: IFFALSE 14405
14395: GO 14397
14397: DISABLE
// YouLost ( Engineer ) ;
14398: LD_STRING Engineer
14400: PPUSH
14401: CALL_OW 104
14405: END
// every 0 0$1 trigger GetSide ( dep1 ) = 3 and LastBattle = 1 do
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 255
14413: PUSH
14414: LD_INT 3
14416: EQUAL
14417: PUSH
14418: LD_EXP 27
14422: PUSH
14423: LD_INT 1
14425: EQUAL
14426: AND
14427: IFFALSE 14439
14429: GO 14431
14431: DISABLE
// YouLost ( DepotCaptured ) ; end_of_file
14432: LD_STRING DepotCaptured
14434: PPUSH
14435: CALL_OW 104
14439: END
// export function PrepareTigers ; var i , un ; begin
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
14444: PPUSH
// for i = 1 to Difficulty do
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: DOUBLE
14451: LD_INT 1
14453: DEC
14454: ST_TO_ADDR
14455: LD_OWVAR 67
14459: PUSH
14460: FOR_TO
14461: IFFALSE 14596
// begin hc_sex = sex_male ;
14463: LD_ADDR_OWVAR 27
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// uc_side = 0 ;
14471: LD_ADDR_OWVAR 20
14475: PUSH
14476: LD_INT 0
14478: ST_TO_ADDR
// uc_nation = nation_nature ;
14479: LD_ADDR_OWVAR 21
14483: PUSH
14484: LD_INT 0
14486: ST_TO_ADDR
// hc_class = class_tiger ;
14487: LD_ADDR_OWVAR 28
14491: PUSH
14492: LD_INT 14
14494: ST_TO_ADDR
// hc_skills = [ RuSoldMaxLevel , 0 , 0 , 0 ] ;
14495: LD_ADDR_OWVAR 31
14499: PUSH
14500: LD_EXP 14
14504: PUSH
14505: LD_INT 0
14507: PUSH
14508: LD_INT 0
14510: PUSH
14511: LD_INT 0
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: ST_TO_ADDR
// hc_agressivity = [ rand ( 30 , 40 ) , rand ( 40 , 50 ) , rand ( 50 , 60 ) ] [ Difficulty ] ;
14520: LD_ADDR_OWVAR 35
14524: PUSH
14525: LD_INT 30
14527: PPUSH
14528: LD_INT 40
14530: PPUSH
14531: CALL_OW 12
14535: PUSH
14536: LD_INT 40
14538: PPUSH
14539: LD_INT 50
14541: PPUSH
14542: CALL_OW 12
14546: PUSH
14547: LD_INT 50
14549: PPUSH
14550: LD_INT 60
14552: PPUSH
14553: CALL_OW 12
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: LIST
14562: PUSH
14563: LD_OWVAR 67
14567: ARRAY
14568: ST_TO_ADDR
// un = CreateHuman ;
14569: LD_ADDR_VAR 0 3
14573: PUSH
14574: CALL_OW 44
14578: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
14579: LD_VAR 0 3
14583: PPUSH
14584: LD_INT 27
14586: PPUSH
14587: LD_INT 0
14589: PPUSH
14590: CALL_OW 49
// end ;
14594: GO 14460
14596: POP
14597: POP
// end ; end_of_file
14598: LD_VAR 0 1
14602: RET
// every 0 0$01 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape = 1 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 51 ] , [ f_not , [ f_empty ] ] ] ) = 0 do
14603: LD_INT 1
14605: PPUSH
14606: CALL_OW 255
14610: PUSH
14611: LD_INT 1
14613: EQUAL
14614: PUSH
14615: LD_INT 10
14617: PPUSH
14618: CALL_OW 255
14622: PUSH
14623: LD_INT 1
14625: EQUAL
14626: AND
14627: PUSH
14628: LD_EXP 20
14632: PUSH
14633: LD_INT 1
14635: EQUAL
14636: AND
14637: PUSH
14638: LD_INT 22
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 21
14650: PUSH
14651: LD_INT 2
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 34
14660: PUSH
14661: LD_INT 51
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 58
14673: PUSH
14674: EMPTY
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_INT 0
14694: EQUAL
14695: AND
14696: IFFALSE 14787
14698: GO 14700
14700: DISABLE
// begin wait ( [ 4 4$30 , 4 4$0 , 3 3$0 ] [ Difficulty ] ) ;
14701: LD_INT 9450
14703: PUSH
14704: LD_INT 8400
14706: PUSH
14707: LD_INT 6300
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_OWVAR 67
14719: ARRAY
14720: PPUSH
14721: CALL_OW 67
// if cargoEscape = 1 then
14725: LD_EXP 20
14729: PUSH
14730: LD_INT 1
14732: EQUAL
14733: IFFALSE 14787
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14735: LD_EXP 9
14739: PPUSH
14740: LD_STRING D6-Pow-1
14742: PPUSH
14743: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14747: LD_EXP 1
14751: PPUSH
14752: LD_STRING D6-JMM-1
14754: PPUSH
14755: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14759: LD_EXP 9
14763: PPUSH
14764: LD_STRING D6-Pow-2
14766: PPUSH
14767: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14771: LD_EXP 1
14775: PPUSH
14776: LD_STRING D6-JMM-2
14778: PPUSH
14779: CALL_OW 88
// FinishMission ;
14783: CALL 14995 0 0
// end ; end ;
14787: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape > 1 do var tmp ;
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 255
14795: PUSH
14796: LD_INT 1
14798: EQUAL
14799: PUSH
14800: LD_INT 10
14802: PPUSH
14803: CALL_OW 255
14807: PUSH
14808: LD_INT 1
14810: EQUAL
14811: AND
14812: PUSH
14813: LD_EXP 20
14817: PUSH
14818: LD_INT 1
14820: GREATER
14821: AND
14822: IFFALSE 14889
14824: GO 14826
14826: DISABLE
14827: LD_INT 0
14829: PPUSH
// begin wait ( [ 5 5$30 , 5 5$0 , 4 4$30 ] [ Difficulty ] ) ;
14830: LD_INT 11550
14832: PUSH
14833: LD_INT 10500
14835: PUSH
14836: LD_INT 9450
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: PUSH
14844: LD_OWVAR 67
14848: ARRAY
14849: PPUSH
14850: CALL_OW 67
// PrepareRussianAttack ( [ 1 , 2 , 3 ] [ Difficulty ] , RussianAttack ) ;
14854: LD_INT 1
14856: PUSH
14857: LD_INT 2
14859: PUSH
14860: LD_INT 3
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PUSH
14868: LD_OWVAR 67
14872: ARRAY
14873: PPUSH
14874: LD_INT 13
14876: PPUSH
14877: CALL 12986 0 2
// lastBattle = 1 ;
14881: LD_ADDR_EXP 27
14885: PUSH
14886: LD_INT 1
14888: ST_TO_ADDR
// end ;
14889: PPOPN 1
14891: END
// every 0 0$7 trigger LastBattle = 1 and FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
14892: LD_EXP 27
14896: PUSH
14897: LD_INT 1
14899: EQUAL
14900: PUSH
14901: LD_INT 26
14903: PPUSH
14904: LD_INT 22
14906: PUSH
14907: LD_INT 3
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: LD_INT 21
14916: PUSH
14917: LD_INT 1
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PPUSH
14928: CALL_OW 70
14932: PUSH
14933: LD_INT 0
14935: EQUAL
14936: AND
14937: IFFALSE 14994
14939: GO 14941
14941: DISABLE
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14942: LD_EXP 9
14946: PPUSH
14947: LD_STRING D6-Pow-1
14949: PPUSH
14950: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14954: LD_EXP 1
14958: PPUSH
14959: LD_STRING D6-JMM-1
14961: PPUSH
14962: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14966: LD_EXP 9
14970: PPUSH
14971: LD_STRING D6-Pow-2
14973: PPUSH
14974: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14978: LD_EXP 1
14982: PPUSH
14983: LD_STRING D6-JMM-2
14985: PPUSH
14986: CALL_OW 88
// FinishMission ;
14990: CALL 14995 0 0
// end ;
14994: END
// export function FinishMission ; var tmp , m1 , m2 , m3 ; begin
14995: LD_INT 0
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// if tick <= 18 18$00 then
15002: LD_OWVAR 1
15006: PUSH
15007: LD_INT 37800
15009: LESSEQUAL
15010: IFFALSE 15019
// SetAchievement ( ACH_ASPEED_2 ) ;
15012: LD_STRING ACH_ASPEED_2
15014: PPUSH
15015: CALL_OW 543
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_lives , 251 ] ] ) ;
15019: LD_ADDR_VAR 0 2
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 1
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 21
15036: PUSH
15037: LD_INT 2
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PUSH
15044: LD_INT 24
15046: PUSH
15047: LD_INT 251
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: LIST
15058: PPUSH
15059: CALL_OW 69
15063: ST_TO_ADDR
// if tmp then
15064: LD_VAR 0 2
15068: IFFALSE 15082
// SaveVehicles ( tmp , 02_tanks_1 ) ;
15070: LD_VAR 0 2
15074: PPUSH
15075: LD_STRING 02_tanks_1
15077: PPUSH
15078: CALL 10459 0 2
// if mikhailStatus = 1 and IsLive ( Mikhail ) then
15082: LD_EXP 21
15086: PUSH
15087: LD_INT 1
15089: EQUAL
15090: PUSH
15091: LD_EXP 8
15095: PPUSH
15096: CALL_OW 300
15100: AND
15101: IFFALSE 15115
// SaveVariable ( mikhailStatus , 02_mikhailStatus_1 ) ;
15103: LD_EXP 21
15107: PPUSH
15108: LD_STRING 02_mikhailStatus_1
15110: PPUSH
15111: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( dep1 ) , 1 ) , 02_resources_4 ) ;
15115: LD_INT 1
15117: PPUSH
15118: CALL_OW 274
15122: PPUSH
15123: LD_INT 1
15125: PPUSH
15126: CALL_OW 275
15130: PPUSH
15131: LD_STRING 02_resources_4
15133: PPUSH
15134: CALL_OW 39
// m1 := false ;
15138: LD_ADDR_VAR 0 3
15142: PUSH
15143: LD_INT 0
15145: ST_TO_ADDR
// m2 := false ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: LD_INT 0
15153: ST_TO_ADDR
// m3 := false ;
15154: LD_ADDR_VAR 0 5
15158: PUSH
15159: LD_INT 0
15161: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep1 ) , 1 ) >= 200 then
15162: LD_INT 1
15164: PPUSH
15165: CALL_OW 274
15169: PPUSH
15170: LD_INT 1
15172: PPUSH
15173: CALL_OW 275
15177: PUSH
15178: LD_INT 200
15180: GREATEREQUAL
15181: IFFALSE 15203
// begin AddMedal ( Cans , 1 ) ;
15183: LD_STRING Cans
15185: PPUSH
15186: LD_INT 1
15188: PPUSH
15189: CALL_OW 101
// m1 := true ;
15193: LD_ADDR_VAR 0 3
15197: PUSH
15198: LD_INT 1
15200: ST_TO_ADDR
// end else
15201: GO 15214
// begin AddMedal ( Cans , - 1 ) ;
15203: LD_STRING Cans
15205: PPUSH
15206: LD_INT 1
15208: NEG
15209: PPUSH
15210: CALL_OW 101
// end ; if deadsCounter < 2 then
15214: LD_EXP 31
15218: PUSH
15219: LD_INT 2
15221: LESS
15222: IFFALSE 15244
// begin AddMedal ( Deaths , 1 ) ;
15224: LD_STRING Deaths
15226: PPUSH
15227: LD_INT 1
15229: PPUSH
15230: CALL_OW 101
// m2 := true ;
15234: LD_ADDR_VAR 0 4
15238: PUSH
15239: LD_INT 1
15241: ST_TO_ADDR
// end else
15242: GO 15255
// begin AddMedal ( Deaths , - 1 ) ;
15244: LD_STRING Deaths
15246: PPUSH
15247: LD_INT 1
15249: NEG
15250: PPUSH
15251: CALL_OW 101
// end ; if mikhailStatus = 0 then
15255: LD_EXP 21
15259: PUSH
15260: LD_INT 0
15262: EQUAL
15263: IFFALSE 15276
// AddMedal ( Prisoner , - 1 ) ;
15265: LD_STRING Prisoner
15267: PPUSH
15268: LD_INT 1
15270: NEG
15271: PPUSH
15272: CALL_OW 101
// if mikhailStatus = 1 then
15276: LD_EXP 21
15280: PUSH
15281: LD_INT 1
15283: EQUAL
15284: IFFALSE 15304
// begin AddMedal ( Prisoner , 1 ) ;
15286: LD_STRING Prisoner
15288: PPUSH
15289: LD_INT 1
15291: PPUSH
15292: CALL_OW 101
// m3 := true ;
15296: LD_ADDR_VAR 0 5
15300: PUSH
15301: LD_INT 1
15303: ST_TO_ADDR
// end ; if mikhailStatus = 2 then
15304: LD_EXP 21
15308: PUSH
15309: LD_INT 2
15311: EQUAL
15312: IFFALSE 15332
// begin AddMedal ( Prisoner , 2 ) ;
15314: LD_STRING Prisoner
15316: PPUSH
15317: LD_INT 2
15319: PPUSH
15320: CALL_OW 101
// m3 := true ;
15324: LD_ADDR_VAR 0 5
15328: PUSH
15329: LD_INT 1
15331: ST_TO_ADDR
// end ; if mikhailStatus = 3 then
15332: LD_EXP 21
15336: PUSH
15337: LD_INT 3
15339: EQUAL
15340: IFFALSE 15353
// AddMedal ( Prisoner , - 2 ) ;
15342: LD_STRING Prisoner
15344: PPUSH
15345: LD_INT 2
15347: NEG
15348: PPUSH
15349: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
15353: LD_OWVAR 67
15357: PUSH
15358: LD_INT 3
15360: EQUAL
15361: PUSH
15362: LD_VAR 0 3
15366: AND
15367: PUSH
15368: LD_VAR 0 4
15372: AND
15373: PUSH
15374: LD_VAR 0 5
15378: AND
15379: IFFALSE 15391
// SetAchievementEX ( ACH_AMER , 2 ) ;
15381: LD_STRING ACH_AMER
15383: PPUSH
15384: LD_INT 2
15386: PPUSH
15387: CALL_OW 564
// GiveMedals ( MAIN ) ;
15391: LD_STRING MAIN
15393: PPUSH
15394: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) ) ;
15398: LD_INT 22
15400: PUSH
15401: LD_INT 1
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 23
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 21
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: LIST
15432: PPUSH
15433: CALL_OW 69
15437: PPUSH
15438: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15442: LD_EXP 1
15446: PPUSH
15447: LD_EXP 33
15451: PUSH
15452: LD_STRING JMM
15454: STR
15455: PPUSH
15456: CALL_OW 38
// if IsOK ( Bobby ) then
15460: LD_EXP 2
15464: PPUSH
15465: CALL_OW 302
15469: IFFALSE 15489
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15471: LD_EXP 2
15475: PPUSH
15476: LD_EXP 33
15480: PUSH
15481: LD_STRING Bobby
15483: STR
15484: PPUSH
15485: CALL_OW 38
// if IsOK ( Cyrus ) then
15489: LD_EXP 3
15493: PPUSH
15494: CALL_OW 302
15498: IFFALSE 15518
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15500: LD_EXP 3
15504: PPUSH
15505: LD_EXP 33
15509: PUSH
15510: LD_STRING Cyrus
15512: STR
15513: PPUSH
15514: CALL_OW 38
// if IsOK ( Lisa ) then
15518: LD_EXP 4
15522: PPUSH
15523: CALL_OW 302
15527: IFFALSE 15547
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15529: LD_EXP 4
15533: PPUSH
15534: LD_EXP 33
15538: PUSH
15539: LD_STRING Lisa
15541: STR
15542: PPUSH
15543: CALL_OW 38
// if IsOK ( Khatam ) then
15547: LD_EXP 5
15551: PPUSH
15552: CALL_OW 302
15556: IFFALSE 15576
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
15558: LD_EXP 5
15562: PPUSH
15563: LD_EXP 33
15567: PUSH
15568: LD_STRING Khatam
15570: STR
15571: PPUSH
15572: CALL_OW 38
// if IsOK ( Brian ) then
15576: LD_EXP 6
15580: PPUSH
15581: CALL_OW 302
15585: IFFALSE 15605
// SaveCharacters ( Brian , mission_prefix & Brian ) ;
15587: LD_EXP 6
15591: PPUSH
15592: LD_EXP 33
15596: PUSH
15597: LD_STRING Brian
15599: STR
15600: PPUSH
15601: CALL_OW 38
// if IsOk ( Jerry ) then
15605: LD_EXP 7
15609: PPUSH
15610: CALL_OW 302
15614: IFFALSE 15634
// SaveCharacters ( Jerry , mission_prefix & Jerry ) ;
15616: LD_EXP 7
15620: PPUSH
15621: LD_EXP 33
15625: PUSH
15626: LD_STRING Jerry
15628: STR
15629: PPUSH
15630: CALL_OW 38
// if mikhailStatus = 1 and GetSide ( Mikhail ) = 1 and IsOk ( Mikhail ) then
15634: LD_EXP 21
15638: PUSH
15639: LD_INT 1
15641: EQUAL
15642: PUSH
15643: LD_EXP 8
15647: PPUSH
15648: CALL_OW 255
15652: PUSH
15653: LD_INT 1
15655: EQUAL
15656: AND
15657: PUSH
15658: LD_EXP 8
15662: PPUSH
15663: CALL_OW 302
15667: AND
15668: IFFALSE 15688
// SaveCharacters ( Mikhail , mission_prefix & Mikhail ) ;
15670: LD_EXP 8
15674: PPUSH
15675: LD_EXP 33
15679: PUSH
15680: LD_STRING Mikhail
15682: STR
15683: PPUSH
15684: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Mikhail ] , 02_other_survivors ) ;
15688: LD_INT 50
15690: PUSH
15691: EMPTY
15692: LIST
15693: PUSH
15694: LD_INT 22
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 21
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_EXP 1
15728: PUSH
15729: LD_EXP 2
15733: PUSH
15734: LD_EXP 3
15738: PUSH
15739: LD_EXP 4
15743: PUSH
15744: LD_EXP 5
15748: PUSH
15749: LD_EXP 6
15753: PUSH
15754: LD_EXP 7
15758: PUSH
15759: LD_EXP 8
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: DIFF
15774: PPUSH
15775: LD_STRING 02_other_survivors
15777: PPUSH
15778: CALL_OW 38
// YouWin ;
15782: CALL_OW 103
// end ; end_of_file
15786: LD_VAR 0 1
15790: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
15791: GO 15793
15793: DISABLE
// begin ru_radar := 98 ;
15794: LD_ADDR_EXP 35
15798: PUSH
15799: LD_INT 98
15801: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
15802: LD_ADDR_EXP 36
15806: PUSH
15807: LD_INT 89
15809: ST_TO_ADDR
// us_hack := 99 ;
15810: LD_ADDR_EXP 37
15814: PUSH
15815: LD_INT 99
15817: ST_TO_ADDR
// us_artillery := 97 ;
15818: LD_ADDR_EXP 38
15822: PUSH
15823: LD_INT 97
15825: ST_TO_ADDR
// ar_bio_bomb := 91 ;
15826: LD_ADDR_EXP 39
15830: PUSH
15831: LD_INT 91
15833: ST_TO_ADDR
// end ; end_of_file end_of_file
15834: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
15835: GO 15837
15837: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
15838: LD_STRING initStreamRollete();
15840: PPUSH
15841: CALL_OW 559
// InitStreamMode ;
15845: CALL 15854 0 0
// DefineStreamItems ( ) ;
15849: CALL 16294 0 0
// end ;
15853: END
// function InitStreamMode ; begin
15854: LD_INT 0
15856: PPUSH
// streamModeActive := false ;
15857: LD_ADDR_EXP 40
15861: PUSH
15862: LD_INT 0
15864: ST_TO_ADDR
// normalCounter := 26 ;
15865: LD_ADDR_EXP 41
15869: PUSH
15870: LD_INT 26
15872: ST_TO_ADDR
// hardcoreCounter := 12 ;
15873: LD_ADDR_EXP 42
15877: PUSH
15878: LD_INT 12
15880: ST_TO_ADDR
// sRocket := false ;
15881: LD_ADDR_EXP 45
15885: PUSH
15886: LD_INT 0
15888: ST_TO_ADDR
// sSpeed := false ;
15889: LD_ADDR_EXP 44
15893: PUSH
15894: LD_INT 0
15896: ST_TO_ADDR
// sEngine := false ;
15897: LD_ADDR_EXP 46
15901: PUSH
15902: LD_INT 0
15904: ST_TO_ADDR
// sSpec := false ;
15905: LD_ADDR_EXP 43
15909: PUSH
15910: LD_INT 0
15912: ST_TO_ADDR
// sLevel := false ;
15913: LD_ADDR_EXP 47
15917: PUSH
15918: LD_INT 0
15920: ST_TO_ADDR
// sArmoury := false ;
15921: LD_ADDR_EXP 48
15925: PUSH
15926: LD_INT 0
15928: ST_TO_ADDR
// sRadar := false ;
15929: LD_ADDR_EXP 49
15933: PUSH
15934: LD_INT 0
15936: ST_TO_ADDR
// sBunker := false ;
15937: LD_ADDR_EXP 50
15941: PUSH
15942: LD_INT 0
15944: ST_TO_ADDR
// sHack := false ;
15945: LD_ADDR_EXP 51
15949: PUSH
15950: LD_INT 0
15952: ST_TO_ADDR
// sFire := false ;
15953: LD_ADDR_EXP 52
15957: PUSH
15958: LD_INT 0
15960: ST_TO_ADDR
// sRefresh := false ;
15961: LD_ADDR_EXP 53
15965: PUSH
15966: LD_INT 0
15968: ST_TO_ADDR
// sExp := false ;
15969: LD_ADDR_EXP 54
15973: PUSH
15974: LD_INT 0
15976: ST_TO_ADDR
// sDepot := false ;
15977: LD_ADDR_EXP 55
15981: PUSH
15982: LD_INT 0
15984: ST_TO_ADDR
// sFlag := false ;
15985: LD_ADDR_EXP 56
15989: PUSH
15990: LD_INT 0
15992: ST_TO_ADDR
// sKamikadze := false ;
15993: LD_ADDR_EXP 64
15997: PUSH
15998: LD_INT 0
16000: ST_TO_ADDR
// sTroll := false ;
16001: LD_ADDR_EXP 65
16005: PUSH
16006: LD_INT 0
16008: ST_TO_ADDR
// sSlow := false ;
16009: LD_ADDR_EXP 66
16013: PUSH
16014: LD_INT 0
16016: ST_TO_ADDR
// sLack := false ;
16017: LD_ADDR_EXP 67
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// sTank := false ;
16025: LD_ADDR_EXP 69
16029: PUSH
16030: LD_INT 0
16032: ST_TO_ADDR
// sRemote := false ;
16033: LD_ADDR_EXP 70
16037: PUSH
16038: LD_INT 0
16040: ST_TO_ADDR
// sPowell := false ;
16041: LD_ADDR_EXP 71
16045: PUSH
16046: LD_INT 0
16048: ST_TO_ADDR
// sTeleport := false ;
16049: LD_ADDR_EXP 74
16053: PUSH
16054: LD_INT 0
16056: ST_TO_ADDR
// sOilTower := false ;
16057: LD_ADDR_EXP 76
16061: PUSH
16062: LD_INT 0
16064: ST_TO_ADDR
// sShovel := false ;
16065: LD_ADDR_EXP 77
16069: PUSH
16070: LD_INT 0
16072: ST_TO_ADDR
// sSheik := false ;
16073: LD_ADDR_EXP 78
16077: PUSH
16078: LD_INT 0
16080: ST_TO_ADDR
// sEarthquake := false ;
16081: LD_ADDR_EXP 80
16085: PUSH
16086: LD_INT 0
16088: ST_TO_ADDR
// sAI := false ;
16089: LD_ADDR_EXP 81
16093: PUSH
16094: LD_INT 0
16096: ST_TO_ADDR
// sCargo := false ;
16097: LD_ADDR_EXP 84
16101: PUSH
16102: LD_INT 0
16104: ST_TO_ADDR
// sDLaser := false ;
16105: LD_ADDR_EXP 85
16109: PUSH
16110: LD_INT 0
16112: ST_TO_ADDR
// sExchange := false ;
16113: LD_ADDR_EXP 86
16117: PUSH
16118: LD_INT 0
16120: ST_TO_ADDR
// sFac := false ;
16121: LD_ADDR_EXP 87
16125: PUSH
16126: LD_INT 0
16128: ST_TO_ADDR
// sPower := false ;
16129: LD_ADDR_EXP 88
16133: PUSH
16134: LD_INT 0
16136: ST_TO_ADDR
// sRandom := false ;
16137: LD_ADDR_EXP 89
16141: PUSH
16142: LD_INT 0
16144: ST_TO_ADDR
// sShield := false ;
16145: LD_ADDR_EXP 90
16149: PUSH
16150: LD_INT 0
16152: ST_TO_ADDR
// sTime := false ;
16153: LD_ADDR_EXP 91
16157: PUSH
16158: LD_INT 0
16160: ST_TO_ADDR
// sTools := false ;
16161: LD_ADDR_EXP 92
16165: PUSH
16166: LD_INT 0
16168: ST_TO_ADDR
// sSold := false ;
16169: LD_ADDR_EXP 57
16173: PUSH
16174: LD_INT 0
16176: ST_TO_ADDR
// sDiff := false ;
16177: LD_ADDR_EXP 58
16181: PUSH
16182: LD_INT 0
16184: ST_TO_ADDR
// sFog := false ;
16185: LD_ADDR_EXP 61
16189: PUSH
16190: LD_INT 0
16192: ST_TO_ADDR
// sReset := false ;
16193: LD_ADDR_EXP 62
16197: PUSH
16198: LD_INT 0
16200: ST_TO_ADDR
// sSun := false ;
16201: LD_ADDR_EXP 63
16205: PUSH
16206: LD_INT 0
16208: ST_TO_ADDR
// sTiger := false ;
16209: LD_ADDR_EXP 59
16213: PUSH
16214: LD_INT 0
16216: ST_TO_ADDR
// sBomb := false ;
16217: LD_ADDR_EXP 60
16221: PUSH
16222: LD_INT 0
16224: ST_TO_ADDR
// sWound := false ;
16225: LD_ADDR_EXP 68
16229: PUSH
16230: LD_INT 0
16232: ST_TO_ADDR
// sBetray := false ;
16233: LD_ADDR_EXP 72
16237: PUSH
16238: LD_INT 0
16240: ST_TO_ADDR
// sContamin := false ;
16241: LD_ADDR_EXP 73
16245: PUSH
16246: LD_INT 0
16248: ST_TO_ADDR
// sOil := false ;
16249: LD_ADDR_EXP 75
16253: PUSH
16254: LD_INT 0
16256: ST_TO_ADDR
// sStu := false ;
16257: LD_ADDR_EXP 79
16261: PUSH
16262: LD_INT 0
16264: ST_TO_ADDR
// sBazooka := false ;
16265: LD_ADDR_EXP 82
16269: PUSH
16270: LD_INT 0
16272: ST_TO_ADDR
// sMortar := false ;
16273: LD_ADDR_EXP 83
16277: PUSH
16278: LD_INT 0
16280: ST_TO_ADDR
// sRanger := false ;
16281: LD_ADDR_EXP 93
16285: PUSH
16286: LD_INT 0
16288: ST_TO_ADDR
// end ;
16289: LD_VAR 0 1
16293: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
16294: LD_INT 0
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
// result := [ ] ;
16301: LD_ADDR_VAR 0 1
16305: PUSH
16306: EMPTY
16307: ST_TO_ADDR
// if campaign_id = 1 then
16308: LD_OWVAR 69
16312: PUSH
16313: LD_INT 1
16315: EQUAL
16316: IFFALSE 19252
// begin case mission_number of 1 :
16318: LD_OWVAR 70
16322: PUSH
16323: LD_INT 1
16325: DOUBLE
16326: EQUAL
16327: IFTRUE 16331
16329: GO 16395
16331: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
16332: LD_ADDR_VAR 0 1
16336: PUSH
16337: LD_INT 2
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: LD_INT 11
16345: PUSH
16346: LD_INT 12
16348: PUSH
16349: LD_INT 15
16351: PUSH
16352: LD_INT 16
16354: PUSH
16355: LD_INT 22
16357: PUSH
16358: LD_INT 23
16360: PUSH
16361: LD_INT 26
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: PUSH
16375: LD_INT 101
16377: PUSH
16378: LD_INT 102
16380: PUSH
16381: LD_INT 106
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: LIST
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: ST_TO_ADDR
16393: GO 19252
16395: LD_INT 2
16397: DOUBLE
16398: EQUAL
16399: IFTRUE 16403
16401: GO 16475
16403: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
16404: LD_ADDR_VAR 0 1
16408: PUSH
16409: LD_INT 2
16411: PUSH
16412: LD_INT 4
16414: PUSH
16415: LD_INT 11
16417: PUSH
16418: LD_INT 12
16420: PUSH
16421: LD_INT 15
16423: PUSH
16424: LD_INT 16
16426: PUSH
16427: LD_INT 22
16429: PUSH
16430: LD_INT 23
16432: PUSH
16433: LD_INT 26
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: LIST
16446: PUSH
16447: LD_INT 101
16449: PUSH
16450: LD_INT 102
16452: PUSH
16453: LD_INT 105
16455: PUSH
16456: LD_INT 106
16458: PUSH
16459: LD_INT 108
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: LIST
16467: LIST
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: ST_TO_ADDR
16473: GO 19252
16475: LD_INT 3
16477: DOUBLE
16478: EQUAL
16479: IFTRUE 16483
16481: GO 16559
16483: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
16484: LD_ADDR_VAR 0 1
16488: PUSH
16489: LD_INT 2
16491: PUSH
16492: LD_INT 4
16494: PUSH
16495: LD_INT 5
16497: PUSH
16498: LD_INT 11
16500: PUSH
16501: LD_INT 12
16503: PUSH
16504: LD_INT 15
16506: PUSH
16507: LD_INT 16
16509: PUSH
16510: LD_INT 22
16512: PUSH
16513: LD_INT 26
16515: PUSH
16516: LD_INT 36
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 101
16533: PUSH
16534: LD_INT 102
16536: PUSH
16537: LD_INT 105
16539: PUSH
16540: LD_INT 106
16542: PUSH
16543: LD_INT 108
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: LIST
16550: LIST
16551: LIST
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: ST_TO_ADDR
16557: GO 19252
16559: LD_INT 4
16561: DOUBLE
16562: EQUAL
16563: IFTRUE 16567
16565: GO 16651
16567: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
16568: LD_ADDR_VAR 0 1
16572: PUSH
16573: LD_INT 2
16575: PUSH
16576: LD_INT 4
16578: PUSH
16579: LD_INT 5
16581: PUSH
16582: LD_INT 8
16584: PUSH
16585: LD_INT 11
16587: PUSH
16588: LD_INT 12
16590: PUSH
16591: LD_INT 15
16593: PUSH
16594: LD_INT 16
16596: PUSH
16597: LD_INT 22
16599: PUSH
16600: LD_INT 23
16602: PUSH
16603: LD_INT 26
16605: PUSH
16606: LD_INT 36
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: LIST
16621: LIST
16622: PUSH
16623: LD_INT 101
16625: PUSH
16626: LD_INT 102
16628: PUSH
16629: LD_INT 105
16631: PUSH
16632: LD_INT 106
16634: PUSH
16635: LD_INT 108
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: LIST
16642: LIST
16643: LIST
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: ST_TO_ADDR
16649: GO 19252
16651: LD_INT 5
16653: DOUBLE
16654: EQUAL
16655: IFTRUE 16659
16657: GO 16759
16659: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
16660: LD_ADDR_VAR 0 1
16664: PUSH
16665: LD_INT 2
16667: PUSH
16668: LD_INT 4
16670: PUSH
16671: LD_INT 5
16673: PUSH
16674: LD_INT 6
16676: PUSH
16677: LD_INT 8
16679: PUSH
16680: LD_INT 11
16682: PUSH
16683: LD_INT 12
16685: PUSH
16686: LD_INT 15
16688: PUSH
16689: LD_INT 16
16691: PUSH
16692: LD_INT 22
16694: PUSH
16695: LD_INT 23
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 26
16703: PUSH
16704: LD_INT 36
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 101
16725: PUSH
16726: LD_INT 102
16728: PUSH
16729: LD_INT 105
16731: PUSH
16732: LD_INT 106
16734: PUSH
16735: LD_INT 108
16737: PUSH
16738: LD_INT 109
16740: PUSH
16741: LD_INT 112
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: ST_TO_ADDR
16757: GO 19252
16759: LD_INT 6
16761: DOUBLE
16762: EQUAL
16763: IFTRUE 16767
16765: GO 16887
16767: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_INT 2
16775: PUSH
16776: LD_INT 4
16778: PUSH
16779: LD_INT 5
16781: PUSH
16782: LD_INT 6
16784: PUSH
16785: LD_INT 8
16787: PUSH
16788: LD_INT 11
16790: PUSH
16791: LD_INT 12
16793: PUSH
16794: LD_INT 15
16796: PUSH
16797: LD_INT 16
16799: PUSH
16800: LD_INT 20
16802: PUSH
16803: LD_INT 21
16805: PUSH
16806: LD_INT 22
16808: PUSH
16809: LD_INT 23
16811: PUSH
16812: LD_INT 25
16814: PUSH
16815: LD_INT 26
16817: PUSH
16818: LD_INT 30
16820: PUSH
16821: LD_INT 31
16823: PUSH
16824: LD_INT 32
16826: PUSH
16827: LD_INT 36
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: LIST
16850: PUSH
16851: LD_INT 101
16853: PUSH
16854: LD_INT 102
16856: PUSH
16857: LD_INT 105
16859: PUSH
16860: LD_INT 106
16862: PUSH
16863: LD_INT 108
16865: PUSH
16866: LD_INT 109
16868: PUSH
16869: LD_INT 112
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: LIST
16878: LIST
16879: LIST
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: ST_TO_ADDR
16885: GO 19252
16887: LD_INT 7
16889: DOUBLE
16890: EQUAL
16891: IFTRUE 16895
16893: GO 16995
16895: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
16896: LD_ADDR_VAR 0 1
16900: PUSH
16901: LD_INT 2
16903: PUSH
16904: LD_INT 4
16906: PUSH
16907: LD_INT 5
16909: PUSH
16910: LD_INT 7
16912: PUSH
16913: LD_INT 11
16915: PUSH
16916: LD_INT 12
16918: PUSH
16919: LD_INT 15
16921: PUSH
16922: LD_INT 16
16924: PUSH
16925: LD_INT 20
16927: PUSH
16928: LD_INT 21
16930: PUSH
16931: LD_INT 22
16933: PUSH
16934: LD_INT 23
16936: PUSH
16937: LD_INT 25
16939: PUSH
16940: LD_INT 26
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 101
16961: PUSH
16962: LD_INT 102
16964: PUSH
16965: LD_INT 103
16967: PUSH
16968: LD_INT 105
16970: PUSH
16971: LD_INT 106
16973: PUSH
16974: LD_INT 108
16976: PUSH
16977: LD_INT 112
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: ST_TO_ADDR
16993: GO 19252
16995: LD_INT 8
16997: DOUBLE
16998: EQUAL
16999: IFTRUE 17003
17001: GO 17131
17003: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
17004: LD_ADDR_VAR 0 1
17008: PUSH
17009: LD_INT 2
17011: PUSH
17012: LD_INT 4
17014: PUSH
17015: LD_INT 5
17017: PUSH
17018: LD_INT 6
17020: PUSH
17021: LD_INT 7
17023: PUSH
17024: LD_INT 8
17026: PUSH
17027: LD_INT 11
17029: PUSH
17030: LD_INT 12
17032: PUSH
17033: LD_INT 15
17035: PUSH
17036: LD_INT 16
17038: PUSH
17039: LD_INT 20
17041: PUSH
17042: LD_INT 21
17044: PUSH
17045: LD_INT 22
17047: PUSH
17048: LD_INT 23
17050: PUSH
17051: LD_INT 25
17053: PUSH
17054: LD_INT 26
17056: PUSH
17057: LD_INT 30
17059: PUSH
17060: LD_INT 31
17062: PUSH
17063: LD_INT 32
17065: PUSH
17066: LD_INT 36
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: LIST
17090: PUSH
17091: LD_INT 101
17093: PUSH
17094: LD_INT 102
17096: PUSH
17097: LD_INT 103
17099: PUSH
17100: LD_INT 105
17102: PUSH
17103: LD_INT 106
17105: PUSH
17106: LD_INT 108
17108: PUSH
17109: LD_INT 109
17111: PUSH
17112: LD_INT 112
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: ST_TO_ADDR
17129: GO 19252
17131: LD_INT 9
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17139
17137: GO 17275
17139: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
17140: LD_ADDR_VAR 0 1
17144: PUSH
17145: LD_INT 2
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: LD_INT 7
17159: PUSH
17160: LD_INT 8
17162: PUSH
17163: LD_INT 11
17165: PUSH
17166: LD_INT 12
17168: PUSH
17169: LD_INT 15
17171: PUSH
17172: LD_INT 16
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: LD_INT 21
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 23
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 26
17192: PUSH
17193: LD_INT 28
17195: PUSH
17196: LD_INT 30
17198: PUSH
17199: LD_INT 31
17201: PUSH
17202: LD_INT 32
17204: PUSH
17205: LD_INT 36
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 101
17233: PUSH
17234: LD_INT 102
17236: PUSH
17237: LD_INT 103
17239: PUSH
17240: LD_INT 105
17242: PUSH
17243: LD_INT 106
17245: PUSH
17246: LD_INT 108
17248: PUSH
17249: LD_INT 109
17251: PUSH
17252: LD_INT 112
17254: PUSH
17255: LD_INT 114
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: LIST
17267: LIST
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: ST_TO_ADDR
17273: GO 19252
17275: LD_INT 10
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17467
17283: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
17284: LD_ADDR_VAR 0 1
17288: PUSH
17289: LD_INT 2
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: LD_INT 5
17297: PUSH
17298: LD_INT 6
17300: PUSH
17301: LD_INT 7
17303: PUSH
17304: LD_INT 8
17306: PUSH
17307: LD_INT 9
17309: PUSH
17310: LD_INT 10
17312: PUSH
17313: LD_INT 11
17315: PUSH
17316: LD_INT 12
17318: PUSH
17319: LD_INT 13
17321: PUSH
17322: LD_INT 14
17324: PUSH
17325: LD_INT 15
17327: PUSH
17328: LD_INT 16
17330: PUSH
17331: LD_INT 17
17333: PUSH
17334: LD_INT 18
17336: PUSH
17337: LD_INT 19
17339: PUSH
17340: LD_INT 20
17342: PUSH
17343: LD_INT 21
17345: PUSH
17346: LD_INT 22
17348: PUSH
17349: LD_INT 23
17351: PUSH
17352: LD_INT 24
17354: PUSH
17355: LD_INT 25
17357: PUSH
17358: LD_INT 26
17360: PUSH
17361: LD_INT 28
17363: PUSH
17364: LD_INT 30
17366: PUSH
17367: LD_INT 31
17369: PUSH
17370: LD_INT 32
17372: PUSH
17373: LD_INT 36
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: LIST
17406: PUSH
17407: LD_INT 101
17409: PUSH
17410: LD_INT 102
17412: PUSH
17413: LD_INT 103
17415: PUSH
17416: LD_INT 104
17418: PUSH
17419: LD_INT 105
17421: PUSH
17422: LD_INT 106
17424: PUSH
17425: LD_INT 107
17427: PUSH
17428: LD_INT 108
17430: PUSH
17431: LD_INT 109
17433: PUSH
17434: LD_INT 110
17436: PUSH
17437: LD_INT 111
17439: PUSH
17440: LD_INT 112
17442: PUSH
17443: LD_INT 114
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: LIST
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: ST_TO_ADDR
17465: GO 19252
17467: LD_INT 11
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17667
17475: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
17476: LD_ADDR_VAR 0 1
17480: PUSH
17481: LD_INT 2
17483: PUSH
17484: LD_INT 3
17486: PUSH
17487: LD_INT 4
17489: PUSH
17490: LD_INT 5
17492: PUSH
17493: LD_INT 6
17495: PUSH
17496: LD_INT 7
17498: PUSH
17499: LD_INT 8
17501: PUSH
17502: LD_INT 9
17504: PUSH
17505: LD_INT 10
17507: PUSH
17508: LD_INT 11
17510: PUSH
17511: LD_INT 12
17513: PUSH
17514: LD_INT 13
17516: PUSH
17517: LD_INT 14
17519: PUSH
17520: LD_INT 15
17522: PUSH
17523: LD_INT 16
17525: PUSH
17526: LD_INT 17
17528: PUSH
17529: LD_INT 18
17531: PUSH
17532: LD_INT 19
17534: PUSH
17535: LD_INT 20
17537: PUSH
17538: LD_INT 21
17540: PUSH
17541: LD_INT 22
17543: PUSH
17544: LD_INT 23
17546: PUSH
17547: LD_INT 24
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 26
17555: PUSH
17556: LD_INT 28
17558: PUSH
17559: LD_INT 30
17561: PUSH
17562: LD_INT 31
17564: PUSH
17565: LD_INT 32
17567: PUSH
17568: LD_INT 34
17570: PUSH
17571: LD_INT 36
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: LIST
17593: LIST
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 101
17609: PUSH
17610: LD_INT 102
17612: PUSH
17613: LD_INT 103
17615: PUSH
17616: LD_INT 104
17618: PUSH
17619: LD_INT 105
17621: PUSH
17622: LD_INT 106
17624: PUSH
17625: LD_INT 107
17627: PUSH
17628: LD_INT 108
17630: PUSH
17631: LD_INT 109
17633: PUSH
17634: LD_INT 110
17636: PUSH
17637: LD_INT 111
17639: PUSH
17640: LD_INT 112
17642: PUSH
17643: LD_INT 114
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: LIST
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: ST_TO_ADDR
17665: GO 19252
17667: LD_INT 12
17669: DOUBLE
17670: EQUAL
17671: IFTRUE 17675
17673: GO 17883
17675: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
17676: LD_ADDR_VAR 0 1
17680: PUSH
17681: LD_INT 1
17683: PUSH
17684: LD_INT 2
17686: PUSH
17687: LD_INT 3
17689: PUSH
17690: LD_INT 4
17692: PUSH
17693: LD_INT 5
17695: PUSH
17696: LD_INT 6
17698: PUSH
17699: LD_INT 7
17701: PUSH
17702: LD_INT 8
17704: PUSH
17705: LD_INT 9
17707: PUSH
17708: LD_INT 10
17710: PUSH
17711: LD_INT 11
17713: PUSH
17714: LD_INT 12
17716: PUSH
17717: LD_INT 13
17719: PUSH
17720: LD_INT 14
17722: PUSH
17723: LD_INT 15
17725: PUSH
17726: LD_INT 16
17728: PUSH
17729: LD_INT 17
17731: PUSH
17732: LD_INT 18
17734: PUSH
17735: LD_INT 19
17737: PUSH
17738: LD_INT 20
17740: PUSH
17741: LD_INT 21
17743: PUSH
17744: LD_INT 22
17746: PUSH
17747: LD_INT 23
17749: PUSH
17750: LD_INT 24
17752: PUSH
17753: LD_INT 25
17755: PUSH
17756: LD_INT 26
17758: PUSH
17759: LD_INT 27
17761: PUSH
17762: LD_INT 28
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 31
17770: PUSH
17771: LD_INT 32
17773: PUSH
17774: LD_INT 33
17776: PUSH
17777: LD_INT 34
17779: PUSH
17780: LD_INT 36
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 101
17821: PUSH
17822: LD_INT 102
17824: PUSH
17825: LD_INT 103
17827: PUSH
17828: LD_INT 104
17830: PUSH
17831: LD_INT 105
17833: PUSH
17834: LD_INT 106
17836: PUSH
17837: LD_INT 107
17839: PUSH
17840: LD_INT 108
17842: PUSH
17843: LD_INT 109
17845: PUSH
17846: LD_INT 110
17848: PUSH
17849: LD_INT 111
17851: PUSH
17852: LD_INT 112
17854: PUSH
17855: LD_INT 113
17857: PUSH
17858: LD_INT 114
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: LIST
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: ST_TO_ADDR
17881: GO 19252
17883: LD_INT 13
17885: DOUBLE
17886: EQUAL
17887: IFTRUE 17891
17889: GO 18087
17891: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
17892: LD_ADDR_VAR 0 1
17896: PUSH
17897: LD_INT 1
17899: PUSH
17900: LD_INT 2
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 4
17908: PUSH
17909: LD_INT 5
17911: PUSH
17912: LD_INT 8
17914: PUSH
17915: LD_INT 9
17917: PUSH
17918: LD_INT 10
17920: PUSH
17921: LD_INT 11
17923: PUSH
17924: LD_INT 12
17926: PUSH
17927: LD_INT 14
17929: PUSH
17930: LD_INT 15
17932: PUSH
17933: LD_INT 16
17935: PUSH
17936: LD_INT 17
17938: PUSH
17939: LD_INT 18
17941: PUSH
17942: LD_INT 19
17944: PUSH
17945: LD_INT 20
17947: PUSH
17948: LD_INT 21
17950: PUSH
17951: LD_INT 22
17953: PUSH
17954: LD_INT 23
17956: PUSH
17957: LD_INT 24
17959: PUSH
17960: LD_INT 25
17962: PUSH
17963: LD_INT 26
17965: PUSH
17966: LD_INT 27
17968: PUSH
17969: LD_INT 28
17971: PUSH
17972: LD_INT 30
17974: PUSH
17975: LD_INT 31
17977: PUSH
17978: LD_INT 32
17980: PUSH
17981: LD_INT 33
17983: PUSH
17984: LD_INT 34
17986: PUSH
17987: LD_INT 36
17989: PUSH
17990: EMPTY
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 101
18025: PUSH
18026: LD_INT 102
18028: PUSH
18029: LD_INT 103
18031: PUSH
18032: LD_INT 104
18034: PUSH
18035: LD_INT 105
18037: PUSH
18038: LD_INT 106
18040: PUSH
18041: LD_INT 107
18043: PUSH
18044: LD_INT 108
18046: PUSH
18047: LD_INT 109
18049: PUSH
18050: LD_INT 110
18052: PUSH
18053: LD_INT 111
18055: PUSH
18056: LD_INT 112
18058: PUSH
18059: LD_INT 113
18061: PUSH
18062: LD_INT 114
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: LIST
18069: LIST
18070: LIST
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: LIST
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: ST_TO_ADDR
18085: GO 19252
18087: LD_INT 14
18089: DOUBLE
18090: EQUAL
18091: IFTRUE 18095
18093: GO 18307
18095: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
18096: LD_ADDR_VAR 0 1
18100: PUSH
18101: LD_INT 1
18103: PUSH
18104: LD_INT 2
18106: PUSH
18107: LD_INT 3
18109: PUSH
18110: LD_INT 4
18112: PUSH
18113: LD_INT 5
18115: PUSH
18116: LD_INT 6
18118: PUSH
18119: LD_INT 7
18121: PUSH
18122: LD_INT 8
18124: PUSH
18125: LD_INT 9
18127: PUSH
18128: LD_INT 10
18130: PUSH
18131: LD_INT 11
18133: PUSH
18134: LD_INT 12
18136: PUSH
18137: LD_INT 13
18139: PUSH
18140: LD_INT 14
18142: PUSH
18143: LD_INT 15
18145: PUSH
18146: LD_INT 16
18148: PUSH
18149: LD_INT 17
18151: PUSH
18152: LD_INT 18
18154: PUSH
18155: LD_INT 19
18157: PUSH
18158: LD_INT 20
18160: PUSH
18161: LD_INT 21
18163: PUSH
18164: LD_INT 22
18166: PUSH
18167: LD_INT 23
18169: PUSH
18170: LD_INT 24
18172: PUSH
18173: LD_INT 25
18175: PUSH
18176: LD_INT 26
18178: PUSH
18179: LD_INT 27
18181: PUSH
18182: LD_INT 28
18184: PUSH
18185: LD_INT 29
18187: PUSH
18188: LD_INT 30
18190: PUSH
18191: LD_INT 31
18193: PUSH
18194: LD_INT 32
18196: PUSH
18197: LD_INT 33
18199: PUSH
18200: LD_INT 34
18202: PUSH
18203: LD_INT 36
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: PUSH
18243: LD_INT 101
18245: PUSH
18246: LD_INT 102
18248: PUSH
18249: LD_INT 103
18251: PUSH
18252: LD_INT 104
18254: PUSH
18255: LD_INT 105
18257: PUSH
18258: LD_INT 106
18260: PUSH
18261: LD_INT 107
18263: PUSH
18264: LD_INT 108
18266: PUSH
18267: LD_INT 109
18269: PUSH
18270: LD_INT 110
18272: PUSH
18273: LD_INT 111
18275: PUSH
18276: LD_INT 112
18278: PUSH
18279: LD_INT 113
18281: PUSH
18282: LD_INT 114
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: LIST
18299: LIST
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: ST_TO_ADDR
18305: GO 19252
18307: LD_INT 15
18309: DOUBLE
18310: EQUAL
18311: IFTRUE 18315
18313: GO 18527
18315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
18316: LD_ADDR_VAR 0 1
18320: PUSH
18321: LD_INT 1
18323: PUSH
18324: LD_INT 2
18326: PUSH
18327: LD_INT 3
18329: PUSH
18330: LD_INT 4
18332: PUSH
18333: LD_INT 5
18335: PUSH
18336: LD_INT 6
18338: PUSH
18339: LD_INT 7
18341: PUSH
18342: LD_INT 8
18344: PUSH
18345: LD_INT 9
18347: PUSH
18348: LD_INT 10
18350: PUSH
18351: LD_INT 11
18353: PUSH
18354: LD_INT 12
18356: PUSH
18357: LD_INT 13
18359: PUSH
18360: LD_INT 14
18362: PUSH
18363: LD_INT 15
18365: PUSH
18366: LD_INT 16
18368: PUSH
18369: LD_INT 17
18371: PUSH
18372: LD_INT 18
18374: PUSH
18375: LD_INT 19
18377: PUSH
18378: LD_INT 20
18380: PUSH
18381: LD_INT 21
18383: PUSH
18384: LD_INT 22
18386: PUSH
18387: LD_INT 23
18389: PUSH
18390: LD_INT 24
18392: PUSH
18393: LD_INT 25
18395: PUSH
18396: LD_INT 26
18398: PUSH
18399: LD_INT 27
18401: PUSH
18402: LD_INT 28
18404: PUSH
18405: LD_INT 29
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 31
18413: PUSH
18414: LD_INT 32
18416: PUSH
18417: LD_INT 33
18419: PUSH
18420: LD_INT 34
18422: PUSH
18423: LD_INT 36
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: PUSH
18463: LD_INT 101
18465: PUSH
18466: LD_INT 102
18468: PUSH
18469: LD_INT 103
18471: PUSH
18472: LD_INT 104
18474: PUSH
18475: LD_INT 105
18477: PUSH
18478: LD_INT 106
18480: PUSH
18481: LD_INT 107
18483: PUSH
18484: LD_INT 108
18486: PUSH
18487: LD_INT 109
18489: PUSH
18490: LD_INT 110
18492: PUSH
18493: LD_INT 111
18495: PUSH
18496: LD_INT 112
18498: PUSH
18499: LD_INT 113
18501: PUSH
18502: LD_INT 114
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: LIST
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: ST_TO_ADDR
18525: GO 19252
18527: LD_INT 16
18529: DOUBLE
18530: EQUAL
18531: IFTRUE 18535
18533: GO 18659
18535: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
18536: LD_ADDR_VAR 0 1
18540: PUSH
18541: LD_INT 2
18543: PUSH
18544: LD_INT 4
18546: PUSH
18547: LD_INT 5
18549: PUSH
18550: LD_INT 7
18552: PUSH
18553: LD_INT 11
18555: PUSH
18556: LD_INT 12
18558: PUSH
18559: LD_INT 15
18561: PUSH
18562: LD_INT 16
18564: PUSH
18565: LD_INT 20
18567: PUSH
18568: LD_INT 21
18570: PUSH
18571: LD_INT 22
18573: PUSH
18574: LD_INT 23
18576: PUSH
18577: LD_INT 25
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: LD_INT 30
18585: PUSH
18586: LD_INT 31
18588: PUSH
18589: LD_INT 32
18591: PUSH
18592: LD_INT 33
18594: PUSH
18595: LD_INT 34
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: PUSH
18619: LD_INT 101
18621: PUSH
18622: LD_INT 102
18624: PUSH
18625: LD_INT 103
18627: PUSH
18628: LD_INT 106
18630: PUSH
18631: LD_INT 108
18633: PUSH
18634: LD_INT 112
18636: PUSH
18637: LD_INT 113
18639: PUSH
18640: LD_INT 114
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: LIST
18647: LIST
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: ST_TO_ADDR
18657: GO 19252
18659: LD_INT 17
18661: DOUBLE
18662: EQUAL
18663: IFTRUE 18667
18665: GO 18879
18667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
18668: LD_ADDR_VAR 0 1
18672: PUSH
18673: LD_INT 1
18675: PUSH
18676: LD_INT 2
18678: PUSH
18679: LD_INT 3
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: LD_INT 5
18687: PUSH
18688: LD_INT 6
18690: PUSH
18691: LD_INT 7
18693: PUSH
18694: LD_INT 8
18696: PUSH
18697: LD_INT 9
18699: PUSH
18700: LD_INT 10
18702: PUSH
18703: LD_INT 11
18705: PUSH
18706: LD_INT 12
18708: PUSH
18709: LD_INT 13
18711: PUSH
18712: LD_INT 14
18714: PUSH
18715: LD_INT 15
18717: PUSH
18718: LD_INT 16
18720: PUSH
18721: LD_INT 17
18723: PUSH
18724: LD_INT 18
18726: PUSH
18727: LD_INT 19
18729: PUSH
18730: LD_INT 20
18732: PUSH
18733: LD_INT 21
18735: PUSH
18736: LD_INT 22
18738: PUSH
18739: LD_INT 23
18741: PUSH
18742: LD_INT 24
18744: PUSH
18745: LD_INT 25
18747: PUSH
18748: LD_INT 26
18750: PUSH
18751: LD_INT 27
18753: PUSH
18754: LD_INT 28
18756: PUSH
18757: LD_INT 29
18759: PUSH
18760: LD_INT 30
18762: PUSH
18763: LD_INT 31
18765: PUSH
18766: LD_INT 32
18768: PUSH
18769: LD_INT 33
18771: PUSH
18772: LD_INT 34
18774: PUSH
18775: LD_INT 36
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 101
18817: PUSH
18818: LD_INT 102
18820: PUSH
18821: LD_INT 103
18823: PUSH
18824: LD_INT 104
18826: PUSH
18827: LD_INT 105
18829: PUSH
18830: LD_INT 106
18832: PUSH
18833: LD_INT 107
18835: PUSH
18836: LD_INT 108
18838: PUSH
18839: LD_INT 109
18841: PUSH
18842: LD_INT 110
18844: PUSH
18845: LD_INT 111
18847: PUSH
18848: LD_INT 112
18850: PUSH
18851: LD_INT 113
18853: PUSH
18854: LD_INT 114
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: ST_TO_ADDR
18877: GO 19252
18879: LD_INT 18
18881: DOUBLE
18882: EQUAL
18883: IFTRUE 18887
18885: GO 19023
18887: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
18888: LD_ADDR_VAR 0 1
18892: PUSH
18893: LD_INT 2
18895: PUSH
18896: LD_INT 4
18898: PUSH
18899: LD_INT 5
18901: PUSH
18902: LD_INT 7
18904: PUSH
18905: LD_INT 11
18907: PUSH
18908: LD_INT 12
18910: PUSH
18911: LD_INT 15
18913: PUSH
18914: LD_INT 16
18916: PUSH
18917: LD_INT 20
18919: PUSH
18920: LD_INT 21
18922: PUSH
18923: LD_INT 22
18925: PUSH
18926: LD_INT 23
18928: PUSH
18929: LD_INT 25
18931: PUSH
18932: LD_INT 26
18934: PUSH
18935: LD_INT 30
18937: PUSH
18938: LD_INT 31
18940: PUSH
18941: LD_INT 32
18943: PUSH
18944: LD_INT 33
18946: PUSH
18947: LD_INT 34
18949: PUSH
18950: LD_INT 35
18952: PUSH
18953: LD_INT 36
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: LIST
18970: LIST
18971: LIST
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 101
18981: PUSH
18982: LD_INT 102
18984: PUSH
18985: LD_INT 103
18987: PUSH
18988: LD_INT 106
18990: PUSH
18991: LD_INT 108
18993: PUSH
18994: LD_INT 112
18996: PUSH
18997: LD_INT 113
18999: PUSH
19000: LD_INT 114
19002: PUSH
19003: LD_INT 115
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: PUSH
19017: EMPTY
19018: LIST
19019: LIST
19020: ST_TO_ADDR
19021: GO 19252
19023: LD_INT 19
19025: DOUBLE
19026: EQUAL
19027: IFTRUE 19031
19029: GO 19251
19031: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
19032: LD_ADDR_VAR 0 1
19036: PUSH
19037: LD_INT 1
19039: PUSH
19040: LD_INT 2
19042: PUSH
19043: LD_INT 3
19045: PUSH
19046: LD_INT 4
19048: PUSH
19049: LD_INT 5
19051: PUSH
19052: LD_INT 6
19054: PUSH
19055: LD_INT 7
19057: PUSH
19058: LD_INT 8
19060: PUSH
19061: LD_INT 9
19063: PUSH
19064: LD_INT 10
19066: PUSH
19067: LD_INT 11
19069: PUSH
19070: LD_INT 12
19072: PUSH
19073: LD_INT 13
19075: PUSH
19076: LD_INT 14
19078: PUSH
19079: LD_INT 15
19081: PUSH
19082: LD_INT 16
19084: PUSH
19085: LD_INT 17
19087: PUSH
19088: LD_INT 18
19090: PUSH
19091: LD_INT 19
19093: PUSH
19094: LD_INT 20
19096: PUSH
19097: LD_INT 21
19099: PUSH
19100: LD_INT 22
19102: PUSH
19103: LD_INT 23
19105: PUSH
19106: LD_INT 24
19108: PUSH
19109: LD_INT 25
19111: PUSH
19112: LD_INT 26
19114: PUSH
19115: LD_INT 27
19117: PUSH
19118: LD_INT 28
19120: PUSH
19121: LD_INT 29
19123: PUSH
19124: LD_INT 30
19126: PUSH
19127: LD_INT 31
19129: PUSH
19130: LD_INT 32
19132: PUSH
19133: LD_INT 33
19135: PUSH
19136: LD_INT 34
19138: PUSH
19139: LD_INT 35
19141: PUSH
19142: LD_INT 36
19144: PUSH
19145: EMPTY
19146: LIST
19147: LIST
19148: LIST
19149: LIST
19150: LIST
19151: LIST
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: LIST
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: PUSH
19183: LD_INT 101
19185: PUSH
19186: LD_INT 102
19188: PUSH
19189: LD_INT 103
19191: PUSH
19192: LD_INT 104
19194: PUSH
19195: LD_INT 105
19197: PUSH
19198: LD_INT 106
19200: PUSH
19201: LD_INT 107
19203: PUSH
19204: LD_INT 108
19206: PUSH
19207: LD_INT 109
19209: PUSH
19210: LD_INT 110
19212: PUSH
19213: LD_INT 111
19215: PUSH
19216: LD_INT 112
19218: PUSH
19219: LD_INT 113
19221: PUSH
19222: LD_INT 114
19224: PUSH
19225: LD_INT 115
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: LIST
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: LIST
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 19252
19251: POP
// end ; if result then
19252: LD_VAR 0 1
19256: IFFALSE 19545
// begin normal :=  ;
19258: LD_ADDR_VAR 0 3
19262: PUSH
19263: LD_STRING 
19265: ST_TO_ADDR
// hardcore :=  ;
19266: LD_ADDR_VAR 0 4
19270: PUSH
19271: LD_STRING 
19273: ST_TO_ADDR
// for i = 1 to normalCounter do
19274: LD_ADDR_VAR 0 5
19278: PUSH
19279: DOUBLE
19280: LD_INT 1
19282: DEC
19283: ST_TO_ADDR
19284: LD_EXP 41
19288: PUSH
19289: FOR_TO
19290: IFFALSE 19391
// begin tmp := 0 ;
19292: LD_ADDR_VAR 0 2
19296: PUSH
19297: LD_STRING 0
19299: ST_TO_ADDR
// if result [ 1 ] then
19300: LD_VAR 0 1
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: IFFALSE 19373
// if result [ 1 ] [ 1 ] = i then
19310: LD_VAR 0 1
19314: PUSH
19315: LD_INT 1
19317: ARRAY
19318: PUSH
19319: LD_INT 1
19321: ARRAY
19322: PUSH
19323: LD_VAR 0 5
19327: EQUAL
19328: IFFALSE 19373
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
19330: LD_ADDR_VAR 0 1
19334: PUSH
19335: LD_VAR 0 1
19339: PPUSH
19340: LD_INT 1
19342: PPUSH
19343: LD_VAR 0 1
19347: PUSH
19348: LD_INT 1
19350: ARRAY
19351: PPUSH
19352: LD_INT 1
19354: PPUSH
19355: CALL_OW 3
19359: PPUSH
19360: CALL_OW 1
19364: ST_TO_ADDR
// tmp := 1 ;
19365: LD_ADDR_VAR 0 2
19369: PUSH
19370: LD_STRING 1
19372: ST_TO_ADDR
// end ; normal := normal & tmp ;
19373: LD_ADDR_VAR 0 3
19377: PUSH
19378: LD_VAR 0 3
19382: PUSH
19383: LD_VAR 0 2
19387: STR
19388: ST_TO_ADDR
// end ;
19389: GO 19289
19391: POP
19392: POP
// for i = 1 to hardcoreCounter do
19393: LD_ADDR_VAR 0 5
19397: PUSH
19398: DOUBLE
19399: LD_INT 1
19401: DEC
19402: ST_TO_ADDR
19403: LD_EXP 42
19407: PUSH
19408: FOR_TO
19409: IFFALSE 19514
// begin tmp := 0 ;
19411: LD_ADDR_VAR 0 2
19415: PUSH
19416: LD_STRING 0
19418: ST_TO_ADDR
// if result [ 2 ] then
19419: LD_VAR 0 1
19423: PUSH
19424: LD_INT 2
19426: ARRAY
19427: IFFALSE 19496
// if result [ 2 ] [ 1 ] = 100 + i then
19429: LD_VAR 0 1
19433: PUSH
19434: LD_INT 2
19436: ARRAY
19437: PUSH
19438: LD_INT 1
19440: ARRAY
19441: PUSH
19442: LD_INT 100
19444: PUSH
19445: LD_VAR 0 5
19449: PLUS
19450: EQUAL
19451: IFFALSE 19496
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
19453: LD_ADDR_VAR 0 1
19457: PUSH
19458: LD_VAR 0 1
19462: PPUSH
19463: LD_INT 2
19465: PPUSH
19466: LD_VAR 0 1
19470: PUSH
19471: LD_INT 2
19473: ARRAY
19474: PPUSH
19475: LD_INT 1
19477: PPUSH
19478: CALL_OW 3
19482: PPUSH
19483: CALL_OW 1
19487: ST_TO_ADDR
// tmp := 1 ;
19488: LD_ADDR_VAR 0 2
19492: PUSH
19493: LD_STRING 1
19495: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
19496: LD_ADDR_VAR 0 4
19500: PUSH
19501: LD_VAR 0 4
19505: PUSH
19506: LD_VAR 0 2
19510: STR
19511: ST_TO_ADDR
// end ;
19512: GO 19408
19514: POP
19515: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
19516: LD_STRING getStreamItemsFromMission("
19518: PUSH
19519: LD_VAR 0 3
19523: STR
19524: PUSH
19525: LD_STRING ","
19527: STR
19528: PUSH
19529: LD_VAR 0 4
19533: STR
19534: PUSH
19535: LD_STRING ")
19537: STR
19538: PPUSH
19539: CALL_OW 559
// end else
19543: GO 19552
// ToLua ( getStreamItemsFromMission("","") ) ;
19545: LD_STRING getStreamItemsFromMission("","")
19547: PPUSH
19548: CALL_OW 559
// end ;
19552: LD_VAR 0 1
19556: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19557: LD_VAR 0 2
19561: PUSH
19562: LD_INT 100
19564: EQUAL
19565: IFFALSE 20514
// begin if not StreamModeActive then
19567: LD_EXP 40
19571: NOT
19572: IFFALSE 19582
// StreamModeActive := true ;
19574: LD_ADDR_EXP 40
19578: PUSH
19579: LD_INT 1
19581: ST_TO_ADDR
// if p3 = 0 then
19582: LD_VAR 0 3
19586: PUSH
19587: LD_INT 0
19589: EQUAL
19590: IFFALSE 19596
// InitStreamMode ;
19592: CALL 15854 0 0
// if p3 = 1 then
19596: LD_VAR 0 3
19600: PUSH
19601: LD_INT 1
19603: EQUAL
19604: IFFALSE 19614
// sRocket := true ;
19606: LD_ADDR_EXP 45
19610: PUSH
19611: LD_INT 1
19613: ST_TO_ADDR
// if p3 = 2 then
19614: LD_VAR 0 3
19618: PUSH
19619: LD_INT 2
19621: EQUAL
19622: IFFALSE 19632
// sSpeed := true ;
19624: LD_ADDR_EXP 44
19628: PUSH
19629: LD_INT 1
19631: ST_TO_ADDR
// if p3 = 3 then
19632: LD_VAR 0 3
19636: PUSH
19637: LD_INT 3
19639: EQUAL
19640: IFFALSE 19650
// sEngine := true ;
19642: LD_ADDR_EXP 46
19646: PUSH
19647: LD_INT 1
19649: ST_TO_ADDR
// if p3 = 4 then
19650: LD_VAR 0 3
19654: PUSH
19655: LD_INT 4
19657: EQUAL
19658: IFFALSE 19668
// sSpec := true ;
19660: LD_ADDR_EXP 43
19664: PUSH
19665: LD_INT 1
19667: ST_TO_ADDR
// if p3 = 5 then
19668: LD_VAR 0 3
19672: PUSH
19673: LD_INT 5
19675: EQUAL
19676: IFFALSE 19686
// sLevel := true ;
19678: LD_ADDR_EXP 47
19682: PUSH
19683: LD_INT 1
19685: ST_TO_ADDR
// if p3 = 6 then
19686: LD_VAR 0 3
19690: PUSH
19691: LD_INT 6
19693: EQUAL
19694: IFFALSE 19704
// sArmoury := true ;
19696: LD_ADDR_EXP 48
19700: PUSH
19701: LD_INT 1
19703: ST_TO_ADDR
// if p3 = 7 then
19704: LD_VAR 0 3
19708: PUSH
19709: LD_INT 7
19711: EQUAL
19712: IFFALSE 19722
// sRadar := true ;
19714: LD_ADDR_EXP 49
19718: PUSH
19719: LD_INT 1
19721: ST_TO_ADDR
// if p3 = 8 then
19722: LD_VAR 0 3
19726: PUSH
19727: LD_INT 8
19729: EQUAL
19730: IFFALSE 19740
// sBunker := true ;
19732: LD_ADDR_EXP 50
19736: PUSH
19737: LD_INT 1
19739: ST_TO_ADDR
// if p3 = 9 then
19740: LD_VAR 0 3
19744: PUSH
19745: LD_INT 9
19747: EQUAL
19748: IFFALSE 19758
// sHack := true ;
19750: LD_ADDR_EXP 51
19754: PUSH
19755: LD_INT 1
19757: ST_TO_ADDR
// if p3 = 10 then
19758: LD_VAR 0 3
19762: PUSH
19763: LD_INT 10
19765: EQUAL
19766: IFFALSE 19776
// sFire := true ;
19768: LD_ADDR_EXP 52
19772: PUSH
19773: LD_INT 1
19775: ST_TO_ADDR
// if p3 = 11 then
19776: LD_VAR 0 3
19780: PUSH
19781: LD_INT 11
19783: EQUAL
19784: IFFALSE 19794
// sRefresh := true ;
19786: LD_ADDR_EXP 53
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// if p3 = 12 then
19794: LD_VAR 0 3
19798: PUSH
19799: LD_INT 12
19801: EQUAL
19802: IFFALSE 19812
// sExp := true ;
19804: LD_ADDR_EXP 54
19808: PUSH
19809: LD_INT 1
19811: ST_TO_ADDR
// if p3 = 13 then
19812: LD_VAR 0 3
19816: PUSH
19817: LD_INT 13
19819: EQUAL
19820: IFFALSE 19830
// sDepot := true ;
19822: LD_ADDR_EXP 55
19826: PUSH
19827: LD_INT 1
19829: ST_TO_ADDR
// if p3 = 14 then
19830: LD_VAR 0 3
19834: PUSH
19835: LD_INT 14
19837: EQUAL
19838: IFFALSE 19848
// sFlag := true ;
19840: LD_ADDR_EXP 56
19844: PUSH
19845: LD_INT 1
19847: ST_TO_ADDR
// if p3 = 15 then
19848: LD_VAR 0 3
19852: PUSH
19853: LD_INT 15
19855: EQUAL
19856: IFFALSE 19866
// sKamikadze := true ;
19858: LD_ADDR_EXP 64
19862: PUSH
19863: LD_INT 1
19865: ST_TO_ADDR
// if p3 = 16 then
19866: LD_VAR 0 3
19870: PUSH
19871: LD_INT 16
19873: EQUAL
19874: IFFALSE 19884
// sTroll := true ;
19876: LD_ADDR_EXP 65
19880: PUSH
19881: LD_INT 1
19883: ST_TO_ADDR
// if p3 = 17 then
19884: LD_VAR 0 3
19888: PUSH
19889: LD_INT 17
19891: EQUAL
19892: IFFALSE 19902
// sSlow := true ;
19894: LD_ADDR_EXP 66
19898: PUSH
19899: LD_INT 1
19901: ST_TO_ADDR
// if p3 = 18 then
19902: LD_VAR 0 3
19906: PUSH
19907: LD_INT 18
19909: EQUAL
19910: IFFALSE 19920
// sLack := true ;
19912: LD_ADDR_EXP 67
19916: PUSH
19917: LD_INT 1
19919: ST_TO_ADDR
// if p3 = 19 then
19920: LD_VAR 0 3
19924: PUSH
19925: LD_INT 19
19927: EQUAL
19928: IFFALSE 19938
// sTank := true ;
19930: LD_ADDR_EXP 69
19934: PUSH
19935: LD_INT 1
19937: ST_TO_ADDR
// if p3 = 20 then
19938: LD_VAR 0 3
19942: PUSH
19943: LD_INT 20
19945: EQUAL
19946: IFFALSE 19956
// sRemote := true ;
19948: LD_ADDR_EXP 70
19952: PUSH
19953: LD_INT 1
19955: ST_TO_ADDR
// if p3 = 21 then
19956: LD_VAR 0 3
19960: PUSH
19961: LD_INT 21
19963: EQUAL
19964: IFFALSE 19974
// sPowell := true ;
19966: LD_ADDR_EXP 71
19970: PUSH
19971: LD_INT 1
19973: ST_TO_ADDR
// if p3 = 22 then
19974: LD_VAR 0 3
19978: PUSH
19979: LD_INT 22
19981: EQUAL
19982: IFFALSE 19992
// sTeleport := true ;
19984: LD_ADDR_EXP 74
19988: PUSH
19989: LD_INT 1
19991: ST_TO_ADDR
// if p3 = 23 then
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 23
19999: EQUAL
20000: IFFALSE 20010
// sOilTower := true ;
20002: LD_ADDR_EXP 76
20006: PUSH
20007: LD_INT 1
20009: ST_TO_ADDR
// if p3 = 24 then
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 24
20017: EQUAL
20018: IFFALSE 20028
// sShovel := true ;
20020: LD_ADDR_EXP 77
20024: PUSH
20025: LD_INT 1
20027: ST_TO_ADDR
// if p3 = 25 then
20028: LD_VAR 0 3
20032: PUSH
20033: LD_INT 25
20035: EQUAL
20036: IFFALSE 20046
// sSheik := true ;
20038: LD_ADDR_EXP 78
20042: PUSH
20043: LD_INT 1
20045: ST_TO_ADDR
// if p3 = 26 then
20046: LD_VAR 0 3
20050: PUSH
20051: LD_INT 26
20053: EQUAL
20054: IFFALSE 20064
// sEarthquake := true ;
20056: LD_ADDR_EXP 80
20060: PUSH
20061: LD_INT 1
20063: ST_TO_ADDR
// if p3 = 27 then
20064: LD_VAR 0 3
20068: PUSH
20069: LD_INT 27
20071: EQUAL
20072: IFFALSE 20082
// sAI := true ;
20074: LD_ADDR_EXP 81
20078: PUSH
20079: LD_INT 1
20081: ST_TO_ADDR
// if p3 = 28 then
20082: LD_VAR 0 3
20086: PUSH
20087: LD_INT 28
20089: EQUAL
20090: IFFALSE 20100
// sCargo := true ;
20092: LD_ADDR_EXP 84
20096: PUSH
20097: LD_INT 1
20099: ST_TO_ADDR
// if p3 = 29 then
20100: LD_VAR 0 3
20104: PUSH
20105: LD_INT 29
20107: EQUAL
20108: IFFALSE 20118
// sDLaser := true ;
20110: LD_ADDR_EXP 85
20114: PUSH
20115: LD_INT 1
20117: ST_TO_ADDR
// if p3 = 30 then
20118: LD_VAR 0 3
20122: PUSH
20123: LD_INT 30
20125: EQUAL
20126: IFFALSE 20136
// sExchange := true ;
20128: LD_ADDR_EXP 86
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// if p3 = 31 then
20136: LD_VAR 0 3
20140: PUSH
20141: LD_INT 31
20143: EQUAL
20144: IFFALSE 20154
// sFac := true ;
20146: LD_ADDR_EXP 87
20150: PUSH
20151: LD_INT 1
20153: ST_TO_ADDR
// if p3 = 32 then
20154: LD_VAR 0 3
20158: PUSH
20159: LD_INT 32
20161: EQUAL
20162: IFFALSE 20172
// sPower := true ;
20164: LD_ADDR_EXP 88
20168: PUSH
20169: LD_INT 1
20171: ST_TO_ADDR
// if p3 = 33 then
20172: LD_VAR 0 3
20176: PUSH
20177: LD_INT 33
20179: EQUAL
20180: IFFALSE 20190
// sRandom := true ;
20182: LD_ADDR_EXP 89
20186: PUSH
20187: LD_INT 1
20189: ST_TO_ADDR
// if p3 = 34 then
20190: LD_VAR 0 3
20194: PUSH
20195: LD_INT 34
20197: EQUAL
20198: IFFALSE 20208
// sShield := true ;
20200: LD_ADDR_EXP 90
20204: PUSH
20205: LD_INT 1
20207: ST_TO_ADDR
// if p3 = 35 then
20208: LD_VAR 0 3
20212: PUSH
20213: LD_INT 35
20215: EQUAL
20216: IFFALSE 20226
// sTime := true ;
20218: LD_ADDR_EXP 91
20222: PUSH
20223: LD_INT 1
20225: ST_TO_ADDR
// if p3 = 36 then
20226: LD_VAR 0 3
20230: PUSH
20231: LD_INT 36
20233: EQUAL
20234: IFFALSE 20244
// sTools := true ;
20236: LD_ADDR_EXP 92
20240: PUSH
20241: LD_INT 1
20243: ST_TO_ADDR
// if p3 = 101 then
20244: LD_VAR 0 3
20248: PUSH
20249: LD_INT 101
20251: EQUAL
20252: IFFALSE 20262
// sSold := true ;
20254: LD_ADDR_EXP 57
20258: PUSH
20259: LD_INT 1
20261: ST_TO_ADDR
// if p3 = 102 then
20262: LD_VAR 0 3
20266: PUSH
20267: LD_INT 102
20269: EQUAL
20270: IFFALSE 20280
// sDiff := true ;
20272: LD_ADDR_EXP 58
20276: PUSH
20277: LD_INT 1
20279: ST_TO_ADDR
// if p3 = 103 then
20280: LD_VAR 0 3
20284: PUSH
20285: LD_INT 103
20287: EQUAL
20288: IFFALSE 20298
// sFog := true ;
20290: LD_ADDR_EXP 61
20294: PUSH
20295: LD_INT 1
20297: ST_TO_ADDR
// if p3 = 104 then
20298: LD_VAR 0 3
20302: PUSH
20303: LD_INT 104
20305: EQUAL
20306: IFFALSE 20316
// sReset := true ;
20308: LD_ADDR_EXP 62
20312: PUSH
20313: LD_INT 1
20315: ST_TO_ADDR
// if p3 = 105 then
20316: LD_VAR 0 3
20320: PUSH
20321: LD_INT 105
20323: EQUAL
20324: IFFALSE 20334
// sSun := true ;
20326: LD_ADDR_EXP 63
20330: PUSH
20331: LD_INT 1
20333: ST_TO_ADDR
// if p3 = 106 then
20334: LD_VAR 0 3
20338: PUSH
20339: LD_INT 106
20341: EQUAL
20342: IFFALSE 20352
// sTiger := true ;
20344: LD_ADDR_EXP 59
20348: PUSH
20349: LD_INT 1
20351: ST_TO_ADDR
// if p3 = 107 then
20352: LD_VAR 0 3
20356: PUSH
20357: LD_INT 107
20359: EQUAL
20360: IFFALSE 20370
// sBomb := true ;
20362: LD_ADDR_EXP 60
20366: PUSH
20367: LD_INT 1
20369: ST_TO_ADDR
// if p3 = 108 then
20370: LD_VAR 0 3
20374: PUSH
20375: LD_INT 108
20377: EQUAL
20378: IFFALSE 20388
// sWound := true ;
20380: LD_ADDR_EXP 68
20384: PUSH
20385: LD_INT 1
20387: ST_TO_ADDR
// if p3 = 109 then
20388: LD_VAR 0 3
20392: PUSH
20393: LD_INT 109
20395: EQUAL
20396: IFFALSE 20406
// sBetray := true ;
20398: LD_ADDR_EXP 72
20402: PUSH
20403: LD_INT 1
20405: ST_TO_ADDR
// if p3 = 110 then
20406: LD_VAR 0 3
20410: PUSH
20411: LD_INT 110
20413: EQUAL
20414: IFFALSE 20424
// sContamin := true ;
20416: LD_ADDR_EXP 73
20420: PUSH
20421: LD_INT 1
20423: ST_TO_ADDR
// if p3 = 111 then
20424: LD_VAR 0 3
20428: PUSH
20429: LD_INT 111
20431: EQUAL
20432: IFFALSE 20442
// sOil := true ;
20434: LD_ADDR_EXP 75
20438: PUSH
20439: LD_INT 1
20441: ST_TO_ADDR
// if p3 = 112 then
20442: LD_VAR 0 3
20446: PUSH
20447: LD_INT 112
20449: EQUAL
20450: IFFALSE 20460
// sStu := true ;
20452: LD_ADDR_EXP 79
20456: PUSH
20457: LD_INT 1
20459: ST_TO_ADDR
// if p3 = 113 then
20460: LD_VAR 0 3
20464: PUSH
20465: LD_INT 113
20467: EQUAL
20468: IFFALSE 20478
// sBazooka := true ;
20470: LD_ADDR_EXP 82
20474: PUSH
20475: LD_INT 1
20477: ST_TO_ADDR
// if p3 = 114 then
20478: LD_VAR 0 3
20482: PUSH
20483: LD_INT 114
20485: EQUAL
20486: IFFALSE 20496
// sMortar := true ;
20488: LD_ADDR_EXP 83
20492: PUSH
20493: LD_INT 1
20495: ST_TO_ADDR
// if p3 = 115 then
20496: LD_VAR 0 3
20500: PUSH
20501: LD_INT 115
20503: EQUAL
20504: IFFALSE 20514
// sRanger := true ;
20506: LD_ADDR_EXP 93
20510: PUSH
20511: LD_INT 1
20513: ST_TO_ADDR
// end ; end ;
20514: PPOPN 6
20516: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
20517: LD_EXP 40
20521: PUSH
20522: LD_EXP 45
20526: AND
20527: IFFALSE 20651
20529: GO 20531
20531: DISABLE
20532: LD_INT 0
20534: PPUSH
20535: PPUSH
// begin enable ;
20536: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
20537: LD_ADDR_VAR 0 2
20541: PUSH
20542: LD_INT 22
20544: PUSH
20545: LD_OWVAR 2
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: PUSH
20554: LD_INT 2
20556: PUSH
20557: LD_INT 34
20559: PUSH
20560: LD_INT 7
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: PUSH
20567: LD_INT 34
20569: PUSH
20570: LD_INT 45
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: LD_INT 34
20579: PUSH
20580: LD_INT 28
20582: PUSH
20583: EMPTY
20584: LIST
20585: LIST
20586: PUSH
20587: LD_INT 34
20589: PUSH
20590: LD_INT 47
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: PUSH
20597: EMPTY
20598: LIST
20599: LIST
20600: LIST
20601: LIST
20602: LIST
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: PPUSH
20608: CALL_OW 69
20612: ST_TO_ADDR
// if not tmp then
20613: LD_VAR 0 2
20617: NOT
20618: IFFALSE 20622
// exit ;
20620: GO 20651
// for i in tmp do
20622: LD_ADDR_VAR 0 1
20626: PUSH
20627: LD_VAR 0 2
20631: PUSH
20632: FOR_IN
20633: IFFALSE 20649
// begin SetLives ( i , 0 ) ;
20635: LD_VAR 0 1
20639: PPUSH
20640: LD_INT 0
20642: PPUSH
20643: CALL_OW 234
// end ;
20647: GO 20632
20649: POP
20650: POP
// end ;
20651: PPOPN 2
20653: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
20654: LD_EXP 40
20658: PUSH
20659: LD_EXP 46
20663: AND
20664: IFFALSE 20748
20666: GO 20668
20668: DISABLE
20669: LD_INT 0
20671: PPUSH
20672: PPUSH
// begin enable ;
20673: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
20674: LD_ADDR_VAR 0 2
20678: PUSH
20679: LD_INT 22
20681: PUSH
20682: LD_OWVAR 2
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: PUSH
20691: LD_INT 32
20693: PUSH
20694: LD_INT 3
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: ST_TO_ADDR
// if not tmp then
20710: LD_VAR 0 2
20714: NOT
20715: IFFALSE 20719
// exit ;
20717: GO 20748
// for i in tmp do
20719: LD_ADDR_VAR 0 1
20723: PUSH
20724: LD_VAR 0 2
20728: PUSH
20729: FOR_IN
20730: IFFALSE 20746
// begin SetLives ( i , 0 ) ;
20732: LD_VAR 0 1
20736: PPUSH
20737: LD_INT 0
20739: PPUSH
20740: CALL_OW 234
// end ;
20744: GO 20729
20746: POP
20747: POP
// end ;
20748: PPOPN 2
20750: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
20751: LD_EXP 40
20755: PUSH
20756: LD_EXP 43
20760: AND
20761: IFFALSE 20854
20763: GO 20765
20765: DISABLE
20766: LD_INT 0
20768: PPUSH
// begin enable ;
20769: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
20770: LD_ADDR_VAR 0 1
20774: PUSH
20775: LD_INT 22
20777: PUSH
20778: LD_OWVAR 2
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: PUSH
20787: LD_INT 2
20789: PUSH
20790: LD_INT 25
20792: PUSH
20793: LD_INT 5
20795: PUSH
20796: EMPTY
20797: LIST
20798: LIST
20799: PUSH
20800: LD_INT 25
20802: PUSH
20803: LD_INT 9
20805: PUSH
20806: EMPTY
20807: LIST
20808: LIST
20809: PUSH
20810: LD_INT 25
20812: PUSH
20813: LD_INT 8
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: PUSH
20826: EMPTY
20827: LIST
20828: LIST
20829: PPUSH
20830: CALL_OW 69
20834: PUSH
20835: FOR_IN
20836: IFFALSE 20852
// begin SetClass ( i , 1 ) ;
20838: LD_VAR 0 1
20842: PPUSH
20843: LD_INT 1
20845: PPUSH
20846: CALL_OW 336
// end ;
20850: GO 20835
20852: POP
20853: POP
// end ;
20854: PPOPN 1
20856: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
20857: LD_EXP 40
20861: PUSH
20862: LD_EXP 44
20866: AND
20867: PUSH
20868: LD_OWVAR 65
20872: PUSH
20873: LD_INT 7
20875: LESS
20876: AND
20877: IFFALSE 20891
20879: GO 20881
20881: DISABLE
// begin enable ;
20882: ENABLE
// game_speed := 7 ;
20883: LD_ADDR_OWVAR 65
20887: PUSH
20888: LD_INT 7
20890: ST_TO_ADDR
// end ;
20891: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
20892: LD_EXP 40
20896: PUSH
20897: LD_EXP 47
20901: AND
20902: IFFALSE 21104
20904: GO 20906
20906: DISABLE
20907: LD_INT 0
20909: PPUSH
20910: PPUSH
20911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
20912: LD_ADDR_VAR 0 3
20916: PUSH
20917: LD_INT 81
20919: PUSH
20920: LD_OWVAR 2
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PUSH
20929: LD_INT 21
20931: PUSH
20932: LD_INT 1
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: PPUSH
20943: CALL_OW 69
20947: ST_TO_ADDR
// if not tmp then
20948: LD_VAR 0 3
20952: NOT
20953: IFFALSE 20957
// exit ;
20955: GO 21104
// if tmp > 5 then
20957: LD_VAR 0 3
20961: PUSH
20962: LD_INT 5
20964: GREATER
20965: IFFALSE 20977
// k := 5 else
20967: LD_ADDR_VAR 0 2
20971: PUSH
20972: LD_INT 5
20974: ST_TO_ADDR
20975: GO 20987
// k := tmp ;
20977: LD_ADDR_VAR 0 2
20981: PUSH
20982: LD_VAR 0 3
20986: ST_TO_ADDR
// for i := 1 to k do
20987: LD_ADDR_VAR 0 1
20991: PUSH
20992: DOUBLE
20993: LD_INT 1
20995: DEC
20996: ST_TO_ADDR
20997: LD_VAR 0 2
21001: PUSH
21002: FOR_TO
21003: IFFALSE 21102
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
21005: LD_VAR 0 3
21009: PUSH
21010: LD_VAR 0 1
21014: ARRAY
21015: PPUSH
21016: LD_VAR 0 1
21020: PUSH
21021: LD_INT 4
21023: MOD
21024: PUSH
21025: LD_INT 1
21027: PLUS
21028: PPUSH
21029: CALL_OW 259
21033: PUSH
21034: LD_INT 10
21036: LESS
21037: IFFALSE 21100
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
21039: LD_VAR 0 3
21043: PUSH
21044: LD_VAR 0 1
21048: ARRAY
21049: PPUSH
21050: LD_VAR 0 1
21054: PUSH
21055: LD_INT 4
21057: MOD
21058: PUSH
21059: LD_INT 1
21061: PLUS
21062: PPUSH
21063: LD_VAR 0 3
21067: PUSH
21068: LD_VAR 0 1
21072: ARRAY
21073: PPUSH
21074: LD_VAR 0 1
21078: PUSH
21079: LD_INT 4
21081: MOD
21082: PUSH
21083: LD_INT 1
21085: PLUS
21086: PPUSH
21087: CALL_OW 259
21091: PUSH
21092: LD_INT 1
21094: PLUS
21095: PPUSH
21096: CALL_OW 237
21100: GO 21002
21102: POP
21103: POP
// end ;
21104: PPOPN 3
21106: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
21107: LD_EXP 40
21111: PUSH
21112: LD_EXP 48
21116: AND
21117: IFFALSE 21137
21119: GO 21121
21121: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
21122: LD_INT 4
21124: PPUSH
21125: LD_OWVAR 2
21129: PPUSH
21130: LD_INT 0
21132: PPUSH
21133: CALL_OW 324
21137: END
// every 0 0$1 trigger StreamModeActive and sShovel do
21138: LD_EXP 40
21142: PUSH
21143: LD_EXP 77
21147: AND
21148: IFFALSE 21168
21150: GO 21152
21152: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
21153: LD_INT 19
21155: PPUSH
21156: LD_OWVAR 2
21160: PPUSH
21161: LD_INT 0
21163: PPUSH
21164: CALL_OW 324
21168: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
21169: LD_EXP 40
21173: PUSH
21174: LD_EXP 49
21178: AND
21179: IFFALSE 21281
21181: GO 21183
21183: DISABLE
21184: LD_INT 0
21186: PPUSH
21187: PPUSH
// begin enable ;
21188: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
21189: LD_ADDR_VAR 0 2
21193: PUSH
21194: LD_INT 22
21196: PUSH
21197: LD_OWVAR 2
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PUSH
21206: LD_INT 2
21208: PUSH
21209: LD_INT 34
21211: PUSH
21212: LD_INT 11
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PUSH
21219: LD_INT 34
21221: PUSH
21222: LD_INT 30
21224: PUSH
21225: EMPTY
21226: LIST
21227: LIST
21228: PUSH
21229: EMPTY
21230: LIST
21231: LIST
21232: LIST
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PPUSH
21238: CALL_OW 69
21242: ST_TO_ADDR
// if not tmp then
21243: LD_VAR 0 2
21247: NOT
21248: IFFALSE 21252
// exit ;
21250: GO 21281
// for i in tmp do
21252: LD_ADDR_VAR 0 1
21256: PUSH
21257: LD_VAR 0 2
21261: PUSH
21262: FOR_IN
21263: IFFALSE 21279
// begin SetLives ( i , 0 ) ;
21265: LD_VAR 0 1
21269: PPUSH
21270: LD_INT 0
21272: PPUSH
21273: CALL_OW 234
// end ;
21277: GO 21262
21279: POP
21280: POP
// end ;
21281: PPOPN 2
21283: END
// every 0 0$1 trigger StreamModeActive and sBunker do
21284: LD_EXP 40
21288: PUSH
21289: LD_EXP 50
21293: AND
21294: IFFALSE 21314
21296: GO 21298
21298: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
21299: LD_INT 32
21301: PPUSH
21302: LD_OWVAR 2
21306: PPUSH
21307: LD_INT 0
21309: PPUSH
21310: CALL_OW 324
21314: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
21315: LD_EXP 40
21319: PUSH
21320: LD_EXP 51
21324: AND
21325: IFFALSE 21506
21327: GO 21329
21329: DISABLE
21330: LD_INT 0
21332: PPUSH
21333: PPUSH
21334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
21335: LD_ADDR_VAR 0 2
21339: PUSH
21340: LD_INT 22
21342: PUSH
21343: LD_OWVAR 2
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: PUSH
21352: LD_INT 33
21354: PUSH
21355: LD_INT 3
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PUSH
21362: EMPTY
21363: LIST
21364: LIST
21365: PPUSH
21366: CALL_OW 69
21370: ST_TO_ADDR
// if not tmp then
21371: LD_VAR 0 2
21375: NOT
21376: IFFALSE 21380
// exit ;
21378: GO 21506
// side := 0 ;
21380: LD_ADDR_VAR 0 3
21384: PUSH
21385: LD_INT 0
21387: ST_TO_ADDR
// for i := 1 to 8 do
21388: LD_ADDR_VAR 0 1
21392: PUSH
21393: DOUBLE
21394: LD_INT 1
21396: DEC
21397: ST_TO_ADDR
21398: LD_INT 8
21400: PUSH
21401: FOR_TO
21402: IFFALSE 21450
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
21404: LD_OWVAR 2
21408: PUSH
21409: LD_VAR 0 1
21413: NONEQUAL
21414: PUSH
21415: LD_OWVAR 2
21419: PPUSH
21420: LD_VAR 0 1
21424: PPUSH
21425: CALL_OW 81
21429: PUSH
21430: LD_INT 2
21432: EQUAL
21433: AND
21434: IFFALSE 21448
// begin side := i ;
21436: LD_ADDR_VAR 0 3
21440: PUSH
21441: LD_VAR 0 1
21445: ST_TO_ADDR
// break ;
21446: GO 21450
// end ;
21448: GO 21401
21450: POP
21451: POP
// if not side then
21452: LD_VAR 0 3
21456: NOT
21457: IFFALSE 21461
// exit ;
21459: GO 21506
// for i := 1 to tmp do
21461: LD_ADDR_VAR 0 1
21465: PUSH
21466: DOUBLE
21467: LD_INT 1
21469: DEC
21470: ST_TO_ADDR
21471: LD_VAR 0 2
21475: PUSH
21476: FOR_TO
21477: IFFALSE 21504
// if Prob ( 60 ) then
21479: LD_INT 60
21481: PPUSH
21482: CALL_OW 13
21486: IFFALSE 21502
// SetSide ( i , side ) ;
21488: LD_VAR 0 1
21492: PPUSH
21493: LD_VAR 0 3
21497: PPUSH
21498: CALL_OW 235
21502: GO 21476
21504: POP
21505: POP
// end ;
21506: PPOPN 3
21508: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
21509: LD_EXP 40
21513: PUSH
21514: LD_EXP 53
21518: AND
21519: IFFALSE 21638
21521: GO 21523
21523: DISABLE
21524: LD_INT 0
21526: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
21527: LD_ADDR_VAR 0 1
21531: PUSH
21532: LD_INT 22
21534: PUSH
21535: LD_OWVAR 2
21539: PUSH
21540: EMPTY
21541: LIST
21542: LIST
21543: PUSH
21544: LD_INT 21
21546: PUSH
21547: LD_INT 1
21549: PUSH
21550: EMPTY
21551: LIST
21552: LIST
21553: PUSH
21554: LD_INT 3
21556: PUSH
21557: LD_INT 23
21559: PUSH
21560: LD_INT 0
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: PUSH
21571: EMPTY
21572: LIST
21573: LIST
21574: LIST
21575: PPUSH
21576: CALL_OW 69
21580: PUSH
21581: FOR_IN
21582: IFFALSE 21636
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
21584: LD_VAR 0 1
21588: PPUSH
21589: CALL_OW 257
21593: PUSH
21594: LD_INT 1
21596: PUSH
21597: LD_INT 2
21599: PUSH
21600: LD_INT 3
21602: PUSH
21603: LD_INT 4
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: LIST
21610: LIST
21611: IN
21612: IFFALSE 21634
// SetClass ( un , rand ( 1 , 4 ) ) ;
21614: LD_VAR 0 1
21618: PPUSH
21619: LD_INT 1
21621: PPUSH
21622: LD_INT 4
21624: PPUSH
21625: CALL_OW 12
21629: PPUSH
21630: CALL_OW 336
21634: GO 21581
21636: POP
21637: POP
// end ;
21638: PPOPN 1
21640: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
21641: LD_EXP 40
21645: PUSH
21646: LD_EXP 52
21650: AND
21651: IFFALSE 21730
21653: GO 21655
21655: DISABLE
21656: LD_INT 0
21658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21659: LD_ADDR_VAR 0 1
21663: PUSH
21664: LD_INT 22
21666: PUSH
21667: LD_OWVAR 2
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: LD_INT 21
21678: PUSH
21679: LD_INT 3
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: PPUSH
21690: CALL_OW 69
21694: ST_TO_ADDR
// if not tmp then
21695: LD_VAR 0 1
21699: NOT
21700: IFFALSE 21704
// exit ;
21702: GO 21730
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
21704: LD_VAR 0 1
21708: PUSH
21709: LD_INT 1
21711: PPUSH
21712: LD_VAR 0 1
21716: PPUSH
21717: CALL_OW 12
21721: ARRAY
21722: PPUSH
21723: LD_INT 100
21725: PPUSH
21726: CALL_OW 234
// end ;
21730: PPOPN 1
21732: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
21733: LD_EXP 40
21737: PUSH
21738: LD_EXP 54
21742: AND
21743: IFFALSE 21841
21745: GO 21747
21747: DISABLE
21748: LD_INT 0
21750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
21751: LD_ADDR_VAR 0 1
21755: PUSH
21756: LD_INT 22
21758: PUSH
21759: LD_OWVAR 2
21763: PUSH
21764: EMPTY
21765: LIST
21766: LIST
21767: PUSH
21768: LD_INT 21
21770: PUSH
21771: LD_INT 1
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PPUSH
21782: CALL_OW 69
21786: ST_TO_ADDR
// if not tmp then
21787: LD_VAR 0 1
21791: NOT
21792: IFFALSE 21796
// exit ;
21794: GO 21841
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
21796: LD_VAR 0 1
21800: PUSH
21801: LD_INT 1
21803: PPUSH
21804: LD_VAR 0 1
21808: PPUSH
21809: CALL_OW 12
21813: ARRAY
21814: PPUSH
21815: LD_INT 1
21817: PPUSH
21818: LD_INT 4
21820: PPUSH
21821: CALL_OW 12
21825: PPUSH
21826: LD_INT 3000
21828: PPUSH
21829: LD_INT 9000
21831: PPUSH
21832: CALL_OW 12
21836: PPUSH
21837: CALL_OW 492
// end ;
21841: PPOPN 1
21843: END
// every 0 0$1 trigger StreamModeActive and sDepot do
21844: LD_EXP 40
21848: PUSH
21849: LD_EXP 55
21853: AND
21854: IFFALSE 21874
21856: GO 21858
21858: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
21859: LD_INT 1
21861: PPUSH
21862: LD_OWVAR 2
21866: PPUSH
21867: LD_INT 0
21869: PPUSH
21870: CALL_OW 324
21874: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
21875: LD_EXP 40
21879: PUSH
21880: LD_EXP 56
21884: AND
21885: IFFALSE 21968
21887: GO 21889
21889: DISABLE
21890: LD_INT 0
21892: PPUSH
21893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21894: LD_ADDR_VAR 0 2
21898: PUSH
21899: LD_INT 22
21901: PUSH
21902: LD_OWVAR 2
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: LD_INT 21
21913: PUSH
21914: LD_INT 3
21916: PUSH
21917: EMPTY
21918: LIST
21919: LIST
21920: PUSH
21921: EMPTY
21922: LIST
21923: LIST
21924: PPUSH
21925: CALL_OW 69
21929: ST_TO_ADDR
// if not tmp then
21930: LD_VAR 0 2
21934: NOT
21935: IFFALSE 21939
// exit ;
21937: GO 21968
// for i in tmp do
21939: LD_ADDR_VAR 0 1
21943: PUSH
21944: LD_VAR 0 2
21948: PUSH
21949: FOR_IN
21950: IFFALSE 21966
// SetBLevel ( i , 10 ) ;
21952: LD_VAR 0 1
21956: PPUSH
21957: LD_INT 10
21959: PPUSH
21960: CALL_OW 241
21964: GO 21949
21966: POP
21967: POP
// end ;
21968: PPOPN 2
21970: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
21971: LD_EXP 40
21975: PUSH
21976: LD_EXP 57
21980: AND
21981: IFFALSE 22092
21983: GO 21985
21985: DISABLE
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
21990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21991: LD_ADDR_VAR 0 3
21995: PUSH
21996: LD_INT 22
21998: PUSH
21999: LD_OWVAR 2
22003: PUSH
22004: EMPTY
22005: LIST
22006: LIST
22007: PUSH
22008: LD_INT 25
22010: PUSH
22011: LD_INT 1
22013: PUSH
22014: EMPTY
22015: LIST
22016: LIST
22017: PUSH
22018: EMPTY
22019: LIST
22020: LIST
22021: PPUSH
22022: CALL_OW 69
22026: ST_TO_ADDR
// if not tmp then
22027: LD_VAR 0 3
22031: NOT
22032: IFFALSE 22036
// exit ;
22034: GO 22092
// un := tmp [ rand ( 1 , tmp ) ] ;
22036: LD_ADDR_VAR 0 2
22040: PUSH
22041: LD_VAR 0 3
22045: PUSH
22046: LD_INT 1
22048: PPUSH
22049: LD_VAR 0 3
22053: PPUSH
22054: CALL_OW 12
22058: ARRAY
22059: ST_TO_ADDR
// if Crawls ( un ) then
22060: LD_VAR 0 2
22064: PPUSH
22065: CALL_OW 318
22069: IFFALSE 22080
// ComWalk ( un ) ;
22071: LD_VAR 0 2
22075: PPUSH
22076: CALL_OW 138
// SetClass ( un , class_sniper ) ;
22080: LD_VAR 0 2
22084: PPUSH
22085: LD_INT 5
22087: PPUSH
22088: CALL_OW 336
// end ;
22092: PPOPN 3
22094: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
22095: LD_EXP 40
22099: PUSH
22100: LD_EXP 58
22104: AND
22105: PUSH
22106: LD_OWVAR 67
22110: PUSH
22111: LD_INT 3
22113: LESS
22114: AND
22115: IFFALSE 22134
22117: GO 22119
22119: DISABLE
// Difficulty := Difficulty + 1 ;
22120: LD_ADDR_OWVAR 67
22124: PUSH
22125: LD_OWVAR 67
22129: PUSH
22130: LD_INT 1
22132: PLUS
22133: ST_TO_ADDR
22134: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
22135: LD_EXP 40
22139: PUSH
22140: LD_EXP 59
22144: AND
22145: IFFALSE 22248
22147: GO 22149
22149: DISABLE
22150: LD_INT 0
22152: PPUSH
// begin for i := 1 to 5 do
22153: LD_ADDR_VAR 0 1
22157: PUSH
22158: DOUBLE
22159: LD_INT 1
22161: DEC
22162: ST_TO_ADDR
22163: LD_INT 5
22165: PUSH
22166: FOR_TO
22167: IFFALSE 22246
// begin uc_nation := nation_nature ;
22169: LD_ADDR_OWVAR 21
22173: PUSH
22174: LD_INT 0
22176: ST_TO_ADDR
// uc_side := 0 ;
22177: LD_ADDR_OWVAR 20
22181: PUSH
22182: LD_INT 0
22184: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22185: LD_ADDR_OWVAR 29
22189: PUSH
22190: LD_INT 12
22192: PUSH
22193: LD_INT 12
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: ST_TO_ADDR
// hc_agressivity := 20 ;
22200: LD_ADDR_OWVAR 35
22204: PUSH
22205: LD_INT 20
22207: ST_TO_ADDR
// hc_class := class_tiger ;
22208: LD_ADDR_OWVAR 28
22212: PUSH
22213: LD_INT 14
22215: ST_TO_ADDR
// hc_gallery :=  ;
22216: LD_ADDR_OWVAR 33
22220: PUSH
22221: LD_STRING 
22223: ST_TO_ADDR
// hc_name :=  ;
22224: LD_ADDR_OWVAR 26
22228: PUSH
22229: LD_STRING 
22231: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
22232: CALL_OW 44
22236: PPUSH
22237: LD_INT 0
22239: PPUSH
22240: CALL_OW 51
// end ;
22244: GO 22166
22246: POP
22247: POP
// end ;
22248: PPOPN 1
22250: END
// every 0 0$1 trigger StreamModeActive and sBomb do
22251: LD_EXP 40
22255: PUSH
22256: LD_EXP 60
22260: AND
22261: IFFALSE 22270
22263: GO 22265
22265: DISABLE
// StreamSibBomb ;
22266: CALL 22271 0 0
22270: END
// export function StreamSibBomb ; var i , x , y ; begin
22271: LD_INT 0
22273: PPUSH
22274: PPUSH
22275: PPUSH
22276: PPUSH
// result := false ;
22277: LD_ADDR_VAR 0 1
22281: PUSH
22282: LD_INT 0
22284: ST_TO_ADDR
// for i := 1 to 16 do
22285: LD_ADDR_VAR 0 2
22289: PUSH
22290: DOUBLE
22291: LD_INT 1
22293: DEC
22294: ST_TO_ADDR
22295: LD_INT 16
22297: PUSH
22298: FOR_TO
22299: IFFALSE 22498
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22301: LD_ADDR_VAR 0 3
22305: PUSH
22306: LD_INT 10
22308: PUSH
22309: LD_INT 20
22311: PUSH
22312: LD_INT 30
22314: PUSH
22315: LD_INT 40
22317: PUSH
22318: LD_INT 50
22320: PUSH
22321: LD_INT 60
22323: PUSH
22324: LD_INT 70
22326: PUSH
22327: LD_INT 80
22329: PUSH
22330: LD_INT 90
22332: PUSH
22333: LD_INT 100
22335: PUSH
22336: LD_INT 110
22338: PUSH
22339: LD_INT 120
22341: PUSH
22342: LD_INT 130
22344: PUSH
22345: LD_INT 140
22347: PUSH
22348: LD_INT 150
22350: PUSH
22351: EMPTY
22352: LIST
22353: LIST
22354: LIST
22355: LIST
22356: LIST
22357: LIST
22358: LIST
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: LIST
22367: PUSH
22368: LD_INT 1
22370: PPUSH
22371: LD_INT 15
22373: PPUSH
22374: CALL_OW 12
22378: ARRAY
22379: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22380: LD_ADDR_VAR 0 4
22384: PUSH
22385: LD_INT 10
22387: PUSH
22388: LD_INT 20
22390: PUSH
22391: LD_INT 30
22393: PUSH
22394: LD_INT 40
22396: PUSH
22397: LD_INT 50
22399: PUSH
22400: LD_INT 60
22402: PUSH
22403: LD_INT 70
22405: PUSH
22406: LD_INT 80
22408: PUSH
22409: LD_INT 90
22411: PUSH
22412: LD_INT 100
22414: PUSH
22415: LD_INT 110
22417: PUSH
22418: LD_INT 120
22420: PUSH
22421: LD_INT 130
22423: PUSH
22424: LD_INT 140
22426: PUSH
22427: LD_INT 150
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 1
22449: PPUSH
22450: LD_INT 15
22452: PPUSH
22453: CALL_OW 12
22457: ARRAY
22458: ST_TO_ADDR
// if ValidHex ( x , y ) then
22459: LD_VAR 0 3
22463: PPUSH
22464: LD_VAR 0 4
22468: PPUSH
22469: CALL_OW 488
22473: IFFALSE 22496
// begin result := [ x , y ] ;
22475: LD_ADDR_VAR 0 1
22479: PUSH
22480: LD_VAR 0 3
22484: PUSH
22485: LD_VAR 0 4
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: ST_TO_ADDR
// break ;
22494: GO 22498
// end ; end ;
22496: GO 22298
22498: POP
22499: POP
// if result then
22500: LD_VAR 0 1
22504: IFFALSE 22564
// begin ToLua ( playSibBomb() ) ;
22506: LD_STRING playSibBomb()
22508: PPUSH
22509: CALL_OW 559
// wait ( 0 0$14 ) ;
22513: LD_INT 490
22515: PPUSH
22516: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
22520: LD_VAR 0 1
22524: PUSH
22525: LD_INT 1
22527: ARRAY
22528: PPUSH
22529: LD_VAR 0 1
22533: PUSH
22534: LD_INT 2
22536: ARRAY
22537: PPUSH
22538: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
22542: LD_VAR 0 1
22546: PUSH
22547: LD_INT 1
22549: ARRAY
22550: PPUSH
22551: LD_VAR 0 1
22555: PUSH
22556: LD_INT 2
22558: ARRAY
22559: PPUSH
22560: CALL_OW 429
// end ; end ;
22564: LD_VAR 0 1
22568: RET
// every 0 0$1 trigger StreamModeActive and sReset do
22569: LD_EXP 40
22573: PUSH
22574: LD_EXP 62
22578: AND
22579: IFFALSE 22591
22581: GO 22583
22583: DISABLE
// YouLost (  ) ;
22584: LD_STRING 
22586: PPUSH
22587: CALL_OW 104
22591: END
// every 0 0$1 trigger StreamModeActive and sFog do
22592: LD_EXP 40
22596: PUSH
22597: LD_EXP 61
22601: AND
22602: IFFALSE 22616
22604: GO 22606
22606: DISABLE
// FogOff ( your_side ) ;
22607: LD_OWVAR 2
22611: PPUSH
22612: CALL_OW 344
22616: END
// every 0 0$1 trigger StreamModeActive and sSun do
22617: LD_EXP 40
22621: PUSH
22622: LD_EXP 63
22626: AND
22627: IFFALSE 22655
22629: GO 22631
22631: DISABLE
// begin solar_recharge_percent := 0 ;
22632: LD_ADDR_OWVAR 79
22636: PUSH
22637: LD_INT 0
22639: ST_TO_ADDR
// wait ( 5 5$00 ) ;
22640: LD_INT 10500
22642: PPUSH
22643: CALL_OW 67
// solar_recharge_percent := 100 ;
22647: LD_ADDR_OWVAR 79
22651: PUSH
22652: LD_INT 100
22654: ST_TO_ADDR
// end ;
22655: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
22656: LD_EXP 40
22660: PUSH
22661: LD_EXP 64
22665: AND
22666: IFFALSE 22905
22668: GO 22670
22670: DISABLE
22671: LD_INT 0
22673: PPUSH
22674: PPUSH
22675: PPUSH
// begin tmp := [ ] ;
22676: LD_ADDR_VAR 0 3
22680: PUSH
22681: EMPTY
22682: ST_TO_ADDR
// for i := 1 to 6 do
22683: LD_ADDR_VAR 0 1
22687: PUSH
22688: DOUBLE
22689: LD_INT 1
22691: DEC
22692: ST_TO_ADDR
22693: LD_INT 6
22695: PUSH
22696: FOR_TO
22697: IFFALSE 22802
// begin uc_nation := nation_nature ;
22699: LD_ADDR_OWVAR 21
22703: PUSH
22704: LD_INT 0
22706: ST_TO_ADDR
// uc_side := 0 ;
22707: LD_ADDR_OWVAR 20
22711: PUSH
22712: LD_INT 0
22714: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22715: LD_ADDR_OWVAR 29
22719: PUSH
22720: LD_INT 12
22722: PUSH
22723: LD_INT 12
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: ST_TO_ADDR
// hc_agressivity := 20 ;
22730: LD_ADDR_OWVAR 35
22734: PUSH
22735: LD_INT 20
22737: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
22738: LD_ADDR_OWVAR 28
22742: PUSH
22743: LD_INT 17
22745: ST_TO_ADDR
// hc_gallery :=  ;
22746: LD_ADDR_OWVAR 33
22750: PUSH
22751: LD_STRING 
22753: ST_TO_ADDR
// hc_name :=  ;
22754: LD_ADDR_OWVAR 26
22758: PUSH
22759: LD_STRING 
22761: ST_TO_ADDR
// un := CreateHuman ;
22762: LD_ADDR_VAR 0 2
22766: PUSH
22767: CALL_OW 44
22771: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
22772: LD_VAR 0 2
22776: PPUSH
22777: LD_INT 1
22779: PPUSH
22780: CALL_OW 51
// tmp := tmp ^ un ;
22784: LD_ADDR_VAR 0 3
22788: PUSH
22789: LD_VAR 0 3
22793: PUSH
22794: LD_VAR 0 2
22798: ADD
22799: ST_TO_ADDR
// end ;
22800: GO 22696
22802: POP
22803: POP
// repeat wait ( 0 0$1 ) ;
22804: LD_INT 35
22806: PPUSH
22807: CALL_OW 67
// for un in tmp do
22811: LD_ADDR_VAR 0 2
22815: PUSH
22816: LD_VAR 0 3
22820: PUSH
22821: FOR_IN
22822: IFFALSE 22896
// begin if IsDead ( un ) then
22824: LD_VAR 0 2
22828: PPUSH
22829: CALL_OW 301
22833: IFFALSE 22853
// begin tmp := tmp diff un ;
22835: LD_ADDR_VAR 0 3
22839: PUSH
22840: LD_VAR 0 3
22844: PUSH
22845: LD_VAR 0 2
22849: DIFF
22850: ST_TO_ADDR
// continue ;
22851: GO 22821
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
22853: LD_VAR 0 2
22857: PPUSH
22858: LD_INT 3
22860: PUSH
22861: LD_INT 22
22863: PUSH
22864: LD_INT 0
22866: PUSH
22867: EMPTY
22868: LIST
22869: LIST
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: PPUSH
22875: CALL_OW 69
22879: PPUSH
22880: LD_VAR 0 2
22884: PPUSH
22885: CALL_OW 74
22889: PPUSH
22890: CALL_OW 115
// end ;
22894: GO 22821
22896: POP
22897: POP
// until not tmp ;
22898: LD_VAR 0 3
22902: NOT
22903: IFFALSE 22804
// end ;
22905: PPOPN 3
22907: END
// every 0 0$1 trigger StreamModeActive and sTroll do
22908: LD_EXP 40
22912: PUSH
22913: LD_EXP 65
22917: AND
22918: IFFALSE 22972
22920: GO 22922
22922: DISABLE
// begin ToLua ( displayTroll(); ) ;
22923: LD_STRING displayTroll();
22925: PPUSH
22926: CALL_OW 559
// wait ( 3 3$00 ) ;
22930: LD_INT 6300
22932: PPUSH
22933: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22937: LD_STRING hideTroll();
22939: PPUSH
22940: CALL_OW 559
// wait ( 1 1$00 ) ;
22944: LD_INT 2100
22946: PPUSH
22947: CALL_OW 67
// ToLua ( displayTroll(); ) ;
22951: LD_STRING displayTroll();
22953: PPUSH
22954: CALL_OW 559
// wait ( 1 1$00 ) ;
22958: LD_INT 2100
22960: PPUSH
22961: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22965: LD_STRING hideTroll();
22967: PPUSH
22968: CALL_OW 559
// end ;
22972: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
22973: LD_EXP 40
22977: PUSH
22978: LD_EXP 66
22982: AND
22983: IFFALSE 23046
22985: GO 22987
22987: DISABLE
22988: LD_INT 0
22990: PPUSH
// begin p := 0 ;
22991: LD_ADDR_VAR 0 1
22995: PUSH
22996: LD_INT 0
22998: ST_TO_ADDR
// repeat game_speed := 1 ;
22999: LD_ADDR_OWVAR 65
23003: PUSH
23004: LD_INT 1
23006: ST_TO_ADDR
// wait ( 0 0$1 ) ;
23007: LD_INT 35
23009: PPUSH
23010: CALL_OW 67
// p := p + 1 ;
23014: LD_ADDR_VAR 0 1
23018: PUSH
23019: LD_VAR 0 1
23023: PUSH
23024: LD_INT 1
23026: PLUS
23027: ST_TO_ADDR
// until p >= 60 ;
23028: LD_VAR 0 1
23032: PUSH
23033: LD_INT 60
23035: GREATEREQUAL
23036: IFFALSE 22999
// game_speed := 4 ;
23038: LD_ADDR_OWVAR 65
23042: PUSH
23043: LD_INT 4
23045: ST_TO_ADDR
// end ;
23046: PPOPN 1
23048: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
23049: LD_EXP 40
23053: PUSH
23054: LD_EXP 67
23058: AND
23059: IFFALSE 23205
23061: GO 23063
23063: DISABLE
23064: LD_INT 0
23066: PPUSH
23067: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23068: LD_ADDR_VAR 0 1
23072: PUSH
23073: LD_INT 22
23075: PUSH
23076: LD_OWVAR 2
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: PUSH
23085: LD_INT 2
23087: PUSH
23088: LD_INT 30
23090: PUSH
23091: LD_INT 0
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 30
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: LIST
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: PPUSH
23117: CALL_OW 69
23121: ST_TO_ADDR
// if not depot then
23122: LD_VAR 0 1
23126: NOT
23127: IFFALSE 23131
// exit ;
23129: GO 23205
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
23131: LD_ADDR_VAR 0 2
23135: PUSH
23136: LD_VAR 0 1
23140: PUSH
23141: LD_INT 1
23143: PPUSH
23144: LD_VAR 0 1
23148: PPUSH
23149: CALL_OW 12
23153: ARRAY
23154: PPUSH
23155: CALL_OW 274
23159: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
23160: LD_VAR 0 2
23164: PPUSH
23165: LD_INT 1
23167: PPUSH
23168: LD_INT 0
23170: PPUSH
23171: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
23175: LD_VAR 0 2
23179: PPUSH
23180: LD_INT 2
23182: PPUSH
23183: LD_INT 0
23185: PPUSH
23186: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
23190: LD_VAR 0 2
23194: PPUSH
23195: LD_INT 3
23197: PPUSH
23198: LD_INT 0
23200: PPUSH
23201: CALL_OW 277
// end ;
23205: PPOPN 2
23207: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
23208: LD_EXP 40
23212: PUSH
23213: LD_EXP 68
23217: AND
23218: IFFALSE 23315
23220: GO 23222
23222: DISABLE
23223: LD_INT 0
23225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
23226: LD_ADDR_VAR 0 1
23230: PUSH
23231: LD_INT 22
23233: PUSH
23234: LD_OWVAR 2
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PUSH
23243: LD_INT 21
23245: PUSH
23246: LD_INT 1
23248: PUSH
23249: EMPTY
23250: LIST
23251: LIST
23252: PUSH
23253: LD_INT 3
23255: PUSH
23256: LD_INT 23
23258: PUSH
23259: LD_INT 0
23261: PUSH
23262: EMPTY
23263: LIST
23264: LIST
23265: PUSH
23266: EMPTY
23267: LIST
23268: LIST
23269: PUSH
23270: EMPTY
23271: LIST
23272: LIST
23273: LIST
23274: PPUSH
23275: CALL_OW 69
23279: ST_TO_ADDR
// if not tmp then
23280: LD_VAR 0 1
23284: NOT
23285: IFFALSE 23289
// exit ;
23287: GO 23315
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
23289: LD_VAR 0 1
23293: PUSH
23294: LD_INT 1
23296: PPUSH
23297: LD_VAR 0 1
23301: PPUSH
23302: CALL_OW 12
23306: ARRAY
23307: PPUSH
23308: LD_INT 200
23310: PPUSH
23311: CALL_OW 234
// end ;
23315: PPOPN 1
23317: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
23318: LD_EXP 40
23322: PUSH
23323: LD_EXP 69
23327: AND
23328: IFFALSE 23407
23330: GO 23332
23332: DISABLE
23333: LD_INT 0
23335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
23336: LD_ADDR_VAR 0 1
23340: PUSH
23341: LD_INT 22
23343: PUSH
23344: LD_OWVAR 2
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PUSH
23353: LD_INT 21
23355: PUSH
23356: LD_INT 2
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PPUSH
23367: CALL_OW 69
23371: ST_TO_ADDR
// if not tmp then
23372: LD_VAR 0 1
23376: NOT
23377: IFFALSE 23381
// exit ;
23379: GO 23407
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
23381: LD_VAR 0 1
23385: PUSH
23386: LD_INT 1
23388: PPUSH
23389: LD_VAR 0 1
23393: PPUSH
23394: CALL_OW 12
23398: ARRAY
23399: PPUSH
23400: LD_INT 60
23402: PPUSH
23403: CALL_OW 234
// end ;
23407: PPOPN 1
23409: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
23410: LD_EXP 40
23414: PUSH
23415: LD_EXP 70
23419: AND
23420: IFFALSE 23519
23422: GO 23424
23424: DISABLE
23425: LD_INT 0
23427: PPUSH
23428: PPUSH
// begin enable ;
23429: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
23430: LD_ADDR_VAR 0 1
23434: PUSH
23435: LD_INT 22
23437: PUSH
23438: LD_OWVAR 2
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 61
23449: PUSH
23450: EMPTY
23451: LIST
23452: PUSH
23453: LD_INT 33
23455: PUSH
23456: LD_INT 2
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: LIST
23467: PPUSH
23468: CALL_OW 69
23472: ST_TO_ADDR
// if not tmp then
23473: LD_VAR 0 1
23477: NOT
23478: IFFALSE 23482
// exit ;
23480: GO 23519
// for i in tmp do
23482: LD_ADDR_VAR 0 2
23486: PUSH
23487: LD_VAR 0 1
23491: PUSH
23492: FOR_IN
23493: IFFALSE 23517
// if IsControledBy ( i ) then
23495: LD_VAR 0 2
23499: PPUSH
23500: CALL_OW 312
23504: IFFALSE 23515
// ComUnlink ( i ) ;
23506: LD_VAR 0 2
23510: PPUSH
23511: CALL_OW 136
23515: GO 23492
23517: POP
23518: POP
// end ;
23519: PPOPN 2
23521: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
23522: LD_EXP 40
23526: PUSH
23527: LD_EXP 71
23531: AND
23532: IFFALSE 23672
23534: GO 23536
23536: DISABLE
23537: LD_INT 0
23539: PPUSH
23540: PPUSH
// begin ToLua ( displayPowell(); ) ;
23541: LD_STRING displayPowell();
23543: PPUSH
23544: CALL_OW 559
// uc_side := 0 ;
23548: LD_ADDR_OWVAR 20
23552: PUSH
23553: LD_INT 0
23555: ST_TO_ADDR
// uc_nation := 2 ;
23556: LD_ADDR_OWVAR 21
23560: PUSH
23561: LD_INT 2
23563: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
23564: LD_ADDR_OWVAR 37
23568: PUSH
23569: LD_INT 14
23571: ST_TO_ADDR
// vc_engine := engine_siberite ;
23572: LD_ADDR_OWVAR 39
23576: PUSH
23577: LD_INT 3
23579: ST_TO_ADDR
// vc_control := control_apeman ;
23580: LD_ADDR_OWVAR 38
23584: PUSH
23585: LD_INT 5
23587: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
23588: LD_ADDR_OWVAR 40
23592: PUSH
23593: LD_INT 29
23595: ST_TO_ADDR
// un := CreateVehicle ;
23596: LD_ADDR_VAR 0 2
23600: PUSH
23601: CALL_OW 45
23605: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23606: LD_VAR 0 2
23610: PPUSH
23611: LD_INT 1
23613: PPUSH
23614: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23618: LD_INT 35
23620: PPUSH
23621: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
23625: LD_VAR 0 2
23629: PPUSH
23630: LD_INT 22
23632: PUSH
23633: LD_OWVAR 2
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PPUSH
23642: CALL_OW 69
23646: PPUSH
23647: LD_VAR 0 2
23651: PPUSH
23652: CALL_OW 74
23656: PPUSH
23657: CALL_OW 115
// until IsDead ( un ) ;
23661: LD_VAR 0 2
23665: PPUSH
23666: CALL_OW 301
23670: IFFALSE 23618
// end ;
23672: PPOPN 2
23674: END
// every 0 0$1 trigger StreamModeActive and sStu do
23675: LD_EXP 40
23679: PUSH
23680: LD_EXP 79
23684: AND
23685: IFFALSE 23697
23687: GO 23689
23689: DISABLE
// begin ToLua ( displayStucuk(); ) ;
23690: LD_STRING displayStucuk();
23692: PPUSH
23693: CALL_OW 559
// end ;
23697: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
23698: LD_EXP 40
23702: PUSH
23703: LD_EXP 72
23707: AND
23708: IFFALSE 23849
23710: GO 23712
23712: DISABLE
23713: LD_INT 0
23715: PPUSH
23716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23717: LD_ADDR_VAR 0 2
23721: PUSH
23722: LD_INT 22
23724: PUSH
23725: LD_OWVAR 2
23729: PUSH
23730: EMPTY
23731: LIST
23732: LIST
23733: PUSH
23734: LD_INT 21
23736: PUSH
23737: LD_INT 1
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: PPUSH
23748: CALL_OW 69
23752: ST_TO_ADDR
// if not tmp then
23753: LD_VAR 0 2
23757: NOT
23758: IFFALSE 23762
// exit ;
23760: GO 23849
// un := tmp [ rand ( 1 , tmp ) ] ;
23762: LD_ADDR_VAR 0 1
23766: PUSH
23767: LD_VAR 0 2
23771: PUSH
23772: LD_INT 1
23774: PPUSH
23775: LD_VAR 0 2
23779: PPUSH
23780: CALL_OW 12
23784: ARRAY
23785: ST_TO_ADDR
// SetSide ( un , 0 ) ;
23786: LD_VAR 0 1
23790: PPUSH
23791: LD_INT 0
23793: PPUSH
23794: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
23798: LD_VAR 0 1
23802: PPUSH
23803: LD_OWVAR 3
23807: PUSH
23808: LD_VAR 0 1
23812: DIFF
23813: PPUSH
23814: LD_VAR 0 1
23818: PPUSH
23819: CALL_OW 74
23823: PPUSH
23824: CALL_OW 115
// wait ( 0 0$20 ) ;
23828: LD_INT 700
23830: PPUSH
23831: CALL_OW 67
// SetSide ( un , your_side ) ;
23835: LD_VAR 0 1
23839: PPUSH
23840: LD_OWVAR 2
23844: PPUSH
23845: CALL_OW 235
// end ;
23849: PPOPN 2
23851: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
23852: LD_EXP 40
23856: PUSH
23857: LD_EXP 73
23861: AND
23862: IFFALSE 23968
23864: GO 23866
23866: DISABLE
23867: LD_INT 0
23869: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23870: LD_ADDR_VAR 0 1
23874: PUSH
23875: LD_INT 22
23877: PUSH
23878: LD_OWVAR 2
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: LD_INT 0
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_INT 1
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: LIST
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: PPUSH
23919: CALL_OW 69
23923: ST_TO_ADDR
// if not depot then
23924: LD_VAR 0 1
23928: NOT
23929: IFFALSE 23933
// exit ;
23931: GO 23968
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
23933: LD_VAR 0 1
23937: PUSH
23938: LD_INT 1
23940: ARRAY
23941: PPUSH
23942: CALL_OW 250
23946: PPUSH
23947: LD_VAR 0 1
23951: PUSH
23952: LD_INT 1
23954: ARRAY
23955: PPUSH
23956: CALL_OW 251
23960: PPUSH
23961: LD_INT 70
23963: PPUSH
23964: CALL_OW 495
// end ;
23968: PPOPN 1
23970: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
23971: LD_EXP 40
23975: PUSH
23976: LD_EXP 74
23980: AND
23981: IFFALSE 24192
23983: GO 23985
23985: DISABLE
23986: LD_INT 0
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23993: LD_ADDR_VAR 0 5
23997: PUSH
23998: LD_INT 22
24000: PUSH
24001: LD_OWVAR 2
24005: PUSH
24006: EMPTY
24007: LIST
24008: LIST
24009: PUSH
24010: LD_INT 21
24012: PUSH
24013: LD_INT 1
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PPUSH
24024: CALL_OW 69
24028: ST_TO_ADDR
// if not tmp then
24029: LD_VAR 0 5
24033: NOT
24034: IFFALSE 24038
// exit ;
24036: GO 24192
// for i in tmp do
24038: LD_ADDR_VAR 0 1
24042: PUSH
24043: LD_VAR 0 5
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24190
// begin d := rand ( 0 , 5 ) ;
24051: LD_ADDR_VAR 0 4
24055: PUSH
24056: LD_INT 0
24058: PPUSH
24059: LD_INT 5
24061: PPUSH
24062: CALL_OW 12
24066: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
24067: LD_ADDR_VAR 0 2
24071: PUSH
24072: LD_VAR 0 1
24076: PPUSH
24077: CALL_OW 250
24081: PPUSH
24082: LD_VAR 0 4
24086: PPUSH
24087: LD_INT 3
24089: PPUSH
24090: LD_INT 12
24092: PPUSH
24093: CALL_OW 12
24097: PPUSH
24098: CALL_OW 272
24102: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
24103: LD_ADDR_VAR 0 3
24107: PUSH
24108: LD_VAR 0 1
24112: PPUSH
24113: CALL_OW 251
24117: PPUSH
24118: LD_VAR 0 4
24122: PPUSH
24123: LD_INT 3
24125: PPUSH
24126: LD_INT 12
24128: PPUSH
24129: CALL_OW 12
24133: PPUSH
24134: CALL_OW 273
24138: ST_TO_ADDR
// if ValidHex ( x , y ) then
24139: LD_VAR 0 2
24143: PPUSH
24144: LD_VAR 0 3
24148: PPUSH
24149: CALL_OW 488
24153: IFFALSE 24188
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
24155: LD_VAR 0 1
24159: PPUSH
24160: LD_VAR 0 2
24164: PPUSH
24165: LD_VAR 0 3
24169: PPUSH
24170: LD_INT 3
24172: PPUSH
24173: LD_INT 6
24175: PPUSH
24176: CALL_OW 12
24180: PPUSH
24181: LD_INT 1
24183: PPUSH
24184: CALL_OW 483
// end ;
24188: GO 24048
24190: POP
24191: POP
// end ;
24192: PPOPN 5
24194: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
24195: LD_EXP 40
24199: PUSH
24200: LD_EXP 75
24204: AND
24205: IFFALSE 24299
24207: GO 24209
24209: DISABLE
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
24214: LD_ADDR_VAR 0 2
24218: PUSH
24219: LD_INT 22
24221: PUSH
24222: LD_OWVAR 2
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 32
24233: PUSH
24234: LD_INT 1
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: LD_INT 21
24243: PUSH
24244: LD_INT 2
24246: PUSH
24247: EMPTY
24248: LIST
24249: LIST
24250: PUSH
24251: EMPTY
24252: LIST
24253: LIST
24254: LIST
24255: PPUSH
24256: CALL_OW 69
24260: ST_TO_ADDR
// if not tmp then
24261: LD_VAR 0 2
24265: NOT
24266: IFFALSE 24270
// exit ;
24268: GO 24299
// for i in tmp do
24270: LD_ADDR_VAR 0 1
24274: PUSH
24275: LD_VAR 0 2
24279: PUSH
24280: FOR_IN
24281: IFFALSE 24297
// SetFuel ( i , 0 ) ;
24283: LD_VAR 0 1
24287: PPUSH
24288: LD_INT 0
24290: PPUSH
24291: CALL_OW 240
24295: GO 24280
24297: POP
24298: POP
// end ;
24299: PPOPN 2
24301: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
24302: LD_EXP 40
24306: PUSH
24307: LD_EXP 76
24311: AND
24312: IFFALSE 24378
24314: GO 24316
24316: DISABLE
24317: LD_INT 0
24319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
24320: LD_ADDR_VAR 0 1
24324: PUSH
24325: LD_INT 22
24327: PUSH
24328: LD_OWVAR 2
24332: PUSH
24333: EMPTY
24334: LIST
24335: LIST
24336: PUSH
24337: LD_INT 30
24339: PUSH
24340: LD_INT 29
24342: PUSH
24343: EMPTY
24344: LIST
24345: LIST
24346: PUSH
24347: EMPTY
24348: LIST
24349: LIST
24350: PPUSH
24351: CALL_OW 69
24355: ST_TO_ADDR
// if not tmp then
24356: LD_VAR 0 1
24360: NOT
24361: IFFALSE 24365
// exit ;
24363: GO 24378
// DestroyUnit ( tmp [ 1 ] ) ;
24365: LD_VAR 0 1
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: CALL_OW 65
// end ;
24378: PPOPN 1
24380: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
24381: LD_EXP 40
24385: PUSH
24386: LD_EXP 78
24390: AND
24391: IFFALSE 24520
24393: GO 24395
24395: DISABLE
24396: LD_INT 0
24398: PPUSH
// begin uc_side := 0 ;
24399: LD_ADDR_OWVAR 20
24403: PUSH
24404: LD_INT 0
24406: ST_TO_ADDR
// uc_nation := nation_arabian ;
24407: LD_ADDR_OWVAR 21
24411: PUSH
24412: LD_INT 2
24414: ST_TO_ADDR
// hc_gallery :=  ;
24415: LD_ADDR_OWVAR 33
24419: PUSH
24420: LD_STRING 
24422: ST_TO_ADDR
// hc_name :=  ;
24423: LD_ADDR_OWVAR 26
24427: PUSH
24428: LD_STRING 
24430: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
24431: LD_INT 1
24433: PPUSH
24434: LD_INT 11
24436: PPUSH
24437: LD_INT 10
24439: PPUSH
24440: CALL_OW 380
// un := CreateHuman ;
24444: LD_ADDR_VAR 0 1
24448: PUSH
24449: CALL_OW 44
24453: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
24454: LD_VAR 0 1
24458: PPUSH
24459: LD_INT 1
24461: PPUSH
24462: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
24466: LD_INT 35
24468: PPUSH
24469: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
24473: LD_VAR 0 1
24477: PPUSH
24478: LD_INT 22
24480: PUSH
24481: LD_OWVAR 2
24485: PUSH
24486: EMPTY
24487: LIST
24488: LIST
24489: PPUSH
24490: CALL_OW 69
24494: PPUSH
24495: LD_VAR 0 1
24499: PPUSH
24500: CALL_OW 74
24504: PPUSH
24505: CALL_OW 115
// until IsDead ( un ) ;
24509: LD_VAR 0 1
24513: PPUSH
24514: CALL_OW 301
24518: IFFALSE 24466
// end ;
24520: PPOPN 1
24522: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
24523: LD_EXP 40
24527: PUSH
24528: LD_EXP 80
24532: AND
24533: IFFALSE 24545
24535: GO 24537
24537: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
24538: LD_STRING earthquake(getX(game), 0, 32)
24540: PPUSH
24541: CALL_OW 559
24545: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
24546: LD_EXP 40
24550: PUSH
24551: LD_EXP 81
24555: AND
24556: IFFALSE 24647
24558: GO 24560
24560: DISABLE
24561: LD_INT 0
24563: PPUSH
// begin enable ;
24564: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
24565: LD_ADDR_VAR 0 1
24569: PUSH
24570: LD_INT 22
24572: PUSH
24573: LD_OWVAR 2
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: PUSH
24582: LD_INT 21
24584: PUSH
24585: LD_INT 2
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: PUSH
24592: LD_INT 33
24594: PUSH
24595: LD_INT 3
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: LIST
24606: PPUSH
24607: CALL_OW 69
24611: ST_TO_ADDR
// if not tmp then
24612: LD_VAR 0 1
24616: NOT
24617: IFFALSE 24621
// exit ;
24619: GO 24647
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
24621: LD_VAR 0 1
24625: PUSH
24626: LD_INT 1
24628: PPUSH
24629: LD_VAR 0 1
24633: PPUSH
24634: CALL_OW 12
24638: ARRAY
24639: PPUSH
24640: LD_INT 1
24642: PPUSH
24643: CALL_OW 234
// end ;
24647: PPOPN 1
24649: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
24650: LD_EXP 40
24654: PUSH
24655: LD_EXP 82
24659: AND
24660: IFFALSE 24801
24662: GO 24664
24664: DISABLE
24665: LD_INT 0
24667: PPUSH
24668: PPUSH
24669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24670: LD_ADDR_VAR 0 3
24674: PUSH
24675: LD_INT 22
24677: PUSH
24678: LD_OWVAR 2
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 25
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: EMPTY
24698: LIST
24699: LIST
24700: PPUSH
24701: CALL_OW 69
24705: ST_TO_ADDR
// if not tmp then
24706: LD_VAR 0 3
24710: NOT
24711: IFFALSE 24715
// exit ;
24713: GO 24801
// un := tmp [ rand ( 1 , tmp ) ] ;
24715: LD_ADDR_VAR 0 2
24719: PUSH
24720: LD_VAR 0 3
24724: PUSH
24725: LD_INT 1
24727: PPUSH
24728: LD_VAR 0 3
24732: PPUSH
24733: CALL_OW 12
24737: ARRAY
24738: ST_TO_ADDR
// if Crawls ( un ) then
24739: LD_VAR 0 2
24743: PPUSH
24744: CALL_OW 318
24748: IFFALSE 24759
// ComWalk ( un ) ;
24750: LD_VAR 0 2
24754: PPUSH
24755: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
24759: LD_VAR 0 2
24763: PPUSH
24764: LD_INT 9
24766: PPUSH
24767: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
24771: LD_INT 28
24773: PPUSH
24774: LD_OWVAR 2
24778: PPUSH
24779: LD_INT 2
24781: PPUSH
24782: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
24786: LD_INT 29
24788: PPUSH
24789: LD_OWVAR 2
24793: PPUSH
24794: LD_INT 2
24796: PPUSH
24797: CALL_OW 322
// end ;
24801: PPOPN 3
24803: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
24804: LD_EXP 40
24808: PUSH
24809: LD_EXP 83
24813: AND
24814: IFFALSE 24925
24816: GO 24818
24818: DISABLE
24819: LD_INT 0
24821: PPUSH
24822: PPUSH
24823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24824: LD_ADDR_VAR 0 3
24828: PUSH
24829: LD_INT 22
24831: PUSH
24832: LD_OWVAR 2
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 25
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: ST_TO_ADDR
// if not tmp then
24860: LD_VAR 0 3
24864: NOT
24865: IFFALSE 24869
// exit ;
24867: GO 24925
// un := tmp [ rand ( 1 , tmp ) ] ;
24869: LD_ADDR_VAR 0 2
24873: PUSH
24874: LD_VAR 0 3
24878: PUSH
24879: LD_INT 1
24881: PPUSH
24882: LD_VAR 0 3
24886: PPUSH
24887: CALL_OW 12
24891: ARRAY
24892: ST_TO_ADDR
// if Crawls ( un ) then
24893: LD_VAR 0 2
24897: PPUSH
24898: CALL_OW 318
24902: IFFALSE 24913
// ComWalk ( un ) ;
24904: LD_VAR 0 2
24908: PPUSH
24909: CALL_OW 138
// SetClass ( un , class_mortar ) ;
24913: LD_VAR 0 2
24917: PPUSH
24918: LD_INT 8
24920: PPUSH
24921: CALL_OW 336
// end ;
24925: PPOPN 3
24927: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
24928: LD_EXP 40
24932: PUSH
24933: LD_EXP 84
24937: AND
24938: IFFALSE 25082
24940: GO 24942
24942: DISABLE
24943: LD_INT 0
24945: PPUSH
24946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
24947: LD_ADDR_VAR 0 2
24951: PUSH
24952: LD_INT 22
24954: PUSH
24955: LD_OWVAR 2
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PUSH
24964: LD_INT 21
24966: PUSH
24967: LD_INT 2
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 2
24976: PUSH
24977: LD_INT 34
24979: PUSH
24980: LD_INT 12
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PUSH
24987: LD_INT 34
24989: PUSH
24990: LD_INT 51
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: PUSH
24997: LD_INT 34
24999: PUSH
25000: LD_INT 32
25002: PUSH
25003: EMPTY
25004: LIST
25005: LIST
25006: PUSH
25007: EMPTY
25008: LIST
25009: LIST
25010: LIST
25011: LIST
25012: PUSH
25013: EMPTY
25014: LIST
25015: LIST
25016: LIST
25017: PPUSH
25018: CALL_OW 69
25022: ST_TO_ADDR
// if not tmp then
25023: LD_VAR 0 2
25027: NOT
25028: IFFALSE 25032
// exit ;
25030: GO 25082
// for i in tmp do
25032: LD_ADDR_VAR 0 1
25036: PUSH
25037: LD_VAR 0 2
25041: PUSH
25042: FOR_IN
25043: IFFALSE 25080
// if GetCargo ( i , mat_artifact ) = 0 then
25045: LD_VAR 0 1
25049: PPUSH
25050: LD_INT 4
25052: PPUSH
25053: CALL_OW 289
25057: PUSH
25058: LD_INT 0
25060: EQUAL
25061: IFFALSE 25078
// SetCargo ( i , mat_siberit , 100 ) ;
25063: LD_VAR 0 1
25067: PPUSH
25068: LD_INT 3
25070: PPUSH
25071: LD_INT 100
25073: PPUSH
25074: CALL_OW 290
25078: GO 25042
25080: POP
25081: POP
// end ;
25082: PPOPN 2
25084: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
25085: LD_EXP 40
25089: PUSH
25090: LD_EXP 85
25094: AND
25095: IFFALSE 25248
25097: GO 25099
25099: DISABLE
25100: LD_INT 0
25102: PPUSH
25103: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
25104: LD_ADDR_VAR 0 2
25108: PUSH
25109: LD_INT 22
25111: PUSH
25112: LD_OWVAR 2
25116: PUSH
25117: EMPTY
25118: LIST
25119: LIST
25120: PPUSH
25121: CALL_OW 69
25125: ST_TO_ADDR
// if not tmp then
25126: LD_VAR 0 2
25130: NOT
25131: IFFALSE 25135
// exit ;
25133: GO 25248
// for i := 1 to 2 do
25135: LD_ADDR_VAR 0 1
25139: PUSH
25140: DOUBLE
25141: LD_INT 1
25143: DEC
25144: ST_TO_ADDR
25145: LD_INT 2
25147: PUSH
25148: FOR_TO
25149: IFFALSE 25246
// begin uc_side := your_side ;
25151: LD_ADDR_OWVAR 20
25155: PUSH
25156: LD_OWVAR 2
25160: ST_TO_ADDR
// uc_nation := nation_american ;
25161: LD_ADDR_OWVAR 21
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// vc_chassis := us_morphling ;
25169: LD_ADDR_OWVAR 37
25173: PUSH
25174: LD_INT 5
25176: ST_TO_ADDR
// vc_engine := engine_siberite ;
25177: LD_ADDR_OWVAR 39
25181: PUSH
25182: LD_INT 3
25184: ST_TO_ADDR
// vc_control := control_computer ;
25185: LD_ADDR_OWVAR 38
25189: PUSH
25190: LD_INT 3
25192: ST_TO_ADDR
// vc_weapon := us_double_laser ;
25193: LD_ADDR_OWVAR 40
25197: PUSH
25198: LD_INT 10
25200: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
25201: CALL_OW 45
25205: PPUSH
25206: LD_VAR 0 2
25210: PUSH
25211: LD_INT 1
25213: ARRAY
25214: PPUSH
25215: CALL_OW 250
25219: PPUSH
25220: LD_VAR 0 2
25224: PUSH
25225: LD_INT 1
25227: ARRAY
25228: PPUSH
25229: CALL_OW 251
25233: PPUSH
25234: LD_INT 12
25236: PPUSH
25237: LD_INT 1
25239: PPUSH
25240: CALL_OW 50
// end ;
25244: GO 25148
25246: POP
25247: POP
// end ;
25248: PPOPN 2
25250: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
25251: LD_EXP 40
25255: PUSH
25256: LD_EXP 86
25260: AND
25261: IFFALSE 25483
25263: GO 25265
25265: DISABLE
25266: LD_INT 0
25268: PPUSH
25269: PPUSH
25270: PPUSH
25271: PPUSH
25272: PPUSH
25273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25274: LD_ADDR_VAR 0 6
25278: PUSH
25279: LD_INT 22
25281: PUSH
25282: LD_OWVAR 2
25286: PUSH
25287: EMPTY
25288: LIST
25289: LIST
25290: PUSH
25291: LD_INT 21
25293: PUSH
25294: LD_INT 1
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: PUSH
25301: LD_INT 3
25303: PUSH
25304: LD_INT 23
25306: PUSH
25307: LD_INT 0
25309: PUSH
25310: EMPTY
25311: LIST
25312: LIST
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: EMPTY
25319: LIST
25320: LIST
25321: LIST
25322: PPUSH
25323: CALL_OW 69
25327: ST_TO_ADDR
// if not tmp then
25328: LD_VAR 0 6
25332: NOT
25333: IFFALSE 25337
// exit ;
25335: GO 25483
// s1 := rand ( 1 , 4 ) ;
25337: LD_ADDR_VAR 0 2
25341: PUSH
25342: LD_INT 1
25344: PPUSH
25345: LD_INT 4
25347: PPUSH
25348: CALL_OW 12
25352: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
25353: LD_ADDR_VAR 0 4
25357: PUSH
25358: LD_VAR 0 6
25362: PUSH
25363: LD_INT 1
25365: ARRAY
25366: PPUSH
25367: LD_VAR 0 2
25371: PPUSH
25372: CALL_OW 259
25376: ST_TO_ADDR
// if s1 = 1 then
25377: LD_VAR 0 2
25381: PUSH
25382: LD_INT 1
25384: EQUAL
25385: IFFALSE 25405
// s2 := rand ( 2 , 4 ) else
25387: LD_ADDR_VAR 0 3
25391: PUSH
25392: LD_INT 2
25394: PPUSH
25395: LD_INT 4
25397: PPUSH
25398: CALL_OW 12
25402: ST_TO_ADDR
25403: GO 25413
// s2 := 1 ;
25405: LD_ADDR_VAR 0 3
25409: PUSH
25410: LD_INT 1
25412: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
25413: LD_ADDR_VAR 0 5
25417: PUSH
25418: LD_VAR 0 6
25422: PUSH
25423: LD_INT 1
25425: ARRAY
25426: PPUSH
25427: LD_VAR 0 3
25431: PPUSH
25432: CALL_OW 259
25436: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
25437: LD_VAR 0 6
25441: PUSH
25442: LD_INT 1
25444: ARRAY
25445: PPUSH
25446: LD_VAR 0 2
25450: PPUSH
25451: LD_VAR 0 5
25455: PPUSH
25456: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
25460: LD_VAR 0 6
25464: PUSH
25465: LD_INT 1
25467: ARRAY
25468: PPUSH
25469: LD_VAR 0 3
25473: PPUSH
25474: LD_VAR 0 4
25478: PPUSH
25479: CALL_OW 237
// end ;
25483: PPOPN 6
25485: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
25486: LD_EXP 40
25490: PUSH
25491: LD_EXP 87
25495: AND
25496: IFFALSE 25575
25498: GO 25500
25500: DISABLE
25501: LD_INT 0
25503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
25504: LD_ADDR_VAR 0 1
25508: PUSH
25509: LD_INT 22
25511: PUSH
25512: LD_OWVAR 2
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: LD_INT 30
25523: PUSH
25524: LD_INT 3
25526: PUSH
25527: EMPTY
25528: LIST
25529: LIST
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: PPUSH
25535: CALL_OW 69
25539: ST_TO_ADDR
// if not tmp then
25540: LD_VAR 0 1
25544: NOT
25545: IFFALSE 25549
// exit ;
25547: GO 25575
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
25549: LD_VAR 0 1
25553: PUSH
25554: LD_INT 1
25556: PPUSH
25557: LD_VAR 0 1
25561: PPUSH
25562: CALL_OW 12
25566: ARRAY
25567: PPUSH
25568: LD_INT 1
25570: PPUSH
25571: CALL_OW 234
// end ;
25575: PPOPN 1
25577: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
25578: LD_EXP 40
25582: PUSH
25583: LD_EXP 88
25587: AND
25588: IFFALSE 25700
25590: GO 25592
25592: DISABLE
25593: LD_INT 0
25595: PPUSH
25596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
25597: LD_ADDR_VAR 0 2
25601: PUSH
25602: LD_INT 22
25604: PUSH
25605: LD_OWVAR 2
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: PUSH
25614: LD_INT 2
25616: PUSH
25617: LD_INT 30
25619: PUSH
25620: LD_INT 27
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: LD_INT 30
25629: PUSH
25630: LD_INT 26
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PUSH
25637: LD_INT 30
25639: PUSH
25640: LD_INT 28
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: LIST
25651: LIST
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: PPUSH
25657: CALL_OW 69
25661: ST_TO_ADDR
// if not tmp then
25662: LD_VAR 0 2
25666: NOT
25667: IFFALSE 25671
// exit ;
25669: GO 25700
// for i in tmp do
25671: LD_ADDR_VAR 0 1
25675: PUSH
25676: LD_VAR 0 2
25680: PUSH
25681: FOR_IN
25682: IFFALSE 25698
// SetLives ( i , 1 ) ;
25684: LD_VAR 0 1
25688: PPUSH
25689: LD_INT 1
25691: PPUSH
25692: CALL_OW 234
25696: GO 25681
25698: POP
25699: POP
// end ;
25700: PPOPN 2
25702: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
25703: LD_EXP 40
25707: PUSH
25708: LD_EXP 89
25712: AND
25713: IFFALSE 25983
25715: GO 25717
25717: DISABLE
25718: LD_INT 0
25720: PPUSH
25721: PPUSH
25722: PPUSH
// begin i := rand ( 1 , 7 ) ;
25723: LD_ADDR_VAR 0 1
25727: PUSH
25728: LD_INT 1
25730: PPUSH
25731: LD_INT 7
25733: PPUSH
25734: CALL_OW 12
25738: ST_TO_ADDR
// case i of 1 :
25739: LD_VAR 0 1
25743: PUSH
25744: LD_INT 1
25746: DOUBLE
25747: EQUAL
25748: IFTRUE 25752
25750: GO 25762
25752: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
25753: LD_STRING earthquake(getX(game), 0, 32)
25755: PPUSH
25756: CALL_OW 559
25760: GO 25983
25762: LD_INT 2
25764: DOUBLE
25765: EQUAL
25766: IFTRUE 25770
25768: GO 25780
25770: POP
// ToLua ( displayStucuk(); ) ; 3 :
25771: LD_STRING displayStucuk();
25773: PPUSH
25774: CALL_OW 559
25778: GO 25983
25780: LD_INT 3
25782: DOUBLE
25783: EQUAL
25784: IFTRUE 25788
25786: GO 25892
25788: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25789: LD_ADDR_VAR 0 2
25793: PUSH
25794: LD_INT 22
25796: PUSH
25797: LD_OWVAR 2
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 25
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PPUSH
25820: CALL_OW 69
25824: ST_TO_ADDR
// if not tmp then
25825: LD_VAR 0 2
25829: NOT
25830: IFFALSE 25834
// exit ;
25832: GO 25983
// un := tmp [ rand ( 1 , tmp ) ] ;
25834: LD_ADDR_VAR 0 3
25838: PUSH
25839: LD_VAR 0 2
25843: PUSH
25844: LD_INT 1
25846: PPUSH
25847: LD_VAR 0 2
25851: PPUSH
25852: CALL_OW 12
25856: ARRAY
25857: ST_TO_ADDR
// if Crawls ( un ) then
25858: LD_VAR 0 3
25862: PPUSH
25863: CALL_OW 318
25867: IFFALSE 25878
// ComWalk ( un ) ;
25869: LD_VAR 0 3
25873: PPUSH
25874: CALL_OW 138
// SetClass ( un , class_mortar ) ;
25878: LD_VAR 0 3
25882: PPUSH
25883: LD_INT 8
25885: PPUSH
25886: CALL_OW 336
// end ; 4 :
25890: GO 25983
25892: LD_INT 4
25894: DOUBLE
25895: EQUAL
25896: IFTRUE 25900
25898: GO 25961
25900: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
25901: LD_ADDR_VAR 0 2
25905: PUSH
25906: LD_INT 22
25908: PUSH
25909: LD_OWVAR 2
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 30
25920: PUSH
25921: LD_INT 29
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PPUSH
25932: CALL_OW 69
25936: ST_TO_ADDR
// if not tmp then
25937: LD_VAR 0 2
25941: NOT
25942: IFFALSE 25946
// exit ;
25944: GO 25983
// DestroyUnit ( tmp [ 1 ] ) ;
25946: LD_VAR 0 2
25950: PUSH
25951: LD_INT 1
25953: ARRAY
25954: PPUSH
25955: CALL_OW 65
// end ; 5 .. 7 :
25959: GO 25983
25961: LD_INT 5
25963: DOUBLE
25964: GREATEREQUAL
25965: IFFALSE 25973
25967: LD_INT 7
25969: DOUBLE
25970: LESSEQUAL
25971: IFTRUE 25975
25973: GO 25982
25975: POP
// StreamSibBomb ; end ;
25976: CALL 22271 0 0
25980: GO 25983
25982: POP
// end ;
25983: PPOPN 3
25985: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
25986: LD_EXP 40
25990: PUSH
25991: LD_EXP 90
25995: AND
25996: IFFALSE 26152
25998: GO 26000
26000: DISABLE
26001: LD_INT 0
26003: PPUSH
26004: PPUSH
26005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
26006: LD_ADDR_VAR 0 2
26010: PUSH
26011: LD_INT 81
26013: PUSH
26014: LD_OWVAR 2
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 2
26025: PUSH
26026: LD_INT 21
26028: PUSH
26029: LD_INT 1
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 21
26038: PUSH
26039: LD_INT 2
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: LIST
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PPUSH
26055: CALL_OW 69
26059: ST_TO_ADDR
// if not tmp then
26060: LD_VAR 0 2
26064: NOT
26065: IFFALSE 26069
// exit ;
26067: GO 26152
// p := 0 ;
26069: LD_ADDR_VAR 0 3
26073: PUSH
26074: LD_INT 0
26076: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26077: LD_INT 35
26079: PPUSH
26080: CALL_OW 67
// p := p + 1 ;
26084: LD_ADDR_VAR 0 3
26088: PUSH
26089: LD_VAR 0 3
26093: PUSH
26094: LD_INT 1
26096: PLUS
26097: ST_TO_ADDR
// for i in tmp do
26098: LD_ADDR_VAR 0 1
26102: PUSH
26103: LD_VAR 0 2
26107: PUSH
26108: FOR_IN
26109: IFFALSE 26140
// if GetLives ( i ) < 1000 then
26111: LD_VAR 0 1
26115: PPUSH
26116: CALL_OW 256
26120: PUSH
26121: LD_INT 1000
26123: LESS
26124: IFFALSE 26138
// SetLives ( i , 1000 ) ;
26126: LD_VAR 0 1
26130: PPUSH
26131: LD_INT 1000
26133: PPUSH
26134: CALL_OW 234
26138: GO 26108
26140: POP
26141: POP
// until p > 20 ;
26142: LD_VAR 0 3
26146: PUSH
26147: LD_INT 20
26149: GREATER
26150: IFFALSE 26077
// end ;
26152: PPOPN 3
26154: END
// every 0 0$1 trigger StreamModeActive and sTime do
26155: LD_EXP 40
26159: PUSH
26160: LD_EXP 91
26164: AND
26165: IFFALSE 26200
26167: GO 26169
26169: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
26170: LD_INT 28
26172: PPUSH
26173: LD_OWVAR 2
26177: PPUSH
26178: LD_INT 2
26180: PPUSH
26181: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
26185: LD_INT 30
26187: PPUSH
26188: LD_OWVAR 2
26192: PPUSH
26193: LD_INT 2
26195: PPUSH
26196: CALL_OW 322
// end ;
26200: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
26201: LD_EXP 40
26205: PUSH
26206: LD_EXP 92
26210: AND
26211: IFFALSE 26332
26213: GO 26215
26215: DISABLE
26216: LD_INT 0
26218: PPUSH
26219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26220: LD_ADDR_VAR 0 2
26224: PUSH
26225: LD_INT 22
26227: PUSH
26228: LD_OWVAR 2
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 21
26239: PUSH
26240: LD_INT 1
26242: PUSH
26243: EMPTY
26244: LIST
26245: LIST
26246: PUSH
26247: LD_INT 3
26249: PUSH
26250: LD_INT 23
26252: PUSH
26253: LD_INT 0
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: LIST
26268: PPUSH
26269: CALL_OW 69
26273: ST_TO_ADDR
// if not tmp then
26274: LD_VAR 0 2
26278: NOT
26279: IFFALSE 26283
// exit ;
26281: GO 26332
// for i in tmp do
26283: LD_ADDR_VAR 0 1
26287: PUSH
26288: LD_VAR 0 2
26292: PUSH
26293: FOR_IN
26294: IFFALSE 26330
// begin if Crawls ( i ) then
26296: LD_VAR 0 1
26300: PPUSH
26301: CALL_OW 318
26305: IFFALSE 26316
// ComWalk ( i ) ;
26307: LD_VAR 0 1
26311: PPUSH
26312: CALL_OW 138
// SetClass ( i , 2 ) ;
26316: LD_VAR 0 1
26320: PPUSH
26321: LD_INT 2
26323: PPUSH
26324: CALL_OW 336
// end ;
26328: GO 26293
26330: POP
26331: POP
// end ;
26332: PPOPN 2
26334: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
26335: LD_EXP 40
26339: PUSH
26340: LD_EXP 93
26344: AND
26345: IFFALSE 26566
26347: GO 26349
26349: DISABLE
26350: LD_INT 0
26352: PPUSH
26353: PPUSH
26354: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
26355: LD_OWVAR 2
26359: PPUSH
26360: LD_INT 9
26362: PPUSH
26363: LD_INT 1
26365: PPUSH
26366: LD_INT 1
26368: PPUSH
26369: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
26373: LD_INT 9
26375: PPUSH
26376: LD_OWVAR 2
26380: PPUSH
26381: CALL_OW 343
// uc_side := 9 ;
26385: LD_ADDR_OWVAR 20
26389: PUSH
26390: LD_INT 9
26392: ST_TO_ADDR
// uc_nation := 2 ;
26393: LD_ADDR_OWVAR 21
26397: PUSH
26398: LD_INT 2
26400: ST_TO_ADDR
// hc_name := Dark Warrior ;
26401: LD_ADDR_OWVAR 26
26405: PUSH
26406: LD_STRING Dark Warrior
26408: ST_TO_ADDR
// hc_gallery :=  ;
26409: LD_ADDR_OWVAR 33
26413: PUSH
26414: LD_STRING 
26416: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
26417: LD_INT 1
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: LD_INT 10
26425: PPUSH
26426: CALL_OW 380
// un := CreateHuman ;
26430: LD_ADDR_VAR 0 3
26434: PUSH
26435: CALL_OW 44
26439: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26440: LD_VAR 0 3
26444: PPUSH
26445: LD_INT 1
26447: PPUSH
26448: CALL_OW 51
// p := 0 ;
26452: LD_ADDR_VAR 0 2
26456: PUSH
26457: LD_INT 0
26459: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26460: LD_INT 35
26462: PPUSH
26463: CALL_OW 67
// if GetLives ( un ) < 1000 then
26467: LD_VAR 0 3
26471: PPUSH
26472: CALL_OW 256
26476: PUSH
26477: LD_INT 1000
26479: LESS
26480: IFFALSE 26494
// SetLives ( un , 1000 ) ;
26482: LD_VAR 0 3
26486: PPUSH
26487: LD_INT 1000
26489: PPUSH
26490: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
26494: LD_VAR 0 3
26498: PPUSH
26499: LD_INT 81
26501: PUSH
26502: LD_OWVAR 2
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PPUSH
26511: CALL_OW 69
26515: PPUSH
26516: LD_VAR 0 3
26520: PPUSH
26521: CALL_OW 74
26525: PPUSH
26526: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
26530: LD_VAR 0 2
26534: PUSH
26535: LD_INT 60
26537: GREATER
26538: PUSH
26539: LD_VAR 0 3
26543: PPUSH
26544: CALL_OW 301
26548: OR
26549: IFFALSE 26460
// if un then
26551: LD_VAR 0 3
26555: IFFALSE 26566
// RemoveUnit ( un ) ;
26557: LD_VAR 0 3
26561: PPUSH
26562: CALL_OW 64
// end ; end_of_file
26566: PPOPN 3
26568: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
26569: LD_INT 0
26571: PPUSH
26572: PPUSH
26573: PPUSH
26574: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
26575: LD_VAR 0 1
26579: PPUSH
26580: CALL_OW 264
26584: PUSH
26585: LD_EXP 39
26589: EQUAL
26590: IFFALSE 26662
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
26592: LD_INT 68
26594: PPUSH
26595: LD_VAR 0 1
26599: PPUSH
26600: CALL_OW 255
26604: PPUSH
26605: CALL_OW 321
26609: PUSH
26610: LD_INT 2
26612: EQUAL
26613: IFFALSE 26625
// eff := 70 else
26615: LD_ADDR_VAR 0 6
26619: PUSH
26620: LD_INT 70
26622: ST_TO_ADDR
26623: GO 26633
// eff := 30 ;
26625: LD_ADDR_VAR 0 6
26629: PUSH
26630: LD_INT 30
26632: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
26633: LD_VAR 0 1
26637: PPUSH
26638: CALL_OW 250
26642: PPUSH
26643: LD_VAR 0 1
26647: PPUSH
26648: CALL_OW 251
26652: PPUSH
26653: LD_VAR 0 6
26657: PPUSH
26658: CALL_OW 495
// end ; end ;
26662: LD_VAR 0 4
26666: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
26667: LD_INT 0
26669: PPUSH
26670: PPUSH
26671: PPUSH
26672: PPUSH
26673: PPUSH
26674: PPUSH
// if cmd = 124 then
26675: LD_VAR 0 1
26679: PUSH
26680: LD_INT 124
26682: EQUAL
26683: IFFALSE 26889
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
26685: LD_ADDR_VAR 0 5
26689: PUSH
26690: LD_INT 2
26692: PUSH
26693: LD_INT 34
26695: PUSH
26696: LD_INT 53
26698: PUSH
26699: EMPTY
26700: LIST
26701: LIST
26702: PUSH
26703: LD_INT 34
26705: PUSH
26706: LD_INT 14
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: LIST
26717: PPUSH
26718: CALL_OW 69
26722: ST_TO_ADDR
// if not tmp then
26723: LD_VAR 0 5
26727: NOT
26728: IFFALSE 26732
// exit ;
26730: GO 26889
// for i in tmp do
26732: LD_ADDR_VAR 0 3
26736: PUSH
26737: LD_VAR 0 5
26741: PUSH
26742: FOR_IN
26743: IFFALSE 26887
// begin taskList := GetTaskList ( i ) ;
26745: LD_ADDR_VAR 0 6
26749: PUSH
26750: LD_VAR 0 3
26754: PPUSH
26755: CALL_OW 437
26759: ST_TO_ADDR
// if not taskList then
26760: LD_VAR 0 6
26764: NOT
26765: IFFALSE 26769
// continue ;
26767: GO 26742
// for j = 1 to taskList do
26769: LD_ADDR_VAR 0 4
26773: PUSH
26774: DOUBLE
26775: LD_INT 1
26777: DEC
26778: ST_TO_ADDR
26779: LD_VAR 0 6
26783: PUSH
26784: FOR_TO
26785: IFFALSE 26883
// if taskList [ j ] [ 1 ] = | then
26787: LD_VAR 0 6
26791: PUSH
26792: LD_VAR 0 4
26796: ARRAY
26797: PUSH
26798: LD_INT 1
26800: ARRAY
26801: PUSH
26802: LD_STRING |
26804: EQUAL
26805: IFFALSE 26881
// begin _taskList := Delete ( taskList , 1 ) ;
26807: LD_ADDR_VAR 0 7
26811: PUSH
26812: LD_VAR 0 6
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 3
26824: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
26825: LD_VAR 0 3
26829: PPUSH
26830: LD_VAR 0 7
26834: PPUSH
26835: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
26839: LD_VAR 0 3
26843: PPUSH
26844: LD_VAR 0 6
26848: PUSH
26849: LD_VAR 0 4
26853: ARRAY
26854: PUSH
26855: LD_INT 2
26857: ARRAY
26858: PPUSH
26859: LD_VAR 0 6
26863: PUSH
26864: LD_VAR 0 4
26868: ARRAY
26869: PUSH
26870: LD_INT 3
26872: ARRAY
26873: PPUSH
26874: LD_INT 8
26876: PPUSH
26877: CALL 26894 0 4
// end ;
26881: GO 26784
26883: POP
26884: POP
// end ;
26885: GO 26742
26887: POP
26888: POP
// end ; end ;
26889: LD_VAR 0 2
26893: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
26894: LD_INT 0
26896: PPUSH
26897: PPUSH
26898: PPUSH
26899: PPUSH
26900: PPUSH
26901: PPUSH
26902: PPUSH
26903: PPUSH
26904: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
26905: LD_VAR 0 1
26909: NOT
26910: PUSH
26911: LD_VAR 0 2
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: CALL_OW 488
26925: NOT
26926: OR
26927: PUSH
26928: LD_VAR 0 4
26932: NOT
26933: OR
26934: IFFALSE 26938
// exit ;
26936: GO 27278
// list := [ ] ;
26938: LD_ADDR_VAR 0 13
26942: PUSH
26943: EMPTY
26944: ST_TO_ADDR
// if x - r < 0 then
26945: LD_VAR 0 2
26949: PUSH
26950: LD_VAR 0 4
26954: MINUS
26955: PUSH
26956: LD_INT 0
26958: LESS
26959: IFFALSE 26971
// min_x := 0 else
26961: LD_ADDR_VAR 0 7
26965: PUSH
26966: LD_INT 0
26968: ST_TO_ADDR
26969: GO 26987
// min_x := x - r ;
26971: LD_ADDR_VAR 0 7
26975: PUSH
26976: LD_VAR 0 2
26980: PUSH
26981: LD_VAR 0 4
26985: MINUS
26986: ST_TO_ADDR
// if y - r < 0 then
26987: LD_VAR 0 3
26991: PUSH
26992: LD_VAR 0 4
26996: MINUS
26997: PUSH
26998: LD_INT 0
27000: LESS
27001: IFFALSE 27013
// min_y := 0 else
27003: LD_ADDR_VAR 0 8
27007: PUSH
27008: LD_INT 0
27010: ST_TO_ADDR
27011: GO 27029
// min_y := y - r ;
27013: LD_ADDR_VAR 0 8
27017: PUSH
27018: LD_VAR 0 3
27022: PUSH
27023: LD_VAR 0 4
27027: MINUS
27028: ST_TO_ADDR
// max_x := x + r ;
27029: LD_ADDR_VAR 0 9
27033: PUSH
27034: LD_VAR 0 2
27038: PUSH
27039: LD_VAR 0 4
27043: PLUS
27044: ST_TO_ADDR
// max_y := y + r ;
27045: LD_ADDR_VAR 0 10
27049: PUSH
27050: LD_VAR 0 3
27054: PUSH
27055: LD_VAR 0 4
27059: PLUS
27060: ST_TO_ADDR
// for _x = min_x to max_x do
27061: LD_ADDR_VAR 0 11
27065: PUSH
27066: DOUBLE
27067: LD_VAR 0 7
27071: DEC
27072: ST_TO_ADDR
27073: LD_VAR 0 9
27077: PUSH
27078: FOR_TO
27079: IFFALSE 27196
// for _y = min_y to max_y do
27081: LD_ADDR_VAR 0 12
27085: PUSH
27086: DOUBLE
27087: LD_VAR 0 8
27091: DEC
27092: ST_TO_ADDR
27093: LD_VAR 0 10
27097: PUSH
27098: FOR_TO
27099: IFFALSE 27192
// begin if not ValidHex ( _x , _y ) then
27101: LD_VAR 0 11
27105: PPUSH
27106: LD_VAR 0 12
27110: PPUSH
27111: CALL_OW 488
27115: NOT
27116: IFFALSE 27120
// continue ;
27118: GO 27098
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
27120: LD_VAR 0 11
27124: PPUSH
27125: LD_VAR 0 12
27129: PPUSH
27130: CALL_OW 351
27134: PUSH
27135: LD_VAR 0 11
27139: PPUSH
27140: LD_VAR 0 12
27144: PPUSH
27145: CALL_OW 554
27149: AND
27150: IFFALSE 27190
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
27152: LD_ADDR_VAR 0 13
27156: PUSH
27157: LD_VAR 0 13
27161: PPUSH
27162: LD_VAR 0 13
27166: PUSH
27167: LD_INT 1
27169: PLUS
27170: PPUSH
27171: LD_VAR 0 11
27175: PUSH
27176: LD_VAR 0 12
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PPUSH
27185: CALL_OW 2
27189: ST_TO_ADDR
// end ;
27190: GO 27098
27192: POP
27193: POP
27194: GO 27078
27196: POP
27197: POP
// if not list then
27198: LD_VAR 0 13
27202: NOT
27203: IFFALSE 27207
// exit ;
27205: GO 27278
// for i in list do
27207: LD_ADDR_VAR 0 6
27211: PUSH
27212: LD_VAR 0 13
27216: PUSH
27217: FOR_IN
27218: IFFALSE 27276
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
27220: LD_VAR 0 1
27224: PPUSH
27225: LD_STRING M
27227: PUSH
27228: LD_VAR 0 6
27232: PUSH
27233: LD_INT 1
27235: ARRAY
27236: PUSH
27237: LD_VAR 0 6
27241: PUSH
27242: LD_INT 2
27244: ARRAY
27245: PUSH
27246: LD_INT 0
27248: PUSH
27249: LD_INT 0
27251: PUSH
27252: LD_INT 0
27254: PUSH
27255: LD_INT 0
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: LIST
27265: LIST
27266: PUSH
27267: EMPTY
27268: LIST
27269: PPUSH
27270: CALL_OW 447
27274: GO 27217
27276: POP
27277: POP
// end ;
27278: LD_VAR 0 5
27282: RET
