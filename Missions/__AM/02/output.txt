// export JMM , Bobby , Cyrus ; export Lisa , Khatam , Brian , Jerry , Mikhail ; export Powell ; export hpJMM , hpBobby , hpCyrus ; export RuSoldMinLevel , RuSoldMaxLevel ; export cargo1 , cargo2 ; export driver1 , driver2 ; export Natasza ; export cargoEscape ; export mikhailStatus , mikhailInBase , mikhailDepot ; export northBaseDefenders , southBaseDefenders , attackGroup ; export lastBattle ; export cargoRespawn , cargoSee ; export tigersRespawn ; export deadsCounter ; export spotCorpses ; export mission_prefix ; starting begin mission_prefix := 02_ ;
   0: LD_ADDR_EXP 33
   4: PUSH
   5: LD_STRING 02_
   7: ST_TO_ADDR
// RuSoldMinLevel = 0 ;
   8: LD_ADDR_EXP 13
  12: PUSH
  13: LD_INT 0
  15: ST_TO_ADDR
// RuSoldMaxLevel = 0 ;
  16: LD_ADDR_EXP 14
  20: PUSH
  21: LD_INT 0
  23: ST_TO_ADDR
// hpJMM = 0 ;
  24: LD_ADDR_EXP 10
  28: PUSH
  29: LD_INT 0
  31: ST_TO_ADDR
// hpBobby = 0 ;
  32: LD_ADDR_EXP 11
  36: PUSH
  37: LD_INT 0
  39: ST_TO_ADDR
// hpCyrus = 0 ;
  40: LD_ADDR_EXP 12
  44: PUSH
  45: LD_INT 0
  47: ST_TO_ADDR
// cargoEscape = 0 ;
  48: LD_ADDR_EXP 20
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// mikhailStatus = 0 ;
  56: LD_ADDR_EXP 21
  60: PUSH
  61: LD_INT 0
  63: ST_TO_ADDR
// mikhailInBase = 0 ;
  64: LD_ADDR_EXP 22
  68: PUSH
  69: LD_INT 0
  71: ST_TO_ADDR
// mikhailDepot = 0 ;
  72: LD_ADDR_EXP 23
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// tigersRespawn = 0 ;
  80: LD_ADDR_EXP 30
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// cargoRespawn = 0 ;
  88: LD_ADDR_EXP 28
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// cargoSee = 0 ;
  96: LD_ADDR_EXP 29
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// lastBattle = 0 ;
 104: LD_ADDR_EXP 27
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// deadsCounter = 0 ;
 112: LD_ADDR_EXP 31
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// spotCorpses = 0 ;
 120: LD_ADDR_EXP 32
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// southBaseDefenders = [ ] ;
 128: LD_ADDR_EXP 25
 132: PUSH
 133: EMPTY
 134: ST_TO_ADDR
// northBaseDefenders = [ ] ;
 135: LD_ADDR_EXP 24
 139: PUSH
 140: EMPTY
 141: ST_TO_ADDR
// attackGroup = [ ] ;
 142: LD_ADDR_EXP 26
 146: PUSH
 147: EMPTY
 148: ST_TO_ADDR
// RandomizeAll ;
 149: CALL_OW 11
// InGameOn ;
 153: CALL_OW 8
// Resetfog ;
 157: CALL_OW 335
// AnimateTrees ( true ) ;
 161: LD_INT 1
 163: PPUSH
 164: CALL_OW 573
// PrepareDifficulty ;
 168: CALL 10287 0 0
// PrepareRussianCommander ;
 172: CALL 11743 0 0
// PrepareSouthBase ;
 176: CALL 11826 0 0
// PrepareNorthBase ;
 180: CALL 12165 0 0
// PrepareOtherRussians ;
 184: CALL 12531 0 0
// PrepareHeroes ;
 188: CALL 10602 0 0
// PrepareLisSquad ;
 192: CALL 10930 0 0
// PrepareOtherAmericans ;
 196: CALL 11275 0 0
// end ; end_of_file
 200: END
// every 1 do var tmp ;
 201: GO 203
 203: DISABLE
 204: LD_INT 0
 206: PPUSH
// begin CenterNowOnUnits ( JMM ) ;
 207: LD_EXP 1
 211: PPUSH
 212: CALL_OW 87
// tmp = FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff [ Lisa ] ;
 216: LD_ADDR_VAR 0 1
 220: PUSH
 221: LD_INT 22
 223: PUSH
 224: LD_INT 4
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: PUSH
 231: LD_INT 21
 233: PUSH
 234: LD_INT 1
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: EMPTY
 242: LIST
 243: LIST
 244: PPUSH
 245: CALL_OW 69
 249: PUSH
 250: LD_EXP 4
 254: PUSH
 255: EMPTY
 256: LIST
 257: DIFF
 258: ST_TO_ADDR
// if Cyrus and Bobby then
 259: LD_EXP 3
 263: PUSH
 264: LD_EXP 2
 268: AND
 269: IFFALSE 599
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 271: LD_EXP 3
 275: PPUSH
 276: LD_INT 43
 278: PPUSH
 279: LD_INT 72
 281: PPUSH
 282: CALL_OW 111
// ComMoveXY ( Bobby , 44 , 70 ) ;
 286: LD_EXP 2
 290: PPUSH
 291: LD_INT 44
 293: PPUSH
 294: LD_INT 70
 296: PPUSH
 297: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 301: LD_EXP 1
 305: PPUSH
 306: LD_INT 46
 308: PPUSH
 309: LD_INT 73
 311: PPUSH
 312: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 316: LD_EXP 3
 320: PPUSH
 321: LD_STRING D1a-Cyrus-1
 323: PPUSH
 324: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 328: LD_EXP 1
 332: PPUSH
 333: LD_STRING D1a-JMM-1
 335: PPUSH
 336: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 340: LD_EXP 3
 344: PPUSH
 345: LD_INT 37
 347: PPUSH
 348: LD_INT 66
 350: PPUSH
 351: CALL_OW 171
// AddComMoveXY ( Bobby , 41 , 67 ) ;
 355: LD_EXP 2
 359: PPUSH
 360: LD_INT 41
 362: PPUSH
 363: LD_INT 67
 365: PPUSH
 366: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 370: LD_EXP 1
 374: PPUSH
 375: LD_INT 38
 377: PPUSH
 378: LD_INT 64
 380: PPUSH
 381: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 385: LD_EXP 2
 389: PPUSH
 390: LD_STRING D1a-Bobby-2
 392: PPUSH
 393: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 397: LD_EXP 3
 401: PPUSH
 402: LD_INT 35
 404: PPUSH
 405: LD_INT 62
 407: PPUSH
 408: CALL_OW 171
// AddComMoveXY ( Bobby , 32 , 60 ) ;
 412: LD_EXP 2
 416: PPUSH
 417: LD_INT 32
 419: PPUSH
 420: LD_INT 60
 422: PPUSH
 423: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 427: LD_EXP 1
 431: PPUSH
 432: LD_INT 35
 434: PPUSH
 435: LD_INT 60
 437: PPUSH
 438: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 442: LD_EXP 1
 446: PPUSH
 447: LD_STRING D1a-JMM-2
 449: PPUSH
 450: CALL_OW 88
// ComWalk ( Lisa ) ;
 454: LD_EXP 4
 458: PPUSH
 459: CALL_OW 138
// wait ( 0 0$1 ) ;
 463: LD_INT 35
 465: PPUSH
 466: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 470: LD_EXP 4
 474: PPUSH
 475: LD_EXP 1
 479: PPUSH
 480: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus , Bobby ] , Lisa ) ;
 484: LD_EXP 1
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_EXP 2
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PPUSH
 504: LD_EXP 4
 508: PPUSH
 509: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
 513: LD_VAR 0 1
 517: PUSH
 518: LD_INT 1
 520: ARRAY
 521: PPUSH
 522: LD_INT 33
 524: PPUSH
 525: LD_INT 55
 527: PPUSH
 528: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
 532: LD_VAR 0 1
 536: PUSH
 537: LD_INT 2
 539: ARRAY
 540: PPUSH
 541: LD_INT 30
 543: PPUSH
 544: LD_INT 54
 546: PPUSH
 547: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
 551: LD_VAR 0 1
 555: PUSH
 556: LD_INT 1
 558: ARRAY
 559: PPUSH
 560: LD_EXP 1
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
 569: LD_VAR 0 1
 573: PUSH
 574: LD_INT 2
 576: ARRAY
 577: PPUSH
 578: LD_EXP 1
 582: PPUSH
 583: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 587: LD_EXP 4
 591: PPUSH
 592: LD_STRING D1a-Lisa-2
 594: PPUSH
 595: CALL_OW 88
// end ; if Cyrus and not Bobby then
 599: LD_EXP 3
 603: PUSH
 604: LD_EXP 2
 608: NOT
 609: AND
 610: IFFALSE 815
// begin ComMoveXY ( Cyrus , 43 , 72 ) ;
 612: LD_EXP 3
 616: PPUSH
 617: LD_INT 43
 619: PPUSH
 620: LD_INT 72
 622: PPUSH
 623: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 627: LD_EXP 1
 631: PPUSH
 632: LD_INT 46
 634: PPUSH
 635: LD_INT 73
 637: PPUSH
 638: CALL_OW 111
// Say ( Cyrus , D1a-Cyrus-1 ) ;
 642: LD_EXP 3
 646: PPUSH
 647: LD_STRING D1a-Cyrus-1
 649: PPUSH
 650: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 654: LD_EXP 1
 658: PPUSH
 659: LD_STRING D1a-JMM-1
 661: PPUSH
 662: CALL_OW 88
// AddComMoveXY ( Cyrus , 37 , 66 ) ;
 666: LD_EXP 3
 670: PPUSH
 671: LD_INT 37
 673: PPUSH
 674: LD_INT 66
 676: PPUSH
 677: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 681: LD_EXP 1
 685: PPUSH
 686: LD_INT 38
 688: PPUSH
 689: LD_INT 64
 691: PPUSH
 692: CALL_OW 171
// Say ( Cyrus , D1a-Cyrus-2 ) ;
 696: LD_EXP 3
 700: PPUSH
 701: LD_STRING D1a-Cyrus-2
 703: PPUSH
 704: CALL_OW 88
// AddComMoveXY ( Cyrus , 35 , 62 ) ;
 708: LD_EXP 3
 712: PPUSH
 713: LD_INT 35
 715: PPUSH
 716: LD_INT 62
 718: PPUSH
 719: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 723: LD_EXP 1
 727: PPUSH
 728: LD_INT 35
 730: PPUSH
 731: LD_INT 60
 733: PPUSH
 734: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 738: LD_EXP 1
 742: PPUSH
 743: LD_STRING D1a-JMM-2
 745: PPUSH
 746: CALL_OW 88
// ComWalk ( Lisa ) ;
 750: LD_EXP 4
 754: PPUSH
 755: CALL_OW 138
// wait ( 0 0$1 ) ;
 759: LD_INT 35
 761: PPUSH
 762: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 766: LD_EXP 4
 770: PPUSH
 771: LD_EXP 1
 775: PPUSH
 776: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
 780: LD_EXP 4
 784: PPUSH
 785: LD_STRING D1a-Lisa-2
 787: PPUSH
 788: CALL_OW 88
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 792: LD_EXP 1
 796: PUSH
 797: LD_EXP 3
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: LD_EXP 4
 810: PPUSH
 811: CALL_OW 119
// end ; if not Cyrus and Bobby then
 815: LD_EXP 3
 819: NOT
 820: PUSH
 821: LD_EXP 2
 825: AND
 826: IFFALSE 1105
// begin ComMoveXY ( Bobby , 44 , 70 ) ;
 828: LD_EXP 2
 832: PPUSH
 833: LD_INT 44
 835: PPUSH
 836: LD_INT 70
 838: PPUSH
 839: CALL_OW 111
// ComMoveXY ( JMM , 46 , 73 ) ;
 843: LD_EXP 1
 847: PPUSH
 848: LD_INT 46
 850: PPUSH
 851: LD_INT 73
 853: PPUSH
 854: CALL_OW 111
// Say ( Bobby , D1a-Bobby-1 ) ;
 858: LD_EXP 2
 862: PPUSH
 863: LD_STRING D1a-Bobby-1
 865: PPUSH
 866: CALL_OW 88
// Say ( JMM , D1a-JMM-1 ) ;
 870: LD_EXP 1
 874: PPUSH
 875: LD_STRING D1a-JMM-1
 877: PPUSH
 878: CALL_OW 88
// AddComMoveXY ( Bobby , 37 , 66 ) ;
 882: LD_EXP 2
 886: PPUSH
 887: LD_INT 37
 889: PPUSH
 890: LD_INT 66
 892: PPUSH
 893: CALL_OW 171
// AddComMoveXY ( JMM , 38 , 64 ) ;
 897: LD_EXP 1
 901: PPUSH
 902: LD_INT 38
 904: PPUSH
 905: LD_INT 64
 907: PPUSH
 908: CALL_OW 171
// Say ( Bobby , D1a-Bobby-2 ) ;
 912: LD_EXP 2
 916: PPUSH
 917: LD_STRING D1a-Bobby-2
 919: PPUSH
 920: CALL_OW 88
// AddComMoveXY ( Bobby , 35 , 62 ) ;
 924: LD_EXP 2
 928: PPUSH
 929: LD_INT 35
 931: PPUSH
 932: LD_INT 62
 934: PPUSH
 935: CALL_OW 171
// AddComMoveXY ( JMM , 35 , 60 ) ;
 939: LD_EXP 1
 943: PPUSH
 944: LD_INT 35
 946: PPUSH
 947: LD_INT 60
 949: PPUSH
 950: CALL_OW 171
// Say ( JMM , D1a-JMM-2 ) ;
 954: LD_EXP 1
 958: PPUSH
 959: LD_STRING D1a-JMM-2
 961: PPUSH
 962: CALL_OW 88
// ComWalk ( Lisa ) ;
 966: LD_EXP 4
 970: PPUSH
 971: CALL_OW 138
// wait ( 0 0$1 ) ;
 975: LD_INT 35
 977: PPUSH
 978: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
 982: LD_EXP 4
 986: PPUSH
 987: LD_EXP 1
 991: PPUSH
 992: CALL_OW 179
// ComTurnUnit ( [ JMM , Cyrus ] , Lisa ) ;
 996: LD_EXP 1
1000: PUSH
1001: LD_EXP 3
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: PPUSH
1010: LD_EXP 4
1014: PPUSH
1015: CALL_OW 119
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1019: LD_VAR 0 1
1023: PUSH
1024: LD_INT 1
1026: ARRAY
1027: PPUSH
1028: LD_INT 33
1030: PPUSH
1031: LD_INT 55
1033: PPUSH
1034: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1038: LD_VAR 0 1
1042: PUSH
1043: LD_INT 2
1045: ARRAY
1046: PPUSH
1047: LD_INT 30
1049: PPUSH
1050: LD_INT 54
1052: PPUSH
1053: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1057: LD_VAR 0 1
1061: PUSH
1062: LD_INT 1
1064: ARRAY
1065: PPUSH
1066: LD_EXP 1
1070: PPUSH
1071: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1075: LD_VAR 0 1
1079: PUSH
1080: LD_INT 2
1082: ARRAY
1083: PPUSH
1084: LD_EXP 1
1088: PPUSH
1089: CALL_OW 179
// Say ( Lisa , D1a-Lisa-2 ) ;
1093: LD_EXP 4
1097: PPUSH
1098: LD_STRING D1a-Lisa-2
1100: PPUSH
1101: CALL_OW 88
// end ; if not Cyrus and not Bobby then
1105: LD_EXP 3
1109: NOT
1110: PUSH
1111: LD_EXP 2
1115: NOT
1116: AND
1117: IFFALSE 1331
// begin ComMoveXY ( JMM , 37 , 66 ) ;
1119: LD_EXP 1
1123: PPUSH
1124: LD_INT 37
1126: PPUSH
1127: LD_INT 66
1129: PPUSH
1130: CALL_OW 111
// Say ( JMM , D1b-JMM-1 ) ;
1134: LD_EXP 1
1138: PPUSH
1139: LD_STRING D1b-JMM-1
1141: PPUSH
1142: CALL_OW 88
// ComCrawl ( JMM ) ;
1146: LD_EXP 1
1150: PPUSH
1151: CALL_OW 137
// AddComMoveXY ( JMM , 35 , 60 ) ;
1155: LD_EXP 1
1159: PPUSH
1160: LD_INT 35
1162: PPUSH
1163: LD_INT 60
1165: PPUSH
1166: CALL_OW 171
// wait ( 0 0$8 ) ;
1170: LD_INT 280
1172: PPUSH
1173: CALL_OW 67
// Say ( JMM , D1b-JMM-1a ) ;
1177: LD_EXP 1
1181: PPUSH
1182: LD_STRING D1b-JMM-1a
1184: PPUSH
1185: CALL_OW 88
// ComWalk ( [ JMM , Lisa ] ) ;
1189: LD_EXP 1
1193: PUSH
1194: LD_EXP 4
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL_OW 138
// wait ( 0 0$1 ) ;
1207: LD_INT 35
1209: PPUSH
1210: CALL_OW 67
// AddComTurnUnit ( Lisa , JMM ) ;
1214: LD_EXP 4
1218: PPUSH
1219: LD_EXP 1
1223: PPUSH
1224: CALL_OW 179
// AddComTurnUnit ( [ JMM ] , Lisa ) ;
1228: LD_EXP 1
1232: PUSH
1233: EMPTY
1234: LIST
1235: PPUSH
1236: LD_EXP 4
1240: PPUSH
1241: CALL_OW 179
// ComMoveXY ( tmp [ 1 ] , 33 , 55 ) ;
1245: LD_VAR 0 1
1249: PUSH
1250: LD_INT 1
1252: ARRAY
1253: PPUSH
1254: LD_INT 33
1256: PPUSH
1257: LD_INT 55
1259: PPUSH
1260: CALL_OW 111
// ComMoveXY ( tmp [ 2 ] , 30 , 54 ) ;
1264: LD_VAR 0 1
1268: PUSH
1269: LD_INT 2
1271: ARRAY
1272: PPUSH
1273: LD_INT 30
1275: PPUSH
1276: LD_INT 54
1278: PPUSH
1279: CALL_OW 111
// AddComTurnUnit ( tmp [ 1 ] , JMM ) ;
1283: LD_VAR 0 1
1287: PUSH
1288: LD_INT 1
1290: ARRAY
1291: PPUSH
1292: LD_EXP 1
1296: PPUSH
1297: CALL_OW 179
// AddComTurnUnit ( tmp [ 2 ] , JMM ) ;
1301: LD_VAR 0 1
1305: PUSH
1306: LD_INT 2
1308: ARRAY
1309: PPUSH
1310: LD_EXP 1
1314: PPUSH
1315: CALL_OW 179
// Say ( Lisa , D1b-Lisa-1 ) ;
1319: LD_EXP 4
1323: PPUSH
1324: LD_STRING D1b-Lisa-1
1326: PPUSH
1327: CALL_OW 88
// end ; Say ( JMM , D1-JMM-1 ) ;
1331: LD_EXP 1
1335: PPUSH
1336: LD_STRING D1-JMM-1
1338: PPUSH
1339: CALL_OW 88
// Say ( Lisa , D1-Lisa-1 ) ;
1343: LD_EXP 4
1347: PPUSH
1348: LD_STRING D1-Lisa-1
1350: PPUSH
1351: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
1355: LD_EXP 1
1359: PPUSH
1360: LD_STRING D1-JMM-2
1362: PPUSH
1363: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
1367: LD_EXP 9
1371: PPUSH
1372: LD_STRING D1-Pow-2
1374: PPUSH
1375: CALL_OW 94
// if Cyrus then
1379: LD_EXP 3
1383: IFFALSE 1409
// begin Say ( Cyrus , D1-Cyrus-2 ) ;
1385: LD_EXP 3
1389: PPUSH
1390: LD_STRING D1-Cyrus-2
1392: PPUSH
1393: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
1397: LD_EXP 1
1401: PPUSH
1402: LD_STRING D1-JMM-3
1404: PPUSH
1405: CALL_OW 88
// end ; SayRadio ( Powell , D1-Pow-3 ) ;
1409: LD_EXP 9
1413: PPUSH
1414: LD_STRING D1-Pow-3
1416: PPUSH
1417: CALL_OW 94
// Say ( JMM , D1-JMM-4 ) ;
1421: LD_EXP 1
1425: PPUSH
1426: LD_STRING D1-JMM-4
1428: PPUSH
1429: CALL_OW 88
// SayRadio ( Powell , D1-Pow-4 ) ;
1433: LD_EXP 9
1437: PPUSH
1438: LD_STRING D1-Pow-4
1440: PPUSH
1441: CALL_OW 94
// SayRadio ( Powell , D1-Pow-4a ) ;
1445: LD_EXP 9
1449: PPUSH
1450: LD_STRING D1-Pow-4a
1452: PPUSH
1453: CALL_OW 94
// if Cyrus then
1457: LD_EXP 3
1461: IFFALSE 1475
// Say ( Cyrus , D1-Cyrus-4 ) ;
1463: LD_EXP 3
1467: PPUSH
1468: LD_STRING D1-Cyrus-4
1470: PPUSH
1471: CALL_OW 88
// if Bobby then
1475: LD_EXP 2
1479: IFFALSE 1517
// begin Say ( Bobby , D1-Bobby-4 ) ;
1481: LD_EXP 2
1485: PPUSH
1486: LD_STRING D1-Bobby-4
1488: PPUSH
1489: CALL_OW 88
// Say ( Lisa , D1-Lisa-4 ) ;
1493: LD_EXP 4
1497: PPUSH
1498: LD_STRING D1-Lisa-4
1500: PPUSH
1501: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
1505: LD_EXP 1
1509: PPUSH
1510: LD_STRING D1-JMM-5
1512: PPUSH
1513: CALL_OW 88
// end ; InGameOff ;
1517: CALL_OW 9
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) diff [ Brian , Jerry ] , 1 ) ;
1521: LD_INT 22
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: PPUSH
1531: CALL_OW 69
1535: PUSH
1536: LD_EXP 6
1540: PUSH
1541: LD_EXP 7
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: DIFF
1550: PPUSH
1551: LD_INT 1
1553: PPUSH
1554: CALL_OW 235
// ChangeMissionObjectives ( M1 ) ;
1558: LD_STRING M1
1560: PPUSH
1561: CALL_OW 337
// SaveForQuickRestart ;
1565: CALL_OW 22
// end ;
1569: PPOPN 1
1571: END
// every 0 0$1 trigger FilterUnitsInArea ( PaulTriggerArea , [ f_side , 1 ] ) > 0 do
1572: LD_INT 7
1574: PPUSH
1575: LD_INT 22
1577: PUSH
1578: LD_INT 1
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PPUSH
1585: CALL_OW 70
1589: PUSH
1590: LD_INT 0
1592: GREATER
1593: IFFALSE 2010
1595: GO 1597
1597: DISABLE
// begin InGameOn ;
1598: CALL_OW 8
// ComHold ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
1602: LD_INT 22
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 21
1614: PUSH
1615: LD_INT 1
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PPUSH
1626: CALL_OW 69
1630: PPUSH
1631: CALL_OW 140
// CenterOnXY ( 24 , 32 ) ;
1635: LD_INT 24
1637: PPUSH
1638: LD_INT 32
1640: PPUSH
1641: CALL_OW 84
// PlaceUnitArea ( Khatam , PaulSpawn , true ) ;
1645: LD_EXP 5
1649: PPUSH
1650: LD_INT 4
1652: PPUSH
1653: LD_INT 1
1655: PPUSH
1656: CALL_OW 49
// SetClass ( Khatam , 4 ) ;
1660: LD_EXP 5
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 336
// wait ( 0 0$1 ) ;
1672: LD_INT 35
1674: PPUSH
1675: CALL_OW 67
// ComMoveXY ( Khatam , 27 , 38 ) ;
1679: LD_EXP 5
1683: PPUSH
1684: LD_INT 27
1686: PPUSH
1687: LD_INT 38
1689: PPUSH
1690: CALL_OW 111
// AddComTurnUnit ( Khatam , JMM ) ;
1694: LD_EXP 5
1698: PPUSH
1699: LD_EXP 1
1703: PPUSH
1704: CALL_OW 179
// ComTurnUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ Khatam ] , Khatam ) ;
1708: LD_INT 22
1710: PUSH
1711: LD_INT 1
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: PUSH
1718: LD_INT 21
1720: PUSH
1721: LD_INT 1
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PPUSH
1732: CALL_OW 69
1736: PUSH
1737: LD_EXP 5
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: PPUSH
1746: LD_EXP 5
1750: PPUSH
1751: CALL_OW 119
// wait ( 0 0$1 ) ;
1755: LD_INT 35
1757: PPUSH
1758: CALL_OW 67
// Say ( Khatam , D2a-Khat-1 ) ;
1762: LD_EXP 5
1766: PPUSH
1767: LD_STRING D2a-Khat-1
1769: PPUSH
1770: CALL_OW 88
// Say ( JMM , D2a-JMM-1 ) ;
1774: LD_EXP 1
1778: PPUSH
1779: LD_STRING D2a-JMM-1
1781: PPUSH
1782: CALL_OW 88
// Say ( Khatam , D2a-Khat-2 ) ;
1786: LD_EXP 5
1790: PPUSH
1791: LD_STRING D2a-Khat-2
1793: PPUSH
1794: CALL_OW 88
// Say ( JMM , D2a-JMM-2 ) ;
1798: LD_EXP 1
1802: PPUSH
1803: LD_STRING D2a-JMM-2
1805: PPUSH
1806: CALL_OW 88
// Say ( Khatam , D2a-Khat-3 ) ;
1810: LD_EXP 5
1814: PPUSH
1815: LD_STRING D2a-Khat-3
1817: PPUSH
1818: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
1822: LD_EXP 1
1826: PPUSH
1827: LD_STRING D2a-JMM-3
1829: PPUSH
1830: CALL_OW 88
// Say ( Khatam , D2a-Khat-4 ) ;
1834: LD_EXP 5
1838: PPUSH
1839: LD_STRING D2a-Khat-4
1841: PPUSH
1842: CALL_OW 88
// Say ( JMM , D2a-JMM-4 ) ;
1846: LD_EXP 1
1850: PPUSH
1851: LD_STRING D2a-JMM-4
1853: PPUSH
1854: CALL_OW 88
// Say ( Khatam , D2a-Khat-5 ) ;
1858: LD_EXP 5
1862: PPUSH
1863: LD_STRING D2a-Khat-5
1865: PPUSH
1866: CALL_OW 88
// Say ( JMM , D2a-JMM-5 ) ;
1870: LD_EXP 1
1874: PPUSH
1875: LD_STRING D2a-JMM-5
1877: PPUSH
1878: CALL_OW 88
// InGameOff ;
1882: CALL_OW 9
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 800 ] ] ] ) > 0 then
1886: LD_INT 22
1888: PUSH
1889: LD_INT 1
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: LD_INT 21
1898: PUSH
1899: LD_INT 1
1901: PUSH
1902: EMPTY
1903: LIST
1904: LIST
1905: PUSH
1906: LD_INT 3
1908: PUSH
1909: LD_INT 24
1911: PUSH
1912: LD_INT 800
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: PUSH
1923: EMPTY
1924: LIST
1925: LIST
1926: LIST
1927: PPUSH
1928: CALL_OW 69
1932: PUSH
1933: LD_INT 0
1935: GREATER
1936: IFFALSE 2010
// begin ComHeal ( Khatam , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ) ;
1938: LD_EXP 5
1942: PPUSH
1943: LD_INT 22
1945: PUSH
1946: LD_INT 1
1948: PUSH
1949: EMPTY
1950: LIST
1951: LIST
1952: PUSH
1953: LD_INT 21
1955: PUSH
1956: LD_INT 1
1958: PUSH
1959: EMPTY
1960: LIST
1961: LIST
1962: PUSH
1963: LD_INT 3
1965: PUSH
1966: LD_INT 24
1968: PUSH
1969: LD_INT 1000
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: PUSH
1980: EMPTY
1981: LIST
1982: LIST
1983: LIST
1984: PPUSH
1985: CALL_OW 69
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: CALL_OW 128
// Say ( Khatam , D2b-Khat-1 ) ;
1998: LD_EXP 5
2002: PPUSH
2003: LD_STRING D2b-Khat-1
2005: PPUSH
2006: CALL_OW 88
// end ; end ;
2010: END
// every 0 0$1 trigger FilterUnitsInArea ( DeadTriggerArea , [ f_side , 1 ] ) > 0 do var i , distanceTab , min , tmp , p ;
2011: LD_INT 15
2013: PPUSH
2014: LD_INT 22
2016: PUSH
2017: LD_INT 1
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: PPUSH
2024: CALL_OW 70
2028: PUSH
2029: LD_INT 0
2031: GREATER
2032: IFFALSE 3229
2034: GO 2036
2036: DISABLE
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
// begin distanceTab = [ [ 999 , 999 ] ] ;
2044: LD_ADDR_VAR 0 2
2048: PUSH
2049: LD_INT 999
2051: PUSH
2052: LD_INT 999
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: PUSH
2059: EMPTY
2060: LIST
2061: ST_TO_ADDR
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam ] ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: LD_INT 22
2069: PUSH
2070: LD_INT 1
2072: PUSH
2073: EMPTY
2074: LIST
2075: LIST
2076: PUSH
2077: LD_INT 21
2079: PUSH
2080: LD_INT 1
2082: PUSH
2083: EMPTY
2084: LIST
2085: LIST
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: PPUSH
2091: CALL_OW 69
2095: PUSH
2096: LD_EXP 1
2100: PUSH
2101: LD_EXP 2
2105: PUSH
2106: LD_EXP 3
2110: PUSH
2111: LD_EXP 4
2115: PUSH
2116: LD_EXP 5
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: DIFF
2128: ST_TO_ADDR
// PrepareDeadSoldiers ;
2129: CALL 11433 0 0
// spotCorpses = 1 ;
2133: LD_ADDR_EXP 32
2137: PUSH
2138: LD_INT 1
2140: ST_TO_ADDR
// wait ( 0 0$2 ) ;
2141: LD_INT 70
2143: PPUSH
2144: CALL_OW 67
// InGameOn ;
2148: CALL_OW 8
// CenterOnXY ( 23 , 12 ) ;
2152: LD_INT 23
2154: PPUSH
2155: LD_INT 12
2157: PPUSH
2158: CALL_OW 84
// min = distanceTab [ 1 ] [ 2 ] ;
2162: LD_ADDR_VAR 0 3
2166: PUSH
2167: LD_VAR 0 2
2171: PUSH
2172: LD_INT 1
2174: ARRAY
2175: PUSH
2176: LD_INT 2
2178: ARRAY
2179: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Khatam ] do
2180: LD_ADDR_VAR 0 1
2184: PUSH
2185: LD_INT 22
2187: PUSH
2188: LD_INT 1
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 21
2197: PUSH
2198: LD_INT 1
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PPUSH
2209: CALL_OW 69
2213: PUSH
2214: LD_EXP 1
2218: PUSH
2219: LD_EXP 5
2223: PUSH
2224: EMPTY
2225: LIST
2226: LIST
2227: DIFF
2228: PUSH
2229: FOR_IN
2230: IFFALSE 2281
// if IsOK ( i ) then
2232: LD_VAR 0 1
2236: PPUSH
2237: CALL_OW 302
2241: IFFALSE 2279
// distanceTab = distanceTab ^ [ [ i , GetDistUnitArea ( i , DeadsSpawn ) ] ] ;
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 2
2252: PUSH
2253: LD_VAR 0 1
2257: PUSH
2258: LD_VAR 0 1
2262: PPUSH
2263: LD_INT 16
2265: PPUSH
2266: CALL_OW 299
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: ADD
2278: ST_TO_ADDR
2279: GO 2229
2281: POP
2282: POP
// for i = 2 to distanceTab do
2283: LD_ADDR_VAR 0 1
2287: PUSH
2288: DOUBLE
2289: LD_INT 2
2291: DEC
2292: ST_TO_ADDR
2293: LD_VAR 0 2
2297: PUSH
2298: FOR_TO
2299: IFFALSE 2345
// if distanceTab [ i ] [ 2 ] < min then
2301: LD_VAR 0 2
2305: PUSH
2306: LD_VAR 0 1
2310: ARRAY
2311: PUSH
2312: LD_INT 2
2314: ARRAY
2315: PUSH
2316: LD_VAR 0 3
2320: LESS
2321: IFFALSE 2343
// min = distanceTab [ i ] [ 2 ] ;
2323: LD_ADDR_VAR 0 3
2327: PUSH
2328: LD_VAR 0 2
2332: PUSH
2333: LD_VAR 0 1
2337: ARRAY
2338: PUSH
2339: LD_INT 2
2341: ARRAY
2342: ST_TO_ADDR
2343: GO 2298
2345: POP
2346: POP
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2347: LD_ADDR_VAR 0 1
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: LD_INT 1
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: PUSH
2362: LD_INT 21
2364: PUSH
2365: LD_INT 1
2367: PUSH
2368: EMPTY
2369: LIST
2370: LIST
2371: PUSH
2372: EMPTY
2373: LIST
2374: LIST
2375: PPUSH
2376: CALL_OW 69
2380: PUSH
2381: LD_EXP 1
2385: PUSH
2386: EMPTY
2387: LIST
2388: DIFF
2389: PUSH
2390: FOR_IN
2391: IFFALSE 2461
// begin ComMoveToArea ( i , DeadCutscene ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 28
2400: PPUSH
2401: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2405: LD_EXP 1
2409: PPUSH
2410: LD_INT 30
2412: PPUSH
2413: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2417: LD_VAR 0 1
2421: PPUSH
2422: LD_INT 23
2424: PPUSH
2425: LD_INT 11
2427: PPUSH
2428: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2432: LD_EXP 1
2436: PPUSH
2437: LD_INT 23
2439: PPUSH
2440: LD_INT 11
2442: PPUSH
2443: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2447: LD_EXP 34
2451: PPUSH
2452: LD_INT 250
2454: PPUSH
2455: CALL_OW 234
// end ;
2459: GO 2390
2461: POP
2462: POP
// for i = 2 to distanceTab do
2463: LD_ADDR_VAR 0 1
2467: PUSH
2468: DOUBLE
2469: LD_INT 2
2471: DEC
2472: ST_TO_ADDR
2473: LD_VAR 0 2
2477: PUSH
2478: FOR_TO
2479: IFFALSE 2865
// begin if distanceTab [ i ] [ 2 ] = min then
2481: LD_VAR 0 2
2485: PUSH
2486: LD_VAR 0 1
2490: ARRAY
2491: PUSH
2492: LD_INT 2
2494: ARRAY
2495: PUSH
2496: LD_VAR 0 3
2500: EQUAL
2501: IFFALSE 2863
// begin if distanceTab [ i ] [ 1 ] = Bobby then
2503: LD_VAR 0 2
2507: PUSH
2508: LD_VAR 0 1
2512: ARRAY
2513: PUSH
2514: LD_INT 1
2516: ARRAY
2517: PUSH
2518: LD_EXP 2
2522: EQUAL
2523: IFFALSE 2537
// Say ( Bobby , DCorpses-Bobby-1 ) ;
2525: LD_EXP 2
2529: PPUSH
2530: LD_STRING DCorpses-Bobby-1
2532: PPUSH
2533: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Cyrus then
2537: LD_VAR 0 2
2541: PUSH
2542: LD_VAR 0 1
2546: ARRAY
2547: PUSH
2548: LD_INT 1
2550: ARRAY
2551: PUSH
2552: LD_EXP 3
2556: EQUAL
2557: IFFALSE 2571
// Say ( Cyrus , DCorpses-Cyrus-1 ) ;
2559: LD_EXP 3
2563: PPUSH
2564: LD_STRING DCorpses-Cyrus-1
2566: PPUSH
2567: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = Lisa then
2571: LD_VAR 0 2
2575: PUSH
2576: LD_VAR 0 1
2580: ARRAY
2581: PUSH
2582: LD_INT 1
2584: ARRAY
2585: PUSH
2586: LD_EXP 4
2590: EQUAL
2591: IFFALSE 2605
// Say ( Lisa , DCorpses-Lisa-1 ) ;
2593: LD_EXP 4
2597: PPUSH
2598: LD_STRING DCorpses-Lisa-1
2600: PPUSH
2601: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 1 then
2605: LD_VAR 0 2
2609: PUSH
2610: LD_VAR 0 1
2614: ARRAY
2615: PUSH
2616: LD_INT 1
2618: ARRAY
2619: PUSH
2620: LD_VAR 0 4
2624: PUSH
2625: LD_INT 1
2627: ARRAY
2628: EQUAL
2629: PUSH
2630: LD_VAR 0 4
2634: PUSH
2635: LD_INT 1
2637: ARRAY
2638: PPUSH
2639: CALL_OW 258
2643: PUSH
2644: LD_INT 1
2646: EQUAL
2647: AND
2648: IFFALSE 2666
// Say ( tmp [ 1 ] , DCorpses-Sol1-1 ) ;
2650: LD_VAR 0 4
2654: PUSH
2655: LD_INT 1
2657: ARRAY
2658: PPUSH
2659: LD_STRING DCorpses-Sol1-1
2661: PPUSH
2662: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 1 ] and GetSex ( tmp [ 1 ] ) = 2 then
2666: LD_VAR 0 2
2670: PUSH
2671: LD_VAR 0 1
2675: ARRAY
2676: PUSH
2677: LD_INT 1
2679: ARRAY
2680: PUSH
2681: LD_VAR 0 4
2685: PUSH
2686: LD_INT 1
2688: ARRAY
2689: EQUAL
2690: PUSH
2691: LD_VAR 0 4
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 258
2704: PUSH
2705: LD_INT 2
2707: EQUAL
2708: AND
2709: IFFALSE 2727
// Say ( tmp [ 1 ] , DCorpses-FSol1-1 ) ;
2711: LD_VAR 0 4
2715: PUSH
2716: LD_INT 1
2718: ARRAY
2719: PPUSH
2720: LD_STRING DCorpses-FSol1-1
2722: PPUSH
2723: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 1 then
2727: LD_VAR 0 2
2731: PUSH
2732: LD_VAR 0 1
2736: ARRAY
2737: PUSH
2738: LD_INT 1
2740: ARRAY
2741: PUSH
2742: LD_VAR 0 4
2746: PUSH
2747: LD_INT 2
2749: ARRAY
2750: EQUAL
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 2
2759: ARRAY
2760: PPUSH
2761: CALL_OW 258
2765: PUSH
2766: LD_INT 1
2768: EQUAL
2769: AND
2770: IFFALSE 2788
// Say ( tmp [ 2 ] , DCorpses-Sol1-1 ) ;
2772: LD_VAR 0 4
2776: PUSH
2777: LD_INT 2
2779: ARRAY
2780: PPUSH
2781: LD_STRING DCorpses-Sol1-1
2783: PPUSH
2784: CALL_OW 88
// if distanceTab [ i ] [ 1 ] = tmp [ 2 ] and GetSex ( tmp [ 2 ] ) = 2 then
2788: LD_VAR 0 2
2792: PUSH
2793: LD_VAR 0 1
2797: ARRAY
2798: PUSH
2799: LD_INT 1
2801: ARRAY
2802: PUSH
2803: LD_VAR 0 4
2807: PUSH
2808: LD_INT 2
2810: ARRAY
2811: EQUAL
2812: PUSH
2813: LD_VAR 0 4
2817: PUSH
2818: LD_INT 2
2820: ARRAY
2821: PPUSH
2822: CALL_OW 258
2826: PUSH
2827: LD_INT 2
2829: EQUAL
2830: AND
2831: IFFALSE 2849
// Say ( tmp [ 2 ] , DCorpses-FSol1-1 ) ;
2833: LD_VAR 0 4
2837: PUSH
2838: LD_INT 2
2840: ARRAY
2841: PPUSH
2842: LD_STRING DCorpses-FSol1-1
2844: PPUSH
2845: CALL_OW 88
// SetLives ( DyingSold , 150 ) ;
2849: LD_EXP 34
2853: PPUSH
2854: LD_INT 150
2856: PPUSH
2857: CALL_OW 234
// break ;
2861: GO 2865
// end ; end ;
2863: GO 2478
2865: POP
2866: POP
// p := 0 ;
2867: LD_ADDR_VAR 0 5
2871: PUSH
2872: LD_INT 0
2874: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2875: LD_INT 35
2877: PPUSH
2878: CALL_OW 67
// p := p + 1 ;
2882: LD_ADDR_VAR 0 5
2886: PUSH
2887: LD_VAR 0 5
2891: PUSH
2892: LD_INT 1
2894: PLUS
2895: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM ] do
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_INT 22
2903: PUSH
2904: LD_INT 1
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PUSH
2911: LD_INT 21
2913: PUSH
2914: LD_INT 1
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: PUSH
2921: EMPTY
2922: LIST
2923: LIST
2924: PPUSH
2925: CALL_OW 69
2929: PUSH
2930: LD_EXP 1
2934: PUSH
2935: EMPTY
2936: LIST
2937: DIFF
2938: PUSH
2939: FOR_IN
2940: IFFALSE 3010
// begin ComMoveToArea ( i , DeadCutscene ) ;
2942: LD_VAR 0 1
2946: PPUSH
2947: LD_INT 28
2949: PPUSH
2950: CALL_OW 113
// ComMoveToArea ( JMM , JMMAreaCutscene ) ;
2954: LD_EXP 1
2958: PPUSH
2959: LD_INT 30
2961: PPUSH
2962: CALL_OW 113
// AddComTurnXY ( i , 23 , 11 ) ;
2966: LD_VAR 0 1
2970: PPUSH
2971: LD_INT 23
2973: PPUSH
2974: LD_INT 11
2976: PPUSH
2977: CALL_OW 178
// AddComTurnXY ( JMM , 23 , 11 ) ;
2981: LD_EXP 1
2985: PPUSH
2986: LD_INT 23
2988: PPUSH
2989: LD_INT 11
2991: PPUSH
2992: CALL_OW 178
// SetLives ( DyingSold , 250 ) ;
2996: LD_EXP 34
3000: PPUSH
3001: LD_INT 250
3003: PPUSH
3004: CALL_OW 234
// end ;
3008: GO 2939
3010: POP
3011: POP
// until IsInArea ( JMM , JMMAreaCutscene ) or p >= 16 ;
3012: LD_EXP 1
3016: PPUSH
3017: LD_INT 30
3019: PPUSH
3020: CALL_OW 308
3024: PUSH
3025: LD_VAR 0 5
3029: PUSH
3030: LD_INT 16
3032: GREATEREQUAL
3033: OR
3034: IFFALSE 2875
// wait ( 0 0$1 ) ;
3036: LD_INT 35
3038: PPUSH
3039: CALL_OW 67
// Say ( JMM , DCorpses-JMM-1 ) ;
3043: LD_EXP 1
3047: PPUSH
3048: LD_STRING DCorpses-JMM-1
3050: PPUSH
3051: CALL_OW 88
// SetLives ( DyingSold , 100 ) ;
3055: LD_EXP 34
3059: PPUSH
3060: LD_INT 100
3062: PPUSH
3063: CALL_OW 234
// if IsOK ( Khatam ) then
3067: LD_EXP 5
3071: PPUSH
3072: CALL_OW 302
3076: IFFALSE 3213
// begin repeat wait ( 0 0$1 ) ;
3078: LD_INT 35
3080: PPUSH
3081: CALL_OW 67
// ComHeal ( Khatam , DyingSold ) ;
3085: LD_EXP 5
3089: PPUSH
3090: LD_EXP 34
3094: PPUSH
3095: CALL_OW 128
// until GetDistUnits ( Khatam , DyingSold ) < 2 ;
3099: LD_EXP 5
3103: PPUSH
3104: LD_EXP 34
3108: PPUSH
3109: CALL_OW 296
3113: PUSH
3114: LD_INT 2
3116: LESS
3117: IFFALSE 3078
// spotCorpses = 0 ;
3119: LD_ADDR_EXP 32
3123: PUSH
3124: LD_INT 0
3126: ST_TO_ADDR
// SetLives ( DyingSold , 10 ) ;
3127: LD_EXP 34
3131: PPUSH
3132: LD_INT 10
3134: PPUSH
3135: CALL_OW 234
// wait ( 0 0$3 ) ;
3139: LD_INT 105
3141: PPUSH
3142: CALL_OW 67
// KillUnit ( DyingSold ) ;
3146: LD_EXP 34
3150: PPUSH
3151: CALL_OW 66
// wait ( 0 0$1 ) ;
3155: LD_INT 35
3157: PPUSH
3158: CALL_OW 67
// CenterNowOnUnits ( [ JMM , Khatam ] ) ;
3162: LD_EXP 1
3166: PUSH
3167: LD_EXP 5
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 87
// ComTurnUnit ( Khatam , JMM ) ;
3180: LD_EXP 5
3184: PPUSH
3185: LD_EXP 1
3189: PPUSH
3190: CALL_OW 119
// wait ( 0 0$1 ) ;
3194: LD_INT 35
3196: PPUSH
3197: CALL_OW 67
// Say ( Khatam , DCorpses-Khat-1 ) ;
3201: LD_EXP 5
3205: PPUSH
3206: LD_STRING DCorpses-Khat-1
3208: PPUSH
3209: CALL_OW 88
// end ; InGameOff ;
3213: CALL_OW 9
// Say ( JMM , DCorpses-JMM-2 ) ;
3217: LD_EXP 1
3221: PPUSH
3222: LD_STRING DCorpses-JMM-2
3224: PPUSH
3225: CALL_OW 88
// end ;
3229: PPOPN 5
3231: END
// every 0 0$1 trigger spotCorpses = 1 do
3232: LD_EXP 32
3236: PUSH
3237: LD_INT 1
3239: EQUAL
3240: IFFALSE 3258
3242: GO 3244
3244: DISABLE
// begin enable ;
3245: ENABLE
// SetLives ( DyingSold , 10 ) ;
3246: LD_EXP 34
3250: PPUSH
3251: LD_INT 10
3253: PPUSH
3254: CALL_OW 234
// end ;
3258: END
// every 1 trigger ( FilterUnitsInArea ( WaterScene , [ f_side , 1 ] ) > 0 or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Jerry ) , Jerry ) < 13 ) do var i ;
3259: LD_INT 8
3261: PPUSH
3262: LD_INT 22
3264: PUSH
3265: LD_INT 1
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 70
3276: PUSH
3277: LD_INT 0
3279: GREATER
3280: PUSH
3281: LD_INT 22
3283: PUSH
3284: LD_INT 1
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: PPUSH
3291: CALL_OW 69
3295: PPUSH
3296: LD_EXP 7
3300: PPUSH
3301: CALL_OW 74
3305: PPUSH
3306: LD_EXP 7
3310: PPUSH
3311: CALL_OW 296
3315: PUSH
3316: LD_INT 13
3318: LESS
3319: OR
3320: IFFALSE 3517
3322: GO 3324
3324: DISABLE
3325: LD_INT 0
3327: PPUSH
// begin InGameOn ;
3328: CALL_OW 8
// SetLives ( Jerry , 250 ) ;
3332: LD_EXP 7
3336: PPUSH
3337: LD_INT 250
3339: PPUSH
3340: CALL_OW 234
// SetLives ( Brian , [ 1000 , 800 , 750 ] [ Difficulty ] ) ;
3344: LD_EXP 6
3348: PPUSH
3349: LD_INT 1000
3351: PUSH
3352: LD_INT 800
3354: PUSH
3355: LD_INT 750
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_OWVAR 67
3367: ARRAY
3368: PPUSH
3369: CALL_OW 234
// SetAttitude ( 3 , 4 , att_enemy , true ) ;
3373: LD_INT 3
3375: PPUSH
3376: LD_INT 4
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: LD_INT 1
3384: PPUSH
3385: CALL_OW 80
// CenterOnUnits ( [ Brian , Jerry ] ) ;
3389: LD_EXP 6
3393: PUSH
3394: LD_EXP 7
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: PPUSH
3403: CALL_OW 85
// for i in FilterUnitsInArea ( RussiansWaterSpawn , [ f_side , 3 ] ) do
3407: LD_ADDR_VAR 0 1
3411: PUSH
3412: LD_INT 9
3414: PPUSH
3415: LD_INT 22
3417: PUSH
3418: LD_INT 3
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PPUSH
3425: CALL_OW 70
3429: PUSH
3430: FOR_IN
3431: IFFALSE 3444
// ComFree ( i ) ;
3433: LD_VAR 0 1
3437: PPUSH
3438: CALL_OW 139
3442: GO 3430
3444: POP
3445: POP
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
3446: LD_ADDR_VAR 0 1
3450: PUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 4
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 69
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// ComFree ( i ) ;
3469: LD_VAR 0 1
3473: PPUSH
3474: CALL_OW 139
3478: GO 3466
3480: POP
3481: POP
// wait ( 0 0$1 ) ;
3482: LD_INT 35
3484: PPUSH
3485: CALL_OW 67
// InGameOff ;
3489: CALL_OW 9
// Say ( Brian , DF-Sol1-1 ) ;
3493: LD_EXP 6
3497: PPUSH
3498: LD_STRING DF-Sol1-1
3500: PPUSH
3501: CALL_OW 88
// Say ( JMM , DF-JMM-1 ) ;
3505: LD_EXP 1
3509: PPUSH
3510: LD_STRING DF-JMM-1
3512: PPUSH
3513: CALL_OW 88
// end ;
3517: PPOPN 1
3519: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 do
3520: LD_INT 19
3522: PPUSH
3523: LD_INT 22
3525: PUSH
3526: LD_INT 3
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PPUSH
3533: CALL_OW 70
3537: PUSH
3538: LD_INT 0
3540: EQUAL
3541: IFFALSE 3650
3543: GO 3545
3545: DISABLE
// begin if not IsDead ( Brian ) then
3546: LD_EXP 6
3550: PPUSH
3551: CALL_OW 301
3555: NOT
3556: IFFALSE 3570
// SetSide ( Brian , 1 ) ;
3558: LD_EXP 6
3562: PPUSH
3563: LD_INT 1
3565: PPUSH
3566: CALL_OW 235
// if not IsDead ( Jerry ) then
3570: LD_EXP 7
3574: PPUSH
3575: CALL_OW 301
3579: NOT
3580: IFFALSE 3594
// SetSide ( Jerry , 1 ) ;
3582: LD_EXP 7
3586: PPUSH
3587: LD_INT 1
3589: PPUSH
3590: CALL_OW 235
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) then
3594: LD_INT 22
3596: PUSH
3597: LD_INT 1
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 25
3606: PUSH
3607: LD_INT 4
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: PPUSH
3618: CALL_OW 69
3622: IFFALSE 3638
// Say ( JMM , DFa-JMM-1 ) else
3624: LD_EXP 1
3628: PPUSH
3629: LD_STRING DFa-JMM-1
3631: PPUSH
3632: CALL_OW 88
3636: GO 3650
// Say ( JMM , DFa-JMM-1a ) ;
3638: LD_EXP 1
3642: PPUSH
3643: LD_STRING DFa-JMM-1a
3645: PPUSH
3646: CALL_OW 88
// end ;
3650: END
// every 0 0$1 trigger FilterUnitsInArea ( WaterArea , [ f_side , 3 ] ) = 0 and not IsOk ( Brian ) do
3651: LD_INT 19
3653: PPUSH
3654: LD_INT 22
3656: PUSH
3657: LD_INT 3
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: PPUSH
3664: CALL_OW 70
3668: PUSH
3669: LD_INT 0
3671: EQUAL
3672: PUSH
3673: LD_EXP 6
3677: PPUSH
3678: CALL_OW 302
3682: NOT
3683: AND
3684: IFFALSE 3770
3686: GO 3688
3688: DISABLE
// begin repeat wait ( 0 0$1 ) ;
3689: LD_INT 35
3691: PPUSH
3692: CALL_OW 67
// until GetLives ( Brian ) > 250 ;
3696: LD_EXP 6
3700: PPUSH
3701: CALL_OW 256
3705: PUSH
3706: LD_INT 250
3708: GREATER
3709: IFFALSE 3689
// Say ( Brian , DFb-Sol1-1 ) ;
3711: LD_EXP 6
3715: PPUSH
3716: LD_STRING DFb-Sol1-1
3718: PPUSH
3719: CALL_OW 88
// ComMoveXY ( Brian , 78 , 74 ) ;
3723: LD_EXP 6
3727: PPUSH
3728: LD_INT 78
3730: PPUSH
3731: LD_INT 74
3733: PPUSH
3734: CALL_OW 111
// if IsDead ( Jerry ) then
3738: LD_EXP 7
3742: PPUSH
3743: CALL_OW 301
3747: IFFALSE 3763
// Say ( Brian , DFb-Sol1-1a ) else
3749: LD_EXP 6
3753: PPUSH
3754: LD_STRING DFb-Sol1-1a
3756: PPUSH
3757: CALL_OW 88
3761: GO 3770
// SetAchievement ( ACH_JERRY ) ;
3763: LD_STRING ACH_JERRY
3765: PPUSH
3766: CALL_OW 543
// end ;
3770: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) = 0 do var i ;
3771: LD_INT 22
3773: PUSH
3774: LD_INT 1
3776: PUSH
3777: EMPTY
3778: LIST
3779: LIST
3780: PUSH
3781: LD_INT 21
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 0
3802: EQUAL
3803: IFFALSE 3891
3805: GO 3807
3807: DISABLE
3808: LD_INT 0
3810: PPUSH
// begin enable ;
3811: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_btype , 31 ] ] ) do
3812: LD_ADDR_VAR 0 1
3816: PUSH
3817: LD_INT 22
3819: PUSH
3820: LD_INT 3
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: PUSH
3827: LD_INT 21
3829: PUSH
3830: LD_INT 3
3832: PUSH
3833: EMPTY
3834: LIST
3835: LIST
3836: PUSH
3837: LD_INT 30
3839: PUSH
3840: LD_INT 31
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 69
3856: PUSH
3857: FOR_IN
3858: IFFALSE 3889
// begin if See ( 1 , i ) then
3860: LD_INT 1
3862: PPUSH
3863: LD_VAR 0 1
3867: PPUSH
3868: CALL_OW 292
3872: IFFALSE 3887
// begin disable ;
3874: DISABLE
// Say ( JMM , DX1-JMM-1 ) ;
3875: LD_EXP 1
3879: PPUSH
3880: LD_STRING DX1-JMM-1
3882: PPUSH
3883: CALL_OW 88
// end ; end ;
3887: GO 3857
3889: POP
3890: POP
// end ;
3891: PPOPN 1
3893: END
// every 0 0$1 trigger SeeArea ( 1 , SouthBaseRussianSpawn1 ) do var i , j , mech ;
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 11
3899: PPUSH
3900: CALL_OW 294
3904: IFFALSE 4163
3906: GO 3908
3908: DISABLE
3909: LD_INT 0
3911: PPUSH
3912: PPUSH
3913: PPUSH
// begin DialogueOn ;
3914: CALL_OW 6
// Say ( FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) [ 1 ] , DX3-Rus1-1 ) ;
3918: LD_INT 11
3920: PPUSH
3921: LD_INT 22
3923: PUSH
3924: LD_INT 3
3926: PUSH
3927: EMPTY
3928: LIST
3929: LIST
3930: PUSH
3931: LD_INT 21
3933: PUSH
3934: LD_INT 1
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: PPUSH
3945: CALL_OW 70
3949: PUSH
3950: LD_INT 1
3952: ARRAY
3953: PPUSH
3954: LD_STRING DX3-Rus1-1
3956: PPUSH
3957: CALL_OW 88
// Say ( JMM , DX3-JMM-1 ) ;
3961: LD_EXP 1
3965: PPUSH
3966: LD_STRING DX3-JMM-1
3968: PPUSH
3969: CALL_OW 88
// DialogueOff ;
3973: CALL_OW 7
// for i in FilterUnitsInArea ( SouthBaseRussianSpawn1 , [ [ f_side , 3 ] , [ f_class , 1 ] ] ) do
3977: LD_ADDR_VAR 0 1
3981: PUSH
3982: LD_INT 11
3984: PPUSH
3985: LD_INT 22
3987: PUSH
3988: LD_INT 3
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: LD_INT 25
3997: PUSH
3998: LD_INT 1
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: PPUSH
4009: CALL_OW 70
4013: PUSH
4014: FOR_IN
4015: IFFALSE 4035
// southBaseDefenders = southBaseDefenders ^ i ;
4017: LD_ADDR_EXP 25
4021: PUSH
4022: LD_EXP 25
4026: PUSH
4027: LD_VAR 0 1
4031: ADD
4032: ST_TO_ADDR
4033: GO 4014
4035: POP
4036: POP
// wait ( [ 0 0$5 , 0 0$4 , 0 0$3 ] [ Difficulty ] ) ;
4037: LD_INT 175
4039: PUSH
4040: LD_INT 140
4042: PUSH
4043: LD_INT 105
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: LD_OWVAR 67
4055: ARRAY
4056: PPUSH
4057: CALL_OW 67
// mech := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_class , 3 ] ] ) ;
4061: LD_ADDR_VAR 0 3
4065: PUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 3
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 21
4078: PUSH
4079: LD_INT 1
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 25
4088: PUSH
4089: LD_INT 3
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 69
4105: ST_TO_ADDR
// if not mech then
4106: LD_VAR 0 3
4110: NOT
4111: IFFALSE 4115
// exit ;
4113: GO 4163
// ComExitBuilding ( mech ) ;
4115: LD_VAR 0 3
4119: PPUSH
4120: CALL_OW 122
// wait ( 0 0$1 ) ;
4124: LD_INT 35
4126: PPUSH
4127: CALL_OW 67
// AddComEnterUnit ( mech [ 1 ] , vehicle1 ) ;
4131: LD_VAR 0 3
4135: PUSH
4136: LD_INT 1
4138: ARRAY
4139: PPUSH
4140: LD_INT 5
4142: PPUSH
4143: CALL_OW 180
// AddComEnterUnit ( mech [ 2 ] , vehicle2 ) ;
4147: LD_VAR 0 3
4151: PUSH
4152: LD_INT 2
4154: ARRAY
4155: PPUSH
4156: LD_INT 4
4158: PPUSH
4159: CALL_OW 180
// end ;
4163: PPOPN 3
4165: END
// every 0 0$1 trigger See ( 1 , vehicle1 ) or See ( 1 , vehicle2 ) do
4166: LD_INT 1
4168: PPUSH
4169: LD_INT 5
4171: PPUSH
4172: CALL_OW 292
4176: PUSH
4177: LD_INT 1
4179: PPUSH
4180: LD_INT 4
4182: PPUSH
4183: CALL_OW 292
4187: OR
4188: IFFALSE 4272
4190: GO 4192
4192: DISABLE
// begin CenterOnUnits ( [ vehicle1 , vehicle2 ] ) ;
4193: LD_INT 5
4195: PUSH
4196: LD_INT 4
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PPUSH
4203: CALL_OW 85
// if IsOK ( Bobby ) then
4207: LD_EXP 2
4211: PPUSH
4212: CALL_OW 302
4216: IFFALSE 4252
// begin DialogueOn ;
4218: CALL_OW 6
// Say ( Bobby , DX2-Bobby-1 ) ;
4222: LD_EXP 2
4226: PPUSH
4227: LD_STRING DX2-Bobby-1
4229: PPUSH
4230: CALL_OW 88
// Say ( JMM , DX2-JMM-1a ) ;
4234: LD_EXP 1
4238: PPUSH
4239: LD_STRING DX2-JMM-1a
4241: PPUSH
4242: CALL_OW 88
// DialogueOff ;
4246: CALL_OW 7
// end else
4250: GO 4272
// begin DialogueOn ;
4252: CALL_OW 6
// Say ( JMM , DX2-JMM-1 ) ;
4256: LD_EXP 1
4260: PPUSH
4261: LD_STRING DX2-JMM-1
4263: PPUSH
4264: CALL_OW 88
// DialogueOff ;
4268: CALL_OW 7
// end ; end ;
4272: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) do var tmp , speaker , temp1 , temp2 , i ;
4273: LD_INT 22
4275: PUSH
4276: LD_INT 1
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 23
4285: PUSH
4286: LD_INT 3
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 2
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: LD_INT 34
4305: PUSH
4306: LD_INT 42
4308: PUSH
4309: EMPTY
4310: LIST
4311: LIST
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: LIST
4318: PPUSH
4319: CALL_OW 69
4323: IFFALSE 4744
4325: GO 4327
4327: DISABLE
4328: LD_INT 0
4330: PPUSH
4331: PPUSH
4332: PPUSH
4333: PPUSH
4334: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 42 ] ] ) ;
4335: LD_ADDR_VAR 0 1
4339: PUSH
4340: LD_INT 22
4342: PUSH
4343: LD_INT 1
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 23
4352: PUSH
4353: LD_INT 3
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 21
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: LD_INT 34
4372: PUSH
4373: LD_INT 42
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: PPUSH
4386: CALL_OW 69
4390: ST_TO_ADDR
// temp1 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Cyrus , Bobby ] ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: LD_INT 22
4398: PUSH
4399: LD_INT 1
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 21
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 26
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL_OW 69
4435: PUSH
4436: LD_EXP 1
4440: PUSH
4441: LD_EXP 3
4445: PUSH
4446: LD_EXP 2
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: DIFF
4456: ST_TO_ADDR
// temp2 = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_female ] ] ) diff [ Lisa ] ;
4457: LD_ADDR_VAR 0 4
4461: PUSH
4462: LD_INT 22
4464: PUSH
4465: LD_INT 1
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PUSH
4472: LD_INT 21
4474: PUSH
4475: LD_INT 1
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 26
4484: PUSH
4485: LD_INT 2
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: PUSH
4502: LD_EXP 4
4506: PUSH
4507: EMPTY
4508: LIST
4509: DIFF
4510: ST_TO_ADDR
// if not tmp then
4511: LD_VAR 0 1
4515: NOT
4516: IFFALSE 4520
// exit ;
4518: GO 4744
// speaker := IsDrivenBy ( tmp [ 1 ] ) ;
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: LD_VAR 0 1
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PPUSH
4534: CALL_OW 311
4538: ST_TO_ADDR
// if not speaker then
4539: LD_VAR 0 2
4543: NOT
4544: IFFALSE 4548
// exit ;
4546: GO 4744
// DialogueOn ;
4548: CALL_OW 6
// if speaker = JMM then
4552: LD_VAR 0 2
4556: PUSH
4557: LD_EXP 1
4561: EQUAL
4562: IFFALSE 4596
// begin if Lisa then
4564: LD_EXP 4
4568: IFFALSE 4582
// Say ( Lisa , DX2b-Lisa-1 ) ;
4570: LD_EXP 4
4574: PPUSH
4575: LD_STRING DX2b-Lisa-1
4577: PPUSH
4578: CALL_OW 88
// Say ( JMM , DX2b-JMM-1 ) ;
4582: LD_EXP 1
4586: PPUSH
4587: LD_STRING DX2b-JMM-1
4589: PPUSH
4590: CALL_OW 88
// end else
4594: GO 4740
// begin Say ( JMM , DX2a-JMM-1 ) ;
4596: LD_EXP 1
4600: PPUSH
4601: LD_STRING DX2a-JMM-1
4603: PPUSH
4604: CALL_OW 88
// if speaker = Bobby then
4608: LD_VAR 0 2
4612: PUSH
4613: LD_EXP 2
4617: EQUAL
4618: IFFALSE 4632
// Say ( Bobby , DX2a-Bobby-1 ) ;
4620: LD_EXP 2
4624: PPUSH
4625: LD_STRING DX2a-Bobby-1
4627: PPUSH
4628: CALL_OW 88
// if speaker = Cyrus then
4632: LD_VAR 0 2
4636: PUSH
4637: LD_EXP 3
4641: EQUAL
4642: IFFALSE 4656
// Say ( Cyrus , DX2a-Cyrus-1 ) ;
4644: LD_EXP 3
4648: PPUSH
4649: LD_STRING DX2a-Cyrus-1
4651: PPUSH
4652: CALL_OW 88
// if speaker = Lisa then
4656: LD_VAR 0 2
4660: PUSH
4661: LD_EXP 4
4665: EQUAL
4666: IFFALSE 4680
// Say ( Lisa , DX2a-Lisa-1 ) ;
4668: LD_EXP 4
4672: PPUSH
4673: LD_STRING DX2a-Lisa-1
4675: PPUSH
4676: CALL_OW 88
// if speaker in temp1 then
4680: LD_VAR 0 2
4684: PUSH
4685: LD_VAR 0 3
4689: IN
4690: IFFALSE 4704
// Say ( speaker , DX2a-Sol1-1 ) ;
4692: LD_VAR 0 2
4696: PPUSH
4697: LD_STRING DX2a-Sol1-1
4699: PPUSH
4700: CALL_OW 88
// if speaker in temp2 then
4704: LD_VAR 0 2
4708: PUSH
4709: LD_VAR 0 4
4713: IN
4714: IFFALSE 4728
// Say ( speaker , DX2a-FSol1-1 ) ;
4716: LD_VAR 0 2
4720: PPUSH
4721: LD_STRING DX2a-FSol1-1
4723: PPUSH
4724: CALL_OW 88
// Say ( JMM , DX2a-JMM-2 ) ;
4728: LD_EXP 1
4732: PPUSH
4733: LD_STRING DX2a-JMM-2
4735: PPUSH
4736: CALL_OW 88
// end ; DialogueOff ;
4740: CALL_OW 7
// end ;
4744: PPOPN 5
4746: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 or GetSide ( dep2 ) = 1 do
4747: LD_INT 1
4749: PPUSH
4750: CALL_OW 255
4754: PUSH
4755: LD_INT 1
4757: EQUAL
4758: PUSH
4759: LD_INT 10
4761: PPUSH
4762: CALL_OW 255
4766: PUSH
4767: LD_INT 1
4769: EQUAL
4770: OR
4771: IFFALSE 4831
4773: GO 4775
4775: DISABLE
// begin DialogueOn ;
4776: CALL_OW 6
// Say ( JMM , D3-JMM-1 ) ;
4780: LD_EXP 1
4784: PPUSH
4785: LD_STRING D3-JMM-1
4787: PPUSH
4788: CALL_OW 88
// SayRadio ( Powell , D3-Pow-1 ) ;
4792: LD_EXP 9
4796: PPUSH
4797: LD_STRING D3-Pow-1
4799: PPUSH
4800: CALL_OW 94
// if IsOK ( Cyrus ) then
4804: LD_EXP 3
4808: PPUSH
4809: CALL_OW 302
4813: IFFALSE 4827
// Say ( Cyrus , D3-Cyrus-1 ) ;
4815: LD_EXP 3
4819: PPUSH
4820: LD_STRING D3-Cyrus-1
4822: PPUSH
4823: CALL_OW 88
// DialogueOff ;
4827: CALL_OW 7
// end ;
4831: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 do var temp , tmp , i ;
4832: LD_INT 1
4834: PPUSH
4835: CALL_OW 255
4839: PUSH
4840: LD_INT 1
4842: EQUAL
4843: PUSH
4844: LD_INT 10
4846: PPUSH
4847: CALL_OW 255
4851: PUSH
4852: LD_INT 1
4854: EQUAL
4855: AND
4856: IFFALSE 6239
4858: GO 4860
4860: DISABLE
4861: LD_INT 0
4863: PPUSH
4864: PPUSH
4865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
4866: LD_ADDR_VAR 0 2
4870: PUSH
4871: LD_INT 22
4873: PUSH
4874: LD_INT 3
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 21
4883: PUSH
4884: LD_INT 1
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 69
4899: ST_TO_ADDR
// if tmp then
4900: LD_VAR 0 2
4904: IFFALSE 4965
// begin for i in tmp do
4906: LD_ADDR_VAR 0 3
4910: PUSH
4911: LD_VAR 0 2
4915: PUSH
4916: FOR_IN
4917: IFFALSE 4963
// begin if IsInUnit ( i ) then
4919: LD_VAR 0 3
4923: PPUSH
4924: CALL_OW 310
4928: IFFALSE 4939
// ComExitBuilding ( i ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: CALL_OW 122
// wait ( 0 0$1 ) ;
4939: LD_INT 35
4941: PPUSH
4942: CALL_OW 67
// AddComAgressiveMove ( i , 54 , 17 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 54
4953: PPUSH
4954: LD_INT 17
4956: PPUSH
4957: CALL_OW 174
// end ;
4961: GO 4916
4963: POP
4964: POP
// end ; wait ( 0 0$03 ) ;
4965: LD_INT 105
4967: PPUSH
4968: CALL_OW 67
// DialogueOn ;
4972: CALL_OW 6
// Say ( JMM , D3a-JMM-1 ) ;
4976: LD_EXP 1
4980: PPUSH
4981: LD_STRING D3a-JMM-1
4983: PPUSH
4984: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-1 ) ;
4988: LD_EXP 9
4992: PPUSH
4993: LD_STRING D3a-Pow-1
4995: PPUSH
4996: CALL_OW 94
// Say ( JMM , D3a-JMM-2 ) ;
5000: LD_EXP 1
5004: PPUSH
5005: LD_STRING D3a-JMM-2
5007: PPUSH
5008: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-2 ) ;
5012: LD_EXP 9
5016: PPUSH
5017: LD_STRING D3a-Pow-2
5019: PPUSH
5020: CALL_OW 94
// Say ( JMM , D3a-JMM-3 ) ;
5024: LD_EXP 1
5028: PPUSH
5029: LD_STRING D3a-JMM-3
5031: PPUSH
5032: CALL_OW 88
// SayRadio ( Powell , D3a-Pow-3 ) ;
5036: LD_EXP 9
5040: PPUSH
5041: LD_STRING D3a-Pow-3
5043: PPUSH
5044: CALL_OW 94
// Say ( JMM , D3a-JMM-4 ) ;
5048: LD_EXP 1
5052: PPUSH
5053: LD_STRING D3a-JMM-4
5055: PPUSH
5056: CALL_OW 88
// DialogueOff ;
5060: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5064: LD_STRING M2
5066: PPUSH
5067: CALL_OW 337
// Say ( JMM , D3b-JMM-1 ) ;
5071: LD_EXP 1
5075: PPUSH
5076: LD_STRING D3b-JMM-1
5078: PPUSH
5079: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// until FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_class , 2 ] ] ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ;
5090: LD_INT 22
5092: PPUSH
5093: LD_INT 22
5095: PUSH
5096: LD_INT 1
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 25
5105: PUSH
5106: LD_INT 2
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PPUSH
5117: CALL_OW 70
5121: PUSH
5122: LD_INT 22
5124: PUSH
5125: LD_INT 3
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 21
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PPUSH
5146: CALL_OW 69
5150: NOT
5151: AND
5152: IFFALSE 5083
// repeat temp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Khatam ] ;
5154: LD_ADDR_VAR 0 1
5158: PUSH
5159: LD_INT 22
5161: PUSH
5162: LD_INT 1
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: LD_INT 23
5171: PUSH
5172: LD_INT 1
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: PUSH
5179: LD_INT 25
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PUSH
5189: LD_INT 50
5191: PUSH
5192: EMPTY
5193: LIST
5194: PUSH
5195: LD_INT 56
5197: PUSH
5198: EMPTY
5199: LIST
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: PUSH
5213: LD_EXP 1
5217: PUSH
5218: LD_EXP 5
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: DIFF
5227: ST_TO_ADDR
// wait ( 0 0$1 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until temp > 0 ;
5235: LD_VAR 0 1
5239: PUSH
5240: LD_INT 0
5242: GREATER
5243: IFFALSE 5154
// wait ( 0 0$5 ) ;
5245: LD_INT 175
5247: PPUSH
5248: CALL_OW 67
// PrepareRussianHeroes ;
5252: CALL 11590 0 0
// InGameOn ;
5256: CALL_OW 8
// CenterNowOnUnits ( Mikhail ) ;
5260: LD_EXP 8
5264: PPUSH
5265: CALL_OW 87
// ComTurnUnit ( [ JMM , temp [ 1 ] ] , Mikhail ) ;
5269: LD_EXP 1
5273: PUSH
5274: LD_VAR 0 1
5278: PUSH
5279: LD_INT 1
5281: ARRAY
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PPUSH
5287: LD_EXP 8
5291: PPUSH
5292: CALL_OW 119
// ComTurnUnit ( Mikhail , temp [ 1 ] ) ;
5296: LD_EXP 8
5300: PPUSH
5301: LD_VAR 0 1
5305: PUSH
5306: LD_INT 1
5308: ARRAY
5309: PPUSH
5310: CALL_OW 119
// Wait ( 0 0$02 ) ;
5314: LD_INT 70
5316: PPUSH
5317: CALL_OW 67
// Say ( Mikhail , D4-Mikh-1 ) ;
5321: LD_EXP 8
5325: PPUSH
5326: LD_STRING D4-Mikh-1
5328: PPUSH
5329: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5333: LD_VAR 0 1
5337: PUSH
5338: LD_INT 1
5340: ARRAY
5341: PPUSH
5342: CALL_OW 258
5346: PUSH
5347: LD_INT 1
5349: EQUAL
5350: IFFALSE 5368
// Say ( temp [ 1 ] , D4-Sol1-1 ) ;
5352: LD_VAR 0 1
5356: PUSH
5357: LD_INT 1
5359: ARRAY
5360: PPUSH
5361: LD_STRING D4-Sol1-1
5363: PPUSH
5364: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5368: LD_VAR 0 1
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: CALL_OW 258
5381: PUSH
5382: LD_INT 2
5384: EQUAL
5385: IFFALSE 5403
// Say ( temp [ 1 ] , D4-FSol1-1 ) ;
5387: LD_VAR 0 1
5391: PUSH
5392: LD_INT 1
5394: ARRAY
5395: PPUSH
5396: LD_STRING D4-FSol1-1
5398: PPUSH
5399: CALL_OW 88
// Say ( Mikhail , D4-Mikh-2 ) ;
5403: LD_EXP 8
5407: PPUSH
5408: LD_STRING D4-Mikh-2
5410: PPUSH
5411: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5415: LD_VAR 0 1
5419: PUSH
5420: LD_INT 1
5422: ARRAY
5423: PPUSH
5424: CALL_OW 258
5428: PUSH
5429: LD_INT 1
5431: EQUAL
5432: IFFALSE 5450
// Say ( temp [ 1 ] , D4-Sol1-2 ) ;
5434: LD_VAR 0 1
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PPUSH
5443: LD_STRING D4-Sol1-2
5445: PPUSH
5446: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5450: LD_VAR 0 1
5454: PUSH
5455: LD_INT 1
5457: ARRAY
5458: PPUSH
5459: CALL_OW 258
5463: PUSH
5464: LD_INT 2
5466: EQUAL
5467: IFFALSE 5485
// Say ( temp [ 1 ] , D4-FSol1-2 ) ;
5469: LD_VAR 0 1
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PPUSH
5478: LD_STRING D4-FSol1-2
5480: PPUSH
5481: CALL_OW 88
// Say ( Mikhail , D4-Mikh-3 ) ;
5485: LD_EXP 8
5489: PPUSH
5490: LD_STRING D4-Mikh-3
5492: PPUSH
5493: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: CALL_OW 258
5510: PUSH
5511: LD_INT 1
5513: EQUAL
5514: IFFALSE 5532
// Say ( temp [ 1 ] , D4-Sol1-3 ) ;
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 1
5523: ARRAY
5524: PPUSH
5525: LD_STRING D4-Sol1-3
5527: PPUSH
5528: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5532: LD_VAR 0 1
5536: PUSH
5537: LD_INT 1
5539: ARRAY
5540: PPUSH
5541: CALL_OW 258
5545: PUSH
5546: LD_INT 2
5548: EQUAL
5549: IFFALSE 5567
// Say ( temp [ 1 ] , D4-FSol1-3 ) ;
5551: LD_VAR 0 1
5555: PUSH
5556: LD_INT 1
5558: ARRAY
5559: PPUSH
5560: LD_STRING D4-FSol1-3
5562: PPUSH
5563: CALL_OW 88
// Say ( Mikhail , D4-Mikh-4 ) ;
5567: LD_EXP 8
5571: PPUSH
5572: LD_STRING D4-Mikh-4
5574: PPUSH
5575: CALL_OW 88
// case query ( Qs1 ) of 1 :
5579: LD_STRING Qs1
5581: PPUSH
5582: CALL_OW 97
5586: PUSH
5587: LD_INT 1
5589: DOUBLE
5590: EQUAL
5591: IFTRUE 5595
5593: GO 5630
5595: POP
// begin InGameOff ;
5596: CALL_OW 9
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
5600: LD_INT 1
5602: PPUSH
5603: LD_INT 6
5605: PPUSH
5606: LD_INT 2
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: CALL_OW 80
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
5616: LD_EXP 8
5620: PPUSH
5621: LD_INT 17
5623: PPUSH
5624: CALL_OW 113
// end ; 2 :
5628: GO 6223
5630: LD_INT 2
5632: DOUBLE
5633: EQUAL
5634: IFTRUE 5638
5636: GO 6188
5638: POP
// begin repeat wait ( 0 0$1 ) ;
5639: LD_INT 35
5641: PPUSH
5642: CALL_OW 67
// CenterNowOnUnits ( temp [ 1 ] ) ;
5646: LD_VAR 0 1
5650: PUSH
5651: LD_INT 1
5653: ARRAY
5654: PPUSH
5655: CALL_OW 87
// ComMoveUnit ( temp [ 1 ] , JMM ) ;
5659: LD_VAR 0 1
5663: PUSH
5664: LD_INT 1
5666: ARRAY
5667: PPUSH
5668: LD_EXP 1
5672: PPUSH
5673: CALL_OW 112
// ComMoveUnit ( Mikhail , JMM ) ;
5677: LD_EXP 8
5681: PPUSH
5682: LD_EXP 1
5686: PPUSH
5687: CALL_OW 112
// until ( GetDistUnits ( JMM , Mikhail ) < 5 ) ;
5691: LD_EXP 1
5695: PPUSH
5696: LD_EXP 8
5700: PPUSH
5701: CALL_OW 296
5705: PUSH
5706: LD_INT 5
5708: LESS
5709: IFFALSE 5639
// ComTurnUnit ( Mikhail , JMM ) ;
5711: LD_EXP 8
5715: PPUSH
5716: LD_EXP 1
5720: PPUSH
5721: CALL_OW 119
// Say ( JMM , D4b-JMM-1 ) ;
5725: LD_EXP 1
5729: PPUSH
5730: LD_STRING D4b-JMM-1
5732: PPUSH
5733: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-1 ) ;
5737: LD_EXP 8
5741: PPUSH
5742: LD_STRING D4b-Mikh-1
5744: PPUSH
5745: CALL_OW 88
// Say ( JMM , D4b-JMM-2 ) ;
5749: LD_EXP 1
5753: PPUSH
5754: LD_STRING D4b-JMM-2
5756: PPUSH
5757: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-2 ) ;
5761: LD_EXP 8
5765: PPUSH
5766: LD_STRING D4b-Mikh-2
5768: PPUSH
5769: CALL_OW 88
// Say ( JMM , D4b-JMM-3 ) ;
5773: LD_EXP 1
5777: PPUSH
5778: LD_STRING D4b-JMM-3
5780: PPUSH
5781: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-3 ) ;
5785: LD_EXP 8
5789: PPUSH
5790: LD_STRING D4b-Mikh-3
5792: PPUSH
5793: CALL_OW 88
// Say ( JMM , D4b-JMM-4 ) ;
5797: LD_EXP 1
5801: PPUSH
5802: LD_STRING D4b-JMM-4
5804: PPUSH
5805: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-4 ) ;
5809: LD_EXP 8
5813: PPUSH
5814: LD_STRING D4b-Mikh-4
5816: PPUSH
5817: CALL_OW 88
// Say ( JMM , D4b-JMM-5 ) ;
5821: LD_EXP 1
5825: PPUSH
5826: LD_STRING D4b-JMM-5
5828: PPUSH
5829: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-5 ) ;
5833: LD_EXP 8
5837: PPUSH
5838: LD_STRING D4b-Mikh-5
5840: PPUSH
5841: CALL_OW 88
// Say ( JMM , D4b-JMM-6 ) ;
5845: LD_EXP 1
5849: PPUSH
5850: LD_STRING D4b-JMM-6
5852: PPUSH
5853: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-6 ) ;
5857: LD_EXP 8
5861: PPUSH
5862: LD_STRING D4b-Mikh-6
5864: PPUSH
5865: CALL_OW 88
// Say ( JMM , D4b-JMM-7 ) ;
5869: LD_EXP 1
5873: PPUSH
5874: LD_STRING D4b-JMM-7
5876: PPUSH
5877: CALL_OW 88
// Say ( Mikhail , D4b-Mikh-7 ) ;
5881: LD_EXP 8
5885: PPUSH
5886: LD_STRING D4b-Mikh-7
5888: PPUSH
5889: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5893: LD_VAR 0 1
5897: PUSH
5898: LD_INT 1
5900: ARRAY
5901: PPUSH
5902: CALL_OW 258
5906: PUSH
5907: LD_INT 1
5909: EQUAL
5910: IFFALSE 5928
// Say ( temp [ 1 ] , D4b-Sol1-7 ) ;
5912: LD_VAR 0 1
5916: PUSH
5917: LD_INT 1
5919: ARRAY
5920: PPUSH
5921: LD_STRING D4b-Sol1-7
5923: PPUSH
5924: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
5928: LD_VAR 0 1
5932: PUSH
5933: LD_INT 1
5935: ARRAY
5936: PPUSH
5937: CALL_OW 258
5941: PUSH
5942: LD_INT 2
5944: EQUAL
5945: IFFALSE 5963
// Say ( temp [ 1 ] , D4b-FSol1-7 ) ;
5947: LD_VAR 0 1
5951: PUSH
5952: LD_INT 1
5954: ARRAY
5955: PPUSH
5956: LD_STRING D4b-FSol1-7
5958: PPUSH
5959: CALL_OW 88
// Say ( JMM , D4b-JMM-8 ) ;
5963: LD_EXP 1
5967: PPUSH
5968: LD_STRING D4b-JMM-8
5970: PPUSH
5971: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 1 then
5975: LD_VAR 0 1
5979: PUSH
5980: LD_INT 1
5982: ARRAY
5983: PPUSH
5984: CALL_OW 258
5988: PUSH
5989: LD_INT 1
5991: EQUAL
5992: IFFALSE 6010
// Say ( temp [ 1 ] , D4b-Sol1-8 ) ;
5994: LD_VAR 0 1
5998: PUSH
5999: LD_INT 1
6001: ARRAY
6002: PPUSH
6003: LD_STRING D4b-Sol1-8
6005: PPUSH
6006: CALL_OW 88
// if GetSex ( temp [ 1 ] ) = 2 then
6010: LD_VAR 0 1
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PPUSH
6019: CALL_OW 258
6023: PUSH
6024: LD_INT 2
6026: EQUAL
6027: IFFALSE 6045
// Say ( temp [ 1 ] , D4b-FSol1-8 ) ;
6029: LD_VAR 0 1
6033: PUSH
6034: LD_INT 1
6036: ARRAY
6037: PPUSH
6038: LD_STRING D4b-FSol1-8
6040: PPUSH
6041: CALL_OW 88
// Say ( JMM , D4b-JMM-9 ) ;
6045: LD_EXP 1
6049: PPUSH
6050: LD_STRING D4b-JMM-9
6052: PPUSH
6053: CALL_OW 88
// SetSide ( Mikhail , 1 ) ;
6057: LD_EXP 8
6061: PPUSH
6062: LD_INT 1
6064: PPUSH
6065: CALL_OW 235
// for i in FilterAllUnits ( [ [ f_side , 1 ] ] ) do
6069: LD_ADDR_VAR 0 3
6073: PUSH
6074: LD_INT 22
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: PPUSH
6087: CALL_OW 69
6091: PUSH
6092: FOR_IN
6093: IFFALSE 6106
// ComFree ( i ) ;
6095: LD_VAR 0 3
6099: PPUSH
6100: CALL_OW 139
6104: GO 6092
6106: POP
6107: POP
// repeat wait ( 0 0$1 ) ;
6108: LD_INT 35
6110: PPUSH
6111: CALL_OW 67
// CenterNowOnUnits ( Mikhail ) ;
6115: LD_EXP 8
6119: PPUSH
6120: CALL_OW 87
// ComEnterUnit ( [ Mikhail , temp [ 1 ] ] , dep1 ) ;
6124: LD_EXP 8
6128: PUSH
6129: LD_VAR 0 1
6133: PUSH
6134: LD_INT 1
6136: ARRAY
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: CALL_OW 120
// until IsInUnit ( Mikhail ) ;
6149: LD_EXP 8
6153: PPUSH
6154: CALL_OW 310
6158: IFFALSE 6108
// mikhailDepot = IsInUnit ( Mikhail ) ;
6160: LD_ADDR_EXP 23
6164: PUSH
6165: LD_EXP 8
6169: PPUSH
6170: CALL_OW 310
6174: ST_TO_ADDR
// InGameOff ;
6175: CALL_OW 9
// ChangeMissionObjectives ( M3 ) ;
6179: LD_STRING M3
6181: PPUSH
6182: CALL_OW 337
// end ; 3 :
6186: GO 6223
6188: LD_INT 3
6190: DOUBLE
6191: EQUAL
6192: IFTRUE 6196
6194: GO 6222
6196: POP
// begin ComMoveToArea ( Mikhail , MikhailEscape ) ;
6197: LD_EXP 8
6201: PPUSH
6202: LD_INT 17
6204: PPUSH
6205: CALL_OW 113
// wait ( 0 0$3 ) ;
6209: LD_INT 105
6211: PPUSH
6212: CALL_OW 67
// InGameOff ;
6216: CALL_OW 9
// end ; end ;
6220: GO 6223
6222: POP
// PrepareTigers ;
6223: CALL 14440 0 0
// RussianTrap ;
6227: CALL 9986 0 0
// tigersRespawn = 1 ;
6231: LD_ADDR_EXP 30
6235: PUSH
6236: LD_INT 1
6238: ST_TO_ADDR
// end ;
6239: PPOPN 3
6241: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and GetResourceType ( GetBase ( dep1 ) , 1 ) >= 100 do var tmp ;
6242: LD_INT 1
6244: PPUSH
6245: CALL_OW 255
6249: PUSH
6250: LD_INT 1
6252: EQUAL
6253: PUSH
6254: LD_INT 10
6256: PPUSH
6257: CALL_OW 255
6261: PUSH
6262: LD_INT 1
6264: EQUAL
6265: AND
6266: PUSH
6267: LD_INT 1
6269: PPUSH
6270: CALL_OW 274
6274: PPUSH
6275: LD_INT 1
6277: PPUSH
6278: CALL_OW 275
6282: PUSH
6283: LD_INT 100
6285: GREATEREQUAL
6286: AND
6287: IFFALSE 6436
6289: GO 6291
6291: DISABLE
6292: LD_INT 0
6294: PPUSH
// begin wait ( rand ( 1 1$0 , 2 2$0 ) + 0 0$30 ) ;
6295: LD_INT 2100
6297: PPUSH
6298: LD_INT 4200
6300: PPUSH
6301: CALL_OW 12
6305: PUSH
6306: LD_INT 1050
6308: PLUS
6309: PPUSH
6310: CALL_OW 67
// PrepareCargoBays ;
6314: CALL 12723 0 0
// cargoRespawn = 1 ;
6318: LD_ADDR_EXP 28
6322: PUSH
6323: LD_INT 1
6325: ST_TO_ADDR
// tmp := [ cargo1 , cargo2 , driver1 , driver2 ] ;
6326: LD_ADDR_VAR 0 1
6330: PUSH
6331: LD_EXP 15
6335: PUSH
6336: LD_EXP 16
6340: PUSH
6341: LD_EXP 17
6345: PUSH
6346: LD_EXP 18
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: ST_TO_ADDR
// ComMoveXY ( tmp , 17 , 10 ) ;
6357: LD_VAR 0 1
6361: PPUSH
6362: LD_INT 17
6364: PPUSH
6365: LD_INT 10
6367: PPUSH
6368: CALL_OW 111
// AddComMoveXY ( tmp , 36 , 13 ) ;
6372: LD_VAR 0 1
6376: PPUSH
6377: LD_INT 36
6379: PPUSH
6380: LD_INT 13
6382: PPUSH
6383: CALL_OW 171
// AddComMoveXY ( tmp , 40 , 20 ) ;
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 40
6394: PPUSH
6395: LD_INT 20
6397: PPUSH
6398: CALL_OW 171
// AddComMoveXY ( tmp , 53 , 16 ) ;
6402: LD_VAR 0 1
6406: PPUSH
6407: LD_INT 53
6409: PPUSH
6410: LD_INT 16
6412: PPUSH
6413: CALL_OW 171
// wait ( 0 0$5 ) ;
6417: LD_INT 175
6419: PPUSH
6420: CALL_OW 67
// Say ( driver1 , D5-Rus2-1 ) ;
6424: LD_EXP 17
6428: PPUSH
6429: LD_STRING D5-Rus2-1
6431: PPUSH
6432: CALL_OW 88
// end ;
6436: PPOPN 1
6438: END
// every 0 0$1 trigger cargoRespawn = 1 do var cargos ;
6439: LD_EXP 28
6443: PUSH
6444: LD_INT 1
6446: EQUAL
6447: IFFALSE 6602
6449: GO 6451
6451: DISABLE
6452: LD_INT 0
6454: PPUSH
// begin cargos = FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
6455: LD_ADDR_VAR 0 1
6459: PUSH
6460: LD_INT 22
6462: PUSH
6463: LD_INT 3
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 21
6472: PUSH
6473: LD_INT 2
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: LD_INT 34
6482: PUSH
6483: LD_INT 51
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: PPUSH
6495: CALL_OW 69
6499: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
6500: LD_INT 105
6502: PPUSH
6503: CALL_OW 67
// until UnitFilter ( cargos , [ f_not , [ f_hastask ] ] ) or UnitFilter ( cargos , [ f_not , [ f_lives , 980 ] ] ) ;
6507: LD_VAR 0 1
6511: PPUSH
6512: LD_INT 3
6514: PUSH
6515: LD_INT 60
6517: PUSH
6518: EMPTY
6519: LIST
6520: PUSH
6521: EMPTY
6522: LIST
6523: LIST
6524: PPUSH
6525: CALL_OW 72
6529: PUSH
6530: LD_VAR 0 1
6534: PPUSH
6535: LD_INT 3
6537: PUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 980
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PPUSH
6552: CALL_OW 72
6556: OR
6557: IFFALSE 6500
// ComMoveXY ( cargos , 7 , 9 ) ;
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 7
6566: PPUSH
6567: LD_INT 9
6569: PPUSH
6570: CALL_OW 111
// cargoSee = 1 ;
6574: LD_ADDR_EXP 29
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// cargoEscape = 1 ;
6582: LD_ADDR_EXP 20
6586: PUSH
6587: LD_INT 1
6589: ST_TO_ADDR
// Say ( driver1 , D5-Rus2-1a ) ;
6590: LD_EXP 17
6594: PPUSH
6595: LD_STRING D5-Rus2-1a
6597: PPUSH
6598: CALL_OW 88
// end ;
6602: PPOPN 1
6604: END
// every 0 0$1 trigger cargoEscape > 0 do
6605: LD_EXP 20
6609: PUSH
6610: LD_INT 0
6612: GREATER
6613: IFFALSE 6760
6615: GO 6617
6617: DISABLE
// begin enable ;
6618: ENABLE
// ComMoveToArea ( [ cargo1 , cargo2 ] , RussianAttack ) ;
6619: LD_EXP 15
6623: PUSH
6624: LD_EXP 16
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PPUSH
6633: LD_INT 13
6635: PPUSH
6636: CALL_OW 113
// if IsInArea ( cargo1 , RussianAttack ) or IsInArea ( driver1 , RussianAttack ) then
6640: LD_EXP 15
6644: PPUSH
6645: LD_INT 13
6647: PPUSH
6648: CALL_OW 308
6652: PUSH
6653: LD_EXP 17
6657: PPUSH
6658: LD_INT 13
6660: PPUSH
6661: CALL_OW 308
6665: OR
6666: IFFALSE 6700
// begin RemoveUnit ( cargo1 ) ;
6668: LD_EXP 15
6672: PPUSH
6673: CALL_OW 64
// RemoveUnit ( driver1 ) ;
6677: LD_EXP 17
6681: PPUSH
6682: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6686: LD_ADDR_EXP 20
6690: PUSH
6691: LD_EXP 20
6695: PUSH
6696: LD_INT 1
6698: PLUS
6699: ST_TO_ADDR
// end ; if IsInArea ( cargo2 , RussianAttack ) or IsInArea ( driver2 , RussianAttack ) then
6700: LD_EXP 16
6704: PPUSH
6705: LD_INT 13
6707: PPUSH
6708: CALL_OW 308
6712: PUSH
6713: LD_EXP 18
6717: PPUSH
6718: LD_INT 13
6720: PPUSH
6721: CALL_OW 308
6725: OR
6726: IFFALSE 6760
// begin RemoveUnit ( cargo2 ) ;
6728: LD_EXP 16
6732: PPUSH
6733: CALL_OW 64
// RemoveUnit ( driver2 ) ;
6737: LD_EXP 18
6741: PPUSH
6742: CALL_OW 64
// cargoEscape = cargoEscape + 1 ;
6746: LD_ADDR_EXP 20
6750: PUSH
6751: LD_EXP 20
6755: PUSH
6756: LD_INT 1
6758: PLUS
6759: ST_TO_ADDR
// end ; end ;
6760: END
// every 0 0$1 trigger cargoEscape > 1 do var speaker ;
6761: LD_EXP 20
6765: PUSH
6766: LD_INT 1
6768: GREATER
6769: IFFALSE 6926
6771: GO 6773
6773: DISABLE
6774: LD_INT 0
6776: PPUSH
// begin SetRestrict ( b_armoury , 1 , true ) ;
6777: LD_INT 4
6779: PPUSH
6780: LD_INT 1
6782: PPUSH
6783: LD_INT 1
6785: PPUSH
6786: CALL_OW 324
// SetRestrict ( 31 , 1 , true ) ;
6790: LD_INT 31
6792: PPUSH
6793: LD_INT 1
6795: PPUSH
6796: LD_INT 1
6798: PPUSH
6799: CALL_OW 324
// if IsOK ( Jerry ) then
6803: LD_EXP 7
6807: PPUSH
6808: CALL_OW 302
6812: IFFALSE 6828
// Say ( Jerry , D5a-Sol1-1 ) else
6814: LD_EXP 7
6818: PPUSH
6819: LD_STRING D5a-Sol1-1
6821: PPUSH
6822: CALL_OW 88
6826: GO 6914
// begin speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Khatam ] ;
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: LD_INT 22
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: LD_INT 26
6845: PUSH
6846: LD_INT 1
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PPUSH
6857: CALL_OW 69
6861: PUSH
6862: LD_EXP 1
6866: PUSH
6867: LD_EXP 2
6871: PUSH
6872: LD_EXP 3
6876: PUSH
6877: LD_EXP 5
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: LIST
6886: LIST
6887: DIFF
6888: ST_TO_ADDR
// if not speaker then
6889: LD_VAR 0 1
6893: NOT
6894: IFFALSE 6898
// exit ;
6896: GO 6926
// Say ( speaker [ 1 ] , D5a-Sol1-1 ) ;
6898: LD_VAR 0 1
6902: PUSH
6903: LD_INT 1
6905: ARRAY
6906: PPUSH
6907: LD_STRING D5a-Sol1-1
6909: PPUSH
6910: CALL_OW 88
// end ; Say ( JMM , D5a-JMM-1 ) ;
6914: LD_EXP 1
6918: PPUSH
6919: LD_STRING D5a-JMM-1
6921: PPUSH
6922: CALL_OW 88
// end ;
6926: PPOPN 1
6928: END
// every 0 0$1 trigger ( GetSide ( dep1 ) = 3 and GetLives ( dep1 ) < 1000 ) or ( GetSide ( dep2 ) = 3 and GetLives ( dep2 ) < 1000 ) do
6929: LD_INT 1
6931: PPUSH
6932: CALL_OW 255
6936: PUSH
6937: LD_INT 3
6939: EQUAL
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: CALL_OW 256
6948: PUSH
6949: LD_INT 1000
6951: LESS
6952: AND
6953: PUSH
6954: LD_INT 10
6956: PPUSH
6957: CALL_OW 255
6961: PUSH
6962: LD_INT 3
6964: EQUAL
6965: PUSH
6966: LD_INT 10
6968: PPUSH
6969: CALL_OW 256
6973: PUSH
6974: LD_INT 1000
6976: LESS
6977: AND
6978: OR
6979: IFFALSE 6996
6981: GO 6983
6983: DISABLE
// begin Say ( JMM , D8-JMM-1 ) ;
6984: LD_EXP 1
6988: PPUSH
6989: LD_STRING D8-JMM-1
6991: PPUSH
6992: CALL_OW 88
// end ;
6996: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) = dep1 and not mikhailInbase = 3 do
6997: LD_EXP 8
7001: PPUSH
7002: CALL_OW 310
7006: PUSH
7007: LD_INT 1
7009: EQUAL
7010: PUSH
7011: LD_EXP 22
7015: PUSH
7016: LD_INT 3
7018: EQUAL
7019: NOT
7020: AND
7021: IFFALSE 7043
7023: GO 7025
7025: DISABLE
// begin mikhailInBase = 1 ;
7026: LD_ADDR_EXP 22
7030: PUSH
7031: LD_INT 1
7033: ST_TO_ADDR
// mikhailStatus = 1 ;
7034: LD_ADDR_EXP 21
7038: PUSH
7039: LD_INT 1
7041: ST_TO_ADDR
// enable ;
7042: ENABLE
// end ;
7043: END
// export function AskMikhail ; begin
7044: LD_INT 0
7046: PPUSH
// case query ( QMikh2 ) of 1 :
7047: LD_STRING QMikh2
7049: PPUSH
7050: CALL_OW 97
7054: PUSH
7055: LD_INT 1
7057: DOUBLE
7058: EQUAL
7059: IFTRUE 7063
7061: GO 7130
7063: POP
// begin SetAttitude ( 1 , 6 , att_enemy , true ) ;
7064: LD_INT 1
7066: PPUSH
7067: LD_INT 6
7069: PPUSH
7070: LD_INT 2
7072: PPUSH
7073: LD_INT 1
7075: PPUSH
7076: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7080: LD_EXP 8
7084: PPUSH
7085: LD_INT 6
7087: PPUSH
7088: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7092: LD_EXP 8
7096: PPUSH
7097: CALL_OW 122
// wait ( 0 0$1 ) ;
7101: LD_INT 35
7103: PPUSH
7104: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7108: LD_EXP 8
7112: PPUSH
7113: LD_INT 17
7115: PPUSH
7116: CALL_OW 113
// mikhailInbase = 0 ;
7120: LD_ADDR_EXP 22
7124: PUSH
7125: LD_INT 0
7127: ST_TO_ADDR
// end ; 2 :
7128: GO 7371
7130: LD_INT 2
7132: DOUBLE
7133: EQUAL
7134: IFTRUE 7138
7136: GO 7311
7138: POP
// begin mikhailInBase = 2 ;
7139: LD_ADDR_EXP 22
7143: PUSH
7144: LD_INT 2
7146: ST_TO_ADDR
// SetSide ( Mikhail , 6 ) ;
7147: LD_EXP 8
7151: PPUSH
7152: LD_INT 6
7154: PPUSH
7155: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7159: LD_EXP 8
7163: PPUSH
7164: CALL_OW 122
// wait ( 0 0$1 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// ComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) + 2 ) ;
7175: LD_EXP 8
7179: PPUSH
7180: LD_EXP 8
7184: PPUSH
7185: CALL_OW 250
7189: PUSH
7190: LD_INT 2
7192: PLUS
7193: PPUSH
7194: LD_EXP 8
7198: PPUSH
7199: CALL_OW 251
7203: PUSH
7204: LD_INT 2
7206: PLUS
7207: PPUSH
7208: CALL_OW 111
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 1 , GetY ( Mikhail ) + 2 ) ;
7212: LD_EXP 8
7216: PPUSH
7217: LD_EXP 8
7221: PPUSH
7222: CALL_OW 250
7226: PUSH
7227: LD_INT 1
7229: PLUS
7230: PPUSH
7231: LD_EXP 8
7235: PPUSH
7236: CALL_OW 251
7240: PUSH
7241: LD_INT 2
7243: PLUS
7244: PPUSH
7245: CALL_OW 171
// AddComMoveXY ( Mikhail , GetX ( Mikhail ) + 2 , GetY ( Mikhail ) ) ;
7249: LD_EXP 8
7253: PPUSH
7254: LD_EXP 8
7258: PPUSH
7259: CALL_OW 250
7263: PUSH
7264: LD_INT 2
7266: PLUS
7267: PPUSH
7268: LD_EXP 8
7272: PPUSH
7273: CALL_OW 251
7277: PPUSH
7278: CALL_OW 171
// wait ( 0 0$5 ) ;
7282: LD_INT 175
7284: PPUSH
7285: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEnter ) ;
7289: LD_EXP 8
7293: PPUSH
7294: LD_INT 25
7296: PPUSH
7297: CALL_OW 113
// mikhailInBase = 4 ;
7301: LD_ADDR_EXP 22
7305: PUSH
7306: LD_INT 4
7308: ST_TO_ADDR
// end ; 3 :
7309: GO 7371
7311: LD_INT 3
7313: DOUBLE
7314: EQUAL
7315: IFTRUE 7319
7317: GO 7370
7319: POP
// begin SetSide ( Mikhail , 6 ) ;
7320: LD_EXP 8
7324: PPUSH
7325: LD_INT 6
7327: PPUSH
7328: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7332: LD_EXP 8
7336: PPUSH
7337: CALL_OW 122
// wait ( 0 0$1 ) ;
7341: LD_INT 35
7343: PPUSH
7344: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7348: LD_EXP 8
7352: PPUSH
7353: LD_INT 17
7355: PPUSH
7356: CALL_OW 113
// mikhailInbase = 3 ;
7360: LD_ADDR_EXP 22
7364: PUSH
7365: LD_INT 3
7367: ST_TO_ADDR
// end ; end ;
7368: GO 7371
7370: POP
// end ;
7371: LD_VAR 0 1
7375: RET
// every 1 trigger IsInArea ( Mikhail , MikhailEnter ) and mikhailInBase = 4 do
7376: LD_EXP 8
7380: PPUSH
7381: LD_INT 25
7383: PPUSH
7384: CALL_OW 308
7388: PUSH
7389: LD_EXP 22
7393: PUSH
7394: LD_INT 4
7396: EQUAL
7397: AND
7398: IFFALSE 7502
7400: GO 7402
7402: DISABLE
// begin enable ;
7403: ENABLE
// mikhailInBase = 1 ;
7404: LD_ADDR_EXP 22
7408: PUSH
7409: LD_INT 1
7411: ST_TO_ADDR
// InGameOn ;
7412: CALL_OW 8
// SetSide ( dep1 , 6 ) ;
7416: LD_INT 1
7418: PPUSH
7419: LD_INT 6
7421: PPUSH
7422: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
7426: LD_INT 35
7428: PPUSH
7429: CALL_OW 67
// if Carry ( Mikhail ) then
7433: LD_EXP 8
7437: PPUSH
7438: CALL_OW 281
7442: IFFALSE 7453
// ComUnload ( Mikhail ) ;
7444: LD_EXP 8
7448: PPUSH
7449: CALL_OW 159
// AddComEnterUnit ( Mikhail , dep1 ) ;
7453: LD_EXP 8
7457: PPUSH
7458: LD_INT 1
7460: PPUSH
7461: CALL_OW 180
// until IsInUnit ( Mikhail ) ;
7465: LD_EXP 8
7469: PPUSH
7470: CALL_OW 310
7474: IFFALSE 7426
// SetSide ( dep1 , 1 ) ;
7476: LD_INT 1
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: CALL_OW 235
// SetSide ( Mikhail , 1 ) ;
7486: LD_EXP 8
7490: PPUSH
7491: LD_INT 1
7493: PPUSH
7494: CALL_OW 235
// InGameOff ;
7498: CALL_OW 9
// end ;
7502: END
// every 0 0$1 trigger IsInUnit ( Mikhail ) and not mikhailInBase = 3 do
7503: LD_EXP 8
7507: PPUSH
7508: CALL_OW 310
7512: PUSH
7513: LD_EXP 22
7517: PUSH
7518: LD_INT 3
7520: EQUAL
7521: NOT
7522: AND
7523: IFFALSE 7658
7525: GO 7527
7527: DISABLE
// begin enable ;
7528: ENABLE
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , IsInUnit ( Mikhail ) , 10 ] ] ) = 1 then
7529: LD_INT 22
7531: PUSH
7532: LD_INT 1
7534: PUSH
7535: EMPTY
7536: LIST
7537: LIST
7538: PUSH
7539: LD_INT 21
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: EMPTY
7546: LIST
7547: LIST
7548: PUSH
7549: LD_INT 91
7551: PUSH
7552: LD_EXP 8
7556: PPUSH
7557: CALL_OW 310
7561: PUSH
7562: LD_INT 10
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: PPUSH
7575: CALL_OW 69
7579: PUSH
7580: LD_INT 1
7582: EQUAL
7583: IFFALSE 7658
// begin mikhailStatus = 4 ;
7585: LD_ADDR_EXP 21
7589: PUSH
7590: LD_INT 4
7592: ST_TO_ADDR
// SetAttitude ( 1 , 6 , att_enemy , true ) ;
7593: LD_INT 1
7595: PPUSH
7596: LD_INT 6
7598: PPUSH
7599: LD_INT 2
7601: PPUSH
7602: LD_INT 1
7604: PPUSH
7605: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
7609: LD_EXP 8
7613: PPUSH
7614: LD_INT 6
7616: PPUSH
7617: CALL_OW 235
// ComExitBuilding ( Mikhail ) ;
7621: LD_EXP 8
7625: PPUSH
7626: CALL_OW 122
// wait ( 0 0$1 ) ;
7630: LD_INT 35
7632: PPUSH
7633: CALL_OW 67
// ComMoveToArea ( Mikhail , MikhailEscape ) ;
7637: LD_EXP 8
7641: PPUSH
7642: LD_INT 17
7644: PPUSH
7645: CALL_OW 113
// mikhailStatus = 3 ;
7649: LD_ADDR_EXP 21
7653: PUSH
7654: LD_INT 3
7656: ST_TO_ADDR
// disable ;
7657: DISABLE
// end ; end ;
7658: END
// every 0 0$1 trigger GetDistUnits ( JMM , mikhailDepot ) < 5 and mikhailStatus = 3 and not mikhailInBase = 3 do var tmp ;
7659: LD_EXP 1
7663: PPUSH
7664: LD_EXP 23
7668: PPUSH
7669: CALL_OW 296
7673: PUSH
7674: LD_INT 5
7676: LESS
7677: PUSH
7678: LD_EXP 21
7682: PUSH
7683: LD_INT 3
7685: EQUAL
7686: AND
7687: PUSH
7688: LD_EXP 22
7692: PUSH
7693: LD_INT 3
7695: EQUAL
7696: NOT
7697: AND
7698: IFFALSE 7920
7700: GO 7702
7702: DISABLE
7703: LD_INT 0
7705: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ JMM , Khatam ] ;
7706: LD_ADDR_VAR 0 1
7710: PUSH
7711: LD_INT 22
7713: PUSH
7714: LD_INT 1
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: LD_INT 21
7723: PUSH
7724: LD_INT 1
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: PUSH
7731: LD_INT 26
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: LIST
7745: PPUSH
7746: CALL_OW 69
7750: PUSH
7751: LD_EXP 1
7755: PUSH
7756: LD_EXP 5
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: DIFF
7765: ST_TO_ADDR
// DialogueOn ;
7766: CALL_OW 6
// Say ( JMM , D7-JMM-1 ) ;
7770: LD_EXP 1
7774: PPUSH
7775: LD_STRING D7-JMM-1
7777: PPUSH
7778: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-1 ) ;
7782: LD_VAR 0 1
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: PPUSH
7791: LD_STRING D7-Sol1-1
7793: PPUSH
7794: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
7798: LD_EXP 1
7802: PPUSH
7803: LD_STRING D7-JMM-2
7805: PPUSH
7806: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-2 ) ;
7810: LD_VAR 0 1
7814: PUSH
7815: LD_INT 1
7817: ARRAY
7818: PPUSH
7819: LD_STRING D7-Sol1-2
7821: PPUSH
7822: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
7826: LD_EXP 1
7830: PPUSH
7831: LD_STRING D7-JMM-3
7833: PPUSH
7834: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-3 ) ;
7838: LD_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PPUSH
7847: LD_STRING D7-Sol1-3
7849: PPUSH
7850: CALL_OW 88
// if IsOK ( Cyrus ) and IsOK ( Lisa ) then
7854: LD_EXP 3
7858: PPUSH
7859: CALL_OW 302
7863: PUSH
7864: LD_EXP 4
7868: PPUSH
7869: CALL_OW 302
7873: AND
7874: IFFALSE 7916
// begin Say ( Cyrus , D7-Cyrus-3 ) ;
7876: LD_EXP 3
7880: PPUSH
7881: LD_STRING D7-Cyrus-3
7883: PPUSH
7884: CALL_OW 88
// Say ( tmp [ 1 ] , D7-Sol1-4 ) ;
7888: LD_VAR 0 1
7892: PUSH
7893: LD_INT 1
7895: ARRAY
7896: PPUSH
7897: LD_STRING D7-Sol1-4
7899: PPUSH
7900: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
7904: LD_EXP 4
7908: PPUSH
7909: LD_STRING D7-Lisa-4
7911: PPUSH
7912: CALL_OW 88
// end ; DialogueOff ;
7916: CALL_OW 7
// end ;
7920: PPOPN 1
7922: END
// every 0 0$1 trigger IsDying ( Mikhail ) and mikhailStatus = 3 do
7923: LD_EXP 8
7927: PPUSH
7928: CALL_OW 303
7932: PUSH
7933: LD_EXP 21
7937: PUSH
7938: LD_INT 3
7940: EQUAL
7941: AND
7942: IFFALSE 7956
7944: GO 7946
7946: DISABLE
// begin enable ;
7947: ENABLE
// mikhailStatus = 2 ;
7948: LD_ADDR_EXP 21
7952: PUSH
7953: LD_INT 2
7955: ST_TO_ADDR
// end ;
7956: END
// every 0 0$1 trigger IsInArea ( Mikhail , MikhailEscape ) and GetSide ( Mikhail ) = 6 do
7957: LD_EXP 8
7961: PPUSH
7962: LD_INT 17
7964: PPUSH
7965: CALL_OW 308
7969: PUSH
7970: LD_EXP 8
7974: PPUSH
7975: CALL_OW 255
7979: PUSH
7980: LD_INT 6
7982: EQUAL
7983: AND
7984: IFFALSE 8017
7986: GO 7988
7988: DISABLE
// begin if not mikhailInBase = 3 then
7989: LD_EXP 22
7993: PUSH
7994: LD_INT 3
7996: EQUAL
7997: NOT
7998: IFFALSE 8008
// mikhailStatus = 3 ;
8000: LD_ADDR_EXP 21
8004: PUSH
8005: LD_INT 3
8007: ST_TO_ADDR
// RemoveUnit ( Mikhail ) ;
8008: LD_EXP 8
8012: PPUSH
8013: CALL_OW 64
// end ;
8017: END
// every 0 0$1 trigger mikhailStatus = 3 and GetSide ( Mikhail ) = 6 do var i , attacker ;
8018: LD_EXP 21
8022: PUSH
8023: LD_INT 3
8025: EQUAL
8026: PUSH
8027: LD_EXP 8
8031: PPUSH
8032: CALL_OW 255
8036: PUSH
8037: LD_INT 6
8039: EQUAL
8040: AND
8041: IFFALSE 8207
8043: GO 8045
8045: DISABLE
8046: LD_INT 0
8048: PPUSH
8049: PPUSH
// begin enable ;
8050: ENABLE
// if IsOk ( Mikhail ) then
8051: LD_EXP 8
8055: PPUSH
8056: CALL_OW 302
8060: IFFALSE 8207
// begin attacker = Nearest ( Mikhail , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ) ;
8062: LD_ADDR_VAR 0 2
8066: PUSH
8067: LD_EXP 8
8071: PPUSH
8072: LD_INT 22
8074: PUSH
8075: LD_INT 1
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: LD_INT 21
8084: PUSH
8085: LD_INT 1
8087: PUSH
8088: EMPTY
8089: LIST
8090: LIST
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PPUSH
8096: CALL_OW 69
8100: PPUSH
8101: CALL 10178 0 2
8105: ST_TO_ADDR
// if GetDistUnits ( attacker , Mikhail ) < 8 then
8106: LD_VAR 0 2
8110: PPUSH
8111: LD_EXP 8
8115: PPUSH
8116: CALL_OW 296
8120: PUSH
8121: LD_INT 8
8123: LESS
8124: IFFALSE 8207
// begin if GetSex ( attacker ) = sex_male then
8126: LD_VAR 0 2
8130: PPUSH
8131: CALL_OW 258
8135: PUSH
8136: LD_INT 1
8138: EQUAL
8139: IFFALSE 8175
// begin disable ;
8141: DISABLE
// Say ( attacker , D7a-Sol1-1 ) ;
8142: LD_VAR 0 2
8146: PPUSH
8147: LD_STRING D7a-Sol1-1
8149: PPUSH
8150: CALL_OW 88
// wait ( 0 0$2 ) ;
8154: LD_INT 70
8156: PPUSH
8157: CALL_OW 67
// Say ( attacker , D7a-Sol1-1a ) ;
8161: LD_VAR 0 2
8165: PPUSH
8166: LD_STRING D7a-Sol1-1a
8168: PPUSH
8169: CALL_OW 88
// end else
8173: GO 8207
// begin disable ;
8175: DISABLE
// Say ( attacker , D7a-FSol1-1 ) ;
8176: LD_VAR 0 2
8180: PPUSH
8181: LD_STRING D7a-FSol1-1
8183: PPUSH
8184: CALL_OW 88
// wait ( 0 0$2 ) ;
8188: LD_INT 70
8190: PPUSH
8191: CALL_OW 67
// Say ( attacker , D7a-FSol1-1a ) ;
8195: LD_VAR 0 2
8199: PPUSH
8200: LD_STRING D7a-FSol1-1a
8202: PPUSH
8203: CALL_OW 88
// end ; end ; end ; end ;
8207: PPOPN 2
8209: END
// every 0 0$1 trigger LastBattle = 1 and FilterUnitsInArea ( NorthBase , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) > 2 and FilterUnitsInArea ( NorthBase , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_occupied ] ] ] ) = 0 do
8210: LD_EXP 27
8214: PUSH
8215: LD_INT 1
8217: EQUAL
8218: PUSH
8219: LD_INT 22
8221: PPUSH
8222: LD_INT 22
8224: PUSH
8225: LD_INT 3
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 21
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: EMPTY
8243: LIST
8244: LIST
8245: PPUSH
8246: CALL_OW 70
8250: PUSH
8251: LD_INT 2
8253: GREATER
8254: AND
8255: PUSH
8256: LD_INT 22
8258: PPUSH
8259: LD_INT 22
8261: PUSH
8262: LD_INT 1
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 2
8271: PUSH
8272: LD_INT 21
8274: PUSH
8275: LD_INT 1
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: PUSH
8282: LD_INT 59
8284: PUSH
8285: EMPTY
8286: LIST
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: LIST
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PPUSH
8297: CALL_OW 70
8301: PUSH
8302: LD_INT 0
8304: EQUAL
8305: AND
8306: IFFALSE 8321
8308: GO 8310
8310: DISABLE
// begin SetSide ( dep1 , 3 ) ;
8311: LD_INT 1
8313: PPUSH
8314: LD_INT 3
8316: PPUSH
8317: CALL_OW 235
// end ;
8321: END
// every 0 0$1 trigger tigersRespawn = 1 and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , 14 ] ] ) = 0 do var i , tmp ;
8322: LD_EXP 30
8326: PUSH
8327: LD_INT 1
8329: EQUAL
8330: PUSH
8331: LD_INT 22
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: EMPTY
8338: LIST
8339: LIST
8340: PUSH
8341: LD_INT 25
8343: PUSH
8344: LD_INT 14
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PPUSH
8355: CALL_OW 69
8359: PUSH
8360: LD_INT 0
8362: EQUAL
8363: AND
8364: IFFALSE 8465
8366: GO 8368
8368: DISABLE
8369: LD_INT 0
8371: PPUSH
8372: PPUSH
// begin tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) ;
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: EMPTY
8385: LIST
8386: LIST
8387: PUSH
8388: LD_INT 21
8390: PUSH
8391: LD_INT 1
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 23
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: PPUSH
8413: CALL_OW 69
8417: ST_TO_ADDR
// for i in tmp do
8418: LD_ADDR_VAR 0 1
8422: PUSH
8423: LD_VAR 0 2
8427: PUSH
8428: FOR_IN
8429: IFFALSE 8456
// AddExperience ( i , rand ( 1 , 4 ) , 300 ) ;
8431: LD_VAR 0 1
8435: PPUSH
8436: LD_INT 1
8438: PPUSH
8439: LD_INT 4
8441: PPUSH
8442: CALL_OW 12
8446: PPUSH
8447: LD_INT 300
8449: PPUSH
8450: CALL_OW 492
8454: GO 8428
8456: POP
8457: POP
// SetAchievement ( ACH_TIGER ) ;
8458: LD_STRING ACH_TIGER
8460: PPUSH
8461: CALL_OW 543
// end ;
8465: PPOPN 2
8467: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] ] ) >= 2 do
8468: LD_INT 22
8470: PUSH
8471: LD_INT 1
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PUSH
8478: LD_INT 34
8480: PUSH
8481: LD_INT 51
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PPUSH
8492: CALL_OW 69
8496: PUSH
8497: LD_INT 2
8499: GREATEREQUAL
8500: IFFALSE 8512
8502: GO 8504
8504: DISABLE
// SetAchievement ( ACH_CARGO ) ; end_of_file
8505: LD_STRING ACH_CARGO
8507: PPUSH
8508: CALL_OW 543
8512: END
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
8513: LD_INT 0
8515: PPUSH
8516: PPUSH
8517: PPUSH
8518: PPUSH
// for i = 1 to count do
8519: LD_ADDR_VAR 0 8
8523: PUSH
8524: DOUBLE
8525: LD_INT 1
8527: DEC
8528: ST_TO_ADDR
8529: LD_VAR 0 6
8533: PUSH
8534: FOR_TO
8535: IFFALSE 8616
// begin uc_side = side ;
8537: LD_ADDR_OWVAR 20
8541: PUSH
8542: LD_VAR 0 1
8546: ST_TO_ADDR
// uc_nation = nation ;
8547: LD_ADDR_OWVAR 21
8551: PUSH
8552: LD_VAR 0 2
8556: ST_TO_ADDR
// hc_gallery =  ;
8557: LD_ADDR_OWVAR 33
8561: PUSH
8562: LD_STRING 
8564: ST_TO_ADDR
// hc_name =  ;
8565: LD_ADDR_OWVAR 26
8569: PUSH
8570: LD_STRING 
8572: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_VAR 0 5
8580: PPUSH
8581: LD_VAR 0 4
8585: PPUSH
8586: CALL_OW 380
// un = CreateHuman ;
8590: LD_ADDR_VAR 0 10
8594: PUSH
8595: CALL_OW 44
8599: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
8600: LD_VAR 0 10
8604: PPUSH
8605: LD_VAR 0 3
8609: PPUSH
8610: CALL_OW 52
// end ;
8614: GO 8534
8616: POP
8617: POP
// end ;
8618: LD_VAR 0 7
8622: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
8623: LD_INT 0
8625: PPUSH
8626: PPUSH
8627: PPUSH
// uc_side := GetSide ( b ) ;
8628: LD_ADDR_OWVAR 20
8632: PUSH
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 255
8642: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_VAR 0 2
8652: PPUSH
8653: CALL_OW 248
8657: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
8658: LD_INT 0
8660: PPUSH
8661: LD_INT 1
8663: PPUSH
8664: LD_VAR 0 1
8668: PPUSH
8669: CALL_OW 380
// un = CreateHuman ;
8673: LD_ADDR_VAR 0 4
8677: PUSH
8678: CALL_OW 44
8682: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 254
8697: PUSH
8698: LD_INT 3
8700: MINUS
8701: ST_TO_ADDR
// if dir < 0 then
8702: LD_VAR 0 5
8706: PUSH
8707: LD_INT 0
8709: LESS
8710: IFFALSE 8726
// dir := 6 + dir ;
8712: LD_ADDR_VAR 0 5
8716: PUSH
8717: LD_INT 6
8719: PUSH
8720: LD_VAR 0 5
8724: PLUS
8725: ST_TO_ADDR
// SetDir ( un , dir ) ;
8726: LD_VAR 0 4
8730: PPUSH
8731: LD_VAR 0 5
8735: PPUSH
8736: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
8740: LD_VAR 0 4
8744: PPUSH
8745: LD_VAR 0 2
8749: PPUSH
8750: CALL_OW 52
// end ;
8754: LD_VAR 0 3
8758: RET
// export function RepairBuilding ( side , building , area ) ; var buildings_list , i , engineerOk_list , j ; begin
8759: LD_INT 0
8761: PPUSH
8762: PPUSH
8763: PPUSH
8764: PPUSH
8765: PPUSH
// engineerOk_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] , [ f_lives , 1000 ] ] ) ;
8766: LD_ADDR_VAR 0 7
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_VAR 0 1
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PUSH
8783: LD_INT 25
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PUSH
8793: LD_INT 24
8795: PUSH
8796: LD_INT 1000
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: LIST
8807: PPUSH
8808: CALL_OW 69
8812: ST_TO_ADDR
// buildings_list = FilterUnitsInArea ( area , [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
8813: LD_ADDR_VAR 0 5
8817: PUSH
8818: LD_VAR 0 3
8822: PPUSH
8823: LD_INT 22
8825: PUSH
8826: LD_VAR 0 1
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PUSH
8835: LD_INT 21
8837: PUSH
8838: LD_INT 3
8840: PUSH
8841: EMPTY
8842: LIST
8843: LIST
8844: PUSH
8845: LD_INT 3
8847: PUSH
8848: LD_INT 24
8850: PUSH
8851: LD_INT 1000
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: PPUSH
8870: CALL_OW 70
8874: ST_TO_ADDR
// if buildings_list > 0 and engineerOk_list > 0 then
8875: LD_VAR 0 5
8879: PUSH
8880: LD_INT 0
8882: GREATER
8883: PUSH
8884: LD_VAR 0 7
8888: PUSH
8889: LD_INT 0
8891: GREATER
8892: AND
8893: IFFALSE 8959
// begin for i in engineerOk_list do
8895: LD_ADDR_VAR 0 6
8899: PUSH
8900: LD_VAR 0 7
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8957
// begin for j in buildings_list do
8908: LD_ADDR_VAR 0 8
8912: PUSH
8913: LD_VAR 0 5
8917: PUSH
8918: FOR_IN
8919: IFFALSE 8953
// begin AddComExitBuilding ( i ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 182
// wait ( 0 0$1 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// AddComRepairBuilding ( i , j ) ;
8937: LD_VAR 0 6
8941: PPUSH
8942: LD_VAR 0 8
8946: PPUSH
8947: CALL_OW 190
// end ;
8951: GO 8918
8953: POP
8954: POP
// end ;
8955: GO 8905
8957: POP
8958: POP
// end ; if buildings_list = 0 then
8959: LD_VAR 0 5
8963: PUSH
8964: LD_INT 0
8966: EQUAL
8967: IFFALSE 9000
// begin for i in engineerOK_list do
8969: LD_ADDR_VAR 0 6
8973: PUSH
8974: LD_VAR 0 7
8978: PUSH
8979: FOR_IN
8980: IFFALSE 8998
// begin ComEnterUnit ( i , building ) ;
8982: LD_VAR 0 6
8986: PPUSH
8987: LD_VAR 0 2
8991: PPUSH
8992: CALL_OW 120
// end ;
8996: GO 8979
8998: POP
8999: POP
// end ; end ;
9000: LD_VAR 0 4
9004: RET
// export function HealUnitInBase ( side , healArea , baseArea , build ) ; var sci_list , i , j , damageUnits ; begin
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
9010: PPUSH
9011: PPUSH
// sci_list = FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] , [ f_lives , 250 ] ] ) ;
9012: LD_ADDR_VAR 0 6
9016: PUSH
9017: LD_INT 22
9019: PUSH
9020: LD_VAR 0 1
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: PUSH
9029: LD_INT 25
9031: PUSH
9032: LD_INT 4
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PUSH
9039: LD_INT 24
9041: PUSH
9042: LD_INT 250
9044: PUSH
9045: EMPTY
9046: LIST
9047: LIST
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: PPUSH
9054: CALL_OW 69
9058: ST_TO_ADDR
// damageUnits = FilterUnitsInArea ( baseArea , [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 650 ] ] ] ) ;
9059: LD_ADDR_VAR 0 9
9063: PUSH
9064: LD_VAR 0 3
9068: PPUSH
9069: LD_INT 22
9071: PUSH
9072: LD_VAR 0 1
9076: PUSH
9077: EMPTY
9078: LIST
9079: LIST
9080: PUSH
9081: LD_INT 21
9083: PUSH
9084: LD_INT 1
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: PUSH
9091: LD_INT 3
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: LD_INT 650
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: LIST
9112: PPUSH
9113: CALL_OW 70
9117: ST_TO_ADDR
// if damageUnits > 0 and sci_list > 0 then
9118: LD_VAR 0 9
9122: PUSH
9123: LD_INT 0
9125: GREATER
9126: PUSH
9127: LD_VAR 0 6
9131: PUSH
9132: LD_INT 0
9134: GREATER
9135: AND
9136: IFFALSE 9263
// begin for i = 1 to damageUnits do
9138: LD_ADDR_VAR 0 7
9142: PUSH
9143: DOUBLE
9144: LD_INT 1
9146: DEC
9147: ST_TO_ADDR
9148: LD_VAR 0 9
9152: PUSH
9153: FOR_TO
9154: IFFALSE 9178
// ComMoveToArea ( damageUnits [ i ] , healArea ) ;
9156: LD_VAR 0 9
9160: PUSH
9161: LD_VAR 0 7
9165: ARRAY
9166: PPUSH
9167: LD_VAR 0 2
9171: PPUSH
9172: CALL_OW 113
9176: GO 9153
9178: POP
9179: POP
// for i in sci_list do
9180: LD_ADDR_VAR 0 7
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: FOR_IN
9191: IFFALSE 9259
// begin ComExitBuilding ( i ) ;
9193: LD_VAR 0 7
9197: PPUSH
9198: CALL_OW 122
// for j in FilterUnitsInArea ( healArea , [ f_side , side ] ) do
9202: LD_ADDR_VAR 0 8
9206: PUSH
9207: LD_VAR 0 2
9211: PPUSH
9212: LD_INT 22
9214: PUSH
9215: LD_VAR 0 1
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: PPUSH
9224: CALL_OW 70
9228: PUSH
9229: FOR_IN
9230: IFFALSE 9255
// begin AddComHeal ( i , j ) ;
9232: LD_VAR 0 7
9236: PPUSH
9237: LD_VAR 0 8
9241: PPUSH
9242: CALL_OW 188
// wait ( 1 1$0 ) ;
9246: LD_INT 2100
9248: PPUSH
9249: CALL_OW 67
// end ;
9253: GO 9229
9255: POP
9256: POP
// end ;
9257: GO 9190
9259: POP
9260: POP
// end else
9261: GO 9277
// begin AddComEnterUnit ( sci_list , build ) ;
9263: LD_VAR 0 6
9267: PPUSH
9268: LD_VAR 0 4
9272: PPUSH
9273: CALL_OW 180
// end ; end ;
9277: LD_VAR 0 5
9281: RET
// export function RepairVehicle ( side , repairArea , area ) ; var i , j , vehicleOK_list , damageVehicle_list , emptyVehicle_list , mechanicInside_list , mechanicOutside_list ; begin
9282: LD_INT 0
9284: PPUSH
9285: PPUSH
9286: PPUSH
9287: PPUSH
9288: PPUSH
9289: PPUSH
9290: PPUSH
9291: PPUSH
// vehicleOK_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_lives , 550 ] , [ f_weapon , 46 ] ] ) ;
9292: LD_ADDR_VAR 0 7
9296: PUSH
9297: LD_VAR 0 3
9301: PPUSH
9302: LD_INT 22
9304: PUSH
9305: LD_VAR 0 1
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 21
9316: PUSH
9317: LD_INT 2
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 24
9326: PUSH
9327: LD_INT 550
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 34
9336: PUSH
9337: LD_INT 46
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 70
9354: ST_TO_ADDR
// damageVehicle_list = FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_not , [ f_lives , 550 ] ] ] ) ;
9355: LD_ADDR_VAR 0 8
9359: PUSH
9360: LD_VAR 0 3
9364: PPUSH
9365: LD_INT 22
9367: PUSH
9368: LD_VAR 0 1
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: LD_INT 34
9389: PUSH
9390: LD_INT 46
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: PUSH
9397: LD_INT 3
9399: PUSH
9400: LD_INT 24
9402: PUSH
9403: LD_INT 550
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 70
9424: ST_TO_ADDR
// emptyVehicle_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_weapon , 46 ] , [ f_lives , 1000 ] , [ f_empty ] ] ) ;
9425: LD_ADDR_VAR 0 9
9429: PUSH
9430: LD_VAR 0 2
9434: PPUSH
9435: LD_INT 22
9437: PUSH
9438: LD_VAR 0 1
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: LD_INT 21
9449: PUSH
9450: LD_INT 2
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: PUSH
9457: LD_INT 34
9459: PUSH
9460: LD_INT 46
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PUSH
9467: LD_INT 24
9469: PUSH
9470: LD_INT 1000
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 58
9479: PUSH
9480: EMPTY
9481: LIST
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: PPUSH
9490: CALL_OW 70
9494: ST_TO_ADDR
// for i in damageVehicle_list do
9495: LD_ADDR_VAR 0 5
9499: PUSH
9500: LD_VAR 0 8
9504: PUSH
9505: FOR_IN
9506: IFFALSE 9525
// mechanicInside_list = UnitsInside ( i ) ;
9508: LD_ADDR_VAR 0 10
9512: PUSH
9513: LD_VAR 0 5
9517: PPUSH
9518: CALL_OW 313
9522: ST_TO_ADDR
9523: GO 9505
9525: POP
9526: POP
// mechanicOutside_list = FilterUnitsInArea ( repairArea , [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
9527: LD_ADDR_VAR 0 11
9531: PUSH
9532: LD_VAR 0 2
9536: PPUSH
9537: LD_INT 22
9539: PUSH
9540: LD_VAR 0 1
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 25
9551: PUSH
9552: LD_INT 3
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PPUSH
9563: CALL_OW 70
9567: ST_TO_ADDR
// if damageVehicle_list > 0 then
9568: LD_VAR 0 8
9572: PUSH
9573: LD_INT 0
9575: GREATER
9576: IFFALSE 9649
// begin for i in damageVehicle_list do
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_VAR 0 8
9587: PUSH
9588: FOR_IN
9589: IFFALSE 9647
// begin for j in mechanicInside_list do
9591: LD_ADDR_VAR 0 6
9595: PUSH
9596: LD_VAR 0 10
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9643
// begin ComMoveToArea ( damageVehicle_list , repairArea ) ;
9604: LD_VAR 0 8
9608: PPUSH
9609: LD_VAR 0 2
9613: PPUSH
9614: CALL_OW 113
// AddComExitVehicle ( j ) ;
9618: LD_VAR 0 6
9622: PPUSH
9623: CALL_OW 181
// AddComRepairVehicle ( j , i ) ;
9627: LD_VAR 0 6
9631: PPUSH
9632: LD_VAR 0 5
9636: PPUSH
9637: CALL_OW 189
// end ;
9641: GO 9601
9643: POP
9644: POP
// end ;
9645: GO 9588
9647: POP
9648: POP
// end ; if emptyVehicle_list > 0 then
9649: LD_VAR 0 9
9653: PUSH
9654: LD_INT 0
9656: GREATER
9657: IFFALSE 9707
// begin for i in emptyVehicle_list do
9659: LD_ADDR_VAR 0 5
9663: PUSH
9664: LD_VAR 0 9
9668: PUSH
9669: FOR_IN
9670: IFFALSE 9705
// begin for j in mechanicOutside_list do
9672: LD_ADDR_VAR 0 6
9676: PUSH
9677: LD_VAR 0 11
9681: PUSH
9682: FOR_IN
9683: IFFALSE 9701
// begin AddComEnterUnit ( j , i ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: CALL_OW 180
// end ;
9699: GO 9682
9701: POP
9702: POP
// end ;
9703: GO 9669
9705: POP
9706: POP
// end ; if VehicleOK_list > 0 then
9707: LD_VAR 0 7
9711: PUSH
9712: LD_INT 0
9714: GREATER
9715: IFFALSE 9749
// begin for i in VehicleOK_list do
9717: LD_ADDR_VAR 0 5
9721: PUSH
9722: LD_VAR 0 7
9726: PUSH
9727: FOR_IN
9728: IFFALSE 9747
// ComAgressiveMove ( i , 110 , 29 ) ;
9730: LD_VAR 0 5
9734: PPUSH
9735: LD_INT 110
9737: PPUSH
9738: LD_INT 29
9740: PPUSH
9741: CALL_OW 114
9745: GO 9727
9747: POP
9748: POP
// end ; end ;
9749: LD_VAR 0 4
9753: RET
// export function DefendBases ( area , enemySide , defendersList , build , count ) ; var i , j ; begin
9754: LD_INT 0
9756: PPUSH
9757: PPUSH
9758: PPUSH
// if FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) > count then
9759: LD_VAR 0 1
9763: PPUSH
9764: LD_INT 22
9766: PUSH
9767: LD_VAR 0 2
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 2
9778: PUSH
9779: LD_INT 21
9781: PUSH
9782: LD_INT 2
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PUSH
9789: LD_INT 21
9791: PUSH
9792: LD_INT 1
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 70
9812: PUSH
9813: LD_VAR 0 5
9817: GREATER
9818: IFFALSE 9950
// begin for i in defendersList do
9820: LD_ADDR_VAR 0 7
9824: PUSH
9825: LD_VAR 0 3
9829: PUSH
9830: FOR_IN
9831: IFFALSE 9946
// begin AddComExitBuilding ( i ) ;
9833: LD_VAR 0 7
9837: PPUSH
9838: CALL_OW 182
// wait ( 0 0$1 ) ;
9842: LD_INT 35
9844: PPUSH
9845: CALL_OW 67
// for j in FilterUnitsInArea ( area , [ [ f_side , enemySide ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) do
9849: LD_ADDR_VAR 0 8
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: LD_INT 22
9861: PUSH
9862: LD_VAR 0 2
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 2
9873: PUSH
9874: LD_INT 21
9876: PUSH
9877: LD_INT 2
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PUSH
9884: LD_INT 21
9886: PUSH
9887: LD_INT 1
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 70
9907: PUSH
9908: FOR_IN
9909: IFFALSE 9942
// AddComAgressiveMove ( i , GetX ( j ) , GetY ( j ) ) ;
9911: LD_VAR 0 7
9915: PPUSH
9916: LD_VAR 0 8
9920: PPUSH
9921: CALL_OW 250
9925: PPUSH
9926: LD_VAR 0 8
9930: PPUSH
9931: CALL_OW 251
9935: PPUSH
9936: CALL_OW 174
9940: GO 9908
9942: POP
9943: POP
// end ;
9944: GO 9830
9946: POP
9947: POP
// end else
9948: GO 9981
// begin for i in defendersList do
9950: LD_ADDR_VAR 0 7
9954: PUSH
9955: LD_VAR 0 3
9959: PUSH
9960: FOR_IN
9961: IFFALSE 9979
// ComEnterUnit ( i , build ) ;
9963: LD_VAR 0 7
9967: PPUSH
9968: LD_VAR 0 4
9972: PPUSH
9973: CALL_OW 120
9977: GO 9960
9979: POP
9980: POP
// end ; end ;
9981: LD_VAR 0 6
9985: RET
// export function RussianTrap ; var i ; begin
9986: LD_INT 0
9988: PPUSH
9989: PPUSH
// if GetSide ( Brian ) = 4 then
9990: LD_EXP 6
9994: PPUSH
9995: CALL_OW 255
9999: PUSH
10000: LD_INT 4
10002: EQUAL
10003: IFFALSE 10026
// SetLives ( [ Brian , Jerry ] , 0 ) ;
10005: LD_EXP 6
10009: PUSH
10010: LD_EXP 7
10014: PUSH
10015: EMPTY
10016: LIST
10017: LIST
10018: PPUSH
10019: LD_INT 0
10021: PPUSH
10022: CALL_OW 234
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) do
10026: LD_ADDR_VAR 0 2
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: EMPTY
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 21
10043: PUSH
10044: LD_INT 1
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: PPUSH
10055: CALL_OW 69
10059: PUSH
10060: FOR_IN
10061: IFFALSE 10171
// begin ComExitBuilding ( i ) ;
10063: LD_VAR 0 2
10067: PPUSH
10068: CALL_OW 122
// wait ( 0 0$1 ) ;
10072: LD_INT 35
10074: PPUSH
10075: CALL_OW 67
// AddComAgressiveMove ( i , 120 , 56 ) ;
10079: LD_VAR 0 2
10083: PPUSH
10084: LD_INT 120
10086: PPUSH
10087: LD_INT 56
10089: PPUSH
10090: CALL_OW 174
// AddComAgressiveMove ( i , 111 , 37 ) ;
10094: LD_VAR 0 2
10098: PPUSH
10099: LD_INT 111
10101: PPUSH
10102: LD_INT 37
10104: PPUSH
10105: CALL_OW 174
// if GetSide ( arm2 ) = 3 and IsOk ( arm2 ) then
10109: LD_INT 33
10111: PPUSH
10112: CALL_OW 255
10116: PUSH
10117: LD_INT 3
10119: EQUAL
10120: PUSH
10121: LD_INT 33
10123: PPUSH
10124: CALL_OW 302
10128: AND
10129: IFFALSE 10145
// begin AddComEnterUnit ( i , arm2 ) ;
10131: LD_VAR 0 2
10135: PPUSH
10136: LD_INT 33
10138: PPUSH
10139: CALL_OW 180
// end else
10143: GO 10169
// begin AddComCrawl ( i ) ;
10145: LD_VAR 0 2
10149: PPUSH
10150: CALL_OW 197
// AddComAgressiveMove ( i , 109 , 30 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 109
10161: PPUSH
10162: LD_INT 30
10164: PPUSH
10165: CALL_OW 174
// end ; end ;
10169: GO 10060
10171: POP
10172: POP
// end ;
10173: LD_VAR 0 1
10177: RET
// export function Nearest ( un , units ) ; var nearest_dist , nearest_un , sold , dist ; begin
10178: LD_INT 0
10180: PPUSH
10181: PPUSH
10182: PPUSH
10183: PPUSH
10184: PPUSH
// nearest_dist = 1000 ;
10185: LD_ADDR_VAR 0 4
10189: PUSH
10190: LD_INT 1000
10192: ST_TO_ADDR
// nearest_un = un ;
10193: LD_ADDR_VAR 0 5
10197: PUSH
10198: LD_VAR 0 1
10202: ST_TO_ADDR
// for sold in units do
10203: LD_ADDR_VAR 0 6
10207: PUSH
10208: LD_VAR 0 2
10212: PUSH
10213: FOR_IN
10214: IFFALSE 10270
// begin dist = GetDistUnits ( un , sold ) ;
10216: LD_ADDR_VAR 0 7
10220: PUSH
10221: LD_VAR 0 1
10225: PPUSH
10226: LD_VAR 0 6
10230: PPUSH
10231: CALL_OW 296
10235: ST_TO_ADDR
// if dist < nearest_dist then
10236: LD_VAR 0 7
10240: PUSH
10241: LD_VAR 0 4
10245: LESS
10246: IFFALSE 10268
// begin nearest_un = sold ;
10248: LD_ADDR_VAR 0 5
10252: PUSH
10253: LD_VAR 0 6
10257: ST_TO_ADDR
// nearest_dist = dist ;
10258: LD_ADDR_VAR 0 4
10262: PUSH
10263: LD_VAR 0 7
10267: ST_TO_ADDR
// end ; end ;
10268: GO 10213
10270: POP
10271: POP
// result := nearest_un ;
10272: LD_ADDR_VAR 0 3
10276: PUSH
10277: LD_VAR 0 5
10281: ST_TO_ADDR
// end ;
10282: LD_VAR 0 3
10286: RET
// export function PrepareDifficulty ; begin
10287: LD_INT 0
10289: PPUSH
// if Difficulty = 1 then
10290: LD_OWVAR 67
10294: PUSH
10295: LD_INT 1
10297: EQUAL
10298: IFFALSE 10361
// begin RemoveUnit ( brw2 ) ;
10300: LD_INT 9
10302: PPUSH
10303: CALL_OW 64
// RemoveUnit ( brw3 ) ;
10307: LD_INT 30
10309: PPUSH
10310: CALL_OW 64
// RemoveUnit ( brw4 ) ;
10314: LD_INT 52
10316: PPUSH
10317: CALL_OW 64
// RemoveUnit ( brw5 ) ;
10321: LD_INT 63
10323: PPUSH
10324: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 60 ) ;
10328: LD_INT 5
10330: PUSH
10331: LD_INT 4
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: PPUSH
10338: LD_INT 60
10340: PPUSH
10341: CALL_OW 240
// RuSoldMinLevel = 0 ;
10345: LD_ADDR_EXP 13
10349: PUSH
10350: LD_INT 0
10352: ST_TO_ADDR
// RuSoldMaxLevel = 1 ;
10353: LD_ADDR_EXP 14
10357: PUSH
10358: LD_INT 1
10360: ST_TO_ADDR
// end ; if Difficulty = 2 then
10361: LD_OWVAR 67
10365: PUSH
10366: LD_INT 2
10368: EQUAL
10369: IFFALSE 10411
// begin RemoveUnit ( brw4 ) ;
10371: LD_INT 52
10373: PPUSH
10374: CALL_OW 64
// SetFuel ( [ vehicle1 , vehicle2 ] , 50 ) ;
10378: LD_INT 5
10380: PUSH
10381: LD_INT 4
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: PPUSH
10388: LD_INT 50
10390: PPUSH
10391: CALL_OW 240
// RuSoldMinLevel = 1 ;
10395: LD_ADDR_EXP 13
10399: PUSH
10400: LD_INT 1
10402: ST_TO_ADDR
// RuSoldMaxLevel = 2 ;
10403: LD_ADDR_EXP 14
10407: PUSH
10408: LD_INT 2
10410: ST_TO_ADDR
// end ; if Difficulty = 3 then
10411: LD_OWVAR 67
10415: PUSH
10416: LD_INT 3
10418: EQUAL
10419: IFFALSE 10454
// begin SetFuel ( [ vehicle1 , vehicle2 ] , 40 ) ;
10421: LD_INT 5
10423: PUSH
10424: LD_INT 4
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: PPUSH
10431: LD_INT 40
10433: PPUSH
10434: CALL_OW 240
// RuSoldMinLevel = 2 ;
10438: LD_ADDR_EXP 13
10442: PUSH
10443: LD_INT 2
10445: ST_TO_ADDR
// RuSoldMaxLevel = 3 ;
10446: LD_ADDR_EXP 14
10450: PUSH
10451: LD_INT 3
10453: ST_TO_ADDR
// end ; end ;
10454: LD_VAR 0 1
10458: RET
// export function SaveVehicles ( vehicles , ident ) ; var i , tmp ; begin
10459: LD_INT 0
10461: PPUSH
10462: PPUSH
10463: PPUSH
// tmp = [ ] ;
10464: LD_ADDR_VAR 0 5
10468: PUSH
10469: EMPTY
10470: ST_TO_ADDR
// if not vehicles then
10471: LD_VAR 0 1
10475: NOT
10476: IFFALSE 10480
// exit ;
10478: GO 10597
// for i in vehicles do
10480: LD_ADDR_VAR 0 4
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: FOR_IN
10491: IFFALSE 10581
// begin tmp := Insert ( tmp , 1 , [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) , GetFuel ( i ) , GetLives ( i ) ] ) ;
10493: LD_ADDR_VAR 0 5
10497: PUSH
10498: LD_VAR 0 5
10502: PPUSH
10503: LD_INT 1
10505: PPUSH
10506: LD_VAR 0 4
10510: PPUSH
10511: CALL_OW 265
10515: PUSH
10516: LD_VAR 0 4
10520: PPUSH
10521: CALL_OW 262
10525: PUSH
10526: LD_VAR 0 4
10530: PPUSH
10531: CALL_OW 263
10535: PUSH
10536: LD_VAR 0 4
10540: PPUSH
10541: CALL_OW 264
10545: PUSH
10546: LD_VAR 0 4
10550: PPUSH
10551: CALL_OW 261
10555: PUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL_OW 256
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PPUSH
10574: CALL_OW 2
10578: ST_TO_ADDR
// end ;
10579: GO 10490
10581: POP
10582: POP
// SaveVariable ( tmp , ident ) ;
10583: LD_VAR 0 5
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 39
// end ; end_of_file
10597: LD_VAR 0 3
10601: RET
// export function PrepareHeroes ; var plive ; begin
10602: LD_INT 0
10604: PPUSH
10605: PPUSH
// uc_side = 1 ;
10606: LD_ADDR_OWVAR 20
10610: PUSH
10611: LD_INT 1
10613: ST_TO_ADDR
// JMM = CreateCharacter ( 01_JMM ) ;
10614: LD_ADDR_EXP 1
10618: PUSH
10619: LD_STRING 01_JMM
10621: PPUSH
10622: CALL_OW 34
10626: ST_TO_ADDR
// plive := LoadVariable ( 01_JMMLifePoints_1 , 1000 ) ;
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_STRING 01_JMMLifePoints_1
10634: PPUSH
10635: LD_INT 1000
10637: PPUSH
10638: CALL_OW 30
10642: ST_TO_ADDR
// if plive < 250 then
10643: LD_VAR 0 2
10647: PUSH
10648: LD_INT 250
10650: LESS
10651: IFFALSE 10661
// plive := 300 ;
10653: LD_ADDR_VAR 0 2
10657: PUSH
10658: LD_INT 300
10660: ST_TO_ADDR
// SetLives ( JMM , plive ) ;
10661: LD_EXP 1
10665: PPUSH
10666: LD_VAR 0 2
10670: PPUSH
10671: CALL_OW 234
// Powell = NewCharacter ( Powell ) ;
10675: LD_ADDR_EXP 9
10679: PUSH
10680: LD_STRING Powell
10682: PPUSH
10683: CALL_OW 25
10687: ST_TO_ADDR
// Bobby = CreateCharacter ( 01_Bobby ) ;
10688: LD_ADDR_EXP 2
10692: PUSH
10693: LD_STRING 01_Bobby
10695: PPUSH
10696: CALL_OW 34
10700: ST_TO_ADDR
// if Bobby then
10701: LD_EXP 2
10705: IFFALSE 10755
// begin plive := LoadVariable ( 01_BobbyLifePoints_1 , 1000 ) ;
10707: LD_ADDR_VAR 0 2
10711: PUSH
10712: LD_STRING 01_BobbyLifePoints_1
10714: PPUSH
10715: LD_INT 1000
10717: PPUSH
10718: CALL_OW 30
10722: ST_TO_ADDR
// if plive < 250 then
10723: LD_VAR 0 2
10727: PUSH
10728: LD_INT 250
10730: LESS
10731: IFFALSE 10741
// plive := 300 ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 300
10740: ST_TO_ADDR
// SetLives ( Bobby , plive ) ;
10741: LD_EXP 2
10745: PPUSH
10746: LD_VAR 0 2
10750: PPUSH
10751: CALL_OW 234
// end ; Cyrus = CreateCharacter ( 01_Cyrus ) ;
10755: LD_ADDR_EXP 3
10759: PUSH
10760: LD_STRING 01_Cyrus
10762: PPUSH
10763: CALL_OW 34
10767: ST_TO_ADDR
// if Cyrus then
10768: LD_EXP 3
10772: IFFALSE 10822
// begin plive := LoadVariable ( 01_CyrusLifePoints_1 , 1000 ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_STRING 01_CyrusLifePoints_1
10781: PPUSH
10782: LD_INT 1000
10784: PPUSH
10785: CALL_OW 30
10789: ST_TO_ADDR
// if plive < 250 then
10790: LD_VAR 0 2
10794: PUSH
10795: LD_INT 250
10797: LESS
10798: IFFALSE 10808
// plive := 300 ;
10800: LD_ADDR_VAR 0 2
10804: PUSH
10805: LD_INT 300
10807: ST_TO_ADDR
// SetLives ( Cyrus , plive ) ;
10808: LD_EXP 3
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 234
// end ; Khatam = NewCharacter ( Khatam ) ;
10822: LD_ADDR_EXP 5
10826: PUSH
10827: LD_STRING Khatam
10829: PPUSH
10830: CALL_OW 25
10834: ST_TO_ADDR
// uc_side = 4 ;
10835: LD_ADDR_OWVAR 20
10839: PUSH
10840: LD_INT 4
10842: ST_TO_ADDR
// Lisa = NewCharacter ( Lisa ) ;
10843: LD_ADDR_EXP 4
10847: PUSH
10848: LD_STRING Lisa
10850: PPUSH
10851: CALL_OW 25
10855: ST_TO_ADDR
// PlaceUnitArea ( JMM , StartArea , false ) ;
10856: LD_EXP 1
10860: PPUSH
10861: LD_INT 3
10863: PPUSH
10864: LD_INT 0
10866: PPUSH
10867: CALL_OW 49
// PlaceUnitArea ( Bobby , StartArea , false ) ;
10871: LD_EXP 2
10875: PPUSH
10876: LD_INT 3
10878: PPUSH
10879: LD_INT 0
10881: PPUSH
10882: CALL_OW 49
// PlaceUnitArea ( Cyrus , StartArea , false ) ;
10886: LD_EXP 3
10890: PPUSH
10891: LD_INT 3
10893: PPUSH
10894: LD_INT 0
10896: PPUSH
10897: CALL_OW 49
// PlaceUnitArea ( Lisa , LisaSpawn , false ) ;
10901: LD_EXP 4
10905: PPUSH
10906: LD_INT 5
10908: PPUSH
10909: LD_INT 0
10911: PPUSH
10912: CALL_OW 49
// ComCrawl ( Lisa ) ;
10916: LD_EXP 4
10920: PPUSH
10921: CALL_OW 137
// end ;
10925: LD_VAR 0 1
10929: RET
// export function PrepareLisSquad ; var i , un ; begin
10930: LD_INT 0
10932: PPUSH
10933: PPUSH
10934: PPUSH
// uc_side = 4 ;
10935: LD_ADDR_OWVAR 20
10939: PUSH
10940: LD_INT 4
10942: ST_TO_ADDR
// uc_nation = 1 ;
10943: LD_ADDR_OWVAR 21
10947: PUSH
10948: LD_INT 1
10950: ST_TO_ADDR
// hc_class := 2 ;
10951: LD_ADDR_OWVAR 28
10955: PUSH
10956: LD_INT 2
10958: ST_TO_ADDR
// hc_sex := sex_male ;
10959: LD_ADDR_OWVAR 27
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// hc_gallery :=  ;
10967: LD_ADDR_OWVAR 33
10971: PUSH
10972: LD_STRING 
10974: ST_TO_ADDR
// hc_name :=  ;
10975: LD_ADDR_OWVAR 26
10979: PUSH
10980: LD_STRING 
10982: ST_TO_ADDR
// hc_basic_skills := [ 0 , 1 , 0 , 0 ] ;
10983: LD_ADDR_OWVAR 30
10987: PUSH
10988: LD_INT 0
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: LD_INT 0
10996: PUSH
10997: LD_INT 0
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: ST_TO_ADDR
// hc_skills := [ 1 , 2 , 0 , 0 ] ;
11006: LD_ADDR_OWVAR 31
11010: PUSH
11011: LD_INT 1
11013: PUSH
11014: LD_INT 2
11016: PUSH
11017: LD_INT 0
11019: PUSH
11020: LD_INT 0
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: ST_TO_ADDR
// un := CreateHuman ;
11029: LD_ADDR_VAR 0 3
11033: PUSH
11034: CALL_OW 44
11038: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11039: LD_VAR 0 3
11043: PPUSH
11044: LD_INT 6
11046: PPUSH
11047: LD_INT 0
11049: PPUSH
11050: CALL_OW 49
// hc_sex := sex_female ;
11054: LD_ADDR_OWVAR 27
11058: PUSH
11059: LD_INT 2
11061: ST_TO_ADDR
// hc_gallery :=  ;
11062: LD_ADDR_OWVAR 33
11066: PUSH
11067: LD_STRING 
11069: ST_TO_ADDR
// hc_name :=  ;
11070: LD_ADDR_OWVAR 26
11074: PUSH
11075: LD_STRING 
11077: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 1 ] ;
11078: LD_ADDR_OWVAR 30
11082: PUSH
11083: LD_INT 0
11085: PUSH
11086: LD_INT 0
11088: PUSH
11089: LD_INT 0
11091: PUSH
11092: LD_INT 1
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: ST_TO_ADDR
// hc_skills := [ 0 , 1 , 0 , 1 ] ;
11101: LD_ADDR_OWVAR 31
11105: PUSH
11106: LD_INT 0
11108: PUSH
11109: LD_INT 1
11111: PUSH
11112: LD_INT 0
11114: PUSH
11115: LD_INT 1
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: LIST
11122: LIST
11123: ST_TO_ADDR
// un := CreateHuman ;
11124: LD_ADDR_VAR 0 3
11128: PUSH
11129: CALL_OW 44
11133: ST_TO_ADDR
// PlaceUnitArea ( un , LisaEngs , false ) ;
11134: LD_VAR 0 3
11138: PPUSH
11139: LD_INT 6
11141: PPUSH
11142: LD_INT 0
11144: PPUSH
11145: CALL_OW 49
// if not Bobby and not Cyrus then
11149: LD_EXP 2
11153: NOT
11154: PUSH
11155: LD_EXP 3
11159: NOT
11160: AND
11161: IFFALSE 11266
// begin hc_class := 1 ;
11163: LD_ADDR_OWVAR 28
11167: PUSH
11168: LD_INT 1
11170: ST_TO_ADDR
// hc_sex := sex_male ;
11171: LD_ADDR_OWVAR 27
11175: PUSH
11176: LD_INT 1
11178: ST_TO_ADDR
// hc_gallery :=  ;
11179: LD_ADDR_OWVAR 33
11183: PUSH
11184: LD_STRING 
11186: ST_TO_ADDR
// hc_name :=  ;
11187: LD_ADDR_OWVAR 26
11191: PUSH
11192: LD_STRING 
11194: ST_TO_ADDR
// hc_basic_skills := [ 2 , 3 , 1 , 0 ] ;
11195: LD_ADDR_OWVAR 30
11199: PUSH
11200: LD_INT 2
11202: PUSH
11203: LD_INT 3
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: LD_INT 0
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: ST_TO_ADDR
// hc_skills := [ 2 , 3 , 1 , 0 ] ;
11218: LD_ADDR_OWVAR 31
11222: PUSH
11223: LD_INT 2
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 1
11231: PUSH
11232: LD_INT 0
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: ST_TO_ADDR
// un := CreateHuman ;
11241: LD_ADDR_VAR 0 3
11245: PUSH
11246: CALL_OW 44
11250: ST_TO_ADDR
// PlaceUnitArea ( un , AmNewSpawn , false ) ;
11251: LD_VAR 0 3
11255: PPUSH
11256: LD_INT 31
11258: PPUSH
11259: LD_INT 0
11261: PPUSH
11262: CALL_OW 49
// end ; InitHc ;
11266: CALL_OW 19
// end ;
11270: LD_VAR 0 1
11274: RET
// export function PrepareOtherAmericans ; begin
11275: LD_INT 0
11277: PPUSH
// uc_side = 4 ;
11278: LD_ADDR_OWVAR 20
11282: PUSH
11283: LD_INT 4
11285: ST_TO_ADDR
// uc_nation = 1 ;
11286: LD_ADDR_OWVAR 21
11290: PUSH
11291: LD_INT 1
11293: ST_TO_ADDR
// hc_gallery =  ;
11294: LD_ADDR_OWVAR 33
11298: PUSH
11299: LD_STRING 
11301: ST_TO_ADDR
// hc_name = Tom Garvin ;
11302: LD_ADDR_OWVAR 26
11306: PUSH
11307: LD_STRING Tom Garvin
11309: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( 1 , 2 ) ) ;
11310: LD_INT 1
11312: PPUSH
11313: LD_INT 1
11315: PPUSH
11316: LD_INT 1
11318: PPUSH
11319: LD_INT 2
11321: PPUSH
11322: CALL_OW 12
11326: PPUSH
11327: CALL_OW 380
// Brian = CreateHuman ;
11331: LD_ADDR_EXP 6
11335: PUSH
11336: CALL_OW 44
11340: ST_TO_ADDR
// PlaceUnitArea ( Brian , OtherAmericanSpawn , false ) ;
11341: LD_EXP 6
11345: PPUSH
11346: LD_INT 10
11348: PPUSH
11349: LD_INT 0
11351: PPUSH
11352: CALL_OW 49
// hc_name = Jerry White ;
11356: LD_ADDR_OWVAR 26
11360: PUSH
11361: LD_STRING Jerry White
11363: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
11364: LD_INT 1
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 1
11372: PPUSH
11373: LD_INT 2
11375: PPUSH
11376: CALL_OW 12
11380: PPUSH
11381: CALL_OW 380
// Jerry = CreateHuman ;
11385: LD_ADDR_EXP 7
11389: PUSH
11390: CALL_OW 44
11394: ST_TO_ADDR
// PlaceUnitArea ( Jerry , OtherAmericanSpawn , false ) ;
11395: LD_EXP 7
11399: PPUSH
11400: LD_INT 10
11402: PPUSH
11403: LD_INT 0
11405: PPUSH
11406: CALL_OW 49
// ComHold ( [ Brian , Jerry ] ) ;
11410: LD_EXP 6
11414: PUSH
11415: LD_EXP 7
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PPUSH
11424: CALL_OW 140
// end ;
11428: LD_VAR 0 1
11432: RET
// export DyingSold ; export function PrepareDeadSoldiers ; var i , un ; begin
11433: LD_INT 0
11435: PPUSH
11436: PPUSH
11437: PPUSH
// for i = 1 to 6 do
11438: LD_ADDR_VAR 0 2
11442: PUSH
11443: DOUBLE
11444: LD_INT 1
11446: DEC
11447: ST_TO_ADDR
11448: LD_INT 6
11450: PUSH
11451: FOR_TO
11452: IFFALSE 11546
// begin uc_side = 4 ;
11454: LD_ADDR_OWVAR 20
11458: PUSH
11459: LD_INT 4
11461: ST_TO_ADDR
// uc_nation = 1 ;
11462: LD_ADDR_OWVAR 21
11466: PUSH
11467: LD_INT 1
11469: ST_TO_ADDR
// hc_gallery =  ;
11470: LD_ADDR_OWVAR 33
11474: PUSH
11475: LD_STRING 
11477: ST_TO_ADDR
// hc_name =  ;
11478: LD_ADDR_OWVAR 26
11482: PUSH
11483: LD_STRING 
11485: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 1 ) ;
11486: LD_INT 0
11488: PPUSH
11489: LD_INT 1
11491: PPUSH
11492: LD_INT 4
11494: PPUSH
11495: CALL_OW 12
11499: PPUSH
11500: LD_INT 1
11502: PPUSH
11503: CALL_OW 380
// un = CreateHuman ;
11507: LD_ADDR_VAR 0 3
11511: PUSH
11512: CALL_OW 44
11516: ST_TO_ADDR
// PlaceUnitArea ( un , DeadsSpawn , false ) ;
11517: LD_VAR 0 3
11521: PPUSH
11522: LD_INT 16
11524: PPUSH
11525: LD_INT 0
11527: PPUSH
11528: CALL_OW 49
// SetLives ( un , 1 ) ;
11532: LD_VAR 0 3
11536: PPUSH
11537: LD_INT 1
11539: PPUSH
11540: CALL_OW 234
// end ;
11544: GO 11451
11546: POP
11547: POP
// DyingSold = CreateHuman ;
11548: LD_ADDR_EXP 34
11552: PUSH
11553: CALL_OW 44
11557: ST_TO_ADDR
// PlaceUnitArea ( DyingSold , DeadsSpawn , false ) ;
11558: LD_EXP 34
11562: PPUSH
11563: LD_INT 16
11565: PPUSH
11566: LD_INT 0
11568: PPUSH
11569: CALL_OW 49
// SetLives ( DyingSold , 250 ) ;
11573: LD_EXP 34
11577: PPUSH
11578: LD_INT 250
11580: PPUSH
11581: CALL_OW 234
// end ; end_of_file
11585: LD_VAR 0 1
11589: RET
// export function PrepareRussianHeroes ; var tmp ; begin
11590: LD_INT 0
11592: PPUSH
11593: PPUSH
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_class , 2 ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM ] ;
11594: LD_ADDR_VAR 0 2
11598: PUSH
11599: LD_INT 22
11601: PUSH
11602: LD_INT 1
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 23
11611: PUSH
11612: LD_INT 1
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 25
11621: PUSH
11622: LD_INT 2
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 50
11631: PUSH
11632: EMPTY
11633: LIST
11634: PUSH
11635: LD_INT 56
11637: PUSH
11638: EMPTY
11639: LIST
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: PPUSH
11648: CALL_OW 69
11652: PUSH
11653: LD_EXP 1
11657: PUSH
11658: EMPTY
11659: LIST
11660: DIFF
11661: ST_TO_ADDR
// uc_side = 6 ;
11662: LD_ADDR_OWVAR 20
11666: PUSH
11667: LD_INT 6
11669: ST_TO_ADDR
// Mikhail = NewCharacter ( Mikhail ) ;
11670: LD_ADDR_EXP 8
11674: PUSH
11675: LD_STRING Mikhail
11677: PPUSH
11678: CALL_OW 25
11682: ST_TO_ADDR
// SetClass ( Mikhail , 3 ) ;
11683: LD_EXP 8
11687: PPUSH
11688: LD_INT 3
11690: PPUSH
11691: CALL_OW 336
// PlaceUnitXYR ( Mikhail , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 5 , true ) ;
11695: LD_EXP 8
11699: PPUSH
11700: LD_VAR 0 2
11704: PUSH
11705: LD_INT 1
11707: ARRAY
11708: PPUSH
11709: CALL_OW 250
11713: PPUSH
11714: LD_VAR 0 2
11718: PUSH
11719: LD_INT 1
11721: ARRAY
11722: PPUSH
11723: CALL_OW 251
11727: PPUSH
11728: LD_INT 5
11730: PPUSH
11731: LD_INT 1
11733: PPUSH
11734: CALL_OW 50
// end ;
11738: LD_VAR 0 1
11742: RET
// export function PrepareRussianCommander ; begin
11743: LD_INT 0
11745: PPUSH
// uc_side = 3 ;
11746: LD_ADDR_OWVAR 20
11750: PUSH
11751: LD_INT 3
11753: ST_TO_ADDR
// uc_nation = 3 ;
11754: LD_ADDR_OWVAR 21
11758: PUSH
11759: LD_INT 3
11761: ST_TO_ADDR
// Natasza = NewCharacter ( Natasza ) ;
11762: LD_ADDR_EXP 19
11766: PUSH
11767: LD_STRING Natasza
11769: PPUSH
11770: CALL_OW 25
11774: ST_TO_ADDR
// PlaceUnitArea ( Natasza , NataszaSpawn , false ) ;
11775: LD_EXP 19
11779: PPUSH
11780: LD_INT 24
11782: PPUSH
11783: LD_INT 0
11785: PPUSH
11786: CALL_OW 49
// ComTurnXY ( Natasza , 56 , 16 ) ;
11790: LD_EXP 19
11794: PPUSH
11795: LD_INT 56
11797: PPUSH
11798: LD_INT 16
11800: PPUSH
11801: CALL_OW 118
// northBaseDefenders = northBaseDefenders ^ Natasza ;
11805: LD_ADDR_EXP 24
11809: PUSH
11810: LD_EXP 24
11814: PUSH
11815: LD_EXP 19
11819: ADD
11820: ST_TO_ADDR
// end ;
11821: LD_VAR 0 1
11825: RET
// export function PrepareSouthBase ; var i , un ; begin
11826: LD_INT 0
11828: PPUSH
11829: PPUSH
11830: PPUSH
// for i = 1 to 2 do
11831: LD_ADDR_VAR 0 2
11835: PUSH
11836: DOUBLE
11837: LD_INT 1
11839: DEC
11840: ST_TO_ADDR
11841: LD_INT 2
11843: PUSH
11844: FOR_TO
11845: IFFALSE 11954
// begin uc_side = 3 ;
11847: LD_ADDR_OWVAR 20
11851: PUSH
11852: LD_INT 3
11854: ST_TO_ADDR
// uc_nation = 3 ;
11855: LD_ADDR_OWVAR 21
11859: PUSH
11860: LD_INT 3
11862: ST_TO_ADDR
// hc_gallery =  ;
11863: LD_ADDR_OWVAR 33
11867: PUSH
11868: LD_STRING 
11870: ST_TO_ADDR
// hc_name =  ;
11871: LD_ADDR_OWVAR 26
11875: PUSH
11876: LD_STRING 
11878: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
11879: LD_INT 1
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: LD_EXP 13
11889: PPUSH
11890: LD_EXP 14
11894: PPUSH
11895: CALL_OW 12
11899: PPUSH
11900: CALL_OW 380
// hc_importance = 0 ;
11904: LD_ADDR_OWVAR 32
11908: PUSH
11909: LD_INT 0
11911: ST_TO_ADDR
// un = CreateHuman ;
11912: LD_ADDR_VAR 0 3
11916: PUSH
11917: CALL_OW 44
11921: ST_TO_ADDR
// PlaceUnitArea ( un , SouthBaseRussianSpawn1 , false ) ;
11922: LD_VAR 0 3
11926: PPUSH
11927: LD_INT 11
11929: PPUSH
11930: LD_INT 0
11932: PPUSH
11933: CALL_OW 49
// ComTurnXY ( un , 111 , 38 ) ;
11937: LD_VAR 0 3
11941: PPUSH
11942: LD_INT 111
11944: PPUSH
11945: LD_INT 38
11947: PPUSH
11948: CALL_OW 118
// end ;
11952: GO 11844
11954: POP
11955: POP
// for i = 1 to Difficulty do
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: DOUBLE
11962: LD_INT 1
11964: DEC
11965: ST_TO_ADDR
11966: LD_OWVAR 67
11970: PUSH
11971: FOR_TO
11972: IFFALSE 12055
// begin uc_side = 3 ;
11974: LD_ADDR_OWVAR 20
11978: PUSH
11979: LD_INT 3
11981: ST_TO_ADDR
// uc_nation = 3 ;
11982: LD_ADDR_OWVAR 21
11986: PUSH
11987: LD_INT 3
11989: ST_TO_ADDR
// hc_gallery =  ;
11990: LD_ADDR_OWVAR 33
11994: PUSH
11995: LD_STRING 
11997: ST_TO_ADDR
// hc_name =  ;
11998: LD_ADDR_OWVAR 26
12002: PUSH
12003: LD_STRING 
12005: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12006: LD_INT 0
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_EXP 13
12016: PPUSH
12017: LD_EXP 14
12021: PPUSH
12022: CALL_OW 12
12026: PPUSH
12027: CALL_OW 380
// un = CreateHuman ;
12031: LD_ADDR_VAR 0 3
12035: PUSH
12036: CALL_OW 44
12040: ST_TO_ADDR
// PlaceHumanInUnit ( un , dep2 ) ;
12041: LD_VAR 0 3
12045: PPUSH
12046: LD_INT 10
12048: PPUSH
12049: CALL_OW 52
// end ;
12053: GO 11971
12055: POP
12056: POP
// RespawnInside ( 3 , 3 , arm2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ 1 , rand ( 1 , 2 ) , rand ( 1 , 2 ) ] [ Difficulty ] ) ;
12057: LD_INT 3
12059: PPUSH
12060: LD_INT 3
12062: PPUSH
12063: LD_INT 33
12065: PPUSH
12066: LD_EXP 13
12070: PPUSH
12071: LD_EXP 14
12075: PPUSH
12076: CALL_OW 12
12080: PPUSH
12081: LD_INT 1
12083: PPUSH
12084: LD_INT 1
12086: PUSH
12087: LD_INT 1
12089: PPUSH
12090: LD_INT 2
12092: PPUSH
12093: CALL_OW 12
12097: PUSH
12098: LD_INT 1
12100: PPUSH
12101: LD_INT 2
12103: PPUSH
12104: CALL_OW 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: LIST
12113: PUSH
12114: LD_OWVAR 67
12118: ARRAY
12119: PPUSH
12120: CALL 8513 0 6
// for i in UnitsInside ( arm2 ) do
12124: LD_ADDR_VAR 0 2
12128: PUSH
12129: LD_INT 33
12131: PPUSH
12132: CALL_OW 313
12136: PUSH
12137: FOR_IN
12138: IFFALSE 12158
// southBaseDefenders = southBaseDefenders ^ i ;
12140: LD_ADDR_EXP 25
12144: PUSH
12145: LD_EXP 25
12149: PUSH
12150: LD_VAR 0 2
12154: ADD
12155: ST_TO_ADDR
12156: GO 12137
12158: POP
12159: POP
// end ;
12160: LD_VAR 0 1
12164: RET
// export function PrepareNorthBase ; var i , un ; begin
12165: LD_INT 0
12167: PPUSH
12168: PPUSH
12169: PPUSH
// for i = 1 to [ rand ( 1 , 2 ) , rand ( 2 , 3 ) , rand ( 3 , 4 ) ] [ Difficulty ] do
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_INT 1
12182: PPUSH
12183: LD_INT 2
12185: PPUSH
12186: CALL_OW 12
12190: PUSH
12191: LD_INT 2
12193: PPUSH
12194: LD_INT 3
12196: PPUSH
12197: CALL_OW 12
12201: PUSH
12202: LD_INT 3
12204: PPUSH
12205: LD_INT 4
12207: PPUSH
12208: CALL_OW 12
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: LIST
12217: PUSH
12218: LD_OWVAR 67
12222: ARRAY
12223: PUSH
12224: FOR_TO
12225: IFFALSE 12311
// begin uc_side = 3 ;
12227: LD_ADDR_OWVAR 20
12231: PUSH
12232: LD_INT 3
12234: ST_TO_ADDR
// uc_nation = 3 ;
12235: LD_ADDR_OWVAR 21
12239: PUSH
12240: LD_INT 3
12242: ST_TO_ADDR
// hc_gallery =  ;
12243: LD_ADDR_OWVAR 33
12247: PUSH
12248: LD_STRING 
12250: ST_TO_ADDR
// hc_name =  ;
12251: LD_ADDR_OWVAR 26
12255: PUSH
12256: LD_STRING 
12258: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12259: LD_INT 0
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: LD_EXP 13
12269: PPUSH
12270: LD_EXP 14
12274: PPUSH
12275: CALL_OW 12
12279: PPUSH
12280: CALL_OW 380
// un = CreateHuman ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: CALL_OW 44
12293: ST_TO_ADDR
// PlaceUnitArea ( un , NorthBaseRussianSpawn1 , false ) ;
12294: LD_VAR 0 3
12298: PPUSH
12299: LD_INT 14
12301: PPUSH
12302: LD_INT 0
12304: PPUSH
12305: CALL_OW 49
// end ;
12309: GO 12224
12311: POP
12312: POP
// RespawnInside ( 3 , 3 , arm1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 1 , [ Rand ( 1 , 2 ) , Rand ( 1 , 3 ) , Rand ( 1 , 3 ) ] [ Difficulty ] ) ;
12313: LD_INT 3
12315: PPUSH
12316: LD_INT 3
12318: PPUSH
12319: LD_INT 2
12321: PPUSH
12322: LD_EXP 13
12326: PPUSH
12327: LD_EXP 14
12331: PPUSH
12332: CALL_OW 12
12336: PPUSH
12337: LD_INT 1
12339: PPUSH
12340: LD_INT 1
12342: PPUSH
12343: LD_INT 2
12345: PPUSH
12346: CALL_OW 12
12350: PUSH
12351: LD_INT 1
12353: PPUSH
12354: LD_INT 3
12356: PPUSH
12357: CALL_OW 12
12361: PUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 3
12367: PPUSH
12368: CALL_OW 12
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: LIST
12377: PUSH
12378: LD_OWVAR 67
12382: ARRAY
12383: PPUSH
12384: CALL 8513 0 6
// RespawnInside ( 3 , 3 , lab1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 4 , [ 0 , 1 , 2 ] [ Difficulty ] ) ;
12388: LD_INT 3
12390: PPUSH
12391: LD_INT 3
12393: PPUSH
12394: LD_INT 23
12396: PPUSH
12397: LD_EXP 13
12401: PPUSH
12402: LD_EXP 14
12406: PPUSH
12407: CALL_OW 12
12411: PPUSH
12412: LD_INT 4
12414: PPUSH
12415: LD_INT 0
12417: PUSH
12418: LD_INT 1
12420: PUSH
12421: LD_INT 2
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: LIST
12428: PUSH
12429: LD_OWVAR 67
12433: ARRAY
12434: PPUSH
12435: CALL 8513 0 6
// RespawnInside ( 3 , 3 , dep1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
12439: LD_INT 3
12441: PPUSH
12442: LD_INT 3
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: LD_EXP 13
12452: PPUSH
12453: LD_EXP 14
12457: PPUSH
12458: CALL_OW 12
12462: PPUSH
12463: LD_INT 2
12465: PPUSH
12466: LD_INT 1
12468: PUSH
12469: LD_INT 2
12471: PUSH
12472: LD_INT 2
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: LIST
12479: PUSH
12480: LD_OWVAR 67
12484: ARRAY
12485: PPUSH
12486: CALL 8513 0 6
// for i in UnitsInside ( arm1 ) do
12490: LD_ADDR_VAR 0 2
12494: PUSH
12495: LD_INT 2
12497: PPUSH
12498: CALL_OW 313
12502: PUSH
12503: FOR_IN
12504: IFFALSE 12524
// northBaseDefenders = northBaseDefenders ^ i ;
12506: LD_ADDR_EXP 24
12510: PUSH
12511: LD_EXP 24
12515: PUSH
12516: LD_VAR 0 2
12520: ADD
12521: ST_TO_ADDR
12522: GO 12503
12524: POP
12525: POP
// end ;
12526: LD_VAR 0 1
12530: RET
// export function PrepareOtherRussians ; var i , un ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// for i = 1 to 2 do
12536: LD_ADDR_VAR 0 2
12540: PUSH
12541: DOUBLE
12542: LD_INT 1
12544: DEC
12545: ST_TO_ADDR
12546: LD_INT 2
12548: PUSH
12549: FOR_TO
12550: IFFALSE 12651
// begin uc_side = 3 ;
12552: LD_ADDR_OWVAR 20
12556: PUSH
12557: LD_INT 3
12559: ST_TO_ADDR
// uc_nation = 3 ;
12560: LD_ADDR_OWVAR 21
12564: PUSH
12565: LD_INT 3
12567: ST_TO_ADDR
// hc_gallery =  ;
12568: LD_ADDR_OWVAR 33
12572: PUSH
12573: LD_STRING 
12575: ST_TO_ADDR
// hc_name =  ;
12576: LD_ADDR_OWVAR 26
12580: PUSH
12581: LD_STRING 
12583: ST_TO_ADDR
// PrepareHuman ( false , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
12584: LD_INT 0
12586: PPUSH
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 13
12594: PPUSH
12595: LD_EXP 14
12599: PPUSH
12600: CALL_OW 12
12604: PPUSH
12605: CALL_OW 380
// un = CreateHuman ;
12609: LD_ADDR_VAR 0 3
12613: PUSH
12614: CALL_OW 44
12618: ST_TO_ADDR
// PlaceUnitArea ( un , RussiansWaterSpawn , false ) ;
12619: LD_VAR 0 3
12623: PPUSH
12624: LD_INT 9
12626: PPUSH
12627: LD_INT 0
12629: PPUSH
12630: CALL_OW 49
// ComTurnXY ( un , 80 , 73 ) ;
12634: LD_VAR 0 3
12638: PPUSH
12639: LD_INT 80
12641: PPUSH
12642: LD_INT 73
12644: PPUSH
12645: CALL_OW 118
// end ;
12649: GO 12549
12651: POP
12652: POP
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , 31 ] ] ) do
12653: LD_ADDR_VAR 0 2
12657: PUSH
12658: LD_INT 22
12660: PUSH
12661: LD_INT 3
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 30
12670: PUSH
12671: LD_INT 31
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: EMPTY
12679: LIST
12680: LIST
12681: PPUSH
12682: CALL_OW 69
12686: PUSH
12687: FOR_IN
12688: IFFALSE 12716
// PrepareSolBun ( rand ( RuSoldMinLevel , RuSoldMaxLevel ) , i ) ;
12690: LD_EXP 13
12694: PPUSH
12695: LD_EXP 14
12699: PPUSH
12700: CALL_OW 12
12704: PPUSH
12705: LD_VAR 0 2
12709: PPUSH
12710: CALL 8623 0 2
12714: GO 12687
12716: POP
12717: POP
// end ;
12718: LD_VAR 0 1
12722: RET
// export function PrepareCargoBays ; begin
12723: LD_INT 0
12725: PPUSH
// uc_side = 3 ;
12726: LD_ADDR_OWVAR 20
12730: PUSH
12731: LD_INT 3
12733: ST_TO_ADDR
// uc_nation = 3 ;
12734: LD_ADDR_OWVAR 21
12738: PUSH
12739: LD_INT 3
12741: ST_TO_ADDR
// vc_engine = 1 ;
12742: LD_ADDR_OWVAR 39
12746: PUSH
12747: LD_INT 1
12749: ST_TO_ADDR
// vc_control = 1 ;
12750: LD_ADDR_OWVAR 38
12754: PUSH
12755: LD_INT 1
12757: ST_TO_ADDR
// vc_weapon = 51 ;
12758: LD_ADDR_OWVAR 40
12762: PUSH
12763: LD_INT 51
12765: ST_TO_ADDR
// vc_chassis = 22 ;
12766: LD_ADDR_OWVAR 37
12770: PUSH
12771: LD_INT 22
12773: ST_TO_ADDR
// cargo1 = CreateVehicle ;
12774: LD_ADDR_EXP 15
12778: PUSH
12779: CALL_OW 45
12783: ST_TO_ADDR
// cargo2 = CreateVehicle ;
12784: LD_ADDR_EXP 16
12788: PUSH
12789: CALL_OW 45
12793: ST_TO_ADDR
// PlaceUnitArea ( cargo1 , RussianAttack , false ) ;
12794: LD_EXP 15
12798: PPUSH
12799: LD_INT 13
12801: PPUSH
12802: LD_INT 0
12804: PPUSH
12805: CALL_OW 49
// PlaceUnitArea ( cargo2 , RussianAttack , false ) ;
12809: LD_EXP 16
12813: PPUSH
12814: LD_INT 13
12816: PPUSH
12817: LD_INT 0
12819: PPUSH
12820: CALL_OW 49
// AddCargo ( cargo1 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12824: LD_EXP 15
12828: PPUSH
12829: LD_INT 2
12831: PPUSH
12832: LD_INT 70
12834: PUSH
12835: LD_INT 50
12837: PUSH
12838: LD_INT 30
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: LIST
12845: PUSH
12846: LD_OWVAR 67
12850: ARRAY
12851: PPUSH
12852: CALL_OW 291
// AddCargo ( cargo2 , 2 , [ 70 , 50 , 30 ] [ Difficulty ] ) ;
12856: LD_EXP 16
12860: PPUSH
12861: LD_INT 2
12863: PPUSH
12864: LD_INT 70
12866: PUSH
12867: LD_INT 50
12869: PUSH
12870: LD_INT 30
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: LIST
12877: PUSH
12878: LD_OWVAR 67
12882: ARRAY
12883: PPUSH
12884: CALL_OW 291
// hc_gallery =  ;
12888: LD_ADDR_OWVAR 33
12892: PUSH
12893: LD_STRING 
12895: ST_TO_ADDR
// hc_name =  ;
12896: LD_ADDR_OWVAR 26
12900: PUSH
12901: LD_STRING 
12903: ST_TO_ADDR
// PrepareHuman ( 1 , 3 , rand ( 1 , 2 ) ) ;
12904: LD_INT 1
12906: PPUSH
12907: LD_INT 3
12909: PPUSH
12910: LD_INT 1
12912: PPUSH
12913: LD_INT 2
12915: PPUSH
12916: CALL_OW 12
12920: PPUSH
12921: CALL_OW 380
// driver1 = CreateHuman ;
12925: LD_ADDR_EXP 17
12929: PUSH
12930: CALL_OW 44
12934: ST_TO_ADDR
// PlaceHumanInUnit ( driver1 , cargo1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_EXP 15
12944: PPUSH
12945: CALL_OW 52
// hc_name = Nikolai Andreyev ;
12949: LD_ADDR_OWVAR 26
12953: PUSH
12954: LD_STRING Nikolai Andreyev
12956: ST_TO_ADDR
// driver2 = CreateHuman ;
12957: LD_ADDR_EXP 18
12961: PUSH
12962: CALL_OW 44
12966: ST_TO_ADDR
// PlaceHumanInUnit ( driver2 , cargo2 ) ;
12967: LD_EXP 18
12971: PPUSH
12972: LD_EXP 16
12976: PPUSH
12977: CALL_OW 52
// end ;
12981: LD_VAR 0 1
12985: RET
// export function PrepareRussianAttack ( count , area ) ; var i , veh , un , tmp , target1 , target2 ; begin
12986: LD_INT 0
12988: PPUSH
12989: PPUSH
12990: PPUSH
12991: PPUSH
12992: PPUSH
12993: PPUSH
12994: PPUSH
// uc_side = 3 ;
12995: LD_ADDR_OWVAR 20
12999: PUSH
13000: LD_INT 3
13002: ST_TO_ADDR
// uc_nation = 3 ;
13003: LD_ADDR_OWVAR 21
13007: PUSH
13008: LD_INT 3
13010: ST_TO_ADDR
// for i := 1 to count + rand ( 1 , 3 ) do
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: DOUBLE
13017: LD_INT 1
13019: DEC
13020: ST_TO_ADDR
13021: LD_VAR 0 1
13025: PUSH
13026: LD_INT 1
13028: PPUSH
13029: LD_INT 3
13031: PPUSH
13032: CALL_OW 12
13036: PLUS
13037: PUSH
13038: FOR_TO
13039: IFFALSE 13216
// begin vc_engine = 1 ;
13041: LD_ADDR_OWVAR 39
13045: PUSH
13046: LD_INT 1
13048: ST_TO_ADDR
// vc_control = 1 ;
13049: LD_ADDR_OWVAR 38
13053: PUSH
13054: LD_INT 1
13056: ST_TO_ADDR
// vc_weapon = 42 ;
13057: LD_ADDR_OWVAR 40
13061: PUSH
13062: LD_INT 42
13064: ST_TO_ADDR
// vc_chassis = [ 21 , 22 , 22 ] [ Difficulty ] ;
13065: LD_ADDR_OWVAR 37
13069: PUSH
13070: LD_INT 21
13072: PUSH
13073: LD_INT 22
13075: PUSH
13076: LD_INT 22
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: LIST
13083: PUSH
13084: LD_OWVAR 67
13088: ARRAY
13089: ST_TO_ADDR
// veh = CreateVehicle ;
13090: LD_ADDR_VAR 0 5
13094: PUSH
13095: CALL_OW 45
13099: ST_TO_ADDR
// PlaceUnitArea ( veh , area , false ) ;
13100: LD_VAR 0 5
13104: PPUSH
13105: LD_VAR 0 2
13109: PPUSH
13110: LD_INT 0
13112: PPUSH
13113: CALL_OW 49
// attackGroup = attackGroup ^ veh ;
13117: LD_ADDR_EXP 26
13121: PUSH
13122: LD_EXP 26
13126: PUSH
13127: LD_VAR 0 5
13131: ADD
13132: ST_TO_ADDR
// hc_gallery =  ;
13133: LD_ADDR_OWVAR 33
13137: PUSH
13138: LD_STRING 
13140: ST_TO_ADDR
// hc_name =  ;
13141: LD_ADDR_OWVAR 26
13145: PUSH
13146: LD_STRING 
13148: ST_TO_ADDR
// PrepareHuman ( false , 3 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13149: LD_INT 0
13151: PPUSH
13152: LD_INT 3
13154: PPUSH
13155: LD_EXP 13
13159: PPUSH
13160: LD_EXP 14
13164: PPUSH
13165: CALL_OW 12
13169: PPUSH
13170: CALL_OW 380
// un = CreateHuman ;
13174: LD_ADDR_VAR 0 6
13178: PUSH
13179: CALL_OW 44
13183: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
13184: LD_VAR 0 6
13188: PPUSH
13189: LD_VAR 0 5
13193: PPUSH
13194: CALL_OW 52
// attackGroup = attackGroup ^ un ;
13198: LD_ADDR_EXP 26
13202: PUSH
13203: LD_EXP 26
13207: PUSH
13208: LD_VAR 0 6
13212: ADD
13213: ST_TO_ADDR
// end ;
13214: GO 13038
13216: POP
13217: POP
// PrepareHuman ( false , 2 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13218: LD_INT 0
13220: PPUSH
13221: LD_INT 2
13223: PPUSH
13224: LD_EXP 13
13228: PPUSH
13229: LD_EXP 14
13233: PPUSH
13234: CALL_OW 12
13238: PPUSH
13239: CALL_OW 380
// un = CreateHuman ;
13243: LD_ADDR_VAR 0 6
13247: PUSH
13248: CALL_OW 44
13252: ST_TO_ADDR
// for i := 1 to count + 2 * 2 do
13253: LD_ADDR_VAR 0 4
13257: PUSH
13258: DOUBLE
13259: LD_INT 1
13261: DEC
13262: ST_TO_ADDR
13263: LD_VAR 0 1
13267: PUSH
13268: LD_INT 2
13270: PUSH
13271: LD_INT 2
13273: MUL
13274: PLUS
13275: PUSH
13276: FOR_TO
13277: IFFALSE 13365
// begin hc_gallery =  ;
13279: LD_ADDR_OWVAR 33
13283: PUSH
13284: LD_STRING 
13286: ST_TO_ADDR
// hc_name =  ;
13287: LD_ADDR_OWVAR 26
13291: PUSH
13292: LD_STRING 
13294: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , rand ( RuSoldMinLevel , RuSoldMaxLevel ) ) ;
13295: LD_INT 1
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: LD_EXP 13
13305: PPUSH
13306: LD_EXP 14
13310: PPUSH
13311: CALL_OW 12
13315: PPUSH
13316: CALL_OW 380
// un = CreateHuman ;
13320: LD_ADDR_VAR 0 6
13324: PUSH
13325: CALL_OW 44
13329: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
13330: LD_VAR 0 6
13334: PPUSH
13335: LD_VAR 0 2
13339: PPUSH
13340: LD_INT 0
13342: PPUSH
13343: CALL_OW 49
// attackGroup = attackGroup ^ un ;
13347: LD_ADDR_EXP 26
13351: PUSH
13352: LD_EXP 26
13356: PUSH
13357: LD_VAR 0 6
13361: ADD
13362: ST_TO_ADDR
// end ;
13363: GO 13276
13365: POP
13366: POP
// tmp = FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) ;
13367: LD_ADDR_VAR 0 7
13371: PUSH
13372: LD_INT 26
13374: PPUSH
13375: LD_INT 22
13377: PUSH
13378: LD_INT 3
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: LD_INT 21
13387: PUSH
13388: LD_INT 1
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PUSH
13395: LD_INT 26
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: LIST
13409: PPUSH
13410: CALL_OW 70
13414: ST_TO_ADDR
// Say ( tmp [ 1 ] , D9-Rus3-1 ) ;
13415: LD_VAR 0 7
13419: PUSH
13420: LD_INT 1
13422: ARRAY
13423: PPUSH
13424: LD_STRING D9-Rus3-1
13426: PPUSH
13427: CALL_OW 88
// Say ( tmp [ 2 ] , D9-Russ-1 ) ;
13431: LD_VAR 0 7
13435: PUSH
13436: LD_INT 2
13438: ARRAY
13439: PPUSH
13440: LD_STRING D9-Russ-1
13442: PPUSH
13443: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13447: LD_INT 35
13449: PPUSH
13450: CALL_OW 67
// for i in FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] ] ) do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: LD_INT 26
13461: PPUSH
13462: LD_INT 22
13464: PUSH
13465: LD_INT 3
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: EMPTY
13473: LIST
13474: PPUSH
13475: CALL_OW 70
13479: PUSH
13480: FOR_IN
13481: IFFALSE 13653
// begin target1 := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ;
13483: LD_ADDR_VAR 0 8
13487: PUSH
13488: LD_INT 22
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PPUSH
13498: CALL_OW 69
13502: PPUSH
13503: LD_VAR 0 4
13507: PPUSH
13508: CALL_OW 74
13512: ST_TO_ADDR
// target2 := NearestUnitToUnit ( FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_or , [ f_occupied ] , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ] ) , i ) ;
13513: LD_ADDR_VAR 0 9
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 1
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 2
13530: PUSH
13531: LD_INT 59
13533: PUSH
13534: EMPTY
13535: LIST
13536: PUSH
13537: LD_INT 21
13539: PUSH
13540: LD_INT 1
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 21
13549: PUSH
13550: LD_INT 2
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: EMPTY
13568: LIST
13569: PPUSH
13570: CALL_OW 69
13574: PPUSH
13575: LD_VAR 0 4
13579: PPUSH
13580: CALL_OW 74
13584: ST_TO_ADDR
// if GetDistUnits ( i , target1 ) + 8 < GetDistUnits ( i , target2 ) then
13585: LD_VAR 0 4
13589: PPUSH
13590: LD_VAR 0 8
13594: PPUSH
13595: CALL_OW 296
13599: PUSH
13600: LD_INT 8
13602: PLUS
13603: PUSH
13604: LD_VAR 0 4
13608: PPUSH
13609: LD_VAR 0 9
13613: PPUSH
13614: CALL_OW 296
13618: LESS
13619: IFFALSE 13637
// begin ComAttackUnit ( i , target1 ) ;
13621: LD_VAR 0 4
13625: PPUSH
13626: LD_VAR 0 8
13630: PPUSH
13631: CALL_OW 115
// end else
13635: GO 13651
// begin ComAttackUnit ( i , target2 ) ;
13637: LD_VAR 0 4
13641: PPUSH
13642: LD_VAR 0 9
13646: PPUSH
13647: CALL_OW 115
// end ; end ;
13651: GO 13480
13653: POP
13654: POP
// until FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_occupied ] ] ] ) = 0 ;
13655: LD_INT 26
13657: PPUSH
13658: LD_INT 22
13660: PUSH
13661: LD_INT 3
13663: PUSH
13664: EMPTY
13665: LIST
13666: LIST
13667: PUSH
13668: LD_INT 2
13670: PUSH
13671: LD_INT 21
13673: PUSH
13674: LD_INT 1
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 2
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: LD_INT 59
13693: PUSH
13694: EMPTY
13695: LIST
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 70
13711: PUSH
13712: LD_INT 0
13714: EQUAL
13715: IFFALSE 13447
// end ; end_of_file
13717: LD_VAR 0 3
13721: RET
// every 0 0$1 do
13722: GO 13724
13724: DISABLE
// begin enable ;
13725: ENABLE
// RepairBuilding ( 3 , dep1 , NorthBase ) ;
13726: LD_INT 3
13728: PPUSH
13729: LD_INT 1
13731: PPUSH
13732: LD_INT 22
13734: PPUSH
13735: CALL 8759 0 3
// HealUnitInBase ( 3 , NorthBaseHealArea , NorthBase , lab1 ) ;
13739: LD_INT 3
13741: PPUSH
13742: LD_INT 20
13744: PPUSH
13745: LD_INT 22
13747: PPUSH
13748: LD_INT 23
13750: PPUSH
13751: CALL 9005 0 4
// RepairVehicle ( 3 , SouthBaseRepairArea , SouthBase ) ;
13755: LD_INT 3
13757: PPUSH
13758: LD_INT 21
13760: PPUSH
13761: LD_INT 23
13763: PPUSH
13764: CALL 9282 0 3
// DefendBases ( NorthBase , 1 , northBaseDefenders , arm1 , 3 ) ;
13768: LD_INT 22
13770: PPUSH
13771: LD_INT 1
13773: PPUSH
13774: LD_EXP 24
13778: PPUSH
13779: LD_INT 2
13781: PPUSH
13782: LD_INT 3
13784: PPUSH
13785: CALL 9754 0 5
// DefendBases ( SouthBase , 1 , southBaseDefenders , arm2 , 1 ) ;
13789: LD_INT 23
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_EXP 25
13799: PPUSH
13800: LD_INT 33
13802: PPUSH
13803: LD_INT 1
13805: PPUSH
13806: CALL 9754 0 5
// end ; end_of_file
13810: END
// on UnitDestroyed ( unit ) do begin if GetBType ( unit ) = b_depot then
13811: LD_VAR 0 1
13815: PPUSH
13816: CALL_OW 266
13820: PUSH
13821: LD_INT 0
13823: EQUAL
13824: IFFALSE 13833
// YouLost ( DepotDestroyed ) ;
13826: LD_STRING DepotDestroyed
13828: PPUSH
13829: CALL_OW 104
// if GetSide ( unit ) = 1 and GetType ( unit ) = unit_human then
13833: LD_VAR 0 1
13837: PPUSH
13838: CALL_OW 255
13842: PUSH
13843: LD_INT 1
13845: EQUAL
13846: PUSH
13847: LD_VAR 0 1
13851: PPUSH
13852: CALL_OW 247
13856: PUSH
13857: LD_INT 1
13859: EQUAL
13860: AND
13861: IFFALSE 13877
// deadsCounter = deadsCounter + 1 ;
13863: LD_ADDR_EXP 31
13867: PUSH
13868: LD_EXP 31
13872: PUSH
13873: LD_INT 1
13875: PLUS
13876: ST_TO_ADDR
// end ;
13877: PPOPN 1
13879: END
// on Command ( comandid ) do var i , j , tmp ;
13880: LD_INT 0
13882: PPUSH
13883: PPUSH
13884: PPUSH
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 22
13892: PUSH
13893: LD_INT 1
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: LD_INT 21
13902: PUSH
13903: LD_INT 2
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PPUSH
13914: CALL_OW 69
13918: PUSH
13919: FOR_IN
13920: IFFALSE 14045
// begin if GetTaskList ( i ) > 0 then
13922: LD_VAR 0 2
13926: PPUSH
13927: CALL_OW 437
13931: PUSH
13932: LD_INT 0
13934: GREATER
13935: IFFALSE 14043
// begin for j = 1 to GetTaskList ( i ) do
13937: LD_ADDR_VAR 0 3
13941: PUSH
13942: DOUBLE
13943: LD_INT 1
13945: DEC
13946: ST_TO_ADDR
13947: LD_VAR 0 2
13951: PPUSH
13952: CALL_OW 437
13956: PUSH
13957: FOR_TO
13958: IFFALSE 14041
// begin tmp = GetTaskList ( i ) [ j ] [ 4 ] ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: LD_VAR 0 2
13969: PPUSH
13970: CALL_OW 437
13974: PUSH
13975: LD_VAR 0 3
13979: ARRAY
13980: PUSH
13981: LD_INT 4
13983: ARRAY
13984: ST_TO_ADDR
// if ( GetSide ( tmp ) = 3 and GetType ( tmp ) = unit_vehicle and GetWeapon ( tmp ) = ru_cargo_bay ) then
13985: LD_VAR 0 4
13989: PPUSH
13990: CALL_OW 255
13994: PUSH
13995: LD_INT 3
13997: EQUAL
13998: PUSH
13999: LD_VAR 0 4
14003: PPUSH
14004: CALL_OW 247
14008: PUSH
14009: LD_INT 2
14011: EQUAL
14012: AND
14013: PUSH
14014: LD_VAR 0 4
14018: PPUSH
14019: CALL_OW 264
14023: PUSH
14024: LD_INT 51
14026: EQUAL
14027: AND
14028: IFFALSE 14039
// ComStop ( i ) ;
14030: LD_VAR 0 2
14034: PPUSH
14035: CALL_OW 141
// end ;
14039: GO 13957
14041: POP
14042: POP
// end ; end ;
14043: GO 13919
14045: POP
14046: POP
// end ;
14047: PPOPN 4
14049: END
// on LeaveBuilding ( b , un ) do begin if un = Mikhail and mikhailStatus <> 4 then
14050: LD_VAR 0 2
14054: PUSH
14055: LD_EXP 8
14059: EQUAL
14060: PUSH
14061: LD_EXP 21
14065: PUSH
14066: LD_INT 4
14068: NONEQUAL
14069: AND
14070: IFFALSE 14222
// begin if IsOk ( Mikhail ) then
14072: LD_EXP 8
14076: PPUSH
14077: CALL_OW 302
14081: IFFALSE 14089
// AskMikhail else
14083: CALL 7044 0 0
14087: GO 14222
// if IsOk ( lab1 ) then
14089: LD_INT 23
14091: PPUSH
14092: CALL_OW 302
14096: IFFALSE 14185
// begin InGameOn ;
14098: CALL_OW 8
// SetSide ( Mikhail , 6 ) ;
14102: LD_EXP 8
14106: PPUSH
14107: LD_INT 6
14109: PPUSH
14110: CALL_OW 235
// SetSide ( lab1 , 6 ) ;
14114: LD_INT 23
14116: PPUSH
14117: LD_INT 6
14119: PPUSH
14120: CALL_OW 235
// ComEnterUnit ( Mikhail , lab1 ) ;
14124: LD_EXP 8
14128: PPUSH
14129: LD_INT 23
14131: PPUSH
14132: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
14136: LD_INT 35
14138: PPUSH
14139: CALL_OW 67
// until IsInUnit ( Mikhail ) = lab1 or IsDead ( Mikhail ) ;
14143: LD_EXP 8
14147: PPUSH
14148: CALL_OW 310
14152: PUSH
14153: LD_INT 23
14155: EQUAL
14156: PUSH
14157: LD_EXP 8
14161: PPUSH
14162: CALL_OW 301
14166: OR
14167: IFFALSE 14136
// SetSide ( lab1 , 1 ) ;
14169: LD_INT 23
14171: PPUSH
14172: LD_INT 1
14174: PPUSH
14175: CALL_OW 235
// InGameOff ;
14179: CALL_OW 9
// end else
14183: GO 14222
// begin SetAttitude ( 3 , 6 , att_enemy , true ) ;
14185: LD_INT 3
14187: PPUSH
14188: LD_INT 6
14190: PPUSH
14191: LD_INT 2
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 80
// SetSide ( Mikhail , 6 ) ;
14201: LD_EXP 8
14205: PPUSH
14206: LD_INT 6
14208: PPUSH
14209: CALL_OW 235
// ComHold ( Mikhail ) ;
14213: LD_EXP 8
14217: PPUSH
14218: CALL_OW 140
// end ; end ; end ;
14222: PPOPN 2
14224: END
// every 3 trigger GetClass ( Mikhail ) <> 3 do
14225: LD_EXP 8
14229: PPUSH
14230: CALL_OW 257
14234: PUSH
14235: LD_INT 3
14237: NONEQUAL
14238: IFFALSE 14256
14240: GO 14242
14242: DISABLE
// begin enable ;
14243: ENABLE
// SetClass ( Mikhail , 3 ) ;
14244: LD_EXP 8
14248: PPUSH
14249: LD_INT 3
14251: PPUSH
14252: CALL_OW 336
// end ; end_of_file
14256: END
// every 0 0$1 trigger IsDead ( JMM ) do
14257: LD_EXP 1
14261: PPUSH
14262: CALL_OW 301
14266: IFFALSE 14278
14268: GO 14270
14270: DISABLE
// YouLost ( JMM ) ;
14271: LD_STRING JMM
14273: PPUSH
14274: CALL_OW 104
14278: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_class , 2 ] ] ) = 0 and GetSide ( dep1 ) = 3 and GetSide ( dep2 ) = 3 do
14279: LD_INT 22
14281: PUSH
14282: LD_INT 1
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PUSH
14289: LD_INT 21
14291: PUSH
14292: LD_INT 1
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: LD_INT 2
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: LIST
14313: PPUSH
14314: CALL_OW 69
14318: PUSH
14319: LD_INT 0
14321: EQUAL
14322: PUSH
14323: LD_INT 22
14325: PUSH
14326: LD_INT 4
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 21
14335: PUSH
14336: LD_INT 1
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 25
14345: PUSH
14346: LD_INT 2
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: LIST
14357: PPUSH
14358: CALL_OW 69
14362: PUSH
14363: LD_INT 0
14365: EQUAL
14366: AND
14367: PUSH
14368: LD_INT 1
14370: PPUSH
14371: CALL_OW 255
14375: PUSH
14376: LD_INT 3
14378: EQUAL
14379: AND
14380: PUSH
14381: LD_INT 10
14383: PPUSH
14384: CALL_OW 255
14388: PUSH
14389: LD_INT 3
14391: EQUAL
14392: AND
14393: IFFALSE 14405
14395: GO 14397
14397: DISABLE
// YouLost ( Engineer ) ;
14398: LD_STRING Engineer
14400: PPUSH
14401: CALL_OW 104
14405: END
// every 0 0$1 trigger GetSide ( dep1 ) = 3 and LastBattle = 1 do
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 255
14413: PUSH
14414: LD_INT 3
14416: EQUAL
14417: PUSH
14418: LD_EXP 27
14422: PUSH
14423: LD_INT 1
14425: EQUAL
14426: AND
14427: IFFALSE 14439
14429: GO 14431
14431: DISABLE
// YouLost ( DepotCaptured ) ; end_of_file
14432: LD_STRING DepotCaptured
14434: PPUSH
14435: CALL_OW 104
14439: END
// export function PrepareTigers ; var i , un ; begin
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
14444: PPUSH
// for i = 1 to Difficulty do
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: DOUBLE
14451: LD_INT 1
14453: DEC
14454: ST_TO_ADDR
14455: LD_OWVAR 67
14459: PUSH
14460: FOR_TO
14461: IFFALSE 14596
// begin hc_sex = sex_male ;
14463: LD_ADDR_OWVAR 27
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// uc_side = 0 ;
14471: LD_ADDR_OWVAR 20
14475: PUSH
14476: LD_INT 0
14478: ST_TO_ADDR
// uc_nation = nation_nature ;
14479: LD_ADDR_OWVAR 21
14483: PUSH
14484: LD_INT 0
14486: ST_TO_ADDR
// hc_class = class_tiger ;
14487: LD_ADDR_OWVAR 28
14491: PUSH
14492: LD_INT 14
14494: ST_TO_ADDR
// hc_skills = [ RuSoldMaxLevel , 0 , 0 , 0 ] ;
14495: LD_ADDR_OWVAR 31
14499: PUSH
14500: LD_EXP 14
14504: PUSH
14505: LD_INT 0
14507: PUSH
14508: LD_INT 0
14510: PUSH
14511: LD_INT 0
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: ST_TO_ADDR
// hc_agressivity = [ rand ( 30 , 40 ) , rand ( 40 , 50 ) , rand ( 50 , 60 ) ] [ Difficulty ] ;
14520: LD_ADDR_OWVAR 35
14524: PUSH
14525: LD_INT 30
14527: PPUSH
14528: LD_INT 40
14530: PPUSH
14531: CALL_OW 12
14535: PUSH
14536: LD_INT 40
14538: PPUSH
14539: LD_INT 50
14541: PPUSH
14542: CALL_OW 12
14546: PUSH
14547: LD_INT 50
14549: PPUSH
14550: LD_INT 60
14552: PPUSH
14553: CALL_OW 12
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: LIST
14562: PUSH
14563: LD_OWVAR 67
14567: ARRAY
14568: ST_TO_ADDR
// un = CreateHuman ;
14569: LD_ADDR_VAR 0 3
14573: PUSH
14574: CALL_OW 44
14578: ST_TO_ADDR
// PlaceUnitArea ( un , NatureArea , false ) ;
14579: LD_VAR 0 3
14583: PPUSH
14584: LD_INT 27
14586: PPUSH
14587: LD_INT 0
14589: PPUSH
14590: CALL_OW 49
// end ;
14594: GO 14460
14596: POP
14597: POP
// end ; end_of_file
14598: LD_VAR 0 1
14602: RET
// every 0 0$01 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape = 1 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_weapon , 51 ] , [ f_not , [ f_empty ] ] ] ) = 0 do
14603: LD_INT 1
14605: PPUSH
14606: CALL_OW 255
14610: PUSH
14611: LD_INT 1
14613: EQUAL
14614: PUSH
14615: LD_INT 10
14617: PPUSH
14618: CALL_OW 255
14622: PUSH
14623: LD_INT 1
14625: EQUAL
14626: AND
14627: PUSH
14628: LD_EXP 20
14632: PUSH
14633: LD_INT 1
14635: EQUAL
14636: AND
14637: PUSH
14638: LD_INT 22
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 21
14650: PUSH
14651: LD_INT 2
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: LD_INT 34
14660: PUSH
14661: LD_INT 51
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 58
14673: PUSH
14674: EMPTY
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_INT 0
14694: EQUAL
14695: AND
14696: IFFALSE 14787
14698: GO 14700
14700: DISABLE
// begin wait ( [ 4 4$30 , 4 4$0 , 3 3$0 ] [ Difficulty ] ) ;
14701: LD_INT 9450
14703: PUSH
14704: LD_INT 8400
14706: PUSH
14707: LD_INT 6300
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_OWVAR 67
14719: ARRAY
14720: PPUSH
14721: CALL_OW 67
// if cargoEscape = 1 then
14725: LD_EXP 20
14729: PUSH
14730: LD_INT 1
14732: EQUAL
14733: IFFALSE 14787
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14735: LD_EXP 9
14739: PPUSH
14740: LD_STRING D6-Pow-1
14742: PPUSH
14743: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14747: LD_EXP 1
14751: PPUSH
14752: LD_STRING D6-JMM-1
14754: PPUSH
14755: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14759: LD_EXP 9
14763: PPUSH
14764: LD_STRING D6-Pow-2
14766: PPUSH
14767: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14771: LD_EXP 1
14775: PPUSH
14776: LD_STRING D6-JMM-2
14778: PPUSH
14779: CALL_OW 88
// FinishMission ;
14783: CALL 14995 0 0
// end ; end ;
14787: END
// every 0 0$1 trigger GetSide ( dep1 ) = 1 and GetSide ( dep2 ) = 1 and cargoEscape > 1 do var tmp ;
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 255
14795: PUSH
14796: LD_INT 1
14798: EQUAL
14799: PUSH
14800: LD_INT 10
14802: PPUSH
14803: CALL_OW 255
14807: PUSH
14808: LD_INT 1
14810: EQUAL
14811: AND
14812: PUSH
14813: LD_EXP 20
14817: PUSH
14818: LD_INT 1
14820: GREATER
14821: AND
14822: IFFALSE 14889
14824: GO 14826
14826: DISABLE
14827: LD_INT 0
14829: PPUSH
// begin wait ( [ 5 5$30 , 5 5$0 , 4 4$30 ] [ Difficulty ] ) ;
14830: LD_INT 11550
14832: PUSH
14833: LD_INT 10500
14835: PUSH
14836: LD_INT 9450
14838: PUSH
14839: EMPTY
14840: LIST
14841: LIST
14842: LIST
14843: PUSH
14844: LD_OWVAR 67
14848: ARRAY
14849: PPUSH
14850: CALL_OW 67
// PrepareRussianAttack ( [ 1 , 2 , 3 ] [ Difficulty ] , RussianAttack ) ;
14854: LD_INT 1
14856: PUSH
14857: LD_INT 2
14859: PUSH
14860: LD_INT 3
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PUSH
14868: LD_OWVAR 67
14872: ARRAY
14873: PPUSH
14874: LD_INT 13
14876: PPUSH
14877: CALL 12986 0 2
// lastBattle = 1 ;
14881: LD_ADDR_EXP 27
14885: PUSH
14886: LD_INT 1
14888: ST_TO_ADDR
// end ;
14889: PPOPN 1
14891: END
// every 0 0$7 trigger LastBattle = 1 and FilterUnitsInArea ( Battlefield , [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
14892: LD_EXP 27
14896: PUSH
14897: LD_INT 1
14899: EQUAL
14900: PUSH
14901: LD_INT 26
14903: PPUSH
14904: LD_INT 22
14906: PUSH
14907: LD_INT 3
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: PUSH
14914: LD_INT 21
14916: PUSH
14917: LD_INT 1
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PPUSH
14928: CALL_OW 70
14932: PUSH
14933: LD_INT 0
14935: EQUAL
14936: AND
14937: IFFALSE 14994
14939: GO 14941
14941: DISABLE
// begin SayRadio ( Powell , D6-Pow-1 ) ;
14942: LD_EXP 9
14946: PPUSH
14947: LD_STRING D6-Pow-1
14949: PPUSH
14950: CALL_OW 94
// Say ( JMM , D6-JMM-1 ) ;
14954: LD_EXP 1
14958: PPUSH
14959: LD_STRING D6-JMM-1
14961: PPUSH
14962: CALL_OW 88
// SayRadio ( Powell , D6-Pow-2 ) ;
14966: LD_EXP 9
14970: PPUSH
14971: LD_STRING D6-Pow-2
14973: PPUSH
14974: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
14978: LD_EXP 1
14982: PPUSH
14983: LD_STRING D6-JMM-2
14985: PPUSH
14986: CALL_OW 88
// FinishMission ;
14990: CALL 14995 0 0
// end ;
14994: END
// export function FinishMission ; var tmp , m1 , m2 , m3 ; begin
14995: LD_INT 0
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// if tick <= 18 18$00 then
15002: LD_OWVAR 1
15006: PUSH
15007: LD_INT 37800
15009: LESSEQUAL
15010: IFFALSE 15019
// SetAchievement ( ACH_ASPEED_2 ) ;
15012: LD_STRING ACH_ASPEED_2
15014: PPUSH
15015: CALL_OW 543
// tmp = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_lives , 251 ] ] ) ;
15019: LD_ADDR_VAR 0 2
15023: PUSH
15024: LD_INT 22
15026: PUSH
15027: LD_INT 1
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 21
15036: PUSH
15037: LD_INT 2
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PUSH
15044: LD_INT 24
15046: PUSH
15047: LD_INT 251
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: LIST
15058: PPUSH
15059: CALL_OW 69
15063: ST_TO_ADDR
// if tmp then
15064: LD_VAR 0 2
15068: IFFALSE 15082
// SaveVehicles ( tmp , 02_tanks_1 ) ;
15070: LD_VAR 0 2
15074: PPUSH
15075: LD_STRING 02_tanks_1
15077: PPUSH
15078: CALL 10459 0 2
// if mikhailStatus = 1 and IsLive ( Mikhail ) then
15082: LD_EXP 21
15086: PUSH
15087: LD_INT 1
15089: EQUAL
15090: PUSH
15091: LD_EXP 8
15095: PPUSH
15096: CALL_OW 300
15100: AND
15101: IFFALSE 15115
// SaveVariable ( mikhailStatus , 02_mikhailStatus_1 ) ;
15103: LD_EXP 21
15107: PPUSH
15108: LD_STRING 02_mikhailStatus_1
15110: PPUSH
15111: CALL_OW 39
// SaveVariable ( GetResourceType ( GetBase ( dep1 ) , 1 ) , 02_resources_4 ) ;
15115: LD_INT 1
15117: PPUSH
15118: CALL_OW 274
15122: PPUSH
15123: LD_INT 1
15125: PPUSH
15126: CALL_OW 275
15130: PPUSH
15131: LD_STRING 02_resources_4
15133: PPUSH
15134: CALL_OW 39
// m1 := false ;
15138: LD_ADDR_VAR 0 3
15142: PUSH
15143: LD_INT 0
15145: ST_TO_ADDR
// m2 := false ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: LD_INT 0
15153: ST_TO_ADDR
// m3 := false ;
15154: LD_ADDR_VAR 0 5
15158: PUSH
15159: LD_INT 0
15161: ST_TO_ADDR
// if GetResourceType ( GetBase ( dep1 ) , 1 ) >= 200 then
15162: LD_INT 1
15164: PPUSH
15165: CALL_OW 274
15169: PPUSH
15170: LD_INT 1
15172: PPUSH
15173: CALL_OW 275
15177: PUSH
15178: LD_INT 200
15180: GREATEREQUAL
15181: IFFALSE 15203
// begin AddMedal ( Cans , 1 ) ;
15183: LD_STRING Cans
15185: PPUSH
15186: LD_INT 1
15188: PPUSH
15189: CALL_OW 101
// m1 := true ;
15193: LD_ADDR_VAR 0 3
15197: PUSH
15198: LD_INT 1
15200: ST_TO_ADDR
// end else
15201: GO 15214
// begin AddMedal ( Cans , - 1 ) ;
15203: LD_STRING Cans
15205: PPUSH
15206: LD_INT 1
15208: NEG
15209: PPUSH
15210: CALL_OW 101
// end ; if deadsCounter < 2 then
15214: LD_EXP 31
15218: PUSH
15219: LD_INT 2
15221: LESS
15222: IFFALSE 15244
// begin AddMedal ( Deaths , 1 ) ;
15224: LD_STRING Deaths
15226: PPUSH
15227: LD_INT 1
15229: PPUSH
15230: CALL_OW 101
// m2 := true ;
15234: LD_ADDR_VAR 0 4
15238: PUSH
15239: LD_INT 1
15241: ST_TO_ADDR
// end else
15242: GO 15255
// begin AddMedal ( Deaths , - 1 ) ;
15244: LD_STRING Deaths
15246: PPUSH
15247: LD_INT 1
15249: NEG
15250: PPUSH
15251: CALL_OW 101
// end ; if mikhailStatus = 0 then
15255: LD_EXP 21
15259: PUSH
15260: LD_INT 0
15262: EQUAL
15263: IFFALSE 15276
// AddMedal ( Prisoner , - 1 ) ;
15265: LD_STRING Prisoner
15267: PPUSH
15268: LD_INT 1
15270: NEG
15271: PPUSH
15272: CALL_OW 101
// if mikhailStatus = 1 then
15276: LD_EXP 21
15280: PUSH
15281: LD_INT 1
15283: EQUAL
15284: IFFALSE 15304
// begin AddMedal ( Prisoner , 1 ) ;
15286: LD_STRING Prisoner
15288: PPUSH
15289: LD_INT 1
15291: PPUSH
15292: CALL_OW 101
// m3 := true ;
15296: LD_ADDR_VAR 0 5
15300: PUSH
15301: LD_INT 1
15303: ST_TO_ADDR
// end ; if mikhailStatus = 2 then
15304: LD_EXP 21
15308: PUSH
15309: LD_INT 2
15311: EQUAL
15312: IFFALSE 15332
// begin AddMedal ( Prisoner , 2 ) ;
15314: LD_STRING Prisoner
15316: PPUSH
15317: LD_INT 2
15319: PPUSH
15320: CALL_OW 101
// m3 := true ;
15324: LD_ADDR_VAR 0 5
15328: PUSH
15329: LD_INT 1
15331: ST_TO_ADDR
// end ; if mikhailStatus = 3 then
15332: LD_EXP 21
15336: PUSH
15337: LD_INT 3
15339: EQUAL
15340: IFFALSE 15353
// AddMedal ( Prisoner , - 2 ) ;
15342: LD_STRING Prisoner
15344: PPUSH
15345: LD_INT 2
15347: NEG
15348: PPUSH
15349: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
15353: LD_OWVAR 67
15357: PUSH
15358: LD_INT 3
15360: EQUAL
15361: PUSH
15362: LD_VAR 0 3
15366: AND
15367: PUSH
15368: LD_VAR 0 4
15372: AND
15373: PUSH
15374: LD_VAR 0 5
15378: AND
15379: IFFALSE 15391
// SetAchievementEX ( ACH_AMER , 2 ) ;
15381: LD_STRING ACH_AMER
15383: PPUSH
15384: LD_INT 2
15386: PPUSH
15387: CALL_OW 564
// GiveMedals ( MAIN ) ;
15391: LD_STRING MAIN
15393: PPUSH
15394: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) ) ;
15398: LD_INT 22
15400: PUSH
15401: LD_INT 1
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 23
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 21
15420: PUSH
15421: LD_INT 1
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: LIST
15432: PPUSH
15433: CALL_OW 69
15437: PPUSH
15438: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15442: LD_EXP 1
15446: PPUSH
15447: LD_EXP 33
15451: PUSH
15452: LD_STRING JMM
15454: STR
15455: PPUSH
15456: CALL_OW 38
// if IsOK ( Bobby ) then
15460: LD_EXP 2
15464: PPUSH
15465: CALL_OW 302
15469: IFFALSE 15489
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15471: LD_EXP 2
15475: PPUSH
15476: LD_EXP 33
15480: PUSH
15481: LD_STRING Bobby
15483: STR
15484: PPUSH
15485: CALL_OW 38
// if IsOK ( Cyrus ) then
15489: LD_EXP 3
15493: PPUSH
15494: CALL_OW 302
15498: IFFALSE 15518
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15500: LD_EXP 3
15504: PPUSH
15505: LD_EXP 33
15509: PUSH
15510: LD_STRING Cyrus
15512: STR
15513: PPUSH
15514: CALL_OW 38
// if IsOK ( Lisa ) then
15518: LD_EXP 4
15522: PPUSH
15523: CALL_OW 302
15527: IFFALSE 15547
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15529: LD_EXP 4
15533: PPUSH
15534: LD_EXP 33
15538: PUSH
15539: LD_STRING Lisa
15541: STR
15542: PPUSH
15543: CALL_OW 38
// if IsOK ( Khatam ) then
15547: LD_EXP 5
15551: PPUSH
15552: CALL_OW 302
15556: IFFALSE 15576
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
15558: LD_EXP 5
15562: PPUSH
15563: LD_EXP 33
15567: PUSH
15568: LD_STRING Khatam
15570: STR
15571: PPUSH
15572: CALL_OW 38
// if IsOK ( Brian ) then
15576: LD_EXP 6
15580: PPUSH
15581: CALL_OW 302
15585: IFFALSE 15605
// SaveCharacters ( Brian , mission_prefix & Brian ) ;
15587: LD_EXP 6
15591: PPUSH
15592: LD_EXP 33
15596: PUSH
15597: LD_STRING Brian
15599: STR
15600: PPUSH
15601: CALL_OW 38
// if IsOk ( Jerry ) then
15605: LD_EXP 7
15609: PPUSH
15610: CALL_OW 302
15614: IFFALSE 15634
// SaveCharacters ( Jerry , mission_prefix & Jerry ) ;
15616: LD_EXP 7
15620: PPUSH
15621: LD_EXP 33
15625: PUSH
15626: LD_STRING Jerry
15628: STR
15629: PPUSH
15630: CALL_OW 38
// if mikhailStatus = 1 and GetSide ( Mikhail ) = 1 and IsOk ( Mikhail ) then
15634: LD_EXP 21
15638: PUSH
15639: LD_INT 1
15641: EQUAL
15642: PUSH
15643: LD_EXP 8
15647: PPUSH
15648: CALL_OW 255
15652: PUSH
15653: LD_INT 1
15655: EQUAL
15656: AND
15657: PUSH
15658: LD_EXP 8
15662: PPUSH
15663: CALL_OW 302
15667: AND
15668: IFFALSE 15688
// SaveCharacters ( Mikhail , mission_prefix & Mikhail ) ;
15670: LD_EXP 8
15674: PPUSH
15675: LD_EXP 33
15679: PUSH
15680: LD_STRING Mikhail
15682: STR
15683: PPUSH
15684: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_ok ] , [ f_side , 1 ] , [ f_type , unit_human ] ] ) diff [ JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Mikhail ] , 02_other_survivors ) ;
15688: LD_INT 50
15690: PUSH
15691: EMPTY
15692: LIST
15693: PUSH
15694: LD_INT 22
15696: PUSH
15697: LD_INT 1
15699: PUSH
15700: EMPTY
15701: LIST
15702: LIST
15703: PUSH
15704: LD_INT 21
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_EXP 1
15728: PUSH
15729: LD_EXP 2
15733: PUSH
15734: LD_EXP 3
15738: PUSH
15739: LD_EXP 4
15743: PUSH
15744: LD_EXP 5
15748: PUSH
15749: LD_EXP 6
15753: PUSH
15754: LD_EXP 7
15758: PUSH
15759: LD_EXP 8
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: DIFF
15774: PPUSH
15775: LD_STRING 02_other_survivors
15777: PPUSH
15778: CALL_OW 38
// YouWin ;
15782: CALL_OW 103
// end ; end_of_file
15786: LD_VAR 0 1
15790: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
15791: GO 15793
15793: DISABLE
// begin ru_radar := 98 ;
15794: LD_ADDR_EXP 35
15798: PUSH
15799: LD_INT 98
15801: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
15802: LD_ADDR_EXP 36
15806: PUSH
15807: LD_INT 89
15809: ST_TO_ADDR
// us_hack := 99 ;
15810: LD_ADDR_EXP 37
15814: PUSH
15815: LD_INT 99
15817: ST_TO_ADDR
// us_artillery := 97 ;
15818: LD_ADDR_EXP 38
15822: PUSH
15823: LD_INT 97
15825: ST_TO_ADDR
// ar_bio_bomb := 91 ;
15826: LD_ADDR_EXP 39
15830: PUSH
15831: LD_INT 91
15833: ST_TO_ADDR
// end ; end_of_file end_of_file
15834: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
15835: GO 15837
15837: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
15838: LD_STRING initStreamRollete();
15840: PPUSH
15841: CALL_OW 559
// InitStreamMode ;
15845: CALL 15854 0 0
// DefineStreamItems ( ) ;
15849: CALL 16294 0 0
// end ;
15853: END
// function InitStreamMode ; begin
15854: LD_INT 0
15856: PPUSH
// streamModeActive := false ;
15857: LD_ADDR_EXP 40
15861: PUSH
15862: LD_INT 0
15864: ST_TO_ADDR
// normalCounter := 36 ;
15865: LD_ADDR_EXP 41
15869: PUSH
15870: LD_INT 36
15872: ST_TO_ADDR
// hardcoreCounter := 16 ;
15873: LD_ADDR_EXP 42
15877: PUSH
15878: LD_INT 16
15880: ST_TO_ADDR
// sRocket := false ;
15881: LD_ADDR_EXP 45
15885: PUSH
15886: LD_INT 0
15888: ST_TO_ADDR
// sSpeed := false ;
15889: LD_ADDR_EXP 44
15893: PUSH
15894: LD_INT 0
15896: ST_TO_ADDR
// sEngine := false ;
15897: LD_ADDR_EXP 46
15901: PUSH
15902: LD_INT 0
15904: ST_TO_ADDR
// sSpec := false ;
15905: LD_ADDR_EXP 43
15909: PUSH
15910: LD_INT 0
15912: ST_TO_ADDR
// sLevel := false ;
15913: LD_ADDR_EXP 47
15917: PUSH
15918: LD_INT 0
15920: ST_TO_ADDR
// sArmoury := false ;
15921: LD_ADDR_EXP 48
15925: PUSH
15926: LD_INT 0
15928: ST_TO_ADDR
// sRadar := false ;
15929: LD_ADDR_EXP 49
15933: PUSH
15934: LD_INT 0
15936: ST_TO_ADDR
// sBunker := false ;
15937: LD_ADDR_EXP 50
15941: PUSH
15942: LD_INT 0
15944: ST_TO_ADDR
// sHack := false ;
15945: LD_ADDR_EXP 51
15949: PUSH
15950: LD_INT 0
15952: ST_TO_ADDR
// sFire := false ;
15953: LD_ADDR_EXP 52
15957: PUSH
15958: LD_INT 0
15960: ST_TO_ADDR
// sRefresh := false ;
15961: LD_ADDR_EXP 53
15965: PUSH
15966: LD_INT 0
15968: ST_TO_ADDR
// sExp := false ;
15969: LD_ADDR_EXP 54
15973: PUSH
15974: LD_INT 0
15976: ST_TO_ADDR
// sDepot := false ;
15977: LD_ADDR_EXP 55
15981: PUSH
15982: LD_INT 0
15984: ST_TO_ADDR
// sFlag := false ;
15985: LD_ADDR_EXP 56
15989: PUSH
15990: LD_INT 0
15992: ST_TO_ADDR
// sKamikadze := false ;
15993: LD_ADDR_EXP 64
15997: PUSH
15998: LD_INT 0
16000: ST_TO_ADDR
// sTroll := false ;
16001: LD_ADDR_EXP 65
16005: PUSH
16006: LD_INT 0
16008: ST_TO_ADDR
// sSlow := false ;
16009: LD_ADDR_EXP 66
16013: PUSH
16014: LD_INT 0
16016: ST_TO_ADDR
// sLack := false ;
16017: LD_ADDR_EXP 67
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// sTank := false ;
16025: LD_ADDR_EXP 69
16029: PUSH
16030: LD_INT 0
16032: ST_TO_ADDR
// sRemote := false ;
16033: LD_ADDR_EXP 70
16037: PUSH
16038: LD_INT 0
16040: ST_TO_ADDR
// sPowell := false ;
16041: LD_ADDR_EXP 71
16045: PUSH
16046: LD_INT 0
16048: ST_TO_ADDR
// sTeleport := false ;
16049: LD_ADDR_EXP 74
16053: PUSH
16054: LD_INT 0
16056: ST_TO_ADDR
// sOilTower := false ;
16057: LD_ADDR_EXP 76
16061: PUSH
16062: LD_INT 0
16064: ST_TO_ADDR
// sShovel := false ;
16065: LD_ADDR_EXP 77
16069: PUSH
16070: LD_INT 0
16072: ST_TO_ADDR
// sSheik := false ;
16073: LD_ADDR_EXP 78
16077: PUSH
16078: LD_INT 0
16080: ST_TO_ADDR
// sEarthquake := false ;
16081: LD_ADDR_EXP 80
16085: PUSH
16086: LD_INT 0
16088: ST_TO_ADDR
// sAI := false ;
16089: LD_ADDR_EXP 81
16093: PUSH
16094: LD_INT 0
16096: ST_TO_ADDR
// sCargo := false ;
16097: LD_ADDR_EXP 84
16101: PUSH
16102: LD_INT 0
16104: ST_TO_ADDR
// sDLaser := false ;
16105: LD_ADDR_EXP 85
16109: PUSH
16110: LD_INT 0
16112: ST_TO_ADDR
// sExchange := false ;
16113: LD_ADDR_EXP 86
16117: PUSH
16118: LD_INT 0
16120: ST_TO_ADDR
// sFac := false ;
16121: LD_ADDR_EXP 87
16125: PUSH
16126: LD_INT 0
16128: ST_TO_ADDR
// sPower := false ;
16129: LD_ADDR_EXP 88
16133: PUSH
16134: LD_INT 0
16136: ST_TO_ADDR
// sRandom := false ;
16137: LD_ADDR_EXP 89
16141: PUSH
16142: LD_INT 0
16144: ST_TO_ADDR
// sShield := false ;
16145: LD_ADDR_EXP 90
16149: PUSH
16150: LD_INT 0
16152: ST_TO_ADDR
// sTime := false ;
16153: LD_ADDR_EXP 91
16157: PUSH
16158: LD_INT 0
16160: ST_TO_ADDR
// sTools := false ;
16161: LD_ADDR_EXP 92
16165: PUSH
16166: LD_INT 0
16168: ST_TO_ADDR
// sSold := false ;
16169: LD_ADDR_EXP 57
16173: PUSH
16174: LD_INT 0
16176: ST_TO_ADDR
// sDiff := false ;
16177: LD_ADDR_EXP 58
16181: PUSH
16182: LD_INT 0
16184: ST_TO_ADDR
// sFog := false ;
16185: LD_ADDR_EXP 61
16189: PUSH
16190: LD_INT 0
16192: ST_TO_ADDR
// sReset := false ;
16193: LD_ADDR_EXP 62
16197: PUSH
16198: LD_INT 0
16200: ST_TO_ADDR
// sSun := false ;
16201: LD_ADDR_EXP 63
16205: PUSH
16206: LD_INT 0
16208: ST_TO_ADDR
// sTiger := false ;
16209: LD_ADDR_EXP 59
16213: PUSH
16214: LD_INT 0
16216: ST_TO_ADDR
// sBomb := false ;
16217: LD_ADDR_EXP 60
16221: PUSH
16222: LD_INT 0
16224: ST_TO_ADDR
// sWound := false ;
16225: LD_ADDR_EXP 68
16229: PUSH
16230: LD_INT 0
16232: ST_TO_ADDR
// sBetray := false ;
16233: LD_ADDR_EXP 72
16237: PUSH
16238: LD_INT 0
16240: ST_TO_ADDR
// sContamin := false ;
16241: LD_ADDR_EXP 73
16245: PUSH
16246: LD_INT 0
16248: ST_TO_ADDR
// sOil := false ;
16249: LD_ADDR_EXP 75
16253: PUSH
16254: LD_INT 0
16256: ST_TO_ADDR
// sStu := false ;
16257: LD_ADDR_EXP 79
16261: PUSH
16262: LD_INT 0
16264: ST_TO_ADDR
// sBazooka := false ;
16265: LD_ADDR_EXP 82
16269: PUSH
16270: LD_INT 0
16272: ST_TO_ADDR
// sMortar := false ;
16273: LD_ADDR_EXP 83
16277: PUSH
16278: LD_INT 0
16280: ST_TO_ADDR
// sRanger := false ;
16281: LD_ADDR_EXP 93
16285: PUSH
16286: LD_INT 0
16288: ST_TO_ADDR
// end ;
16289: LD_VAR 0 1
16293: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
16294: LD_INT 0
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
// result := [ ] ;
16301: LD_ADDR_VAR 0 1
16305: PUSH
16306: EMPTY
16307: ST_TO_ADDR
// if campaign_id = 1 then
16308: LD_OWVAR 69
16312: PUSH
16313: LD_INT 1
16315: EQUAL
16316: IFFALSE 19254
// begin case mission_number of 1 :
16318: LD_OWVAR 70
16322: PUSH
16323: LD_INT 1
16325: DOUBLE
16326: EQUAL
16327: IFTRUE 16331
16329: GO 16395
16331: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
16332: LD_ADDR_VAR 0 1
16336: PUSH
16337: LD_INT 2
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: LD_INT 11
16345: PUSH
16346: LD_INT 12
16348: PUSH
16349: LD_INT 15
16351: PUSH
16352: LD_INT 16
16354: PUSH
16355: LD_INT 22
16357: PUSH
16358: LD_INT 23
16360: PUSH
16361: LD_INT 26
16363: PUSH
16364: EMPTY
16365: LIST
16366: LIST
16367: LIST
16368: LIST
16369: LIST
16370: LIST
16371: LIST
16372: LIST
16373: LIST
16374: PUSH
16375: LD_INT 101
16377: PUSH
16378: LD_INT 102
16380: PUSH
16381: LD_INT 106
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: LIST
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: ST_TO_ADDR
16393: GO 19252
16395: LD_INT 2
16397: DOUBLE
16398: EQUAL
16399: IFTRUE 16403
16401: GO 16475
16403: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
16404: LD_ADDR_VAR 0 1
16408: PUSH
16409: LD_INT 2
16411: PUSH
16412: LD_INT 4
16414: PUSH
16415: LD_INT 11
16417: PUSH
16418: LD_INT 12
16420: PUSH
16421: LD_INT 15
16423: PUSH
16424: LD_INT 16
16426: PUSH
16427: LD_INT 22
16429: PUSH
16430: LD_INT 23
16432: PUSH
16433: LD_INT 26
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: LIST
16446: PUSH
16447: LD_INT 101
16449: PUSH
16450: LD_INT 102
16452: PUSH
16453: LD_INT 105
16455: PUSH
16456: LD_INT 106
16458: PUSH
16459: LD_INT 108
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: LIST
16467: LIST
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: ST_TO_ADDR
16473: GO 19252
16475: LD_INT 3
16477: DOUBLE
16478: EQUAL
16479: IFTRUE 16483
16481: GO 16559
16483: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
16484: LD_ADDR_VAR 0 1
16488: PUSH
16489: LD_INT 2
16491: PUSH
16492: LD_INT 4
16494: PUSH
16495: LD_INT 5
16497: PUSH
16498: LD_INT 11
16500: PUSH
16501: LD_INT 12
16503: PUSH
16504: LD_INT 15
16506: PUSH
16507: LD_INT 16
16509: PUSH
16510: LD_INT 22
16512: PUSH
16513: LD_INT 26
16515: PUSH
16516: LD_INT 36
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 101
16533: PUSH
16534: LD_INT 102
16536: PUSH
16537: LD_INT 105
16539: PUSH
16540: LD_INT 106
16542: PUSH
16543: LD_INT 108
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: LIST
16550: LIST
16551: LIST
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: ST_TO_ADDR
16557: GO 19252
16559: LD_INT 4
16561: DOUBLE
16562: EQUAL
16563: IFTRUE 16567
16565: GO 16651
16567: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
16568: LD_ADDR_VAR 0 1
16572: PUSH
16573: LD_INT 2
16575: PUSH
16576: LD_INT 4
16578: PUSH
16579: LD_INT 5
16581: PUSH
16582: LD_INT 8
16584: PUSH
16585: LD_INT 11
16587: PUSH
16588: LD_INT 12
16590: PUSH
16591: LD_INT 15
16593: PUSH
16594: LD_INT 16
16596: PUSH
16597: LD_INT 22
16599: PUSH
16600: LD_INT 23
16602: PUSH
16603: LD_INT 26
16605: PUSH
16606: LD_INT 36
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: LIST
16621: LIST
16622: PUSH
16623: LD_INT 101
16625: PUSH
16626: LD_INT 102
16628: PUSH
16629: LD_INT 105
16631: PUSH
16632: LD_INT 106
16634: PUSH
16635: LD_INT 108
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: LIST
16642: LIST
16643: LIST
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: ST_TO_ADDR
16649: GO 19252
16651: LD_INT 5
16653: DOUBLE
16654: EQUAL
16655: IFTRUE 16659
16657: GO 16759
16659: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
16660: LD_ADDR_VAR 0 1
16664: PUSH
16665: LD_INT 2
16667: PUSH
16668: LD_INT 4
16670: PUSH
16671: LD_INT 5
16673: PUSH
16674: LD_INT 6
16676: PUSH
16677: LD_INT 8
16679: PUSH
16680: LD_INT 11
16682: PUSH
16683: LD_INT 12
16685: PUSH
16686: LD_INT 15
16688: PUSH
16689: LD_INT 16
16691: PUSH
16692: LD_INT 22
16694: PUSH
16695: LD_INT 23
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 26
16703: PUSH
16704: LD_INT 36
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 101
16725: PUSH
16726: LD_INT 102
16728: PUSH
16729: LD_INT 105
16731: PUSH
16732: LD_INT 106
16734: PUSH
16735: LD_INT 108
16737: PUSH
16738: LD_INT 109
16740: PUSH
16741: LD_INT 112
16743: PUSH
16744: EMPTY
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: ST_TO_ADDR
16757: GO 19252
16759: LD_INT 6
16761: DOUBLE
16762: EQUAL
16763: IFTRUE 16767
16765: GO 16887
16767: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_INT 2
16775: PUSH
16776: LD_INT 4
16778: PUSH
16779: LD_INT 5
16781: PUSH
16782: LD_INT 6
16784: PUSH
16785: LD_INT 8
16787: PUSH
16788: LD_INT 11
16790: PUSH
16791: LD_INT 12
16793: PUSH
16794: LD_INT 15
16796: PUSH
16797: LD_INT 16
16799: PUSH
16800: LD_INT 20
16802: PUSH
16803: LD_INT 21
16805: PUSH
16806: LD_INT 22
16808: PUSH
16809: LD_INT 23
16811: PUSH
16812: LD_INT 25
16814: PUSH
16815: LD_INT 26
16817: PUSH
16818: LD_INT 30
16820: PUSH
16821: LD_INT 31
16823: PUSH
16824: LD_INT 32
16826: PUSH
16827: LD_INT 36
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: LIST
16847: LIST
16848: LIST
16849: LIST
16850: PUSH
16851: LD_INT 101
16853: PUSH
16854: LD_INT 102
16856: PUSH
16857: LD_INT 105
16859: PUSH
16860: LD_INT 106
16862: PUSH
16863: LD_INT 108
16865: PUSH
16866: LD_INT 109
16868: PUSH
16869: LD_INT 112
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: LIST
16878: LIST
16879: LIST
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: ST_TO_ADDR
16885: GO 19252
16887: LD_INT 7
16889: DOUBLE
16890: EQUAL
16891: IFTRUE 16895
16893: GO 16995
16895: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
16896: LD_ADDR_VAR 0 1
16900: PUSH
16901: LD_INT 2
16903: PUSH
16904: LD_INT 4
16906: PUSH
16907: LD_INT 5
16909: PUSH
16910: LD_INT 7
16912: PUSH
16913: LD_INT 11
16915: PUSH
16916: LD_INT 12
16918: PUSH
16919: LD_INT 15
16921: PUSH
16922: LD_INT 16
16924: PUSH
16925: LD_INT 20
16927: PUSH
16928: LD_INT 21
16930: PUSH
16931: LD_INT 22
16933: PUSH
16934: LD_INT 23
16936: PUSH
16937: LD_INT 25
16939: PUSH
16940: LD_INT 26
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 101
16961: PUSH
16962: LD_INT 102
16964: PUSH
16965: LD_INT 103
16967: PUSH
16968: LD_INT 105
16970: PUSH
16971: LD_INT 106
16973: PUSH
16974: LD_INT 108
16976: PUSH
16977: LD_INT 112
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: ST_TO_ADDR
16993: GO 19252
16995: LD_INT 8
16997: DOUBLE
16998: EQUAL
16999: IFTRUE 17003
17001: GO 17131
17003: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
17004: LD_ADDR_VAR 0 1
17008: PUSH
17009: LD_INT 2
17011: PUSH
17012: LD_INT 4
17014: PUSH
17015: LD_INT 5
17017: PUSH
17018: LD_INT 6
17020: PUSH
17021: LD_INT 7
17023: PUSH
17024: LD_INT 8
17026: PUSH
17027: LD_INT 11
17029: PUSH
17030: LD_INT 12
17032: PUSH
17033: LD_INT 15
17035: PUSH
17036: LD_INT 16
17038: PUSH
17039: LD_INT 20
17041: PUSH
17042: LD_INT 21
17044: PUSH
17045: LD_INT 22
17047: PUSH
17048: LD_INT 23
17050: PUSH
17051: LD_INT 25
17053: PUSH
17054: LD_INT 26
17056: PUSH
17057: LD_INT 30
17059: PUSH
17060: LD_INT 31
17062: PUSH
17063: LD_INT 32
17065: PUSH
17066: LD_INT 36
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: LIST
17090: PUSH
17091: LD_INT 101
17093: PUSH
17094: LD_INT 102
17096: PUSH
17097: LD_INT 103
17099: PUSH
17100: LD_INT 105
17102: PUSH
17103: LD_INT 106
17105: PUSH
17106: LD_INT 108
17108: PUSH
17109: LD_INT 109
17111: PUSH
17112: LD_INT 112
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: ST_TO_ADDR
17129: GO 19252
17131: LD_INT 9
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17139
17137: GO 17275
17139: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
17140: LD_ADDR_VAR 0 1
17144: PUSH
17145: LD_INT 2
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: LD_INT 7
17159: PUSH
17160: LD_INT 8
17162: PUSH
17163: LD_INT 11
17165: PUSH
17166: LD_INT 12
17168: PUSH
17169: LD_INT 15
17171: PUSH
17172: LD_INT 16
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: LD_INT 21
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 23
17186: PUSH
17187: LD_INT 25
17189: PUSH
17190: LD_INT 26
17192: PUSH
17193: LD_INT 28
17195: PUSH
17196: LD_INT 30
17198: PUSH
17199: LD_INT 31
17201: PUSH
17202: LD_INT 32
17204: PUSH
17205: LD_INT 36
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: LIST
17228: LIST
17229: LIST
17230: PUSH
17231: LD_INT 101
17233: PUSH
17234: LD_INT 102
17236: PUSH
17237: LD_INT 103
17239: PUSH
17240: LD_INT 105
17242: PUSH
17243: LD_INT 106
17245: PUSH
17246: LD_INT 108
17248: PUSH
17249: LD_INT 109
17251: PUSH
17252: LD_INT 112
17254: PUSH
17255: LD_INT 114
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: LIST
17266: LIST
17267: LIST
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: ST_TO_ADDR
17273: GO 19252
17275: LD_INT 10
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17467
17283: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
17284: LD_ADDR_VAR 0 1
17288: PUSH
17289: LD_INT 2
17291: PUSH
17292: LD_INT 4
17294: PUSH
17295: LD_INT 5
17297: PUSH
17298: LD_INT 6
17300: PUSH
17301: LD_INT 7
17303: PUSH
17304: LD_INT 8
17306: PUSH
17307: LD_INT 9
17309: PUSH
17310: LD_INT 10
17312: PUSH
17313: LD_INT 11
17315: PUSH
17316: LD_INT 12
17318: PUSH
17319: LD_INT 13
17321: PUSH
17322: LD_INT 14
17324: PUSH
17325: LD_INT 15
17327: PUSH
17328: LD_INT 16
17330: PUSH
17331: LD_INT 17
17333: PUSH
17334: LD_INT 18
17336: PUSH
17337: LD_INT 19
17339: PUSH
17340: LD_INT 20
17342: PUSH
17343: LD_INT 21
17345: PUSH
17346: LD_INT 22
17348: PUSH
17349: LD_INT 23
17351: PUSH
17352: LD_INT 24
17354: PUSH
17355: LD_INT 25
17357: PUSH
17358: LD_INT 26
17360: PUSH
17361: LD_INT 28
17363: PUSH
17364: LD_INT 30
17366: PUSH
17367: LD_INT 31
17369: PUSH
17370: LD_INT 32
17372: PUSH
17373: LD_INT 36
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: LIST
17406: PUSH
17407: LD_INT 101
17409: PUSH
17410: LD_INT 102
17412: PUSH
17413: LD_INT 103
17415: PUSH
17416: LD_INT 104
17418: PUSH
17419: LD_INT 105
17421: PUSH
17422: LD_INT 106
17424: PUSH
17425: LD_INT 107
17427: PUSH
17428: LD_INT 108
17430: PUSH
17431: LD_INT 109
17433: PUSH
17434: LD_INT 110
17436: PUSH
17437: LD_INT 111
17439: PUSH
17440: LD_INT 112
17442: PUSH
17443: LD_INT 114
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: LIST
17454: LIST
17455: LIST
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: ST_TO_ADDR
17465: GO 19252
17467: LD_INT 11
17469: DOUBLE
17470: EQUAL
17471: IFTRUE 17475
17473: GO 17667
17475: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
17476: LD_ADDR_VAR 0 1
17480: PUSH
17481: LD_INT 2
17483: PUSH
17484: LD_INT 3
17486: PUSH
17487: LD_INT 4
17489: PUSH
17490: LD_INT 5
17492: PUSH
17493: LD_INT 6
17495: PUSH
17496: LD_INT 7
17498: PUSH
17499: LD_INT 8
17501: PUSH
17502: LD_INT 9
17504: PUSH
17505: LD_INT 10
17507: PUSH
17508: LD_INT 11
17510: PUSH
17511: LD_INT 12
17513: PUSH
17514: LD_INT 13
17516: PUSH
17517: LD_INT 14
17519: PUSH
17520: LD_INT 15
17522: PUSH
17523: LD_INT 16
17525: PUSH
17526: LD_INT 17
17528: PUSH
17529: LD_INT 18
17531: PUSH
17532: LD_INT 19
17534: PUSH
17535: LD_INT 20
17537: PUSH
17538: LD_INT 21
17540: PUSH
17541: LD_INT 22
17543: PUSH
17544: LD_INT 23
17546: PUSH
17547: LD_INT 24
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 26
17555: PUSH
17556: LD_INT 28
17558: PUSH
17559: LD_INT 30
17561: PUSH
17562: LD_INT 31
17564: PUSH
17565: LD_INT 32
17567: PUSH
17568: LD_INT 34
17570: PUSH
17571: LD_INT 36
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: LIST
17593: LIST
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 101
17609: PUSH
17610: LD_INT 102
17612: PUSH
17613: LD_INT 103
17615: PUSH
17616: LD_INT 104
17618: PUSH
17619: LD_INT 105
17621: PUSH
17622: LD_INT 106
17624: PUSH
17625: LD_INT 107
17627: PUSH
17628: LD_INT 108
17630: PUSH
17631: LD_INT 109
17633: PUSH
17634: LD_INT 110
17636: PUSH
17637: LD_INT 111
17639: PUSH
17640: LD_INT 112
17642: PUSH
17643: LD_INT 114
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: LIST
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: ST_TO_ADDR
17665: GO 19252
17667: LD_INT 12
17669: DOUBLE
17670: EQUAL
17671: IFTRUE 17675
17673: GO 17883
17675: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
17676: LD_ADDR_VAR 0 1
17680: PUSH
17681: LD_INT 1
17683: PUSH
17684: LD_INT 2
17686: PUSH
17687: LD_INT 3
17689: PUSH
17690: LD_INT 4
17692: PUSH
17693: LD_INT 5
17695: PUSH
17696: LD_INT 6
17698: PUSH
17699: LD_INT 7
17701: PUSH
17702: LD_INT 8
17704: PUSH
17705: LD_INT 9
17707: PUSH
17708: LD_INT 10
17710: PUSH
17711: LD_INT 11
17713: PUSH
17714: LD_INT 12
17716: PUSH
17717: LD_INT 13
17719: PUSH
17720: LD_INT 14
17722: PUSH
17723: LD_INT 15
17725: PUSH
17726: LD_INT 16
17728: PUSH
17729: LD_INT 17
17731: PUSH
17732: LD_INT 18
17734: PUSH
17735: LD_INT 19
17737: PUSH
17738: LD_INT 20
17740: PUSH
17741: LD_INT 21
17743: PUSH
17744: LD_INT 22
17746: PUSH
17747: LD_INT 23
17749: PUSH
17750: LD_INT 24
17752: PUSH
17753: LD_INT 25
17755: PUSH
17756: LD_INT 26
17758: PUSH
17759: LD_INT 27
17761: PUSH
17762: LD_INT 28
17764: PUSH
17765: LD_INT 30
17767: PUSH
17768: LD_INT 31
17770: PUSH
17771: LD_INT 32
17773: PUSH
17774: LD_INT 33
17776: PUSH
17777: LD_INT 34
17779: PUSH
17780: LD_INT 36
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 101
17821: PUSH
17822: LD_INT 102
17824: PUSH
17825: LD_INT 103
17827: PUSH
17828: LD_INT 104
17830: PUSH
17831: LD_INT 105
17833: PUSH
17834: LD_INT 106
17836: PUSH
17837: LD_INT 107
17839: PUSH
17840: LD_INT 108
17842: PUSH
17843: LD_INT 109
17845: PUSH
17846: LD_INT 110
17848: PUSH
17849: LD_INT 111
17851: PUSH
17852: LD_INT 112
17854: PUSH
17855: LD_INT 113
17857: PUSH
17858: LD_INT 114
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: LIST
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: ST_TO_ADDR
17881: GO 19252
17883: LD_INT 13
17885: DOUBLE
17886: EQUAL
17887: IFTRUE 17891
17889: GO 18087
17891: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
17892: LD_ADDR_VAR 0 1
17896: PUSH
17897: LD_INT 1
17899: PUSH
17900: LD_INT 2
17902: PUSH
17903: LD_INT 3
17905: PUSH
17906: LD_INT 4
17908: PUSH
17909: LD_INT 5
17911: PUSH
17912: LD_INT 8
17914: PUSH
17915: LD_INT 9
17917: PUSH
17918: LD_INT 10
17920: PUSH
17921: LD_INT 11
17923: PUSH
17924: LD_INT 12
17926: PUSH
17927: LD_INT 14
17929: PUSH
17930: LD_INT 15
17932: PUSH
17933: LD_INT 16
17935: PUSH
17936: LD_INT 17
17938: PUSH
17939: LD_INT 18
17941: PUSH
17942: LD_INT 19
17944: PUSH
17945: LD_INT 20
17947: PUSH
17948: LD_INT 21
17950: PUSH
17951: LD_INT 22
17953: PUSH
17954: LD_INT 23
17956: PUSH
17957: LD_INT 24
17959: PUSH
17960: LD_INT 25
17962: PUSH
17963: LD_INT 26
17965: PUSH
17966: LD_INT 27
17968: PUSH
17969: LD_INT 28
17971: PUSH
17972: LD_INT 30
17974: PUSH
17975: LD_INT 31
17977: PUSH
17978: LD_INT 32
17980: PUSH
17981: LD_INT 33
17983: PUSH
17984: LD_INT 34
17986: PUSH
17987: LD_INT 36
17989: PUSH
17990: EMPTY
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: PUSH
18023: LD_INT 101
18025: PUSH
18026: LD_INT 102
18028: PUSH
18029: LD_INT 103
18031: PUSH
18032: LD_INT 104
18034: PUSH
18035: LD_INT 105
18037: PUSH
18038: LD_INT 106
18040: PUSH
18041: LD_INT 107
18043: PUSH
18044: LD_INT 108
18046: PUSH
18047: LD_INT 109
18049: PUSH
18050: LD_INT 110
18052: PUSH
18053: LD_INT 111
18055: PUSH
18056: LD_INT 112
18058: PUSH
18059: LD_INT 113
18061: PUSH
18062: LD_INT 114
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: LIST
18069: LIST
18070: LIST
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: LIST
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: ST_TO_ADDR
18085: GO 19252
18087: LD_INT 14
18089: DOUBLE
18090: EQUAL
18091: IFTRUE 18095
18093: GO 18307
18095: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
18096: LD_ADDR_VAR 0 1
18100: PUSH
18101: LD_INT 1
18103: PUSH
18104: LD_INT 2
18106: PUSH
18107: LD_INT 3
18109: PUSH
18110: LD_INT 4
18112: PUSH
18113: LD_INT 5
18115: PUSH
18116: LD_INT 6
18118: PUSH
18119: LD_INT 7
18121: PUSH
18122: LD_INT 8
18124: PUSH
18125: LD_INT 9
18127: PUSH
18128: LD_INT 10
18130: PUSH
18131: LD_INT 11
18133: PUSH
18134: LD_INT 12
18136: PUSH
18137: LD_INT 13
18139: PUSH
18140: LD_INT 14
18142: PUSH
18143: LD_INT 15
18145: PUSH
18146: LD_INT 16
18148: PUSH
18149: LD_INT 17
18151: PUSH
18152: LD_INT 18
18154: PUSH
18155: LD_INT 19
18157: PUSH
18158: LD_INT 20
18160: PUSH
18161: LD_INT 21
18163: PUSH
18164: LD_INT 22
18166: PUSH
18167: LD_INT 23
18169: PUSH
18170: LD_INT 24
18172: PUSH
18173: LD_INT 25
18175: PUSH
18176: LD_INT 26
18178: PUSH
18179: LD_INT 27
18181: PUSH
18182: LD_INT 28
18184: PUSH
18185: LD_INT 29
18187: PUSH
18188: LD_INT 30
18190: PUSH
18191: LD_INT 31
18193: PUSH
18194: LD_INT 32
18196: PUSH
18197: LD_INT 33
18199: PUSH
18200: LD_INT 34
18202: PUSH
18203: LD_INT 36
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: LIST
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: PUSH
18243: LD_INT 101
18245: PUSH
18246: LD_INT 102
18248: PUSH
18249: LD_INT 103
18251: PUSH
18252: LD_INT 104
18254: PUSH
18255: LD_INT 105
18257: PUSH
18258: LD_INT 106
18260: PUSH
18261: LD_INT 107
18263: PUSH
18264: LD_INT 108
18266: PUSH
18267: LD_INT 109
18269: PUSH
18270: LD_INT 110
18272: PUSH
18273: LD_INT 111
18275: PUSH
18276: LD_INT 112
18278: PUSH
18279: LD_INT 113
18281: PUSH
18282: LD_INT 114
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: LIST
18297: LIST
18298: LIST
18299: LIST
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: ST_TO_ADDR
18305: GO 19252
18307: LD_INT 15
18309: DOUBLE
18310: EQUAL
18311: IFTRUE 18315
18313: GO 18527
18315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
18316: LD_ADDR_VAR 0 1
18320: PUSH
18321: LD_INT 1
18323: PUSH
18324: LD_INT 2
18326: PUSH
18327: LD_INT 3
18329: PUSH
18330: LD_INT 4
18332: PUSH
18333: LD_INT 5
18335: PUSH
18336: LD_INT 6
18338: PUSH
18339: LD_INT 7
18341: PUSH
18342: LD_INT 8
18344: PUSH
18345: LD_INT 9
18347: PUSH
18348: LD_INT 10
18350: PUSH
18351: LD_INT 11
18353: PUSH
18354: LD_INT 12
18356: PUSH
18357: LD_INT 13
18359: PUSH
18360: LD_INT 14
18362: PUSH
18363: LD_INT 15
18365: PUSH
18366: LD_INT 16
18368: PUSH
18369: LD_INT 17
18371: PUSH
18372: LD_INT 18
18374: PUSH
18375: LD_INT 19
18377: PUSH
18378: LD_INT 20
18380: PUSH
18381: LD_INT 21
18383: PUSH
18384: LD_INT 22
18386: PUSH
18387: LD_INT 23
18389: PUSH
18390: LD_INT 24
18392: PUSH
18393: LD_INT 25
18395: PUSH
18396: LD_INT 26
18398: PUSH
18399: LD_INT 27
18401: PUSH
18402: LD_INT 28
18404: PUSH
18405: LD_INT 29
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 31
18413: PUSH
18414: LD_INT 32
18416: PUSH
18417: LD_INT 33
18419: PUSH
18420: LD_INT 34
18422: PUSH
18423: LD_INT 36
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: PUSH
18463: LD_INT 101
18465: PUSH
18466: LD_INT 102
18468: PUSH
18469: LD_INT 103
18471: PUSH
18472: LD_INT 104
18474: PUSH
18475: LD_INT 105
18477: PUSH
18478: LD_INT 106
18480: PUSH
18481: LD_INT 107
18483: PUSH
18484: LD_INT 108
18486: PUSH
18487: LD_INT 109
18489: PUSH
18490: LD_INT 110
18492: PUSH
18493: LD_INT 111
18495: PUSH
18496: LD_INT 112
18498: PUSH
18499: LD_INT 113
18501: PUSH
18502: LD_INT 114
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: LIST
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: ST_TO_ADDR
18525: GO 19252
18527: LD_INT 16
18529: DOUBLE
18530: EQUAL
18531: IFTRUE 18535
18533: GO 18659
18535: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
18536: LD_ADDR_VAR 0 1
18540: PUSH
18541: LD_INT 2
18543: PUSH
18544: LD_INT 4
18546: PUSH
18547: LD_INT 5
18549: PUSH
18550: LD_INT 7
18552: PUSH
18553: LD_INT 11
18555: PUSH
18556: LD_INT 12
18558: PUSH
18559: LD_INT 15
18561: PUSH
18562: LD_INT 16
18564: PUSH
18565: LD_INT 20
18567: PUSH
18568: LD_INT 21
18570: PUSH
18571: LD_INT 22
18573: PUSH
18574: LD_INT 23
18576: PUSH
18577: LD_INT 25
18579: PUSH
18580: LD_INT 26
18582: PUSH
18583: LD_INT 30
18585: PUSH
18586: LD_INT 31
18588: PUSH
18589: LD_INT 32
18591: PUSH
18592: LD_INT 33
18594: PUSH
18595: LD_INT 34
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: PUSH
18619: LD_INT 101
18621: PUSH
18622: LD_INT 102
18624: PUSH
18625: LD_INT 103
18627: PUSH
18628: LD_INT 106
18630: PUSH
18631: LD_INT 108
18633: PUSH
18634: LD_INT 112
18636: PUSH
18637: LD_INT 113
18639: PUSH
18640: LD_INT 114
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: LIST
18647: LIST
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: ST_TO_ADDR
18657: GO 19252
18659: LD_INT 17
18661: DOUBLE
18662: EQUAL
18663: IFTRUE 18667
18665: GO 18879
18667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
18668: LD_ADDR_VAR 0 1
18672: PUSH
18673: LD_INT 1
18675: PUSH
18676: LD_INT 2
18678: PUSH
18679: LD_INT 3
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: LD_INT 5
18687: PUSH
18688: LD_INT 6
18690: PUSH
18691: LD_INT 7
18693: PUSH
18694: LD_INT 8
18696: PUSH
18697: LD_INT 9
18699: PUSH
18700: LD_INT 10
18702: PUSH
18703: LD_INT 11
18705: PUSH
18706: LD_INT 12
18708: PUSH
18709: LD_INT 13
18711: PUSH
18712: LD_INT 14
18714: PUSH
18715: LD_INT 15
18717: PUSH
18718: LD_INT 16
18720: PUSH
18721: LD_INT 17
18723: PUSH
18724: LD_INT 18
18726: PUSH
18727: LD_INT 19
18729: PUSH
18730: LD_INT 20
18732: PUSH
18733: LD_INT 21
18735: PUSH
18736: LD_INT 22
18738: PUSH
18739: LD_INT 23
18741: PUSH
18742: LD_INT 24
18744: PUSH
18745: LD_INT 25
18747: PUSH
18748: LD_INT 26
18750: PUSH
18751: LD_INT 27
18753: PUSH
18754: LD_INT 28
18756: PUSH
18757: LD_INT 29
18759: PUSH
18760: LD_INT 30
18762: PUSH
18763: LD_INT 31
18765: PUSH
18766: LD_INT 32
18768: PUSH
18769: LD_INT 33
18771: PUSH
18772: LD_INT 34
18774: PUSH
18775: LD_INT 36
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: LIST
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: PUSH
18815: LD_INT 101
18817: PUSH
18818: LD_INT 102
18820: PUSH
18821: LD_INT 103
18823: PUSH
18824: LD_INT 104
18826: PUSH
18827: LD_INT 105
18829: PUSH
18830: LD_INT 106
18832: PUSH
18833: LD_INT 107
18835: PUSH
18836: LD_INT 108
18838: PUSH
18839: LD_INT 109
18841: PUSH
18842: LD_INT 110
18844: PUSH
18845: LD_INT 111
18847: PUSH
18848: LD_INT 112
18850: PUSH
18851: LD_INT 113
18853: PUSH
18854: LD_INT 114
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: ST_TO_ADDR
18877: GO 19252
18879: LD_INT 18
18881: DOUBLE
18882: EQUAL
18883: IFTRUE 18887
18885: GO 19023
18887: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
18888: LD_ADDR_VAR 0 1
18892: PUSH
18893: LD_INT 2
18895: PUSH
18896: LD_INT 4
18898: PUSH
18899: LD_INT 5
18901: PUSH
18902: LD_INT 7
18904: PUSH
18905: LD_INT 11
18907: PUSH
18908: LD_INT 12
18910: PUSH
18911: LD_INT 15
18913: PUSH
18914: LD_INT 16
18916: PUSH
18917: LD_INT 20
18919: PUSH
18920: LD_INT 21
18922: PUSH
18923: LD_INT 22
18925: PUSH
18926: LD_INT 23
18928: PUSH
18929: LD_INT 25
18931: PUSH
18932: LD_INT 26
18934: PUSH
18935: LD_INT 30
18937: PUSH
18938: LD_INT 31
18940: PUSH
18941: LD_INT 32
18943: PUSH
18944: LD_INT 33
18946: PUSH
18947: LD_INT 34
18949: PUSH
18950: LD_INT 35
18952: PUSH
18953: LD_INT 36
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: LIST
18970: LIST
18971: LIST
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 101
18981: PUSH
18982: LD_INT 102
18984: PUSH
18985: LD_INT 103
18987: PUSH
18988: LD_INT 106
18990: PUSH
18991: LD_INT 108
18993: PUSH
18994: LD_INT 112
18996: PUSH
18997: LD_INT 113
18999: PUSH
19000: LD_INT 114
19002: PUSH
19003: LD_INT 115
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: PUSH
19017: EMPTY
19018: LIST
19019: LIST
19020: ST_TO_ADDR
19021: GO 19252
19023: LD_INT 19
19025: DOUBLE
19026: EQUAL
19027: IFTRUE 19031
19029: GO 19251
19031: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
19032: LD_ADDR_VAR 0 1
19036: PUSH
19037: LD_INT 1
19039: PUSH
19040: LD_INT 2
19042: PUSH
19043: LD_INT 3
19045: PUSH
19046: LD_INT 4
19048: PUSH
19049: LD_INT 5
19051: PUSH
19052: LD_INT 6
19054: PUSH
19055: LD_INT 7
19057: PUSH
19058: LD_INT 8
19060: PUSH
19061: LD_INT 9
19063: PUSH
19064: LD_INT 10
19066: PUSH
19067: LD_INT 11
19069: PUSH
19070: LD_INT 12
19072: PUSH
19073: LD_INT 13
19075: PUSH
19076: LD_INT 14
19078: PUSH
19079: LD_INT 15
19081: PUSH
19082: LD_INT 16
19084: PUSH
19085: LD_INT 17
19087: PUSH
19088: LD_INT 18
19090: PUSH
19091: LD_INT 19
19093: PUSH
19094: LD_INT 20
19096: PUSH
19097: LD_INT 21
19099: PUSH
19100: LD_INT 22
19102: PUSH
19103: LD_INT 23
19105: PUSH
19106: LD_INT 24
19108: PUSH
19109: LD_INT 25
19111: PUSH
19112: LD_INT 26
19114: PUSH
19115: LD_INT 27
19117: PUSH
19118: LD_INT 28
19120: PUSH
19121: LD_INT 29
19123: PUSH
19124: LD_INT 30
19126: PUSH
19127: LD_INT 31
19129: PUSH
19130: LD_INT 32
19132: PUSH
19133: LD_INT 33
19135: PUSH
19136: LD_INT 34
19138: PUSH
19139: LD_INT 35
19141: PUSH
19142: LD_INT 36
19144: PUSH
19145: EMPTY
19146: LIST
19147: LIST
19148: LIST
19149: LIST
19150: LIST
19151: LIST
19152: LIST
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: LIST
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: PUSH
19183: LD_INT 101
19185: PUSH
19186: LD_INT 102
19188: PUSH
19189: LD_INT 103
19191: PUSH
19192: LD_INT 104
19194: PUSH
19195: LD_INT 105
19197: PUSH
19198: LD_INT 106
19200: PUSH
19201: LD_INT 107
19203: PUSH
19204: LD_INT 108
19206: PUSH
19207: LD_INT 109
19209: PUSH
19210: LD_INT 110
19212: PUSH
19213: LD_INT 111
19215: PUSH
19216: LD_INT 112
19218: PUSH
19219: LD_INT 113
19221: PUSH
19222: LD_INT 114
19224: PUSH
19225: LD_INT 115
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: LIST
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: LIST
19237: LIST
19238: LIST
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: LIST
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 19252
19251: POP
// end else
19252: GO 19289
// if campaign_id = 5 then
19254: LD_OWVAR 69
19258: PUSH
19259: LD_INT 5
19261: EQUAL
19262: IFFALSE 19289
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_INT 1
19271: PUSH
19272: LD_INT 2
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 100
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: ST_TO_ADDR
// end ; if result then
19289: LD_VAR 0 1
19293: IFFALSE 19582
// begin normal :=  ;
19295: LD_ADDR_VAR 0 3
19299: PUSH
19300: LD_STRING 
19302: ST_TO_ADDR
// hardcore :=  ;
19303: LD_ADDR_VAR 0 4
19307: PUSH
19308: LD_STRING 
19310: ST_TO_ADDR
// for i = 1 to normalCounter do
19311: LD_ADDR_VAR 0 5
19315: PUSH
19316: DOUBLE
19317: LD_INT 1
19319: DEC
19320: ST_TO_ADDR
19321: LD_EXP 41
19325: PUSH
19326: FOR_TO
19327: IFFALSE 19428
// begin tmp := 0 ;
19329: LD_ADDR_VAR 0 2
19333: PUSH
19334: LD_STRING 0
19336: ST_TO_ADDR
// if result [ 1 ] then
19337: LD_VAR 0 1
19341: PUSH
19342: LD_INT 1
19344: ARRAY
19345: IFFALSE 19410
// if result [ 1 ] [ 1 ] = i then
19347: LD_VAR 0 1
19351: PUSH
19352: LD_INT 1
19354: ARRAY
19355: PUSH
19356: LD_INT 1
19358: ARRAY
19359: PUSH
19360: LD_VAR 0 5
19364: EQUAL
19365: IFFALSE 19410
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: LD_VAR 0 1
19376: PPUSH
19377: LD_INT 1
19379: PPUSH
19380: LD_VAR 0 1
19384: PUSH
19385: LD_INT 1
19387: ARRAY
19388: PPUSH
19389: LD_INT 1
19391: PPUSH
19392: CALL_OW 3
19396: PPUSH
19397: CALL_OW 1
19401: ST_TO_ADDR
// tmp := 1 ;
19402: LD_ADDR_VAR 0 2
19406: PUSH
19407: LD_STRING 1
19409: ST_TO_ADDR
// end ; normal := normal & tmp ;
19410: LD_ADDR_VAR 0 3
19414: PUSH
19415: LD_VAR 0 3
19419: PUSH
19420: LD_VAR 0 2
19424: STR
19425: ST_TO_ADDR
// end ;
19426: GO 19326
19428: POP
19429: POP
// for i = 1 to hardcoreCounter do
19430: LD_ADDR_VAR 0 5
19434: PUSH
19435: DOUBLE
19436: LD_INT 1
19438: DEC
19439: ST_TO_ADDR
19440: LD_EXP 42
19444: PUSH
19445: FOR_TO
19446: IFFALSE 19551
// begin tmp := 0 ;
19448: LD_ADDR_VAR 0 2
19452: PUSH
19453: LD_STRING 0
19455: ST_TO_ADDR
// if result [ 2 ] then
19456: LD_VAR 0 1
19460: PUSH
19461: LD_INT 2
19463: ARRAY
19464: IFFALSE 19533
// if result [ 2 ] [ 1 ] = 100 + i then
19466: LD_VAR 0 1
19470: PUSH
19471: LD_INT 2
19473: ARRAY
19474: PUSH
19475: LD_INT 1
19477: ARRAY
19478: PUSH
19479: LD_INT 100
19481: PUSH
19482: LD_VAR 0 5
19486: PLUS
19487: EQUAL
19488: IFFALSE 19533
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: LD_VAR 0 1
19499: PPUSH
19500: LD_INT 2
19502: PPUSH
19503: LD_VAR 0 1
19507: PUSH
19508: LD_INT 2
19510: ARRAY
19511: PPUSH
19512: LD_INT 1
19514: PPUSH
19515: CALL_OW 3
19519: PPUSH
19520: CALL_OW 1
19524: ST_TO_ADDR
// tmp := 1 ;
19525: LD_ADDR_VAR 0 2
19529: PUSH
19530: LD_STRING 1
19532: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
19533: LD_ADDR_VAR 0 4
19537: PUSH
19538: LD_VAR 0 4
19542: PUSH
19543: LD_VAR 0 2
19547: STR
19548: ST_TO_ADDR
// end ;
19549: GO 19445
19551: POP
19552: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
19553: LD_STRING getStreamItemsFromMission("
19555: PUSH
19556: LD_VAR 0 3
19560: STR
19561: PUSH
19562: LD_STRING ","
19564: STR
19565: PUSH
19566: LD_VAR 0 4
19570: STR
19571: PUSH
19572: LD_STRING ")
19574: STR
19575: PPUSH
19576: CALL_OW 559
// end else
19580: GO 19589
// ToLua ( getStreamItemsFromMission("","") ) ;
19582: LD_STRING getStreamItemsFromMission("","")
19584: PPUSH
19585: CALL_OW 559
// end ;
19589: LD_VAR 0 1
19593: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19594: LD_VAR 0 2
19598: PUSH
19599: LD_INT 100
19601: EQUAL
19602: IFFALSE 20551
// begin if not StreamModeActive then
19604: LD_EXP 40
19608: NOT
19609: IFFALSE 19619
// StreamModeActive := true ;
19611: LD_ADDR_EXP 40
19615: PUSH
19616: LD_INT 1
19618: ST_TO_ADDR
// if p3 = 0 then
19619: LD_VAR 0 3
19623: PUSH
19624: LD_INT 0
19626: EQUAL
19627: IFFALSE 19633
// InitStreamMode ;
19629: CALL 15854 0 0
// if p3 = 1 then
19633: LD_VAR 0 3
19637: PUSH
19638: LD_INT 1
19640: EQUAL
19641: IFFALSE 19651
// sRocket := true ;
19643: LD_ADDR_EXP 45
19647: PUSH
19648: LD_INT 1
19650: ST_TO_ADDR
// if p3 = 2 then
19651: LD_VAR 0 3
19655: PUSH
19656: LD_INT 2
19658: EQUAL
19659: IFFALSE 19669
// sSpeed := true ;
19661: LD_ADDR_EXP 44
19665: PUSH
19666: LD_INT 1
19668: ST_TO_ADDR
// if p3 = 3 then
19669: LD_VAR 0 3
19673: PUSH
19674: LD_INT 3
19676: EQUAL
19677: IFFALSE 19687
// sEngine := true ;
19679: LD_ADDR_EXP 46
19683: PUSH
19684: LD_INT 1
19686: ST_TO_ADDR
// if p3 = 4 then
19687: LD_VAR 0 3
19691: PUSH
19692: LD_INT 4
19694: EQUAL
19695: IFFALSE 19705
// sSpec := true ;
19697: LD_ADDR_EXP 43
19701: PUSH
19702: LD_INT 1
19704: ST_TO_ADDR
// if p3 = 5 then
19705: LD_VAR 0 3
19709: PUSH
19710: LD_INT 5
19712: EQUAL
19713: IFFALSE 19723
// sLevel := true ;
19715: LD_ADDR_EXP 47
19719: PUSH
19720: LD_INT 1
19722: ST_TO_ADDR
// if p3 = 6 then
19723: LD_VAR 0 3
19727: PUSH
19728: LD_INT 6
19730: EQUAL
19731: IFFALSE 19741
// sArmoury := true ;
19733: LD_ADDR_EXP 48
19737: PUSH
19738: LD_INT 1
19740: ST_TO_ADDR
// if p3 = 7 then
19741: LD_VAR 0 3
19745: PUSH
19746: LD_INT 7
19748: EQUAL
19749: IFFALSE 19759
// sRadar := true ;
19751: LD_ADDR_EXP 49
19755: PUSH
19756: LD_INT 1
19758: ST_TO_ADDR
// if p3 = 8 then
19759: LD_VAR 0 3
19763: PUSH
19764: LD_INT 8
19766: EQUAL
19767: IFFALSE 19777
// sBunker := true ;
19769: LD_ADDR_EXP 50
19773: PUSH
19774: LD_INT 1
19776: ST_TO_ADDR
// if p3 = 9 then
19777: LD_VAR 0 3
19781: PUSH
19782: LD_INT 9
19784: EQUAL
19785: IFFALSE 19795
// sHack := true ;
19787: LD_ADDR_EXP 51
19791: PUSH
19792: LD_INT 1
19794: ST_TO_ADDR
// if p3 = 10 then
19795: LD_VAR 0 3
19799: PUSH
19800: LD_INT 10
19802: EQUAL
19803: IFFALSE 19813
// sFire := true ;
19805: LD_ADDR_EXP 52
19809: PUSH
19810: LD_INT 1
19812: ST_TO_ADDR
// if p3 = 11 then
19813: LD_VAR 0 3
19817: PUSH
19818: LD_INT 11
19820: EQUAL
19821: IFFALSE 19831
// sRefresh := true ;
19823: LD_ADDR_EXP 53
19827: PUSH
19828: LD_INT 1
19830: ST_TO_ADDR
// if p3 = 12 then
19831: LD_VAR 0 3
19835: PUSH
19836: LD_INT 12
19838: EQUAL
19839: IFFALSE 19849
// sExp := true ;
19841: LD_ADDR_EXP 54
19845: PUSH
19846: LD_INT 1
19848: ST_TO_ADDR
// if p3 = 13 then
19849: LD_VAR 0 3
19853: PUSH
19854: LD_INT 13
19856: EQUAL
19857: IFFALSE 19867
// sDepot := true ;
19859: LD_ADDR_EXP 55
19863: PUSH
19864: LD_INT 1
19866: ST_TO_ADDR
// if p3 = 14 then
19867: LD_VAR 0 3
19871: PUSH
19872: LD_INT 14
19874: EQUAL
19875: IFFALSE 19885
// sFlag := true ;
19877: LD_ADDR_EXP 56
19881: PUSH
19882: LD_INT 1
19884: ST_TO_ADDR
// if p3 = 15 then
19885: LD_VAR 0 3
19889: PUSH
19890: LD_INT 15
19892: EQUAL
19893: IFFALSE 19903
// sKamikadze := true ;
19895: LD_ADDR_EXP 64
19899: PUSH
19900: LD_INT 1
19902: ST_TO_ADDR
// if p3 = 16 then
19903: LD_VAR 0 3
19907: PUSH
19908: LD_INT 16
19910: EQUAL
19911: IFFALSE 19921
// sTroll := true ;
19913: LD_ADDR_EXP 65
19917: PUSH
19918: LD_INT 1
19920: ST_TO_ADDR
// if p3 = 17 then
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 17
19928: EQUAL
19929: IFFALSE 19939
// sSlow := true ;
19931: LD_ADDR_EXP 66
19935: PUSH
19936: LD_INT 1
19938: ST_TO_ADDR
// if p3 = 18 then
19939: LD_VAR 0 3
19943: PUSH
19944: LD_INT 18
19946: EQUAL
19947: IFFALSE 19957
// sLack := true ;
19949: LD_ADDR_EXP 67
19953: PUSH
19954: LD_INT 1
19956: ST_TO_ADDR
// if p3 = 19 then
19957: LD_VAR 0 3
19961: PUSH
19962: LD_INT 19
19964: EQUAL
19965: IFFALSE 19975
// sTank := true ;
19967: LD_ADDR_EXP 69
19971: PUSH
19972: LD_INT 1
19974: ST_TO_ADDR
// if p3 = 20 then
19975: LD_VAR 0 3
19979: PUSH
19980: LD_INT 20
19982: EQUAL
19983: IFFALSE 19993
// sRemote := true ;
19985: LD_ADDR_EXP 70
19989: PUSH
19990: LD_INT 1
19992: ST_TO_ADDR
// if p3 = 21 then
19993: LD_VAR 0 3
19997: PUSH
19998: LD_INT 21
20000: EQUAL
20001: IFFALSE 20011
// sPowell := true ;
20003: LD_ADDR_EXP 71
20007: PUSH
20008: LD_INT 1
20010: ST_TO_ADDR
// if p3 = 22 then
20011: LD_VAR 0 3
20015: PUSH
20016: LD_INT 22
20018: EQUAL
20019: IFFALSE 20029
// sTeleport := true ;
20021: LD_ADDR_EXP 74
20025: PUSH
20026: LD_INT 1
20028: ST_TO_ADDR
// if p3 = 23 then
20029: LD_VAR 0 3
20033: PUSH
20034: LD_INT 23
20036: EQUAL
20037: IFFALSE 20047
// sOilTower := true ;
20039: LD_ADDR_EXP 76
20043: PUSH
20044: LD_INT 1
20046: ST_TO_ADDR
// if p3 = 24 then
20047: LD_VAR 0 3
20051: PUSH
20052: LD_INT 24
20054: EQUAL
20055: IFFALSE 20065
// sShovel := true ;
20057: LD_ADDR_EXP 77
20061: PUSH
20062: LD_INT 1
20064: ST_TO_ADDR
// if p3 = 25 then
20065: LD_VAR 0 3
20069: PUSH
20070: LD_INT 25
20072: EQUAL
20073: IFFALSE 20083
// sSheik := true ;
20075: LD_ADDR_EXP 78
20079: PUSH
20080: LD_INT 1
20082: ST_TO_ADDR
// if p3 = 26 then
20083: LD_VAR 0 3
20087: PUSH
20088: LD_INT 26
20090: EQUAL
20091: IFFALSE 20101
// sEarthquake := true ;
20093: LD_ADDR_EXP 80
20097: PUSH
20098: LD_INT 1
20100: ST_TO_ADDR
// if p3 = 27 then
20101: LD_VAR 0 3
20105: PUSH
20106: LD_INT 27
20108: EQUAL
20109: IFFALSE 20119
// sAI := true ;
20111: LD_ADDR_EXP 81
20115: PUSH
20116: LD_INT 1
20118: ST_TO_ADDR
// if p3 = 28 then
20119: LD_VAR 0 3
20123: PUSH
20124: LD_INT 28
20126: EQUAL
20127: IFFALSE 20137
// sCargo := true ;
20129: LD_ADDR_EXP 84
20133: PUSH
20134: LD_INT 1
20136: ST_TO_ADDR
// if p3 = 29 then
20137: LD_VAR 0 3
20141: PUSH
20142: LD_INT 29
20144: EQUAL
20145: IFFALSE 20155
// sDLaser := true ;
20147: LD_ADDR_EXP 85
20151: PUSH
20152: LD_INT 1
20154: ST_TO_ADDR
// if p3 = 30 then
20155: LD_VAR 0 3
20159: PUSH
20160: LD_INT 30
20162: EQUAL
20163: IFFALSE 20173
// sExchange := true ;
20165: LD_ADDR_EXP 86
20169: PUSH
20170: LD_INT 1
20172: ST_TO_ADDR
// if p3 = 31 then
20173: LD_VAR 0 3
20177: PUSH
20178: LD_INT 31
20180: EQUAL
20181: IFFALSE 20191
// sFac := true ;
20183: LD_ADDR_EXP 87
20187: PUSH
20188: LD_INT 1
20190: ST_TO_ADDR
// if p3 = 32 then
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 32
20198: EQUAL
20199: IFFALSE 20209
// sPower := true ;
20201: LD_ADDR_EXP 88
20205: PUSH
20206: LD_INT 1
20208: ST_TO_ADDR
// if p3 = 33 then
20209: LD_VAR 0 3
20213: PUSH
20214: LD_INT 33
20216: EQUAL
20217: IFFALSE 20227
// sRandom := true ;
20219: LD_ADDR_EXP 89
20223: PUSH
20224: LD_INT 1
20226: ST_TO_ADDR
// if p3 = 34 then
20227: LD_VAR 0 3
20231: PUSH
20232: LD_INT 34
20234: EQUAL
20235: IFFALSE 20245
// sShield := true ;
20237: LD_ADDR_EXP 90
20241: PUSH
20242: LD_INT 1
20244: ST_TO_ADDR
// if p3 = 35 then
20245: LD_VAR 0 3
20249: PUSH
20250: LD_INT 35
20252: EQUAL
20253: IFFALSE 20263
// sTime := true ;
20255: LD_ADDR_EXP 91
20259: PUSH
20260: LD_INT 1
20262: ST_TO_ADDR
// if p3 = 36 then
20263: LD_VAR 0 3
20267: PUSH
20268: LD_INT 36
20270: EQUAL
20271: IFFALSE 20281
// sTools := true ;
20273: LD_ADDR_EXP 92
20277: PUSH
20278: LD_INT 1
20280: ST_TO_ADDR
// if p3 = 101 then
20281: LD_VAR 0 3
20285: PUSH
20286: LD_INT 101
20288: EQUAL
20289: IFFALSE 20299
// sSold := true ;
20291: LD_ADDR_EXP 57
20295: PUSH
20296: LD_INT 1
20298: ST_TO_ADDR
// if p3 = 102 then
20299: LD_VAR 0 3
20303: PUSH
20304: LD_INT 102
20306: EQUAL
20307: IFFALSE 20317
// sDiff := true ;
20309: LD_ADDR_EXP 58
20313: PUSH
20314: LD_INT 1
20316: ST_TO_ADDR
// if p3 = 103 then
20317: LD_VAR 0 3
20321: PUSH
20322: LD_INT 103
20324: EQUAL
20325: IFFALSE 20335
// sFog := true ;
20327: LD_ADDR_EXP 61
20331: PUSH
20332: LD_INT 1
20334: ST_TO_ADDR
// if p3 = 104 then
20335: LD_VAR 0 3
20339: PUSH
20340: LD_INT 104
20342: EQUAL
20343: IFFALSE 20353
// sReset := true ;
20345: LD_ADDR_EXP 62
20349: PUSH
20350: LD_INT 1
20352: ST_TO_ADDR
// if p3 = 105 then
20353: LD_VAR 0 3
20357: PUSH
20358: LD_INT 105
20360: EQUAL
20361: IFFALSE 20371
// sSun := true ;
20363: LD_ADDR_EXP 63
20367: PUSH
20368: LD_INT 1
20370: ST_TO_ADDR
// if p3 = 106 then
20371: LD_VAR 0 3
20375: PUSH
20376: LD_INT 106
20378: EQUAL
20379: IFFALSE 20389
// sTiger := true ;
20381: LD_ADDR_EXP 59
20385: PUSH
20386: LD_INT 1
20388: ST_TO_ADDR
// if p3 = 107 then
20389: LD_VAR 0 3
20393: PUSH
20394: LD_INT 107
20396: EQUAL
20397: IFFALSE 20407
// sBomb := true ;
20399: LD_ADDR_EXP 60
20403: PUSH
20404: LD_INT 1
20406: ST_TO_ADDR
// if p3 = 108 then
20407: LD_VAR 0 3
20411: PUSH
20412: LD_INT 108
20414: EQUAL
20415: IFFALSE 20425
// sWound := true ;
20417: LD_ADDR_EXP 68
20421: PUSH
20422: LD_INT 1
20424: ST_TO_ADDR
// if p3 = 109 then
20425: LD_VAR 0 3
20429: PUSH
20430: LD_INT 109
20432: EQUAL
20433: IFFALSE 20443
// sBetray := true ;
20435: LD_ADDR_EXP 72
20439: PUSH
20440: LD_INT 1
20442: ST_TO_ADDR
// if p3 = 110 then
20443: LD_VAR 0 3
20447: PUSH
20448: LD_INT 110
20450: EQUAL
20451: IFFALSE 20461
// sContamin := true ;
20453: LD_ADDR_EXP 73
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// if p3 = 111 then
20461: LD_VAR 0 3
20465: PUSH
20466: LD_INT 111
20468: EQUAL
20469: IFFALSE 20479
// sOil := true ;
20471: LD_ADDR_EXP 75
20475: PUSH
20476: LD_INT 1
20478: ST_TO_ADDR
// if p3 = 112 then
20479: LD_VAR 0 3
20483: PUSH
20484: LD_INT 112
20486: EQUAL
20487: IFFALSE 20497
// sStu := true ;
20489: LD_ADDR_EXP 79
20493: PUSH
20494: LD_INT 1
20496: ST_TO_ADDR
// if p3 = 113 then
20497: LD_VAR 0 3
20501: PUSH
20502: LD_INT 113
20504: EQUAL
20505: IFFALSE 20515
// sBazooka := true ;
20507: LD_ADDR_EXP 82
20511: PUSH
20512: LD_INT 1
20514: ST_TO_ADDR
// if p3 = 114 then
20515: LD_VAR 0 3
20519: PUSH
20520: LD_INT 114
20522: EQUAL
20523: IFFALSE 20533
// sMortar := true ;
20525: LD_ADDR_EXP 83
20529: PUSH
20530: LD_INT 1
20532: ST_TO_ADDR
// if p3 = 115 then
20533: LD_VAR 0 3
20537: PUSH
20538: LD_INT 115
20540: EQUAL
20541: IFFALSE 20551
// sRanger := true ;
20543: LD_ADDR_EXP 93
20547: PUSH
20548: LD_INT 1
20550: ST_TO_ADDR
// end ; end ;
20551: PPOPN 6
20553: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
20554: LD_EXP 40
20558: PUSH
20559: LD_EXP 45
20563: AND
20564: IFFALSE 20688
20566: GO 20568
20568: DISABLE
20569: LD_INT 0
20571: PPUSH
20572: PPUSH
// begin enable ;
20573: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
20574: LD_ADDR_VAR 0 2
20578: PUSH
20579: LD_INT 22
20581: PUSH
20582: LD_OWVAR 2
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: PUSH
20591: LD_INT 2
20593: PUSH
20594: LD_INT 34
20596: PUSH
20597: LD_INT 7
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: PUSH
20604: LD_INT 34
20606: PUSH
20607: LD_INT 45
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: PUSH
20614: LD_INT 34
20616: PUSH
20617: LD_INT 28
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: PUSH
20624: LD_INT 34
20626: PUSH
20627: LD_INT 47
20629: PUSH
20630: EMPTY
20631: LIST
20632: LIST
20633: PUSH
20634: EMPTY
20635: LIST
20636: LIST
20637: LIST
20638: LIST
20639: LIST
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: PPUSH
20645: CALL_OW 69
20649: ST_TO_ADDR
// if not tmp then
20650: LD_VAR 0 2
20654: NOT
20655: IFFALSE 20659
// exit ;
20657: GO 20688
// for i in tmp do
20659: LD_ADDR_VAR 0 1
20663: PUSH
20664: LD_VAR 0 2
20668: PUSH
20669: FOR_IN
20670: IFFALSE 20686
// begin SetLives ( i , 0 ) ;
20672: LD_VAR 0 1
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 234
// end ;
20684: GO 20669
20686: POP
20687: POP
// end ;
20688: PPOPN 2
20690: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
20691: LD_EXP 40
20695: PUSH
20696: LD_EXP 46
20700: AND
20701: IFFALSE 20785
20703: GO 20705
20705: DISABLE
20706: LD_INT 0
20708: PPUSH
20709: PPUSH
// begin enable ;
20710: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
20711: LD_ADDR_VAR 0 2
20715: PUSH
20716: LD_INT 22
20718: PUSH
20719: LD_OWVAR 2
20723: PUSH
20724: EMPTY
20725: LIST
20726: LIST
20727: PUSH
20728: LD_INT 32
20730: PUSH
20731: LD_INT 3
20733: PUSH
20734: EMPTY
20735: LIST
20736: LIST
20737: PUSH
20738: EMPTY
20739: LIST
20740: LIST
20741: PPUSH
20742: CALL_OW 69
20746: ST_TO_ADDR
// if not tmp then
20747: LD_VAR 0 2
20751: NOT
20752: IFFALSE 20756
// exit ;
20754: GO 20785
// for i in tmp do
20756: LD_ADDR_VAR 0 1
20760: PUSH
20761: LD_VAR 0 2
20765: PUSH
20766: FOR_IN
20767: IFFALSE 20783
// begin SetLives ( i , 0 ) ;
20769: LD_VAR 0 1
20773: PPUSH
20774: LD_INT 0
20776: PPUSH
20777: CALL_OW 234
// end ;
20781: GO 20766
20783: POP
20784: POP
// end ;
20785: PPOPN 2
20787: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
20788: LD_EXP 40
20792: PUSH
20793: LD_EXP 43
20797: AND
20798: IFFALSE 20891
20800: GO 20802
20802: DISABLE
20803: LD_INT 0
20805: PPUSH
// begin enable ;
20806: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
20807: LD_ADDR_VAR 0 1
20811: PUSH
20812: LD_INT 22
20814: PUSH
20815: LD_OWVAR 2
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: PUSH
20824: LD_INT 2
20826: PUSH
20827: LD_INT 25
20829: PUSH
20830: LD_INT 5
20832: PUSH
20833: EMPTY
20834: LIST
20835: LIST
20836: PUSH
20837: LD_INT 25
20839: PUSH
20840: LD_INT 9
20842: PUSH
20843: EMPTY
20844: LIST
20845: LIST
20846: PUSH
20847: LD_INT 25
20849: PUSH
20850: LD_INT 8
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: LIST
20861: LIST
20862: PUSH
20863: EMPTY
20864: LIST
20865: LIST
20866: PPUSH
20867: CALL_OW 69
20871: PUSH
20872: FOR_IN
20873: IFFALSE 20889
// begin SetClass ( i , 1 ) ;
20875: LD_VAR 0 1
20879: PPUSH
20880: LD_INT 1
20882: PPUSH
20883: CALL_OW 336
// end ;
20887: GO 20872
20889: POP
20890: POP
// end ;
20891: PPOPN 1
20893: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
20894: LD_EXP 40
20898: PUSH
20899: LD_EXP 44
20903: AND
20904: PUSH
20905: LD_OWVAR 65
20909: PUSH
20910: LD_INT 7
20912: LESS
20913: AND
20914: IFFALSE 20928
20916: GO 20918
20918: DISABLE
// begin enable ;
20919: ENABLE
// game_speed := 7 ;
20920: LD_ADDR_OWVAR 65
20924: PUSH
20925: LD_INT 7
20927: ST_TO_ADDR
// end ;
20928: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
20929: LD_EXP 40
20933: PUSH
20934: LD_EXP 47
20938: AND
20939: IFFALSE 21141
20941: GO 20943
20943: DISABLE
20944: LD_INT 0
20946: PPUSH
20947: PPUSH
20948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
20949: LD_ADDR_VAR 0 3
20953: PUSH
20954: LD_INT 81
20956: PUSH
20957: LD_OWVAR 2
20961: PUSH
20962: EMPTY
20963: LIST
20964: LIST
20965: PUSH
20966: LD_INT 21
20968: PUSH
20969: LD_INT 1
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 69
20984: ST_TO_ADDR
// if not tmp then
20985: LD_VAR 0 3
20989: NOT
20990: IFFALSE 20994
// exit ;
20992: GO 21141
// if tmp > 5 then
20994: LD_VAR 0 3
20998: PUSH
20999: LD_INT 5
21001: GREATER
21002: IFFALSE 21014
// k := 5 else
21004: LD_ADDR_VAR 0 2
21008: PUSH
21009: LD_INT 5
21011: ST_TO_ADDR
21012: GO 21024
// k := tmp ;
21014: LD_ADDR_VAR 0 2
21018: PUSH
21019: LD_VAR 0 3
21023: ST_TO_ADDR
// for i := 1 to k do
21024: LD_ADDR_VAR 0 1
21028: PUSH
21029: DOUBLE
21030: LD_INT 1
21032: DEC
21033: ST_TO_ADDR
21034: LD_VAR 0 2
21038: PUSH
21039: FOR_TO
21040: IFFALSE 21139
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
21042: LD_VAR 0 3
21046: PUSH
21047: LD_VAR 0 1
21051: ARRAY
21052: PPUSH
21053: LD_VAR 0 1
21057: PUSH
21058: LD_INT 4
21060: MOD
21061: PUSH
21062: LD_INT 1
21064: PLUS
21065: PPUSH
21066: CALL_OW 259
21070: PUSH
21071: LD_INT 10
21073: LESS
21074: IFFALSE 21137
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
21076: LD_VAR 0 3
21080: PUSH
21081: LD_VAR 0 1
21085: ARRAY
21086: PPUSH
21087: LD_VAR 0 1
21091: PUSH
21092: LD_INT 4
21094: MOD
21095: PUSH
21096: LD_INT 1
21098: PLUS
21099: PPUSH
21100: LD_VAR 0 3
21104: PUSH
21105: LD_VAR 0 1
21109: ARRAY
21110: PPUSH
21111: LD_VAR 0 1
21115: PUSH
21116: LD_INT 4
21118: MOD
21119: PUSH
21120: LD_INT 1
21122: PLUS
21123: PPUSH
21124: CALL_OW 259
21128: PUSH
21129: LD_INT 1
21131: PLUS
21132: PPUSH
21133: CALL_OW 237
21137: GO 21039
21139: POP
21140: POP
// end ;
21141: PPOPN 3
21143: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
21144: LD_EXP 40
21148: PUSH
21149: LD_EXP 48
21153: AND
21154: IFFALSE 21174
21156: GO 21158
21158: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
21159: LD_INT 4
21161: PPUSH
21162: LD_OWVAR 2
21166: PPUSH
21167: LD_INT 0
21169: PPUSH
21170: CALL_OW 324
21174: END
// every 0 0$1 trigger StreamModeActive and sShovel do
21175: LD_EXP 40
21179: PUSH
21180: LD_EXP 77
21184: AND
21185: IFFALSE 21205
21187: GO 21189
21189: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
21190: LD_INT 19
21192: PPUSH
21193: LD_OWVAR 2
21197: PPUSH
21198: LD_INT 0
21200: PPUSH
21201: CALL_OW 324
21205: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
21206: LD_EXP 40
21210: PUSH
21211: LD_EXP 49
21215: AND
21216: IFFALSE 21318
21218: GO 21220
21220: DISABLE
21221: LD_INT 0
21223: PPUSH
21224: PPUSH
// begin enable ;
21225: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
21226: LD_ADDR_VAR 0 2
21230: PUSH
21231: LD_INT 22
21233: PUSH
21234: LD_OWVAR 2
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: PUSH
21243: LD_INT 2
21245: PUSH
21246: LD_INT 34
21248: PUSH
21249: LD_INT 11
21251: PUSH
21252: EMPTY
21253: LIST
21254: LIST
21255: PUSH
21256: LD_INT 34
21258: PUSH
21259: LD_INT 30
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: EMPTY
21267: LIST
21268: LIST
21269: LIST
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: PPUSH
21275: CALL_OW 69
21279: ST_TO_ADDR
// if not tmp then
21280: LD_VAR 0 2
21284: NOT
21285: IFFALSE 21289
// exit ;
21287: GO 21318
// for i in tmp do
21289: LD_ADDR_VAR 0 1
21293: PUSH
21294: LD_VAR 0 2
21298: PUSH
21299: FOR_IN
21300: IFFALSE 21316
// begin SetLives ( i , 0 ) ;
21302: LD_VAR 0 1
21306: PPUSH
21307: LD_INT 0
21309: PPUSH
21310: CALL_OW 234
// end ;
21314: GO 21299
21316: POP
21317: POP
// end ;
21318: PPOPN 2
21320: END
// every 0 0$1 trigger StreamModeActive and sBunker do
21321: LD_EXP 40
21325: PUSH
21326: LD_EXP 50
21330: AND
21331: IFFALSE 21351
21333: GO 21335
21335: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
21336: LD_INT 32
21338: PPUSH
21339: LD_OWVAR 2
21343: PPUSH
21344: LD_INT 0
21346: PPUSH
21347: CALL_OW 324
21351: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
21352: LD_EXP 40
21356: PUSH
21357: LD_EXP 51
21361: AND
21362: IFFALSE 21543
21364: GO 21366
21366: DISABLE
21367: LD_INT 0
21369: PPUSH
21370: PPUSH
21371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
21372: LD_ADDR_VAR 0 2
21376: PUSH
21377: LD_INT 22
21379: PUSH
21380: LD_OWVAR 2
21384: PUSH
21385: EMPTY
21386: LIST
21387: LIST
21388: PUSH
21389: LD_INT 33
21391: PUSH
21392: LD_INT 3
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PPUSH
21403: CALL_OW 69
21407: ST_TO_ADDR
// if not tmp then
21408: LD_VAR 0 2
21412: NOT
21413: IFFALSE 21417
// exit ;
21415: GO 21543
// side := 0 ;
21417: LD_ADDR_VAR 0 3
21421: PUSH
21422: LD_INT 0
21424: ST_TO_ADDR
// for i := 1 to 8 do
21425: LD_ADDR_VAR 0 1
21429: PUSH
21430: DOUBLE
21431: LD_INT 1
21433: DEC
21434: ST_TO_ADDR
21435: LD_INT 8
21437: PUSH
21438: FOR_TO
21439: IFFALSE 21487
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
21441: LD_OWVAR 2
21445: PUSH
21446: LD_VAR 0 1
21450: NONEQUAL
21451: PUSH
21452: LD_OWVAR 2
21456: PPUSH
21457: LD_VAR 0 1
21461: PPUSH
21462: CALL_OW 81
21466: PUSH
21467: LD_INT 2
21469: EQUAL
21470: AND
21471: IFFALSE 21485
// begin side := i ;
21473: LD_ADDR_VAR 0 3
21477: PUSH
21478: LD_VAR 0 1
21482: ST_TO_ADDR
// break ;
21483: GO 21487
// end ;
21485: GO 21438
21487: POP
21488: POP
// if not side then
21489: LD_VAR 0 3
21493: NOT
21494: IFFALSE 21498
// exit ;
21496: GO 21543
// for i := 1 to tmp do
21498: LD_ADDR_VAR 0 1
21502: PUSH
21503: DOUBLE
21504: LD_INT 1
21506: DEC
21507: ST_TO_ADDR
21508: LD_VAR 0 2
21512: PUSH
21513: FOR_TO
21514: IFFALSE 21541
// if Prob ( 60 ) then
21516: LD_INT 60
21518: PPUSH
21519: CALL_OW 13
21523: IFFALSE 21539
// SetSide ( i , side ) ;
21525: LD_VAR 0 1
21529: PPUSH
21530: LD_VAR 0 3
21534: PPUSH
21535: CALL_OW 235
21539: GO 21513
21541: POP
21542: POP
// end ;
21543: PPOPN 3
21545: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
21546: LD_EXP 40
21550: PUSH
21551: LD_EXP 53
21555: AND
21556: IFFALSE 21675
21558: GO 21560
21560: DISABLE
21561: LD_INT 0
21563: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
21564: LD_ADDR_VAR 0 1
21568: PUSH
21569: LD_INT 22
21571: PUSH
21572: LD_OWVAR 2
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: PUSH
21581: LD_INT 21
21583: PUSH
21584: LD_INT 1
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PUSH
21591: LD_INT 3
21593: PUSH
21594: LD_INT 23
21596: PUSH
21597: LD_INT 0
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: EMPTY
21605: LIST
21606: LIST
21607: PUSH
21608: EMPTY
21609: LIST
21610: LIST
21611: LIST
21612: PPUSH
21613: CALL_OW 69
21617: PUSH
21618: FOR_IN
21619: IFFALSE 21673
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
21621: LD_VAR 0 1
21625: PPUSH
21626: CALL_OW 257
21630: PUSH
21631: LD_INT 1
21633: PUSH
21634: LD_INT 2
21636: PUSH
21637: LD_INT 3
21639: PUSH
21640: LD_INT 4
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: IN
21649: IFFALSE 21671
// SetClass ( un , rand ( 1 , 4 ) ) ;
21651: LD_VAR 0 1
21655: PPUSH
21656: LD_INT 1
21658: PPUSH
21659: LD_INT 4
21661: PPUSH
21662: CALL_OW 12
21666: PPUSH
21667: CALL_OW 336
21671: GO 21618
21673: POP
21674: POP
// end ;
21675: PPOPN 1
21677: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
21678: LD_EXP 40
21682: PUSH
21683: LD_EXP 52
21687: AND
21688: IFFALSE 21767
21690: GO 21692
21692: DISABLE
21693: LD_INT 0
21695: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21696: LD_ADDR_VAR 0 1
21700: PUSH
21701: LD_INT 22
21703: PUSH
21704: LD_OWVAR 2
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PUSH
21713: LD_INT 21
21715: PUSH
21716: LD_INT 3
21718: PUSH
21719: EMPTY
21720: LIST
21721: LIST
21722: PUSH
21723: EMPTY
21724: LIST
21725: LIST
21726: PPUSH
21727: CALL_OW 69
21731: ST_TO_ADDR
// if not tmp then
21732: LD_VAR 0 1
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 21767
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
21741: LD_VAR 0 1
21745: PUSH
21746: LD_INT 1
21748: PPUSH
21749: LD_VAR 0 1
21753: PPUSH
21754: CALL_OW 12
21758: ARRAY
21759: PPUSH
21760: LD_INT 100
21762: PPUSH
21763: CALL_OW 234
// end ;
21767: PPOPN 1
21769: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
21770: LD_EXP 40
21774: PUSH
21775: LD_EXP 54
21779: AND
21780: IFFALSE 21878
21782: GO 21784
21784: DISABLE
21785: LD_INT 0
21787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
21788: LD_ADDR_VAR 0 1
21792: PUSH
21793: LD_INT 22
21795: PUSH
21796: LD_OWVAR 2
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PUSH
21805: LD_INT 21
21807: PUSH
21808: LD_INT 1
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: PPUSH
21819: CALL_OW 69
21823: ST_TO_ADDR
// if not tmp then
21824: LD_VAR 0 1
21828: NOT
21829: IFFALSE 21833
// exit ;
21831: GO 21878
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
21833: LD_VAR 0 1
21837: PUSH
21838: LD_INT 1
21840: PPUSH
21841: LD_VAR 0 1
21845: PPUSH
21846: CALL_OW 12
21850: ARRAY
21851: PPUSH
21852: LD_INT 1
21854: PPUSH
21855: LD_INT 4
21857: PPUSH
21858: CALL_OW 12
21862: PPUSH
21863: LD_INT 3000
21865: PPUSH
21866: LD_INT 9000
21868: PPUSH
21869: CALL_OW 12
21873: PPUSH
21874: CALL_OW 492
// end ;
21878: PPOPN 1
21880: END
// every 0 0$1 trigger StreamModeActive and sDepot do
21881: LD_EXP 40
21885: PUSH
21886: LD_EXP 55
21890: AND
21891: IFFALSE 21911
21893: GO 21895
21895: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
21896: LD_INT 1
21898: PPUSH
21899: LD_OWVAR 2
21903: PPUSH
21904: LD_INT 0
21906: PPUSH
21907: CALL_OW 324
21911: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
21912: LD_EXP 40
21916: PUSH
21917: LD_EXP 56
21921: AND
21922: IFFALSE 22005
21924: GO 21926
21926: DISABLE
21927: LD_INT 0
21929: PPUSH
21930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
21931: LD_ADDR_VAR 0 2
21935: PUSH
21936: LD_INT 22
21938: PUSH
21939: LD_OWVAR 2
21943: PUSH
21944: EMPTY
21945: LIST
21946: LIST
21947: PUSH
21948: LD_INT 21
21950: PUSH
21951: LD_INT 3
21953: PUSH
21954: EMPTY
21955: LIST
21956: LIST
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PPUSH
21962: CALL_OW 69
21966: ST_TO_ADDR
// if not tmp then
21967: LD_VAR 0 2
21971: NOT
21972: IFFALSE 21976
// exit ;
21974: GO 22005
// for i in tmp do
21976: LD_ADDR_VAR 0 1
21980: PUSH
21981: LD_VAR 0 2
21985: PUSH
21986: FOR_IN
21987: IFFALSE 22003
// SetBLevel ( i , 10 ) ;
21989: LD_VAR 0 1
21993: PPUSH
21994: LD_INT 10
21996: PPUSH
21997: CALL_OW 241
22001: GO 21986
22003: POP
22004: POP
// end ;
22005: PPOPN 2
22007: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
22008: LD_EXP 40
22012: PUSH
22013: LD_EXP 57
22017: AND
22018: IFFALSE 22129
22020: GO 22022
22022: DISABLE
22023: LD_INT 0
22025: PPUSH
22026: PPUSH
22027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22028: LD_ADDR_VAR 0 3
22032: PUSH
22033: LD_INT 22
22035: PUSH
22036: LD_OWVAR 2
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: LD_INT 25
22047: PUSH
22048: LD_INT 1
22050: PUSH
22051: EMPTY
22052: LIST
22053: LIST
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PPUSH
22059: CALL_OW 69
22063: ST_TO_ADDR
// if not tmp then
22064: LD_VAR 0 3
22068: NOT
22069: IFFALSE 22073
// exit ;
22071: GO 22129
// un := tmp [ rand ( 1 , tmp ) ] ;
22073: LD_ADDR_VAR 0 2
22077: PUSH
22078: LD_VAR 0 3
22082: PUSH
22083: LD_INT 1
22085: PPUSH
22086: LD_VAR 0 3
22090: PPUSH
22091: CALL_OW 12
22095: ARRAY
22096: ST_TO_ADDR
// if Crawls ( un ) then
22097: LD_VAR 0 2
22101: PPUSH
22102: CALL_OW 318
22106: IFFALSE 22117
// ComWalk ( un ) ;
22108: LD_VAR 0 2
22112: PPUSH
22113: CALL_OW 138
// SetClass ( un , class_sniper ) ;
22117: LD_VAR 0 2
22121: PPUSH
22122: LD_INT 5
22124: PPUSH
22125: CALL_OW 336
// end ;
22129: PPOPN 3
22131: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
22132: LD_EXP 40
22136: PUSH
22137: LD_EXP 58
22141: AND
22142: PUSH
22143: LD_OWVAR 67
22147: PUSH
22148: LD_INT 3
22150: LESS
22151: AND
22152: IFFALSE 22171
22154: GO 22156
22156: DISABLE
// Difficulty := Difficulty + 1 ;
22157: LD_ADDR_OWVAR 67
22161: PUSH
22162: LD_OWVAR 67
22166: PUSH
22167: LD_INT 1
22169: PLUS
22170: ST_TO_ADDR
22171: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
22172: LD_EXP 40
22176: PUSH
22177: LD_EXP 59
22181: AND
22182: IFFALSE 22285
22184: GO 22186
22186: DISABLE
22187: LD_INT 0
22189: PPUSH
// begin for i := 1 to 5 do
22190: LD_ADDR_VAR 0 1
22194: PUSH
22195: DOUBLE
22196: LD_INT 1
22198: DEC
22199: ST_TO_ADDR
22200: LD_INT 5
22202: PUSH
22203: FOR_TO
22204: IFFALSE 22283
// begin uc_nation := nation_nature ;
22206: LD_ADDR_OWVAR 21
22210: PUSH
22211: LD_INT 0
22213: ST_TO_ADDR
// uc_side := 0 ;
22214: LD_ADDR_OWVAR 20
22218: PUSH
22219: LD_INT 0
22221: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22222: LD_ADDR_OWVAR 29
22226: PUSH
22227: LD_INT 12
22229: PUSH
22230: LD_INT 12
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: ST_TO_ADDR
// hc_agressivity := 20 ;
22237: LD_ADDR_OWVAR 35
22241: PUSH
22242: LD_INT 20
22244: ST_TO_ADDR
// hc_class := class_tiger ;
22245: LD_ADDR_OWVAR 28
22249: PUSH
22250: LD_INT 14
22252: ST_TO_ADDR
// hc_gallery :=  ;
22253: LD_ADDR_OWVAR 33
22257: PUSH
22258: LD_STRING 
22260: ST_TO_ADDR
// hc_name :=  ;
22261: LD_ADDR_OWVAR 26
22265: PUSH
22266: LD_STRING 
22268: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
22269: CALL_OW 44
22273: PPUSH
22274: LD_INT 0
22276: PPUSH
22277: CALL_OW 51
// end ;
22281: GO 22203
22283: POP
22284: POP
// end ;
22285: PPOPN 1
22287: END
// every 0 0$1 trigger StreamModeActive and sBomb do
22288: LD_EXP 40
22292: PUSH
22293: LD_EXP 60
22297: AND
22298: IFFALSE 22307
22300: GO 22302
22302: DISABLE
// StreamSibBomb ;
22303: CALL 22308 0 0
22307: END
// export function StreamSibBomb ; var i , x , y ; begin
22308: LD_INT 0
22310: PPUSH
22311: PPUSH
22312: PPUSH
22313: PPUSH
// result := false ;
22314: LD_ADDR_VAR 0 1
22318: PUSH
22319: LD_INT 0
22321: ST_TO_ADDR
// for i := 1 to 16 do
22322: LD_ADDR_VAR 0 2
22326: PUSH
22327: DOUBLE
22328: LD_INT 1
22330: DEC
22331: ST_TO_ADDR
22332: LD_INT 16
22334: PUSH
22335: FOR_TO
22336: IFFALSE 22535
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22338: LD_ADDR_VAR 0 3
22342: PUSH
22343: LD_INT 10
22345: PUSH
22346: LD_INT 20
22348: PUSH
22349: LD_INT 30
22351: PUSH
22352: LD_INT 40
22354: PUSH
22355: LD_INT 50
22357: PUSH
22358: LD_INT 60
22360: PUSH
22361: LD_INT 70
22363: PUSH
22364: LD_INT 80
22366: PUSH
22367: LD_INT 90
22369: PUSH
22370: LD_INT 100
22372: PUSH
22373: LD_INT 110
22375: PUSH
22376: LD_INT 120
22378: PUSH
22379: LD_INT 130
22381: PUSH
22382: LD_INT 140
22384: PUSH
22385: LD_INT 150
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: LIST
22394: LIST
22395: LIST
22396: LIST
22397: LIST
22398: LIST
22399: LIST
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: PUSH
22405: LD_INT 1
22407: PPUSH
22408: LD_INT 15
22410: PPUSH
22411: CALL_OW 12
22415: ARRAY
22416: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
22417: LD_ADDR_VAR 0 4
22421: PUSH
22422: LD_INT 10
22424: PUSH
22425: LD_INT 20
22427: PUSH
22428: LD_INT 30
22430: PUSH
22431: LD_INT 40
22433: PUSH
22434: LD_INT 50
22436: PUSH
22437: LD_INT 60
22439: PUSH
22440: LD_INT 70
22442: PUSH
22443: LD_INT 80
22445: PUSH
22446: LD_INT 90
22448: PUSH
22449: LD_INT 100
22451: PUSH
22452: LD_INT 110
22454: PUSH
22455: LD_INT 120
22457: PUSH
22458: LD_INT 130
22460: PUSH
22461: LD_INT 140
22463: PUSH
22464: LD_INT 150
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: LIST
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: LIST
22476: LIST
22477: LIST
22478: LIST
22479: LIST
22480: LIST
22481: LIST
22482: LIST
22483: PUSH
22484: LD_INT 1
22486: PPUSH
22487: LD_INT 15
22489: PPUSH
22490: CALL_OW 12
22494: ARRAY
22495: ST_TO_ADDR
// if ValidHex ( x , y ) then
22496: LD_VAR 0 3
22500: PPUSH
22501: LD_VAR 0 4
22505: PPUSH
22506: CALL_OW 488
22510: IFFALSE 22533
// begin result := [ x , y ] ;
22512: LD_ADDR_VAR 0 1
22516: PUSH
22517: LD_VAR 0 3
22521: PUSH
22522: LD_VAR 0 4
22526: PUSH
22527: EMPTY
22528: LIST
22529: LIST
22530: ST_TO_ADDR
// break ;
22531: GO 22535
// end ; end ;
22533: GO 22335
22535: POP
22536: POP
// if result then
22537: LD_VAR 0 1
22541: IFFALSE 22601
// begin ToLua ( playSibBomb() ) ;
22543: LD_STRING playSibBomb()
22545: PPUSH
22546: CALL_OW 559
// wait ( 0 0$14 ) ;
22550: LD_INT 490
22552: PPUSH
22553: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
22557: LD_VAR 0 1
22561: PUSH
22562: LD_INT 1
22564: ARRAY
22565: PPUSH
22566: LD_VAR 0 1
22570: PUSH
22571: LD_INT 2
22573: ARRAY
22574: PPUSH
22575: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
22579: LD_VAR 0 1
22583: PUSH
22584: LD_INT 1
22586: ARRAY
22587: PPUSH
22588: LD_VAR 0 1
22592: PUSH
22593: LD_INT 2
22595: ARRAY
22596: PPUSH
22597: CALL_OW 429
// end ; end ;
22601: LD_VAR 0 1
22605: RET
// every 0 0$1 trigger StreamModeActive and sReset do
22606: LD_EXP 40
22610: PUSH
22611: LD_EXP 62
22615: AND
22616: IFFALSE 22628
22618: GO 22620
22620: DISABLE
// YouLost (  ) ;
22621: LD_STRING 
22623: PPUSH
22624: CALL_OW 104
22628: END
// every 0 0$1 trigger StreamModeActive and sFog do
22629: LD_EXP 40
22633: PUSH
22634: LD_EXP 61
22638: AND
22639: IFFALSE 22653
22641: GO 22643
22643: DISABLE
// FogOff ( your_side ) ;
22644: LD_OWVAR 2
22648: PPUSH
22649: CALL_OW 344
22653: END
// every 0 0$1 trigger StreamModeActive and sSun do
22654: LD_EXP 40
22658: PUSH
22659: LD_EXP 63
22663: AND
22664: IFFALSE 22692
22666: GO 22668
22668: DISABLE
// begin solar_recharge_percent := 0 ;
22669: LD_ADDR_OWVAR 79
22673: PUSH
22674: LD_INT 0
22676: ST_TO_ADDR
// wait ( 5 5$00 ) ;
22677: LD_INT 10500
22679: PPUSH
22680: CALL_OW 67
// solar_recharge_percent := 100 ;
22684: LD_ADDR_OWVAR 79
22688: PUSH
22689: LD_INT 100
22691: ST_TO_ADDR
// end ;
22692: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
22693: LD_EXP 40
22697: PUSH
22698: LD_EXP 64
22702: AND
22703: IFFALSE 22942
22705: GO 22707
22707: DISABLE
22708: LD_INT 0
22710: PPUSH
22711: PPUSH
22712: PPUSH
// begin tmp := [ ] ;
22713: LD_ADDR_VAR 0 3
22717: PUSH
22718: EMPTY
22719: ST_TO_ADDR
// for i := 1 to 6 do
22720: LD_ADDR_VAR 0 1
22724: PUSH
22725: DOUBLE
22726: LD_INT 1
22728: DEC
22729: ST_TO_ADDR
22730: LD_INT 6
22732: PUSH
22733: FOR_TO
22734: IFFALSE 22839
// begin uc_nation := nation_nature ;
22736: LD_ADDR_OWVAR 21
22740: PUSH
22741: LD_INT 0
22743: ST_TO_ADDR
// uc_side := 0 ;
22744: LD_ADDR_OWVAR 20
22748: PUSH
22749: LD_INT 0
22751: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
22752: LD_ADDR_OWVAR 29
22756: PUSH
22757: LD_INT 12
22759: PUSH
22760: LD_INT 12
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: ST_TO_ADDR
// hc_agressivity := 20 ;
22767: LD_ADDR_OWVAR 35
22771: PUSH
22772: LD_INT 20
22774: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
22775: LD_ADDR_OWVAR 28
22779: PUSH
22780: LD_INT 17
22782: ST_TO_ADDR
// hc_gallery :=  ;
22783: LD_ADDR_OWVAR 33
22787: PUSH
22788: LD_STRING 
22790: ST_TO_ADDR
// hc_name :=  ;
22791: LD_ADDR_OWVAR 26
22795: PUSH
22796: LD_STRING 
22798: ST_TO_ADDR
// un := CreateHuman ;
22799: LD_ADDR_VAR 0 2
22803: PUSH
22804: CALL_OW 44
22808: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
22809: LD_VAR 0 2
22813: PPUSH
22814: LD_INT 1
22816: PPUSH
22817: CALL_OW 51
// tmp := tmp ^ un ;
22821: LD_ADDR_VAR 0 3
22825: PUSH
22826: LD_VAR 0 3
22830: PUSH
22831: LD_VAR 0 2
22835: ADD
22836: ST_TO_ADDR
// end ;
22837: GO 22733
22839: POP
22840: POP
// repeat wait ( 0 0$1 ) ;
22841: LD_INT 35
22843: PPUSH
22844: CALL_OW 67
// for un in tmp do
22848: LD_ADDR_VAR 0 2
22852: PUSH
22853: LD_VAR 0 3
22857: PUSH
22858: FOR_IN
22859: IFFALSE 22933
// begin if IsDead ( un ) then
22861: LD_VAR 0 2
22865: PPUSH
22866: CALL_OW 301
22870: IFFALSE 22890
// begin tmp := tmp diff un ;
22872: LD_ADDR_VAR 0 3
22876: PUSH
22877: LD_VAR 0 3
22881: PUSH
22882: LD_VAR 0 2
22886: DIFF
22887: ST_TO_ADDR
// continue ;
22888: GO 22858
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
22890: LD_VAR 0 2
22894: PPUSH
22895: LD_INT 3
22897: PUSH
22898: LD_INT 22
22900: PUSH
22901: LD_INT 0
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PUSH
22908: EMPTY
22909: LIST
22910: LIST
22911: PPUSH
22912: CALL_OW 69
22916: PPUSH
22917: LD_VAR 0 2
22921: PPUSH
22922: CALL_OW 74
22926: PPUSH
22927: CALL_OW 115
// end ;
22931: GO 22858
22933: POP
22934: POP
// until not tmp ;
22935: LD_VAR 0 3
22939: NOT
22940: IFFALSE 22841
// end ;
22942: PPOPN 3
22944: END
// every 0 0$1 trigger StreamModeActive and sTroll do
22945: LD_EXP 40
22949: PUSH
22950: LD_EXP 65
22954: AND
22955: IFFALSE 23009
22957: GO 22959
22959: DISABLE
// begin ToLua ( displayTroll(); ) ;
22960: LD_STRING displayTroll();
22962: PPUSH
22963: CALL_OW 559
// wait ( 3 3$00 ) ;
22967: LD_INT 6300
22969: PPUSH
22970: CALL_OW 67
// ToLua ( hideTroll(); ) ;
22974: LD_STRING hideTroll();
22976: PPUSH
22977: CALL_OW 559
// wait ( 1 1$00 ) ;
22981: LD_INT 2100
22983: PPUSH
22984: CALL_OW 67
// ToLua ( displayTroll(); ) ;
22988: LD_STRING displayTroll();
22990: PPUSH
22991: CALL_OW 559
// wait ( 1 1$00 ) ;
22995: LD_INT 2100
22997: PPUSH
22998: CALL_OW 67
// ToLua ( hideTroll(); ) ;
23002: LD_STRING hideTroll();
23004: PPUSH
23005: CALL_OW 559
// end ;
23009: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
23010: LD_EXP 40
23014: PUSH
23015: LD_EXP 66
23019: AND
23020: IFFALSE 23083
23022: GO 23024
23024: DISABLE
23025: LD_INT 0
23027: PPUSH
// begin p := 0 ;
23028: LD_ADDR_VAR 0 1
23032: PUSH
23033: LD_INT 0
23035: ST_TO_ADDR
// repeat game_speed := 1 ;
23036: LD_ADDR_OWVAR 65
23040: PUSH
23041: LD_INT 1
23043: ST_TO_ADDR
// wait ( 0 0$1 ) ;
23044: LD_INT 35
23046: PPUSH
23047: CALL_OW 67
// p := p + 1 ;
23051: LD_ADDR_VAR 0 1
23055: PUSH
23056: LD_VAR 0 1
23060: PUSH
23061: LD_INT 1
23063: PLUS
23064: ST_TO_ADDR
// until p >= 60 ;
23065: LD_VAR 0 1
23069: PUSH
23070: LD_INT 60
23072: GREATEREQUAL
23073: IFFALSE 23036
// game_speed := 4 ;
23075: LD_ADDR_OWVAR 65
23079: PUSH
23080: LD_INT 4
23082: ST_TO_ADDR
// end ;
23083: PPOPN 1
23085: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
23086: LD_EXP 40
23090: PUSH
23091: LD_EXP 67
23095: AND
23096: IFFALSE 23242
23098: GO 23100
23100: DISABLE
23101: LD_INT 0
23103: PPUSH
23104: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23105: LD_ADDR_VAR 0 1
23109: PUSH
23110: LD_INT 22
23112: PUSH
23113: LD_OWVAR 2
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: PUSH
23122: LD_INT 2
23124: PUSH
23125: LD_INT 30
23127: PUSH
23128: LD_INT 0
23130: PUSH
23131: EMPTY
23132: LIST
23133: LIST
23134: PUSH
23135: LD_INT 30
23137: PUSH
23138: LD_INT 1
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: PUSH
23145: EMPTY
23146: LIST
23147: LIST
23148: LIST
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: PPUSH
23154: CALL_OW 69
23158: ST_TO_ADDR
// if not depot then
23159: LD_VAR 0 1
23163: NOT
23164: IFFALSE 23168
// exit ;
23166: GO 23242
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
23168: LD_ADDR_VAR 0 2
23172: PUSH
23173: LD_VAR 0 1
23177: PUSH
23178: LD_INT 1
23180: PPUSH
23181: LD_VAR 0 1
23185: PPUSH
23186: CALL_OW 12
23190: ARRAY
23191: PPUSH
23192: CALL_OW 274
23196: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
23197: LD_VAR 0 2
23201: PPUSH
23202: LD_INT 1
23204: PPUSH
23205: LD_INT 0
23207: PPUSH
23208: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
23212: LD_VAR 0 2
23216: PPUSH
23217: LD_INT 2
23219: PPUSH
23220: LD_INT 0
23222: PPUSH
23223: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
23227: LD_VAR 0 2
23231: PPUSH
23232: LD_INT 3
23234: PPUSH
23235: LD_INT 0
23237: PPUSH
23238: CALL_OW 277
// end ;
23242: PPOPN 2
23244: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
23245: LD_EXP 40
23249: PUSH
23250: LD_EXP 68
23254: AND
23255: IFFALSE 23352
23257: GO 23259
23259: DISABLE
23260: LD_INT 0
23262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
23263: LD_ADDR_VAR 0 1
23267: PUSH
23268: LD_INT 22
23270: PUSH
23271: LD_OWVAR 2
23275: PUSH
23276: EMPTY
23277: LIST
23278: LIST
23279: PUSH
23280: LD_INT 21
23282: PUSH
23283: LD_INT 1
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PUSH
23290: LD_INT 3
23292: PUSH
23293: LD_INT 23
23295: PUSH
23296: LD_INT 0
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: LIST
23311: PPUSH
23312: CALL_OW 69
23316: ST_TO_ADDR
// if not tmp then
23317: LD_VAR 0 1
23321: NOT
23322: IFFALSE 23326
// exit ;
23324: GO 23352
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
23326: LD_VAR 0 1
23330: PUSH
23331: LD_INT 1
23333: PPUSH
23334: LD_VAR 0 1
23338: PPUSH
23339: CALL_OW 12
23343: ARRAY
23344: PPUSH
23345: LD_INT 200
23347: PPUSH
23348: CALL_OW 234
// end ;
23352: PPOPN 1
23354: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
23355: LD_EXP 40
23359: PUSH
23360: LD_EXP 69
23364: AND
23365: IFFALSE 23444
23367: GO 23369
23369: DISABLE
23370: LD_INT 0
23372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
23373: LD_ADDR_VAR 0 1
23377: PUSH
23378: LD_INT 22
23380: PUSH
23381: LD_OWVAR 2
23385: PUSH
23386: EMPTY
23387: LIST
23388: LIST
23389: PUSH
23390: LD_INT 21
23392: PUSH
23393: LD_INT 2
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: PPUSH
23404: CALL_OW 69
23408: ST_TO_ADDR
// if not tmp then
23409: LD_VAR 0 1
23413: NOT
23414: IFFALSE 23418
// exit ;
23416: GO 23444
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
23418: LD_VAR 0 1
23422: PUSH
23423: LD_INT 1
23425: PPUSH
23426: LD_VAR 0 1
23430: PPUSH
23431: CALL_OW 12
23435: ARRAY
23436: PPUSH
23437: LD_INT 60
23439: PPUSH
23440: CALL_OW 234
// end ;
23444: PPOPN 1
23446: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
23447: LD_EXP 40
23451: PUSH
23452: LD_EXP 70
23456: AND
23457: IFFALSE 23556
23459: GO 23461
23461: DISABLE
23462: LD_INT 0
23464: PPUSH
23465: PPUSH
// begin enable ;
23466: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
23467: LD_ADDR_VAR 0 1
23471: PUSH
23472: LD_INT 22
23474: PUSH
23475: LD_OWVAR 2
23479: PUSH
23480: EMPTY
23481: LIST
23482: LIST
23483: PUSH
23484: LD_INT 61
23486: PUSH
23487: EMPTY
23488: LIST
23489: PUSH
23490: LD_INT 33
23492: PUSH
23493: LD_INT 2
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: LIST
23504: PPUSH
23505: CALL_OW 69
23509: ST_TO_ADDR
// if not tmp then
23510: LD_VAR 0 1
23514: NOT
23515: IFFALSE 23519
// exit ;
23517: GO 23556
// for i in tmp do
23519: LD_ADDR_VAR 0 2
23523: PUSH
23524: LD_VAR 0 1
23528: PUSH
23529: FOR_IN
23530: IFFALSE 23554
// if IsControledBy ( i ) then
23532: LD_VAR 0 2
23536: PPUSH
23537: CALL_OW 312
23541: IFFALSE 23552
// ComUnlink ( i ) ;
23543: LD_VAR 0 2
23547: PPUSH
23548: CALL_OW 136
23552: GO 23529
23554: POP
23555: POP
// end ;
23556: PPOPN 2
23558: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
23559: LD_EXP 40
23563: PUSH
23564: LD_EXP 71
23568: AND
23569: IFFALSE 23709
23571: GO 23573
23573: DISABLE
23574: LD_INT 0
23576: PPUSH
23577: PPUSH
// begin ToLua ( displayPowell(); ) ;
23578: LD_STRING displayPowell();
23580: PPUSH
23581: CALL_OW 559
// uc_side := 0 ;
23585: LD_ADDR_OWVAR 20
23589: PUSH
23590: LD_INT 0
23592: ST_TO_ADDR
// uc_nation := 2 ;
23593: LD_ADDR_OWVAR 21
23597: PUSH
23598: LD_INT 2
23600: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
23601: LD_ADDR_OWVAR 37
23605: PUSH
23606: LD_INT 14
23608: ST_TO_ADDR
// vc_engine := engine_siberite ;
23609: LD_ADDR_OWVAR 39
23613: PUSH
23614: LD_INT 3
23616: ST_TO_ADDR
// vc_control := control_apeman ;
23617: LD_ADDR_OWVAR 38
23621: PUSH
23622: LD_INT 5
23624: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
23625: LD_ADDR_OWVAR 40
23629: PUSH
23630: LD_INT 29
23632: ST_TO_ADDR
// un := CreateVehicle ;
23633: LD_ADDR_VAR 0 2
23637: PUSH
23638: CALL_OW 45
23642: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23643: LD_VAR 0 2
23647: PPUSH
23648: LD_INT 1
23650: PPUSH
23651: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
23655: LD_INT 35
23657: PPUSH
23658: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
23662: LD_VAR 0 2
23666: PPUSH
23667: LD_INT 22
23669: PUSH
23670: LD_OWVAR 2
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: PPUSH
23679: CALL_OW 69
23683: PPUSH
23684: LD_VAR 0 2
23688: PPUSH
23689: CALL_OW 74
23693: PPUSH
23694: CALL_OW 115
// until IsDead ( un ) ;
23698: LD_VAR 0 2
23702: PPUSH
23703: CALL_OW 301
23707: IFFALSE 23655
// end ;
23709: PPOPN 2
23711: END
// every 0 0$1 trigger StreamModeActive and sStu do
23712: LD_EXP 40
23716: PUSH
23717: LD_EXP 79
23721: AND
23722: IFFALSE 23738
23724: GO 23726
23726: DISABLE
// begin ToLua ( displayStucuk(); ) ;
23727: LD_STRING displayStucuk();
23729: PPUSH
23730: CALL_OW 559
// ResetFog ;
23734: CALL_OW 335
// end ;
23738: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
23739: LD_EXP 40
23743: PUSH
23744: LD_EXP 72
23748: AND
23749: IFFALSE 23890
23751: GO 23753
23753: DISABLE
23754: LD_INT 0
23756: PPUSH
23757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
23758: LD_ADDR_VAR 0 2
23762: PUSH
23763: LD_INT 22
23765: PUSH
23766: LD_OWVAR 2
23770: PUSH
23771: EMPTY
23772: LIST
23773: LIST
23774: PUSH
23775: LD_INT 21
23777: PUSH
23778: LD_INT 1
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: PPUSH
23789: CALL_OW 69
23793: ST_TO_ADDR
// if not tmp then
23794: LD_VAR 0 2
23798: NOT
23799: IFFALSE 23803
// exit ;
23801: GO 23890
// un := tmp [ rand ( 1 , tmp ) ] ;
23803: LD_ADDR_VAR 0 1
23807: PUSH
23808: LD_VAR 0 2
23812: PUSH
23813: LD_INT 1
23815: PPUSH
23816: LD_VAR 0 2
23820: PPUSH
23821: CALL_OW 12
23825: ARRAY
23826: ST_TO_ADDR
// SetSide ( un , 0 ) ;
23827: LD_VAR 0 1
23831: PPUSH
23832: LD_INT 0
23834: PPUSH
23835: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_OWVAR 3
23848: PUSH
23849: LD_VAR 0 1
23853: DIFF
23854: PPUSH
23855: LD_VAR 0 1
23859: PPUSH
23860: CALL_OW 74
23864: PPUSH
23865: CALL_OW 115
// wait ( 0 0$20 ) ;
23869: LD_INT 700
23871: PPUSH
23872: CALL_OW 67
// SetSide ( un , your_side ) ;
23876: LD_VAR 0 1
23880: PPUSH
23881: LD_OWVAR 2
23885: PPUSH
23886: CALL_OW 235
// end ;
23890: PPOPN 2
23892: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
23893: LD_EXP 40
23897: PUSH
23898: LD_EXP 73
23902: AND
23903: IFFALSE 24009
23905: GO 23907
23907: DISABLE
23908: LD_INT 0
23910: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23911: LD_ADDR_VAR 0 1
23915: PUSH
23916: LD_INT 22
23918: PUSH
23919: LD_OWVAR 2
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 2
23930: PUSH
23931: LD_INT 30
23933: PUSH
23934: LD_INT 0
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: LD_INT 30
23943: PUSH
23944: LD_INT 1
23946: PUSH
23947: EMPTY
23948: LIST
23949: LIST
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: LIST
23955: PUSH
23956: EMPTY
23957: LIST
23958: LIST
23959: PPUSH
23960: CALL_OW 69
23964: ST_TO_ADDR
// if not depot then
23965: LD_VAR 0 1
23969: NOT
23970: IFFALSE 23974
// exit ;
23972: GO 24009
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
23974: LD_VAR 0 1
23978: PUSH
23979: LD_INT 1
23981: ARRAY
23982: PPUSH
23983: CALL_OW 250
23987: PPUSH
23988: LD_VAR 0 1
23992: PUSH
23993: LD_INT 1
23995: ARRAY
23996: PPUSH
23997: CALL_OW 251
24001: PPUSH
24002: LD_INT 70
24004: PPUSH
24005: CALL_OW 495
// end ;
24009: PPOPN 1
24011: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
24012: LD_EXP 40
24016: PUSH
24017: LD_EXP 74
24021: AND
24022: IFFALSE 24233
24024: GO 24026
24026: DISABLE
24027: LD_INT 0
24029: PPUSH
24030: PPUSH
24031: PPUSH
24032: PPUSH
24033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
24034: LD_ADDR_VAR 0 5
24038: PUSH
24039: LD_INT 22
24041: PUSH
24042: LD_OWVAR 2
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: PUSH
24051: LD_INT 21
24053: PUSH
24054: LD_INT 1
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PPUSH
24065: CALL_OW 69
24069: ST_TO_ADDR
// if not tmp then
24070: LD_VAR 0 5
24074: NOT
24075: IFFALSE 24079
// exit ;
24077: GO 24233
// for i in tmp do
24079: LD_ADDR_VAR 0 1
24083: PUSH
24084: LD_VAR 0 5
24088: PUSH
24089: FOR_IN
24090: IFFALSE 24231
// begin d := rand ( 0 , 5 ) ;
24092: LD_ADDR_VAR 0 4
24096: PUSH
24097: LD_INT 0
24099: PPUSH
24100: LD_INT 5
24102: PPUSH
24103: CALL_OW 12
24107: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
24108: LD_ADDR_VAR 0 2
24112: PUSH
24113: LD_VAR 0 1
24117: PPUSH
24118: CALL_OW 250
24122: PPUSH
24123: LD_VAR 0 4
24127: PPUSH
24128: LD_INT 3
24130: PPUSH
24131: LD_INT 12
24133: PPUSH
24134: CALL_OW 12
24138: PPUSH
24139: CALL_OW 272
24143: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_VAR 0 1
24153: PPUSH
24154: CALL_OW 251
24158: PPUSH
24159: LD_VAR 0 4
24163: PPUSH
24164: LD_INT 3
24166: PPUSH
24167: LD_INT 12
24169: PPUSH
24170: CALL_OW 12
24174: PPUSH
24175: CALL_OW 273
24179: ST_TO_ADDR
// if ValidHex ( x , y ) then
24180: LD_VAR 0 2
24184: PPUSH
24185: LD_VAR 0 3
24189: PPUSH
24190: CALL_OW 488
24194: IFFALSE 24229
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
24196: LD_VAR 0 1
24200: PPUSH
24201: LD_VAR 0 2
24205: PPUSH
24206: LD_VAR 0 3
24210: PPUSH
24211: LD_INT 3
24213: PPUSH
24214: LD_INT 6
24216: PPUSH
24217: CALL_OW 12
24221: PPUSH
24222: LD_INT 1
24224: PPUSH
24225: CALL_OW 483
// end ;
24229: GO 24089
24231: POP
24232: POP
// end ;
24233: PPOPN 5
24235: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
24236: LD_EXP 40
24240: PUSH
24241: LD_EXP 75
24245: AND
24246: IFFALSE 24340
24248: GO 24250
24250: DISABLE
24251: LD_INT 0
24253: PPUSH
24254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
24255: LD_ADDR_VAR 0 2
24259: PUSH
24260: LD_INT 22
24262: PUSH
24263: LD_OWVAR 2
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: PUSH
24272: LD_INT 32
24274: PUSH
24275: LD_INT 1
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 21
24284: PUSH
24285: LD_INT 2
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL_OW 69
24301: ST_TO_ADDR
// if not tmp then
24302: LD_VAR 0 2
24306: NOT
24307: IFFALSE 24311
// exit ;
24309: GO 24340
// for i in tmp do
24311: LD_ADDR_VAR 0 1
24315: PUSH
24316: LD_VAR 0 2
24320: PUSH
24321: FOR_IN
24322: IFFALSE 24338
// SetFuel ( i , 0 ) ;
24324: LD_VAR 0 1
24328: PPUSH
24329: LD_INT 0
24331: PPUSH
24332: CALL_OW 240
24336: GO 24321
24338: POP
24339: POP
// end ;
24340: PPOPN 2
24342: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
24343: LD_EXP 40
24347: PUSH
24348: LD_EXP 76
24352: AND
24353: IFFALSE 24419
24355: GO 24357
24357: DISABLE
24358: LD_INT 0
24360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
24361: LD_ADDR_VAR 0 1
24365: PUSH
24366: LD_INT 22
24368: PUSH
24369: LD_OWVAR 2
24373: PUSH
24374: EMPTY
24375: LIST
24376: LIST
24377: PUSH
24378: LD_INT 30
24380: PUSH
24381: LD_INT 29
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PPUSH
24392: CALL_OW 69
24396: ST_TO_ADDR
// if not tmp then
24397: LD_VAR 0 1
24401: NOT
24402: IFFALSE 24406
// exit ;
24404: GO 24419
// DestroyUnit ( tmp [ 1 ] ) ;
24406: LD_VAR 0 1
24410: PUSH
24411: LD_INT 1
24413: ARRAY
24414: PPUSH
24415: CALL_OW 65
// end ;
24419: PPOPN 1
24421: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
24422: LD_EXP 40
24426: PUSH
24427: LD_EXP 78
24431: AND
24432: IFFALSE 24561
24434: GO 24436
24436: DISABLE
24437: LD_INT 0
24439: PPUSH
// begin uc_side := 0 ;
24440: LD_ADDR_OWVAR 20
24444: PUSH
24445: LD_INT 0
24447: ST_TO_ADDR
// uc_nation := nation_arabian ;
24448: LD_ADDR_OWVAR 21
24452: PUSH
24453: LD_INT 2
24455: ST_TO_ADDR
// hc_gallery :=  ;
24456: LD_ADDR_OWVAR 33
24460: PUSH
24461: LD_STRING 
24463: ST_TO_ADDR
// hc_name :=  ;
24464: LD_ADDR_OWVAR 26
24468: PUSH
24469: LD_STRING 
24471: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
24472: LD_INT 1
24474: PPUSH
24475: LD_INT 11
24477: PPUSH
24478: LD_INT 10
24480: PPUSH
24481: CALL_OW 380
// un := CreateHuman ;
24485: LD_ADDR_VAR 0 1
24489: PUSH
24490: CALL_OW 44
24494: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
24495: LD_VAR 0 1
24499: PPUSH
24500: LD_INT 1
24502: PPUSH
24503: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
24507: LD_INT 35
24509: PPUSH
24510: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
24514: LD_VAR 0 1
24518: PPUSH
24519: LD_INT 22
24521: PUSH
24522: LD_OWVAR 2
24526: PUSH
24527: EMPTY
24528: LIST
24529: LIST
24530: PPUSH
24531: CALL_OW 69
24535: PPUSH
24536: LD_VAR 0 1
24540: PPUSH
24541: CALL_OW 74
24545: PPUSH
24546: CALL_OW 115
// until IsDead ( un ) ;
24550: LD_VAR 0 1
24554: PPUSH
24555: CALL_OW 301
24559: IFFALSE 24507
// end ;
24561: PPOPN 1
24563: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
24564: LD_EXP 40
24568: PUSH
24569: LD_EXP 80
24573: AND
24574: IFFALSE 24586
24576: GO 24578
24578: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
24579: LD_STRING earthquake(getX(game), 0, 32)
24581: PPUSH
24582: CALL_OW 559
24586: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
24587: LD_EXP 40
24591: PUSH
24592: LD_EXP 81
24596: AND
24597: IFFALSE 24688
24599: GO 24601
24601: DISABLE
24602: LD_INT 0
24604: PPUSH
// begin enable ;
24605: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_OWVAR 2
24618: PUSH
24619: EMPTY
24620: LIST
24621: LIST
24622: PUSH
24623: LD_INT 21
24625: PUSH
24626: LD_INT 2
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: LD_INT 33
24635: PUSH
24636: LD_INT 3
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: PPUSH
24648: CALL_OW 69
24652: ST_TO_ADDR
// if not tmp then
24653: LD_VAR 0 1
24657: NOT
24658: IFFALSE 24662
// exit ;
24660: GO 24688
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
24662: LD_VAR 0 1
24666: PUSH
24667: LD_INT 1
24669: PPUSH
24670: LD_VAR 0 1
24674: PPUSH
24675: CALL_OW 12
24679: ARRAY
24680: PPUSH
24681: LD_INT 1
24683: PPUSH
24684: CALL_OW 234
// end ;
24688: PPOPN 1
24690: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
24691: LD_EXP 40
24695: PUSH
24696: LD_EXP 82
24700: AND
24701: IFFALSE 24842
24703: GO 24705
24705: DISABLE
24706: LD_INT 0
24708: PPUSH
24709: PPUSH
24710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24711: LD_ADDR_VAR 0 3
24715: PUSH
24716: LD_INT 22
24718: PUSH
24719: LD_OWVAR 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 25
24730: PUSH
24731: LD_INT 1
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PPUSH
24742: CALL_OW 69
24746: ST_TO_ADDR
// if not tmp then
24747: LD_VAR 0 3
24751: NOT
24752: IFFALSE 24756
// exit ;
24754: GO 24842
// un := tmp [ rand ( 1 , tmp ) ] ;
24756: LD_ADDR_VAR 0 2
24760: PUSH
24761: LD_VAR 0 3
24765: PUSH
24766: LD_INT 1
24768: PPUSH
24769: LD_VAR 0 3
24773: PPUSH
24774: CALL_OW 12
24778: ARRAY
24779: ST_TO_ADDR
// if Crawls ( un ) then
24780: LD_VAR 0 2
24784: PPUSH
24785: CALL_OW 318
24789: IFFALSE 24800
// ComWalk ( un ) ;
24791: LD_VAR 0 2
24795: PPUSH
24796: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
24800: LD_VAR 0 2
24804: PPUSH
24805: LD_INT 9
24807: PPUSH
24808: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
24812: LD_INT 28
24814: PPUSH
24815: LD_OWVAR 2
24819: PPUSH
24820: LD_INT 2
24822: PPUSH
24823: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
24827: LD_INT 29
24829: PPUSH
24830: LD_OWVAR 2
24834: PPUSH
24835: LD_INT 2
24837: PPUSH
24838: CALL_OW 322
// end ;
24842: PPOPN 3
24844: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
24845: LD_EXP 40
24849: PUSH
24850: LD_EXP 83
24854: AND
24855: IFFALSE 24966
24857: GO 24859
24859: DISABLE
24860: LD_INT 0
24862: PPUSH
24863: PPUSH
24864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
24865: LD_ADDR_VAR 0 3
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_OWVAR 2
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PUSH
24882: LD_INT 25
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PPUSH
24896: CALL_OW 69
24900: ST_TO_ADDR
// if not tmp then
24901: LD_VAR 0 3
24905: NOT
24906: IFFALSE 24910
// exit ;
24908: GO 24966
// un := tmp [ rand ( 1 , tmp ) ] ;
24910: LD_ADDR_VAR 0 2
24914: PUSH
24915: LD_VAR 0 3
24919: PUSH
24920: LD_INT 1
24922: PPUSH
24923: LD_VAR 0 3
24927: PPUSH
24928: CALL_OW 12
24932: ARRAY
24933: ST_TO_ADDR
// if Crawls ( un ) then
24934: LD_VAR 0 2
24938: PPUSH
24939: CALL_OW 318
24943: IFFALSE 24954
// ComWalk ( un ) ;
24945: LD_VAR 0 2
24949: PPUSH
24950: CALL_OW 138
// SetClass ( un , class_mortar ) ;
24954: LD_VAR 0 2
24958: PPUSH
24959: LD_INT 8
24961: PPUSH
24962: CALL_OW 336
// end ;
24966: PPOPN 3
24968: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
24969: LD_EXP 40
24973: PUSH
24974: LD_EXP 84
24978: AND
24979: IFFALSE 25123
24981: GO 24983
24983: DISABLE
24984: LD_INT 0
24986: PPUSH
24987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
24988: LD_ADDR_VAR 0 2
24992: PUSH
24993: LD_INT 22
24995: PUSH
24996: LD_OWVAR 2
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: PUSH
25005: LD_INT 21
25007: PUSH
25008: LD_INT 2
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 2
25017: PUSH
25018: LD_INT 34
25020: PUSH
25021: LD_INT 12
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: LD_INT 34
25030: PUSH
25031: LD_INT 51
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 34
25040: PUSH
25041: LD_INT 32
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: LIST
25058: PPUSH
25059: CALL_OW 69
25063: ST_TO_ADDR
// if not tmp then
25064: LD_VAR 0 2
25068: NOT
25069: IFFALSE 25073
// exit ;
25071: GO 25123
// for i in tmp do
25073: LD_ADDR_VAR 0 1
25077: PUSH
25078: LD_VAR 0 2
25082: PUSH
25083: FOR_IN
25084: IFFALSE 25121
// if GetCargo ( i , mat_artifact ) = 0 then
25086: LD_VAR 0 1
25090: PPUSH
25091: LD_INT 4
25093: PPUSH
25094: CALL_OW 289
25098: PUSH
25099: LD_INT 0
25101: EQUAL
25102: IFFALSE 25119
// SetCargo ( i , mat_siberit , 100 ) ;
25104: LD_VAR 0 1
25108: PPUSH
25109: LD_INT 3
25111: PPUSH
25112: LD_INT 100
25114: PPUSH
25115: CALL_OW 290
25119: GO 25083
25121: POP
25122: POP
// end ;
25123: PPOPN 2
25125: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
25126: LD_EXP 40
25130: PUSH
25131: LD_EXP 85
25135: AND
25136: IFFALSE 25289
25138: GO 25140
25140: DISABLE
25141: LD_INT 0
25143: PPUSH
25144: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
25145: LD_ADDR_VAR 0 2
25149: PUSH
25150: LD_INT 22
25152: PUSH
25153: LD_OWVAR 2
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PPUSH
25162: CALL_OW 69
25166: ST_TO_ADDR
// if not tmp then
25167: LD_VAR 0 2
25171: NOT
25172: IFFALSE 25176
// exit ;
25174: GO 25289
// for i := 1 to 2 do
25176: LD_ADDR_VAR 0 1
25180: PUSH
25181: DOUBLE
25182: LD_INT 1
25184: DEC
25185: ST_TO_ADDR
25186: LD_INT 2
25188: PUSH
25189: FOR_TO
25190: IFFALSE 25287
// begin uc_side := your_side ;
25192: LD_ADDR_OWVAR 20
25196: PUSH
25197: LD_OWVAR 2
25201: ST_TO_ADDR
// uc_nation := nation_american ;
25202: LD_ADDR_OWVAR 21
25206: PUSH
25207: LD_INT 1
25209: ST_TO_ADDR
// vc_chassis := us_morphling ;
25210: LD_ADDR_OWVAR 37
25214: PUSH
25215: LD_INT 5
25217: ST_TO_ADDR
// vc_engine := engine_siberite ;
25218: LD_ADDR_OWVAR 39
25222: PUSH
25223: LD_INT 3
25225: ST_TO_ADDR
// vc_control := control_computer ;
25226: LD_ADDR_OWVAR 38
25230: PUSH
25231: LD_INT 3
25233: ST_TO_ADDR
// vc_weapon := us_double_laser ;
25234: LD_ADDR_OWVAR 40
25238: PUSH
25239: LD_INT 10
25241: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
25242: CALL_OW 45
25246: PPUSH
25247: LD_VAR 0 2
25251: PUSH
25252: LD_INT 1
25254: ARRAY
25255: PPUSH
25256: CALL_OW 250
25260: PPUSH
25261: LD_VAR 0 2
25265: PUSH
25266: LD_INT 1
25268: ARRAY
25269: PPUSH
25270: CALL_OW 251
25274: PPUSH
25275: LD_INT 12
25277: PPUSH
25278: LD_INT 1
25280: PPUSH
25281: CALL_OW 50
// end ;
25285: GO 25189
25287: POP
25288: POP
// end ;
25289: PPOPN 2
25291: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
25292: LD_EXP 40
25296: PUSH
25297: LD_EXP 86
25301: AND
25302: IFFALSE 25524
25304: GO 25306
25306: DISABLE
25307: LD_INT 0
25309: PPUSH
25310: PPUSH
25311: PPUSH
25312: PPUSH
25313: PPUSH
25314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
25315: LD_ADDR_VAR 0 6
25319: PUSH
25320: LD_INT 22
25322: PUSH
25323: LD_OWVAR 2
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: PUSH
25332: LD_INT 21
25334: PUSH
25335: LD_INT 1
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: PUSH
25342: LD_INT 3
25344: PUSH
25345: LD_INT 23
25347: PUSH
25348: LD_INT 0
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: LIST
25363: PPUSH
25364: CALL_OW 69
25368: ST_TO_ADDR
// if not tmp then
25369: LD_VAR 0 6
25373: NOT
25374: IFFALSE 25378
// exit ;
25376: GO 25524
// s1 := rand ( 1 , 4 ) ;
25378: LD_ADDR_VAR 0 2
25382: PUSH
25383: LD_INT 1
25385: PPUSH
25386: LD_INT 4
25388: PPUSH
25389: CALL_OW 12
25393: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
25394: LD_ADDR_VAR 0 4
25398: PUSH
25399: LD_VAR 0 6
25403: PUSH
25404: LD_INT 1
25406: ARRAY
25407: PPUSH
25408: LD_VAR 0 2
25412: PPUSH
25413: CALL_OW 259
25417: ST_TO_ADDR
// if s1 = 1 then
25418: LD_VAR 0 2
25422: PUSH
25423: LD_INT 1
25425: EQUAL
25426: IFFALSE 25446
// s2 := rand ( 2 , 4 ) else
25428: LD_ADDR_VAR 0 3
25432: PUSH
25433: LD_INT 2
25435: PPUSH
25436: LD_INT 4
25438: PPUSH
25439: CALL_OW 12
25443: ST_TO_ADDR
25444: GO 25454
// s2 := 1 ;
25446: LD_ADDR_VAR 0 3
25450: PUSH
25451: LD_INT 1
25453: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
25454: LD_ADDR_VAR 0 5
25458: PUSH
25459: LD_VAR 0 6
25463: PUSH
25464: LD_INT 1
25466: ARRAY
25467: PPUSH
25468: LD_VAR 0 3
25472: PPUSH
25473: CALL_OW 259
25477: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
25478: LD_VAR 0 6
25482: PUSH
25483: LD_INT 1
25485: ARRAY
25486: PPUSH
25487: LD_VAR 0 2
25491: PPUSH
25492: LD_VAR 0 5
25496: PPUSH
25497: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
25501: LD_VAR 0 6
25505: PUSH
25506: LD_INT 1
25508: ARRAY
25509: PPUSH
25510: LD_VAR 0 3
25514: PPUSH
25515: LD_VAR 0 4
25519: PPUSH
25520: CALL_OW 237
// end ;
25524: PPOPN 6
25526: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
25527: LD_EXP 40
25531: PUSH
25532: LD_EXP 87
25536: AND
25537: IFFALSE 25616
25539: GO 25541
25541: DISABLE
25542: LD_INT 0
25544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
25545: LD_ADDR_VAR 0 1
25549: PUSH
25550: LD_INT 22
25552: PUSH
25553: LD_OWVAR 2
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: LD_INT 30
25564: PUSH
25565: LD_INT 3
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PPUSH
25576: CALL_OW 69
25580: ST_TO_ADDR
// if not tmp then
25581: LD_VAR 0 1
25585: NOT
25586: IFFALSE 25590
// exit ;
25588: GO 25616
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
25590: LD_VAR 0 1
25594: PUSH
25595: LD_INT 1
25597: PPUSH
25598: LD_VAR 0 1
25602: PPUSH
25603: CALL_OW 12
25607: ARRAY
25608: PPUSH
25609: LD_INT 1
25611: PPUSH
25612: CALL_OW 234
// end ;
25616: PPOPN 1
25618: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
25619: LD_EXP 40
25623: PUSH
25624: LD_EXP 88
25628: AND
25629: IFFALSE 25741
25631: GO 25633
25633: DISABLE
25634: LD_INT 0
25636: PPUSH
25637: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
25638: LD_ADDR_VAR 0 2
25642: PUSH
25643: LD_INT 22
25645: PUSH
25646: LD_OWVAR 2
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: PUSH
25655: LD_INT 2
25657: PUSH
25658: LD_INT 30
25660: PUSH
25661: LD_INT 27
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 30
25670: PUSH
25671: LD_INT 26
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 30
25680: PUSH
25681: LD_INT 28
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PPUSH
25698: CALL_OW 69
25702: ST_TO_ADDR
// if not tmp then
25703: LD_VAR 0 2
25707: NOT
25708: IFFALSE 25712
// exit ;
25710: GO 25741
// for i in tmp do
25712: LD_ADDR_VAR 0 1
25716: PUSH
25717: LD_VAR 0 2
25721: PUSH
25722: FOR_IN
25723: IFFALSE 25739
// SetLives ( i , 1 ) ;
25725: LD_VAR 0 1
25729: PPUSH
25730: LD_INT 1
25732: PPUSH
25733: CALL_OW 234
25737: GO 25722
25739: POP
25740: POP
// end ;
25741: PPOPN 2
25743: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
25744: LD_EXP 40
25748: PUSH
25749: LD_EXP 89
25753: AND
25754: IFFALSE 26028
25756: GO 25758
25758: DISABLE
25759: LD_INT 0
25761: PPUSH
25762: PPUSH
25763: PPUSH
// begin i := rand ( 1 , 7 ) ;
25764: LD_ADDR_VAR 0 1
25768: PUSH
25769: LD_INT 1
25771: PPUSH
25772: LD_INT 7
25774: PPUSH
25775: CALL_OW 12
25779: ST_TO_ADDR
// case i of 1 :
25780: LD_VAR 0 1
25784: PUSH
25785: LD_INT 1
25787: DOUBLE
25788: EQUAL
25789: IFTRUE 25793
25791: GO 25803
25793: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
25794: LD_STRING earthquake(getX(game), 0, 32)
25796: PPUSH
25797: CALL_OW 559
25801: GO 26028
25803: LD_INT 2
25805: DOUBLE
25806: EQUAL
25807: IFTRUE 25811
25809: GO 25825
25811: POP
// begin ToLua ( displayStucuk(); ) ;
25812: LD_STRING displayStucuk();
25814: PPUSH
25815: CALL_OW 559
// ResetFog ;
25819: CALL_OW 335
// end ; 3 :
25823: GO 26028
25825: LD_INT 3
25827: DOUBLE
25828: EQUAL
25829: IFTRUE 25833
25831: GO 25937
25833: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
25834: LD_ADDR_VAR 0 2
25838: PUSH
25839: LD_INT 22
25841: PUSH
25842: LD_OWVAR 2
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 25
25853: PUSH
25854: LD_INT 1
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PPUSH
25865: CALL_OW 69
25869: ST_TO_ADDR
// if not tmp then
25870: LD_VAR 0 2
25874: NOT
25875: IFFALSE 25879
// exit ;
25877: GO 26028
// un := tmp [ rand ( 1 , tmp ) ] ;
25879: LD_ADDR_VAR 0 3
25883: PUSH
25884: LD_VAR 0 2
25888: PUSH
25889: LD_INT 1
25891: PPUSH
25892: LD_VAR 0 2
25896: PPUSH
25897: CALL_OW 12
25901: ARRAY
25902: ST_TO_ADDR
// if Crawls ( un ) then
25903: LD_VAR 0 3
25907: PPUSH
25908: CALL_OW 318
25912: IFFALSE 25923
// ComWalk ( un ) ;
25914: LD_VAR 0 3
25918: PPUSH
25919: CALL_OW 138
// SetClass ( un , class_mortar ) ;
25923: LD_VAR 0 3
25927: PPUSH
25928: LD_INT 8
25930: PPUSH
25931: CALL_OW 336
// end ; 4 :
25935: GO 26028
25937: LD_INT 4
25939: DOUBLE
25940: EQUAL
25941: IFTRUE 25945
25943: GO 26006
25945: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
25946: LD_ADDR_VAR 0 2
25950: PUSH
25951: LD_INT 22
25953: PUSH
25954: LD_OWVAR 2
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 30
25965: PUSH
25966: LD_INT 29
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL_OW 69
25981: ST_TO_ADDR
// if not tmp then
25982: LD_VAR 0 2
25986: NOT
25987: IFFALSE 25991
// exit ;
25989: GO 26028
// DestroyUnit ( tmp [ 1 ] ) ;
25991: LD_VAR 0 2
25995: PUSH
25996: LD_INT 1
25998: ARRAY
25999: PPUSH
26000: CALL_OW 65
// end ; 5 .. 7 :
26004: GO 26028
26006: LD_INT 5
26008: DOUBLE
26009: GREATEREQUAL
26010: IFFALSE 26018
26012: LD_INT 7
26014: DOUBLE
26015: LESSEQUAL
26016: IFTRUE 26020
26018: GO 26027
26020: POP
// StreamSibBomb ; end ;
26021: CALL 22308 0 0
26025: GO 26028
26027: POP
// end ;
26028: PPOPN 3
26030: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
26031: LD_EXP 40
26035: PUSH
26036: LD_EXP 90
26040: AND
26041: IFFALSE 26197
26043: GO 26045
26045: DISABLE
26046: LD_INT 0
26048: PPUSH
26049: PPUSH
26050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
26051: LD_ADDR_VAR 0 2
26055: PUSH
26056: LD_INT 81
26058: PUSH
26059: LD_OWVAR 2
26063: PUSH
26064: EMPTY
26065: LIST
26066: LIST
26067: PUSH
26068: LD_INT 2
26070: PUSH
26071: LD_INT 21
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 21
26083: PUSH
26084: LD_INT 2
26086: PUSH
26087: EMPTY
26088: LIST
26089: LIST
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: LIST
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: PPUSH
26100: CALL_OW 69
26104: ST_TO_ADDR
// if not tmp then
26105: LD_VAR 0 2
26109: NOT
26110: IFFALSE 26114
// exit ;
26112: GO 26197
// p := 0 ;
26114: LD_ADDR_VAR 0 3
26118: PUSH
26119: LD_INT 0
26121: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26122: LD_INT 35
26124: PPUSH
26125: CALL_OW 67
// p := p + 1 ;
26129: LD_ADDR_VAR 0 3
26133: PUSH
26134: LD_VAR 0 3
26138: PUSH
26139: LD_INT 1
26141: PLUS
26142: ST_TO_ADDR
// for i in tmp do
26143: LD_ADDR_VAR 0 1
26147: PUSH
26148: LD_VAR 0 2
26152: PUSH
26153: FOR_IN
26154: IFFALSE 26185
// if GetLives ( i ) < 1000 then
26156: LD_VAR 0 1
26160: PPUSH
26161: CALL_OW 256
26165: PUSH
26166: LD_INT 1000
26168: LESS
26169: IFFALSE 26183
// SetLives ( i , 1000 ) ;
26171: LD_VAR 0 1
26175: PPUSH
26176: LD_INT 1000
26178: PPUSH
26179: CALL_OW 234
26183: GO 26153
26185: POP
26186: POP
// until p > 20 ;
26187: LD_VAR 0 3
26191: PUSH
26192: LD_INT 20
26194: GREATER
26195: IFFALSE 26122
// end ;
26197: PPOPN 3
26199: END
// every 0 0$1 trigger StreamModeActive and sTime do
26200: LD_EXP 40
26204: PUSH
26205: LD_EXP 91
26209: AND
26210: IFFALSE 26245
26212: GO 26214
26214: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
26215: LD_INT 28
26217: PPUSH
26218: LD_OWVAR 2
26222: PPUSH
26223: LD_INT 2
26225: PPUSH
26226: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
26230: LD_INT 30
26232: PPUSH
26233: LD_OWVAR 2
26237: PPUSH
26238: LD_INT 2
26240: PPUSH
26241: CALL_OW 322
// end ;
26245: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
26246: LD_EXP 40
26250: PUSH
26251: LD_EXP 92
26255: AND
26256: IFFALSE 26377
26258: GO 26260
26260: DISABLE
26261: LD_INT 0
26263: PPUSH
26264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
26265: LD_ADDR_VAR 0 2
26269: PUSH
26270: LD_INT 22
26272: PUSH
26273: LD_OWVAR 2
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 21
26284: PUSH
26285: LD_INT 1
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: LD_INT 3
26294: PUSH
26295: LD_INT 23
26297: PUSH
26298: LD_INT 0
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: LIST
26313: PPUSH
26314: CALL_OW 69
26318: ST_TO_ADDR
// if not tmp then
26319: LD_VAR 0 2
26323: NOT
26324: IFFALSE 26328
// exit ;
26326: GO 26377
// for i in tmp do
26328: LD_ADDR_VAR 0 1
26332: PUSH
26333: LD_VAR 0 2
26337: PUSH
26338: FOR_IN
26339: IFFALSE 26375
// begin if Crawls ( i ) then
26341: LD_VAR 0 1
26345: PPUSH
26346: CALL_OW 318
26350: IFFALSE 26361
// ComWalk ( i ) ;
26352: LD_VAR 0 1
26356: PPUSH
26357: CALL_OW 138
// SetClass ( i , 2 ) ;
26361: LD_VAR 0 1
26365: PPUSH
26366: LD_INT 2
26368: PPUSH
26369: CALL_OW 336
// end ;
26373: GO 26338
26375: POP
26376: POP
// end ;
26377: PPOPN 2
26379: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
26380: LD_EXP 40
26384: PUSH
26385: LD_EXP 93
26389: AND
26390: IFFALSE 26671
26392: GO 26394
26394: DISABLE
26395: LD_INT 0
26397: PPUSH
26398: PPUSH
26399: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
26400: LD_OWVAR 2
26404: PPUSH
26405: LD_INT 9
26407: PPUSH
26408: LD_INT 1
26410: PPUSH
26411: LD_INT 1
26413: PPUSH
26414: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
26418: LD_INT 9
26420: PPUSH
26421: LD_OWVAR 2
26425: PPUSH
26426: CALL_OW 343
// uc_side := 9 ;
26430: LD_ADDR_OWVAR 20
26434: PUSH
26435: LD_INT 9
26437: ST_TO_ADDR
// uc_nation := 2 ;
26438: LD_ADDR_OWVAR 21
26442: PUSH
26443: LD_INT 2
26445: ST_TO_ADDR
// hc_name := Dark Warrior ;
26446: LD_ADDR_OWVAR 26
26450: PUSH
26451: LD_STRING Dark Warrior
26453: ST_TO_ADDR
// hc_gallery :=  ;
26454: LD_ADDR_OWVAR 33
26458: PUSH
26459: LD_STRING 
26461: ST_TO_ADDR
// hc_noskilllimit := true ;
26462: LD_ADDR_OWVAR 76
26466: PUSH
26467: LD_INT 1
26469: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
26470: LD_ADDR_OWVAR 31
26474: PUSH
26475: LD_INT 30
26477: PUSH
26478: LD_INT 30
26480: PUSH
26481: LD_INT 30
26483: PUSH
26484: LD_INT 30
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: LIST
26491: LIST
26492: ST_TO_ADDR
// un := CreateHuman ;
26493: LD_ADDR_VAR 0 3
26497: PUSH
26498: CALL_OW 44
26502: ST_TO_ADDR
// hc_noskilllimit := false ;
26503: LD_ADDR_OWVAR 76
26507: PUSH
26508: LD_INT 0
26510: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
26511: LD_VAR 0 3
26515: PPUSH
26516: LD_INT 1
26518: PPUSH
26519: CALL_OW 51
// p := 0 ;
26523: LD_ADDR_VAR 0 2
26527: PUSH
26528: LD_INT 0
26530: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
26531: LD_INT 35
26533: PPUSH
26534: CALL_OW 67
// p := p + 1 ;
26538: LD_ADDR_VAR 0 2
26542: PUSH
26543: LD_VAR 0 2
26547: PUSH
26548: LD_INT 1
26550: PLUS
26551: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
26552: LD_VAR 0 3
26556: PPUSH
26557: CALL_OW 256
26561: PUSH
26562: LD_INT 1000
26564: LESS
26565: IFFALSE 26579
// SetLives ( un , 1000 ) ;
26567: LD_VAR 0 3
26571: PPUSH
26572: LD_INT 1000
26574: PPUSH
26575: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
26579: LD_VAR 0 3
26583: PPUSH
26584: LD_INT 81
26586: PUSH
26587: LD_OWVAR 2
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 91
26598: PUSH
26599: LD_VAR 0 3
26603: PUSH
26604: LD_INT 30
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: LIST
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PPUSH
26616: CALL_OW 69
26620: PPUSH
26621: LD_VAR 0 3
26625: PPUSH
26626: CALL_OW 74
26630: PPUSH
26631: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
26635: LD_VAR 0 2
26639: PUSH
26640: LD_INT 60
26642: GREATER
26643: PUSH
26644: LD_VAR 0 3
26648: PPUSH
26649: CALL_OW 301
26653: OR
26654: IFFALSE 26531
// if un then
26656: LD_VAR 0 3
26660: IFFALSE 26671
// RemoveUnit ( un ) ;
26662: LD_VAR 0 3
26666: PPUSH
26667: CALL_OW 64
// end ; end_of_file
26671: PPOPN 3
26673: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
26674: LD_INT 0
26676: PPUSH
26677: PPUSH
26678: PPUSH
26679: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
26680: LD_VAR 0 1
26684: PPUSH
26685: CALL_OW 264
26689: PUSH
26690: LD_EXP 39
26694: EQUAL
26695: IFFALSE 26767
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
26697: LD_INT 68
26699: PPUSH
26700: LD_VAR 0 1
26704: PPUSH
26705: CALL_OW 255
26709: PPUSH
26710: CALL_OW 321
26714: PUSH
26715: LD_INT 2
26717: EQUAL
26718: IFFALSE 26730
// eff := 70 else
26720: LD_ADDR_VAR 0 6
26724: PUSH
26725: LD_INT 70
26727: ST_TO_ADDR
26728: GO 26738
// eff := 30 ;
26730: LD_ADDR_VAR 0 6
26734: PUSH
26735: LD_INT 30
26737: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
26738: LD_VAR 0 1
26742: PPUSH
26743: CALL_OW 250
26747: PPUSH
26748: LD_VAR 0 1
26752: PPUSH
26753: CALL_OW 251
26757: PPUSH
26758: LD_VAR 0 6
26762: PPUSH
26763: CALL_OW 495
// end ; end ;
26767: LD_VAR 0 4
26771: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
26772: LD_INT 0
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
// if cmd = 124 then
26780: LD_VAR 0 1
26784: PUSH
26785: LD_INT 124
26787: EQUAL
26788: IFFALSE 26994
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
26790: LD_ADDR_VAR 0 5
26794: PUSH
26795: LD_INT 2
26797: PUSH
26798: LD_INT 34
26800: PUSH
26801: LD_INT 53
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 34
26810: PUSH
26811: LD_INT 14
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: LIST
26822: PPUSH
26823: CALL_OW 69
26827: ST_TO_ADDR
// if not tmp then
26828: LD_VAR 0 5
26832: NOT
26833: IFFALSE 26837
// exit ;
26835: GO 26994
// for i in tmp do
26837: LD_ADDR_VAR 0 3
26841: PUSH
26842: LD_VAR 0 5
26846: PUSH
26847: FOR_IN
26848: IFFALSE 26992
// begin taskList := GetTaskList ( i ) ;
26850: LD_ADDR_VAR 0 6
26854: PUSH
26855: LD_VAR 0 3
26859: PPUSH
26860: CALL_OW 437
26864: ST_TO_ADDR
// if not taskList then
26865: LD_VAR 0 6
26869: NOT
26870: IFFALSE 26874
// continue ;
26872: GO 26847
// for j = 1 to taskList do
26874: LD_ADDR_VAR 0 4
26878: PUSH
26879: DOUBLE
26880: LD_INT 1
26882: DEC
26883: ST_TO_ADDR
26884: LD_VAR 0 6
26888: PUSH
26889: FOR_TO
26890: IFFALSE 26988
// if taskList [ j ] [ 1 ] = | then
26892: LD_VAR 0 6
26896: PUSH
26897: LD_VAR 0 4
26901: ARRAY
26902: PUSH
26903: LD_INT 1
26905: ARRAY
26906: PUSH
26907: LD_STRING |
26909: EQUAL
26910: IFFALSE 26986
// begin _taskList := Delete ( taskList , 1 ) ;
26912: LD_ADDR_VAR 0 7
26916: PUSH
26917: LD_VAR 0 6
26921: PPUSH
26922: LD_INT 1
26924: PPUSH
26925: CALL_OW 3
26929: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
26930: LD_VAR 0 3
26934: PPUSH
26935: LD_VAR 0 7
26939: PPUSH
26940: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
26944: LD_VAR 0 3
26948: PPUSH
26949: LD_VAR 0 6
26953: PUSH
26954: LD_VAR 0 4
26958: ARRAY
26959: PUSH
26960: LD_INT 2
26962: ARRAY
26963: PPUSH
26964: LD_VAR 0 6
26968: PUSH
26969: LD_VAR 0 4
26973: ARRAY
26974: PUSH
26975: LD_INT 3
26977: ARRAY
26978: PPUSH
26979: LD_INT 8
26981: PPUSH
26982: CALL 26999 0 4
// end ;
26986: GO 26889
26988: POP
26989: POP
// end ;
26990: GO 26847
26992: POP
26993: POP
// end ; end ;
26994: LD_VAR 0 2
26998: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
26999: LD_INT 0
27001: PPUSH
27002: PPUSH
27003: PPUSH
27004: PPUSH
27005: PPUSH
27006: PPUSH
27007: PPUSH
27008: PPUSH
27009: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
27010: LD_VAR 0 1
27014: NOT
27015: PUSH
27016: LD_VAR 0 2
27020: PPUSH
27021: LD_VAR 0 3
27025: PPUSH
27026: CALL_OW 488
27030: NOT
27031: OR
27032: PUSH
27033: LD_VAR 0 4
27037: NOT
27038: OR
27039: IFFALSE 27043
// exit ;
27041: GO 27383
// list := [ ] ;
27043: LD_ADDR_VAR 0 13
27047: PUSH
27048: EMPTY
27049: ST_TO_ADDR
// if x - r < 0 then
27050: LD_VAR 0 2
27054: PUSH
27055: LD_VAR 0 4
27059: MINUS
27060: PUSH
27061: LD_INT 0
27063: LESS
27064: IFFALSE 27076
// min_x := 0 else
27066: LD_ADDR_VAR 0 7
27070: PUSH
27071: LD_INT 0
27073: ST_TO_ADDR
27074: GO 27092
// min_x := x - r ;
27076: LD_ADDR_VAR 0 7
27080: PUSH
27081: LD_VAR 0 2
27085: PUSH
27086: LD_VAR 0 4
27090: MINUS
27091: ST_TO_ADDR
// if y - r < 0 then
27092: LD_VAR 0 3
27096: PUSH
27097: LD_VAR 0 4
27101: MINUS
27102: PUSH
27103: LD_INT 0
27105: LESS
27106: IFFALSE 27118
// min_y := 0 else
27108: LD_ADDR_VAR 0 8
27112: PUSH
27113: LD_INT 0
27115: ST_TO_ADDR
27116: GO 27134
// min_y := y - r ;
27118: LD_ADDR_VAR 0 8
27122: PUSH
27123: LD_VAR 0 3
27127: PUSH
27128: LD_VAR 0 4
27132: MINUS
27133: ST_TO_ADDR
// max_x := x + r ;
27134: LD_ADDR_VAR 0 9
27138: PUSH
27139: LD_VAR 0 2
27143: PUSH
27144: LD_VAR 0 4
27148: PLUS
27149: ST_TO_ADDR
// max_y := y + r ;
27150: LD_ADDR_VAR 0 10
27154: PUSH
27155: LD_VAR 0 3
27159: PUSH
27160: LD_VAR 0 4
27164: PLUS
27165: ST_TO_ADDR
// for _x = min_x to max_x do
27166: LD_ADDR_VAR 0 11
27170: PUSH
27171: DOUBLE
27172: LD_VAR 0 7
27176: DEC
27177: ST_TO_ADDR
27178: LD_VAR 0 9
27182: PUSH
27183: FOR_TO
27184: IFFALSE 27301
// for _y = min_y to max_y do
27186: LD_ADDR_VAR 0 12
27190: PUSH
27191: DOUBLE
27192: LD_VAR 0 8
27196: DEC
27197: ST_TO_ADDR
27198: LD_VAR 0 10
27202: PUSH
27203: FOR_TO
27204: IFFALSE 27297
// begin if not ValidHex ( _x , _y ) then
27206: LD_VAR 0 11
27210: PPUSH
27211: LD_VAR 0 12
27215: PPUSH
27216: CALL_OW 488
27220: NOT
27221: IFFALSE 27225
// continue ;
27223: GO 27203
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
27225: LD_VAR 0 11
27229: PPUSH
27230: LD_VAR 0 12
27234: PPUSH
27235: CALL_OW 351
27239: PUSH
27240: LD_VAR 0 11
27244: PPUSH
27245: LD_VAR 0 12
27249: PPUSH
27250: CALL_OW 554
27254: AND
27255: IFFALSE 27295
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
27257: LD_ADDR_VAR 0 13
27261: PUSH
27262: LD_VAR 0 13
27266: PPUSH
27267: LD_VAR 0 13
27271: PUSH
27272: LD_INT 1
27274: PLUS
27275: PPUSH
27276: LD_VAR 0 11
27280: PUSH
27281: LD_VAR 0 12
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PPUSH
27290: CALL_OW 2
27294: ST_TO_ADDR
// end ;
27295: GO 27203
27297: POP
27298: POP
27299: GO 27183
27301: POP
27302: POP
// if not list then
27303: LD_VAR 0 13
27307: NOT
27308: IFFALSE 27312
// exit ;
27310: GO 27383
// for i in list do
27312: LD_ADDR_VAR 0 6
27316: PUSH
27317: LD_VAR 0 13
27321: PUSH
27322: FOR_IN
27323: IFFALSE 27381
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_STRING M
27332: PUSH
27333: LD_VAR 0 6
27337: PUSH
27338: LD_INT 1
27340: ARRAY
27341: PUSH
27342: LD_VAR 0 6
27346: PUSH
27347: LD_INT 2
27349: ARRAY
27350: PUSH
27351: LD_INT 0
27353: PUSH
27354: LD_INT 0
27356: PUSH
27357: LD_INT 0
27359: PUSH
27360: LD_INT 0
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: PUSH
27372: EMPTY
27373: LIST
27374: PPUSH
27375: CALL_OW 447
27379: GO 27322
27381: POP
27382: POP
// end ;
27383: LD_VAR 0 5
27387: RET
