// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17175 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82247 0 9
// PrepareAmerican ;
  77: CALL 562 0 0
// PrepareArabian ;
  81: CALL 2234 0 0
// MC_Start ( ) ;
  85: CALL 19287 0 0
// Action ;
  89: CALL 7865 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: EMPTY
 227: LIST
 228: LIST
 229: LIST
 230: PUSH
 231: LD_OWVAR 67
 235: ARRAY
 236: ST_TO_ADDR
// powell_warn := false ;
 237: LD_ADDR_EXP 16
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// loses_counter := 0 ;
 245: LD_ADDR_EXP 17
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// artifact_oncargo := false ;
 253: LD_ADDR_EXP 14
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 261: LD_ADDR_EXP 18
 265: PUSH
 266: LD_STRING 10_GensherEscape_1
 268: PPUSH
 269: LD_EXP 1
 273: PPUSH
 274: CALL_OW 30
 278: ST_TO_ADDR
// can_kamikazed := false ;
 279: LD_ADDR_EXP 10
 283: PUSH
 284: LD_INT 0
 286: ST_TO_ADDR
// am_veh_consturcted := false ;
 287: LD_ADDR_EXP 20
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 1
 299: RET
// export function CustomInitMacro ; var i ; begin
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 304: LD_ADDR_EXP 74
 308: PUSH
 309: LD_INT 20
 311: PUSH
 312: LD_INT 21
 314: PUSH
 315: LD_INT 22
 317: PUSH
 318: EMPTY
 319: LIST
 320: LIST
 321: LIST
 322: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 323: LD_ADDR_EXP 75
 327: PUSH
 328: LD_INT 28
 330: PUSH
 331: LD_INT 24
 333: PUSH
 334: LD_INT 26
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 3 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 3
 347: PUSH
 348: LD_INT 6
 350: PUSH
 351: LD_INT 9
 353: PUSH
 354: EMPTY
 355: LIST
 356: LIST
 357: LIST
 358: PUSH
 359: LD_OWVAR 67
 363: ARRAY
 364: PPUSH
 365: LD_INT 3
 367: PPUSH
 368: CALL 40608 0 3
// MC_SetMinesField ( 2 , [ 3 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 3
 377: PUSH
 378: LD_INT 6
 380: PUSH
 381: LD_INT 9
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_OWVAR 67
 393: ARRAY
 394: PPUSH
 395: LD_INT 2
 397: PPUSH
 398: CALL 40608 0 3
// MC_SetMinesField ( 3 , [ 3 , 5 , 9 ] [ Difficulty ] , minefield3_left ) ;
 402: LD_INT 3
 404: PPUSH
 405: LD_INT 3
 407: PUSH
 408: LD_INT 5
 410: PUSH
 411: LD_INT 9
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: PUSH
 419: LD_OWVAR 67
 423: ARRAY
 424: PPUSH
 425: LD_INT 1
 427: PPUSH
 428: CALL 40608 0 3
// for i = 1 to mc_bases do
 432: LD_ADDR_VAR 0 2
 436: PUSH
 437: DOUBLE
 438: LD_INT 1
 440: DEC
 441: ST_TO_ADDR
 442: LD_EXP 50
 446: PUSH
 447: FOR_TO
 448: IFFALSE 472
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 450: LD_VAR 0 2
 454: PPUSH
 455: LD_EXP 43
 459: PUSH
 460: LD_VAR 0 2
 464: ARRAY
 465: PPUSH
 466: CALL 41034 0 2
 470: GO 447
 472: POP
 473: POP
// end ;
 474: LD_VAR 0 1
 478: RET
// function Debuger ; var i ; begin
 479: LD_INT 0
 481: PPUSH
 482: PPUSH
// if not debug then
 483: LD_EXP 1
 487: NOT
 488: IFFALSE 492
// exit ;
 490: GO 528
// game_speed := 5 ;
 492: LD_ADDR_OWVAR 65
 496: PUSH
 497: LD_INT 5
 499: ST_TO_ADDR
// uc_side := 1 ;
 500: LD_ADDR_OWVAR 20
 504: PUSH
 505: LD_INT 1
 507: ST_TO_ADDR
// uc_nation := 1 ;
 508: LD_ADDR_OWVAR 21
 512: PUSH
 513: LD_INT 1
 515: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 516: LD_EXP 36
 520: PPUSH
 521: LD_INT 1
 523: PPUSH
 524: CALL_OW 235
// end ;
 528: LD_VAR 0 1
 532: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 533: LD_INT 94
 535: PPUSH
 536: CALL_OW 301
 540: PUSH
 541: LD_INT 45
 543: PPUSH
 544: CALL_OW 302
 548: AND
 549: IFFALSE 561
 551: GO 553
 553: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 554: LD_STRING ACH_EAST
 556: PPUSH
 557: CALL_OW 543
 561: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
 566: PPUSH
 567: PPUSH
 568: PPUSH
 569: PPUSH
 570: PPUSH
 571: PPUSH
// uc_side := 4 ;
 572: LD_ADDR_OWVAR 20
 576: PUSH
 577: LD_INT 4
 579: ST_TO_ADDR
// uc_nation := 1 ;
 580: LD_ADDR_OWVAR 21
 584: PUSH
 585: LD_INT 1
 587: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 588: LD_ADDR_EXP 30
 592: PUSH
 593: LD_STRING Powell
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: LD_STRING 
 601: PPUSH
 602: CALL 47318 0 3
 606: ST_TO_ADDR
// uc_side := 1 ;
 607: LD_ADDR_OWVAR 20
 611: PUSH
 612: LD_INT 1
 614: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 615: LD_ADDR_EXP 21
 619: PUSH
 620: LD_STRING JMM
 622: PPUSH
 623: LD_EXP 1
 627: NOT
 628: PPUSH
 629: LD_EXP 4
 633: PPUSH
 634: CALL 47318 0 3
 638: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 639: LD_EXP 21
 643: PPUSH
 644: CALL_OW 257
 648: PUSH
 649: LD_INT 4
 651: GREATER
 652: IFFALSE 666
// SetClass ( JMM , 1 ) ;
 654: LD_EXP 21
 658: PPUSH
 659: LD_INT 1
 661: PPUSH
 662: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 666: LD_ADDR_EXP 22
 670: PUSH
 671: LD_STRING Lisa
 673: PPUSH
 674: LD_EXP 1
 678: NOT
 679: PPUSH
 680: LD_EXP 4
 684: PPUSH
 685: CALL 47318 0 3
 689: ST_TO_ADDR
// if not Lisa then
 690: LD_EXP 22
 694: NOT
 695: IFFALSE 710
// Lisa := CreateCharacter ( 10_Lisa ) ;
 697: LD_ADDR_EXP 22
 701: PUSH
 702: LD_STRING 10_Lisa
 704: PPUSH
 705: CALL_OW 34
 709: ST_TO_ADDR
// if not Lisa then
 710: LD_EXP 22
 714: NOT
 715: IFFALSE 730
// Lisa := CreateCharacter ( 09_Lisa ) ;
 717: LD_ADDR_EXP 22
 721: PUSH
 722: LD_STRING 09_Lisa
 724: PPUSH
 725: CALL_OW 34
 729: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 730: LD_ADDR_EXP 31
 734: PUSH
 735: LD_STRING Cornel
 737: PPUSH
 738: LD_EXP 1
 742: NOT
 743: PPUSH
 744: LD_EXP 4
 748: PPUSH
 749: CALL 47318 0 3
 753: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 754: LD_ADDR_EXP 23
 758: PUSH
 759: LD_STRING Donaldson
 761: PPUSH
 762: LD_EXP 1
 766: NOT
 767: PPUSH
 768: LD_EXP 4
 772: PPUSH
 773: CALL 47318 0 3
 777: ST_TO_ADDR
// if not Donaldson then
 778: LD_EXP 23
 782: NOT
 783: IFFALSE 798
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 785: LD_ADDR_EXP 23
 789: PUSH
 790: LD_STRING 10_Donaldson
 792: PPUSH
 793: CALL_OW 34
 797: ST_TO_ADDR
// if not Donaldson then
 798: LD_EXP 23
 802: NOT
 803: IFFALSE 818
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 805: LD_ADDR_EXP 23
 809: PUSH
 810: LD_STRING 09_Donaldson
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 818: LD_ADDR_EXP 24
 822: PUSH
 823: LD_STRING Bobby
 825: PPUSH
 826: LD_EXP 1
 830: NOT
 831: PPUSH
 832: LD_EXP 4
 836: PPUSH
 837: CALL 47318 0 3
 841: ST_TO_ADDR
// if not Bobby then
 842: LD_EXP 24
 846: NOT
 847: IFFALSE 862
// Bobby := CreateCharacter ( 10_Bobby ) ;
 849: LD_ADDR_EXP 24
 853: PUSH
 854: LD_STRING 10_Bobby
 856: PPUSH
 857: CALL_OW 34
 861: ST_TO_ADDR
// if not Bobby then
 862: LD_EXP 24
 866: NOT
 867: IFFALSE 882
// Bobby := CreateCharacter ( 09_Bobby ) ;
 869: LD_ADDR_EXP 24
 873: PUSH
 874: LD_STRING 09_Bobby
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 882: LD_ADDR_EXP 25
 886: PUSH
 887: LD_STRING Cyrus
 889: PPUSH
 890: LD_EXP 1
 894: NOT
 895: PPUSH
 896: LD_EXP 4
 900: PPUSH
 901: CALL 47318 0 3
 905: ST_TO_ADDR
// if not Cyrus then
 906: LD_EXP 25
 910: NOT
 911: IFFALSE 926
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 913: LD_ADDR_EXP 25
 917: PUSH
 918: LD_STRING 10_Cyrus
 920: PPUSH
 921: CALL_OW 34
 925: ST_TO_ADDR
// if not Cyrus then
 926: LD_EXP 25
 930: NOT
 931: IFFALSE 946
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 933: LD_ADDR_EXP 25
 937: PUSH
 938: LD_STRING 09_Cyrus
 940: PPUSH
 941: CALL_OW 34
 945: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 946: LD_ADDR_EXP 26
 950: PUSH
 951: LD_STRING Denis
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_EXP 4
 964: PPUSH
 965: CALL 47318 0 3
 969: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 970: LD_ADDR_EXP 27
 974: PUSH
 975: LD_STRING Brown
 977: PPUSH
 978: LD_EXP 1
 982: NOT
 983: PPUSH
 984: LD_EXP 4
 988: PPUSH
 989: CALL 47318 0 3
 993: ST_TO_ADDR
// if not Brown then
 994: LD_EXP 27
 998: NOT
 999: IFFALSE 1014
// Brown := CreateCharacter ( 10_Brown ) ;
1001: LD_ADDR_EXP 27
1005: PUSH
1006: LD_STRING 10_Brown
1008: PPUSH
1009: CALL_OW 34
1013: ST_TO_ADDR
// if not Brown then
1014: LD_EXP 27
1018: NOT
1019: IFFALSE 1034
// Brown := CreateCharacter ( 08_Brown ) ;
1021: LD_ADDR_EXP 27
1025: PUSH
1026: LD_STRING 08_Brown
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1034: LD_ADDR_EXP 28
1038: PUSH
1039: LD_STRING Gladstone
1041: PPUSH
1042: LD_EXP 1
1046: NOT
1047: PPUSH
1048: LD_EXP 4
1052: PPUSH
1053: CALL 47318 0 3
1057: ST_TO_ADDR
// if not Gladstone then
1058: LD_EXP 28
1062: NOT
1063: IFFALSE 1078
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1065: LD_ADDR_EXP 28
1069: PUSH
1070: LD_STRING 10_Gladstone
1072: PPUSH
1073: CALL_OW 34
1077: ST_TO_ADDR
// if not Gladstone then
1078: LD_EXP 28
1082: NOT
1083: IFFALSE 1098
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1085: LD_ADDR_EXP 28
1089: PUSH
1090: LD_STRING 08_Gladstone
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1098: LD_ADDR_EXP 29
1102: PUSH
1103: LD_STRING Houten
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_EXP 4
1116: PPUSH
1117: CALL 47318 0 3
1121: ST_TO_ADDR
// if not Houten then
1122: LD_EXP 29
1126: NOT
1127: IFFALSE 1142
// Houten := CreateCharacter ( 10_Houten ) ;
1129: LD_ADDR_EXP 29
1133: PUSH
1134: LD_STRING 10_Houten
1136: PPUSH
1137: CALL_OW 34
1141: ST_TO_ADDR
// if not Houten then
1142: LD_EXP 29
1146: NOT
1147: IFFALSE 1162
// Houten := CreateCharacter ( 09_Houten ) ;
1149: LD_ADDR_EXP 29
1153: PUSH
1154: LD_STRING 09_Houten
1156: PPUSH
1157: CALL_OW 34
1161: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1162: LD_ADDR_EXP 31
1166: PUSH
1167: LD_STRING Cornell
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: LD_EXP 4
1180: PPUSH
1181: CALL 47318 0 3
1185: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 32
1190: PUSH
1191: LD_STRING Gary
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 47318 0 3
1209: ST_TO_ADDR
// if not Gary then
1210: LD_EXP 32
1214: NOT
1215: IFFALSE 1230
// Gary := CreateCharacter ( 10_Gary ) ;
1217: LD_ADDR_EXP 32
1221: PUSH
1222: LD_STRING 10_Gary
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 33
1234: PUSH
1235: LD_STRING Frank
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 47318 0 3
1253: ST_TO_ADDR
// if not Frank then
1254: LD_EXP 33
1258: NOT
1259: IFFALSE 1274
// Frank := CreateCharacter ( 08_Frank ) ;
1261: LD_ADDR_EXP 33
1265: PUSH
1266: LD_STRING 08_Frank
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1274: LD_ADDR_EXP 34
1278: PUSH
1279: LD_STRING Kikuchi
1281: PPUSH
1282: LD_EXP 1
1286: NOT
1287: PPUSH
1288: LD_EXP 4
1292: PPUSH
1293: CALL 47318 0 3
1297: ST_TO_ADDR
// if not Kikuchi then
1298: LD_EXP 34
1302: NOT
1303: IFFALSE 1318
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1305: LD_ADDR_EXP 34
1309: PUSH
1310: LD_STRING 08_Kikuchi
1312: PPUSH
1313: CALL_OW 34
1317: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1318: LD_ADDR_VAR 0 5
1322: PUSH
1323: LD_EXP 22
1327: PUSH
1328: LD_EXP 23
1332: PUSH
1333: LD_EXP 24
1337: PUSH
1338: LD_EXP 25
1342: PUSH
1343: LD_EXP 26
1347: PUSH
1348: LD_EXP 27
1352: PUSH
1353: LD_EXP 28
1357: PUSH
1358: LD_EXP 29
1362: PUSH
1363: LD_EXP 31
1367: PUSH
1368: LD_EXP 32
1372: PUSH
1373: LD_EXP 33
1377: PUSH
1378: LD_EXP 34
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// tmp := tmp diff 0 ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_INT 0
1409: DIFF
1410: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1411: LD_ADDR_VAR 0 5
1415: PUSH
1416: LD_VAR 0 5
1420: PUSH
1421: LD_STRING 10_lock
1423: PPUSH
1424: CALL_OW 31
1428: UNION
1429: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1430: LD_ADDR_VAR 0 5
1434: PUSH
1435: LD_VAR 0 5
1439: PUSH
1440: LD_STRING 10c_lock
1442: PPUSH
1443: CALL_OW 31
1447: UNION
1448: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1449: LD_STRING 10_lock
1451: PPUSH
1452: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1456: LD_STRING 10c_lock
1458: PPUSH
1459: CALL_OW 40
// for i in tmp do
1463: LD_ADDR_VAR 0 2
1467: PUSH
1468: LD_VAR 0 5
1472: PUSH
1473: FOR_IN
1474: IFFALSE 1512
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1476: LD_VAR 0 2
1480: PPUSH
1481: CALL_OW 257
1485: PUSH
1486: LD_INT 8
1488: PUSH
1489: LD_INT 2
1491: PUSH
1492: EMPTY
1493: LIST
1494: LIST
1495: IN
1496: IFFALSE 1510
// SetClass ( i , class_soldier ) ;
1498: LD_VAR 0 2
1502: PPUSH
1503: LD_INT 1
1505: PPUSH
1506: CALL_OW 336
1510: GO 1473
1512: POP
1513: POP
// if tmp < 12 then
1514: LD_VAR 0 5
1518: PUSH
1519: LD_INT 12
1521: LESS
1522: IFFALSE 1616
// begin k := 16 - tmp ;
1524: LD_ADDR_VAR 0 3
1528: PUSH
1529: LD_INT 16
1531: PUSH
1532: LD_VAR 0 5
1536: MINUS
1537: ST_TO_ADDR
// for i = 1 to k do
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: DOUBLE
1544: LD_INT 1
1546: DEC
1547: ST_TO_ADDR
1548: LD_VAR 0 3
1552: PUSH
1553: FOR_TO
1554: IFFALSE 1614
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1556: LD_INT 0
1558: PPUSH
1559: LD_INT 1
1561: PUSH
1562: LD_INT 1
1564: PUSH
1565: LD_INT 3
1567: PUSH
1568: LD_INT 4
1570: PUSH
1571: EMPTY
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: PUSH
1577: LD_INT 1
1579: PPUSH
1580: LD_INT 4
1582: PPUSH
1583: CALL_OW 12
1587: ARRAY
1588: PPUSH
1589: LD_INT 6
1591: PPUSH
1592: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1596: LD_ADDR_VAR 0 5
1600: PUSH
1601: LD_VAR 0 5
1605: PUSH
1606: CALL_OW 44
1610: ADD
1611: ST_TO_ADDR
// end ;
1612: GO 1553
1614: POP
1615: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1616: LD_ADDR_EXP 19
1620: PUSH
1621: LD_STRING 1
1623: PPUSH
1624: LD_INT 12
1626: PPUSH
1627: LD_INT 12
1629: PPUSH
1630: LD_INT -5
1632: PUSH
1633: LD_EXP 21
1637: PUSH
1638: LD_INT -2
1640: PUSH
1641: LD_INT -3
1643: PUSH
1644: LD_INT -5
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: PUSH
1654: LD_VAR 0 5
1658: ADD
1659: PUSH
1660: LD_INT -6
1662: PUSH
1663: LD_INT -4
1665: PUSH
1666: LD_EXP 30
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: ADD
1676: PPUSH
1677: LD_INT 1
1679: PUSH
1680: LD_INT 4
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 3
1689: PUSH
1690: LD_INT 0
1692: PUSH
1693: LD_INT 5
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_INT 4
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_INT 3
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 5
1717: PUSH
1718: LD_INT 0
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: PPUSH
1735: CALL_OW 42
1739: ST_TO_ADDR
// others := tmp diff selected ;
1740: LD_ADDR_VAR 0 8
1744: PUSH
1745: LD_VAR 0 5
1749: PUSH
1750: LD_EXP 19
1754: DIFF
1755: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_VAR 0 8
1765: PUSH
1766: LD_EXP 22
1770: PUSH
1771: LD_EXP 23
1775: PUSH
1776: LD_EXP 24
1780: PUSH
1781: LD_EXP 25
1785: PUSH
1786: LD_EXP 26
1790: PUSH
1791: LD_EXP 27
1795: PUSH
1796: LD_EXP 28
1800: PUSH
1801: LD_EXP 29
1805: PUSH
1806: LD_EXP 31
1810: PUSH
1811: LD_EXP 32
1815: PUSH
1816: LD_EXP 33
1820: PUSH
1821: LD_EXP 34
1825: PUSH
1826: EMPTY
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: DIFF
1840: ST_TO_ADDR
// if others then
1841: LD_VAR 0 8
1845: IFFALSE 1859
// SaveCharacters ( others , 11_others ) ;
1847: LD_VAR 0 8
1851: PPUSH
1852: LD_STRING 11_others
1854: PPUSH
1855: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1859: LD_ADDR_VAR 0 6
1863: PUSH
1864: LD_INT 3
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 4
1875: PUSH
1876: EMPTY
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: PUSH
1882: LD_INT 2
1884: PUSH
1885: LD_INT 2
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 5
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: PUSH
1900: LD_INT 4
1902: PUSH
1903: LD_INT 1
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 5
1911: PUSH
1912: EMPTY
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: PUSH
1918: LD_INT 2
1920: PUSH
1921: LD_INT 1
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 7
1929: PUSH
1930: EMPTY
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: PUSH
1936: LD_INT 3
1938: PUSH
1939: LD_INT 2
1941: PUSH
1942: LD_INT 1
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: EMPTY
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: ST_TO_ADDR
// for i in JMM ^ selected do
1961: LD_ADDR_VAR 0 2
1965: PUSH
1966: LD_EXP 21
1970: PUSH
1971: LD_EXP 19
1975: ADD
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2167
// begin if GetClass ( i ) = 3 then
1980: LD_VAR 0 2
1984: PPUSH
1985: CALL_OW 257
1989: PUSH
1990: LD_INT 3
1992: EQUAL
1993: IFFALSE 2150
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1995: LD_ADDR_OWVAR 37
1999: PUSH
2000: LD_VAR 0 6
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2013: LD_ADDR_OWVAR 39
2017: PUSH
2018: LD_VAR 0 6
2022: PUSH
2023: LD_INT 1
2025: ARRAY
2026: PUSH
2027: LD_INT 2
2029: ARRAY
2030: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2031: LD_ADDR_OWVAR 38
2035: PUSH
2036: LD_VAR 0 6
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PUSH
2045: LD_INT 3
2047: ARRAY
2048: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2049: LD_ADDR_OWVAR 40
2053: PUSH
2054: LD_VAR 0 6
2058: PUSH
2059: LD_INT 1
2061: ARRAY
2062: PUSH
2063: LD_INT 4
2065: ARRAY
2066: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2067: LD_ADDR_VAR 0 6
2071: PUSH
2072: LD_VAR 0 6
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: CALL_OW 3
2084: ST_TO_ADDR
// veh := CreateVehicle ;
2085: LD_ADDR_VAR 0 7
2089: PUSH
2090: CALL_OW 45
2094: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2095: LD_VAR 0 7
2099: PPUSH
2100: LD_INT 8
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2110: LD_VAR 0 2
2114: PPUSH
2115: LD_VAR 0 7
2119: PPUSH
2120: CALL_OW 52
// if i = JMM then
2124: LD_VAR 0 2
2128: PUSH
2129: LD_EXP 21
2133: EQUAL
2134: IFFALSE 2148
// SetMark ( veh , 1 ) ;
2136: LD_VAR 0 7
2140: PPUSH
2141: LD_INT 1
2143: PPUSH
2144: CALL_OW 242
// end else
2148: GO 2165
// PlaceUnitArea ( i , am_hum_start , false ) ;
2150: LD_VAR 0 2
2154: PPUSH
2155: LD_INT 9
2157: PPUSH
2158: LD_INT 0
2160: PPUSH
2161: CALL_OW 49
// end ;
2165: GO 1977
2167: POP
2168: POP
// vc_chassis := us_medium_tracked ;
2169: LD_ADDR_OWVAR 37
2173: PUSH
2174: LD_INT 3
2176: ST_TO_ADDR
// vc_engine := engine_solar ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_INT 2
2184: ST_TO_ADDR
// vc_control := control_computer ;
2185: LD_ADDR_OWVAR 38
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// vc_weapon := us_radar ;
2193: LD_ADDR_OWVAR 40
2197: PUSH
2198: LD_INT 11
2200: ST_TO_ADDR
// veh := CreateVehicle ;
2201: LD_ADDR_VAR 0 7
2205: PUSH
2206: CALL_OW 45
2210: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2211: LD_VAR 0 7
2215: PPUSH
2216: LD_INT 87
2218: PPUSH
2219: LD_INT 142
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 48
// end ; end_of_file
2229: LD_VAR 0 1
2233: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2234: LD_INT 0
2236: PPUSH
2237: PPUSH
2238: PPUSH
2239: PPUSH
2240: PPUSH
2241: PPUSH
// if Difficulty = 1 then
2242: LD_OWVAR 67
2246: PUSH
2247: LD_INT 1
2249: EQUAL
2250: IFFALSE 2347
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2252: LD_ADDR_VAR 0 6
2256: PUSH
2257: LD_INT 129
2259: PUSH
2260: LD_INT 45
2262: PUSH
2263: EMPTY
2264: LIST
2265: LIST
2266: PUSH
2267: LD_INT 143
2269: PUSH
2270: LD_INT 58
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 184
2279: PUSH
2280: LD_INT 113
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: LD_INT 163
2289: PUSH
2290: LD_INT 107
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: EMPTY
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: ST_TO_ADDR
// for i in tmp do
2303: LD_ADDR_VAR 0 2
2307: PUSH
2308: LD_VAR 0 6
2312: PUSH
2313: FOR_IN
2314: IFFALSE 2345
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2316: LD_VAR 0 2
2320: PUSH
2321: LD_INT 1
2323: ARRAY
2324: PPUSH
2325: LD_VAR 0 2
2329: PUSH
2330: LD_INT 2
2332: ARRAY
2333: PPUSH
2334: CALL_OW 428
2338: PPUSH
2339: CALL_OW 64
2343: GO 2313
2345: POP
2346: POP
// end ; skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2347: LD_ADDR_VAR 0 5
2351: PUSH
2352: LD_INT 5
2354: PUSH
2355: LD_INT 6
2357: PUSH
2358: LD_INT 7
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: LD_OWVAR 67
2370: ARRAY
2371: ST_TO_ADDR
// uc_side := 2 ;
2372: LD_ADDR_OWVAR 20
2376: PUSH
2377: LD_INT 2
2379: ST_TO_ADDR
// uc_nation := 2 ;
2380: LD_ADDR_OWVAR 21
2384: PUSH
2385: LD_INT 2
2387: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2388: LD_ADDR_OWVAR 37
2392: PUSH
2393: LD_INT 14
2395: ST_TO_ADDR
// vc_engine := engine_siberite ;
2396: LD_ADDR_OWVAR 39
2400: PUSH
2401: LD_INT 3
2403: ST_TO_ADDR
// vc_control := control_manual ;
2404: LD_ADDR_OWVAR 38
2408: PUSH
2409: LD_INT 1
2411: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2412: LD_ADDR_OWVAR 40
2416: PUSH
2417: LD_INT 31
2419: ST_TO_ADDR
// for i = 1 to 3 do
2420: LD_ADDR_VAR 0 2
2424: PUSH
2425: DOUBLE
2426: LD_INT 1
2428: DEC
2429: ST_TO_ADDR
2430: LD_INT 3
2432: PUSH
2433: FOR_TO
2434: IFFALSE 2518
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2436: LD_INT 0
2438: PPUSH
2439: LD_INT 3
2441: PPUSH
2442: LD_VAR 0 5
2446: PPUSH
2447: CALL_OW 380
// un := CreateVehicle ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: CALL_OW 45
2460: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: LD_INT 5
2471: PPUSH
2472: CALL_OW 12
2476: PPUSH
2477: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2481: LD_VAR 0 4
2485: PPUSH
2486: LD_INT 156
2488: PPUSH
2489: LD_INT 15
2491: PPUSH
2492: LD_INT 6
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2502: CALL_OW 44
2506: PPUSH
2507: LD_VAR 0 4
2511: PPUSH
2512: CALL_OW 52
// end ;
2516: GO 2433
2518: POP
2519: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , [ 3 , 4 , 5 ] [ Difficulty ] , - 1 , 4 ] ) ;
2520: LD_ADDR_EXP 37
2524: PUSH
2525: LD_INT 94
2527: PPUSH
2528: LD_INT 28
2530: PPUSH
2531: LD_STRING dammam
2533: PPUSH
2534: LD_VAR 0 5
2538: PPUSH
2539: LD_INT 10000
2541: PUSH
2542: LD_INT 1000
2544: PUSH
2545: LD_INT 300
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PPUSH
2553: LD_INT 1
2555: NEG
2556: PUSH
2557: LD_INT 3
2559: PUSH
2560: LD_INT 4
2562: PUSH
2563: LD_INT 5
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: LIST
2570: PUSH
2571: LD_OWVAR 67
2575: ARRAY
2576: PUSH
2577: LD_INT 1
2579: NEG
2580: PUSH
2581: LD_INT 4
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: PPUSH
2590: CALL 57842 0 6
2594: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , [ 3 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
2595: LD_ADDR_EXP 37
2599: PUSH
2600: LD_EXP 37
2604: PUSH
2605: LD_INT 122
2607: PPUSH
2608: LD_INT 25
2610: PPUSH
2611: LD_STRING 
2613: PPUSH
2614: LD_VAR 0 5
2618: PPUSH
2619: LD_INT 500
2621: PUSH
2622: LD_INT 60
2624: PUSH
2625: LD_INT 0
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: LIST
2632: PPUSH
2633: LD_INT 1
2635: NEG
2636: PUSH
2637: LD_INT 3
2639: PUSH
2640: LD_INT 3
2642: PUSH
2643: LD_INT 4
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: LIST
2650: PUSH
2651: LD_OWVAR 67
2655: ARRAY
2656: PUSH
2657: LD_INT 2
2659: PUSH
2660: LD_INT 0
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL 57842 0 6
2673: UNION
2674: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2675: LD_ADDR_EXP 35
2679: PUSH
2680: LD_INT 45
2682: PPUSH
2683: LD_INT 24
2685: PPUSH
2686: LD_STRING jeddah
2688: PPUSH
2689: LD_VAR 0 5
2693: PPUSH
2694: LD_INT 700
2696: PUSH
2697: LD_INT 300
2699: PUSH
2700: LD_INT 10
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 1
2710: NEG
2711: PUSH
2712: LD_INT 5
2714: PUSH
2715: LD_INT 3
2717: PUSH
2718: LD_INT 2
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: LIST
2725: LIST
2726: PPUSH
2727: CALL 57842 0 6
2731: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2732: LD_ADDR_EXP 36
2736: PUSH
2737: LD_INT 7
2739: PPUSH
2740: LD_INT 27
2742: PPUSH
2743: LD_STRING riyadh
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: LD_INT 500
2753: PUSH
2754: LD_INT 60
2756: PUSH
2757: LD_INT 0
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_INT 4
2767: PUSH
2768: LD_INT 2
2770: PUSH
2771: LD_INT 3
2773: PUSH
2774: LD_INT 1
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PPUSH
2783: CALL 57842 0 6
2787: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2788: LD_ADDR_EXP 39
2792: PUSH
2793: LD_INT 204
2795: PPUSH
2796: LD_INT 26
2798: PPUSH
2799: LD_STRING 
2801: PPUSH
2802: LD_VAR 0 5
2806: PPUSH
2807: LD_INT 500
2809: PUSH
2810: LD_INT 50
2812: PUSH
2813: LD_INT 0
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: LIST
2820: PPUSH
2821: LD_INT 1
2823: NEG
2824: PUSH
2825: LD_INT 3
2827: PUSH
2828: LD_INT 3
2830: PUSH
2831: LD_INT 2
2833: PUSH
2834: EMPTY
2835: LIST
2836: LIST
2837: LIST
2838: LIST
2839: PPUSH
2840: CALL 57842 0 6
2844: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2845: LD_ADDR_EXP 50
2849: PUSH
2850: LD_EXP 37
2854: PUSH
2855: LD_EXP 35
2859: PUSH
2860: LD_EXP 39
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: LIST
2869: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_INT 22
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: PUSH
2885: LD_INT 30
2887: PUSH
2888: LD_INT 31
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: PUSH
2895: LD_INT 58
2897: PUSH
2898: EMPTY
2899: LIST
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: LIST
2905: PPUSH
2906: CALL_OW 69
2910: PUSH
2911: FOR_IN
2912: IFFALSE 3037
// begin if GetBase ( i ) then
2914: LD_VAR 0 2
2918: PPUSH
2919: CALL_OW 274
2923: IFFALSE 2927
// continue ;
2925: GO 2911
// d := GetDir ( i ) ;
2927: LD_ADDR_VAR 0 3
2931: PUSH
2932: LD_VAR 0 2
2936: PPUSH
2937: CALL_OW 254
2941: ST_TO_ADDR
// if d < 3 then
2942: LD_VAR 0 3
2946: PUSH
2947: LD_INT 3
2949: LESS
2950: IFFALSE 2968
// d := d + 3 else
2952: LD_ADDR_VAR 0 3
2956: PUSH
2957: LD_VAR 0 3
2961: PUSH
2962: LD_INT 3
2964: PLUS
2965: ST_TO_ADDR
2966: GO 2982
// d := d - 3 ;
2968: LD_ADDR_VAR 0 3
2972: PUSH
2973: LD_VAR 0 3
2977: PUSH
2978: LD_INT 3
2980: MINUS
2981: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2982: LD_INT 0
2984: PPUSH
2985: LD_INT 8
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: CALL_OW 380
// un := CreateHuman ;
2997: LD_ADDR_VAR 0 4
3001: PUSH
3002: CALL_OW 44
3006: ST_TO_ADDR
// SetDir ( un , d ) ;
3007: LD_VAR 0 4
3011: PPUSH
3012: LD_VAR 0 3
3016: PPUSH
3017: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_VAR 0 2
3030: PPUSH
3031: CALL_OW 52
// end ;
3035: GO 2911
3037: POP
3038: POP
// if Difficulty > 1 then
3039: LD_OWVAR 67
3043: PUSH
3044: LD_INT 1
3046: GREATER
3047: IFFALSE 3418
// begin ar_kamikadze := [ ] ;
3049: LD_ADDR_EXP 42
3053: PUSH
3054: EMPTY
3055: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3056: LD_INT 0
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: LD_VAR 0 5
3066: PPUSH
3067: CALL_OW 380
// un := CreateHuman ;
3071: LD_ADDR_VAR 0 4
3075: PUSH
3076: CALL_OW 44
3080: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 3
3088: PPUSH
3089: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 23
3100: PPUSH
3101: LD_INT 44
3103: PPUSH
3104: LD_INT 0
3106: PPUSH
3107: CALL_OW 48
// ComCrawl ( un ) ;
3111: LD_VAR 0 4
3115: PPUSH
3116: CALL_OW 137
// un := CreateHuman ;
3120: LD_ADDR_VAR 0 4
3124: PUSH
3125: CALL_OW 44
3129: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3130: LD_VAR 0 4
3134: PPUSH
3135: LD_INT 3
3137: PPUSH
3138: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3142: LD_VAR 0 4
3146: PPUSH
3147: LD_INT 30
3149: PPUSH
3150: LD_INT 39
3152: PPUSH
3153: LD_INT 0
3155: PPUSH
3156: CALL_OW 48
// ComCrawl ( un ) ;
3160: LD_VAR 0 4
3164: PPUSH
3165: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3169: LD_INT 0
3171: PPUSH
3172: LD_INT 17
3174: PPUSH
3175: LD_VAR 0 5
3179: PPUSH
3180: CALL_OW 380
// un := CreateHuman ;
3184: LD_ADDR_VAR 0 4
3188: PUSH
3189: CALL_OW 44
3193: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3194: LD_VAR 0 4
3198: PPUSH
3199: LD_INT 3
3201: PPUSH
3202: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3206: LD_VAR 0 4
3210: PPUSH
3211: LD_INT 45
3213: PPUSH
3214: LD_INT 86
3216: PPUSH
3217: LD_INT 0
3219: PPUSH
3220: CALL_OW 48
// ComHold ( un ) ;
3224: LD_VAR 0 4
3228: PPUSH
3229: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3233: LD_ADDR_EXP 42
3237: PUSH
3238: LD_EXP 42
3242: PPUSH
3243: LD_EXP 42
3247: PUSH
3248: LD_INT 1
3250: PLUS
3251: PPUSH
3252: LD_VAR 0 4
3256: PPUSH
3257: CALL_OW 1
3261: ST_TO_ADDR
// un := CreateHuman ;
3262: LD_ADDR_VAR 0 4
3266: PUSH
3267: CALL_OW 44
3271: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3272: LD_VAR 0 4
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3284: LD_VAR 0 4
3288: PPUSH
3289: LD_INT 60
3291: PPUSH
3292: LD_INT 85
3294: PPUSH
3295: LD_INT 0
3297: PPUSH
3298: CALL_OW 48
// ComHold ( un ) ;
3302: LD_VAR 0 4
3306: PPUSH
3307: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3311: LD_ADDR_EXP 42
3315: PUSH
3316: LD_EXP 42
3320: PPUSH
3321: LD_EXP 42
3325: PUSH
3326: LD_INT 1
3328: PLUS
3329: PPUSH
3330: LD_VAR 0 4
3334: PPUSH
3335: CALL_OW 1
3339: ST_TO_ADDR
// un := CreateHuman ;
3340: LD_ADDR_VAR 0 4
3344: PUSH
3345: CALL_OW 44
3349: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3350: LD_VAR 0 4
3354: PPUSH
3355: LD_INT 3
3357: PPUSH
3358: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3362: LD_VAR 0 4
3366: PPUSH
3367: LD_INT 222
3369: PPUSH
3370: LD_INT 166
3372: PPUSH
3373: LD_INT 0
3375: PPUSH
3376: CALL_OW 48
// ComHold ( un ) ;
3380: LD_VAR 0 4
3384: PPUSH
3385: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3389: LD_ADDR_EXP 42
3393: PUSH
3394: LD_EXP 42
3398: PPUSH
3399: LD_EXP 42
3403: PUSH
3404: LD_INT 1
3406: PLUS
3407: PPUSH
3408: LD_VAR 0 4
3412: PPUSH
3413: CALL_OW 1
3417: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3418: LD_ADDR_EXP 40
3422: PUSH
3423: EMPTY
3424: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3425: LD_INT 1
3427: PPUSH
3428: LD_INT 1
3430: PPUSH
3431: LD_VAR 0 5
3435: PPUSH
3436: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3440: LD_ADDR_OWVAR 26
3444: PUSH
3445: LD_STRING Pavel Grigorovic
3447: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3448: LD_ADDR_OWVAR 33
3452: PUSH
3453: LD_STRING SecondCharsGal
3455: ST_TO_ADDR
// hc_face_number := 4 ;
3456: LD_ADDR_OWVAR 34
3460: PUSH
3461: LD_INT 4
3463: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3464: LD_ADDR_EXP 40
3468: PUSH
3469: LD_EXP 40
3473: PPUSH
3474: LD_INT 1
3476: PPUSH
3477: CALL_OW 44
3481: PPUSH
3482: CALL_OW 1
3486: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3487: LD_INT 2
3489: PPUSH
3490: LD_INT 4
3492: PPUSH
3493: LD_VAR 0 5
3497: PPUSH
3498: CALL_OW 380
// hc_name := Lucy Sebel ;
3502: LD_ADDR_OWVAR 26
3506: PUSH
3507: LD_STRING Lucy Sebel
3509: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3510: LD_ADDR_OWVAR 33
3514: PUSH
3515: LD_STRING SecondCharsGal
3517: ST_TO_ADDR
// hc_face_number := 15 ;
3518: LD_ADDR_OWVAR 34
3522: PUSH
3523: LD_INT 15
3525: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3526: LD_ADDR_EXP 40
3530: PUSH
3531: LD_EXP 40
3535: PPUSH
3536: LD_INT 2
3538: PPUSH
3539: CALL_OW 44
3543: PPUSH
3544: CALL_OW 1
3548: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3549: LD_INT 2
3551: PPUSH
3552: LD_INT 4
3554: PPUSH
3555: LD_VAR 0 5
3559: PPUSH
3560: CALL_OW 380
// hc_gallery :=  ;
3564: LD_ADDR_OWVAR 33
3568: PUSH
3569: LD_STRING 
3571: ST_TO_ADDR
// hc_name :=  ;
3572: LD_ADDR_OWVAR 26
3576: PUSH
3577: LD_STRING 
3579: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3580: LD_ADDR_EXP 40
3584: PUSH
3585: LD_EXP 40
3589: PPUSH
3590: LD_INT 3
3592: PPUSH
3593: CALL_OW 44
3597: PPUSH
3598: CALL_OW 1
3602: ST_TO_ADDR
// hc_sex := sex_male ;
3603: LD_ADDR_OWVAR 27
3607: PUSH
3608: LD_INT 1
3610: ST_TO_ADDR
// hc_class = 11 ;
3611: LD_ADDR_OWVAR 28
3615: PUSH
3616: LD_INT 11
3618: ST_TO_ADDR
// hc_gallery = sandar ;
3619: LD_ADDR_OWVAR 33
3623: PUSH
3624: LD_STRING sandar
3626: ST_TO_ADDR
// hc_face_number = 33 ;
3627: LD_ADDR_OWVAR 34
3631: PUSH
3632: LD_INT 33
3634: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3635: LD_ADDR_OWVAR 26
3639: PUSH
3640: LD_STRING Thabit Muhair Saliba
3642: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3643: LD_ADDR_OWVAR 31
3647: PUSH
3648: LD_INT 0
3650: PUSH
3651: LD_INT 0
3653: PUSH
3654: LD_INT 0
3656: PUSH
3657: LD_INT 0
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: LIST
3664: LIST
3665: ST_TO_ADDR
// Saliba = CreateHuman ;
3666: LD_ADDR_EXP 44
3670: PUSH
3671: CALL_OW 44
3675: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3676: LD_EXP 44
3680: PPUSH
3681: LD_INT 7
3683: PPUSH
3684: CALL_OW 52
// if gensher_active then
3688: LD_EXP 18
3692: IFFALSE 3719
// begin Gensher = NewCharacter ( Dietrich ) ;
3694: LD_ADDR_EXP 45
3698: PUSH
3699: LD_STRING Dietrich
3701: PPUSH
3702: CALL_OW 25
3706: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3707: LD_EXP 45
3711: PPUSH
3712: LD_INT 94
3714: PPUSH
3715: CALL_OW 52
// end ; InitHc ;
3719: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3723: LD_ADDR_EXP 41
3727: PUSH
3728: EMPTY
3729: ST_TO_ADDR
// for i = 1 to 5 do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: DOUBLE
3736: LD_INT 1
3738: DEC
3739: ST_TO_ADDR
3740: LD_INT 5
3742: PUSH
3743: FOR_TO
3744: IFFALSE 3916
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3746: LD_INT 13
3748: PUSH
3749: LD_INT 14
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PUSH
3756: LD_INT 1
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: CALL_OW 12
3766: ARRAY
3767: PPUSH
3768: LD_INT 1
3770: PUSH
3771: LD_INT 2
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: PUSH
3778: LD_INT 1
3780: PPUSH
3781: LD_INT 2
3783: PPUSH
3784: CALL_OW 12
3788: ARRAY
3789: PPUSH
3790: LD_INT 1
3792: PPUSH
3793: LD_INT 25
3795: PUSH
3796: LD_INT 27
3798: PUSH
3799: LD_INT 26
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: LIST
3806: PUSH
3807: LD_INT 1
3809: PPUSH
3810: LD_INT 3
3812: PPUSH
3813: CALL_OW 12
3817: ARRAY
3818: PPUSH
3819: LD_INT 60
3821: PPUSH
3822: LD_INT 100
3824: PPUSH
3825: CALL_OW 12
3829: PPUSH
3830: CALL 54433 0 5
// un := CreateVehicle ;
3834: LD_ADDR_VAR 0 4
3838: PUSH
3839: CALL_OW 45
3843: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3844: LD_ADDR_EXP 41
3848: PUSH
3849: LD_EXP 41
3853: PPUSH
3854: LD_EXP 41
3858: PUSH
3859: LD_INT 1
3861: PLUS
3862: PPUSH
3863: LD_VAR 0 4
3867: PPUSH
3868: CALL_OW 1
3872: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3873: LD_VAR 0 4
3877: PPUSH
3878: LD_INT 0
3880: PPUSH
3881: LD_INT 5
3883: PPUSH
3884: CALL_OW 12
3888: PPUSH
3889: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3893: LD_VAR 0 4
3897: PPUSH
3898: LD_INT 124
3900: PPUSH
3901: LD_INT 141
3903: PPUSH
3904: LD_INT 8
3906: PPUSH
3907: LD_INT 0
3909: PPUSH
3910: CALL_OW 50
// end ;
3914: GO 3743
3916: POP
3917: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3918: LD_ADDR_EXP 43
3922: PUSH
3923: EMPTY
3924: PUSH
3925: EMPTY
3926: PUSH
3927: EMPTY
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: LIST
3933: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3934: LD_ADDR_VAR 0 3
3938: PUSH
3939: DOUBLE
3940: LD_INT 1
3942: DEC
3943: ST_TO_ADDR
3944: LD_INT 3
3946: PUSH
3947: LD_INT 3
3949: PUSH
3950: LD_INT 4
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: LIST
3957: PUSH
3958: LD_OWVAR 67
3962: ARRAY
3963: PUSH
3964: FOR_TO
3965: IFFALSE 4179
// for i = 1 to 3 do
3967: LD_ADDR_VAR 0 2
3971: PUSH
3972: DOUBLE
3973: LD_INT 1
3975: DEC
3976: ST_TO_ADDR
3977: LD_INT 3
3979: PUSH
3980: FOR_TO
3981: IFFALSE 4175
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3983: LD_INT 14
3985: PPUSH
3986: LD_INT 3
3988: PUSH
3989: LD_INT 2
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: LD_INT 1
3998: PPUSH
3999: LD_INT 2
4001: PPUSH
4002: CALL_OW 12
4006: ARRAY
4007: PPUSH
4008: LD_INT 1
4010: PUSH
4011: LD_INT 5
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 2
4023: PPUSH
4024: CALL_OW 12
4028: ARRAY
4029: PPUSH
4030: LD_INT 25
4032: PUSH
4033: LD_INT 27
4035: PUSH
4036: LD_INT 26
4038: PUSH
4039: LD_INT 28
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: PUSH
4048: LD_INT 1
4050: PPUSH
4051: LD_INT 4
4053: PPUSH
4054: CALL_OW 12
4058: ARRAY
4059: PPUSH
4060: LD_INT 100
4062: PPUSH
4063: CALL 54433 0 5
// un := CreateVehicle ;
4067: LD_ADDR_VAR 0 4
4071: PUSH
4072: CALL_OW 45
4076: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4077: LD_ADDR_EXP 43
4081: PUSH
4082: LD_EXP 43
4086: PPUSH
4087: LD_VAR 0 2
4091: PUSH
4092: LD_EXP 43
4096: PUSH
4097: LD_VAR 0 2
4101: ARRAY
4102: PUSH
4103: LD_INT 1
4105: PLUS
4106: PUSH
4107: EMPTY
4108: LIST
4109: LIST
4110: PPUSH
4111: LD_VAR 0 4
4115: PPUSH
4116: CALL 54555 0 3
4120: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4121: LD_VAR 0 4
4125: PPUSH
4126: LD_INT 0
4128: PPUSH
4129: LD_INT 5
4131: PPUSH
4132: CALL_OW 12
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 20
4148: PUSH
4149: LD_INT 21
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: LIST
4159: PUSH
4160: LD_VAR 0 2
4164: ARRAY
4165: PPUSH
4166: LD_INT 0
4168: PPUSH
4169: CALL_OW 49
// end ;
4173: GO 3980
4175: POP
4176: POP
4177: GO 3964
4179: POP
4180: POP
// InitHc ;
4181: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4185: LD_INT 4
4187: PPUSH
4188: LD_INT 5
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: LD_INT 5
4196: PPUSH
4197: LD_INT 0
4199: PPUSH
4200: CALL_OW 58
// end ;
4204: LD_VAR 0 1
4208: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4209: LD_EXP 42
4213: IFFALSE 4287
4215: GO 4217
4217: DISABLE
4218: LD_INT 0
4220: PPUSH
// begin enable ;
4221: ENABLE
// for i in ar_kamikadze do
4222: LD_ADDR_VAR 0 1
4226: PUSH
4227: LD_EXP 42
4231: PUSH
4232: FOR_IN
4233: IFFALSE 4285
// if See ( 1 , i ) then
4235: LD_INT 1
4237: PPUSH
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL_OW 292
4247: IFFALSE 4283
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4249: LD_VAR 0 1
4253: PPUSH
4254: LD_INT 81
4256: PUSH
4257: LD_INT 2
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 69
4268: PPUSH
4269: LD_VAR 0 1
4273: PPUSH
4274: CALL_OW 74
4278: PPUSH
4279: CALL_OW 115
4283: GO 4232
4285: POP
4286: POP
// end ;
4287: PPOPN 1
4289: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4290: LD_EXP 13
4294: IFFALSE 4611
4296: GO 4298
4298: DISABLE
4299: LD_INT 0
4301: PPUSH
4302: PPUSH
4303: PPUSH
4304: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4305: LD_INT 35
4307: PPUSH
4308: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4312: LD_INT 1
4314: PPUSH
4315: CALL 41322 0 1
4319: PUSH
4320: LD_INT 0
4322: EQUAL
4323: IFFALSE 4305
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4325: LD_INT 1
4327: PPUSH
4328: LD_INT 14
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: LD_INT 2
4336: PUSH
4337: LD_INT 32
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: LIST
4344: LIST
4345: PUSH
4346: EMPTY
4347: LIST
4348: PPUSH
4349: CALL 40926 0 2
// repeat wait ( 0 0$1 ) ;
4353: LD_INT 35
4355: PPUSH
4356: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4360: LD_EXP 69
4364: PUSH
4365: LD_INT 1
4367: ARRAY
4368: PPUSH
4369: LD_INT 33
4371: PUSH
4372: LD_INT 2
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 34
4381: PUSH
4382: LD_INT 32
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PPUSH
4393: CALL_OW 72
4397: IFFALSE 4353
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4399: LD_ADDR_VAR 0 2
4403: PUSH
4404: LD_EXP 69
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PPUSH
4413: LD_INT 33
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: LD_INT 34
4425: PUSH
4426: LD_INT 32
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 72
4441: PUSH
4442: LD_INT 1
4444: ARRAY
4445: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4446: LD_ADDR_VAR 0 4
4450: PUSH
4451: LD_INT 5
4453: PPUSH
4454: CALL_OW 469
4458: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4459: LD_INT 35
4461: PPUSH
4462: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4466: LD_ADDR_VAR 0 4
4470: PUSH
4471: LD_INT 5
4473: PPUSH
4474: CALL_OW 469
4478: ST_TO_ADDR
// tmp := 100 ;
4479: LD_ADDR_VAR 0 3
4483: PUSH
4484: LD_INT 100
4486: ST_TO_ADDR
// if pos then
4487: LD_VAR 0 4
4491: IFFALSE 4531
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4493: LD_ADDR_VAR 0 3
4497: PUSH
4498: LD_INT 2
4500: PPUSH
4501: LD_VAR 0 4
4505: PUSH
4506: LD_INT 1
4508: ARRAY
4509: PPUSH
4510: LD_VAR 0 4
4514: PUSH
4515: LD_INT 2
4517: ARRAY
4518: PPUSH
4519: LD_INT 20
4521: PPUSH
4522: CALL 55451 0 4
4526: PUSH
4527: LD_INT 4
4529: ARRAY
4530: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4531: LD_VAR 0 4
4535: PUSH
4536: LD_EXP 14
4540: NOT
4541: AND
4542: PUSH
4543: LD_VAR 0 3
4547: PUSH
4548: LD_INT 10
4550: LESS
4551: AND
4552: IFFALSE 4459
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4554: LD_VAR 0 2
4558: PPUSH
4559: LD_VAR 0 4
4563: PUSH
4564: LD_INT 1
4566: ARRAY
4567: PPUSH
4568: LD_VAR 0 4
4572: PUSH
4573: LD_INT 2
4575: ARRAY
4576: PPUSH
4577: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4581: LD_VAR 0 2
4585: PPUSH
4586: LD_INT 198
4588: PPUSH
4589: LD_INT 113
4591: PPUSH
4592: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4596: LD_VAR 0 2
4600: PPUSH
4601: LD_INT 124
4603: PPUSH
4604: LD_INT 7
4606: PPUSH
4607: CALL_OW 171
// end ;
4611: PPOPN 4
4613: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4614: LD_EXP 6
4618: IFFALSE 7292
4620: GO 4622
4622: DISABLE
4623: LD_INT 0
4625: PPUSH
4626: PPUSH
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4633: LD_ADDR_VAR 0 4
4637: PUSH
4638: LD_INT 5
4640: PUSH
4641: LD_INT 6
4643: PUSH
4644: LD_INT 7
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: ST_TO_ADDR
// coords := [ ] ;
4658: LD_ADDR_VAR 0 5
4662: PUSH
4663: EMPTY
4664: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4665: LD_ADDR_VAR 0 6
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: LD_INT 0
4681: PUSH
4682: LD_INT 1
4684: PUSH
4685: LD_INT 0
4687: PUSH
4688: LD_INT 0
4690: PUSH
4691: LD_INT 0
4693: PUSH
4694: LD_INT 1
4696: PUSH
4697: LD_INT 0
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: LIST
4706: LIST
4707: LIST
4708: LIST
4709: LIST
4710: LIST
4711: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4712: LD_INT 1
4714: PPUSH
4715: LD_INT 14
4717: PUSH
4718: LD_INT 1
4720: PUSH
4721: LD_INT 2
4723: PUSH
4724: LD_INT 28
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_INT 14
4735: PUSH
4736: LD_INT 1
4738: PUSH
4739: LD_INT 2
4741: PUSH
4742: LD_INT 25
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: PUSH
4751: LD_INT 14
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 2
4759: PUSH
4760: LD_INT 28
4762: PUSH
4763: EMPTY
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: PUSH
4769: LD_INT 14
4771: PUSH
4772: LD_INT 1
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: LD_INT 29
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: LIST
4792: PPUSH
4793: CALL 40926 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4797: LD_INT 21000
4799: PUSH
4800: LD_INT 19950
4802: PUSH
4803: LD_INT 18900
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: LIST
4810: PUSH
4811: LD_OWVAR 67
4815: ARRAY
4816: PPUSH
4817: CALL_OW 67
// InitHc ;
4821: CALL_OW 19
// InitUc ;
4825: CALL_OW 18
// uc_side := 2 ;
4829: LD_ADDR_OWVAR 20
4833: PUSH
4834: LD_INT 2
4836: ST_TO_ADDR
// uc_nation := 2 ;
4837: LD_ADDR_OWVAR 21
4841: PUSH
4842: LD_INT 2
4844: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4845: LD_ADDR_VAR 0 3
4849: PUSH
4850: EMPTY
4851: PUSH
4852: EMPTY
4853: PUSH
4854: EMPTY
4855: PUSH
4856: EMPTY
4857: PUSH
4858: EMPTY
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4867: LD_ADDR_VAR 0 3
4871: PUSH
4872: LD_VAR 0 3
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: LD_EXP 69
4884: PUSH
4885: LD_INT 1
4887: ARRAY
4888: PUSH
4889: LD_INT 34
4891: PUSH
4892: LD_INT 32
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PPUSH
4899: CALL_OW 69
4903: DIFF
4904: PPUSH
4905: CALL_OW 1
4909: ST_TO_ADDR
// for i = 1 to Difficulty do
4910: LD_ADDR_VAR 0 1
4914: PUSH
4915: DOUBLE
4916: LD_INT 1
4918: DEC
4919: ST_TO_ADDR
4920: LD_OWVAR 67
4924: PUSH
4925: FOR_TO
4926: IFFALSE 5064
// begin uc_side := 2 ;
4928: LD_ADDR_OWVAR 20
4932: PUSH
4933: LD_INT 2
4935: ST_TO_ADDR
// uc_nation := 2 ;
4936: LD_ADDR_OWVAR 21
4940: PUSH
4941: LD_INT 2
4943: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4944: LD_INT 13
4946: PPUSH
4947: LD_INT 3
4949: PPUSH
4950: LD_INT 5
4952: PPUSH
4953: LD_INT 29
4955: PPUSH
4956: LD_INT 100
4958: PPUSH
4959: CALL 54433 0 5
// un := CreateVehicle ;
4963: LD_ADDR_VAR 0 2
4967: PUSH
4968: CALL_OW 45
4972: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4973: LD_ADDR_VAR 0 3
4977: PUSH
4978: LD_VAR 0 3
4982: PPUSH
4983: LD_INT 1
4985: PUSH
4986: LD_VAR 0 3
4990: PUSH
4991: LD_INT 1
4993: ARRAY
4994: PUSH
4995: LD_INT 1
4997: PLUS
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PPUSH
5003: LD_VAR 0 2
5007: PPUSH
5008: CALL 54555 0 3
5012: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5013: LD_VAR 0 2
5017: PPUSH
5018: LD_INT 3
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5025: LD_VAR 0 2
5029: PPUSH
5030: LD_INT 16
5032: PPUSH
5033: LD_INT 0
5035: PPUSH
5036: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5040: LD_VAR 0 2
5044: PPUSH
5045: LD_INT 51
5047: PPUSH
5048: LD_INT 10
5050: PPUSH
5051: CALL_OW 111
// wait ( 0 0$2 ) ;
5055: LD_INT 70
5057: PPUSH
5058: CALL_OW 67
// end ;
5062: GO 4925
5064: POP
5065: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5066: LD_ADDR_VAR 0 5
5070: PUSH
5071: LD_INT 51
5073: PUSH
5074: LD_INT 24
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 75
5083: PUSH
5084: LD_INT 90
5086: PUSH
5087: EMPTY
5088: LIST
5089: LIST
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5095: LD_INT 1
5097: PPUSH
5098: LD_VAR 0 3
5102: PUSH
5103: LD_INT 1
5105: ARRAY
5106: PPUSH
5107: LD_VAR 0 5
5111: PPUSH
5112: LD_VAR 0 6
5116: PPUSH
5117: CALL 41159 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5121: LD_ADDR_VAR 0 1
5125: PUSH
5126: DOUBLE
5127: LD_INT 1
5129: DEC
5130: ST_TO_ADDR
5131: LD_INT 1
5133: PUSH
5134: LD_INT 3
5136: PUSH
5137: LD_INT 3
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_OWVAR 67
5149: ARRAY
5150: PUSH
5151: FOR_TO
5152: IFFALSE 5252
// begin uc_side := 2 ;
5154: LD_ADDR_OWVAR 20
5158: PUSH
5159: LD_INT 2
5161: ST_TO_ADDR
// uc_nation := 2 ;
5162: LD_ADDR_OWVAR 21
5166: PUSH
5167: LD_INT 2
5169: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5170: LD_INT 0
5172: PPUSH
5173: LD_INT 17
5175: PPUSH
5176: LD_VAR 0 4
5180: PPUSH
5181: CALL_OW 380
// un := CreateHuman ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: CALL_OW 44
5194: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5195: LD_ADDR_VAR 0 3
5199: PUSH
5200: LD_VAR 0 3
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_VAR 0 3
5212: PUSH
5213: LD_INT 2
5215: ARRAY
5216: PUSH
5217: LD_INT 1
5219: PLUS
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PPUSH
5225: LD_VAR 0 2
5229: PPUSH
5230: CALL 54555 0 3
5234: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5235: LD_VAR 0 2
5239: PPUSH
5240: LD_INT 13
5242: PPUSH
5243: LD_INT 0
5245: PPUSH
5246: CALL_OW 49
// end ;
5250: GO 5151
5252: POP
5253: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5254: LD_ADDR_VAR 0 1
5258: PUSH
5259: DOUBLE
5260: LD_INT 1
5262: DEC
5263: ST_TO_ADDR
5264: LD_INT 2
5266: PUSH
5267: LD_INT 3
5269: PUSH
5270: LD_INT 3
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: PUSH
5284: FOR_TO
5285: IFFALSE 5404
// begin uc_side := 2 ;
5287: LD_ADDR_OWVAR 20
5291: PUSH
5292: LD_INT 2
5294: ST_TO_ADDR
// uc_nation := 2 ;
5295: LD_ADDR_OWVAR 21
5299: PUSH
5300: LD_INT 2
5302: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5303: LD_INT 0
5305: PPUSH
5306: LD_INT 1
5308: PUSH
5309: LD_INT 8
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 1
5318: PPUSH
5319: LD_INT 2
5321: PPUSH
5322: CALL_OW 12
5326: ARRAY
5327: PPUSH
5328: LD_VAR 0 4
5332: PPUSH
5333: CALL_OW 380
// un := CreateHuman ;
5337: LD_ADDR_VAR 0 2
5341: PUSH
5342: CALL_OW 44
5346: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5347: LD_ADDR_VAR 0 3
5351: PUSH
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_INT 2
5359: PUSH
5360: LD_VAR 0 3
5364: PUSH
5365: LD_INT 2
5367: ARRAY
5368: PUSH
5369: LD_INT 1
5371: PLUS
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PPUSH
5377: LD_VAR 0 2
5381: PPUSH
5382: CALL 54555 0 3
5386: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5387: LD_VAR 0 2
5391: PPUSH
5392: LD_INT 13
5394: PPUSH
5395: LD_INT 0
5397: PPUSH
5398: CALL_OW 49
// end ;
5402: GO 5284
5404: POP
5405: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5406: LD_ADDR_VAR 0 5
5410: PUSH
5411: LD_INT 67
5413: PUSH
5414: LD_INT 112
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 85
5423: PUSH
5424: LD_INT 130
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5435: LD_INT 2
5437: PPUSH
5438: LD_VAR 0 3
5442: PUSH
5443: LD_INT 2
5445: ARRAY
5446: PPUSH
5447: LD_VAR 0 5
5451: PPUSH
5452: LD_VAR 0 6
5456: PPUSH
5457: CALL 41159 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5461: LD_ADDR_VAR 0 1
5465: PUSH
5466: DOUBLE
5467: LD_INT 1
5469: DEC
5470: ST_TO_ADDR
5471: LD_INT 1
5473: PUSH
5474: LD_INT 2
5476: PUSH
5477: LD_INT 3
5479: PUSH
5480: EMPTY
5481: LIST
5482: LIST
5483: LIST
5484: PUSH
5485: LD_OWVAR 67
5489: ARRAY
5490: PUSH
5491: FOR_TO
5492: IFFALSE 5592
// begin uc_side := 2 ;
5494: LD_ADDR_OWVAR 20
5498: PUSH
5499: LD_INT 2
5501: ST_TO_ADDR
// uc_nation := 2 ;
5502: LD_ADDR_OWVAR 21
5506: PUSH
5507: LD_INT 2
5509: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5510: LD_INT 0
5512: PPUSH
5513: LD_INT 17
5515: PPUSH
5516: LD_VAR 0 4
5520: PPUSH
5521: CALL_OW 380
// un := CreateHuman ;
5525: LD_ADDR_VAR 0 2
5529: PUSH
5530: CALL_OW 44
5534: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5535: LD_ADDR_VAR 0 3
5539: PUSH
5540: LD_VAR 0 3
5544: PPUSH
5545: LD_INT 3
5547: PUSH
5548: LD_VAR 0 3
5552: PUSH
5553: LD_INT 3
5555: ARRAY
5556: PUSH
5557: LD_INT 1
5559: PLUS
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PPUSH
5565: LD_VAR 0 2
5569: PPUSH
5570: CALL 54555 0 3
5574: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5575: LD_VAR 0 2
5579: PPUSH
5580: LD_INT 14
5582: PPUSH
5583: LD_INT 0
5585: PPUSH
5586: CALL_OW 49
// end ;
5590: GO 5491
5592: POP
5593: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5594: LD_ADDR_VAR 0 5
5598: PUSH
5599: LD_INT 148
5601: PUSH
5602: LD_INT 158
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: LD_INT 148
5611: PUSH
5612: LD_INT 158
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_VAR 0 3
5630: PUSH
5631: LD_INT 3
5633: ARRAY
5634: PPUSH
5635: LD_VAR 0 5
5639: PPUSH
5640: LD_VAR 0 6
5644: PPUSH
5645: CALL 41159 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
5649: LD_ADDR_VAR 0 1
5653: PUSH
5654: DOUBLE
5655: LD_INT 1
5657: DEC
5658: ST_TO_ADDR
5659: LD_INT 2
5661: PUSH
5662: LD_INT 4
5664: PUSH
5665: LD_INT 4
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: PUSH
5673: LD_OWVAR 67
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5904
// begin uc_side := 2 ;
5682: LD_ADDR_OWVAR 20
5686: PUSH
5687: LD_INT 2
5689: ST_TO_ADDR
// uc_nation := 2 ;
5690: LD_ADDR_OWVAR 21
5694: PUSH
5695: LD_INT 2
5697: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5698: LD_INT 14
5700: PPUSH
5701: LD_INT 3
5703: PPUSH
5704: LD_INT 1
5706: PUSH
5707: LD_INT 5
5709: PUSH
5710: EMPTY
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 1
5716: PPUSH
5717: LD_INT 2
5719: PPUSH
5720: CALL_OW 12
5724: ARRAY
5725: PPUSH
5726: LD_INT 27
5728: PUSH
5729: LD_INT 26
5731: PUSH
5732: LD_INT 28
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: PUSH
5740: LD_INT 1
5742: PPUSH
5743: LD_INT 3
5745: PPUSH
5746: CALL_OW 12
5750: ARRAY
5751: PPUSH
5752: LD_INT 100
5754: PPUSH
5755: CALL 54433 0 5
// un := CreateVehicle ;
5759: LD_ADDR_VAR 0 2
5763: PUSH
5764: CALL_OW 45
5768: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5769: LD_ADDR_VAR 0 3
5773: PUSH
5774: LD_VAR 0 3
5778: PPUSH
5779: LD_INT 4
5781: PUSH
5782: LD_VAR 0 3
5786: PUSH
5787: LD_INT 4
5789: ARRAY
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PPUSH
5799: LD_VAR 0 2
5803: PPUSH
5804: CALL 54555 0 3
5808: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5809: LD_VAR 0 2
5813: PPUSH
5814: LD_INT 5
5816: PPUSH
5817: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 15
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// if GetControl ( un ) = control_manual then
5836: LD_VAR 0 2
5840: PPUSH
5841: CALL_OW 263
5845: PUSH
5846: LD_INT 1
5848: EQUAL
5849: IFFALSE 5880
// begin PrepareHuman ( false , 3 , skill ) ;
5851: LD_INT 0
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: LD_VAR 0 4
5861: PPUSH
5862: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5866: CALL_OW 44
5870: PPUSH
5871: LD_VAR 0 2
5875: PPUSH
5876: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 179
5887: PPUSH
5888: LD_INT 135
5890: PPUSH
5891: CALL_OW 111
// wait ( 0 0$2 ) ;
5895: LD_INT 70
5897: PPUSH
5898: CALL_OW 67
// end ;
5902: GO 5679
5904: POP
5905: POP
// vc_chassis := 15 ;
5906: LD_ADDR_OWVAR 37
5910: PUSH
5911: LD_INT 15
5913: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_VAR 0 3
5923: PPUSH
5924: LD_INT 4
5926: PUSH
5927: LD_VAR 0 3
5931: PUSH
5932: LD_INT 4
5934: ARRAY
5935: PUSH
5936: LD_INT 1
5938: PLUS
5939: PUSH
5940: EMPTY
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL_OW 45
5948: PPUSH
5949: CALL 54555 0 3
5953: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5954: LD_VAR 0 3
5958: PUSH
5959: LD_INT 4
5961: ARRAY
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: LD_INT 4
5970: ARRAY
5971: ARRAY
5972: PPUSH
5973: LD_INT 15
5975: PPUSH
5976: LD_INT 0
5978: PPUSH
5979: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5983: LD_INT 0
5985: PPUSH
5986: LD_INT 11
5988: PPUSH
5989: LD_VAR 0 4
5993: PPUSH
5994: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5998: LD_ADDR_VAR 0 3
6002: PUSH
6003: LD_VAR 0 3
6007: PPUSH
6008: LD_INT 4
6010: PUSH
6011: LD_VAR 0 3
6015: PUSH
6016: LD_INT 4
6018: ARRAY
6019: PUSH
6020: LD_INT 1
6022: PLUS
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: PPUSH
6028: CALL_OW 44
6032: PPUSH
6033: CALL 54555 0 3
6037: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6038: LD_VAR 0 3
6042: PUSH
6043: LD_INT 4
6045: ARRAY
6046: PUSH
6047: LD_VAR 0 3
6051: PUSH
6052: LD_INT 4
6054: ARRAY
6055: ARRAY
6056: PPUSH
6057: LD_VAR 0 3
6061: PUSH
6062: LD_INT 4
6064: ARRAY
6065: PUSH
6066: LD_VAR 0 3
6070: PUSH
6071: LD_INT 4
6073: ARRAY
6074: PUSH
6075: LD_INT 1
6077: MINUS
6078: ARRAY
6079: PPUSH
6080: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 148
6091: PUSH
6092: LD_INT 140
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6102: LD_INT 1
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 4
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 41159 0 4
// if gensher_active then
6128: LD_EXP 18
6132: IFFALSE 6534
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6134: LD_EXP 45
6138: PPUSH
6139: LD_STRING D10-Diet-1
6141: PPUSH
6142: CALL_OW 94
// for i = 1 to 2 do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: FOR_TO
6160: IFFALSE 6298
// begin uc_side := 2 ;
6162: LD_ADDR_OWVAR 20
6166: PUSH
6167: LD_INT 2
6169: ST_TO_ADDR
// uc_nation := 2 ;
6170: LD_ADDR_OWVAR 21
6174: PUSH
6175: LD_INT 2
6177: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6178: LD_INT 13
6180: PPUSH
6181: LD_INT 3
6183: PPUSH
6184: LD_INT 5
6186: PPUSH
6187: LD_INT 29
6189: PPUSH
6190: LD_INT 100
6192: PPUSH
6193: CALL 54433 0 5
// un := CreateVehicle ;
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: CALL_OW 45
6206: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6207: LD_ADDR_VAR 0 3
6211: PUSH
6212: LD_VAR 0 3
6216: PPUSH
6217: LD_INT 5
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: LD_INT 5
6227: ARRAY
6228: PUSH
6229: LD_INT 1
6231: PLUS
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PPUSH
6237: LD_VAR 0 2
6241: PPUSH
6242: CALL 54555 0 3
6246: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6247: LD_VAR 0 2
6251: PPUSH
6252: LD_INT 0
6254: PPUSH
6255: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_INT 23
6266: PPUSH
6267: LD_INT 0
6269: PPUSH
6270: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6274: LD_VAR 0 2
6278: PPUSH
6279: LD_INT 85
6281: PPUSH
6282: LD_INT 152
6284: PPUSH
6285: CALL_OW 111
// wait ( 0 0$2 ) ;
6289: LD_INT 70
6291: PPUSH
6292: CALL_OW 67
// end ;
6296: GO 6159
6298: POP
6299: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6300: LD_ADDR_VAR 0 1
6304: PUSH
6305: DOUBLE
6306: LD_INT 1
6308: DEC
6309: ST_TO_ADDR
6310: LD_INT 2
6312: PUSH
6313: LD_INT 3
6315: PUSH
6316: LD_INT 3
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: LD_OWVAR 67
6328: ARRAY
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6488
// begin uc_side := 2 ;
6333: LD_ADDR_OWVAR 20
6337: PUSH
6338: LD_INT 2
6340: ST_TO_ADDR
// uc_nation := 2 ;
6341: LD_ADDR_OWVAR 21
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6349: LD_INT 14
6351: PPUSH
6352: LD_INT 3
6354: PPUSH
6355: LD_INT 5
6357: PPUSH
6358: LD_INT 27
6360: PUSH
6361: LD_INT 28
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 1
6370: PPUSH
6371: LD_INT 2
6373: PPUSH
6374: CALL_OW 12
6378: ARRAY
6379: PPUSH
6380: LD_INT 100
6382: PPUSH
6383: CALL 54433 0 5
// un := CreateVehicle ;
6387: LD_ADDR_VAR 0 2
6391: PUSH
6392: CALL_OW 45
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 5
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 5
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: LD_VAR 0 2
6431: PPUSH
6432: CALL 54555 0 3
6436: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6437: LD_VAR 0 2
6441: PPUSH
6442: LD_INT 0
6444: PPUSH
6445: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6449: LD_VAR 0 2
6453: PPUSH
6454: LD_INT 23
6456: PPUSH
6457: LD_INT 0
6459: PPUSH
6460: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6464: LD_VAR 0 2
6468: PPUSH
6469: LD_INT 85
6471: PPUSH
6472: LD_INT 152
6474: PPUSH
6475: CALL_OW 111
// wait ( 0 0$2 ) ;
6479: LD_INT 70
6481: PPUSH
6482: CALL_OW 67
// end ;
6486: GO 6330
6488: POP
6489: POP
// coords := [ [ 97 , 143 ] ] ;
6490: LD_ADDR_VAR 0 5
6494: PUSH
6495: LD_INT 97
6497: PUSH
6498: LD_INT 143
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: PUSH
6505: EMPTY
6506: LIST
6507: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6508: LD_INT 1
6510: PPUSH
6511: LD_VAR 0 3
6515: PUSH
6516: LD_INT 5
6518: ARRAY
6519: PPUSH
6520: LD_VAR 0 5
6524: PPUSH
6525: LD_VAR 0 6
6529: PPUSH
6530: CALL 41159 0 4
// end ; Wait ( 13 13$00 ) ;
6534: LD_INT 27300
6536: PPUSH
6537: CALL_OW 67
// tmp := [ ] ;
6541: LD_ADDR_VAR 0 3
6545: PUSH
6546: EMPTY
6547: ST_TO_ADDR
// w := 1 ;
6548: LD_ADDR_VAR 0 7
6552: PUSH
6553: LD_INT 1
6555: ST_TO_ADDR
// repeat tmp := [ ] ;
6556: LD_ADDR_VAR 0 3
6560: PUSH
6561: EMPTY
6562: ST_TO_ADDR
// if w mod 4 = 0 then
6563: LD_VAR 0 7
6567: PUSH
6568: LD_INT 4
6570: MOD
6571: PUSH
6572: LD_INT 0
6574: EQUAL
6575: IFFALSE 6662
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6577: LD_ADDR_VAR 0 8
6581: PUSH
6582: LD_INT 11
6584: PUSH
6585: LD_INT 1
6587: PUSH
6588: LD_INT 2
6590: PUSH
6591: LD_INT 24
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 11
6602: PUSH
6603: LD_INT 1
6605: PUSH
6606: LD_INT 2
6608: PUSH
6609: LD_INT 24
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 11
6620: PUSH
6621: LD_INT 1
6623: PUSH
6624: LD_INT 2
6626: PUSH
6627: LD_INT 24
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 11
6638: PUSH
6639: LD_INT 1
6641: PUSH
6642: LD_INT 2
6644: PUSH
6645: LD_INT 24
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: ST_TO_ADDR
6660: GO 6764
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6662: LD_ADDR_VAR 0 8
6666: PUSH
6667: LD_INT 14
6669: PUSH
6670: LD_INT 1
6672: PUSH
6673: LD_INT 2
6675: PUSH
6676: LD_INT 28
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 14
6687: PUSH
6688: LD_INT 1
6690: PUSH
6691: LD_INT 2
6693: PUSH
6694: LD_INT 25
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 14
6705: PUSH
6706: LD_INT 1
6708: PUSH
6709: LD_INT 2
6711: PUSH
6712: LD_INT 28
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 14
6723: PUSH
6724: LD_INT 1
6726: PUSH
6727: LD_INT 2
6729: PUSH
6730: LD_INT 29
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 11
6741: PUSH
6742: LD_INT 1
6744: PUSH
6745: LD_INT 2
6747: PUSH
6748: LD_INT 24
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// if w mod 3 = 0 then
6764: LD_VAR 0 7
6768: PUSH
6769: LD_INT 3
6771: MOD
6772: PUSH
6773: LD_INT 0
6775: EQUAL
6776: IFFALSE 6852
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6778: LD_ADDR_VAR 0 8
6782: PUSH
6783: LD_VAR 0 8
6787: PPUSH
6788: LD_INT 1
6790: PUSH
6791: LD_VAR 0 8
6795: PUSH
6796: LD_VAR 0 1
6800: ARRAY
6801: PUSH
6802: LD_INT 1
6804: PLUS
6805: PUSH
6806: EMPTY
6807: LIST
6808: LIST
6809: PPUSH
6810: LD_INT 14
6812: PUSH
6813: LD_INT 1
6815: PUSH
6816: LD_INT 2
6818: PUSH
6819: LD_INT 25
6821: PUSH
6822: LD_INT 28
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 1
6831: PPUSH
6832: LD_INT 2
6834: PPUSH
6835: CALL_OW 12
6839: ARRAY
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL 54555 0 3
6851: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6852: LD_INT 1
6854: PPUSH
6855: LD_VAR 0 8
6859: PPUSH
6860: CALL 40926 0 2
// if GetSide ( ar_dep_w ) = 2 then
6864: LD_INT 45
6866: PPUSH
6867: CALL_OW 255
6871: PUSH
6872: LD_INT 2
6874: EQUAL
6875: IFFALSE 6960
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6877: LD_ADDR_VAR 0 8
6881: PUSH
6882: LD_INT 14
6884: PUSH
6885: LD_INT 1
6887: PUSH
6888: LD_INT 2
6890: PUSH
6891: LD_INT 28
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 14
6902: PUSH
6903: LD_INT 1
6905: PUSH
6906: LD_INT 2
6908: PUSH
6909: LD_INT 27
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 14
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 2
6926: PUSH
6927: LD_INT 27
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6941: LD_INT 2
6943: PPUSH
6944: LD_VAR 0 8
6948: PPUSH
6949: CALL 40926 0 2
// wait ( 0 0$50 ) ;
6953: LD_INT 1750
6955: PPUSH
6956: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6967: LD_EXP 69
6971: PUSH
6972: LD_INT 1
6974: ARRAY
6975: PPUSH
6976: LD_INT 3
6978: PUSH
6979: LD_INT 34
6981: PUSH
6982: LD_INT 32
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 72
6997: PUSH
6998: LD_INT 4
7000: GREATEREQUAL
7001: IFFALSE 6960
// wait ( 0 0$10 ) ;
7003: LD_INT 350
7005: PPUSH
7006: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7010: LD_ADDR_VAR 0 3
7014: PUSH
7015: LD_EXP 69
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: PPUSH
7024: LD_INT 3
7026: PUSH
7027: LD_INT 34
7029: PUSH
7030: LD_INT 32
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PPUSH
7041: CALL_OW 72
7045: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7046: LD_INT 100
7048: PPUSH
7049: CALL_OW 13
7053: PUSH
7054: LD_INT 50
7056: LESS
7057: IFFALSE 7090
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7059: LD_ADDR_VAR 0 5
7063: PUSH
7064: LD_INT 55
7066: PUSH
7067: LD_INT 7
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: PUSH
7074: LD_INT 75
7076: PUSH
7077: LD_INT 90
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: ST_TO_ADDR
7088: GO 7119
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7090: LD_ADDR_VAR 0 5
7094: PUSH
7095: LD_INT 128
7097: PUSH
7098: LD_INT 94
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 180
7107: PUSH
7108: LD_INT 135
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: EMPTY
7116: LIST
7117: LIST
7118: ST_TO_ADDR
// if w mod 4 = 0 then
7119: LD_VAR 0 7
7123: PUSH
7124: LD_INT 4
7126: MOD
7127: PUSH
7128: LD_INT 0
7130: EQUAL
7131: IFFALSE 7162
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7133: LD_ADDR_VAR 0 5
7137: PUSH
7138: LD_INT 91
7140: PUSH
7141: LD_INT 58
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 117
7150: PUSH
7151: LD_INT 107
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
7162: LD_INT 1
7164: PPUSH
7165: LD_VAR 0 3
7169: PPUSH
7170: LD_VAR 0 5
7174: PPUSH
7175: LD_VAR 0 6
7179: PPUSH
7180: CALL 41159 0 4
// if mc_vehicles [ 2 ] then
7184: LD_EXP 69
7188: PUSH
7189: LD_INT 2
7191: ARRAY
7192: IFFALSE 7228
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7194: LD_INT 2
7196: PPUSH
7197: LD_EXP 69
7201: PUSH
7202: LD_INT 2
7204: ARRAY
7205: PPUSH
7206: LD_INT 73
7208: PUSH
7209: LD_INT 115
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: LD_VAR 0 6
7223: PPUSH
7224: CALL 41159 0 4
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7228: LD_INT 22050
7230: PPUSH
7231: LD_INT 28350
7233: PPUSH
7234: CALL_OW 12
7238: PPUSH
7239: CALL_OW 67
// w := w + 1 ;
7243: LD_ADDR_VAR 0 7
7247: PUSH
7248: LD_VAR 0 7
7252: PUSH
7253: LD_INT 1
7255: PLUS
7256: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7257: LD_INT 94
7259: PPUSH
7260: CALL_OW 301
7264: PUSH
7265: LD_EXP 50
7269: PUSH
7270: LD_INT 1
7272: ARRAY
7273: PPUSH
7274: LD_INT 30
7276: PUSH
7277: LD_INT 3
7279: PUSH
7280: EMPTY
7281: LIST
7282: LIST
7283: PPUSH
7284: CALL_OW 72
7288: NOT
7289: OR
7290: IFFALSE 6556
// end ;
7292: PPOPN 8
7294: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7295: LD_INT 204
7297: IFFALSE 7771
7299: GO 7301
7301: DISABLE
7302: LD_INT 0
7304: PPUSH
7305: PPUSH
7306: PPUSH
7307: PPUSH
// begin enable ;
7308: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7309: LD_INT 35
7311: PPUSH
7312: LD_INT 1190
7314: PPUSH
7315: CALL_OW 12
7319: PPUSH
7320: CALL_OW 67
// tmp := [ ] ;
7324: LD_ADDR_VAR 0 2
7328: PUSH
7329: EMPTY
7330: ST_TO_ADDR
// uc_side := 8 ;
7331: LD_ADDR_OWVAR 20
7335: PUSH
7336: LD_INT 8
7338: ST_TO_ADDR
// uc_nation := 2 ;
7339: LD_ADDR_OWVAR 21
7343: PUSH
7344: LD_INT 2
7346: ST_TO_ADDR
// InitHc ;
7347: CALL_OW 19
// for i = 1 to 3 do
7351: LD_ADDR_VAR 0 1
7355: PUSH
7356: DOUBLE
7357: LD_INT 1
7359: DEC
7360: ST_TO_ADDR
7361: LD_INT 3
7363: PUSH
7364: FOR_TO
7365: IFFALSE 7492
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7367: LD_INT 13
7369: PUSH
7370: LD_INT 14
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: PUSH
7377: LD_INT 1
7379: PPUSH
7380: LD_INT 2
7382: PPUSH
7383: CALL_OW 12
7387: ARRAY
7388: PPUSH
7389: LD_INT 3
7391: PPUSH
7392: LD_INT 5
7394: PPUSH
7395: LD_INT 27
7397: PUSH
7398: LD_INT 28
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 1
7407: PPUSH
7408: LD_INT 2
7410: PPUSH
7411: CALL_OW 12
7415: ARRAY
7416: PPUSH
7417: LD_INT 100
7419: PPUSH
7420: CALL 54433 0 5
// un := CreateVehicle ;
7424: LD_ADDR_VAR 0 3
7428: PUSH
7429: CALL_OW 45
7433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7434: LD_VAR 0 3
7438: PPUSH
7439: LD_INT 4
7441: PPUSH
7442: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7446: LD_VAR 0 3
7450: PPUSH
7451: LD_INT 15
7453: PPUSH
7454: LD_INT 0
7456: PPUSH
7457: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7461: LD_ADDR_VAR 0 2
7465: PUSH
7466: LD_VAR 0 2
7470: PPUSH
7471: LD_VAR 0 2
7475: PUSH
7476: LD_INT 1
7478: PLUS
7479: PPUSH
7480: LD_VAR 0 3
7484: PPUSH
7485: CALL_OW 1
7489: ST_TO_ADDR
// end ;
7490: GO 7364
7492: POP
7493: POP
// for i = 1 to 4 do
7494: LD_ADDR_VAR 0 1
7498: PUSH
7499: DOUBLE
7500: LD_INT 1
7502: DEC
7503: ST_TO_ADDR
7504: LD_INT 4
7506: PUSH
7507: FOR_TO
7508: IFFALSE 7587
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7510: LD_INT 0
7512: PPUSH
7513: LD_INT 1
7515: PPUSH
7516: LD_INT 4
7518: PPUSH
7519: CALL_OW 12
7523: PPUSH
7524: LD_INT 6
7526: PPUSH
7527: CALL_OW 380
// un := CreateHuman ;
7531: LD_ADDR_VAR 0 3
7535: PUSH
7536: CALL_OW 44
7540: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7541: LD_VAR 0 3
7545: PPUSH
7546: LD_INT 15
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_VAR 0 2
7565: PPUSH
7566: LD_VAR 0 2
7570: PUSH
7571: LD_INT 1
7573: PLUS
7574: PPUSH
7575: LD_VAR 0 3
7579: PPUSH
7580: CALL_OW 1
7584: ST_TO_ADDR
// end ;
7585: GO 7507
7587: POP
7588: POP
// wait ( 0 0$3 ) ;
7589: LD_INT 105
7591: PPUSH
7592: CALL_OW 67
// for i in tmp do
7596: LD_ADDR_VAR 0 1
7600: PUSH
7601: LD_VAR 0 2
7605: PUSH
7606: FOR_IN
7607: IFFALSE 7675
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
7609: LD_VAR 0 1
7613: PPUSH
7614: CALL_OW 257
7618: PUSH
7619: LD_INT 1
7621: EQUAL
7622: PUSH
7623: LD_VAR 0 1
7627: PPUSH
7628: CALL_OW 247
7632: PUSH
7633: LD_INT 2
7635: EQUAL
7636: OR
7637: IFFALSE 7673
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7639: LD_VAR 0 1
7643: PPUSH
7644: LD_INT 81
7646: PUSH
7647: LD_INT 8
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PPUSH
7654: CALL_OW 69
7658: PPUSH
7659: LD_VAR 0 1
7663: PPUSH
7664: CALL_OW 74
7668: PPUSH
7669: CALL_OW 115
7673: GO 7606
7675: POP
7676: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
7677: LD_VAR 0 2
7681: PPUSH
7682: LD_INT 210
7684: PPUSH
7685: LD_INT 178
7687: PPUSH
7688: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7692: LD_ADDR_VAR 0 4
7696: PUSH
7697: LD_INT 10
7699: PPUSH
7700: LD_INT 22
7702: PUSH
7703: LD_INT 8
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PPUSH
7710: CALL_OW 70
7714: ST_TO_ADDR
// if x then
7715: LD_VAR 0 4
7719: IFFALSE 7747
// for i in x do
7721: LD_ADDR_VAR 0 1
7725: PUSH
7726: LD_VAR 0 4
7730: PUSH
7731: FOR_IN
7732: IFFALSE 7745
// RemoveUnit ( i ) ;
7734: LD_VAR 0 1
7738: PPUSH
7739: CALL_OW 64
7743: GO 7731
7745: POP
7746: POP
// wait ( 0 0$1 ) ;
7747: LD_INT 35
7749: PPUSH
7750: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
7754: LD_INT 22
7756: PUSH
7757: LD_INT 8
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PPUSH
7764: CALL_OW 69
7768: NOT
7769: IFFALSE 7677
// end ;
7771: PPOPN 4
7773: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7774: LD_INT 22
7776: PUSH
7777: LD_INT 2
7779: PUSH
7780: EMPTY
7781: LIST
7782: LIST
7783: PUSH
7784: LD_INT 34
7786: PUSH
7787: LD_INT 31
7789: PUSH
7790: EMPTY
7791: LIST
7792: LIST
7793: PUSH
7794: LD_INT 3
7796: PUSH
7797: LD_INT 24
7799: PUSH
7800: LD_INT 1000
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: IFFALSE 7864
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7825: LD_INT 22
7827: PUSH
7828: LD_INT 2
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 34
7837: PUSH
7838: LD_INT 31
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: PPUSH
7849: CALL_OW 69
7853: PPUSH
7854: LD_INT 106
7856: PPUSH
7857: LD_INT 14
7859: PPUSH
7860: CALL_OW 111
// end ; end_of_file
7864: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7865: LD_INT 0
7867: PPUSH
7868: PPUSH
7869: PPUSH
7870: PPUSH
7871: PPUSH
7872: PPUSH
// InGameOn ;
7873: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7877: LD_EXP 21
7881: PPUSH
7882: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7886: LD_INT 2
7888: PPUSH
7889: LD_INT 1
7891: PPUSH
7892: LD_INT 1
7894: PPUSH
7895: LD_INT 1
7897: PPUSH
7898: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7902: LD_ADDR_VAR 0 2
7906: PUSH
7907: LD_INT 22
7909: PUSH
7910: LD_INT 1
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 25
7919: PUSH
7920: LD_INT 1
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: PPUSH
7931: CALL_OW 69
7935: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7936: LD_ADDR_VAR 0 4
7940: PUSH
7941: LD_INT 22
7943: PUSH
7944: LD_INT 1
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PUSH
7951: LD_INT 34
7953: PUSH
7954: LD_INT 11
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: PPUSH
7965: CALL_OW 69
7969: PUSH
7970: LD_INT 1
7972: ARRAY
7973: ST_TO_ADDR
// for i = 1 to tmp do
7974: LD_ADDR_VAR 0 6
7978: PUSH
7979: DOUBLE
7980: LD_INT 1
7982: DEC
7983: ST_TO_ADDR
7984: LD_VAR 0 2
7988: PUSH
7989: FOR_TO
7990: IFFALSE 8037
// begin if i = 5 then
7992: LD_VAR 0 6
7996: PUSH
7997: LD_INT 5
7999: EQUAL
8000: IFFALSE 8004
// break ;
8002: GO 8037
// sols := Replace ( sols , i , tmp [ i ] ) ;
8004: LD_ADDR_VAR 0 5
8008: PUSH
8009: LD_VAR 0 5
8013: PPUSH
8014: LD_VAR 0 6
8018: PPUSH
8019: LD_VAR 0 2
8023: PUSH
8024: LD_VAR 0 6
8028: ARRAY
8029: PPUSH
8030: CALL_OW 1
8034: ST_TO_ADDR
// end ;
8035: GO 7989
8037: POP
8038: POP
// tmp := ar_force_tmp ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_EXP 40
8048: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8049: LD_VAR 0 2
8053: PUSH
8054: LD_INT 1
8056: ARRAY
8057: PPUSH
8058: LD_INT 108
8060: PPUSH
8061: LD_INT 139
8063: PPUSH
8064: LD_INT 0
8066: PPUSH
8067: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8071: LD_VAR 0 2
8075: PUSH
8076: LD_INT 1
8078: ARRAY
8079: PPUSH
8080: LD_EXP 21
8084: PPUSH
8085: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8089: LD_VAR 0 2
8093: PUSH
8094: LD_INT 2
8096: ARRAY
8097: PPUSH
8098: LD_INT 114
8100: PPUSH
8101: LD_INT 132
8103: PPUSH
8104: LD_INT 0
8106: PPUSH
8107: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8111: LD_VAR 0 2
8115: PUSH
8116: LD_INT 3
8118: ARRAY
8119: PPUSH
8120: LD_INT 115
8122: PPUSH
8123: LD_INT 132
8125: PPUSH
8126: LD_INT 0
8128: PPUSH
8129: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8133: LD_VAR 0 2
8137: PUSH
8138: LD_INT 2
8140: ARRAY
8141: PUSH
8142: LD_VAR 0 2
8146: PUSH
8147: LD_INT 3
8149: ARRAY
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PPUSH
8155: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8159: LD_VAR 0 4
8163: PPUSH
8164: LD_INT 83
8166: PPUSH
8167: LD_INT 123
8169: PPUSH
8170: CALL_OW 111
// Wait ( 0 0$01 ) ;
8174: LD_INT 35
8176: PPUSH
8177: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8181: LD_INT 90
8183: PPUSH
8184: LD_INT 144
8186: PPUSH
8187: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8191: LD_VAR 0 5
8195: PPUSH
8196: LD_INT 88
8198: PPUSH
8199: LD_INT 129
8201: PPUSH
8202: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8206: LD_ADDR_VAR 0 3
8210: PUSH
8211: LD_INT 92
8213: PUSH
8214: LD_INT 131
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: LD_INT 88
8223: PUSH
8224: LD_INT 127
8226: PUSH
8227: EMPTY
8228: LIST
8229: LIST
8230: PUSH
8231: LD_INT 91
8233: PUSH
8234: LD_INT 132
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 92
8243: PUSH
8244: LD_INT 134
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: LIST
8255: LIST
8256: ST_TO_ADDR
// for i = 1 to sols do
8257: LD_ADDR_VAR 0 6
8261: PUSH
8262: DOUBLE
8263: LD_INT 1
8265: DEC
8266: ST_TO_ADDR
8267: LD_VAR 0 5
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8346
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8275: LD_VAR 0 5
8279: PUSH
8280: LD_VAR 0 6
8284: ARRAY
8285: PPUSH
8286: LD_VAR 0 3
8290: PUSH
8291: LD_VAR 0 6
8295: ARRAY
8296: PUSH
8297: LD_INT 1
8299: ARRAY
8300: PPUSH
8301: LD_VAR 0 3
8305: PUSH
8306: LD_VAR 0 6
8310: ARRAY
8311: PUSH
8312: LD_INT 2
8314: ARRAY
8315: PPUSH
8316: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8320: LD_VAR 0 5
8324: PUSH
8325: LD_VAR 0 6
8329: ARRAY
8330: PPUSH
8331: CALL_OW 197
// AddComHold ( sols ) ;
8335: LD_VAR 0 5
8339: PPUSH
8340: CALL_OW 200
// end ;
8344: GO 8272
8346: POP
8347: POP
// repeat wait ( 0 0$1 ) ;
8348: LD_INT 35
8350: PPUSH
8351: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8355: LD_VAR 0 5
8359: PUSH
8360: LD_INT 1
8362: ARRAY
8363: PPUSH
8364: LD_INT 92
8366: PPUSH
8367: LD_INT 131
8369: PPUSH
8370: CALL_OW 297
8374: PUSH
8375: LD_INT 4
8377: LESS
8378: IFFALSE 8348
// CenterOnXY ( 96 , 139 ) ;
8380: LD_INT 96
8382: PPUSH
8383: LD_INT 139
8385: PPUSH
8386: CALL_OW 84
// wait ( 0 0$3 ) ;
8390: LD_INT 105
8392: PPUSH
8393: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8397: LD_INT 111
8399: PPUSH
8400: LD_INT 135
8402: PPUSH
8403: LD_INT 1
8405: PPUSH
8406: LD_INT 25
8408: NEG
8409: PPUSH
8410: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8414: LD_VAR 0 2
8418: PUSH
8419: LD_INT 2
8421: ARRAY
8422: PPUSH
8423: LD_VAR 0 2
8427: PUSH
8428: LD_INT 1
8430: ARRAY
8431: PPUSH
8432: CALL_OW 250
8436: PUSH
8437: LD_INT 3
8439: PLUS
8440: PPUSH
8441: LD_VAR 0 2
8445: PUSH
8446: LD_INT 1
8448: ARRAY
8449: PPUSH
8450: CALL_OW 251
8454: PPUSH
8455: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8459: LD_VAR 0 2
8463: PUSH
8464: LD_INT 3
8466: ARRAY
8467: PPUSH
8468: LD_INT 7
8470: PPUSH
8471: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8475: LD_VAR 0 2
8479: PUSH
8480: LD_INT 2
8482: ARRAY
8483: PPUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_INT 1
8491: ARRAY
8492: PPUSH
8493: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8497: LD_INT 35
8499: PPUSH
8500: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8504: LD_VAR 0 2
8508: PUSH
8509: LD_INT 1
8511: ARRAY
8512: PPUSH
8513: LD_VAR 0 2
8517: PUSH
8518: LD_INT 2
8520: ARRAY
8521: PPUSH
8522: CALL_OW 296
8526: PUSH
8527: LD_INT 5
8529: LESS
8530: IFFALSE 8497
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8532: LD_VAR 0 2
8536: PUSH
8537: LD_INT 1
8539: ARRAY
8540: PPUSH
8541: LD_VAR 0 2
8545: PUSH
8546: LD_INT 2
8548: ARRAY
8549: PPUSH
8550: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8554: LD_VAR 0 2
8558: PUSH
8559: LD_INT 1
8561: ARRAY
8562: PPUSH
8563: LD_STRING D1a-Merc1-1
8565: PPUSH
8566: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8570: LD_VAR 0 2
8574: PUSH
8575: LD_INT 2
8577: ARRAY
8578: PPUSH
8579: LD_STRING D1a-FMerc2-1
8581: PPUSH
8582: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8586: LD_VAR 0 2
8590: PUSH
8591: LD_INT 2
8593: ARRAY
8594: PPUSH
8595: LD_VAR 0 2
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: PPUSH
8604: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8608: LD_VAR 0 2
8612: PUSH
8613: LD_INT 1
8615: ARRAY
8616: PPUSH
8617: LD_INT 500
8619: PPUSH
8620: CALL_OW 234
// wait ( 0 0$2 ) ;
8624: LD_INT 70
8626: PPUSH
8627: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8631: LD_VAR 0 2
8635: PUSH
8636: LD_INT 1
8638: ARRAY
8639: PPUSH
8640: LD_INT 2
8642: PPUSH
8643: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8647: LD_INT 10
8649: PPUSH
8650: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8654: LD_VAR 0 2
8658: PUSH
8659: LD_INT 1
8661: ARRAY
8662: PPUSH
8663: LD_STRING D1a-Merc1-2
8665: PPUSH
8666: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8670: LD_INT 7
8672: PPUSH
8673: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8677: LD_VAR 0 2
8681: PUSH
8682: LD_INT 1
8684: ARRAY
8685: PPUSH
8686: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8690: LD_VAR 0 2
8694: PUSH
8695: LD_INT 2
8697: ARRAY
8698: PPUSH
8699: LD_INT 10
8701: PPUSH
8702: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8706: LD_VAR 0 2
8710: PUSH
8711: LD_INT 2
8713: ARRAY
8714: PPUSH
8715: LD_STRING D1a-FMerc2-2
8717: PPUSH
8718: CALL_OW 88
// wait ( 0 0$1 ) ;
8722: LD_INT 35
8724: PPUSH
8725: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8729: LD_INT 7
8731: PPUSH
8732: CALL_OW 85
// wait ( 0 0$2 ) ;
8736: LD_INT 70
8738: PPUSH
8739: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8743: LD_EXP 44
8747: PPUSH
8748: LD_STRING D1a-Saliba-1
8750: PPUSH
8751: CALL_OW 91
// KillUnit ( Saliba ) ;
8755: LD_EXP 44
8759: PPUSH
8760: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8764: LD_VAR 0 2
8768: PUSH
8769: LD_INT 3
8771: ARRAY
8772: PPUSH
8773: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8777: LD_EXP 21
8781: PPUSH
8782: CALL_OW 85
// wait ( 0 0$1 ) ;
8786: LD_INT 35
8788: PPUSH
8789: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8793: LD_VAR 0 5
8797: PPUSH
8798: LD_INT 88
8800: PPUSH
8801: LD_INT 141
8803: PPUSH
8804: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8808: LD_VAR 0 5
8812: PPUSH
8813: LD_INT 70
8815: PPUSH
8816: CALL_OW 202
// wait ( 0 0$2 ) ;
8820: LD_INT 70
8822: PPUSH
8823: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8827: LD_INT 2
8829: PPUSH
8830: LD_INT 1
8832: PPUSH
8833: LD_INT 2
8835: PPUSH
8836: LD_INT 1
8838: PPUSH
8839: CALL_OW 80
// InGameOff ;
8843: CALL_OW 9
// ComWalk ( sols ) ;
8847: LD_VAR 0 5
8851: PPUSH
8852: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8856: LD_STRING M1
8858: PPUSH
8859: CALL_OW 337
// game_speed := 4 ;
8863: LD_ADDR_OWVAR 65
8867: PUSH
8868: LD_INT 4
8870: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8871: LD_INT 111
8873: PPUSH
8874: LD_INT 135
8876: PPUSH
8877: LD_INT 1
8879: PPUSH
8880: CALL_OW 331
// SaveForQuickRestart ;
8884: CALL_OW 22
// ar_run := true ;
8888: LD_ADDR_EXP 5
8892: PUSH
8893: LD_INT 1
8895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8896: LD_INT 35
8898: PPUSH
8899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8903: LD_INT 22
8905: PUSH
8906: LD_INT 1
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PUSH
8913: LD_INT 91
8915: PUSH
8916: LD_INT 7
8918: PUSH
8919: LD_INT 10
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: LIST
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: PPUSH
8931: CALL_OW 69
8935: PUSH
8936: LD_INT 7
8938: PPUSH
8939: CALL_OW 256
8943: PUSH
8944: LD_INT 999
8946: LESS
8947: OR
8948: IFFALSE 8896
// if GetSide ( ar_dep_s ) = 2 then
8950: LD_INT 7
8952: PPUSH
8953: CALL_OW 255
8957: PUSH
8958: LD_INT 2
8960: EQUAL
8961: IFFALSE 8973
// SetSide ( ar_dep_s , 1 ) ;
8963: LD_INT 7
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: CALL_OW 235
// end ;
8973: LD_VAR 0 1
8977: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8978: LD_EXP 5
8982: IFFALSE 9342
8984: GO 8986
8986: DISABLE
8987: LD_INT 0
8989: PPUSH
8990: PPUSH
8991: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8992: LD_ADDR_VAR 0 2
8996: PUSH
8997: LD_EXP 40
9001: PUSH
9002: LD_EXP 36
9006: PPUSH
9007: LD_INT 2
9009: PUSH
9010: LD_INT 21
9012: PUSH
9013: LD_INT 2
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: LD_INT 21
9022: PUSH
9023: LD_INT 1
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL_OW 72
9039: ADD
9040: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: LD_INT 5
9048: PPUSH
9049: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9053: LD_INT 5
9055: PPUSH
9056: LD_INT 1
9058: PPUSH
9059: CALL_OW 343
// k := 1 ;
9063: LD_ADDR_VAR 0 3
9067: PUSH
9068: LD_INT 1
9070: ST_TO_ADDR
// for i in tmp do
9071: LD_ADDR_VAR 0 1
9075: PUSH
9076: LD_VAR 0 2
9080: PUSH
9081: FOR_IN
9082: IFFALSE 9167
// begin if IsInUnit ( i ) then
9084: LD_VAR 0 1
9088: PPUSH
9089: CALL_OW 310
9093: IFFALSE 9104
// ComExitBuilding ( i ) ;
9095: LD_VAR 0 1
9099: PPUSH
9100: CALL_OW 122
// if GetClass ( i ) = 3 then
9104: LD_VAR 0 1
9108: PPUSH
9109: CALL_OW 257
9113: PUSH
9114: LD_INT 3
9116: EQUAL
9117: IFFALSE 9153
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9119: LD_VAR 0 1
9123: PPUSH
9124: LD_EXP 41
9128: PUSH
9129: LD_VAR 0 3
9133: ARRAY
9134: PPUSH
9135: CALL_OW 180
// k := k + 1 ;
9139: LD_ADDR_VAR 0 3
9143: PUSH
9144: LD_VAR 0 3
9148: PUSH
9149: LD_INT 1
9151: PLUS
9152: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_INT 10
9160: PPUSH
9161: CALL_OW 173
// end ;
9165: GO 9081
9167: POP
9168: POP
// ar_patrol := true ;
9169: LD_ADDR_EXP 7
9173: PUSH
9174: LD_INT 1
9176: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9177: LD_INT 10
9179: PPUSH
9180: CALL_OW 67
// for i in tmp do
9184: LD_ADDR_VAR 0 1
9188: PUSH
9189: LD_VAR 0 2
9193: PUSH
9194: FOR_IN
9195: IFFALSE 9223
// if not HasTask ( i ) then
9197: LD_VAR 0 1
9201: PPUSH
9202: CALL_OW 314
9206: NOT
9207: IFFALSE 9221
// ComMoveToArea ( i , escape_area ) ;
9209: LD_VAR 0 1
9213: PPUSH
9214: LD_INT 10
9216: PPUSH
9217: CALL_OW 113
9221: GO 9194
9223: POP
9224: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9225: LD_ADDR_VAR 0 3
9229: PUSH
9230: LD_VAR 0 2
9234: PPUSH
9235: LD_INT 95
9237: PUSH
9238: LD_INT 10
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 72
9249: ST_TO_ADDR
// if k then
9250: LD_VAR 0 3
9254: IFFALSE 9323
// for i in k do
9256: LD_ADDR_VAR 0 1
9260: PUSH
9261: LD_VAR 0 3
9265: PUSH
9266: FOR_IN
9267: IFFALSE 9321
// begin if IsInUnit ( i ) then
9269: LD_VAR 0 1
9273: PPUSH
9274: CALL_OW 310
9278: IFFALSE 9294
// RemoveUnit ( IsInUnit ( i ) ) ;
9280: LD_VAR 0 1
9284: PPUSH
9285: CALL_OW 310
9289: PPUSH
9290: CALL_OW 64
// RemoveUnit ( i ) ;
9294: LD_VAR 0 1
9298: PPUSH
9299: CALL_OW 64
// tmp := tmp diff i ;
9303: LD_ADDR_VAR 0 2
9307: PUSH
9308: LD_VAR 0 2
9312: PUSH
9313: LD_VAR 0 1
9317: DIFF
9318: ST_TO_ADDR
// end ;
9319: GO 9266
9321: POP
9322: POP
// until tmp = [ ] ;
9323: LD_VAR 0 2
9327: PUSH
9328: EMPTY
9329: EQUAL
9330: IFFALSE 9177
// ChangeSideFog ( 5 , 5 ) ;
9332: LD_INT 5
9334: PPUSH
9335: LD_INT 5
9337: PPUSH
9338: CALL_OW 343
// end ;
9342: PPOPN 3
9344: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9345: LD_EXP 7
9349: IFFALSE 9639
9351: GO 9353
9353: DISABLE
9354: LD_INT 0
9356: PPUSH
9357: PPUSH
9358: PPUSH
// begin uc_side := 2 ;
9359: LD_ADDR_OWVAR 20
9363: PUSH
9364: LD_INT 2
9366: ST_TO_ADDR
// uc_nation := 2 ;
9367: LD_ADDR_OWVAR 21
9371: PUSH
9372: LD_INT 2
9374: ST_TO_ADDR
// InitHc ;
9375: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9379: LD_INT 1
9381: PPUSH
9382: LD_INT 1
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: CALL_OW 380
// un := CreateHuman ;
9392: LD_ADDR_VAR 0 2
9396: PUSH
9397: CALL_OW 44
9401: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9402: LD_INT 14
9404: PPUSH
9405: LD_INT 1
9407: PPUSH
9408: LD_INT 1
9410: PPUSH
9411: LD_INT 27
9413: PPUSH
9414: LD_INT 98
9416: PPUSH
9417: CALL 54433 0 5
// veh := CreateVehicle ;
9421: LD_ADDR_VAR 0 3
9425: PUSH
9426: CALL_OW 45
9430: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9431: LD_VAR 0 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9443: LD_VAR 0 3
9447: PPUSH
9448: LD_INT 179
9450: PPUSH
9451: LD_INT 135
9453: PPUSH
9454: LD_INT 0
9456: PPUSH
9457: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9461: LD_VAR 0 2
9465: PPUSH
9466: LD_VAR 0 3
9470: PPUSH
9471: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9475: LD_VAR 0 2
9479: PPUSH
9480: LD_INT 126
9482: PPUSH
9483: LD_INT 133
9485: PPUSH
9486: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9490: LD_INT 10
9492: PPUSH
9493: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9497: LD_INT 1
9499: PPUSH
9500: LD_VAR 0 3
9504: PPUSH
9505: CALL_OW 292
9509: PUSH
9510: LD_VAR 0 3
9514: PPUSH
9515: LD_INT 7
9517: PPUSH
9518: CALL_OW 296
9522: PUSH
9523: LD_INT 9
9525: LESS
9526: OR
9527: IFFALSE 9490
// ComHold ( veh ) ;
9529: LD_VAR 0 3
9533: PPUSH
9534: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9538: LD_VAR 0 2
9542: PPUSH
9543: LD_STRING D2aa-Ar1-1
9545: PPUSH
9546: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9550: LD_VAR 0 2
9554: PPUSH
9555: LD_INT 177
9557: PPUSH
9558: LD_INT 96
9560: PPUSH
9561: CALL_OW 111
// AddComExitVehicle ( un ) ;
9565: LD_VAR 0 2
9569: PPUSH
9570: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9574: LD_INT 35
9576: PPUSH
9577: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9581: LD_VAR 0 2
9585: PPUSH
9586: LD_INT 204
9588: PPUSH
9589: CALL_OW 296
9593: PUSH
9594: LD_INT 15
9596: LESS
9597: IFFALSE 9574
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9599: LD_ADDR_EXP 50
9603: PUSH
9604: LD_EXP 50
9608: PPUSH
9609: LD_INT 3
9611: PUSH
9612: LD_EXP 50
9616: PUSH
9617: LD_INT 3
9619: ARRAY
9620: PUSH
9621: LD_INT 1
9623: PLUS
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL 54555 0 3
9638: ST_TO_ADDR
// end ;
9639: PPOPN 3
9641: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9642: LD_INT 7
9644: PPUSH
9645: CALL_OW 255
9649: PUSH
9650: LD_INT 1
9652: EQUAL
9653: PUSH
9654: LD_INT 7
9656: PPUSH
9657: CALL_OW 301
9661: OR
9662: IFFALSE 12086
9664: GO 9666
9666: DISABLE
9667: LD_INT 0
9669: PPUSH
9670: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9671: LD_ADDR_VAR 0 1
9675: PUSH
9676: LD_EXP 36
9680: PPUSH
9681: LD_INT 21
9683: PUSH
9684: LD_INT 3
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 72
9695: PUSH
9696: FOR_IN
9697: IFFALSE 9713
// SetSide ( i , 1 ) ;
9699: LD_VAR 0 1
9703: PPUSH
9704: LD_INT 1
9706: PPUSH
9707: CALL_OW 235
9711: GO 9696
9713: POP
9714: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9715: LD_ADDR_VAR 0 2
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: LD_INT 41
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: LD_INT 50
9732: PUSH
9733: LD_INT 25
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 57
9742: PUSH
9743: LD_INT 75
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: LD_INT 75
9752: PUSH
9753: LD_INT 89
9755: PUSH
9756: EMPTY
9757: LIST
9758: LIST
9759: PUSH
9760: LD_INT 51
9762: PUSH
9763: LD_INT 45
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PUSH
9770: LD_INT 95
9772: PUSH
9773: LD_INT 95
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: PUSH
9780: LD_INT 84
9782: PUSH
9783: LD_INT 77
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: PUSH
9790: LD_INT 101
9792: PUSH
9793: LD_INT 76
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: LD_INT 118
9802: PUSH
9803: LD_INT 81
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: PUSH
9810: LD_INT 139
9812: PUSH
9813: LD_INT 97
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: PUSH
9820: LD_INT 129
9822: PUSH
9823: LD_INT 114
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: PUSH
9830: LD_INT 154
9832: PUSH
9833: LD_INT 111
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: LIST
9848: LIST
9849: LIST
9850: LIST
9851: LIST
9852: LIST
9853: ST_TO_ADDR
// base_captured := true ;
9854: LD_ADDR_EXP 6
9858: PUSH
9859: LD_INT 1
9861: ST_TO_ADDR
// DialogueOn ;
9862: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9866: LD_EXP 21
9870: PPUSH
9871: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9875: LD_EXP 21
9879: PPUSH
9880: LD_STRING D2-JMM-1
9882: PPUSH
9883: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9887: LD_EXP 30
9891: PPUSH
9892: LD_STRING D2-Pow-1
9894: PPUSH
9895: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9899: LD_EXP 21
9903: PPUSH
9904: LD_STRING D2-JMM-2
9906: PPUSH
9907: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9911: LD_EXP 30
9915: PPUSH
9916: LD_STRING D2-Pow-2
9918: PPUSH
9919: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9923: LD_EXP 21
9927: PPUSH
9928: LD_STRING D2-JMM-3
9930: PPUSH
9931: CALL_OW 88
// DialogueOff ;
9935: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9939: LD_STRING M2
9941: PPUSH
9942: CALL_OW 337
// Wait ( 0 0$2 ) ;
9946: LD_INT 70
9948: PPUSH
9949: CALL_OW 67
// if IsOk ( Gary ) then
9953: LD_EXP 32
9957: PPUSH
9958: CALL_OW 302
9962: IFFALSE 9976
// Say ( Gary , D2a-Gary-1 ) ;
9964: LD_EXP 32
9968: PPUSH
9969: LD_STRING D2a-Gary-1
9971: PPUSH
9972: CALL_OW 88
// if IsOk ( Bobby ) then
9976: LD_EXP 24
9980: PPUSH
9981: CALL_OW 302
9985: IFFALSE 9999
// Say ( Bobby , D2a-Bobby-1 ) ;
9987: LD_EXP 24
9991: PPUSH
9992: LD_STRING D2a-Bobby-1
9994: PPUSH
9995: CALL_OW 88
// if IsOk ( Cyrus ) then
9999: LD_EXP 25
10003: PPUSH
10004: CALL_OW 302
10008: IFFALSE 10022
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10010: LD_EXP 25
10014: PPUSH
10015: LD_STRING D2a-Cyrus-1
10017: PPUSH
10018: CALL_OW 88
// if IsOk ( Lisa ) then
10022: LD_EXP 22
10026: PPUSH
10027: CALL_OW 302
10031: IFFALSE 10045
// Say ( Lisa , D2a-Lisa-1 ) ;
10033: LD_EXP 22
10037: PPUSH
10038: LD_STRING D2a-Lisa-1
10040: PPUSH
10041: CALL_OW 88
// if IsOk ( Frank ) then
10045: LD_EXP 33
10049: PPUSH
10050: CALL_OW 302
10054: IFFALSE 10068
// Say ( Frank , D2a-Frank-1 ) ;
10056: LD_EXP 33
10060: PPUSH
10061: LD_STRING D2a-Frank-1
10063: PPUSH
10064: CALL_OW 88
// if IsOk ( Cornel ) then
10068: LD_EXP 31
10072: PPUSH
10073: CALL_OW 302
10077: IFFALSE 10091
// Say ( Cornel , D2a-Corn-1 ) ;
10079: LD_EXP 31
10083: PPUSH
10084: LD_STRING D2a-Corn-1
10086: PPUSH
10087: CALL_OW 88
// if IsOk ( Donaldson ) then
10091: LD_EXP 23
10095: PPUSH
10096: CALL_OW 302
10100: IFFALSE 10114
// Say ( Donaldson , D2a-Don-1 ) ;
10102: LD_EXP 23
10106: PPUSH
10107: LD_STRING D2a-Don-1
10109: PPUSH
10110: CALL_OW 88
// if IsOk ( Brown ) then
10114: LD_EXP 27
10118: PPUSH
10119: CALL_OW 302
10123: IFFALSE 10137
// Say ( Brown , D2a-Brown-1 ) ;
10125: LD_EXP 27
10129: PPUSH
10130: LD_STRING D2a-Brown-1
10132: PPUSH
10133: CALL_OW 88
// Wait ( 0 0$30 ) ;
10137: LD_INT 1050
10139: PPUSH
10140: CALL_OW 67
// if IsOk ( Frank ) then
10144: LD_EXP 33
10148: PPUSH
10149: CALL_OW 302
10153: IFFALSE 10419
// begin DialogueOn ;
10155: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10159: LD_EXP 21
10163: PUSH
10164: LD_EXP 33
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10177: LD_EXP 33
10181: PPUSH
10182: LD_STRING D3F-Frank-1
10184: PPUSH
10185: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10189: LD_EXP 21
10193: PPUSH
10194: LD_STRING D3F-JMM-1
10196: PPUSH
10197: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10201: LD_EXP 33
10205: PPUSH
10206: LD_STRING D3F-Frank-2
10208: PPUSH
10209: CALL_OW 88
// case Query ( QFrank ) of 1 :
10213: LD_STRING QFrank
10215: PPUSH
10216: CALL_OW 97
10220: PUSH
10221: LD_INT 1
10223: DOUBLE
10224: EQUAL
10225: IFTRUE 10229
10227: GO 10252
10229: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10230: LD_EXP 21
10234: PPUSH
10235: LD_STRING D3Fa-JMM-1
10237: PPUSH
10238: CALL_OW 88
// us_scout := 1 ;
10242: LD_ADDR_EXP 8
10246: PUSH
10247: LD_INT 1
10249: ST_TO_ADDR
// end ; 2 :
10250: GO 10415
10252: LD_INT 2
10254: DOUBLE
10255: EQUAL
10256: IFTRUE 10260
10258: GO 10382
10260: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10261: LD_EXP 21
10265: PPUSH
10266: LD_STRING D3Fb-JMM-1
10268: PPUSH
10269: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10273: LD_EXP 33
10277: PPUSH
10278: LD_STRING D3Fb-Frank-1
10280: PPUSH
10281: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10285: LD_STRING QFrank2
10287: PPUSH
10288: CALL_OW 97
10292: PUSH
10293: LD_INT 1
10295: DOUBLE
10296: EQUAL
10297: IFTRUE 10301
10299: GO 10348
10301: POP
// begin us_scout := 2 ;
10302: LD_ADDR_EXP 8
10306: PUSH
10307: LD_INT 2
10309: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10310: LD_EXP 21
10314: PPUSH
10315: LD_STRING D3Fba-JMM-1
10317: PPUSH
10318: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10322: LD_EXP 33
10326: PPUSH
10327: LD_STRING D3Fba-Frank-1
10329: PPUSH
10330: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10334: LD_EXP 21
10338: PPUSH
10339: LD_STRING D3Fba-JMM-2
10341: PPUSH
10342: CALL_OW 88
// end ; 2 :
10346: GO 10380
10348: LD_INT 2
10350: DOUBLE
10351: EQUAL
10352: IFTRUE 10356
10354: GO 10379
10356: POP
// begin us_scout := 0 ;
10357: LD_ADDR_EXP 8
10361: PUSH
10362: LD_INT 0
10364: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10365: LD_EXP 21
10369: PPUSH
10370: LD_STRING D3Fbb-JMM-1
10372: PPUSH
10373: CALL_OW 88
// end ; end ;
10377: GO 10380
10379: POP
// end ; 3 :
10380: GO 10415
10382: LD_INT 3
10384: DOUBLE
10385: EQUAL
10386: IFTRUE 10390
10388: GO 10414
10390: POP
// begin us_scout := - 1 ;
10391: LD_ADDR_EXP 8
10395: PUSH
10396: LD_INT 1
10398: NEG
10399: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10400: LD_EXP 21
10404: PPUSH
10405: LD_STRING D3Fc-JMM-1
10407: PPUSH
10408: CALL_OW 88
// end ; end ;
10412: GO 10415
10414: POP
// DialogueOff ;
10415: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10419: LD_EXP 8
10423: PUSH
10424: LD_INT 1
10426: NEG
10427: PUSH
10428: LD_INT 0
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: IN
10435: IFFALSE 10439
// exit ;
10437: GO 12086
// if us_scout in [ 1 , 2 ] then
10439: LD_EXP 8
10443: PUSH
10444: LD_INT 1
10446: PUSH
10447: LD_INT 2
10449: PUSH
10450: EMPTY
10451: LIST
10452: LIST
10453: IN
10454: IFFALSE 11153
// begin if IsInUnit ( Frank ) then
10456: LD_EXP 33
10460: PPUSH
10461: CALL_OW 310
10465: IFFALSE 10476
// ComExitBuilding ( Frank ) ;
10467: LD_EXP 33
10471: PPUSH
10472: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10476: LD_EXP 33
10480: PPUSH
10481: CALL_OW 311
10485: IFFALSE 10496
// ComExitVehicle ( Frank ) ;
10487: LD_EXP 33
10491: PPUSH
10492: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10496: LD_EXP 33
10500: PPUSH
10501: LD_INT 4
10503: PPUSH
10504: CALL_OW 235
// wait ( 0 0$1 ) ;
10508: LD_INT 35
10510: PPUSH
10511: CALL_OW 67
// if us_scout = 2 then
10515: LD_EXP 8
10519: PUSH
10520: LD_INT 2
10522: EQUAL
10523: IFFALSE 10891
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10525: LD_EXP 33
10529: PPUSH
10530: LD_INT 75
10532: PPUSH
10533: LD_INT 63
10535: PPUSH
10536: CALL_OW 111
// AddComHold ( Frank ) ;
10540: LD_EXP 33
10544: PPUSH
10545: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10549: LD_EXP 33
10553: PPUSH
10554: LD_INT 770
10556: PPUSH
10557: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10561: LD_EXP 33
10565: PPUSH
10566: LD_INT 100
10568: PPUSH
10569: LD_INT 75
10571: PPUSH
10572: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10576: LD_EXP 33
10580: PPUSH
10581: LD_INT 123
10583: PPUSH
10584: LD_INT 103
10586: PPUSH
10587: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10591: LD_EXP 33
10595: PPUSH
10596: LD_INT 138
10598: PPUSH
10599: LD_INT 108
10601: PPUSH
10602: CALL_OW 171
// AddComHold ( Frank ) ;
10606: LD_EXP 33
10610: PPUSH
10611: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10622: LD_EXP 33
10626: PPUSH
10627: LD_INT 138
10629: PPUSH
10630: LD_INT 108
10632: PPUSH
10633: CALL_OW 307
10637: IFFALSE 10615
// AddComMoveXY ( Frank , 125 , 132 ) ;
10639: LD_EXP 33
10643: PPUSH
10644: LD_INT 125
10646: PPUSH
10647: LD_INT 132
10649: PPUSH
10650: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10654: LD_INT 35
10656: PPUSH
10657: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10661: LD_INT 1
10663: PPUSH
10664: LD_EXP 33
10668: PPUSH
10669: CALL_OW 292
10673: PUSH
10674: LD_EXP 33
10678: PPUSH
10679: LD_INT 7
10681: PPUSH
10682: CALL_OW 296
10686: PUSH
10687: LD_INT 7
10689: LESS
10690: OR
10691: IFFALSE 10654
// DialogueOn ;
10693: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10697: LD_EXP 33
10701: PPUSH
10702: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10706: LD_INT 10
10708: PPUSH
10709: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10713: LD_EXP 21
10717: PPUSH
10718: LD_STRING D4Fa-JMM-1
10720: PPUSH
10721: CALL_OW 88
// for i in points do
10725: LD_ADDR_VAR 0 1
10729: PUSH
10730: LD_VAR 0 2
10734: PUSH
10735: FOR_IN
10736: IFFALSE 10794
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10738: LD_VAR 0 1
10742: PUSH
10743: LD_INT 1
10745: ARRAY
10746: PPUSH
10747: LD_VAR 0 1
10751: PUSH
10752: LD_INT 2
10754: ARRAY
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: LD_INT 20
10761: NEG
10762: PPUSH
10763: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10767: LD_VAR 0 1
10771: PUSH
10772: LD_INT 1
10774: ARRAY
10775: PPUSH
10776: LD_VAR 0 1
10780: PUSH
10781: LD_INT 2
10783: ARRAY
10784: PPUSH
10785: LD_INT 1
10787: PPUSH
10788: CALL_OW 331
// end ;
10792: GO 10735
10794: POP
10795: POP
// dwait ( 0 0$0.5 ) ;
10796: LD_INT 18
10798: PPUSH
10799: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10803: LD_INT 42
10805: PPUSH
10806: LD_INT 27
10808: PPUSH
10809: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10813: LD_EXP 33
10817: PPUSH
10818: LD_STRING D4Fa-Frank-1
10820: PPUSH
10821: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10825: LD_INT 18
10827: PPUSH
10828: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10832: LD_EXP 21
10836: PPUSH
10837: LD_STRING D4Fa-JMM-2
10839: PPUSH
10840: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10844: LD_INT 118
10846: PPUSH
10847: LD_INT 80
10849: PPUSH
10850: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10854: LD_EXP 33
10858: PPUSH
10859: LD_STRING D4Fa-Frank-2
10861: PPUSH
10862: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10866: LD_INT 10
10868: PPUSH
10869: CALL_OW 68
// DialogueOff ;
10873: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10877: LD_EXP 33
10881: PPUSH
10882: LD_INT 1
10884: PPUSH
10885: CALL_OW 235
// end else
10889: GO 11153
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10891: LD_INT 2
10893: PPUSH
10894: LD_INT 4
10896: PPUSH
10897: LD_INT 2
10899: PPUSH
10900: LD_INT 1
10902: PPUSH
10903: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10907: LD_EXP 33
10911: PPUSH
10912: LD_INT 75
10914: PPUSH
10915: LD_INT 63
10917: PPUSH
10918: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10922: LD_EXP 33
10926: PPUSH
10927: LD_INT 175
10929: PPUSH
10930: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10934: LD_EXP 33
10938: PPUSH
10939: LD_INT 102
10941: PPUSH
10942: LD_INT 76
10944: PPUSH
10945: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10949: LD_EXP 33
10953: PPUSH
10954: LD_INT 108
10956: PPUSH
10957: LD_INT 70
10959: PPUSH
10960: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10964: LD_INT 35
10966: PPUSH
10967: CALL_OW 67
// until See ( 2 , Frank ) ;
10971: LD_INT 2
10973: PPUSH
10974: LD_EXP 33
10978: PPUSH
10979: CALL_OW 292
10983: IFFALSE 10964
// ComMoveXY ( Frank , 112 , 118 ) ;
10985: LD_EXP 33
10989: PPUSH
10990: LD_INT 112
10992: PPUSH
10993: LD_INT 118
10995: PPUSH
10996: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11000: LD_EXP 33
11004: PPUSH
11005: CALL_OW 256
11009: PUSH
11010: LD_INT 750
11012: GREATEREQUAL
11013: IFFALSE 11027
// SetLives ( Frank , 700 ) ;
11015: LD_EXP 33
11019: PPUSH
11020: LD_INT 700
11022: PPUSH
11023: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11027: LD_INT 35
11029: PPUSH
11030: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11034: LD_INT 1
11036: PPUSH
11037: LD_EXP 33
11041: PPUSH
11042: CALL_OW 292
11046: PUSH
11047: LD_EXP 33
11051: PPUSH
11052: LD_INT 7
11054: PPUSH
11055: CALL_OW 296
11059: PUSH
11060: LD_INT 17
11062: LESS
11063: OR
11064: IFFALSE 11027
// DialogueOn ;
11066: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11070: LD_EXP 33
11074: PPUSH
11075: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11079: LD_EXP 33
11083: PPUSH
11084: LD_STRING D4Fb-Frank-1
11086: PPUSH
11087: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11091: LD_EXP 21
11095: PPUSH
11096: LD_STRING D4Fb-JMM-1
11098: PPUSH
11099: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11103: LD_INT 2
11105: PPUSH
11106: LD_STRING D4Fb-FSci1-1
11108: PPUSH
11109: CALL 15990 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11113: LD_EXP 33
11117: PPUSH
11118: LD_STRING D4Fb-Frank-2
11120: PPUSH
11121: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11125: LD_EXP 21
11129: PPUSH
11130: LD_STRING D4Fb-JMM-2
11132: PPUSH
11133: CALL_OW 88
// DialogueOff ;
11137: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 1
11148: PPUSH
11149: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11153: LD_EXP 34
11157: PPUSH
11158: CALL_OW 302
11162: PUSH
11163: LD_EXP 33
11167: NOT
11168: AND
11169: IFFALSE 11317
// begin DialogueOn ;
11171: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11175: LD_EXP 21
11179: PUSH
11180: LD_EXP 34
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PPUSH
11189: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11193: LD_EXP 34
11197: PPUSH
11198: LD_STRING D3Y-Yam-1
11200: PPUSH
11201: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11205: LD_EXP 21
11209: PPUSH
11210: LD_STRING D3Y-JMM-1
11212: PPUSH
11213: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11217: LD_EXP 34
11221: PPUSH
11222: LD_STRING D3Y-Yam-2
11224: PPUSH
11225: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11229: LD_STRING QYamoko
11231: PPUSH
11232: CALL_OW 97
11236: PUSH
11237: LD_INT 1
11239: DOUBLE
11240: EQUAL
11241: IFTRUE 11245
11243: GO 11280
11245: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11246: LD_EXP 21
11250: PPUSH
11251: LD_STRING D3Ya-JMM-1
11253: PPUSH
11254: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11258: LD_EXP 34
11262: PPUSH
11263: LD_STRING D3Ya-Yam-1
11265: PPUSH
11266: CALL_OW 88
// us_scout := 1 ;
11270: LD_ADDR_EXP 8
11274: PUSH
11275: LD_INT 1
11277: ST_TO_ADDR
// end ; 2 :
11278: GO 11313
11280: LD_INT 2
11282: DOUBLE
11283: EQUAL
11284: IFTRUE 11288
11286: GO 11312
11288: POP
// begin us_scout := - 1 ;
11289: LD_ADDR_EXP 8
11293: PUSH
11294: LD_INT 1
11296: NEG
11297: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11298: LD_EXP 21
11302: PPUSH
11303: LD_STRING D3Yb-JMM-1
11305: PPUSH
11306: CALL_OW 88
// end ; end ;
11310: GO 11313
11312: POP
// DialogueOff ;
11313: CALL_OW 7
// end ; if Frank then
11317: LD_EXP 33
11321: IFFALSE 11325
// exit ;
11323: GO 12086
// if us_scout in [ - 1 , 0 ] then
11325: LD_EXP 8
11329: PUSH
11330: LD_INT 1
11332: NEG
11333: PUSH
11334: LD_INT 0
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: IN
11341: IFFALSE 11345
// exit ;
11343: GO 12086
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11345: LD_ADDR_EXP 8
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 2
11355: PUSH
11356: LD_INT 1
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: PUSH
11364: LD_OWVAR 67
11368: ARRAY
11369: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11370: LD_EXP 8
11374: PUSH
11375: LD_INT 1
11377: PUSH
11378: LD_INT 2
11380: PUSH
11381: EMPTY
11382: LIST
11383: LIST
11384: IN
11385: IFFALSE 12086
// begin if IsInUnit ( Kikuchi ) then
11387: LD_EXP 34
11391: PPUSH
11392: CALL_OW 310
11396: IFFALSE 11407
// ComExitBuilding ( Kikuchi ) ;
11398: LD_EXP 34
11402: PPUSH
11403: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11407: LD_EXP 34
11411: PPUSH
11412: CALL_OW 311
11416: IFFALSE 11427
// ComExitVehicle ( Kikuchi ) ;
11418: LD_EXP 34
11422: PPUSH
11423: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11427: LD_EXP 34
11431: PPUSH
11432: LD_INT 4
11434: PPUSH
11435: CALL_OW 235
// wait ( 0 0$1 ) ;
11439: LD_INT 35
11441: PPUSH
11442: CALL_OW 67
// if us_scout = 2 then
11446: LD_EXP 8
11450: PUSH
11451: LD_INT 2
11453: EQUAL
11454: IFFALSE 11834
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11456: LD_EXP 34
11460: PPUSH
11461: LD_INT 75
11463: PPUSH
11464: LD_INT 63
11466: PPUSH
11467: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11471: LD_EXP 34
11475: PPUSH
11476: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11480: LD_EXP 34
11484: PPUSH
11485: LD_INT 770
11487: PPUSH
11488: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11492: LD_EXP 34
11496: PPUSH
11497: LD_INT 100
11499: PPUSH
11500: LD_INT 75
11502: PPUSH
11503: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11507: LD_EXP 34
11511: PPUSH
11512: LD_INT 123
11514: PPUSH
11515: LD_INT 103
11517: PPUSH
11518: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11522: LD_EXP 34
11526: PPUSH
11527: LD_INT 138
11529: PPUSH
11530: LD_INT 108
11532: PPUSH
11533: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11537: LD_EXP 34
11541: PPUSH
11542: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11546: LD_INT 35
11548: PPUSH
11549: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11553: LD_EXP 34
11557: PPUSH
11558: LD_INT 138
11560: PPUSH
11561: LD_INT 108
11563: PPUSH
11564: CALL_OW 307
11568: IFFALSE 11546
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11570: LD_EXP 34
11574: PPUSH
11575: LD_INT 125
11577: PPUSH
11578: LD_INT 132
11580: PPUSH
11581: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11585: LD_INT 35
11587: PPUSH
11588: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11592: LD_INT 1
11594: PPUSH
11595: LD_EXP 34
11599: PPUSH
11600: CALL_OW 292
11604: PUSH
11605: LD_EXP 34
11609: PPUSH
11610: LD_INT 7
11612: PPUSH
11613: CALL_OW 296
11617: PUSH
11618: LD_INT 7
11620: LESS
11621: OR
11622: IFFALSE 11585
// DialogueOn ;
11624: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11628: LD_EXP 34
11632: PPUSH
11633: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11637: LD_INT 10
11639: PPUSH
11640: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11644: LD_EXP 34
11648: PPUSH
11649: LD_STRING D4Ya-Yam-1
11651: PPUSH
11652: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11656: LD_EXP 21
11660: PPUSH
11661: LD_STRING D4Ya-JMM-1
11663: PPUSH
11664: CALL_OW 88
// for i in points do
11668: LD_ADDR_VAR 0 1
11672: PUSH
11673: LD_VAR 0 2
11677: PUSH
11678: FOR_IN
11679: IFFALSE 11737
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11681: LD_VAR 0 1
11685: PUSH
11686: LD_INT 1
11688: ARRAY
11689: PPUSH
11690: LD_VAR 0 1
11694: PUSH
11695: LD_INT 2
11697: ARRAY
11698: PPUSH
11699: LD_INT 1
11701: PPUSH
11702: LD_INT 20
11704: NEG
11705: PPUSH
11706: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11710: LD_VAR 0 1
11714: PUSH
11715: LD_INT 1
11717: ARRAY
11718: PPUSH
11719: LD_VAR 0 1
11723: PUSH
11724: LD_INT 2
11726: ARRAY
11727: PPUSH
11728: LD_INT 1
11730: PPUSH
11731: CALL_OW 331
// end ;
11735: GO 11678
11737: POP
11738: POP
// dwait ( 0 0$0.5 ) ;
11739: LD_INT 18
11741: PPUSH
11742: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11746: LD_INT 42
11748: PPUSH
11749: LD_INT 27
11751: PPUSH
11752: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11756: LD_EXP 34
11760: PPUSH
11761: LD_STRING D4Ya-Yam-2
11763: PPUSH
11764: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11768: LD_INT 18
11770: PPUSH
11771: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11775: LD_INT 118
11777: PPUSH
11778: LD_INT 80
11780: PPUSH
11781: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11785: LD_EXP 21
11789: PPUSH
11790: LD_STRING D4Ya-JMM-2
11792: PPUSH
11793: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11797: LD_EXP 34
11801: PPUSH
11802: LD_STRING D4Ya-Yam-3
11804: PPUSH
11805: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11809: LD_INT 10
11811: PPUSH
11812: CALL_OW 68
// DialogueOff ;
11816: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11820: LD_EXP 34
11824: PPUSH
11825: LD_INT 1
11827: PPUSH
11828: CALL_OW 235
// end else
11832: GO 12086
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11834: LD_INT 2
11836: PPUSH
11837: LD_INT 4
11839: PPUSH
11840: LD_INT 2
11842: PPUSH
11843: LD_INT 1
11845: PPUSH
11846: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11850: LD_EXP 34
11854: PPUSH
11855: LD_INT 75
11857: PPUSH
11858: LD_INT 63
11860: PPUSH
11861: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11865: LD_EXP 34
11869: PPUSH
11870: LD_INT 175
11872: PPUSH
11873: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11877: LD_EXP 34
11881: PPUSH
11882: LD_INT 102
11884: PPUSH
11885: LD_INT 76
11887: PPUSH
11888: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_INT 108
11899: PPUSH
11900: LD_INT 70
11902: PPUSH
11903: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11907: LD_INT 35
11909: PPUSH
11910: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11914: LD_INT 2
11916: PPUSH
11917: LD_EXP 34
11921: PPUSH
11922: CALL_OW 292
11926: IFFALSE 11907
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11928: LD_EXP 34
11932: PPUSH
11933: LD_INT 112
11935: PPUSH
11936: LD_INT 118
11938: PPUSH
11939: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11943: LD_EXP 34
11947: PPUSH
11948: CALL_OW 256
11952: PUSH
11953: LD_INT 750
11955: GREATEREQUAL
11956: IFFALSE 11970
// SetLives ( Kikuchi , 700 ) ;
11958: LD_EXP 34
11962: PPUSH
11963: LD_INT 700
11965: PPUSH
11966: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11970: LD_INT 35
11972: PPUSH
11973: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11977: LD_INT 1
11979: PPUSH
11980: LD_EXP 34
11984: PPUSH
11985: CALL_OW 292
11989: PUSH
11990: LD_EXP 34
11994: PPUSH
11995: LD_INT 7
11997: PPUSH
11998: CALL_OW 296
12002: PUSH
12003: LD_INT 17
12005: LESS
12006: OR
12007: IFFALSE 11970
// DialogueOn ;
12009: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12013: LD_EXP 34
12017: PPUSH
12018: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12022: LD_EXP 34
12026: PPUSH
12027: LD_STRING D4Yb-Yam-1
12029: PPUSH
12030: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12034: LD_EXP 21
12038: PPUSH
12039: LD_STRING D4Yb-JMM-1
12041: PPUSH
12042: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12046: LD_EXP 34
12050: PPUSH
12051: LD_STRING D4Yb-Yam-2
12053: PPUSH
12054: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12058: LD_EXP 21
12062: PPUSH
12063: LD_STRING D4Yb-JMM-2
12065: PPUSH
12066: CALL_OW 88
// DialogueOff ;
12070: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12074: LD_EXP 34
12078: PPUSH
12079: LD_INT 1
12081: PPUSH
12082: CALL_OW 235
// end ; end ; end ;
12086: PPOPN 2
12088: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12089: LD_EXP 6
12093: IFFALSE 13126
12095: GO 12097
12097: DISABLE
12098: LD_INT 0
12100: PPUSH
12101: PPUSH
12102: PPUSH
12103: PPUSH
// begin enable ;
12104: ENABLE
// if not seen [ 1 ] then
12105: LD_EXP 9
12109: PUSH
12110: LD_INT 1
12112: ARRAY
12113: NOT
12114: IFFALSE 12294
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12116: LD_ADDR_VAR 0 2
12120: PUSH
12121: LD_INT 22
12123: PUSH
12124: LD_INT 2
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PUSH
12131: LD_INT 2
12133: PUSH
12134: LD_INT 25
12136: PUSH
12137: LD_INT 11
12139: PUSH
12140: EMPTY
12141: LIST
12142: LIST
12143: PUSH
12144: LD_INT 33
12146: PUSH
12147: LD_INT 4
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: LIST
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: PPUSH
12163: CALL_OW 69
12167: ST_TO_ADDR
// if tmp then
12168: LD_VAR 0 2
12172: IFFALSE 12294
// for i in tmp do
12174: LD_ADDR_VAR 0 1
12178: PUSH
12179: LD_VAR 0 2
12183: PUSH
12184: FOR_IN
12185: IFFALSE 12292
// if See ( 1 , i ) then
12187: LD_INT 1
12189: PPUSH
12190: LD_VAR 0 1
12194: PPUSH
12195: CALL_OW 292
12199: IFFALSE 12290
// begin seen := Replace ( seen , 1 , true ) ;
12201: LD_ADDR_EXP 9
12205: PUSH
12206: LD_EXP 9
12210: PPUSH
12211: LD_INT 1
12213: PPUSH
12214: LD_INT 1
12216: PPUSH
12217: CALL_OW 1
12221: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12222: LD_INT 1
12224: PPUSH
12225: CALL 15812 0 1
12229: IFFALSE 12290
// begin DialogueOn ;
12231: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12235: LD_VAR 0 1
12239: PPUSH
12240: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12244: LD_INT 10
12246: PPUSH
12247: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12251: LD_ADDR_VAR 0 3
12255: PUSH
12256: LD_INT 1
12258: PPUSH
12259: LD_STRING D5a-Sol2-1
12261: PPUSH
12262: CALL 15990 0 2
12266: ST_TO_ADDR
// if not un then
12267: LD_VAR 0 3
12271: NOT
12272: IFFALSE 12284
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12274: LD_INT 2
12276: PPUSH
12277: LD_STRING D5a-FSol2-1
12279: PPUSH
12280: CALL 15990 0 2
// DialogueOff ;
12284: CALL_OW 7
// break ;
12288: GO 12292
// end ; end ;
12290: GO 12184
12292: POP
12293: POP
// end ; if not seen [ 2 ] then
12294: LD_EXP 9
12298: PUSH
12299: LD_INT 2
12301: ARRAY
12302: NOT
12303: IFFALSE 12528
// begin can_kamikazed := true ;
12305: LD_ADDR_EXP 10
12309: PUSH
12310: LD_INT 1
12312: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12313: LD_ADDR_VAR 0 2
12317: PUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 2
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 25
12330: PUSH
12331: LD_INT 17
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PPUSH
12342: CALL_OW 69
12346: ST_TO_ADDR
// if tmp then
12347: LD_VAR 0 2
12351: IFFALSE 12528
// for i in tmp do
12353: LD_ADDR_VAR 0 1
12357: PUSH
12358: LD_VAR 0 2
12362: PUSH
12363: FOR_IN
12364: IFFALSE 12526
// if See ( 1 , i ) then
12366: LD_INT 1
12368: PPUSH
12369: LD_VAR 0 1
12373: PPUSH
12374: CALL_OW 292
12378: IFFALSE 12524
// begin seen := Replace ( seen , 2 , true ) ;
12380: LD_ADDR_EXP 9
12384: PUSH
12385: LD_EXP 9
12389: PPUSH
12390: LD_INT 2
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 1
12400: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12401: LD_INT 1
12403: PPUSH
12404: CALL 15812 0 1
12408: IFFALSE 12524
// begin DialogueOn ;
12410: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12414: LD_VAR 0 1
12418: PPUSH
12419: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12423: LD_INT 10
12425: PPUSH
12426: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12430: LD_ADDR_VAR 0 3
12434: PUSH
12435: LD_INT 1
12437: PPUSH
12438: LD_STRING D5b-Sol1-1
12440: PPUSH
12441: CALL 15990 0 2
12445: ST_TO_ADDR
// if not un then
12446: LD_VAR 0 3
12450: NOT
12451: IFFALSE 12469
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12453: LD_ADDR_VAR 0 3
12457: PUSH
12458: LD_INT 2
12460: PPUSH
12461: LD_STRING D5b-FSol1-1
12463: PPUSH
12464: CALL 15990 0 2
12468: ST_TO_ADDR
// if un then
12469: LD_VAR 0 3
12473: IFFALSE 12518
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12475: LD_ADDR_VAR 0 4
12479: PUSH
12480: LD_INT 1
12482: PPUSH
12483: LD_STRING D5b-Sol2-1
12485: PPUSH
12486: LD_VAR 0 3
12490: PPUSH
12491: CALL 16216 0 3
12495: ST_TO_ADDR
// if not un2 then
12496: LD_VAR 0 4
12500: NOT
12501: IFFALSE 12518
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12503: LD_INT 2
12505: PPUSH
12506: LD_STRING D5b-FSol2-1
12508: PPUSH
12509: LD_VAR 0 3
12513: PPUSH
12514: CALL 16216 0 3
// end ; DialogueOff ;
12518: CALL_OW 7
// break ;
12522: GO 12526
// end ; end ;
12524: GO 12363
12526: POP
12527: POP
// end ; if not seen [ 3 ] then
12528: LD_EXP 9
12532: PUSH
12533: LD_INT 3
12535: ARRAY
12536: NOT
12537: IFFALSE 12711
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12539: LD_ADDR_VAR 0 2
12543: PUSH
12544: LD_INT 22
12546: PUSH
12547: LD_INT 2
12549: PUSH
12550: EMPTY
12551: LIST
12552: LIST
12553: PUSH
12554: LD_INT 33
12556: PUSH
12557: LD_INT 2
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: EMPTY
12565: LIST
12566: LIST
12567: PPUSH
12568: CALL_OW 69
12572: ST_TO_ADDR
// if tmp then
12573: LD_VAR 0 2
12577: IFFALSE 12711
// for i in tmp do
12579: LD_ADDR_VAR 0 1
12583: PUSH
12584: LD_VAR 0 2
12588: PUSH
12589: FOR_IN
12590: IFFALSE 12709
// if See ( 1 , i ) then
12592: LD_INT 1
12594: PPUSH
12595: LD_VAR 0 1
12599: PPUSH
12600: CALL_OW 292
12604: IFFALSE 12707
// begin seen := Replace ( seen , 3 , true ) ;
12606: LD_ADDR_EXP 9
12610: PUSH
12611: LD_EXP 9
12615: PPUSH
12616: LD_INT 3
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: CALL_OW 1
12626: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12627: LD_INT 1
12629: PPUSH
12630: CALL 15812 0 1
12634: IFFALSE 12707
// begin DialogueOn ;
12636: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12640: LD_VAR 0 1
12644: PPUSH
12645: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12649: LD_INT 10
12651: PPUSH
12652: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: LD_INT 1
12663: PPUSH
12664: LD_STRING D8-Sol1-1
12666: PPUSH
12667: CALL 15990 0 2
12671: ST_TO_ADDR
// if not un then
12672: LD_VAR 0 3
12676: NOT
12677: IFFALSE 12689
// SayRand ( sex_female , D8-FSol1-1 ) ;
12679: LD_INT 2
12681: PPUSH
12682: LD_STRING D8-FSol1-1
12684: PPUSH
12685: CALL 15990 0 2
// Say ( JMM , D8-JMM-1 ) ;
12689: LD_EXP 21
12693: PPUSH
12694: LD_STRING D8-JMM-1
12696: PPUSH
12697: CALL_OW 88
// DialogueOff ;
12701: CALL_OW 7
// break ;
12705: GO 12709
// end ; end ;
12707: GO 12589
12709: POP
12710: POP
// end ; if not seen [ 4 ] then
12711: LD_EXP 9
12715: PUSH
12716: LD_INT 4
12718: ARRAY
12719: NOT
12720: IFFALSE 12882
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12722: LD_ADDR_VAR 0 2
12726: PUSH
12727: LD_INT 22
12729: PUSH
12730: LD_INT 2
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 33
12739: PUSH
12740: LD_INT 5
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: EMPTY
12748: LIST
12749: LIST
12750: PPUSH
12751: CALL_OW 69
12755: ST_TO_ADDR
// if tmp then
12756: LD_VAR 0 2
12760: IFFALSE 12882
// for i in tmp do
12762: LD_ADDR_VAR 0 1
12766: PUSH
12767: LD_VAR 0 2
12771: PUSH
12772: FOR_IN
12773: IFFALSE 12880
// if See ( 1 , i ) then
12775: LD_INT 1
12777: PPUSH
12778: LD_VAR 0 1
12782: PPUSH
12783: CALL_OW 292
12787: IFFALSE 12878
// begin seen := Replace ( seen , 4 , true ) ;
12789: LD_ADDR_EXP 9
12793: PUSH
12794: LD_EXP 9
12798: PPUSH
12799: LD_INT 4
12801: PPUSH
12802: LD_INT 1
12804: PPUSH
12805: CALL_OW 1
12809: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12810: LD_INT 1
12812: PPUSH
12813: CALL 15812 0 1
12817: IFFALSE 12878
// begin DialogueOn ;
12819: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12823: LD_VAR 0 1
12827: PPUSH
12828: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12832: LD_INT 10
12834: PPUSH
12835: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12839: LD_ADDR_VAR 0 3
12843: PUSH
12844: LD_INT 1
12846: PPUSH
12847: LD_STRING D5a-Sol1-1
12849: PPUSH
12850: CALL 15990 0 2
12854: ST_TO_ADDR
// if not un then
12855: LD_VAR 0 3
12859: NOT
12860: IFFALSE 12872
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12862: LD_INT 2
12864: PPUSH
12865: LD_STRING D5a-FSol1-1
12867: PPUSH
12868: CALL 15990 0 2
// DialogueOff ;
12872: CALL_OW 7
// break ;
12876: GO 12880
// end ; end ;
12878: GO 12772
12880: POP
12881: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12882: LD_EXP 9
12886: PUSH
12887: LD_INT 5
12889: ARRAY
12890: NOT
12891: PUSH
12892: LD_EXP 9
12896: PUSH
12897: LD_INT 3
12899: ARRAY
12900: AND
12901: IFFALSE 13075
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 2
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: LD_INT 34
12920: PUSH
12921: LD_INT 31
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PPUSH
12932: CALL_OW 69
12936: ST_TO_ADDR
// if tmp then
12937: LD_VAR 0 2
12941: IFFALSE 13075
// for i in tmp do
12943: LD_ADDR_VAR 0 1
12947: PUSH
12948: LD_VAR 0 2
12952: PUSH
12953: FOR_IN
12954: IFFALSE 13073
// if See ( 1 , i ) then
12956: LD_INT 1
12958: PPUSH
12959: LD_VAR 0 1
12963: PPUSH
12964: CALL_OW 292
12968: IFFALSE 13071
// begin seen := Replace ( seen , 5 , true ) ;
12970: LD_ADDR_EXP 9
12974: PUSH
12975: LD_EXP 9
12979: PPUSH
12980: LD_INT 5
12982: PPUSH
12983: LD_INT 1
12985: PPUSH
12986: CALL_OW 1
12990: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12991: LD_INT 1
12993: PPUSH
12994: CALL 15812 0 1
12998: IFFALSE 13071
// begin DialogueOn ;
13000: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13004: LD_VAR 0 1
13008: PPUSH
13009: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13013: LD_INT 10
13015: PPUSH
13016: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13020: LD_ADDR_VAR 0 3
13024: PUSH
13025: LD_INT 1
13027: PPUSH
13028: LD_STRING D8a-Sol2-1
13030: PPUSH
13031: CALL 15990 0 2
13035: ST_TO_ADDR
// if not un then
13036: LD_VAR 0 3
13040: NOT
13041: IFFALSE 13053
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13043: LD_INT 2
13045: PPUSH
13046: LD_STRING D8a-FSol2-1
13048: PPUSH
13049: CALL 15990 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13053: LD_EXP 21
13057: PPUSH
13058: LD_STRING D8a-JMM-1
13060: PPUSH
13061: CALL_OW 88
// DialogueOff ;
13065: CALL_OW 7
// break ;
13069: GO 13073
// end ; end ;
13071: GO 12953
13073: POP
13074: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13075: LD_EXP 9
13079: PUSH
13080: LD_INT 1
13082: ARRAY
13083: PUSH
13084: LD_EXP 9
13088: PUSH
13089: LD_INT 2
13091: ARRAY
13092: AND
13093: PUSH
13094: LD_EXP 9
13098: PUSH
13099: LD_INT 3
13101: ARRAY
13102: AND
13103: PUSH
13104: LD_EXP 9
13108: PUSH
13109: LD_INT 4
13111: ARRAY
13112: AND
13113: PUSH
13114: LD_EXP 9
13118: PUSH
13119: LD_INT 5
13121: ARRAY
13122: AND
13123: IFFALSE 13126
// disable ;
13125: DISABLE
// end ;
13126: PPOPN 4
13128: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13129: LD_EXP 10
13133: PUSH
13134: LD_EXP 11
13138: AND
13139: IFFALSE 13337
13141: GO 13143
13143: DISABLE
13144: LD_INT 0
13146: PPUSH
// begin DialogueOn ;
13147: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13151: LD_EXP 11
13155: PPUSH
13156: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: PPUSH
13168: LD_STRING D5c-Sol1-1
13170: PPUSH
13171: CALL 15990 0 2
13175: ST_TO_ADDR
// if not un then
13176: LD_VAR 0 1
13180: NOT
13181: IFFALSE 13199
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13183: LD_ADDR_VAR 0 1
13187: PUSH
13188: LD_INT 2
13190: PPUSH
13191: LD_STRING D5c-FSol1-1
13193: PPUSH
13194: CALL 15990 0 2
13198: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13199: LD_EXP 21
13203: PPUSH
13204: LD_STRING D5c-JMM-1
13206: PPUSH
13207: CALL_OW 88
// if IsOk ( Lisa ) then
13211: LD_EXP 22
13215: PPUSH
13216: CALL_OW 302
13220: IFFALSE 13236
// Say ( Lisa , D5d-Lisa-1 ) else
13222: LD_EXP 22
13226: PPUSH
13227: LD_STRING D5d-Lisa-1
13229: PPUSH
13230: CALL_OW 88
13234: GO 13321
// if IsOk ( Cyrus ) then
13236: LD_EXP 25
13240: PPUSH
13241: CALL_OW 302
13245: IFFALSE 13261
// Say ( Cyrus , D5d-Cyrus-1 ) else
13247: LD_EXP 25
13251: PPUSH
13252: LD_STRING D5d-Cyrus-1
13254: PPUSH
13255: CALL_OW 88
13259: GO 13321
// if IsOk ( Gary ) then
13261: LD_EXP 32
13265: PPUSH
13266: CALL_OW 302
13270: IFFALSE 13286
// Say ( Gary , D5d-Gary-1 ) else
13272: LD_EXP 32
13276: PPUSH
13277: LD_STRING D5d-Gary-1
13279: PPUSH
13280: CALL_OW 88
13284: GO 13321
// if GetSex ( un ) = sex_male then
13286: LD_VAR 0 1
13290: PPUSH
13291: CALL_OW 258
13295: PUSH
13296: LD_INT 1
13298: EQUAL
13299: IFFALSE 13315
// Say ( un , D5d-Sol1-1 ) else
13301: LD_VAR 0 1
13305: PPUSH
13306: LD_STRING D5d-Sol1-1
13308: PPUSH
13309: CALL_OW 88
13313: GO 13321
// begin DialogueOff ;
13315: CALL_OW 7
// exit ;
13319: GO 13337
// end ; Say ( JMM , D5d-JMM-1 ) ;
13321: LD_EXP 21
13325: PPUSH
13326: LD_STRING D5d-JMM-1
13328: PPUSH
13329: CALL_OW 88
// DialogueOff ;
13333: CALL_OW 7
// end ;
13337: PPOPN 1
13339: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13340: LD_INT 1
13342: PPUSH
13343: LD_INT 17
13345: PPUSH
13346: CALL_OW 294
13350: PUSH
13351: LD_INT 2
13353: GREATEREQUAL
13354: IFFALSE 13475
13356: GO 13358
13358: DISABLE
13359: LD_INT 0
13361: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13362: LD_INT 10
13364: PPUSH
13365: LD_INT 5
13367: PPUSH
13368: LD_INT 1
13370: PPUSH
13371: LD_INT 10
13373: NEG
13374: PPUSH
13375: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13379: LD_INT 10
13381: PPUSH
13382: LD_INT 5
13384: PPUSH
13385: LD_INT 1
13387: PPUSH
13388: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13392: LD_INT 10
13394: PPUSH
13395: LD_INT 5
13397: PPUSH
13398: CALL_OW 86
// DialogueOn ;
13402: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13406: LD_ADDR_VAR 0 1
13410: PUSH
13411: LD_INT 1
13413: PPUSH
13414: LD_STRING D6-Sci1-1
13416: PPUSH
13417: CALL 15990 0 2
13421: ST_TO_ADDR
// if un then
13422: LD_VAR 0 1
13426: IFFALSE 13464
// begin Say ( JMM , D6-JMM-1 ) ;
13428: LD_EXP 21
13432: PPUSH
13433: LD_STRING D6-JMM-1
13435: PPUSH
13436: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_STRING D6-Sci1-2
13447: PPUSH
13448: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13452: LD_EXP 21
13456: PPUSH
13457: LD_STRING D6-JMM-2
13459: PPUSH
13460: CALL_OW 88
// end ; DialogueOff ;
13464: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13468: LD_STRING M3
13470: PPUSH
13471: CALL_OW 337
// end ;
13475: PPOPN 1
13477: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
13478: LD_OWVAR 1
13482: PUSH
13483: LD_INT 42000
13485: GREATEREQUAL
13486: PUSH
13487: LD_INT 2
13489: PPUSH
13490: LD_INT 169
13492: PPUSH
13493: LD_INT 90
13495: PPUSH
13496: LD_INT 10
13498: PPUSH
13499: CALL 55451 0 4
13503: PUSH
13504: LD_INT 4
13506: ARRAY
13507: PUSH
13508: LD_INT 0
13510: EQUAL
13511: PUSH
13512: LD_INT 45
13514: PPUSH
13515: CALL_OW 301
13519: OR
13520: PUSH
13521: LD_INT 45
13523: PPUSH
13524: CALL_OW 255
13528: PUSH
13529: LD_INT 1
13531: EQUAL
13532: OR
13533: AND
13534: PUSH
13535: LD_INT 94
13537: PPUSH
13538: CALL_OW 301
13542: NOT
13543: AND
13544: IFFALSE 14749
13546: GO 13548
13548: DISABLE
13549: LD_INT 0
13551: PPUSH
13552: PPUSH
13553: PPUSH
13554: PPUSH
13555: PPUSH
// begin uc_side := 5 ;
13556: LD_ADDR_OWVAR 20
13560: PUSH
13561: LD_INT 5
13563: ST_TO_ADDR
// uc_nation := 2 ;
13564: LD_ADDR_OWVAR 21
13568: PUSH
13569: LD_INT 2
13571: ST_TO_ADDR
// InitHc ;
13572: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13576: LD_INT 1
13578: PPUSH
13579: LD_INT 3
13581: PPUSH
13582: LD_INT 8
13584: PPUSH
13585: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13589: LD_ADDR_OWVAR 29
13593: PUSH
13594: LD_INT 12
13596: PUSH
13597: LD_INT 12
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: ST_TO_ADDR
// hc_name := Hans Felige ;
13604: LD_ADDR_OWVAR 26
13608: PUSH
13609: LD_STRING Hans Felige
13611: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13612: LD_ADDR_OWVAR 33
13616: PUSH
13617: LD_STRING SecondCharsGal
13619: ST_TO_ADDR
// hc_face_number := 7 ;
13620: LD_ADDR_OWVAR 34
13624: PUSH
13625: LD_INT 7
13627: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13628: LD_ADDR_EXP 46
13632: PUSH
13633: CALL_OW 44
13637: ST_TO_ADDR
// InitHc ;
13638: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13642: LD_INT 1
13644: PPUSH
13645: LD_INT 16
13647: PPUSH
13648: LD_INT 2
13650: PPUSH
13651: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13655: LD_ADDR_OWVAR 29
13659: PUSH
13660: LD_INT 12
13662: PUSH
13663: LD_INT 12
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: ST_TO_ADDR
// hc_name :=  ;
13670: LD_ADDR_OWVAR 26
13674: PUSH
13675: LD_STRING 
13677: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13678: LD_ADDR_EXP 47
13682: PUSH
13683: CALL_OW 44
13687: ST_TO_ADDR
// InitHc ;
13688: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13692: LD_INT 35
13694: PPUSH
13695: CALL_OW 67
// until not InBattle ( 1 ) ;
13699: LD_INT 1
13701: PPUSH
13702: CALL_OW 463
13706: NOT
13707: IFFALSE 13692
// wait ( 0 0$5 ) ;
13709: LD_INT 175
13711: PPUSH
13712: CALL_OW 67
// DialogueOn ;
13716: CALL_OW 6
// InGameOn ;
13720: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 1
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 2
13741: PUSH
13742: LD_INT 25
13744: PUSH
13745: LD_INT 1
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: PUSH
13752: LD_INT 25
13754: PUSH
13755: LD_INT 2
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PUSH
13762: LD_INT 25
13764: PUSH
13765: LD_INT 3
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: PUSH
13772: LD_INT 25
13774: PUSH
13775: LD_INT 4
13777: PUSH
13778: EMPTY
13779: LIST
13780: LIST
13781: PUSH
13782: LD_INT 25
13784: PUSH
13785: LD_INT 5
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 25
13794: PUSH
13795: LD_INT 8
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 69
13819: PUSH
13820: LD_EXP 21
13824: PUSH
13825: LD_EXP 22
13829: PUSH
13830: LD_EXP 23
13834: PUSH
13835: LD_EXP 24
13839: PUSH
13840: LD_EXP 25
13844: PUSH
13845: LD_EXP 26
13849: PUSH
13850: LD_EXP 27
13854: PUSH
13855: LD_EXP 28
13859: PUSH
13860: LD_EXP 29
13864: PUSH
13865: LD_EXP 31
13869: PUSH
13870: LD_EXP 32
13874: PUSH
13875: LD_EXP 33
13879: PUSH
13880: LD_EXP 34
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: DIFF
13900: PPUSH
13901: LD_INT 26
13903: PUSH
13904: LD_INT 1
13906: PUSH
13907: EMPTY
13908: LIST
13909: LIST
13910: PPUSH
13911: CALL_OW 72
13915: PUSH
13916: LD_INT 1
13918: ARRAY
13919: ST_TO_ADDR
// if Brown then
13920: LD_EXP 27
13924: IFFALSE 13936
// un := Brown ;
13926: LD_ADDR_VAR 0 1
13930: PUSH
13931: LD_EXP 27
13935: ST_TO_ADDR
// if un then
13936: LD_VAR 0 1
13940: IFFALSE 13966
// begin Say ( un , D7-Sol1-1 ) ;
13942: LD_VAR 0 1
13946: PPUSH
13947: LD_STRING D7-Sol1-1
13949: PPUSH
13950: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13954: LD_EXP 21
13958: PPUSH
13959: LD_STRING D7-JMM-1
13961: PPUSH
13962: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13966: LD_EXP 46
13970: PPUSH
13971: LD_STRING D7-Ar1-1
13973: PPUSH
13974: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13978: LD_EXP 21
13982: PPUSH
13983: LD_STRING D7-JMM-2
13985: PPUSH
13986: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13990: LD_EXP 46
13994: PPUSH
13995: LD_STRING D7-Ar1-2
13997: PPUSH
13998: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14002: LD_EXP 21
14006: PPUSH
14007: LD_STRING D7-JMM-3
14009: PPUSH
14010: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14014: LD_EXP 46
14018: PPUSH
14019: LD_STRING D7-Ar1-3
14021: PPUSH
14022: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14026: LD_EXP 21
14030: PPUSH
14031: LD_STRING D7-JMM-4
14033: PPUSH
14034: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14038: LD_EXP 46
14042: PPUSH
14043: LD_STRING D7-Ar1-4
14045: PPUSH
14046: CALL_OW 94
// InGameOff ;
14050: CALL_OW 9
// DialogueOff ;
14054: CALL_OW 7
// case Query ( QCameras ) of 1 :
14058: LD_STRING QCameras
14060: PPUSH
14061: CALL_OW 97
14065: PUSH
14066: LD_INT 1
14068: DOUBLE
14069: EQUAL
14070: IFTRUE 14074
14072: GO 14077
14074: POP
// ; 2 :
14075: GO 14091
14077: LD_INT 2
14079: DOUBLE
14080: EQUAL
14081: IFTRUE 14085
14083: GO 14090
14085: POP
// exit ; end ;
14086: GO 14749
14088: GO 14091
14090: POP
// ChangeMissionObjectives ( MCar ) ;
14091: LD_STRING MCar
14093: PPUSH
14094: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14098: LD_INT 124
14100: PPUSH
14101: LD_INT 90
14103: PPUSH
14104: LD_INT 1
14106: PPUSH
14107: LD_INT 6
14109: NEG
14110: PPUSH
14111: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14115: LD_INT 124
14117: PPUSH
14118: LD_INT 90
14120: PPUSH
14121: LD_INT 1
14123: PPUSH
14124: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14128: LD_INT 12
14130: PPUSH
14131: LD_INT 1
14133: PPUSH
14134: CALL_OW 424
// wait ( 3 ) ;
14138: LD_INT 3
14140: PPUSH
14141: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14145: LD_INT 124
14147: PPUSH
14148: LD_INT 90
14150: PPUSH
14151: CALL_OW 86
// cargo := false ;
14155: LD_ADDR_VAR 0 3
14159: PUSH
14160: LD_INT 0
14162: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14163: LD_INT 35
14165: PPUSH
14166: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: LD_INT 12
14177: PPUSH
14178: LD_INT 32
14180: PUSH
14181: LD_INT 3
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_INT 34
14190: PUSH
14191: LD_INT 32
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: PUSH
14198: LD_INT 58
14200: PUSH
14201: EMPTY
14202: LIST
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: LIST
14208: PPUSH
14209: CALL_OW 70
14213: ST_TO_ADDR
// until cargo ;
14214: LD_VAR 0 3
14218: IFFALSE 14163
// cargo := cargo [ 1 ] ;
14220: LD_ADDR_VAR 0 3
14224: PUSH
14225: LD_VAR 0 3
14229: PUSH
14230: LD_INT 1
14232: ARRAY
14233: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14234: LD_VAR 0 3
14238: PPUSH
14239: LD_INT 5
14241: PPUSH
14242: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14246: LD_INT 12
14248: PPUSH
14249: LD_INT 0
14251: PPUSH
14252: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14256: LD_EXP 46
14260: PPUSH
14261: LD_INT 11
14263: PPUSH
14264: LD_INT 0
14266: PPUSH
14267: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14271: LD_EXP 47
14275: PPUSH
14276: LD_INT 11
14278: PPUSH
14279: LD_INT 0
14281: PPUSH
14282: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14286: LD_EXP 46
14290: PUSH
14291: LD_EXP 47
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PPUSH
14300: LD_INT 12
14302: PPUSH
14303: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14307: LD_EXP 46
14311: PPUSH
14312: LD_VAR 0 3
14316: PPUSH
14317: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14321: LD_EXP 46
14325: PUSH
14326: LD_EXP 47
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PPUSH
14335: LD_INT 209
14337: PPUSH
14338: LD_INT 178
14340: PPUSH
14341: CALL_OW 171
// escaped := 0 ;
14345: LD_ADDR_VAR 0 5
14349: PUSH
14350: LD_INT 0
14352: ST_TO_ADDR
// while ( true ) do
14353: LD_INT 1
14355: IFFALSE 14571
// begin wait ( 0 0$1 ) ;
14357: LD_INT 35
14359: PPUSH
14360: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14364: LD_EXP 46
14368: PPUSH
14369: CALL_OW 314
14373: NOT
14374: PUSH
14375: LD_EXP 47
14379: PPUSH
14380: CALL_OW 314
14384: NOT
14385: OR
14386: IFFALSE 14412
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14388: LD_EXP 46
14392: PUSH
14393: LD_EXP 47
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: PPUSH
14402: LD_INT 209
14404: PPUSH
14405: LD_INT 178
14407: PPUSH
14408: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14412: LD_EXP 46
14416: PPUSH
14417: LD_INT 10
14419: PPUSH
14420: CALL_OW 308
14424: IFFALSE 14449
// begin RemoveUnit ( ar_mechanic ) ;
14426: LD_EXP 46
14430: PPUSH
14431: CALL_OW 64
// escaped := escaped + 1 ;
14435: LD_ADDR_VAR 0 5
14439: PUSH
14440: LD_VAR 0 5
14444: PUSH
14445: LD_INT 1
14447: PLUS
14448: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
14449: LD_EXP 47
14453: PPUSH
14454: LD_INT 10
14456: PPUSH
14457: CALL_OW 308
14461: IFFALSE 14486
// begin RemoveUnit ( ar_mechanic_friend ) ;
14463: LD_EXP 47
14467: PPUSH
14468: CALL_OW 64
// escaped := escaped + 1 ;
14472: LD_ADDR_VAR 0 5
14476: PUSH
14477: LD_VAR 0 5
14481: PUSH
14482: LD_INT 1
14484: PLUS
14485: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
14486: LD_VAR 0 3
14490: PPUSH
14491: LD_INT 10
14493: PPUSH
14494: CALL_OW 308
14498: IFFALSE 14509
// RemoveUnit ( cargo ) ;
14500: LD_VAR 0 3
14504: PPUSH
14505: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
14509: LD_EXP 46
14513: PPUSH
14514: CALL_OW 305
14518: NOT
14519: PUSH
14520: LD_VAR 0 5
14524: PUSH
14525: LD_INT 2
14527: GREATEREQUAL
14528: AND
14529: IFFALSE 14533
// break ;
14531: GO 14571
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
14533: LD_EXP 46
14537: PPUSH
14538: CALL_OW 305
14542: NOT
14543: PUSH
14544: LD_EXP 47
14548: PPUSH
14549: CALL_OW 305
14553: NOT
14554: AND
14555: PUSH
14556: LD_VAR 0 5
14560: PUSH
14561: LD_INT 2
14563: LESS
14564: AND
14565: IFFALSE 14569
// exit ;
14567: GO 14749
// end ;
14569: GO 14353
// wait ( 0 0$2 ) ;
14571: LD_INT 70
14573: PPUSH
14574: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14578: LD_EXP 46
14582: PPUSH
14583: LD_STRING D7a-Ar1-1
14585: PPUSH
14586: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14590: LD_ADDR_VAR 0 4
14594: PUSH
14595: LD_INT 129
14597: PUSH
14598: LD_INT 10
14600: PUSH
14601: EMPTY
14602: LIST
14603: LIST
14604: PUSH
14605: LD_INT 103
14607: PUSH
14608: LD_INT 6
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: PUSH
14615: LD_INT 148
14617: PUSH
14618: LD_INT 47
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 155
14627: PUSH
14628: LD_INT 16
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: ST_TO_ADDR
// if Difficulty = 1 then
14641: LD_OWVAR 67
14645: PUSH
14646: LD_INT 1
14648: EQUAL
14649: IFFALSE 14686
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14651: LD_ADDR_VAR 0 4
14655: PUSH
14656: LD_VAR 0 4
14660: PUSH
14661: LD_INT 78
14663: PUSH
14664: LD_INT 7
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PUSH
14671: LD_INT 104
14673: PUSH
14674: LD_INT 43
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: ADD
14685: ST_TO_ADDR
// for i in tmp do
14686: LD_ADDR_VAR 0 2
14690: PUSH
14691: LD_VAR 0 4
14695: PUSH
14696: FOR_IN
14697: IFFALSE 14730
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14699: LD_VAR 0 2
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_VAR 0 2
14712: PUSH
14713: LD_INT 2
14715: ARRAY
14716: PPUSH
14717: LD_INT 1
14719: PPUSH
14720: LD_INT 9
14722: NEG
14723: PPUSH
14724: CALL_OW 330
14728: GO 14696
14730: POP
14731: POP
// SetAchievement ( ACH_FRIEND ) ;
14732: LD_STRING ACH_FRIEND
14734: PPUSH
14735: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
14739: LD_INT 129
14741: PPUSH
14742: LD_INT 10
14744: PPUSH
14745: CALL_OW 84
// end ;
14749: PPOPN 5
14751: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14752: LD_EXP 15
14756: PUSH
14757: LD_INT 21000
14759: MINUS
14760: PUSH
14761: LD_OWVAR 1
14765: LESSEQUAL
14766: IFFALSE 14806
14768: GO 14770
14770: DISABLE
// begin powell_warn := true ;
14771: LD_ADDR_EXP 16
14775: PUSH
14776: LD_INT 1
14778: ST_TO_ADDR
// DialogueOn ;
14779: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14783: LD_EXP 30
14787: PPUSH
14788: LD_STRING D9-Pow-1
14790: PPUSH
14791: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14795: LD_INT 10
14797: PPUSH
14798: CALL_OW 68
// DialogueOff ;
14802: CALL_OW 7
// end ;
14806: END
// every 0 0$1 trigger game_time <= tick do
14807: LD_EXP 15
14811: PUSH
14812: LD_OWVAR 1
14816: LESSEQUAL
14817: IFFALSE 14856
14819: GO 14821
14821: DISABLE
// begin DialogueOn ;
14822: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14826: LD_EXP 30
14830: PPUSH
14831: LD_STRING D9a-Pow-1
14833: PPUSH
14834: CALL_OW 94
// dwait ( 0 0$2 ) ;
14838: LD_INT 70
14840: PPUSH
14841: CALL_OW 68
// DialogueOff ;
14845: CALL_OW 7
// YouLost ( Command ) ;
14849: LD_STRING Command
14851: PPUSH
14852: CALL_OW 104
// end ;
14856: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
14857: LD_INT 22
14859: PUSH
14860: LD_INT 2
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: PUSH
14867: LD_INT 30
14869: PUSH
14870: LD_INT 1
14872: PUSH
14873: EMPTY
14874: LIST
14875: LIST
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PPUSH
14881: CALL_OW 69
14885: PUSH
14886: LD_INT 0
14888: EQUAL
14889: PUSH
14890: LD_EXP 21
14894: PPUSH
14895: CALL_OW 302
14899: AND
14900: IFFALSE 15809
14902: GO 14904
14904: DISABLE
14905: LD_INT 0
14907: PPUSH
14908: PPUSH
14909: PPUSH
14910: PPUSH
// begin m1 := false ;
14911: LD_ADDR_VAR 0 2
14915: PUSH
14916: LD_INT 0
14918: ST_TO_ADDR
// m2 := false ;
14919: LD_ADDR_VAR 0 3
14923: PUSH
14924: LD_INT 0
14926: ST_TO_ADDR
// m3 := false ;
14927: LD_ADDR_VAR 0 4
14931: PUSH
14932: LD_INT 0
14934: ST_TO_ADDR
// if not am_veh_consturcted then
14935: LD_EXP 20
14939: NOT
14940: IFFALSE 14949
// SetAchievement ( ACH_ARABTECH ) ;
14942: LD_STRING ACH_ARABTECH
14944: PPUSH
14945: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
14949: LD_OWVAR 1
14953: PUSH
14954: LD_INT 252000
14956: PUSH
14957: LD_INT 210000
14959: PUSH
14960: LD_INT 199500
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: LIST
14967: PUSH
14968: LD_OWVAR 67
14972: ARRAY
14973: LESS
14974: IFFALSE 14996
// begin m3 := true ;
14976: LD_ADDR_VAR 0 4
14980: PUSH
14981: LD_INT 1
14983: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
14984: LD_STRING Time1
14986: PPUSH
14987: LD_INT 1
14989: PPUSH
14990: CALL_OW 101
// end else
14994: GO 15027
// if not powell_warn then
14996: LD_EXP 16
15000: NOT
15001: IFFALSE 15016
// AddMedal ( Time1 , - 1 ) else
15003: LD_STRING Time1
15005: PPUSH
15006: LD_INT 1
15008: NEG
15009: PPUSH
15010: CALL_OW 101
15014: GO 15027
// AddMedal ( Time1 , - 2 ) ;
15016: LD_STRING Time1
15018: PPUSH
15019: LD_INT 2
15021: NEG
15022: PPUSH
15023: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15027: LD_EXP 17
15031: PUSH
15032: LD_INT 5
15034: PUSH
15035: LD_INT 4
15037: PUSH
15038: LD_INT 3
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: LIST
15045: PUSH
15046: LD_OWVAR 67
15050: ARRAY
15051: GREATEREQUAL
15052: IFFALSE 15067
// AddMedal ( Destroy , - 2 ) else
15054: LD_STRING Destroy
15056: PPUSH
15057: LD_INT 2
15059: NEG
15060: PPUSH
15061: CALL_OW 101
15065: GO 15200
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15067: LD_INT 22
15069: PUSH
15070: LD_INT 2
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PUSH
15077: LD_INT 21
15079: PUSH
15080: LD_INT 3
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: PUSH
15087: LD_INT 50
15089: PUSH
15090: EMPTY
15091: LIST
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: PPUSH
15098: CALL_OW 69
15102: PUSH
15103: LD_INT 25
15105: GREATEREQUAL
15106: IFFALSE 15121
// AddMedal ( Destroy , - 1 ) else
15108: LD_STRING Destroy
15110: PPUSH
15111: LD_INT 1
15113: NEG
15114: PPUSH
15115: CALL_OW 101
15119: GO 15200
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15121: LD_INT 22
15123: PUSH
15124: LD_INT 2
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 3
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: LD_INT 50
15143: PUSH
15144: EMPTY
15145: LIST
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: LIST
15151: PPUSH
15152: CALL_OW 69
15156: PUSH
15157: LD_INT 15
15159: GREATEREQUAL
15160: IFFALSE 15182
// begin m1 := true ;
15162: LD_ADDR_VAR 0 2
15166: PUSH
15167: LD_INT 1
15169: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15170: LD_STRING Destroy
15172: PPUSH
15173: LD_INT 1
15175: PPUSH
15176: CALL_OW 101
// end else
15180: GO 15200
// begin m1 := true ;
15182: LD_ADDR_VAR 0 2
15186: PUSH
15187: LD_INT 1
15189: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15190: LD_STRING Destroy
15192: PPUSH
15193: LD_INT 2
15195: PPUSH
15196: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15200: LD_EXP 13
15204: PPUSH
15205: LD_STRING 11_artifact_captured
15207: PPUSH
15208: CALL_OW 39
// if artifact_get then
15212: LD_EXP 13
15216: IFFALSE 15238
// begin m2 := true ;
15218: LD_ADDR_VAR 0 3
15222: PUSH
15223: LD_INT 1
15225: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15226: LD_STRING Artefact
15228: PPUSH
15229: LD_INT 1
15231: PPUSH
15232: CALL_OW 101
// end else
15236: GO 15249
// AddMedal ( Artefact , - 1 ) ;
15238: LD_STRING Artefact
15240: PPUSH
15241: LD_INT 1
15243: NEG
15244: PPUSH
15245: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15249: LD_VAR 0 2
15253: PUSH
15254: LD_VAR 0 3
15258: AND
15259: PUSH
15260: LD_VAR 0 4
15264: AND
15265: PUSH
15266: LD_OWVAR 67
15270: PUSH
15271: LD_INT 3
15273: EQUAL
15274: AND
15275: IFFALSE 15287
// SetAchievementEX ( ACH_AMER , 11 ) ;
15277: LD_STRING ACH_AMER
15279: PPUSH
15280: LD_INT 11
15282: PPUSH
15283: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15287: LD_VAR 0 2
15291: PUSH
15292: LD_VAR 0 3
15296: AND
15297: PUSH
15298: LD_VAR 0 4
15302: AND
15303: PUSH
15304: LD_EXP 17
15308: PUSH
15309: LD_INT 0
15311: EQUAL
15312: AND
15313: IFFALSE 15329
// begin wait ( 3 ) ;
15315: LD_INT 3
15317: PPUSH
15318: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15322: LD_STRING ACH_GENERAL
15324: PPUSH
15325: CALL_OW 543
// end ; if tick <= 100 100$00 then
15329: LD_OWVAR 1
15333: PUSH
15334: LD_INT 210000
15336: LESSEQUAL
15337: IFFALSE 15353
// begin wait ( 3 ) ;
15339: LD_INT 3
15341: PPUSH
15342: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15346: LD_STRING ACH_ASPEED_11
15348: PPUSH
15349: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15353: LD_STRING MAIN
15355: PPUSH
15356: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15360: LD_ADDR_EXP 19
15364: PUSH
15365: LD_EXP 19
15369: PPUSH
15370: LD_INT 51
15372: PUSH
15373: EMPTY
15374: LIST
15375: PPUSH
15376: CALL_OW 72
15380: ST_TO_ADDR
// tmp := JMM ^ selected ;
15381: LD_ADDR_VAR 0 1
15385: PUSH
15386: LD_EXP 21
15390: PUSH
15391: LD_EXP 19
15395: ADD
15396: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15397: LD_VAR 0 1
15401: PPUSH
15402: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15406: LD_VAR 0 1
15410: PUSH
15411: LD_EXP 21
15415: PUSH
15416: LD_EXP 22
15420: PUSH
15421: LD_EXP 23
15425: PUSH
15426: LD_EXP 24
15430: PUSH
15431: LD_EXP 25
15435: PUSH
15436: LD_EXP 26
15440: PUSH
15441: LD_EXP 27
15445: PUSH
15446: LD_EXP 28
15450: PUSH
15451: LD_EXP 29
15455: PUSH
15456: LD_EXP 31
15460: PUSH
15461: LD_EXP 32
15465: PUSH
15466: LD_EXP 33
15470: PUSH
15471: LD_EXP 34
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: DIFF
15491: PPUSH
15492: LD_STRING 11c_others
15494: PPUSH
15495: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
15499: LD_EXP 21
15503: PPUSH
15504: LD_EXP 3
15508: PUSH
15509: LD_STRING JMM
15511: STR
15512: PPUSH
15513: CALL_OW 38
// if Lisa then
15517: LD_EXP 22
15521: IFFALSE 15541
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
15523: LD_EXP 22
15527: PPUSH
15528: LD_EXP 3
15532: PUSH
15533: LD_STRING Lisa
15535: STR
15536: PPUSH
15537: CALL_OW 38
// if Donaldson then
15541: LD_EXP 23
15545: IFFALSE 15565
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15547: LD_EXP 23
15551: PPUSH
15552: LD_EXP 3
15556: PUSH
15557: LD_STRING Donaldson
15559: STR
15560: PPUSH
15561: CALL_OW 38
// if Bobby then
15565: LD_EXP 24
15569: IFFALSE 15589
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15571: LD_EXP 24
15575: PPUSH
15576: LD_EXP 3
15580: PUSH
15581: LD_STRING Bobby
15583: STR
15584: PPUSH
15585: CALL_OW 38
// if Cyrus then
15589: LD_EXP 25
15593: IFFALSE 15613
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15595: LD_EXP 25
15599: PPUSH
15600: LD_EXP 3
15604: PUSH
15605: LD_STRING Cyrus
15607: STR
15608: PPUSH
15609: CALL_OW 38
// if Denis then
15613: LD_EXP 26
15617: IFFALSE 15637
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15619: LD_EXP 26
15623: PPUSH
15624: LD_EXP 3
15628: PUSH
15629: LD_STRING Denis
15631: STR
15632: PPUSH
15633: CALL_OW 38
// if Brown then
15637: LD_EXP 27
15641: IFFALSE 15661
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15643: LD_EXP 27
15647: PPUSH
15648: LD_EXP 3
15652: PUSH
15653: LD_STRING Brown
15655: STR
15656: PPUSH
15657: CALL_OW 38
// if Gladstone then
15661: LD_EXP 28
15665: IFFALSE 15685
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15667: LD_EXP 28
15671: PPUSH
15672: LD_EXP 3
15676: PUSH
15677: LD_STRING Gladstone
15679: STR
15680: PPUSH
15681: CALL_OW 38
// if Houten then
15685: LD_EXP 29
15689: IFFALSE 15709
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15691: LD_EXP 29
15695: PPUSH
15696: LD_EXP 3
15700: PUSH
15701: LD_STRING Houten
15703: STR
15704: PPUSH
15705: CALL_OW 38
// if Cornel then
15709: LD_EXP 31
15713: IFFALSE 15733
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
15715: LD_EXP 31
15719: PPUSH
15720: LD_EXP 3
15724: PUSH
15725: LD_STRING Cornell
15727: STR
15728: PPUSH
15729: CALL_OW 38
// if Gary then
15733: LD_EXP 32
15737: IFFALSE 15757
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15739: LD_EXP 32
15743: PPUSH
15744: LD_EXP 3
15748: PUSH
15749: LD_STRING Gary
15751: STR
15752: PPUSH
15753: CALL_OW 38
// if Frank then
15757: LD_EXP 33
15761: IFFALSE 15781
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15763: LD_EXP 33
15767: PPUSH
15768: LD_EXP 3
15772: PUSH
15773: LD_STRING Frank
15775: STR
15776: PPUSH
15777: CALL_OW 38
// if Kikuchi then
15781: LD_EXP 34
15785: IFFALSE 15805
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15787: LD_EXP 34
15791: PPUSH
15792: LD_EXP 3
15796: PUSH
15797: LD_STRING Kikuchi
15799: STR
15800: PPUSH
15801: CALL_OW 38
// YouWin ;
15805: CALL_OW 103
// end ;
15809: PPOPN 4
15811: END
// export function CanSayRand ( side ) ; begin
15812: LD_INT 0
15814: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15815: LD_ADDR_VAR 0 2
15819: PUSH
15820: LD_INT 52
15822: PUSH
15823: EMPTY
15824: LIST
15825: PUSH
15826: LD_INT 22
15828: PUSH
15829: LD_VAR 0 1
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 2
15840: PUSH
15841: LD_INT 25
15843: PUSH
15844: LD_INT 1
15846: PUSH
15847: EMPTY
15848: LIST
15849: LIST
15850: PUSH
15851: LD_INT 25
15853: PUSH
15854: LD_INT 2
15856: PUSH
15857: EMPTY
15858: LIST
15859: LIST
15860: PUSH
15861: LD_INT 25
15863: PUSH
15864: LD_INT 3
15866: PUSH
15867: EMPTY
15868: LIST
15869: LIST
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 4
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: LIST
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: LIST
15892: PPUSH
15893: CALL_OW 69
15897: PUSH
15898: LD_EXP 21
15902: PUSH
15903: LD_EXP 33
15907: PUSH
15908: LD_EXP 22
15912: PUSH
15913: LD_EXP 23
15917: PUSH
15918: LD_EXP 24
15922: PUSH
15923: LD_EXP 25
15927: PUSH
15928: LD_EXP 26
15932: PUSH
15933: LD_EXP 27
15937: PUSH
15938: LD_EXP 28
15942: PUSH
15943: LD_EXP 29
15947: PUSH
15948: LD_EXP 30
15952: PUSH
15953: LD_EXP 31
15957: PUSH
15958: LD_EXP 32
15962: PUSH
15963: LD_EXP 34
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: LIST
15972: LIST
15973: LIST
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: LIST
15982: LIST
15983: DIFF
15984: ST_TO_ADDR
// end ;
15985: LD_VAR 0 2
15989: RET
// export function SayRand ( sex , dial ) ; begin
15990: LD_INT 0
15992: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15993: LD_ADDR_VAR 0 3
15997: PUSH
15998: LD_INT 52
16000: PUSH
16001: EMPTY
16002: LIST
16003: PUSH
16004: LD_INT 22
16006: PUSH
16007: LD_INT 1
16009: PUSH
16010: EMPTY
16011: LIST
16012: LIST
16013: PUSH
16014: LD_INT 26
16016: PUSH
16017: LD_VAR 0 1
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PUSH
16026: LD_INT 2
16028: PUSH
16029: LD_INT 25
16031: PUSH
16032: LD_INT 1
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PUSH
16039: LD_INT 25
16041: PUSH
16042: LD_INT 2
16044: PUSH
16045: EMPTY
16046: LIST
16047: LIST
16048: PUSH
16049: LD_INT 25
16051: PUSH
16052: LD_INT 3
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: PUSH
16059: LD_INT 25
16061: PUSH
16062: LD_INT 4
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PUSH
16069: EMPTY
16070: LIST
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: LIST
16080: LIST
16081: PPUSH
16082: CALL_OW 69
16086: PUSH
16087: LD_EXP 21
16091: PUSH
16092: LD_EXP 33
16096: PUSH
16097: LD_EXP 22
16101: PUSH
16102: LD_EXP 23
16106: PUSH
16107: LD_EXP 24
16111: PUSH
16112: LD_EXP 25
16116: PUSH
16117: LD_EXP 26
16121: PUSH
16122: LD_EXP 27
16126: PUSH
16127: LD_EXP 28
16131: PUSH
16132: LD_EXP 29
16136: PUSH
16137: LD_EXP 30
16141: PUSH
16142: LD_EXP 31
16146: PUSH
16147: LD_EXP 32
16151: PUSH
16152: LD_EXP 34
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: LIST
16164: LIST
16165: LIST
16166: LIST
16167: LIST
16168: LIST
16169: LIST
16170: LIST
16171: LIST
16172: DIFF
16173: ST_TO_ADDR
// if not result then
16174: LD_VAR 0 3
16178: NOT
16179: IFFALSE 16183
// exit ;
16181: GO 16211
// result := result [ 1 ] ;
16183: LD_ADDR_VAR 0 3
16187: PUSH
16188: LD_VAR 0 3
16192: PUSH
16193: LD_INT 1
16195: ARRAY
16196: ST_TO_ADDR
// Say ( result , dial ) ;
16197: LD_VAR 0 3
16201: PPUSH
16202: LD_VAR 0 2
16206: PPUSH
16207: CALL_OW 88
// end ;
16211: LD_VAR 0 3
16215: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16216: LD_INT 0
16218: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16219: LD_ADDR_VAR 0 4
16223: PUSH
16224: LD_INT 22
16226: PUSH
16227: LD_INT 1
16229: PUSH
16230: EMPTY
16231: LIST
16232: LIST
16233: PUSH
16234: LD_INT 26
16236: PUSH
16237: LD_VAR 0 1
16241: PUSH
16242: EMPTY
16243: LIST
16244: LIST
16245: PUSH
16246: LD_INT 2
16248: PUSH
16249: LD_INT 25
16251: PUSH
16252: LD_INT 1
16254: PUSH
16255: EMPTY
16256: LIST
16257: LIST
16258: PUSH
16259: LD_INT 25
16261: PUSH
16262: LD_INT 2
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: PUSH
16269: LD_INT 25
16271: PUSH
16272: LD_INT 3
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PUSH
16279: LD_INT 25
16281: PUSH
16282: LD_INT 4
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: PUSH
16289: EMPTY
16290: LIST
16291: LIST
16292: LIST
16293: LIST
16294: LIST
16295: PUSH
16296: EMPTY
16297: LIST
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 69
16305: PUSH
16306: LD_EXP 21
16310: PUSH
16311: LD_EXP 33
16315: PUSH
16316: LD_EXP 22
16320: PUSH
16321: LD_EXP 23
16325: PUSH
16326: LD_EXP 24
16330: PUSH
16331: LD_EXP 25
16335: PUSH
16336: LD_EXP 26
16340: PUSH
16341: LD_EXP 27
16345: PUSH
16346: LD_EXP 28
16350: PUSH
16351: LD_EXP 29
16355: PUSH
16356: LD_EXP 30
16360: PUSH
16361: LD_EXP 31
16365: PUSH
16366: LD_EXP 32
16370: PUSH
16371: LD_EXP 34
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: LIST
16380: LIST
16381: LIST
16382: LIST
16383: LIST
16384: LIST
16385: LIST
16386: LIST
16387: LIST
16388: LIST
16389: LIST
16390: LIST
16391: PUSH
16392: LD_VAR 0 3
16396: ADD
16397: DIFF
16398: ST_TO_ADDR
// if not result then
16399: LD_VAR 0 4
16403: NOT
16404: IFFALSE 16408
// exit ;
16406: GO 16436
// result := result [ 1 ] ;
16408: LD_ADDR_VAR 0 4
16412: PUSH
16413: LD_VAR 0 4
16417: PUSH
16418: LD_INT 1
16420: ARRAY
16421: ST_TO_ADDR
// Say ( result , dial ) ;
16422: LD_VAR 0 4
16426: PPUSH
16427: LD_VAR 0 2
16431: PPUSH
16432: CALL_OW 88
// end ; end_of_file
16436: LD_VAR 0 4
16440: RET
// export function CustomEvent ( event ) ; begin
16441: LD_INT 0
16443: PPUSH
// end ;
16444: LD_VAR 0 2
16448: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
16449: LD_VAR 0 1
16453: PPUSH
16454: CALL_OW 255
16458: PUSH
16459: LD_INT 1
16461: EQUAL
16462: IFFALSE 16472
// artifact_get := true ;
16464: LD_ADDR_EXP 13
16468: PUSH
16469: LD_INT 1
16471: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
16472: LD_VAR 0 1
16476: PPUSH
16477: CALL_OW 255
16481: PUSH
16482: LD_INT 2
16484: EQUAL
16485: IFFALSE 16503
// begin artifact_get := false ;
16487: LD_ADDR_EXP 13
16491: PUSH
16492: LD_INT 0
16494: ST_TO_ADDR
// artifact_stolen := true ;
16495: LD_ADDR_EXP 12
16499: PUSH
16500: LD_INT 1
16502: ST_TO_ADDR
// end ; artifact_oncargo := true ;
16503: LD_ADDR_EXP 14
16507: PUSH
16508: LD_INT 1
16510: ST_TO_ADDR
// end ;
16511: PPOPN 2
16513: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
16514: LD_ADDR_EXP 14
16518: PUSH
16519: LD_INT 0
16521: ST_TO_ADDR
// end ;
16522: PPOPN 2
16524: END
// on UnitDestroyed ( un ) do begin if un = JMM then
16525: LD_VAR 0 1
16529: PUSH
16530: LD_EXP 21
16534: EQUAL
16535: IFFALSE 16546
// begin YouLost ( JMM ) ;
16537: LD_STRING JMM
16539: PPUSH
16540: CALL_OW 104
// exit ;
16544: GO 16678
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16546: LD_VAR 0 1
16550: PUSH
16551: LD_INT 22
16553: PUSH
16554: LD_INT 1
16556: PUSH
16557: EMPTY
16558: LIST
16559: LIST
16560: PUSH
16561: LD_INT 21
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 25
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 25
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 25
16596: PUSH
16597: LD_INT 3
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: LD_INT 25
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 25
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: LD_INT 25
16626: PUSH
16627: LD_INT 8
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: LIST
16639: LIST
16640: LIST
16641: LIST
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: LIST
16647: PPUSH
16648: CALL_OW 69
16652: IN
16653: IFFALSE 16669
// loses_counter := loses_counter + 1 ;
16655: LD_ADDR_EXP 17
16659: PUSH
16660: LD_EXP 17
16664: PUSH
16665: LD_INT 1
16667: PLUS
16668: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16669: LD_VAR 0 1
16673: PPUSH
16674: CALL 44366 0 1
// end ;
16678: PPOPN 1
16680: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16681: LD_VAR 0 1
16685: PPUSH
16686: LD_VAR 0 2
16690: PPUSH
16691: CALL 46700 0 2
// end ;
16695: PPOPN 2
16697: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16698: LD_VAR 0 1
16702: PPUSH
16703: CALL 46009 0 1
// end ;
16707: PPOPN 1
16709: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16710: LD_VAR 0 1
16714: PPUSH
16715: LD_VAR 0 2
16719: PPUSH
16720: LD_VAR 0 3
16724: PPUSH
16725: LD_VAR 0 4
16729: PPUSH
16730: LD_VAR 0 5
16734: PPUSH
16735: CALL 43682 0 5
// end ;
16739: PPOPN 5
16741: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
16742: LD_VAR 0 1
16746: PPUSH
16747: CALL_OW 248
16751: PUSH
16752: LD_INT 1
16754: EQUAL
16755: IFFALSE 16765
// am_veh_consturcted := true ;
16757: LD_ADDR_EXP 20
16761: PUSH
16762: LD_INT 1
16764: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
16765: LD_VAR 0 1
16769: PPUSH
16770: LD_VAR 0 2
16774: PPUSH
16775: CALL 43278 0 2
// end ;
16779: PPOPN 2
16781: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16782: LD_VAR 0 1
16786: PPUSH
16787: CALL_OW 247
16791: PUSH
16792: LD_INT 2
16794: EQUAL
16795: IFFALSE 16799
// exit ;
16797: GO 16816
// if not kamikazed then
16799: LD_EXP 11
16803: NOT
16804: IFFALSE 16816
// kamikazed := unit ;
16806: LD_ADDR_EXP 11
16810: PUSH
16811: LD_VAR 0 1
16815: ST_TO_ADDR
// end ;
16816: PPOPN 1
16818: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16819: LD_INT 0
16821: PPUSH
16822: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16823: LD_VAR 0 1
16827: PPUSH
16828: LD_VAR 0 2
16832: PPUSH
16833: LD_VAR 0 3
16837: PPUSH
16838: LD_VAR 0 4
16842: PPUSH
16843: CALL 43116 0 4
// end ;
16847: PPOPN 6
16849: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16850: LD_VAR 0 1
16854: PPUSH
16855: LD_VAR 0 2
16859: PPUSH
16860: LD_VAR 0 3
16864: PPUSH
16865: CALL 42891 0 3
// end ;
16869: PPOPN 3
16871: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16872: LD_VAR 0 1
16876: PPUSH
16877: LD_VAR 0 2
16881: PPUSH
16882: CALL 44062 0 2
// end ;
16886: PPOPN 2
16888: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16889: LD_VAR 0 1
16893: PPUSH
16894: LD_VAR 0 2
16898: PPUSH
16899: CALL 42585 0 2
// end ;
16903: PPOPN 2
16905: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16906: LD_VAR 0 1
16910: PPUSH
16911: LD_VAR 0 2
16915: PPUSH
16916: CALL 42776 0 2
// end ;
16920: PPOPN 2
16922: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16923: LD_VAR 0 1
16927: PPUSH
16928: CALL 45768 0 1
// end ;
16932: PPOPN 1
16934: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16935: LD_VAR 0 1
16939: PPUSH
16940: LD_VAR 0 2
16944: PPUSH
16945: CALL 46961 0 2
// end ;
16949: PPOPN 2
16951: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_VAR 0 2
16961: PPUSH
16962: LD_VAR 0 3
16966: PPUSH
16967: LD_VAR 0 4
16971: PPUSH
16972: CALL 47177 0 4
// end ;
16976: PPOPN 4
16978: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL 90622 0 1
// end ; end_of_file
16988: PPOPN 1
16990: END
// every 0 0$1 trigger game do
16991: LD_EXP 2
16995: IFFALSE 17025
16997: GO 16999
16999: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17000: LD_INT 7
17002: PUSH
17003: LD_INT 6
17005: PUSH
17006: LD_INT 4
17008: PUSH
17009: LD_INT 6
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: PPUSH
17018: LD_INT 1750
17020: PPUSH
17021: CALL 17026 0 2
17025: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17026: LD_INT 0
17028: PPUSH
17029: PPUSH
17030: PPUSH
// if not areas then
17031: LD_VAR 0 1
17035: NOT
17036: IFFALSE 17040
// exit ;
17038: GO 17170
// repeat wait ( time ) ;
17040: LD_VAR 0 2
17044: PPUSH
17045: CALL_OW 67
// p := rand ( 1 , 90 ) ;
17049: LD_ADDR_VAR 0 5
17053: PUSH
17054: LD_INT 1
17056: PPUSH
17057: LD_INT 90
17059: PPUSH
17060: CALL_OW 12
17064: ST_TO_ADDR
// for i in areas do
17065: LD_ADDR_VAR 0 4
17069: PUSH
17070: LD_VAR 0 1
17074: PUSH
17075: FOR_IN
17076: IFFALSE 17129
// begin if Prob ( p ) then
17078: LD_VAR 0 5
17082: PPUSH
17083: CALL_OW 13
17087: IFFALSE 17127
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 5
17094: PPUSH
17095: CALL_OW 12
17099: PPUSH
17100: LD_VAR 0 4
17104: PPUSH
17105: LD_INT 1
17107: PPUSH
17108: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
17112: LD_INT 385
17114: PPUSH
17115: LD_INT 595
17117: PPUSH
17118: CALL_OW 12
17122: PPUSH
17123: CALL_OW 67
// end ; end ;
17127: GO 17075
17129: POP
17130: POP
// time := time + 0 0$3 ;
17131: LD_ADDR_VAR 0 2
17135: PUSH
17136: LD_VAR 0 2
17140: PUSH
17141: LD_INT 105
17143: PLUS
17144: ST_TO_ADDR
// if time > 7 7$00 then
17145: LD_VAR 0 2
17149: PUSH
17150: LD_INT 14700
17152: GREATER
17153: IFFALSE 17163
// time := 0 0$40 ;
17155: LD_ADDR_VAR 0 2
17159: PUSH
17160: LD_INT 1400
17162: ST_TO_ADDR
// until not game ;
17163: LD_EXP 2
17167: NOT
17168: IFFALSE 17040
// end ; end_of_file
17170: LD_VAR 0 3
17174: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
// skirmish := false ;
17179: LD_ADDR_EXP 48
17183: PUSH
17184: LD_INT 0
17186: ST_TO_ADDR
// debug_mc := false ;
17187: LD_ADDR_EXP 49
17191: PUSH
17192: LD_INT 0
17194: ST_TO_ADDR
// mc_bases := [ ] ;
17195: LD_ADDR_EXP 50
17199: PUSH
17200: EMPTY
17201: ST_TO_ADDR
// mc_sides := [ ] ;
17202: LD_ADDR_EXP 76
17206: PUSH
17207: EMPTY
17208: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17209: LD_ADDR_EXP 51
17213: PUSH
17214: EMPTY
17215: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17216: LD_ADDR_EXP 52
17220: PUSH
17221: EMPTY
17222: ST_TO_ADDR
// mc_need_heal := [ ] ;
17223: LD_ADDR_EXP 53
17227: PUSH
17228: EMPTY
17229: ST_TO_ADDR
// mc_healers := [ ] ;
17230: LD_ADDR_EXP 54
17234: PUSH
17235: EMPTY
17236: ST_TO_ADDR
// mc_build_list := [ ] ;
17237: LD_ADDR_EXP 55
17241: PUSH
17242: EMPTY
17243: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17244: LD_ADDR_EXP 82
17248: PUSH
17249: EMPTY
17250: ST_TO_ADDR
// mc_builders := [ ] ;
17251: LD_ADDR_EXP 56
17255: PUSH
17256: EMPTY
17257: ST_TO_ADDR
// mc_construct_list := [ ] ;
17258: LD_ADDR_EXP 57
17262: PUSH
17263: EMPTY
17264: ST_TO_ADDR
// mc_turret_list := [ ] ;
17265: LD_ADDR_EXP 58
17269: PUSH
17270: EMPTY
17271: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17272: LD_ADDR_EXP 59
17276: PUSH
17277: EMPTY
17278: ST_TO_ADDR
// mc_miners := [ ] ;
17279: LD_ADDR_EXP 64
17283: PUSH
17284: EMPTY
17285: ST_TO_ADDR
// mc_mines := [ ] ;
17286: LD_ADDR_EXP 63
17290: PUSH
17291: EMPTY
17292: ST_TO_ADDR
// mc_minefields := [ ] ;
17293: LD_ADDR_EXP 65
17297: PUSH
17298: EMPTY
17299: ST_TO_ADDR
// mc_crates := [ ] ;
17300: LD_ADDR_EXP 66
17304: PUSH
17305: EMPTY
17306: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17307: LD_ADDR_EXP 67
17311: PUSH
17312: EMPTY
17313: ST_TO_ADDR
// mc_crates_area := [ ] ;
17314: LD_ADDR_EXP 68
17318: PUSH
17319: EMPTY
17320: ST_TO_ADDR
// mc_vehicles := [ ] ;
17321: LD_ADDR_EXP 69
17325: PUSH
17326: EMPTY
17327: ST_TO_ADDR
// mc_attack := [ ] ;
17328: LD_ADDR_EXP 70
17332: PUSH
17333: EMPTY
17334: ST_TO_ADDR
// mc_produce := [ ] ;
17335: LD_ADDR_EXP 71
17339: PUSH
17340: EMPTY
17341: ST_TO_ADDR
// mc_defender := [ ] ;
17342: LD_ADDR_EXP 72
17346: PUSH
17347: EMPTY
17348: ST_TO_ADDR
// mc_parking := [ ] ;
17349: LD_ADDR_EXP 74
17353: PUSH
17354: EMPTY
17355: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17356: LD_ADDR_EXP 60
17360: PUSH
17361: EMPTY
17362: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17363: LD_ADDR_EXP 62
17367: PUSH
17368: EMPTY
17369: ST_TO_ADDR
// mc_scan := [ ] ;
17370: LD_ADDR_EXP 73
17374: PUSH
17375: EMPTY
17376: ST_TO_ADDR
// mc_scan_area := [ ] ;
17377: LD_ADDR_EXP 75
17381: PUSH
17382: EMPTY
17383: ST_TO_ADDR
// mc_tech := [ ] ;
17384: LD_ADDR_EXP 77
17388: PUSH
17389: EMPTY
17390: ST_TO_ADDR
// mc_class := [ ] ;
17391: LD_ADDR_EXP 91
17395: PUSH
17396: EMPTY
17397: ST_TO_ADDR
// mc_class_case_use := [ ] ;
17398: LD_ADDR_EXP 92
17402: PUSH
17403: EMPTY
17404: ST_TO_ADDR
// end ;
17405: LD_VAR 0 1
17409: RET
// export function MC_Kill ( base ) ; begin
17410: LD_INT 0
17412: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
17413: LD_ADDR_EXP 50
17417: PUSH
17418: LD_EXP 50
17422: PPUSH
17423: LD_VAR 0 1
17427: PPUSH
17428: EMPTY
17429: PPUSH
17430: CALL_OW 1
17434: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
17435: LD_ADDR_EXP 51
17439: PUSH
17440: LD_EXP 51
17444: PPUSH
17445: LD_VAR 0 1
17449: PPUSH
17450: EMPTY
17451: PPUSH
17452: CALL_OW 1
17456: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
17457: LD_ADDR_EXP 52
17461: PUSH
17462: LD_EXP 52
17466: PPUSH
17467: LD_VAR 0 1
17471: PPUSH
17472: EMPTY
17473: PPUSH
17474: CALL_OW 1
17478: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
17479: LD_ADDR_EXP 53
17483: PUSH
17484: LD_EXP 53
17488: PPUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: EMPTY
17495: PPUSH
17496: CALL_OW 1
17500: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
17501: LD_ADDR_EXP 54
17505: PUSH
17506: LD_EXP 54
17510: PPUSH
17511: LD_VAR 0 1
17515: PPUSH
17516: EMPTY
17517: PPUSH
17518: CALL_OW 1
17522: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
17523: LD_ADDR_EXP 55
17527: PUSH
17528: LD_EXP 55
17532: PPUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: EMPTY
17539: PPUSH
17540: CALL_OW 1
17544: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
17545: LD_ADDR_EXP 56
17549: PUSH
17550: LD_EXP 56
17554: PPUSH
17555: LD_VAR 0 1
17559: PPUSH
17560: EMPTY
17561: PPUSH
17562: CALL_OW 1
17566: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
17567: LD_ADDR_EXP 57
17571: PUSH
17572: LD_EXP 57
17576: PPUSH
17577: LD_VAR 0 1
17581: PPUSH
17582: EMPTY
17583: PPUSH
17584: CALL_OW 1
17588: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17589: LD_ADDR_EXP 58
17593: PUSH
17594: LD_EXP 58
17598: PPUSH
17599: LD_VAR 0 1
17603: PPUSH
17604: EMPTY
17605: PPUSH
17606: CALL_OW 1
17610: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17611: LD_ADDR_EXP 59
17615: PUSH
17616: LD_EXP 59
17620: PPUSH
17621: LD_VAR 0 1
17625: PPUSH
17626: EMPTY
17627: PPUSH
17628: CALL_OW 1
17632: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17633: LD_ADDR_EXP 60
17637: PUSH
17638: LD_EXP 60
17642: PPUSH
17643: LD_VAR 0 1
17647: PPUSH
17648: EMPTY
17649: PPUSH
17650: CALL_OW 1
17654: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17655: LD_ADDR_EXP 61
17659: PUSH
17660: LD_EXP 61
17664: PPUSH
17665: LD_VAR 0 1
17669: PPUSH
17670: LD_INT 0
17672: PPUSH
17673: CALL_OW 1
17677: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17678: LD_ADDR_EXP 62
17682: PUSH
17683: LD_EXP 62
17687: PPUSH
17688: LD_VAR 0 1
17692: PPUSH
17693: EMPTY
17694: PPUSH
17695: CALL_OW 1
17699: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17700: LD_ADDR_EXP 63
17704: PUSH
17705: LD_EXP 63
17709: PPUSH
17710: LD_VAR 0 1
17714: PPUSH
17715: EMPTY
17716: PPUSH
17717: CALL_OW 1
17721: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17722: LD_ADDR_EXP 64
17726: PUSH
17727: LD_EXP 64
17731: PPUSH
17732: LD_VAR 0 1
17736: PPUSH
17737: EMPTY
17738: PPUSH
17739: CALL_OW 1
17743: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17744: LD_ADDR_EXP 65
17748: PUSH
17749: LD_EXP 65
17753: PPUSH
17754: LD_VAR 0 1
17758: PPUSH
17759: EMPTY
17760: PPUSH
17761: CALL_OW 1
17765: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17766: LD_ADDR_EXP 66
17770: PUSH
17771: LD_EXP 66
17775: PPUSH
17776: LD_VAR 0 1
17780: PPUSH
17781: EMPTY
17782: PPUSH
17783: CALL_OW 1
17787: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17788: LD_ADDR_EXP 67
17792: PUSH
17793: LD_EXP 67
17797: PPUSH
17798: LD_VAR 0 1
17802: PPUSH
17803: EMPTY
17804: PPUSH
17805: CALL_OW 1
17809: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17810: LD_ADDR_EXP 68
17814: PUSH
17815: LD_EXP 68
17819: PPUSH
17820: LD_VAR 0 1
17824: PPUSH
17825: EMPTY
17826: PPUSH
17827: CALL_OW 1
17831: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17832: LD_ADDR_EXP 69
17836: PUSH
17837: LD_EXP 69
17841: PPUSH
17842: LD_VAR 0 1
17846: PPUSH
17847: EMPTY
17848: PPUSH
17849: CALL_OW 1
17853: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17854: LD_ADDR_EXP 70
17858: PUSH
17859: LD_EXP 70
17863: PPUSH
17864: LD_VAR 0 1
17868: PPUSH
17869: EMPTY
17870: PPUSH
17871: CALL_OW 1
17875: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17876: LD_ADDR_EXP 71
17880: PUSH
17881: LD_EXP 71
17885: PPUSH
17886: LD_VAR 0 1
17890: PPUSH
17891: EMPTY
17892: PPUSH
17893: CALL_OW 1
17897: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17898: LD_ADDR_EXP 72
17902: PUSH
17903: LD_EXP 72
17907: PPUSH
17908: LD_VAR 0 1
17912: PPUSH
17913: EMPTY
17914: PPUSH
17915: CALL_OW 1
17919: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17920: LD_ADDR_EXP 73
17924: PUSH
17925: LD_EXP 73
17929: PPUSH
17930: LD_VAR 0 1
17934: PPUSH
17935: EMPTY
17936: PPUSH
17937: CALL_OW 1
17941: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17942: LD_ADDR_EXP 74
17946: PUSH
17947: LD_EXP 74
17951: PPUSH
17952: LD_VAR 0 1
17956: PPUSH
17957: EMPTY
17958: PPUSH
17959: CALL_OW 1
17963: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17964: LD_ADDR_EXP 75
17968: PUSH
17969: LD_EXP 75
17973: PPUSH
17974: LD_VAR 0 1
17978: PPUSH
17979: EMPTY
17980: PPUSH
17981: CALL_OW 1
17985: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17986: LD_ADDR_EXP 77
17990: PUSH
17991: LD_EXP 77
17995: PPUSH
17996: LD_VAR 0 1
18000: PPUSH
18001: EMPTY
18002: PPUSH
18003: CALL_OW 1
18007: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18008: LD_ADDR_EXP 79
18012: PUSH
18013: LD_EXP 79
18017: PPUSH
18018: LD_VAR 0 1
18022: PPUSH
18023: EMPTY
18024: PPUSH
18025: CALL_OW 1
18029: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18030: LD_ADDR_EXP 80
18034: PUSH
18035: LD_EXP 80
18039: PPUSH
18040: LD_VAR 0 1
18044: PPUSH
18045: EMPTY
18046: PPUSH
18047: CALL_OW 1
18051: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18052: LD_ADDR_EXP 81
18056: PUSH
18057: LD_EXP 81
18061: PPUSH
18062: LD_VAR 0 1
18066: PPUSH
18067: EMPTY
18068: PPUSH
18069: CALL_OW 1
18073: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18074: LD_ADDR_EXP 82
18078: PUSH
18079: LD_EXP 82
18083: PPUSH
18084: LD_VAR 0 1
18088: PPUSH
18089: EMPTY
18090: PPUSH
18091: CALL_OW 1
18095: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18096: LD_ADDR_EXP 83
18100: PUSH
18101: LD_EXP 83
18105: PPUSH
18106: LD_VAR 0 1
18110: PPUSH
18111: EMPTY
18112: PPUSH
18113: CALL_OW 1
18117: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18118: LD_ADDR_EXP 84
18122: PUSH
18123: LD_EXP 84
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: EMPTY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18140: LD_ADDR_EXP 85
18144: PUSH
18145: LD_EXP 85
18149: PPUSH
18150: LD_VAR 0 1
18154: PPUSH
18155: EMPTY
18156: PPUSH
18157: CALL_OW 1
18161: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18162: LD_ADDR_EXP 86
18166: PUSH
18167: LD_EXP 86
18171: PPUSH
18172: LD_VAR 0 1
18176: PPUSH
18177: EMPTY
18178: PPUSH
18179: CALL_OW 1
18183: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18184: LD_ADDR_EXP 87
18188: PUSH
18189: LD_EXP 87
18193: PPUSH
18194: LD_VAR 0 1
18198: PPUSH
18199: EMPTY
18200: PPUSH
18201: CALL_OW 1
18205: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18206: LD_ADDR_EXP 88
18210: PUSH
18211: LD_EXP 88
18215: PPUSH
18216: LD_VAR 0 1
18220: PPUSH
18221: EMPTY
18222: PPUSH
18223: CALL_OW 1
18227: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18228: LD_ADDR_EXP 89
18232: PUSH
18233: LD_EXP 89
18237: PPUSH
18238: LD_VAR 0 1
18242: PPUSH
18243: EMPTY
18244: PPUSH
18245: CALL_OW 1
18249: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18250: LD_ADDR_EXP 90
18254: PUSH
18255: LD_EXP 90
18259: PPUSH
18260: LD_VAR 0 1
18264: PPUSH
18265: EMPTY
18266: PPUSH
18267: CALL_OW 1
18271: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18272: LD_ADDR_EXP 91
18276: PUSH
18277: LD_EXP 91
18281: PPUSH
18282: LD_VAR 0 1
18286: PPUSH
18287: EMPTY
18288: PPUSH
18289: CALL_OW 1
18293: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18294: LD_ADDR_EXP 92
18298: PUSH
18299: LD_EXP 92
18303: PPUSH
18304: LD_VAR 0 1
18308: PPUSH
18309: LD_INT 0
18311: PPUSH
18312: CALL_OW 1
18316: ST_TO_ADDR
// end ;
18317: LD_VAR 0 2
18321: RET
// export function MC_Add ( side , units ) ; var base ; begin
18322: LD_INT 0
18324: PPUSH
18325: PPUSH
// base := mc_bases + 1 ;
18326: LD_ADDR_VAR 0 4
18330: PUSH
18331: LD_EXP 50
18335: PUSH
18336: LD_INT 1
18338: PLUS
18339: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18340: LD_ADDR_EXP 76
18344: PUSH
18345: LD_EXP 76
18349: PPUSH
18350: LD_VAR 0 4
18354: PPUSH
18355: LD_VAR 0 1
18359: PPUSH
18360: CALL_OW 1
18364: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18365: LD_ADDR_EXP 50
18369: PUSH
18370: LD_EXP 50
18374: PPUSH
18375: LD_VAR 0 4
18379: PPUSH
18380: LD_VAR 0 2
18384: PPUSH
18385: CALL_OW 1
18389: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18390: LD_ADDR_EXP 51
18394: PUSH
18395: LD_EXP 51
18399: PPUSH
18400: LD_VAR 0 4
18404: PPUSH
18405: EMPTY
18406: PPUSH
18407: CALL_OW 1
18411: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18412: LD_ADDR_EXP 52
18416: PUSH
18417: LD_EXP 52
18421: PPUSH
18422: LD_VAR 0 4
18426: PPUSH
18427: EMPTY
18428: PPUSH
18429: CALL_OW 1
18433: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18434: LD_ADDR_EXP 53
18438: PUSH
18439: LD_EXP 53
18443: PPUSH
18444: LD_VAR 0 4
18448: PPUSH
18449: EMPTY
18450: PPUSH
18451: CALL_OW 1
18455: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18456: LD_ADDR_EXP 54
18460: PUSH
18461: LD_EXP 54
18465: PPUSH
18466: LD_VAR 0 4
18470: PPUSH
18471: EMPTY
18472: PPUSH
18473: CALL_OW 1
18477: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18478: LD_ADDR_EXP 55
18482: PUSH
18483: LD_EXP 55
18487: PPUSH
18488: LD_VAR 0 4
18492: PPUSH
18493: EMPTY
18494: PPUSH
18495: CALL_OW 1
18499: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18500: LD_ADDR_EXP 56
18504: PUSH
18505: LD_EXP 56
18509: PPUSH
18510: LD_VAR 0 4
18514: PPUSH
18515: EMPTY
18516: PPUSH
18517: CALL_OW 1
18521: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18522: LD_ADDR_EXP 57
18526: PUSH
18527: LD_EXP 57
18531: PPUSH
18532: LD_VAR 0 4
18536: PPUSH
18537: EMPTY
18538: PPUSH
18539: CALL_OW 1
18543: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18544: LD_ADDR_EXP 58
18548: PUSH
18549: LD_EXP 58
18553: PPUSH
18554: LD_VAR 0 4
18558: PPUSH
18559: EMPTY
18560: PPUSH
18561: CALL_OW 1
18565: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18566: LD_ADDR_EXP 59
18570: PUSH
18571: LD_EXP 59
18575: PPUSH
18576: LD_VAR 0 4
18580: PPUSH
18581: EMPTY
18582: PPUSH
18583: CALL_OW 1
18587: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18588: LD_ADDR_EXP 60
18592: PUSH
18593: LD_EXP 60
18597: PPUSH
18598: LD_VAR 0 4
18602: PPUSH
18603: EMPTY
18604: PPUSH
18605: CALL_OW 1
18609: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18610: LD_ADDR_EXP 61
18614: PUSH
18615: LD_EXP 61
18619: PPUSH
18620: LD_VAR 0 4
18624: PPUSH
18625: LD_INT 0
18627: PPUSH
18628: CALL_OW 1
18632: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18633: LD_ADDR_EXP 62
18637: PUSH
18638: LD_EXP 62
18642: PPUSH
18643: LD_VAR 0 4
18647: PPUSH
18648: EMPTY
18649: PPUSH
18650: CALL_OW 1
18654: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18655: LD_ADDR_EXP 63
18659: PUSH
18660: LD_EXP 63
18664: PPUSH
18665: LD_VAR 0 4
18669: PPUSH
18670: EMPTY
18671: PPUSH
18672: CALL_OW 1
18676: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18677: LD_ADDR_EXP 64
18681: PUSH
18682: LD_EXP 64
18686: PPUSH
18687: LD_VAR 0 4
18691: PPUSH
18692: EMPTY
18693: PPUSH
18694: CALL_OW 1
18698: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18699: LD_ADDR_EXP 65
18703: PUSH
18704: LD_EXP 65
18708: PPUSH
18709: LD_VAR 0 4
18713: PPUSH
18714: EMPTY
18715: PPUSH
18716: CALL_OW 1
18720: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18721: LD_ADDR_EXP 66
18725: PUSH
18726: LD_EXP 66
18730: PPUSH
18731: LD_VAR 0 4
18735: PPUSH
18736: EMPTY
18737: PPUSH
18738: CALL_OW 1
18742: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18743: LD_ADDR_EXP 67
18747: PUSH
18748: LD_EXP 67
18752: PPUSH
18753: LD_VAR 0 4
18757: PPUSH
18758: EMPTY
18759: PPUSH
18760: CALL_OW 1
18764: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18765: LD_ADDR_EXP 68
18769: PUSH
18770: LD_EXP 68
18774: PPUSH
18775: LD_VAR 0 4
18779: PPUSH
18780: EMPTY
18781: PPUSH
18782: CALL_OW 1
18786: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18787: LD_ADDR_EXP 69
18791: PUSH
18792: LD_EXP 69
18796: PPUSH
18797: LD_VAR 0 4
18801: PPUSH
18802: EMPTY
18803: PPUSH
18804: CALL_OW 1
18808: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18809: LD_ADDR_EXP 70
18813: PUSH
18814: LD_EXP 70
18818: PPUSH
18819: LD_VAR 0 4
18823: PPUSH
18824: EMPTY
18825: PPUSH
18826: CALL_OW 1
18830: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18831: LD_ADDR_EXP 71
18835: PUSH
18836: LD_EXP 71
18840: PPUSH
18841: LD_VAR 0 4
18845: PPUSH
18846: EMPTY
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18853: LD_ADDR_EXP 72
18857: PUSH
18858: LD_EXP 72
18862: PPUSH
18863: LD_VAR 0 4
18867: PPUSH
18868: EMPTY
18869: PPUSH
18870: CALL_OW 1
18874: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18875: LD_ADDR_EXP 73
18879: PUSH
18880: LD_EXP 73
18884: PPUSH
18885: LD_VAR 0 4
18889: PPUSH
18890: EMPTY
18891: PPUSH
18892: CALL_OW 1
18896: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18897: LD_ADDR_EXP 74
18901: PUSH
18902: LD_EXP 74
18906: PPUSH
18907: LD_VAR 0 4
18911: PPUSH
18912: EMPTY
18913: PPUSH
18914: CALL_OW 1
18918: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18919: LD_ADDR_EXP 75
18923: PUSH
18924: LD_EXP 75
18928: PPUSH
18929: LD_VAR 0 4
18933: PPUSH
18934: EMPTY
18935: PPUSH
18936: CALL_OW 1
18940: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18941: LD_ADDR_EXP 77
18945: PUSH
18946: LD_EXP 77
18950: PPUSH
18951: LD_VAR 0 4
18955: PPUSH
18956: EMPTY
18957: PPUSH
18958: CALL_OW 1
18962: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18963: LD_ADDR_EXP 79
18967: PUSH
18968: LD_EXP 79
18972: PPUSH
18973: LD_VAR 0 4
18977: PPUSH
18978: EMPTY
18979: PPUSH
18980: CALL_OW 1
18984: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18985: LD_ADDR_EXP 80
18989: PUSH
18990: LD_EXP 80
18994: PPUSH
18995: LD_VAR 0 4
18999: PPUSH
19000: EMPTY
19001: PPUSH
19002: CALL_OW 1
19006: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19007: LD_ADDR_EXP 81
19011: PUSH
19012: LD_EXP 81
19016: PPUSH
19017: LD_VAR 0 4
19021: PPUSH
19022: EMPTY
19023: PPUSH
19024: CALL_OW 1
19028: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19029: LD_ADDR_EXP 82
19033: PUSH
19034: LD_EXP 82
19038: PPUSH
19039: LD_VAR 0 4
19043: PPUSH
19044: EMPTY
19045: PPUSH
19046: CALL_OW 1
19050: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19051: LD_ADDR_EXP 83
19055: PUSH
19056: LD_EXP 83
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: EMPTY
19067: PPUSH
19068: CALL_OW 1
19072: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19073: LD_ADDR_EXP 84
19077: PUSH
19078: LD_EXP 84
19082: PPUSH
19083: LD_VAR 0 4
19087: PPUSH
19088: EMPTY
19089: PPUSH
19090: CALL_OW 1
19094: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19095: LD_ADDR_EXP 85
19099: PUSH
19100: LD_EXP 85
19104: PPUSH
19105: LD_VAR 0 4
19109: PPUSH
19110: EMPTY
19111: PPUSH
19112: CALL_OW 1
19116: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19117: LD_ADDR_EXP 86
19121: PUSH
19122: LD_EXP 86
19126: PPUSH
19127: LD_VAR 0 4
19131: PPUSH
19132: EMPTY
19133: PPUSH
19134: CALL_OW 1
19138: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19139: LD_ADDR_EXP 87
19143: PUSH
19144: LD_EXP 87
19148: PPUSH
19149: LD_VAR 0 4
19153: PPUSH
19154: EMPTY
19155: PPUSH
19156: CALL_OW 1
19160: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19161: LD_ADDR_EXP 88
19165: PUSH
19166: LD_EXP 88
19170: PPUSH
19171: LD_VAR 0 4
19175: PPUSH
19176: EMPTY
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19183: LD_ADDR_EXP 89
19187: PUSH
19188: LD_EXP 89
19192: PPUSH
19193: LD_VAR 0 4
19197: PPUSH
19198: EMPTY
19199: PPUSH
19200: CALL_OW 1
19204: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19205: LD_ADDR_EXP 90
19209: PUSH
19210: LD_EXP 90
19214: PPUSH
19215: LD_VAR 0 4
19219: PPUSH
19220: EMPTY
19221: PPUSH
19222: CALL_OW 1
19226: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19227: LD_ADDR_EXP 91
19231: PUSH
19232: LD_EXP 91
19236: PPUSH
19237: LD_VAR 0 4
19241: PPUSH
19242: EMPTY
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19249: LD_ADDR_EXP 92
19253: PUSH
19254: LD_EXP 92
19258: PPUSH
19259: LD_VAR 0 4
19263: PPUSH
19264: LD_INT 0
19266: PPUSH
19267: CALL_OW 1
19271: ST_TO_ADDR
// result := base ;
19272: LD_ADDR_VAR 0 3
19276: PUSH
19277: LD_VAR 0 4
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 3
19286: RET
// export function MC_Start ( ) ; var i ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
// for i = 1 to mc_bases do
19291: LD_ADDR_VAR 0 2
19295: PUSH
19296: DOUBLE
19297: LD_INT 1
19299: DEC
19300: ST_TO_ADDR
19301: LD_EXP 50
19305: PUSH
19306: FOR_TO
19307: IFFALSE 20384
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19309: LD_ADDR_EXP 50
19313: PUSH
19314: LD_EXP 50
19318: PPUSH
19319: LD_VAR 0 2
19323: PPUSH
19324: LD_EXP 50
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PUSH
19335: LD_INT 0
19337: DIFF
19338: PPUSH
19339: CALL_OW 1
19343: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19344: LD_ADDR_EXP 51
19348: PUSH
19349: LD_EXP 51
19353: PPUSH
19354: LD_VAR 0 2
19358: PPUSH
19359: EMPTY
19360: PPUSH
19361: CALL_OW 1
19365: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19366: LD_ADDR_EXP 52
19370: PUSH
19371: LD_EXP 52
19375: PPUSH
19376: LD_VAR 0 2
19380: PPUSH
19381: EMPTY
19382: PPUSH
19383: CALL_OW 1
19387: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
19388: LD_ADDR_EXP 53
19392: PUSH
19393: LD_EXP 53
19397: PPUSH
19398: LD_VAR 0 2
19402: PPUSH
19403: EMPTY
19404: PPUSH
19405: CALL_OW 1
19409: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
19410: LD_ADDR_EXP 54
19414: PUSH
19415: LD_EXP 54
19419: PPUSH
19420: LD_VAR 0 2
19424: PPUSH
19425: EMPTY
19426: PUSH
19427: EMPTY
19428: PUSH
19429: EMPTY
19430: LIST
19431: LIST
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
19438: LD_ADDR_EXP 55
19442: PUSH
19443: LD_EXP 55
19447: PPUSH
19448: LD_VAR 0 2
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
19460: LD_ADDR_EXP 82
19464: PUSH
19465: LD_EXP 82
19469: PPUSH
19470: LD_VAR 0 2
19474: PPUSH
19475: EMPTY
19476: PPUSH
19477: CALL_OW 1
19481: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
19482: LD_ADDR_EXP 56
19486: PUSH
19487: LD_EXP 56
19491: PPUSH
19492: LD_VAR 0 2
19496: PPUSH
19497: EMPTY
19498: PPUSH
19499: CALL_OW 1
19503: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
19504: LD_ADDR_EXP 57
19508: PUSH
19509: LD_EXP 57
19513: PPUSH
19514: LD_VAR 0 2
19518: PPUSH
19519: EMPTY
19520: PPUSH
19521: CALL_OW 1
19525: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
19526: LD_ADDR_EXP 58
19530: PUSH
19531: LD_EXP 58
19535: PPUSH
19536: LD_VAR 0 2
19540: PPUSH
19541: LD_EXP 50
19545: PUSH
19546: LD_VAR 0 2
19550: ARRAY
19551: PPUSH
19552: LD_INT 2
19554: PUSH
19555: LD_INT 30
19557: PUSH
19558: LD_INT 32
19560: PUSH
19561: EMPTY
19562: LIST
19563: LIST
19564: PUSH
19565: LD_INT 30
19567: PUSH
19568: LD_INT 33
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: PUSH
19575: EMPTY
19576: LIST
19577: LIST
19578: LIST
19579: PPUSH
19580: CALL_OW 72
19584: PPUSH
19585: CALL_OW 1
19589: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
19590: LD_ADDR_EXP 59
19594: PUSH
19595: LD_EXP 59
19599: PPUSH
19600: LD_VAR 0 2
19604: PPUSH
19605: LD_EXP 50
19609: PUSH
19610: LD_VAR 0 2
19614: ARRAY
19615: PPUSH
19616: LD_INT 2
19618: PUSH
19619: LD_INT 30
19621: PUSH
19622: LD_INT 32
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: PUSH
19629: LD_INT 30
19631: PUSH
19632: LD_INT 31
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: PUSH
19639: EMPTY
19640: LIST
19641: LIST
19642: LIST
19643: PUSH
19644: LD_INT 58
19646: PUSH
19647: EMPTY
19648: LIST
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: PPUSH
19654: CALL_OW 72
19658: PPUSH
19659: CALL_OW 1
19663: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
19664: LD_ADDR_EXP 60
19668: PUSH
19669: LD_EXP 60
19673: PPUSH
19674: LD_VAR 0 2
19678: PPUSH
19679: EMPTY
19680: PPUSH
19681: CALL_OW 1
19685: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
19686: LD_ADDR_EXP 64
19690: PUSH
19691: LD_EXP 64
19695: PPUSH
19696: LD_VAR 0 2
19700: PPUSH
19701: EMPTY
19702: PPUSH
19703: CALL_OW 1
19707: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
19708: LD_ADDR_EXP 63
19712: PUSH
19713: LD_EXP 63
19717: PPUSH
19718: LD_VAR 0 2
19722: PPUSH
19723: EMPTY
19724: PPUSH
19725: CALL_OW 1
19729: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
19730: LD_ADDR_EXP 65
19734: PUSH
19735: LD_EXP 65
19739: PPUSH
19740: LD_VAR 0 2
19744: PPUSH
19745: EMPTY
19746: PPUSH
19747: CALL_OW 1
19751: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
19752: LD_ADDR_EXP 66
19756: PUSH
19757: LD_EXP 66
19761: PPUSH
19762: LD_VAR 0 2
19766: PPUSH
19767: EMPTY
19768: PPUSH
19769: CALL_OW 1
19773: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
19774: LD_ADDR_EXP 67
19778: PUSH
19779: LD_EXP 67
19783: PPUSH
19784: LD_VAR 0 2
19788: PPUSH
19789: EMPTY
19790: PPUSH
19791: CALL_OW 1
19795: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
19796: LD_ADDR_EXP 68
19800: PUSH
19801: LD_EXP 68
19805: PPUSH
19806: LD_VAR 0 2
19810: PPUSH
19811: EMPTY
19812: PPUSH
19813: CALL_OW 1
19817: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
19818: LD_ADDR_EXP 69
19822: PUSH
19823: LD_EXP 69
19827: PPUSH
19828: LD_VAR 0 2
19832: PPUSH
19833: EMPTY
19834: PPUSH
19835: CALL_OW 1
19839: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
19840: LD_ADDR_EXP 70
19844: PUSH
19845: LD_EXP 70
19849: PPUSH
19850: LD_VAR 0 2
19854: PPUSH
19855: EMPTY
19856: PPUSH
19857: CALL_OW 1
19861: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
19862: LD_ADDR_EXP 71
19866: PUSH
19867: LD_EXP 71
19871: PPUSH
19872: LD_VAR 0 2
19876: PPUSH
19877: EMPTY
19878: PPUSH
19879: CALL_OW 1
19883: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
19884: LD_ADDR_EXP 72
19888: PUSH
19889: LD_EXP 72
19893: PPUSH
19894: LD_VAR 0 2
19898: PPUSH
19899: EMPTY
19900: PPUSH
19901: CALL_OW 1
19905: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
19906: LD_ADDR_EXP 61
19910: PUSH
19911: LD_EXP 61
19915: PPUSH
19916: LD_VAR 0 2
19920: PPUSH
19921: LD_INT 0
19923: PPUSH
19924: CALL_OW 1
19928: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
19929: LD_ADDR_EXP 74
19933: PUSH
19934: LD_EXP 74
19938: PPUSH
19939: LD_VAR 0 2
19943: PPUSH
19944: LD_INT 0
19946: PPUSH
19947: CALL_OW 1
19951: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
19952: LD_ADDR_EXP 62
19956: PUSH
19957: LD_EXP 62
19961: PPUSH
19962: LD_VAR 0 2
19966: PPUSH
19967: EMPTY
19968: PPUSH
19969: CALL_OW 1
19973: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
19974: LD_ADDR_EXP 73
19978: PUSH
19979: LD_EXP 73
19983: PPUSH
19984: LD_VAR 0 2
19988: PPUSH
19989: LD_INT 0
19991: PPUSH
19992: CALL_OW 1
19996: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
19997: LD_ADDR_EXP 75
20001: PUSH
20002: LD_EXP 75
20006: PPUSH
20007: LD_VAR 0 2
20011: PPUSH
20012: EMPTY
20013: PPUSH
20014: CALL_OW 1
20018: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20019: LD_ADDR_EXP 78
20023: PUSH
20024: LD_EXP 78
20028: PPUSH
20029: LD_VAR 0 2
20033: PPUSH
20034: LD_INT 0
20036: PPUSH
20037: CALL_OW 1
20041: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20042: LD_ADDR_EXP 79
20046: PUSH
20047: LD_EXP 79
20051: PPUSH
20052: LD_VAR 0 2
20056: PPUSH
20057: EMPTY
20058: PPUSH
20059: CALL_OW 1
20063: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20064: LD_ADDR_EXP 80
20068: PUSH
20069: LD_EXP 80
20073: PPUSH
20074: LD_VAR 0 2
20078: PPUSH
20079: EMPTY
20080: PPUSH
20081: CALL_OW 1
20085: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20086: LD_ADDR_EXP 81
20090: PUSH
20091: LD_EXP 81
20095: PPUSH
20096: LD_VAR 0 2
20100: PPUSH
20101: EMPTY
20102: PPUSH
20103: CALL_OW 1
20107: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20108: LD_ADDR_EXP 83
20112: PUSH
20113: LD_EXP 83
20117: PPUSH
20118: LD_VAR 0 2
20122: PPUSH
20123: LD_EXP 50
20127: PUSH
20128: LD_VAR 0 2
20132: ARRAY
20133: PPUSH
20134: LD_INT 2
20136: PUSH
20137: LD_INT 30
20139: PUSH
20140: LD_INT 6
20142: PUSH
20143: EMPTY
20144: LIST
20145: LIST
20146: PUSH
20147: LD_INT 30
20149: PUSH
20150: LD_INT 7
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 30
20159: PUSH
20160: LD_INT 8
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: EMPTY
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: PPUSH
20173: CALL_OW 72
20177: PPUSH
20178: CALL_OW 1
20182: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20183: LD_ADDR_EXP 84
20187: PUSH
20188: LD_EXP 84
20192: PPUSH
20193: LD_VAR 0 2
20197: PPUSH
20198: EMPTY
20199: PPUSH
20200: CALL_OW 1
20204: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20205: LD_ADDR_EXP 85
20209: PUSH
20210: LD_EXP 85
20214: PPUSH
20215: LD_VAR 0 2
20219: PPUSH
20220: EMPTY
20221: PPUSH
20222: CALL_OW 1
20226: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20227: LD_ADDR_EXP 86
20231: PUSH
20232: LD_EXP 86
20236: PPUSH
20237: LD_VAR 0 2
20241: PPUSH
20242: EMPTY
20243: PPUSH
20244: CALL_OW 1
20248: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20249: LD_ADDR_EXP 87
20253: PUSH
20254: LD_EXP 87
20258: PPUSH
20259: LD_VAR 0 2
20263: PPUSH
20264: EMPTY
20265: PPUSH
20266: CALL_OW 1
20270: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20271: LD_ADDR_EXP 88
20275: PUSH
20276: LD_EXP 88
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: EMPTY
20287: PPUSH
20288: CALL_OW 1
20292: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20293: LD_ADDR_EXP 89
20297: PUSH
20298: LD_EXP 89
20302: PPUSH
20303: LD_VAR 0 2
20307: PPUSH
20308: EMPTY
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20315: LD_ADDR_EXP 90
20319: PUSH
20320: LD_EXP 90
20324: PPUSH
20325: LD_VAR 0 2
20329: PPUSH
20330: EMPTY
20331: PPUSH
20332: CALL_OW 1
20336: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20337: LD_ADDR_EXP 91
20341: PUSH
20342: LD_EXP 91
20346: PPUSH
20347: LD_VAR 0 2
20351: PPUSH
20352: EMPTY
20353: PPUSH
20354: CALL_OW 1
20358: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20359: LD_ADDR_EXP 92
20363: PUSH
20364: LD_EXP 92
20368: PPUSH
20369: LD_VAR 0 2
20373: PPUSH
20374: LD_INT 0
20376: PPUSH
20377: CALL_OW 1
20381: ST_TO_ADDR
// end ;
20382: GO 19306
20384: POP
20385: POP
// MC_InitSides ( ) ;
20386: CALL 20672 0 0
// MC_InitResearch ( ) ;
20390: CALL 20411 0 0
// CustomInitMacro ( ) ;
20394: CALL 300 0 0
// skirmish := true ;
20398: LD_ADDR_EXP 48
20402: PUSH
20403: LD_INT 1
20405: ST_TO_ADDR
// end ;
20406: LD_VAR 0 1
20410: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
20411: LD_INT 0
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
// if not mc_bases then
20419: LD_EXP 50
20423: NOT
20424: IFFALSE 20428
// exit ;
20426: GO 20667
// for i = 1 to 8 do
20428: LD_ADDR_VAR 0 2
20432: PUSH
20433: DOUBLE
20434: LD_INT 1
20436: DEC
20437: ST_TO_ADDR
20438: LD_INT 8
20440: PUSH
20441: FOR_TO
20442: IFFALSE 20468
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
20444: LD_ADDR_EXP 77
20448: PUSH
20449: LD_EXP 77
20453: PPUSH
20454: LD_VAR 0 2
20458: PPUSH
20459: EMPTY
20460: PPUSH
20461: CALL_OW 1
20465: ST_TO_ADDR
20466: GO 20441
20468: POP
20469: POP
// tmp := [ ] ;
20470: LD_ADDR_VAR 0 5
20474: PUSH
20475: EMPTY
20476: ST_TO_ADDR
// for i = 1 to mc_sides do
20477: LD_ADDR_VAR 0 2
20481: PUSH
20482: DOUBLE
20483: LD_INT 1
20485: DEC
20486: ST_TO_ADDR
20487: LD_EXP 76
20491: PUSH
20492: FOR_TO
20493: IFFALSE 20551
// if not mc_sides [ i ] in tmp then
20495: LD_EXP 76
20499: PUSH
20500: LD_VAR 0 2
20504: ARRAY
20505: PUSH
20506: LD_VAR 0 5
20510: IN
20511: NOT
20512: IFFALSE 20549
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
20514: LD_ADDR_VAR 0 5
20518: PUSH
20519: LD_VAR 0 5
20523: PPUSH
20524: LD_VAR 0 5
20528: PUSH
20529: LD_INT 1
20531: PLUS
20532: PPUSH
20533: LD_EXP 76
20537: PUSH
20538: LD_VAR 0 2
20542: ARRAY
20543: PPUSH
20544: CALL_OW 2
20548: ST_TO_ADDR
20549: GO 20492
20551: POP
20552: POP
// if not tmp then
20553: LD_VAR 0 5
20557: NOT
20558: IFFALSE 20562
// exit ;
20560: GO 20667
// for j in tmp do
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_VAR 0 5
20571: PUSH
20572: FOR_IN
20573: IFFALSE 20665
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
20575: LD_ADDR_VAR 0 6
20579: PUSH
20580: LD_INT 22
20582: PUSH
20583: LD_VAR 0 3
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: PPUSH
20592: CALL_OW 69
20596: ST_TO_ADDR
// if not un then
20597: LD_VAR 0 6
20601: NOT
20602: IFFALSE 20606
// continue ;
20604: GO 20572
// nation := GetNation ( un [ 1 ] ) ;
20606: LD_ADDR_VAR 0 4
20610: PUSH
20611: LD_VAR 0 6
20615: PUSH
20616: LD_INT 1
20618: ARRAY
20619: PPUSH
20620: CALL_OW 248
20624: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
20625: LD_ADDR_EXP 77
20629: PUSH
20630: LD_EXP 77
20634: PPUSH
20635: LD_VAR 0 3
20639: PPUSH
20640: LD_VAR 0 3
20644: PPUSH
20645: LD_VAR 0 4
20649: PPUSH
20650: LD_INT 1
20652: PPUSH
20653: CALL 47381 0 3
20657: PPUSH
20658: CALL_OW 1
20662: ST_TO_ADDR
// end ;
20663: GO 20572
20665: POP
20666: POP
// end ;
20667: LD_VAR 0 1
20671: RET
// export function MC_InitSides ( ) ; var i ; begin
20672: LD_INT 0
20674: PPUSH
20675: PPUSH
// if not mc_bases then
20676: LD_EXP 50
20680: NOT
20681: IFFALSE 20685
// exit ;
20683: GO 20759
// for i = 1 to mc_bases do
20685: LD_ADDR_VAR 0 2
20689: PUSH
20690: DOUBLE
20691: LD_INT 1
20693: DEC
20694: ST_TO_ADDR
20695: LD_EXP 50
20699: PUSH
20700: FOR_TO
20701: IFFALSE 20757
// if mc_bases [ i ] then
20703: LD_EXP 50
20707: PUSH
20708: LD_VAR 0 2
20712: ARRAY
20713: IFFALSE 20755
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
20715: LD_ADDR_EXP 76
20719: PUSH
20720: LD_EXP 76
20724: PPUSH
20725: LD_VAR 0 2
20729: PPUSH
20730: LD_EXP 50
20734: PUSH
20735: LD_VAR 0 2
20739: ARRAY
20740: PUSH
20741: LD_INT 1
20743: ARRAY
20744: PPUSH
20745: CALL_OW 255
20749: PPUSH
20750: CALL_OW 1
20754: ST_TO_ADDR
20755: GO 20700
20757: POP
20758: POP
// end ;
20759: LD_VAR 0 1
20763: RET
// every 0 0$01 trigger skirmish do
20764: LD_EXP 48
20768: IFFALSE 20922
20770: GO 20772
20772: DISABLE
// begin enable ;
20773: ENABLE
// MC_CheckBuildings ( ) ;
20774: CALL 25420 0 0
// MC_CheckPeopleLife ( ) ;
20778: CALL 25545 0 0
// RaiseSailEvent ( 100 ) ;
20782: LD_INT 100
20784: PPUSH
20785: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
20789: LD_INT 103
20791: PPUSH
20792: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
20796: LD_INT 104
20798: PPUSH
20799: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
20803: LD_INT 105
20805: PPUSH
20806: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
20810: LD_INT 106
20812: PPUSH
20813: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
20817: LD_INT 107
20819: PPUSH
20820: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
20824: LD_INT 108
20826: PPUSH
20827: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
20831: LD_INT 109
20833: PPUSH
20834: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
20838: LD_INT 110
20840: PPUSH
20841: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
20845: LD_INT 111
20847: PPUSH
20848: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
20852: LD_INT 112
20854: PPUSH
20855: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
20859: LD_INT 113
20861: PPUSH
20862: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
20866: LD_INT 120
20868: PPUSH
20869: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
20873: LD_INT 121
20875: PPUSH
20876: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
20880: LD_INT 122
20882: PPUSH
20883: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
20887: LD_INT 123
20889: PPUSH
20890: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
20894: LD_INT 124
20896: PPUSH
20897: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
20901: LD_INT 125
20903: PPUSH
20904: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
20908: LD_INT 126
20910: PPUSH
20911: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
20915: LD_INT 200
20917: PPUSH
20918: CALL_OW 427
// end ;
20922: END
// on SailEvent ( event ) do begin if event < 100 then
20923: LD_VAR 0 1
20927: PUSH
20928: LD_INT 100
20930: LESS
20931: IFFALSE 20942
// CustomEvent ( event ) ;
20933: LD_VAR 0 1
20937: PPUSH
20938: CALL 16441 0 1
// if event = 100 then
20942: LD_VAR 0 1
20946: PUSH
20947: LD_INT 100
20949: EQUAL
20950: IFFALSE 20956
// MC_ClassManager ( ) ;
20952: CALL 21348 0 0
// if event = 101 then
20956: LD_VAR 0 1
20960: PUSH
20961: LD_INT 101
20963: EQUAL
20964: IFFALSE 20970
// MC_RepairBuildings ( ) ;
20966: CALL 26141 0 0
// if event = 102 then
20970: LD_VAR 0 1
20974: PUSH
20975: LD_INT 102
20977: EQUAL
20978: IFFALSE 20984
// MC_Heal ( ) ;
20980: CALL 26873 0 0
// if event = 103 then
20984: LD_VAR 0 1
20988: PUSH
20989: LD_INT 103
20991: EQUAL
20992: IFFALSE 20998
// MC_Build ( ) ;
20994: CALL 27295 0 0
// if event = 104 then
20998: LD_VAR 0 1
21002: PUSH
21003: LD_INT 104
21005: EQUAL
21006: IFFALSE 21012
// MC_TurretWeapon ( ) ;
21008: CALL 28908 0 0
// if event = 105 then
21012: LD_VAR 0 1
21016: PUSH
21017: LD_INT 105
21019: EQUAL
21020: IFFALSE 21026
// MC_BuildUpgrade ( ) ;
21022: CALL 28459 0 0
// if event = 106 then
21026: LD_VAR 0 1
21030: PUSH
21031: LD_INT 106
21033: EQUAL
21034: IFFALSE 21040
// MC_PlantMines ( ) ;
21036: CALL 29338 0 0
// if event = 107 then
21040: LD_VAR 0 1
21044: PUSH
21045: LD_INT 107
21047: EQUAL
21048: IFFALSE 21054
// MC_CollectCrates ( ) ;
21050: CALL 30372 0 0
// if event = 108 then
21054: LD_VAR 0 1
21058: PUSH
21059: LD_INT 108
21061: EQUAL
21062: IFFALSE 21068
// MC_LinkRemoteControl ( ) ;
21064: CALL 32148 0 0
// if event = 109 then
21068: LD_VAR 0 1
21072: PUSH
21073: LD_INT 109
21075: EQUAL
21076: IFFALSE 21082
// MC_ProduceVehicle ( ) ;
21078: CALL 32329 0 0
// if event = 110 then
21082: LD_VAR 0 1
21086: PUSH
21087: LD_INT 110
21089: EQUAL
21090: IFFALSE 21096
// MC_SendAttack ( ) ;
21092: CALL 32795 0 0
// if event = 111 then
21096: LD_VAR 0 1
21100: PUSH
21101: LD_INT 111
21103: EQUAL
21104: IFFALSE 21110
// MC_Defend ( ) ;
21106: CALL 32903 0 0
// if event = 112 then
21110: LD_VAR 0 1
21114: PUSH
21115: LD_INT 112
21117: EQUAL
21118: IFFALSE 21124
// MC_Research ( ) ;
21120: CALL 33508 0 0
// if event = 113 then
21124: LD_VAR 0 1
21128: PUSH
21129: LD_INT 113
21131: EQUAL
21132: IFFALSE 21138
// MC_MinesTrigger ( ) ;
21134: CALL 34622 0 0
// if event = 120 then
21138: LD_VAR 0 1
21142: PUSH
21143: LD_INT 120
21145: EQUAL
21146: IFFALSE 21152
// MC_RepairVehicle ( ) ;
21148: CALL 34721 0 0
// if event = 121 then
21152: LD_VAR 0 1
21156: PUSH
21157: LD_INT 121
21159: EQUAL
21160: IFFALSE 21166
// MC_TameApe ( ) ;
21162: CALL 35451 0 0
// if event = 122 then
21166: LD_VAR 0 1
21170: PUSH
21171: LD_INT 122
21173: EQUAL
21174: IFFALSE 21180
// MC_ChangeApeClass ( ) ;
21176: CALL 36280 0 0
// if event = 123 then
21180: LD_VAR 0 1
21184: PUSH
21185: LD_INT 123
21187: EQUAL
21188: IFFALSE 21194
// MC_Bazooka ( ) ;
21190: CALL 36930 0 0
// if event = 124 then
21194: LD_VAR 0 1
21198: PUSH
21199: LD_INT 124
21201: EQUAL
21202: IFFALSE 21208
// MC_TeleportExit ( ) ;
21204: CALL 37128 0 0
// if event = 125 then
21208: LD_VAR 0 1
21212: PUSH
21213: LD_INT 125
21215: EQUAL
21216: IFFALSE 21222
// MC_Deposits ( ) ;
21218: CALL 37775 0 0
// if event = 126 then
21222: LD_VAR 0 1
21226: PUSH
21227: LD_INT 126
21229: EQUAL
21230: IFFALSE 21236
// MC_RemoteDriver ( ) ;
21232: CALL 38400 0 0
// if event = 200 then
21236: LD_VAR 0 1
21240: PUSH
21241: LD_INT 200
21243: EQUAL
21244: IFFALSE 21250
// MC_Idle ( ) ;
21246: CALL 40349 0 0
// end ;
21250: PPOPN 1
21252: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21253: LD_INT 0
21255: PPUSH
21256: PPUSH
// if not mc_bases [ base ] or not tag then
21257: LD_EXP 50
21261: PUSH
21262: LD_VAR 0 1
21266: ARRAY
21267: NOT
21268: PUSH
21269: LD_VAR 0 2
21273: NOT
21274: OR
21275: IFFALSE 21279
// exit ;
21277: GO 21343
// for i in mc_bases [ base ] union mc_ape [ base ] do
21279: LD_ADDR_VAR 0 4
21283: PUSH
21284: LD_EXP 50
21288: PUSH
21289: LD_VAR 0 1
21293: ARRAY
21294: PUSH
21295: LD_EXP 79
21299: PUSH
21300: LD_VAR 0 1
21304: ARRAY
21305: UNION
21306: PUSH
21307: FOR_IN
21308: IFFALSE 21341
// if GetTag ( i ) = tag then
21310: LD_VAR 0 4
21314: PPUSH
21315: CALL_OW 110
21319: PUSH
21320: LD_VAR 0 2
21324: EQUAL
21325: IFFALSE 21339
// SetTag ( i , 0 ) ;
21327: LD_VAR 0 4
21331: PPUSH
21332: LD_INT 0
21334: PPUSH
21335: CALL_OW 109
21339: GO 21307
21341: POP
21342: POP
// end ;
21343: LD_VAR 0 3
21347: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21348: LD_INT 0
21350: PPUSH
21351: PPUSH
21352: PPUSH
21353: PPUSH
21354: PPUSH
21355: PPUSH
21356: PPUSH
21357: PPUSH
// if not mc_bases then
21358: LD_EXP 50
21362: NOT
21363: IFFALSE 21367
// exit ;
21365: GO 21825
// for i = 1 to mc_bases do
21367: LD_ADDR_VAR 0 2
21371: PUSH
21372: DOUBLE
21373: LD_INT 1
21375: DEC
21376: ST_TO_ADDR
21377: LD_EXP 50
21381: PUSH
21382: FOR_TO
21383: IFFALSE 21823
// begin tmp := MC_ClassCheckReq ( i ) ;
21385: LD_ADDR_VAR 0 4
21389: PUSH
21390: LD_VAR 0 2
21394: PPUSH
21395: CALL 21830 0 1
21399: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
21400: LD_ADDR_EXP 91
21404: PUSH
21405: LD_EXP 91
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: LD_VAR 0 4
21419: PPUSH
21420: CALL_OW 1
21424: ST_TO_ADDR
// if not tmp then
21425: LD_VAR 0 4
21429: NOT
21430: IFFALSE 21434
// continue ;
21432: GO 21382
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
21434: LD_ADDR_VAR 0 6
21438: PUSH
21439: LD_EXP 50
21443: PUSH
21444: LD_VAR 0 2
21448: ARRAY
21449: PPUSH
21450: LD_INT 2
21452: PUSH
21453: LD_INT 30
21455: PUSH
21456: LD_INT 4
21458: PUSH
21459: EMPTY
21460: LIST
21461: LIST
21462: PUSH
21463: LD_INT 30
21465: PUSH
21466: LD_INT 5
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: LIST
21477: PPUSH
21478: CALL_OW 72
21482: PUSH
21483: LD_EXP 50
21487: PUSH
21488: LD_VAR 0 2
21492: ARRAY
21493: PPUSH
21494: LD_INT 2
21496: PUSH
21497: LD_INT 30
21499: PUSH
21500: LD_INT 0
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 1
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: LIST
21521: PPUSH
21522: CALL_OW 72
21526: PUSH
21527: LD_EXP 50
21531: PUSH
21532: LD_VAR 0 2
21536: ARRAY
21537: PPUSH
21538: LD_INT 30
21540: PUSH
21541: LD_INT 3
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: PPUSH
21548: CALL_OW 72
21552: PUSH
21553: LD_EXP 50
21557: PUSH
21558: LD_VAR 0 2
21562: ARRAY
21563: PPUSH
21564: LD_INT 2
21566: PUSH
21567: LD_INT 30
21569: PUSH
21570: LD_INT 6
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 30
21579: PUSH
21580: LD_INT 7
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 30
21589: PUSH
21590: LD_INT 8
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: LIST
21601: LIST
21602: PPUSH
21603: CALL_OW 72
21607: PUSH
21608: EMPTY
21609: LIST
21610: LIST
21611: LIST
21612: LIST
21613: ST_TO_ADDR
// for j = 1 to 4 do
21614: LD_ADDR_VAR 0 3
21618: PUSH
21619: DOUBLE
21620: LD_INT 1
21622: DEC
21623: ST_TO_ADDR
21624: LD_INT 4
21626: PUSH
21627: FOR_TO
21628: IFFALSE 21819
// begin if not tmp [ j ] then
21630: LD_VAR 0 4
21634: PUSH
21635: LD_VAR 0 3
21639: ARRAY
21640: NOT
21641: IFFALSE 21645
// continue ;
21643: GO 21627
// for p in tmp [ j ] do
21645: LD_ADDR_VAR 0 5
21649: PUSH
21650: LD_VAR 0 4
21654: PUSH
21655: LD_VAR 0 3
21659: ARRAY
21660: PUSH
21661: FOR_IN
21662: IFFALSE 21815
// begin if not b [ j ] then
21664: LD_VAR 0 6
21668: PUSH
21669: LD_VAR 0 3
21673: ARRAY
21674: NOT
21675: IFFALSE 21679
// break ;
21677: GO 21815
// e := 0 ;
21679: LD_ADDR_VAR 0 7
21683: PUSH
21684: LD_INT 0
21686: ST_TO_ADDR
// for k in b [ j ] do
21687: LD_ADDR_VAR 0 8
21691: PUSH
21692: LD_VAR 0 6
21696: PUSH
21697: LD_VAR 0 3
21701: ARRAY
21702: PUSH
21703: FOR_IN
21704: IFFALSE 21731
// if IsNotFull ( k ) then
21706: LD_VAR 0 8
21710: PPUSH
21711: CALL 51821 0 1
21715: IFFALSE 21729
// begin e := k ;
21717: LD_ADDR_VAR 0 7
21721: PUSH
21722: LD_VAR 0 8
21726: ST_TO_ADDR
// break ;
21727: GO 21731
// end ;
21729: GO 21703
21731: POP
21732: POP
// if e and not UnitGoingToBuilding ( p , e ) then
21733: LD_VAR 0 7
21737: PUSH
21738: LD_VAR 0 5
21742: PPUSH
21743: LD_VAR 0 7
21747: PPUSH
21748: CALL 88940 0 2
21752: NOT
21753: AND
21754: IFFALSE 21813
// begin if IsInUnit ( p ) then
21756: LD_VAR 0 5
21760: PPUSH
21761: CALL_OW 310
21765: IFFALSE 21776
// ComExitBuilding ( p ) ;
21767: LD_VAR 0 5
21771: PPUSH
21772: CALL_OW 122
// ComEnterUnit ( p , e ) ;
21776: LD_VAR 0 5
21780: PPUSH
21781: LD_VAR 0 7
21785: PPUSH
21786: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
21790: LD_VAR 0 5
21794: PPUSH
21795: LD_VAR 0 3
21799: PPUSH
21800: CALL_OW 183
// AddComExitBuilding ( p ) ;
21804: LD_VAR 0 5
21808: PPUSH
21809: CALL_OW 182
// end ; end ;
21813: GO 21661
21815: POP
21816: POP
// end ;
21817: GO 21627
21819: POP
21820: POP
// end ;
21821: GO 21382
21823: POP
21824: POP
// end ;
21825: LD_VAR 0 1
21829: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
21830: LD_INT 0
21832: PPUSH
21833: PPUSH
21834: PPUSH
21835: PPUSH
21836: PPUSH
21837: PPUSH
21838: PPUSH
21839: PPUSH
21840: PPUSH
21841: PPUSH
21842: PPUSH
21843: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
21844: LD_VAR 0 1
21848: NOT
21849: PUSH
21850: LD_EXP 50
21854: PUSH
21855: LD_VAR 0 1
21859: ARRAY
21860: NOT
21861: OR
21862: PUSH
21863: LD_EXP 50
21867: PUSH
21868: LD_VAR 0 1
21872: ARRAY
21873: PPUSH
21874: LD_INT 2
21876: PUSH
21877: LD_INT 30
21879: PUSH
21880: LD_INT 0
21882: PUSH
21883: EMPTY
21884: LIST
21885: LIST
21886: PUSH
21887: LD_INT 30
21889: PUSH
21890: LD_INT 1
21892: PUSH
21893: EMPTY
21894: LIST
21895: LIST
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: PPUSH
21902: CALL_OW 72
21906: NOT
21907: OR
21908: IFFALSE 21912
// exit ;
21910: GO 25415
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
21912: LD_ADDR_VAR 0 4
21916: PUSH
21917: LD_EXP 50
21921: PUSH
21922: LD_VAR 0 1
21926: ARRAY
21927: PPUSH
21928: LD_INT 2
21930: PUSH
21931: LD_INT 25
21933: PUSH
21934: LD_INT 1
21936: PUSH
21937: EMPTY
21938: LIST
21939: LIST
21940: PUSH
21941: LD_INT 25
21943: PUSH
21944: LD_INT 2
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: PUSH
21951: LD_INT 25
21953: PUSH
21954: LD_INT 3
21956: PUSH
21957: EMPTY
21958: LIST
21959: LIST
21960: PUSH
21961: LD_INT 25
21963: PUSH
21964: LD_INT 4
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: PUSH
21971: LD_INT 25
21973: PUSH
21974: LD_INT 5
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PUSH
21981: LD_INT 25
21983: PUSH
21984: LD_INT 8
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: PUSH
21991: LD_INT 25
21993: PUSH
21994: LD_INT 9
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: EMPTY
22002: LIST
22003: LIST
22004: LIST
22005: LIST
22006: LIST
22007: LIST
22008: LIST
22009: LIST
22010: PPUSH
22011: CALL_OW 72
22015: ST_TO_ADDR
// if not tmp then
22016: LD_VAR 0 4
22020: NOT
22021: IFFALSE 22025
// exit ;
22023: GO 25415
// for i in tmp do
22025: LD_ADDR_VAR 0 3
22029: PUSH
22030: LD_VAR 0 4
22034: PUSH
22035: FOR_IN
22036: IFFALSE 22067
// if GetTag ( i ) then
22038: LD_VAR 0 3
22042: PPUSH
22043: CALL_OW 110
22047: IFFALSE 22065
// tmp := tmp diff i ;
22049: LD_ADDR_VAR 0 4
22053: PUSH
22054: LD_VAR 0 4
22058: PUSH
22059: LD_VAR 0 3
22063: DIFF
22064: ST_TO_ADDR
22065: GO 22035
22067: POP
22068: POP
// if not tmp then
22069: LD_VAR 0 4
22073: NOT
22074: IFFALSE 22078
// exit ;
22076: GO 25415
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22078: LD_ADDR_VAR 0 5
22082: PUSH
22083: LD_EXP 50
22087: PUSH
22088: LD_VAR 0 1
22092: ARRAY
22093: PPUSH
22094: LD_INT 2
22096: PUSH
22097: LD_INT 25
22099: PUSH
22100: LD_INT 1
22102: PUSH
22103: EMPTY
22104: LIST
22105: LIST
22106: PUSH
22107: LD_INT 25
22109: PUSH
22110: LD_INT 5
22112: PUSH
22113: EMPTY
22114: LIST
22115: LIST
22116: PUSH
22117: LD_INT 25
22119: PUSH
22120: LD_INT 8
22122: PUSH
22123: EMPTY
22124: LIST
22125: LIST
22126: PUSH
22127: LD_INT 25
22129: PUSH
22130: LD_INT 9
22132: PUSH
22133: EMPTY
22134: LIST
22135: LIST
22136: PUSH
22137: EMPTY
22138: LIST
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL_OW 72
22148: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22149: LD_ADDR_VAR 0 6
22153: PUSH
22154: LD_EXP 50
22158: PUSH
22159: LD_VAR 0 1
22163: ARRAY
22164: PPUSH
22165: LD_INT 25
22167: PUSH
22168: LD_INT 2
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PPUSH
22175: CALL_OW 72
22179: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22180: LD_ADDR_VAR 0 7
22184: PUSH
22185: LD_EXP 50
22189: PUSH
22190: LD_VAR 0 1
22194: ARRAY
22195: PPUSH
22196: LD_INT 25
22198: PUSH
22199: LD_INT 3
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PPUSH
22206: CALL_OW 72
22210: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22211: LD_ADDR_VAR 0 8
22215: PUSH
22216: LD_EXP 50
22220: PUSH
22221: LD_VAR 0 1
22225: ARRAY
22226: PPUSH
22227: LD_INT 25
22229: PUSH
22230: LD_INT 4
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: PUSH
22237: LD_INT 24
22239: PUSH
22240: LD_INT 251
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PPUSH
22251: CALL_OW 72
22255: ST_TO_ADDR
// if mc_scan [ base ] then
22256: LD_EXP 73
22260: PUSH
22261: LD_VAR 0 1
22265: ARRAY
22266: IFFALSE 22727
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22268: LD_ADDR_EXP 92
22272: PUSH
22273: LD_EXP 92
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PPUSH
22286: CALL_OW 1
22290: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22291: LD_ADDR_VAR 0 12
22295: PUSH
22296: LD_EXP 50
22300: PUSH
22301: LD_VAR 0 1
22305: ARRAY
22306: PPUSH
22307: LD_INT 2
22309: PUSH
22310: LD_INT 30
22312: PUSH
22313: LD_INT 4
22315: PUSH
22316: EMPTY
22317: LIST
22318: LIST
22319: PUSH
22320: LD_INT 30
22322: PUSH
22323: LD_INT 5
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: LIST
22334: PPUSH
22335: CALL_OW 72
22339: ST_TO_ADDR
// if not b then
22340: LD_VAR 0 12
22344: NOT
22345: IFFALSE 22349
// exit ;
22347: GO 25415
// p := [ ] ;
22349: LD_ADDR_VAR 0 11
22353: PUSH
22354: EMPTY
22355: ST_TO_ADDR
// if sci >= 2 then
22356: LD_VAR 0 8
22360: PUSH
22361: LD_INT 2
22363: GREATEREQUAL
22364: IFFALSE 22395
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22366: LD_ADDR_VAR 0 8
22370: PUSH
22371: LD_VAR 0 8
22375: PUSH
22376: LD_INT 1
22378: ARRAY
22379: PUSH
22380: LD_VAR 0 8
22384: PUSH
22385: LD_INT 2
22387: ARRAY
22388: PUSH
22389: EMPTY
22390: LIST
22391: LIST
22392: ST_TO_ADDR
22393: GO 22456
// if sci = 1 then
22395: LD_VAR 0 8
22399: PUSH
22400: LD_INT 1
22402: EQUAL
22403: IFFALSE 22424
// sci := [ sci [ 1 ] ] else
22405: LD_ADDR_VAR 0 8
22409: PUSH
22410: LD_VAR 0 8
22414: PUSH
22415: LD_INT 1
22417: ARRAY
22418: PUSH
22419: EMPTY
22420: LIST
22421: ST_TO_ADDR
22422: GO 22456
// if sci = 0 then
22424: LD_VAR 0 8
22428: PUSH
22429: LD_INT 0
22431: EQUAL
22432: IFFALSE 22456
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
22434: LD_ADDR_VAR 0 11
22438: PUSH
22439: LD_VAR 0 4
22443: PPUSH
22444: LD_INT 4
22446: PPUSH
22447: CALL 88803 0 2
22451: PUSH
22452: LD_INT 1
22454: ARRAY
22455: ST_TO_ADDR
// if eng > 4 then
22456: LD_VAR 0 6
22460: PUSH
22461: LD_INT 4
22463: GREATER
22464: IFFALSE 22510
// for i = eng downto 4 do
22466: LD_ADDR_VAR 0 3
22470: PUSH
22471: DOUBLE
22472: LD_VAR 0 6
22476: INC
22477: ST_TO_ADDR
22478: LD_INT 4
22480: PUSH
22481: FOR_DOWNTO
22482: IFFALSE 22508
// eng := eng diff eng [ i ] ;
22484: LD_ADDR_VAR 0 6
22488: PUSH
22489: LD_VAR 0 6
22493: PUSH
22494: LD_VAR 0 6
22498: PUSH
22499: LD_VAR 0 3
22503: ARRAY
22504: DIFF
22505: ST_TO_ADDR
22506: GO 22481
22508: POP
22509: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
22510: LD_ADDR_VAR 0 4
22514: PUSH
22515: LD_VAR 0 4
22519: PUSH
22520: LD_VAR 0 5
22524: PUSH
22525: LD_VAR 0 6
22529: UNION
22530: PUSH
22531: LD_VAR 0 7
22535: UNION
22536: PUSH
22537: LD_VAR 0 8
22541: UNION
22542: DIFF
22543: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
22544: LD_ADDR_VAR 0 13
22548: PUSH
22549: LD_EXP 50
22553: PUSH
22554: LD_VAR 0 1
22558: ARRAY
22559: PPUSH
22560: LD_INT 2
22562: PUSH
22563: LD_INT 30
22565: PUSH
22566: LD_INT 32
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: PUSH
22573: LD_INT 30
22575: PUSH
22576: LD_INT 31
22578: PUSH
22579: EMPTY
22580: LIST
22581: LIST
22582: PUSH
22583: EMPTY
22584: LIST
22585: LIST
22586: LIST
22587: PPUSH
22588: CALL_OW 72
22592: PUSH
22593: LD_EXP 50
22597: PUSH
22598: LD_VAR 0 1
22602: ARRAY
22603: PPUSH
22604: LD_INT 2
22606: PUSH
22607: LD_INT 30
22609: PUSH
22610: LD_INT 4
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: PUSH
22617: LD_INT 30
22619: PUSH
22620: LD_INT 5
22622: PUSH
22623: EMPTY
22624: LIST
22625: LIST
22626: PUSH
22627: EMPTY
22628: LIST
22629: LIST
22630: LIST
22631: PPUSH
22632: CALL_OW 72
22636: PUSH
22637: LD_INT 6
22639: MUL
22640: PLUS
22641: ST_TO_ADDR
// if bcount < tmp then
22642: LD_VAR 0 13
22646: PUSH
22647: LD_VAR 0 4
22651: LESS
22652: IFFALSE 22698
// for i = tmp downto bcount do
22654: LD_ADDR_VAR 0 3
22658: PUSH
22659: DOUBLE
22660: LD_VAR 0 4
22664: INC
22665: ST_TO_ADDR
22666: LD_VAR 0 13
22670: PUSH
22671: FOR_DOWNTO
22672: IFFALSE 22696
// tmp := Delete ( tmp , tmp ) ;
22674: LD_ADDR_VAR 0 4
22678: PUSH
22679: LD_VAR 0 4
22683: PPUSH
22684: LD_VAR 0 4
22688: PPUSH
22689: CALL_OW 3
22693: ST_TO_ADDR
22694: GO 22671
22696: POP
22697: POP
// result := [ tmp , 0 , 0 , p ] ;
22698: LD_ADDR_VAR 0 2
22702: PUSH
22703: LD_VAR 0 4
22707: PUSH
22708: LD_INT 0
22710: PUSH
22711: LD_INT 0
22713: PUSH
22714: LD_VAR 0 11
22718: PUSH
22719: EMPTY
22720: LIST
22721: LIST
22722: LIST
22723: LIST
22724: ST_TO_ADDR
// exit ;
22725: GO 25415
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22727: LD_EXP 50
22731: PUSH
22732: LD_VAR 0 1
22736: ARRAY
22737: PPUSH
22738: LD_INT 2
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 6
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 30
22753: PUSH
22754: LD_INT 7
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: PUSH
22761: LD_INT 30
22763: PUSH
22764: LD_INT 8
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: PPUSH
22777: CALL_OW 72
22781: NOT
22782: PUSH
22783: LD_EXP 50
22787: PUSH
22788: LD_VAR 0 1
22792: ARRAY
22793: PPUSH
22794: LD_INT 30
22796: PUSH
22797: LD_INT 3
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PPUSH
22804: CALL_OW 72
22808: NOT
22809: AND
22810: IFFALSE 22882
// begin if eng = tmp then
22812: LD_VAR 0 6
22816: PUSH
22817: LD_VAR 0 4
22821: EQUAL
22822: IFFALSE 22826
// exit ;
22824: GO 25415
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
22826: LD_ADDR_EXP 92
22830: PUSH
22831: LD_EXP 92
22835: PPUSH
22836: LD_VAR 0 1
22840: PPUSH
22841: LD_INT 1
22843: PPUSH
22844: CALL_OW 1
22848: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
22849: LD_ADDR_VAR 0 2
22853: PUSH
22854: LD_INT 0
22856: PUSH
22857: LD_VAR 0 4
22861: PUSH
22862: LD_VAR 0 6
22866: DIFF
22867: PUSH
22868: LD_INT 0
22870: PUSH
22871: LD_INT 0
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: LIST
22878: LIST
22879: ST_TO_ADDR
// exit ;
22880: GO 25415
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
22882: LD_EXP 77
22886: PUSH
22887: LD_EXP 76
22891: PUSH
22892: LD_VAR 0 1
22896: ARRAY
22897: ARRAY
22898: PUSH
22899: LD_EXP 50
22903: PUSH
22904: LD_VAR 0 1
22908: ARRAY
22909: PPUSH
22910: LD_INT 2
22912: PUSH
22913: LD_INT 30
22915: PUSH
22916: LD_INT 6
22918: PUSH
22919: EMPTY
22920: LIST
22921: LIST
22922: PUSH
22923: LD_INT 30
22925: PUSH
22926: LD_INT 7
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: PUSH
22933: LD_INT 30
22935: PUSH
22936: LD_INT 8
22938: PUSH
22939: EMPTY
22940: LIST
22941: LIST
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: LIST
22947: LIST
22948: PPUSH
22949: CALL_OW 72
22953: AND
22954: PUSH
22955: LD_EXP 50
22959: PUSH
22960: LD_VAR 0 1
22964: ARRAY
22965: PPUSH
22966: LD_INT 30
22968: PUSH
22969: LD_INT 3
22971: PUSH
22972: EMPTY
22973: LIST
22974: LIST
22975: PPUSH
22976: CALL_OW 72
22980: NOT
22981: AND
22982: IFFALSE 23196
// begin if sci >= 6 then
22984: LD_VAR 0 8
22988: PUSH
22989: LD_INT 6
22991: GREATEREQUAL
22992: IFFALSE 22996
// exit ;
22994: GO 25415
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
22996: LD_ADDR_EXP 92
23000: PUSH
23001: LD_EXP 92
23005: PPUSH
23006: LD_VAR 0 1
23010: PPUSH
23011: LD_INT 2
23013: PPUSH
23014: CALL_OW 1
23018: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23019: LD_ADDR_VAR 0 9
23023: PUSH
23024: LD_VAR 0 4
23028: PUSH
23029: LD_VAR 0 8
23033: DIFF
23034: PPUSH
23035: LD_INT 4
23037: PPUSH
23038: CALL 88803 0 2
23042: ST_TO_ADDR
// p := [ ] ;
23043: LD_ADDR_VAR 0 11
23047: PUSH
23048: EMPTY
23049: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23050: LD_VAR 0 8
23054: PUSH
23055: LD_INT 6
23057: LESS
23058: PUSH
23059: LD_VAR 0 9
23063: PUSH
23064: LD_INT 6
23066: GREATER
23067: AND
23068: IFFALSE 23149
// begin for i = 1 to 6 - sci do
23070: LD_ADDR_VAR 0 3
23074: PUSH
23075: DOUBLE
23076: LD_INT 1
23078: DEC
23079: ST_TO_ADDR
23080: LD_INT 6
23082: PUSH
23083: LD_VAR 0 8
23087: MINUS
23088: PUSH
23089: FOR_TO
23090: IFFALSE 23145
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23092: LD_ADDR_VAR 0 11
23096: PUSH
23097: LD_VAR 0 11
23101: PPUSH
23102: LD_VAR 0 11
23106: PUSH
23107: LD_INT 1
23109: PLUS
23110: PPUSH
23111: LD_VAR 0 9
23115: PUSH
23116: LD_INT 1
23118: ARRAY
23119: PPUSH
23120: CALL_OW 2
23124: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23125: LD_ADDR_VAR 0 9
23129: PUSH
23130: LD_VAR 0 9
23134: PPUSH
23135: LD_INT 1
23137: PPUSH
23138: CALL_OW 3
23142: ST_TO_ADDR
// end ;
23143: GO 23089
23145: POP
23146: POP
// end else
23147: GO 23169
// if sort then
23149: LD_VAR 0 9
23153: IFFALSE 23169
// p := sort [ 1 ] ;
23155: LD_ADDR_VAR 0 11
23159: PUSH
23160: LD_VAR 0 9
23164: PUSH
23165: LD_INT 1
23167: ARRAY
23168: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23169: LD_ADDR_VAR 0 2
23173: PUSH
23174: LD_INT 0
23176: PUSH
23177: LD_INT 0
23179: PUSH
23180: LD_INT 0
23182: PUSH
23183: LD_VAR 0 11
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: ST_TO_ADDR
// exit ;
23194: GO 25415
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23196: LD_EXP 77
23200: PUSH
23201: LD_EXP 76
23205: PUSH
23206: LD_VAR 0 1
23210: ARRAY
23211: ARRAY
23212: PUSH
23213: LD_EXP 50
23217: PUSH
23218: LD_VAR 0 1
23222: ARRAY
23223: PPUSH
23224: LD_INT 2
23226: PUSH
23227: LD_INT 30
23229: PUSH
23230: LD_INT 6
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: PUSH
23237: LD_INT 30
23239: PUSH
23240: LD_INT 7
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 30
23249: PUSH
23250: LD_INT 8
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: LIST
23262: PPUSH
23263: CALL_OW 72
23267: AND
23268: PUSH
23269: LD_EXP 50
23273: PUSH
23274: LD_VAR 0 1
23278: ARRAY
23279: PPUSH
23280: LD_INT 30
23282: PUSH
23283: LD_INT 3
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PPUSH
23290: CALL_OW 72
23294: AND
23295: IFFALSE 24029
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23297: LD_ADDR_EXP 92
23301: PUSH
23302: LD_EXP 92
23306: PPUSH
23307: LD_VAR 0 1
23311: PPUSH
23312: LD_INT 3
23314: PPUSH
23315: CALL_OW 1
23319: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23320: LD_ADDR_VAR 0 2
23324: PUSH
23325: LD_INT 0
23327: PUSH
23328: LD_INT 0
23330: PUSH
23331: LD_INT 0
23333: PUSH
23334: LD_INT 0
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: ST_TO_ADDR
// if not eng then
23343: LD_VAR 0 6
23347: NOT
23348: IFFALSE 23411
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23350: LD_ADDR_VAR 0 11
23354: PUSH
23355: LD_VAR 0 4
23359: PPUSH
23360: LD_INT 2
23362: PPUSH
23363: CALL 88803 0 2
23367: PUSH
23368: LD_INT 1
23370: ARRAY
23371: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23372: LD_ADDR_VAR 0 2
23376: PUSH
23377: LD_VAR 0 2
23381: PPUSH
23382: LD_INT 2
23384: PPUSH
23385: LD_VAR 0 11
23389: PPUSH
23390: CALL_OW 1
23394: ST_TO_ADDR
// tmp := tmp diff p ;
23395: LD_ADDR_VAR 0 4
23399: PUSH
23400: LD_VAR 0 4
23404: PUSH
23405: LD_VAR 0 11
23409: DIFF
23410: ST_TO_ADDR
// end ; if tmp and sci < 6 then
23411: LD_VAR 0 4
23415: PUSH
23416: LD_VAR 0 8
23420: PUSH
23421: LD_INT 6
23423: LESS
23424: AND
23425: IFFALSE 23613
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
23427: LD_ADDR_VAR 0 9
23431: PUSH
23432: LD_VAR 0 4
23436: PUSH
23437: LD_VAR 0 8
23441: PUSH
23442: LD_VAR 0 7
23446: UNION
23447: DIFF
23448: PPUSH
23449: LD_INT 4
23451: PPUSH
23452: CALL 88803 0 2
23456: ST_TO_ADDR
// p := [ ] ;
23457: LD_ADDR_VAR 0 11
23461: PUSH
23462: EMPTY
23463: ST_TO_ADDR
// if sort then
23464: LD_VAR 0 9
23468: IFFALSE 23584
// for i = 1 to 6 - sci do
23470: LD_ADDR_VAR 0 3
23474: PUSH
23475: DOUBLE
23476: LD_INT 1
23478: DEC
23479: ST_TO_ADDR
23480: LD_INT 6
23482: PUSH
23483: LD_VAR 0 8
23487: MINUS
23488: PUSH
23489: FOR_TO
23490: IFFALSE 23582
// begin if i = sort then
23492: LD_VAR 0 3
23496: PUSH
23497: LD_VAR 0 9
23501: EQUAL
23502: IFFALSE 23506
// break ;
23504: GO 23582
// if GetClass ( i ) = 4 then
23506: LD_VAR 0 3
23510: PPUSH
23511: CALL_OW 257
23515: PUSH
23516: LD_INT 4
23518: EQUAL
23519: IFFALSE 23523
// continue ;
23521: GO 23489
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23523: LD_ADDR_VAR 0 11
23527: PUSH
23528: LD_VAR 0 11
23532: PPUSH
23533: LD_VAR 0 11
23537: PUSH
23538: LD_INT 1
23540: PLUS
23541: PPUSH
23542: LD_VAR 0 9
23546: PUSH
23547: LD_VAR 0 3
23551: ARRAY
23552: PPUSH
23553: CALL_OW 2
23557: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23558: LD_ADDR_VAR 0 4
23562: PUSH
23563: LD_VAR 0 4
23567: PUSH
23568: LD_VAR 0 9
23572: PUSH
23573: LD_VAR 0 3
23577: ARRAY
23578: DIFF
23579: ST_TO_ADDR
// end ;
23580: GO 23489
23582: POP
23583: POP
// if p then
23584: LD_VAR 0 11
23588: IFFALSE 23613
// result := Replace ( result , 4 , p ) ;
23590: LD_ADDR_VAR 0 2
23594: PUSH
23595: LD_VAR 0 2
23599: PPUSH
23600: LD_INT 4
23602: PPUSH
23603: LD_VAR 0 11
23607: PPUSH
23608: CALL_OW 1
23612: ST_TO_ADDR
// end ; if tmp and mech < 6 then
23613: LD_VAR 0 4
23617: PUSH
23618: LD_VAR 0 7
23622: PUSH
23623: LD_INT 6
23625: LESS
23626: AND
23627: IFFALSE 23815
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
23629: LD_ADDR_VAR 0 9
23633: PUSH
23634: LD_VAR 0 4
23638: PUSH
23639: LD_VAR 0 8
23643: PUSH
23644: LD_VAR 0 7
23648: UNION
23649: DIFF
23650: PPUSH
23651: LD_INT 3
23653: PPUSH
23654: CALL 88803 0 2
23658: ST_TO_ADDR
// p := [ ] ;
23659: LD_ADDR_VAR 0 11
23663: PUSH
23664: EMPTY
23665: ST_TO_ADDR
// if sort then
23666: LD_VAR 0 9
23670: IFFALSE 23786
// for i = 1 to 6 - mech do
23672: LD_ADDR_VAR 0 3
23676: PUSH
23677: DOUBLE
23678: LD_INT 1
23680: DEC
23681: ST_TO_ADDR
23682: LD_INT 6
23684: PUSH
23685: LD_VAR 0 7
23689: MINUS
23690: PUSH
23691: FOR_TO
23692: IFFALSE 23784
// begin if i = sort then
23694: LD_VAR 0 3
23698: PUSH
23699: LD_VAR 0 9
23703: EQUAL
23704: IFFALSE 23708
// break ;
23706: GO 23784
// if GetClass ( i ) = 3 then
23708: LD_VAR 0 3
23712: PPUSH
23713: CALL_OW 257
23717: PUSH
23718: LD_INT 3
23720: EQUAL
23721: IFFALSE 23725
// continue ;
23723: GO 23691
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23725: LD_ADDR_VAR 0 11
23729: PUSH
23730: LD_VAR 0 11
23734: PPUSH
23735: LD_VAR 0 11
23739: PUSH
23740: LD_INT 1
23742: PLUS
23743: PPUSH
23744: LD_VAR 0 9
23748: PUSH
23749: LD_VAR 0 3
23753: ARRAY
23754: PPUSH
23755: CALL_OW 2
23759: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23760: LD_ADDR_VAR 0 4
23764: PUSH
23765: LD_VAR 0 4
23769: PUSH
23770: LD_VAR 0 9
23774: PUSH
23775: LD_VAR 0 3
23779: ARRAY
23780: DIFF
23781: ST_TO_ADDR
// end ;
23782: GO 23691
23784: POP
23785: POP
// if p then
23786: LD_VAR 0 11
23790: IFFALSE 23815
// result := Replace ( result , 3 , p ) ;
23792: LD_ADDR_VAR 0 2
23796: PUSH
23797: LD_VAR 0 2
23801: PPUSH
23802: LD_INT 3
23804: PPUSH
23805: LD_VAR 0 11
23809: PPUSH
23810: CALL_OW 1
23814: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
23815: LD_VAR 0 4
23819: PUSH
23820: LD_INT 6
23822: GREATER
23823: PUSH
23824: LD_VAR 0 6
23828: PUSH
23829: LD_INT 6
23831: LESS
23832: AND
23833: IFFALSE 24027
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
23835: LD_ADDR_VAR 0 9
23839: PUSH
23840: LD_VAR 0 4
23844: PUSH
23845: LD_VAR 0 8
23849: PUSH
23850: LD_VAR 0 7
23854: UNION
23855: PUSH
23856: LD_VAR 0 6
23860: UNION
23861: DIFF
23862: PPUSH
23863: LD_INT 2
23865: PPUSH
23866: CALL 88803 0 2
23870: ST_TO_ADDR
// p := [ ] ;
23871: LD_ADDR_VAR 0 11
23875: PUSH
23876: EMPTY
23877: ST_TO_ADDR
// if sort then
23878: LD_VAR 0 9
23882: IFFALSE 23998
// for i = 1 to 6 - eng do
23884: LD_ADDR_VAR 0 3
23888: PUSH
23889: DOUBLE
23890: LD_INT 1
23892: DEC
23893: ST_TO_ADDR
23894: LD_INT 6
23896: PUSH
23897: LD_VAR 0 6
23901: MINUS
23902: PUSH
23903: FOR_TO
23904: IFFALSE 23996
// begin if i = sort then
23906: LD_VAR 0 3
23910: PUSH
23911: LD_VAR 0 9
23915: EQUAL
23916: IFFALSE 23920
// break ;
23918: GO 23996
// if GetClass ( i ) = 2 then
23920: LD_VAR 0 3
23924: PPUSH
23925: CALL_OW 257
23929: PUSH
23930: LD_INT 2
23932: EQUAL
23933: IFFALSE 23937
// continue ;
23935: GO 23903
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23937: LD_ADDR_VAR 0 11
23941: PUSH
23942: LD_VAR 0 11
23946: PPUSH
23947: LD_VAR 0 11
23951: PUSH
23952: LD_INT 1
23954: PLUS
23955: PPUSH
23956: LD_VAR 0 9
23960: PUSH
23961: LD_VAR 0 3
23965: ARRAY
23966: PPUSH
23967: CALL_OW 2
23971: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23972: LD_ADDR_VAR 0 4
23976: PUSH
23977: LD_VAR 0 4
23981: PUSH
23982: LD_VAR 0 9
23986: PUSH
23987: LD_VAR 0 3
23991: ARRAY
23992: DIFF
23993: ST_TO_ADDR
// end ;
23994: GO 23903
23996: POP
23997: POP
// if p then
23998: LD_VAR 0 11
24002: IFFALSE 24027
// result := Replace ( result , 2 , p ) ;
24004: LD_ADDR_VAR 0 2
24008: PUSH
24009: LD_VAR 0 2
24013: PPUSH
24014: LD_INT 2
24016: PPUSH
24017: LD_VAR 0 11
24021: PPUSH
24022: CALL_OW 1
24026: ST_TO_ADDR
// end ; exit ;
24027: GO 25415
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24029: LD_EXP 77
24033: PUSH
24034: LD_EXP 76
24038: PUSH
24039: LD_VAR 0 1
24043: ARRAY
24044: ARRAY
24045: NOT
24046: PUSH
24047: LD_EXP 50
24051: PUSH
24052: LD_VAR 0 1
24056: ARRAY
24057: PPUSH
24058: LD_INT 30
24060: PUSH
24061: LD_INT 3
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PPUSH
24068: CALL_OW 72
24072: AND
24073: PUSH
24074: LD_EXP 55
24078: PUSH
24079: LD_VAR 0 1
24083: ARRAY
24084: AND
24085: IFFALSE 24693
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24087: LD_ADDR_EXP 92
24091: PUSH
24092: LD_EXP 92
24096: PPUSH
24097: LD_VAR 0 1
24101: PPUSH
24102: LD_INT 5
24104: PPUSH
24105: CALL_OW 1
24109: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24110: LD_ADDR_VAR 0 2
24114: PUSH
24115: LD_INT 0
24117: PUSH
24118: LD_INT 0
24120: PUSH
24121: LD_INT 0
24123: PUSH
24124: LD_INT 0
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: ST_TO_ADDR
// if sci > 1 then
24133: LD_VAR 0 8
24137: PUSH
24138: LD_INT 1
24140: GREATER
24141: IFFALSE 24169
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24143: LD_ADDR_VAR 0 4
24147: PUSH
24148: LD_VAR 0 4
24152: PUSH
24153: LD_VAR 0 8
24157: PUSH
24158: LD_VAR 0 8
24162: PUSH
24163: LD_INT 1
24165: ARRAY
24166: DIFF
24167: DIFF
24168: ST_TO_ADDR
// if tmp and not sci then
24169: LD_VAR 0 4
24173: PUSH
24174: LD_VAR 0 8
24178: NOT
24179: AND
24180: IFFALSE 24249
// begin sort := SortBySkill ( tmp , 4 ) ;
24182: LD_ADDR_VAR 0 9
24186: PUSH
24187: LD_VAR 0 4
24191: PPUSH
24192: LD_INT 4
24194: PPUSH
24195: CALL 88803 0 2
24199: ST_TO_ADDR
// if sort then
24200: LD_VAR 0 9
24204: IFFALSE 24220
// p := sort [ 1 ] ;
24206: LD_ADDR_VAR 0 11
24210: PUSH
24211: LD_VAR 0 9
24215: PUSH
24216: LD_INT 1
24218: ARRAY
24219: ST_TO_ADDR
// if p then
24220: LD_VAR 0 11
24224: IFFALSE 24249
// result := Replace ( result , 4 , p ) ;
24226: LD_ADDR_VAR 0 2
24230: PUSH
24231: LD_VAR 0 2
24235: PPUSH
24236: LD_INT 4
24238: PPUSH
24239: LD_VAR 0 11
24243: PPUSH
24244: CALL_OW 1
24248: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24249: LD_ADDR_VAR 0 4
24253: PUSH
24254: LD_VAR 0 4
24258: PUSH
24259: LD_VAR 0 7
24263: DIFF
24264: ST_TO_ADDR
// if tmp and mech < 6 then
24265: LD_VAR 0 4
24269: PUSH
24270: LD_VAR 0 7
24274: PUSH
24275: LD_INT 6
24277: LESS
24278: AND
24279: IFFALSE 24467
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24281: LD_ADDR_VAR 0 9
24285: PUSH
24286: LD_VAR 0 4
24290: PUSH
24291: LD_VAR 0 8
24295: PUSH
24296: LD_VAR 0 7
24300: UNION
24301: DIFF
24302: PPUSH
24303: LD_INT 3
24305: PPUSH
24306: CALL 88803 0 2
24310: ST_TO_ADDR
// p := [ ] ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: EMPTY
24317: ST_TO_ADDR
// if sort then
24318: LD_VAR 0 9
24322: IFFALSE 24438
// for i = 1 to 6 - mech do
24324: LD_ADDR_VAR 0 3
24328: PUSH
24329: DOUBLE
24330: LD_INT 1
24332: DEC
24333: ST_TO_ADDR
24334: LD_INT 6
24336: PUSH
24337: LD_VAR 0 7
24341: MINUS
24342: PUSH
24343: FOR_TO
24344: IFFALSE 24436
// begin if i = sort then
24346: LD_VAR 0 3
24350: PUSH
24351: LD_VAR 0 9
24355: EQUAL
24356: IFFALSE 24360
// break ;
24358: GO 24436
// if GetClass ( i ) = 3 then
24360: LD_VAR 0 3
24364: PPUSH
24365: CALL_OW 257
24369: PUSH
24370: LD_INT 3
24372: EQUAL
24373: IFFALSE 24377
// continue ;
24375: GO 24343
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24377: LD_ADDR_VAR 0 11
24381: PUSH
24382: LD_VAR 0 11
24386: PPUSH
24387: LD_VAR 0 11
24391: PUSH
24392: LD_INT 1
24394: PLUS
24395: PPUSH
24396: LD_VAR 0 9
24400: PUSH
24401: LD_VAR 0 3
24405: ARRAY
24406: PPUSH
24407: CALL_OW 2
24411: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24412: LD_ADDR_VAR 0 4
24416: PUSH
24417: LD_VAR 0 4
24421: PUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_VAR 0 3
24431: ARRAY
24432: DIFF
24433: ST_TO_ADDR
// end ;
24434: GO 24343
24436: POP
24437: POP
// if p then
24438: LD_VAR 0 11
24442: IFFALSE 24467
// result := Replace ( result , 3 , p ) ;
24444: LD_ADDR_VAR 0 2
24448: PUSH
24449: LD_VAR 0 2
24453: PPUSH
24454: LD_INT 3
24456: PPUSH
24457: LD_VAR 0 11
24461: PPUSH
24462: CALL_OW 1
24466: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
24467: LD_ADDR_VAR 0 4
24471: PUSH
24472: LD_VAR 0 4
24476: PUSH
24477: LD_VAR 0 6
24481: DIFF
24482: ST_TO_ADDR
// if tmp and eng < 6 then
24483: LD_VAR 0 4
24487: PUSH
24488: LD_VAR 0 6
24492: PUSH
24493: LD_INT 6
24495: LESS
24496: AND
24497: IFFALSE 24691
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24499: LD_ADDR_VAR 0 9
24503: PUSH
24504: LD_VAR 0 4
24508: PUSH
24509: LD_VAR 0 8
24513: PUSH
24514: LD_VAR 0 7
24518: UNION
24519: PUSH
24520: LD_VAR 0 6
24524: UNION
24525: DIFF
24526: PPUSH
24527: LD_INT 2
24529: PPUSH
24530: CALL 88803 0 2
24534: ST_TO_ADDR
// p := [ ] ;
24535: LD_ADDR_VAR 0 11
24539: PUSH
24540: EMPTY
24541: ST_TO_ADDR
// if sort then
24542: LD_VAR 0 9
24546: IFFALSE 24662
// for i = 1 to 6 - eng do
24548: LD_ADDR_VAR 0 3
24552: PUSH
24553: DOUBLE
24554: LD_INT 1
24556: DEC
24557: ST_TO_ADDR
24558: LD_INT 6
24560: PUSH
24561: LD_VAR 0 6
24565: MINUS
24566: PUSH
24567: FOR_TO
24568: IFFALSE 24660
// begin if i = sort then
24570: LD_VAR 0 3
24574: PUSH
24575: LD_VAR 0 9
24579: EQUAL
24580: IFFALSE 24584
// break ;
24582: GO 24660
// if GetClass ( i ) = 2 then
24584: LD_VAR 0 3
24588: PPUSH
24589: CALL_OW 257
24593: PUSH
24594: LD_INT 2
24596: EQUAL
24597: IFFALSE 24601
// continue ;
24599: GO 24567
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24601: LD_ADDR_VAR 0 11
24605: PUSH
24606: LD_VAR 0 11
24610: PPUSH
24611: LD_VAR 0 11
24615: PUSH
24616: LD_INT 1
24618: PLUS
24619: PPUSH
24620: LD_VAR 0 9
24624: PUSH
24625: LD_VAR 0 3
24629: ARRAY
24630: PPUSH
24631: CALL_OW 2
24635: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24636: LD_ADDR_VAR 0 4
24640: PUSH
24641: LD_VAR 0 4
24645: PUSH
24646: LD_VAR 0 9
24650: PUSH
24651: LD_VAR 0 3
24655: ARRAY
24656: DIFF
24657: ST_TO_ADDR
// end ;
24658: GO 24567
24660: POP
24661: POP
// if p then
24662: LD_VAR 0 11
24666: IFFALSE 24691
// result := Replace ( result , 2 , p ) ;
24668: LD_ADDR_VAR 0 2
24672: PUSH
24673: LD_VAR 0 2
24677: PPUSH
24678: LD_INT 2
24680: PPUSH
24681: LD_VAR 0 11
24685: PPUSH
24686: CALL_OW 1
24690: ST_TO_ADDR
// end ; exit ;
24691: GO 25415
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
24693: LD_EXP 77
24697: PUSH
24698: LD_EXP 76
24702: PUSH
24703: LD_VAR 0 1
24707: ARRAY
24708: ARRAY
24709: NOT
24710: PUSH
24711: LD_EXP 50
24715: PUSH
24716: LD_VAR 0 1
24720: ARRAY
24721: PPUSH
24722: LD_INT 30
24724: PUSH
24725: LD_INT 3
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: PPUSH
24732: CALL_OW 72
24736: AND
24737: PUSH
24738: LD_EXP 55
24742: PUSH
24743: LD_VAR 0 1
24747: ARRAY
24748: NOT
24749: AND
24750: IFFALSE 25415
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
24752: LD_ADDR_EXP 92
24756: PUSH
24757: LD_EXP 92
24761: PPUSH
24762: LD_VAR 0 1
24766: PPUSH
24767: LD_INT 6
24769: PPUSH
24770: CALL_OW 1
24774: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24775: LD_ADDR_VAR 0 2
24779: PUSH
24780: LD_INT 0
24782: PUSH
24783: LD_INT 0
24785: PUSH
24786: LD_INT 0
24788: PUSH
24789: LD_INT 0
24791: PUSH
24792: EMPTY
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: ST_TO_ADDR
// if sci >= 1 then
24798: LD_VAR 0 8
24802: PUSH
24803: LD_INT 1
24805: GREATEREQUAL
24806: IFFALSE 24828
// tmp := tmp diff sci [ 1 ] ;
24808: LD_ADDR_VAR 0 4
24812: PUSH
24813: LD_VAR 0 4
24817: PUSH
24818: LD_VAR 0 8
24822: PUSH
24823: LD_INT 1
24825: ARRAY
24826: DIFF
24827: ST_TO_ADDR
// if tmp and not sci then
24828: LD_VAR 0 4
24832: PUSH
24833: LD_VAR 0 8
24837: NOT
24838: AND
24839: IFFALSE 24908
// begin sort := SortBySkill ( tmp , 4 ) ;
24841: LD_ADDR_VAR 0 9
24845: PUSH
24846: LD_VAR 0 4
24850: PPUSH
24851: LD_INT 4
24853: PPUSH
24854: CALL 88803 0 2
24858: ST_TO_ADDR
// if sort then
24859: LD_VAR 0 9
24863: IFFALSE 24879
// p := sort [ 1 ] ;
24865: LD_ADDR_VAR 0 11
24869: PUSH
24870: LD_VAR 0 9
24874: PUSH
24875: LD_INT 1
24877: ARRAY
24878: ST_TO_ADDR
// if p then
24879: LD_VAR 0 11
24883: IFFALSE 24908
// result := Replace ( result , 4 , p ) ;
24885: LD_ADDR_VAR 0 2
24889: PUSH
24890: LD_VAR 0 2
24894: PPUSH
24895: LD_INT 4
24897: PPUSH
24898: LD_VAR 0 11
24902: PPUSH
24903: CALL_OW 1
24907: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24908: LD_ADDR_VAR 0 4
24912: PUSH
24913: LD_VAR 0 4
24917: PUSH
24918: LD_VAR 0 7
24922: DIFF
24923: ST_TO_ADDR
// if tmp and mech < 6 then
24924: LD_VAR 0 4
24928: PUSH
24929: LD_VAR 0 7
24933: PUSH
24934: LD_INT 6
24936: LESS
24937: AND
24938: IFFALSE 25120
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
24940: LD_ADDR_VAR 0 9
24944: PUSH
24945: LD_VAR 0 4
24949: PUSH
24950: LD_VAR 0 7
24954: DIFF
24955: PPUSH
24956: LD_INT 3
24958: PPUSH
24959: CALL 88803 0 2
24963: ST_TO_ADDR
// p := [ ] ;
24964: LD_ADDR_VAR 0 11
24968: PUSH
24969: EMPTY
24970: ST_TO_ADDR
// if sort then
24971: LD_VAR 0 9
24975: IFFALSE 25091
// for i = 1 to 6 - mech do
24977: LD_ADDR_VAR 0 3
24981: PUSH
24982: DOUBLE
24983: LD_INT 1
24985: DEC
24986: ST_TO_ADDR
24987: LD_INT 6
24989: PUSH
24990: LD_VAR 0 7
24994: MINUS
24995: PUSH
24996: FOR_TO
24997: IFFALSE 25089
// begin if i = sort then
24999: LD_VAR 0 3
25003: PUSH
25004: LD_VAR 0 9
25008: EQUAL
25009: IFFALSE 25013
// break ;
25011: GO 25089
// if GetClass ( i ) = 3 then
25013: LD_VAR 0 3
25017: PPUSH
25018: CALL_OW 257
25022: PUSH
25023: LD_INT 3
25025: EQUAL
25026: IFFALSE 25030
// continue ;
25028: GO 24996
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25030: LD_ADDR_VAR 0 11
25034: PUSH
25035: LD_VAR 0 11
25039: PPUSH
25040: LD_VAR 0 11
25044: PUSH
25045: LD_INT 1
25047: PLUS
25048: PPUSH
25049: LD_VAR 0 9
25053: PUSH
25054: LD_VAR 0 3
25058: ARRAY
25059: PPUSH
25060: CALL_OW 2
25064: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25065: LD_ADDR_VAR 0 4
25069: PUSH
25070: LD_VAR 0 4
25074: PUSH
25075: LD_VAR 0 9
25079: PUSH
25080: LD_VAR 0 3
25084: ARRAY
25085: DIFF
25086: ST_TO_ADDR
// end ;
25087: GO 24996
25089: POP
25090: POP
// if p then
25091: LD_VAR 0 11
25095: IFFALSE 25120
// result := Replace ( result , 3 , p ) ;
25097: LD_ADDR_VAR 0 2
25101: PUSH
25102: LD_VAR 0 2
25106: PPUSH
25107: LD_INT 3
25109: PPUSH
25110: LD_VAR 0 11
25114: PPUSH
25115: CALL_OW 1
25119: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25120: LD_ADDR_VAR 0 4
25124: PUSH
25125: LD_VAR 0 4
25129: PUSH
25130: LD_VAR 0 6
25134: DIFF
25135: ST_TO_ADDR
// if tmp and eng < 4 then
25136: LD_VAR 0 4
25140: PUSH
25141: LD_VAR 0 6
25145: PUSH
25146: LD_INT 4
25148: LESS
25149: AND
25150: IFFALSE 25340
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25152: LD_ADDR_VAR 0 9
25156: PUSH
25157: LD_VAR 0 4
25161: PUSH
25162: LD_VAR 0 7
25166: PUSH
25167: LD_VAR 0 6
25171: UNION
25172: DIFF
25173: PPUSH
25174: LD_INT 2
25176: PPUSH
25177: CALL 88803 0 2
25181: ST_TO_ADDR
// p := [ ] ;
25182: LD_ADDR_VAR 0 11
25186: PUSH
25187: EMPTY
25188: ST_TO_ADDR
// if sort then
25189: LD_VAR 0 9
25193: IFFALSE 25309
// for i = 1 to 4 - eng do
25195: LD_ADDR_VAR 0 3
25199: PUSH
25200: DOUBLE
25201: LD_INT 1
25203: DEC
25204: ST_TO_ADDR
25205: LD_INT 4
25207: PUSH
25208: LD_VAR 0 6
25212: MINUS
25213: PUSH
25214: FOR_TO
25215: IFFALSE 25307
// begin if i = sort then
25217: LD_VAR 0 3
25221: PUSH
25222: LD_VAR 0 9
25226: EQUAL
25227: IFFALSE 25231
// break ;
25229: GO 25307
// if GetClass ( i ) = 2 then
25231: LD_VAR 0 3
25235: PPUSH
25236: CALL_OW 257
25240: PUSH
25241: LD_INT 2
25243: EQUAL
25244: IFFALSE 25248
// continue ;
25246: GO 25214
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25248: LD_ADDR_VAR 0 11
25252: PUSH
25253: LD_VAR 0 11
25257: PPUSH
25258: LD_VAR 0 11
25262: PUSH
25263: LD_INT 1
25265: PLUS
25266: PPUSH
25267: LD_VAR 0 9
25271: PUSH
25272: LD_VAR 0 3
25276: ARRAY
25277: PPUSH
25278: CALL_OW 2
25282: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25283: LD_ADDR_VAR 0 4
25287: PUSH
25288: LD_VAR 0 4
25292: PUSH
25293: LD_VAR 0 9
25297: PUSH
25298: LD_VAR 0 3
25302: ARRAY
25303: DIFF
25304: ST_TO_ADDR
// end ;
25305: GO 25214
25307: POP
25308: POP
// if p then
25309: LD_VAR 0 11
25313: IFFALSE 25338
// result := Replace ( result , 2 , p ) ;
25315: LD_ADDR_VAR 0 2
25319: PUSH
25320: LD_VAR 0 2
25324: PPUSH
25325: LD_INT 2
25327: PPUSH
25328: LD_VAR 0 11
25332: PPUSH
25333: CALL_OW 1
25337: ST_TO_ADDR
// end else
25338: GO 25384
// for i = eng downto 5 do
25340: LD_ADDR_VAR 0 3
25344: PUSH
25345: DOUBLE
25346: LD_VAR 0 6
25350: INC
25351: ST_TO_ADDR
25352: LD_INT 5
25354: PUSH
25355: FOR_DOWNTO
25356: IFFALSE 25382
// tmp := tmp union eng [ i ] ;
25358: LD_ADDR_VAR 0 4
25362: PUSH
25363: LD_VAR 0 4
25367: PUSH
25368: LD_VAR 0 6
25372: PUSH
25373: LD_VAR 0 3
25377: ARRAY
25378: UNION
25379: ST_TO_ADDR
25380: GO 25355
25382: POP
25383: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25384: LD_ADDR_VAR 0 2
25388: PUSH
25389: LD_VAR 0 2
25393: PPUSH
25394: LD_INT 1
25396: PPUSH
25397: LD_VAR 0 4
25401: PUSH
25402: LD_VAR 0 5
25406: DIFF
25407: PPUSH
25408: CALL_OW 1
25412: ST_TO_ADDR
// exit ;
25413: GO 25415
// end ; end ;
25415: LD_VAR 0 2
25419: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// if not mc_bases then
25425: LD_EXP 50
25429: NOT
25430: IFFALSE 25434
// exit ;
25432: GO 25540
// for i = 1 to mc_bases do
25434: LD_ADDR_VAR 0 2
25438: PUSH
25439: DOUBLE
25440: LD_INT 1
25442: DEC
25443: ST_TO_ADDR
25444: LD_EXP 50
25448: PUSH
25449: FOR_TO
25450: IFFALSE 25531
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
25452: LD_ADDR_VAR 0 3
25456: PUSH
25457: LD_EXP 50
25461: PUSH
25462: LD_VAR 0 2
25466: ARRAY
25467: PPUSH
25468: LD_INT 21
25470: PUSH
25471: LD_INT 3
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 3
25480: PUSH
25481: LD_INT 24
25483: PUSH
25484: LD_INT 1000
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PPUSH
25499: CALL_OW 72
25503: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
25504: LD_ADDR_EXP 51
25508: PUSH
25509: LD_EXP 51
25513: PPUSH
25514: LD_VAR 0 2
25518: PPUSH
25519: LD_VAR 0 3
25523: PPUSH
25524: CALL_OW 1
25528: ST_TO_ADDR
// end ;
25529: GO 25449
25531: POP
25532: POP
// RaiseSailEvent ( 101 ) ;
25533: LD_INT 101
25535: PPUSH
25536: CALL_OW 427
// end ;
25540: LD_VAR 0 1
25544: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
25545: LD_INT 0
25547: PPUSH
25548: PPUSH
25549: PPUSH
25550: PPUSH
25551: PPUSH
25552: PPUSH
25553: PPUSH
// if not mc_bases then
25554: LD_EXP 50
25558: NOT
25559: IFFALSE 25563
// exit ;
25561: GO 26136
// for i = 1 to mc_bases do
25563: LD_ADDR_VAR 0 2
25567: PUSH
25568: DOUBLE
25569: LD_INT 1
25571: DEC
25572: ST_TO_ADDR
25573: LD_EXP 50
25577: PUSH
25578: FOR_TO
25579: IFFALSE 26127
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
25581: LD_ADDR_VAR 0 5
25585: PUSH
25586: LD_EXP 50
25590: PUSH
25591: LD_VAR 0 2
25595: ARRAY
25596: PUSH
25597: LD_EXP 79
25601: PUSH
25602: LD_VAR 0 2
25606: ARRAY
25607: UNION
25608: PPUSH
25609: LD_INT 21
25611: PUSH
25612: LD_INT 1
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 1
25621: PUSH
25622: LD_INT 3
25624: PUSH
25625: LD_INT 54
25627: PUSH
25628: EMPTY
25629: LIST
25630: PUSH
25631: EMPTY
25632: LIST
25633: LIST
25634: PUSH
25635: LD_INT 3
25637: PUSH
25638: LD_INT 24
25640: PUSH
25641: LD_INT 800
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: LIST
25656: PUSH
25657: EMPTY
25658: LIST
25659: LIST
25660: PPUSH
25661: CALL_OW 72
25665: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
25666: LD_ADDR_VAR 0 6
25670: PUSH
25671: LD_EXP 50
25675: PUSH
25676: LD_VAR 0 2
25680: ARRAY
25681: PPUSH
25682: LD_INT 21
25684: PUSH
25685: LD_INT 1
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: PUSH
25692: LD_INT 1
25694: PUSH
25695: LD_INT 3
25697: PUSH
25698: LD_INT 54
25700: PUSH
25701: EMPTY
25702: LIST
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 3
25710: PUSH
25711: LD_INT 24
25713: PUSH
25714: LD_INT 250
25716: PUSH
25717: EMPTY
25718: LIST
25719: LIST
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: LIST
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PPUSH
25734: CALL_OW 72
25738: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
25739: LD_ADDR_VAR 0 7
25743: PUSH
25744: LD_VAR 0 5
25748: PUSH
25749: LD_VAR 0 6
25753: DIFF
25754: ST_TO_ADDR
// if not need_heal_1 then
25755: LD_VAR 0 6
25759: NOT
25760: IFFALSE 25793
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
25762: LD_ADDR_EXP 53
25766: PUSH
25767: LD_EXP 53
25771: PPUSH
25772: LD_VAR 0 2
25776: PUSH
25777: LD_INT 1
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PPUSH
25784: EMPTY
25785: PPUSH
25786: CALL 54555 0 3
25790: ST_TO_ADDR
25791: GO 25863
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
25793: LD_ADDR_EXP 53
25797: PUSH
25798: LD_EXP 53
25802: PPUSH
25803: LD_VAR 0 2
25807: PUSH
25808: LD_INT 1
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: PPUSH
25815: LD_EXP 53
25819: PUSH
25820: LD_VAR 0 2
25824: ARRAY
25825: PUSH
25826: LD_INT 1
25828: ARRAY
25829: PPUSH
25830: LD_INT 3
25832: PUSH
25833: LD_INT 24
25835: PUSH
25836: LD_INT 1000
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: EMPTY
25844: LIST
25845: LIST
25846: PPUSH
25847: CALL_OW 72
25851: PUSH
25852: LD_VAR 0 6
25856: UNION
25857: PPUSH
25858: CALL 54555 0 3
25862: ST_TO_ADDR
// if not need_heal_2 then
25863: LD_VAR 0 7
25867: NOT
25868: IFFALSE 25901
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
25870: LD_ADDR_EXP 53
25874: PUSH
25875: LD_EXP 53
25879: PPUSH
25880: LD_VAR 0 2
25884: PUSH
25885: LD_INT 2
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: EMPTY
25893: PPUSH
25894: CALL 54555 0 3
25898: ST_TO_ADDR
25899: GO 25933
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
25901: LD_ADDR_EXP 53
25905: PUSH
25906: LD_EXP 53
25910: PPUSH
25911: LD_VAR 0 2
25915: PUSH
25916: LD_INT 2
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PPUSH
25923: LD_VAR 0 7
25927: PPUSH
25928: CALL 54555 0 3
25932: ST_TO_ADDR
// if need_heal_2 then
25933: LD_VAR 0 7
25937: IFFALSE 26109
// for j in need_heal_2 do
25939: LD_ADDR_VAR 0 3
25943: PUSH
25944: LD_VAR 0 7
25948: PUSH
25949: FOR_IN
25950: IFFALSE 26107
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
25952: LD_ADDR_VAR 0 5
25956: PUSH
25957: LD_EXP 50
25961: PUSH
25962: LD_VAR 0 2
25966: ARRAY
25967: PPUSH
25968: LD_INT 2
25970: PUSH
25971: LD_INT 30
25973: PUSH
25974: LD_INT 6
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: PUSH
25981: LD_INT 30
25983: PUSH
25984: LD_INT 7
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PUSH
25991: LD_INT 30
25993: PUSH
25994: LD_INT 8
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: LD_INT 30
26003: PUSH
26004: LD_INT 0
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 30
26013: PUSH
26014: LD_INT 1
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 25
26023: PUSH
26024: LD_INT 4
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: PUSH
26031: EMPTY
26032: LIST
26033: LIST
26034: LIST
26035: LIST
26036: LIST
26037: LIST
26038: LIST
26039: PPUSH
26040: CALL_OW 72
26044: ST_TO_ADDR
// if tmp then
26045: LD_VAR 0 5
26049: IFFALSE 26105
// begin k := NearestUnitToUnit ( tmp , j ) ;
26051: LD_ADDR_VAR 0 4
26055: PUSH
26056: LD_VAR 0 5
26060: PPUSH
26061: LD_VAR 0 3
26065: PPUSH
26066: CALL_OW 74
26070: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
26071: LD_VAR 0 3
26075: PPUSH
26076: LD_VAR 0 4
26080: PPUSH
26081: CALL_OW 296
26085: PUSH
26086: LD_INT 7
26088: GREATER
26089: IFFALSE 26105
// ComMoveUnit ( j , k ) ;
26091: LD_VAR 0 3
26095: PPUSH
26096: LD_VAR 0 4
26100: PPUSH
26101: CALL_OW 112
// end ; end ;
26105: GO 25949
26107: POP
26108: POP
// if not need_heal_1 and not need_heal_2 then
26109: LD_VAR 0 6
26113: NOT
26114: PUSH
26115: LD_VAR 0 7
26119: NOT
26120: AND
26121: IFFALSE 26125
// continue ;
26123: GO 25578
// end ;
26125: GO 25578
26127: POP
26128: POP
// RaiseSailEvent ( 102 ) ;
26129: LD_INT 102
26131: PPUSH
26132: CALL_OW 427
// end ;
26136: LD_VAR 0 1
26140: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
26141: LD_INT 0
26143: PPUSH
26144: PPUSH
26145: PPUSH
26146: PPUSH
26147: PPUSH
26148: PPUSH
// if not mc_bases then
26149: LD_EXP 50
26153: NOT
26154: IFFALSE 26158
// exit ;
26156: GO 26868
// for i = 1 to mc_bases do
26158: LD_ADDR_VAR 0 2
26162: PUSH
26163: DOUBLE
26164: LD_INT 1
26166: DEC
26167: ST_TO_ADDR
26168: LD_EXP 50
26172: PUSH
26173: FOR_TO
26174: IFFALSE 26866
// begin if not mc_building_need_repair [ i ] then
26176: LD_EXP 51
26180: PUSH
26181: LD_VAR 0 2
26185: ARRAY
26186: NOT
26187: IFFALSE 26361
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
26189: LD_ADDR_VAR 0 6
26193: PUSH
26194: LD_EXP 69
26198: PUSH
26199: LD_VAR 0 2
26203: ARRAY
26204: PPUSH
26205: LD_INT 3
26207: PUSH
26208: LD_INT 24
26210: PUSH
26211: LD_INT 1000
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 2
26224: PUSH
26225: LD_INT 34
26227: PUSH
26228: LD_INT 13
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: PUSH
26235: LD_INT 34
26237: PUSH
26238: LD_INT 52
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: LIST
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PPUSH
26254: CALL_OW 72
26258: ST_TO_ADDR
// if cranes then
26259: LD_VAR 0 6
26263: IFFALSE 26325
// for j in cranes do
26265: LD_ADDR_VAR 0 3
26269: PUSH
26270: LD_VAR 0 6
26274: PUSH
26275: FOR_IN
26276: IFFALSE 26323
// if not IsInArea ( j , mc_parking [ i ] ) then
26278: LD_VAR 0 3
26282: PPUSH
26283: LD_EXP 74
26287: PUSH
26288: LD_VAR 0 2
26292: ARRAY
26293: PPUSH
26294: CALL_OW 308
26298: NOT
26299: IFFALSE 26321
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26301: LD_VAR 0 3
26305: PPUSH
26306: LD_EXP 74
26310: PUSH
26311: LD_VAR 0 2
26315: ARRAY
26316: PPUSH
26317: CALL_OW 113
26321: GO 26275
26323: POP
26324: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26325: LD_ADDR_EXP 52
26329: PUSH
26330: LD_EXP 52
26334: PPUSH
26335: LD_VAR 0 2
26339: PPUSH
26340: EMPTY
26341: PPUSH
26342: CALL_OW 1
26346: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26347: LD_VAR 0 2
26351: PPUSH
26352: LD_INT 101
26354: PPUSH
26355: CALL 21253 0 2
// continue ;
26359: GO 26173
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26361: LD_ADDR_EXP 56
26365: PUSH
26366: LD_EXP 56
26370: PPUSH
26371: LD_VAR 0 2
26375: PPUSH
26376: EMPTY
26377: PPUSH
26378: CALL_OW 1
26382: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
26383: LD_VAR 0 2
26387: PPUSH
26388: LD_INT 103
26390: PPUSH
26391: CALL 21253 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
26395: LD_ADDR_VAR 0 5
26399: PUSH
26400: LD_EXP 50
26404: PUSH
26405: LD_VAR 0 2
26409: ARRAY
26410: PUSH
26411: LD_EXP 79
26415: PUSH
26416: LD_VAR 0 2
26420: ARRAY
26421: UNION
26422: PPUSH
26423: LD_INT 2
26425: PUSH
26426: LD_INT 25
26428: PUSH
26429: LD_INT 2
26431: PUSH
26432: EMPTY
26433: LIST
26434: LIST
26435: PUSH
26436: LD_INT 25
26438: PUSH
26439: LD_INT 16
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: LIST
26450: PUSH
26451: EMPTY
26452: LIST
26453: PPUSH
26454: CALL_OW 72
26458: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
26459: LD_ADDR_VAR 0 6
26463: PUSH
26464: LD_EXP 69
26468: PUSH
26469: LD_VAR 0 2
26473: ARRAY
26474: PPUSH
26475: LD_INT 2
26477: PUSH
26478: LD_INT 34
26480: PUSH
26481: LD_INT 13
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 34
26490: PUSH
26491: LD_INT 52
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: LIST
26502: PPUSH
26503: CALL_OW 72
26507: ST_TO_ADDR
// if cranes then
26508: LD_VAR 0 6
26512: IFFALSE 26648
// begin for j in cranes do
26514: LD_ADDR_VAR 0 3
26518: PUSH
26519: LD_VAR 0 6
26523: PUSH
26524: FOR_IN
26525: IFFALSE 26646
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
26527: LD_VAR 0 3
26531: PPUSH
26532: CALL_OW 256
26536: PUSH
26537: LD_INT 500
26539: GREATEREQUAL
26540: PUSH
26541: LD_VAR 0 3
26545: PPUSH
26546: CALL_OW 314
26550: NOT
26551: AND
26552: IFFALSE 26586
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
26554: LD_VAR 0 3
26558: PPUSH
26559: LD_EXP 51
26563: PUSH
26564: LD_VAR 0 2
26568: ARRAY
26569: PPUSH
26570: LD_VAR 0 3
26574: PPUSH
26575: CALL_OW 74
26579: PPUSH
26580: CALL_OW 130
26584: GO 26644
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
26586: LD_VAR 0 3
26590: PPUSH
26591: CALL_OW 256
26595: PUSH
26596: LD_INT 500
26598: LESS
26599: PUSH
26600: LD_VAR 0 3
26604: PPUSH
26605: LD_EXP 74
26609: PUSH
26610: LD_VAR 0 2
26614: ARRAY
26615: PPUSH
26616: CALL_OW 308
26620: NOT
26621: AND
26622: IFFALSE 26644
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26624: LD_VAR 0 3
26628: PPUSH
26629: LD_EXP 74
26633: PUSH
26634: LD_VAR 0 2
26638: ARRAY
26639: PPUSH
26640: CALL_OW 113
26644: GO 26524
26646: POP
26647: POP
// end ; if not tmp then
26648: LD_VAR 0 5
26652: NOT
26653: IFFALSE 26657
// continue ;
26655: GO 26173
// for j in tmp do
26657: LD_ADDR_VAR 0 3
26661: PUSH
26662: LD_VAR 0 5
26666: PUSH
26667: FOR_IN
26668: IFFALSE 26862
// begin if mc_need_heal [ i ] then
26670: LD_EXP 53
26674: PUSH
26675: LD_VAR 0 2
26679: ARRAY
26680: IFFALSE 26728
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
26682: LD_VAR 0 3
26686: PUSH
26687: LD_EXP 53
26691: PUSH
26692: LD_VAR 0 2
26696: ARRAY
26697: PUSH
26698: LD_INT 1
26700: ARRAY
26701: IN
26702: PUSH
26703: LD_VAR 0 3
26707: PUSH
26708: LD_EXP 53
26712: PUSH
26713: LD_VAR 0 2
26717: ARRAY
26718: PUSH
26719: LD_INT 2
26721: ARRAY
26722: IN
26723: OR
26724: IFFALSE 26728
// continue ;
26726: GO 26667
// if IsInUnit ( j ) then
26728: LD_VAR 0 3
26732: PPUSH
26733: CALL_OW 310
26737: IFFALSE 26748
// ComExitBuilding ( j ) ;
26739: LD_VAR 0 3
26743: PPUSH
26744: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
26748: LD_VAR 0 3
26752: PUSH
26753: LD_EXP 52
26757: PUSH
26758: LD_VAR 0 2
26762: ARRAY
26763: IN
26764: NOT
26765: IFFALSE 26823
// begin SetTag ( j , 101 ) ;
26767: LD_VAR 0 3
26771: PPUSH
26772: LD_INT 101
26774: PPUSH
26775: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
26779: LD_ADDR_EXP 52
26783: PUSH
26784: LD_EXP 52
26788: PPUSH
26789: LD_VAR 0 2
26793: PUSH
26794: LD_EXP 52
26798: PUSH
26799: LD_VAR 0 2
26803: ARRAY
26804: PUSH
26805: LD_INT 1
26807: PLUS
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PPUSH
26813: LD_VAR 0 3
26817: PPUSH
26818: CALL 54555 0 3
26822: ST_TO_ADDR
// end ; wait ( 1 ) ;
26823: LD_INT 1
26825: PPUSH
26826: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
26830: LD_VAR 0 3
26834: PPUSH
26835: LD_EXP 51
26839: PUSH
26840: LD_VAR 0 2
26844: ARRAY
26845: PPUSH
26846: LD_VAR 0 3
26850: PPUSH
26851: CALL_OW 74
26855: PPUSH
26856: CALL_OW 130
// end ;
26860: GO 26667
26862: POP
26863: POP
// end ;
26864: GO 26173
26866: POP
26867: POP
// end ;
26868: LD_VAR 0 1
26872: RET
// export function MC_Heal ; var i , j , tmp ; begin
26873: LD_INT 0
26875: PPUSH
26876: PPUSH
26877: PPUSH
26878: PPUSH
// if not mc_bases then
26879: LD_EXP 50
26883: NOT
26884: IFFALSE 26888
// exit ;
26886: GO 27290
// for i = 1 to mc_bases do
26888: LD_ADDR_VAR 0 2
26892: PUSH
26893: DOUBLE
26894: LD_INT 1
26896: DEC
26897: ST_TO_ADDR
26898: LD_EXP 50
26902: PUSH
26903: FOR_TO
26904: IFFALSE 27288
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
26906: LD_EXP 53
26910: PUSH
26911: LD_VAR 0 2
26915: ARRAY
26916: PUSH
26917: LD_INT 1
26919: ARRAY
26920: NOT
26921: PUSH
26922: LD_EXP 53
26926: PUSH
26927: LD_VAR 0 2
26931: ARRAY
26932: PUSH
26933: LD_INT 2
26935: ARRAY
26936: NOT
26937: AND
26938: IFFALSE 26976
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
26940: LD_ADDR_EXP 54
26944: PUSH
26945: LD_EXP 54
26949: PPUSH
26950: LD_VAR 0 2
26954: PPUSH
26955: EMPTY
26956: PPUSH
26957: CALL_OW 1
26961: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
26962: LD_VAR 0 2
26966: PPUSH
26967: LD_INT 102
26969: PPUSH
26970: CALL 21253 0 2
// continue ;
26974: GO 26903
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
26976: LD_ADDR_VAR 0 4
26980: PUSH
26981: LD_EXP 50
26985: PUSH
26986: LD_VAR 0 2
26990: ARRAY
26991: PPUSH
26992: LD_INT 25
26994: PUSH
26995: LD_INT 4
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PPUSH
27002: CALL_OW 72
27006: ST_TO_ADDR
// if not tmp then
27007: LD_VAR 0 4
27011: NOT
27012: IFFALSE 27016
// continue ;
27014: GO 26903
// if mc_taming [ i ] then
27016: LD_EXP 81
27020: PUSH
27021: LD_VAR 0 2
27025: ARRAY
27026: IFFALSE 27050
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27028: LD_ADDR_EXP 81
27032: PUSH
27033: LD_EXP 81
27037: PPUSH
27038: LD_VAR 0 2
27042: PPUSH
27043: EMPTY
27044: PPUSH
27045: CALL_OW 1
27049: ST_TO_ADDR
// for j in tmp do
27050: LD_ADDR_VAR 0 3
27054: PUSH
27055: LD_VAR 0 4
27059: PUSH
27060: FOR_IN
27061: IFFALSE 27284
// begin if IsInUnit ( j ) then
27063: LD_VAR 0 3
27067: PPUSH
27068: CALL_OW 310
27072: IFFALSE 27083
// ComExitBuilding ( j ) ;
27074: LD_VAR 0 3
27078: PPUSH
27079: CALL_OW 122
// if not j in mc_healers [ i ] then
27083: LD_VAR 0 3
27087: PUSH
27088: LD_EXP 54
27092: PUSH
27093: LD_VAR 0 2
27097: ARRAY
27098: IN
27099: NOT
27100: IFFALSE 27146
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27102: LD_ADDR_EXP 54
27106: PUSH
27107: LD_EXP 54
27111: PPUSH
27112: LD_VAR 0 2
27116: PUSH
27117: LD_EXP 54
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: PUSH
27128: LD_INT 1
27130: PLUS
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PPUSH
27136: LD_VAR 0 3
27140: PPUSH
27141: CALL 54555 0 3
27145: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27146: LD_VAR 0 3
27150: PPUSH
27151: CALL_OW 110
27155: PUSH
27156: LD_INT 102
27158: NONEQUAL
27159: IFFALSE 27173
// SetTag ( j , 102 ) ;
27161: LD_VAR 0 3
27165: PPUSH
27166: LD_INT 102
27168: PPUSH
27169: CALL_OW 109
// Wait ( 3 ) ;
27173: LD_INT 3
27175: PPUSH
27176: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27180: LD_EXP 53
27184: PUSH
27185: LD_VAR 0 2
27189: ARRAY
27190: PUSH
27191: LD_INT 1
27193: ARRAY
27194: IFFALSE 27226
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27196: LD_VAR 0 3
27200: PPUSH
27201: LD_EXP 53
27205: PUSH
27206: LD_VAR 0 2
27210: ARRAY
27211: PUSH
27212: LD_INT 1
27214: ARRAY
27215: PUSH
27216: LD_INT 1
27218: ARRAY
27219: PPUSH
27220: CALL_OW 128
27224: GO 27282
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27226: LD_VAR 0 3
27230: PPUSH
27231: CALL_OW 314
27235: NOT
27236: PUSH
27237: LD_EXP 53
27241: PUSH
27242: LD_VAR 0 2
27246: ARRAY
27247: PUSH
27248: LD_INT 2
27250: ARRAY
27251: AND
27252: IFFALSE 27282
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
27254: LD_VAR 0 3
27258: PPUSH
27259: LD_EXP 53
27263: PUSH
27264: LD_VAR 0 2
27268: ARRAY
27269: PUSH
27270: LD_INT 2
27272: ARRAY
27273: PUSH
27274: LD_INT 1
27276: ARRAY
27277: PPUSH
27278: CALL_OW 128
// end ;
27282: GO 27060
27284: POP
27285: POP
// end ;
27286: GO 26903
27288: POP
27289: POP
// end ;
27290: LD_VAR 0 1
27294: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
27295: LD_INT 0
27297: PPUSH
27298: PPUSH
27299: PPUSH
27300: PPUSH
27301: PPUSH
// if not mc_bases then
27302: LD_EXP 50
27306: NOT
27307: IFFALSE 27311
// exit ;
27309: GO 28454
// for i = 1 to mc_bases do
27311: LD_ADDR_VAR 0 2
27315: PUSH
27316: DOUBLE
27317: LD_INT 1
27319: DEC
27320: ST_TO_ADDR
27321: LD_EXP 50
27325: PUSH
27326: FOR_TO
27327: IFFALSE 28452
// begin if mc_scan [ i ] then
27329: LD_EXP 73
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: IFFALSE 27343
// continue ;
27341: GO 27326
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
27343: LD_EXP 55
27347: PUSH
27348: LD_VAR 0 2
27352: ARRAY
27353: NOT
27354: PUSH
27355: LD_EXP 57
27359: PUSH
27360: LD_VAR 0 2
27364: ARRAY
27365: NOT
27366: AND
27367: PUSH
27368: LD_EXP 56
27372: PUSH
27373: LD_VAR 0 2
27377: ARRAY
27378: AND
27379: IFFALSE 27417
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
27381: LD_ADDR_EXP 56
27385: PUSH
27386: LD_EXP 56
27390: PPUSH
27391: LD_VAR 0 2
27395: PPUSH
27396: EMPTY
27397: PPUSH
27398: CALL_OW 1
27402: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27403: LD_VAR 0 2
27407: PPUSH
27408: LD_INT 103
27410: PPUSH
27411: CALL 21253 0 2
// continue ;
27415: GO 27326
// end ; if mc_construct_list [ i ] then
27417: LD_EXP 57
27421: PUSH
27422: LD_VAR 0 2
27426: ARRAY
27427: IFFALSE 27647
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
27429: LD_ADDR_VAR 0 4
27433: PUSH
27434: LD_EXP 50
27438: PUSH
27439: LD_VAR 0 2
27443: ARRAY
27444: PPUSH
27445: LD_INT 25
27447: PUSH
27448: LD_INT 2
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PPUSH
27455: CALL_OW 72
27459: PUSH
27460: LD_EXP 52
27464: PUSH
27465: LD_VAR 0 2
27469: ARRAY
27470: DIFF
27471: ST_TO_ADDR
// if not tmp then
27472: LD_VAR 0 4
27476: NOT
27477: IFFALSE 27481
// continue ;
27479: GO 27326
// for j in tmp do
27481: LD_ADDR_VAR 0 3
27485: PUSH
27486: LD_VAR 0 4
27490: PUSH
27491: FOR_IN
27492: IFFALSE 27643
// begin if not mc_builders [ i ] then
27494: LD_EXP 56
27498: PUSH
27499: LD_VAR 0 2
27503: ARRAY
27504: NOT
27505: IFFALSE 27563
// begin SetTag ( j , 103 ) ;
27507: LD_VAR 0 3
27511: PPUSH
27512: LD_INT 103
27514: PPUSH
27515: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
27519: LD_ADDR_EXP 56
27523: PUSH
27524: LD_EXP 56
27528: PPUSH
27529: LD_VAR 0 2
27533: PUSH
27534: LD_EXP 56
27538: PUSH
27539: LD_VAR 0 2
27543: ARRAY
27544: PUSH
27545: LD_INT 1
27547: PLUS
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PPUSH
27553: LD_VAR 0 3
27557: PPUSH
27558: CALL 54555 0 3
27562: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
27563: LD_VAR 0 3
27567: PPUSH
27568: CALL_OW 310
27572: IFFALSE 27583
// ComExitBuilding ( j ) ;
27574: LD_VAR 0 3
27578: PPUSH
27579: CALL_OW 122
// wait ( 3 ) ;
27583: LD_INT 3
27585: PPUSH
27586: CALL_OW 67
// if not mc_construct_list [ i ] then
27590: LD_EXP 57
27594: PUSH
27595: LD_VAR 0 2
27599: ARRAY
27600: NOT
27601: IFFALSE 27605
// break ;
27603: GO 27643
// if not HasTask ( j ) then
27605: LD_VAR 0 3
27609: PPUSH
27610: CALL_OW 314
27614: NOT
27615: IFFALSE 27641
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
27617: LD_VAR 0 3
27621: PPUSH
27622: LD_EXP 57
27626: PUSH
27627: LD_VAR 0 2
27631: ARRAY
27632: PUSH
27633: LD_INT 1
27635: ARRAY
27636: PPUSH
27637: CALL 57406 0 2
// end ;
27641: GO 27491
27643: POP
27644: POP
// end else
27645: GO 28450
// if mc_build_list [ i ] then
27647: LD_EXP 55
27651: PUSH
27652: LD_VAR 0 2
27656: ARRAY
27657: IFFALSE 28450
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27659: LD_ADDR_VAR 0 5
27663: PUSH
27664: LD_EXP 50
27668: PUSH
27669: LD_VAR 0 2
27673: ARRAY
27674: PPUSH
27675: LD_INT 2
27677: PUSH
27678: LD_INT 30
27680: PUSH
27681: LD_INT 0
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: PUSH
27688: LD_INT 30
27690: PUSH
27691: LD_INT 1
27693: PUSH
27694: EMPTY
27695: LIST
27696: LIST
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: LIST
27702: PPUSH
27703: CALL_OW 72
27707: ST_TO_ADDR
// if depot then
27708: LD_VAR 0 5
27712: IFFALSE 27730
// depot := depot [ 1 ] else
27714: LD_ADDR_VAR 0 5
27718: PUSH
27719: LD_VAR 0 5
27723: PUSH
27724: LD_INT 1
27726: ARRAY
27727: ST_TO_ADDR
27728: GO 27738
// depot := 0 ;
27730: LD_ADDR_VAR 0 5
27734: PUSH
27735: LD_INT 0
27737: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
27738: LD_EXP 55
27742: PUSH
27743: LD_VAR 0 2
27747: ARRAY
27748: PUSH
27749: LD_INT 1
27751: ARRAY
27752: PUSH
27753: LD_INT 1
27755: ARRAY
27756: PPUSH
27757: CALL 57236 0 1
27761: PUSH
27762: LD_EXP 50
27766: PUSH
27767: LD_VAR 0 2
27771: ARRAY
27772: PPUSH
27773: LD_INT 2
27775: PUSH
27776: LD_INT 30
27778: PUSH
27779: LD_INT 2
27781: PUSH
27782: EMPTY
27783: LIST
27784: LIST
27785: PUSH
27786: LD_INT 30
27788: PUSH
27789: LD_INT 3
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: LIST
27800: PPUSH
27801: CALL_OW 72
27805: NOT
27806: AND
27807: IFFALSE 27912
// begin for j = 1 to mc_build_list [ i ] do
27809: LD_ADDR_VAR 0 3
27813: PUSH
27814: DOUBLE
27815: LD_INT 1
27817: DEC
27818: ST_TO_ADDR
27819: LD_EXP 55
27823: PUSH
27824: LD_VAR 0 2
27828: ARRAY
27829: PUSH
27830: FOR_TO
27831: IFFALSE 27910
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
27833: LD_EXP 55
27837: PUSH
27838: LD_VAR 0 2
27842: ARRAY
27843: PUSH
27844: LD_VAR 0 3
27848: ARRAY
27849: PUSH
27850: LD_INT 1
27852: ARRAY
27853: PUSH
27854: LD_INT 2
27856: EQUAL
27857: IFFALSE 27908
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
27859: LD_ADDR_EXP 55
27863: PUSH
27864: LD_EXP 55
27868: PPUSH
27869: LD_VAR 0 2
27873: PPUSH
27874: LD_EXP 55
27878: PUSH
27879: LD_VAR 0 2
27883: ARRAY
27884: PPUSH
27885: LD_VAR 0 3
27889: PPUSH
27890: LD_INT 1
27892: PPUSH
27893: LD_INT 0
27895: PPUSH
27896: CALL 53973 0 4
27900: PPUSH
27901: CALL_OW 1
27905: ST_TO_ADDR
// break ;
27906: GO 27910
// end ;
27908: GO 27830
27910: POP
27911: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
27912: LD_EXP 55
27916: PUSH
27917: LD_VAR 0 2
27921: ARRAY
27922: PUSH
27923: LD_INT 1
27925: ARRAY
27926: PUSH
27927: LD_INT 1
27929: ARRAY
27930: PUSH
27931: LD_INT 0
27933: EQUAL
27934: PUSH
27935: LD_VAR 0 5
27939: PUSH
27940: LD_VAR 0 5
27944: PPUSH
27945: LD_EXP 55
27949: PUSH
27950: LD_VAR 0 2
27954: ARRAY
27955: PUSH
27956: LD_INT 1
27958: ARRAY
27959: PUSH
27960: LD_INT 1
27962: ARRAY
27963: PPUSH
27964: LD_EXP 55
27968: PUSH
27969: LD_VAR 0 2
27973: ARRAY
27974: PUSH
27975: LD_INT 1
27977: ARRAY
27978: PUSH
27979: LD_INT 2
27981: ARRAY
27982: PPUSH
27983: LD_EXP 55
27987: PUSH
27988: LD_VAR 0 2
27992: ARRAY
27993: PUSH
27994: LD_INT 1
27996: ARRAY
27997: PUSH
27998: LD_INT 3
28000: ARRAY
28001: PPUSH
28002: LD_EXP 55
28006: PUSH
28007: LD_VAR 0 2
28011: ARRAY
28012: PUSH
28013: LD_INT 1
28015: ARRAY
28016: PUSH
28017: LD_INT 4
28019: ARRAY
28020: PPUSH
28021: CALL 61970 0 5
28025: AND
28026: OR
28027: IFFALSE 28308
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28029: LD_ADDR_VAR 0 4
28033: PUSH
28034: LD_EXP 50
28038: PUSH
28039: LD_VAR 0 2
28043: ARRAY
28044: PPUSH
28045: LD_INT 25
28047: PUSH
28048: LD_INT 2
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PPUSH
28055: CALL_OW 72
28059: PUSH
28060: LD_EXP 52
28064: PUSH
28065: LD_VAR 0 2
28069: ARRAY
28070: DIFF
28071: ST_TO_ADDR
// if not tmp then
28072: LD_VAR 0 4
28076: NOT
28077: IFFALSE 28081
// continue ;
28079: GO 27326
// for j in tmp do
28081: LD_ADDR_VAR 0 3
28085: PUSH
28086: LD_VAR 0 4
28090: PUSH
28091: FOR_IN
28092: IFFALSE 28304
// begin if not mc_builders [ i ] then
28094: LD_EXP 56
28098: PUSH
28099: LD_VAR 0 2
28103: ARRAY
28104: NOT
28105: IFFALSE 28163
// begin SetTag ( j , 103 ) ;
28107: LD_VAR 0 3
28111: PPUSH
28112: LD_INT 103
28114: PPUSH
28115: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28119: LD_ADDR_EXP 56
28123: PUSH
28124: LD_EXP 56
28128: PPUSH
28129: LD_VAR 0 2
28133: PUSH
28134: LD_EXP 56
28138: PUSH
28139: LD_VAR 0 2
28143: ARRAY
28144: PUSH
28145: LD_INT 1
28147: PLUS
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PPUSH
28153: LD_VAR 0 3
28157: PPUSH
28158: CALL 54555 0 3
28162: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28163: LD_VAR 0 3
28167: PPUSH
28168: CALL_OW 310
28172: IFFALSE 28183
// ComExitBuilding ( j ) ;
28174: LD_VAR 0 3
28178: PPUSH
28179: CALL_OW 122
// wait ( 3 ) ;
28183: LD_INT 3
28185: PPUSH
28186: CALL_OW 67
// if not mc_build_list [ i ] then
28190: LD_EXP 55
28194: PUSH
28195: LD_VAR 0 2
28199: ARRAY
28200: NOT
28201: IFFALSE 28205
// break ;
28203: GO 28304
// if not HasTask ( j ) then
28205: LD_VAR 0 3
28209: PPUSH
28210: CALL_OW 314
28214: NOT
28215: IFFALSE 28302
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28217: LD_VAR 0 3
28221: PPUSH
28222: LD_EXP 55
28226: PUSH
28227: LD_VAR 0 2
28231: ARRAY
28232: PUSH
28233: LD_INT 1
28235: ARRAY
28236: PUSH
28237: LD_INT 1
28239: ARRAY
28240: PPUSH
28241: LD_EXP 55
28245: PUSH
28246: LD_VAR 0 2
28250: ARRAY
28251: PUSH
28252: LD_INT 1
28254: ARRAY
28255: PUSH
28256: LD_INT 2
28258: ARRAY
28259: PPUSH
28260: LD_EXP 55
28264: PUSH
28265: LD_VAR 0 2
28269: ARRAY
28270: PUSH
28271: LD_INT 1
28273: ARRAY
28274: PUSH
28275: LD_INT 3
28277: ARRAY
28278: PPUSH
28279: LD_EXP 55
28283: PUSH
28284: LD_VAR 0 2
28288: ARRAY
28289: PUSH
28290: LD_INT 1
28292: ARRAY
28293: PUSH
28294: LD_INT 4
28296: ARRAY
28297: PPUSH
28298: CALL_OW 145
// end ;
28302: GO 28091
28304: POP
28305: POP
// end else
28306: GO 28450
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
28308: LD_EXP 50
28312: PUSH
28313: LD_VAR 0 2
28317: ARRAY
28318: PPUSH
28319: LD_EXP 55
28323: PUSH
28324: LD_VAR 0 2
28328: ARRAY
28329: PUSH
28330: LD_INT 1
28332: ARRAY
28333: PUSH
28334: LD_INT 1
28336: ARRAY
28337: PPUSH
28338: LD_EXP 55
28342: PUSH
28343: LD_VAR 0 2
28347: ARRAY
28348: PUSH
28349: LD_INT 1
28351: ARRAY
28352: PUSH
28353: LD_INT 2
28355: ARRAY
28356: PPUSH
28357: LD_EXP 55
28361: PUSH
28362: LD_VAR 0 2
28366: ARRAY
28367: PUSH
28368: LD_INT 1
28370: ARRAY
28371: PUSH
28372: LD_INT 3
28374: ARRAY
28375: PPUSH
28376: LD_EXP 55
28380: PUSH
28381: LD_VAR 0 2
28385: ARRAY
28386: PUSH
28387: LD_INT 1
28389: ARRAY
28390: PUSH
28391: LD_INT 4
28393: ARRAY
28394: PPUSH
28395: CALL 61306 0 5
28399: NOT
28400: IFFALSE 28450
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
28402: LD_ADDR_EXP 55
28406: PUSH
28407: LD_EXP 55
28411: PPUSH
28412: LD_VAR 0 2
28416: PPUSH
28417: LD_EXP 55
28421: PUSH
28422: LD_VAR 0 2
28426: ARRAY
28427: PPUSH
28428: LD_INT 1
28430: PPUSH
28431: LD_INT 1
28433: NEG
28434: PPUSH
28435: LD_INT 0
28437: PPUSH
28438: CALL 53973 0 4
28442: PPUSH
28443: CALL_OW 1
28447: ST_TO_ADDR
// continue ;
28448: GO 27326
// end ; end ; end ;
28450: GO 27326
28452: POP
28453: POP
// end ;
28454: LD_VAR 0 1
28458: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
28459: LD_INT 0
28461: PPUSH
28462: PPUSH
28463: PPUSH
28464: PPUSH
28465: PPUSH
28466: PPUSH
// if not mc_bases then
28467: LD_EXP 50
28471: NOT
28472: IFFALSE 28476
// exit ;
28474: GO 28903
// for i = 1 to mc_bases do
28476: LD_ADDR_VAR 0 2
28480: PUSH
28481: DOUBLE
28482: LD_INT 1
28484: DEC
28485: ST_TO_ADDR
28486: LD_EXP 50
28490: PUSH
28491: FOR_TO
28492: IFFALSE 28901
// begin tmp := mc_build_upgrade [ i ] ;
28494: LD_ADDR_VAR 0 4
28498: PUSH
28499: LD_EXP 82
28503: PUSH
28504: LD_VAR 0 2
28508: ARRAY
28509: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
28510: LD_ADDR_VAR 0 6
28514: PUSH
28515: LD_EXP 83
28519: PUSH
28520: LD_VAR 0 2
28524: ARRAY
28525: PPUSH
28526: LD_INT 2
28528: PUSH
28529: LD_INT 30
28531: PUSH
28532: LD_INT 6
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 30
28541: PUSH
28542: LD_INT 7
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: LIST
28553: PPUSH
28554: CALL_OW 72
28558: ST_TO_ADDR
// if not tmp and not lab then
28559: LD_VAR 0 4
28563: NOT
28564: PUSH
28565: LD_VAR 0 6
28569: NOT
28570: AND
28571: IFFALSE 28575
// continue ;
28573: GO 28491
// if tmp then
28575: LD_VAR 0 4
28579: IFFALSE 28699
// for j in tmp do
28581: LD_ADDR_VAR 0 3
28585: PUSH
28586: LD_VAR 0 4
28590: PUSH
28591: FOR_IN
28592: IFFALSE 28697
// begin if UpgradeCost ( j ) then
28594: LD_VAR 0 3
28598: PPUSH
28599: CALL 60966 0 1
28603: IFFALSE 28695
// begin ComUpgrade ( j ) ;
28605: LD_VAR 0 3
28609: PPUSH
28610: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
28614: LD_ADDR_EXP 82
28618: PUSH
28619: LD_EXP 82
28623: PPUSH
28624: LD_VAR 0 2
28628: PPUSH
28629: LD_EXP 82
28633: PUSH
28634: LD_VAR 0 2
28638: ARRAY
28639: PUSH
28640: LD_VAR 0 3
28644: DIFF
28645: PPUSH
28646: CALL_OW 1
28650: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28651: LD_ADDR_EXP 57
28655: PUSH
28656: LD_EXP 57
28660: PPUSH
28661: LD_VAR 0 2
28665: PUSH
28666: LD_EXP 57
28670: PUSH
28671: LD_VAR 0 2
28675: ARRAY
28676: PUSH
28677: LD_INT 1
28679: PLUS
28680: PUSH
28681: EMPTY
28682: LIST
28683: LIST
28684: PPUSH
28685: LD_VAR 0 3
28689: PPUSH
28690: CALL 54555 0 3
28694: ST_TO_ADDR
// end ; end ;
28695: GO 28591
28697: POP
28698: POP
// if not lab or not mc_lab_upgrade [ i ] then
28699: LD_VAR 0 6
28703: NOT
28704: PUSH
28705: LD_EXP 84
28709: PUSH
28710: LD_VAR 0 2
28714: ARRAY
28715: NOT
28716: OR
28717: IFFALSE 28721
// continue ;
28719: GO 28491
// for j in lab do
28721: LD_ADDR_VAR 0 3
28725: PUSH
28726: LD_VAR 0 6
28730: PUSH
28731: FOR_IN
28732: IFFALSE 28897
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
28734: LD_VAR 0 3
28738: PPUSH
28739: CALL_OW 266
28743: PUSH
28744: LD_INT 6
28746: PUSH
28747: LD_INT 7
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: IN
28754: PUSH
28755: LD_VAR 0 3
28759: PPUSH
28760: CALL_OW 461
28764: PUSH
28765: LD_INT 1
28767: NONEQUAL
28768: AND
28769: IFFALSE 28895
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
28771: LD_VAR 0 3
28775: PPUSH
28776: LD_EXP 84
28780: PUSH
28781: LD_VAR 0 2
28785: ARRAY
28786: PUSH
28787: LD_INT 1
28789: ARRAY
28790: PPUSH
28791: CALL 61171 0 2
28795: IFFALSE 28895
// begin ComCancel ( j ) ;
28797: LD_VAR 0 3
28801: PPUSH
28802: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
28806: LD_VAR 0 3
28810: PPUSH
28811: LD_EXP 84
28815: PUSH
28816: LD_VAR 0 2
28820: ARRAY
28821: PUSH
28822: LD_INT 1
28824: ARRAY
28825: PPUSH
28826: CALL_OW 207
// if not j in mc_construct_list [ i ] then
28830: LD_VAR 0 3
28834: PUSH
28835: LD_EXP 57
28839: PUSH
28840: LD_VAR 0 2
28844: ARRAY
28845: IN
28846: NOT
28847: IFFALSE 28893
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
28849: LD_ADDR_EXP 57
28853: PUSH
28854: LD_EXP 57
28858: PPUSH
28859: LD_VAR 0 2
28863: PUSH
28864: LD_EXP 57
28868: PUSH
28869: LD_VAR 0 2
28873: ARRAY
28874: PUSH
28875: LD_INT 1
28877: PLUS
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PPUSH
28883: LD_VAR 0 3
28887: PPUSH
28888: CALL 54555 0 3
28892: ST_TO_ADDR
// break ;
28893: GO 28897
// end ; end ; end ;
28895: GO 28731
28897: POP
28898: POP
// end ;
28899: GO 28491
28901: POP
28902: POP
// end ;
28903: LD_VAR 0 1
28907: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
28908: LD_INT 0
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
// if not mc_bases then
28919: LD_EXP 50
28923: NOT
28924: IFFALSE 28928
// exit ;
28926: GO 29333
// for i = 1 to mc_bases do
28928: LD_ADDR_VAR 0 2
28932: PUSH
28933: DOUBLE
28934: LD_INT 1
28936: DEC
28937: ST_TO_ADDR
28938: LD_EXP 50
28942: PUSH
28943: FOR_TO
28944: IFFALSE 29331
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
28946: LD_EXP 58
28950: PUSH
28951: LD_VAR 0 2
28955: ARRAY
28956: NOT
28957: PUSH
28958: LD_EXP 50
28962: PUSH
28963: LD_VAR 0 2
28967: ARRAY
28968: PPUSH
28969: LD_INT 30
28971: PUSH
28972: LD_INT 3
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PPUSH
28979: CALL_OW 72
28983: NOT
28984: OR
28985: IFFALSE 28989
// continue ;
28987: GO 28943
// busy := false ;
28989: LD_ADDR_VAR 0 8
28993: PUSH
28994: LD_INT 0
28996: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28997: LD_ADDR_VAR 0 4
29001: PUSH
29002: LD_EXP 50
29006: PUSH
29007: LD_VAR 0 2
29011: ARRAY
29012: PPUSH
29013: LD_INT 30
29015: PUSH
29016: LD_INT 3
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: PPUSH
29023: CALL_OW 72
29027: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29028: LD_ADDR_VAR 0 6
29032: PUSH
29033: LD_EXP 58
29037: PUSH
29038: LD_VAR 0 2
29042: ARRAY
29043: PPUSH
29044: LD_INT 2
29046: PUSH
29047: LD_INT 30
29049: PUSH
29050: LD_INT 32
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 30
29059: PUSH
29060: LD_INT 33
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: EMPTY
29068: LIST
29069: LIST
29070: LIST
29071: PPUSH
29072: CALL_OW 72
29076: ST_TO_ADDR
// if not t then
29077: LD_VAR 0 6
29081: NOT
29082: IFFALSE 29086
// continue ;
29084: GO 28943
// for j in tmp do
29086: LD_ADDR_VAR 0 3
29090: PUSH
29091: LD_VAR 0 4
29095: PUSH
29096: FOR_IN
29097: IFFALSE 29127
// if not BuildingStatus ( j ) = bs_idle then
29099: LD_VAR 0 3
29103: PPUSH
29104: CALL_OW 461
29108: PUSH
29109: LD_INT 2
29111: EQUAL
29112: NOT
29113: IFFALSE 29125
// begin busy := true ;
29115: LD_ADDR_VAR 0 8
29119: PUSH
29120: LD_INT 1
29122: ST_TO_ADDR
// break ;
29123: GO 29127
// end ;
29125: GO 29096
29127: POP
29128: POP
// if busy then
29129: LD_VAR 0 8
29133: IFFALSE 29137
// continue ;
29135: GO 28943
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29137: LD_ADDR_VAR 0 7
29141: PUSH
29142: LD_VAR 0 6
29146: PPUSH
29147: LD_INT 35
29149: PUSH
29150: LD_INT 0
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PPUSH
29157: CALL_OW 72
29161: ST_TO_ADDR
// if tw then
29162: LD_VAR 0 7
29166: IFFALSE 29243
// begin tw := tw [ 1 ] ;
29168: LD_ADDR_VAR 0 7
29172: PUSH
29173: LD_VAR 0 7
29177: PUSH
29178: LD_INT 1
29180: ARRAY
29181: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29182: LD_ADDR_VAR 0 9
29186: PUSH
29187: LD_VAR 0 7
29191: PPUSH
29192: LD_EXP 75
29196: PUSH
29197: LD_VAR 0 2
29201: ARRAY
29202: PPUSH
29203: CALL 59525 0 2
29207: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29208: LD_EXP 89
29212: PUSH
29213: LD_VAR 0 2
29217: ARRAY
29218: IFFALSE 29241
// if not weapon in mc_allowed_tower_weapons [ i ] then
29220: LD_VAR 0 9
29224: PUSH
29225: LD_EXP 89
29229: PUSH
29230: LD_VAR 0 2
29234: ARRAY
29235: IN
29236: NOT
29237: IFFALSE 29241
// continue ;
29239: GO 28943
// end else
29241: GO 29306
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29243: LD_ADDR_VAR 0 5
29247: PUSH
29248: LD_EXP 58
29252: PUSH
29253: LD_VAR 0 2
29257: ARRAY
29258: PPUSH
29259: LD_VAR 0 4
29263: PPUSH
29264: CALL 89726 0 2
29268: ST_TO_ADDR
// if not tmp2 then
29269: LD_VAR 0 5
29273: NOT
29274: IFFALSE 29278
// continue ;
29276: GO 28943
// tw := tmp2 [ 1 ] ;
29278: LD_ADDR_VAR 0 7
29282: PUSH
29283: LD_VAR 0 5
29287: PUSH
29288: LD_INT 1
29290: ARRAY
29291: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
29292: LD_ADDR_VAR 0 9
29296: PUSH
29297: LD_VAR 0 5
29301: PUSH
29302: LD_INT 2
29304: ARRAY
29305: ST_TO_ADDR
// end ; if not weapon then
29306: LD_VAR 0 9
29310: NOT
29311: IFFALSE 29315
// continue ;
29313: GO 28943
// ComPlaceWeapon ( tw , weapon ) ;
29315: LD_VAR 0 7
29319: PPUSH
29320: LD_VAR 0 9
29324: PPUSH
29325: CALL_OW 148
// end ;
29329: GO 28943
29331: POP
29332: POP
// end ;
29333: LD_VAR 0 1
29337: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
29338: LD_INT 0
29340: PPUSH
29341: PPUSH
29342: PPUSH
29343: PPUSH
29344: PPUSH
29345: PPUSH
// if not mc_bases then
29346: LD_EXP 50
29350: NOT
29351: IFFALSE 29355
// exit ;
29353: GO 30367
// for i = 1 to mc_bases do
29355: LD_ADDR_VAR 0 2
29359: PUSH
29360: DOUBLE
29361: LD_INT 1
29363: DEC
29364: ST_TO_ADDR
29365: LD_EXP 50
29369: PUSH
29370: FOR_TO
29371: IFFALSE 30365
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
29373: LD_EXP 63
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: NOT
29384: PUSH
29385: LD_EXP 63
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_EXP 64
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: EQUAL
29407: OR
29408: IFFALSE 29412
// continue ;
29410: GO 29370
// if mc_miners [ i ] then
29412: LD_EXP 64
29416: PUSH
29417: LD_VAR 0 2
29421: ARRAY
29422: IFFALSE 30052
// begin k := 1 ;
29424: LD_ADDR_VAR 0 4
29428: PUSH
29429: LD_INT 1
29431: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
29432: LD_ADDR_VAR 0 3
29436: PUSH
29437: DOUBLE
29438: LD_EXP 64
29442: PUSH
29443: LD_VAR 0 2
29447: ARRAY
29448: INC
29449: ST_TO_ADDR
29450: LD_INT 1
29452: PUSH
29453: FOR_DOWNTO
29454: IFFALSE 30050
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
29456: LD_EXP 64
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PUSH
29467: LD_VAR 0 3
29471: ARRAY
29472: PPUSH
29473: CALL_OW 301
29477: PUSH
29478: LD_EXP 64
29482: PUSH
29483: LD_VAR 0 2
29487: ARRAY
29488: PUSH
29489: LD_VAR 0 3
29493: ARRAY
29494: PPUSH
29495: CALL_OW 257
29499: PUSH
29500: LD_INT 1
29502: NONEQUAL
29503: OR
29504: IFFALSE 29567
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
29506: LD_ADDR_VAR 0 5
29510: PUSH
29511: LD_EXP 64
29515: PUSH
29516: LD_VAR 0 2
29520: ARRAY
29521: PUSH
29522: LD_EXP 64
29526: PUSH
29527: LD_VAR 0 2
29531: ARRAY
29532: PUSH
29533: LD_VAR 0 3
29537: ARRAY
29538: DIFF
29539: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
29540: LD_ADDR_EXP 64
29544: PUSH
29545: LD_EXP 64
29549: PPUSH
29550: LD_VAR 0 2
29554: PPUSH
29555: LD_VAR 0 5
29559: PPUSH
29560: CALL_OW 1
29564: ST_TO_ADDR
// continue ;
29565: GO 29453
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
29567: LD_EXP 64
29571: PUSH
29572: LD_VAR 0 2
29576: ARRAY
29577: PUSH
29578: LD_VAR 0 3
29582: ARRAY
29583: PPUSH
29584: CALL 54491 0 1
29588: PUSH
29589: LD_EXP 64
29593: PUSH
29594: LD_VAR 0 2
29598: ARRAY
29599: PUSH
29600: LD_VAR 0 3
29604: ARRAY
29605: PPUSH
29606: CALL_OW 255
29610: PPUSH
29611: LD_EXP 63
29615: PUSH
29616: LD_VAR 0 2
29620: ARRAY
29621: PUSH
29622: LD_VAR 0 4
29626: ARRAY
29627: PUSH
29628: LD_INT 1
29630: ARRAY
29631: PPUSH
29632: LD_EXP 63
29636: PUSH
29637: LD_VAR 0 2
29641: ARRAY
29642: PUSH
29643: LD_VAR 0 4
29647: ARRAY
29648: PUSH
29649: LD_INT 2
29651: ARRAY
29652: PPUSH
29653: LD_INT 15
29655: PPUSH
29656: CALL 55451 0 4
29660: PUSH
29661: LD_INT 4
29663: ARRAY
29664: PUSH
29665: LD_EXP 64
29669: PUSH
29670: LD_VAR 0 2
29674: ARRAY
29675: PUSH
29676: LD_VAR 0 3
29680: ARRAY
29681: PPUSH
29682: LD_INT 10
29684: PPUSH
29685: CALL 57148 0 2
29689: PUSH
29690: LD_INT 4
29692: ARRAY
29693: OR
29694: AND
29695: IFFALSE 29718
// ComStop ( mc_miners [ i ] [ j ] ) ;
29697: LD_EXP 64
29701: PUSH
29702: LD_VAR 0 2
29706: ARRAY
29707: PUSH
29708: LD_VAR 0 3
29712: ARRAY
29713: PPUSH
29714: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
29718: LD_EXP 64
29722: PUSH
29723: LD_VAR 0 2
29727: ARRAY
29728: PUSH
29729: LD_VAR 0 3
29733: ARRAY
29734: PPUSH
29735: CALL_OW 257
29739: PUSH
29740: LD_INT 1
29742: EQUAL
29743: PUSH
29744: LD_EXP 64
29748: PUSH
29749: LD_VAR 0 2
29753: ARRAY
29754: PUSH
29755: LD_VAR 0 3
29759: ARRAY
29760: PPUSH
29761: CALL_OW 459
29765: NOT
29766: AND
29767: PUSH
29768: LD_EXP 64
29772: PUSH
29773: LD_VAR 0 2
29777: ARRAY
29778: PUSH
29779: LD_VAR 0 3
29783: ARRAY
29784: PPUSH
29785: CALL_OW 255
29789: PPUSH
29790: LD_EXP 63
29794: PUSH
29795: LD_VAR 0 2
29799: ARRAY
29800: PUSH
29801: LD_VAR 0 4
29805: ARRAY
29806: PUSH
29807: LD_INT 1
29809: ARRAY
29810: PPUSH
29811: LD_EXP 63
29815: PUSH
29816: LD_VAR 0 2
29820: ARRAY
29821: PUSH
29822: LD_VAR 0 4
29826: ARRAY
29827: PUSH
29828: LD_INT 2
29830: ARRAY
29831: PPUSH
29832: LD_INT 15
29834: PPUSH
29835: CALL 55451 0 4
29839: PUSH
29840: LD_INT 4
29842: ARRAY
29843: PUSH
29844: LD_INT 0
29846: EQUAL
29847: AND
29848: PUSH
29849: LD_EXP 64
29853: PUSH
29854: LD_VAR 0 2
29858: ARRAY
29859: PUSH
29860: LD_VAR 0 3
29864: ARRAY
29865: PPUSH
29866: CALL_OW 314
29870: NOT
29871: AND
29872: IFFALSE 30048
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
29874: LD_EXP 64
29878: PUSH
29879: LD_VAR 0 2
29883: ARRAY
29884: PUSH
29885: LD_VAR 0 3
29889: ARRAY
29890: PPUSH
29891: CALL_OW 310
29895: IFFALSE 29918
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
29897: LD_EXP 64
29901: PUSH
29902: LD_VAR 0 2
29906: ARRAY
29907: PUSH
29908: LD_VAR 0 3
29912: ARRAY
29913: PPUSH
29914: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
29918: LD_EXP 64
29922: PUSH
29923: LD_VAR 0 2
29927: ARRAY
29928: PUSH
29929: LD_VAR 0 3
29933: ARRAY
29934: PPUSH
29935: CALL_OW 314
29939: NOT
29940: IFFALSE 30008
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
29942: LD_EXP 64
29946: PUSH
29947: LD_VAR 0 2
29951: ARRAY
29952: PUSH
29953: LD_VAR 0 3
29957: ARRAY
29958: PPUSH
29959: LD_EXP 63
29963: PUSH
29964: LD_VAR 0 2
29968: ARRAY
29969: PUSH
29970: LD_VAR 0 4
29974: ARRAY
29975: PUSH
29976: LD_INT 1
29978: ARRAY
29979: PPUSH
29980: LD_EXP 63
29984: PUSH
29985: LD_VAR 0 2
29989: ARRAY
29990: PUSH
29991: LD_VAR 0 4
29995: ARRAY
29996: PUSH
29997: LD_INT 2
29999: ARRAY
30000: PPUSH
30001: LD_INT 0
30003: PPUSH
30004: CALL_OW 193
// k := k + 1 ;
30008: LD_ADDR_VAR 0 4
30012: PUSH
30013: LD_VAR 0 4
30017: PUSH
30018: LD_INT 1
30020: PLUS
30021: ST_TO_ADDR
// if k > mc_mines [ i ] then
30022: LD_VAR 0 4
30026: PUSH
30027: LD_EXP 63
30031: PUSH
30032: LD_VAR 0 2
30036: ARRAY
30037: GREATER
30038: IFFALSE 30048
// k := 1 ;
30040: LD_ADDR_VAR 0 4
30044: PUSH
30045: LD_INT 1
30047: ST_TO_ADDR
// end ; end ;
30048: GO 29453
30050: POP
30051: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30052: LD_ADDR_VAR 0 5
30056: PUSH
30057: LD_EXP 50
30061: PUSH
30062: LD_VAR 0 2
30066: ARRAY
30067: PPUSH
30068: LD_INT 2
30070: PUSH
30071: LD_INT 30
30073: PUSH
30074: LD_INT 4
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 30
30083: PUSH
30084: LD_INT 5
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 30
30093: PUSH
30094: LD_INT 32
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: PPUSH
30107: CALL_OW 72
30111: ST_TO_ADDR
// if not tmp then
30112: LD_VAR 0 5
30116: NOT
30117: IFFALSE 30121
// continue ;
30119: GO 29370
// list := [ ] ;
30121: LD_ADDR_VAR 0 6
30125: PUSH
30126: EMPTY
30127: ST_TO_ADDR
// for j in tmp do
30128: LD_ADDR_VAR 0 3
30132: PUSH
30133: LD_VAR 0 5
30137: PUSH
30138: FOR_IN
30139: IFFALSE 30208
// begin for k in UnitsInside ( j ) do
30141: LD_ADDR_VAR 0 4
30145: PUSH
30146: LD_VAR 0 3
30150: PPUSH
30151: CALL_OW 313
30155: PUSH
30156: FOR_IN
30157: IFFALSE 30204
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30159: LD_VAR 0 4
30163: PPUSH
30164: CALL_OW 257
30168: PUSH
30169: LD_INT 1
30171: EQUAL
30172: PUSH
30173: LD_VAR 0 4
30177: PPUSH
30178: CALL_OW 459
30182: NOT
30183: AND
30184: IFFALSE 30202
// list := list ^ k ;
30186: LD_ADDR_VAR 0 6
30190: PUSH
30191: LD_VAR 0 6
30195: PUSH
30196: LD_VAR 0 4
30200: ADD
30201: ST_TO_ADDR
30202: GO 30156
30204: POP
30205: POP
// end ;
30206: GO 30138
30208: POP
30209: POP
// list := list diff mc_miners [ i ] ;
30210: LD_ADDR_VAR 0 6
30214: PUSH
30215: LD_VAR 0 6
30219: PUSH
30220: LD_EXP 64
30224: PUSH
30225: LD_VAR 0 2
30229: ARRAY
30230: DIFF
30231: ST_TO_ADDR
// if not list then
30232: LD_VAR 0 6
30236: NOT
30237: IFFALSE 30241
// continue ;
30239: GO 29370
// k := mc_mines [ i ] - mc_miners [ i ] ;
30241: LD_ADDR_VAR 0 4
30245: PUSH
30246: LD_EXP 63
30250: PUSH
30251: LD_VAR 0 2
30255: ARRAY
30256: PUSH
30257: LD_EXP 64
30261: PUSH
30262: LD_VAR 0 2
30266: ARRAY
30267: MINUS
30268: ST_TO_ADDR
// if k > list then
30269: LD_VAR 0 4
30273: PUSH
30274: LD_VAR 0 6
30278: GREATER
30279: IFFALSE 30291
// k := list ;
30281: LD_ADDR_VAR 0 4
30285: PUSH
30286: LD_VAR 0 6
30290: ST_TO_ADDR
// for j = 1 to k do
30291: LD_ADDR_VAR 0 3
30295: PUSH
30296: DOUBLE
30297: LD_INT 1
30299: DEC
30300: ST_TO_ADDR
30301: LD_VAR 0 4
30305: PUSH
30306: FOR_TO
30307: IFFALSE 30361
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30309: LD_ADDR_EXP 64
30313: PUSH
30314: LD_EXP 64
30318: PPUSH
30319: LD_VAR 0 2
30323: PUSH
30324: LD_EXP 64
30328: PUSH
30329: LD_VAR 0 2
30333: ARRAY
30334: PUSH
30335: LD_INT 1
30337: PLUS
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PPUSH
30343: LD_VAR 0 6
30347: PUSH
30348: LD_VAR 0 3
30352: ARRAY
30353: PPUSH
30354: CALL 54555 0 3
30358: ST_TO_ADDR
30359: GO 30306
30361: POP
30362: POP
// end ;
30363: GO 29370
30365: POP
30366: POP
// end ;
30367: LD_VAR 0 1
30371: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30372: LD_INT 0
30374: PPUSH
30375: PPUSH
30376: PPUSH
30377: PPUSH
30378: PPUSH
30379: PPUSH
30380: PPUSH
30381: PPUSH
30382: PPUSH
30383: PPUSH
// if not mc_bases then
30384: LD_EXP 50
30388: NOT
30389: IFFALSE 30393
// exit ;
30391: GO 32143
// for i = 1 to mc_bases do
30393: LD_ADDR_VAR 0 2
30397: PUSH
30398: DOUBLE
30399: LD_INT 1
30401: DEC
30402: ST_TO_ADDR
30403: LD_EXP 50
30407: PUSH
30408: FOR_TO
30409: IFFALSE 32141
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30411: LD_EXP 50
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: NOT
30422: PUSH
30423: LD_EXP 57
30427: PUSH
30428: LD_VAR 0 2
30432: ARRAY
30433: OR
30434: IFFALSE 30438
// continue ;
30436: GO 30408
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30438: LD_EXP 66
30442: PUSH
30443: LD_VAR 0 2
30447: ARRAY
30448: NOT
30449: PUSH
30450: LD_EXP 67
30454: PUSH
30455: LD_VAR 0 2
30459: ARRAY
30460: AND
30461: IFFALSE 30499
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30463: LD_ADDR_EXP 67
30467: PUSH
30468: LD_EXP 67
30472: PPUSH
30473: LD_VAR 0 2
30477: PPUSH
30478: EMPTY
30479: PPUSH
30480: CALL_OW 1
30484: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
30485: LD_VAR 0 2
30489: PPUSH
30490: LD_INT 107
30492: PPUSH
30493: CALL 21253 0 2
// continue ;
30497: GO 30408
// end ; target := [ ] ;
30499: LD_ADDR_VAR 0 6
30503: PUSH
30504: EMPTY
30505: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
30506: LD_ADDR_VAR 0 3
30510: PUSH
30511: DOUBLE
30512: LD_EXP 66
30516: PUSH
30517: LD_VAR 0 2
30521: ARRAY
30522: INC
30523: ST_TO_ADDR
30524: LD_INT 1
30526: PUSH
30527: FOR_DOWNTO
30528: IFFALSE 30788
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
30530: LD_EXP 66
30534: PUSH
30535: LD_VAR 0 2
30539: ARRAY
30540: PUSH
30541: LD_VAR 0 3
30545: ARRAY
30546: PUSH
30547: LD_INT 2
30549: ARRAY
30550: PPUSH
30551: LD_EXP 66
30555: PUSH
30556: LD_VAR 0 2
30560: ARRAY
30561: PUSH
30562: LD_VAR 0 3
30566: ARRAY
30567: PUSH
30568: LD_INT 3
30570: ARRAY
30571: PPUSH
30572: CALL_OW 488
30576: PUSH
30577: LD_EXP 66
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PUSH
30588: LD_VAR 0 3
30592: ARRAY
30593: PUSH
30594: LD_INT 2
30596: ARRAY
30597: PPUSH
30598: LD_EXP 66
30602: PUSH
30603: LD_VAR 0 2
30607: ARRAY
30608: PUSH
30609: LD_VAR 0 3
30613: ARRAY
30614: PUSH
30615: LD_INT 3
30617: ARRAY
30618: PPUSH
30619: CALL_OW 284
30623: PUSH
30624: LD_INT 0
30626: EQUAL
30627: AND
30628: IFFALSE 30683
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
30630: LD_ADDR_VAR 0 5
30634: PUSH
30635: LD_EXP 66
30639: PUSH
30640: LD_VAR 0 2
30644: ARRAY
30645: PPUSH
30646: LD_VAR 0 3
30650: PPUSH
30651: CALL_OW 3
30655: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
30656: LD_ADDR_EXP 66
30660: PUSH
30661: LD_EXP 66
30665: PPUSH
30666: LD_VAR 0 2
30670: PPUSH
30671: LD_VAR 0 5
30675: PPUSH
30676: CALL_OW 1
30680: ST_TO_ADDR
// continue ;
30681: GO 30527
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
30683: LD_EXP 50
30687: PUSH
30688: LD_VAR 0 2
30692: ARRAY
30693: PUSH
30694: LD_INT 1
30696: ARRAY
30697: PPUSH
30698: CALL_OW 255
30702: PPUSH
30703: LD_EXP 66
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PUSH
30714: LD_VAR 0 3
30718: ARRAY
30719: PUSH
30720: LD_INT 2
30722: ARRAY
30723: PPUSH
30724: LD_EXP 66
30728: PUSH
30729: LD_VAR 0 2
30733: ARRAY
30734: PUSH
30735: LD_VAR 0 3
30739: ARRAY
30740: PUSH
30741: LD_INT 3
30743: ARRAY
30744: PPUSH
30745: LD_INT 30
30747: PPUSH
30748: CALL 55451 0 4
30752: PUSH
30753: LD_INT 4
30755: ARRAY
30756: PUSH
30757: LD_INT 0
30759: EQUAL
30760: IFFALSE 30786
// begin target := mc_crates [ i ] [ j ] ;
30762: LD_ADDR_VAR 0 6
30766: PUSH
30767: LD_EXP 66
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_VAR 0 3
30782: ARRAY
30783: ST_TO_ADDR
// break ;
30784: GO 30788
// end ; end ;
30786: GO 30527
30788: POP
30789: POP
// if not target then
30790: LD_VAR 0 6
30794: NOT
30795: IFFALSE 30799
// continue ;
30797: GO 30408
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
30799: LD_ADDR_VAR 0 7
30803: PUSH
30804: LD_EXP 69
30808: PUSH
30809: LD_VAR 0 2
30813: ARRAY
30814: PPUSH
30815: LD_INT 2
30817: PUSH
30818: LD_INT 3
30820: PUSH
30821: LD_INT 58
30823: PUSH
30824: EMPTY
30825: LIST
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 61
30833: PUSH
30834: EMPTY
30835: LIST
30836: PUSH
30837: LD_INT 33
30839: PUSH
30840: LD_INT 5
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 33
30849: PUSH
30850: LD_INT 3
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: LD_INT 34
30869: PUSH
30870: LD_INT 32
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 34
30879: PUSH
30880: LD_INT 51
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 34
30889: PUSH
30890: LD_INT 12
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PPUSH
30907: CALL_OW 72
30911: ST_TO_ADDR
// if not cargo then
30912: LD_VAR 0 7
30916: NOT
30917: IFFALSE 31560
// begin if mc_crates_collector [ i ] < 5 then
30919: LD_EXP 67
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: PUSH
30930: LD_INT 5
30932: LESS
30933: IFFALSE 31299
// begin if mc_ape [ i ] then
30935: LD_EXP 79
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: IFFALSE 30992
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
30947: LD_ADDR_VAR 0 5
30951: PUSH
30952: LD_EXP 79
30956: PUSH
30957: LD_VAR 0 2
30961: ARRAY
30962: PPUSH
30963: LD_INT 25
30965: PUSH
30966: LD_INT 16
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 24
30975: PUSH
30976: LD_INT 750
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PPUSH
30987: CALL_OW 72
30991: ST_TO_ADDR
// if not tmp then
30992: LD_VAR 0 5
30996: NOT
30997: IFFALSE 31044
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
30999: LD_ADDR_VAR 0 5
31003: PUSH
31004: LD_EXP 50
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PPUSH
31015: LD_INT 25
31017: PUSH
31018: LD_INT 2
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 24
31027: PUSH
31028: LD_INT 750
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PPUSH
31039: CALL_OW 72
31043: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31044: LD_EXP 79
31048: PUSH
31049: LD_VAR 0 2
31053: ARRAY
31054: PUSH
31055: LD_EXP 50
31059: PUSH
31060: LD_VAR 0 2
31064: ARRAY
31065: PPUSH
31066: LD_INT 25
31068: PUSH
31069: LD_INT 2
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 24
31078: PUSH
31079: LD_INT 750
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PPUSH
31090: CALL_OW 72
31094: AND
31095: PUSH
31096: LD_VAR 0 5
31100: PUSH
31101: LD_INT 5
31103: LESS
31104: AND
31105: IFFALSE 31187
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31107: LD_ADDR_VAR 0 3
31111: PUSH
31112: LD_EXP 50
31116: PUSH
31117: LD_VAR 0 2
31121: ARRAY
31122: PPUSH
31123: LD_INT 25
31125: PUSH
31126: LD_INT 2
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 24
31135: PUSH
31136: LD_INT 750
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PPUSH
31147: CALL_OW 72
31151: PUSH
31152: FOR_IN
31153: IFFALSE 31185
// begin tmp := tmp union j ;
31155: LD_ADDR_VAR 0 5
31159: PUSH
31160: LD_VAR 0 5
31164: PUSH
31165: LD_VAR 0 3
31169: UNION
31170: ST_TO_ADDR
// if tmp >= 5 then
31171: LD_VAR 0 5
31175: PUSH
31176: LD_INT 5
31178: GREATEREQUAL
31179: IFFALSE 31183
// break ;
31181: GO 31185
// end ;
31183: GO 31152
31185: POP
31186: POP
// end ; if not tmp then
31187: LD_VAR 0 5
31191: NOT
31192: IFFALSE 31196
// continue ;
31194: GO 30408
// for j in tmp do
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 5
31205: PUSH
31206: FOR_IN
31207: IFFALSE 31297
// if not GetTag ( j ) then
31209: LD_VAR 0 3
31213: PPUSH
31214: CALL_OW 110
31218: NOT
31219: IFFALSE 31295
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31221: LD_ADDR_EXP 67
31225: PUSH
31226: LD_EXP 67
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_EXP 67
31240: PUSH
31241: LD_VAR 0 2
31245: ARRAY
31246: PUSH
31247: LD_INT 1
31249: PLUS
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PPUSH
31255: LD_VAR 0 3
31259: PPUSH
31260: CALL 54555 0 3
31264: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31265: LD_VAR 0 3
31269: PPUSH
31270: LD_INT 107
31272: PPUSH
31273: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31277: LD_EXP 67
31281: PUSH
31282: LD_VAR 0 2
31286: ARRAY
31287: PUSH
31288: LD_INT 5
31290: GREATEREQUAL
31291: IFFALSE 31295
// break ;
31293: GO 31297
// end ;
31295: GO 31206
31297: POP
31298: POP
// end ; if mc_crates_collector [ i ] and target then
31299: LD_EXP 67
31303: PUSH
31304: LD_VAR 0 2
31308: ARRAY
31309: PUSH
31310: LD_VAR 0 6
31314: AND
31315: IFFALSE 31558
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31317: LD_EXP 67
31321: PUSH
31322: LD_VAR 0 2
31326: ARRAY
31327: PUSH
31328: LD_VAR 0 6
31332: PUSH
31333: LD_INT 1
31335: ARRAY
31336: LESS
31337: IFFALSE 31357
// tmp := mc_crates_collector [ i ] else
31339: LD_ADDR_VAR 0 5
31343: PUSH
31344: LD_EXP 67
31348: PUSH
31349: LD_VAR 0 2
31353: ARRAY
31354: ST_TO_ADDR
31355: GO 31371
// tmp := target [ 1 ] ;
31357: LD_ADDR_VAR 0 5
31361: PUSH
31362: LD_VAR 0 6
31366: PUSH
31367: LD_INT 1
31369: ARRAY
31370: ST_TO_ADDR
// k := 0 ;
31371: LD_ADDR_VAR 0 4
31375: PUSH
31376: LD_INT 0
31378: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31379: LD_ADDR_VAR 0 3
31383: PUSH
31384: LD_EXP 67
31388: PUSH
31389: LD_VAR 0 2
31393: ARRAY
31394: PUSH
31395: FOR_IN
31396: IFFALSE 31556
// begin k := k + 1 ;
31398: LD_ADDR_VAR 0 4
31402: PUSH
31403: LD_VAR 0 4
31407: PUSH
31408: LD_INT 1
31410: PLUS
31411: ST_TO_ADDR
// if k > tmp then
31412: LD_VAR 0 4
31416: PUSH
31417: LD_VAR 0 5
31421: GREATER
31422: IFFALSE 31426
// break ;
31424: GO 31556
// if not GetClass ( j ) in [ 2 , 16 ] then
31426: LD_VAR 0 3
31430: PPUSH
31431: CALL_OW 257
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: LD_INT 16
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: IN
31446: NOT
31447: IFFALSE 31500
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31449: LD_ADDR_EXP 67
31453: PUSH
31454: LD_EXP 67
31458: PPUSH
31459: LD_VAR 0 2
31463: PPUSH
31464: LD_EXP 67
31468: PUSH
31469: LD_VAR 0 2
31473: ARRAY
31474: PUSH
31475: LD_VAR 0 3
31479: DIFF
31480: PPUSH
31481: CALL_OW 1
31485: ST_TO_ADDR
// SetTag ( j , 0 ) ;
31486: LD_VAR 0 3
31490: PPUSH
31491: LD_INT 0
31493: PPUSH
31494: CALL_OW 109
// continue ;
31498: GO 31395
// end ; if IsInUnit ( j ) then
31500: LD_VAR 0 3
31504: PPUSH
31505: CALL_OW 310
31509: IFFALSE 31520
// ComExitBuilding ( j ) ;
31511: LD_VAR 0 3
31515: PPUSH
31516: CALL_OW 122
// wait ( 3 ) ;
31520: LD_INT 3
31522: PPUSH
31523: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
31527: LD_VAR 0 3
31531: PPUSH
31532: LD_VAR 0 6
31536: PUSH
31537: LD_INT 2
31539: ARRAY
31540: PPUSH
31541: LD_VAR 0 6
31545: PUSH
31546: LD_INT 3
31548: ARRAY
31549: PPUSH
31550: CALL_OW 117
// end ;
31554: GO 31395
31556: POP
31557: POP
// end ; end else
31558: GO 32139
// begin for j in cargo do
31560: LD_ADDR_VAR 0 3
31564: PUSH
31565: LD_VAR 0 7
31569: PUSH
31570: FOR_IN
31571: IFFALSE 32137
// begin if GetTag ( j ) <> 0 then
31573: LD_VAR 0 3
31577: PPUSH
31578: CALL_OW 110
31582: PUSH
31583: LD_INT 0
31585: NONEQUAL
31586: IFFALSE 31590
// continue ;
31588: GO 31570
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
31590: LD_VAR 0 3
31594: PPUSH
31595: CALL_OW 256
31599: PUSH
31600: LD_INT 1000
31602: LESS
31603: PUSH
31604: LD_VAR 0 3
31608: PPUSH
31609: LD_EXP 74
31613: PUSH
31614: LD_VAR 0 2
31618: ARRAY
31619: PPUSH
31620: CALL_OW 308
31624: NOT
31625: AND
31626: IFFALSE 31648
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31628: LD_VAR 0 3
31632: PPUSH
31633: LD_EXP 74
31637: PUSH
31638: LD_VAR 0 2
31642: ARRAY
31643: PPUSH
31644: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
31648: LD_VAR 0 3
31652: PPUSH
31653: CALL_OW 256
31657: PUSH
31658: LD_INT 1000
31660: LESS
31661: PUSH
31662: LD_VAR 0 3
31666: PPUSH
31667: LD_EXP 74
31671: PUSH
31672: LD_VAR 0 2
31676: ARRAY
31677: PPUSH
31678: CALL_OW 308
31682: AND
31683: IFFALSE 31687
// continue ;
31685: GO 31570
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
31687: LD_VAR 0 3
31691: PPUSH
31692: CALL_OW 262
31696: PUSH
31697: LD_INT 2
31699: EQUAL
31700: PUSH
31701: LD_VAR 0 3
31705: PPUSH
31706: CALL_OW 261
31710: PUSH
31711: LD_INT 15
31713: LESS
31714: AND
31715: IFFALSE 31719
// continue ;
31717: GO 31570
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
31719: LD_VAR 0 3
31723: PPUSH
31724: CALL_OW 262
31728: PUSH
31729: LD_INT 1
31731: EQUAL
31732: PUSH
31733: LD_VAR 0 3
31737: PPUSH
31738: CALL_OW 261
31742: PUSH
31743: LD_INT 10
31745: LESS
31746: AND
31747: IFFALSE 32076
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31749: LD_ADDR_VAR 0 8
31753: PUSH
31754: LD_EXP 50
31758: PUSH
31759: LD_VAR 0 2
31763: ARRAY
31764: PPUSH
31765: LD_INT 2
31767: PUSH
31768: LD_INT 30
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 30
31780: PUSH
31781: LD_INT 1
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: LIST
31792: PPUSH
31793: CALL_OW 72
31797: ST_TO_ADDR
// if not depot then
31798: LD_VAR 0 8
31802: NOT
31803: IFFALSE 31807
// continue ;
31805: GO 31570
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
31807: LD_VAR 0 3
31811: PPUSH
31812: LD_VAR 0 8
31816: PPUSH
31817: LD_VAR 0 3
31821: PPUSH
31822: CALL_OW 74
31826: PPUSH
31827: CALL_OW 296
31831: PUSH
31832: LD_INT 6
31834: LESS
31835: IFFALSE 31851
// SetFuel ( j , 100 ) else
31837: LD_VAR 0 3
31841: PPUSH
31842: LD_INT 100
31844: PPUSH
31845: CALL_OW 240
31849: GO 32076
// if GetFuel ( j ) = 0 then
31851: LD_VAR 0 3
31855: PPUSH
31856: CALL_OW 261
31860: PUSH
31861: LD_INT 0
31863: EQUAL
31864: IFFALSE 32076
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
31866: LD_ADDR_EXP 69
31870: PUSH
31871: LD_EXP 69
31875: PPUSH
31876: LD_VAR 0 2
31880: PPUSH
31881: LD_EXP 69
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: PUSH
31892: LD_VAR 0 3
31896: DIFF
31897: PPUSH
31898: CALL_OW 1
31902: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
31903: LD_VAR 0 3
31907: PPUSH
31908: CALL_OW 263
31912: PUSH
31913: LD_INT 1
31915: EQUAL
31916: IFFALSE 31932
// ComExitVehicle ( IsInUnit ( j ) ) ;
31918: LD_VAR 0 3
31922: PPUSH
31923: CALL_OW 310
31927: PPUSH
31928: CALL_OW 121
// if GetControl ( j ) = control_remote then
31932: LD_VAR 0 3
31936: PPUSH
31937: CALL_OW 263
31941: PUSH
31942: LD_INT 2
31944: EQUAL
31945: IFFALSE 31956
// ComUnlink ( j ) ;
31947: LD_VAR 0 3
31951: PPUSH
31952: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
31956: LD_ADDR_VAR 0 9
31960: PUSH
31961: LD_VAR 0 2
31965: PPUSH
31966: LD_INT 3
31968: PPUSH
31969: CALL 41429 0 2
31973: ST_TO_ADDR
// if fac then
31974: LD_VAR 0 9
31978: IFFALSE 32074
// begin for k in fac do
31980: LD_ADDR_VAR 0 4
31984: PUSH
31985: LD_VAR 0 9
31989: PUSH
31990: FOR_IN
31991: IFFALSE 32072
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
31993: LD_ADDR_VAR 0 10
31997: PUSH
31998: LD_VAR 0 9
32002: PPUSH
32003: LD_VAR 0 3
32007: PPUSH
32008: CALL_OW 265
32012: PPUSH
32013: LD_VAR 0 3
32017: PPUSH
32018: CALL_OW 262
32022: PPUSH
32023: LD_VAR 0 3
32027: PPUSH
32028: CALL_OW 263
32032: PPUSH
32033: LD_VAR 0 3
32037: PPUSH
32038: CALL_OW 264
32042: PPUSH
32043: CALL 52087 0 5
32047: ST_TO_ADDR
// if components then
32048: LD_VAR 0 10
32052: IFFALSE 32070
// begin MC_InsertProduceList ( i , components ) ;
32054: LD_VAR 0 2
32058: PPUSH
32059: LD_VAR 0 10
32063: PPUSH
32064: CALL 40974 0 2
// break ;
32068: GO 32072
// end ; end ;
32070: GO 31990
32072: POP
32073: POP
// end ; continue ;
32074: GO 31570
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32076: LD_VAR 0 3
32080: PPUSH
32081: LD_INT 1
32083: PPUSH
32084: CALL_OW 289
32088: PUSH
32089: LD_INT 100
32091: LESS
32092: PUSH
32093: LD_VAR 0 3
32097: PPUSH
32098: CALL_OW 314
32102: NOT
32103: AND
32104: IFFALSE 32133
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32106: LD_VAR 0 3
32110: PPUSH
32111: LD_VAR 0 6
32115: PUSH
32116: LD_INT 2
32118: ARRAY
32119: PPUSH
32120: LD_VAR 0 6
32124: PUSH
32125: LD_INT 3
32127: ARRAY
32128: PPUSH
32129: CALL_OW 117
// break ;
32133: GO 32137
// end ;
32135: GO 31570
32137: POP
32138: POP
// end ; end ;
32139: GO 30408
32141: POP
32142: POP
// end ;
32143: LD_VAR 0 1
32147: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32148: LD_INT 0
32150: PPUSH
32151: PPUSH
32152: PPUSH
32153: PPUSH
// if not mc_bases then
32154: LD_EXP 50
32158: NOT
32159: IFFALSE 32163
// exit ;
32161: GO 32324
// for i = 1 to mc_bases do
32163: LD_ADDR_VAR 0 2
32167: PUSH
32168: DOUBLE
32169: LD_INT 1
32171: DEC
32172: ST_TO_ADDR
32173: LD_EXP 50
32177: PUSH
32178: FOR_TO
32179: IFFALSE 32322
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32181: LD_ADDR_VAR 0 4
32185: PUSH
32186: LD_EXP 69
32190: PUSH
32191: LD_VAR 0 2
32195: ARRAY
32196: PUSH
32197: LD_EXP 72
32201: PUSH
32202: LD_VAR 0 2
32206: ARRAY
32207: UNION
32208: PPUSH
32209: LD_INT 33
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PPUSH
32219: CALL_OW 72
32223: ST_TO_ADDR
// if tmp then
32224: LD_VAR 0 4
32228: IFFALSE 32320
// for j in tmp do
32230: LD_ADDR_VAR 0 3
32234: PUSH
32235: LD_VAR 0 4
32239: PUSH
32240: FOR_IN
32241: IFFALSE 32318
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32243: LD_VAR 0 3
32247: PPUSH
32248: CALL_OW 312
32252: NOT
32253: PUSH
32254: LD_VAR 0 3
32258: PPUSH
32259: CALL_OW 256
32263: PUSH
32264: LD_INT 250
32266: GREATEREQUAL
32267: AND
32268: IFFALSE 32281
// Connect ( j ) else
32270: LD_VAR 0 3
32274: PPUSH
32275: CALL 57488 0 1
32279: GO 32316
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32281: LD_VAR 0 3
32285: PPUSH
32286: CALL_OW 256
32290: PUSH
32291: LD_INT 250
32293: LESS
32294: PUSH
32295: LD_VAR 0 3
32299: PPUSH
32300: CALL_OW 312
32304: AND
32305: IFFALSE 32316
// ComUnlink ( j ) ;
32307: LD_VAR 0 3
32311: PPUSH
32312: CALL_OW 136
32316: GO 32240
32318: POP
32319: POP
// end ;
32320: GO 32178
32322: POP
32323: POP
// end ;
32324: LD_VAR 0 1
32328: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32329: LD_INT 0
32331: PPUSH
32332: PPUSH
32333: PPUSH
32334: PPUSH
32335: PPUSH
// if not mc_bases then
32336: LD_EXP 50
32340: NOT
32341: IFFALSE 32345
// exit ;
32343: GO 32790
// for i = 1 to mc_bases do
32345: LD_ADDR_VAR 0 2
32349: PUSH
32350: DOUBLE
32351: LD_INT 1
32353: DEC
32354: ST_TO_ADDR
32355: LD_EXP 50
32359: PUSH
32360: FOR_TO
32361: IFFALSE 32788
// begin if not mc_produce [ i ] then
32363: LD_EXP 71
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: NOT
32374: IFFALSE 32378
// continue ;
32376: GO 32360
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32378: LD_ADDR_VAR 0 5
32382: PUSH
32383: LD_EXP 50
32387: PUSH
32388: LD_VAR 0 2
32392: ARRAY
32393: PPUSH
32394: LD_INT 30
32396: PUSH
32397: LD_INT 3
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PPUSH
32404: CALL_OW 72
32408: ST_TO_ADDR
// if not fac then
32409: LD_VAR 0 5
32413: NOT
32414: IFFALSE 32418
// continue ;
32416: GO 32360
// for j in fac do
32418: LD_ADDR_VAR 0 3
32422: PUSH
32423: LD_VAR 0 5
32427: PUSH
32428: FOR_IN
32429: IFFALSE 32784
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32431: LD_VAR 0 3
32435: PPUSH
32436: CALL_OW 461
32440: PUSH
32441: LD_INT 2
32443: NONEQUAL
32444: PUSH
32445: LD_VAR 0 3
32449: PPUSH
32450: LD_INT 15
32452: PPUSH
32453: CALL 57148 0 2
32457: PUSH
32458: LD_INT 4
32460: ARRAY
32461: OR
32462: IFFALSE 32466
// continue ;
32464: GO 32428
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32466: LD_VAR 0 3
32470: PPUSH
32471: LD_EXP 71
32475: PUSH
32476: LD_VAR 0 2
32480: ARRAY
32481: PUSH
32482: LD_INT 1
32484: ARRAY
32485: PUSH
32486: LD_INT 1
32488: ARRAY
32489: PPUSH
32490: LD_EXP 71
32494: PUSH
32495: LD_VAR 0 2
32499: ARRAY
32500: PUSH
32501: LD_INT 1
32503: ARRAY
32504: PUSH
32505: LD_INT 2
32507: ARRAY
32508: PPUSH
32509: LD_EXP 71
32513: PUSH
32514: LD_VAR 0 2
32518: ARRAY
32519: PUSH
32520: LD_INT 1
32522: ARRAY
32523: PUSH
32524: LD_INT 3
32526: ARRAY
32527: PPUSH
32528: LD_EXP 71
32532: PUSH
32533: LD_VAR 0 2
32537: ARRAY
32538: PUSH
32539: LD_INT 1
32541: ARRAY
32542: PUSH
32543: LD_INT 4
32545: ARRAY
32546: PPUSH
32547: CALL_OW 448
32551: PUSH
32552: LD_VAR 0 3
32556: PPUSH
32557: LD_EXP 71
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: PUSH
32568: LD_INT 1
32570: ARRAY
32571: PUSH
32572: LD_INT 1
32574: ARRAY
32575: PUSH
32576: LD_EXP 71
32580: PUSH
32581: LD_VAR 0 2
32585: ARRAY
32586: PUSH
32587: LD_INT 1
32589: ARRAY
32590: PUSH
32591: LD_INT 2
32593: ARRAY
32594: PUSH
32595: LD_EXP 71
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PUSH
32606: LD_INT 1
32608: ARRAY
32609: PUSH
32610: LD_INT 3
32612: ARRAY
32613: PUSH
32614: LD_EXP 71
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PUSH
32625: LD_INT 1
32627: ARRAY
32628: PUSH
32629: LD_INT 4
32631: ARRAY
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: PPUSH
32639: CALL 60819 0 2
32643: AND
32644: IFFALSE 32782
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
32646: LD_VAR 0 3
32650: PPUSH
32651: LD_EXP 71
32655: PUSH
32656: LD_VAR 0 2
32660: ARRAY
32661: PUSH
32662: LD_INT 1
32664: ARRAY
32665: PUSH
32666: LD_INT 1
32668: ARRAY
32669: PPUSH
32670: LD_EXP 71
32674: PUSH
32675: LD_VAR 0 2
32679: ARRAY
32680: PUSH
32681: LD_INT 1
32683: ARRAY
32684: PUSH
32685: LD_INT 2
32687: ARRAY
32688: PPUSH
32689: LD_EXP 71
32693: PUSH
32694: LD_VAR 0 2
32698: ARRAY
32699: PUSH
32700: LD_INT 1
32702: ARRAY
32703: PUSH
32704: LD_INT 3
32706: ARRAY
32707: PPUSH
32708: LD_EXP 71
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: PUSH
32719: LD_INT 1
32721: ARRAY
32722: PUSH
32723: LD_INT 4
32725: ARRAY
32726: PPUSH
32727: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
32731: LD_ADDR_VAR 0 4
32735: PUSH
32736: LD_EXP 71
32740: PUSH
32741: LD_VAR 0 2
32745: ARRAY
32746: PPUSH
32747: LD_INT 1
32749: PPUSH
32750: CALL_OW 3
32754: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
32755: LD_ADDR_EXP 71
32759: PUSH
32760: LD_EXP 71
32764: PPUSH
32765: LD_VAR 0 2
32769: PPUSH
32770: LD_VAR 0 4
32774: PPUSH
32775: CALL_OW 1
32779: ST_TO_ADDR
// break ;
32780: GO 32784
// end ; end ;
32782: GO 32428
32784: POP
32785: POP
// end ;
32786: GO 32360
32788: POP
32789: POP
// end ;
32790: LD_VAR 0 1
32794: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
32795: LD_INT 0
32797: PPUSH
32798: PPUSH
32799: PPUSH
// if not mc_bases then
32800: LD_EXP 50
32804: NOT
32805: IFFALSE 32809
// exit ;
32807: GO 32898
// for i = 1 to mc_bases do
32809: LD_ADDR_VAR 0 2
32813: PUSH
32814: DOUBLE
32815: LD_INT 1
32817: DEC
32818: ST_TO_ADDR
32819: LD_EXP 50
32823: PUSH
32824: FOR_TO
32825: IFFALSE 32896
// begin if mc_attack [ i ] then
32827: LD_EXP 70
32831: PUSH
32832: LD_VAR 0 2
32836: ARRAY
32837: IFFALSE 32894
// begin tmp := mc_attack [ i ] [ 1 ] ;
32839: LD_ADDR_VAR 0 3
32843: PUSH
32844: LD_EXP 70
32848: PUSH
32849: LD_VAR 0 2
32853: ARRAY
32854: PUSH
32855: LD_INT 1
32857: ARRAY
32858: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
32859: LD_ADDR_EXP 70
32863: PUSH
32864: LD_EXP 70
32868: PPUSH
32869: LD_VAR 0 2
32873: PPUSH
32874: EMPTY
32875: PPUSH
32876: CALL_OW 1
32880: ST_TO_ADDR
// Attack ( tmp ) ;
32881: LD_VAR 0 3
32885: PPUSH
32886: CALL 83032 0 1
// exit ;
32890: POP
32891: POP
32892: GO 32898
// end ; end ;
32894: GO 32824
32896: POP
32897: POP
// end ;
32898: LD_VAR 0 1
32902: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
32903: LD_INT 0
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
32910: PPUSH
32911: PPUSH
// if not mc_bases then
32912: LD_EXP 50
32916: NOT
32917: IFFALSE 32921
// exit ;
32919: GO 33503
// for i = 1 to mc_bases do
32921: LD_ADDR_VAR 0 2
32925: PUSH
32926: DOUBLE
32927: LD_INT 1
32929: DEC
32930: ST_TO_ADDR
32931: LD_EXP 50
32935: PUSH
32936: FOR_TO
32937: IFFALSE 33501
// begin if not mc_bases [ i ] then
32939: LD_EXP 50
32943: PUSH
32944: LD_VAR 0 2
32948: ARRAY
32949: NOT
32950: IFFALSE 32954
// continue ;
32952: GO 32936
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
32954: LD_ADDR_VAR 0 7
32958: PUSH
32959: LD_EXP 50
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: PUSH
32970: LD_INT 1
32972: ARRAY
32973: PPUSH
32974: CALL 51391 0 1
32978: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
32979: LD_ADDR_EXP 73
32983: PUSH
32984: LD_EXP 73
32988: PPUSH
32989: LD_VAR 0 2
32993: PPUSH
32994: LD_EXP 50
32998: PUSH
32999: LD_VAR 0 2
33003: ARRAY
33004: PUSH
33005: LD_INT 1
33007: ARRAY
33008: PPUSH
33009: CALL_OW 255
33013: PPUSH
33014: LD_EXP 75
33018: PUSH
33019: LD_VAR 0 2
33023: ARRAY
33024: PPUSH
33025: CALL 48945 0 2
33029: PPUSH
33030: CALL_OW 1
33034: ST_TO_ADDR
// if not mc_scan [ i ] then
33035: LD_EXP 73
33039: PUSH
33040: LD_VAR 0 2
33044: ARRAY
33045: NOT
33046: IFFALSE 33201
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33048: LD_ADDR_VAR 0 4
33052: PUSH
33053: LD_EXP 50
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PPUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 25
33069: PUSH
33070: LD_INT 5
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 25
33079: PUSH
33080: LD_INT 8
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 25
33089: PUSH
33090: LD_INT 9
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: PPUSH
33103: CALL_OW 72
33107: ST_TO_ADDR
// if not tmp then
33108: LD_VAR 0 4
33112: NOT
33113: IFFALSE 33117
// continue ;
33115: GO 32936
// for j in tmp do
33117: LD_ADDR_VAR 0 3
33121: PUSH
33122: LD_VAR 0 4
33126: PUSH
33127: FOR_IN
33128: IFFALSE 33199
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33130: LD_VAR 0 3
33134: PPUSH
33135: CALL_OW 310
33139: PPUSH
33140: CALL_OW 266
33144: PUSH
33145: LD_INT 5
33147: EQUAL
33148: PUSH
33149: LD_VAR 0 3
33153: PPUSH
33154: CALL_OW 257
33158: PUSH
33159: LD_INT 1
33161: EQUAL
33162: AND
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 459
33173: NOT
33174: AND
33175: PUSH
33176: LD_VAR 0 7
33180: AND
33181: IFFALSE 33197
// ComChangeProfession ( j , class ) ;
33183: LD_VAR 0 3
33187: PPUSH
33188: LD_VAR 0 7
33192: PPUSH
33193: CALL_OW 123
33197: GO 33127
33199: POP
33200: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33201: LD_EXP 73
33205: PUSH
33206: LD_VAR 0 2
33210: ARRAY
33211: PUSH
33212: LD_EXP 72
33216: PUSH
33217: LD_VAR 0 2
33221: ARRAY
33222: NOT
33223: AND
33224: PUSH
33225: LD_EXP 50
33229: PUSH
33230: LD_VAR 0 2
33234: ARRAY
33235: PPUSH
33236: LD_INT 30
33238: PUSH
33239: LD_INT 32
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PPUSH
33246: CALL_OW 72
33250: NOT
33251: AND
33252: PUSH
33253: LD_EXP 50
33257: PUSH
33258: LD_VAR 0 2
33262: ARRAY
33263: PPUSH
33264: LD_INT 2
33266: PUSH
33267: LD_INT 30
33269: PUSH
33270: LD_INT 4
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 30
33279: PUSH
33280: LD_INT 5
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: LIST
33291: PPUSH
33292: CALL_OW 72
33296: NOT
33297: AND
33298: IFFALSE 33430
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33300: LD_ADDR_VAR 0 4
33304: PUSH
33305: LD_EXP 50
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: PPUSH
33316: LD_INT 2
33318: PUSH
33319: LD_INT 25
33321: PUSH
33322: LD_INT 1
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 25
33331: PUSH
33332: LD_INT 5
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 25
33341: PUSH
33342: LD_INT 8
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 25
33351: PUSH
33352: LD_INT 9
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: PPUSH
33366: CALL_OW 72
33370: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33371: LD_ADDR_VAR 0 4
33375: PUSH
33376: LD_VAR 0 4
33380: PUSH
33381: LD_VAR 0 4
33385: PPUSH
33386: LD_INT 18
33388: PPUSH
33389: CALL 87815 0 2
33393: DIFF
33394: ST_TO_ADDR
// if tmp then
33395: LD_VAR 0 4
33399: IFFALSE 33430
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33401: LD_VAR 0 2
33405: PPUSH
33406: LD_VAR 0 4
33410: PPUSH
33411: LD_EXP 75
33415: PUSH
33416: LD_VAR 0 2
33420: ARRAY
33421: PPUSH
33422: CALL 48980 0 3
// exit ;
33426: POP
33427: POP
33428: GO 33503
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33430: LD_EXP 73
33434: PUSH
33435: LD_VAR 0 2
33439: ARRAY
33440: PUSH
33441: LD_EXP 72
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: AND
33452: IFFALSE 33499
// begin tmp := mc_defender [ i ] ;
33454: LD_ADDR_VAR 0 4
33458: PUSH
33459: LD_EXP 72
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33470: LD_VAR 0 2
33474: PPUSH
33475: LD_VAR 0 4
33479: PPUSH
33480: LD_EXP 73
33484: PUSH
33485: LD_VAR 0 2
33489: ARRAY
33490: PPUSH
33491: CALL 49541 0 3
// exit ;
33495: POP
33496: POP
33497: GO 33503
// end ; end ;
33499: GO 32936
33501: POP
33502: POP
// end ;
33503: LD_VAR 0 1
33507: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
33508: LD_INT 0
33510: PPUSH
33511: PPUSH
33512: PPUSH
33513: PPUSH
33514: PPUSH
33515: PPUSH
33516: PPUSH
33517: PPUSH
33518: PPUSH
33519: PPUSH
33520: PPUSH
// if not mc_bases then
33521: LD_EXP 50
33525: NOT
33526: IFFALSE 33530
// exit ;
33528: GO 34617
// for i = 1 to mc_bases do
33530: LD_ADDR_VAR 0 2
33534: PUSH
33535: DOUBLE
33536: LD_INT 1
33538: DEC
33539: ST_TO_ADDR
33540: LD_EXP 50
33544: PUSH
33545: FOR_TO
33546: IFFALSE 34615
// begin tmp := mc_lab [ i ] ;
33548: LD_ADDR_VAR 0 6
33552: PUSH
33553: LD_EXP 83
33557: PUSH
33558: LD_VAR 0 2
33562: ARRAY
33563: ST_TO_ADDR
// if not tmp then
33564: LD_VAR 0 6
33568: NOT
33569: IFFALSE 33573
// continue ;
33571: GO 33545
// idle_lab := 0 ;
33573: LD_ADDR_VAR 0 11
33577: PUSH
33578: LD_INT 0
33580: ST_TO_ADDR
// for j in tmp do
33581: LD_ADDR_VAR 0 3
33585: PUSH
33586: LD_VAR 0 6
33590: PUSH
33591: FOR_IN
33592: IFFALSE 34611
// begin researching := false ;
33594: LD_ADDR_VAR 0 10
33598: PUSH
33599: LD_INT 0
33601: ST_TO_ADDR
// side := GetSide ( j ) ;
33602: LD_ADDR_VAR 0 4
33606: PUSH
33607: LD_VAR 0 3
33611: PPUSH
33612: CALL_OW 255
33616: ST_TO_ADDR
// if not mc_tech [ side ] then
33617: LD_EXP 77
33621: PUSH
33622: LD_VAR 0 4
33626: ARRAY
33627: NOT
33628: IFFALSE 33632
// continue ;
33630: GO 33591
// if BuildingStatus ( j ) = bs_idle then
33632: LD_VAR 0 3
33636: PPUSH
33637: CALL_OW 461
33641: PUSH
33642: LD_INT 2
33644: EQUAL
33645: IFFALSE 33833
// begin if idle_lab and UnitsInside ( j ) < 6 then
33647: LD_VAR 0 11
33651: PUSH
33652: LD_VAR 0 3
33656: PPUSH
33657: CALL_OW 313
33661: PUSH
33662: LD_INT 6
33664: LESS
33665: AND
33666: IFFALSE 33737
// begin tmp2 := UnitsInside ( idle_lab ) ;
33668: LD_ADDR_VAR 0 9
33672: PUSH
33673: LD_VAR 0 11
33677: PPUSH
33678: CALL_OW 313
33682: ST_TO_ADDR
// if tmp2 then
33683: LD_VAR 0 9
33687: IFFALSE 33729
// for x in tmp2 do
33689: LD_ADDR_VAR 0 7
33693: PUSH
33694: LD_VAR 0 9
33698: PUSH
33699: FOR_IN
33700: IFFALSE 33727
// begin ComExitBuilding ( x ) ;
33702: LD_VAR 0 7
33706: PPUSH
33707: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
33711: LD_VAR 0 7
33715: PPUSH
33716: LD_VAR 0 3
33720: PPUSH
33721: CALL_OW 180
// end ;
33725: GO 33699
33727: POP
33728: POP
// idle_lab := 0 ;
33729: LD_ADDR_VAR 0 11
33733: PUSH
33734: LD_INT 0
33736: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
33737: LD_ADDR_VAR 0 5
33741: PUSH
33742: LD_EXP 77
33746: PUSH
33747: LD_VAR 0 4
33751: ARRAY
33752: PUSH
33753: FOR_IN
33754: IFFALSE 33814
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
33756: LD_VAR 0 3
33760: PPUSH
33761: LD_VAR 0 5
33765: PPUSH
33766: CALL_OW 430
33770: PUSH
33771: LD_VAR 0 4
33775: PPUSH
33776: LD_VAR 0 5
33780: PPUSH
33781: CALL 48050 0 2
33785: AND
33786: IFFALSE 33812
// begin researching := true ;
33788: LD_ADDR_VAR 0 10
33792: PUSH
33793: LD_INT 1
33795: ST_TO_ADDR
// ComResearch ( j , t ) ;
33796: LD_VAR 0 3
33800: PPUSH
33801: LD_VAR 0 5
33805: PPUSH
33806: CALL_OW 124
// break ;
33810: GO 33814
// end ;
33812: GO 33753
33814: POP
33815: POP
// if not researching then
33816: LD_VAR 0 10
33820: NOT
33821: IFFALSE 33833
// idle_lab := j ;
33823: LD_ADDR_VAR 0 11
33827: PUSH
33828: LD_VAR 0 3
33832: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
33833: LD_VAR 0 3
33837: PPUSH
33838: CALL_OW 461
33842: PUSH
33843: LD_INT 10
33845: EQUAL
33846: IFFALSE 34434
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
33848: LD_EXP 79
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: NOT
33859: PUSH
33860: LD_EXP 80
33864: PUSH
33865: LD_VAR 0 2
33869: ARRAY
33870: NOT
33871: AND
33872: PUSH
33873: LD_EXP 77
33877: PUSH
33878: LD_VAR 0 4
33882: ARRAY
33883: PUSH
33884: LD_INT 1
33886: GREATER
33887: AND
33888: IFFALSE 34019
// begin ComCancel ( j ) ;
33890: LD_VAR 0 3
33894: PPUSH
33895: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
33899: LD_ADDR_EXP 77
33903: PUSH
33904: LD_EXP 77
33908: PPUSH
33909: LD_VAR 0 4
33913: PPUSH
33914: LD_EXP 77
33918: PUSH
33919: LD_VAR 0 4
33923: ARRAY
33924: PPUSH
33925: LD_EXP 77
33929: PUSH
33930: LD_VAR 0 4
33934: ARRAY
33935: PUSH
33936: LD_INT 1
33938: MINUS
33939: PPUSH
33940: LD_EXP 77
33944: PUSH
33945: LD_VAR 0 4
33949: ARRAY
33950: PPUSH
33951: LD_INT 0
33953: PPUSH
33954: CALL 53973 0 4
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
33964: LD_ADDR_EXP 77
33968: PUSH
33969: LD_EXP 77
33973: PPUSH
33974: LD_VAR 0 4
33978: PPUSH
33979: LD_EXP 77
33983: PUSH
33984: LD_VAR 0 4
33988: ARRAY
33989: PPUSH
33990: LD_EXP 77
33994: PUSH
33995: LD_VAR 0 4
33999: ARRAY
34000: PPUSH
34001: LD_INT 1
34003: PPUSH
34004: LD_INT 0
34006: PPUSH
34007: CALL 53973 0 4
34011: PPUSH
34012: CALL_OW 1
34016: ST_TO_ADDR
// continue ;
34017: GO 33591
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34019: LD_EXP 79
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_EXP 80
34034: PUSH
34035: LD_VAR 0 2
34039: ARRAY
34040: NOT
34041: AND
34042: IFFALSE 34169
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34044: LD_ADDR_EXP 80
34048: PUSH
34049: LD_EXP 80
34053: PPUSH
34054: LD_VAR 0 2
34058: PUSH
34059: LD_EXP 80
34063: PUSH
34064: LD_VAR 0 2
34068: ARRAY
34069: PUSH
34070: LD_INT 1
34072: PLUS
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PPUSH
34078: LD_EXP 79
34082: PUSH
34083: LD_VAR 0 2
34087: ARRAY
34088: PUSH
34089: LD_INT 1
34091: ARRAY
34092: PPUSH
34093: CALL 54555 0 3
34097: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34098: LD_EXP 79
34102: PUSH
34103: LD_VAR 0 2
34107: ARRAY
34108: PUSH
34109: LD_INT 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 112
34115: PPUSH
34116: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34120: LD_ADDR_VAR 0 9
34124: PUSH
34125: LD_EXP 79
34129: PUSH
34130: LD_VAR 0 2
34134: ARRAY
34135: PPUSH
34136: LD_INT 1
34138: PPUSH
34139: CALL_OW 3
34143: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34144: LD_ADDR_EXP 79
34148: PUSH
34149: LD_EXP 79
34153: PPUSH
34154: LD_VAR 0 2
34158: PPUSH
34159: LD_VAR 0 9
34163: PPUSH
34164: CALL_OW 1
34168: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34169: LD_EXP 79
34173: PUSH
34174: LD_VAR 0 2
34178: ARRAY
34179: PUSH
34180: LD_EXP 80
34184: PUSH
34185: LD_VAR 0 2
34189: ARRAY
34190: AND
34191: PUSH
34192: LD_EXP 80
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PUSH
34203: LD_INT 1
34205: ARRAY
34206: PPUSH
34207: CALL_OW 310
34211: NOT
34212: AND
34213: PUSH
34214: LD_VAR 0 3
34218: PPUSH
34219: CALL_OW 313
34223: PUSH
34224: LD_INT 6
34226: EQUAL
34227: AND
34228: IFFALSE 34284
// begin tmp2 := UnitsInside ( j ) ;
34230: LD_ADDR_VAR 0 9
34234: PUSH
34235: LD_VAR 0 3
34239: PPUSH
34240: CALL_OW 313
34244: ST_TO_ADDR
// if tmp2 = 6 then
34245: LD_VAR 0 9
34249: PUSH
34250: LD_INT 6
34252: EQUAL
34253: IFFALSE 34284
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34255: LD_VAR 0 9
34259: PUSH
34260: LD_INT 1
34262: ARRAY
34263: PPUSH
34264: LD_INT 112
34266: PPUSH
34267: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34271: LD_VAR 0 9
34275: PUSH
34276: LD_INT 1
34278: ARRAY
34279: PPUSH
34280: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34284: LD_EXP 80
34288: PUSH
34289: LD_VAR 0 2
34293: ARRAY
34294: PUSH
34295: LD_EXP 80
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PPUSH
34310: CALL_OW 314
34314: NOT
34315: AND
34316: PUSH
34317: LD_EXP 80
34321: PUSH
34322: LD_VAR 0 2
34326: ARRAY
34327: PUSH
34328: LD_INT 1
34330: ARRAY
34331: PPUSH
34332: CALL_OW 310
34336: NOT
34337: AND
34338: IFFALSE 34364
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34340: LD_EXP 80
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PUSH
34351: LD_INT 1
34353: ARRAY
34354: PPUSH
34355: LD_VAR 0 3
34359: PPUSH
34360: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34364: LD_EXP 80
34368: PUSH
34369: LD_VAR 0 2
34373: ARRAY
34374: PUSH
34375: LD_INT 1
34377: ARRAY
34378: PPUSH
34379: CALL_OW 310
34383: PUSH
34384: LD_EXP 80
34388: PUSH
34389: LD_VAR 0 2
34393: ARRAY
34394: PUSH
34395: LD_INT 1
34397: ARRAY
34398: PPUSH
34399: CALL_OW 310
34403: PPUSH
34404: CALL_OW 461
34408: PUSH
34409: LD_INT 3
34411: NONEQUAL
34412: AND
34413: IFFALSE 34434
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34415: LD_EXP 80
34419: PUSH
34420: LD_VAR 0 2
34424: ARRAY
34425: PUSH
34426: LD_INT 1
34428: ARRAY
34429: PPUSH
34430: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34434: LD_VAR 0 3
34438: PPUSH
34439: CALL_OW 461
34443: PUSH
34444: LD_INT 6
34446: EQUAL
34447: PUSH
34448: LD_VAR 0 6
34452: PUSH
34453: LD_INT 1
34455: GREATER
34456: AND
34457: IFFALSE 34609
// begin sci := [ ] ;
34459: LD_ADDR_VAR 0 8
34463: PUSH
34464: EMPTY
34465: ST_TO_ADDR
// for x in ( tmp diff j ) do
34466: LD_ADDR_VAR 0 7
34470: PUSH
34471: LD_VAR 0 6
34475: PUSH
34476: LD_VAR 0 3
34480: DIFF
34481: PUSH
34482: FOR_IN
34483: IFFALSE 34535
// begin if sci = 6 then
34485: LD_VAR 0 8
34489: PUSH
34490: LD_INT 6
34492: EQUAL
34493: IFFALSE 34497
// break ;
34495: GO 34535
// if BuildingStatus ( x ) = bs_idle then
34497: LD_VAR 0 7
34501: PPUSH
34502: CALL_OW 461
34506: PUSH
34507: LD_INT 2
34509: EQUAL
34510: IFFALSE 34533
// sci := sci ^ UnitsInside ( x ) ;
34512: LD_ADDR_VAR 0 8
34516: PUSH
34517: LD_VAR 0 8
34521: PUSH
34522: LD_VAR 0 7
34526: PPUSH
34527: CALL_OW 313
34531: ADD
34532: ST_TO_ADDR
// end ;
34533: GO 34482
34535: POP
34536: POP
// if not sci then
34537: LD_VAR 0 8
34541: NOT
34542: IFFALSE 34546
// continue ;
34544: GO 33591
// for x in sci do
34546: LD_ADDR_VAR 0 7
34550: PUSH
34551: LD_VAR 0 8
34555: PUSH
34556: FOR_IN
34557: IFFALSE 34607
// if IsInUnit ( x ) and not HasTask ( x ) then
34559: LD_VAR 0 7
34563: PPUSH
34564: CALL_OW 310
34568: PUSH
34569: LD_VAR 0 7
34573: PPUSH
34574: CALL_OW 314
34578: NOT
34579: AND
34580: IFFALSE 34605
// begin ComExitBuilding ( x ) ;
34582: LD_VAR 0 7
34586: PPUSH
34587: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34591: LD_VAR 0 7
34595: PPUSH
34596: LD_VAR 0 3
34600: PPUSH
34601: CALL_OW 180
// end ;
34605: GO 34556
34607: POP
34608: POP
// end ; end ;
34609: GO 33591
34611: POP
34612: POP
// end ;
34613: GO 33545
34615: POP
34616: POP
// end ;
34617: LD_VAR 0 1
34621: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
34622: LD_INT 0
34624: PPUSH
34625: PPUSH
// if not mc_bases then
34626: LD_EXP 50
34630: NOT
34631: IFFALSE 34635
// exit ;
34633: GO 34716
// for i = 1 to mc_bases do
34635: LD_ADDR_VAR 0 2
34639: PUSH
34640: DOUBLE
34641: LD_INT 1
34643: DEC
34644: ST_TO_ADDR
34645: LD_EXP 50
34649: PUSH
34650: FOR_TO
34651: IFFALSE 34714
// if mc_mines [ i ] and mc_miners [ i ] then
34653: LD_EXP 63
34657: PUSH
34658: LD_VAR 0 2
34662: ARRAY
34663: PUSH
34664: LD_EXP 64
34668: PUSH
34669: LD_VAR 0 2
34673: ARRAY
34674: AND
34675: IFFALSE 34712
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
34677: LD_EXP 64
34681: PUSH
34682: LD_VAR 0 2
34686: ARRAY
34687: PUSH
34688: LD_INT 1
34690: ARRAY
34691: PPUSH
34692: CALL_OW 255
34696: PPUSH
34697: LD_EXP 63
34701: PUSH
34702: LD_VAR 0 2
34706: ARRAY
34707: PPUSH
34708: CALL 51544 0 2
34712: GO 34650
34714: POP
34715: POP
// end ;
34716: LD_VAR 0 1
34720: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
34721: LD_INT 0
34723: PPUSH
34724: PPUSH
34725: PPUSH
34726: PPUSH
34727: PPUSH
34728: PPUSH
34729: PPUSH
34730: PPUSH
// if not mc_bases or not mc_parking then
34731: LD_EXP 50
34735: NOT
34736: PUSH
34737: LD_EXP 74
34741: NOT
34742: OR
34743: IFFALSE 34747
// exit ;
34745: GO 35446
// for i = 1 to mc_bases do
34747: LD_ADDR_VAR 0 2
34751: PUSH
34752: DOUBLE
34753: LD_INT 1
34755: DEC
34756: ST_TO_ADDR
34757: LD_EXP 50
34761: PUSH
34762: FOR_TO
34763: IFFALSE 35444
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
34765: LD_EXP 50
34769: PUSH
34770: LD_VAR 0 2
34774: ARRAY
34775: NOT
34776: PUSH
34777: LD_EXP 74
34781: PUSH
34782: LD_VAR 0 2
34786: ARRAY
34787: NOT
34788: OR
34789: IFFALSE 34793
// continue ;
34791: GO 34762
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34793: LD_ADDR_VAR 0 5
34797: PUSH
34798: LD_EXP 50
34802: PUSH
34803: LD_VAR 0 2
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PPUSH
34813: CALL_OW 255
34817: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34818: LD_ADDR_VAR 0 6
34822: PUSH
34823: LD_EXP 50
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PPUSH
34834: LD_INT 30
34836: PUSH
34837: LD_INT 3
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PPUSH
34844: CALL_OW 72
34848: ST_TO_ADDR
// if not fac then
34849: LD_VAR 0 6
34853: NOT
34854: IFFALSE 34905
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34856: LD_ADDR_VAR 0 6
34860: PUSH
34861: LD_EXP 50
34865: PUSH
34866: LD_VAR 0 2
34870: ARRAY
34871: PPUSH
34872: LD_INT 2
34874: PUSH
34875: LD_INT 30
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 30
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: LIST
34899: PPUSH
34900: CALL_OW 72
34904: ST_TO_ADDR
// if not fac then
34905: LD_VAR 0 6
34909: NOT
34910: IFFALSE 34914
// continue ;
34912: GO 34762
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34914: LD_ADDR_VAR 0 7
34918: PUSH
34919: LD_EXP 74
34923: PUSH
34924: LD_VAR 0 2
34928: ARRAY
34929: PPUSH
34930: LD_INT 22
34932: PUSH
34933: LD_VAR 0 5
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 21
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 3
34954: PUSH
34955: LD_INT 24
34957: PUSH
34958: LD_INT 1000
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: LIST
34973: PPUSH
34974: CALL_OW 70
34978: ST_TO_ADDR
// for j in fac do
34979: LD_ADDR_VAR 0 3
34983: PUSH
34984: LD_VAR 0 6
34988: PUSH
34989: FOR_IN
34990: IFFALSE 35071
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
34992: LD_ADDR_VAR 0 7
34996: PUSH
34997: LD_VAR 0 7
35001: PUSH
35002: LD_INT 22
35004: PUSH
35005: LD_VAR 0 5
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 91
35016: PUSH
35017: LD_VAR 0 3
35021: PUSH
35022: LD_INT 15
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 21
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: LD_INT 24
35045: PUSH
35046: LD_INT 1000
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: PPUSH
35063: CALL_OW 69
35067: UNION
35068: ST_TO_ADDR
35069: GO 34989
35071: POP
35072: POP
// if not vehs then
35073: LD_VAR 0 7
35077: NOT
35078: IFFALSE 35104
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35080: LD_ADDR_EXP 62
35084: PUSH
35085: LD_EXP 62
35089: PPUSH
35090: LD_VAR 0 2
35094: PPUSH
35095: EMPTY
35096: PPUSH
35097: CALL_OW 1
35101: ST_TO_ADDR
// continue ;
35102: GO 34762
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35104: LD_ADDR_VAR 0 8
35108: PUSH
35109: LD_EXP 50
35113: PUSH
35114: LD_VAR 0 2
35118: ARRAY
35119: PPUSH
35120: LD_INT 30
35122: PUSH
35123: LD_INT 3
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PPUSH
35130: CALL_OW 72
35134: ST_TO_ADDR
// if tmp then
35135: LD_VAR 0 8
35139: IFFALSE 35242
// begin for j in tmp do
35141: LD_ADDR_VAR 0 3
35145: PUSH
35146: LD_VAR 0 8
35150: PUSH
35151: FOR_IN
35152: IFFALSE 35240
// for k in UnitsInside ( j ) do
35154: LD_ADDR_VAR 0 4
35158: PUSH
35159: LD_VAR 0 3
35163: PPUSH
35164: CALL_OW 313
35168: PUSH
35169: FOR_IN
35170: IFFALSE 35236
// if k then
35172: LD_VAR 0 4
35176: IFFALSE 35234
// if not k in mc_repair_vehicle [ i ] then
35178: LD_VAR 0 4
35182: PUSH
35183: LD_EXP 62
35187: PUSH
35188: LD_VAR 0 2
35192: ARRAY
35193: IN
35194: NOT
35195: IFFALSE 35234
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35197: LD_ADDR_EXP 62
35201: PUSH
35202: LD_EXP 62
35206: PPUSH
35207: LD_VAR 0 2
35211: PPUSH
35212: LD_EXP 62
35216: PUSH
35217: LD_VAR 0 2
35221: ARRAY
35222: PUSH
35223: LD_VAR 0 4
35227: UNION
35228: PPUSH
35229: CALL_OW 1
35233: ST_TO_ADDR
35234: GO 35169
35236: POP
35237: POP
35238: GO 35151
35240: POP
35241: POP
// end ; if not mc_repair_vehicle [ i ] then
35242: LD_EXP 62
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: NOT
35253: IFFALSE 35257
// continue ;
35255: GO 34762
// for j in mc_repair_vehicle [ i ] do
35257: LD_ADDR_VAR 0 3
35261: PUSH
35262: LD_EXP 62
35266: PUSH
35267: LD_VAR 0 2
35271: ARRAY
35272: PUSH
35273: FOR_IN
35274: IFFALSE 35440
// begin if GetClass ( j ) <> 3 then
35276: LD_VAR 0 3
35280: PPUSH
35281: CALL_OW 257
35285: PUSH
35286: LD_INT 3
35288: NONEQUAL
35289: IFFALSE 35330
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35291: LD_ADDR_EXP 62
35295: PUSH
35296: LD_EXP 62
35300: PPUSH
35301: LD_VAR 0 2
35305: PPUSH
35306: LD_EXP 62
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_VAR 0 3
35321: DIFF
35322: PPUSH
35323: CALL_OW 1
35327: ST_TO_ADDR
// continue ;
35328: GO 35273
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35330: LD_VAR 0 3
35334: PPUSH
35335: CALL_OW 311
35339: NOT
35340: PUSH
35341: LD_VAR 0 3
35345: PUSH
35346: LD_EXP 53
35350: PUSH
35351: LD_VAR 0 2
35355: ARRAY
35356: PUSH
35357: LD_INT 1
35359: ARRAY
35360: IN
35361: NOT
35362: AND
35363: PUSH
35364: LD_VAR 0 3
35368: PUSH
35369: LD_EXP 53
35373: PUSH
35374: LD_VAR 0 2
35378: ARRAY
35379: PUSH
35380: LD_INT 2
35382: ARRAY
35383: IN
35384: NOT
35385: AND
35386: IFFALSE 35438
// begin if IsInUnit ( j ) then
35388: LD_VAR 0 3
35392: PPUSH
35393: CALL_OW 310
35397: IFFALSE 35408
// ComExitBuilding ( j ) ;
35399: LD_VAR 0 3
35403: PPUSH
35404: CALL_OW 122
// if not HasTask ( j ) then
35408: LD_VAR 0 3
35412: PPUSH
35413: CALL_OW 314
35417: NOT
35418: IFFALSE 35438
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35420: LD_VAR 0 3
35424: PPUSH
35425: LD_VAR 0 7
35429: PUSH
35430: LD_INT 1
35432: ARRAY
35433: PPUSH
35434: CALL_OW 189
// end ; end ;
35438: GO 35273
35440: POP
35441: POP
// end ;
35442: GO 34762
35444: POP
35445: POP
// end ;
35446: LD_VAR 0 1
35450: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35451: LD_INT 0
35453: PPUSH
35454: PPUSH
35455: PPUSH
35456: PPUSH
35457: PPUSH
35458: PPUSH
35459: PPUSH
35460: PPUSH
35461: PPUSH
35462: PPUSH
35463: PPUSH
// if not mc_bases then
35464: LD_EXP 50
35468: NOT
35469: IFFALSE 35473
// exit ;
35471: GO 36275
// for i = 1 to mc_bases do
35473: LD_ADDR_VAR 0 2
35477: PUSH
35478: DOUBLE
35479: LD_INT 1
35481: DEC
35482: ST_TO_ADDR
35483: LD_EXP 50
35487: PUSH
35488: FOR_TO
35489: IFFALSE 36273
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
35491: LD_EXP 78
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: NOT
35502: PUSH
35503: LD_EXP 53
35507: PUSH
35508: LD_VAR 0 2
35512: ARRAY
35513: PUSH
35514: LD_INT 1
35516: ARRAY
35517: OR
35518: PUSH
35519: LD_EXP 53
35523: PUSH
35524: LD_VAR 0 2
35528: ARRAY
35529: PUSH
35530: LD_INT 2
35532: ARRAY
35533: OR
35534: PUSH
35535: LD_EXP 76
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PPUSH
35546: LD_INT 1
35548: PPUSH
35549: CALL_OW 325
35553: NOT
35554: OR
35555: PUSH
35556: LD_EXP 73
35560: PUSH
35561: LD_VAR 0 2
35565: ARRAY
35566: OR
35567: IFFALSE 35571
// continue ;
35569: GO 35488
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
35571: LD_ADDR_VAR 0 8
35575: PUSH
35576: LD_EXP 50
35580: PUSH
35581: LD_VAR 0 2
35585: ARRAY
35586: PPUSH
35587: LD_INT 25
35589: PUSH
35590: LD_INT 4
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 50
35599: PUSH
35600: EMPTY
35601: LIST
35602: PUSH
35603: LD_INT 3
35605: PUSH
35606: LD_INT 60
35608: PUSH
35609: EMPTY
35610: LIST
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: LIST
35620: PPUSH
35621: CALL_OW 72
35625: PUSH
35626: LD_EXP 54
35630: PUSH
35631: LD_VAR 0 2
35635: ARRAY
35636: DIFF
35637: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35638: LD_ADDR_VAR 0 9
35642: PUSH
35643: LD_EXP 50
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: PPUSH
35654: LD_INT 2
35656: PUSH
35657: LD_INT 30
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 30
35669: PUSH
35670: LD_INT 1
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: LIST
35681: PPUSH
35682: CALL_OW 72
35686: ST_TO_ADDR
// if not tmp or not dep then
35687: LD_VAR 0 8
35691: NOT
35692: PUSH
35693: LD_VAR 0 9
35697: NOT
35698: OR
35699: IFFALSE 35703
// continue ;
35701: GO 35488
// side := GetSide ( tmp [ 1 ] ) ;
35703: LD_ADDR_VAR 0 11
35707: PUSH
35708: LD_VAR 0 8
35712: PUSH
35713: LD_INT 1
35715: ARRAY
35716: PPUSH
35717: CALL_OW 255
35721: ST_TO_ADDR
// dep := dep [ 1 ] ;
35722: LD_ADDR_VAR 0 9
35726: PUSH
35727: LD_VAR 0 9
35731: PUSH
35732: LD_INT 1
35734: ARRAY
35735: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
35736: LD_ADDR_VAR 0 7
35740: PUSH
35741: LD_EXP 78
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PPUSH
35752: LD_INT 22
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 25
35764: PUSH
35765: LD_INT 12
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PPUSH
35776: CALL_OW 70
35780: PUSH
35781: LD_INT 22
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 25
35793: PUSH
35794: LD_INT 12
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 91
35803: PUSH
35804: LD_VAR 0 9
35808: PUSH
35809: LD_INT 20
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: LIST
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: LIST
35821: PPUSH
35822: CALL_OW 69
35826: UNION
35827: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
35828: LD_ADDR_VAR 0 10
35832: PUSH
35833: LD_EXP 78
35837: PUSH
35838: LD_VAR 0 2
35842: ARRAY
35843: PPUSH
35844: LD_INT 81
35846: PUSH
35847: LD_VAR 0 11
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PPUSH
35856: CALL_OW 70
35860: ST_TO_ADDR
// if not apes or danger_at_area then
35861: LD_VAR 0 7
35865: NOT
35866: PUSH
35867: LD_VAR 0 10
35871: OR
35872: IFFALSE 35922
// begin if mc_taming [ i ] then
35874: LD_EXP 81
35878: PUSH
35879: LD_VAR 0 2
35883: ARRAY
35884: IFFALSE 35920
// begin MC_Reset ( i , 121 ) ;
35886: LD_VAR 0 2
35890: PPUSH
35891: LD_INT 121
35893: PPUSH
35894: CALL 21253 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
35898: LD_ADDR_EXP 81
35902: PUSH
35903: LD_EXP 81
35907: PPUSH
35908: LD_VAR 0 2
35912: PPUSH
35913: EMPTY
35914: PPUSH
35915: CALL_OW 1
35919: ST_TO_ADDR
// end ; continue ;
35920: GO 35488
// end ; for j in tmp do
35922: LD_ADDR_VAR 0 3
35926: PUSH
35927: LD_VAR 0 8
35931: PUSH
35932: FOR_IN
35933: IFFALSE 36269
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
35935: LD_VAR 0 3
35939: PUSH
35940: LD_EXP 81
35944: PUSH
35945: LD_VAR 0 2
35949: ARRAY
35950: IN
35951: NOT
35952: PUSH
35953: LD_EXP 81
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: PUSH
35964: LD_INT 3
35966: LESS
35967: AND
35968: IFFALSE 36026
// begin SetTag ( j , 121 ) ;
35970: LD_VAR 0 3
35974: PPUSH
35975: LD_INT 121
35977: PPUSH
35978: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
35982: LD_ADDR_EXP 81
35986: PUSH
35987: LD_EXP 81
35991: PPUSH
35992: LD_VAR 0 2
35996: PUSH
35997: LD_EXP 81
36001: PUSH
36002: LD_VAR 0 2
36006: ARRAY
36007: PUSH
36008: LD_INT 1
36010: PLUS
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PPUSH
36016: LD_VAR 0 3
36020: PPUSH
36021: CALL 54555 0 3
36025: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36026: LD_VAR 0 3
36030: PUSH
36031: LD_EXP 81
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: IN
36042: IFFALSE 36267
// begin if GetClass ( j ) <> 4 then
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 257
36053: PUSH
36054: LD_INT 4
36056: NONEQUAL
36057: IFFALSE 36110
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36059: LD_ADDR_EXP 81
36063: PUSH
36064: LD_EXP 81
36068: PPUSH
36069: LD_VAR 0 2
36073: PPUSH
36074: LD_EXP 81
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PUSH
36085: LD_VAR 0 3
36089: DIFF
36090: PPUSH
36091: CALL_OW 1
36095: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36096: LD_VAR 0 3
36100: PPUSH
36101: LD_INT 0
36103: PPUSH
36104: CALL_OW 109
// continue ;
36108: GO 35932
// end ; if IsInUnit ( j ) then
36110: LD_VAR 0 3
36114: PPUSH
36115: CALL_OW 310
36119: IFFALSE 36130
// ComExitBuilding ( j ) ;
36121: LD_VAR 0 3
36125: PPUSH
36126: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36130: LD_ADDR_VAR 0 6
36134: PUSH
36135: LD_VAR 0 7
36139: PPUSH
36140: LD_VAR 0 3
36144: PPUSH
36145: CALL_OW 74
36149: ST_TO_ADDR
// if not ape then
36150: LD_VAR 0 6
36154: NOT
36155: IFFALSE 36159
// break ;
36157: GO 36269
// x := GetX ( ape ) ;
36159: LD_ADDR_VAR 0 4
36163: PUSH
36164: LD_VAR 0 6
36168: PPUSH
36169: CALL_OW 250
36173: ST_TO_ADDR
// y := GetY ( ape ) ;
36174: LD_ADDR_VAR 0 5
36178: PUSH
36179: LD_VAR 0 6
36183: PPUSH
36184: CALL_OW 251
36188: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36189: LD_VAR 0 4
36193: PPUSH
36194: LD_VAR 0 5
36198: PPUSH
36199: CALL_OW 488
36203: NOT
36204: PUSH
36205: LD_VAR 0 11
36209: PPUSH
36210: LD_VAR 0 4
36214: PPUSH
36215: LD_VAR 0 5
36219: PPUSH
36220: LD_INT 20
36222: PPUSH
36223: CALL 55451 0 4
36227: PUSH
36228: LD_INT 4
36230: ARRAY
36231: OR
36232: IFFALSE 36236
// break ;
36234: GO 36269
// if not HasTask ( j ) then
36236: LD_VAR 0 3
36240: PPUSH
36241: CALL_OW 314
36245: NOT
36246: IFFALSE 36267
// ComTameXY ( j , x , y ) ;
36248: LD_VAR 0 3
36252: PPUSH
36253: LD_VAR 0 4
36257: PPUSH
36258: LD_VAR 0 5
36262: PPUSH
36263: CALL_OW 131
// end ; end ;
36267: GO 35932
36269: POP
36270: POP
// end ;
36271: GO 35488
36273: POP
36274: POP
// end ;
36275: LD_VAR 0 1
36279: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36280: LD_INT 0
36282: PPUSH
36283: PPUSH
36284: PPUSH
36285: PPUSH
36286: PPUSH
36287: PPUSH
36288: PPUSH
36289: PPUSH
// if not mc_bases then
36290: LD_EXP 50
36294: NOT
36295: IFFALSE 36299
// exit ;
36297: GO 36925
// for i = 1 to mc_bases do
36299: LD_ADDR_VAR 0 2
36303: PUSH
36304: DOUBLE
36305: LD_INT 1
36307: DEC
36308: ST_TO_ADDR
36309: LD_EXP 50
36313: PUSH
36314: FOR_TO
36315: IFFALSE 36923
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36317: LD_EXP 79
36321: PUSH
36322: LD_VAR 0 2
36326: ARRAY
36327: NOT
36328: PUSH
36329: LD_EXP 79
36333: PUSH
36334: LD_VAR 0 2
36338: ARRAY
36339: PPUSH
36340: LD_INT 25
36342: PUSH
36343: LD_INT 12
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PPUSH
36350: CALL_OW 72
36354: NOT
36355: OR
36356: IFFALSE 36360
// continue ;
36358: GO 36314
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36360: LD_ADDR_VAR 0 5
36364: PUSH
36365: LD_EXP 79
36369: PUSH
36370: LD_VAR 0 2
36374: ARRAY
36375: PUSH
36376: LD_INT 1
36378: ARRAY
36379: PPUSH
36380: CALL_OW 255
36384: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36385: LD_VAR 0 5
36389: PPUSH
36390: LD_INT 2
36392: PPUSH
36393: CALL_OW 325
36397: IFFALSE 36650
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36399: LD_ADDR_VAR 0 4
36403: PUSH
36404: LD_EXP 79
36408: PUSH
36409: LD_VAR 0 2
36413: ARRAY
36414: PPUSH
36415: LD_INT 25
36417: PUSH
36418: LD_INT 16
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PPUSH
36425: CALL_OW 72
36429: ST_TO_ADDR
// if tmp < 6 then
36430: LD_VAR 0 4
36434: PUSH
36435: LD_INT 6
36437: LESS
36438: IFFALSE 36650
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36440: LD_ADDR_VAR 0 6
36444: PUSH
36445: LD_EXP 50
36449: PUSH
36450: LD_VAR 0 2
36454: ARRAY
36455: PPUSH
36456: LD_INT 2
36458: PUSH
36459: LD_INT 30
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 30
36471: PUSH
36472: LD_INT 1
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: LIST
36483: PPUSH
36484: CALL_OW 72
36488: ST_TO_ADDR
// if depot then
36489: LD_VAR 0 6
36493: IFFALSE 36650
// begin selected := 0 ;
36495: LD_ADDR_VAR 0 7
36499: PUSH
36500: LD_INT 0
36502: ST_TO_ADDR
// for j in depot do
36503: LD_ADDR_VAR 0 3
36507: PUSH
36508: LD_VAR 0 6
36512: PUSH
36513: FOR_IN
36514: IFFALSE 36545
// begin if UnitsInside ( j ) < 6 then
36516: LD_VAR 0 3
36520: PPUSH
36521: CALL_OW 313
36525: PUSH
36526: LD_INT 6
36528: LESS
36529: IFFALSE 36543
// begin selected := j ;
36531: LD_ADDR_VAR 0 7
36535: PUSH
36536: LD_VAR 0 3
36540: ST_TO_ADDR
// break ;
36541: GO 36545
// end ; end ;
36543: GO 36513
36545: POP
36546: POP
// if selected then
36547: LD_VAR 0 7
36551: IFFALSE 36650
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36553: LD_ADDR_VAR 0 3
36557: PUSH
36558: LD_EXP 79
36562: PUSH
36563: LD_VAR 0 2
36567: ARRAY
36568: PPUSH
36569: LD_INT 25
36571: PUSH
36572: LD_INT 12
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PPUSH
36579: CALL_OW 72
36583: PUSH
36584: FOR_IN
36585: IFFALSE 36648
// if not HasTask ( j ) then
36587: LD_VAR 0 3
36591: PPUSH
36592: CALL_OW 314
36596: NOT
36597: IFFALSE 36646
// begin if not IsInUnit ( j ) then
36599: LD_VAR 0 3
36603: PPUSH
36604: CALL_OW 310
36608: NOT
36609: IFFALSE 36625
// ComEnterUnit ( j , selected ) ;
36611: LD_VAR 0 3
36615: PPUSH
36616: LD_VAR 0 7
36620: PPUSH
36621: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
36625: LD_VAR 0 3
36629: PPUSH
36630: LD_INT 16
36632: PPUSH
36633: CALL_OW 183
// AddComExitBuilding ( j ) ;
36637: LD_VAR 0 3
36641: PPUSH
36642: CALL_OW 182
// end ;
36646: GO 36584
36648: POP
36649: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
36650: LD_VAR 0 5
36654: PPUSH
36655: LD_INT 11
36657: PPUSH
36658: CALL_OW 325
36662: IFFALSE 36921
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36664: LD_ADDR_VAR 0 4
36668: PUSH
36669: LD_EXP 79
36673: PUSH
36674: LD_VAR 0 2
36678: ARRAY
36679: PPUSH
36680: LD_INT 25
36682: PUSH
36683: LD_INT 16
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PPUSH
36690: CALL_OW 72
36694: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
36695: LD_VAR 0 4
36699: PUSH
36700: LD_INT 6
36702: GREATEREQUAL
36703: PUSH
36704: LD_VAR 0 5
36708: PPUSH
36709: LD_INT 2
36711: PPUSH
36712: CALL_OW 325
36716: NOT
36717: OR
36718: IFFALSE 36921
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
36720: LD_ADDR_VAR 0 8
36724: PUSH
36725: LD_EXP 50
36729: PUSH
36730: LD_VAR 0 2
36734: ARRAY
36735: PPUSH
36736: LD_INT 2
36738: PUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 4
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 30
36751: PUSH
36752: LD_INT 5
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: LIST
36763: PPUSH
36764: CALL_OW 72
36768: ST_TO_ADDR
// if barracks then
36769: LD_VAR 0 8
36773: IFFALSE 36921
// begin selected := 0 ;
36775: LD_ADDR_VAR 0 7
36779: PUSH
36780: LD_INT 0
36782: ST_TO_ADDR
// for j in barracks do
36783: LD_ADDR_VAR 0 3
36787: PUSH
36788: LD_VAR 0 8
36792: PUSH
36793: FOR_IN
36794: IFFALSE 36825
// begin if UnitsInside ( j ) < 6 then
36796: LD_VAR 0 3
36800: PPUSH
36801: CALL_OW 313
36805: PUSH
36806: LD_INT 6
36808: LESS
36809: IFFALSE 36823
// begin selected := j ;
36811: LD_ADDR_VAR 0 7
36815: PUSH
36816: LD_VAR 0 3
36820: ST_TO_ADDR
// break ;
36821: GO 36825
// end ; end ;
36823: GO 36793
36825: POP
36826: POP
// if selected then
36827: LD_VAR 0 7
36831: IFFALSE 36921
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
36833: LD_ADDR_VAR 0 3
36837: PUSH
36838: LD_EXP 79
36842: PUSH
36843: LD_VAR 0 2
36847: ARRAY
36848: PPUSH
36849: LD_INT 25
36851: PUSH
36852: LD_INT 12
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PPUSH
36859: CALL_OW 72
36863: PUSH
36864: FOR_IN
36865: IFFALSE 36919
// if not IsInUnit ( j ) and not HasTask ( j ) then
36867: LD_VAR 0 3
36871: PPUSH
36872: CALL_OW 310
36876: NOT
36877: PUSH
36878: LD_VAR 0 3
36882: PPUSH
36883: CALL_OW 314
36887: NOT
36888: AND
36889: IFFALSE 36917
// begin ComEnterUnit ( j , selected ) ;
36891: LD_VAR 0 3
36895: PPUSH
36896: LD_VAR 0 7
36900: PPUSH
36901: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
36905: LD_VAR 0 3
36909: PPUSH
36910: LD_INT 15
36912: PPUSH
36913: CALL_OW 183
// end ;
36917: GO 36864
36919: POP
36920: POP
// end ; end ; end ; end ; end ;
36921: GO 36314
36923: POP
36924: POP
// end ;
36925: LD_VAR 0 1
36929: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
36930: LD_INT 0
36932: PPUSH
36933: PPUSH
36934: PPUSH
36935: PPUSH
// if not mc_bases then
36936: LD_EXP 50
36940: NOT
36941: IFFALSE 36945
// exit ;
36943: GO 37123
// for i = 1 to mc_bases do
36945: LD_ADDR_VAR 0 2
36949: PUSH
36950: DOUBLE
36951: LD_INT 1
36953: DEC
36954: ST_TO_ADDR
36955: LD_EXP 50
36959: PUSH
36960: FOR_TO
36961: IFFALSE 37121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_EXP 50
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: PPUSH
36979: LD_INT 25
36981: PUSH
36982: LD_INT 9
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PPUSH
36989: CALL_OW 72
36993: ST_TO_ADDR
// if not tmp then
36994: LD_VAR 0 4
36998: NOT
36999: IFFALSE 37003
// continue ;
37001: GO 36960
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37003: LD_EXP 76
37007: PUSH
37008: LD_VAR 0 2
37012: ARRAY
37013: PPUSH
37014: LD_INT 29
37016: PPUSH
37017: CALL_OW 325
37021: NOT
37022: PUSH
37023: LD_EXP 76
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PPUSH
37034: LD_INT 28
37036: PPUSH
37037: CALL_OW 325
37041: NOT
37042: AND
37043: IFFALSE 37047
// continue ;
37045: GO 36960
// for j in tmp do
37047: LD_ADDR_VAR 0 3
37051: PUSH
37052: LD_VAR 0 4
37056: PUSH
37057: FOR_IN
37058: IFFALSE 37117
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37060: LD_VAR 0 3
37064: PUSH
37065: LD_EXP 53
37069: PUSH
37070: LD_VAR 0 2
37074: ARRAY
37075: PUSH
37076: LD_INT 1
37078: ARRAY
37079: IN
37080: NOT
37081: PUSH
37082: LD_VAR 0 3
37086: PUSH
37087: LD_EXP 53
37091: PUSH
37092: LD_VAR 0 2
37096: ARRAY
37097: PUSH
37098: LD_INT 2
37100: ARRAY
37101: IN
37102: NOT
37103: AND
37104: IFFALSE 37115
// ComSpaceTimeShoot ( j ) ;
37106: LD_VAR 0 3
37110: PPUSH
37111: CALL 48141 0 1
37115: GO 37057
37117: POP
37118: POP
// end ;
37119: GO 36960
37121: POP
37122: POP
// end ;
37123: LD_VAR 0 1
37127: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37128: LD_INT 0
37130: PPUSH
37131: PPUSH
37132: PPUSH
37133: PPUSH
37134: PPUSH
37135: PPUSH
37136: PPUSH
37137: PPUSH
37138: PPUSH
// if not mc_bases then
37139: LD_EXP 50
37143: NOT
37144: IFFALSE 37148
// exit ;
37146: GO 37770
// for i = 1 to mc_bases do
37148: LD_ADDR_VAR 0 2
37152: PUSH
37153: DOUBLE
37154: LD_INT 1
37156: DEC
37157: ST_TO_ADDR
37158: LD_EXP 50
37162: PUSH
37163: FOR_TO
37164: IFFALSE 37768
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37166: LD_EXP 85
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: NOT
37177: PUSH
37178: LD_INT 38
37180: PPUSH
37181: LD_EXP 76
37185: PUSH
37186: LD_VAR 0 2
37190: ARRAY
37191: PPUSH
37192: CALL_OW 321
37196: PUSH
37197: LD_INT 2
37199: NONEQUAL
37200: OR
37201: IFFALSE 37205
// continue ;
37203: GO 37163
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37205: LD_ADDR_VAR 0 8
37209: PUSH
37210: LD_EXP 50
37214: PUSH
37215: LD_VAR 0 2
37219: ARRAY
37220: PPUSH
37221: LD_INT 30
37223: PUSH
37224: LD_INT 34
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PPUSH
37231: CALL_OW 72
37235: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37236: LD_ADDR_VAR 0 9
37240: PUSH
37241: LD_EXP 50
37245: PUSH
37246: LD_VAR 0 2
37250: ARRAY
37251: PPUSH
37252: LD_INT 25
37254: PUSH
37255: LD_INT 4
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PPUSH
37262: CALL_OW 72
37266: PPUSH
37267: LD_INT 0
37269: PPUSH
37270: CALL 87815 0 2
37274: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37275: LD_VAR 0 9
37279: NOT
37280: PUSH
37281: LD_VAR 0 8
37285: NOT
37286: OR
37287: PUSH
37288: LD_EXP 50
37292: PUSH
37293: LD_VAR 0 2
37297: ARRAY
37298: PPUSH
37299: LD_INT 124
37301: PPUSH
37302: CALL 87815 0 2
37306: OR
37307: IFFALSE 37311
// continue ;
37309: GO 37163
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37311: LD_EXP 86
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: PUSH
37322: LD_EXP 85
37326: PUSH
37327: LD_VAR 0 2
37331: ARRAY
37332: LESS
37333: PUSH
37334: LD_EXP 86
37338: PUSH
37339: LD_VAR 0 2
37343: ARRAY
37344: PUSH
37345: LD_VAR 0 8
37349: LESS
37350: AND
37351: IFFALSE 37766
// begin tmp := sci [ 1 ] ;
37353: LD_ADDR_VAR 0 7
37357: PUSH
37358: LD_VAR 0 9
37362: PUSH
37363: LD_INT 1
37365: ARRAY
37366: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37367: LD_VAR 0 7
37371: PPUSH
37372: LD_INT 124
37374: PPUSH
37375: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37379: LD_ADDR_VAR 0 3
37383: PUSH
37384: DOUBLE
37385: LD_EXP 85
37389: PUSH
37390: LD_VAR 0 2
37394: ARRAY
37395: INC
37396: ST_TO_ADDR
37397: LD_EXP 85
37401: PUSH
37402: LD_VAR 0 2
37406: ARRAY
37407: PUSH
37408: FOR_DOWNTO
37409: IFFALSE 37752
// begin if IsInUnit ( tmp ) then
37411: LD_VAR 0 7
37415: PPUSH
37416: CALL_OW 310
37420: IFFALSE 37431
// ComExitBuilding ( tmp ) ;
37422: LD_VAR 0 7
37426: PPUSH
37427: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37431: LD_INT 35
37433: PPUSH
37434: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37438: LD_VAR 0 7
37442: PPUSH
37443: CALL_OW 310
37447: NOT
37448: PUSH
37449: LD_VAR 0 7
37453: PPUSH
37454: CALL_OW 314
37458: NOT
37459: AND
37460: IFFALSE 37431
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37462: LD_ADDR_VAR 0 6
37466: PUSH
37467: LD_VAR 0 7
37471: PPUSH
37472: CALL_OW 250
37476: PUSH
37477: LD_VAR 0 7
37481: PPUSH
37482: CALL_OW 251
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
37491: LD_INT 35
37493: PPUSH
37494: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
37498: LD_ADDR_VAR 0 4
37502: PUSH
37503: LD_EXP 85
37507: PUSH
37508: LD_VAR 0 2
37512: ARRAY
37513: PUSH
37514: LD_VAR 0 3
37518: ARRAY
37519: PUSH
37520: LD_INT 1
37522: ARRAY
37523: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
37524: LD_ADDR_VAR 0 5
37528: PUSH
37529: LD_EXP 85
37533: PUSH
37534: LD_VAR 0 2
37538: ARRAY
37539: PUSH
37540: LD_VAR 0 3
37544: ARRAY
37545: PUSH
37546: LD_INT 2
37548: ARRAY
37549: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
37550: LD_VAR 0 7
37554: PPUSH
37555: LD_INT 10
37557: PPUSH
37558: CALL 57148 0 2
37562: PUSH
37563: LD_INT 4
37565: ARRAY
37566: IFFALSE 37604
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
37568: LD_VAR 0 7
37572: PPUSH
37573: LD_VAR 0 6
37577: PUSH
37578: LD_INT 1
37580: ARRAY
37581: PPUSH
37582: LD_VAR 0 6
37586: PUSH
37587: LD_INT 2
37589: ARRAY
37590: PPUSH
37591: CALL_OW 111
// wait ( 0 0$10 ) ;
37595: LD_INT 350
37597: PPUSH
37598: CALL_OW 67
// end else
37602: GO 37630
// begin ComMoveXY ( tmp , x , y ) ;
37604: LD_VAR 0 7
37608: PPUSH
37609: LD_VAR 0 4
37613: PPUSH
37614: LD_VAR 0 5
37618: PPUSH
37619: CALL_OW 111
// wait ( 0 0$3 ) ;
37623: LD_INT 105
37625: PPUSH
37626: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
37630: LD_VAR 0 7
37634: PPUSH
37635: LD_VAR 0 4
37639: PPUSH
37640: LD_VAR 0 5
37644: PPUSH
37645: CALL_OW 307
37649: IFFALSE 37491
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
37651: LD_VAR 0 7
37655: PPUSH
37656: LD_VAR 0 4
37660: PPUSH
37661: LD_VAR 0 5
37665: PPUSH
37666: LD_VAR 0 8
37670: PUSH
37671: LD_VAR 0 3
37675: ARRAY
37676: PPUSH
37677: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
37681: LD_INT 35
37683: PPUSH
37684: CALL_OW 67
// until not HasTask ( tmp ) ;
37688: LD_VAR 0 7
37692: PPUSH
37693: CALL_OW 314
37697: NOT
37698: IFFALSE 37681
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
37700: LD_ADDR_EXP 86
37704: PUSH
37705: LD_EXP 86
37709: PPUSH
37710: LD_VAR 0 2
37714: PUSH
37715: LD_EXP 86
37719: PUSH
37720: LD_VAR 0 2
37724: ARRAY
37725: PUSH
37726: LD_INT 1
37728: PLUS
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PPUSH
37734: LD_VAR 0 8
37738: PUSH
37739: LD_VAR 0 3
37743: ARRAY
37744: PPUSH
37745: CALL 54555 0 3
37749: ST_TO_ADDR
// end ;
37750: GO 37408
37752: POP
37753: POP
// MC_Reset ( i , 124 ) ;
37754: LD_VAR 0 2
37758: PPUSH
37759: LD_INT 124
37761: PPUSH
37762: CALL 21253 0 2
// end ; end ;
37766: GO 37163
37768: POP
37769: POP
// end ;
37770: LD_VAR 0 1
37774: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
37775: LD_INT 0
37777: PPUSH
37778: PPUSH
37779: PPUSH
// if not mc_bases then
37780: LD_EXP 50
37784: NOT
37785: IFFALSE 37789
// exit ;
37787: GO 38395
// for i = 1 to mc_bases do
37789: LD_ADDR_VAR 0 2
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_EXP 50
37803: PUSH
37804: FOR_TO
37805: IFFALSE 38393
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
37807: LD_ADDR_VAR 0 3
37811: PUSH
37812: LD_EXP 50
37816: PUSH
37817: LD_VAR 0 2
37821: ARRAY
37822: PPUSH
37823: LD_INT 25
37825: PUSH
37826: LD_INT 4
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PPUSH
37833: CALL_OW 72
37837: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
37838: LD_VAR 0 3
37842: NOT
37843: PUSH
37844: LD_EXP 87
37848: PUSH
37849: LD_VAR 0 2
37853: ARRAY
37854: NOT
37855: OR
37856: PUSH
37857: LD_EXP 50
37861: PUSH
37862: LD_VAR 0 2
37866: ARRAY
37867: PPUSH
37868: LD_INT 2
37870: PUSH
37871: LD_INT 30
37873: PUSH
37874: LD_INT 0
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 30
37883: PUSH
37884: LD_INT 1
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: LIST
37895: PPUSH
37896: CALL_OW 72
37900: NOT
37901: OR
37902: IFFALSE 37952
// begin if mc_deposits_finder [ i ] then
37904: LD_EXP 88
37908: PUSH
37909: LD_VAR 0 2
37913: ARRAY
37914: IFFALSE 37950
// begin MC_Reset ( i , 125 ) ;
37916: LD_VAR 0 2
37920: PPUSH
37921: LD_INT 125
37923: PPUSH
37924: CALL 21253 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37928: LD_ADDR_EXP 88
37932: PUSH
37933: LD_EXP 88
37937: PPUSH
37938: LD_VAR 0 2
37942: PPUSH
37943: EMPTY
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// end ; continue ;
37950: GO 37804
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
37952: LD_EXP 87
37956: PUSH
37957: LD_VAR 0 2
37961: ARRAY
37962: PUSH
37963: LD_INT 1
37965: ARRAY
37966: PUSH
37967: LD_INT 3
37969: ARRAY
37970: PUSH
37971: LD_INT 1
37973: EQUAL
37974: PUSH
37975: LD_INT 20
37977: PPUSH
37978: LD_EXP 76
37982: PUSH
37983: LD_VAR 0 2
37987: ARRAY
37988: PPUSH
37989: CALL_OW 321
37993: PUSH
37994: LD_INT 2
37996: NONEQUAL
37997: AND
37998: IFFALSE 38048
// begin if mc_deposits_finder [ i ] then
38000: LD_EXP 88
38004: PUSH
38005: LD_VAR 0 2
38009: ARRAY
38010: IFFALSE 38046
// begin MC_Reset ( i , 125 ) ;
38012: LD_VAR 0 2
38016: PPUSH
38017: LD_INT 125
38019: PPUSH
38020: CALL 21253 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38024: LD_ADDR_EXP 88
38028: PUSH
38029: LD_EXP 88
38033: PPUSH
38034: LD_VAR 0 2
38038: PPUSH
38039: EMPTY
38040: PPUSH
38041: CALL_OW 1
38045: ST_TO_ADDR
// end ; continue ;
38046: GO 37804
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38048: LD_EXP 87
38052: PUSH
38053: LD_VAR 0 2
38057: ARRAY
38058: PUSH
38059: LD_INT 1
38061: ARRAY
38062: PUSH
38063: LD_INT 1
38065: ARRAY
38066: PPUSH
38067: LD_EXP 87
38071: PUSH
38072: LD_VAR 0 2
38076: ARRAY
38077: PUSH
38078: LD_INT 1
38080: ARRAY
38081: PUSH
38082: LD_INT 2
38084: ARRAY
38085: PPUSH
38086: LD_EXP 76
38090: PUSH
38091: LD_VAR 0 2
38095: ARRAY
38096: PPUSH
38097: CALL_OW 440
38101: IFFALSE 38144
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38103: LD_ADDR_EXP 87
38107: PUSH
38108: LD_EXP 87
38112: PPUSH
38113: LD_VAR 0 2
38117: PPUSH
38118: LD_EXP 87
38122: PUSH
38123: LD_VAR 0 2
38127: ARRAY
38128: PPUSH
38129: LD_INT 1
38131: PPUSH
38132: CALL_OW 3
38136: PPUSH
38137: CALL_OW 1
38141: ST_TO_ADDR
38142: GO 38391
// begin if not mc_deposits_finder [ i ] then
38144: LD_EXP 88
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: NOT
38155: IFFALSE 38207
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38157: LD_ADDR_EXP 88
38161: PUSH
38162: LD_EXP 88
38166: PPUSH
38167: LD_VAR 0 2
38171: PPUSH
38172: LD_VAR 0 3
38176: PUSH
38177: LD_INT 1
38179: ARRAY
38180: PUSH
38181: EMPTY
38182: LIST
38183: PPUSH
38184: CALL_OW 1
38188: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38189: LD_VAR 0 3
38193: PUSH
38194: LD_INT 1
38196: ARRAY
38197: PPUSH
38198: LD_INT 125
38200: PPUSH
38201: CALL_OW 109
// end else
38205: GO 38391
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38207: LD_EXP 88
38211: PUSH
38212: LD_VAR 0 2
38216: ARRAY
38217: PUSH
38218: LD_INT 1
38220: ARRAY
38221: PPUSH
38222: CALL_OW 310
38226: IFFALSE 38249
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38228: LD_EXP 88
38232: PUSH
38233: LD_VAR 0 2
38237: ARRAY
38238: PUSH
38239: LD_INT 1
38241: ARRAY
38242: PPUSH
38243: CALL_OW 122
38247: GO 38391
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38249: LD_EXP 88
38253: PUSH
38254: LD_VAR 0 2
38258: ARRAY
38259: PUSH
38260: LD_INT 1
38262: ARRAY
38263: PPUSH
38264: CALL_OW 314
38268: NOT
38269: PUSH
38270: LD_EXP 88
38274: PUSH
38275: LD_VAR 0 2
38279: ARRAY
38280: PUSH
38281: LD_INT 1
38283: ARRAY
38284: PPUSH
38285: LD_EXP 87
38289: PUSH
38290: LD_VAR 0 2
38294: ARRAY
38295: PUSH
38296: LD_INT 1
38298: ARRAY
38299: PUSH
38300: LD_INT 1
38302: ARRAY
38303: PPUSH
38304: LD_EXP 87
38308: PUSH
38309: LD_VAR 0 2
38313: ARRAY
38314: PUSH
38315: LD_INT 1
38317: ARRAY
38318: PUSH
38319: LD_INT 2
38321: ARRAY
38322: PPUSH
38323: CALL_OW 297
38327: PUSH
38328: LD_INT 6
38330: GREATER
38331: AND
38332: IFFALSE 38391
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38334: LD_EXP 88
38338: PUSH
38339: LD_VAR 0 2
38343: ARRAY
38344: PUSH
38345: LD_INT 1
38347: ARRAY
38348: PPUSH
38349: LD_EXP 87
38353: PUSH
38354: LD_VAR 0 2
38358: ARRAY
38359: PUSH
38360: LD_INT 1
38362: ARRAY
38363: PUSH
38364: LD_INT 1
38366: ARRAY
38367: PPUSH
38368: LD_EXP 87
38372: PUSH
38373: LD_VAR 0 2
38377: ARRAY
38378: PUSH
38379: LD_INT 1
38381: ARRAY
38382: PUSH
38383: LD_INT 2
38385: ARRAY
38386: PPUSH
38387: CALL_OW 111
// end ; end ; end ;
38391: GO 37804
38393: POP
38394: POP
// end ;
38395: LD_VAR 0 1
38399: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38400: LD_INT 0
38402: PPUSH
38403: PPUSH
38404: PPUSH
38405: PPUSH
38406: PPUSH
38407: PPUSH
38408: PPUSH
38409: PPUSH
38410: PPUSH
38411: PPUSH
38412: PPUSH
// if not mc_bases then
38413: LD_EXP 50
38417: NOT
38418: IFFALSE 38422
// exit ;
38420: GO 39362
// for i = 1 to mc_bases do
38422: LD_ADDR_VAR 0 2
38426: PUSH
38427: DOUBLE
38428: LD_INT 1
38430: DEC
38431: ST_TO_ADDR
38432: LD_EXP 50
38436: PUSH
38437: FOR_TO
38438: IFFALSE 39360
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38440: LD_EXP 50
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: NOT
38451: PUSH
38452: LD_EXP 73
38456: PUSH
38457: LD_VAR 0 2
38461: ARRAY
38462: OR
38463: IFFALSE 38467
// continue ;
38465: GO 38437
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38467: LD_ADDR_VAR 0 7
38471: PUSH
38472: LD_EXP 50
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PUSH
38483: LD_INT 1
38485: ARRAY
38486: PPUSH
38487: CALL_OW 248
38491: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
38492: LD_VAR 0 7
38496: PUSH
38497: LD_INT 3
38499: EQUAL
38500: PUSH
38501: LD_EXP 69
38505: PUSH
38506: LD_VAR 0 2
38510: ARRAY
38511: PUSH
38512: LD_EXP 72
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: UNION
38523: PPUSH
38524: LD_INT 33
38526: PUSH
38527: LD_INT 2
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PPUSH
38534: CALL_OW 72
38538: NOT
38539: OR
38540: IFFALSE 38544
// continue ;
38542: GO 38437
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
38544: LD_ADDR_VAR 0 9
38548: PUSH
38549: LD_EXP 50
38553: PUSH
38554: LD_VAR 0 2
38558: ARRAY
38559: PPUSH
38560: LD_INT 30
38562: PUSH
38563: LD_INT 36
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PPUSH
38570: CALL_OW 72
38574: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
38575: LD_ADDR_VAR 0 10
38579: PUSH
38580: LD_EXP 69
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: PPUSH
38591: LD_INT 34
38593: PUSH
38594: LD_INT 31
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PPUSH
38601: CALL_OW 72
38605: ST_TO_ADDR
// if not cts and not mcts then
38606: LD_VAR 0 9
38610: NOT
38611: PUSH
38612: LD_VAR 0 10
38616: NOT
38617: AND
38618: IFFALSE 38622
// continue ;
38620: GO 38437
// x := cts ;
38622: LD_ADDR_VAR 0 11
38626: PUSH
38627: LD_VAR 0 9
38631: ST_TO_ADDR
// if not x then
38632: LD_VAR 0 11
38636: NOT
38637: IFFALSE 38649
// x := mcts ;
38639: LD_ADDR_VAR 0 11
38643: PUSH
38644: LD_VAR 0 10
38648: ST_TO_ADDR
// if not x then
38649: LD_VAR 0 11
38653: NOT
38654: IFFALSE 38658
// continue ;
38656: GO 38437
// if mc_remote_driver [ i ] then
38658: LD_EXP 90
38662: PUSH
38663: LD_VAR 0 2
38667: ARRAY
38668: IFFALSE 39055
// for j in mc_remote_driver [ i ] do
38670: LD_ADDR_VAR 0 3
38674: PUSH
38675: LD_EXP 90
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: PUSH
38686: FOR_IN
38687: IFFALSE 39053
// begin if GetClass ( j ) <> 3 then
38689: LD_VAR 0 3
38693: PPUSH
38694: CALL_OW 257
38698: PUSH
38699: LD_INT 3
38701: NONEQUAL
38702: IFFALSE 38755
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
38704: LD_ADDR_EXP 90
38708: PUSH
38709: LD_EXP 90
38713: PPUSH
38714: LD_VAR 0 2
38718: PPUSH
38719: LD_EXP 90
38723: PUSH
38724: LD_VAR 0 2
38728: ARRAY
38729: PUSH
38730: LD_VAR 0 3
38734: DIFF
38735: PPUSH
38736: CALL_OW 1
38740: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38741: LD_VAR 0 3
38745: PPUSH
38746: LD_INT 0
38748: PPUSH
38749: CALL_OW 109
// continue ;
38753: GO 38686
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
38755: LD_EXP 69
38759: PUSH
38760: LD_VAR 0 2
38764: ARRAY
38765: PPUSH
38766: LD_INT 34
38768: PUSH
38769: LD_INT 31
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 58
38778: PUSH
38779: EMPTY
38780: LIST
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PPUSH
38786: CALL_OW 72
38790: PUSH
38791: LD_VAR 0 3
38795: PPUSH
38796: CALL 87903 0 1
38800: NOT
38801: AND
38802: IFFALSE 38873
// begin if IsInUnit ( j ) then
38804: LD_VAR 0 3
38808: PPUSH
38809: CALL_OW 310
38813: IFFALSE 38824
// ComExitBuilding ( j ) ;
38815: LD_VAR 0 3
38819: PPUSH
38820: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
38824: LD_VAR 0 3
38828: PPUSH
38829: LD_EXP 69
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PPUSH
38840: LD_INT 34
38842: PUSH
38843: LD_INT 31
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 58
38852: PUSH
38853: EMPTY
38854: LIST
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PPUSH
38860: CALL_OW 72
38864: PUSH
38865: LD_INT 1
38867: ARRAY
38868: PPUSH
38869: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
38873: LD_VAR 0 3
38877: PPUSH
38878: CALL_OW 310
38882: NOT
38883: PUSH
38884: LD_VAR 0 3
38888: PPUSH
38889: CALL_OW 310
38893: PPUSH
38894: CALL_OW 266
38898: PUSH
38899: LD_INT 36
38901: NONEQUAL
38902: PUSH
38903: LD_VAR 0 3
38907: PPUSH
38908: CALL 87903 0 1
38912: NOT
38913: AND
38914: OR
38915: IFFALSE 39051
// begin if IsInUnit ( j ) then
38917: LD_VAR 0 3
38921: PPUSH
38922: CALL_OW 310
38926: IFFALSE 38937
// ComExitBuilding ( j ) ;
38928: LD_VAR 0 3
38932: PPUSH
38933: CALL_OW 122
// ct := 0 ;
38937: LD_ADDR_VAR 0 8
38941: PUSH
38942: LD_INT 0
38944: ST_TO_ADDR
// for k in x do
38945: LD_ADDR_VAR 0 4
38949: PUSH
38950: LD_VAR 0 11
38954: PUSH
38955: FOR_IN
38956: IFFALSE 39029
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
38958: LD_VAR 0 4
38962: PPUSH
38963: CALL_OW 264
38967: PUSH
38968: LD_INT 31
38970: EQUAL
38971: PUSH
38972: LD_VAR 0 4
38976: PPUSH
38977: CALL_OW 311
38981: NOT
38982: AND
38983: PUSH
38984: LD_VAR 0 4
38988: PPUSH
38989: CALL_OW 266
38993: PUSH
38994: LD_INT 36
38996: EQUAL
38997: PUSH
38998: LD_VAR 0 4
39002: PPUSH
39003: CALL_OW 313
39007: PUSH
39008: LD_INT 3
39010: LESS
39011: AND
39012: OR
39013: IFFALSE 39027
// begin ct := k ;
39015: LD_ADDR_VAR 0 8
39019: PUSH
39020: LD_VAR 0 4
39024: ST_TO_ADDR
// break ;
39025: GO 39029
// end ;
39027: GO 38955
39029: POP
39030: POP
// if ct then
39031: LD_VAR 0 8
39035: IFFALSE 39051
// ComEnterUnit ( j , ct ) ;
39037: LD_VAR 0 3
39041: PPUSH
39042: LD_VAR 0 8
39046: PPUSH
39047: CALL_OW 120
// end ; end ;
39051: GO 38686
39053: POP
39054: POP
// places := 0 ;
39055: LD_ADDR_VAR 0 5
39059: PUSH
39060: LD_INT 0
39062: ST_TO_ADDR
// for j = 1 to x do
39063: LD_ADDR_VAR 0 3
39067: PUSH
39068: DOUBLE
39069: LD_INT 1
39071: DEC
39072: ST_TO_ADDR
39073: LD_VAR 0 11
39077: PUSH
39078: FOR_TO
39079: IFFALSE 39155
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39081: LD_VAR 0 11
39085: PUSH
39086: LD_VAR 0 3
39090: ARRAY
39091: PPUSH
39092: CALL_OW 264
39096: PUSH
39097: LD_INT 31
39099: EQUAL
39100: IFFALSE 39118
// places := places + 1 else
39102: LD_ADDR_VAR 0 5
39106: PUSH
39107: LD_VAR 0 5
39111: PUSH
39112: LD_INT 1
39114: PLUS
39115: ST_TO_ADDR
39116: GO 39153
// if GetBType ( x [ j ] ) = b_control_tower then
39118: LD_VAR 0 11
39122: PUSH
39123: LD_VAR 0 3
39127: ARRAY
39128: PPUSH
39129: CALL_OW 266
39133: PUSH
39134: LD_INT 36
39136: EQUAL
39137: IFFALSE 39153
// places := places + 3 ;
39139: LD_ADDR_VAR 0 5
39143: PUSH
39144: LD_VAR 0 5
39148: PUSH
39149: LD_INT 3
39151: PLUS
39152: ST_TO_ADDR
39153: GO 39078
39155: POP
39156: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39157: LD_VAR 0 5
39161: PUSH
39162: LD_INT 0
39164: EQUAL
39165: PUSH
39166: LD_VAR 0 5
39170: PUSH
39171: LD_EXP 90
39175: PUSH
39176: LD_VAR 0 2
39180: ARRAY
39181: LESSEQUAL
39182: OR
39183: IFFALSE 39187
// continue ;
39185: GO 38437
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39187: LD_ADDR_VAR 0 6
39191: PUSH
39192: LD_EXP 50
39196: PUSH
39197: LD_VAR 0 2
39201: ARRAY
39202: PPUSH
39203: LD_INT 25
39205: PUSH
39206: LD_INT 3
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PPUSH
39213: CALL_OW 72
39217: PUSH
39218: LD_EXP 90
39222: PUSH
39223: LD_VAR 0 2
39227: ARRAY
39228: DIFF
39229: PPUSH
39230: LD_INT 3
39232: PPUSH
39233: CALL 88803 0 2
39237: ST_TO_ADDR
// for j in tmp do
39238: LD_ADDR_VAR 0 3
39242: PUSH
39243: LD_VAR 0 6
39247: PUSH
39248: FOR_IN
39249: IFFALSE 39284
// if GetTag ( j ) > 0 then
39251: LD_VAR 0 3
39255: PPUSH
39256: CALL_OW 110
39260: PUSH
39261: LD_INT 0
39263: GREATER
39264: IFFALSE 39282
// tmp := tmp diff j ;
39266: LD_ADDR_VAR 0 6
39270: PUSH
39271: LD_VAR 0 6
39275: PUSH
39276: LD_VAR 0 3
39280: DIFF
39281: ST_TO_ADDR
39282: GO 39248
39284: POP
39285: POP
// if not tmp then
39286: LD_VAR 0 6
39290: NOT
39291: IFFALSE 39295
// continue ;
39293: GO 38437
// if places then
39295: LD_VAR 0 5
39299: IFFALSE 39358
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39301: LD_ADDR_EXP 90
39305: PUSH
39306: LD_EXP 90
39310: PPUSH
39311: LD_VAR 0 2
39315: PPUSH
39316: LD_EXP 90
39320: PUSH
39321: LD_VAR 0 2
39325: ARRAY
39326: PUSH
39327: LD_VAR 0 6
39331: PUSH
39332: LD_INT 1
39334: ARRAY
39335: UNION
39336: PPUSH
39337: CALL_OW 1
39341: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39342: LD_VAR 0 6
39346: PUSH
39347: LD_INT 1
39349: ARRAY
39350: PPUSH
39351: LD_INT 126
39353: PPUSH
39354: CALL_OW 109
// end ; end ;
39358: GO 38437
39360: POP
39361: POP
// end ;
39362: LD_VAR 0 1
39366: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39367: LD_INT 0
39369: PPUSH
39370: PPUSH
39371: PPUSH
39372: PPUSH
39373: PPUSH
39374: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39375: LD_VAR 0 1
39379: NOT
39380: PUSH
39381: LD_VAR 0 2
39385: NOT
39386: OR
39387: PUSH
39388: LD_VAR 0 3
39392: NOT
39393: OR
39394: PUSH
39395: LD_VAR 0 4
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: LD_INT 2
39405: PUSH
39406: LD_INT 3
39408: PUSH
39409: LD_INT 4
39411: PUSH
39412: LD_INT 5
39414: PUSH
39415: LD_INT 8
39417: PUSH
39418: LD_INT 9
39420: PUSH
39421: LD_INT 15
39423: PUSH
39424: LD_INT 16
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: IN
39438: NOT
39439: OR
39440: IFFALSE 39444
// exit ;
39442: GO 40344
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39444: LD_ADDR_VAR 0 2
39448: PUSH
39449: LD_VAR 0 2
39453: PPUSH
39454: LD_INT 21
39456: PUSH
39457: LD_INT 3
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 24
39466: PUSH
39467: LD_INT 250
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PPUSH
39478: CALL_OW 72
39482: ST_TO_ADDR
// case class of 1 , 15 :
39483: LD_VAR 0 4
39487: PUSH
39488: LD_INT 1
39490: DOUBLE
39491: EQUAL
39492: IFTRUE 39502
39494: LD_INT 15
39496: DOUBLE
39497: EQUAL
39498: IFTRUE 39502
39500: GO 39587
39502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
39503: LD_ADDR_VAR 0 8
39507: PUSH
39508: LD_VAR 0 2
39512: PPUSH
39513: LD_INT 2
39515: PUSH
39516: LD_INT 30
39518: PUSH
39519: LD_INT 32
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 30
39528: PUSH
39529: LD_INT 31
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: LIST
39540: PPUSH
39541: CALL_OW 72
39545: PUSH
39546: LD_VAR 0 2
39550: PPUSH
39551: LD_INT 2
39553: PUSH
39554: LD_INT 30
39556: PUSH
39557: LD_INT 4
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 30
39566: PUSH
39567: LD_INT 5
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: LIST
39578: PPUSH
39579: CALL_OW 72
39583: ADD
39584: ST_TO_ADDR
39585: GO 39833
39587: LD_INT 2
39589: DOUBLE
39590: EQUAL
39591: IFTRUE 39601
39593: LD_INT 16
39595: DOUBLE
39596: EQUAL
39597: IFTRUE 39601
39599: GO 39647
39601: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
39602: LD_ADDR_VAR 0 8
39606: PUSH
39607: LD_VAR 0 2
39611: PPUSH
39612: LD_INT 2
39614: PUSH
39615: LD_INT 30
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 30
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: LIST
39639: PPUSH
39640: CALL_OW 72
39644: ST_TO_ADDR
39645: GO 39833
39647: LD_INT 3
39649: DOUBLE
39650: EQUAL
39651: IFTRUE 39655
39653: GO 39701
39655: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
39656: LD_ADDR_VAR 0 8
39660: PUSH
39661: LD_VAR 0 2
39665: PPUSH
39666: LD_INT 2
39668: PUSH
39669: LD_INT 30
39671: PUSH
39672: LD_INT 2
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: LIST
39693: PPUSH
39694: CALL_OW 72
39698: ST_TO_ADDR
39699: GO 39833
39701: LD_INT 4
39703: DOUBLE
39704: EQUAL
39705: IFTRUE 39709
39707: GO 39766
39709: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
39710: LD_ADDR_VAR 0 8
39714: PUSH
39715: LD_VAR 0 2
39719: PPUSH
39720: LD_INT 2
39722: PUSH
39723: LD_INT 30
39725: PUSH
39726: LD_INT 6
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 30
39735: PUSH
39736: LD_INT 7
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 30
39745: PUSH
39746: LD_INT 8
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: PPUSH
39759: CALL_OW 72
39763: ST_TO_ADDR
39764: GO 39833
39766: LD_INT 5
39768: DOUBLE
39769: EQUAL
39770: IFTRUE 39786
39772: LD_INT 8
39774: DOUBLE
39775: EQUAL
39776: IFTRUE 39786
39778: LD_INT 9
39780: DOUBLE
39781: EQUAL
39782: IFTRUE 39786
39784: GO 39832
39786: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
39787: LD_ADDR_VAR 0 8
39791: PUSH
39792: LD_VAR 0 2
39796: PPUSH
39797: LD_INT 2
39799: PUSH
39800: LD_INT 30
39802: PUSH
39803: LD_INT 4
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 30
39812: PUSH
39813: LD_INT 5
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: LIST
39824: PPUSH
39825: CALL_OW 72
39829: ST_TO_ADDR
39830: GO 39833
39832: POP
// if not tmp then
39833: LD_VAR 0 8
39837: NOT
39838: IFFALSE 39842
// exit ;
39840: GO 40344
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
39842: LD_VAR 0 4
39846: PUSH
39847: LD_INT 1
39849: PUSH
39850: LD_INT 15
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: IN
39857: PUSH
39858: LD_EXP 59
39862: PUSH
39863: LD_VAR 0 1
39867: ARRAY
39868: AND
39869: IFFALSE 40025
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
39871: LD_ADDR_VAR 0 9
39875: PUSH
39876: LD_EXP 59
39880: PUSH
39881: LD_VAR 0 1
39885: ARRAY
39886: PUSH
39887: LD_INT 1
39889: ARRAY
39890: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
39891: LD_VAR 0 9
39895: PUSH
39896: LD_EXP 60
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: IN
39907: NOT
39908: IFFALSE 40023
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
39910: LD_ADDR_EXP 60
39914: PUSH
39915: LD_EXP 60
39919: PPUSH
39920: LD_VAR 0 1
39924: PUSH
39925: LD_EXP 60
39929: PUSH
39930: LD_VAR 0 1
39934: ARRAY
39935: PUSH
39936: LD_INT 1
39938: PLUS
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PPUSH
39944: LD_VAR 0 9
39948: PPUSH
39949: CALL 54555 0 3
39953: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
39954: LD_ADDR_EXP 59
39958: PUSH
39959: LD_EXP 59
39963: PPUSH
39964: LD_VAR 0 1
39968: PPUSH
39969: LD_EXP 59
39973: PUSH
39974: LD_VAR 0 1
39978: ARRAY
39979: PUSH
39980: LD_VAR 0 9
39984: DIFF
39985: PPUSH
39986: CALL_OW 1
39990: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
39991: LD_VAR 0 3
39995: PPUSH
39996: LD_EXP 60
40000: PUSH
40001: LD_VAR 0 1
40005: ARRAY
40006: PUSH
40007: LD_EXP 60
40011: PUSH
40012: LD_VAR 0 1
40016: ARRAY
40017: ARRAY
40018: PPUSH
40019: CALL_OW 120
// end ; exit ;
40023: GO 40344
// end ; if tmp > 1 then
40025: LD_VAR 0 8
40029: PUSH
40030: LD_INT 1
40032: GREATER
40033: IFFALSE 40137
// for i = 2 to tmp do
40035: LD_ADDR_VAR 0 6
40039: PUSH
40040: DOUBLE
40041: LD_INT 2
40043: DEC
40044: ST_TO_ADDR
40045: LD_VAR 0 8
40049: PUSH
40050: FOR_TO
40051: IFFALSE 40135
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40053: LD_VAR 0 8
40057: PUSH
40058: LD_VAR 0 6
40062: ARRAY
40063: PPUSH
40064: CALL_OW 461
40068: PUSH
40069: LD_INT 6
40071: EQUAL
40072: IFFALSE 40133
// begin x := tmp [ i ] ;
40074: LD_ADDR_VAR 0 9
40078: PUSH
40079: LD_VAR 0 8
40083: PUSH
40084: LD_VAR 0 6
40088: ARRAY
40089: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40090: LD_ADDR_VAR 0 8
40094: PUSH
40095: LD_VAR 0 8
40099: PPUSH
40100: LD_VAR 0 6
40104: PPUSH
40105: CALL_OW 3
40109: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40110: LD_ADDR_VAR 0 8
40114: PUSH
40115: LD_VAR 0 8
40119: PPUSH
40120: LD_INT 1
40122: PPUSH
40123: LD_VAR 0 9
40127: PPUSH
40128: CALL_OW 2
40132: ST_TO_ADDR
// end ;
40133: GO 40050
40135: POP
40136: POP
// for i in tmp do
40137: LD_ADDR_VAR 0 6
40141: PUSH
40142: LD_VAR 0 8
40146: PUSH
40147: FOR_IN
40148: IFFALSE 40217
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40150: LD_VAR 0 6
40154: PPUSH
40155: CALL_OW 313
40159: PUSH
40160: LD_INT 6
40162: LESS
40163: PUSH
40164: LD_VAR 0 6
40168: PPUSH
40169: CALL_OW 266
40173: PUSH
40174: LD_INT 31
40176: PUSH
40177: LD_INT 32
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: IN
40184: NOT
40185: AND
40186: PUSH
40187: LD_VAR 0 6
40191: PPUSH
40192: CALL_OW 313
40196: PUSH
40197: LD_INT 0
40199: EQUAL
40200: OR
40201: IFFALSE 40215
// begin j := i ;
40203: LD_ADDR_VAR 0 7
40207: PUSH
40208: LD_VAR 0 6
40212: ST_TO_ADDR
// break ;
40213: GO 40217
// end ; end ;
40215: GO 40147
40217: POP
40218: POP
// if j then
40219: LD_VAR 0 7
40223: IFFALSE 40241
// ComEnterUnit ( unit , j ) else
40225: LD_VAR 0 3
40229: PPUSH
40230: LD_VAR 0 7
40234: PPUSH
40235: CALL_OW 120
40239: GO 40344
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40241: LD_ADDR_VAR 0 10
40245: PUSH
40246: LD_VAR 0 2
40250: PPUSH
40251: LD_INT 2
40253: PUSH
40254: LD_INT 30
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 30
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: LIST
40278: PPUSH
40279: CALL_OW 72
40283: ST_TO_ADDR
// if depot then
40284: LD_VAR 0 10
40288: IFFALSE 40344
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40290: LD_ADDR_VAR 0 10
40294: PUSH
40295: LD_VAR 0 10
40299: PPUSH
40300: LD_VAR 0 3
40304: PPUSH
40305: CALL_OW 74
40309: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40310: LD_VAR 0 3
40314: PPUSH
40315: LD_VAR 0 10
40319: PPUSH
40320: CALL_OW 296
40324: PUSH
40325: LD_INT 10
40327: GREATER
40328: IFFALSE 40344
// ComStandNearbyBuilding ( unit , depot ) ;
40330: LD_VAR 0 3
40334: PPUSH
40335: LD_VAR 0 10
40339: PPUSH
40340: CALL 48758 0 2
// end ; end ; end ;
40344: LD_VAR 0 5
40348: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40349: LD_INT 0
40351: PPUSH
40352: PPUSH
40353: PPUSH
40354: PPUSH
// if not mc_bases then
40355: LD_EXP 50
40359: NOT
40360: IFFALSE 40364
// exit ;
40362: GO 40603
// for i = 1 to mc_bases do
40364: LD_ADDR_VAR 0 2
40368: PUSH
40369: DOUBLE
40370: LD_INT 1
40372: DEC
40373: ST_TO_ADDR
40374: LD_EXP 50
40378: PUSH
40379: FOR_TO
40380: IFFALSE 40601
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40382: LD_ADDR_VAR 0 4
40386: PUSH
40387: LD_EXP 50
40391: PUSH
40392: LD_VAR 0 2
40396: ARRAY
40397: PPUSH
40398: LD_INT 21
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PPUSH
40408: CALL_OW 72
40412: PUSH
40413: LD_EXP 79
40417: PUSH
40418: LD_VAR 0 2
40422: ARRAY
40423: UNION
40424: ST_TO_ADDR
// if not tmp then
40425: LD_VAR 0 4
40429: NOT
40430: IFFALSE 40434
// continue ;
40432: GO 40379
// for j in tmp do
40434: LD_ADDR_VAR 0 3
40438: PUSH
40439: LD_VAR 0 4
40443: PUSH
40444: FOR_IN
40445: IFFALSE 40597
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40447: LD_VAR 0 3
40451: PPUSH
40452: CALL_OW 110
40456: NOT
40457: PUSH
40458: LD_VAR 0 3
40462: PPUSH
40463: CALL_OW 314
40467: NOT
40468: AND
40469: PUSH
40470: LD_VAR 0 3
40474: PPUSH
40475: CALL_OW 311
40479: NOT
40480: AND
40481: PUSH
40482: LD_VAR 0 3
40486: PPUSH
40487: CALL_OW 310
40491: NOT
40492: AND
40493: PUSH
40494: LD_VAR 0 3
40498: PUSH
40499: LD_EXP 53
40503: PUSH
40504: LD_VAR 0 2
40508: ARRAY
40509: PUSH
40510: LD_INT 1
40512: ARRAY
40513: IN
40514: NOT
40515: AND
40516: PUSH
40517: LD_VAR 0 3
40521: PUSH
40522: LD_EXP 53
40526: PUSH
40527: LD_VAR 0 2
40531: ARRAY
40532: PUSH
40533: LD_INT 2
40535: ARRAY
40536: IN
40537: NOT
40538: AND
40539: PUSH
40540: LD_VAR 0 3
40544: PUSH
40545: LD_EXP 62
40549: PUSH
40550: LD_VAR 0 2
40554: ARRAY
40555: IN
40556: NOT
40557: AND
40558: IFFALSE 40595
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
40560: LD_VAR 0 2
40564: PPUSH
40565: LD_EXP 50
40569: PUSH
40570: LD_VAR 0 2
40574: ARRAY
40575: PPUSH
40576: LD_VAR 0 3
40580: PPUSH
40581: LD_VAR 0 3
40585: PPUSH
40586: CALL_OW 257
40590: PPUSH
40591: CALL 39367 0 4
// end ;
40595: GO 40444
40597: POP
40598: POP
// end ;
40599: GO 40379
40601: POP
40602: POP
// end ;
40603: LD_VAR 0 1
40607: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
40608: LD_INT 0
40610: PPUSH
40611: PPUSH
40612: PPUSH
40613: PPUSH
40614: PPUSH
40615: PPUSH
// if not mc_bases [ base ] then
40616: LD_EXP 50
40620: PUSH
40621: LD_VAR 0 1
40625: ARRAY
40626: NOT
40627: IFFALSE 40631
// exit ;
40629: GO 40813
// tmp := [ ] ;
40631: LD_ADDR_VAR 0 6
40635: PUSH
40636: EMPTY
40637: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
40638: LD_ADDR_VAR 0 7
40642: PUSH
40643: LD_VAR 0 3
40647: PPUSH
40648: LD_INT 0
40650: PPUSH
40651: CALL_OW 517
40655: ST_TO_ADDR
// if not list then
40656: LD_VAR 0 7
40660: NOT
40661: IFFALSE 40665
// exit ;
40663: GO 40813
// for i = 1 to amount do
40665: LD_ADDR_VAR 0 5
40669: PUSH
40670: DOUBLE
40671: LD_INT 1
40673: DEC
40674: ST_TO_ADDR
40675: LD_VAR 0 2
40679: PUSH
40680: FOR_TO
40681: IFFALSE 40761
// begin x := rand ( 1 , list [ 1 ] ) ;
40683: LD_ADDR_VAR 0 8
40687: PUSH
40688: LD_INT 1
40690: PPUSH
40691: LD_VAR 0 7
40695: PUSH
40696: LD_INT 1
40698: ARRAY
40699: PPUSH
40700: CALL_OW 12
40704: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
40705: LD_ADDR_VAR 0 6
40709: PUSH
40710: LD_VAR 0 6
40714: PPUSH
40715: LD_VAR 0 5
40719: PPUSH
40720: LD_VAR 0 7
40724: PUSH
40725: LD_INT 1
40727: ARRAY
40728: PUSH
40729: LD_VAR 0 8
40733: ARRAY
40734: PUSH
40735: LD_VAR 0 7
40739: PUSH
40740: LD_INT 2
40742: ARRAY
40743: PUSH
40744: LD_VAR 0 8
40748: ARRAY
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PPUSH
40754: CALL_OW 1
40758: ST_TO_ADDR
// end ;
40759: GO 40680
40761: POP
40762: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
40763: LD_ADDR_EXP 63
40767: PUSH
40768: LD_EXP 63
40772: PPUSH
40773: LD_VAR 0 1
40777: PPUSH
40778: LD_VAR 0 6
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
40788: LD_ADDR_EXP 65
40792: PUSH
40793: LD_EXP 65
40797: PPUSH
40798: LD_VAR 0 1
40802: PPUSH
40803: LD_VAR 0 3
40807: PPUSH
40808: CALL_OW 1
40812: ST_TO_ADDR
// end ;
40813: LD_VAR 0 4
40817: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
40818: LD_INT 0
40820: PPUSH
// if not mc_bases [ base ] then
40821: LD_EXP 50
40825: PUSH
40826: LD_VAR 0 1
40830: ARRAY
40831: NOT
40832: IFFALSE 40836
// exit ;
40834: GO 40861
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
40836: LD_ADDR_EXP 55
40840: PUSH
40841: LD_EXP 55
40845: PPUSH
40846: LD_VAR 0 1
40850: PPUSH
40851: LD_VAR 0 2
40855: PPUSH
40856: CALL_OW 1
40860: ST_TO_ADDR
// end ;
40861: LD_VAR 0 3
40865: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
40866: LD_INT 0
40868: PPUSH
// if not mc_bases [ base ] then
40869: LD_EXP 50
40873: PUSH
40874: LD_VAR 0 1
40878: ARRAY
40879: NOT
40880: IFFALSE 40884
// exit ;
40882: GO 40921
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
40884: LD_ADDR_EXP 55
40888: PUSH
40889: LD_EXP 55
40893: PPUSH
40894: LD_VAR 0 1
40898: PPUSH
40899: LD_EXP 55
40903: PUSH
40904: LD_VAR 0 1
40908: ARRAY
40909: PUSH
40910: LD_VAR 0 2
40914: UNION
40915: PPUSH
40916: CALL_OW 1
40920: ST_TO_ADDR
// end ;
40921: LD_VAR 0 3
40925: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
40926: LD_INT 0
40928: PPUSH
// if not mc_bases [ base ] then
40929: LD_EXP 50
40933: PUSH
40934: LD_VAR 0 1
40938: ARRAY
40939: NOT
40940: IFFALSE 40944
// exit ;
40942: GO 40969
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
40944: LD_ADDR_EXP 71
40948: PUSH
40949: LD_EXP 71
40953: PPUSH
40954: LD_VAR 0 1
40958: PPUSH
40959: LD_VAR 0 2
40963: PPUSH
40964: CALL_OW 1
40968: ST_TO_ADDR
// end ;
40969: LD_VAR 0 3
40973: RET
// export function MC_InsertProduceList ( base , components ) ; begin
40974: LD_INT 0
40976: PPUSH
// if not mc_bases [ base ] then
40977: LD_EXP 50
40981: PUSH
40982: LD_VAR 0 1
40986: ARRAY
40987: NOT
40988: IFFALSE 40992
// exit ;
40990: GO 41029
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
40992: LD_ADDR_EXP 71
40996: PUSH
40997: LD_EXP 71
41001: PPUSH
41002: LD_VAR 0 1
41006: PPUSH
41007: LD_EXP 71
41011: PUSH
41012: LD_VAR 0 1
41016: ARRAY
41017: PUSH
41018: LD_VAR 0 2
41022: ADD
41023: PPUSH
41024: CALL_OW 1
41028: ST_TO_ADDR
// end ;
41029: LD_VAR 0 3
41033: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41034: LD_INT 0
41036: PPUSH
// if not mc_bases [ base ] then
41037: LD_EXP 50
41041: PUSH
41042: LD_VAR 0 1
41046: ARRAY
41047: NOT
41048: IFFALSE 41052
// exit ;
41050: GO 41106
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41052: LD_ADDR_EXP 72
41056: PUSH
41057: LD_EXP 72
41061: PPUSH
41062: LD_VAR 0 1
41066: PPUSH
41067: LD_VAR 0 2
41071: PPUSH
41072: CALL_OW 1
41076: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41077: LD_ADDR_EXP 61
41081: PUSH
41082: LD_EXP 61
41086: PPUSH
41087: LD_VAR 0 1
41091: PPUSH
41092: LD_VAR 0 2
41096: PUSH
41097: LD_INT 0
41099: PLUS
41100: PPUSH
41101: CALL_OW 1
41105: ST_TO_ADDR
// end ;
41106: LD_VAR 0 3
41110: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41111: LD_INT 0
41113: PPUSH
// if not mc_bases [ base ] then
41114: LD_EXP 50
41118: PUSH
41119: LD_VAR 0 1
41123: ARRAY
41124: NOT
41125: IFFALSE 41129
// exit ;
41127: GO 41154
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41129: LD_ADDR_EXP 61
41133: PUSH
41134: LD_EXP 61
41138: PPUSH
41139: LD_VAR 0 1
41143: PPUSH
41144: LD_VAR 0 2
41148: PPUSH
41149: CALL_OW 1
41153: ST_TO_ADDR
// end ;
41154: LD_VAR 0 3
41158: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41159: LD_INT 0
41161: PPUSH
41162: PPUSH
41163: PPUSH
41164: PPUSH
// if not mc_bases [ base ] then
41165: LD_EXP 50
41169: PUSH
41170: LD_VAR 0 1
41174: ARRAY
41175: NOT
41176: IFFALSE 41180
// exit ;
41178: GO 41245
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41180: LD_ADDR_EXP 70
41184: PUSH
41185: LD_EXP 70
41189: PPUSH
41190: LD_VAR 0 1
41194: PUSH
41195: LD_EXP 70
41199: PUSH
41200: LD_VAR 0 1
41204: ARRAY
41205: PUSH
41206: LD_INT 1
41208: PLUS
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PPUSH
41214: LD_VAR 0 1
41218: PUSH
41219: LD_VAR 0 2
41223: PUSH
41224: LD_VAR 0 3
41228: PUSH
41229: LD_VAR 0 4
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: PPUSH
41240: CALL 54555 0 3
41244: ST_TO_ADDR
// end ;
41245: LD_VAR 0 5
41249: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41250: LD_INT 0
41252: PPUSH
// if not mc_bases [ base ] then
41253: LD_EXP 50
41257: PUSH
41258: LD_VAR 0 1
41262: ARRAY
41263: NOT
41264: IFFALSE 41268
// exit ;
41266: GO 41293
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41268: LD_ADDR_EXP 87
41272: PUSH
41273: LD_EXP 87
41277: PPUSH
41278: LD_VAR 0 1
41282: PPUSH
41283: LD_VAR 0 2
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// end ;
41293: LD_VAR 0 3
41297: RET
// export function MC_GetMinesField ( base ) ; begin
41298: LD_INT 0
41300: PPUSH
// result := mc_mines [ base ] ;
41301: LD_ADDR_VAR 0 2
41305: PUSH
41306: LD_EXP 63
41310: PUSH
41311: LD_VAR 0 1
41315: ARRAY
41316: ST_TO_ADDR
// end ;
41317: LD_VAR 0 2
41321: RET
// export function MC_GetProduceList ( base ) ; begin
41322: LD_INT 0
41324: PPUSH
// result := mc_produce [ base ] ;
41325: LD_ADDR_VAR 0 2
41329: PUSH
41330: LD_EXP 71
41334: PUSH
41335: LD_VAR 0 1
41339: ARRAY
41340: ST_TO_ADDR
// end ;
41341: LD_VAR 0 2
41345: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41346: LD_INT 0
41348: PPUSH
41349: PPUSH
// if not mc_bases then
41350: LD_EXP 50
41354: NOT
41355: IFFALSE 41359
// exit ;
41357: GO 41424
// if mc_bases [ base ] then
41359: LD_EXP 50
41363: PUSH
41364: LD_VAR 0 1
41368: ARRAY
41369: IFFALSE 41424
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41371: LD_ADDR_VAR 0 3
41375: PUSH
41376: LD_EXP 50
41380: PUSH
41381: LD_VAR 0 1
41385: ARRAY
41386: PPUSH
41387: LD_INT 30
41389: PUSH
41390: LD_VAR 0 2
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL_OW 72
41403: ST_TO_ADDR
// if result then
41404: LD_VAR 0 3
41408: IFFALSE 41424
// result := result [ 1 ] ;
41410: LD_ADDR_VAR 0 3
41414: PUSH
41415: LD_VAR 0 3
41419: PUSH
41420: LD_INT 1
41422: ARRAY
41423: ST_TO_ADDR
// end ; end ;
41424: LD_VAR 0 3
41428: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41429: LD_INT 0
41431: PPUSH
41432: PPUSH
// if not mc_bases then
41433: LD_EXP 50
41437: NOT
41438: IFFALSE 41442
// exit ;
41440: GO 41487
// if mc_bases [ base ] then
41442: LD_EXP 50
41446: PUSH
41447: LD_VAR 0 1
41451: ARRAY
41452: IFFALSE 41487
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41454: LD_ADDR_VAR 0 3
41458: PUSH
41459: LD_EXP 50
41463: PUSH
41464: LD_VAR 0 1
41468: ARRAY
41469: PPUSH
41470: LD_INT 30
41472: PUSH
41473: LD_VAR 0 2
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PPUSH
41482: CALL_OW 72
41486: ST_TO_ADDR
// end ;
41487: LD_VAR 0 3
41491: RET
// export function MC_SetTame ( base , area ) ; begin
41492: LD_INT 0
41494: PPUSH
// if not mc_bases or not base then
41495: LD_EXP 50
41499: NOT
41500: PUSH
41501: LD_VAR 0 1
41505: NOT
41506: OR
41507: IFFALSE 41511
// exit ;
41509: GO 41536
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
41511: LD_ADDR_EXP 78
41515: PUSH
41516: LD_EXP 78
41520: PPUSH
41521: LD_VAR 0 1
41525: PPUSH
41526: LD_VAR 0 2
41530: PPUSH
41531: CALL_OW 1
41535: ST_TO_ADDR
// end ;
41536: LD_VAR 0 3
41540: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
41541: LD_INT 0
41543: PPUSH
41544: PPUSH
// if not mc_bases or not base then
41545: LD_EXP 50
41549: NOT
41550: PUSH
41551: LD_VAR 0 1
41555: NOT
41556: OR
41557: IFFALSE 41561
// exit ;
41559: GO 41663
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41561: LD_ADDR_VAR 0 4
41565: PUSH
41566: LD_EXP 50
41570: PUSH
41571: LD_VAR 0 1
41575: ARRAY
41576: PPUSH
41577: LD_INT 30
41579: PUSH
41580: LD_VAR 0 2
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PPUSH
41589: CALL_OW 72
41593: ST_TO_ADDR
// if not tmp then
41594: LD_VAR 0 4
41598: NOT
41599: IFFALSE 41603
// exit ;
41601: GO 41663
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
41603: LD_ADDR_EXP 82
41607: PUSH
41608: LD_EXP 82
41612: PPUSH
41613: LD_VAR 0 1
41617: PPUSH
41618: LD_EXP 82
41622: PUSH
41623: LD_VAR 0 1
41627: ARRAY
41628: PPUSH
41629: LD_EXP 82
41633: PUSH
41634: LD_VAR 0 1
41638: ARRAY
41639: PUSH
41640: LD_INT 1
41642: PLUS
41643: PPUSH
41644: LD_VAR 0 4
41648: PUSH
41649: LD_INT 1
41651: ARRAY
41652: PPUSH
41653: CALL_OW 2
41657: PPUSH
41658: CALL_OW 1
41662: ST_TO_ADDR
// end ;
41663: LD_VAR 0 3
41667: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
41668: LD_INT 0
41670: PPUSH
41671: PPUSH
// if not mc_bases or not base or not kinds then
41672: LD_EXP 50
41676: NOT
41677: PUSH
41678: LD_VAR 0 1
41682: NOT
41683: OR
41684: PUSH
41685: LD_VAR 0 2
41689: NOT
41690: OR
41691: IFFALSE 41695
// exit ;
41693: GO 41756
// for i in kinds do
41695: LD_ADDR_VAR 0 4
41699: PUSH
41700: LD_VAR 0 2
41704: PUSH
41705: FOR_IN
41706: IFFALSE 41754
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
41708: LD_ADDR_EXP 84
41712: PUSH
41713: LD_EXP 84
41717: PPUSH
41718: LD_VAR 0 1
41722: PUSH
41723: LD_EXP 84
41727: PUSH
41728: LD_VAR 0 1
41732: ARRAY
41733: PUSH
41734: LD_INT 1
41736: PLUS
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PPUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: CALL 54555 0 3
41751: ST_TO_ADDR
41752: GO 41705
41754: POP
41755: POP
// end ;
41756: LD_VAR 0 3
41760: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
41761: LD_INT 0
41763: PPUSH
// if not mc_bases or not base or not areas then
41764: LD_EXP 50
41768: NOT
41769: PUSH
41770: LD_VAR 0 1
41774: NOT
41775: OR
41776: PUSH
41777: LD_VAR 0 2
41781: NOT
41782: OR
41783: IFFALSE 41787
// exit ;
41785: GO 41812
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
41787: LD_ADDR_EXP 68
41791: PUSH
41792: LD_EXP 68
41796: PPUSH
41797: LD_VAR 0 1
41801: PPUSH
41802: LD_VAR 0 2
41806: PPUSH
41807: CALL_OW 1
41811: ST_TO_ADDR
// end ;
41812: LD_VAR 0 3
41816: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
41817: LD_INT 0
41819: PPUSH
// if not mc_bases or not base or not teleports_exit then
41820: LD_EXP 50
41824: NOT
41825: PUSH
41826: LD_VAR 0 1
41830: NOT
41831: OR
41832: PUSH
41833: LD_VAR 0 2
41837: NOT
41838: OR
41839: IFFALSE 41843
// exit ;
41841: GO 41868
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
41843: LD_ADDR_EXP 85
41847: PUSH
41848: LD_EXP 85
41852: PPUSH
41853: LD_VAR 0 1
41857: PPUSH
41858: LD_VAR 0 2
41862: PPUSH
41863: CALL_OW 1
41867: ST_TO_ADDR
// end ;
41868: LD_VAR 0 3
41872: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
41873: LD_INT 0
41875: PPUSH
41876: PPUSH
41877: PPUSH
// if not mc_bases or not base or not ext_list then
41878: LD_EXP 50
41882: NOT
41883: PUSH
41884: LD_VAR 0 1
41888: NOT
41889: OR
41890: PUSH
41891: LD_VAR 0 5
41895: NOT
41896: OR
41897: IFFALSE 41901
// exit ;
41899: GO 42074
// tmp := GetFacExtXYD ( x , y , d ) ;
41901: LD_ADDR_VAR 0 8
41905: PUSH
41906: LD_VAR 0 2
41910: PPUSH
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 4
41920: PPUSH
41921: CALL 87933 0 3
41925: ST_TO_ADDR
// if not tmp then
41926: LD_VAR 0 8
41930: NOT
41931: IFFALSE 41935
// exit ;
41933: GO 42074
// for i in tmp do
41935: LD_ADDR_VAR 0 7
41939: PUSH
41940: LD_VAR 0 8
41944: PUSH
41945: FOR_IN
41946: IFFALSE 42072
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
41948: LD_ADDR_EXP 55
41952: PUSH
41953: LD_EXP 55
41957: PPUSH
41958: LD_VAR 0 1
41962: PPUSH
41963: LD_EXP 55
41967: PUSH
41968: LD_VAR 0 1
41972: ARRAY
41973: PPUSH
41974: LD_EXP 55
41978: PUSH
41979: LD_VAR 0 1
41983: ARRAY
41984: PUSH
41985: LD_INT 1
41987: PLUS
41988: PPUSH
41989: LD_VAR 0 5
41993: PUSH
41994: LD_INT 1
41996: ARRAY
41997: PUSH
41998: LD_VAR 0 7
42002: PUSH
42003: LD_INT 1
42005: ARRAY
42006: PUSH
42007: LD_VAR 0 7
42011: PUSH
42012: LD_INT 2
42014: ARRAY
42015: PUSH
42016: LD_VAR 0 7
42020: PUSH
42021: LD_INT 3
42023: ARRAY
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: LIST
42029: LIST
42030: PPUSH
42031: CALL_OW 2
42035: PPUSH
42036: CALL_OW 1
42040: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42041: LD_ADDR_VAR 0 5
42045: PUSH
42046: LD_VAR 0 5
42050: PPUSH
42051: LD_INT 1
42053: PPUSH
42054: CALL_OW 3
42058: ST_TO_ADDR
// if not ext_list then
42059: LD_VAR 0 5
42063: NOT
42064: IFFALSE 42070
// exit ;
42066: POP
42067: POP
42068: GO 42074
// end ;
42070: GO 41945
42072: POP
42073: POP
// end ;
42074: LD_VAR 0 6
42078: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42079: LD_INT 0
42081: PPUSH
// if not mc_bases or not base or not weapon_list then
42082: LD_EXP 50
42086: NOT
42087: PUSH
42088: LD_VAR 0 1
42092: NOT
42093: OR
42094: PUSH
42095: LD_VAR 0 2
42099: NOT
42100: OR
42101: IFFALSE 42105
// exit ;
42103: GO 42130
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42105: LD_ADDR_EXP 89
42109: PUSH
42110: LD_EXP 89
42114: PPUSH
42115: LD_VAR 0 1
42119: PPUSH
42120: LD_VAR 0 2
42124: PPUSH
42125: CALL_OW 1
42129: ST_TO_ADDR
// end ;
42130: LD_VAR 0 3
42134: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42135: LD_INT 0
42137: PPUSH
// if not mc_bases or not base or not tech_list then
42138: LD_EXP 50
42142: NOT
42143: PUSH
42144: LD_VAR 0 1
42148: NOT
42149: OR
42150: PUSH
42151: LD_VAR 0 2
42155: NOT
42156: OR
42157: IFFALSE 42161
// exit ;
42159: GO 42186
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42161: LD_ADDR_EXP 77
42165: PUSH
42166: LD_EXP 77
42170: PPUSH
42171: LD_VAR 0 1
42175: PPUSH
42176: LD_VAR 0 2
42180: PPUSH
42181: CALL_OW 1
42185: ST_TO_ADDR
// end ;
42186: LD_VAR 0 3
42190: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42191: LD_INT 0
42193: PPUSH
// if not mc_bases or not parking_area or not base then
42194: LD_EXP 50
42198: NOT
42199: PUSH
42200: LD_VAR 0 2
42204: NOT
42205: OR
42206: PUSH
42207: LD_VAR 0 1
42211: NOT
42212: OR
42213: IFFALSE 42217
// exit ;
42215: GO 42242
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42217: LD_ADDR_EXP 74
42221: PUSH
42222: LD_EXP 74
42226: PPUSH
42227: LD_VAR 0 1
42231: PPUSH
42232: LD_VAR 0 2
42236: PPUSH
42237: CALL_OW 1
42241: ST_TO_ADDR
// end ;
42242: LD_VAR 0 3
42246: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42247: LD_INT 0
42249: PPUSH
// if not mc_bases or not base or not scan_area then
42250: LD_EXP 50
42254: NOT
42255: PUSH
42256: LD_VAR 0 1
42260: NOT
42261: OR
42262: PUSH
42263: LD_VAR 0 2
42267: NOT
42268: OR
42269: IFFALSE 42273
// exit ;
42271: GO 42298
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42273: LD_ADDR_EXP 75
42277: PUSH
42278: LD_EXP 75
42282: PPUSH
42283: LD_VAR 0 1
42287: PPUSH
42288: LD_VAR 0 2
42292: PPUSH
42293: CALL_OW 1
42297: ST_TO_ADDR
// end ;
42298: LD_VAR 0 3
42302: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42303: LD_INT 0
42305: PPUSH
42306: PPUSH
// if not mc_bases or not base then
42307: LD_EXP 50
42311: NOT
42312: PUSH
42313: LD_VAR 0 1
42317: NOT
42318: OR
42319: IFFALSE 42323
// exit ;
42321: GO 42387
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42323: LD_ADDR_VAR 0 3
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: LD_INT 4
42339: PUSH
42340: LD_INT 11
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42350: LD_ADDR_EXP 77
42354: PUSH
42355: LD_EXP 77
42359: PPUSH
42360: LD_VAR 0 1
42364: PPUSH
42365: LD_EXP 77
42369: PUSH
42370: LD_VAR 0 1
42374: ARRAY
42375: PUSH
42376: LD_VAR 0 3
42380: DIFF
42381: PPUSH
42382: CALL_OW 1
42386: ST_TO_ADDR
// end ;
42387: LD_VAR 0 2
42391: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42392: LD_INT 0
42394: PPUSH
// result := mc_vehicles [ base ] ;
42395: LD_ADDR_VAR 0 3
42399: PUSH
42400: LD_EXP 69
42404: PUSH
42405: LD_VAR 0 1
42409: ARRAY
42410: ST_TO_ADDR
// if onlyCombat then
42411: LD_VAR 0 2
42415: IFFALSE 42580
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42417: LD_ADDR_VAR 0 3
42421: PUSH
42422: LD_VAR 0 3
42426: PUSH
42427: LD_VAR 0 3
42431: PPUSH
42432: LD_INT 2
42434: PUSH
42435: LD_INT 34
42437: PUSH
42438: LD_INT 12
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 34
42447: PUSH
42448: LD_INT 51
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 34
42457: PUSH
42458: LD_EXP 94
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 34
42469: PUSH
42470: LD_INT 32
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 34
42479: PUSH
42480: LD_INT 13
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 34
42489: PUSH
42490: LD_INT 52
42492: PUSH
42493: EMPTY
42494: LIST
42495: LIST
42496: PUSH
42497: LD_INT 34
42499: PUSH
42500: LD_INT 14
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 34
42509: PUSH
42510: LD_INT 53
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 34
42519: PUSH
42520: LD_EXP 93
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 34
42531: PUSH
42532: LD_INT 31
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 34
42541: PUSH
42542: LD_INT 48
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 34
42551: PUSH
42552: LD_INT 8
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: LIST
42565: LIST
42566: LIST
42567: LIST
42568: LIST
42569: LIST
42570: LIST
42571: LIST
42572: LIST
42573: PPUSH
42574: CALL_OW 72
42578: DIFF
42579: ST_TO_ADDR
// end ; end_of_file
42580: LD_VAR 0 3
42584: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
42585: LD_INT 0
42587: PPUSH
42588: PPUSH
42589: PPUSH
// if not mc_bases or not skirmish then
42590: LD_EXP 50
42594: NOT
42595: PUSH
42596: LD_EXP 48
42600: NOT
42601: OR
42602: IFFALSE 42606
// exit ;
42604: GO 42771
// for i = 1 to mc_bases do
42606: LD_ADDR_VAR 0 4
42610: PUSH
42611: DOUBLE
42612: LD_INT 1
42614: DEC
42615: ST_TO_ADDR
42616: LD_EXP 50
42620: PUSH
42621: FOR_TO
42622: IFFALSE 42769
// begin if sci in mc_bases [ i ] then
42624: LD_VAR 0 2
42628: PUSH
42629: LD_EXP 50
42633: PUSH
42634: LD_VAR 0 4
42638: ARRAY
42639: IN
42640: IFFALSE 42767
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
42642: LD_ADDR_EXP 79
42646: PUSH
42647: LD_EXP 79
42651: PPUSH
42652: LD_VAR 0 4
42656: PUSH
42657: LD_EXP 79
42661: PUSH
42662: LD_VAR 0 4
42666: ARRAY
42667: PUSH
42668: LD_INT 1
42670: PLUS
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PPUSH
42676: LD_VAR 0 1
42680: PPUSH
42681: CALL 54555 0 3
42685: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
42686: LD_ADDR_VAR 0 5
42690: PUSH
42691: LD_EXP 50
42695: PUSH
42696: LD_VAR 0 4
42700: ARRAY
42701: PPUSH
42702: LD_INT 2
42704: PUSH
42705: LD_INT 30
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 30
42717: PUSH
42718: LD_INT 1
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: LIST
42729: PPUSH
42730: CALL_OW 72
42734: PPUSH
42735: LD_VAR 0 1
42739: PPUSH
42740: CALL_OW 74
42744: ST_TO_ADDR
// if tmp then
42745: LD_VAR 0 5
42749: IFFALSE 42765
// ComStandNearbyBuilding ( ape , tmp ) ;
42751: LD_VAR 0 1
42755: PPUSH
42756: LD_VAR 0 5
42760: PPUSH
42761: CALL 48758 0 2
// break ;
42765: GO 42769
// end ; end ;
42767: GO 42621
42769: POP
42770: POP
// end ;
42771: LD_VAR 0 3
42775: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
42776: LD_INT 0
42778: PPUSH
42779: PPUSH
42780: PPUSH
// if not mc_bases or not skirmish then
42781: LD_EXP 50
42785: NOT
42786: PUSH
42787: LD_EXP 48
42791: NOT
42792: OR
42793: IFFALSE 42797
// exit ;
42795: GO 42886
// for i = 1 to mc_bases do
42797: LD_ADDR_VAR 0 4
42801: PUSH
42802: DOUBLE
42803: LD_INT 1
42805: DEC
42806: ST_TO_ADDR
42807: LD_EXP 50
42811: PUSH
42812: FOR_TO
42813: IFFALSE 42884
// begin if building in mc_busy_turret_list [ i ] then
42815: LD_VAR 0 1
42819: PUSH
42820: LD_EXP 60
42824: PUSH
42825: LD_VAR 0 4
42829: ARRAY
42830: IN
42831: IFFALSE 42882
// begin tmp := mc_busy_turret_list [ i ] diff building ;
42833: LD_ADDR_VAR 0 5
42837: PUSH
42838: LD_EXP 60
42842: PUSH
42843: LD_VAR 0 4
42847: ARRAY
42848: PUSH
42849: LD_VAR 0 1
42853: DIFF
42854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
42855: LD_ADDR_EXP 60
42859: PUSH
42860: LD_EXP 60
42864: PPUSH
42865: LD_VAR 0 4
42869: PPUSH
42870: LD_VAR 0 5
42874: PPUSH
42875: CALL_OW 1
42879: ST_TO_ADDR
// break ;
42880: GO 42884
// end ; end ;
42882: GO 42812
42884: POP
42885: POP
// end ;
42886: LD_VAR 0 3
42890: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
42891: LD_INT 0
42893: PPUSH
42894: PPUSH
42895: PPUSH
// if not mc_bases or not skirmish then
42896: LD_EXP 50
42900: NOT
42901: PUSH
42902: LD_EXP 48
42906: NOT
42907: OR
42908: IFFALSE 42912
// exit ;
42910: GO 43111
// for i = 1 to mc_bases do
42912: LD_ADDR_VAR 0 5
42916: PUSH
42917: DOUBLE
42918: LD_INT 1
42920: DEC
42921: ST_TO_ADDR
42922: LD_EXP 50
42926: PUSH
42927: FOR_TO
42928: IFFALSE 43109
// if building in mc_bases [ i ] then
42930: LD_VAR 0 1
42934: PUSH
42935: LD_EXP 50
42939: PUSH
42940: LD_VAR 0 5
42944: ARRAY
42945: IN
42946: IFFALSE 43107
// begin tmp := mc_bases [ i ] diff building ;
42948: LD_ADDR_VAR 0 6
42952: PUSH
42953: LD_EXP 50
42957: PUSH
42958: LD_VAR 0 5
42962: ARRAY
42963: PUSH
42964: LD_VAR 0 1
42968: DIFF
42969: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
42970: LD_ADDR_EXP 50
42974: PUSH
42975: LD_EXP 50
42979: PPUSH
42980: LD_VAR 0 5
42984: PPUSH
42985: LD_VAR 0 6
42989: PPUSH
42990: CALL_OW 1
42994: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
42995: LD_VAR 0 1
42999: PUSH
43000: LD_EXP 58
43004: PUSH
43005: LD_VAR 0 5
43009: ARRAY
43010: IN
43011: IFFALSE 43050
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43013: LD_ADDR_EXP 58
43017: PUSH
43018: LD_EXP 58
43022: PPUSH
43023: LD_VAR 0 5
43027: PPUSH
43028: LD_EXP 58
43032: PUSH
43033: LD_VAR 0 5
43037: ARRAY
43038: PUSH
43039: LD_VAR 0 1
43043: DIFF
43044: PPUSH
43045: CALL_OW 1
43049: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43050: LD_VAR 0 1
43054: PUSH
43055: LD_EXP 59
43059: PUSH
43060: LD_VAR 0 5
43064: ARRAY
43065: IN
43066: IFFALSE 43105
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43068: LD_ADDR_EXP 59
43072: PUSH
43073: LD_EXP 59
43077: PPUSH
43078: LD_VAR 0 5
43082: PPUSH
43083: LD_EXP 59
43087: PUSH
43088: LD_VAR 0 5
43092: ARRAY
43093: PUSH
43094: LD_VAR 0 1
43098: DIFF
43099: PPUSH
43100: CALL_OW 1
43104: ST_TO_ADDR
// break ;
43105: GO 43109
// end ;
43107: GO 42927
43109: POP
43110: POP
// end ;
43111: LD_VAR 0 4
43115: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43116: LD_INT 0
43118: PPUSH
43119: PPUSH
43120: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43121: LD_EXP 50
43125: NOT
43126: PUSH
43127: LD_EXP 48
43131: NOT
43132: OR
43133: PUSH
43134: LD_VAR 0 3
43138: PUSH
43139: LD_EXP 76
43143: IN
43144: NOT
43145: OR
43146: IFFALSE 43150
// exit ;
43148: GO 43273
// for i = 1 to mc_vehicles do
43150: LD_ADDR_VAR 0 6
43154: PUSH
43155: DOUBLE
43156: LD_INT 1
43158: DEC
43159: ST_TO_ADDR
43160: LD_EXP 69
43164: PUSH
43165: FOR_TO
43166: IFFALSE 43271
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43168: LD_VAR 0 2
43172: PUSH
43173: LD_EXP 69
43177: PUSH
43178: LD_VAR 0 6
43182: ARRAY
43183: IN
43184: PUSH
43185: LD_VAR 0 1
43189: PUSH
43190: LD_EXP 69
43194: PUSH
43195: LD_VAR 0 6
43199: ARRAY
43200: IN
43201: OR
43202: IFFALSE 43269
// begin tmp := mc_vehicles [ i ] diff old ;
43204: LD_ADDR_VAR 0 7
43208: PUSH
43209: LD_EXP 69
43213: PUSH
43214: LD_VAR 0 6
43218: ARRAY
43219: PUSH
43220: LD_VAR 0 2
43224: DIFF
43225: ST_TO_ADDR
// tmp := tmp diff new ;
43226: LD_ADDR_VAR 0 7
43230: PUSH
43231: LD_VAR 0 7
43235: PUSH
43236: LD_VAR 0 1
43240: DIFF
43241: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43242: LD_ADDR_EXP 69
43246: PUSH
43247: LD_EXP 69
43251: PPUSH
43252: LD_VAR 0 6
43256: PPUSH
43257: LD_VAR 0 7
43261: PPUSH
43262: CALL_OW 1
43266: ST_TO_ADDR
// break ;
43267: GO 43271
// end ;
43269: GO 43165
43271: POP
43272: POP
// end ;
43273: LD_VAR 0 5
43277: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43278: LD_INT 0
43280: PPUSH
43281: PPUSH
43282: PPUSH
43283: PPUSH
// if not mc_bases or not skirmish then
43284: LD_EXP 50
43288: NOT
43289: PUSH
43290: LD_EXP 48
43294: NOT
43295: OR
43296: IFFALSE 43300
// exit ;
43298: GO 43677
// side := GetSide ( vehicle ) ;
43300: LD_ADDR_VAR 0 5
43304: PUSH
43305: LD_VAR 0 1
43309: PPUSH
43310: CALL_OW 255
43314: ST_TO_ADDR
// for i = 1 to mc_bases do
43315: LD_ADDR_VAR 0 4
43319: PUSH
43320: DOUBLE
43321: LD_INT 1
43323: DEC
43324: ST_TO_ADDR
43325: LD_EXP 50
43329: PUSH
43330: FOR_TO
43331: IFFALSE 43675
// begin if factory in mc_bases [ i ] then
43333: LD_VAR 0 2
43337: PUSH
43338: LD_EXP 50
43342: PUSH
43343: LD_VAR 0 4
43347: ARRAY
43348: IN
43349: IFFALSE 43673
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
43351: LD_EXP 72
43355: PUSH
43356: LD_VAR 0 4
43360: ARRAY
43361: PUSH
43362: LD_EXP 61
43366: PUSH
43367: LD_VAR 0 4
43371: ARRAY
43372: LESS
43373: PUSH
43374: LD_VAR 0 1
43378: PPUSH
43379: CALL_OW 264
43383: PUSH
43384: LD_INT 31
43386: PUSH
43387: LD_INT 32
43389: PUSH
43390: LD_INT 51
43392: PUSH
43393: LD_EXP 94
43397: PUSH
43398: LD_INT 12
43400: PUSH
43401: LD_INT 30
43403: PUSH
43404: LD_EXP 93
43408: PUSH
43409: LD_INT 11
43411: PUSH
43412: LD_INT 53
43414: PUSH
43415: LD_INT 14
43417: PUSH
43418: LD_EXP 97
43422: PUSH
43423: LD_INT 29
43425: PUSH
43426: LD_EXP 95
43430: PUSH
43431: LD_INT 13
43433: PUSH
43434: LD_INT 52
43436: PUSH
43437: LD_INT 48
43439: PUSH
43440: LD_INT 8
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: IN
43462: NOT
43463: AND
43464: IFFALSE 43512
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
43466: LD_ADDR_EXP 72
43470: PUSH
43471: LD_EXP 72
43475: PPUSH
43476: LD_VAR 0 4
43480: PUSH
43481: LD_EXP 72
43485: PUSH
43486: LD_VAR 0 4
43490: ARRAY
43491: PUSH
43492: LD_INT 1
43494: PLUS
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PPUSH
43500: LD_VAR 0 1
43504: PPUSH
43505: CALL 54555 0 3
43509: ST_TO_ADDR
43510: GO 43556
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
43512: LD_ADDR_EXP 69
43516: PUSH
43517: LD_EXP 69
43521: PPUSH
43522: LD_VAR 0 4
43526: PUSH
43527: LD_EXP 69
43531: PUSH
43532: LD_VAR 0 4
43536: ARRAY
43537: PUSH
43538: LD_INT 1
43540: PLUS
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PPUSH
43546: LD_VAR 0 1
43550: PPUSH
43551: CALL 54555 0 3
43555: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
43556: LD_VAR 0 1
43560: PPUSH
43561: CALL_OW 263
43565: PUSH
43566: LD_INT 2
43568: EQUAL
43569: IFFALSE 43589
// begin repeat wait ( 0 0$1 ) ;
43571: LD_INT 35
43573: PPUSH
43574: CALL_OW 67
// until IsControledBy ( vehicle ) ;
43578: LD_VAR 0 1
43582: PPUSH
43583: CALL_OW 312
43587: IFFALSE 43571
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
43589: LD_VAR 0 1
43593: PPUSH
43594: LD_EXP 74
43598: PUSH
43599: LD_VAR 0 4
43603: ARRAY
43604: PPUSH
43605: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
43609: LD_VAR 0 1
43613: PPUSH
43614: CALL_OW 263
43618: PUSH
43619: LD_INT 1
43621: NONEQUAL
43622: IFFALSE 43626
// break ;
43624: GO 43675
// repeat wait ( 0 0$1 ) ;
43626: LD_INT 35
43628: PPUSH
43629: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
43633: LD_VAR 0 1
43637: PPUSH
43638: LD_EXP 74
43642: PUSH
43643: LD_VAR 0 4
43647: ARRAY
43648: PPUSH
43649: CALL_OW 308
43653: IFFALSE 43626
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
43655: LD_VAR 0 1
43659: PPUSH
43660: CALL_OW 311
43664: PPUSH
43665: CALL_OW 121
// exit ;
43669: POP
43670: POP
43671: GO 43677
// end ; end ;
43673: GO 43330
43675: POP
43676: POP
// end ;
43677: LD_VAR 0 3
43681: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
43682: LD_INT 0
43684: PPUSH
43685: PPUSH
43686: PPUSH
43687: PPUSH
// if not mc_bases or not skirmish then
43688: LD_EXP 50
43692: NOT
43693: PUSH
43694: LD_EXP 48
43698: NOT
43699: OR
43700: IFFALSE 43704
// exit ;
43702: GO 44057
// repeat wait ( 0 0$1 ) ;
43704: LD_INT 35
43706: PPUSH
43707: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
43711: LD_VAR 0 2
43715: PPUSH
43716: LD_VAR 0 3
43720: PPUSH
43721: CALL_OW 284
43725: IFFALSE 43704
// if GetResourceTypeXY ( x , y ) = mat_artefact then
43727: LD_VAR 0 2
43731: PPUSH
43732: LD_VAR 0 3
43736: PPUSH
43737: CALL_OW 283
43741: PUSH
43742: LD_INT 4
43744: EQUAL
43745: IFFALSE 43749
// exit ;
43747: GO 44057
// for i = 1 to mc_bases do
43749: LD_ADDR_VAR 0 7
43753: PUSH
43754: DOUBLE
43755: LD_INT 1
43757: DEC
43758: ST_TO_ADDR
43759: LD_EXP 50
43763: PUSH
43764: FOR_TO
43765: IFFALSE 44055
// begin if mc_crates_area [ i ] then
43767: LD_EXP 68
43771: PUSH
43772: LD_VAR 0 7
43776: ARRAY
43777: IFFALSE 43888
// for j in mc_crates_area [ i ] do
43779: LD_ADDR_VAR 0 8
43783: PUSH
43784: LD_EXP 68
43788: PUSH
43789: LD_VAR 0 7
43793: ARRAY
43794: PUSH
43795: FOR_IN
43796: IFFALSE 43886
// if InArea ( x , y , j ) then
43798: LD_VAR 0 2
43802: PPUSH
43803: LD_VAR 0 3
43807: PPUSH
43808: LD_VAR 0 8
43812: PPUSH
43813: CALL_OW 309
43817: IFFALSE 43884
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43819: LD_ADDR_EXP 66
43823: PUSH
43824: LD_EXP 66
43828: PPUSH
43829: LD_VAR 0 7
43833: PUSH
43834: LD_EXP 66
43838: PUSH
43839: LD_VAR 0 7
43843: ARRAY
43844: PUSH
43845: LD_INT 1
43847: PLUS
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PPUSH
43853: LD_VAR 0 4
43857: PUSH
43858: LD_VAR 0 2
43862: PUSH
43863: LD_VAR 0 3
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: LIST
43872: PPUSH
43873: CALL 54555 0 3
43877: ST_TO_ADDR
// exit ;
43878: POP
43879: POP
43880: POP
43881: POP
43882: GO 44057
// end ;
43884: GO 43795
43886: POP
43887: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43888: LD_ADDR_VAR 0 9
43892: PUSH
43893: LD_EXP 50
43897: PUSH
43898: LD_VAR 0 7
43902: ARRAY
43903: PPUSH
43904: LD_INT 2
43906: PUSH
43907: LD_INT 30
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 1
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: LIST
43931: PPUSH
43932: CALL_OW 72
43936: ST_TO_ADDR
// if not depot then
43937: LD_VAR 0 9
43941: NOT
43942: IFFALSE 43946
// continue ;
43944: GO 43764
// for j in depot do
43946: LD_ADDR_VAR 0 8
43950: PUSH
43951: LD_VAR 0 9
43955: PUSH
43956: FOR_IN
43957: IFFALSE 44051
// if GetDistUnitXY ( j , x , y ) < 30 then
43959: LD_VAR 0 8
43963: PPUSH
43964: LD_VAR 0 2
43968: PPUSH
43969: LD_VAR 0 3
43973: PPUSH
43974: CALL_OW 297
43978: PUSH
43979: LD_INT 30
43981: LESS
43982: IFFALSE 44049
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
43984: LD_ADDR_EXP 66
43988: PUSH
43989: LD_EXP 66
43993: PPUSH
43994: LD_VAR 0 7
43998: PUSH
43999: LD_EXP 66
44003: PUSH
44004: LD_VAR 0 7
44008: ARRAY
44009: PUSH
44010: LD_INT 1
44012: PLUS
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PPUSH
44018: LD_VAR 0 4
44022: PUSH
44023: LD_VAR 0 2
44027: PUSH
44028: LD_VAR 0 3
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: LIST
44037: PPUSH
44038: CALL 54555 0 3
44042: ST_TO_ADDR
// exit ;
44043: POP
44044: POP
44045: POP
44046: POP
44047: GO 44057
// end ;
44049: GO 43956
44051: POP
44052: POP
// end ;
44053: GO 43764
44055: POP
44056: POP
// end ;
44057: LD_VAR 0 6
44061: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44062: LD_INT 0
44064: PPUSH
44065: PPUSH
44066: PPUSH
44067: PPUSH
// if not mc_bases or not skirmish then
44068: LD_EXP 50
44072: NOT
44073: PUSH
44074: LD_EXP 48
44078: NOT
44079: OR
44080: IFFALSE 44084
// exit ;
44082: GO 44361
// side := GetSide ( lab ) ;
44084: LD_ADDR_VAR 0 4
44088: PUSH
44089: LD_VAR 0 2
44093: PPUSH
44094: CALL_OW 255
44098: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44099: LD_VAR 0 4
44103: PUSH
44104: LD_EXP 76
44108: IN
44109: NOT
44110: PUSH
44111: LD_EXP 77
44115: NOT
44116: OR
44117: PUSH
44118: LD_EXP 50
44122: NOT
44123: OR
44124: IFFALSE 44128
// exit ;
44126: GO 44361
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44128: LD_ADDR_EXP 77
44132: PUSH
44133: LD_EXP 77
44137: PPUSH
44138: LD_VAR 0 4
44142: PPUSH
44143: LD_EXP 77
44147: PUSH
44148: LD_VAR 0 4
44152: ARRAY
44153: PUSH
44154: LD_VAR 0 1
44158: DIFF
44159: PPUSH
44160: CALL_OW 1
44164: ST_TO_ADDR
// for i = 1 to mc_bases do
44165: LD_ADDR_VAR 0 5
44169: PUSH
44170: DOUBLE
44171: LD_INT 1
44173: DEC
44174: ST_TO_ADDR
44175: LD_EXP 50
44179: PUSH
44180: FOR_TO
44181: IFFALSE 44359
// begin if lab in mc_bases [ i ] then
44183: LD_VAR 0 2
44187: PUSH
44188: LD_EXP 50
44192: PUSH
44193: LD_VAR 0 5
44197: ARRAY
44198: IN
44199: IFFALSE 44357
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44201: LD_VAR 0 1
44205: PUSH
44206: LD_INT 11
44208: PUSH
44209: LD_INT 4
44211: PUSH
44212: LD_INT 3
44214: PUSH
44215: LD_INT 2
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: IN
44224: PUSH
44225: LD_EXP 80
44229: PUSH
44230: LD_VAR 0 5
44234: ARRAY
44235: AND
44236: IFFALSE 44357
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44238: LD_ADDR_VAR 0 6
44242: PUSH
44243: LD_EXP 80
44247: PUSH
44248: LD_VAR 0 5
44252: ARRAY
44253: PUSH
44254: LD_INT 1
44256: ARRAY
44257: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44258: LD_ADDR_EXP 80
44262: PUSH
44263: LD_EXP 80
44267: PPUSH
44268: LD_VAR 0 5
44272: PPUSH
44273: EMPTY
44274: PPUSH
44275: CALL_OW 1
44279: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44280: LD_VAR 0 6
44284: PPUSH
44285: LD_INT 0
44287: PPUSH
44288: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44292: LD_VAR 0 6
44296: PPUSH
44297: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44301: LD_ADDR_EXP 79
44305: PUSH
44306: LD_EXP 79
44310: PPUSH
44311: LD_VAR 0 5
44315: PPUSH
44316: LD_EXP 79
44320: PUSH
44321: LD_VAR 0 5
44325: ARRAY
44326: PPUSH
44327: LD_INT 1
44329: PPUSH
44330: LD_VAR 0 6
44334: PPUSH
44335: CALL_OW 2
44339: PPUSH
44340: CALL_OW 1
44344: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44345: LD_VAR 0 5
44349: PPUSH
44350: LD_INT 112
44352: PPUSH
44353: CALL 21253 0 2
// end ; end ; end ;
44357: GO 44180
44359: POP
44360: POP
// end ;
44361: LD_VAR 0 3
44365: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44366: LD_INT 0
44368: PPUSH
44369: PPUSH
44370: PPUSH
44371: PPUSH
44372: PPUSH
44373: PPUSH
44374: PPUSH
44375: PPUSH
// if not mc_bases or not skirmish then
44376: LD_EXP 50
44380: NOT
44381: PUSH
44382: LD_EXP 48
44386: NOT
44387: OR
44388: IFFALSE 44392
// exit ;
44390: GO 45763
// for i = 1 to mc_bases do
44392: LD_ADDR_VAR 0 3
44396: PUSH
44397: DOUBLE
44398: LD_INT 1
44400: DEC
44401: ST_TO_ADDR
44402: LD_EXP 50
44406: PUSH
44407: FOR_TO
44408: IFFALSE 45761
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44410: LD_VAR 0 1
44414: PUSH
44415: LD_EXP 50
44419: PUSH
44420: LD_VAR 0 3
44424: ARRAY
44425: IN
44426: PUSH
44427: LD_VAR 0 1
44431: PUSH
44432: LD_EXP 57
44436: PUSH
44437: LD_VAR 0 3
44441: ARRAY
44442: IN
44443: OR
44444: PUSH
44445: LD_VAR 0 1
44449: PUSH
44450: LD_EXP 72
44454: PUSH
44455: LD_VAR 0 3
44459: ARRAY
44460: IN
44461: OR
44462: PUSH
44463: LD_VAR 0 1
44467: PUSH
44468: LD_EXP 69
44472: PUSH
44473: LD_VAR 0 3
44477: ARRAY
44478: IN
44479: OR
44480: PUSH
44481: LD_VAR 0 1
44485: PUSH
44486: LD_EXP 79
44490: PUSH
44491: LD_VAR 0 3
44495: ARRAY
44496: IN
44497: OR
44498: PUSH
44499: LD_VAR 0 1
44503: PUSH
44504: LD_EXP 80
44508: PUSH
44509: LD_VAR 0 3
44513: ARRAY
44514: IN
44515: OR
44516: IFFALSE 45759
// begin if un in mc_ape [ i ] then
44518: LD_VAR 0 1
44522: PUSH
44523: LD_EXP 79
44527: PUSH
44528: LD_VAR 0 3
44532: ARRAY
44533: IN
44534: IFFALSE 44573
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
44536: LD_ADDR_EXP 79
44540: PUSH
44541: LD_EXP 79
44545: PPUSH
44546: LD_VAR 0 3
44550: PPUSH
44551: LD_EXP 79
44555: PUSH
44556: LD_VAR 0 3
44560: ARRAY
44561: PUSH
44562: LD_VAR 0 1
44566: DIFF
44567: PPUSH
44568: CALL_OW 1
44572: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
44573: LD_VAR 0 1
44577: PUSH
44578: LD_EXP 80
44582: PUSH
44583: LD_VAR 0 3
44587: ARRAY
44588: IN
44589: IFFALSE 44613
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44591: LD_ADDR_EXP 80
44595: PUSH
44596: LD_EXP 80
44600: PPUSH
44601: LD_VAR 0 3
44605: PPUSH
44606: EMPTY
44607: PPUSH
44608: CALL_OW 1
44612: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
44613: LD_VAR 0 1
44617: PPUSH
44618: CALL_OW 247
44622: PUSH
44623: LD_INT 2
44625: EQUAL
44626: PUSH
44627: LD_VAR 0 1
44631: PPUSH
44632: CALL_OW 110
44636: PUSH
44637: LD_INT 20
44639: EQUAL
44640: PUSH
44641: LD_VAR 0 1
44645: PUSH
44646: LD_EXP 72
44650: PUSH
44651: LD_VAR 0 3
44655: ARRAY
44656: IN
44657: OR
44658: PUSH
44659: LD_VAR 0 1
44663: PPUSH
44664: CALL_OW 264
44668: PUSH
44669: LD_INT 12
44671: PUSH
44672: LD_INT 51
44674: PUSH
44675: LD_EXP 94
44679: PUSH
44680: LD_INT 32
44682: PUSH
44683: LD_INT 13
44685: PUSH
44686: LD_INT 52
44688: PUSH
44689: LD_INT 31
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: IN
44701: OR
44702: AND
44703: IFFALSE 45011
// begin if un in mc_defender [ i ] then
44705: LD_VAR 0 1
44709: PUSH
44710: LD_EXP 72
44714: PUSH
44715: LD_VAR 0 3
44719: ARRAY
44720: IN
44721: IFFALSE 44760
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
44723: LD_ADDR_EXP 72
44727: PUSH
44728: LD_EXP 72
44732: PPUSH
44733: LD_VAR 0 3
44737: PPUSH
44738: LD_EXP 72
44742: PUSH
44743: LD_VAR 0 3
44747: ARRAY
44748: PUSH
44749: LD_VAR 0 1
44753: DIFF
44754: PPUSH
44755: CALL_OW 1
44759: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
44760: LD_ADDR_VAR 0 8
44764: PUSH
44765: LD_VAR 0 3
44769: PPUSH
44770: LD_INT 3
44772: PPUSH
44773: CALL 41429 0 2
44777: ST_TO_ADDR
// if fac then
44778: LD_VAR 0 8
44782: IFFALSE 45011
// begin for j in fac do
44784: LD_ADDR_VAR 0 4
44788: PUSH
44789: LD_VAR 0 8
44793: PUSH
44794: FOR_IN
44795: IFFALSE 45009
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
44797: LD_ADDR_VAR 0 9
44801: PUSH
44802: LD_VAR 0 8
44806: PPUSH
44807: LD_VAR 0 1
44811: PPUSH
44812: CALL_OW 265
44816: PPUSH
44817: LD_VAR 0 1
44821: PPUSH
44822: CALL_OW 262
44826: PPUSH
44827: LD_VAR 0 1
44831: PPUSH
44832: CALL_OW 263
44836: PPUSH
44837: LD_VAR 0 1
44841: PPUSH
44842: CALL_OW 264
44846: PPUSH
44847: CALL 52087 0 5
44851: ST_TO_ADDR
// if components then
44852: LD_VAR 0 9
44856: IFFALSE 45007
// begin if GetWeapon ( un ) = ar_control_tower then
44858: LD_VAR 0 1
44862: PPUSH
44863: CALL_OW 264
44867: PUSH
44868: LD_INT 31
44870: EQUAL
44871: IFFALSE 44988
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
44873: LD_VAR 0 1
44877: PPUSH
44878: CALL_OW 311
44882: PPUSH
44883: LD_INT 0
44885: PPUSH
44886: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
44890: LD_ADDR_EXP 90
44894: PUSH
44895: LD_EXP 90
44899: PPUSH
44900: LD_VAR 0 3
44904: PPUSH
44905: LD_EXP 90
44909: PUSH
44910: LD_VAR 0 3
44914: ARRAY
44915: PUSH
44916: LD_VAR 0 1
44920: PPUSH
44921: CALL_OW 311
44925: DIFF
44926: PPUSH
44927: CALL_OW 1
44931: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
44932: LD_ADDR_VAR 0 7
44936: PUSH
44937: LD_EXP 71
44941: PUSH
44942: LD_VAR 0 3
44946: ARRAY
44947: PPUSH
44948: LD_INT 1
44950: PPUSH
44951: LD_VAR 0 9
44955: PPUSH
44956: CALL_OW 2
44960: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
44961: LD_ADDR_EXP 71
44965: PUSH
44966: LD_EXP 71
44970: PPUSH
44971: LD_VAR 0 3
44975: PPUSH
44976: LD_VAR 0 7
44980: PPUSH
44981: CALL_OW 1
44985: ST_TO_ADDR
// end else
44986: GO 45005
// MC_InsertProduceList ( i , [ components ] ) ;
44988: LD_VAR 0 3
44992: PPUSH
44993: LD_VAR 0 9
44997: PUSH
44998: EMPTY
44999: LIST
45000: PPUSH
45001: CALL 40974 0 2
// break ;
45005: GO 45009
// end ; end ;
45007: GO 44794
45009: POP
45010: POP
// end ; end ; if GetType ( un ) = unit_building then
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 247
45020: PUSH
45021: LD_INT 3
45023: EQUAL
45024: IFFALSE 45427
// begin btype := GetBType ( un ) ;
45026: LD_ADDR_VAR 0 5
45030: PUSH
45031: LD_VAR 0 1
45035: PPUSH
45036: CALL_OW 266
45040: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45041: LD_VAR 0 5
45045: PUSH
45046: LD_INT 29
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: IN
45056: IFFALSE 45129
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45058: LD_VAR 0 1
45062: PPUSH
45063: CALL_OW 250
45067: PPUSH
45068: LD_VAR 0 1
45072: PPUSH
45073: CALL_OW 251
45077: PPUSH
45078: LD_VAR 0 1
45082: PPUSH
45083: CALL_OW 255
45087: PPUSH
45088: CALL_OW 440
45092: NOT
45093: IFFALSE 45129
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45095: LD_VAR 0 1
45099: PPUSH
45100: CALL_OW 250
45104: PPUSH
45105: LD_VAR 0 1
45109: PPUSH
45110: CALL_OW 251
45114: PPUSH
45115: LD_VAR 0 1
45119: PPUSH
45120: CALL_OW 255
45124: PPUSH
45125: CALL_OW 441
// end ; if btype = b_warehouse then
45129: LD_VAR 0 5
45133: PUSH
45134: LD_INT 1
45136: EQUAL
45137: IFFALSE 45155
// begin btype := b_depot ;
45139: LD_ADDR_VAR 0 5
45143: PUSH
45144: LD_INT 0
45146: ST_TO_ADDR
// pos := 1 ;
45147: LD_ADDR_VAR 0 6
45151: PUSH
45152: LD_INT 1
45154: ST_TO_ADDR
// end ; if btype = b_factory then
45155: LD_VAR 0 5
45159: PUSH
45160: LD_INT 3
45162: EQUAL
45163: IFFALSE 45181
// begin btype := b_workshop ;
45165: LD_ADDR_VAR 0 5
45169: PUSH
45170: LD_INT 2
45172: ST_TO_ADDR
// pos := 1 ;
45173: LD_ADDR_VAR 0 6
45177: PUSH
45178: LD_INT 1
45180: ST_TO_ADDR
// end ; if btype = b_barracks then
45181: LD_VAR 0 5
45185: PUSH
45186: LD_INT 5
45188: EQUAL
45189: IFFALSE 45199
// btype := b_armoury ;
45191: LD_ADDR_VAR 0 5
45195: PUSH
45196: LD_INT 4
45198: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45199: LD_VAR 0 5
45203: PUSH
45204: LD_INT 7
45206: PUSH
45207: LD_INT 8
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: IN
45214: IFFALSE 45224
// btype := b_lab ;
45216: LD_ADDR_VAR 0 5
45220: PUSH
45221: LD_INT 6
45223: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45224: LD_ADDR_EXP 55
45228: PUSH
45229: LD_EXP 55
45233: PPUSH
45234: LD_VAR 0 3
45238: PUSH
45239: LD_EXP 55
45243: PUSH
45244: LD_VAR 0 3
45248: ARRAY
45249: PUSH
45250: LD_INT 1
45252: PLUS
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PPUSH
45258: LD_VAR 0 5
45262: PUSH
45263: LD_VAR 0 1
45267: PPUSH
45268: CALL_OW 250
45272: PUSH
45273: LD_VAR 0 1
45277: PPUSH
45278: CALL_OW 251
45282: PUSH
45283: LD_VAR 0 1
45287: PPUSH
45288: CALL_OW 254
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: PPUSH
45299: CALL 54555 0 3
45303: ST_TO_ADDR
// if pos = 1 then
45304: LD_VAR 0 6
45308: PUSH
45309: LD_INT 1
45311: EQUAL
45312: IFFALSE 45427
// begin tmp := mc_build_list [ i ] ;
45314: LD_ADDR_VAR 0 7
45318: PUSH
45319: LD_EXP 55
45323: PUSH
45324: LD_VAR 0 3
45328: ARRAY
45329: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45330: LD_VAR 0 7
45334: PPUSH
45335: LD_INT 2
45337: PUSH
45338: LD_INT 30
45340: PUSH
45341: LD_INT 0
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 30
45350: PUSH
45351: LD_INT 1
45353: PUSH
45354: EMPTY
45355: LIST
45356: LIST
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: LIST
45362: PPUSH
45363: CALL_OW 72
45367: IFFALSE 45377
// pos := 2 ;
45369: LD_ADDR_VAR 0 6
45373: PUSH
45374: LD_INT 2
45376: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45377: LD_ADDR_VAR 0 7
45381: PUSH
45382: LD_VAR 0 7
45386: PPUSH
45387: LD_VAR 0 6
45391: PPUSH
45392: LD_VAR 0 7
45396: PPUSH
45397: CALL 54881 0 3
45401: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45402: LD_ADDR_EXP 55
45406: PUSH
45407: LD_EXP 55
45411: PPUSH
45412: LD_VAR 0 3
45416: PPUSH
45417: LD_VAR 0 7
45421: PPUSH
45422: CALL_OW 1
45426: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45427: LD_VAR 0 1
45431: PUSH
45432: LD_EXP 50
45436: PUSH
45437: LD_VAR 0 3
45441: ARRAY
45442: IN
45443: IFFALSE 45482
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45445: LD_ADDR_EXP 50
45449: PUSH
45450: LD_EXP 50
45454: PPUSH
45455: LD_VAR 0 3
45459: PPUSH
45460: LD_EXP 50
45464: PUSH
45465: LD_VAR 0 3
45469: ARRAY
45470: PUSH
45471: LD_VAR 0 1
45475: DIFF
45476: PPUSH
45477: CALL_OW 1
45481: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
45482: LD_VAR 0 1
45486: PUSH
45487: LD_EXP 57
45491: PUSH
45492: LD_VAR 0 3
45496: ARRAY
45497: IN
45498: IFFALSE 45537
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
45500: LD_ADDR_EXP 57
45504: PUSH
45505: LD_EXP 57
45509: PPUSH
45510: LD_VAR 0 3
45514: PPUSH
45515: LD_EXP 57
45519: PUSH
45520: LD_VAR 0 3
45524: ARRAY
45525: PUSH
45526: LD_VAR 0 1
45530: DIFF
45531: PPUSH
45532: CALL_OW 1
45536: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
45537: LD_VAR 0 1
45541: PUSH
45542: LD_EXP 69
45546: PUSH
45547: LD_VAR 0 3
45551: ARRAY
45552: IN
45553: IFFALSE 45592
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
45555: LD_ADDR_EXP 69
45559: PUSH
45560: LD_EXP 69
45564: PPUSH
45565: LD_VAR 0 3
45569: PPUSH
45570: LD_EXP 69
45574: PUSH
45575: LD_VAR 0 3
45579: ARRAY
45580: PUSH
45581: LD_VAR 0 1
45585: DIFF
45586: PPUSH
45587: CALL_OW 1
45591: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
45592: LD_VAR 0 1
45596: PUSH
45597: LD_EXP 72
45601: PUSH
45602: LD_VAR 0 3
45606: ARRAY
45607: IN
45608: IFFALSE 45647
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45610: LD_ADDR_EXP 72
45614: PUSH
45615: LD_EXP 72
45619: PPUSH
45620: LD_VAR 0 3
45624: PPUSH
45625: LD_EXP 72
45629: PUSH
45630: LD_VAR 0 3
45634: ARRAY
45635: PUSH
45636: LD_VAR 0 1
45640: DIFF
45641: PPUSH
45642: CALL_OW 1
45646: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
45647: LD_VAR 0 1
45651: PUSH
45652: LD_EXP 59
45656: PUSH
45657: LD_VAR 0 3
45661: ARRAY
45662: IN
45663: IFFALSE 45702
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
45665: LD_ADDR_EXP 59
45669: PUSH
45670: LD_EXP 59
45674: PPUSH
45675: LD_VAR 0 3
45679: PPUSH
45680: LD_EXP 59
45684: PUSH
45685: LD_VAR 0 3
45689: ARRAY
45690: PUSH
45691: LD_VAR 0 1
45695: DIFF
45696: PPUSH
45697: CALL_OW 1
45701: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
45702: LD_VAR 0 1
45706: PUSH
45707: LD_EXP 58
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: IN
45718: IFFALSE 45757
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
45720: LD_ADDR_EXP 58
45724: PUSH
45725: LD_EXP 58
45729: PPUSH
45730: LD_VAR 0 3
45734: PPUSH
45735: LD_EXP 58
45739: PUSH
45740: LD_VAR 0 3
45744: ARRAY
45745: PUSH
45746: LD_VAR 0 1
45750: DIFF
45751: PPUSH
45752: CALL_OW 1
45756: ST_TO_ADDR
// end ; break ;
45757: GO 45761
// end ;
45759: GO 44407
45761: POP
45762: POP
// end ;
45763: LD_VAR 0 2
45767: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
45768: LD_INT 0
45770: PPUSH
45771: PPUSH
45772: PPUSH
// if not mc_bases or not skirmish then
45773: LD_EXP 50
45777: NOT
45778: PUSH
45779: LD_EXP 48
45783: NOT
45784: OR
45785: IFFALSE 45789
// exit ;
45787: GO 46004
// for i = 1 to mc_bases do
45789: LD_ADDR_VAR 0 3
45793: PUSH
45794: DOUBLE
45795: LD_INT 1
45797: DEC
45798: ST_TO_ADDR
45799: LD_EXP 50
45803: PUSH
45804: FOR_TO
45805: IFFALSE 46002
// begin if building in mc_construct_list [ i ] then
45807: LD_VAR 0 1
45811: PUSH
45812: LD_EXP 57
45816: PUSH
45817: LD_VAR 0 3
45821: ARRAY
45822: IN
45823: IFFALSE 46000
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
45825: LD_ADDR_EXP 57
45829: PUSH
45830: LD_EXP 57
45834: PPUSH
45835: LD_VAR 0 3
45839: PPUSH
45840: LD_EXP 57
45844: PUSH
45845: LD_VAR 0 3
45849: ARRAY
45850: PUSH
45851: LD_VAR 0 1
45855: DIFF
45856: PPUSH
45857: CALL_OW 1
45861: ST_TO_ADDR
// if building in mc_lab [ i ] then
45862: LD_VAR 0 1
45866: PUSH
45867: LD_EXP 83
45871: PUSH
45872: LD_VAR 0 3
45876: ARRAY
45877: IN
45878: IFFALSE 45933
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
45880: LD_ADDR_EXP 84
45884: PUSH
45885: LD_EXP 84
45889: PPUSH
45890: LD_VAR 0 3
45894: PPUSH
45895: LD_EXP 84
45899: PUSH
45900: LD_VAR 0 3
45904: ARRAY
45905: PPUSH
45906: LD_INT 1
45908: PPUSH
45909: LD_EXP 84
45913: PUSH
45914: LD_VAR 0 3
45918: ARRAY
45919: PPUSH
45920: LD_INT 0
45922: PPUSH
45923: CALL 53973 0 4
45927: PPUSH
45928: CALL_OW 1
45932: ST_TO_ADDR
// if not building in mc_bases [ i ] then
45933: LD_VAR 0 1
45937: PUSH
45938: LD_EXP 50
45942: PUSH
45943: LD_VAR 0 3
45947: ARRAY
45948: IN
45949: NOT
45950: IFFALSE 45996
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
45952: LD_ADDR_EXP 50
45956: PUSH
45957: LD_EXP 50
45961: PPUSH
45962: LD_VAR 0 3
45966: PUSH
45967: LD_EXP 50
45971: PUSH
45972: LD_VAR 0 3
45976: ARRAY
45977: PUSH
45978: LD_INT 1
45980: PLUS
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PPUSH
45986: LD_VAR 0 1
45990: PPUSH
45991: CALL 54555 0 3
45995: ST_TO_ADDR
// exit ;
45996: POP
45997: POP
45998: GO 46004
// end ; end ;
46000: GO 45804
46002: POP
46003: POP
// end ;
46004: LD_VAR 0 2
46008: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46009: LD_INT 0
46011: PPUSH
46012: PPUSH
46013: PPUSH
46014: PPUSH
46015: PPUSH
46016: PPUSH
46017: PPUSH
// if not mc_bases or not skirmish then
46018: LD_EXP 50
46022: NOT
46023: PUSH
46024: LD_EXP 48
46028: NOT
46029: OR
46030: IFFALSE 46034
// exit ;
46032: GO 46695
// for i = 1 to mc_bases do
46034: LD_ADDR_VAR 0 3
46038: PUSH
46039: DOUBLE
46040: LD_INT 1
46042: DEC
46043: ST_TO_ADDR
46044: LD_EXP 50
46048: PUSH
46049: FOR_TO
46050: IFFALSE 46693
// begin if building in mc_construct_list [ i ] then
46052: LD_VAR 0 1
46056: PUSH
46057: LD_EXP 57
46061: PUSH
46062: LD_VAR 0 3
46066: ARRAY
46067: IN
46068: IFFALSE 46691
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46070: LD_ADDR_EXP 57
46074: PUSH
46075: LD_EXP 57
46079: PPUSH
46080: LD_VAR 0 3
46084: PPUSH
46085: LD_EXP 57
46089: PUSH
46090: LD_VAR 0 3
46094: ARRAY
46095: PUSH
46096: LD_VAR 0 1
46100: DIFF
46101: PPUSH
46102: CALL_OW 1
46106: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46107: LD_ADDR_EXP 50
46111: PUSH
46112: LD_EXP 50
46116: PPUSH
46117: LD_VAR 0 3
46121: PUSH
46122: LD_EXP 50
46126: PUSH
46127: LD_VAR 0 3
46131: ARRAY
46132: PUSH
46133: LD_INT 1
46135: PLUS
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PPUSH
46141: LD_VAR 0 1
46145: PPUSH
46146: CALL 54555 0 3
46150: ST_TO_ADDR
// btype := GetBType ( building ) ;
46151: LD_ADDR_VAR 0 5
46155: PUSH
46156: LD_VAR 0 1
46160: PPUSH
46161: CALL_OW 266
46165: ST_TO_ADDR
// side := GetSide ( building ) ;
46166: LD_ADDR_VAR 0 8
46170: PUSH
46171: LD_VAR 0 1
46175: PPUSH
46176: CALL_OW 255
46180: ST_TO_ADDR
// if btype = b_lab then
46181: LD_VAR 0 5
46185: PUSH
46186: LD_INT 6
46188: EQUAL
46189: IFFALSE 46239
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46191: LD_ADDR_EXP 83
46195: PUSH
46196: LD_EXP 83
46200: PPUSH
46201: LD_VAR 0 3
46205: PUSH
46206: LD_EXP 83
46210: PUSH
46211: LD_VAR 0 3
46215: ARRAY
46216: PUSH
46217: LD_INT 1
46219: PLUS
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PPUSH
46225: LD_VAR 0 1
46229: PPUSH
46230: CALL 54555 0 3
46234: ST_TO_ADDR
// exit ;
46235: POP
46236: POP
46237: GO 46695
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46239: LD_VAR 0 5
46243: PUSH
46244: LD_INT 0
46246: PUSH
46247: LD_INT 2
46249: PUSH
46250: LD_INT 4
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: IN
46258: IFFALSE 46382
// begin if btype = b_armoury then
46260: LD_VAR 0 5
46264: PUSH
46265: LD_INT 4
46267: EQUAL
46268: IFFALSE 46278
// btype := b_barracks ;
46270: LD_ADDR_VAR 0 5
46274: PUSH
46275: LD_INT 5
46277: ST_TO_ADDR
// if btype = b_depot then
46278: LD_VAR 0 5
46282: PUSH
46283: LD_INT 0
46285: EQUAL
46286: IFFALSE 46296
// btype := b_warehouse ;
46288: LD_ADDR_VAR 0 5
46292: PUSH
46293: LD_INT 1
46295: ST_TO_ADDR
// if btype = b_workshop then
46296: LD_VAR 0 5
46300: PUSH
46301: LD_INT 2
46303: EQUAL
46304: IFFALSE 46314
// btype := b_factory ;
46306: LD_ADDR_VAR 0 5
46310: PUSH
46311: LD_INT 3
46313: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46314: LD_VAR 0 5
46318: PPUSH
46319: LD_VAR 0 8
46323: PPUSH
46324: CALL_OW 323
46328: PUSH
46329: LD_INT 1
46331: EQUAL
46332: IFFALSE 46378
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46334: LD_ADDR_EXP 82
46338: PUSH
46339: LD_EXP 82
46343: PPUSH
46344: LD_VAR 0 3
46348: PUSH
46349: LD_EXP 82
46353: PUSH
46354: LD_VAR 0 3
46358: ARRAY
46359: PUSH
46360: LD_INT 1
46362: PLUS
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PPUSH
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL 54555 0 3
46377: ST_TO_ADDR
// exit ;
46378: POP
46379: POP
46380: GO 46695
// end ; if btype in [ b_bunker , b_turret ] then
46382: LD_VAR 0 5
46386: PUSH
46387: LD_INT 32
46389: PUSH
46390: LD_INT 33
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: IN
46397: IFFALSE 46687
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46399: LD_ADDR_EXP 58
46403: PUSH
46404: LD_EXP 58
46408: PPUSH
46409: LD_VAR 0 3
46413: PUSH
46414: LD_EXP 58
46418: PUSH
46419: LD_VAR 0 3
46423: ARRAY
46424: PUSH
46425: LD_INT 1
46427: PLUS
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PPUSH
46433: LD_VAR 0 1
46437: PPUSH
46438: CALL 54555 0 3
46442: ST_TO_ADDR
// if btype = b_bunker then
46443: LD_VAR 0 5
46447: PUSH
46448: LD_INT 32
46450: EQUAL
46451: IFFALSE 46687
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46453: LD_ADDR_EXP 59
46457: PUSH
46458: LD_EXP 59
46462: PPUSH
46463: LD_VAR 0 3
46467: PUSH
46468: LD_EXP 59
46472: PUSH
46473: LD_VAR 0 3
46477: ARRAY
46478: PUSH
46479: LD_INT 1
46481: PLUS
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PPUSH
46487: LD_VAR 0 1
46491: PPUSH
46492: CALL 54555 0 3
46496: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
46497: LD_ADDR_VAR 0 6
46501: PUSH
46502: LD_EXP 50
46506: PUSH
46507: LD_VAR 0 3
46511: ARRAY
46512: PPUSH
46513: LD_INT 25
46515: PUSH
46516: LD_INT 1
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 3
46525: PUSH
46526: LD_INT 54
46528: PUSH
46529: EMPTY
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PPUSH
46540: CALL_OW 72
46544: ST_TO_ADDR
// if tmp then
46545: LD_VAR 0 6
46549: IFFALSE 46555
// exit ;
46551: POP
46552: POP
46553: GO 46695
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46555: LD_ADDR_VAR 0 6
46559: PUSH
46560: LD_EXP 50
46564: PUSH
46565: LD_VAR 0 3
46569: ARRAY
46570: PPUSH
46571: LD_INT 2
46573: PUSH
46574: LD_INT 30
46576: PUSH
46577: LD_INT 4
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_INT 30
46586: PUSH
46587: LD_INT 5
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: LIST
46598: PPUSH
46599: CALL_OW 72
46603: ST_TO_ADDR
// if not tmp then
46604: LD_VAR 0 6
46608: NOT
46609: IFFALSE 46615
// exit ;
46611: POP
46612: POP
46613: GO 46695
// for j in tmp do
46615: LD_ADDR_VAR 0 4
46619: PUSH
46620: LD_VAR 0 6
46624: PUSH
46625: FOR_IN
46626: IFFALSE 46685
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
46628: LD_ADDR_VAR 0 7
46632: PUSH
46633: LD_VAR 0 4
46637: PPUSH
46638: CALL_OW 313
46642: PPUSH
46643: LD_INT 25
46645: PUSH
46646: LD_INT 1
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PPUSH
46653: CALL_OW 72
46657: ST_TO_ADDR
// if units then
46658: LD_VAR 0 7
46662: IFFALSE 46683
// begin ComExitBuilding ( units [ 1 ] ) ;
46664: LD_VAR 0 7
46668: PUSH
46669: LD_INT 1
46671: ARRAY
46672: PPUSH
46673: CALL_OW 122
// exit ;
46677: POP
46678: POP
46679: POP
46680: POP
46681: GO 46695
// end ; end ;
46683: GO 46625
46685: POP
46686: POP
// end ; end ; exit ;
46687: POP
46688: POP
46689: GO 46695
// end ; end ;
46691: GO 46049
46693: POP
46694: POP
// end ;
46695: LD_VAR 0 2
46699: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
46700: LD_INT 0
46702: PPUSH
46703: PPUSH
46704: PPUSH
46705: PPUSH
46706: PPUSH
46707: PPUSH
46708: PPUSH
// if not mc_bases or not skirmish then
46709: LD_EXP 50
46713: NOT
46714: PUSH
46715: LD_EXP 48
46719: NOT
46720: OR
46721: IFFALSE 46725
// exit ;
46723: GO 46956
// btype := GetBType ( building ) ;
46725: LD_ADDR_VAR 0 6
46729: PUSH
46730: LD_VAR 0 1
46734: PPUSH
46735: CALL_OW 266
46739: ST_TO_ADDR
// x := GetX ( building ) ;
46740: LD_ADDR_VAR 0 7
46744: PUSH
46745: LD_VAR 0 1
46749: PPUSH
46750: CALL_OW 250
46754: ST_TO_ADDR
// y := GetY ( building ) ;
46755: LD_ADDR_VAR 0 8
46759: PUSH
46760: LD_VAR 0 1
46764: PPUSH
46765: CALL_OW 251
46769: ST_TO_ADDR
// d := GetDir ( building ) ;
46770: LD_ADDR_VAR 0 9
46774: PUSH
46775: LD_VAR 0 1
46779: PPUSH
46780: CALL_OW 254
46784: ST_TO_ADDR
// for i = 1 to mc_bases do
46785: LD_ADDR_VAR 0 4
46789: PUSH
46790: DOUBLE
46791: LD_INT 1
46793: DEC
46794: ST_TO_ADDR
46795: LD_EXP 50
46799: PUSH
46800: FOR_TO
46801: IFFALSE 46954
// begin if not mc_build_list [ i ] then
46803: LD_EXP 55
46807: PUSH
46808: LD_VAR 0 4
46812: ARRAY
46813: NOT
46814: IFFALSE 46818
// continue ;
46816: GO 46800
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
46818: LD_VAR 0 6
46822: PUSH
46823: LD_VAR 0 7
46827: PUSH
46828: LD_VAR 0 8
46832: PUSH
46833: LD_VAR 0 9
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: PPUSH
46844: LD_EXP 55
46848: PUSH
46849: LD_VAR 0 4
46853: ARRAY
46854: PUSH
46855: LD_INT 1
46857: ARRAY
46858: PPUSH
46859: CALL 60724 0 2
46863: IFFALSE 46952
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
46865: LD_ADDR_EXP 55
46869: PUSH
46870: LD_EXP 55
46874: PPUSH
46875: LD_VAR 0 4
46879: PPUSH
46880: LD_EXP 55
46884: PUSH
46885: LD_VAR 0 4
46889: ARRAY
46890: PPUSH
46891: LD_INT 1
46893: PPUSH
46894: CALL_OW 3
46898: PPUSH
46899: CALL_OW 1
46903: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
46904: LD_ADDR_EXP 57
46908: PUSH
46909: LD_EXP 57
46913: PPUSH
46914: LD_VAR 0 4
46918: PUSH
46919: LD_EXP 57
46923: PUSH
46924: LD_VAR 0 4
46928: ARRAY
46929: PUSH
46930: LD_INT 1
46932: PLUS
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PPUSH
46938: LD_VAR 0 1
46942: PPUSH
46943: CALL 54555 0 3
46947: ST_TO_ADDR
// exit ;
46948: POP
46949: POP
46950: GO 46956
// end ; end ;
46952: GO 46800
46954: POP
46955: POP
// end ;
46956: LD_VAR 0 3
46960: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
46961: LD_INT 0
46963: PPUSH
46964: PPUSH
46965: PPUSH
// if not mc_bases or not skirmish then
46966: LD_EXP 50
46970: NOT
46971: PUSH
46972: LD_EXP 48
46976: NOT
46977: OR
46978: IFFALSE 46982
// exit ;
46980: GO 47172
// for i = 1 to mc_bases do
46982: LD_ADDR_VAR 0 4
46986: PUSH
46987: DOUBLE
46988: LD_INT 1
46990: DEC
46991: ST_TO_ADDR
46992: LD_EXP 50
46996: PUSH
46997: FOR_TO
46998: IFFALSE 47085
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47000: LD_VAR 0 1
47004: PUSH
47005: LD_EXP 58
47009: PUSH
47010: LD_VAR 0 4
47014: ARRAY
47015: IN
47016: PUSH
47017: LD_VAR 0 1
47021: PUSH
47022: LD_EXP 59
47026: PUSH
47027: LD_VAR 0 4
47031: ARRAY
47032: IN
47033: NOT
47034: AND
47035: IFFALSE 47083
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47037: LD_ADDR_EXP 59
47041: PUSH
47042: LD_EXP 59
47046: PPUSH
47047: LD_VAR 0 4
47051: PUSH
47052: LD_EXP 59
47056: PUSH
47057: LD_VAR 0 4
47061: ARRAY
47062: PUSH
47063: LD_INT 1
47065: PLUS
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PPUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: CALL 54555 0 3
47080: ST_TO_ADDR
// break ;
47081: GO 47085
// end ; end ;
47083: GO 46997
47085: POP
47086: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47087: LD_VAR 0 1
47091: PPUSH
47092: CALL_OW 257
47096: PUSH
47097: LD_EXP 76
47101: IN
47102: PUSH
47103: LD_VAR 0 1
47107: PPUSH
47108: CALL_OW 266
47112: PUSH
47113: LD_INT 5
47115: EQUAL
47116: AND
47117: PUSH
47118: LD_VAR 0 2
47122: PPUSH
47123: CALL_OW 110
47127: PUSH
47128: LD_INT 18
47130: NONEQUAL
47131: AND
47132: IFFALSE 47172
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47134: LD_VAR 0 2
47138: PPUSH
47139: CALL_OW 257
47143: PUSH
47144: LD_INT 5
47146: PUSH
47147: LD_INT 8
47149: PUSH
47150: LD_INT 9
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: LIST
47157: IN
47158: IFFALSE 47172
// SetClass ( unit , 1 ) ;
47160: LD_VAR 0 2
47164: PPUSH
47165: LD_INT 1
47167: PPUSH
47168: CALL_OW 336
// end ;
47172: LD_VAR 0 3
47176: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47177: LD_INT 0
47179: PPUSH
47180: PPUSH
// if not mc_bases or not skirmish then
47181: LD_EXP 50
47185: NOT
47186: PUSH
47187: LD_EXP 48
47191: NOT
47192: OR
47193: IFFALSE 47197
// exit ;
47195: GO 47313
// if GetLives ( abandoned_vehicle ) > 250 then
47197: LD_VAR 0 2
47201: PPUSH
47202: CALL_OW 256
47206: PUSH
47207: LD_INT 250
47209: GREATER
47210: IFFALSE 47214
// exit ;
47212: GO 47313
// for i = 1 to mc_bases do
47214: LD_ADDR_VAR 0 6
47218: PUSH
47219: DOUBLE
47220: LD_INT 1
47222: DEC
47223: ST_TO_ADDR
47224: LD_EXP 50
47228: PUSH
47229: FOR_TO
47230: IFFALSE 47311
// begin if driver in mc_bases [ i ] then
47232: LD_VAR 0 1
47236: PUSH
47237: LD_EXP 50
47241: PUSH
47242: LD_VAR 0 6
47246: ARRAY
47247: IN
47248: IFFALSE 47309
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47250: LD_VAR 0 1
47254: PPUSH
47255: LD_EXP 50
47259: PUSH
47260: LD_VAR 0 6
47264: ARRAY
47265: PPUSH
47266: LD_INT 2
47268: PUSH
47269: LD_INT 30
47271: PUSH
47272: LD_INT 0
47274: PUSH
47275: EMPTY
47276: LIST
47277: LIST
47278: PUSH
47279: LD_INT 30
47281: PUSH
47282: LD_INT 1
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: LIST
47293: PPUSH
47294: CALL_OW 72
47298: PUSH
47299: LD_INT 1
47301: ARRAY
47302: PPUSH
47303: CALL_OW 112
// break ;
47307: GO 47311
// end ; end ;
47309: GO 47229
47311: POP
47312: POP
// end ; end_of_file
47313: LD_VAR 0 5
47317: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47318: LD_INT 0
47320: PPUSH
47321: PPUSH
// if exist_mode then
47322: LD_VAR 0 2
47326: IFFALSE 47351
// unit := CreateCharacter ( prefix & ident ) else
47328: LD_ADDR_VAR 0 5
47332: PUSH
47333: LD_VAR 0 3
47337: PUSH
47338: LD_VAR 0 1
47342: STR
47343: PPUSH
47344: CALL_OW 34
47348: ST_TO_ADDR
47349: GO 47366
// unit := NewCharacter ( ident ) ;
47351: LD_ADDR_VAR 0 5
47355: PUSH
47356: LD_VAR 0 1
47360: PPUSH
47361: CALL_OW 25
47365: ST_TO_ADDR
// result := unit ;
47366: LD_ADDR_VAR 0 4
47370: PUSH
47371: LD_VAR 0 5
47375: ST_TO_ADDR
// end ;
47376: LD_VAR 0 4
47380: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47381: LD_INT 0
47383: PPUSH
47384: PPUSH
// if not side or not nation then
47385: LD_VAR 0 1
47389: NOT
47390: PUSH
47391: LD_VAR 0 2
47395: NOT
47396: OR
47397: IFFALSE 47401
// exit ;
47399: GO 48045
// case nation of nation_american :
47401: LD_VAR 0 2
47405: PUSH
47406: LD_INT 1
47408: DOUBLE
47409: EQUAL
47410: IFTRUE 47414
47412: GO 47588
47414: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
47415: LD_ADDR_VAR 0 4
47419: PUSH
47420: LD_INT 35
47422: PUSH
47423: LD_INT 45
47425: PUSH
47426: LD_INT 46
47428: PUSH
47429: LD_INT 47
47431: PUSH
47432: LD_INT 1
47434: PUSH
47435: LD_INT 2
47437: PUSH
47438: LD_INT 6
47440: PUSH
47441: LD_INT 15
47443: PUSH
47444: LD_INT 16
47446: PUSH
47447: LD_INT 7
47449: PUSH
47450: LD_INT 12
47452: PUSH
47453: LD_INT 13
47455: PUSH
47456: LD_INT 10
47458: PUSH
47459: LD_INT 14
47461: PUSH
47462: LD_INT 20
47464: PUSH
47465: LD_INT 21
47467: PUSH
47468: LD_INT 22
47470: PUSH
47471: LD_INT 25
47473: PUSH
47474: LD_INT 32
47476: PUSH
47477: LD_INT 27
47479: PUSH
47480: LD_INT 36
47482: PUSH
47483: LD_INT 69
47485: PUSH
47486: LD_INT 39
47488: PUSH
47489: LD_INT 34
47491: PUSH
47492: LD_INT 40
47494: PUSH
47495: LD_INT 48
47497: PUSH
47498: LD_INT 49
47500: PUSH
47501: LD_INT 50
47503: PUSH
47504: LD_INT 51
47506: PUSH
47507: LD_INT 52
47509: PUSH
47510: LD_INT 53
47512: PUSH
47513: LD_INT 54
47515: PUSH
47516: LD_INT 55
47518: PUSH
47519: LD_INT 56
47521: PUSH
47522: LD_INT 57
47524: PUSH
47525: LD_INT 58
47527: PUSH
47528: LD_INT 59
47530: PUSH
47531: LD_INT 60
47533: PUSH
47534: LD_INT 61
47536: PUSH
47537: LD_INT 62
47539: PUSH
47540: LD_INT 80
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: LIST
47547: LIST
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: LIST
47577: LIST
47578: LIST
47579: LIST
47580: LIST
47581: LIST
47582: LIST
47583: LIST
47584: LIST
47585: ST_TO_ADDR
47586: GO 47969
47588: LD_INT 2
47590: DOUBLE
47591: EQUAL
47592: IFTRUE 47596
47594: GO 47778
47596: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
47597: LD_ADDR_VAR 0 4
47601: PUSH
47602: LD_INT 35
47604: PUSH
47605: LD_INT 45
47607: PUSH
47608: LD_INT 46
47610: PUSH
47611: LD_INT 47
47613: PUSH
47614: LD_INT 70
47616: PUSH
47617: LD_INT 1
47619: PUSH
47620: LD_INT 11
47622: PUSH
47623: LD_INT 3
47625: PUSH
47626: LD_INT 4
47628: PUSH
47629: LD_INT 5
47631: PUSH
47632: LD_INT 6
47634: PUSH
47635: LD_INT 15
47637: PUSH
47638: LD_INT 18
47640: PUSH
47641: LD_INT 7
47643: PUSH
47644: LD_INT 17
47646: PUSH
47647: LD_INT 8
47649: PUSH
47650: LD_INT 20
47652: PUSH
47653: LD_INT 21
47655: PUSH
47656: LD_INT 22
47658: PUSH
47659: LD_INT 72
47661: PUSH
47662: LD_INT 26
47664: PUSH
47665: LD_INT 69
47667: PUSH
47668: LD_INT 39
47670: PUSH
47671: LD_INT 40
47673: PUSH
47674: LD_INT 41
47676: PUSH
47677: LD_INT 42
47679: PUSH
47680: LD_INT 43
47682: PUSH
47683: LD_INT 48
47685: PUSH
47686: LD_INT 49
47688: PUSH
47689: LD_INT 50
47691: PUSH
47692: LD_INT 51
47694: PUSH
47695: LD_INT 52
47697: PUSH
47698: LD_INT 53
47700: PUSH
47701: LD_INT 54
47703: PUSH
47704: LD_INT 55
47706: PUSH
47707: LD_INT 56
47709: PUSH
47710: LD_INT 60
47712: PUSH
47713: LD_INT 61
47715: PUSH
47716: LD_INT 62
47718: PUSH
47719: LD_INT 66
47721: PUSH
47722: LD_INT 67
47724: PUSH
47725: LD_INT 68
47727: PUSH
47728: LD_INT 81
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: ST_TO_ADDR
47776: GO 47969
47778: LD_INT 3
47780: DOUBLE
47781: EQUAL
47782: IFTRUE 47786
47784: GO 47968
47786: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
47787: LD_ADDR_VAR 0 4
47791: PUSH
47792: LD_INT 46
47794: PUSH
47795: LD_INT 47
47797: PUSH
47798: LD_INT 1
47800: PUSH
47801: LD_INT 2
47803: PUSH
47804: LD_INT 11
47806: PUSH
47807: LD_INT 9
47809: PUSH
47810: LD_INT 20
47812: PUSH
47813: LD_INT 19
47815: PUSH
47816: LD_INT 21
47818: PUSH
47819: LD_INT 24
47821: PUSH
47822: LD_INT 22
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: LD_INT 28
47830: PUSH
47831: LD_INT 29
47833: PUSH
47834: LD_INT 30
47836: PUSH
47837: LD_INT 31
47839: PUSH
47840: LD_INT 37
47842: PUSH
47843: LD_INT 38
47845: PUSH
47846: LD_INT 32
47848: PUSH
47849: LD_INT 27
47851: PUSH
47852: LD_INT 33
47854: PUSH
47855: LD_INT 69
47857: PUSH
47858: LD_INT 39
47860: PUSH
47861: LD_INT 34
47863: PUSH
47864: LD_INT 40
47866: PUSH
47867: LD_INT 71
47869: PUSH
47870: LD_INT 23
47872: PUSH
47873: LD_INT 44
47875: PUSH
47876: LD_INT 48
47878: PUSH
47879: LD_INT 49
47881: PUSH
47882: LD_INT 50
47884: PUSH
47885: LD_INT 51
47887: PUSH
47888: LD_INT 52
47890: PUSH
47891: LD_INT 53
47893: PUSH
47894: LD_INT 54
47896: PUSH
47897: LD_INT 55
47899: PUSH
47900: LD_INT 56
47902: PUSH
47903: LD_INT 57
47905: PUSH
47906: LD_INT 58
47908: PUSH
47909: LD_INT 59
47911: PUSH
47912: LD_INT 63
47914: PUSH
47915: LD_INT 64
47917: PUSH
47918: LD_INT 65
47920: PUSH
47921: EMPTY
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: LIST
47933: LIST
47934: LIST
47935: LIST
47936: LIST
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: ST_TO_ADDR
47966: GO 47969
47968: POP
// if state > - 1 and state < 3 then
47969: LD_VAR 0 3
47973: PUSH
47974: LD_INT 1
47976: NEG
47977: GREATER
47978: PUSH
47979: LD_VAR 0 3
47983: PUSH
47984: LD_INT 3
47986: LESS
47987: AND
47988: IFFALSE 48045
// for i in result do
47990: LD_ADDR_VAR 0 5
47994: PUSH
47995: LD_VAR 0 4
47999: PUSH
48000: FOR_IN
48001: IFFALSE 48043
// if GetTech ( i , side ) <> state then
48003: LD_VAR 0 5
48007: PPUSH
48008: LD_VAR 0 1
48012: PPUSH
48013: CALL_OW 321
48017: PUSH
48018: LD_VAR 0 3
48022: NONEQUAL
48023: IFFALSE 48041
// result := result diff i ;
48025: LD_ADDR_VAR 0 4
48029: PUSH
48030: LD_VAR 0 4
48034: PUSH
48035: LD_VAR 0 5
48039: DIFF
48040: ST_TO_ADDR
48041: GO 48000
48043: POP
48044: POP
// end ;
48045: LD_VAR 0 4
48049: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
// result := true ;
48055: LD_ADDR_VAR 0 3
48059: PUSH
48060: LD_INT 1
48062: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48063: LD_ADDR_VAR 0 5
48067: PUSH
48068: LD_VAR 0 2
48072: PPUSH
48073: CALL_OW 480
48077: ST_TO_ADDR
// if not tmp then
48078: LD_VAR 0 5
48082: NOT
48083: IFFALSE 48087
// exit ;
48085: GO 48136
// for i in tmp do
48087: LD_ADDR_VAR 0 4
48091: PUSH
48092: LD_VAR 0 5
48096: PUSH
48097: FOR_IN
48098: IFFALSE 48134
// if GetTech ( i , side ) <> state_researched then
48100: LD_VAR 0 4
48104: PPUSH
48105: LD_VAR 0 1
48109: PPUSH
48110: CALL_OW 321
48114: PUSH
48115: LD_INT 2
48117: NONEQUAL
48118: IFFALSE 48132
// begin result := false ;
48120: LD_ADDR_VAR 0 3
48124: PUSH
48125: LD_INT 0
48127: ST_TO_ADDR
// exit ;
48128: POP
48129: POP
48130: GO 48136
// end ;
48132: GO 48097
48134: POP
48135: POP
// end ;
48136: LD_VAR 0 3
48140: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48141: LD_INT 0
48143: PPUSH
48144: PPUSH
48145: PPUSH
48146: PPUSH
48147: PPUSH
48148: PPUSH
48149: PPUSH
48150: PPUSH
48151: PPUSH
48152: PPUSH
48153: PPUSH
48154: PPUSH
48155: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48156: LD_VAR 0 1
48160: NOT
48161: PUSH
48162: LD_VAR 0 1
48166: PPUSH
48167: CALL_OW 257
48171: PUSH
48172: LD_INT 9
48174: NONEQUAL
48175: OR
48176: IFFALSE 48180
// exit ;
48178: GO 48753
// side := GetSide ( unit ) ;
48180: LD_ADDR_VAR 0 9
48184: PUSH
48185: LD_VAR 0 1
48189: PPUSH
48190: CALL_OW 255
48194: ST_TO_ADDR
// tech_space := tech_spacanom ;
48195: LD_ADDR_VAR 0 12
48199: PUSH
48200: LD_INT 29
48202: ST_TO_ADDR
// tech_time := tech_taurad ;
48203: LD_ADDR_VAR 0 13
48207: PUSH
48208: LD_INT 28
48210: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48211: LD_ADDR_VAR 0 11
48215: PUSH
48216: LD_VAR 0 1
48220: PPUSH
48221: CALL_OW 310
48225: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48226: LD_VAR 0 11
48230: PPUSH
48231: CALL_OW 247
48235: PUSH
48236: LD_INT 2
48238: EQUAL
48239: IFFALSE 48243
// exit ;
48241: GO 48753
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48243: LD_ADDR_VAR 0 8
48247: PUSH
48248: LD_INT 81
48250: PUSH
48251: LD_VAR 0 9
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: PUSH
48260: LD_INT 3
48262: PUSH
48263: LD_INT 21
48265: PUSH
48266: LD_INT 3
48268: PUSH
48269: EMPTY
48270: LIST
48271: LIST
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PPUSH
48281: CALL_OW 69
48285: ST_TO_ADDR
// if not tmp then
48286: LD_VAR 0 8
48290: NOT
48291: IFFALSE 48295
// exit ;
48293: GO 48753
// if in_unit then
48295: LD_VAR 0 11
48299: IFFALSE 48323
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48301: LD_ADDR_VAR 0 10
48305: PUSH
48306: LD_VAR 0 8
48310: PPUSH
48311: LD_VAR 0 11
48315: PPUSH
48316: CALL_OW 74
48320: ST_TO_ADDR
48321: GO 48343
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48323: LD_ADDR_VAR 0 10
48327: PUSH
48328: LD_VAR 0 8
48332: PPUSH
48333: LD_VAR 0 1
48337: PPUSH
48338: CALL_OW 74
48342: ST_TO_ADDR
// if not enemy then
48343: LD_VAR 0 10
48347: NOT
48348: IFFALSE 48352
// exit ;
48350: GO 48753
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
48352: LD_VAR 0 11
48356: PUSH
48357: LD_VAR 0 11
48361: PPUSH
48362: LD_VAR 0 10
48366: PPUSH
48367: CALL_OW 296
48371: PUSH
48372: LD_INT 13
48374: GREATER
48375: AND
48376: PUSH
48377: LD_VAR 0 1
48381: PPUSH
48382: LD_VAR 0 10
48386: PPUSH
48387: CALL_OW 296
48391: PUSH
48392: LD_INT 12
48394: GREATER
48395: OR
48396: IFFALSE 48400
// exit ;
48398: GO 48753
// missile := [ 1 ] ;
48400: LD_ADDR_VAR 0 14
48404: PUSH
48405: LD_INT 1
48407: PUSH
48408: EMPTY
48409: LIST
48410: ST_TO_ADDR
// if Researched ( side , tech_space ) then
48411: LD_VAR 0 9
48415: PPUSH
48416: LD_VAR 0 12
48420: PPUSH
48421: CALL_OW 325
48425: IFFALSE 48454
// missile := Insert ( missile , missile + 1 , 2 ) ;
48427: LD_ADDR_VAR 0 14
48431: PUSH
48432: LD_VAR 0 14
48436: PPUSH
48437: LD_VAR 0 14
48441: PUSH
48442: LD_INT 1
48444: PLUS
48445: PPUSH
48446: LD_INT 2
48448: PPUSH
48449: CALL_OW 2
48453: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
48454: LD_VAR 0 9
48458: PPUSH
48459: LD_VAR 0 13
48463: PPUSH
48464: CALL_OW 325
48468: PUSH
48469: LD_VAR 0 10
48473: PPUSH
48474: CALL_OW 255
48478: PPUSH
48479: LD_VAR 0 13
48483: PPUSH
48484: CALL_OW 325
48488: NOT
48489: AND
48490: IFFALSE 48519
// missile := Insert ( missile , missile + 1 , 3 ) ;
48492: LD_ADDR_VAR 0 14
48496: PUSH
48497: LD_VAR 0 14
48501: PPUSH
48502: LD_VAR 0 14
48506: PUSH
48507: LD_INT 1
48509: PLUS
48510: PPUSH
48511: LD_INT 3
48513: PPUSH
48514: CALL_OW 2
48518: ST_TO_ADDR
// if missile < 2 then
48519: LD_VAR 0 14
48523: PUSH
48524: LD_INT 2
48526: LESS
48527: IFFALSE 48531
// exit ;
48529: GO 48753
// x := GetX ( enemy ) ;
48531: LD_ADDR_VAR 0 4
48535: PUSH
48536: LD_VAR 0 10
48540: PPUSH
48541: CALL_OW 250
48545: ST_TO_ADDR
// y := GetY ( enemy ) ;
48546: LD_ADDR_VAR 0 5
48550: PUSH
48551: LD_VAR 0 10
48555: PPUSH
48556: CALL_OW 251
48560: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
48561: LD_ADDR_VAR 0 6
48565: PUSH
48566: LD_VAR 0 4
48570: PUSH
48571: LD_INT 1
48573: NEG
48574: PPUSH
48575: LD_INT 1
48577: PPUSH
48578: CALL_OW 12
48582: PLUS
48583: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
48584: LD_ADDR_VAR 0 7
48588: PUSH
48589: LD_VAR 0 5
48593: PUSH
48594: LD_INT 1
48596: NEG
48597: PPUSH
48598: LD_INT 1
48600: PPUSH
48601: CALL_OW 12
48605: PLUS
48606: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48607: LD_VAR 0 6
48611: PPUSH
48612: LD_VAR 0 7
48616: PPUSH
48617: CALL_OW 488
48621: NOT
48622: IFFALSE 48644
// begin _x := x ;
48624: LD_ADDR_VAR 0 6
48628: PUSH
48629: LD_VAR 0 4
48633: ST_TO_ADDR
// _y := y ;
48634: LD_ADDR_VAR 0 7
48638: PUSH
48639: LD_VAR 0 5
48643: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
48644: LD_ADDR_VAR 0 3
48648: PUSH
48649: LD_INT 1
48651: PPUSH
48652: LD_VAR 0 14
48656: PPUSH
48657: CALL_OW 12
48661: ST_TO_ADDR
// case i of 1 :
48662: LD_VAR 0 3
48666: PUSH
48667: LD_INT 1
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48692
48675: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
48676: LD_VAR 0 1
48680: PPUSH
48681: LD_VAR 0 10
48685: PPUSH
48686: CALL_OW 115
48690: GO 48753
48692: LD_INT 2
48694: DOUBLE
48695: EQUAL
48696: IFTRUE 48700
48698: GO 48722
48700: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
48701: LD_VAR 0 1
48705: PPUSH
48706: LD_VAR 0 6
48710: PPUSH
48711: LD_VAR 0 7
48715: PPUSH
48716: CALL_OW 153
48720: GO 48753
48722: LD_INT 3
48724: DOUBLE
48725: EQUAL
48726: IFTRUE 48730
48728: GO 48752
48730: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
48731: LD_VAR 0 1
48735: PPUSH
48736: LD_VAR 0 6
48740: PPUSH
48741: LD_VAR 0 7
48745: PPUSH
48746: CALL_OW 154
48750: GO 48753
48752: POP
// end ;
48753: LD_VAR 0 2
48757: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
48758: LD_INT 0
48760: PPUSH
48761: PPUSH
48762: PPUSH
48763: PPUSH
48764: PPUSH
48765: PPUSH
// if not unit or not building then
48766: LD_VAR 0 1
48770: NOT
48771: PUSH
48772: LD_VAR 0 2
48776: NOT
48777: OR
48778: IFFALSE 48782
// exit ;
48780: GO 48940
// x := GetX ( building ) ;
48782: LD_ADDR_VAR 0 5
48786: PUSH
48787: LD_VAR 0 2
48791: PPUSH
48792: CALL_OW 250
48796: ST_TO_ADDR
// y := GetY ( building ) ;
48797: LD_ADDR_VAR 0 6
48801: PUSH
48802: LD_VAR 0 2
48806: PPUSH
48807: CALL_OW 251
48811: ST_TO_ADDR
// for i = 0 to 5 do
48812: LD_ADDR_VAR 0 4
48816: PUSH
48817: DOUBLE
48818: LD_INT 0
48820: DEC
48821: ST_TO_ADDR
48822: LD_INT 5
48824: PUSH
48825: FOR_TO
48826: IFFALSE 48938
// begin _x := ShiftX ( x , i , 3 ) ;
48828: LD_ADDR_VAR 0 7
48832: PUSH
48833: LD_VAR 0 5
48837: PPUSH
48838: LD_VAR 0 4
48842: PPUSH
48843: LD_INT 3
48845: PPUSH
48846: CALL_OW 272
48850: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
48851: LD_ADDR_VAR 0 8
48855: PUSH
48856: LD_VAR 0 6
48860: PPUSH
48861: LD_VAR 0 4
48865: PPUSH
48866: LD_INT 3
48868: PPUSH
48869: CALL_OW 273
48873: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48874: LD_VAR 0 7
48878: PPUSH
48879: LD_VAR 0 8
48883: PPUSH
48884: CALL_OW 488
48888: NOT
48889: IFFALSE 48893
// continue ;
48891: GO 48825
// if HexInfo ( _x , _y ) = 0 then
48893: LD_VAR 0 7
48897: PPUSH
48898: LD_VAR 0 8
48902: PPUSH
48903: CALL_OW 428
48907: PUSH
48908: LD_INT 0
48910: EQUAL
48911: IFFALSE 48936
// begin ComMoveXY ( unit , _x , _y ) ;
48913: LD_VAR 0 1
48917: PPUSH
48918: LD_VAR 0 7
48922: PPUSH
48923: LD_VAR 0 8
48927: PPUSH
48928: CALL_OW 111
// exit ;
48932: POP
48933: POP
48934: GO 48940
// end ; end ;
48936: GO 48825
48938: POP
48939: POP
// end ;
48940: LD_VAR 0 3
48944: RET
// export function ScanBase ( side , base_area ) ; begin
48945: LD_INT 0
48947: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
48948: LD_ADDR_VAR 0 3
48952: PUSH
48953: LD_VAR 0 2
48957: PPUSH
48958: LD_INT 81
48960: PUSH
48961: LD_VAR 0 1
48965: PUSH
48966: EMPTY
48967: LIST
48968: LIST
48969: PPUSH
48970: CALL_OW 70
48974: ST_TO_ADDR
// end ;
48975: LD_VAR 0 3
48979: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
48980: LD_INT 0
48982: PPUSH
48983: PPUSH
48984: PPUSH
48985: PPUSH
48986: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
48987: LD_VAR 0 1
48991: NOT
48992: PUSH
48993: LD_EXP 50
48997: PUSH
48998: LD_VAR 0 1
49002: ARRAY
49003: NOT
49004: OR
49005: PUSH
49006: LD_VAR 0 2
49010: NOT
49011: OR
49012: PUSH
49013: LD_VAR 0 3
49017: NOT
49018: OR
49019: IFFALSE 49023
// exit ;
49021: GO 49536
// side := mc_sides [ base ] ;
49023: LD_ADDR_VAR 0 6
49027: PUSH
49028: LD_EXP 76
49032: PUSH
49033: LD_VAR 0 1
49037: ARRAY
49038: ST_TO_ADDR
// if not side then
49039: LD_VAR 0 6
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49536
// for i in solds do
49048: LD_ADDR_VAR 0 7
49052: PUSH
49053: LD_VAR 0 2
49057: PUSH
49058: FOR_IN
49059: IFFALSE 49120
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
49061: LD_VAR 0 7
49065: PPUSH
49066: CALL_OW 310
49070: PPUSH
49071: CALL_OW 266
49075: PUSH
49076: LD_INT 32
49078: PUSH
49079: LD_INT 31
49081: PUSH
49082: EMPTY
49083: LIST
49084: LIST
49085: IN
49086: IFFALSE 49106
// solds := solds diff i else
49088: LD_ADDR_VAR 0 2
49092: PUSH
49093: LD_VAR 0 2
49097: PUSH
49098: LD_VAR 0 7
49102: DIFF
49103: ST_TO_ADDR
49104: GO 49118
// SetTag ( i , 18 ) ;
49106: LD_VAR 0 7
49110: PPUSH
49111: LD_INT 18
49113: PPUSH
49114: CALL_OW 109
49118: GO 49058
49120: POP
49121: POP
// if not solds then
49122: LD_VAR 0 2
49126: NOT
49127: IFFALSE 49131
// exit ;
49129: GO 49536
// repeat wait ( 0 0$1 ) ;
49131: LD_INT 35
49133: PPUSH
49134: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 6
49147: PPUSH
49148: LD_VAR 0 3
49152: PPUSH
49153: CALL 48945 0 2
49157: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49158: LD_EXP 50
49162: PUSH
49163: LD_VAR 0 1
49167: ARRAY
49168: NOT
49169: PUSH
49170: LD_EXP 50
49174: PUSH
49175: LD_VAR 0 1
49179: ARRAY
49180: PUSH
49181: EMPTY
49182: EQUAL
49183: OR
49184: IFFALSE 49221
// begin for i in solds do
49186: LD_ADDR_VAR 0 7
49190: PUSH
49191: LD_VAR 0 2
49195: PUSH
49196: FOR_IN
49197: IFFALSE 49210
// ComStop ( i ) ;
49199: LD_VAR 0 7
49203: PPUSH
49204: CALL_OW 141
49208: GO 49196
49210: POP
49211: POP
// solds := [ ] ;
49212: LD_ADDR_VAR 0 2
49216: PUSH
49217: EMPTY
49218: ST_TO_ADDR
// exit ;
49219: GO 49536
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
49221: LD_VAR 0 5
49225: NOT
49226: PUSH
49227: LD_VAR 0 5
49231: PUSH
49232: LD_INT 3
49234: GREATER
49235: OR
49236: PUSH
49237: LD_EXP 72
49241: PUSH
49242: LD_VAR 0 1
49246: ARRAY
49247: OR
49248: IFFALSE 49289
// begin for i in solds do
49250: LD_ADDR_VAR 0 7
49254: PUSH
49255: LD_VAR 0 2
49259: PUSH
49260: FOR_IN
49261: IFFALSE 49285
// if HasTask ( i ) then
49263: LD_VAR 0 7
49267: PPUSH
49268: CALL_OW 314
49272: IFFALSE 49283
// ComStop ( i ) ;
49274: LD_VAR 0 7
49278: PPUSH
49279: CALL_OW 141
49283: GO 49260
49285: POP
49286: POP
// break ;
49287: GO 49524
// end ; for i in solds do
49289: LD_ADDR_VAR 0 7
49293: PUSH
49294: LD_VAR 0 2
49298: PUSH
49299: FOR_IN
49300: IFFALSE 49516
// begin if IsInUnit ( i ) then
49302: LD_VAR 0 7
49306: PPUSH
49307: CALL_OW 310
49311: IFFALSE 49322
// ComExitBuilding ( i ) ;
49313: LD_VAR 0 7
49317: PPUSH
49318: CALL_OW 122
// if GetLives ( i ) > 333 then
49322: LD_VAR 0 7
49326: PPUSH
49327: CALL_OW 256
49331: PUSH
49332: LD_INT 333
49334: GREATER
49335: IFFALSE 49363
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
49337: LD_VAR 0 7
49341: PPUSH
49342: LD_VAR 0 5
49346: PPUSH
49347: LD_VAR 0 7
49351: PPUSH
49352: CALL_OW 74
49356: PPUSH
49357: CALL_OW 115
49361: GO 49514
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
49363: LD_ADDR_VAR 0 8
49367: PUSH
49368: LD_EXP 50
49372: PUSH
49373: LD_VAR 0 1
49377: ARRAY
49378: PPUSH
49379: LD_INT 2
49381: PUSH
49382: LD_INT 30
49384: PUSH
49385: LD_INT 0
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 30
49394: PUSH
49395: LD_INT 1
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 30
49404: PUSH
49405: LD_INT 6
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: EMPTY
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 72
49422: PPUSH
49423: LD_VAR 0 7
49427: PPUSH
49428: CALL_OW 74
49432: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
49433: LD_VAR 0 7
49437: PPUSH
49438: LD_VAR 0 8
49442: PPUSH
49443: CALL_OW 250
49447: PPUSH
49448: LD_INT 3
49450: PPUSH
49451: LD_INT 5
49453: PPUSH
49454: CALL_OW 272
49458: PPUSH
49459: LD_VAR 0 8
49463: PPUSH
49464: CALL_OW 251
49468: PPUSH
49469: LD_INT 3
49471: PPUSH
49472: LD_INT 5
49474: PPUSH
49475: CALL_OW 273
49479: PPUSH
49480: CALL_OW 111
// SetTag ( i , 0 ) ;
49484: LD_VAR 0 7
49488: PPUSH
49489: LD_INT 0
49491: PPUSH
49492: CALL_OW 109
// solds := solds diff i ;
49496: LD_ADDR_VAR 0 2
49500: PUSH
49501: LD_VAR 0 2
49505: PUSH
49506: LD_VAR 0 7
49510: DIFF
49511: ST_TO_ADDR
// continue ;
49512: GO 49299
// end ; end ;
49514: GO 49299
49516: POP
49517: POP
// until solds ;
49518: LD_VAR 0 2
49522: IFFALSE 49131
// MC_Reset ( base , 18 ) ;
49524: LD_VAR 0 1
49528: PPUSH
49529: LD_INT 18
49531: PPUSH
49532: CALL 21253 0 2
// end ;
49536: LD_VAR 0 4
49540: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
49541: LD_INT 0
49543: PPUSH
49544: PPUSH
49545: PPUSH
49546: PPUSH
49547: PPUSH
49548: PPUSH
49549: PPUSH
49550: PPUSH
49551: PPUSH
49552: PPUSH
49553: PPUSH
49554: PPUSH
49555: PPUSH
49556: PPUSH
49557: PPUSH
49558: PPUSH
49559: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
49560: LD_ADDR_VAR 0 13
49564: PUSH
49565: LD_EXP 50
49569: PUSH
49570: LD_VAR 0 1
49574: ARRAY
49575: PPUSH
49576: LD_INT 25
49578: PUSH
49579: LD_INT 3
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PPUSH
49586: CALL_OW 72
49590: ST_TO_ADDR
// if mc_remote_driver [ base ] then
49591: LD_EXP 90
49595: PUSH
49596: LD_VAR 0 1
49600: ARRAY
49601: IFFALSE 49625
// mechs := mechs diff mc_remote_driver [ base ] ;
49603: LD_ADDR_VAR 0 13
49607: PUSH
49608: LD_VAR 0 13
49612: PUSH
49613: LD_EXP 90
49617: PUSH
49618: LD_VAR 0 1
49622: ARRAY
49623: DIFF
49624: ST_TO_ADDR
// for i in mechs do
49625: LD_ADDR_VAR 0 5
49629: PUSH
49630: LD_VAR 0 13
49634: PUSH
49635: FOR_IN
49636: IFFALSE 49671
// if GetTag ( i ) > 0 then
49638: LD_VAR 0 5
49642: PPUSH
49643: CALL_OW 110
49647: PUSH
49648: LD_INT 0
49650: GREATER
49651: IFFALSE 49669
// mechs := mechs diff i ;
49653: LD_ADDR_VAR 0 13
49657: PUSH
49658: LD_VAR 0 13
49662: PUSH
49663: LD_VAR 0 5
49667: DIFF
49668: ST_TO_ADDR
49669: GO 49635
49671: POP
49672: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49673: LD_ADDR_VAR 0 9
49677: PUSH
49678: LD_EXP 50
49682: PUSH
49683: LD_VAR 0 1
49687: ARRAY
49688: PPUSH
49689: LD_INT 2
49691: PUSH
49692: LD_INT 25
49694: PUSH
49695: LD_INT 1
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PUSH
49702: LD_INT 25
49704: PUSH
49705: LD_INT 5
49707: PUSH
49708: EMPTY
49709: LIST
49710: LIST
49711: PUSH
49712: LD_INT 25
49714: PUSH
49715: LD_INT 8
49717: PUSH
49718: EMPTY
49719: LIST
49720: LIST
49721: PUSH
49722: LD_INT 25
49724: PUSH
49725: LD_INT 9
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: PPUSH
49739: CALL_OW 72
49743: ST_TO_ADDR
// if not defenders and not solds then
49744: LD_VAR 0 2
49748: NOT
49749: PUSH
49750: LD_VAR 0 9
49754: NOT
49755: AND
49756: IFFALSE 49760
// exit ;
49758: GO 51386
// depot_under_attack := false ;
49760: LD_ADDR_VAR 0 17
49764: PUSH
49765: LD_INT 0
49767: ST_TO_ADDR
// sold_defenders := [ ] ;
49768: LD_ADDR_VAR 0 18
49772: PUSH
49773: EMPTY
49774: ST_TO_ADDR
// if mechs then
49775: LD_VAR 0 13
49779: IFFALSE 49908
// for i in defenders do
49781: LD_ADDR_VAR 0 5
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: FOR_IN
49792: IFFALSE 49906
// begin SetTag ( i , 20 ) ;
49794: LD_VAR 0 5
49798: PPUSH
49799: LD_INT 20
49801: PPUSH
49802: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
49806: LD_VAR 0 5
49810: PPUSH
49811: CALL_OW 263
49815: PUSH
49816: LD_INT 1
49818: EQUAL
49819: PUSH
49820: LD_VAR 0 5
49824: PPUSH
49825: CALL_OW 311
49829: NOT
49830: AND
49831: PUSH
49832: LD_VAR 0 13
49836: AND
49837: IFFALSE 49904
// begin un := mechs [ 1 ] ;
49839: LD_ADDR_VAR 0 11
49843: PUSH
49844: LD_VAR 0 13
49848: PUSH
49849: LD_INT 1
49851: ARRAY
49852: ST_TO_ADDR
// ComExitBuilding ( un ) ;
49853: LD_VAR 0 11
49857: PPUSH
49858: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
49862: LD_VAR 0 11
49866: PPUSH
49867: LD_VAR 0 5
49871: PPUSH
49872: CALL_OW 180
// SetTag ( un , 19 ) ;
49876: LD_VAR 0 11
49880: PPUSH
49881: LD_INT 19
49883: PPUSH
49884: CALL_OW 109
// mechs := mechs diff un ;
49888: LD_ADDR_VAR 0 13
49892: PUSH
49893: LD_VAR 0 13
49897: PUSH
49898: LD_VAR 0 11
49902: DIFF
49903: ST_TO_ADDR
// end ; end ;
49904: GO 49791
49906: POP
49907: POP
// if solds then
49908: LD_VAR 0 9
49912: IFFALSE 49971
// for i in solds do
49914: LD_ADDR_VAR 0 5
49918: PUSH
49919: LD_VAR 0 9
49923: PUSH
49924: FOR_IN
49925: IFFALSE 49969
// if not GetTag ( i ) then
49927: LD_VAR 0 5
49931: PPUSH
49932: CALL_OW 110
49936: NOT
49937: IFFALSE 49967
// begin defenders := defenders union i ;
49939: LD_ADDR_VAR 0 2
49943: PUSH
49944: LD_VAR 0 2
49948: PUSH
49949: LD_VAR 0 5
49953: UNION
49954: ST_TO_ADDR
// SetTag ( i , 18 ) ;
49955: LD_VAR 0 5
49959: PPUSH
49960: LD_INT 18
49962: PPUSH
49963: CALL_OW 109
// end ;
49967: GO 49924
49969: POP
49970: POP
// repeat wait ( 0 0$1 ) ;
49971: LD_INT 35
49973: PPUSH
49974: CALL_OW 67
// enemy := mc_scan [ base ] ;
49978: LD_ADDR_VAR 0 3
49982: PUSH
49983: LD_EXP 73
49987: PUSH
49988: LD_VAR 0 1
49992: ARRAY
49993: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
49994: LD_EXP 50
49998: PUSH
49999: LD_VAR 0 1
50003: ARRAY
50004: NOT
50005: PUSH
50006: LD_EXP 50
50010: PUSH
50011: LD_VAR 0 1
50015: ARRAY
50016: PUSH
50017: EMPTY
50018: EQUAL
50019: OR
50020: IFFALSE 50057
// begin for i in defenders do
50022: LD_ADDR_VAR 0 5
50026: PUSH
50027: LD_VAR 0 2
50031: PUSH
50032: FOR_IN
50033: IFFALSE 50046
// ComStop ( i ) ;
50035: LD_VAR 0 5
50039: PPUSH
50040: CALL_OW 141
50044: GO 50032
50046: POP
50047: POP
// defenders := [ ] ;
50048: LD_ADDR_VAR 0 2
50052: PUSH
50053: EMPTY
50054: ST_TO_ADDR
// exit ;
50055: GO 51386
// end ; for i in defenders do
50057: LD_ADDR_VAR 0 5
50061: PUSH
50062: LD_VAR 0 2
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50886
// begin e := NearestUnitToUnit ( enemy , i ) ;
50070: LD_ADDR_VAR 0 14
50074: PUSH
50075: LD_VAR 0 3
50079: PPUSH
50080: LD_VAR 0 5
50084: PPUSH
50085: CALL_OW 74
50089: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50090: LD_ADDR_VAR 0 8
50094: PUSH
50095: LD_EXP 50
50099: PUSH
50100: LD_VAR 0 1
50104: ARRAY
50105: PPUSH
50106: LD_INT 2
50108: PUSH
50109: LD_INT 30
50111: PUSH
50112: LD_INT 0
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: PUSH
50119: LD_INT 30
50121: PUSH
50122: LD_INT 1
50124: PUSH
50125: EMPTY
50126: LIST
50127: LIST
50128: PUSH
50129: EMPTY
50130: LIST
50131: LIST
50132: LIST
50133: PPUSH
50134: CALL_OW 72
50138: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
50139: LD_ADDR_VAR 0 17
50143: PUSH
50144: LD_VAR 0 8
50148: NOT
50149: PUSH
50150: LD_VAR 0 8
50154: PPUSH
50155: LD_INT 3
50157: PUSH
50158: LD_INT 24
50160: PUSH
50161: LD_INT 600
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PPUSH
50172: CALL_OW 72
50176: OR
50177: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
50178: LD_VAR 0 5
50182: PPUSH
50183: CALL_OW 247
50187: PUSH
50188: LD_INT 2
50190: DOUBLE
50191: EQUAL
50192: IFTRUE 50196
50194: GO 50592
50196: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
50197: LD_VAR 0 5
50201: PPUSH
50202: CALL_OW 256
50206: PUSH
50207: LD_INT 650
50209: GREATER
50210: PUSH
50211: LD_VAR 0 5
50215: PPUSH
50216: LD_VAR 0 14
50220: PPUSH
50221: CALL_OW 296
50225: PUSH
50226: LD_INT 40
50228: LESS
50229: PUSH
50230: LD_VAR 0 14
50234: PPUSH
50235: LD_EXP 75
50239: PUSH
50240: LD_VAR 0 1
50244: ARRAY
50245: PPUSH
50246: CALL_OW 308
50250: OR
50251: AND
50252: IFFALSE 50374
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
50254: LD_VAR 0 5
50258: PPUSH
50259: CALL_OW 262
50263: PUSH
50264: LD_INT 1
50266: EQUAL
50267: PUSH
50268: LD_VAR 0 5
50272: PPUSH
50273: CALL_OW 261
50277: PUSH
50278: LD_INT 30
50280: LESS
50281: AND
50282: PUSH
50283: LD_VAR 0 8
50287: AND
50288: IFFALSE 50358
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
50290: LD_VAR 0 5
50294: PPUSH
50295: LD_VAR 0 8
50299: PPUSH
50300: LD_VAR 0 5
50304: PPUSH
50305: CALL_OW 74
50309: PPUSH
50310: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
50314: LD_VAR 0 5
50318: PPUSH
50319: LD_VAR 0 8
50323: PPUSH
50324: LD_VAR 0 5
50328: PPUSH
50329: CALL_OW 74
50333: PPUSH
50334: CALL_OW 296
50338: PUSH
50339: LD_INT 6
50341: LESS
50342: IFFALSE 50356
// SetFuel ( i , 100 ) ;
50344: LD_VAR 0 5
50348: PPUSH
50349: LD_INT 100
50351: PPUSH
50352: CALL_OW 240
// end else
50356: GO 50372
// ComAttackUnit ( i , e ) ;
50358: LD_VAR 0 5
50362: PPUSH
50363: LD_VAR 0 14
50367: PPUSH
50368: CALL_OW 115
// end else
50372: GO 50475
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
50374: LD_VAR 0 14
50378: PPUSH
50379: LD_EXP 75
50383: PUSH
50384: LD_VAR 0 1
50388: ARRAY
50389: PPUSH
50390: CALL_OW 308
50394: NOT
50395: PUSH
50396: LD_VAR 0 5
50400: PPUSH
50401: LD_VAR 0 14
50405: PPUSH
50406: CALL_OW 296
50410: PUSH
50411: LD_INT 40
50413: GREATEREQUAL
50414: AND
50415: PUSH
50416: LD_VAR 0 5
50420: PPUSH
50421: CALL_OW 256
50425: PUSH
50426: LD_INT 650
50428: LESSEQUAL
50429: OR
50430: PUSH
50431: LD_VAR 0 5
50435: PPUSH
50436: LD_EXP 74
50440: PUSH
50441: LD_VAR 0 1
50445: ARRAY
50446: PPUSH
50447: CALL_OW 308
50451: NOT
50452: AND
50453: IFFALSE 50475
// ComMoveToArea ( i , mc_parking [ base ] ) ;
50455: LD_VAR 0 5
50459: PPUSH
50460: LD_EXP 74
50464: PUSH
50465: LD_VAR 0 1
50469: ARRAY
50470: PPUSH
50471: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
50475: LD_VAR 0 5
50479: PPUSH
50480: CALL_OW 256
50484: PUSH
50485: LD_INT 998
50487: LESS
50488: PUSH
50489: LD_VAR 0 5
50493: PPUSH
50494: CALL_OW 263
50498: PUSH
50499: LD_INT 1
50501: EQUAL
50502: AND
50503: PUSH
50504: LD_VAR 0 5
50508: PPUSH
50509: CALL_OW 311
50513: AND
50514: PUSH
50515: LD_VAR 0 5
50519: PPUSH
50520: LD_EXP 74
50524: PUSH
50525: LD_VAR 0 1
50529: ARRAY
50530: PPUSH
50531: CALL_OW 308
50535: AND
50536: IFFALSE 50590
// begin mech := IsDrivenBy ( i ) ;
50538: LD_ADDR_VAR 0 10
50542: PUSH
50543: LD_VAR 0 5
50547: PPUSH
50548: CALL_OW 311
50552: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
50553: LD_VAR 0 10
50557: PPUSH
50558: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
50562: LD_VAR 0 10
50566: PPUSH
50567: LD_VAR 0 5
50571: PPUSH
50572: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
50576: LD_VAR 0 10
50580: PPUSH
50581: LD_VAR 0 5
50585: PPUSH
50586: CALL_OW 180
// end ; end ; unit_human :
50590: GO 50857
50592: LD_INT 1
50594: DOUBLE
50595: EQUAL
50596: IFTRUE 50600
50598: GO 50856
50600: POP
// begin b := IsInUnit ( i ) ;
50601: LD_ADDR_VAR 0 19
50605: PUSH
50606: LD_VAR 0 5
50610: PPUSH
50611: CALL_OW 310
50615: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
50616: LD_ADDR_VAR 0 20
50620: PUSH
50621: LD_VAR 0 19
50625: NOT
50626: PUSH
50627: LD_VAR 0 19
50631: PPUSH
50632: CALL_OW 266
50636: PUSH
50637: LD_INT 32
50639: PUSH
50640: LD_INT 31
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: IN
50647: OR
50648: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
50649: LD_VAR 0 17
50653: PUSH
50654: LD_VAR 0 2
50658: PPUSH
50659: LD_INT 21
50661: PUSH
50662: LD_INT 2
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PPUSH
50669: CALL_OW 72
50673: PUSH
50674: LD_INT 1
50676: LESSEQUAL
50677: OR
50678: PUSH
50679: LD_VAR 0 20
50683: AND
50684: PUSH
50685: LD_VAR 0 5
50689: PUSH
50690: LD_VAR 0 18
50694: IN
50695: NOT
50696: AND
50697: IFFALSE 50790
// begin if b then
50699: LD_VAR 0 19
50703: IFFALSE 50752
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
50705: LD_VAR 0 19
50709: PPUSH
50710: LD_VAR 0 3
50714: PPUSH
50715: LD_VAR 0 19
50719: PPUSH
50720: CALL_OW 74
50724: PPUSH
50725: CALL_OW 296
50729: PUSH
50730: LD_INT 10
50732: LESS
50733: PUSH
50734: LD_VAR 0 19
50738: PPUSH
50739: CALL_OW 461
50743: PUSH
50744: LD_INT 7
50746: NONEQUAL
50747: AND
50748: IFFALSE 50752
// continue ;
50750: GO 50067
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
50752: LD_ADDR_VAR 0 18
50756: PUSH
50757: LD_VAR 0 18
50761: PPUSH
50762: LD_VAR 0 18
50766: PUSH
50767: LD_INT 1
50769: PLUS
50770: PPUSH
50771: LD_VAR 0 5
50775: PPUSH
50776: CALL_OW 1
50780: ST_TO_ADDR
// ComExitBuilding ( i ) ;
50781: LD_VAR 0 5
50785: PPUSH
50786: CALL_OW 122
// end ; if sold_defenders then
50790: LD_VAR 0 18
50794: IFFALSE 50854
// if i in sold_defenders then
50796: LD_VAR 0 5
50800: PUSH
50801: LD_VAR 0 18
50805: IN
50806: IFFALSE 50854
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
50808: LD_VAR 0 5
50812: PPUSH
50813: CALL_OW 314
50817: NOT
50818: PUSH
50819: LD_VAR 0 5
50823: PPUSH
50824: LD_VAR 0 14
50828: PPUSH
50829: CALL_OW 296
50833: PUSH
50834: LD_INT 30
50836: LESS
50837: AND
50838: IFFALSE 50854
// ComAttackUnit ( i , e ) ;
50840: LD_VAR 0 5
50844: PPUSH
50845: LD_VAR 0 14
50849: PPUSH
50850: CALL_OW 115
// end ; end ; end ;
50854: GO 50857
50856: POP
// if IsDead ( i ) then
50857: LD_VAR 0 5
50861: PPUSH
50862: CALL_OW 301
50866: IFFALSE 50884
// defenders := defenders diff i ;
50868: LD_ADDR_VAR 0 2
50872: PUSH
50873: LD_VAR 0 2
50877: PUSH
50878: LD_VAR 0 5
50882: DIFF
50883: ST_TO_ADDR
// end ;
50884: GO 50067
50886: POP
50887: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
50888: LD_VAR 0 3
50892: NOT
50893: PUSH
50894: LD_VAR 0 2
50898: NOT
50899: OR
50900: PUSH
50901: LD_EXP 50
50905: PUSH
50906: LD_VAR 0 1
50910: ARRAY
50911: NOT
50912: OR
50913: IFFALSE 49971
// MC_Reset ( base , 18 ) ;
50915: LD_VAR 0 1
50919: PPUSH
50920: LD_INT 18
50922: PPUSH
50923: CALL 21253 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50927: LD_ADDR_VAR 0 2
50931: PUSH
50932: LD_VAR 0 2
50936: PUSH
50937: LD_VAR 0 2
50941: PPUSH
50942: LD_INT 2
50944: PUSH
50945: LD_INT 25
50947: PUSH
50948: LD_INT 1
50950: PUSH
50951: EMPTY
50952: LIST
50953: LIST
50954: PUSH
50955: LD_INT 25
50957: PUSH
50958: LD_INT 5
50960: PUSH
50961: EMPTY
50962: LIST
50963: LIST
50964: PUSH
50965: LD_INT 25
50967: PUSH
50968: LD_INT 8
50970: PUSH
50971: EMPTY
50972: LIST
50973: LIST
50974: PUSH
50975: LD_INT 25
50977: PUSH
50978: LD_INT 9
50980: PUSH
50981: EMPTY
50982: LIST
50983: LIST
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: PPUSH
50992: CALL_OW 72
50996: DIFF
50997: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
50998: LD_VAR 0 3
51002: NOT
51003: PUSH
51004: LD_VAR 0 2
51008: PPUSH
51009: LD_INT 21
51011: PUSH
51012: LD_INT 2
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PPUSH
51019: CALL_OW 72
51023: AND
51024: IFFALSE 51362
// begin tmp := FilterByTag ( defenders , 19 ) ;
51026: LD_ADDR_VAR 0 12
51030: PUSH
51031: LD_VAR 0 2
51035: PPUSH
51036: LD_INT 19
51038: PPUSH
51039: CALL 87815 0 2
51043: ST_TO_ADDR
// if tmp then
51044: LD_VAR 0 12
51048: IFFALSE 51118
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
51050: LD_ADDR_VAR 0 12
51054: PUSH
51055: LD_VAR 0 12
51059: PPUSH
51060: LD_INT 25
51062: PUSH
51063: LD_INT 3
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PPUSH
51070: CALL_OW 72
51074: ST_TO_ADDR
// if tmp then
51075: LD_VAR 0 12
51079: IFFALSE 51118
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
51081: LD_ADDR_EXP 62
51085: PUSH
51086: LD_EXP 62
51090: PPUSH
51091: LD_VAR 0 1
51095: PPUSH
51096: LD_EXP 62
51100: PUSH
51101: LD_VAR 0 1
51105: ARRAY
51106: PUSH
51107: LD_VAR 0 12
51111: UNION
51112: PPUSH
51113: CALL_OW 1
51117: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
51118: LD_VAR 0 1
51122: PPUSH
51123: LD_INT 19
51125: PPUSH
51126: CALL 21253 0 2
// repeat wait ( 0 0$1 ) ;
51130: LD_INT 35
51132: PPUSH
51133: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51137: LD_EXP 50
51141: PUSH
51142: LD_VAR 0 1
51146: ARRAY
51147: NOT
51148: PUSH
51149: LD_EXP 50
51153: PUSH
51154: LD_VAR 0 1
51158: ARRAY
51159: PUSH
51160: EMPTY
51161: EQUAL
51162: OR
51163: IFFALSE 51200
// begin for i in defenders do
51165: LD_ADDR_VAR 0 5
51169: PUSH
51170: LD_VAR 0 2
51174: PUSH
51175: FOR_IN
51176: IFFALSE 51189
// ComStop ( i ) ;
51178: LD_VAR 0 5
51182: PPUSH
51183: CALL_OW 141
51187: GO 51175
51189: POP
51190: POP
// defenders := [ ] ;
51191: LD_ADDR_VAR 0 2
51195: PUSH
51196: EMPTY
51197: ST_TO_ADDR
// exit ;
51198: GO 51386
// end ; for i in defenders do
51200: LD_ADDR_VAR 0 5
51204: PUSH
51205: LD_VAR 0 2
51209: PUSH
51210: FOR_IN
51211: IFFALSE 51300
// begin if not IsInArea ( i , mc_parking [ base ] ) then
51213: LD_VAR 0 5
51217: PPUSH
51218: LD_EXP 74
51222: PUSH
51223: LD_VAR 0 1
51227: ARRAY
51228: PPUSH
51229: CALL_OW 308
51233: NOT
51234: IFFALSE 51258
// ComMoveToArea ( i , mc_parking [ base ] ) else
51236: LD_VAR 0 5
51240: PPUSH
51241: LD_EXP 74
51245: PUSH
51246: LD_VAR 0 1
51250: ARRAY
51251: PPUSH
51252: CALL_OW 113
51256: GO 51298
// if GetControl ( i ) = control_manual then
51258: LD_VAR 0 5
51262: PPUSH
51263: CALL_OW 263
51267: PUSH
51268: LD_INT 1
51270: EQUAL
51271: IFFALSE 51298
// if IsDrivenBy ( i ) then
51273: LD_VAR 0 5
51277: PPUSH
51278: CALL_OW 311
51282: IFFALSE 51298
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
51284: LD_VAR 0 5
51288: PPUSH
51289: CALL_OW 311
51293: PPUSH
51294: CALL_OW 121
// end ;
51298: GO 51210
51300: POP
51301: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
51302: LD_VAR 0 2
51306: PPUSH
51307: LD_INT 95
51309: PUSH
51310: LD_EXP 74
51314: PUSH
51315: LD_VAR 0 1
51319: ARRAY
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: PUSH
51330: LD_VAR 0 2
51334: EQUAL
51335: PUSH
51336: LD_EXP 73
51340: PUSH
51341: LD_VAR 0 1
51345: ARRAY
51346: OR
51347: PUSH
51348: LD_EXP 50
51352: PUSH
51353: LD_VAR 0 1
51357: ARRAY
51358: NOT
51359: OR
51360: IFFALSE 51130
// end ; MC_Reset ( base , 19 ) ;
51362: LD_VAR 0 1
51366: PPUSH
51367: LD_INT 19
51369: PPUSH
51370: CALL 21253 0 2
// MC_Reset ( base , 20 ) ;
51374: LD_VAR 0 1
51378: PPUSH
51379: LD_INT 20
51381: PPUSH
51382: CALL 21253 0 2
// end ;
51386: LD_VAR 0 4
51390: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
51391: LD_INT 0
51393: PPUSH
51394: PPUSH
51395: PPUSH
51396: PPUSH
// result := false ;
51397: LD_ADDR_VAR 0 2
51401: PUSH
51402: LD_INT 0
51404: ST_TO_ADDR
// side := GetSide ( unit ) ;
51405: LD_ADDR_VAR 0 3
51409: PUSH
51410: LD_VAR 0 1
51414: PPUSH
51415: CALL_OW 255
51419: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51420: LD_ADDR_VAR 0 4
51424: PUSH
51425: LD_VAR 0 1
51429: PPUSH
51430: CALL_OW 248
51434: ST_TO_ADDR
// case nat of 1 :
51435: LD_VAR 0 4
51439: PUSH
51440: LD_INT 1
51442: DOUBLE
51443: EQUAL
51444: IFTRUE 51448
51446: GO 51459
51448: POP
// tech := tech_lassight ; 2 :
51449: LD_ADDR_VAR 0 5
51453: PUSH
51454: LD_INT 12
51456: ST_TO_ADDR
51457: GO 51498
51459: LD_INT 2
51461: DOUBLE
51462: EQUAL
51463: IFTRUE 51467
51465: GO 51478
51467: POP
// tech := tech_mortar ; 3 :
51468: LD_ADDR_VAR 0 5
51472: PUSH
51473: LD_INT 41
51475: ST_TO_ADDR
51476: GO 51498
51478: LD_INT 3
51480: DOUBLE
51481: EQUAL
51482: IFTRUE 51486
51484: GO 51497
51486: POP
// tech := tech_bazooka ; end ;
51487: LD_ADDR_VAR 0 5
51491: PUSH
51492: LD_INT 44
51494: ST_TO_ADDR
51495: GO 51498
51497: POP
// if Researched ( side , tech ) then
51498: LD_VAR 0 3
51502: PPUSH
51503: LD_VAR 0 5
51507: PPUSH
51508: CALL_OW 325
51512: IFFALSE 51539
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51514: LD_ADDR_VAR 0 2
51518: PUSH
51519: LD_INT 5
51521: PUSH
51522: LD_INT 8
51524: PUSH
51525: LD_INT 9
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: LIST
51532: PUSH
51533: LD_VAR 0 4
51537: ARRAY
51538: ST_TO_ADDR
// end ;
51539: LD_VAR 0 2
51543: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51544: LD_INT 0
51546: PPUSH
51547: PPUSH
51548: PPUSH
// if not mines then
51549: LD_VAR 0 2
51553: NOT
51554: IFFALSE 51558
// exit ;
51556: GO 51702
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51558: LD_ADDR_VAR 0 5
51562: PUSH
51563: LD_INT 81
51565: PUSH
51566: LD_VAR 0 1
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: LD_INT 3
51577: PUSH
51578: LD_INT 21
51580: PUSH
51581: LD_INT 3
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: EMPTY
51589: LIST
51590: LIST
51591: PUSH
51592: EMPTY
51593: LIST
51594: LIST
51595: PPUSH
51596: CALL_OW 69
51600: ST_TO_ADDR
// for i in mines do
51601: LD_ADDR_VAR 0 4
51605: PUSH
51606: LD_VAR 0 2
51610: PUSH
51611: FOR_IN
51612: IFFALSE 51700
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51614: LD_VAR 0 4
51618: PUSH
51619: LD_INT 1
51621: ARRAY
51622: PPUSH
51623: LD_VAR 0 4
51627: PUSH
51628: LD_INT 2
51630: ARRAY
51631: PPUSH
51632: CALL_OW 458
51636: NOT
51637: IFFALSE 51641
// continue ;
51639: GO 51611
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51641: LD_VAR 0 4
51645: PUSH
51646: LD_INT 1
51648: ARRAY
51649: PPUSH
51650: LD_VAR 0 4
51654: PUSH
51655: LD_INT 2
51657: ARRAY
51658: PPUSH
51659: CALL_OW 428
51663: PUSH
51664: LD_VAR 0 5
51668: IN
51669: IFFALSE 51698
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51671: LD_VAR 0 4
51675: PUSH
51676: LD_INT 1
51678: ARRAY
51679: PPUSH
51680: LD_VAR 0 4
51684: PUSH
51685: LD_INT 2
51687: ARRAY
51688: PPUSH
51689: LD_VAR 0 1
51693: PPUSH
51694: CALL_OW 456
// end ;
51698: GO 51611
51700: POP
51701: POP
// end ;
51702: LD_VAR 0 3
51706: RET
// export function Count ( array ) ; var i ; begin
51707: LD_INT 0
51709: PPUSH
51710: PPUSH
// result := 0 ;
51711: LD_ADDR_VAR 0 2
51715: PUSH
51716: LD_INT 0
51718: ST_TO_ADDR
// for i in array do
51719: LD_ADDR_VAR 0 3
51723: PUSH
51724: LD_VAR 0 1
51728: PUSH
51729: FOR_IN
51730: IFFALSE 51754
// if i then
51732: LD_VAR 0 3
51736: IFFALSE 51752
// result := result + 1 ;
51738: LD_ADDR_VAR 0 2
51742: PUSH
51743: LD_VAR 0 2
51747: PUSH
51748: LD_INT 1
51750: PLUS
51751: ST_TO_ADDR
51752: GO 51729
51754: POP
51755: POP
// end ;
51756: LD_VAR 0 2
51760: RET
// export function IsEmpty ( building ) ; begin
51761: LD_INT 0
51763: PPUSH
// if not building then
51764: LD_VAR 0 1
51768: NOT
51769: IFFALSE 51773
// exit ;
51771: GO 51816
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51773: LD_ADDR_VAR 0 2
51777: PUSH
51778: LD_VAR 0 1
51782: PUSH
51783: LD_INT 22
51785: PUSH
51786: LD_VAR 0 1
51790: PPUSH
51791: CALL_OW 255
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: LD_INT 58
51802: PUSH
51803: EMPTY
51804: LIST
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: PPUSH
51810: CALL_OW 69
51814: IN
51815: ST_TO_ADDR
// end ;
51816: LD_VAR 0 2
51820: RET
// export function IsNotFull ( building ) ; begin
51821: LD_INT 0
51823: PPUSH
// if not building then
51824: LD_VAR 0 1
51828: NOT
51829: IFFALSE 51833
// exit ;
51831: GO 51852
// result := UnitsInside ( building ) < 6 ;
51833: LD_ADDR_VAR 0 2
51837: PUSH
51838: LD_VAR 0 1
51842: PPUSH
51843: CALL_OW 313
51847: PUSH
51848: LD_INT 6
51850: LESS
51851: ST_TO_ADDR
// end ;
51852: LD_VAR 0 2
51856: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51857: LD_INT 0
51859: PPUSH
51860: PPUSH
51861: PPUSH
51862: PPUSH
// tmp := [ ] ;
51863: LD_ADDR_VAR 0 3
51867: PUSH
51868: EMPTY
51869: ST_TO_ADDR
// list := [ ] ;
51870: LD_ADDR_VAR 0 5
51874: PUSH
51875: EMPTY
51876: ST_TO_ADDR
// for i = 16 to 25 do
51877: LD_ADDR_VAR 0 4
51881: PUSH
51882: DOUBLE
51883: LD_INT 16
51885: DEC
51886: ST_TO_ADDR
51887: LD_INT 25
51889: PUSH
51890: FOR_TO
51891: IFFALSE 51964
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51893: LD_ADDR_VAR 0 3
51897: PUSH
51898: LD_VAR 0 3
51902: PUSH
51903: LD_INT 22
51905: PUSH
51906: LD_VAR 0 1
51910: PPUSH
51911: CALL_OW 255
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 91
51922: PUSH
51923: LD_VAR 0 1
51927: PUSH
51928: LD_INT 6
51930: PUSH
51931: EMPTY
51932: LIST
51933: LIST
51934: LIST
51935: PUSH
51936: LD_INT 30
51938: PUSH
51939: LD_VAR 0 4
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: PUSH
51948: EMPTY
51949: LIST
51950: LIST
51951: LIST
51952: PUSH
51953: EMPTY
51954: LIST
51955: PPUSH
51956: CALL_OW 69
51960: ADD
51961: ST_TO_ADDR
51962: GO 51890
51964: POP
51965: POP
// for i = 1 to tmp do
51966: LD_ADDR_VAR 0 4
51970: PUSH
51971: DOUBLE
51972: LD_INT 1
51974: DEC
51975: ST_TO_ADDR
51976: LD_VAR 0 3
51980: PUSH
51981: FOR_TO
51982: IFFALSE 52070
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51984: LD_ADDR_VAR 0 5
51988: PUSH
51989: LD_VAR 0 5
51993: PUSH
51994: LD_VAR 0 3
51998: PUSH
51999: LD_VAR 0 4
52003: ARRAY
52004: PPUSH
52005: CALL_OW 266
52009: PUSH
52010: LD_VAR 0 3
52014: PUSH
52015: LD_VAR 0 4
52019: ARRAY
52020: PPUSH
52021: CALL_OW 250
52025: PUSH
52026: LD_VAR 0 3
52030: PUSH
52031: LD_VAR 0 4
52035: ARRAY
52036: PPUSH
52037: CALL_OW 251
52041: PUSH
52042: LD_VAR 0 3
52046: PUSH
52047: LD_VAR 0 4
52051: ARRAY
52052: PPUSH
52053: CALL_OW 254
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: LIST
52063: PUSH
52064: EMPTY
52065: LIST
52066: ADD
52067: ST_TO_ADDR
52068: GO 51981
52070: POP
52071: POP
// result := list ;
52072: LD_ADDR_VAR 0 2
52076: PUSH
52077: LD_VAR 0 5
52081: ST_TO_ADDR
// end ;
52082: LD_VAR 0 2
52086: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
52087: LD_INT 0
52089: PPUSH
52090: PPUSH
52091: PPUSH
52092: PPUSH
52093: PPUSH
52094: PPUSH
52095: PPUSH
// if not factory then
52096: LD_VAR 0 1
52100: NOT
52101: IFFALSE 52105
// exit ;
52103: GO 52698
// if control = control_apeman then
52105: LD_VAR 0 4
52109: PUSH
52110: LD_INT 5
52112: EQUAL
52113: IFFALSE 52222
// begin tmp := UnitsInside ( factory ) ;
52115: LD_ADDR_VAR 0 8
52119: PUSH
52120: LD_VAR 0 1
52124: PPUSH
52125: CALL_OW 313
52129: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
52130: LD_VAR 0 8
52134: PPUSH
52135: LD_INT 25
52137: PUSH
52138: LD_INT 12
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: PPUSH
52145: CALL_OW 72
52149: NOT
52150: IFFALSE 52160
// control := control_manual ;
52152: LD_ADDR_VAR 0 4
52156: PUSH
52157: LD_INT 1
52159: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
52160: LD_ADDR_VAR 0 8
52164: PUSH
52165: LD_VAR 0 1
52169: PPUSH
52170: CALL 51857 0 1
52174: ST_TO_ADDR
// if tmp then
52175: LD_VAR 0 8
52179: IFFALSE 52222
// begin for i in tmp do
52181: LD_ADDR_VAR 0 7
52185: PUSH
52186: LD_VAR 0 8
52190: PUSH
52191: FOR_IN
52192: IFFALSE 52220
// if i [ 1 ] = b_ext_radio then
52194: LD_VAR 0 7
52198: PUSH
52199: LD_INT 1
52201: ARRAY
52202: PUSH
52203: LD_INT 22
52205: EQUAL
52206: IFFALSE 52218
// begin control := control_remote ;
52208: LD_ADDR_VAR 0 4
52212: PUSH
52213: LD_INT 2
52215: ST_TO_ADDR
// break ;
52216: GO 52220
// end ;
52218: GO 52191
52220: POP
52221: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52222: LD_VAR 0 1
52226: PPUSH
52227: LD_VAR 0 2
52231: PPUSH
52232: LD_VAR 0 3
52236: PPUSH
52237: LD_VAR 0 4
52241: PPUSH
52242: LD_VAR 0 5
52246: PPUSH
52247: CALL_OW 448
52251: IFFALSE 52286
// begin result := [ chassis , engine , control , weapon ] ;
52253: LD_ADDR_VAR 0 6
52257: PUSH
52258: LD_VAR 0 2
52262: PUSH
52263: LD_VAR 0 3
52267: PUSH
52268: LD_VAR 0 4
52272: PUSH
52273: LD_VAR 0 5
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: ST_TO_ADDR
// exit ;
52284: GO 52698
// end ; _chassis := AvailableChassisList ( factory ) ;
52286: LD_ADDR_VAR 0 9
52290: PUSH
52291: LD_VAR 0 1
52295: PPUSH
52296: CALL_OW 475
52300: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
52301: LD_ADDR_VAR 0 11
52305: PUSH
52306: LD_VAR 0 1
52310: PPUSH
52311: CALL_OW 476
52315: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
52316: LD_ADDR_VAR 0 12
52320: PUSH
52321: LD_VAR 0 1
52325: PPUSH
52326: CALL_OW 477
52330: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
52331: LD_ADDR_VAR 0 10
52335: PUSH
52336: LD_VAR 0 1
52340: PPUSH
52341: CALL_OW 478
52345: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
52346: LD_VAR 0 9
52350: NOT
52351: PUSH
52352: LD_VAR 0 11
52356: NOT
52357: OR
52358: PUSH
52359: LD_VAR 0 12
52363: NOT
52364: OR
52365: PUSH
52366: LD_VAR 0 10
52370: NOT
52371: OR
52372: IFFALSE 52407
// begin result := [ chassis , engine , control , weapon ] ;
52374: LD_ADDR_VAR 0 6
52378: PUSH
52379: LD_VAR 0 2
52383: PUSH
52384: LD_VAR 0 3
52388: PUSH
52389: LD_VAR 0 4
52393: PUSH
52394: LD_VAR 0 5
52398: PUSH
52399: EMPTY
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: ST_TO_ADDR
// exit ;
52405: GO 52698
// end ; if not chassis in _chassis then
52407: LD_VAR 0 2
52411: PUSH
52412: LD_VAR 0 9
52416: IN
52417: NOT
52418: IFFALSE 52444
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
52420: LD_ADDR_VAR 0 2
52424: PUSH
52425: LD_VAR 0 9
52429: PUSH
52430: LD_INT 1
52432: PPUSH
52433: LD_VAR 0 9
52437: PPUSH
52438: CALL_OW 12
52442: ARRAY
52443: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52444: LD_VAR 0 2
52448: PPUSH
52449: LD_VAR 0 3
52453: PPUSH
52454: CALL 52703 0 2
52458: NOT
52459: IFFALSE 52518
// repeat engine := _engine [ 1 ] ;
52461: LD_ADDR_VAR 0 3
52465: PUSH
52466: LD_VAR 0 11
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52475: LD_ADDR_VAR 0 11
52479: PUSH
52480: LD_VAR 0 11
52484: PPUSH
52485: LD_INT 1
52487: PPUSH
52488: CALL_OW 3
52492: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52493: LD_VAR 0 2
52497: PPUSH
52498: LD_VAR 0 3
52502: PPUSH
52503: CALL 52703 0 2
52507: PUSH
52508: LD_VAR 0 11
52512: PUSH
52513: EMPTY
52514: EQUAL
52515: OR
52516: IFFALSE 52461
// if not control in _control then
52518: LD_VAR 0 4
52522: PUSH
52523: LD_VAR 0 12
52527: IN
52528: NOT
52529: IFFALSE 52555
// control := _control [ rand ( 1 , _control ) ] ;
52531: LD_ADDR_VAR 0 4
52535: PUSH
52536: LD_VAR 0 12
52540: PUSH
52541: LD_INT 1
52543: PPUSH
52544: LD_VAR 0 12
52548: PPUSH
52549: CALL_OW 12
52553: ARRAY
52554: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52555: LD_VAR 0 2
52559: PPUSH
52560: LD_VAR 0 5
52564: PPUSH
52565: CALL 52923 0 2
52569: NOT
52570: IFFALSE 52629
// repeat weapon := _weapon [ 1 ] ;
52572: LD_ADDR_VAR 0 5
52576: PUSH
52577: LD_VAR 0 10
52581: PUSH
52582: LD_INT 1
52584: ARRAY
52585: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52586: LD_ADDR_VAR 0 10
52590: PUSH
52591: LD_VAR 0 10
52595: PPUSH
52596: LD_INT 1
52598: PPUSH
52599: CALL_OW 3
52603: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52604: LD_VAR 0 2
52608: PPUSH
52609: LD_VAR 0 5
52613: PPUSH
52614: CALL 52923 0 2
52618: PUSH
52619: LD_VAR 0 10
52623: PUSH
52624: EMPTY
52625: EQUAL
52626: OR
52627: IFFALSE 52572
// result := [ ] ;
52629: LD_ADDR_VAR 0 6
52633: PUSH
52634: EMPTY
52635: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52636: LD_VAR 0 1
52640: PPUSH
52641: LD_VAR 0 2
52645: PPUSH
52646: LD_VAR 0 3
52650: PPUSH
52651: LD_VAR 0 4
52655: PPUSH
52656: LD_VAR 0 5
52660: PPUSH
52661: CALL_OW 448
52665: IFFALSE 52698
// result := [ chassis , engine , control , weapon ] ;
52667: LD_ADDR_VAR 0 6
52671: PUSH
52672: LD_VAR 0 2
52676: PUSH
52677: LD_VAR 0 3
52681: PUSH
52682: LD_VAR 0 4
52686: PUSH
52687: LD_VAR 0 5
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: LIST
52696: LIST
52697: ST_TO_ADDR
// end ;
52698: LD_VAR 0 6
52702: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52703: LD_INT 0
52705: PPUSH
// if not chassis or not engine then
52706: LD_VAR 0 1
52710: NOT
52711: PUSH
52712: LD_VAR 0 2
52716: NOT
52717: OR
52718: IFFALSE 52722
// exit ;
52720: GO 52918
// case engine of engine_solar :
52722: LD_VAR 0 2
52726: PUSH
52727: LD_INT 2
52729: DOUBLE
52730: EQUAL
52731: IFTRUE 52735
52733: GO 52773
52735: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52736: LD_ADDR_VAR 0 3
52740: PUSH
52741: LD_INT 11
52743: PUSH
52744: LD_INT 12
52746: PUSH
52747: LD_INT 13
52749: PUSH
52750: LD_INT 14
52752: PUSH
52753: LD_INT 1
52755: PUSH
52756: LD_INT 2
52758: PUSH
52759: LD_INT 3
52761: PUSH
52762: EMPTY
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: ST_TO_ADDR
52771: GO 52902
52773: LD_INT 1
52775: DOUBLE
52776: EQUAL
52777: IFTRUE 52781
52779: GO 52843
52781: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52782: LD_ADDR_VAR 0 3
52786: PUSH
52787: LD_INT 11
52789: PUSH
52790: LD_INT 12
52792: PUSH
52793: LD_INT 13
52795: PUSH
52796: LD_INT 14
52798: PUSH
52799: LD_INT 1
52801: PUSH
52802: LD_INT 2
52804: PUSH
52805: LD_INT 3
52807: PUSH
52808: LD_INT 4
52810: PUSH
52811: LD_INT 5
52813: PUSH
52814: LD_INT 21
52816: PUSH
52817: LD_INT 23
52819: PUSH
52820: LD_INT 22
52822: PUSH
52823: LD_INT 24
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: LIST
52830: LIST
52831: LIST
52832: LIST
52833: LIST
52834: LIST
52835: LIST
52836: LIST
52837: LIST
52838: LIST
52839: LIST
52840: ST_TO_ADDR
52841: GO 52902
52843: LD_INT 3
52845: DOUBLE
52846: EQUAL
52847: IFTRUE 52851
52849: GO 52901
52851: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52852: LD_ADDR_VAR 0 3
52856: PUSH
52857: LD_INT 13
52859: PUSH
52860: LD_INT 14
52862: PUSH
52863: LD_INT 2
52865: PUSH
52866: LD_INT 3
52868: PUSH
52869: LD_INT 4
52871: PUSH
52872: LD_INT 5
52874: PUSH
52875: LD_INT 21
52877: PUSH
52878: LD_INT 22
52880: PUSH
52881: LD_INT 23
52883: PUSH
52884: LD_INT 24
52886: PUSH
52887: EMPTY
52888: LIST
52889: LIST
52890: LIST
52891: LIST
52892: LIST
52893: LIST
52894: LIST
52895: LIST
52896: LIST
52897: LIST
52898: ST_TO_ADDR
52899: GO 52902
52901: POP
// result := ( chassis in result ) ;
52902: LD_ADDR_VAR 0 3
52906: PUSH
52907: LD_VAR 0 1
52911: PUSH
52912: LD_VAR 0 3
52916: IN
52917: ST_TO_ADDR
// end ;
52918: LD_VAR 0 3
52922: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52923: LD_INT 0
52925: PPUSH
// if not chassis or not weapon then
52926: LD_VAR 0 1
52930: NOT
52931: PUSH
52932: LD_VAR 0 2
52936: NOT
52937: OR
52938: IFFALSE 52942
// exit ;
52940: GO 53968
// case weapon of us_machine_gun :
52942: LD_VAR 0 2
52946: PUSH
52947: LD_INT 2
52949: DOUBLE
52950: EQUAL
52951: IFTRUE 52955
52953: GO 52985
52955: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52956: LD_ADDR_VAR 0 3
52960: PUSH
52961: LD_INT 1
52963: PUSH
52964: LD_INT 2
52966: PUSH
52967: LD_INT 3
52969: PUSH
52970: LD_INT 4
52972: PUSH
52973: LD_INT 5
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: LIST
52980: LIST
52981: LIST
52982: ST_TO_ADDR
52983: GO 53952
52985: LD_INT 3
52987: DOUBLE
52988: EQUAL
52989: IFTRUE 52993
52991: GO 53023
52993: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52994: LD_ADDR_VAR 0 3
52998: PUSH
52999: LD_INT 1
53001: PUSH
53002: LD_INT 2
53004: PUSH
53005: LD_INT 3
53007: PUSH
53008: LD_INT 4
53010: PUSH
53011: LD_INT 5
53013: PUSH
53014: EMPTY
53015: LIST
53016: LIST
53017: LIST
53018: LIST
53019: LIST
53020: ST_TO_ADDR
53021: GO 53952
53023: LD_INT 11
53025: DOUBLE
53026: EQUAL
53027: IFTRUE 53031
53029: GO 53061
53031: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
53032: LD_ADDR_VAR 0 3
53036: PUSH
53037: LD_INT 1
53039: PUSH
53040: LD_INT 2
53042: PUSH
53043: LD_INT 3
53045: PUSH
53046: LD_INT 4
53048: PUSH
53049: LD_INT 5
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: LIST
53056: LIST
53057: LIST
53058: ST_TO_ADDR
53059: GO 53952
53061: LD_INT 4
53063: DOUBLE
53064: EQUAL
53065: IFTRUE 53069
53067: GO 53095
53069: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
53070: LD_ADDR_VAR 0 3
53074: PUSH
53075: LD_INT 2
53077: PUSH
53078: LD_INT 3
53080: PUSH
53081: LD_INT 4
53083: PUSH
53084: LD_INT 5
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53952
53095: LD_INT 5
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53129
53103: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 2
53111: PUSH
53112: LD_INT 3
53114: PUSH
53115: LD_INT 4
53117: PUSH
53118: LD_INT 5
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: ST_TO_ADDR
53127: GO 53952
53129: LD_INT 9
53131: DOUBLE
53132: EQUAL
53133: IFTRUE 53137
53135: GO 53163
53137: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
53138: LD_ADDR_VAR 0 3
53142: PUSH
53143: LD_INT 2
53145: PUSH
53146: LD_INT 3
53148: PUSH
53149: LD_INT 4
53151: PUSH
53152: LD_INT 5
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: ST_TO_ADDR
53161: GO 53952
53163: LD_INT 7
53165: DOUBLE
53166: EQUAL
53167: IFTRUE 53171
53169: GO 53197
53171: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
53172: LD_ADDR_VAR 0 3
53176: PUSH
53177: LD_INT 2
53179: PUSH
53180: LD_INT 3
53182: PUSH
53183: LD_INT 4
53185: PUSH
53186: LD_INT 5
53188: PUSH
53189: EMPTY
53190: LIST
53191: LIST
53192: LIST
53193: LIST
53194: ST_TO_ADDR
53195: GO 53952
53197: LD_INT 12
53199: DOUBLE
53200: EQUAL
53201: IFTRUE 53205
53203: GO 53231
53205: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
53206: LD_ADDR_VAR 0 3
53210: PUSH
53211: LD_INT 2
53213: PUSH
53214: LD_INT 3
53216: PUSH
53217: LD_INT 4
53219: PUSH
53220: LD_INT 5
53222: PUSH
53223: EMPTY
53224: LIST
53225: LIST
53226: LIST
53227: LIST
53228: ST_TO_ADDR
53229: GO 53952
53231: LD_INT 13
53233: DOUBLE
53234: EQUAL
53235: IFTRUE 53239
53237: GO 53265
53239: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
53240: LD_ADDR_VAR 0 3
53244: PUSH
53245: LD_INT 2
53247: PUSH
53248: LD_INT 3
53250: PUSH
53251: LD_INT 4
53253: PUSH
53254: LD_INT 5
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: LIST
53261: LIST
53262: ST_TO_ADDR
53263: GO 53952
53265: LD_INT 14
53267: DOUBLE
53268: EQUAL
53269: IFTRUE 53273
53271: GO 53291
53273: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
53274: LD_ADDR_VAR 0 3
53278: PUSH
53279: LD_INT 4
53281: PUSH
53282: LD_INT 5
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: ST_TO_ADDR
53289: GO 53952
53291: LD_INT 6
53293: DOUBLE
53294: EQUAL
53295: IFTRUE 53299
53297: GO 53317
53299: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
53300: LD_ADDR_VAR 0 3
53304: PUSH
53305: LD_INT 4
53307: PUSH
53308: LD_INT 5
53310: PUSH
53311: EMPTY
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53952
53317: LD_INT 10
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53343
53325: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 4
53333: PUSH
53334: LD_INT 5
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: ST_TO_ADDR
53341: GO 53952
53343: LD_INT 22
53345: DOUBLE
53346: EQUAL
53347: IFTRUE 53351
53349: GO 53377
53351: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
53352: LD_ADDR_VAR 0 3
53356: PUSH
53357: LD_INT 11
53359: PUSH
53360: LD_INT 12
53362: PUSH
53363: LD_INT 13
53365: PUSH
53366: LD_INT 14
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: LIST
53373: LIST
53374: ST_TO_ADDR
53375: GO 53952
53377: LD_INT 23
53379: DOUBLE
53380: EQUAL
53381: IFTRUE 53385
53383: GO 53411
53385: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
53386: LD_ADDR_VAR 0 3
53390: PUSH
53391: LD_INT 11
53393: PUSH
53394: LD_INT 12
53396: PUSH
53397: LD_INT 13
53399: PUSH
53400: LD_INT 14
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53952
53411: LD_INT 24
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53445
53419: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 11
53427: PUSH
53428: LD_INT 12
53430: PUSH
53431: LD_INT 13
53433: PUSH
53434: LD_INT 14
53436: PUSH
53437: EMPTY
53438: LIST
53439: LIST
53440: LIST
53441: LIST
53442: ST_TO_ADDR
53443: GO 53952
53445: LD_INT 30
53447: DOUBLE
53448: EQUAL
53449: IFTRUE 53453
53451: GO 53479
53453: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53454: LD_ADDR_VAR 0 3
53458: PUSH
53459: LD_INT 11
53461: PUSH
53462: LD_INT 12
53464: PUSH
53465: LD_INT 13
53467: PUSH
53468: LD_INT 14
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: LIST
53475: LIST
53476: ST_TO_ADDR
53477: GO 53952
53479: LD_INT 25
53481: DOUBLE
53482: EQUAL
53483: IFTRUE 53487
53485: GO 53505
53487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 13
53495: PUSH
53496: LD_INT 14
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: ST_TO_ADDR
53503: GO 53952
53505: LD_INT 27
53507: DOUBLE
53508: EQUAL
53509: IFTRUE 53513
53511: GO 53531
53513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53514: LD_ADDR_VAR 0 3
53518: PUSH
53519: LD_INT 13
53521: PUSH
53522: LD_INT 14
53524: PUSH
53525: EMPTY
53526: LIST
53527: LIST
53528: ST_TO_ADDR
53529: GO 53952
53531: LD_INT 28
53533: DOUBLE
53534: EQUAL
53535: IFTRUE 53539
53537: GO 53557
53539: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53540: LD_ADDR_VAR 0 3
53544: PUSH
53545: LD_INT 13
53547: PUSH
53548: LD_INT 14
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: ST_TO_ADDR
53555: GO 53952
53557: LD_INT 29
53559: DOUBLE
53560: EQUAL
53561: IFTRUE 53565
53563: GO 53583
53565: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53566: LD_ADDR_VAR 0 3
53570: PUSH
53571: LD_INT 13
53573: PUSH
53574: LD_INT 14
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: ST_TO_ADDR
53581: GO 53952
53583: LD_INT 31
53585: DOUBLE
53586: EQUAL
53587: IFTRUE 53591
53589: GO 53609
53591: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53592: LD_ADDR_VAR 0 3
53596: PUSH
53597: LD_INT 13
53599: PUSH
53600: LD_INT 14
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: ST_TO_ADDR
53607: GO 53952
53609: LD_INT 26
53611: DOUBLE
53612: EQUAL
53613: IFTRUE 53617
53615: GO 53635
53617: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53618: LD_ADDR_VAR 0 3
53622: PUSH
53623: LD_INT 13
53625: PUSH
53626: LD_INT 14
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: ST_TO_ADDR
53633: GO 53952
53635: LD_INT 42
53637: DOUBLE
53638: EQUAL
53639: IFTRUE 53643
53641: GO 53669
53643: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53644: LD_ADDR_VAR 0 3
53648: PUSH
53649: LD_INT 21
53651: PUSH
53652: LD_INT 22
53654: PUSH
53655: LD_INT 23
53657: PUSH
53658: LD_INT 24
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: LIST
53665: LIST
53666: ST_TO_ADDR
53667: GO 53952
53669: LD_INT 43
53671: DOUBLE
53672: EQUAL
53673: IFTRUE 53677
53675: GO 53703
53677: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53678: LD_ADDR_VAR 0 3
53682: PUSH
53683: LD_INT 21
53685: PUSH
53686: LD_INT 22
53688: PUSH
53689: LD_INT 23
53691: PUSH
53692: LD_INT 24
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: LIST
53699: LIST
53700: ST_TO_ADDR
53701: GO 53952
53703: LD_INT 44
53705: DOUBLE
53706: EQUAL
53707: IFTRUE 53711
53709: GO 53737
53711: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53712: LD_ADDR_VAR 0 3
53716: PUSH
53717: LD_INT 21
53719: PUSH
53720: LD_INT 22
53722: PUSH
53723: LD_INT 23
53725: PUSH
53726: LD_INT 24
53728: PUSH
53729: EMPTY
53730: LIST
53731: LIST
53732: LIST
53733: LIST
53734: ST_TO_ADDR
53735: GO 53952
53737: LD_INT 45
53739: DOUBLE
53740: EQUAL
53741: IFTRUE 53745
53743: GO 53771
53745: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53746: LD_ADDR_VAR 0 3
53750: PUSH
53751: LD_INT 21
53753: PUSH
53754: LD_INT 22
53756: PUSH
53757: LD_INT 23
53759: PUSH
53760: LD_INT 24
53762: PUSH
53763: EMPTY
53764: LIST
53765: LIST
53766: LIST
53767: LIST
53768: ST_TO_ADDR
53769: GO 53952
53771: LD_INT 49
53773: DOUBLE
53774: EQUAL
53775: IFTRUE 53779
53777: GO 53805
53779: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_INT 21
53787: PUSH
53788: LD_INT 22
53790: PUSH
53791: LD_INT 23
53793: PUSH
53794: LD_INT 24
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: LIST
53801: LIST
53802: ST_TO_ADDR
53803: GO 53952
53805: LD_INT 51
53807: DOUBLE
53808: EQUAL
53809: IFTRUE 53813
53811: GO 53839
53813: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53814: LD_ADDR_VAR 0 3
53818: PUSH
53819: LD_INT 21
53821: PUSH
53822: LD_INT 22
53824: PUSH
53825: LD_INT 23
53827: PUSH
53828: LD_INT 24
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: LIST
53835: LIST
53836: ST_TO_ADDR
53837: GO 53952
53839: LD_INT 52
53841: DOUBLE
53842: EQUAL
53843: IFTRUE 53847
53845: GO 53873
53847: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53848: LD_ADDR_VAR 0 3
53852: PUSH
53853: LD_INT 21
53855: PUSH
53856: LD_INT 22
53858: PUSH
53859: LD_INT 23
53861: PUSH
53862: LD_INT 24
53864: PUSH
53865: EMPTY
53866: LIST
53867: LIST
53868: LIST
53869: LIST
53870: ST_TO_ADDR
53871: GO 53952
53873: LD_INT 53
53875: DOUBLE
53876: EQUAL
53877: IFTRUE 53881
53879: GO 53899
53881: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53882: LD_ADDR_VAR 0 3
53886: PUSH
53887: LD_INT 23
53889: PUSH
53890: LD_INT 24
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: ST_TO_ADDR
53897: GO 53952
53899: LD_INT 46
53901: DOUBLE
53902: EQUAL
53903: IFTRUE 53907
53905: GO 53925
53907: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53908: LD_ADDR_VAR 0 3
53912: PUSH
53913: LD_INT 23
53915: PUSH
53916: LD_INT 24
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: ST_TO_ADDR
53923: GO 53952
53925: LD_INT 47
53927: DOUBLE
53928: EQUAL
53929: IFTRUE 53933
53931: GO 53951
53933: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53934: LD_ADDR_VAR 0 3
53938: PUSH
53939: LD_INT 23
53941: PUSH
53942: LD_INT 24
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: ST_TO_ADDR
53949: GO 53952
53951: POP
// result := ( chassis in result ) ;
53952: LD_ADDR_VAR 0 3
53956: PUSH
53957: LD_VAR 0 1
53961: PUSH
53962: LD_VAR 0 3
53966: IN
53967: ST_TO_ADDR
// end ;
53968: LD_VAR 0 3
53972: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53973: LD_INT 0
53975: PPUSH
53976: PPUSH
53977: PPUSH
53978: PPUSH
53979: PPUSH
53980: PPUSH
53981: PPUSH
// result := array ;
53982: LD_ADDR_VAR 0 5
53986: PUSH
53987: LD_VAR 0 1
53991: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53992: LD_VAR 0 1
53996: NOT
53997: PUSH
53998: LD_VAR 0 2
54002: NOT
54003: OR
54004: PUSH
54005: LD_VAR 0 3
54009: NOT
54010: OR
54011: PUSH
54012: LD_VAR 0 2
54016: PUSH
54017: LD_VAR 0 1
54021: GREATER
54022: OR
54023: PUSH
54024: LD_VAR 0 3
54028: PUSH
54029: LD_VAR 0 1
54033: GREATER
54034: OR
54035: IFFALSE 54039
// exit ;
54037: GO 54335
// if direction then
54039: LD_VAR 0 4
54043: IFFALSE 54107
// begin d := 1 ;
54045: LD_ADDR_VAR 0 9
54049: PUSH
54050: LD_INT 1
54052: ST_TO_ADDR
// if i_from > i_to then
54053: LD_VAR 0 2
54057: PUSH
54058: LD_VAR 0 3
54062: GREATER
54063: IFFALSE 54089
// length := ( array - i_from ) + i_to else
54065: LD_ADDR_VAR 0 11
54069: PUSH
54070: LD_VAR 0 1
54074: PUSH
54075: LD_VAR 0 2
54079: MINUS
54080: PUSH
54081: LD_VAR 0 3
54085: PLUS
54086: ST_TO_ADDR
54087: GO 54105
// length := i_to - i_from ;
54089: LD_ADDR_VAR 0 11
54093: PUSH
54094: LD_VAR 0 3
54098: PUSH
54099: LD_VAR 0 2
54103: MINUS
54104: ST_TO_ADDR
// end else
54105: GO 54168
// begin d := - 1 ;
54107: LD_ADDR_VAR 0 9
54111: PUSH
54112: LD_INT 1
54114: NEG
54115: ST_TO_ADDR
// if i_from > i_to then
54116: LD_VAR 0 2
54120: PUSH
54121: LD_VAR 0 3
54125: GREATER
54126: IFFALSE 54146
// length := i_from - i_to else
54128: LD_ADDR_VAR 0 11
54132: PUSH
54133: LD_VAR 0 2
54137: PUSH
54138: LD_VAR 0 3
54142: MINUS
54143: ST_TO_ADDR
54144: GO 54168
// length := ( array - i_to ) + i_from ;
54146: LD_ADDR_VAR 0 11
54150: PUSH
54151: LD_VAR 0 1
54155: PUSH
54156: LD_VAR 0 3
54160: MINUS
54161: PUSH
54162: LD_VAR 0 2
54166: PLUS
54167: ST_TO_ADDR
// end ; if not length then
54168: LD_VAR 0 11
54172: NOT
54173: IFFALSE 54177
// exit ;
54175: GO 54335
// tmp := array ;
54177: LD_ADDR_VAR 0 10
54181: PUSH
54182: LD_VAR 0 1
54186: ST_TO_ADDR
// for i = 1 to length do
54187: LD_ADDR_VAR 0 6
54191: PUSH
54192: DOUBLE
54193: LD_INT 1
54195: DEC
54196: ST_TO_ADDR
54197: LD_VAR 0 11
54201: PUSH
54202: FOR_TO
54203: IFFALSE 54323
// begin for j = 1 to array do
54205: LD_ADDR_VAR 0 7
54209: PUSH
54210: DOUBLE
54211: LD_INT 1
54213: DEC
54214: ST_TO_ADDR
54215: LD_VAR 0 1
54219: PUSH
54220: FOR_TO
54221: IFFALSE 54309
// begin k := j + d ;
54223: LD_ADDR_VAR 0 8
54227: PUSH
54228: LD_VAR 0 7
54232: PUSH
54233: LD_VAR 0 9
54237: PLUS
54238: ST_TO_ADDR
// if k > array then
54239: LD_VAR 0 8
54243: PUSH
54244: LD_VAR 0 1
54248: GREATER
54249: IFFALSE 54259
// k := 1 ;
54251: LD_ADDR_VAR 0 8
54255: PUSH
54256: LD_INT 1
54258: ST_TO_ADDR
// if not k then
54259: LD_VAR 0 8
54263: NOT
54264: IFFALSE 54276
// k := array ;
54266: LD_ADDR_VAR 0 8
54270: PUSH
54271: LD_VAR 0 1
54275: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
54276: LD_ADDR_VAR 0 10
54280: PUSH
54281: LD_VAR 0 10
54285: PPUSH
54286: LD_VAR 0 8
54290: PPUSH
54291: LD_VAR 0 1
54295: PUSH
54296: LD_VAR 0 7
54300: ARRAY
54301: PPUSH
54302: CALL_OW 1
54306: ST_TO_ADDR
// end ;
54307: GO 54220
54309: POP
54310: POP
// array := tmp ;
54311: LD_ADDR_VAR 0 1
54315: PUSH
54316: LD_VAR 0 10
54320: ST_TO_ADDR
// end ;
54321: GO 54202
54323: POP
54324: POP
// result := array ;
54325: LD_ADDR_VAR 0 5
54329: PUSH
54330: LD_VAR 0 1
54334: ST_TO_ADDR
// end ;
54335: LD_VAR 0 5
54339: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
54340: LD_INT 0
54342: PPUSH
54343: PPUSH
// result := 0 ;
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_INT 0
54351: ST_TO_ADDR
// if not array or not value in array then
54352: LD_VAR 0 1
54356: NOT
54357: PUSH
54358: LD_VAR 0 2
54362: PUSH
54363: LD_VAR 0 1
54367: IN
54368: NOT
54369: OR
54370: IFFALSE 54374
// exit ;
54372: GO 54428
// for i = 1 to array do
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: DOUBLE
54380: LD_INT 1
54382: DEC
54383: ST_TO_ADDR
54384: LD_VAR 0 1
54388: PUSH
54389: FOR_TO
54390: IFFALSE 54426
// if value = array [ i ] then
54392: LD_VAR 0 2
54396: PUSH
54397: LD_VAR 0 1
54401: PUSH
54402: LD_VAR 0 4
54406: ARRAY
54407: EQUAL
54408: IFFALSE 54424
// begin result := i ;
54410: LD_ADDR_VAR 0 3
54414: PUSH
54415: LD_VAR 0 4
54419: ST_TO_ADDR
// exit ;
54420: POP
54421: POP
54422: GO 54428
// end ;
54424: GO 54389
54426: POP
54427: POP
// end ;
54428: LD_VAR 0 3
54432: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54433: LD_INT 0
54435: PPUSH
// vc_chassis := chassis ;
54436: LD_ADDR_OWVAR 37
54440: PUSH
54441: LD_VAR 0 1
54445: ST_TO_ADDR
// vc_engine := engine ;
54446: LD_ADDR_OWVAR 39
54450: PUSH
54451: LD_VAR 0 2
54455: ST_TO_ADDR
// vc_control := control ;
54456: LD_ADDR_OWVAR 38
54460: PUSH
54461: LD_VAR 0 3
54465: ST_TO_ADDR
// vc_weapon := weapon ;
54466: LD_ADDR_OWVAR 40
54470: PUSH
54471: LD_VAR 0 4
54475: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54476: LD_ADDR_OWVAR 41
54480: PUSH
54481: LD_VAR 0 5
54485: ST_TO_ADDR
// end ;
54486: LD_VAR 0 6
54490: RET
// export function WantPlant ( unit ) ; var task ; begin
54491: LD_INT 0
54493: PPUSH
54494: PPUSH
// result := false ;
54495: LD_ADDR_VAR 0 2
54499: PUSH
54500: LD_INT 0
54502: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54503: LD_ADDR_VAR 0 3
54507: PUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: CALL_OW 437
54517: ST_TO_ADDR
// if task then
54518: LD_VAR 0 3
54522: IFFALSE 54550
// if task [ 1 ] [ 1 ] = p then
54524: LD_VAR 0 3
54528: PUSH
54529: LD_INT 1
54531: ARRAY
54532: PUSH
54533: LD_INT 1
54535: ARRAY
54536: PUSH
54537: LD_STRING p
54539: EQUAL
54540: IFFALSE 54550
// result := true ;
54542: LD_ADDR_VAR 0 2
54546: PUSH
54547: LD_INT 1
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 2
54554: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if pos < 1 then
54561: LD_VAR 0 2
54565: PUSH
54566: LD_INT 1
54568: LESS
54569: IFFALSE 54573
// exit ;
54571: GO 54876
// if pos = 1 then
54573: LD_VAR 0 2
54577: PUSH
54578: LD_INT 1
54580: EQUAL
54581: IFFALSE 54614
// result := Replace ( arr , pos [ 1 ] , value ) else
54583: LD_ADDR_VAR 0 4
54587: PUSH
54588: LD_VAR 0 1
54592: PPUSH
54593: LD_VAR 0 2
54597: PUSH
54598: LD_INT 1
54600: ARRAY
54601: PPUSH
54602: LD_VAR 0 3
54606: PPUSH
54607: CALL_OW 1
54611: ST_TO_ADDR
54612: GO 54876
// begin tmp := arr ;
54614: LD_ADDR_VAR 0 6
54618: PUSH
54619: LD_VAR 0 1
54623: ST_TO_ADDR
// s_arr := [ tmp ] ;
54624: LD_ADDR_VAR 0 7
54628: PUSH
54629: LD_VAR 0 6
54633: PUSH
54634: EMPTY
54635: LIST
54636: ST_TO_ADDR
// for i = 1 to pos - 1 do
54637: LD_ADDR_VAR 0 5
54641: PUSH
54642: DOUBLE
54643: LD_INT 1
54645: DEC
54646: ST_TO_ADDR
54647: LD_VAR 0 2
54651: PUSH
54652: LD_INT 1
54654: MINUS
54655: PUSH
54656: FOR_TO
54657: IFFALSE 54702
// begin tmp := tmp [ pos [ i ] ] ;
54659: LD_ADDR_VAR 0 6
54663: PUSH
54664: LD_VAR 0 6
54668: PUSH
54669: LD_VAR 0 2
54673: PUSH
54674: LD_VAR 0 5
54678: ARRAY
54679: ARRAY
54680: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54681: LD_ADDR_VAR 0 7
54685: PUSH
54686: LD_VAR 0 7
54690: PUSH
54691: LD_VAR 0 6
54695: PUSH
54696: EMPTY
54697: LIST
54698: ADD
54699: ST_TO_ADDR
// end ;
54700: GO 54656
54702: POP
54703: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54704: LD_ADDR_VAR 0 6
54708: PUSH
54709: LD_VAR 0 6
54713: PPUSH
54714: LD_VAR 0 2
54718: PUSH
54719: LD_VAR 0 2
54723: ARRAY
54724: PPUSH
54725: LD_VAR 0 3
54729: PPUSH
54730: CALL_OW 1
54734: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54735: LD_ADDR_VAR 0 7
54739: PUSH
54740: LD_VAR 0 7
54744: PPUSH
54745: LD_VAR 0 7
54749: PPUSH
54750: LD_VAR 0 6
54754: PPUSH
54755: CALL_OW 1
54759: ST_TO_ADDR
// for i = s_arr downto 2 do
54760: LD_ADDR_VAR 0 5
54764: PUSH
54765: DOUBLE
54766: LD_VAR 0 7
54770: INC
54771: ST_TO_ADDR
54772: LD_INT 2
54774: PUSH
54775: FOR_DOWNTO
54776: IFFALSE 54860
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54778: LD_ADDR_VAR 0 6
54782: PUSH
54783: LD_VAR 0 7
54787: PUSH
54788: LD_VAR 0 5
54792: PUSH
54793: LD_INT 1
54795: MINUS
54796: ARRAY
54797: PPUSH
54798: LD_VAR 0 2
54802: PUSH
54803: LD_VAR 0 5
54807: PUSH
54808: LD_INT 1
54810: MINUS
54811: ARRAY
54812: PPUSH
54813: LD_VAR 0 7
54817: PUSH
54818: LD_VAR 0 5
54822: ARRAY
54823: PPUSH
54824: CALL_OW 1
54828: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54829: LD_ADDR_VAR 0 7
54833: PUSH
54834: LD_VAR 0 7
54838: PPUSH
54839: LD_VAR 0 5
54843: PUSH
54844: LD_INT 1
54846: MINUS
54847: PPUSH
54848: LD_VAR 0 6
54852: PPUSH
54853: CALL_OW 1
54857: ST_TO_ADDR
// end ;
54858: GO 54775
54860: POP
54861: POP
// result := s_arr [ 1 ] ;
54862: LD_ADDR_VAR 0 4
54866: PUSH
54867: LD_VAR 0 7
54871: PUSH
54872: LD_INT 1
54874: ARRAY
54875: ST_TO_ADDR
// end ; end ;
54876: LD_VAR 0 4
54880: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54881: LD_INT 0
54883: PPUSH
54884: PPUSH
// if not list then
54885: LD_VAR 0 1
54889: NOT
54890: IFFALSE 54894
// exit ;
54892: GO 54985
// i := list [ pos1 ] ;
54894: LD_ADDR_VAR 0 5
54898: PUSH
54899: LD_VAR 0 1
54903: PUSH
54904: LD_VAR 0 2
54908: ARRAY
54909: ST_TO_ADDR
// if not i then
54910: LD_VAR 0 5
54914: NOT
54915: IFFALSE 54919
// exit ;
54917: GO 54985
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54919: LD_ADDR_VAR 0 1
54923: PUSH
54924: LD_VAR 0 1
54928: PPUSH
54929: LD_VAR 0 2
54933: PPUSH
54934: LD_VAR 0 1
54938: PUSH
54939: LD_VAR 0 3
54943: ARRAY
54944: PPUSH
54945: CALL_OW 1
54949: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54950: LD_ADDR_VAR 0 1
54954: PUSH
54955: LD_VAR 0 1
54959: PPUSH
54960: LD_VAR 0 3
54964: PPUSH
54965: LD_VAR 0 5
54969: PPUSH
54970: CALL_OW 1
54974: ST_TO_ADDR
// result := list ;
54975: LD_ADDR_VAR 0 4
54979: PUSH
54980: LD_VAR 0 1
54984: ST_TO_ADDR
// end ;
54985: LD_VAR 0 4
54989: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54990: LD_INT 0
54992: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54993: LD_ADDR_VAR 0 5
54997: PUSH
54998: LD_VAR 0 1
55002: PPUSH
55003: CALL_OW 250
55007: PPUSH
55008: LD_VAR 0 1
55012: PPUSH
55013: CALL_OW 251
55017: PPUSH
55018: LD_VAR 0 2
55022: PPUSH
55023: LD_VAR 0 3
55027: PPUSH
55028: LD_VAR 0 4
55032: PPUSH
55033: CALL 55043 0 5
55037: ST_TO_ADDR
// end ;
55038: LD_VAR 0 5
55042: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55043: LD_INT 0
55045: PPUSH
55046: PPUSH
55047: PPUSH
55048: PPUSH
// if not list then
55049: LD_VAR 0 3
55053: NOT
55054: IFFALSE 55058
// exit ;
55056: GO 55446
// result := [ ] ;
55058: LD_ADDR_VAR 0 6
55062: PUSH
55063: EMPTY
55064: ST_TO_ADDR
// for i in list do
55065: LD_ADDR_VAR 0 7
55069: PUSH
55070: LD_VAR 0 3
55074: PUSH
55075: FOR_IN
55076: IFFALSE 55278
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55078: LD_ADDR_VAR 0 9
55082: PUSH
55083: LD_VAR 0 7
55087: PPUSH
55088: LD_VAR 0 1
55092: PPUSH
55093: LD_VAR 0 2
55097: PPUSH
55098: CALL_OW 297
55102: ST_TO_ADDR
// if not result then
55103: LD_VAR 0 6
55107: NOT
55108: IFFALSE 55134
// result := [ [ i , tmp ] ] else
55110: LD_ADDR_VAR 0 6
55114: PUSH
55115: LD_VAR 0 7
55119: PUSH
55120: LD_VAR 0 9
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: PUSH
55129: EMPTY
55130: LIST
55131: ST_TO_ADDR
55132: GO 55276
// begin if result [ result ] [ 2 ] < tmp then
55134: LD_VAR 0 6
55138: PUSH
55139: LD_VAR 0 6
55143: ARRAY
55144: PUSH
55145: LD_INT 2
55147: ARRAY
55148: PUSH
55149: LD_VAR 0 9
55153: LESS
55154: IFFALSE 55196
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55156: LD_ADDR_VAR 0 6
55160: PUSH
55161: LD_VAR 0 6
55165: PPUSH
55166: LD_VAR 0 6
55170: PUSH
55171: LD_INT 1
55173: PLUS
55174: PPUSH
55175: LD_VAR 0 7
55179: PUSH
55180: LD_VAR 0 9
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: PPUSH
55189: CALL_OW 2
55193: ST_TO_ADDR
55194: GO 55276
// for j = 1 to result do
55196: LD_ADDR_VAR 0 8
55200: PUSH
55201: DOUBLE
55202: LD_INT 1
55204: DEC
55205: ST_TO_ADDR
55206: LD_VAR 0 6
55210: PUSH
55211: FOR_TO
55212: IFFALSE 55274
// begin if tmp < result [ j ] [ 2 ] then
55214: LD_VAR 0 9
55218: PUSH
55219: LD_VAR 0 6
55223: PUSH
55224: LD_VAR 0 8
55228: ARRAY
55229: PUSH
55230: LD_INT 2
55232: ARRAY
55233: LESS
55234: IFFALSE 55272
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55236: LD_ADDR_VAR 0 6
55240: PUSH
55241: LD_VAR 0 6
55245: PPUSH
55246: LD_VAR 0 8
55250: PPUSH
55251: LD_VAR 0 7
55255: PUSH
55256: LD_VAR 0 9
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: PPUSH
55265: CALL_OW 2
55269: ST_TO_ADDR
// break ;
55270: GO 55274
// end ; end ;
55272: GO 55211
55274: POP
55275: POP
// end ; end ;
55276: GO 55075
55278: POP
55279: POP
// if result and not asc then
55280: LD_VAR 0 6
55284: PUSH
55285: LD_VAR 0 4
55289: NOT
55290: AND
55291: IFFALSE 55366
// begin tmp := result ;
55293: LD_ADDR_VAR 0 9
55297: PUSH
55298: LD_VAR 0 6
55302: ST_TO_ADDR
// for i = tmp downto 1 do
55303: LD_ADDR_VAR 0 7
55307: PUSH
55308: DOUBLE
55309: LD_VAR 0 9
55313: INC
55314: ST_TO_ADDR
55315: LD_INT 1
55317: PUSH
55318: FOR_DOWNTO
55319: IFFALSE 55364
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55321: LD_ADDR_VAR 0 6
55325: PUSH
55326: LD_VAR 0 6
55330: PPUSH
55331: LD_VAR 0 9
55335: PUSH
55336: LD_VAR 0 7
55340: MINUS
55341: PUSH
55342: LD_INT 1
55344: PLUS
55345: PPUSH
55346: LD_VAR 0 9
55350: PUSH
55351: LD_VAR 0 7
55355: ARRAY
55356: PPUSH
55357: CALL_OW 1
55361: ST_TO_ADDR
55362: GO 55318
55364: POP
55365: POP
// end ; tmp := [ ] ;
55366: LD_ADDR_VAR 0 9
55370: PUSH
55371: EMPTY
55372: ST_TO_ADDR
// if mode then
55373: LD_VAR 0 5
55377: IFFALSE 55446
// begin for i = 1 to result do
55379: LD_ADDR_VAR 0 7
55383: PUSH
55384: DOUBLE
55385: LD_INT 1
55387: DEC
55388: ST_TO_ADDR
55389: LD_VAR 0 6
55393: PUSH
55394: FOR_TO
55395: IFFALSE 55434
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55397: LD_ADDR_VAR 0 9
55401: PUSH
55402: LD_VAR 0 9
55406: PPUSH
55407: LD_VAR 0 7
55411: PPUSH
55412: LD_VAR 0 6
55416: PUSH
55417: LD_VAR 0 7
55421: ARRAY
55422: PUSH
55423: LD_INT 1
55425: ARRAY
55426: PPUSH
55427: CALL_OW 1
55431: ST_TO_ADDR
55432: GO 55394
55434: POP
55435: POP
// result := tmp ;
55436: LD_ADDR_VAR 0 6
55440: PUSH
55441: LD_VAR 0 9
55445: ST_TO_ADDR
// end ; end ;
55446: LD_VAR 0 6
55450: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55451: LD_INT 0
55453: PPUSH
55454: PPUSH
55455: PPUSH
55456: PPUSH
55457: PPUSH
55458: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55459: LD_ADDR_VAR 0 5
55463: PUSH
55464: LD_INT 0
55466: PUSH
55467: LD_INT 0
55469: PUSH
55470: LD_INT 0
55472: PUSH
55473: EMPTY
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: ST_TO_ADDR
// if not x or not y then
55481: LD_VAR 0 2
55485: NOT
55486: PUSH
55487: LD_VAR 0 3
55491: NOT
55492: OR
55493: IFFALSE 55497
// exit ;
55495: GO 57143
// if not range then
55497: LD_VAR 0 4
55501: NOT
55502: IFFALSE 55512
// range := 10 ;
55504: LD_ADDR_VAR 0 4
55508: PUSH
55509: LD_INT 10
55511: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55512: LD_ADDR_VAR 0 8
55516: PUSH
55517: LD_INT 81
55519: PUSH
55520: LD_VAR 0 1
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PUSH
55529: LD_INT 92
55531: PUSH
55532: LD_VAR 0 2
55536: PUSH
55537: LD_VAR 0 3
55541: PUSH
55542: LD_VAR 0 4
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: LIST
55551: LIST
55552: PUSH
55553: LD_INT 3
55555: PUSH
55556: LD_INT 21
55558: PUSH
55559: LD_INT 3
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: LIST
55574: PPUSH
55575: CALL_OW 69
55579: ST_TO_ADDR
// if not tmp then
55580: LD_VAR 0 8
55584: NOT
55585: IFFALSE 55589
// exit ;
55587: GO 57143
// for i in tmp do
55589: LD_ADDR_VAR 0 6
55593: PUSH
55594: LD_VAR 0 8
55598: PUSH
55599: FOR_IN
55600: IFFALSE 57118
// begin points := [ 0 , 0 , 0 ] ;
55602: LD_ADDR_VAR 0 9
55606: PUSH
55607: LD_INT 0
55609: PUSH
55610: LD_INT 0
55612: PUSH
55613: LD_INT 0
55615: PUSH
55616: EMPTY
55617: LIST
55618: LIST
55619: LIST
55620: ST_TO_ADDR
// bpoints := 1 ;
55621: LD_ADDR_VAR 0 10
55625: PUSH
55626: LD_INT 1
55628: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55629: LD_VAR 0 6
55633: PPUSH
55634: CALL_OW 247
55638: PUSH
55639: LD_INT 1
55641: DOUBLE
55642: EQUAL
55643: IFTRUE 55647
55645: GO 56225
55647: POP
// begin if GetClass ( i ) = 1 then
55648: LD_VAR 0 6
55652: PPUSH
55653: CALL_OW 257
55657: PUSH
55658: LD_INT 1
55660: EQUAL
55661: IFFALSE 55682
// points := [ 10 , 5 , 3 ] ;
55663: LD_ADDR_VAR 0 9
55667: PUSH
55668: LD_INT 10
55670: PUSH
55671: LD_INT 5
55673: PUSH
55674: LD_INT 3
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: LIST
55681: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55682: LD_VAR 0 6
55686: PPUSH
55687: CALL_OW 257
55691: PUSH
55692: LD_INT 2
55694: PUSH
55695: LD_INT 3
55697: PUSH
55698: LD_INT 4
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: IN
55706: IFFALSE 55727
// points := [ 3 , 2 , 1 ] ;
55708: LD_ADDR_VAR 0 9
55712: PUSH
55713: LD_INT 3
55715: PUSH
55716: LD_INT 2
55718: PUSH
55719: LD_INT 1
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55727: LD_VAR 0 6
55731: PPUSH
55732: CALL_OW 257
55736: PUSH
55737: LD_INT 5
55739: EQUAL
55740: IFFALSE 55761
// points := [ 130 , 5 , 2 ] ;
55742: LD_ADDR_VAR 0 9
55746: PUSH
55747: LD_INT 130
55749: PUSH
55750: LD_INT 5
55752: PUSH
55753: LD_INT 2
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55761: LD_VAR 0 6
55765: PPUSH
55766: CALL_OW 257
55770: PUSH
55771: LD_INT 8
55773: EQUAL
55774: IFFALSE 55795
// points := [ 35 , 35 , 30 ] ;
55776: LD_ADDR_VAR 0 9
55780: PUSH
55781: LD_INT 35
55783: PUSH
55784: LD_INT 35
55786: PUSH
55787: LD_INT 30
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55795: LD_VAR 0 6
55799: PPUSH
55800: CALL_OW 257
55804: PUSH
55805: LD_INT 9
55807: EQUAL
55808: IFFALSE 55829
// points := [ 20 , 55 , 40 ] ;
55810: LD_ADDR_VAR 0 9
55814: PUSH
55815: LD_INT 20
55817: PUSH
55818: LD_INT 55
55820: PUSH
55821: LD_INT 40
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55829: LD_VAR 0 6
55833: PPUSH
55834: CALL_OW 257
55838: PUSH
55839: LD_INT 12
55841: PUSH
55842: LD_INT 16
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: IN
55849: IFFALSE 55870
// points := [ 5 , 3 , 2 ] ;
55851: LD_ADDR_VAR 0 9
55855: PUSH
55856: LD_INT 5
55858: PUSH
55859: LD_INT 3
55861: PUSH
55862: LD_INT 2
55864: PUSH
55865: EMPTY
55866: LIST
55867: LIST
55868: LIST
55869: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55870: LD_VAR 0 6
55874: PPUSH
55875: CALL_OW 257
55879: PUSH
55880: LD_INT 17
55882: EQUAL
55883: IFFALSE 55904
// points := [ 100 , 50 , 75 ] ;
55885: LD_ADDR_VAR 0 9
55889: PUSH
55890: LD_INT 100
55892: PUSH
55893: LD_INT 50
55895: PUSH
55896: LD_INT 75
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: LIST
55903: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55904: LD_VAR 0 6
55908: PPUSH
55909: CALL_OW 257
55913: PUSH
55914: LD_INT 15
55916: EQUAL
55917: IFFALSE 55938
// points := [ 10 , 5 , 3 ] ;
55919: LD_ADDR_VAR 0 9
55923: PUSH
55924: LD_INT 10
55926: PUSH
55927: LD_INT 5
55929: PUSH
55930: LD_INT 3
55932: PUSH
55933: EMPTY
55934: LIST
55935: LIST
55936: LIST
55937: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55938: LD_VAR 0 6
55942: PPUSH
55943: CALL_OW 257
55947: PUSH
55948: LD_INT 14
55950: EQUAL
55951: IFFALSE 55972
// points := [ 10 , 0 , 0 ] ;
55953: LD_ADDR_VAR 0 9
55957: PUSH
55958: LD_INT 10
55960: PUSH
55961: LD_INT 0
55963: PUSH
55964: LD_INT 0
55966: PUSH
55967: EMPTY
55968: LIST
55969: LIST
55970: LIST
55971: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55972: LD_VAR 0 6
55976: PPUSH
55977: CALL_OW 257
55981: PUSH
55982: LD_INT 11
55984: EQUAL
55985: IFFALSE 56006
// points := [ 30 , 10 , 5 ] ;
55987: LD_ADDR_VAR 0 9
55991: PUSH
55992: LD_INT 30
55994: PUSH
55995: LD_INT 10
55997: PUSH
55998: LD_INT 5
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: LIST
56005: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
56006: LD_VAR 0 1
56010: PPUSH
56011: LD_INT 5
56013: PPUSH
56014: CALL_OW 321
56018: PUSH
56019: LD_INT 2
56021: EQUAL
56022: IFFALSE 56039
// bpoints := bpoints * 1.8 ;
56024: LD_ADDR_VAR 0 10
56028: PUSH
56029: LD_VAR 0 10
56033: PUSH
56034: LD_REAL  1.80000000000000E+0000
56037: MUL
56038: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
56039: LD_VAR 0 6
56043: PPUSH
56044: CALL_OW 257
56048: PUSH
56049: LD_INT 1
56051: PUSH
56052: LD_INT 2
56054: PUSH
56055: LD_INT 3
56057: PUSH
56058: LD_INT 4
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: IN
56067: PUSH
56068: LD_VAR 0 1
56072: PPUSH
56073: LD_INT 51
56075: PPUSH
56076: CALL_OW 321
56080: PUSH
56081: LD_INT 2
56083: EQUAL
56084: AND
56085: IFFALSE 56102
// bpoints := bpoints * 1.2 ;
56087: LD_ADDR_VAR 0 10
56091: PUSH
56092: LD_VAR 0 10
56096: PUSH
56097: LD_REAL  1.20000000000000E+0000
56100: MUL
56101: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56102: LD_VAR 0 6
56106: PPUSH
56107: CALL_OW 257
56111: PUSH
56112: LD_INT 5
56114: PUSH
56115: LD_INT 7
56117: PUSH
56118: LD_INT 9
56120: PUSH
56121: EMPTY
56122: LIST
56123: LIST
56124: LIST
56125: IN
56126: PUSH
56127: LD_VAR 0 1
56131: PPUSH
56132: LD_INT 52
56134: PPUSH
56135: CALL_OW 321
56139: PUSH
56140: LD_INT 2
56142: EQUAL
56143: AND
56144: IFFALSE 56161
// bpoints := bpoints * 1.5 ;
56146: LD_ADDR_VAR 0 10
56150: PUSH
56151: LD_VAR 0 10
56155: PUSH
56156: LD_REAL  1.50000000000000E+0000
56159: MUL
56160: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56161: LD_VAR 0 1
56165: PPUSH
56166: LD_INT 66
56168: PPUSH
56169: CALL_OW 321
56173: PUSH
56174: LD_INT 2
56176: EQUAL
56177: IFFALSE 56194
// bpoints := bpoints * 1.1 ;
56179: LD_ADDR_VAR 0 10
56183: PUSH
56184: LD_VAR 0 10
56188: PUSH
56189: LD_REAL  1.10000000000000E+0000
56192: MUL
56193: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56194: LD_ADDR_VAR 0 10
56198: PUSH
56199: LD_VAR 0 10
56203: PUSH
56204: LD_VAR 0 6
56208: PPUSH
56209: LD_INT 1
56211: PPUSH
56212: CALL_OW 259
56216: PUSH
56217: LD_REAL  1.15000000000000E+0000
56220: MUL
56221: MUL
56222: ST_TO_ADDR
// end ; unit_vehicle :
56223: GO 57047
56225: LD_INT 2
56227: DOUBLE
56228: EQUAL
56229: IFTRUE 56233
56231: GO 57035
56233: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56234: LD_VAR 0 6
56238: PPUSH
56239: CALL_OW 264
56243: PUSH
56244: LD_INT 2
56246: PUSH
56247: LD_INT 42
56249: PUSH
56250: LD_INT 24
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: LIST
56257: IN
56258: IFFALSE 56279
// points := [ 25 , 5 , 3 ] ;
56260: LD_ADDR_VAR 0 9
56264: PUSH
56265: LD_INT 25
56267: PUSH
56268: LD_INT 5
56270: PUSH
56271: LD_INT 3
56273: PUSH
56274: EMPTY
56275: LIST
56276: LIST
56277: LIST
56278: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56279: LD_VAR 0 6
56283: PPUSH
56284: CALL_OW 264
56288: PUSH
56289: LD_INT 4
56291: PUSH
56292: LD_INT 43
56294: PUSH
56295: LD_INT 25
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: LIST
56302: IN
56303: IFFALSE 56324
// points := [ 40 , 15 , 5 ] ;
56305: LD_ADDR_VAR 0 9
56309: PUSH
56310: LD_INT 40
56312: PUSH
56313: LD_INT 15
56315: PUSH
56316: LD_INT 5
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: LIST
56323: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56324: LD_VAR 0 6
56328: PPUSH
56329: CALL_OW 264
56333: PUSH
56334: LD_INT 3
56336: PUSH
56337: LD_INT 23
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: IN
56344: IFFALSE 56365
// points := [ 7 , 25 , 8 ] ;
56346: LD_ADDR_VAR 0 9
56350: PUSH
56351: LD_INT 7
56353: PUSH
56354: LD_INT 25
56356: PUSH
56357: LD_INT 8
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: LIST
56364: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56365: LD_VAR 0 6
56369: PPUSH
56370: CALL_OW 264
56374: PUSH
56375: LD_INT 5
56377: PUSH
56378: LD_INT 27
56380: PUSH
56381: LD_INT 44
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: LIST
56388: IN
56389: IFFALSE 56410
// points := [ 14 , 50 , 16 ] ;
56391: LD_ADDR_VAR 0 9
56395: PUSH
56396: LD_INT 14
56398: PUSH
56399: LD_INT 50
56401: PUSH
56402: LD_INT 16
56404: PUSH
56405: EMPTY
56406: LIST
56407: LIST
56408: LIST
56409: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56410: LD_VAR 0 6
56414: PPUSH
56415: CALL_OW 264
56419: PUSH
56420: LD_INT 6
56422: PUSH
56423: LD_INT 46
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: IN
56430: IFFALSE 56451
// points := [ 32 , 120 , 70 ] ;
56432: LD_ADDR_VAR 0 9
56436: PUSH
56437: LD_INT 32
56439: PUSH
56440: LD_INT 120
56442: PUSH
56443: LD_INT 70
56445: PUSH
56446: EMPTY
56447: LIST
56448: LIST
56449: LIST
56450: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
56451: LD_VAR 0 6
56455: PPUSH
56456: CALL_OW 264
56460: PUSH
56461: LD_INT 7
56463: PUSH
56464: LD_INT 28
56466: PUSH
56467: LD_INT 45
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: LIST
56474: IN
56475: IFFALSE 56496
// points := [ 35 , 20 , 45 ] ;
56477: LD_ADDR_VAR 0 9
56481: PUSH
56482: LD_INT 35
56484: PUSH
56485: LD_INT 20
56487: PUSH
56488: LD_INT 45
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: LIST
56495: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56496: LD_VAR 0 6
56500: PPUSH
56501: CALL_OW 264
56505: PUSH
56506: LD_INT 47
56508: PUSH
56509: EMPTY
56510: LIST
56511: IN
56512: IFFALSE 56533
// points := [ 67 , 45 , 75 ] ;
56514: LD_ADDR_VAR 0 9
56518: PUSH
56519: LD_INT 67
56521: PUSH
56522: LD_INT 45
56524: PUSH
56525: LD_INT 75
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: LIST
56532: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56533: LD_VAR 0 6
56537: PPUSH
56538: CALL_OW 264
56542: PUSH
56543: LD_INT 26
56545: PUSH
56546: EMPTY
56547: LIST
56548: IN
56549: IFFALSE 56570
// points := [ 120 , 30 , 80 ] ;
56551: LD_ADDR_VAR 0 9
56555: PUSH
56556: LD_INT 120
56558: PUSH
56559: LD_INT 30
56561: PUSH
56562: LD_INT 80
56564: PUSH
56565: EMPTY
56566: LIST
56567: LIST
56568: LIST
56569: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56570: LD_VAR 0 6
56574: PPUSH
56575: CALL_OW 264
56579: PUSH
56580: LD_INT 22
56582: PUSH
56583: EMPTY
56584: LIST
56585: IN
56586: IFFALSE 56607
// points := [ 40 , 1 , 1 ] ;
56588: LD_ADDR_VAR 0 9
56592: PUSH
56593: LD_INT 40
56595: PUSH
56596: LD_INT 1
56598: PUSH
56599: LD_INT 1
56601: PUSH
56602: EMPTY
56603: LIST
56604: LIST
56605: LIST
56606: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56607: LD_VAR 0 6
56611: PPUSH
56612: CALL_OW 264
56616: PUSH
56617: LD_INT 29
56619: PUSH
56620: EMPTY
56621: LIST
56622: IN
56623: IFFALSE 56644
// points := [ 70 , 200 , 400 ] ;
56625: LD_ADDR_VAR 0 9
56629: PUSH
56630: LD_INT 70
56632: PUSH
56633: LD_INT 200
56635: PUSH
56636: LD_INT 400
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56644: LD_VAR 0 6
56648: PPUSH
56649: CALL_OW 264
56653: PUSH
56654: LD_INT 14
56656: PUSH
56657: LD_INT 53
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: IN
56664: IFFALSE 56685
// points := [ 40 , 10 , 20 ] ;
56666: LD_ADDR_VAR 0 9
56670: PUSH
56671: LD_INT 40
56673: PUSH
56674: LD_INT 10
56676: PUSH
56677: LD_INT 20
56679: PUSH
56680: EMPTY
56681: LIST
56682: LIST
56683: LIST
56684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56685: LD_VAR 0 6
56689: PPUSH
56690: CALL_OW 264
56694: PUSH
56695: LD_INT 9
56697: PUSH
56698: EMPTY
56699: LIST
56700: IN
56701: IFFALSE 56722
// points := [ 5 , 70 , 20 ] ;
56703: LD_ADDR_VAR 0 9
56707: PUSH
56708: LD_INT 5
56710: PUSH
56711: LD_INT 70
56713: PUSH
56714: LD_INT 20
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: LIST
56721: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56722: LD_VAR 0 6
56726: PPUSH
56727: CALL_OW 264
56731: PUSH
56732: LD_INT 10
56734: PUSH
56735: EMPTY
56736: LIST
56737: IN
56738: IFFALSE 56759
// points := [ 35 , 110 , 70 ] ;
56740: LD_ADDR_VAR 0 9
56744: PUSH
56745: LD_INT 35
56747: PUSH
56748: LD_INT 110
56750: PUSH
56751: LD_INT 70
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: LIST
56758: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56759: LD_VAR 0 6
56763: PPUSH
56764: CALL_OW 265
56768: PUSH
56769: LD_INT 25
56771: EQUAL
56772: IFFALSE 56793
// points := [ 80 , 65 , 100 ] ;
56774: LD_ADDR_VAR 0 9
56778: PUSH
56779: LD_INT 80
56781: PUSH
56782: LD_INT 65
56784: PUSH
56785: LD_INT 100
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: LIST
56792: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56793: LD_VAR 0 6
56797: PPUSH
56798: CALL_OW 263
56802: PUSH
56803: LD_INT 1
56805: EQUAL
56806: IFFALSE 56841
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56808: LD_ADDR_VAR 0 10
56812: PUSH
56813: LD_VAR 0 10
56817: PUSH
56818: LD_VAR 0 6
56822: PPUSH
56823: CALL_OW 311
56827: PPUSH
56828: LD_INT 3
56830: PPUSH
56831: CALL_OW 259
56835: PUSH
56836: LD_INT 4
56838: MUL
56839: MUL
56840: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56841: LD_VAR 0 6
56845: PPUSH
56846: CALL_OW 263
56850: PUSH
56851: LD_INT 2
56853: EQUAL
56854: IFFALSE 56905
// begin j := IsControledBy ( i ) ;
56856: LD_ADDR_VAR 0 7
56860: PUSH
56861: LD_VAR 0 6
56865: PPUSH
56866: CALL_OW 312
56870: ST_TO_ADDR
// if j then
56871: LD_VAR 0 7
56875: IFFALSE 56905
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56877: LD_ADDR_VAR 0 10
56881: PUSH
56882: LD_VAR 0 10
56886: PUSH
56887: LD_VAR 0 7
56891: PPUSH
56892: LD_INT 3
56894: PPUSH
56895: CALL_OW 259
56899: PUSH
56900: LD_INT 3
56902: MUL
56903: MUL
56904: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56905: LD_VAR 0 6
56909: PPUSH
56910: CALL_OW 264
56914: PUSH
56915: LD_INT 5
56917: PUSH
56918: LD_INT 6
56920: PUSH
56921: LD_INT 46
56923: PUSH
56924: LD_INT 44
56926: PUSH
56927: LD_INT 47
56929: PUSH
56930: LD_INT 45
56932: PUSH
56933: LD_INT 28
56935: PUSH
56936: LD_INT 7
56938: PUSH
56939: LD_INT 27
56941: PUSH
56942: LD_INT 29
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: LIST
56949: LIST
56950: LIST
56951: LIST
56952: LIST
56953: LIST
56954: LIST
56955: LIST
56956: IN
56957: PUSH
56958: LD_VAR 0 1
56962: PPUSH
56963: LD_INT 52
56965: PPUSH
56966: CALL_OW 321
56970: PUSH
56971: LD_INT 2
56973: EQUAL
56974: AND
56975: IFFALSE 56992
// bpoints := bpoints * 1.2 ;
56977: LD_ADDR_VAR 0 10
56981: PUSH
56982: LD_VAR 0 10
56986: PUSH
56987: LD_REAL  1.20000000000000E+0000
56990: MUL
56991: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56992: LD_VAR 0 6
56996: PPUSH
56997: CALL_OW 264
57001: PUSH
57002: LD_INT 6
57004: PUSH
57005: LD_INT 46
57007: PUSH
57008: LD_INT 47
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: LIST
57015: IN
57016: IFFALSE 57033
// bpoints := bpoints * 1.2 ;
57018: LD_ADDR_VAR 0 10
57022: PUSH
57023: LD_VAR 0 10
57027: PUSH
57028: LD_REAL  1.20000000000000E+0000
57031: MUL
57032: ST_TO_ADDR
// end ; unit_building :
57033: GO 57047
57035: LD_INT 3
57037: DOUBLE
57038: EQUAL
57039: IFTRUE 57043
57041: GO 57046
57043: POP
// ; end ;
57044: GO 57047
57046: POP
// for j = 1 to 3 do
57047: LD_ADDR_VAR 0 7
57051: PUSH
57052: DOUBLE
57053: LD_INT 1
57055: DEC
57056: ST_TO_ADDR
57057: LD_INT 3
57059: PUSH
57060: FOR_TO
57061: IFFALSE 57114
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57063: LD_ADDR_VAR 0 5
57067: PUSH
57068: LD_VAR 0 5
57072: PPUSH
57073: LD_VAR 0 7
57077: PPUSH
57078: LD_VAR 0 5
57082: PUSH
57083: LD_VAR 0 7
57087: ARRAY
57088: PUSH
57089: LD_VAR 0 9
57093: PUSH
57094: LD_VAR 0 7
57098: ARRAY
57099: PUSH
57100: LD_VAR 0 10
57104: MUL
57105: PLUS
57106: PPUSH
57107: CALL_OW 1
57111: ST_TO_ADDR
57112: GO 57060
57114: POP
57115: POP
// end ;
57116: GO 55599
57118: POP
57119: POP
// result := Replace ( result , 4 , tmp ) ;
57120: LD_ADDR_VAR 0 5
57124: PUSH
57125: LD_VAR 0 5
57129: PPUSH
57130: LD_INT 4
57132: PPUSH
57133: LD_VAR 0 8
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// end ;
57143: LD_VAR 0 5
57147: RET
// export function DangerAtRange ( unit , range ) ; begin
57148: LD_INT 0
57150: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_VAR 0 1
57160: PPUSH
57161: CALL_OW 255
57165: PPUSH
57166: LD_VAR 0 1
57170: PPUSH
57171: CALL_OW 250
57175: PPUSH
57176: LD_VAR 0 1
57180: PPUSH
57181: CALL_OW 251
57185: PPUSH
57186: LD_VAR 0 2
57190: PPUSH
57191: CALL 55451 0 4
57195: ST_TO_ADDR
// end ;
57196: LD_VAR 0 3
57200: RET
// export function DangerInArea ( side , area ) ; begin
57201: LD_INT 0
57203: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57204: LD_ADDR_VAR 0 3
57208: PUSH
57209: LD_VAR 0 2
57213: PPUSH
57214: LD_INT 81
57216: PUSH
57217: LD_VAR 0 1
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: PPUSH
57226: CALL_OW 70
57230: ST_TO_ADDR
// end ;
57231: LD_VAR 0 3
57235: RET
// export function IsExtension ( b ) ; begin
57236: LD_INT 0
57238: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57239: LD_ADDR_VAR 0 2
57243: PUSH
57244: LD_VAR 0 1
57248: PUSH
57249: LD_INT 23
57251: PUSH
57252: LD_INT 20
57254: PUSH
57255: LD_INT 22
57257: PUSH
57258: LD_INT 17
57260: PUSH
57261: LD_INT 24
57263: PUSH
57264: LD_INT 21
57266: PUSH
57267: LD_INT 19
57269: PUSH
57270: LD_INT 16
57272: PUSH
57273: LD_INT 25
57275: PUSH
57276: LD_INT 18
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: LIST
57283: LIST
57284: LIST
57285: LIST
57286: LIST
57287: LIST
57288: LIST
57289: LIST
57290: IN
57291: ST_TO_ADDR
// end ;
57292: LD_VAR 0 2
57296: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
57297: LD_INT 0
57299: PPUSH
57300: PPUSH
57301: PPUSH
// result := [ ] ;
57302: LD_ADDR_VAR 0 3
57306: PUSH
57307: EMPTY
57308: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57309: LD_ADDR_VAR 0 4
57313: PUSH
57314: LD_VAR 0 2
57318: PPUSH
57319: LD_INT 21
57321: PUSH
57322: LD_INT 3
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: PPUSH
57329: CALL_OW 70
57333: ST_TO_ADDR
// if not tmp then
57334: LD_VAR 0 4
57338: NOT
57339: IFFALSE 57343
// exit ;
57341: GO 57401
// for i in tmp do
57343: LD_ADDR_VAR 0 5
57347: PUSH
57348: LD_VAR 0 4
57352: PUSH
57353: FOR_IN
57354: IFFALSE 57389
// if GetBase ( i ) <> base then
57356: LD_VAR 0 5
57360: PPUSH
57361: CALL_OW 274
57365: PUSH
57366: LD_VAR 0 1
57370: NONEQUAL
57371: IFFALSE 57387
// ComLinkToBase ( base , i ) ;
57373: LD_VAR 0 1
57377: PPUSH
57378: LD_VAR 0 5
57382: PPUSH
57383: CALL_OW 169
57387: GO 57353
57389: POP
57390: POP
// result := tmp ;
57391: LD_ADDR_VAR 0 3
57395: PUSH
57396: LD_VAR 0 4
57400: ST_TO_ADDR
// end ;
57401: LD_VAR 0 3
57405: RET
// export function ComComplete ( unit , b ) ; var i ; begin
57406: LD_INT 0
57408: PPUSH
57409: PPUSH
// if BuildingStatus ( b ) = bs_build then
57410: LD_VAR 0 2
57414: PPUSH
57415: CALL_OW 461
57419: PUSH
57420: LD_INT 1
57422: EQUAL
57423: IFFALSE 57483
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57425: LD_VAR 0 1
57429: PPUSH
57430: LD_STRING h
57432: PUSH
57433: LD_VAR 0 2
57437: PPUSH
57438: CALL_OW 250
57442: PUSH
57443: LD_VAR 0 2
57447: PPUSH
57448: CALL_OW 251
57452: PUSH
57453: LD_VAR 0 2
57457: PUSH
57458: LD_INT 0
57460: PUSH
57461: LD_INT 0
57463: PUSH
57464: LD_INT 0
57466: PUSH
57467: EMPTY
57468: LIST
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: LIST
57475: PUSH
57476: EMPTY
57477: LIST
57478: PPUSH
57479: CALL_OW 446
// end ;
57483: LD_VAR 0 3
57487: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57488: LD_INT 0
57490: PPUSH
57491: PPUSH
57492: PPUSH
57493: PPUSH
57494: PPUSH
57495: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
57496: LD_VAR 0 1
57500: NOT
57501: PUSH
57502: LD_VAR 0 1
57506: PPUSH
57507: CALL_OW 263
57511: PUSH
57512: LD_INT 2
57514: EQUAL
57515: NOT
57516: OR
57517: IFFALSE 57521
// exit ;
57519: GO 57837
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57521: LD_ADDR_VAR 0 6
57525: PUSH
57526: LD_INT 22
57528: PUSH
57529: LD_VAR 0 1
57533: PPUSH
57534: CALL_OW 255
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: PUSH
57543: LD_INT 2
57545: PUSH
57546: LD_INT 30
57548: PUSH
57549: LD_INT 36
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: LD_INT 34
57558: PUSH
57559: LD_INT 31
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: PUSH
57566: EMPTY
57567: LIST
57568: LIST
57569: LIST
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PPUSH
57575: CALL_OW 69
57579: ST_TO_ADDR
// if not tmp then
57580: LD_VAR 0 6
57584: NOT
57585: IFFALSE 57589
// exit ;
57587: GO 57837
// result := [ ] ;
57589: LD_ADDR_VAR 0 2
57593: PUSH
57594: EMPTY
57595: ST_TO_ADDR
// for i in tmp do
57596: LD_ADDR_VAR 0 3
57600: PUSH
57601: LD_VAR 0 6
57605: PUSH
57606: FOR_IN
57607: IFFALSE 57678
// begin t := UnitsInside ( i ) ;
57609: LD_ADDR_VAR 0 4
57613: PUSH
57614: LD_VAR 0 3
57618: PPUSH
57619: CALL_OW 313
57623: ST_TO_ADDR
// if t then
57624: LD_VAR 0 4
57628: IFFALSE 57676
// for j in t do
57630: LD_ADDR_VAR 0 7
57634: PUSH
57635: LD_VAR 0 4
57639: PUSH
57640: FOR_IN
57641: IFFALSE 57674
// result := Insert ( result , result + 1 , j ) ;
57643: LD_ADDR_VAR 0 2
57647: PUSH
57648: LD_VAR 0 2
57652: PPUSH
57653: LD_VAR 0 2
57657: PUSH
57658: LD_INT 1
57660: PLUS
57661: PPUSH
57662: LD_VAR 0 7
57666: PPUSH
57667: CALL_OW 2
57671: ST_TO_ADDR
57672: GO 57640
57674: POP
57675: POP
// end ;
57676: GO 57606
57678: POP
57679: POP
// if not result then
57680: LD_VAR 0 2
57684: NOT
57685: IFFALSE 57689
// exit ;
57687: GO 57837
// mech := result [ 1 ] ;
57689: LD_ADDR_VAR 0 5
57693: PUSH
57694: LD_VAR 0 2
57698: PUSH
57699: LD_INT 1
57701: ARRAY
57702: ST_TO_ADDR
// if result > 1 then
57703: LD_VAR 0 2
57707: PUSH
57708: LD_INT 1
57710: GREATER
57711: IFFALSE 57823
// for i = 2 to result do
57713: LD_ADDR_VAR 0 3
57717: PUSH
57718: DOUBLE
57719: LD_INT 2
57721: DEC
57722: ST_TO_ADDR
57723: LD_VAR 0 2
57727: PUSH
57728: FOR_TO
57729: IFFALSE 57821
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57731: LD_ADDR_VAR 0 4
57735: PUSH
57736: LD_VAR 0 2
57740: PUSH
57741: LD_VAR 0 3
57745: ARRAY
57746: PPUSH
57747: LD_INT 3
57749: PPUSH
57750: CALL_OW 259
57754: PUSH
57755: LD_VAR 0 2
57759: PUSH
57760: LD_VAR 0 3
57764: ARRAY
57765: PPUSH
57766: CALL_OW 432
57770: MINUS
57771: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57772: LD_VAR 0 4
57776: PUSH
57777: LD_VAR 0 5
57781: PPUSH
57782: LD_INT 3
57784: PPUSH
57785: CALL_OW 259
57789: PUSH
57790: LD_VAR 0 5
57794: PPUSH
57795: CALL_OW 432
57799: MINUS
57800: GREATEREQUAL
57801: IFFALSE 57819
// mech := result [ i ] ;
57803: LD_ADDR_VAR 0 5
57807: PUSH
57808: LD_VAR 0 2
57812: PUSH
57813: LD_VAR 0 3
57817: ARRAY
57818: ST_TO_ADDR
// end ;
57819: GO 57728
57821: POP
57822: POP
// ComLinkTo ( vehicle , mech ) ;
57823: LD_VAR 0 1
57827: PPUSH
57828: LD_VAR 0 5
57832: PPUSH
57833: CALL_OW 135
// end ;
57837: LD_VAR 0 2
57841: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57842: LD_INT 0
57844: PPUSH
57845: PPUSH
57846: PPUSH
57847: PPUSH
57848: PPUSH
57849: PPUSH
57850: PPUSH
57851: PPUSH
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
57856: PPUSH
// result := [ ] ;
57857: LD_ADDR_VAR 0 7
57861: PUSH
57862: EMPTY
57863: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57864: LD_VAR 0 1
57868: PPUSH
57869: CALL_OW 266
57873: PUSH
57874: LD_INT 0
57876: PUSH
57877: LD_INT 1
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: IN
57884: NOT
57885: IFFALSE 57889
// exit ;
57887: GO 59520
// if name then
57889: LD_VAR 0 3
57893: IFFALSE 57909
// SetBName ( base_dep , name ) ;
57895: LD_VAR 0 1
57899: PPUSH
57900: LD_VAR 0 3
57904: PPUSH
57905: CALL_OW 500
// base := GetBase ( base_dep ) ;
57909: LD_ADDR_VAR 0 15
57913: PUSH
57914: LD_VAR 0 1
57918: PPUSH
57919: CALL_OW 274
57923: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57924: LD_ADDR_VAR 0 16
57928: PUSH
57929: LD_VAR 0 1
57933: PPUSH
57934: CALL_OW 255
57938: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57939: LD_ADDR_VAR 0 17
57943: PUSH
57944: LD_VAR 0 1
57948: PPUSH
57949: CALL_OW 248
57953: ST_TO_ADDR
// if sources then
57954: LD_VAR 0 5
57958: IFFALSE 58005
// for i = 1 to 3 do
57960: LD_ADDR_VAR 0 8
57964: PUSH
57965: DOUBLE
57966: LD_INT 1
57968: DEC
57969: ST_TO_ADDR
57970: LD_INT 3
57972: PUSH
57973: FOR_TO
57974: IFFALSE 58003
// AddResourceType ( base , i , sources [ i ] ) ;
57976: LD_VAR 0 15
57980: PPUSH
57981: LD_VAR 0 8
57985: PPUSH
57986: LD_VAR 0 5
57990: PUSH
57991: LD_VAR 0 8
57995: ARRAY
57996: PPUSH
57997: CALL_OW 276
58001: GO 57973
58003: POP
58004: POP
// buildings := GetBaseBuildings ( base , area ) ;
58005: LD_ADDR_VAR 0 18
58009: PUSH
58010: LD_VAR 0 15
58014: PPUSH
58015: LD_VAR 0 2
58019: PPUSH
58020: CALL 57297 0 2
58024: ST_TO_ADDR
// InitHc ;
58025: CALL_OW 19
// InitUc ;
58029: CALL_OW 18
// uc_side := side ;
58033: LD_ADDR_OWVAR 20
58037: PUSH
58038: LD_VAR 0 16
58042: ST_TO_ADDR
// uc_nation := nation ;
58043: LD_ADDR_OWVAR 21
58047: PUSH
58048: LD_VAR 0 17
58052: ST_TO_ADDR
// if buildings then
58053: LD_VAR 0 18
58057: IFFALSE 59379
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58059: LD_ADDR_VAR 0 19
58063: PUSH
58064: LD_VAR 0 18
58068: PPUSH
58069: LD_INT 2
58071: PUSH
58072: LD_INT 30
58074: PUSH
58075: LD_INT 29
58077: PUSH
58078: EMPTY
58079: LIST
58080: LIST
58081: PUSH
58082: LD_INT 30
58084: PUSH
58085: LD_INT 30
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: LIST
58096: PPUSH
58097: CALL_OW 72
58101: ST_TO_ADDR
// if tmp then
58102: LD_VAR 0 19
58106: IFFALSE 58154
// for i in tmp do
58108: LD_ADDR_VAR 0 8
58112: PUSH
58113: LD_VAR 0 19
58117: PUSH
58118: FOR_IN
58119: IFFALSE 58152
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58121: LD_VAR 0 8
58125: PPUSH
58126: CALL_OW 250
58130: PPUSH
58131: LD_VAR 0 8
58135: PPUSH
58136: CALL_OW 251
58140: PPUSH
58141: LD_VAR 0 16
58145: PPUSH
58146: CALL_OW 441
58150: GO 58118
58152: POP
58153: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58154: LD_VAR 0 18
58158: PPUSH
58159: LD_INT 2
58161: PUSH
58162: LD_INT 30
58164: PUSH
58165: LD_INT 32
58167: PUSH
58168: EMPTY
58169: LIST
58170: LIST
58171: PUSH
58172: LD_INT 30
58174: PUSH
58175: LD_INT 33
58177: PUSH
58178: EMPTY
58179: LIST
58180: LIST
58181: PUSH
58182: EMPTY
58183: LIST
58184: LIST
58185: LIST
58186: PPUSH
58187: CALL_OW 72
58191: IFFALSE 58279
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58193: LD_ADDR_VAR 0 8
58197: PUSH
58198: LD_VAR 0 18
58202: PPUSH
58203: LD_INT 2
58205: PUSH
58206: LD_INT 30
58208: PUSH
58209: LD_INT 32
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: PUSH
58216: LD_INT 30
58218: PUSH
58219: LD_INT 33
58221: PUSH
58222: EMPTY
58223: LIST
58224: LIST
58225: PUSH
58226: EMPTY
58227: LIST
58228: LIST
58229: LIST
58230: PPUSH
58231: CALL_OW 72
58235: PUSH
58236: FOR_IN
58237: IFFALSE 58277
// begin if not GetBWeapon ( i ) then
58239: LD_VAR 0 8
58243: PPUSH
58244: CALL_OW 269
58248: NOT
58249: IFFALSE 58275
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58251: LD_VAR 0 8
58255: PPUSH
58256: LD_VAR 0 8
58260: PPUSH
58261: LD_VAR 0 2
58265: PPUSH
58266: CALL 59525 0 2
58270: PPUSH
58271: CALL_OW 431
// end ;
58275: GO 58236
58277: POP
58278: POP
// end ; for i = 1 to personel do
58279: LD_ADDR_VAR 0 8
58283: PUSH
58284: DOUBLE
58285: LD_INT 1
58287: DEC
58288: ST_TO_ADDR
58289: LD_VAR 0 6
58293: PUSH
58294: FOR_TO
58295: IFFALSE 59359
// begin if i > 4 then
58297: LD_VAR 0 8
58301: PUSH
58302: LD_INT 4
58304: GREATER
58305: IFFALSE 58309
// break ;
58307: GO 59359
// case i of 1 :
58309: LD_VAR 0 8
58313: PUSH
58314: LD_INT 1
58316: DOUBLE
58317: EQUAL
58318: IFTRUE 58322
58320: GO 58402
58322: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58323: LD_ADDR_VAR 0 12
58327: PUSH
58328: LD_VAR 0 18
58332: PPUSH
58333: LD_INT 22
58335: PUSH
58336: LD_VAR 0 16
58340: PUSH
58341: EMPTY
58342: LIST
58343: LIST
58344: PUSH
58345: LD_INT 58
58347: PUSH
58348: EMPTY
58349: LIST
58350: PUSH
58351: LD_INT 2
58353: PUSH
58354: LD_INT 30
58356: PUSH
58357: LD_INT 32
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PUSH
58364: LD_INT 30
58366: PUSH
58367: LD_INT 4
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: PUSH
58374: LD_INT 30
58376: PUSH
58377: LD_INT 5
58379: PUSH
58380: EMPTY
58381: LIST
58382: LIST
58383: PUSH
58384: EMPTY
58385: LIST
58386: LIST
58387: LIST
58388: LIST
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: PPUSH
58395: CALL_OW 72
58399: ST_TO_ADDR
58400: GO 58624
58402: LD_INT 2
58404: DOUBLE
58405: EQUAL
58406: IFTRUE 58410
58408: GO 58472
58410: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58411: LD_ADDR_VAR 0 12
58415: PUSH
58416: LD_VAR 0 18
58420: PPUSH
58421: LD_INT 22
58423: PUSH
58424: LD_VAR 0 16
58428: PUSH
58429: EMPTY
58430: LIST
58431: LIST
58432: PUSH
58433: LD_INT 2
58435: PUSH
58436: LD_INT 30
58438: PUSH
58439: LD_INT 0
58441: PUSH
58442: EMPTY
58443: LIST
58444: LIST
58445: PUSH
58446: LD_INT 30
58448: PUSH
58449: LD_INT 1
58451: PUSH
58452: EMPTY
58453: LIST
58454: LIST
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: LIST
58460: PUSH
58461: EMPTY
58462: LIST
58463: LIST
58464: PPUSH
58465: CALL_OW 72
58469: ST_TO_ADDR
58470: GO 58624
58472: LD_INT 3
58474: DOUBLE
58475: EQUAL
58476: IFTRUE 58480
58478: GO 58542
58480: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58481: LD_ADDR_VAR 0 12
58485: PUSH
58486: LD_VAR 0 18
58490: PPUSH
58491: LD_INT 22
58493: PUSH
58494: LD_VAR 0 16
58498: PUSH
58499: EMPTY
58500: LIST
58501: LIST
58502: PUSH
58503: LD_INT 2
58505: PUSH
58506: LD_INT 30
58508: PUSH
58509: LD_INT 2
58511: PUSH
58512: EMPTY
58513: LIST
58514: LIST
58515: PUSH
58516: LD_INT 30
58518: PUSH
58519: LD_INT 3
58521: PUSH
58522: EMPTY
58523: LIST
58524: LIST
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: PPUSH
58535: CALL_OW 72
58539: ST_TO_ADDR
58540: GO 58624
58542: LD_INT 4
58544: DOUBLE
58545: EQUAL
58546: IFTRUE 58550
58548: GO 58623
58550: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58551: LD_ADDR_VAR 0 12
58555: PUSH
58556: LD_VAR 0 18
58560: PPUSH
58561: LD_INT 22
58563: PUSH
58564: LD_VAR 0 16
58568: PUSH
58569: EMPTY
58570: LIST
58571: LIST
58572: PUSH
58573: LD_INT 2
58575: PUSH
58576: LD_INT 30
58578: PUSH
58579: LD_INT 6
58581: PUSH
58582: EMPTY
58583: LIST
58584: LIST
58585: PUSH
58586: LD_INT 30
58588: PUSH
58589: LD_INT 7
58591: PUSH
58592: EMPTY
58593: LIST
58594: LIST
58595: PUSH
58596: LD_INT 30
58598: PUSH
58599: LD_INT 8
58601: PUSH
58602: EMPTY
58603: LIST
58604: LIST
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: LIST
58610: LIST
58611: PUSH
58612: EMPTY
58613: LIST
58614: LIST
58615: PPUSH
58616: CALL_OW 72
58620: ST_TO_ADDR
58621: GO 58624
58623: POP
// if i = 1 then
58624: LD_VAR 0 8
58628: PUSH
58629: LD_INT 1
58631: EQUAL
58632: IFFALSE 58743
// begin tmp := [ ] ;
58634: LD_ADDR_VAR 0 19
58638: PUSH
58639: EMPTY
58640: ST_TO_ADDR
// for j in f do
58641: LD_ADDR_VAR 0 9
58645: PUSH
58646: LD_VAR 0 12
58650: PUSH
58651: FOR_IN
58652: IFFALSE 58725
// if GetBType ( j ) = b_bunker then
58654: LD_VAR 0 9
58658: PPUSH
58659: CALL_OW 266
58663: PUSH
58664: LD_INT 32
58666: EQUAL
58667: IFFALSE 58694
// tmp := Insert ( tmp , 1 , j ) else
58669: LD_ADDR_VAR 0 19
58673: PUSH
58674: LD_VAR 0 19
58678: PPUSH
58679: LD_INT 1
58681: PPUSH
58682: LD_VAR 0 9
58686: PPUSH
58687: CALL_OW 2
58691: ST_TO_ADDR
58692: GO 58723
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58694: LD_ADDR_VAR 0 19
58698: PUSH
58699: LD_VAR 0 19
58703: PPUSH
58704: LD_VAR 0 19
58708: PUSH
58709: LD_INT 1
58711: PLUS
58712: PPUSH
58713: LD_VAR 0 9
58717: PPUSH
58718: CALL_OW 2
58722: ST_TO_ADDR
58723: GO 58651
58725: POP
58726: POP
// if tmp then
58727: LD_VAR 0 19
58731: IFFALSE 58743
// f := tmp ;
58733: LD_ADDR_VAR 0 12
58737: PUSH
58738: LD_VAR 0 19
58742: ST_TO_ADDR
// end ; x := personel [ i ] ;
58743: LD_ADDR_VAR 0 13
58747: PUSH
58748: LD_VAR 0 6
58752: PUSH
58753: LD_VAR 0 8
58757: ARRAY
58758: ST_TO_ADDR
// if x = - 1 then
58759: LD_VAR 0 13
58763: PUSH
58764: LD_INT 1
58766: NEG
58767: EQUAL
58768: IFFALSE 58977
// begin for j in f do
58770: LD_ADDR_VAR 0 9
58774: PUSH
58775: LD_VAR 0 12
58779: PUSH
58780: FOR_IN
58781: IFFALSE 58973
// repeat InitHc ;
58783: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58787: LD_VAR 0 9
58791: PPUSH
58792: CALL_OW 266
58796: PUSH
58797: LD_INT 5
58799: EQUAL
58800: IFFALSE 58870
// begin if UnitsInside ( j ) < 3 then
58802: LD_VAR 0 9
58806: PPUSH
58807: CALL_OW 313
58811: PUSH
58812: LD_INT 3
58814: LESS
58815: IFFALSE 58851
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58817: LD_INT 0
58819: PPUSH
58820: LD_INT 5
58822: PUSH
58823: LD_INT 8
58825: PUSH
58826: LD_INT 9
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: LIST
58833: PUSH
58834: LD_VAR 0 17
58838: ARRAY
58839: PPUSH
58840: LD_VAR 0 4
58844: PPUSH
58845: CALL_OW 380
58849: GO 58868
// PrepareHuman ( false , i , skill ) ;
58851: LD_INT 0
58853: PPUSH
58854: LD_VAR 0 8
58858: PPUSH
58859: LD_VAR 0 4
58863: PPUSH
58864: CALL_OW 380
// end else
58868: GO 58887
// PrepareHuman ( false , i , skill ) ;
58870: LD_INT 0
58872: PPUSH
58873: LD_VAR 0 8
58877: PPUSH
58878: LD_VAR 0 4
58882: PPUSH
58883: CALL_OW 380
// un := CreateHuman ;
58887: LD_ADDR_VAR 0 14
58891: PUSH
58892: CALL_OW 44
58896: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58897: LD_ADDR_VAR 0 7
58901: PUSH
58902: LD_VAR 0 7
58906: PPUSH
58907: LD_INT 1
58909: PPUSH
58910: LD_VAR 0 14
58914: PPUSH
58915: CALL_OW 2
58919: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58920: LD_VAR 0 14
58924: PPUSH
58925: LD_VAR 0 9
58929: PPUSH
58930: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58934: LD_VAR 0 9
58938: PPUSH
58939: CALL_OW 313
58943: PUSH
58944: LD_INT 6
58946: EQUAL
58947: PUSH
58948: LD_VAR 0 9
58952: PPUSH
58953: CALL_OW 266
58957: PUSH
58958: LD_INT 32
58960: PUSH
58961: LD_INT 31
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: IN
58968: OR
58969: IFFALSE 58783
58971: GO 58780
58973: POP
58974: POP
// end else
58975: GO 59357
// for j = 1 to x do
58977: LD_ADDR_VAR 0 9
58981: PUSH
58982: DOUBLE
58983: LD_INT 1
58985: DEC
58986: ST_TO_ADDR
58987: LD_VAR 0 13
58991: PUSH
58992: FOR_TO
58993: IFFALSE 59355
// begin InitHc ;
58995: CALL_OW 19
// if not f then
58999: LD_VAR 0 12
59003: NOT
59004: IFFALSE 59093
// begin PrepareHuman ( false , i , skill ) ;
59006: LD_INT 0
59008: PPUSH
59009: LD_VAR 0 8
59013: PPUSH
59014: LD_VAR 0 4
59018: PPUSH
59019: CALL_OW 380
// un := CreateHuman ;
59023: LD_ADDR_VAR 0 14
59027: PUSH
59028: CALL_OW 44
59032: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59033: LD_ADDR_VAR 0 7
59037: PUSH
59038: LD_VAR 0 7
59042: PPUSH
59043: LD_INT 1
59045: PPUSH
59046: LD_VAR 0 14
59050: PPUSH
59051: CALL_OW 2
59055: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59056: LD_VAR 0 14
59060: PPUSH
59061: LD_VAR 0 1
59065: PPUSH
59066: CALL_OW 250
59070: PPUSH
59071: LD_VAR 0 1
59075: PPUSH
59076: CALL_OW 251
59080: PPUSH
59081: LD_INT 10
59083: PPUSH
59084: LD_INT 0
59086: PPUSH
59087: CALL_OW 50
// continue ;
59091: GO 58992
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59093: LD_VAR 0 12
59097: PUSH
59098: LD_INT 1
59100: ARRAY
59101: PPUSH
59102: CALL_OW 313
59106: PUSH
59107: LD_VAR 0 12
59111: PUSH
59112: LD_INT 1
59114: ARRAY
59115: PPUSH
59116: CALL_OW 266
59120: PUSH
59121: LD_INT 32
59123: PUSH
59124: LD_INT 31
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: IN
59131: AND
59132: PUSH
59133: LD_VAR 0 12
59137: PUSH
59138: LD_INT 1
59140: ARRAY
59141: PPUSH
59142: CALL_OW 313
59146: PUSH
59147: LD_INT 6
59149: EQUAL
59150: OR
59151: IFFALSE 59171
// f := Delete ( f , 1 ) ;
59153: LD_ADDR_VAR 0 12
59157: PUSH
59158: LD_VAR 0 12
59162: PPUSH
59163: LD_INT 1
59165: PPUSH
59166: CALL_OW 3
59170: ST_TO_ADDR
// if not f then
59171: LD_VAR 0 12
59175: NOT
59176: IFFALSE 59194
// begin x := x + 2 ;
59178: LD_ADDR_VAR 0 13
59182: PUSH
59183: LD_VAR 0 13
59187: PUSH
59188: LD_INT 2
59190: PLUS
59191: ST_TO_ADDR
// continue ;
59192: GO 58992
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59194: LD_VAR 0 12
59198: PUSH
59199: LD_INT 1
59201: ARRAY
59202: PPUSH
59203: CALL_OW 266
59207: PUSH
59208: LD_INT 5
59210: EQUAL
59211: IFFALSE 59285
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59213: LD_VAR 0 12
59217: PUSH
59218: LD_INT 1
59220: ARRAY
59221: PPUSH
59222: CALL_OW 313
59226: PUSH
59227: LD_INT 3
59229: LESS
59230: IFFALSE 59266
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59232: LD_INT 0
59234: PPUSH
59235: LD_INT 5
59237: PUSH
59238: LD_INT 8
59240: PUSH
59241: LD_INT 9
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: LIST
59248: PUSH
59249: LD_VAR 0 17
59253: ARRAY
59254: PPUSH
59255: LD_VAR 0 4
59259: PPUSH
59260: CALL_OW 380
59264: GO 59283
// PrepareHuman ( false , i , skill ) ;
59266: LD_INT 0
59268: PPUSH
59269: LD_VAR 0 8
59273: PPUSH
59274: LD_VAR 0 4
59278: PPUSH
59279: CALL_OW 380
// end else
59283: GO 59302
// PrepareHuman ( false , i , skill ) ;
59285: LD_INT 0
59287: PPUSH
59288: LD_VAR 0 8
59292: PPUSH
59293: LD_VAR 0 4
59297: PPUSH
59298: CALL_OW 380
// un := CreateHuman ;
59302: LD_ADDR_VAR 0 14
59306: PUSH
59307: CALL_OW 44
59311: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59312: LD_ADDR_VAR 0 7
59316: PUSH
59317: LD_VAR 0 7
59321: PPUSH
59322: LD_INT 1
59324: PPUSH
59325: LD_VAR 0 14
59329: PPUSH
59330: CALL_OW 2
59334: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59335: LD_VAR 0 14
59339: PPUSH
59340: LD_VAR 0 12
59344: PUSH
59345: LD_INT 1
59347: ARRAY
59348: PPUSH
59349: CALL_OW 52
// end ;
59353: GO 58992
59355: POP
59356: POP
// end ;
59357: GO 58294
59359: POP
59360: POP
// result := result ^ buildings ;
59361: LD_ADDR_VAR 0 7
59365: PUSH
59366: LD_VAR 0 7
59370: PUSH
59371: LD_VAR 0 18
59375: ADD
59376: ST_TO_ADDR
// end else
59377: GO 59520
// begin for i = 1 to personel do
59379: LD_ADDR_VAR 0 8
59383: PUSH
59384: DOUBLE
59385: LD_INT 1
59387: DEC
59388: ST_TO_ADDR
59389: LD_VAR 0 6
59393: PUSH
59394: FOR_TO
59395: IFFALSE 59518
// begin if i > 4 then
59397: LD_VAR 0 8
59401: PUSH
59402: LD_INT 4
59404: GREATER
59405: IFFALSE 59409
// break ;
59407: GO 59518
// x := personel [ i ] ;
59409: LD_ADDR_VAR 0 13
59413: PUSH
59414: LD_VAR 0 6
59418: PUSH
59419: LD_VAR 0 8
59423: ARRAY
59424: ST_TO_ADDR
// if x = - 1 then
59425: LD_VAR 0 13
59429: PUSH
59430: LD_INT 1
59432: NEG
59433: EQUAL
59434: IFFALSE 59438
// continue ;
59436: GO 59394
// PrepareHuman ( false , i , skill ) ;
59438: LD_INT 0
59440: PPUSH
59441: LD_VAR 0 8
59445: PPUSH
59446: LD_VAR 0 4
59450: PPUSH
59451: CALL_OW 380
// un := CreateHuman ;
59455: LD_ADDR_VAR 0 14
59459: PUSH
59460: CALL_OW 44
59464: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59465: LD_VAR 0 14
59469: PPUSH
59470: LD_VAR 0 1
59474: PPUSH
59475: CALL_OW 250
59479: PPUSH
59480: LD_VAR 0 1
59484: PPUSH
59485: CALL_OW 251
59489: PPUSH
59490: LD_INT 10
59492: PPUSH
59493: LD_INT 0
59495: PPUSH
59496: CALL_OW 50
// result := result ^ un ;
59500: LD_ADDR_VAR 0 7
59504: PUSH
59505: LD_VAR 0 7
59509: PUSH
59510: LD_VAR 0 14
59514: ADD
59515: ST_TO_ADDR
// end ;
59516: GO 59394
59518: POP
59519: POP
// end ; end ;
59520: LD_VAR 0 7
59524: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59525: LD_INT 0
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
59540: PPUSH
59541: PPUSH
59542: PPUSH
// result := false ;
59543: LD_ADDR_VAR 0 3
59547: PUSH
59548: LD_INT 0
59550: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59551: LD_VAR 0 1
59555: NOT
59556: PUSH
59557: LD_VAR 0 1
59561: PPUSH
59562: CALL_OW 266
59566: PUSH
59567: LD_INT 32
59569: PUSH
59570: LD_INT 33
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: IN
59577: NOT
59578: OR
59579: IFFALSE 59583
// exit ;
59581: GO 60719
// nat := GetNation ( tower ) ;
59583: LD_ADDR_VAR 0 12
59587: PUSH
59588: LD_VAR 0 1
59592: PPUSH
59593: CALL_OW 248
59597: ST_TO_ADDR
// side := GetSide ( tower ) ;
59598: LD_ADDR_VAR 0 16
59602: PUSH
59603: LD_VAR 0 1
59607: PPUSH
59608: CALL_OW 255
59612: ST_TO_ADDR
// x := GetX ( tower ) ;
59613: LD_ADDR_VAR 0 10
59617: PUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: CALL_OW 250
59627: ST_TO_ADDR
// y := GetY ( tower ) ;
59628: LD_ADDR_VAR 0 11
59632: PUSH
59633: LD_VAR 0 1
59637: PPUSH
59638: CALL_OW 251
59642: ST_TO_ADDR
// if not x or not y then
59643: LD_VAR 0 10
59647: NOT
59648: PUSH
59649: LD_VAR 0 11
59653: NOT
59654: OR
59655: IFFALSE 59659
// exit ;
59657: GO 60719
// weapon := 0 ;
59659: LD_ADDR_VAR 0 18
59663: PUSH
59664: LD_INT 0
59666: ST_TO_ADDR
// fac_list := [ ] ;
59667: LD_ADDR_VAR 0 17
59671: PUSH
59672: EMPTY
59673: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
59674: LD_ADDR_VAR 0 6
59678: PUSH
59679: LD_VAR 0 1
59683: PPUSH
59684: CALL_OW 274
59688: PPUSH
59689: LD_VAR 0 2
59693: PPUSH
59694: CALL 57297 0 2
59698: PPUSH
59699: LD_INT 30
59701: PUSH
59702: LD_INT 3
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: PPUSH
59709: CALL_OW 72
59713: ST_TO_ADDR
// if not factories then
59714: LD_VAR 0 6
59718: NOT
59719: IFFALSE 59723
// exit ;
59721: GO 60719
// for i in factories do
59723: LD_ADDR_VAR 0 8
59727: PUSH
59728: LD_VAR 0 6
59732: PUSH
59733: FOR_IN
59734: IFFALSE 59759
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59736: LD_ADDR_VAR 0 17
59740: PUSH
59741: LD_VAR 0 17
59745: PUSH
59746: LD_VAR 0 8
59750: PPUSH
59751: CALL_OW 478
59755: UNION
59756: ST_TO_ADDR
59757: GO 59733
59759: POP
59760: POP
// if not fac_list then
59761: LD_VAR 0 17
59765: NOT
59766: IFFALSE 59770
// exit ;
59768: GO 60719
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59770: LD_ADDR_VAR 0 5
59774: PUSH
59775: LD_INT 4
59777: PUSH
59778: LD_INT 5
59780: PUSH
59781: LD_INT 9
59783: PUSH
59784: LD_INT 10
59786: PUSH
59787: LD_INT 6
59789: PUSH
59790: LD_INT 7
59792: PUSH
59793: LD_INT 11
59795: PUSH
59796: EMPTY
59797: LIST
59798: LIST
59799: LIST
59800: LIST
59801: LIST
59802: LIST
59803: LIST
59804: PUSH
59805: LD_INT 27
59807: PUSH
59808: LD_INT 28
59810: PUSH
59811: LD_INT 26
59813: PUSH
59814: LD_INT 30
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: LIST
59821: LIST
59822: PUSH
59823: LD_INT 43
59825: PUSH
59826: LD_INT 44
59828: PUSH
59829: LD_INT 46
59831: PUSH
59832: LD_INT 45
59834: PUSH
59835: LD_INT 47
59837: PUSH
59838: LD_INT 49
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: PUSH
59849: EMPTY
59850: LIST
59851: LIST
59852: LIST
59853: PUSH
59854: LD_VAR 0 12
59858: ARRAY
59859: ST_TO_ADDR
// for i in list do
59860: LD_ADDR_VAR 0 8
59864: PUSH
59865: LD_VAR 0 5
59869: PUSH
59870: FOR_IN
59871: IFFALSE 59904
// if not i in fac_list then
59873: LD_VAR 0 8
59877: PUSH
59878: LD_VAR 0 17
59882: IN
59883: NOT
59884: IFFALSE 59902
// list := list diff i ;
59886: LD_ADDR_VAR 0 5
59890: PUSH
59891: LD_VAR 0 5
59895: PUSH
59896: LD_VAR 0 8
59900: DIFF
59901: ST_TO_ADDR
59902: GO 59870
59904: POP
59905: POP
// if not list then
59906: LD_VAR 0 5
59910: NOT
59911: IFFALSE 59915
// exit ;
59913: GO 60719
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59915: LD_VAR 0 12
59919: PUSH
59920: LD_INT 3
59922: EQUAL
59923: PUSH
59924: LD_INT 49
59926: PUSH
59927: LD_VAR 0 5
59931: IN
59932: AND
59933: PUSH
59934: LD_INT 31
59936: PPUSH
59937: LD_VAR 0 16
59941: PPUSH
59942: CALL_OW 321
59946: PUSH
59947: LD_INT 2
59949: EQUAL
59950: AND
59951: IFFALSE 60011
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59953: LD_INT 22
59955: PUSH
59956: LD_VAR 0 16
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: PUSH
59965: LD_INT 35
59967: PUSH
59968: LD_INT 49
59970: PUSH
59971: EMPTY
59972: LIST
59973: LIST
59974: PUSH
59975: LD_INT 91
59977: PUSH
59978: LD_VAR 0 1
59982: PUSH
59983: LD_INT 10
59985: PUSH
59986: EMPTY
59987: LIST
59988: LIST
59989: LIST
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: LIST
59995: PPUSH
59996: CALL_OW 69
60000: NOT
60001: IFFALSE 60011
// weapon := ru_time_lapser ;
60003: LD_ADDR_VAR 0 18
60007: PUSH
60008: LD_INT 49
60010: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
60011: LD_VAR 0 12
60015: PUSH
60016: LD_INT 1
60018: PUSH
60019: LD_INT 2
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: IN
60026: PUSH
60027: LD_INT 11
60029: PUSH
60030: LD_VAR 0 5
60034: IN
60035: PUSH
60036: LD_INT 30
60038: PUSH
60039: LD_VAR 0 5
60043: IN
60044: OR
60045: AND
60046: PUSH
60047: LD_INT 6
60049: PPUSH
60050: LD_VAR 0 16
60054: PPUSH
60055: CALL_OW 321
60059: PUSH
60060: LD_INT 2
60062: EQUAL
60063: AND
60064: IFFALSE 60229
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60066: LD_INT 22
60068: PUSH
60069: LD_VAR 0 16
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: PUSH
60078: LD_INT 2
60080: PUSH
60081: LD_INT 35
60083: PUSH
60084: LD_INT 11
60086: PUSH
60087: EMPTY
60088: LIST
60089: LIST
60090: PUSH
60091: LD_INT 35
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: EMPTY
60098: LIST
60099: LIST
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 91
60108: PUSH
60109: LD_VAR 0 1
60113: PUSH
60114: LD_INT 18
60116: PUSH
60117: EMPTY
60118: LIST
60119: LIST
60120: LIST
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: LIST
60126: PPUSH
60127: CALL_OW 69
60131: NOT
60132: PUSH
60133: LD_INT 22
60135: PUSH
60136: LD_VAR 0 16
60140: PUSH
60141: EMPTY
60142: LIST
60143: LIST
60144: PUSH
60145: LD_INT 2
60147: PUSH
60148: LD_INT 30
60150: PUSH
60151: LD_INT 32
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: LD_INT 30
60160: PUSH
60161: LD_INT 33
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: LIST
60172: PUSH
60173: LD_INT 91
60175: PUSH
60176: LD_VAR 0 1
60180: PUSH
60181: LD_INT 12
60183: PUSH
60184: EMPTY
60185: LIST
60186: LIST
60187: LIST
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: LIST
60193: PUSH
60194: EMPTY
60195: LIST
60196: PPUSH
60197: CALL_OW 69
60201: PUSH
60202: LD_INT 2
60204: GREATER
60205: AND
60206: IFFALSE 60229
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60208: LD_ADDR_VAR 0 18
60212: PUSH
60213: LD_INT 11
60215: PUSH
60216: LD_INT 30
60218: PUSH
60219: EMPTY
60220: LIST
60221: LIST
60222: PUSH
60223: LD_VAR 0 12
60227: ARRAY
60228: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60229: LD_VAR 0 18
60233: NOT
60234: PUSH
60235: LD_INT 40
60237: PPUSH
60238: LD_VAR 0 16
60242: PPUSH
60243: CALL_OW 321
60247: PUSH
60248: LD_INT 2
60250: EQUAL
60251: AND
60252: PUSH
60253: LD_INT 7
60255: PUSH
60256: LD_VAR 0 5
60260: IN
60261: PUSH
60262: LD_INT 28
60264: PUSH
60265: LD_VAR 0 5
60269: IN
60270: OR
60271: PUSH
60272: LD_INT 45
60274: PUSH
60275: LD_VAR 0 5
60279: IN
60280: OR
60281: AND
60282: IFFALSE 60536
// begin hex := GetHexInfo ( x , y ) ;
60284: LD_ADDR_VAR 0 4
60288: PUSH
60289: LD_VAR 0 10
60293: PPUSH
60294: LD_VAR 0 11
60298: PPUSH
60299: CALL_OW 546
60303: ST_TO_ADDR
// if hex [ 1 ] then
60304: LD_VAR 0 4
60308: PUSH
60309: LD_INT 1
60311: ARRAY
60312: IFFALSE 60316
// exit ;
60314: GO 60719
// height := hex [ 2 ] ;
60316: LD_ADDR_VAR 0 15
60320: PUSH
60321: LD_VAR 0 4
60325: PUSH
60326: LD_INT 2
60328: ARRAY
60329: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60330: LD_ADDR_VAR 0 14
60334: PUSH
60335: LD_INT 0
60337: PUSH
60338: LD_INT 2
60340: PUSH
60341: LD_INT 3
60343: PUSH
60344: LD_INT 5
60346: PUSH
60347: EMPTY
60348: LIST
60349: LIST
60350: LIST
60351: LIST
60352: ST_TO_ADDR
// for i in tmp do
60353: LD_ADDR_VAR 0 8
60357: PUSH
60358: LD_VAR 0 14
60362: PUSH
60363: FOR_IN
60364: IFFALSE 60534
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60366: LD_ADDR_VAR 0 9
60370: PUSH
60371: LD_VAR 0 10
60375: PPUSH
60376: LD_VAR 0 8
60380: PPUSH
60381: LD_INT 5
60383: PPUSH
60384: CALL_OW 272
60388: PUSH
60389: LD_VAR 0 11
60393: PPUSH
60394: LD_VAR 0 8
60398: PPUSH
60399: LD_INT 5
60401: PPUSH
60402: CALL_OW 273
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60411: LD_VAR 0 9
60415: PUSH
60416: LD_INT 1
60418: ARRAY
60419: PPUSH
60420: LD_VAR 0 9
60424: PUSH
60425: LD_INT 2
60427: ARRAY
60428: PPUSH
60429: CALL_OW 488
60433: IFFALSE 60532
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60435: LD_ADDR_VAR 0 4
60439: PUSH
60440: LD_VAR 0 9
60444: PUSH
60445: LD_INT 1
60447: ARRAY
60448: PPUSH
60449: LD_VAR 0 9
60453: PUSH
60454: LD_INT 2
60456: ARRAY
60457: PPUSH
60458: CALL_OW 546
60462: ST_TO_ADDR
// if hex [ 1 ] then
60463: LD_VAR 0 4
60467: PUSH
60468: LD_INT 1
60470: ARRAY
60471: IFFALSE 60475
// continue ;
60473: GO 60363
// h := hex [ 2 ] ;
60475: LD_ADDR_VAR 0 13
60479: PUSH
60480: LD_VAR 0 4
60484: PUSH
60485: LD_INT 2
60487: ARRAY
60488: ST_TO_ADDR
// if h + 7 < height then
60489: LD_VAR 0 13
60493: PUSH
60494: LD_INT 7
60496: PLUS
60497: PUSH
60498: LD_VAR 0 15
60502: LESS
60503: IFFALSE 60532
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60505: LD_ADDR_VAR 0 18
60509: PUSH
60510: LD_INT 7
60512: PUSH
60513: LD_INT 28
60515: PUSH
60516: LD_INT 45
60518: PUSH
60519: EMPTY
60520: LIST
60521: LIST
60522: LIST
60523: PUSH
60524: LD_VAR 0 12
60528: ARRAY
60529: ST_TO_ADDR
// break ;
60530: GO 60534
// end ; end ; end ;
60532: GO 60363
60534: POP
60535: POP
// end ; if not weapon then
60536: LD_VAR 0 18
60540: NOT
60541: IFFALSE 60601
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60543: LD_ADDR_VAR 0 5
60547: PUSH
60548: LD_VAR 0 5
60552: PUSH
60553: LD_INT 11
60555: PUSH
60556: LD_INT 30
60558: PUSH
60559: LD_INT 49
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: LIST
60566: DIFF
60567: ST_TO_ADDR
// if not list then
60568: LD_VAR 0 5
60572: NOT
60573: IFFALSE 60577
// exit ;
60575: GO 60719
// weapon := list [ rand ( 1 , list ) ] ;
60577: LD_ADDR_VAR 0 18
60581: PUSH
60582: LD_VAR 0 5
60586: PUSH
60587: LD_INT 1
60589: PPUSH
60590: LD_VAR 0 5
60594: PPUSH
60595: CALL_OW 12
60599: ARRAY
60600: ST_TO_ADDR
// end ; if weapon then
60601: LD_VAR 0 18
60605: IFFALSE 60719
// begin tmp := CostOfWeapon ( weapon ) ;
60607: LD_ADDR_VAR 0 14
60611: PUSH
60612: LD_VAR 0 18
60616: PPUSH
60617: CALL_OW 451
60621: ST_TO_ADDR
// j := GetBase ( tower ) ;
60622: LD_ADDR_VAR 0 9
60626: PUSH
60627: LD_VAR 0 1
60631: PPUSH
60632: CALL_OW 274
60636: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60637: LD_VAR 0 9
60641: PPUSH
60642: LD_INT 1
60644: PPUSH
60645: CALL_OW 275
60649: PUSH
60650: LD_VAR 0 14
60654: PUSH
60655: LD_INT 1
60657: ARRAY
60658: GREATEREQUAL
60659: PUSH
60660: LD_VAR 0 9
60664: PPUSH
60665: LD_INT 2
60667: PPUSH
60668: CALL_OW 275
60672: PUSH
60673: LD_VAR 0 14
60677: PUSH
60678: LD_INT 2
60680: ARRAY
60681: GREATEREQUAL
60682: AND
60683: PUSH
60684: LD_VAR 0 9
60688: PPUSH
60689: LD_INT 3
60691: PPUSH
60692: CALL_OW 275
60696: PUSH
60697: LD_VAR 0 14
60701: PUSH
60702: LD_INT 3
60704: ARRAY
60705: GREATEREQUAL
60706: AND
60707: IFFALSE 60719
// result := weapon ;
60709: LD_ADDR_VAR 0 3
60713: PUSH
60714: LD_VAR 0 18
60718: ST_TO_ADDR
// end ; end ;
60719: LD_VAR 0 3
60723: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60724: LD_INT 0
60726: PPUSH
60727: PPUSH
// result := true ;
60728: LD_ADDR_VAR 0 3
60732: PUSH
60733: LD_INT 1
60735: ST_TO_ADDR
// if array1 = array2 then
60736: LD_VAR 0 1
60740: PUSH
60741: LD_VAR 0 2
60745: EQUAL
60746: IFFALSE 60806
// begin for i = 1 to array1 do
60748: LD_ADDR_VAR 0 4
60752: PUSH
60753: DOUBLE
60754: LD_INT 1
60756: DEC
60757: ST_TO_ADDR
60758: LD_VAR 0 1
60762: PUSH
60763: FOR_TO
60764: IFFALSE 60802
// if array1 [ i ] <> array2 [ i ] then
60766: LD_VAR 0 1
60770: PUSH
60771: LD_VAR 0 4
60775: ARRAY
60776: PUSH
60777: LD_VAR 0 2
60781: PUSH
60782: LD_VAR 0 4
60786: ARRAY
60787: NONEQUAL
60788: IFFALSE 60800
// begin result := false ;
60790: LD_ADDR_VAR 0 3
60794: PUSH
60795: LD_INT 0
60797: ST_TO_ADDR
// break ;
60798: GO 60802
// end ;
60800: GO 60763
60802: POP
60803: POP
// end else
60804: GO 60814
// result := false ;
60806: LD_ADDR_VAR 0 3
60810: PUSH
60811: LD_INT 0
60813: ST_TO_ADDR
// end ;
60814: LD_VAR 0 3
60818: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60819: LD_INT 0
60821: PPUSH
60822: PPUSH
60823: PPUSH
// pom := GetBase ( fac ) ;
60824: LD_ADDR_VAR 0 5
60828: PUSH
60829: LD_VAR 0 1
60833: PPUSH
60834: CALL_OW 274
60838: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60839: LD_ADDR_VAR 0 4
60843: PUSH
60844: LD_VAR 0 2
60848: PUSH
60849: LD_INT 1
60851: ARRAY
60852: PPUSH
60853: LD_VAR 0 2
60857: PUSH
60858: LD_INT 2
60860: ARRAY
60861: PPUSH
60862: LD_VAR 0 2
60866: PUSH
60867: LD_INT 3
60869: ARRAY
60870: PPUSH
60871: LD_VAR 0 2
60875: PUSH
60876: LD_INT 4
60878: ARRAY
60879: PPUSH
60880: CALL_OW 449
60884: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60885: LD_ADDR_VAR 0 3
60889: PUSH
60890: LD_VAR 0 5
60894: PPUSH
60895: LD_INT 1
60897: PPUSH
60898: CALL_OW 275
60902: PUSH
60903: LD_VAR 0 4
60907: PUSH
60908: LD_INT 1
60910: ARRAY
60911: GREATEREQUAL
60912: PUSH
60913: LD_VAR 0 5
60917: PPUSH
60918: LD_INT 2
60920: PPUSH
60921: CALL_OW 275
60925: PUSH
60926: LD_VAR 0 4
60930: PUSH
60931: LD_INT 2
60933: ARRAY
60934: GREATEREQUAL
60935: AND
60936: PUSH
60937: LD_VAR 0 5
60941: PPUSH
60942: LD_INT 3
60944: PPUSH
60945: CALL_OW 275
60949: PUSH
60950: LD_VAR 0 4
60954: PUSH
60955: LD_INT 3
60957: ARRAY
60958: GREATEREQUAL
60959: AND
60960: ST_TO_ADDR
// end ;
60961: LD_VAR 0 3
60965: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60966: LD_INT 0
60968: PPUSH
60969: PPUSH
60970: PPUSH
60971: PPUSH
// pom := GetBase ( building ) ;
60972: LD_ADDR_VAR 0 3
60976: PUSH
60977: LD_VAR 0 1
60981: PPUSH
60982: CALL_OW 274
60986: ST_TO_ADDR
// if not pom then
60987: LD_VAR 0 3
60991: NOT
60992: IFFALSE 60996
// exit ;
60994: GO 61166
// btype := GetBType ( building ) ;
60996: LD_ADDR_VAR 0 5
61000: PUSH
61001: LD_VAR 0 1
61005: PPUSH
61006: CALL_OW 266
61010: ST_TO_ADDR
// if btype = b_armoury then
61011: LD_VAR 0 5
61015: PUSH
61016: LD_INT 4
61018: EQUAL
61019: IFFALSE 61029
// btype := b_barracks ;
61021: LD_ADDR_VAR 0 5
61025: PUSH
61026: LD_INT 5
61028: ST_TO_ADDR
// if btype = b_depot then
61029: LD_VAR 0 5
61033: PUSH
61034: LD_INT 0
61036: EQUAL
61037: IFFALSE 61047
// btype := b_warehouse ;
61039: LD_ADDR_VAR 0 5
61043: PUSH
61044: LD_INT 1
61046: ST_TO_ADDR
// if btype = b_workshop then
61047: LD_VAR 0 5
61051: PUSH
61052: LD_INT 2
61054: EQUAL
61055: IFFALSE 61065
// btype := b_factory ;
61057: LD_ADDR_VAR 0 5
61061: PUSH
61062: LD_INT 3
61064: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61065: LD_ADDR_VAR 0 4
61069: PUSH
61070: LD_VAR 0 5
61074: PPUSH
61075: LD_VAR 0 1
61079: PPUSH
61080: CALL_OW 248
61084: PPUSH
61085: CALL_OW 450
61089: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61090: LD_ADDR_VAR 0 2
61094: PUSH
61095: LD_VAR 0 3
61099: PPUSH
61100: LD_INT 1
61102: PPUSH
61103: CALL_OW 275
61107: PUSH
61108: LD_VAR 0 4
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: GREATEREQUAL
61117: PUSH
61118: LD_VAR 0 3
61122: PPUSH
61123: LD_INT 2
61125: PPUSH
61126: CALL_OW 275
61130: PUSH
61131: LD_VAR 0 4
61135: PUSH
61136: LD_INT 2
61138: ARRAY
61139: GREATEREQUAL
61140: AND
61141: PUSH
61142: LD_VAR 0 3
61146: PPUSH
61147: LD_INT 3
61149: PPUSH
61150: CALL_OW 275
61154: PUSH
61155: LD_VAR 0 4
61159: PUSH
61160: LD_INT 3
61162: ARRAY
61163: GREATEREQUAL
61164: AND
61165: ST_TO_ADDR
// end ;
61166: LD_VAR 0 2
61170: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61171: LD_INT 0
61173: PPUSH
61174: PPUSH
61175: PPUSH
// pom := GetBase ( building ) ;
61176: LD_ADDR_VAR 0 4
61180: PUSH
61181: LD_VAR 0 1
61185: PPUSH
61186: CALL_OW 274
61190: ST_TO_ADDR
// if not pom then
61191: LD_VAR 0 4
61195: NOT
61196: IFFALSE 61200
// exit ;
61198: GO 61301
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61200: LD_ADDR_VAR 0 5
61204: PUSH
61205: LD_VAR 0 2
61209: PPUSH
61210: LD_VAR 0 1
61214: PPUSH
61215: CALL_OW 248
61219: PPUSH
61220: CALL_OW 450
61224: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61225: LD_ADDR_VAR 0 3
61229: PUSH
61230: LD_VAR 0 4
61234: PPUSH
61235: LD_INT 1
61237: PPUSH
61238: CALL_OW 275
61242: PUSH
61243: LD_VAR 0 5
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: GREATEREQUAL
61252: PUSH
61253: LD_VAR 0 4
61257: PPUSH
61258: LD_INT 2
61260: PPUSH
61261: CALL_OW 275
61265: PUSH
61266: LD_VAR 0 5
61270: PUSH
61271: LD_INT 2
61273: ARRAY
61274: GREATEREQUAL
61275: AND
61276: PUSH
61277: LD_VAR 0 4
61281: PPUSH
61282: LD_INT 3
61284: PPUSH
61285: CALL_OW 275
61289: PUSH
61290: LD_VAR 0 5
61294: PUSH
61295: LD_INT 3
61297: ARRAY
61298: GREATEREQUAL
61299: AND
61300: ST_TO_ADDR
// end ;
61301: LD_VAR 0 3
61305: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
61306: LD_INT 0
61308: PPUSH
61309: PPUSH
61310: PPUSH
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
// result := false ;
61318: LD_ADDR_VAR 0 6
61322: PUSH
61323: LD_INT 0
61325: ST_TO_ADDR
// if not base or not btype or not x or not y then
61326: LD_VAR 0 1
61330: NOT
61331: PUSH
61332: LD_VAR 0 2
61336: NOT
61337: OR
61338: PUSH
61339: LD_VAR 0 3
61343: NOT
61344: OR
61345: PUSH
61346: LD_VAR 0 4
61350: NOT
61351: OR
61352: IFFALSE 61356
// exit ;
61354: GO 61965
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
61356: LD_ADDR_VAR 0 12
61360: PUSH
61361: LD_VAR 0 2
61365: PPUSH
61366: LD_VAR 0 3
61370: PPUSH
61371: LD_VAR 0 4
61375: PPUSH
61376: LD_VAR 0 5
61380: PPUSH
61381: LD_VAR 0 1
61385: PUSH
61386: LD_INT 1
61388: ARRAY
61389: PPUSH
61390: CALL_OW 248
61394: PPUSH
61395: LD_INT 0
61397: PPUSH
61398: CALL 62802 0 6
61402: ST_TO_ADDR
// if not hexes then
61403: LD_VAR 0 12
61407: NOT
61408: IFFALSE 61412
// exit ;
61410: GO 61965
// for i = 1 to hexes do
61412: LD_ADDR_VAR 0 7
61416: PUSH
61417: DOUBLE
61418: LD_INT 1
61420: DEC
61421: ST_TO_ADDR
61422: LD_VAR 0 12
61426: PUSH
61427: FOR_TO
61428: IFFALSE 61963
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61430: LD_ADDR_VAR 0 11
61434: PUSH
61435: LD_VAR 0 12
61439: PUSH
61440: LD_VAR 0 7
61444: ARRAY
61445: PUSH
61446: LD_INT 1
61448: ARRAY
61449: PPUSH
61450: LD_VAR 0 12
61454: PUSH
61455: LD_VAR 0 7
61459: ARRAY
61460: PUSH
61461: LD_INT 2
61463: ARRAY
61464: PPUSH
61465: CALL_OW 428
61469: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61470: LD_VAR 0 12
61474: PUSH
61475: LD_VAR 0 7
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: ARRAY
61484: PPUSH
61485: LD_VAR 0 12
61489: PUSH
61490: LD_VAR 0 7
61494: ARRAY
61495: PUSH
61496: LD_INT 2
61498: ARRAY
61499: PPUSH
61500: CALL_OW 351
61504: PUSH
61505: LD_VAR 0 12
61509: PUSH
61510: LD_VAR 0 7
61514: ARRAY
61515: PUSH
61516: LD_INT 1
61518: ARRAY
61519: PPUSH
61520: LD_VAR 0 12
61524: PUSH
61525: LD_VAR 0 7
61529: ARRAY
61530: PUSH
61531: LD_INT 2
61533: ARRAY
61534: PPUSH
61535: CALL_OW 488
61539: NOT
61540: OR
61541: PUSH
61542: LD_VAR 0 11
61546: PPUSH
61547: CALL_OW 247
61551: PUSH
61552: LD_INT 3
61554: EQUAL
61555: OR
61556: IFFALSE 61562
// exit ;
61558: POP
61559: POP
61560: GO 61965
// if not tmp or not tmp in base then
61562: LD_VAR 0 11
61566: NOT
61567: PUSH
61568: LD_VAR 0 11
61572: PUSH
61573: LD_VAR 0 1
61577: IN
61578: NOT
61579: OR
61580: IFFALSE 61584
// continue ;
61582: GO 61427
// result := true ;
61584: LD_ADDR_VAR 0 6
61588: PUSH
61589: LD_INT 1
61591: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61592: LD_ADDR_VAR 0 15
61596: PUSH
61597: LD_VAR 0 1
61601: PPUSH
61602: LD_INT 22
61604: PUSH
61605: LD_VAR 0 11
61609: PPUSH
61610: CALL_OW 255
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: PUSH
61619: LD_INT 2
61621: PUSH
61622: LD_INT 30
61624: PUSH
61625: LD_INT 0
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 30
61634: PUSH
61635: LD_INT 1
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: LIST
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PPUSH
61651: CALL_OW 72
61655: ST_TO_ADDR
// if dep then
61656: LD_VAR 0 15
61660: IFFALSE 61796
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61662: LD_ADDR_VAR 0 14
61666: PUSH
61667: LD_VAR 0 15
61671: PUSH
61672: LD_INT 1
61674: ARRAY
61675: PPUSH
61676: CALL_OW 250
61680: PPUSH
61681: LD_VAR 0 15
61685: PUSH
61686: LD_INT 1
61688: ARRAY
61689: PPUSH
61690: CALL_OW 254
61694: PPUSH
61695: LD_INT 5
61697: PPUSH
61698: CALL_OW 272
61702: PUSH
61703: LD_VAR 0 15
61707: PUSH
61708: LD_INT 1
61710: ARRAY
61711: PPUSH
61712: CALL_OW 251
61716: PPUSH
61717: LD_VAR 0 15
61721: PUSH
61722: LD_INT 1
61724: ARRAY
61725: PPUSH
61726: CALL_OW 254
61730: PPUSH
61731: LD_INT 5
61733: PPUSH
61734: CALL_OW 273
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61743: LD_VAR 0 14
61747: PUSH
61748: LD_INT 1
61750: ARRAY
61751: PPUSH
61752: LD_VAR 0 14
61756: PUSH
61757: LD_INT 2
61759: ARRAY
61760: PPUSH
61761: CALL_OW 488
61765: IFFALSE 61796
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61767: LD_VAR 0 11
61771: PPUSH
61772: LD_VAR 0 14
61776: PUSH
61777: LD_INT 1
61779: ARRAY
61780: PPUSH
61781: LD_VAR 0 14
61785: PUSH
61786: LD_INT 2
61788: ARRAY
61789: PPUSH
61790: CALL_OW 111
// continue ;
61794: GO 61427
// end ; end ; r := GetDir ( tmp ) ;
61796: LD_ADDR_VAR 0 13
61800: PUSH
61801: LD_VAR 0 11
61805: PPUSH
61806: CALL_OW 254
61810: ST_TO_ADDR
// if r = 5 then
61811: LD_VAR 0 13
61815: PUSH
61816: LD_INT 5
61818: EQUAL
61819: IFFALSE 61829
// r := 0 ;
61821: LD_ADDR_VAR 0 13
61825: PUSH
61826: LD_INT 0
61828: ST_TO_ADDR
// for j = r to 5 do
61829: LD_ADDR_VAR 0 8
61833: PUSH
61834: DOUBLE
61835: LD_VAR 0 13
61839: DEC
61840: ST_TO_ADDR
61841: LD_INT 5
61843: PUSH
61844: FOR_TO
61845: IFFALSE 61959
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61847: LD_ADDR_VAR 0 9
61851: PUSH
61852: LD_VAR 0 11
61856: PPUSH
61857: CALL_OW 250
61861: PPUSH
61862: LD_VAR 0 8
61866: PPUSH
61867: LD_INT 2
61869: PPUSH
61870: CALL_OW 272
61874: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61875: LD_ADDR_VAR 0 10
61879: PUSH
61880: LD_VAR 0 11
61884: PPUSH
61885: CALL_OW 251
61889: PPUSH
61890: LD_VAR 0 8
61894: PPUSH
61895: LD_INT 2
61897: PPUSH
61898: CALL_OW 273
61902: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61903: LD_VAR 0 9
61907: PPUSH
61908: LD_VAR 0 10
61912: PPUSH
61913: CALL_OW 488
61917: PUSH
61918: LD_VAR 0 9
61922: PPUSH
61923: LD_VAR 0 10
61927: PPUSH
61928: CALL_OW 428
61932: NOT
61933: AND
61934: IFFALSE 61957
// begin ComMoveXY ( tmp , _x , _y ) ;
61936: LD_VAR 0 11
61940: PPUSH
61941: LD_VAR 0 9
61945: PPUSH
61946: LD_VAR 0 10
61950: PPUSH
61951: CALL_OW 111
// break ;
61955: GO 61959
// end ; end ;
61957: GO 61844
61959: POP
61960: POP
// end ;
61961: GO 61427
61963: POP
61964: POP
// end ;
61965: LD_VAR 0 6
61969: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
61970: LD_INT 0
61972: PPUSH
61973: PPUSH
61974: PPUSH
61975: PPUSH
61976: PPUSH
61977: PPUSH
61978: PPUSH
61979: PPUSH
61980: PPUSH
61981: PPUSH
// result := false ;
61982: LD_ADDR_VAR 0 6
61986: PUSH
61987: LD_INT 0
61989: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61990: LD_VAR 0 1
61994: NOT
61995: PUSH
61996: LD_VAR 0 1
62000: PPUSH
62001: CALL_OW 266
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 1
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: IN
62016: NOT
62017: OR
62018: PUSH
62019: LD_VAR 0 2
62023: NOT
62024: OR
62025: PUSH
62026: LD_VAR 0 5
62030: PUSH
62031: LD_INT 0
62033: PUSH
62034: LD_INT 1
62036: PUSH
62037: LD_INT 2
62039: PUSH
62040: LD_INT 3
62042: PUSH
62043: LD_INT 4
62045: PUSH
62046: LD_INT 5
62048: PUSH
62049: EMPTY
62050: LIST
62051: LIST
62052: LIST
62053: LIST
62054: LIST
62055: LIST
62056: IN
62057: NOT
62058: OR
62059: PUSH
62060: LD_VAR 0 3
62064: PPUSH
62065: LD_VAR 0 4
62069: PPUSH
62070: CALL_OW 488
62074: NOT
62075: OR
62076: IFFALSE 62080
// exit ;
62078: GO 62797
// pom := GetBase ( depot ) ;
62080: LD_ADDR_VAR 0 10
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 274
62094: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62095: LD_ADDR_VAR 0 11
62099: PUSH
62100: LD_VAR 0 2
62104: PPUSH
62105: LD_VAR 0 1
62109: PPUSH
62110: CALL_OW 248
62114: PPUSH
62115: CALL_OW 450
62119: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62120: LD_VAR 0 10
62124: PPUSH
62125: LD_INT 1
62127: PPUSH
62128: CALL_OW 275
62132: PUSH
62133: LD_VAR 0 11
62137: PUSH
62138: LD_INT 1
62140: ARRAY
62141: GREATEREQUAL
62142: PUSH
62143: LD_VAR 0 10
62147: PPUSH
62148: LD_INT 2
62150: PPUSH
62151: CALL_OW 275
62155: PUSH
62156: LD_VAR 0 11
62160: PUSH
62161: LD_INT 2
62163: ARRAY
62164: GREATEREQUAL
62165: AND
62166: PUSH
62167: LD_VAR 0 10
62171: PPUSH
62172: LD_INT 3
62174: PPUSH
62175: CALL_OW 275
62179: PUSH
62180: LD_VAR 0 11
62184: PUSH
62185: LD_INT 3
62187: ARRAY
62188: GREATEREQUAL
62189: AND
62190: NOT
62191: IFFALSE 62195
// exit ;
62193: GO 62797
// if GetBType ( depot ) = b_depot then
62195: LD_VAR 0 1
62199: PPUSH
62200: CALL_OW 266
62204: PUSH
62205: LD_INT 0
62207: EQUAL
62208: IFFALSE 62220
// dist := 28 else
62210: LD_ADDR_VAR 0 14
62214: PUSH
62215: LD_INT 28
62217: ST_TO_ADDR
62218: GO 62228
// dist := 36 ;
62220: LD_ADDR_VAR 0 14
62224: PUSH
62225: LD_INT 36
62227: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62228: LD_VAR 0 1
62232: PPUSH
62233: LD_VAR 0 3
62237: PPUSH
62238: LD_VAR 0 4
62242: PPUSH
62243: CALL_OW 297
62247: PUSH
62248: LD_VAR 0 14
62252: GREATER
62253: IFFALSE 62257
// exit ;
62255: GO 62797
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62257: LD_ADDR_VAR 0 12
62261: PUSH
62262: LD_VAR 0 2
62266: PPUSH
62267: LD_VAR 0 3
62271: PPUSH
62272: LD_VAR 0 4
62276: PPUSH
62277: LD_VAR 0 5
62281: PPUSH
62282: LD_VAR 0 1
62286: PPUSH
62287: CALL_OW 248
62291: PPUSH
62292: LD_INT 0
62294: PPUSH
62295: CALL 62802 0 6
62299: ST_TO_ADDR
// if not hexes then
62300: LD_VAR 0 12
62304: NOT
62305: IFFALSE 62309
// exit ;
62307: GO 62797
// hex := GetHexInfo ( x , y ) ;
62309: LD_ADDR_VAR 0 15
62313: PUSH
62314: LD_VAR 0 3
62318: PPUSH
62319: LD_VAR 0 4
62323: PPUSH
62324: CALL_OW 546
62328: ST_TO_ADDR
// if hex [ 1 ] then
62329: LD_VAR 0 15
62333: PUSH
62334: LD_INT 1
62336: ARRAY
62337: IFFALSE 62341
// exit ;
62339: GO 62797
// height := hex [ 2 ] ;
62341: LD_ADDR_VAR 0 13
62345: PUSH
62346: LD_VAR 0 15
62350: PUSH
62351: LD_INT 2
62353: ARRAY
62354: ST_TO_ADDR
// for i = 1 to hexes do
62355: LD_ADDR_VAR 0 7
62359: PUSH
62360: DOUBLE
62361: LD_INT 1
62363: DEC
62364: ST_TO_ADDR
62365: LD_VAR 0 12
62369: PUSH
62370: FOR_TO
62371: IFFALSE 62701
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62373: LD_VAR 0 12
62377: PUSH
62378: LD_VAR 0 7
62382: ARRAY
62383: PUSH
62384: LD_INT 1
62386: ARRAY
62387: PPUSH
62388: LD_VAR 0 12
62392: PUSH
62393: LD_VAR 0 7
62397: ARRAY
62398: PUSH
62399: LD_INT 2
62401: ARRAY
62402: PPUSH
62403: CALL_OW 488
62407: NOT
62408: PUSH
62409: LD_VAR 0 12
62413: PUSH
62414: LD_VAR 0 7
62418: ARRAY
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PPUSH
62424: LD_VAR 0 12
62428: PUSH
62429: LD_VAR 0 7
62433: ARRAY
62434: PUSH
62435: LD_INT 2
62437: ARRAY
62438: PPUSH
62439: CALL_OW 428
62443: PUSH
62444: LD_INT 0
62446: GREATER
62447: OR
62448: PUSH
62449: LD_VAR 0 12
62453: PUSH
62454: LD_VAR 0 7
62458: ARRAY
62459: PUSH
62460: LD_INT 1
62462: ARRAY
62463: PPUSH
62464: LD_VAR 0 12
62468: PUSH
62469: LD_VAR 0 7
62473: ARRAY
62474: PUSH
62475: LD_INT 2
62477: ARRAY
62478: PPUSH
62479: CALL_OW 351
62483: OR
62484: IFFALSE 62490
// exit ;
62486: POP
62487: POP
62488: GO 62797
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62490: LD_ADDR_VAR 0 8
62494: PUSH
62495: LD_VAR 0 12
62499: PUSH
62500: LD_VAR 0 7
62504: ARRAY
62505: PUSH
62506: LD_INT 1
62508: ARRAY
62509: PPUSH
62510: LD_VAR 0 12
62514: PUSH
62515: LD_VAR 0 7
62519: ARRAY
62520: PUSH
62521: LD_INT 2
62523: ARRAY
62524: PPUSH
62525: CALL_OW 546
62529: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62530: LD_VAR 0 8
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: PUSH
62539: LD_VAR 0 8
62543: PUSH
62544: LD_INT 2
62546: ARRAY
62547: PUSH
62548: LD_VAR 0 13
62552: PUSH
62553: LD_INT 2
62555: PLUS
62556: GREATER
62557: OR
62558: PUSH
62559: LD_VAR 0 8
62563: PUSH
62564: LD_INT 2
62566: ARRAY
62567: PUSH
62568: LD_VAR 0 13
62572: PUSH
62573: LD_INT 2
62575: MINUS
62576: LESS
62577: OR
62578: PUSH
62579: LD_VAR 0 8
62583: PUSH
62584: LD_INT 3
62586: ARRAY
62587: PUSH
62588: LD_INT 0
62590: PUSH
62591: LD_INT 8
62593: PUSH
62594: LD_INT 9
62596: PUSH
62597: LD_INT 10
62599: PUSH
62600: LD_INT 11
62602: PUSH
62603: LD_INT 12
62605: PUSH
62606: LD_INT 13
62608: PUSH
62609: LD_INT 16
62611: PUSH
62612: LD_INT 17
62614: PUSH
62615: LD_INT 18
62617: PUSH
62618: LD_INT 19
62620: PUSH
62621: LD_INT 20
62623: PUSH
62624: LD_INT 21
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: LIST
62641: IN
62642: NOT
62643: OR
62644: PUSH
62645: LD_VAR 0 8
62649: PUSH
62650: LD_INT 5
62652: ARRAY
62653: NOT
62654: OR
62655: PUSH
62656: LD_VAR 0 8
62660: PUSH
62661: LD_INT 6
62663: ARRAY
62664: PUSH
62665: LD_INT 1
62667: PUSH
62668: LD_INT 2
62670: PUSH
62671: LD_INT 7
62673: PUSH
62674: LD_INT 9
62676: PUSH
62677: LD_INT 10
62679: PUSH
62680: LD_INT 11
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: IN
62691: NOT
62692: OR
62693: IFFALSE 62699
// exit ;
62695: POP
62696: POP
62697: GO 62797
// end ;
62699: GO 62370
62701: POP
62702: POP
// side := GetSide ( depot ) ;
62703: LD_ADDR_VAR 0 9
62707: PUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 255
62717: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62718: LD_VAR 0 9
62722: PPUSH
62723: LD_VAR 0 3
62727: PPUSH
62728: LD_VAR 0 4
62732: PPUSH
62733: LD_INT 20
62735: PPUSH
62736: CALL 55451 0 4
62740: PUSH
62741: LD_INT 4
62743: ARRAY
62744: IFFALSE 62748
// exit ;
62746: GO 62797
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62748: LD_VAR 0 2
62752: PUSH
62753: LD_INT 29
62755: PUSH
62756: LD_INT 30
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: IN
62763: PUSH
62764: LD_VAR 0 3
62768: PPUSH
62769: LD_VAR 0 4
62773: PPUSH
62774: LD_VAR 0 9
62778: PPUSH
62779: CALL_OW 440
62783: NOT
62784: AND
62785: IFFALSE 62789
// exit ;
62787: GO 62797
// result := true ;
62789: LD_ADDR_VAR 0 6
62793: PUSH
62794: LD_INT 1
62796: ST_TO_ADDR
// end ;
62797: LD_VAR 0 6
62801: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
62802: LD_INT 0
62804: PPUSH
62805: PPUSH
62806: PPUSH
62807: PPUSH
62808: PPUSH
62809: PPUSH
62810: PPUSH
62811: PPUSH
62812: PPUSH
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
62823: PPUSH
62824: PPUSH
62825: PPUSH
62826: PPUSH
62827: PPUSH
62828: PPUSH
62829: PPUSH
62830: PPUSH
62831: PPUSH
62832: PPUSH
62833: PPUSH
62834: PPUSH
62835: PPUSH
62836: PPUSH
62837: PPUSH
62838: PPUSH
62839: PPUSH
62840: PPUSH
62841: PPUSH
62842: PPUSH
62843: PPUSH
62844: PPUSH
62845: PPUSH
62846: PPUSH
62847: PPUSH
62848: PPUSH
62849: PPUSH
62850: PPUSH
62851: PPUSH
62852: PPUSH
62853: PPUSH
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
62861: PPUSH
// result = [ ] ;
62862: LD_ADDR_VAR 0 7
62866: PUSH
62867: EMPTY
62868: ST_TO_ADDR
// temp_list = [ ] ;
62869: LD_ADDR_VAR 0 9
62873: PUSH
62874: EMPTY
62875: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62876: LD_VAR 0 4
62880: PUSH
62881: LD_INT 0
62883: PUSH
62884: LD_INT 1
62886: PUSH
62887: LD_INT 2
62889: PUSH
62890: LD_INT 3
62892: PUSH
62893: LD_INT 4
62895: PUSH
62896: LD_INT 5
62898: PUSH
62899: EMPTY
62900: LIST
62901: LIST
62902: LIST
62903: LIST
62904: LIST
62905: LIST
62906: IN
62907: NOT
62908: PUSH
62909: LD_VAR 0 1
62913: PUSH
62914: LD_INT 0
62916: PUSH
62917: LD_INT 1
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: IN
62924: PUSH
62925: LD_VAR 0 5
62929: PUSH
62930: LD_INT 1
62932: PUSH
62933: LD_INT 2
62935: PUSH
62936: LD_INT 3
62938: PUSH
62939: EMPTY
62940: LIST
62941: LIST
62942: LIST
62943: IN
62944: NOT
62945: AND
62946: OR
62947: IFFALSE 62951
// exit ;
62949: GO 81342
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62951: LD_VAR 0 1
62955: PUSH
62956: LD_INT 6
62958: PUSH
62959: LD_INT 7
62961: PUSH
62962: LD_INT 8
62964: PUSH
62965: LD_INT 13
62967: PUSH
62968: LD_INT 12
62970: PUSH
62971: LD_INT 15
62973: PUSH
62974: LD_INT 11
62976: PUSH
62977: LD_INT 14
62979: PUSH
62980: LD_INT 10
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: IN
62994: IFFALSE 63004
// btype = b_lab ;
62996: LD_ADDR_VAR 0 1
63000: PUSH
63001: LD_INT 6
63003: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63004: LD_VAR 0 6
63008: PUSH
63009: LD_INT 0
63011: PUSH
63012: LD_INT 1
63014: PUSH
63015: LD_INT 2
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: LIST
63022: IN
63023: NOT
63024: PUSH
63025: LD_VAR 0 1
63029: PUSH
63030: LD_INT 0
63032: PUSH
63033: LD_INT 1
63035: PUSH
63036: LD_INT 2
63038: PUSH
63039: LD_INT 3
63041: PUSH
63042: LD_INT 6
63044: PUSH
63045: LD_INT 36
63047: PUSH
63048: LD_INT 4
63050: PUSH
63051: LD_INT 5
63053: PUSH
63054: LD_INT 31
63056: PUSH
63057: LD_INT 32
63059: PUSH
63060: LD_INT 33
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: LIST
63067: LIST
63068: LIST
63069: LIST
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: IN
63076: NOT
63077: PUSH
63078: LD_VAR 0 6
63082: PUSH
63083: LD_INT 1
63085: EQUAL
63086: AND
63087: OR
63088: PUSH
63089: LD_VAR 0 1
63093: PUSH
63094: LD_INT 2
63096: PUSH
63097: LD_INT 3
63099: PUSH
63100: EMPTY
63101: LIST
63102: LIST
63103: IN
63104: NOT
63105: PUSH
63106: LD_VAR 0 6
63110: PUSH
63111: LD_INT 2
63113: EQUAL
63114: AND
63115: OR
63116: IFFALSE 63126
// mode = 0 ;
63118: LD_ADDR_VAR 0 6
63122: PUSH
63123: LD_INT 0
63125: ST_TO_ADDR
// case mode of 0 :
63126: LD_VAR 0 6
63130: PUSH
63131: LD_INT 0
63133: DOUBLE
63134: EQUAL
63135: IFTRUE 63139
63137: GO 74592
63139: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63140: LD_ADDR_VAR 0 11
63144: PUSH
63145: LD_INT 0
63147: PUSH
63148: LD_INT 0
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 0
63157: PUSH
63158: LD_INT 1
63160: NEG
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PUSH
63166: LD_INT 1
63168: PUSH
63169: LD_INT 0
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: PUSH
63176: LD_INT 1
63178: PUSH
63179: LD_INT 1
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: LD_INT 0
63188: PUSH
63189: LD_INT 1
63191: PUSH
63192: EMPTY
63193: LIST
63194: LIST
63195: PUSH
63196: LD_INT 1
63198: NEG
63199: PUSH
63200: LD_INT 0
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: LD_INT 1
63209: NEG
63210: PUSH
63211: LD_INT 1
63213: NEG
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PUSH
63219: LD_INT 1
63221: NEG
63222: PUSH
63223: LD_INT 2
63225: NEG
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 0
63233: PUSH
63234: LD_INT 2
63236: NEG
63237: PUSH
63238: EMPTY
63239: LIST
63240: LIST
63241: PUSH
63242: LD_INT 1
63244: PUSH
63245: LD_INT 1
63247: NEG
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: PUSH
63253: LD_INT 1
63255: PUSH
63256: LD_INT 2
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: LD_INT 0
63265: PUSH
63266: LD_INT 2
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PUSH
63273: LD_INT 1
63275: NEG
63276: PUSH
63277: LD_INT 1
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 1
63286: PUSH
63287: LD_INT 3
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: PUSH
63294: LD_INT 0
63296: PUSH
63297: LD_INT 3
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_INT 1
63306: NEG
63307: PUSH
63308: LD_INT 2
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: LIST
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63333: LD_ADDR_VAR 0 12
63337: PUSH
63338: LD_INT 0
63340: PUSH
63341: LD_INT 0
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 0
63350: PUSH
63351: LD_INT 1
63353: NEG
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 1
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 1
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 0
63381: PUSH
63382: LD_INT 1
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 1
63391: NEG
63392: PUSH
63393: LD_INT 0
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: PUSH
63400: LD_INT 1
63402: NEG
63403: PUSH
63404: LD_INT 1
63406: NEG
63407: PUSH
63408: EMPTY
63409: LIST
63410: LIST
63411: PUSH
63412: LD_INT 1
63414: PUSH
63415: LD_INT 1
63417: NEG
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: PUSH
63423: LD_INT 2
63425: PUSH
63426: LD_INT 0
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 2
63435: PUSH
63436: LD_INT 1
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: LD_INT 1
63445: NEG
63446: PUSH
63447: LD_INT 1
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PUSH
63454: LD_INT 2
63456: NEG
63457: PUSH
63458: LD_INT 0
63460: PUSH
63461: EMPTY
63462: LIST
63463: LIST
63464: PUSH
63465: LD_INT 2
63467: NEG
63468: PUSH
63469: LD_INT 1
63471: NEG
63472: PUSH
63473: EMPTY
63474: LIST
63475: LIST
63476: PUSH
63477: LD_INT 2
63479: NEG
63480: PUSH
63481: LD_INT 1
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 3
63490: NEG
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PUSH
63499: LD_INT 3
63501: NEG
63502: PUSH
63503: LD_INT 1
63505: NEG
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: LIST
63519: LIST
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63529: LD_ADDR_VAR 0 13
63533: PUSH
63534: LD_INT 0
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 0
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 1
63557: PUSH
63558: LD_INT 0
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PUSH
63565: LD_INT 1
63567: PUSH
63568: LD_INT 1
63570: PUSH
63571: EMPTY
63572: LIST
63573: LIST
63574: PUSH
63575: LD_INT 0
63577: PUSH
63578: LD_INT 1
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: PUSH
63585: LD_INT 1
63587: NEG
63588: PUSH
63589: LD_INT 0
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: LD_INT 1
63598: NEG
63599: PUSH
63600: LD_INT 1
63602: NEG
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PUSH
63608: LD_INT 1
63610: NEG
63611: PUSH
63612: LD_INT 2
63614: NEG
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 2
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 2
63632: PUSH
63633: LD_INT 2
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: LD_INT 1
63642: PUSH
63643: LD_INT 2
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: PUSH
63650: LD_INT 2
63652: NEG
63653: PUSH
63654: LD_INT 1
63656: NEG
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 2
63664: NEG
63665: PUSH
63666: LD_INT 2
63668: NEG
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 2
63676: NEG
63677: PUSH
63678: LD_INT 3
63680: NEG
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 3
63688: NEG
63689: PUSH
63690: LD_INT 2
63692: NEG
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 3
63700: NEG
63701: PUSH
63702: LD_INT 3
63704: NEG
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63728: LD_ADDR_VAR 0 14
63732: PUSH
63733: LD_INT 0
63735: PUSH
63736: LD_INT 0
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 0
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: LD_INT 1
63756: PUSH
63757: LD_INT 0
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PUSH
63764: LD_INT 1
63766: PUSH
63767: LD_INT 1
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 0
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: EMPTY
63781: LIST
63782: LIST
63783: PUSH
63784: LD_INT 1
63786: NEG
63787: PUSH
63788: LD_INT 0
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PUSH
63795: LD_INT 1
63797: NEG
63798: PUSH
63799: LD_INT 1
63801: NEG
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 1
63809: NEG
63810: PUSH
63811: LD_INT 2
63813: NEG
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 0
63821: PUSH
63822: LD_INT 2
63824: NEG
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 1
63832: PUSH
63833: LD_INT 1
63835: NEG
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 1
63843: PUSH
63844: LD_INT 2
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 0
63853: PUSH
63854: LD_INT 2
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 1
63863: NEG
63864: PUSH
63865: LD_INT 1
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PUSH
63872: LD_INT 1
63874: NEG
63875: PUSH
63876: LD_INT 3
63878: NEG
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 0
63886: PUSH
63887: LD_INT 3
63889: NEG
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: PUSH
63895: LD_INT 1
63897: PUSH
63898: LD_INT 2
63900: NEG
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: LIST
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63924: LD_ADDR_VAR 0 15
63928: PUSH
63929: LD_INT 0
63931: PUSH
63932: LD_INT 0
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 0
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 1
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 1
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 0
63972: PUSH
63973: LD_INT 1
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 1
63982: NEG
63983: PUSH
63984: LD_INT 0
63986: PUSH
63987: EMPTY
63988: LIST
63989: LIST
63990: PUSH
63991: LD_INT 1
63993: NEG
63994: PUSH
63995: LD_INT 1
63997: NEG
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 1
64005: PUSH
64006: LD_INT 1
64008: NEG
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: LD_INT 2
64016: PUSH
64017: LD_INT 0
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 2
64026: PUSH
64027: LD_INT 1
64029: PUSH
64030: EMPTY
64031: LIST
64032: LIST
64033: PUSH
64034: LD_INT 1
64036: NEG
64037: PUSH
64038: LD_INT 1
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: PUSH
64045: LD_INT 2
64047: NEG
64048: PUSH
64049: LD_INT 0
64051: PUSH
64052: EMPTY
64053: LIST
64054: LIST
64055: PUSH
64056: LD_INT 2
64058: NEG
64059: PUSH
64060: LD_INT 1
64062: NEG
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 2
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 3
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 3
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64117: LD_ADDR_VAR 0 16
64121: PUSH
64122: LD_INT 0
64124: PUSH
64125: LD_INT 0
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 0
64134: PUSH
64135: LD_INT 1
64137: NEG
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 1
64145: PUSH
64146: LD_INT 0
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 1
64155: PUSH
64156: LD_INT 1
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 0
64165: PUSH
64166: LD_INT 1
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PUSH
64173: LD_INT 1
64175: NEG
64176: PUSH
64177: LD_INT 0
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 1
64186: NEG
64187: PUSH
64188: LD_INT 1
64190: NEG
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: LD_INT 2
64202: NEG
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 2
64210: PUSH
64211: LD_INT 1
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 2
64220: PUSH
64221: LD_INT 2
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 1
64230: PUSH
64231: LD_INT 2
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 2
64240: NEG
64241: PUSH
64242: LD_INT 1
64244: NEG
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 2
64252: NEG
64253: PUSH
64254: LD_INT 2
64256: NEG
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: PUSH
64262: LD_INT 3
64264: PUSH
64265: LD_INT 2
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 3
64274: PUSH
64275: LD_INT 3
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: PUSH
64282: LD_INT 2
64284: PUSH
64285: LD_INT 3
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64310: LD_ADDR_VAR 0 17
64314: PUSH
64315: LD_INT 0
64317: PUSH
64318: LD_INT 0
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: LD_INT 1
64330: NEG
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 1
64338: PUSH
64339: LD_INT 0
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: PUSH
64346: LD_INT 1
64348: PUSH
64349: LD_INT 1
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 0
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: LD_INT 1
64368: NEG
64369: PUSH
64370: LD_INT 0
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 1
64379: NEG
64380: PUSH
64381: LD_INT 1
64383: NEG
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: NEG
64392: PUSH
64393: LD_INT 2
64395: NEG
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 0
64403: PUSH
64404: LD_INT 2
64406: NEG
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: PUSH
64412: LD_INT 1
64414: PUSH
64415: LD_INT 1
64417: NEG
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 2
64425: PUSH
64426: LD_INT 0
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 2
64435: PUSH
64436: LD_INT 1
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: PUSH
64446: LD_INT 2
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 1
64455: PUSH
64456: LD_INT 2
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 0
64465: PUSH
64466: LD_INT 2
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: LD_INT 1
64475: NEG
64476: PUSH
64477: LD_INT 1
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: PUSH
64484: LD_INT 2
64486: NEG
64487: PUSH
64488: LD_INT 0
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: PUSH
64495: LD_INT 2
64497: NEG
64498: PUSH
64499: LD_INT 1
64501: NEG
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: LD_INT 2
64509: NEG
64510: PUSH
64511: LD_INT 2
64513: NEG
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: LIST
64535: LIST
64536: LIST
64537: LIST
64538: LIST
64539: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64540: LD_ADDR_VAR 0 18
64544: PUSH
64545: LD_INT 0
64547: PUSH
64548: LD_INT 0
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 0
64557: PUSH
64558: LD_INT 1
64560: NEG
64561: PUSH
64562: EMPTY
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 1
64568: PUSH
64569: LD_INT 0
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: PUSH
64576: LD_INT 1
64578: PUSH
64579: LD_INT 1
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 0
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 1
64598: NEG
64599: PUSH
64600: LD_INT 0
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 1
64609: NEG
64610: PUSH
64611: LD_INT 1
64613: NEG
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 1
64621: NEG
64622: PUSH
64623: LD_INT 2
64625: NEG
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 0
64633: PUSH
64634: LD_INT 2
64636: NEG
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: PUSH
64642: LD_INT 1
64644: PUSH
64645: LD_INT 1
64647: NEG
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: PUSH
64653: LD_INT 2
64655: PUSH
64656: LD_INT 0
64658: PUSH
64659: EMPTY
64660: LIST
64661: LIST
64662: PUSH
64663: LD_INT 2
64665: PUSH
64666: LD_INT 1
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: PUSH
64676: LD_INT 2
64678: PUSH
64679: EMPTY
64680: LIST
64681: LIST
64682: PUSH
64683: LD_INT 1
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: LD_INT 2
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 1
64705: NEG
64706: PUSH
64707: LD_INT 1
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: PUSH
64714: LD_INT 2
64716: NEG
64717: PUSH
64718: LD_INT 0
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 2
64727: NEG
64728: PUSH
64729: LD_INT 1
64731: NEG
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: LD_INT 2
64739: NEG
64740: PUSH
64741: LD_INT 2
64743: NEG
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64770: LD_ADDR_VAR 0 19
64774: PUSH
64775: LD_INT 0
64777: PUSH
64778: LD_INT 0
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 0
64787: PUSH
64788: LD_INT 1
64790: NEG
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PUSH
64796: LD_INT 1
64798: PUSH
64799: LD_INT 0
64801: PUSH
64802: EMPTY
64803: LIST
64804: LIST
64805: PUSH
64806: LD_INT 1
64808: PUSH
64809: LD_INT 1
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PUSH
64816: LD_INT 0
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 1
64828: NEG
64829: PUSH
64830: LD_INT 0
64832: PUSH
64833: EMPTY
64834: LIST
64835: LIST
64836: PUSH
64837: LD_INT 1
64839: NEG
64840: PUSH
64841: LD_INT 1
64843: NEG
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: NEG
64852: PUSH
64853: LD_INT 2
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 0
64863: PUSH
64864: LD_INT 2
64866: NEG
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 1
64874: PUSH
64875: LD_INT 1
64877: NEG
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 2
64885: PUSH
64886: LD_INT 0
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 2
64895: PUSH
64896: LD_INT 1
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 1
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 0
64925: PUSH
64926: LD_INT 2
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 1
64935: NEG
64936: PUSH
64937: LD_INT 1
64939: PUSH
64940: EMPTY
64941: LIST
64942: LIST
64943: PUSH
64944: LD_INT 2
64946: NEG
64947: PUSH
64948: LD_INT 0
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: PUSH
64955: LD_INT 2
64957: NEG
64958: PUSH
64959: LD_INT 1
64961: NEG
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 2
64969: NEG
64970: PUSH
64971: LD_INT 2
64973: NEG
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65000: LD_ADDR_VAR 0 20
65004: PUSH
65005: LD_INT 0
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 0
65017: PUSH
65018: LD_INT 1
65020: NEG
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: LD_INT 0
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PUSH
65036: LD_INT 1
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 0
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 1
65058: NEG
65059: PUSH
65060: LD_INT 0
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 1
65069: NEG
65070: PUSH
65071: LD_INT 1
65073: NEG
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 1
65081: NEG
65082: PUSH
65083: LD_INT 2
65085: NEG
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 0
65093: PUSH
65094: LD_INT 2
65096: NEG
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: LD_INT 1
65104: PUSH
65105: LD_INT 1
65107: NEG
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PUSH
65113: LD_INT 2
65115: PUSH
65116: LD_INT 0
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: PUSH
65123: LD_INT 2
65125: PUSH
65126: LD_INT 1
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: PUSH
65136: LD_INT 2
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: LD_INT 1
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: LD_INT 0
65155: PUSH
65156: LD_INT 2
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: PUSH
65163: LD_INT 1
65165: NEG
65166: PUSH
65167: LD_INT 1
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 2
65176: NEG
65177: PUSH
65178: LD_INT 0
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 2
65187: NEG
65188: PUSH
65189: LD_INT 1
65191: NEG
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 2
65199: NEG
65200: PUSH
65201: LD_INT 2
65203: NEG
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65230: LD_ADDR_VAR 0 21
65234: PUSH
65235: LD_INT 0
65237: PUSH
65238: LD_INT 0
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 0
65247: PUSH
65248: LD_INT 1
65250: NEG
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: LD_INT 1
65258: PUSH
65259: LD_INT 0
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PUSH
65266: LD_INT 1
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: EMPTY
65273: LIST
65274: LIST
65275: PUSH
65276: LD_INT 0
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: PUSH
65286: LD_INT 1
65288: NEG
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 1
65299: NEG
65300: PUSH
65301: LD_INT 1
65303: NEG
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: LD_INT 2
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: LD_INT 2
65326: NEG
65327: PUSH
65328: EMPTY
65329: LIST
65330: LIST
65331: PUSH
65332: LD_INT 1
65334: PUSH
65335: LD_INT 1
65337: NEG
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PUSH
65343: LD_INT 2
65345: PUSH
65346: LD_INT 0
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: PUSH
65353: LD_INT 2
65355: PUSH
65356: LD_INT 1
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: PUSH
65366: LD_INT 2
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PUSH
65373: LD_INT 1
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 0
65385: PUSH
65386: LD_INT 2
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 1
65395: NEG
65396: PUSH
65397: LD_INT 1
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 2
65406: NEG
65407: PUSH
65408: LD_INT 0
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 2
65417: NEG
65418: PUSH
65419: LD_INT 1
65421: NEG
65422: PUSH
65423: EMPTY
65424: LIST
65425: LIST
65426: PUSH
65427: LD_INT 2
65429: NEG
65430: PUSH
65431: LD_INT 2
65433: NEG
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65460: LD_ADDR_VAR 0 22
65464: PUSH
65465: LD_INT 0
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 0
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: LD_INT 1
65488: PUSH
65489: LD_INT 0
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: PUSH
65496: LD_INT 1
65498: PUSH
65499: LD_INT 1
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 0
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: NEG
65530: PUSH
65531: LD_INT 1
65533: NEG
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: NEG
65542: PUSH
65543: LD_INT 2
65545: NEG
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 0
65553: PUSH
65554: LD_INT 2
65556: NEG
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 1
65564: PUSH
65565: LD_INT 1
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 2
65575: PUSH
65576: LD_INT 0
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 2
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: PUSH
65596: LD_INT 2
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 1
65605: PUSH
65606: LD_INT 2
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: LD_INT 0
65615: PUSH
65616: LD_INT 2
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 1
65625: NEG
65626: PUSH
65627: LD_INT 1
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 2
65636: NEG
65637: PUSH
65638: LD_INT 0
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 2
65647: NEG
65648: PUSH
65649: LD_INT 1
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 2
65659: NEG
65660: PUSH
65661: LD_INT 2
65663: NEG
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65690: LD_ADDR_VAR 0 23
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: LD_INT 0
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 0
65707: PUSH
65708: LD_INT 1
65710: NEG
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PUSH
65716: LD_INT 1
65718: PUSH
65719: LD_INT 0
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PUSH
65726: LD_INT 1
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 0
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 1
65748: NEG
65749: PUSH
65750: LD_INT 0
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: LD_INT 1
65763: NEG
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: LD_INT 2
65775: NEG
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 0
65783: PUSH
65784: LD_INT 2
65786: NEG
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 1
65794: PUSH
65795: LD_INT 1
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 2
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: PUSH
65816: LD_INT 1
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 0
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 1
65855: NEG
65856: PUSH
65857: LD_INT 1
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: PUSH
65864: LD_INT 2
65866: NEG
65867: PUSH
65868: LD_INT 0
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 2
65877: NEG
65878: PUSH
65879: LD_INT 1
65881: NEG
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 2
65889: NEG
65890: PUSH
65891: LD_INT 2
65893: NEG
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PUSH
65899: LD_INT 2
65901: NEG
65902: PUSH
65903: LD_INT 3
65905: NEG
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: NEG
65914: PUSH
65915: LD_INT 3
65917: NEG
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 1
65925: PUSH
65926: LD_INT 2
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 2
65936: PUSH
65937: LD_INT 1
65939: NEG
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65970: LD_ADDR_VAR 0 24
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 0
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 0
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 1
66028: NEG
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: LD_INT 1
66039: NEG
66040: PUSH
66041: LD_INT 1
66043: NEG
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: NEG
66052: PUSH
66053: LD_INT 2
66055: NEG
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 0
66063: PUSH
66064: LD_INT 2
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: PUSH
66075: LD_INT 1
66077: NEG
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 2
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: PUSH
66096: LD_INT 1
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: PUSH
66106: LD_INT 2
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: LD_INT 2
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 0
66125: PUSH
66126: LD_INT 2
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: LD_INT 1
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: LD_INT 2
66146: NEG
66147: PUSH
66148: LD_INT 0
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 2
66157: NEG
66158: PUSH
66159: LD_INT 1
66161: NEG
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: LD_INT 2
66169: NEG
66170: PUSH
66171: LD_INT 2
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 2
66184: NEG
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 1
66195: NEG
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 3
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 3
66213: PUSH
66214: LD_INT 2
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66246: LD_ADDR_VAR 0 25
66250: PUSH
66251: LD_INT 0
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 0
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 1
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 1
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 0
66294: PUSH
66295: LD_INT 1
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 1
66304: NEG
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 1
66315: NEG
66316: PUSH
66317: LD_INT 1
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 1
66327: NEG
66328: PUSH
66329: LD_INT 2
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 0
66339: PUSH
66340: LD_INT 2
66342: NEG
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 1
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: LD_INT 0
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: LD_INT 1
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: LD_INT 2
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 0
66401: PUSH
66402: LD_INT 2
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 1
66411: NEG
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: NEG
66423: PUSH
66424: LD_INT 0
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 2
66433: NEG
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 2
66445: NEG
66446: PUSH
66447: LD_INT 2
66449: NEG
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 3
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 3
66467: PUSH
66468: LD_INT 2
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 2
66477: PUSH
66478: LD_INT 3
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 1
66487: PUSH
66488: LD_INT 3
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66520: LD_ADDR_VAR 0 26
66524: PUSH
66525: LD_INT 0
66527: PUSH
66528: LD_INT 0
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 1
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 1
66558: PUSH
66559: LD_INT 1
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: LD_INT 1
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 1
66578: NEG
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: NEG
66590: PUSH
66591: LD_INT 1
66593: NEG
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: NEG
66602: PUSH
66603: LD_INT 2
66605: NEG
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 0
66613: PUSH
66614: LD_INT 2
66616: NEG
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: PUSH
66625: LD_INT 1
66627: NEG
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 2
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 2
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: LD_INT 2
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 0
66675: PUSH
66676: LD_INT 2
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: NEG
66686: PUSH
66687: LD_INT 1
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 2
66696: NEG
66697: PUSH
66698: LD_INT 0
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 2
66707: NEG
66708: PUSH
66709: LD_INT 1
66711: NEG
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 2
66719: NEG
66720: PUSH
66721: LD_INT 2
66723: NEG
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 2
66731: PUSH
66732: LD_INT 3
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 1
66741: PUSH
66742: LD_INT 3
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 1
66751: NEG
66752: PUSH
66753: LD_INT 2
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: PUSH
66760: LD_INT 2
66762: NEG
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66796: LD_ADDR_VAR 0 27
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 0
66813: PUSH
66814: LD_INT 1
66816: NEG
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 1
66824: PUSH
66825: LD_INT 0
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 1
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 0
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: EMPTY
66849: LIST
66850: LIST
66851: PUSH
66852: LD_INT 1
66854: NEG
66855: PUSH
66856: LD_INT 0
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 1
66865: NEG
66866: PUSH
66867: LD_INT 1
66869: NEG
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: NEG
66878: PUSH
66879: LD_INT 2
66881: NEG
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 0
66889: PUSH
66890: LD_INT 2
66892: NEG
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 1
66900: PUSH
66901: LD_INT 1
66903: NEG
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 0
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 2
66921: PUSH
66922: LD_INT 1
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: PUSH
66932: LD_INT 2
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 1
66941: PUSH
66942: LD_INT 2
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 0
66951: PUSH
66952: LD_INT 2
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 1
66961: NEG
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: LD_INT 2
66972: NEG
66973: PUSH
66974: LD_INT 0
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: PUSH
66981: LD_INT 2
66983: NEG
66984: PUSH
66985: LD_INT 1
66987: NEG
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 2
66995: NEG
66996: PUSH
66997: LD_INT 2
66999: NEG
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: NEG
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 2
67018: NEG
67019: PUSH
67020: LD_INT 1
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 3
67029: NEG
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 3
67041: NEG
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67076: LD_ADDR_VAR 0 28
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: LD_INT 1
67096: NEG
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 1
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 1
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 1
67145: NEG
67146: PUSH
67147: LD_INT 1
67149: NEG
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 1
67157: NEG
67158: PUSH
67159: LD_INT 2
67161: NEG
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 2
67172: NEG
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: LD_INT 1
67183: NEG
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 2
67201: PUSH
67202: LD_INT 1
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: PUSH
67212: LD_INT 2
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: LD_INT 2
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 0
67231: PUSH
67232: LD_INT 2
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: PUSH
67239: LD_INT 1
67241: NEG
67242: PUSH
67243: LD_INT 1
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: PUSH
67250: LD_INT 2
67252: NEG
67253: PUSH
67254: LD_INT 0
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: LD_INT 1
67267: NEG
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: LD_INT 2
67279: NEG
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 2
67287: NEG
67288: PUSH
67289: LD_INT 3
67291: NEG
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PUSH
67301: LD_INT 3
67303: NEG
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 3
67311: NEG
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 3
67323: NEG
67324: PUSH
67325: LD_INT 2
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67358: LD_ADDR_VAR 0 29
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 0
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: LD_INT 0
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: LD_INT 1
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: LD_INT 0
67406: PUSH
67407: LD_INT 1
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 1
67416: NEG
67417: PUSH
67418: LD_INT 0
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 1
67427: NEG
67428: PUSH
67429: LD_INT 1
67431: NEG
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 1
67439: NEG
67440: PUSH
67441: LD_INT 2
67443: NEG
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 2
67454: NEG
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 1
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 2
67473: PUSH
67474: LD_INT 0
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 2
67483: PUSH
67484: LD_INT 1
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 1
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 0
67503: PUSH
67504: LD_INT 2
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: NEG
67514: PUSH
67515: LD_INT 1
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 2
67524: NEG
67525: PUSH
67526: LD_INT 1
67528: NEG
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 2
67536: NEG
67537: PUSH
67538: LD_INT 2
67540: NEG
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 2
67548: NEG
67549: PUSH
67550: LD_INT 3
67552: NEG
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 2
67560: PUSH
67561: LD_INT 1
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 3
67571: PUSH
67572: LD_INT 1
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 1
67581: PUSH
67582: LD_INT 3
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 1
67591: NEG
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 3
67602: NEG
67603: PUSH
67604: LD_INT 2
67606: NEG
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67637: LD_ADDR_VAR 0 30
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 0
67654: PUSH
67655: LD_INT 1
67657: NEG
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: LD_INT 0
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 1
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: NEG
67696: PUSH
67697: LD_INT 0
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 1
67706: NEG
67707: PUSH
67708: LD_INT 1
67710: NEG
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: NEG
67719: PUSH
67720: LD_INT 2
67722: NEG
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 0
67730: PUSH
67731: LD_INT 2
67733: NEG
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 1
67741: PUSH
67742: LD_INT 1
67744: NEG
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: PUSH
67750: LD_INT 2
67752: PUSH
67753: LD_INT 0
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: PUSH
67763: LD_INT 1
67765: PUSH
67766: EMPTY
67767: LIST
67768: LIST
67769: PUSH
67770: LD_INT 2
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 1
67792: NEG
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: NEG
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: LD_INT 1
67818: NEG
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: NEG
67827: PUSH
67828: LD_INT 3
67830: NEG
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 1
67838: PUSH
67839: LD_INT 2
67841: NEG
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 3
67849: PUSH
67850: LD_INT 2
67852: PUSH
67853: EMPTY
67854: LIST
67855: LIST
67856: PUSH
67857: LD_INT 2
67859: PUSH
67860: LD_INT 3
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 2
67869: NEG
67870: PUSH
67871: LD_INT 1
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 3
67880: NEG
67881: PUSH
67882: LD_INT 1
67884: NEG
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67915: LD_ADDR_VAR 0 31
67919: PUSH
67920: LD_INT 0
67922: PUSH
67923: LD_INT 0
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 0
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 1
67943: PUSH
67944: LD_INT 0
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 1
67953: PUSH
67954: LD_INT 1
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 0
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: NEG
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: NEG
67985: PUSH
67986: LD_INT 1
67988: NEG
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: NEG
67997: PUSH
67998: LD_INT 2
68000: NEG
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 2
68019: PUSH
68020: LD_INT 0
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 2
68029: PUSH
68030: LD_INT 1
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 2
68039: PUSH
68040: LD_INT 2
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: LD_INT 1
68049: PUSH
68050: LD_INT 2
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 0
68059: PUSH
68060: LD_INT 2
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 2
68080: NEG
68081: PUSH
68082: LD_INT 1
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 2
68092: NEG
68093: PUSH
68094: LD_INT 2
68096: NEG
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 2
68104: NEG
68105: PUSH
68106: LD_INT 3
68108: NEG
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: PUSH
68117: LD_INT 1
68119: NEG
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: LD_INT 1
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: LD_INT 3
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 3
68158: NEG
68159: PUSH
68160: LD_INT 2
68162: NEG
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68193: LD_ADDR_VAR 0 32
68197: PUSH
68198: LD_INT 0
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 1
68213: NEG
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PUSH
68219: LD_INT 1
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 0
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 0
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 1
68262: NEG
68263: PUSH
68264: LD_INT 1
68266: NEG
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 1
68274: NEG
68275: PUSH
68276: LD_INT 2
68278: NEG
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 0
68286: PUSH
68287: LD_INT 2
68289: NEG
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: PUSH
68298: LD_INT 1
68300: NEG
68301: PUSH
68302: EMPTY
68303: LIST
68304: LIST
68305: PUSH
68306: LD_INT 2
68308: PUSH
68309: LD_INT 1
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: LD_INT 2
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: LD_INT 2
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: NEG
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 2
68359: NEG
68360: PUSH
68361: LD_INT 0
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 2
68370: NEG
68371: PUSH
68372: LD_INT 1
68374: NEG
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PUSH
68380: LD_INT 1
68382: NEG
68383: PUSH
68384: LD_INT 3
68386: NEG
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 1
68394: PUSH
68395: LD_INT 2
68397: NEG
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 3
68405: PUSH
68406: LD_INT 2
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: PUSH
68416: LD_INT 3
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: NEG
68426: PUSH
68427: LD_INT 1
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 3
68436: NEG
68437: PUSH
68438: LD_INT 1
68440: NEG
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: LIST
68470: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68471: LD_ADDR_VAR 0 33
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: LD_INT 0
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: LD_INT 0
68519: PUSH
68520: LD_INT 1
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: LD_INT 0
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: LD_INT 1
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 1
68552: NEG
68553: PUSH
68554: LD_INT 2
68556: NEG
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: LD_INT 1
68567: NEG
68568: PUSH
68569: EMPTY
68570: LIST
68571: LIST
68572: PUSH
68573: LD_INT 2
68575: PUSH
68576: LD_INT 0
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: PUSH
68586: LD_INT 1
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: LD_INT 1
68595: PUSH
68596: LD_INT 2
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: LD_INT 2
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: LD_INT 1
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 2
68626: NEG
68627: PUSH
68628: LD_INT 0
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 2
68637: NEG
68638: PUSH
68639: LD_INT 1
68641: NEG
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 2
68649: NEG
68650: PUSH
68651: LD_INT 2
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: LD_INT 3
68665: NEG
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: LD_INT 1
68676: NEG
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 3
68684: PUSH
68685: LD_INT 1
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: PUSH
68695: LD_INT 3
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 3
68715: NEG
68716: PUSH
68717: LD_INT 2
68719: NEG
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68750: LD_ADDR_VAR 0 34
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: LD_INT 1
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 0
68798: PUSH
68799: LD_INT 1
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: NEG
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 2
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 2
68846: NEG
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 1
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: LD_INT 2
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 2
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 1
68895: NEG
68896: PUSH
68897: LD_INT 1
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: NEG
68907: PUSH
68908: LD_INT 0
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 2
68917: NEG
68918: PUSH
68919: LD_INT 1
68921: NEG
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 2
68929: NEG
68930: PUSH
68931: LD_INT 2
68933: NEG
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 3
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 2
68956: NEG
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 3
68964: PUSH
68965: LD_INT 2
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 3
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 2
68984: NEG
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 3
68995: NEG
68996: PUSH
68997: LD_INT 1
68999: NEG
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: LIST
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69030: LD_ADDR_VAR 0 35
69034: PUSH
69035: LD_INT 0
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 0
69047: PUSH
69048: LD_INT 1
69050: NEG
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 1
69068: PUSH
69069: LD_INT 1
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 0
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: NEG
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 2
69111: PUSH
69112: LD_INT 1
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: LD_INT 1
69125: NEG
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69142: LD_ADDR_VAR 0 36
69146: PUSH
69147: LD_INT 0
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 0
69159: PUSH
69160: LD_INT 1
69162: NEG
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: PUSH
69171: LD_INT 0
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PUSH
69178: LD_INT 1
69180: PUSH
69181: LD_INT 1
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 0
69190: PUSH
69191: LD_INT 1
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: NEG
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: LD_INT 1
69215: NEG
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: NEG
69224: PUSH
69225: LD_INT 2
69227: NEG
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 1
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69254: LD_ADDR_VAR 0 37
69258: PUSH
69259: LD_INT 0
69261: PUSH
69262: LD_INT 0
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 0
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 1
69282: PUSH
69283: LD_INT 0
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: PUSH
69293: LD_INT 1
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 0
69302: PUSH
69303: LD_INT 1
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: LD_INT 0
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: LD_INT 1
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69366: LD_ADDR_VAR 0 38
69370: PUSH
69371: LD_INT 0
69373: PUSH
69374: LD_INT 0
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 0
69383: PUSH
69384: LD_INT 1
69386: NEG
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: PUSH
69392: LD_INT 1
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: LD_INT 1
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: LD_INT 1
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: NEG
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 1
69435: NEG
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: PUSH
69445: LD_INT 2
69447: PUSH
69448: LD_INT 1
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 2
69457: NEG
69458: PUSH
69459: LD_INT 1
69461: NEG
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69478: LD_ADDR_VAR 0 39
69482: PUSH
69483: LD_INT 0
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 0
69495: PUSH
69496: LD_INT 1
69498: NEG
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: LD_INT 1
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: LD_INT 1
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 1
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: LD_INT 0
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: LD_INT 1
69551: NEG
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: LD_INT 2
69563: NEG
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 1
69571: PUSH
69572: LD_INT 2
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69590: LD_ADDR_VAR 0 40
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 0
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: LD_INT 0
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 1
69628: PUSH
69629: LD_INT 1
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: LD_INT 0
69638: PUSH
69639: LD_INT 1
69641: PUSH
69642: EMPTY
69643: LIST
69644: LIST
69645: PUSH
69646: LD_INT 1
69648: NEG
69649: PUSH
69650: LD_INT 0
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 1
69659: NEG
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: LD_INT 1
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69702: LD_ADDR_VAR 0 41
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: LD_INT 0
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 0
69719: PUSH
69720: LD_INT 1
69722: NEG
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 1
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: LD_INT 1
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 1
69760: NEG
69761: PUSH
69762: LD_INT 0
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: LD_INT 1
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 1
69783: NEG
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 1
69795: PUSH
69796: LD_INT 1
69798: NEG
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 2
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: PUSH
69817: LD_INT 1
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 2
69826: PUSH
69827: LD_INT 2
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 1
69836: PUSH
69837: LD_INT 2
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: NEG
69847: PUSH
69848: LD_INT 1
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: NEG
69858: PUSH
69859: LD_INT 0
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 2
69868: NEG
69869: PUSH
69870: LD_INT 1
69872: NEG
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: LD_INT 2
69880: NEG
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 2
69892: NEG
69893: PUSH
69894: LD_INT 3
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 2
69904: PUSH
69905: LD_INT 1
69907: NEG
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 3
69915: PUSH
69916: LD_INT 0
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 3
69925: PUSH
69926: LD_INT 1
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: PUSH
69936: LD_INT 2
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 3
69945: PUSH
69946: LD_INT 3
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 2
69955: PUSH
69956: LD_INT 3
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 2
69965: NEG
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 3
69976: NEG
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 3
69987: NEG
69988: PUSH
69989: LD_INT 1
69991: NEG
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 3
69999: NEG
70000: PUSH
70001: LD_INT 2
70003: NEG
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 3
70011: NEG
70012: PUSH
70013: LD_INT 3
70015: NEG
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70052: LD_ADDR_VAR 0 42
70056: PUSH
70057: LD_INT 0
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 0
70069: PUSH
70070: LD_INT 1
70072: NEG
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 1
70080: PUSH
70081: LD_INT 0
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 0
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 1
70110: NEG
70111: PUSH
70112: LD_INT 0
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 1
70121: NEG
70122: PUSH
70123: LD_INT 1
70125: NEG
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 1
70133: NEG
70134: PUSH
70135: LD_INT 2
70137: NEG
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 0
70145: PUSH
70146: LD_INT 2
70148: NEG
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 1
70156: PUSH
70157: LD_INT 1
70159: NEG
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 2
70167: PUSH
70168: LD_INT 1
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 2
70177: PUSH
70178: LD_INT 2
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 1
70187: PUSH
70188: LD_INT 2
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 0
70197: PUSH
70198: LD_INT 2
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 1
70207: NEG
70208: PUSH
70209: LD_INT 1
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 2
70218: NEG
70219: PUSH
70220: LD_INT 1
70222: NEG
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 2
70230: NEG
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 2
70242: NEG
70243: PUSH
70244: LD_INT 3
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: LD_INT 3
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 0
70266: PUSH
70267: LD_INT 3
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: PUSH
70278: LD_INT 2
70280: NEG
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 3
70288: PUSH
70289: LD_INT 2
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 3
70298: PUSH
70299: LD_INT 3
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 2
70308: PUSH
70309: LD_INT 3
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 3
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 3
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: LD_INT 2
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 3
70349: NEG
70350: PUSH
70351: LD_INT 2
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 3
70361: NEG
70362: PUSH
70363: LD_INT 3
70365: NEG
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: LIST
70401: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70402: LD_ADDR_VAR 0 43
70406: PUSH
70407: LD_INT 0
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 0
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: LD_INT 0
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 1
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 0
70450: PUSH
70451: LD_INT 1
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: LD_INT 1
70475: NEG
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: LD_INT 2
70487: NEG
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 2
70498: NEG
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: LD_INT 1
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 2
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: LD_INT 1
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 2
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: LD_INT 2
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 2
70568: NEG
70569: PUSH
70570: LD_INT 0
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 2
70579: NEG
70580: PUSH
70581: LD_INT 1
70583: NEG
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PUSH
70589: LD_INT 1
70591: NEG
70592: PUSH
70593: LD_INT 3
70595: NEG
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: LD_INT 3
70606: NEG
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 1
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 2
70625: PUSH
70626: LD_INT 1
70628: NEG
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 3
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 3
70646: PUSH
70647: LD_INT 1
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 1
70656: PUSH
70657: LD_INT 3
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 0
70666: PUSH
70667: LD_INT 3
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: LD_INT 1
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 3
70698: NEG
70699: PUSH
70700: LD_INT 0
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 3
70709: NEG
70710: PUSH
70711: LD_INT 1
70713: NEG
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70750: LD_ADDR_VAR 0 44
70754: PUSH
70755: LD_INT 0
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: LD_INT 1
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 1
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 1
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: LD_INT 1
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 1
70808: NEG
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: NEG
70820: PUSH
70821: LD_INT 1
70823: NEG
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 1
70831: NEG
70832: PUSH
70833: LD_INT 2
70835: NEG
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 1
70843: PUSH
70844: LD_INT 1
70846: NEG
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 2
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 2
70874: PUSH
70875: LD_INT 2
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 1
70884: PUSH
70885: LD_INT 2
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 2
70905: NEG
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 2
70916: NEG
70917: PUSH
70918: LD_INT 1
70920: NEG
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 2
70928: NEG
70929: PUSH
70930: LD_INT 2
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: NEG
70941: PUSH
70942: LD_INT 3
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: LD_INT 1
70955: NEG
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 3
70963: PUSH
70964: LD_INT 0
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 3
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: PUSH
70984: LD_INT 2
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 3
70993: PUSH
70994: LD_INT 3
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: LD_INT 3
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 2
71013: NEG
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 3
71024: NEG
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 3
71035: NEG
71036: PUSH
71037: LD_INT 1
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 3
71047: NEG
71048: PUSH
71049: LD_INT 2
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 3
71059: NEG
71060: PUSH
71061: LD_INT 3
71063: NEG
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71100: LD_ADDR_VAR 0 45
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 0
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 1
71128: PUSH
71129: LD_INT 0
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 0
71148: PUSH
71149: LD_INT 1
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: LD_INT 0
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 1
71169: NEG
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: NEG
71182: PUSH
71183: LD_INT 2
71185: NEG
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 0
71193: PUSH
71194: LD_INT 2
71196: NEG
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: LD_INT 1
71207: NEG
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: LD_INT 2
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 2
71225: PUSH
71226: LD_INT 2
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 1
71235: PUSH
71236: LD_INT 2
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 0
71245: PUSH
71246: LD_INT 2
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: PUSH
71253: LD_INT 1
71255: NEG
71256: PUSH
71257: LD_INT 1
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: LD_INT 1
71270: NEG
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 2
71278: NEG
71279: PUSH
71280: LD_INT 2
71282: NEG
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 2
71290: NEG
71291: PUSH
71292: LD_INT 3
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: NEG
71303: PUSH
71304: LD_INT 3
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 0
71314: PUSH
71315: LD_INT 3
71317: NEG
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: LD_INT 2
71328: NEG
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 3
71336: PUSH
71337: LD_INT 2
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 3
71346: PUSH
71347: LD_INT 3
71349: PUSH
71350: EMPTY
71351: LIST
71352: LIST
71353: PUSH
71354: LD_INT 2
71356: PUSH
71357: LD_INT 3
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: LD_INT 3
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: LD_INT 0
71376: PUSH
71377: LD_INT 3
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: NEG
71387: PUSH
71388: LD_INT 2
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 3
71397: NEG
71398: PUSH
71399: LD_INT 2
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 3
71409: NEG
71410: PUSH
71411: LD_INT 3
71413: NEG
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71450: LD_ADDR_VAR 0 46
71454: PUSH
71455: LD_INT 0
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 0
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 0
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 1
71488: PUSH
71489: LD_INT 1
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 0
71498: PUSH
71499: LD_INT 1
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 1
71508: NEG
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: LD_INT 1
71523: NEG
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: LD_INT 2
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: LD_INT 2
71546: NEG
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: PUSH
71555: LD_INT 1
71557: NEG
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 2
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: PUSH
71586: LD_INT 2
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: LD_INT 2
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: LD_INT 1
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 2
71616: NEG
71617: PUSH
71618: LD_INT 0
71620: PUSH
71621: EMPTY
71622: LIST
71623: LIST
71624: PUSH
71625: LD_INT 2
71627: NEG
71628: PUSH
71629: LD_INT 1
71631: NEG
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 1
71639: NEG
71640: PUSH
71641: LD_INT 3
71643: NEG
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: LD_INT 3
71654: NEG
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: PUSH
71663: LD_INT 2
71665: NEG
71666: PUSH
71667: EMPTY
71668: LIST
71669: LIST
71670: PUSH
71671: LD_INT 2
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 3
71684: PUSH
71685: LD_INT 0
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 3
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: PUSH
71705: LD_INT 3
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: LD_INT 3
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: NEG
71725: PUSH
71726: LD_INT 2
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 2
71735: NEG
71736: PUSH
71737: LD_INT 1
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 3
71746: NEG
71747: PUSH
71748: LD_INT 0
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 3
71757: NEG
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71798: LD_ADDR_VAR 0 47
71802: PUSH
71803: LD_INT 0
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 0
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 1
71826: PUSH
71827: LD_INT 0
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PUSH
71834: LD_INT 1
71836: PUSH
71837: LD_INT 1
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: LD_INT 1
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 1
71867: NEG
71868: PUSH
71869: LD_INT 1
71871: NEG
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 1
71879: NEG
71880: PUSH
71881: LD_INT 2
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 0
71891: PUSH
71892: LD_INT 2
71894: NEG
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 2
71913: NEG
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: LD_INT 2
71929: NEG
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71949: LD_ADDR_VAR 0 48
71953: PUSH
71954: LD_INT 0
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 0
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 1
71977: PUSH
71978: LD_INT 0
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 1
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: LD_INT 1
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: LD_INT 0
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 1
72018: NEG
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 1
72030: NEG
72031: PUSH
72032: LD_INT 2
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: LD_INT 2
72045: NEG
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 1
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 2
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72096: LD_ADDR_VAR 0 49
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 1
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 1
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 0
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 0
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 2
72188: PUSH
72189: LD_INT 0
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: LD_INT 1
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 2
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 2
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72240: LD_ADDR_VAR 0 50
72244: PUSH
72245: LD_INT 0
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: LD_INT 1
72260: NEG
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 1
72278: PUSH
72279: LD_INT 1
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 0
72288: PUSH
72289: LD_INT 1
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: LD_INT 0
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: NEG
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 2
72321: PUSH
72322: LD_INT 1
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PUSH
72329: LD_INT 2
72331: PUSH
72332: LD_INT 2
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 1
72341: PUSH
72342: LD_INT 2
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: LD_INT 2
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 1
72361: NEG
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72384: LD_ADDR_VAR 0 51
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: LD_INT 1
72404: NEG
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 1
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: LD_INT 1
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 1
72442: NEG
72443: PUSH
72444: LD_INT 0
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: LD_INT 1
72457: NEG
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: PUSH
72463: LD_INT 1
72465: PUSH
72466: LD_INT 2
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 0
72475: PUSH
72476: LD_INT 2
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: NEG
72486: PUSH
72487: LD_INT 1
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: LD_INT 2
72496: NEG
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 2
72507: NEG
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72531: LD_ADDR_VAR 0 52
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: LD_INT 2
72616: NEG
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 1
72624: NEG
72625: PUSH
72626: LD_INT 1
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 2
72635: NEG
72636: PUSH
72637: LD_INT 0
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: LD_INT 1
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 2
72658: NEG
72659: PUSH
72660: LD_INT 2
72662: NEG
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: LIST
72680: LIST
72681: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72682: LD_ADDR_VAR 0 53
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 0
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 1
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: LD_INT 1
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 0
72730: PUSH
72731: LD_INT 1
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: NEG
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: NEG
72752: PUSH
72753: LD_INT 1
72755: NEG
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: NEG
72764: PUSH
72765: LD_INT 2
72767: NEG
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: LD_INT 2
72778: NEG
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 1
72786: PUSH
72787: LD_INT 1
72789: NEG
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 2
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: LD_INT 2
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: PUSH
72818: LD_INT 2
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 1
72827: PUSH
72828: LD_INT 2
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 0
72837: PUSH
72838: LD_INT 2
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: LD_INT 2
72858: NEG
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 2
72869: NEG
72870: PUSH
72871: LD_INT 1
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 2
72881: NEG
72882: PUSH
72883: LD_INT 2
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: LIST
72898: LIST
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: LIST
72908: LIST
72909: LIST
72910: LIST
72911: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72912: LD_ADDR_VAR 0 54
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: LD_INT 1
72932: NEG
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 0
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 1
72970: NEG
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: NEG
72982: PUSH
72983: LD_INT 1
72985: NEG
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 1
72993: NEG
72994: PUSH
72995: LD_INT 2
72997: NEG
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 0
73005: PUSH
73006: LD_INT 2
73008: NEG
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 1
73016: PUSH
73017: LD_INT 1
73019: NEG
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: EMPTY
73032: LIST
73033: LIST
73034: PUSH
73035: LD_INT 2
73037: PUSH
73038: LD_INT 1
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 2
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: LD_INT 2
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: LD_INT 1
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: LD_INT 0
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 2
73099: NEG
73100: PUSH
73101: LD_INT 1
73103: NEG
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 2
73111: NEG
73112: PUSH
73113: LD_INT 2
73115: NEG
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73142: LD_ADDR_VAR 0 55
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: NEG
73212: PUSH
73213: LD_INT 1
73215: NEG
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 0
73235: PUSH
73236: LD_INT 2
73238: NEG
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: LD_INT 1
73249: NEG
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 2
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 2
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: PUSH
73285: LD_INT 1
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: LD_INT 2
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: LD_INT 1
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 2
73318: NEG
73319: PUSH
73320: LD_INT 0
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: LD_INT 2
73329: NEG
73330: PUSH
73331: LD_INT 1
73333: NEG
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 2
73341: NEG
73342: PUSH
73343: LD_INT 2
73345: NEG
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73372: LD_ADDR_VAR 0 56
73376: PUSH
73377: LD_INT 0
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 1
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 1
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 0
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 1
73430: NEG
73431: PUSH
73432: LD_INT 0
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 1
73441: NEG
73442: PUSH
73443: LD_INT 1
73445: NEG
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 1
73453: NEG
73454: PUSH
73455: LD_INT 2
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 0
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: LD_INT 1
73479: NEG
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 2
73487: PUSH
73488: LD_INT 0
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 2
73497: PUSH
73498: LD_INT 1
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 2
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 1
73537: NEG
73538: PUSH
73539: LD_INT 1
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 2
73548: NEG
73549: PUSH
73550: LD_INT 0
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 2
73559: NEG
73560: PUSH
73561: LD_INT 1
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 2
73571: NEG
73572: PUSH
73573: LD_INT 2
73575: NEG
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73602: LD_ADDR_VAR 0 57
73606: PUSH
73607: LD_INT 0
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 0
73619: PUSH
73620: LD_INT 1
73622: NEG
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 1
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 0
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: LD_INT 0
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: LD_INT 1
73675: NEG
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 1
73683: NEG
73684: PUSH
73685: LD_INT 2
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 0
73695: PUSH
73696: LD_INT 2
73698: NEG
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 1
73706: PUSH
73707: LD_INT 1
73709: NEG
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 2
73717: PUSH
73718: LD_INT 0
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 2
73727: PUSH
73728: LD_INT 1
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: LD_INT 2
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: LD_INT 2
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 1
73767: NEG
73768: PUSH
73769: LD_INT 1
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 2
73778: NEG
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 2
73789: NEG
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 2
73801: NEG
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73832: LD_ADDR_VAR 0 58
73836: PUSH
73837: LD_INT 0
73839: PUSH
73840: LD_INT 0
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 0
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 1
73860: PUSH
73861: LD_INT 0
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 1
73870: PUSH
73871: LD_INT 1
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 1
73890: NEG
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: LD_INT 1
73905: NEG
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 2
73928: NEG
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 1
73936: PUSH
73937: LD_INT 1
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 2
73947: PUSH
73948: LD_INT 0
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: PUSH
73955: LD_INT 2
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 1
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 0
73987: PUSH
73988: LD_INT 2
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 1
73997: NEG
73998: PUSH
73999: LD_INT 1
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 2
74008: NEG
74009: PUSH
74010: LD_INT 0
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: NEG
74020: PUSH
74021: LD_INT 1
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 2
74031: NEG
74032: PUSH
74033: LD_INT 2
74035: NEG
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74062: LD_ADDR_VAR 0 59
74066: PUSH
74067: LD_INT 0
74069: PUSH
74070: LD_INT 0
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 0
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 1
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: LD_INT 0
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: LD_INT 1
74135: NEG
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: LIST
74148: LIST
74149: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74150: LD_ADDR_VAR 0 60
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: LD_INT 0
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 0
74167: PUSH
74168: LD_INT 1
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 1
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 1
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 0
74198: PUSH
74199: LD_INT 1
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: NEG
74220: PUSH
74221: LD_INT 1
74223: NEG
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74238: LD_ADDR_VAR 0 61
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: LD_INT 0
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: PUSH
74277: LD_INT 1
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 0
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: LD_INT 1
74307: NEG
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74326: LD_ADDR_VAR 0 62
74330: PUSH
74331: LD_INT 0
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 0
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 1
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 1
74364: PUSH
74365: LD_INT 1
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: LD_INT 1
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 1
74384: NEG
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: LD_INT 1
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74414: LD_ADDR_VAR 0 63
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: LD_INT 1
74434: NEG
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 1
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 1
74452: PUSH
74453: LD_INT 1
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 0
74462: PUSH
74463: LD_INT 1
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 1
74472: NEG
74473: PUSH
74474: LD_INT 0
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74502: LD_ADDR_VAR 0 64
74506: PUSH
74507: LD_INT 0
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: LD_INT 1
74522: NEG
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: PUSH
74531: LD_INT 0
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 1
74540: PUSH
74541: LD_INT 1
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 0
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 1
74560: NEG
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 1
74571: NEG
74572: PUSH
74573: LD_INT 1
74575: NEG
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: ST_TO_ADDR
// end ; 1 :
74590: GO 80487
74592: LD_INT 1
74594: DOUBLE
74595: EQUAL
74596: IFTRUE 74600
74598: GO 77223
74600: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74601: LD_ADDR_VAR 0 11
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: LD_INT 3
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 0
74620: PUSH
74621: LD_INT 3
74623: NEG
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: PUSH
74629: LD_INT 1
74631: PUSH
74632: LD_INT 2
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: LIST
74644: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74645: LD_ADDR_VAR 0 12
74649: PUSH
74650: LD_INT 2
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 3
74663: PUSH
74664: LD_INT 0
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 3
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: LIST
74685: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74686: LD_ADDR_VAR 0 13
74690: PUSH
74691: LD_INT 3
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 3
74703: PUSH
74704: LD_INT 3
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 2
74713: PUSH
74714: LD_INT 3
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: LIST
74725: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74726: LD_ADDR_VAR 0 14
74730: PUSH
74731: LD_INT 1
74733: PUSH
74734: LD_INT 3
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 0
74743: PUSH
74744: LD_INT 3
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 1
74753: NEG
74754: PUSH
74755: LD_INT 2
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74767: LD_ADDR_VAR 0 15
74771: PUSH
74772: LD_INT 2
74774: NEG
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 3
74785: NEG
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: PUSH
74794: LD_INT 3
74796: NEG
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: LIST
74810: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74811: LD_ADDR_VAR 0 16
74815: PUSH
74816: LD_INT 2
74818: NEG
74819: PUSH
74820: LD_INT 3
74822: NEG
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 3
74830: NEG
74831: PUSH
74832: LD_INT 2
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 3
74842: NEG
74843: PUSH
74844: LD_INT 3
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: LIST
74856: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74857: LD_ADDR_VAR 0 17
74861: PUSH
74862: LD_INT 1
74864: NEG
74865: PUSH
74866: LD_INT 3
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 0
74876: PUSH
74877: LD_INT 3
74879: NEG
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: LD_INT 2
74890: NEG
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: LIST
74900: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74901: LD_ADDR_VAR 0 18
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: LD_INT 1
74911: NEG
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 0
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74942: LD_ADDR_VAR 0 19
74946: PUSH
74947: LD_INT 3
74949: PUSH
74950: LD_INT 2
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: LD_INT 3
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 2
74969: PUSH
74970: LD_INT 3
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74982: LD_ADDR_VAR 0 20
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: LD_INT 3
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: LD_INT 2
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: LIST
75022: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75023: LD_ADDR_VAR 0 21
75027: PUSH
75028: LD_INT 2
75030: NEG
75031: PUSH
75032: LD_INT 1
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 3
75041: NEG
75042: PUSH
75043: LD_INT 0
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 3
75052: NEG
75053: PUSH
75054: LD_INT 1
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: LIST
75066: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75067: LD_ADDR_VAR 0 22
75071: PUSH
75072: LD_INT 2
75074: NEG
75075: PUSH
75076: LD_INT 3
75078: NEG
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 3
75086: NEG
75087: PUSH
75088: LD_INT 2
75090: NEG
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: LD_INT 3
75098: NEG
75099: PUSH
75100: LD_INT 3
75102: NEG
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: LIST
75112: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75113: LD_ADDR_VAR 0 23
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: LD_INT 3
75123: NEG
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: LD_INT 4
75135: NEG
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 1
75143: PUSH
75144: LD_INT 3
75146: NEG
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: LIST
75156: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75157: LD_ADDR_VAR 0 24
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 3
75174: PUSH
75175: LD_INT 1
75177: NEG
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 4
75185: PUSH
75186: LD_INT 1
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: LIST
75197: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75198: LD_ADDR_VAR 0 25
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: LD_INT 3
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 4
75215: PUSH
75216: LD_INT 3
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 3
75225: PUSH
75226: LD_INT 4
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: LIST
75237: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75238: LD_ADDR_VAR 0 26
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 3
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: LD_INT 4
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: NEG
75266: PUSH
75267: LD_INT 3
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: LIST
75278: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75279: LD_ADDR_VAR 0 27
75283: PUSH
75284: LD_INT 3
75286: NEG
75287: PUSH
75288: LD_INT 0
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 3
75297: NEG
75298: PUSH
75299: LD_INT 1
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 4
75308: NEG
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: LIST
75322: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75323: LD_ADDR_VAR 0 28
75327: PUSH
75328: LD_INT 3
75330: NEG
75331: PUSH
75332: LD_INT 3
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 3
75342: NEG
75343: PUSH
75344: LD_INT 4
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 4
75354: NEG
75355: PUSH
75356: LD_INT 3
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: LIST
75368: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75369: LD_ADDR_VAR 0 29
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 3
75380: NEG
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 0
75388: PUSH
75389: LD_INT 3
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 2
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 1
75410: NEG
75411: PUSH
75412: LD_INT 4
75414: NEG
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 4
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 3
75436: NEG
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: NEG
75445: PUSH
75446: LD_INT 5
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 0
75456: PUSH
75457: LD_INT 5
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 1
75467: PUSH
75468: LD_INT 4
75470: NEG
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: LD_INT 6
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 6
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 5
75504: NEG
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75524: LD_ADDR_VAR 0 30
75528: PUSH
75529: LD_INT 2
75531: PUSH
75532: LD_INT 1
75534: NEG
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 3
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 3
75552: PUSH
75553: LD_INT 1
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 3
75562: PUSH
75563: LD_INT 1
75565: NEG
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 4
75573: PUSH
75574: LD_INT 0
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 4
75583: PUSH
75584: LD_INT 1
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 4
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 5
75604: PUSH
75605: LD_INT 0
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 5
75614: PUSH
75615: LD_INT 1
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 5
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 6
75635: PUSH
75636: LD_INT 0
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 6
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75667: LD_ADDR_VAR 0 31
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: LD_INT 3
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 2
75694: PUSH
75695: LD_INT 3
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 4
75704: PUSH
75705: LD_INT 3
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 4
75714: PUSH
75715: LD_INT 4
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 3
75724: PUSH
75725: LD_INT 4
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 5
75734: PUSH
75735: LD_INT 4
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 5
75744: PUSH
75745: LD_INT 5
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 4
75754: PUSH
75755: LD_INT 5
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 6
75764: PUSH
75765: LD_INT 5
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 6
75774: PUSH
75775: LD_INT 6
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: PUSH
75782: LD_INT 5
75784: PUSH
75785: LD_INT 6
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75806: LD_ADDR_VAR 0 32
75810: PUSH
75811: LD_INT 1
75813: PUSH
75814: LD_INT 3
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: LD_INT 3
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PUSH
75831: LD_INT 1
75833: NEG
75834: PUSH
75835: LD_INT 2
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: LD_INT 4
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: LD_INT 4
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 1
75864: NEG
75865: PUSH
75866: LD_INT 3
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: LD_INT 5
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: LD_INT 5
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 1
75895: NEG
75896: PUSH
75897: LD_INT 4
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 1
75906: PUSH
75907: LD_INT 6
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 0
75916: PUSH
75917: LD_INT 6
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 1
75926: NEG
75927: PUSH
75928: LD_INT 5
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75949: LD_ADDR_VAR 0 33
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: LD_INT 1
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: LD_INT 0
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 3
75978: NEG
75979: PUSH
75980: LD_INT 1
75982: NEG
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 3
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 4
76001: NEG
76002: PUSH
76003: LD_INT 0
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 4
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: NEG
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 4
76024: NEG
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 5
76035: NEG
76036: PUSH
76037: LD_INT 0
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 5
76046: NEG
76047: PUSH
76048: LD_INT 1
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 5
76058: NEG
76059: PUSH
76060: LD_INT 1
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 6
76069: NEG
76070: PUSH
76071: LD_INT 0
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: LD_INT 6
76080: NEG
76081: PUSH
76082: LD_INT 1
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76104: LD_ADDR_VAR 0 34
76108: PUSH
76109: LD_INT 2
76111: NEG
76112: PUSH
76113: LD_INT 3
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 3
76123: NEG
76124: PUSH
76125: LD_INT 2
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 3
76135: NEG
76136: PUSH
76137: LD_INT 3
76139: NEG
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 3
76147: NEG
76148: PUSH
76149: LD_INT 4
76151: NEG
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 4
76159: NEG
76160: PUSH
76161: LD_INT 3
76163: NEG
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 4
76171: NEG
76172: PUSH
76173: LD_INT 4
76175: NEG
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 4
76183: NEG
76184: PUSH
76185: LD_INT 5
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 5
76195: NEG
76196: PUSH
76197: LD_INT 4
76199: NEG
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 5
76207: NEG
76208: PUSH
76209: LD_INT 5
76211: NEG
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 5
76219: NEG
76220: PUSH
76221: LD_INT 6
76223: NEG
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 6
76231: NEG
76232: PUSH
76233: LD_INT 5
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 6
76243: NEG
76244: PUSH
76245: LD_INT 6
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76267: LD_ADDR_VAR 0 41
76271: PUSH
76272: LD_INT 0
76274: PUSH
76275: LD_INT 2
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: LD_INT 3
76289: NEG
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 1
76297: PUSH
76298: LD_INT 2
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: LIST
76310: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76311: LD_ADDR_VAR 0 42
76315: PUSH
76316: LD_INT 2
76318: PUSH
76319: LD_INT 0
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 2
76328: PUSH
76329: LD_INT 1
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 3
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: LIST
76351: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76352: LD_ADDR_VAR 0 43
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: LD_INT 2
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PUSH
76367: LD_INT 3
76369: PUSH
76370: LD_INT 2
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 2
76379: PUSH
76380: LD_INT 3
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: LIST
76391: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76392: LD_ADDR_VAR 0 44
76396: PUSH
76397: LD_INT 0
76399: PUSH
76400: LD_INT 2
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 1
76409: PUSH
76410: LD_INT 3
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 1
76419: NEG
76420: PUSH
76421: LD_INT 2
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: LIST
76432: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76433: LD_ADDR_VAR 0 45
76437: PUSH
76438: LD_INT 2
76440: NEG
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 2
76451: NEG
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 3
76462: NEG
76463: PUSH
76464: LD_INT 1
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: LIST
76476: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76477: LD_ADDR_VAR 0 46
76481: PUSH
76482: LD_INT 2
76484: NEG
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 2
76496: NEG
76497: PUSH
76498: LD_INT 3
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 3
76508: NEG
76509: PUSH
76510: LD_INT 2
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: LIST
76522: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76523: LD_ADDR_VAR 0 47
76527: PUSH
76528: LD_INT 2
76530: NEG
76531: PUSH
76532: LD_INT 3
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: NEG
76543: PUSH
76544: LD_INT 3
76546: NEG
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76556: LD_ADDR_VAR 0 48
76560: PUSH
76561: LD_INT 1
76563: PUSH
76564: LD_INT 2
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 1
76577: NEG
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76587: LD_ADDR_VAR 0 49
76591: PUSH
76592: LD_INT 3
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 3
76604: PUSH
76605: LD_INT 2
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76616: LD_ADDR_VAR 0 50
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: LD_INT 3
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: PUSH
76634: LD_INT 3
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76645: LD_ADDR_VAR 0 51
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: LD_INT 2
76656: PUSH
76657: EMPTY
76658: LIST
76659: LIST
76660: PUSH
76661: LD_INT 2
76663: NEG
76664: PUSH
76665: LD_INT 1
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76676: LD_ADDR_VAR 0 52
76680: PUSH
76681: LD_INT 3
76683: NEG
76684: PUSH
76685: LD_INT 1
76687: NEG
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 3
76695: NEG
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76709: LD_ADDR_VAR 0 53
76713: PUSH
76714: LD_INT 1
76716: NEG
76717: PUSH
76718: LD_INT 3
76720: NEG
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: LD_INT 3
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 1
76739: PUSH
76740: LD_INT 2
76742: NEG
76743: PUSH
76744: EMPTY
76745: LIST
76746: LIST
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: LIST
76752: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76753: LD_ADDR_VAR 0 54
76757: PUSH
76758: LD_INT 2
76760: PUSH
76761: LD_INT 1
76763: NEG
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 3
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 3
76781: PUSH
76782: LD_INT 1
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: LIST
76793: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76794: LD_ADDR_VAR 0 55
76798: PUSH
76799: LD_INT 3
76801: PUSH
76802: LD_INT 2
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 3
76811: PUSH
76812: LD_INT 3
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: LD_INT 3
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: LIST
76833: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76834: LD_ADDR_VAR 0 56
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: LD_INT 3
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 0
76851: PUSH
76852: LD_INT 3
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 1
76861: NEG
76862: PUSH
76863: LD_INT 2
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: LIST
76874: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76875: LD_ADDR_VAR 0 57
76879: PUSH
76880: LD_INT 2
76882: NEG
76883: PUSH
76884: LD_INT 1
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 3
76893: NEG
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 3
76904: NEG
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: LIST
76918: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76919: LD_ADDR_VAR 0 58
76923: PUSH
76924: LD_INT 2
76926: NEG
76927: PUSH
76928: LD_INT 3
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 3
76938: NEG
76939: PUSH
76940: LD_INT 2
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 3
76950: NEG
76951: PUSH
76952: LD_INT 3
76954: NEG
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: LIST
76964: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76965: LD_ADDR_VAR 0 59
76969: PUSH
76970: LD_INT 1
76972: NEG
76973: PUSH
76974: LD_INT 2
76976: NEG
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 0
76984: PUSH
76985: LD_INT 2
76987: NEG
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: PUSH
76996: LD_INT 1
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: LIST
77008: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77009: LD_ADDR_VAR 0 60
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: LD_INT 1
77019: NEG
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 2
77027: PUSH
77028: LD_INT 0
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 2
77037: PUSH
77038: LD_INT 1
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: LIST
77049: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77050: LD_ADDR_VAR 0 61
77054: PUSH
77055: LD_INT 2
77057: PUSH
77058: LD_INT 1
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 2
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 1
77077: PUSH
77078: LD_INT 2
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: LIST
77089: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77090: LD_ADDR_VAR 0 62
77094: PUSH
77095: LD_INT 1
77097: PUSH
77098: LD_INT 2
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 2
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 1
77117: NEG
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: LIST
77130: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77131: LD_ADDR_VAR 0 63
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 2
77149: NEG
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 2
77160: NEG
77161: PUSH
77162: LD_INT 1
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: LIST
77174: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77175: LD_ADDR_VAR 0 64
77179: PUSH
77180: LD_INT 1
77182: NEG
77183: PUSH
77184: LD_INT 2
77186: NEG
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 2
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 2
77206: NEG
77207: PUSH
77208: LD_INT 2
77210: NEG
77211: PUSH
77212: EMPTY
77213: LIST
77214: LIST
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: LIST
77220: ST_TO_ADDR
// end ; 2 :
77221: GO 80487
77223: LD_INT 2
77225: DOUBLE
77226: EQUAL
77227: IFTRUE 77231
77229: GO 80486
77231: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77232: LD_ADDR_VAR 0 29
77236: PUSH
77237: LD_INT 4
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 4
77249: PUSH
77250: LD_INT 1
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 5
77260: PUSH
77261: LD_INT 0
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 5
77270: PUSH
77271: LD_INT 1
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 4
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 3
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: LD_INT 1
77303: NEG
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 3
77311: PUSH
77312: LD_INT 2
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 5
77322: PUSH
77323: LD_INT 2
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 3
77332: PUSH
77333: LD_INT 3
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 3
77342: PUSH
77343: LD_INT 2
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 4
77352: PUSH
77353: LD_INT 3
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 4
77362: PUSH
77363: LD_INT 4
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 3
77372: PUSH
77373: LD_INT 4
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 3
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: PUSH
77393: LD_INT 2
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 4
77402: PUSH
77403: LD_INT 2
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 2
77412: PUSH
77413: LD_INT 4
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: LD_INT 4
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 0
77432: PUSH
77433: LD_INT 3
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: LD_INT 4
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 1
77452: PUSH
77453: LD_INT 5
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: LD_INT 5
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 4
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 1
77483: NEG
77484: PUSH
77485: LD_INT 3
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 2
77494: PUSH
77495: LD_INT 5
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 2
77504: NEG
77505: PUSH
77506: LD_INT 3
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 3
77515: NEG
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 3
77526: NEG
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 2
77538: NEG
77539: PUSH
77540: LD_INT 0
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 2
77549: NEG
77550: PUSH
77551: LD_INT 1
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 3
77560: NEG
77561: PUSH
77562: LD_INT 1
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 4
77571: NEG
77572: PUSH
77573: LD_INT 0
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 4
77582: NEG
77583: PUSH
77584: LD_INT 1
77586: NEG
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 4
77594: NEG
77595: PUSH
77596: LD_INT 2
77598: NEG
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 2
77606: NEG
77607: PUSH
77608: LD_INT 2
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 4
77617: NEG
77618: PUSH
77619: LD_INT 4
77621: NEG
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 4
77629: NEG
77630: PUSH
77631: LD_INT 5
77633: NEG
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: NEG
77642: PUSH
77643: LD_INT 4
77645: NEG
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 3
77653: NEG
77654: PUSH
77655: LD_INT 3
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 4
77665: NEG
77666: PUSH
77667: LD_INT 3
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 5
77677: NEG
77678: PUSH
77679: LD_INT 4
77681: NEG
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 5
77689: NEG
77690: PUSH
77691: LD_INT 5
77693: NEG
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 3
77701: NEG
77702: PUSH
77703: LD_INT 5
77705: NEG
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 5
77713: NEG
77714: PUSH
77715: LD_INT 3
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77770: LD_ADDR_VAR 0 30
77774: PUSH
77775: LD_INT 4
77777: PUSH
77778: LD_INT 4
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: LD_INT 4
77787: PUSH
77788: LD_INT 3
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 5
77797: PUSH
77798: LD_INT 4
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 5
77807: PUSH
77808: LD_INT 5
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 4
77817: PUSH
77818: LD_INT 5
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: LD_INT 4
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 3
77837: PUSH
77838: LD_INT 3
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 5
77847: PUSH
77848: LD_INT 3
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 3
77857: PUSH
77858: LD_INT 5
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: LD_INT 3
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 0
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 3
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 1
77897: PUSH
77898: LD_INT 4
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 0
77907: PUSH
77908: LD_INT 4
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 1
77917: NEG
77918: PUSH
77919: LD_INT 3
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PUSH
77926: LD_INT 1
77928: NEG
77929: PUSH
77930: LD_INT 2
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: PUSH
77937: LD_INT 2
77939: PUSH
77940: LD_INT 4
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 2
77949: NEG
77950: PUSH
77951: LD_INT 2
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 4
77960: NEG
77961: PUSH
77962: LD_INT 0
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 4
77971: NEG
77972: PUSH
77973: LD_INT 1
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 3
77983: NEG
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: PUSH
77992: LD_INT 3
77994: NEG
77995: PUSH
77996: LD_INT 1
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 4
78005: NEG
78006: PUSH
78007: LD_INT 1
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 5
78016: NEG
78017: PUSH
78018: LD_INT 0
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 5
78027: NEG
78028: PUSH
78029: LD_INT 1
78031: NEG
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 5
78039: NEG
78040: PUSH
78041: LD_INT 2
78043: NEG
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 3
78051: NEG
78052: PUSH
78053: LD_INT 2
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 3
78062: NEG
78063: PUSH
78064: LD_INT 3
78066: NEG
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 3
78074: NEG
78075: PUSH
78076: LD_INT 4
78078: NEG
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 2
78086: NEG
78087: PUSH
78088: LD_INT 3
78090: NEG
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 2
78098: NEG
78099: PUSH
78100: LD_INT 2
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 3
78110: NEG
78111: PUSH
78112: LD_INT 2
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 4
78122: NEG
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 4
78134: NEG
78135: PUSH
78136: LD_INT 4
78138: NEG
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 2
78146: NEG
78147: PUSH
78148: LD_INT 4
78150: NEG
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 4
78158: NEG
78159: PUSH
78160: LD_INT 2
78162: NEG
78163: PUSH
78164: EMPTY
78165: LIST
78166: LIST
78167: PUSH
78168: LD_INT 0
78170: PUSH
78171: LD_INT 4
78173: NEG
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 0
78181: PUSH
78182: LD_INT 5
78184: NEG
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 1
78192: PUSH
78193: LD_INT 4
78195: NEG
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 1
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 0
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 1
78225: NEG
78226: PUSH
78227: LD_INT 4
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 1
78237: NEG
78238: PUSH
78239: LD_INT 5
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 2
78249: PUSH
78250: LD_INT 3
78252: NEG
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 2
78260: NEG
78261: PUSH
78262: LD_INT 5
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: LIST
78277: LIST
78278: LIST
78279: LIST
78280: LIST
78281: LIST
78282: LIST
78283: LIST
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78317: LD_ADDR_VAR 0 31
78321: PUSH
78322: LD_INT 0
78324: PUSH
78325: LD_INT 4
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 4
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: PUSH
78355: LD_INT 5
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 0
78364: PUSH
78365: LD_INT 5
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 1
78374: NEG
78375: PUSH
78376: LD_INT 4
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 1
78385: NEG
78386: PUSH
78387: LD_INT 3
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 2
78396: PUSH
78397: LD_INT 5
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 2
78406: NEG
78407: PUSH
78408: LD_INT 3
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 3
78417: NEG
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 3
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: NEG
78441: PUSH
78442: LD_INT 0
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 2
78451: NEG
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 4
78484: NEG
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 4
78496: NEG
78497: PUSH
78498: LD_INT 2
78500: NEG
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 2
78508: NEG
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: LD_INT 4
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: LD_INT 4
78531: NEG
78532: PUSH
78533: LD_INT 5
78535: NEG
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 3
78543: NEG
78544: PUSH
78545: LD_INT 4
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 3
78555: NEG
78556: PUSH
78557: LD_INT 3
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 4
78567: NEG
78568: PUSH
78569: LD_INT 3
78571: NEG
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 5
78579: NEG
78580: PUSH
78581: LD_INT 4
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 5
78591: NEG
78592: PUSH
78593: LD_INT 5
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 3
78603: NEG
78604: PUSH
78605: LD_INT 5
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 5
78615: NEG
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 0
78627: PUSH
78628: LD_INT 3
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 0
78638: PUSH
78639: LD_INT 4
78641: NEG
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: PUSH
78650: LD_INT 3
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: LD_INT 2
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 2
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: LD_INT 3
78686: NEG
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 1
78694: NEG
78695: PUSH
78696: LD_INT 4
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 2
78717: NEG
78718: PUSH
78719: LD_INT 4
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 4
78729: PUSH
78730: LD_INT 0
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 4
78739: PUSH
78740: LD_INT 1
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 5
78750: PUSH
78751: LD_INT 0
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 5
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 4
78770: PUSH
78771: LD_INT 1
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 3
78801: PUSH
78802: LD_INT 2
78804: NEG
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 5
78812: PUSH
78813: LD_INT 2
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78867: LD_ADDR_VAR 0 32
78871: PUSH
78872: LD_INT 4
78874: NEG
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 4
78885: NEG
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 3
78897: NEG
78898: PUSH
78899: LD_INT 0
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 3
78908: NEG
78909: PUSH
78910: LD_INT 1
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: NEG
78920: PUSH
78921: LD_INT 1
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 5
78930: NEG
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 5
78941: NEG
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 5
78953: NEG
78954: PUSH
78955: LD_INT 2
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 3
78965: NEG
78966: PUSH
78967: LD_INT 2
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: LD_INT 3
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: LD_INT 4
78992: NEG
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 2
79000: NEG
79001: PUSH
79002: LD_INT 3
79004: NEG
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 2
79012: NEG
79013: PUSH
79014: LD_INT 2
79016: NEG
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 3
79024: NEG
79025: PUSH
79026: LD_INT 2
79028: NEG
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 4
79036: NEG
79037: PUSH
79038: LD_INT 3
79040: NEG
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 4
79048: NEG
79049: PUSH
79050: LD_INT 4
79052: NEG
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 2
79060: NEG
79061: PUSH
79062: LD_INT 4
79064: NEG
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 4
79072: NEG
79073: PUSH
79074: LD_INT 2
79076: NEG
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 0
79084: PUSH
79085: LD_INT 4
79087: NEG
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 0
79095: PUSH
79096: LD_INT 5
79098: NEG
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: LD_INT 4
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 1
79117: PUSH
79118: LD_INT 3
79120: NEG
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 0
79128: PUSH
79129: LD_INT 3
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: LD_INT 5
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 2
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 2
79174: NEG
79175: PUSH
79176: LD_INT 5
79178: NEG
79179: PUSH
79180: EMPTY
79181: LIST
79182: LIST
79183: PUSH
79184: LD_INT 3
79186: PUSH
79187: LD_INT 0
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 3
79196: PUSH
79197: LD_INT 1
79199: NEG
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 4
79207: PUSH
79208: LD_INT 0
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 4
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 3
79227: PUSH
79228: LD_INT 1
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 2
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 2
79247: PUSH
79248: LD_INT 1
79250: NEG
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 2
79258: PUSH
79259: LD_INT 2
79261: NEG
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 4
79269: PUSH
79270: LD_INT 2
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 4
79279: PUSH
79280: LD_INT 4
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 4
79289: PUSH
79290: LD_INT 3
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 5
79299: PUSH
79300: LD_INT 4
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 5
79309: PUSH
79310: LD_INT 5
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 4
79319: PUSH
79320: LD_INT 5
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 3
79329: PUSH
79330: LD_INT 4
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 3
79339: PUSH
79340: LD_INT 3
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 5
79349: PUSH
79350: LD_INT 3
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 3
79359: PUSH
79360: LD_INT 5
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79414: LD_ADDR_VAR 0 33
79418: PUSH
79419: LD_INT 4
79421: NEG
79422: PUSH
79423: LD_INT 4
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 4
79433: NEG
79434: PUSH
79435: LD_INT 5
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 3
79445: NEG
79446: PUSH
79447: LD_INT 4
79449: NEG
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 3
79457: NEG
79458: PUSH
79459: LD_INT 3
79461: NEG
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 4
79469: NEG
79470: PUSH
79471: LD_INT 3
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 5
79481: NEG
79482: PUSH
79483: LD_INT 4
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 5
79493: NEG
79494: PUSH
79495: LD_INT 5
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 3
79505: NEG
79506: PUSH
79507: LD_INT 5
79509: NEG
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 5
79517: NEG
79518: PUSH
79519: LD_INT 3
79521: NEG
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 0
79529: PUSH
79530: LD_INT 3
79532: NEG
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 0
79540: PUSH
79541: LD_INT 4
79543: NEG
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: PUSH
79552: LD_INT 3
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: LD_INT 2
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: LD_INT 2
79576: NEG
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 3
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 1
79596: NEG
79597: PUSH
79598: LD_INT 4
79600: NEG
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 2
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 2
79619: NEG
79620: PUSH
79621: LD_INT 4
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 4
79631: PUSH
79632: LD_INT 0
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 4
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 5
79652: PUSH
79653: LD_INT 0
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 5
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 4
79672: PUSH
79673: LD_INT 1
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 3
79682: PUSH
79683: LD_INT 0
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 3
79692: PUSH
79693: LD_INT 1
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 3
79703: PUSH
79704: LD_INT 2
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 5
79714: PUSH
79715: LD_INT 2
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: PUSH
79725: LD_INT 3
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 3
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 4
79744: PUSH
79745: LD_INT 3
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: LD_INT 4
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: LD_INT 4
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: LD_INT 3
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 2
79784: PUSH
79785: LD_INT 2
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 4
79794: PUSH
79795: LD_INT 2
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 2
79804: PUSH
79805: LD_INT 4
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 4
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 3
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 1
79834: PUSH
79835: LD_INT 4
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: LD_INT 5
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 0
79854: PUSH
79855: LD_INT 5
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 1
79864: NEG
79865: PUSH
79866: LD_INT 4
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: LD_INT 3
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 2
79886: PUSH
79887: LD_INT 5
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: LD_INT 2
79896: NEG
79897: PUSH
79898: LD_INT 3
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79952: LD_ADDR_VAR 0 34
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: LD_INT 4
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: LD_INT 5
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: PUSH
79982: LD_INT 4
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: LD_INT 3
79995: NEG
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: LD_INT 3
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: LD_INT 4
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: LD_INT 5
80030: NEG
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 2
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 2
80049: NEG
80050: PUSH
80051: LD_INT 5
80053: NEG
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 3
80061: PUSH
80062: LD_INT 0
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 3
80071: PUSH
80072: LD_INT 1
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 4
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 4
80092: PUSH
80093: LD_INT 1
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 3
80102: PUSH
80103: LD_INT 1
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PUSH
80110: LD_INT 2
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: PUSH
80123: LD_INT 1
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 2
80133: PUSH
80134: LD_INT 2
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 4
80144: PUSH
80145: LD_INT 2
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 4
80154: PUSH
80155: LD_INT 4
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 4
80164: PUSH
80165: LD_INT 3
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 5
80174: PUSH
80175: LD_INT 4
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 5
80184: PUSH
80185: LD_INT 5
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 4
80194: PUSH
80195: LD_INT 5
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 3
80204: PUSH
80205: LD_INT 4
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 3
80214: PUSH
80215: LD_INT 3
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 5
80224: PUSH
80225: LD_INT 3
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: LD_INT 5
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 0
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: LD_INT 4
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: LD_INT 4
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 1
80294: NEG
80295: PUSH
80296: LD_INT 3
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: LD_INT 2
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 2
80316: PUSH
80317: LD_INT 4
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 2
80326: NEG
80327: PUSH
80328: LD_INT 2
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 4
80337: NEG
80338: PUSH
80339: LD_INT 0
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 4
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 3
80360: NEG
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 3
80371: NEG
80372: PUSH
80373: LD_INT 1
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 4
80382: NEG
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 5
80393: NEG
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 5
80404: NEG
80405: PUSH
80406: LD_INT 1
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 5
80416: NEG
80417: PUSH
80418: LD_INT 2
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 3
80428: NEG
80429: PUSH
80430: LD_INT 2
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: ST_TO_ADDR
// end ; end ;
80484: GO 80487
80486: POP
// case btype of b_depot , b_warehouse :
80487: LD_VAR 0 1
80491: PUSH
80492: LD_INT 0
80494: DOUBLE
80495: EQUAL
80496: IFTRUE 80506
80498: LD_INT 1
80500: DOUBLE
80501: EQUAL
80502: IFTRUE 80506
80504: GO 80707
80506: POP
// case nation of nation_american :
80507: LD_VAR 0 5
80511: PUSH
80512: LD_INT 1
80514: DOUBLE
80515: EQUAL
80516: IFTRUE 80520
80518: GO 80576
80520: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 11
80530: PUSH
80531: LD_VAR 0 12
80535: PUSH
80536: LD_VAR 0 13
80540: PUSH
80541: LD_VAR 0 14
80545: PUSH
80546: LD_VAR 0 15
80550: PUSH
80551: LD_VAR 0 16
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: PUSH
80564: LD_VAR 0 4
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: ARRAY
80573: ST_TO_ADDR
80574: GO 80705
80576: LD_INT 2
80578: DOUBLE
80579: EQUAL
80580: IFTRUE 80584
80582: GO 80640
80584: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
80585: LD_ADDR_VAR 0 9
80589: PUSH
80590: LD_VAR 0 17
80594: PUSH
80595: LD_VAR 0 18
80599: PUSH
80600: LD_VAR 0 19
80604: PUSH
80605: LD_VAR 0 20
80609: PUSH
80610: LD_VAR 0 21
80614: PUSH
80615: LD_VAR 0 22
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: PUSH
80628: LD_VAR 0 4
80632: PUSH
80633: LD_INT 1
80635: PLUS
80636: ARRAY
80637: ST_TO_ADDR
80638: GO 80705
80640: LD_INT 3
80642: DOUBLE
80643: EQUAL
80644: IFTRUE 80648
80646: GO 80704
80648: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80649: LD_ADDR_VAR 0 9
80653: PUSH
80654: LD_VAR 0 23
80658: PUSH
80659: LD_VAR 0 24
80663: PUSH
80664: LD_VAR 0 25
80668: PUSH
80669: LD_VAR 0 26
80673: PUSH
80674: LD_VAR 0 27
80678: PUSH
80679: LD_VAR 0 28
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: PUSH
80692: LD_VAR 0 4
80696: PUSH
80697: LD_INT 1
80699: PLUS
80700: ARRAY
80701: ST_TO_ADDR
80702: GO 80705
80704: POP
80705: GO 81260
80707: LD_INT 2
80709: DOUBLE
80710: EQUAL
80711: IFTRUE 80721
80713: LD_INT 3
80715: DOUBLE
80716: EQUAL
80717: IFTRUE 80721
80719: GO 80777
80721: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80722: LD_ADDR_VAR 0 9
80726: PUSH
80727: LD_VAR 0 29
80731: PUSH
80732: LD_VAR 0 30
80736: PUSH
80737: LD_VAR 0 31
80741: PUSH
80742: LD_VAR 0 32
80746: PUSH
80747: LD_VAR 0 33
80751: PUSH
80752: LD_VAR 0 34
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: PUSH
80765: LD_VAR 0 4
80769: PUSH
80770: LD_INT 1
80772: PLUS
80773: ARRAY
80774: ST_TO_ADDR
80775: GO 81260
80777: LD_INT 16
80779: DOUBLE
80780: EQUAL
80781: IFTRUE 80839
80783: LD_INT 17
80785: DOUBLE
80786: EQUAL
80787: IFTRUE 80839
80789: LD_INT 18
80791: DOUBLE
80792: EQUAL
80793: IFTRUE 80839
80795: LD_INT 19
80797: DOUBLE
80798: EQUAL
80799: IFTRUE 80839
80801: LD_INT 22
80803: DOUBLE
80804: EQUAL
80805: IFTRUE 80839
80807: LD_INT 20
80809: DOUBLE
80810: EQUAL
80811: IFTRUE 80839
80813: LD_INT 21
80815: DOUBLE
80816: EQUAL
80817: IFTRUE 80839
80819: LD_INT 23
80821: DOUBLE
80822: EQUAL
80823: IFTRUE 80839
80825: LD_INT 24
80827: DOUBLE
80828: EQUAL
80829: IFTRUE 80839
80831: LD_INT 25
80833: DOUBLE
80834: EQUAL
80835: IFTRUE 80839
80837: GO 80895
80839: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80840: LD_ADDR_VAR 0 9
80844: PUSH
80845: LD_VAR 0 35
80849: PUSH
80850: LD_VAR 0 36
80854: PUSH
80855: LD_VAR 0 37
80859: PUSH
80860: LD_VAR 0 38
80864: PUSH
80865: LD_VAR 0 39
80869: PUSH
80870: LD_VAR 0 40
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: PUSH
80883: LD_VAR 0 4
80887: PUSH
80888: LD_INT 1
80890: PLUS
80891: ARRAY
80892: ST_TO_ADDR
80893: GO 81260
80895: LD_INT 6
80897: DOUBLE
80898: EQUAL
80899: IFTRUE 80951
80901: LD_INT 7
80903: DOUBLE
80904: EQUAL
80905: IFTRUE 80951
80907: LD_INT 8
80909: DOUBLE
80910: EQUAL
80911: IFTRUE 80951
80913: LD_INT 13
80915: DOUBLE
80916: EQUAL
80917: IFTRUE 80951
80919: LD_INT 12
80921: DOUBLE
80922: EQUAL
80923: IFTRUE 80951
80925: LD_INT 15
80927: DOUBLE
80928: EQUAL
80929: IFTRUE 80951
80931: LD_INT 11
80933: DOUBLE
80934: EQUAL
80935: IFTRUE 80951
80937: LD_INT 14
80939: DOUBLE
80940: EQUAL
80941: IFTRUE 80951
80943: LD_INT 10
80945: DOUBLE
80946: EQUAL
80947: IFTRUE 80951
80949: GO 81007
80951: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
80952: LD_ADDR_VAR 0 9
80956: PUSH
80957: LD_VAR 0 41
80961: PUSH
80962: LD_VAR 0 42
80966: PUSH
80967: LD_VAR 0 43
80971: PUSH
80972: LD_VAR 0 44
80976: PUSH
80977: LD_VAR 0 45
80981: PUSH
80982: LD_VAR 0 46
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: PUSH
80995: LD_VAR 0 4
80999: PUSH
81000: LD_INT 1
81002: PLUS
81003: ARRAY
81004: ST_TO_ADDR
81005: GO 81260
81007: LD_INT 36
81009: DOUBLE
81010: EQUAL
81011: IFTRUE 81015
81013: GO 81071
81015: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81016: LD_ADDR_VAR 0 9
81020: PUSH
81021: LD_VAR 0 47
81025: PUSH
81026: LD_VAR 0 48
81030: PUSH
81031: LD_VAR 0 49
81035: PUSH
81036: LD_VAR 0 50
81040: PUSH
81041: LD_VAR 0 51
81045: PUSH
81046: LD_VAR 0 52
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: PUSH
81059: LD_VAR 0 4
81063: PUSH
81064: LD_INT 1
81066: PLUS
81067: ARRAY
81068: ST_TO_ADDR
81069: GO 81260
81071: LD_INT 4
81073: DOUBLE
81074: EQUAL
81075: IFTRUE 81097
81077: LD_INT 5
81079: DOUBLE
81080: EQUAL
81081: IFTRUE 81097
81083: LD_INT 34
81085: DOUBLE
81086: EQUAL
81087: IFTRUE 81097
81089: LD_INT 37
81091: DOUBLE
81092: EQUAL
81093: IFTRUE 81097
81095: GO 81153
81097: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81098: LD_ADDR_VAR 0 9
81102: PUSH
81103: LD_VAR 0 53
81107: PUSH
81108: LD_VAR 0 54
81112: PUSH
81113: LD_VAR 0 55
81117: PUSH
81118: LD_VAR 0 56
81122: PUSH
81123: LD_VAR 0 57
81127: PUSH
81128: LD_VAR 0 58
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: PUSH
81141: LD_VAR 0 4
81145: PUSH
81146: LD_INT 1
81148: PLUS
81149: ARRAY
81150: ST_TO_ADDR
81151: GO 81260
81153: LD_INT 31
81155: DOUBLE
81156: EQUAL
81157: IFTRUE 81203
81159: LD_INT 32
81161: DOUBLE
81162: EQUAL
81163: IFTRUE 81203
81165: LD_INT 33
81167: DOUBLE
81168: EQUAL
81169: IFTRUE 81203
81171: LD_INT 27
81173: DOUBLE
81174: EQUAL
81175: IFTRUE 81203
81177: LD_INT 26
81179: DOUBLE
81180: EQUAL
81181: IFTRUE 81203
81183: LD_INT 28
81185: DOUBLE
81186: EQUAL
81187: IFTRUE 81203
81189: LD_INT 29
81191: DOUBLE
81192: EQUAL
81193: IFTRUE 81203
81195: LD_INT 30
81197: DOUBLE
81198: EQUAL
81199: IFTRUE 81203
81201: GO 81259
81203: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
81204: LD_ADDR_VAR 0 9
81208: PUSH
81209: LD_VAR 0 59
81213: PUSH
81214: LD_VAR 0 60
81218: PUSH
81219: LD_VAR 0 61
81223: PUSH
81224: LD_VAR 0 62
81228: PUSH
81229: LD_VAR 0 63
81233: PUSH
81234: LD_VAR 0 64
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: PUSH
81247: LD_VAR 0 4
81251: PUSH
81252: LD_INT 1
81254: PLUS
81255: ARRAY
81256: ST_TO_ADDR
81257: GO 81260
81259: POP
// temp_list2 = [ ] ;
81260: LD_ADDR_VAR 0 10
81264: PUSH
81265: EMPTY
81266: ST_TO_ADDR
// for i in temp_list do
81267: LD_ADDR_VAR 0 8
81271: PUSH
81272: LD_VAR 0 9
81276: PUSH
81277: FOR_IN
81278: IFFALSE 81330
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81280: LD_ADDR_VAR 0 10
81284: PUSH
81285: LD_VAR 0 10
81289: PUSH
81290: LD_VAR 0 8
81294: PUSH
81295: LD_INT 1
81297: ARRAY
81298: PUSH
81299: LD_VAR 0 2
81303: PLUS
81304: PUSH
81305: LD_VAR 0 8
81309: PUSH
81310: LD_INT 2
81312: ARRAY
81313: PUSH
81314: LD_VAR 0 3
81318: PLUS
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: EMPTY
81325: LIST
81326: ADD
81327: ST_TO_ADDR
81328: GO 81277
81330: POP
81331: POP
// result = temp_list2 ;
81332: LD_ADDR_VAR 0 7
81336: PUSH
81337: LD_VAR 0 10
81341: ST_TO_ADDR
// end ;
81342: LD_VAR 0 7
81346: RET
// export function EnemyInRange ( unit , dist ) ; begin
81347: LD_INT 0
81349: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81350: LD_ADDR_VAR 0 3
81354: PUSH
81355: LD_VAR 0 1
81359: PPUSH
81360: CALL_OW 255
81364: PPUSH
81365: LD_VAR 0 1
81369: PPUSH
81370: CALL_OW 250
81374: PPUSH
81375: LD_VAR 0 1
81379: PPUSH
81380: CALL_OW 251
81384: PPUSH
81385: LD_VAR 0 2
81389: PPUSH
81390: CALL 55451 0 4
81394: PUSH
81395: LD_INT 4
81397: ARRAY
81398: ST_TO_ADDR
// end ;
81399: LD_VAR 0 3
81403: RET
// export function PlayerSeeMe ( unit ) ; begin
81404: LD_INT 0
81406: PPUSH
// result := See ( your_side , unit ) ;
81407: LD_ADDR_VAR 0 2
81411: PUSH
81412: LD_OWVAR 2
81416: PPUSH
81417: LD_VAR 0 1
81421: PPUSH
81422: CALL_OW 292
81426: ST_TO_ADDR
// end ;
81427: LD_VAR 0 2
81431: RET
// export function ReverseDir ( unit ) ; begin
81432: LD_INT 0
81434: PPUSH
// if not unit then
81435: LD_VAR 0 1
81439: NOT
81440: IFFALSE 81444
// exit ;
81442: GO 81490
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
81444: LD_ADDR_VAR 0 2
81448: PUSH
81449: LD_INT 3
81451: PUSH
81452: LD_INT 4
81454: PUSH
81455: LD_INT 5
81457: PUSH
81458: LD_INT 0
81460: PUSH
81461: LD_INT 1
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: PUSH
81475: LD_VAR 0 1
81479: PPUSH
81480: CALL_OW 254
81484: PUSH
81485: LD_INT 1
81487: PLUS
81488: ARRAY
81489: ST_TO_ADDR
// end ;
81490: LD_VAR 0 2
81494: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81495: LD_INT 0
81497: PPUSH
81498: PPUSH
81499: PPUSH
81500: PPUSH
81501: PPUSH
// if not hexes then
81502: LD_VAR 0 2
81506: NOT
81507: IFFALSE 81511
// exit ;
81509: GO 81659
// dist := 9999 ;
81511: LD_ADDR_VAR 0 5
81515: PUSH
81516: LD_INT 9999
81518: ST_TO_ADDR
// for i = 1 to hexes do
81519: LD_ADDR_VAR 0 4
81523: PUSH
81524: DOUBLE
81525: LD_INT 1
81527: DEC
81528: ST_TO_ADDR
81529: LD_VAR 0 2
81533: PUSH
81534: FOR_TO
81535: IFFALSE 81647
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81537: LD_VAR 0 1
81541: PPUSH
81542: LD_VAR 0 2
81546: PUSH
81547: LD_VAR 0 4
81551: ARRAY
81552: PUSH
81553: LD_INT 1
81555: ARRAY
81556: PPUSH
81557: LD_VAR 0 2
81561: PUSH
81562: LD_VAR 0 4
81566: ARRAY
81567: PUSH
81568: LD_INT 2
81570: ARRAY
81571: PPUSH
81572: CALL_OW 297
81576: PUSH
81577: LD_VAR 0 5
81581: LESS
81582: IFFALSE 81645
// begin hex := hexes [ i ] ;
81584: LD_ADDR_VAR 0 7
81588: PUSH
81589: LD_VAR 0 2
81593: PUSH
81594: LD_VAR 0 4
81598: ARRAY
81599: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81600: LD_ADDR_VAR 0 5
81604: PUSH
81605: LD_VAR 0 1
81609: PPUSH
81610: LD_VAR 0 2
81614: PUSH
81615: LD_VAR 0 4
81619: ARRAY
81620: PUSH
81621: LD_INT 1
81623: ARRAY
81624: PPUSH
81625: LD_VAR 0 2
81629: PUSH
81630: LD_VAR 0 4
81634: ARRAY
81635: PUSH
81636: LD_INT 2
81638: ARRAY
81639: PPUSH
81640: CALL_OW 297
81644: ST_TO_ADDR
// end ; end ;
81645: GO 81534
81647: POP
81648: POP
// result := hex ;
81649: LD_ADDR_VAR 0 3
81653: PUSH
81654: LD_VAR 0 7
81658: ST_TO_ADDR
// end ;
81659: LD_VAR 0 3
81663: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81664: LD_INT 0
81666: PPUSH
81667: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81668: LD_VAR 0 1
81672: NOT
81673: PUSH
81674: LD_VAR 0 1
81678: PUSH
81679: LD_INT 21
81681: PUSH
81682: LD_INT 2
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 23
81691: PUSH
81692: LD_INT 2
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PPUSH
81703: CALL_OW 69
81707: IN
81708: NOT
81709: OR
81710: IFFALSE 81714
// exit ;
81712: GO 81761
// for i = 1 to 3 do
81714: LD_ADDR_VAR 0 3
81718: PUSH
81719: DOUBLE
81720: LD_INT 1
81722: DEC
81723: ST_TO_ADDR
81724: LD_INT 3
81726: PUSH
81727: FOR_TO
81728: IFFALSE 81759
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81730: LD_VAR 0 1
81734: PPUSH
81735: CALL_OW 250
81739: PPUSH
81740: LD_VAR 0 1
81744: PPUSH
81745: CALL_OW 251
81749: PPUSH
81750: LD_INT 1
81752: PPUSH
81753: CALL_OW 453
81757: GO 81727
81759: POP
81760: POP
// end ;
81761: LD_VAR 0 2
81765: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81766: LD_INT 0
81768: PPUSH
81769: PPUSH
81770: PPUSH
81771: PPUSH
81772: PPUSH
81773: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81774: LD_VAR 0 1
81778: NOT
81779: PUSH
81780: LD_VAR 0 2
81784: NOT
81785: OR
81786: PUSH
81787: LD_VAR 0 1
81791: PPUSH
81792: CALL_OW 314
81796: OR
81797: IFFALSE 81801
// exit ;
81799: GO 82242
// x := GetX ( enemy_unit ) ;
81801: LD_ADDR_VAR 0 7
81805: PUSH
81806: LD_VAR 0 2
81810: PPUSH
81811: CALL_OW 250
81815: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81816: LD_ADDR_VAR 0 8
81820: PUSH
81821: LD_VAR 0 2
81825: PPUSH
81826: CALL_OW 251
81830: ST_TO_ADDR
// if not x or not y then
81831: LD_VAR 0 7
81835: NOT
81836: PUSH
81837: LD_VAR 0 8
81841: NOT
81842: OR
81843: IFFALSE 81847
// exit ;
81845: GO 82242
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81847: LD_ADDR_VAR 0 6
81851: PUSH
81852: LD_VAR 0 7
81856: PPUSH
81857: LD_INT 0
81859: PPUSH
81860: LD_INT 4
81862: PPUSH
81863: CALL_OW 272
81867: PUSH
81868: LD_VAR 0 8
81872: PPUSH
81873: LD_INT 0
81875: PPUSH
81876: LD_INT 4
81878: PPUSH
81879: CALL_OW 273
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_VAR 0 7
81892: PPUSH
81893: LD_INT 1
81895: PPUSH
81896: LD_INT 4
81898: PPUSH
81899: CALL_OW 272
81903: PUSH
81904: LD_VAR 0 8
81908: PPUSH
81909: LD_INT 1
81911: PPUSH
81912: LD_INT 4
81914: PPUSH
81915: CALL_OW 273
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_VAR 0 7
81928: PPUSH
81929: LD_INT 2
81931: PPUSH
81932: LD_INT 4
81934: PPUSH
81935: CALL_OW 272
81939: PUSH
81940: LD_VAR 0 8
81944: PPUSH
81945: LD_INT 2
81947: PPUSH
81948: LD_INT 4
81950: PPUSH
81951: CALL_OW 273
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_VAR 0 7
81964: PPUSH
81965: LD_INT 3
81967: PPUSH
81968: LD_INT 4
81970: PPUSH
81971: CALL_OW 272
81975: PUSH
81976: LD_VAR 0 8
81980: PPUSH
81981: LD_INT 3
81983: PPUSH
81984: LD_INT 4
81986: PPUSH
81987: CALL_OW 273
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_VAR 0 7
82000: PPUSH
82001: LD_INT 4
82003: PPUSH
82004: LD_INT 4
82006: PPUSH
82007: CALL_OW 272
82011: PUSH
82012: LD_VAR 0 8
82016: PPUSH
82017: LD_INT 4
82019: PPUSH
82020: LD_INT 4
82022: PPUSH
82023: CALL_OW 273
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_VAR 0 7
82036: PPUSH
82037: LD_INT 5
82039: PPUSH
82040: LD_INT 4
82042: PPUSH
82043: CALL_OW 272
82047: PUSH
82048: LD_VAR 0 8
82052: PPUSH
82053: LD_INT 5
82055: PPUSH
82056: LD_INT 4
82058: PPUSH
82059: CALL_OW 273
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: ST_TO_ADDR
// for i = tmp downto 1 do
82076: LD_ADDR_VAR 0 4
82080: PUSH
82081: DOUBLE
82082: LD_VAR 0 6
82086: INC
82087: ST_TO_ADDR
82088: LD_INT 1
82090: PUSH
82091: FOR_DOWNTO
82092: IFFALSE 82193
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82094: LD_VAR 0 6
82098: PUSH
82099: LD_VAR 0 4
82103: ARRAY
82104: PUSH
82105: LD_INT 1
82107: ARRAY
82108: PPUSH
82109: LD_VAR 0 6
82113: PUSH
82114: LD_VAR 0 4
82118: ARRAY
82119: PUSH
82120: LD_INT 2
82122: ARRAY
82123: PPUSH
82124: CALL_OW 488
82128: NOT
82129: PUSH
82130: LD_VAR 0 6
82134: PUSH
82135: LD_VAR 0 4
82139: ARRAY
82140: PUSH
82141: LD_INT 1
82143: ARRAY
82144: PPUSH
82145: LD_VAR 0 6
82149: PUSH
82150: LD_VAR 0 4
82154: ARRAY
82155: PUSH
82156: LD_INT 2
82158: ARRAY
82159: PPUSH
82160: CALL_OW 428
82164: PUSH
82165: LD_INT 0
82167: NONEQUAL
82168: OR
82169: IFFALSE 82191
// tmp := Delete ( tmp , i ) ;
82171: LD_ADDR_VAR 0 6
82175: PUSH
82176: LD_VAR 0 6
82180: PPUSH
82181: LD_VAR 0 4
82185: PPUSH
82186: CALL_OW 3
82190: ST_TO_ADDR
82191: GO 82091
82193: POP
82194: POP
// j := GetClosestHex ( unit , tmp ) ;
82195: LD_ADDR_VAR 0 5
82199: PUSH
82200: LD_VAR 0 1
82204: PPUSH
82205: LD_VAR 0 6
82209: PPUSH
82210: CALL 81495 0 2
82214: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82215: LD_VAR 0 1
82219: PPUSH
82220: LD_VAR 0 5
82224: PUSH
82225: LD_INT 1
82227: ARRAY
82228: PPUSH
82229: LD_VAR 0 5
82233: PUSH
82234: LD_INT 2
82236: ARRAY
82237: PPUSH
82238: CALL_OW 111
// end ;
82242: LD_VAR 0 3
82246: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82247: LD_INT 0
82249: PPUSH
82250: PPUSH
82251: PPUSH
// uc_side = 0 ;
82252: LD_ADDR_OWVAR 20
82256: PUSH
82257: LD_INT 0
82259: ST_TO_ADDR
// uc_nation = 0 ;
82260: LD_ADDR_OWVAR 21
82264: PUSH
82265: LD_INT 0
82267: ST_TO_ADDR
// InitHc ;
82268: CALL_OW 19
// InitVc ;
82272: CALL_OW 20
// if mastodonts then
82276: LD_VAR 0 6
82280: IFFALSE 82347
// for i = 1 to mastodonts do
82282: LD_ADDR_VAR 0 11
82286: PUSH
82287: DOUBLE
82288: LD_INT 1
82290: DEC
82291: ST_TO_ADDR
82292: LD_VAR 0 6
82296: PUSH
82297: FOR_TO
82298: IFFALSE 82345
// begin vc_chassis := 31 ;
82300: LD_ADDR_OWVAR 37
82304: PUSH
82305: LD_INT 31
82307: ST_TO_ADDR
// vc_control := control_rider ;
82308: LD_ADDR_OWVAR 38
82312: PUSH
82313: LD_INT 4
82315: ST_TO_ADDR
// animal := CreateVehicle ;
82316: LD_ADDR_VAR 0 12
82320: PUSH
82321: CALL_OW 45
82325: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82326: LD_VAR 0 12
82330: PPUSH
82331: LD_VAR 0 8
82335: PPUSH
82336: LD_INT 0
82338: PPUSH
82339: CALL 89092 0 3
// end ;
82343: GO 82297
82345: POP
82346: POP
// if horses then
82347: LD_VAR 0 5
82351: IFFALSE 82418
// for i = 1 to horses do
82353: LD_ADDR_VAR 0 11
82357: PUSH
82358: DOUBLE
82359: LD_INT 1
82361: DEC
82362: ST_TO_ADDR
82363: LD_VAR 0 5
82367: PUSH
82368: FOR_TO
82369: IFFALSE 82416
// begin hc_class := 21 ;
82371: LD_ADDR_OWVAR 28
82375: PUSH
82376: LD_INT 21
82378: ST_TO_ADDR
// hc_gallery :=  ;
82379: LD_ADDR_OWVAR 33
82383: PUSH
82384: LD_STRING 
82386: ST_TO_ADDR
// animal := CreateHuman ;
82387: LD_ADDR_VAR 0 12
82391: PUSH
82392: CALL_OW 44
82396: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82397: LD_VAR 0 12
82401: PPUSH
82402: LD_VAR 0 8
82406: PPUSH
82407: LD_INT 0
82409: PPUSH
82410: CALL 89092 0 3
// end ;
82414: GO 82368
82416: POP
82417: POP
// if birds then
82418: LD_VAR 0 1
82422: IFFALSE 82489
// for i = 1 to birds do
82424: LD_ADDR_VAR 0 11
82428: PUSH
82429: DOUBLE
82430: LD_INT 1
82432: DEC
82433: ST_TO_ADDR
82434: LD_VAR 0 1
82438: PUSH
82439: FOR_TO
82440: IFFALSE 82487
// begin hc_class = 18 ;
82442: LD_ADDR_OWVAR 28
82446: PUSH
82447: LD_INT 18
82449: ST_TO_ADDR
// hc_gallery =  ;
82450: LD_ADDR_OWVAR 33
82454: PUSH
82455: LD_STRING 
82457: ST_TO_ADDR
// animal := CreateHuman ;
82458: LD_ADDR_VAR 0 12
82462: PUSH
82463: CALL_OW 44
82467: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82468: LD_VAR 0 12
82472: PPUSH
82473: LD_VAR 0 8
82477: PPUSH
82478: LD_INT 0
82480: PPUSH
82481: CALL 89092 0 3
// end ;
82485: GO 82439
82487: POP
82488: POP
// if tigers then
82489: LD_VAR 0 2
82493: IFFALSE 82577
// for i = 1 to tigers do
82495: LD_ADDR_VAR 0 11
82499: PUSH
82500: DOUBLE
82501: LD_INT 1
82503: DEC
82504: ST_TO_ADDR
82505: LD_VAR 0 2
82509: PUSH
82510: FOR_TO
82511: IFFALSE 82575
// begin hc_class = class_tiger ;
82513: LD_ADDR_OWVAR 28
82517: PUSH
82518: LD_INT 14
82520: ST_TO_ADDR
// hc_gallery =  ;
82521: LD_ADDR_OWVAR 33
82525: PUSH
82526: LD_STRING 
82528: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82529: LD_ADDR_OWVAR 35
82533: PUSH
82534: LD_INT 7
82536: NEG
82537: PPUSH
82538: LD_INT 7
82540: PPUSH
82541: CALL_OW 12
82545: ST_TO_ADDR
// animal := CreateHuman ;
82546: LD_ADDR_VAR 0 12
82550: PUSH
82551: CALL_OW 44
82555: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82556: LD_VAR 0 12
82560: PPUSH
82561: LD_VAR 0 8
82565: PPUSH
82566: LD_INT 0
82568: PPUSH
82569: CALL 89092 0 3
// end ;
82573: GO 82510
82575: POP
82576: POP
// if apemans then
82577: LD_VAR 0 3
82581: IFFALSE 82704
// for i = 1 to apemans do
82583: LD_ADDR_VAR 0 11
82587: PUSH
82588: DOUBLE
82589: LD_INT 1
82591: DEC
82592: ST_TO_ADDR
82593: LD_VAR 0 3
82597: PUSH
82598: FOR_TO
82599: IFFALSE 82702
// begin hc_class = class_apeman ;
82601: LD_ADDR_OWVAR 28
82605: PUSH
82606: LD_INT 12
82608: ST_TO_ADDR
// hc_gallery =  ;
82609: LD_ADDR_OWVAR 33
82613: PUSH
82614: LD_STRING 
82616: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
82617: LD_ADDR_OWVAR 35
82621: PUSH
82622: LD_INT 5
82624: NEG
82625: PPUSH
82626: LD_INT 5
82628: PPUSH
82629: CALL_OW 12
82633: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82634: LD_ADDR_OWVAR 31
82638: PUSH
82639: LD_INT 1
82641: PPUSH
82642: LD_INT 3
82644: PPUSH
82645: CALL_OW 12
82649: PUSH
82650: LD_INT 1
82652: PPUSH
82653: LD_INT 3
82655: PPUSH
82656: CALL_OW 12
82660: PUSH
82661: LD_INT 0
82663: PUSH
82664: LD_INT 0
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: ST_TO_ADDR
// animal := CreateHuman ;
82673: LD_ADDR_VAR 0 12
82677: PUSH
82678: CALL_OW 44
82682: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82683: LD_VAR 0 12
82687: PPUSH
82688: LD_VAR 0 8
82692: PPUSH
82693: LD_INT 0
82695: PPUSH
82696: CALL 89092 0 3
// end ;
82700: GO 82598
82702: POP
82703: POP
// if enchidnas then
82704: LD_VAR 0 4
82708: IFFALSE 82775
// for i = 1 to enchidnas do
82710: LD_ADDR_VAR 0 11
82714: PUSH
82715: DOUBLE
82716: LD_INT 1
82718: DEC
82719: ST_TO_ADDR
82720: LD_VAR 0 4
82724: PUSH
82725: FOR_TO
82726: IFFALSE 82773
// begin hc_class = 13 ;
82728: LD_ADDR_OWVAR 28
82732: PUSH
82733: LD_INT 13
82735: ST_TO_ADDR
// hc_gallery =  ;
82736: LD_ADDR_OWVAR 33
82740: PUSH
82741: LD_STRING 
82743: ST_TO_ADDR
// animal := CreateHuman ;
82744: LD_ADDR_VAR 0 12
82748: PUSH
82749: CALL_OW 44
82753: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82754: LD_VAR 0 12
82758: PPUSH
82759: LD_VAR 0 8
82763: PPUSH
82764: LD_INT 0
82766: PPUSH
82767: CALL 89092 0 3
// end ;
82771: GO 82725
82773: POP
82774: POP
// if fishes then
82775: LD_VAR 0 7
82779: IFFALSE 82846
// for i = 1 to fishes do
82781: LD_ADDR_VAR 0 11
82785: PUSH
82786: DOUBLE
82787: LD_INT 1
82789: DEC
82790: ST_TO_ADDR
82791: LD_VAR 0 7
82795: PUSH
82796: FOR_TO
82797: IFFALSE 82844
// begin hc_class = 20 ;
82799: LD_ADDR_OWVAR 28
82803: PUSH
82804: LD_INT 20
82806: ST_TO_ADDR
// hc_gallery =  ;
82807: LD_ADDR_OWVAR 33
82811: PUSH
82812: LD_STRING 
82814: ST_TO_ADDR
// animal := CreateHuman ;
82815: LD_ADDR_VAR 0 12
82819: PUSH
82820: CALL_OW 44
82824: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82825: LD_VAR 0 12
82829: PPUSH
82830: LD_VAR 0 9
82834: PPUSH
82835: LD_INT 0
82837: PPUSH
82838: CALL 89092 0 3
// end ;
82842: GO 82796
82844: POP
82845: POP
// end ;
82846: LD_VAR 0 10
82850: RET
// export function WantHeal ( sci , unit ) ; begin
82851: LD_INT 0
82853: PPUSH
// if GetTaskList ( sci ) > 0 then
82854: LD_VAR 0 1
82858: PPUSH
82859: CALL_OW 437
82863: PUSH
82864: LD_INT 0
82866: GREATER
82867: IFFALSE 82937
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82869: LD_VAR 0 1
82873: PPUSH
82874: CALL_OW 437
82878: PUSH
82879: LD_INT 1
82881: ARRAY
82882: PUSH
82883: LD_INT 1
82885: ARRAY
82886: PUSH
82887: LD_STRING l
82889: EQUAL
82890: PUSH
82891: LD_VAR 0 1
82895: PPUSH
82896: CALL_OW 437
82900: PUSH
82901: LD_INT 1
82903: ARRAY
82904: PUSH
82905: LD_INT 4
82907: ARRAY
82908: PUSH
82909: LD_VAR 0 2
82913: EQUAL
82914: AND
82915: IFFALSE 82927
// result := true else
82917: LD_ADDR_VAR 0 3
82921: PUSH
82922: LD_INT 1
82924: ST_TO_ADDR
82925: GO 82935
// result := false ;
82927: LD_ADDR_VAR 0 3
82931: PUSH
82932: LD_INT 0
82934: ST_TO_ADDR
// end else
82935: GO 82945
// result := false ;
82937: LD_ADDR_VAR 0 3
82941: PUSH
82942: LD_INT 0
82944: ST_TO_ADDR
// end ;
82945: LD_VAR 0 3
82949: RET
// export function HealTarget ( sci ) ; begin
82950: LD_INT 0
82952: PPUSH
// if not sci then
82953: LD_VAR 0 1
82957: NOT
82958: IFFALSE 82962
// exit ;
82960: GO 83027
// result := 0 ;
82962: LD_ADDR_VAR 0 2
82966: PUSH
82967: LD_INT 0
82969: ST_TO_ADDR
// if GetTaskList ( sci ) then
82970: LD_VAR 0 1
82974: PPUSH
82975: CALL_OW 437
82979: IFFALSE 83027
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82981: LD_VAR 0 1
82985: PPUSH
82986: CALL_OW 437
82990: PUSH
82991: LD_INT 1
82993: ARRAY
82994: PUSH
82995: LD_INT 1
82997: ARRAY
82998: PUSH
82999: LD_STRING l
83001: EQUAL
83002: IFFALSE 83027
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83004: LD_ADDR_VAR 0 2
83008: PUSH
83009: LD_VAR 0 1
83013: PPUSH
83014: CALL_OW 437
83018: PUSH
83019: LD_INT 1
83021: ARRAY
83022: PUSH
83023: LD_INT 4
83025: ARRAY
83026: ST_TO_ADDR
// end ;
83027: LD_VAR 0 2
83031: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83032: LD_INT 0
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
83042: PPUSH
83043: PPUSH
83044: PPUSH
83045: PPUSH
83046: PPUSH
83047: PPUSH
83048: PPUSH
83049: PPUSH
83050: PPUSH
83051: PPUSH
83052: PPUSH
83053: PPUSH
83054: PPUSH
83055: PPUSH
83056: PPUSH
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
83065: PPUSH
83066: PPUSH
83067: PPUSH
// if not list then
83068: LD_VAR 0 1
83072: NOT
83073: IFFALSE 83077
// exit ;
83075: GO 87703
// base := list [ 1 ] ;
83077: LD_ADDR_VAR 0 3
83081: PUSH
83082: LD_VAR 0 1
83086: PUSH
83087: LD_INT 1
83089: ARRAY
83090: ST_TO_ADDR
// group := list [ 2 ] ;
83091: LD_ADDR_VAR 0 4
83095: PUSH
83096: LD_VAR 0 1
83100: PUSH
83101: LD_INT 2
83103: ARRAY
83104: ST_TO_ADDR
// path := list [ 3 ] ;
83105: LD_ADDR_VAR 0 5
83109: PUSH
83110: LD_VAR 0 1
83114: PUSH
83115: LD_INT 3
83117: ARRAY
83118: ST_TO_ADDR
// flags := list [ 4 ] ;
83119: LD_ADDR_VAR 0 6
83123: PUSH
83124: LD_VAR 0 1
83128: PUSH
83129: LD_INT 4
83131: ARRAY
83132: ST_TO_ADDR
// mined := [ ] ;
83133: LD_ADDR_VAR 0 27
83137: PUSH
83138: EMPTY
83139: ST_TO_ADDR
// bombed := [ ] ;
83140: LD_ADDR_VAR 0 28
83144: PUSH
83145: EMPTY
83146: ST_TO_ADDR
// healers := [ ] ;
83147: LD_ADDR_VAR 0 31
83151: PUSH
83152: EMPTY
83153: ST_TO_ADDR
// to_heal := [ ] ;
83154: LD_ADDR_VAR 0 30
83158: PUSH
83159: EMPTY
83160: ST_TO_ADDR
// repairs := [ ] ;
83161: LD_ADDR_VAR 0 33
83165: PUSH
83166: EMPTY
83167: ST_TO_ADDR
// to_repair := [ ] ;
83168: LD_ADDR_VAR 0 32
83172: PUSH
83173: EMPTY
83174: ST_TO_ADDR
// if not group or not path then
83175: LD_VAR 0 4
83179: NOT
83180: PUSH
83181: LD_VAR 0 5
83185: NOT
83186: OR
83187: IFFALSE 83191
// exit ;
83189: GO 87703
// side := GetSide ( group [ 1 ] ) ;
83191: LD_ADDR_VAR 0 35
83195: PUSH
83196: LD_VAR 0 4
83200: PUSH
83201: LD_INT 1
83203: ARRAY
83204: PPUSH
83205: CALL_OW 255
83209: ST_TO_ADDR
// if flags then
83210: LD_VAR 0 6
83214: IFFALSE 83358
// begin f_ignore_area := flags [ 1 ] ;
83216: LD_ADDR_VAR 0 17
83220: PUSH
83221: LD_VAR 0 6
83225: PUSH
83226: LD_INT 1
83228: ARRAY
83229: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83230: LD_ADDR_VAR 0 18
83234: PUSH
83235: LD_VAR 0 6
83239: PUSH
83240: LD_INT 2
83242: ARRAY
83243: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83244: LD_ADDR_VAR 0 19
83248: PUSH
83249: LD_VAR 0 6
83253: PUSH
83254: LD_INT 3
83256: ARRAY
83257: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83258: LD_ADDR_VAR 0 20
83262: PUSH
83263: LD_VAR 0 6
83267: PUSH
83268: LD_INT 4
83270: ARRAY
83271: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83272: LD_ADDR_VAR 0 21
83276: PUSH
83277: LD_VAR 0 6
83281: PUSH
83282: LD_INT 5
83284: ARRAY
83285: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83286: LD_ADDR_VAR 0 22
83290: PUSH
83291: LD_VAR 0 6
83295: PUSH
83296: LD_INT 6
83298: ARRAY
83299: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83300: LD_ADDR_VAR 0 23
83304: PUSH
83305: LD_VAR 0 6
83309: PUSH
83310: LD_INT 7
83312: ARRAY
83313: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83314: LD_ADDR_VAR 0 24
83318: PUSH
83319: LD_VAR 0 6
83323: PUSH
83324: LD_INT 8
83326: ARRAY
83327: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83328: LD_ADDR_VAR 0 25
83332: PUSH
83333: LD_VAR 0 6
83337: PUSH
83338: LD_INT 9
83340: ARRAY
83341: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83342: LD_ADDR_VAR 0 26
83346: PUSH
83347: LD_VAR 0 6
83351: PUSH
83352: LD_INT 10
83354: ARRAY
83355: ST_TO_ADDR
// end else
83356: GO 83438
// begin f_ignore_area := false ;
83358: LD_ADDR_VAR 0 17
83362: PUSH
83363: LD_INT 0
83365: ST_TO_ADDR
// f_capture := false ;
83366: LD_ADDR_VAR 0 18
83370: PUSH
83371: LD_INT 0
83373: ST_TO_ADDR
// f_ignore_civ := false ;
83374: LD_ADDR_VAR 0 19
83378: PUSH
83379: LD_INT 0
83381: ST_TO_ADDR
// f_murder := false ;
83382: LD_ADDR_VAR 0 20
83386: PUSH
83387: LD_INT 0
83389: ST_TO_ADDR
// f_mines := false ;
83390: LD_ADDR_VAR 0 21
83394: PUSH
83395: LD_INT 0
83397: ST_TO_ADDR
// f_repair := false ;
83398: LD_ADDR_VAR 0 22
83402: PUSH
83403: LD_INT 0
83405: ST_TO_ADDR
// f_heal := false ;
83406: LD_ADDR_VAR 0 23
83410: PUSH
83411: LD_INT 0
83413: ST_TO_ADDR
// f_spacetime := false ;
83414: LD_ADDR_VAR 0 24
83418: PUSH
83419: LD_INT 0
83421: ST_TO_ADDR
// f_attack_depot := false ;
83422: LD_ADDR_VAR 0 25
83426: PUSH
83427: LD_INT 0
83429: ST_TO_ADDR
// f_crawl := false ;
83430: LD_ADDR_VAR 0 26
83434: PUSH
83435: LD_INT 0
83437: ST_TO_ADDR
// end ; if f_heal then
83438: LD_VAR 0 23
83442: IFFALSE 83469
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83444: LD_ADDR_VAR 0 31
83448: PUSH
83449: LD_VAR 0 4
83453: PPUSH
83454: LD_INT 25
83456: PUSH
83457: LD_INT 4
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PPUSH
83464: CALL_OW 72
83468: ST_TO_ADDR
// if f_repair then
83469: LD_VAR 0 22
83473: IFFALSE 83500
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83475: LD_ADDR_VAR 0 33
83479: PUSH
83480: LD_VAR 0 4
83484: PPUSH
83485: LD_INT 25
83487: PUSH
83488: LD_INT 3
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PPUSH
83495: CALL_OW 72
83499: ST_TO_ADDR
// units_path := [ ] ;
83500: LD_ADDR_VAR 0 16
83504: PUSH
83505: EMPTY
83506: ST_TO_ADDR
// for i = 1 to group do
83507: LD_ADDR_VAR 0 7
83511: PUSH
83512: DOUBLE
83513: LD_INT 1
83515: DEC
83516: ST_TO_ADDR
83517: LD_VAR 0 4
83521: PUSH
83522: FOR_TO
83523: IFFALSE 83552
// units_path := Replace ( units_path , i , path ) ;
83525: LD_ADDR_VAR 0 16
83529: PUSH
83530: LD_VAR 0 16
83534: PPUSH
83535: LD_VAR 0 7
83539: PPUSH
83540: LD_VAR 0 5
83544: PPUSH
83545: CALL_OW 1
83549: ST_TO_ADDR
83550: GO 83522
83552: POP
83553: POP
// repeat for i = group downto 1 do
83554: LD_ADDR_VAR 0 7
83558: PUSH
83559: DOUBLE
83560: LD_VAR 0 4
83564: INC
83565: ST_TO_ADDR
83566: LD_INT 1
83568: PUSH
83569: FOR_DOWNTO
83570: IFFALSE 87666
// begin wait ( 5 ) ;
83572: LD_INT 5
83574: PPUSH
83575: CALL_OW 67
// tmp := [ ] ;
83579: LD_ADDR_VAR 0 14
83583: PUSH
83584: EMPTY
83585: ST_TO_ADDR
// attacking := false ;
83586: LD_ADDR_VAR 0 29
83590: PUSH
83591: LD_INT 0
83593: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83594: LD_VAR 0 4
83598: PUSH
83599: LD_VAR 0 7
83603: ARRAY
83604: PPUSH
83605: CALL_OW 301
83609: PUSH
83610: LD_VAR 0 4
83614: PUSH
83615: LD_VAR 0 7
83619: ARRAY
83620: NOT
83621: OR
83622: IFFALSE 83731
// begin if GetType ( group [ i ] ) = unit_human then
83624: LD_VAR 0 4
83628: PUSH
83629: LD_VAR 0 7
83633: ARRAY
83634: PPUSH
83635: CALL_OW 247
83639: PUSH
83640: LD_INT 1
83642: EQUAL
83643: IFFALSE 83689
// begin to_heal := to_heal diff group [ i ] ;
83645: LD_ADDR_VAR 0 30
83649: PUSH
83650: LD_VAR 0 30
83654: PUSH
83655: LD_VAR 0 4
83659: PUSH
83660: LD_VAR 0 7
83664: ARRAY
83665: DIFF
83666: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83667: LD_ADDR_VAR 0 31
83671: PUSH
83672: LD_VAR 0 31
83676: PUSH
83677: LD_VAR 0 4
83681: PUSH
83682: LD_VAR 0 7
83686: ARRAY
83687: DIFF
83688: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83689: LD_ADDR_VAR 0 4
83693: PUSH
83694: LD_VAR 0 4
83698: PPUSH
83699: LD_VAR 0 7
83703: PPUSH
83704: CALL_OW 3
83708: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83709: LD_ADDR_VAR 0 16
83713: PUSH
83714: LD_VAR 0 16
83718: PPUSH
83719: LD_VAR 0 7
83723: PPUSH
83724: CALL_OW 3
83728: ST_TO_ADDR
// continue ;
83729: GO 83569
// end ; if f_repair then
83731: LD_VAR 0 22
83735: IFFALSE 84224
// begin if GetType ( group [ i ] ) = unit_vehicle then
83737: LD_VAR 0 4
83741: PUSH
83742: LD_VAR 0 7
83746: ARRAY
83747: PPUSH
83748: CALL_OW 247
83752: PUSH
83753: LD_INT 2
83755: EQUAL
83756: IFFALSE 83946
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83758: LD_VAR 0 4
83762: PUSH
83763: LD_VAR 0 7
83767: ARRAY
83768: PPUSH
83769: CALL_OW 256
83773: PUSH
83774: LD_INT 700
83776: LESS
83777: PUSH
83778: LD_VAR 0 4
83782: PUSH
83783: LD_VAR 0 7
83787: ARRAY
83788: PUSH
83789: LD_VAR 0 32
83793: IN
83794: NOT
83795: AND
83796: IFFALSE 83820
// to_repair := to_repair union group [ i ] ;
83798: LD_ADDR_VAR 0 32
83802: PUSH
83803: LD_VAR 0 32
83807: PUSH
83808: LD_VAR 0 4
83812: PUSH
83813: LD_VAR 0 7
83817: ARRAY
83818: UNION
83819: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83820: LD_VAR 0 4
83824: PUSH
83825: LD_VAR 0 7
83829: ARRAY
83830: PPUSH
83831: CALL_OW 256
83835: PUSH
83836: LD_INT 1000
83838: EQUAL
83839: PUSH
83840: LD_VAR 0 4
83844: PUSH
83845: LD_VAR 0 7
83849: ARRAY
83850: PUSH
83851: LD_VAR 0 32
83855: IN
83856: AND
83857: IFFALSE 83881
// to_repair := to_repair diff group [ i ] ;
83859: LD_ADDR_VAR 0 32
83863: PUSH
83864: LD_VAR 0 32
83868: PUSH
83869: LD_VAR 0 4
83873: PUSH
83874: LD_VAR 0 7
83878: ARRAY
83879: DIFF
83880: ST_TO_ADDR
// if group [ i ] in to_repair then
83881: LD_VAR 0 4
83885: PUSH
83886: LD_VAR 0 7
83890: ARRAY
83891: PUSH
83892: LD_VAR 0 32
83896: IN
83897: IFFALSE 83944
// begin if not IsInArea ( group [ i ] , f_repair ) then
83899: LD_VAR 0 4
83903: PUSH
83904: LD_VAR 0 7
83908: ARRAY
83909: PPUSH
83910: LD_VAR 0 22
83914: PPUSH
83915: CALL_OW 308
83919: NOT
83920: IFFALSE 83942
// ComMoveToArea ( group [ i ] , f_repair ) ;
83922: LD_VAR 0 4
83926: PUSH
83927: LD_VAR 0 7
83931: ARRAY
83932: PPUSH
83933: LD_VAR 0 22
83937: PPUSH
83938: CALL_OW 113
// continue ;
83942: GO 83569
// end ; end else
83944: GO 84224
// if group [ i ] in repairs then
83946: LD_VAR 0 4
83950: PUSH
83951: LD_VAR 0 7
83955: ARRAY
83956: PUSH
83957: LD_VAR 0 33
83961: IN
83962: IFFALSE 84224
// begin if IsInUnit ( group [ i ] ) then
83964: LD_VAR 0 4
83968: PUSH
83969: LD_VAR 0 7
83973: ARRAY
83974: PPUSH
83975: CALL_OW 310
83979: IFFALSE 84047
// begin z := IsInUnit ( group [ i ] ) ;
83981: LD_ADDR_VAR 0 13
83985: PUSH
83986: LD_VAR 0 4
83990: PUSH
83991: LD_VAR 0 7
83995: ARRAY
83996: PPUSH
83997: CALL_OW 310
84001: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84002: LD_VAR 0 13
84006: PUSH
84007: LD_VAR 0 32
84011: IN
84012: PUSH
84013: LD_VAR 0 13
84017: PPUSH
84018: LD_VAR 0 22
84022: PPUSH
84023: CALL_OW 308
84027: AND
84028: IFFALSE 84045
// ComExitVehicle ( group [ i ] ) ;
84030: LD_VAR 0 4
84034: PUSH
84035: LD_VAR 0 7
84039: ARRAY
84040: PPUSH
84041: CALL_OW 121
// end else
84045: GO 84224
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84047: LD_ADDR_VAR 0 13
84051: PUSH
84052: LD_VAR 0 4
84056: PPUSH
84057: LD_INT 95
84059: PUSH
84060: LD_VAR 0 22
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 58
84071: PUSH
84072: EMPTY
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PPUSH
84079: CALL_OW 72
84083: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84084: LD_VAR 0 4
84088: PUSH
84089: LD_VAR 0 7
84093: ARRAY
84094: PPUSH
84095: CALL_OW 314
84099: NOT
84100: IFFALSE 84222
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84102: LD_ADDR_VAR 0 10
84106: PUSH
84107: LD_VAR 0 13
84111: PPUSH
84112: LD_VAR 0 4
84116: PUSH
84117: LD_VAR 0 7
84121: ARRAY
84122: PPUSH
84123: CALL_OW 74
84127: ST_TO_ADDR
// if not x then
84128: LD_VAR 0 10
84132: NOT
84133: IFFALSE 84137
// continue ;
84135: GO 83569
// if GetLives ( x ) < 1000 then
84137: LD_VAR 0 10
84141: PPUSH
84142: CALL_OW 256
84146: PUSH
84147: LD_INT 1000
84149: LESS
84150: IFFALSE 84174
// ComRepairVehicle ( group [ i ] , x ) else
84152: LD_VAR 0 4
84156: PUSH
84157: LD_VAR 0 7
84161: ARRAY
84162: PPUSH
84163: LD_VAR 0 10
84167: PPUSH
84168: CALL_OW 129
84172: GO 84222
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84174: LD_VAR 0 23
84178: PUSH
84179: LD_VAR 0 4
84183: PUSH
84184: LD_VAR 0 7
84188: ARRAY
84189: PPUSH
84190: CALL_OW 256
84194: PUSH
84195: LD_INT 1000
84197: LESS
84198: AND
84199: NOT
84200: IFFALSE 84222
// ComEnterUnit ( group [ i ] , x ) ;
84202: LD_VAR 0 4
84206: PUSH
84207: LD_VAR 0 7
84211: ARRAY
84212: PPUSH
84213: LD_VAR 0 10
84217: PPUSH
84218: CALL_OW 120
// end ; continue ;
84222: GO 83569
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84224: LD_VAR 0 23
84228: PUSH
84229: LD_VAR 0 4
84233: PUSH
84234: LD_VAR 0 7
84238: ARRAY
84239: PPUSH
84240: CALL_OW 247
84244: PUSH
84245: LD_INT 1
84247: EQUAL
84248: AND
84249: IFFALSE 84727
// begin if group [ i ] in healers then
84251: LD_VAR 0 4
84255: PUSH
84256: LD_VAR 0 7
84260: ARRAY
84261: PUSH
84262: LD_VAR 0 31
84266: IN
84267: IFFALSE 84540
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84269: LD_VAR 0 4
84273: PUSH
84274: LD_VAR 0 7
84278: ARRAY
84279: PPUSH
84280: LD_VAR 0 23
84284: PPUSH
84285: CALL_OW 308
84289: NOT
84290: PUSH
84291: LD_VAR 0 4
84295: PUSH
84296: LD_VAR 0 7
84300: ARRAY
84301: PPUSH
84302: CALL_OW 314
84306: NOT
84307: AND
84308: IFFALSE 84332
// ComMoveToArea ( group [ i ] , f_heal ) else
84310: LD_VAR 0 4
84314: PUSH
84315: LD_VAR 0 7
84319: ARRAY
84320: PPUSH
84321: LD_VAR 0 23
84325: PPUSH
84326: CALL_OW 113
84330: GO 84538
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84332: LD_VAR 0 4
84336: PUSH
84337: LD_VAR 0 7
84341: ARRAY
84342: PPUSH
84343: CALL 82950 0 1
84347: PPUSH
84348: CALL_OW 256
84352: PUSH
84353: LD_INT 1000
84355: EQUAL
84356: IFFALSE 84375
// ComStop ( group [ i ] ) else
84358: LD_VAR 0 4
84362: PUSH
84363: LD_VAR 0 7
84367: ARRAY
84368: PPUSH
84369: CALL_OW 141
84373: GO 84538
// if not HasTask ( group [ i ] ) and to_heal then
84375: LD_VAR 0 4
84379: PUSH
84380: LD_VAR 0 7
84384: ARRAY
84385: PPUSH
84386: CALL_OW 314
84390: NOT
84391: PUSH
84392: LD_VAR 0 30
84396: AND
84397: IFFALSE 84538
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84399: LD_ADDR_VAR 0 13
84403: PUSH
84404: LD_VAR 0 30
84408: PPUSH
84409: LD_INT 3
84411: PUSH
84412: LD_INT 54
84414: PUSH
84415: EMPTY
84416: LIST
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PPUSH
84422: CALL_OW 72
84426: PPUSH
84427: LD_VAR 0 4
84431: PUSH
84432: LD_VAR 0 7
84436: ARRAY
84437: PPUSH
84438: CALL_OW 74
84442: ST_TO_ADDR
// if z then
84443: LD_VAR 0 13
84447: IFFALSE 84538
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84449: LD_INT 91
84451: PUSH
84452: LD_VAR 0 13
84456: PUSH
84457: LD_INT 10
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 81
84467: PUSH
84468: LD_VAR 0 13
84472: PPUSH
84473: CALL_OW 255
84477: PUSH
84478: EMPTY
84479: LIST
84480: LIST
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PPUSH
84486: CALL_OW 69
84490: PUSH
84491: LD_INT 0
84493: EQUAL
84494: IFFALSE 84518
// ComHeal ( group [ i ] , z ) else
84496: LD_VAR 0 4
84500: PUSH
84501: LD_VAR 0 7
84505: ARRAY
84506: PPUSH
84507: LD_VAR 0 13
84511: PPUSH
84512: CALL_OW 128
84516: GO 84538
// ComMoveToArea ( group [ i ] , f_heal ) ;
84518: LD_VAR 0 4
84522: PUSH
84523: LD_VAR 0 7
84527: ARRAY
84528: PPUSH
84529: LD_VAR 0 23
84533: PPUSH
84534: CALL_OW 113
// end ; continue ;
84538: GO 83569
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84540: LD_VAR 0 4
84544: PUSH
84545: LD_VAR 0 7
84549: ARRAY
84550: PPUSH
84551: CALL_OW 256
84555: PUSH
84556: LD_INT 700
84558: LESS
84559: PUSH
84560: LD_VAR 0 4
84564: PUSH
84565: LD_VAR 0 7
84569: ARRAY
84570: PUSH
84571: LD_VAR 0 30
84575: IN
84576: NOT
84577: AND
84578: IFFALSE 84602
// to_heal := to_heal union group [ i ] ;
84580: LD_ADDR_VAR 0 30
84584: PUSH
84585: LD_VAR 0 30
84589: PUSH
84590: LD_VAR 0 4
84594: PUSH
84595: LD_VAR 0 7
84599: ARRAY
84600: UNION
84601: ST_TO_ADDR
// if group [ i ] in to_heal then
84602: LD_VAR 0 4
84606: PUSH
84607: LD_VAR 0 7
84611: ARRAY
84612: PUSH
84613: LD_VAR 0 30
84617: IN
84618: IFFALSE 84727
// begin if GetLives ( group [ i ] ) = 1000 then
84620: LD_VAR 0 4
84624: PUSH
84625: LD_VAR 0 7
84629: ARRAY
84630: PPUSH
84631: CALL_OW 256
84635: PUSH
84636: LD_INT 1000
84638: EQUAL
84639: IFFALSE 84665
// to_heal := to_heal diff group [ i ] else
84641: LD_ADDR_VAR 0 30
84645: PUSH
84646: LD_VAR 0 30
84650: PUSH
84651: LD_VAR 0 4
84655: PUSH
84656: LD_VAR 0 7
84660: ARRAY
84661: DIFF
84662: ST_TO_ADDR
84663: GO 84727
// begin if not IsInArea ( group [ i ] , to_heal ) then
84665: LD_VAR 0 4
84669: PUSH
84670: LD_VAR 0 7
84674: ARRAY
84675: PPUSH
84676: LD_VAR 0 30
84680: PPUSH
84681: CALL_OW 308
84685: NOT
84686: IFFALSE 84710
// ComMoveToArea ( group [ i ] , f_heal ) else
84688: LD_VAR 0 4
84692: PUSH
84693: LD_VAR 0 7
84697: ARRAY
84698: PPUSH
84699: LD_VAR 0 23
84703: PPUSH
84704: CALL_OW 113
84708: GO 84725
// ComHold ( group [ i ] ) ;
84710: LD_VAR 0 4
84714: PUSH
84715: LD_VAR 0 7
84719: ARRAY
84720: PPUSH
84721: CALL_OW 140
// continue ;
84725: GO 83569
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84727: LD_VAR 0 4
84731: PUSH
84732: LD_VAR 0 7
84736: ARRAY
84737: PPUSH
84738: LD_INT 10
84740: PPUSH
84741: CALL 81347 0 2
84745: NOT
84746: PUSH
84747: LD_VAR 0 16
84751: PUSH
84752: LD_VAR 0 7
84756: ARRAY
84757: PUSH
84758: EMPTY
84759: EQUAL
84760: NOT
84761: AND
84762: IFFALSE 85028
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84764: LD_VAR 0 4
84768: PUSH
84769: LD_VAR 0 7
84773: ARRAY
84774: PPUSH
84775: CALL_OW 262
84779: PUSH
84780: LD_INT 1
84782: PUSH
84783: LD_INT 2
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: IN
84790: IFFALSE 84831
// if GetFuel ( group [ i ] ) < 10 then
84792: LD_VAR 0 4
84796: PUSH
84797: LD_VAR 0 7
84801: ARRAY
84802: PPUSH
84803: CALL_OW 261
84807: PUSH
84808: LD_INT 10
84810: LESS
84811: IFFALSE 84831
// SetFuel ( group [ i ] , 12 ) ;
84813: LD_VAR 0 4
84817: PUSH
84818: LD_VAR 0 7
84822: ARRAY
84823: PPUSH
84824: LD_INT 12
84826: PPUSH
84827: CALL_OW 240
// if units_path [ i ] then
84831: LD_VAR 0 16
84835: PUSH
84836: LD_VAR 0 7
84840: ARRAY
84841: IFFALSE 85026
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84843: LD_VAR 0 4
84847: PUSH
84848: LD_VAR 0 7
84852: ARRAY
84853: PPUSH
84854: LD_VAR 0 16
84858: PUSH
84859: LD_VAR 0 7
84863: ARRAY
84864: PUSH
84865: LD_INT 1
84867: ARRAY
84868: PUSH
84869: LD_INT 1
84871: ARRAY
84872: PPUSH
84873: LD_VAR 0 16
84877: PUSH
84878: LD_VAR 0 7
84882: ARRAY
84883: PUSH
84884: LD_INT 1
84886: ARRAY
84887: PUSH
84888: LD_INT 2
84890: ARRAY
84891: PPUSH
84892: CALL_OW 297
84896: PUSH
84897: LD_INT 6
84899: GREATER
84900: IFFALSE 84975
// begin if not HasTask ( group [ i ] ) then
84902: LD_VAR 0 4
84906: PUSH
84907: LD_VAR 0 7
84911: ARRAY
84912: PPUSH
84913: CALL_OW 314
84917: NOT
84918: IFFALSE 84973
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84920: LD_VAR 0 4
84924: PUSH
84925: LD_VAR 0 7
84929: ARRAY
84930: PPUSH
84931: LD_VAR 0 16
84935: PUSH
84936: LD_VAR 0 7
84940: ARRAY
84941: PUSH
84942: LD_INT 1
84944: ARRAY
84945: PUSH
84946: LD_INT 1
84948: ARRAY
84949: PPUSH
84950: LD_VAR 0 16
84954: PUSH
84955: LD_VAR 0 7
84959: ARRAY
84960: PUSH
84961: LD_INT 1
84963: ARRAY
84964: PUSH
84965: LD_INT 2
84967: ARRAY
84968: PPUSH
84969: CALL_OW 114
// end else
84973: GO 85026
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84975: LD_ADDR_VAR 0 15
84979: PUSH
84980: LD_VAR 0 16
84984: PUSH
84985: LD_VAR 0 7
84989: ARRAY
84990: PPUSH
84991: LD_INT 1
84993: PPUSH
84994: CALL_OW 3
84998: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84999: LD_ADDR_VAR 0 16
85003: PUSH
85004: LD_VAR 0 16
85008: PPUSH
85009: LD_VAR 0 7
85013: PPUSH
85014: LD_VAR 0 15
85018: PPUSH
85019: CALL_OW 1
85023: ST_TO_ADDR
// continue ;
85024: GO 83569
// end ; end ; end else
85026: GO 87664
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85028: LD_ADDR_VAR 0 14
85032: PUSH
85033: LD_INT 81
85035: PUSH
85036: LD_VAR 0 4
85040: PUSH
85041: LD_VAR 0 7
85045: ARRAY
85046: PPUSH
85047: CALL_OW 255
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PPUSH
85056: CALL_OW 69
85060: ST_TO_ADDR
// if not tmp then
85061: LD_VAR 0 14
85065: NOT
85066: IFFALSE 85070
// continue ;
85068: GO 83569
// if f_ignore_area then
85070: LD_VAR 0 17
85074: IFFALSE 85162
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85076: LD_ADDR_VAR 0 15
85080: PUSH
85081: LD_VAR 0 14
85085: PPUSH
85086: LD_INT 3
85088: PUSH
85089: LD_INT 92
85091: PUSH
85092: LD_VAR 0 17
85096: PUSH
85097: LD_INT 1
85099: ARRAY
85100: PUSH
85101: LD_VAR 0 17
85105: PUSH
85106: LD_INT 2
85108: ARRAY
85109: PUSH
85110: LD_VAR 0 17
85114: PUSH
85115: LD_INT 3
85117: ARRAY
85118: PUSH
85119: EMPTY
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PPUSH
85129: CALL_OW 72
85133: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85134: LD_VAR 0 14
85138: PUSH
85139: LD_VAR 0 15
85143: DIFF
85144: IFFALSE 85162
// tmp := tmp diff tmp2 ;
85146: LD_ADDR_VAR 0 14
85150: PUSH
85151: LD_VAR 0 14
85155: PUSH
85156: LD_VAR 0 15
85160: DIFF
85161: ST_TO_ADDR
// end ; if not f_murder then
85162: LD_VAR 0 20
85166: NOT
85167: IFFALSE 85225
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85169: LD_ADDR_VAR 0 15
85173: PUSH
85174: LD_VAR 0 14
85178: PPUSH
85179: LD_INT 3
85181: PUSH
85182: LD_INT 50
85184: PUSH
85185: EMPTY
85186: LIST
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PPUSH
85192: CALL_OW 72
85196: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85197: LD_VAR 0 14
85201: PUSH
85202: LD_VAR 0 15
85206: DIFF
85207: IFFALSE 85225
// tmp := tmp diff tmp2 ;
85209: LD_ADDR_VAR 0 14
85213: PUSH
85214: LD_VAR 0 14
85218: PUSH
85219: LD_VAR 0 15
85223: DIFF
85224: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85225: LD_ADDR_VAR 0 14
85229: PUSH
85230: LD_VAR 0 4
85234: PUSH
85235: LD_VAR 0 7
85239: ARRAY
85240: PPUSH
85241: LD_VAR 0 14
85245: PPUSH
85246: LD_INT 1
85248: PPUSH
85249: LD_INT 1
85251: PPUSH
85252: CALL 54990 0 4
85256: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85257: LD_VAR 0 4
85261: PUSH
85262: LD_VAR 0 7
85266: ARRAY
85267: PPUSH
85268: CALL_OW 257
85272: PUSH
85273: LD_INT 1
85275: EQUAL
85276: IFFALSE 85724
// begin if WantPlant ( group [ i ] ) then
85278: LD_VAR 0 4
85282: PUSH
85283: LD_VAR 0 7
85287: ARRAY
85288: PPUSH
85289: CALL 54491 0 1
85293: IFFALSE 85297
// continue ;
85295: GO 83569
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85297: LD_VAR 0 18
85301: PUSH
85302: LD_VAR 0 4
85306: PUSH
85307: LD_VAR 0 7
85311: ARRAY
85312: PPUSH
85313: CALL_OW 310
85317: NOT
85318: AND
85319: PUSH
85320: LD_VAR 0 14
85324: PUSH
85325: LD_INT 1
85327: ARRAY
85328: PUSH
85329: LD_VAR 0 14
85333: PPUSH
85334: LD_INT 21
85336: PUSH
85337: LD_INT 2
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 58
85346: PUSH
85347: EMPTY
85348: LIST
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PPUSH
85354: CALL_OW 72
85358: IN
85359: AND
85360: IFFALSE 85396
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85362: LD_VAR 0 4
85366: PUSH
85367: LD_VAR 0 7
85371: ARRAY
85372: PPUSH
85373: LD_VAR 0 14
85377: PUSH
85378: LD_INT 1
85380: ARRAY
85381: PPUSH
85382: CALL_OW 120
// attacking := true ;
85386: LD_ADDR_VAR 0 29
85390: PUSH
85391: LD_INT 1
85393: ST_TO_ADDR
// continue ;
85394: GO 83569
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85396: LD_VAR 0 26
85400: PUSH
85401: LD_VAR 0 4
85405: PUSH
85406: LD_VAR 0 7
85410: ARRAY
85411: PPUSH
85412: CALL_OW 257
85416: PUSH
85417: LD_INT 1
85419: EQUAL
85420: AND
85421: PUSH
85422: LD_VAR 0 4
85426: PUSH
85427: LD_VAR 0 7
85431: ARRAY
85432: PPUSH
85433: CALL_OW 256
85437: PUSH
85438: LD_INT 800
85440: LESS
85441: AND
85442: PUSH
85443: LD_VAR 0 4
85447: PUSH
85448: LD_VAR 0 7
85452: ARRAY
85453: PPUSH
85454: CALL_OW 318
85458: NOT
85459: AND
85460: IFFALSE 85477
// ComCrawl ( group [ i ] ) ;
85462: LD_VAR 0 4
85466: PUSH
85467: LD_VAR 0 7
85471: ARRAY
85472: PPUSH
85473: CALL_OW 137
// if f_mines then
85477: LD_VAR 0 21
85481: IFFALSE 85724
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85483: LD_VAR 0 14
85487: PUSH
85488: LD_INT 1
85490: ARRAY
85491: PPUSH
85492: CALL_OW 247
85496: PUSH
85497: LD_INT 3
85499: EQUAL
85500: PUSH
85501: LD_VAR 0 14
85505: PUSH
85506: LD_INT 1
85508: ARRAY
85509: PUSH
85510: LD_VAR 0 27
85514: IN
85515: NOT
85516: AND
85517: IFFALSE 85724
// begin x := GetX ( tmp [ 1 ] ) ;
85519: LD_ADDR_VAR 0 10
85523: PUSH
85524: LD_VAR 0 14
85528: PUSH
85529: LD_INT 1
85531: ARRAY
85532: PPUSH
85533: CALL_OW 250
85537: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85538: LD_ADDR_VAR 0 11
85542: PUSH
85543: LD_VAR 0 14
85547: PUSH
85548: LD_INT 1
85550: ARRAY
85551: PPUSH
85552: CALL_OW 251
85556: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85557: LD_ADDR_VAR 0 12
85561: PUSH
85562: LD_VAR 0 4
85566: PUSH
85567: LD_VAR 0 7
85571: ARRAY
85572: PPUSH
85573: CALL 81432 0 1
85577: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85578: LD_VAR 0 4
85582: PUSH
85583: LD_VAR 0 7
85587: ARRAY
85588: PPUSH
85589: LD_VAR 0 10
85593: PPUSH
85594: LD_VAR 0 11
85598: PPUSH
85599: LD_VAR 0 14
85603: PUSH
85604: LD_INT 1
85606: ARRAY
85607: PPUSH
85608: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85612: LD_VAR 0 4
85616: PUSH
85617: LD_VAR 0 7
85621: ARRAY
85622: PPUSH
85623: LD_VAR 0 10
85627: PPUSH
85628: LD_VAR 0 12
85632: PPUSH
85633: LD_INT 7
85635: PPUSH
85636: CALL_OW 272
85640: PPUSH
85641: LD_VAR 0 11
85645: PPUSH
85646: LD_VAR 0 12
85650: PPUSH
85651: LD_INT 7
85653: PPUSH
85654: CALL_OW 273
85658: PPUSH
85659: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85663: LD_VAR 0 4
85667: PUSH
85668: LD_VAR 0 7
85672: ARRAY
85673: PPUSH
85674: LD_INT 71
85676: PPUSH
85677: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85681: LD_ADDR_VAR 0 27
85685: PUSH
85686: LD_VAR 0 27
85690: PPUSH
85691: LD_VAR 0 27
85695: PUSH
85696: LD_INT 1
85698: PLUS
85699: PPUSH
85700: LD_VAR 0 14
85704: PUSH
85705: LD_INT 1
85707: ARRAY
85708: PPUSH
85709: CALL_OW 1
85713: ST_TO_ADDR
// attacking := true ;
85714: LD_ADDR_VAR 0 29
85718: PUSH
85719: LD_INT 1
85721: ST_TO_ADDR
// continue ;
85722: GO 83569
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85724: LD_VAR 0 4
85728: PUSH
85729: LD_VAR 0 7
85733: ARRAY
85734: PPUSH
85735: CALL_OW 257
85739: PUSH
85740: LD_INT 17
85742: EQUAL
85743: PUSH
85744: LD_VAR 0 4
85748: PUSH
85749: LD_VAR 0 7
85753: ARRAY
85754: PPUSH
85755: CALL_OW 110
85759: PUSH
85760: LD_INT 71
85762: EQUAL
85763: NOT
85764: AND
85765: IFFALSE 85911
// begin attacking := false ;
85767: LD_ADDR_VAR 0 29
85771: PUSH
85772: LD_INT 0
85774: ST_TO_ADDR
// k := 5 ;
85775: LD_ADDR_VAR 0 9
85779: PUSH
85780: LD_INT 5
85782: ST_TO_ADDR
// if tmp < k then
85783: LD_VAR 0 14
85787: PUSH
85788: LD_VAR 0 9
85792: LESS
85793: IFFALSE 85805
// k := tmp ;
85795: LD_ADDR_VAR 0 9
85799: PUSH
85800: LD_VAR 0 14
85804: ST_TO_ADDR
// for j = 1 to k do
85805: LD_ADDR_VAR 0 8
85809: PUSH
85810: DOUBLE
85811: LD_INT 1
85813: DEC
85814: ST_TO_ADDR
85815: LD_VAR 0 9
85819: PUSH
85820: FOR_TO
85821: IFFALSE 85909
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85823: LD_VAR 0 14
85827: PUSH
85828: LD_VAR 0 8
85832: ARRAY
85833: PUSH
85834: LD_VAR 0 14
85838: PPUSH
85839: LD_INT 58
85841: PUSH
85842: EMPTY
85843: LIST
85844: PPUSH
85845: CALL_OW 72
85849: IN
85850: NOT
85851: IFFALSE 85907
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85853: LD_VAR 0 4
85857: PUSH
85858: LD_VAR 0 7
85862: ARRAY
85863: PPUSH
85864: LD_VAR 0 14
85868: PUSH
85869: LD_VAR 0 8
85873: ARRAY
85874: PPUSH
85875: CALL_OW 115
// attacking := true ;
85879: LD_ADDR_VAR 0 29
85883: PUSH
85884: LD_INT 1
85886: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85887: LD_VAR 0 4
85891: PUSH
85892: LD_VAR 0 7
85896: ARRAY
85897: PPUSH
85898: LD_INT 71
85900: PPUSH
85901: CALL_OW 109
// continue ;
85905: GO 85820
// end ; end ;
85907: GO 85820
85909: POP
85910: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85911: LD_VAR 0 4
85915: PUSH
85916: LD_VAR 0 7
85920: ARRAY
85921: PPUSH
85922: CALL_OW 257
85926: PUSH
85927: LD_INT 8
85929: EQUAL
85930: PUSH
85931: LD_VAR 0 4
85935: PUSH
85936: LD_VAR 0 7
85940: ARRAY
85941: PPUSH
85942: CALL_OW 264
85946: PUSH
85947: LD_INT 28
85949: PUSH
85950: LD_INT 45
85952: PUSH
85953: LD_INT 7
85955: PUSH
85956: LD_INT 47
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: IN
85965: OR
85966: IFFALSE 86196
// begin attacking := false ;
85968: LD_ADDR_VAR 0 29
85972: PUSH
85973: LD_INT 0
85975: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85976: LD_VAR 0 14
85980: PUSH
85981: LD_INT 1
85983: ARRAY
85984: PPUSH
85985: CALL_OW 266
85989: PUSH
85990: LD_INT 32
85992: PUSH
85993: LD_INT 31
85995: PUSH
85996: LD_INT 33
85998: PUSH
85999: LD_INT 4
86001: PUSH
86002: LD_INT 5
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: IN
86012: IFFALSE 86196
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86014: LD_ADDR_VAR 0 9
86018: PUSH
86019: LD_VAR 0 14
86023: PUSH
86024: LD_INT 1
86026: ARRAY
86027: PPUSH
86028: CALL_OW 266
86032: PPUSH
86033: LD_VAR 0 14
86037: PUSH
86038: LD_INT 1
86040: ARRAY
86041: PPUSH
86042: CALL_OW 250
86046: PPUSH
86047: LD_VAR 0 14
86051: PUSH
86052: LD_INT 1
86054: ARRAY
86055: PPUSH
86056: CALL_OW 251
86060: PPUSH
86061: LD_VAR 0 14
86065: PUSH
86066: LD_INT 1
86068: ARRAY
86069: PPUSH
86070: CALL_OW 254
86074: PPUSH
86075: LD_VAR 0 14
86079: PUSH
86080: LD_INT 1
86082: ARRAY
86083: PPUSH
86084: CALL_OW 248
86088: PPUSH
86089: LD_INT 0
86091: PPUSH
86092: CALL 62802 0 6
86096: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86097: LD_ADDR_VAR 0 8
86101: PUSH
86102: LD_VAR 0 4
86106: PUSH
86107: LD_VAR 0 7
86111: ARRAY
86112: PPUSH
86113: LD_VAR 0 9
86117: PPUSH
86118: CALL 81495 0 2
86122: ST_TO_ADDR
// if j then
86123: LD_VAR 0 8
86127: IFFALSE 86196
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86129: LD_VAR 0 8
86133: PUSH
86134: LD_INT 1
86136: ARRAY
86137: PPUSH
86138: LD_VAR 0 8
86142: PUSH
86143: LD_INT 2
86145: ARRAY
86146: PPUSH
86147: CALL_OW 488
86151: IFFALSE 86196
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86153: LD_VAR 0 4
86157: PUSH
86158: LD_VAR 0 7
86162: ARRAY
86163: PPUSH
86164: LD_VAR 0 8
86168: PUSH
86169: LD_INT 1
86171: ARRAY
86172: PPUSH
86173: LD_VAR 0 8
86177: PUSH
86178: LD_INT 2
86180: ARRAY
86181: PPUSH
86182: CALL_OW 116
// attacking := true ;
86186: LD_ADDR_VAR 0 29
86190: PUSH
86191: LD_INT 1
86193: ST_TO_ADDR
// continue ;
86194: GO 83569
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86196: LD_VAR 0 4
86200: PUSH
86201: LD_VAR 0 7
86205: ARRAY
86206: PPUSH
86207: CALL_OW 265
86211: PUSH
86212: LD_INT 11
86214: EQUAL
86215: IFFALSE 86493
// begin k := 10 ;
86217: LD_ADDR_VAR 0 9
86221: PUSH
86222: LD_INT 10
86224: ST_TO_ADDR
// x := 0 ;
86225: LD_ADDR_VAR 0 10
86229: PUSH
86230: LD_INT 0
86232: ST_TO_ADDR
// if tmp < k then
86233: LD_VAR 0 14
86237: PUSH
86238: LD_VAR 0 9
86242: LESS
86243: IFFALSE 86255
// k := tmp ;
86245: LD_ADDR_VAR 0 9
86249: PUSH
86250: LD_VAR 0 14
86254: ST_TO_ADDR
// for j = k downto 1 do
86255: LD_ADDR_VAR 0 8
86259: PUSH
86260: DOUBLE
86261: LD_VAR 0 9
86265: INC
86266: ST_TO_ADDR
86267: LD_INT 1
86269: PUSH
86270: FOR_DOWNTO
86271: IFFALSE 86346
// begin if GetType ( tmp [ j ] ) = unit_human then
86273: LD_VAR 0 14
86277: PUSH
86278: LD_VAR 0 8
86282: ARRAY
86283: PPUSH
86284: CALL_OW 247
86288: PUSH
86289: LD_INT 1
86291: EQUAL
86292: IFFALSE 86344
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86294: LD_VAR 0 4
86298: PUSH
86299: LD_VAR 0 7
86303: ARRAY
86304: PPUSH
86305: LD_VAR 0 14
86309: PUSH
86310: LD_VAR 0 8
86314: ARRAY
86315: PPUSH
86316: CALL 81766 0 2
// x := tmp [ j ] ;
86320: LD_ADDR_VAR 0 10
86324: PUSH
86325: LD_VAR 0 14
86329: PUSH
86330: LD_VAR 0 8
86334: ARRAY
86335: ST_TO_ADDR
// attacking := true ;
86336: LD_ADDR_VAR 0 29
86340: PUSH
86341: LD_INT 1
86343: ST_TO_ADDR
// end ; end ;
86344: GO 86270
86346: POP
86347: POP
// if not x then
86348: LD_VAR 0 10
86352: NOT
86353: IFFALSE 86493
// begin attacking := true ;
86355: LD_ADDR_VAR 0 29
86359: PUSH
86360: LD_INT 1
86362: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86363: LD_VAR 0 4
86367: PUSH
86368: LD_VAR 0 7
86372: ARRAY
86373: PPUSH
86374: CALL_OW 250
86378: PPUSH
86379: LD_VAR 0 4
86383: PUSH
86384: LD_VAR 0 7
86388: ARRAY
86389: PPUSH
86390: CALL_OW 251
86394: PPUSH
86395: CALL_OW 546
86399: PUSH
86400: LD_INT 2
86402: ARRAY
86403: PUSH
86404: LD_VAR 0 14
86408: PUSH
86409: LD_INT 1
86411: ARRAY
86412: PPUSH
86413: CALL_OW 250
86417: PPUSH
86418: LD_VAR 0 14
86422: PUSH
86423: LD_INT 1
86425: ARRAY
86426: PPUSH
86427: CALL_OW 251
86431: PPUSH
86432: CALL_OW 546
86436: PUSH
86437: LD_INT 2
86439: ARRAY
86440: EQUAL
86441: IFFALSE 86469
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86443: LD_VAR 0 4
86447: PUSH
86448: LD_VAR 0 7
86452: ARRAY
86453: PPUSH
86454: LD_VAR 0 14
86458: PUSH
86459: LD_INT 1
86461: ARRAY
86462: PPUSH
86463: CALL 81766 0 2
86467: GO 86493
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86469: LD_VAR 0 4
86473: PUSH
86474: LD_VAR 0 7
86478: ARRAY
86479: PPUSH
86480: LD_VAR 0 14
86484: PUSH
86485: LD_INT 1
86487: ARRAY
86488: PPUSH
86489: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86493: LD_VAR 0 4
86497: PUSH
86498: LD_VAR 0 7
86502: ARRAY
86503: PPUSH
86504: CALL_OW 264
86508: PUSH
86509: LD_INT 29
86511: EQUAL
86512: IFFALSE 86878
// begin if WantsToAttack ( group [ i ] ) in bombed then
86514: LD_VAR 0 4
86518: PUSH
86519: LD_VAR 0 7
86523: ARRAY
86524: PPUSH
86525: CALL_OW 319
86529: PUSH
86530: LD_VAR 0 28
86534: IN
86535: IFFALSE 86539
// continue ;
86537: GO 83569
// k := 8 ;
86539: LD_ADDR_VAR 0 9
86543: PUSH
86544: LD_INT 8
86546: ST_TO_ADDR
// x := 0 ;
86547: LD_ADDR_VAR 0 10
86551: PUSH
86552: LD_INT 0
86554: ST_TO_ADDR
// if tmp < k then
86555: LD_VAR 0 14
86559: PUSH
86560: LD_VAR 0 9
86564: LESS
86565: IFFALSE 86577
// k := tmp ;
86567: LD_ADDR_VAR 0 9
86571: PUSH
86572: LD_VAR 0 14
86576: ST_TO_ADDR
// for j = 1 to k do
86577: LD_ADDR_VAR 0 8
86581: PUSH
86582: DOUBLE
86583: LD_INT 1
86585: DEC
86586: ST_TO_ADDR
86587: LD_VAR 0 9
86591: PUSH
86592: FOR_TO
86593: IFFALSE 86725
// begin if GetType ( tmp [ j ] ) = unit_building then
86595: LD_VAR 0 14
86599: PUSH
86600: LD_VAR 0 8
86604: ARRAY
86605: PPUSH
86606: CALL_OW 247
86610: PUSH
86611: LD_INT 3
86613: EQUAL
86614: IFFALSE 86723
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86616: LD_VAR 0 14
86620: PUSH
86621: LD_VAR 0 8
86625: ARRAY
86626: PUSH
86627: LD_VAR 0 28
86631: IN
86632: NOT
86633: PUSH
86634: LD_VAR 0 14
86638: PUSH
86639: LD_VAR 0 8
86643: ARRAY
86644: PPUSH
86645: CALL_OW 313
86649: AND
86650: IFFALSE 86723
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86652: LD_VAR 0 4
86656: PUSH
86657: LD_VAR 0 7
86661: ARRAY
86662: PPUSH
86663: LD_VAR 0 14
86667: PUSH
86668: LD_VAR 0 8
86672: ARRAY
86673: PPUSH
86674: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86678: LD_ADDR_VAR 0 28
86682: PUSH
86683: LD_VAR 0 28
86687: PPUSH
86688: LD_VAR 0 28
86692: PUSH
86693: LD_INT 1
86695: PLUS
86696: PPUSH
86697: LD_VAR 0 14
86701: PUSH
86702: LD_VAR 0 8
86706: ARRAY
86707: PPUSH
86708: CALL_OW 1
86712: ST_TO_ADDR
// attacking := true ;
86713: LD_ADDR_VAR 0 29
86717: PUSH
86718: LD_INT 1
86720: ST_TO_ADDR
// break ;
86721: GO 86725
// end ; end ;
86723: GO 86592
86725: POP
86726: POP
// if not attacking and f_attack_depot then
86727: LD_VAR 0 29
86731: NOT
86732: PUSH
86733: LD_VAR 0 25
86737: AND
86738: IFFALSE 86833
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86740: LD_ADDR_VAR 0 13
86744: PUSH
86745: LD_VAR 0 14
86749: PPUSH
86750: LD_INT 2
86752: PUSH
86753: LD_INT 30
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 30
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: LIST
86777: PPUSH
86778: CALL_OW 72
86782: ST_TO_ADDR
// if z then
86783: LD_VAR 0 13
86787: IFFALSE 86833
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86789: LD_VAR 0 4
86793: PUSH
86794: LD_VAR 0 7
86798: ARRAY
86799: PPUSH
86800: LD_VAR 0 13
86804: PPUSH
86805: LD_VAR 0 4
86809: PUSH
86810: LD_VAR 0 7
86814: ARRAY
86815: PPUSH
86816: CALL_OW 74
86820: PPUSH
86821: CALL_OW 115
// attacking := true ;
86825: LD_ADDR_VAR 0 29
86829: PUSH
86830: LD_INT 1
86832: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86833: LD_VAR 0 4
86837: PUSH
86838: LD_VAR 0 7
86842: ARRAY
86843: PPUSH
86844: CALL_OW 256
86848: PUSH
86849: LD_INT 500
86851: LESS
86852: IFFALSE 86878
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86854: LD_VAR 0 4
86858: PUSH
86859: LD_VAR 0 7
86863: ARRAY
86864: PPUSH
86865: LD_VAR 0 14
86869: PUSH
86870: LD_INT 1
86872: ARRAY
86873: PPUSH
86874: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86878: LD_VAR 0 4
86882: PUSH
86883: LD_VAR 0 7
86887: ARRAY
86888: PPUSH
86889: CALL_OW 264
86893: PUSH
86894: LD_INT 49
86896: EQUAL
86897: IFFALSE 87018
// begin if not HasTask ( group [ i ] ) then
86899: LD_VAR 0 4
86903: PUSH
86904: LD_VAR 0 7
86908: ARRAY
86909: PPUSH
86910: CALL_OW 314
86914: NOT
86915: IFFALSE 87018
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86917: LD_ADDR_VAR 0 9
86921: PUSH
86922: LD_INT 81
86924: PUSH
86925: LD_VAR 0 4
86929: PUSH
86930: LD_VAR 0 7
86934: ARRAY
86935: PPUSH
86936: CALL_OW 255
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PPUSH
86945: CALL_OW 69
86949: PPUSH
86950: LD_VAR 0 4
86954: PUSH
86955: LD_VAR 0 7
86959: ARRAY
86960: PPUSH
86961: CALL_OW 74
86965: ST_TO_ADDR
// if k then
86966: LD_VAR 0 9
86970: IFFALSE 87018
// if GetDistUnits ( group [ i ] , k ) > 10 then
86972: LD_VAR 0 4
86976: PUSH
86977: LD_VAR 0 7
86981: ARRAY
86982: PPUSH
86983: LD_VAR 0 9
86987: PPUSH
86988: CALL_OW 296
86992: PUSH
86993: LD_INT 10
86995: GREATER
86996: IFFALSE 87018
// ComMoveUnit ( group [ i ] , k ) ;
86998: LD_VAR 0 4
87002: PUSH
87003: LD_VAR 0 7
87007: ARRAY
87008: PPUSH
87009: LD_VAR 0 9
87013: PPUSH
87014: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87018: LD_VAR 0 4
87022: PUSH
87023: LD_VAR 0 7
87027: ARRAY
87028: PPUSH
87029: CALL_OW 256
87033: PUSH
87034: LD_INT 250
87036: LESS
87037: PUSH
87038: LD_VAR 0 4
87042: PUSH
87043: LD_VAR 0 7
87047: ARRAY
87048: PUSH
87049: LD_INT 21
87051: PUSH
87052: LD_INT 2
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 23
87061: PUSH
87062: LD_INT 2
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PPUSH
87073: CALL_OW 69
87077: IN
87078: AND
87079: IFFALSE 87204
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87081: LD_ADDR_VAR 0 9
87085: PUSH
87086: LD_OWVAR 3
87090: PUSH
87091: LD_VAR 0 4
87095: PUSH
87096: LD_VAR 0 7
87100: ARRAY
87101: DIFF
87102: PPUSH
87103: LD_VAR 0 4
87107: PUSH
87108: LD_VAR 0 7
87112: ARRAY
87113: PPUSH
87114: CALL_OW 74
87118: ST_TO_ADDR
// if not k then
87119: LD_VAR 0 9
87123: NOT
87124: IFFALSE 87128
// continue ;
87126: GO 83569
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87128: LD_VAR 0 9
87132: PUSH
87133: LD_INT 81
87135: PUSH
87136: LD_VAR 0 4
87140: PUSH
87141: LD_VAR 0 7
87145: ARRAY
87146: PPUSH
87147: CALL_OW 255
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PPUSH
87156: CALL_OW 69
87160: IN
87161: PUSH
87162: LD_VAR 0 9
87166: PPUSH
87167: LD_VAR 0 4
87171: PUSH
87172: LD_VAR 0 7
87176: ARRAY
87177: PPUSH
87178: CALL_OW 296
87182: PUSH
87183: LD_INT 5
87185: LESS
87186: AND
87187: IFFALSE 87204
// ComAutodestruct ( group [ i ] ) ;
87189: LD_VAR 0 4
87193: PUSH
87194: LD_VAR 0 7
87198: ARRAY
87199: PPUSH
87200: CALL 81664 0 1
// end ; if f_attack_depot then
87204: LD_VAR 0 25
87208: IFFALSE 87320
// begin k := 6 ;
87210: LD_ADDR_VAR 0 9
87214: PUSH
87215: LD_INT 6
87217: ST_TO_ADDR
// if tmp < k then
87218: LD_VAR 0 14
87222: PUSH
87223: LD_VAR 0 9
87227: LESS
87228: IFFALSE 87240
// k := tmp ;
87230: LD_ADDR_VAR 0 9
87234: PUSH
87235: LD_VAR 0 14
87239: ST_TO_ADDR
// for j = 1 to k do
87240: LD_ADDR_VAR 0 8
87244: PUSH
87245: DOUBLE
87246: LD_INT 1
87248: DEC
87249: ST_TO_ADDR
87250: LD_VAR 0 9
87254: PUSH
87255: FOR_TO
87256: IFFALSE 87318
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87258: LD_VAR 0 8
87262: PPUSH
87263: CALL_OW 266
87267: PUSH
87268: LD_INT 0
87270: PUSH
87271: LD_INT 1
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: IN
87278: IFFALSE 87316
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87280: LD_VAR 0 4
87284: PUSH
87285: LD_VAR 0 7
87289: ARRAY
87290: PPUSH
87291: LD_VAR 0 14
87295: PUSH
87296: LD_VAR 0 8
87300: ARRAY
87301: PPUSH
87302: CALL_OW 115
// attacking := true ;
87306: LD_ADDR_VAR 0 29
87310: PUSH
87311: LD_INT 1
87313: ST_TO_ADDR
// break ;
87314: GO 87318
// end ;
87316: GO 87255
87318: POP
87319: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87320: LD_VAR 0 4
87324: PUSH
87325: LD_VAR 0 7
87329: ARRAY
87330: PPUSH
87331: CALL_OW 302
87335: PUSH
87336: LD_VAR 0 29
87340: NOT
87341: AND
87342: IFFALSE 87664
// begin if GetTag ( group [ i ] ) = 71 then
87344: LD_VAR 0 4
87348: PUSH
87349: LD_VAR 0 7
87353: ARRAY
87354: PPUSH
87355: CALL_OW 110
87359: PUSH
87360: LD_INT 71
87362: EQUAL
87363: IFFALSE 87404
// begin if HasTask ( group [ i ] ) then
87365: LD_VAR 0 4
87369: PUSH
87370: LD_VAR 0 7
87374: ARRAY
87375: PPUSH
87376: CALL_OW 314
87380: IFFALSE 87386
// continue else
87382: GO 83569
87384: GO 87404
// SetTag ( group [ i ] , 0 ) ;
87386: LD_VAR 0 4
87390: PUSH
87391: LD_VAR 0 7
87395: ARRAY
87396: PPUSH
87397: LD_INT 0
87399: PPUSH
87400: CALL_OW 109
// end ; k := 8 ;
87404: LD_ADDR_VAR 0 9
87408: PUSH
87409: LD_INT 8
87411: ST_TO_ADDR
// x := 0 ;
87412: LD_ADDR_VAR 0 10
87416: PUSH
87417: LD_INT 0
87419: ST_TO_ADDR
// if tmp < k then
87420: LD_VAR 0 14
87424: PUSH
87425: LD_VAR 0 9
87429: LESS
87430: IFFALSE 87442
// k := tmp ;
87432: LD_ADDR_VAR 0 9
87436: PUSH
87437: LD_VAR 0 14
87441: ST_TO_ADDR
// for j = 1 to k do
87442: LD_ADDR_VAR 0 8
87446: PUSH
87447: DOUBLE
87448: LD_INT 1
87450: DEC
87451: ST_TO_ADDR
87452: LD_VAR 0 9
87456: PUSH
87457: FOR_TO
87458: IFFALSE 87556
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87460: LD_VAR 0 14
87464: PUSH
87465: LD_VAR 0 8
87469: ARRAY
87470: PPUSH
87471: CALL_OW 247
87475: PUSH
87476: LD_INT 1
87478: EQUAL
87479: PUSH
87480: LD_VAR 0 14
87484: PUSH
87485: LD_VAR 0 8
87489: ARRAY
87490: PPUSH
87491: CALL_OW 256
87495: PUSH
87496: LD_INT 250
87498: LESS
87499: PUSH
87500: LD_VAR 0 20
87504: AND
87505: PUSH
87506: LD_VAR 0 20
87510: NOT
87511: PUSH
87512: LD_VAR 0 14
87516: PUSH
87517: LD_VAR 0 8
87521: ARRAY
87522: PPUSH
87523: CALL_OW 256
87527: PUSH
87528: LD_INT 250
87530: GREATEREQUAL
87531: AND
87532: OR
87533: AND
87534: IFFALSE 87554
// begin x := tmp [ j ] ;
87536: LD_ADDR_VAR 0 10
87540: PUSH
87541: LD_VAR 0 14
87545: PUSH
87546: LD_VAR 0 8
87550: ARRAY
87551: ST_TO_ADDR
// break ;
87552: GO 87556
// end ;
87554: GO 87457
87556: POP
87557: POP
// if x then
87558: LD_VAR 0 10
87562: IFFALSE 87586
// ComAttackUnit ( group [ i ] , x ) else
87564: LD_VAR 0 4
87568: PUSH
87569: LD_VAR 0 7
87573: ARRAY
87574: PPUSH
87575: LD_VAR 0 10
87579: PPUSH
87580: CALL_OW 115
87584: GO 87610
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87586: LD_VAR 0 4
87590: PUSH
87591: LD_VAR 0 7
87595: ARRAY
87596: PPUSH
87597: LD_VAR 0 14
87601: PUSH
87602: LD_INT 1
87604: ARRAY
87605: PPUSH
87606: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87610: LD_VAR 0 4
87614: PUSH
87615: LD_VAR 0 7
87619: ARRAY
87620: PPUSH
87621: CALL_OW 314
87625: NOT
87626: IFFALSE 87664
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87628: LD_VAR 0 4
87632: PUSH
87633: LD_VAR 0 7
87637: ARRAY
87638: PPUSH
87639: LD_VAR 0 14
87643: PPUSH
87644: LD_VAR 0 4
87648: PUSH
87649: LD_VAR 0 7
87653: ARRAY
87654: PPUSH
87655: CALL_OW 74
87659: PPUSH
87660: CALL_OW 115
// end ; end ; end ;
87664: GO 83569
87666: POP
87667: POP
// wait ( 0 0$1 ) ;
87668: LD_INT 35
87670: PPUSH
87671: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87675: LD_VAR 0 4
87679: PUSH
87680: EMPTY
87681: EQUAL
87682: PUSH
87683: LD_INT 81
87685: PUSH
87686: LD_VAR 0 35
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PPUSH
87695: CALL_OW 69
87699: NOT
87700: OR
87701: IFFALSE 83554
// end ;
87703: LD_VAR 0 2
87707: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87708: LD_INT 0
87710: PPUSH
87711: PPUSH
87712: PPUSH
87713: PPUSH
// if not base_units then
87714: LD_VAR 0 1
87718: NOT
87719: IFFALSE 87723
// exit ;
87721: GO 87810
// result := false ;
87723: LD_ADDR_VAR 0 2
87727: PUSH
87728: LD_INT 0
87730: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87731: LD_ADDR_VAR 0 5
87735: PUSH
87736: LD_VAR 0 1
87740: PPUSH
87741: LD_INT 21
87743: PUSH
87744: LD_INT 3
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PPUSH
87751: CALL_OW 72
87755: ST_TO_ADDR
// if not tmp then
87756: LD_VAR 0 5
87760: NOT
87761: IFFALSE 87765
// exit ;
87763: GO 87810
// for i in tmp do
87765: LD_ADDR_VAR 0 3
87769: PUSH
87770: LD_VAR 0 5
87774: PUSH
87775: FOR_IN
87776: IFFALSE 87808
// begin result := EnemyInRange ( i , 22 ) ;
87778: LD_ADDR_VAR 0 2
87782: PUSH
87783: LD_VAR 0 3
87787: PPUSH
87788: LD_INT 22
87790: PPUSH
87791: CALL 81347 0 2
87795: ST_TO_ADDR
// if result then
87796: LD_VAR 0 2
87800: IFFALSE 87806
// exit ;
87802: POP
87803: POP
87804: GO 87810
// end ;
87806: GO 87775
87808: POP
87809: POP
// end ;
87810: LD_VAR 0 2
87814: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
87815: LD_INT 0
87817: PPUSH
87818: PPUSH
// if not units then
87819: LD_VAR 0 1
87823: NOT
87824: IFFALSE 87828
// exit ;
87826: GO 87898
// result := [ ] ;
87828: LD_ADDR_VAR 0 3
87832: PUSH
87833: EMPTY
87834: ST_TO_ADDR
// for i in units do
87835: LD_ADDR_VAR 0 4
87839: PUSH
87840: LD_VAR 0 1
87844: PUSH
87845: FOR_IN
87846: IFFALSE 87896
// if GetTag ( i ) = tag then
87848: LD_VAR 0 4
87852: PPUSH
87853: CALL_OW 110
87857: PUSH
87858: LD_VAR 0 2
87862: EQUAL
87863: IFFALSE 87894
// result := Insert ( result , result + 1 , i ) ;
87865: LD_ADDR_VAR 0 3
87869: PUSH
87870: LD_VAR 0 3
87874: PPUSH
87875: LD_VAR 0 3
87879: PUSH
87880: LD_INT 1
87882: PLUS
87883: PPUSH
87884: LD_VAR 0 4
87888: PPUSH
87889: CALL_OW 2
87893: ST_TO_ADDR
87894: GO 87845
87896: POP
87897: POP
// end ;
87898: LD_VAR 0 3
87902: RET
// export function IsDriver ( un ) ; begin
87903: LD_INT 0
87905: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87906: LD_ADDR_VAR 0 2
87910: PUSH
87911: LD_VAR 0 1
87915: PUSH
87916: LD_INT 55
87918: PUSH
87919: EMPTY
87920: LIST
87921: PPUSH
87922: CALL_OW 69
87926: IN
87927: ST_TO_ADDR
// end ;
87928: LD_VAR 0 2
87932: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87933: LD_INT 0
87935: PPUSH
87936: PPUSH
// list := [ ] ;
87937: LD_ADDR_VAR 0 5
87941: PUSH
87942: EMPTY
87943: ST_TO_ADDR
// case d of 0 :
87944: LD_VAR 0 3
87948: PUSH
87949: LD_INT 0
87951: DOUBLE
87952: EQUAL
87953: IFTRUE 87957
87955: GO 88090
87957: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87958: LD_ADDR_VAR 0 5
87962: PUSH
87963: LD_VAR 0 1
87967: PUSH
87968: LD_INT 4
87970: MINUS
87971: PUSH
87972: LD_VAR 0 2
87976: PUSH
87977: LD_INT 4
87979: MINUS
87980: PUSH
87981: LD_INT 2
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: LIST
87988: PUSH
87989: LD_VAR 0 1
87993: PUSH
87994: LD_INT 3
87996: MINUS
87997: PUSH
87998: LD_VAR 0 2
88002: PUSH
88003: LD_INT 1
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: LIST
88010: PUSH
88011: LD_VAR 0 1
88015: PUSH
88016: LD_INT 4
88018: PLUS
88019: PUSH
88020: LD_VAR 0 2
88024: PUSH
88025: LD_INT 4
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: LIST
88032: PUSH
88033: LD_VAR 0 1
88037: PUSH
88038: LD_INT 3
88040: PLUS
88041: PUSH
88042: LD_VAR 0 2
88046: PUSH
88047: LD_INT 3
88049: PLUS
88050: PUSH
88051: LD_INT 5
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: LIST
88058: PUSH
88059: LD_VAR 0 1
88063: PUSH
88064: LD_VAR 0 2
88068: PUSH
88069: LD_INT 4
88071: PLUS
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: LIST
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: ST_TO_ADDR
// end ; 1 :
88088: GO 88788
88090: LD_INT 1
88092: DOUBLE
88093: EQUAL
88094: IFTRUE 88098
88096: GO 88231
88098: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88099: LD_ADDR_VAR 0 5
88103: PUSH
88104: LD_VAR 0 1
88108: PUSH
88109: LD_VAR 0 2
88113: PUSH
88114: LD_INT 4
88116: MINUS
88117: PUSH
88118: LD_INT 3
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: LIST
88125: PUSH
88126: LD_VAR 0 1
88130: PUSH
88131: LD_INT 3
88133: MINUS
88134: PUSH
88135: LD_VAR 0 2
88139: PUSH
88140: LD_INT 3
88142: MINUS
88143: PUSH
88144: LD_INT 2
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: LIST
88151: PUSH
88152: LD_VAR 0 1
88156: PUSH
88157: LD_INT 4
88159: MINUS
88160: PUSH
88161: LD_VAR 0 2
88165: PUSH
88166: LD_INT 1
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: LIST
88173: PUSH
88174: LD_VAR 0 1
88178: PUSH
88179: LD_VAR 0 2
88183: PUSH
88184: LD_INT 3
88186: PLUS
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: LIST
88195: PUSH
88196: LD_VAR 0 1
88200: PUSH
88201: LD_INT 4
88203: PLUS
88204: PUSH
88205: LD_VAR 0 2
88209: PUSH
88210: LD_INT 4
88212: PLUS
88213: PUSH
88214: LD_INT 5
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: LIST
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: ST_TO_ADDR
// end ; 2 :
88229: GO 88788
88231: LD_INT 2
88233: DOUBLE
88234: EQUAL
88235: IFTRUE 88239
88237: GO 88368
88239: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88240: LD_ADDR_VAR 0 5
88244: PUSH
88245: LD_VAR 0 1
88249: PUSH
88250: LD_VAR 0 2
88254: PUSH
88255: LD_INT 3
88257: MINUS
88258: PUSH
88259: LD_INT 3
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: LIST
88266: PUSH
88267: LD_VAR 0 1
88271: PUSH
88272: LD_INT 4
88274: PLUS
88275: PUSH
88276: LD_VAR 0 2
88280: PUSH
88281: LD_INT 4
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: LIST
88288: PUSH
88289: LD_VAR 0 1
88293: PUSH
88294: LD_VAR 0 2
88298: PUSH
88299: LD_INT 4
88301: PLUS
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: LIST
88310: PUSH
88311: LD_VAR 0 1
88315: PUSH
88316: LD_INT 3
88318: MINUS
88319: PUSH
88320: LD_VAR 0 2
88324: PUSH
88325: LD_INT 1
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: LIST
88332: PUSH
88333: LD_VAR 0 1
88337: PUSH
88338: LD_INT 4
88340: MINUS
88341: PUSH
88342: LD_VAR 0 2
88346: PUSH
88347: LD_INT 4
88349: MINUS
88350: PUSH
88351: LD_INT 2
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: LIST
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: ST_TO_ADDR
// end ; 3 :
88366: GO 88788
88368: LD_INT 3
88370: DOUBLE
88371: EQUAL
88372: IFTRUE 88376
88374: GO 88509
88376: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88377: LD_ADDR_VAR 0 5
88381: PUSH
88382: LD_VAR 0 1
88386: PUSH
88387: LD_INT 3
88389: PLUS
88390: PUSH
88391: LD_VAR 0 2
88395: PUSH
88396: LD_INT 4
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: LIST
88403: PUSH
88404: LD_VAR 0 1
88408: PUSH
88409: LD_INT 4
88411: PLUS
88412: PUSH
88413: LD_VAR 0 2
88417: PUSH
88418: LD_INT 4
88420: PLUS
88421: PUSH
88422: LD_INT 5
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: LIST
88429: PUSH
88430: LD_VAR 0 1
88434: PUSH
88435: LD_INT 4
88437: MINUS
88438: PUSH
88439: LD_VAR 0 2
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: PUSH
88452: LD_VAR 0 1
88456: PUSH
88457: LD_VAR 0 2
88461: PUSH
88462: LD_INT 4
88464: MINUS
88465: PUSH
88466: LD_INT 3
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: LIST
88473: PUSH
88474: LD_VAR 0 1
88478: PUSH
88479: LD_INT 3
88481: MINUS
88482: PUSH
88483: LD_VAR 0 2
88487: PUSH
88488: LD_INT 3
88490: MINUS
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: LIST
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: ST_TO_ADDR
// end ; 4 :
88507: GO 88788
88509: LD_INT 4
88511: DOUBLE
88512: EQUAL
88513: IFTRUE 88517
88515: GO 88650
88517: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88518: LD_ADDR_VAR 0 5
88522: PUSH
88523: LD_VAR 0 1
88527: PUSH
88528: LD_VAR 0 2
88532: PUSH
88533: LD_INT 4
88535: PLUS
88536: PUSH
88537: LD_INT 0
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: LIST
88544: PUSH
88545: LD_VAR 0 1
88549: PUSH
88550: LD_INT 3
88552: PLUS
88553: PUSH
88554: LD_VAR 0 2
88558: PUSH
88559: LD_INT 3
88561: PLUS
88562: PUSH
88563: LD_INT 5
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: LIST
88570: PUSH
88571: LD_VAR 0 1
88575: PUSH
88576: LD_INT 4
88578: PLUS
88579: PUSH
88580: LD_VAR 0 2
88584: PUSH
88585: LD_INT 4
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: LIST
88592: PUSH
88593: LD_VAR 0 1
88597: PUSH
88598: LD_VAR 0 2
88602: PUSH
88603: LD_INT 3
88605: MINUS
88606: PUSH
88607: LD_INT 3
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: LIST
88614: PUSH
88615: LD_VAR 0 1
88619: PUSH
88620: LD_INT 4
88622: MINUS
88623: PUSH
88624: LD_VAR 0 2
88628: PUSH
88629: LD_INT 4
88631: MINUS
88632: PUSH
88633: LD_INT 2
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: LIST
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: ST_TO_ADDR
// end ; 5 :
88648: GO 88788
88650: LD_INT 5
88652: DOUBLE
88653: EQUAL
88654: IFTRUE 88658
88656: GO 88787
88658: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88659: LD_ADDR_VAR 0 5
88663: PUSH
88664: LD_VAR 0 1
88668: PUSH
88669: LD_INT 4
88671: MINUS
88672: PUSH
88673: LD_VAR 0 2
88677: PUSH
88678: LD_INT 1
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: LIST
88685: PUSH
88686: LD_VAR 0 1
88690: PUSH
88691: LD_VAR 0 2
88695: PUSH
88696: LD_INT 4
88698: MINUS
88699: PUSH
88700: LD_INT 3
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: LIST
88707: PUSH
88708: LD_VAR 0 1
88712: PUSH
88713: LD_INT 4
88715: PLUS
88716: PUSH
88717: LD_VAR 0 2
88721: PUSH
88722: LD_INT 4
88724: PLUS
88725: PUSH
88726: LD_INT 5
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: LIST
88733: PUSH
88734: LD_VAR 0 1
88738: PUSH
88739: LD_INT 3
88741: PLUS
88742: PUSH
88743: LD_VAR 0 2
88747: PUSH
88748: LD_INT 4
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: LIST
88755: PUSH
88756: LD_VAR 0 1
88760: PUSH
88761: LD_VAR 0 2
88765: PUSH
88766: LD_INT 3
88768: PLUS
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: LIST
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: ST_TO_ADDR
// end ; end ;
88785: GO 88788
88787: POP
// result := list ;
88788: LD_ADDR_VAR 0 4
88792: PUSH
88793: LD_VAR 0 5
88797: ST_TO_ADDR
// end ;
88798: LD_VAR 0 4
88802: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88803: LD_INT 0
88805: PPUSH
88806: PPUSH
88807: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88808: LD_VAR 0 1
88812: NOT
88813: PUSH
88814: LD_VAR 0 2
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: LD_INT 2
88824: PUSH
88825: LD_INT 3
88827: PUSH
88828: LD_INT 4
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: IN
88837: NOT
88838: OR
88839: IFFALSE 88843
// exit ;
88841: GO 88935
// tmp := [ ] ;
88843: LD_ADDR_VAR 0 5
88847: PUSH
88848: EMPTY
88849: ST_TO_ADDR
// for i in units do
88850: LD_ADDR_VAR 0 4
88854: PUSH
88855: LD_VAR 0 1
88859: PUSH
88860: FOR_IN
88861: IFFALSE 88904
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
88863: LD_ADDR_VAR 0 5
88867: PUSH
88868: LD_VAR 0 5
88872: PPUSH
88873: LD_VAR 0 5
88877: PUSH
88878: LD_INT 1
88880: PLUS
88881: PPUSH
88882: LD_VAR 0 4
88886: PPUSH
88887: LD_VAR 0 2
88891: PPUSH
88892: CALL_OW 259
88896: PPUSH
88897: CALL_OW 2
88901: ST_TO_ADDR
88902: GO 88860
88904: POP
88905: POP
// if not tmp then
88906: LD_VAR 0 5
88910: NOT
88911: IFFALSE 88915
// exit ;
88913: GO 88935
// result := SortListByListDesc ( units , tmp ) ;
88915: LD_ADDR_VAR 0 3
88919: PUSH
88920: LD_VAR 0 1
88924: PPUSH
88925: LD_VAR 0 5
88929: PPUSH
88930: CALL_OW 77
88934: ST_TO_ADDR
// end ;
88935: LD_VAR 0 3
88939: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88940: LD_INT 0
88942: PPUSH
88943: PPUSH
88944: PPUSH
// x := GetX ( building ) ;
88945: LD_ADDR_VAR 0 4
88949: PUSH
88950: LD_VAR 0 2
88954: PPUSH
88955: CALL_OW 250
88959: ST_TO_ADDR
// y := GetY ( building ) ;
88960: LD_ADDR_VAR 0 5
88964: PUSH
88965: LD_VAR 0 2
88969: PPUSH
88970: CALL_OW 251
88974: ST_TO_ADDR
// if GetTaskList ( unit ) then
88975: LD_VAR 0 1
88979: PPUSH
88980: CALL_OW 437
88984: IFFALSE 89079
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88986: LD_STRING e
88988: PUSH
88989: LD_VAR 0 1
88993: PPUSH
88994: CALL_OW 437
88998: PUSH
88999: LD_INT 1
89001: ARRAY
89002: PUSH
89003: LD_INT 1
89005: ARRAY
89006: EQUAL
89007: PUSH
89008: LD_VAR 0 4
89012: PUSH
89013: LD_VAR 0 1
89017: PPUSH
89018: CALL_OW 437
89022: PUSH
89023: LD_INT 1
89025: ARRAY
89026: PUSH
89027: LD_INT 2
89029: ARRAY
89030: EQUAL
89031: AND
89032: PUSH
89033: LD_VAR 0 5
89037: PUSH
89038: LD_VAR 0 1
89042: PPUSH
89043: CALL_OW 437
89047: PUSH
89048: LD_INT 1
89050: ARRAY
89051: PUSH
89052: LD_INT 3
89054: ARRAY
89055: EQUAL
89056: AND
89057: IFFALSE 89069
// result := true else
89059: LD_ADDR_VAR 0 3
89063: PUSH
89064: LD_INT 1
89066: ST_TO_ADDR
89067: GO 89077
// result := false ;
89069: LD_ADDR_VAR 0 3
89073: PUSH
89074: LD_INT 0
89076: ST_TO_ADDR
// end else
89077: GO 89087
// result := false ;
89079: LD_ADDR_VAR 0 3
89083: PUSH
89084: LD_INT 0
89086: ST_TO_ADDR
// end ;
89087: LD_VAR 0 3
89091: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89092: LD_INT 0
89094: PPUSH
89095: PPUSH
89096: PPUSH
89097: PPUSH
// if not unit or not area then
89098: LD_VAR 0 1
89102: NOT
89103: PUSH
89104: LD_VAR 0 2
89108: NOT
89109: OR
89110: IFFALSE 89114
// exit ;
89112: GO 89278
// tmp := AreaToList ( area , i ) ;
89114: LD_ADDR_VAR 0 6
89118: PUSH
89119: LD_VAR 0 2
89123: PPUSH
89124: LD_VAR 0 5
89128: PPUSH
89129: CALL_OW 517
89133: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89134: LD_ADDR_VAR 0 5
89138: PUSH
89139: DOUBLE
89140: LD_INT 1
89142: DEC
89143: ST_TO_ADDR
89144: LD_VAR 0 6
89148: PUSH
89149: LD_INT 1
89151: ARRAY
89152: PUSH
89153: FOR_TO
89154: IFFALSE 89276
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89156: LD_ADDR_VAR 0 7
89160: PUSH
89161: LD_VAR 0 6
89165: PUSH
89166: LD_INT 1
89168: ARRAY
89169: PUSH
89170: LD_VAR 0 5
89174: ARRAY
89175: PUSH
89176: LD_VAR 0 6
89180: PUSH
89181: LD_INT 2
89183: ARRAY
89184: PUSH
89185: LD_VAR 0 5
89189: ARRAY
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
89195: LD_VAR 0 7
89199: PUSH
89200: LD_INT 1
89202: ARRAY
89203: PPUSH
89204: LD_VAR 0 7
89208: PUSH
89209: LD_INT 2
89211: ARRAY
89212: PPUSH
89213: CALL_OW 428
89217: PUSH
89218: LD_INT 0
89220: EQUAL
89221: IFFALSE 89274
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
89223: LD_VAR 0 1
89227: PPUSH
89228: LD_VAR 0 7
89232: PUSH
89233: LD_INT 1
89235: ARRAY
89236: PPUSH
89237: LD_VAR 0 7
89241: PUSH
89242: LD_INT 2
89244: ARRAY
89245: PPUSH
89246: LD_VAR 0 3
89250: PPUSH
89251: CALL_OW 48
// result := IsPlaced ( unit ) ;
89255: LD_ADDR_VAR 0 4
89259: PUSH
89260: LD_VAR 0 1
89264: PPUSH
89265: CALL_OW 305
89269: ST_TO_ADDR
// exit ;
89270: POP
89271: POP
89272: GO 89278
// end ; end ;
89274: GO 89153
89276: POP
89277: POP
// end ;
89278: LD_VAR 0 4
89282: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89283: LD_INT 0
89285: PPUSH
89286: PPUSH
89287: PPUSH
// if not side or side > 8 then
89288: LD_VAR 0 1
89292: NOT
89293: PUSH
89294: LD_VAR 0 1
89298: PUSH
89299: LD_INT 8
89301: GREATER
89302: OR
89303: IFFALSE 89307
// exit ;
89305: GO 89494
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89307: LD_ADDR_VAR 0 4
89311: PUSH
89312: LD_INT 22
89314: PUSH
89315: LD_VAR 0 1
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 21
89326: PUSH
89327: LD_INT 3
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PPUSH
89338: CALL_OW 69
89342: ST_TO_ADDR
// if not tmp then
89343: LD_VAR 0 4
89347: NOT
89348: IFFALSE 89352
// exit ;
89350: GO 89494
// enable_addtolog := true ;
89352: LD_ADDR_OWVAR 81
89356: PUSH
89357: LD_INT 1
89359: ST_TO_ADDR
// AddToLog ( [ ) ;
89360: LD_STRING [
89362: PPUSH
89363: CALL_OW 561
// for i in tmp do
89367: LD_ADDR_VAR 0 3
89371: PUSH
89372: LD_VAR 0 4
89376: PUSH
89377: FOR_IN
89378: IFFALSE 89485
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89380: LD_STRING [
89382: PUSH
89383: LD_VAR 0 3
89387: PPUSH
89388: CALL_OW 266
89392: STR
89393: PUSH
89394: LD_STRING , 
89396: STR
89397: PUSH
89398: LD_VAR 0 3
89402: PPUSH
89403: CALL_OW 250
89407: STR
89408: PUSH
89409: LD_STRING , 
89411: STR
89412: PUSH
89413: LD_VAR 0 3
89417: PPUSH
89418: CALL_OW 251
89422: STR
89423: PUSH
89424: LD_STRING , 
89426: STR
89427: PUSH
89428: LD_VAR 0 3
89432: PPUSH
89433: CALL_OW 254
89437: STR
89438: PUSH
89439: LD_STRING , 
89441: STR
89442: PUSH
89443: LD_VAR 0 3
89447: PPUSH
89448: LD_INT 1
89450: PPUSH
89451: CALL_OW 268
89455: STR
89456: PUSH
89457: LD_STRING , 
89459: STR
89460: PUSH
89461: LD_VAR 0 3
89465: PPUSH
89466: LD_INT 2
89468: PPUSH
89469: CALL_OW 268
89473: STR
89474: PUSH
89475: LD_STRING ],
89477: STR
89478: PPUSH
89479: CALL_OW 561
// end ;
89483: GO 89377
89485: POP
89486: POP
// AddToLog ( ]; ) ;
89487: LD_STRING ];
89489: PPUSH
89490: CALL_OW 561
// end ;
89494: LD_VAR 0 2
89498: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89499: LD_INT 0
89501: PPUSH
89502: PPUSH
89503: PPUSH
89504: PPUSH
89505: PPUSH
// if not area or not rate or not max then
89506: LD_VAR 0 1
89510: NOT
89511: PUSH
89512: LD_VAR 0 2
89516: NOT
89517: OR
89518: PUSH
89519: LD_VAR 0 4
89523: NOT
89524: OR
89525: IFFALSE 89529
// exit ;
89527: GO 89721
// while 1 do
89529: LD_INT 1
89531: IFFALSE 89721
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89533: LD_ADDR_VAR 0 9
89537: PUSH
89538: LD_VAR 0 1
89542: PPUSH
89543: LD_INT 1
89545: PPUSH
89546: CALL_OW 287
89550: PUSH
89551: LD_INT 10
89553: MUL
89554: ST_TO_ADDR
// r := rate / 10 ;
89555: LD_ADDR_VAR 0 7
89559: PUSH
89560: LD_VAR 0 2
89564: PUSH
89565: LD_INT 10
89567: DIVREAL
89568: ST_TO_ADDR
// time := 1 1$00 ;
89569: LD_ADDR_VAR 0 8
89573: PUSH
89574: LD_INT 2100
89576: ST_TO_ADDR
// if amount < min then
89577: LD_VAR 0 9
89581: PUSH
89582: LD_VAR 0 3
89586: LESS
89587: IFFALSE 89605
// r := r * 2 else
89589: LD_ADDR_VAR 0 7
89593: PUSH
89594: LD_VAR 0 7
89598: PUSH
89599: LD_INT 2
89601: MUL
89602: ST_TO_ADDR
89603: GO 89631
// if amount > max then
89605: LD_VAR 0 9
89609: PUSH
89610: LD_VAR 0 4
89614: GREATER
89615: IFFALSE 89631
// r := r / 2 ;
89617: LD_ADDR_VAR 0 7
89621: PUSH
89622: LD_VAR 0 7
89626: PUSH
89627: LD_INT 2
89629: DIVREAL
89630: ST_TO_ADDR
// time := time / r ;
89631: LD_ADDR_VAR 0 8
89635: PUSH
89636: LD_VAR 0 8
89640: PUSH
89641: LD_VAR 0 7
89645: DIVREAL
89646: ST_TO_ADDR
// if time < 0 then
89647: LD_VAR 0 8
89651: PUSH
89652: LD_INT 0
89654: LESS
89655: IFFALSE 89672
// time := time * - 1 ;
89657: LD_ADDR_VAR 0 8
89661: PUSH
89662: LD_VAR 0 8
89666: PUSH
89667: LD_INT 1
89669: NEG
89670: MUL
89671: ST_TO_ADDR
// wait ( time ) ;
89672: LD_VAR 0 8
89676: PPUSH
89677: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
89681: LD_INT 35
89683: PPUSH
89684: LD_INT 875
89686: PPUSH
89687: CALL_OW 12
89691: PPUSH
89692: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89696: LD_INT 1
89698: PPUSH
89699: LD_INT 5
89701: PPUSH
89702: CALL_OW 12
89706: PPUSH
89707: LD_VAR 0 1
89711: PPUSH
89712: LD_INT 1
89714: PPUSH
89715: CALL_OW 55
// end ;
89719: GO 89529
// end ;
89721: LD_VAR 0 5
89725: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89726: LD_INT 0
89728: PPUSH
89729: PPUSH
89730: PPUSH
89731: PPUSH
89732: PPUSH
89733: PPUSH
89734: PPUSH
89735: PPUSH
// if not turrets or not factories then
89736: LD_VAR 0 1
89740: NOT
89741: PUSH
89742: LD_VAR 0 2
89746: NOT
89747: OR
89748: IFFALSE 89752
// exit ;
89750: GO 90059
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89752: LD_ADDR_VAR 0 10
89756: PUSH
89757: LD_INT 5
89759: PUSH
89760: LD_INT 6
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 2
89769: PUSH
89770: LD_INT 4
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 3
89779: PUSH
89780: LD_INT 5
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 24
89794: PUSH
89795: LD_INT 25
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 23
89804: PUSH
89805: LD_INT 27
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 42
89818: PUSH
89819: LD_INT 43
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 44
89828: PUSH
89829: LD_INT 46
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 45
89838: PUSH
89839: LD_INT 47
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: LIST
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: LIST
89855: ST_TO_ADDR
// result := [ ] ;
89856: LD_ADDR_VAR 0 3
89860: PUSH
89861: EMPTY
89862: ST_TO_ADDR
// for i in turrets do
89863: LD_ADDR_VAR 0 4
89867: PUSH
89868: LD_VAR 0 1
89872: PUSH
89873: FOR_IN
89874: IFFALSE 90057
// begin nat := GetNation ( i ) ;
89876: LD_ADDR_VAR 0 7
89880: PUSH
89881: LD_VAR 0 4
89885: PPUSH
89886: CALL_OW 248
89890: ST_TO_ADDR
// weapon := 0 ;
89891: LD_ADDR_VAR 0 8
89895: PUSH
89896: LD_INT 0
89898: ST_TO_ADDR
// if not nat then
89899: LD_VAR 0 7
89903: NOT
89904: IFFALSE 89908
// continue ;
89906: GO 89873
// for j in list [ nat ] do
89908: LD_ADDR_VAR 0 5
89912: PUSH
89913: LD_VAR 0 10
89917: PUSH
89918: LD_VAR 0 7
89922: ARRAY
89923: PUSH
89924: FOR_IN
89925: IFFALSE 89966
// if GetBWeapon ( i ) = j [ 1 ] then
89927: LD_VAR 0 4
89931: PPUSH
89932: CALL_OW 269
89936: PUSH
89937: LD_VAR 0 5
89941: PUSH
89942: LD_INT 1
89944: ARRAY
89945: EQUAL
89946: IFFALSE 89964
// begin weapon := j [ 2 ] ;
89948: LD_ADDR_VAR 0 8
89952: PUSH
89953: LD_VAR 0 5
89957: PUSH
89958: LD_INT 2
89960: ARRAY
89961: ST_TO_ADDR
// break ;
89962: GO 89966
// end ;
89964: GO 89924
89966: POP
89967: POP
// if not weapon then
89968: LD_VAR 0 8
89972: NOT
89973: IFFALSE 89977
// continue ;
89975: GO 89873
// for k in factories do
89977: LD_ADDR_VAR 0 6
89981: PUSH
89982: LD_VAR 0 2
89986: PUSH
89987: FOR_IN
89988: IFFALSE 90053
// begin weapons := AvailableWeaponList ( k ) ;
89990: LD_ADDR_VAR 0 9
89994: PUSH
89995: LD_VAR 0 6
89999: PPUSH
90000: CALL_OW 478
90004: ST_TO_ADDR
// if not weapons then
90005: LD_VAR 0 9
90009: NOT
90010: IFFALSE 90014
// continue ;
90012: GO 89987
// if weapon in weapons then
90014: LD_VAR 0 8
90018: PUSH
90019: LD_VAR 0 9
90023: IN
90024: IFFALSE 90051
// begin result := [ i , weapon ] ;
90026: LD_ADDR_VAR 0 3
90030: PUSH
90031: LD_VAR 0 4
90035: PUSH
90036: LD_VAR 0 8
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: ST_TO_ADDR
// exit ;
90045: POP
90046: POP
90047: POP
90048: POP
90049: GO 90059
// end ; end ;
90051: GO 89987
90053: POP
90054: POP
// end ;
90055: GO 89873
90057: POP
90058: POP
// end ;
90059: LD_VAR 0 3
90063: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90064: LD_INT 0
90066: PPUSH
// if not side or side > 8 then
90067: LD_VAR 0 3
90071: NOT
90072: PUSH
90073: LD_VAR 0 3
90077: PUSH
90078: LD_INT 8
90080: GREATER
90081: OR
90082: IFFALSE 90086
// exit ;
90084: GO 90145
// if not range then
90086: LD_VAR 0 4
90090: NOT
90091: IFFALSE 90102
// range := - 12 ;
90093: LD_ADDR_VAR 0 4
90097: PUSH
90098: LD_INT 12
90100: NEG
90101: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90102: LD_VAR 0 1
90106: PPUSH
90107: LD_VAR 0 2
90111: PPUSH
90112: LD_VAR 0 3
90116: PPUSH
90117: LD_VAR 0 4
90121: PPUSH
90122: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90126: LD_VAR 0 1
90130: PPUSH
90131: LD_VAR 0 2
90135: PPUSH
90136: LD_VAR 0 3
90140: PPUSH
90141: CALL_OW 331
// end ;
90145: LD_VAR 0 5
90149: RET
// export function Video ( mode ) ; begin
90150: LD_INT 0
90152: PPUSH
// ingame_video = mode ;
90153: LD_ADDR_OWVAR 52
90157: PUSH
90158: LD_VAR 0 1
90162: ST_TO_ADDR
// interface_hidden = mode ;
90163: LD_ADDR_OWVAR 54
90167: PUSH
90168: LD_VAR 0 1
90172: ST_TO_ADDR
// end ;
90173: LD_VAR 0 2
90177: RET
// export function Join ( array , element ) ; begin
90178: LD_INT 0
90180: PPUSH
// result := array ^ element ;
90181: LD_ADDR_VAR 0 3
90185: PUSH
90186: LD_VAR 0 1
90190: PUSH
90191: LD_VAR 0 2
90195: ADD
90196: ST_TO_ADDR
// end ;
90197: LD_VAR 0 3
90201: RET
// export function JoinUnion ( array , element ) ; begin
90202: LD_INT 0
90204: PPUSH
// result := array union element ;
90205: LD_ADDR_VAR 0 3
90209: PUSH
90210: LD_VAR 0 1
90214: PUSH
90215: LD_VAR 0 2
90219: UNION
90220: ST_TO_ADDR
// end ;
90221: LD_VAR 0 3
90225: RET
// export function GetBehemoths ( side ) ; begin
90226: LD_INT 0
90228: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
90229: LD_ADDR_VAR 0 2
90233: PUSH
90234: LD_INT 22
90236: PUSH
90237: LD_VAR 0 1
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 31
90248: PUSH
90249: LD_INT 25
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PPUSH
90260: CALL_OW 69
90264: ST_TO_ADDR
// end ;
90265: LD_VAR 0 2
90269: RET
// export function Shuffle ( array ) ; var i , index ; begin
90270: LD_INT 0
90272: PPUSH
90273: PPUSH
90274: PPUSH
// result := [ ] ;
90275: LD_ADDR_VAR 0 2
90279: PUSH
90280: EMPTY
90281: ST_TO_ADDR
// if not array then
90282: LD_VAR 0 1
90286: NOT
90287: IFFALSE 90291
// exit ;
90289: GO 90390
// Randomize ;
90291: CALL_OW 10
// for i = array downto 1 do
90295: LD_ADDR_VAR 0 3
90299: PUSH
90300: DOUBLE
90301: LD_VAR 0 1
90305: INC
90306: ST_TO_ADDR
90307: LD_INT 1
90309: PUSH
90310: FOR_DOWNTO
90311: IFFALSE 90388
// begin index := rand ( 1 , array ) ;
90313: LD_ADDR_VAR 0 4
90317: PUSH
90318: LD_INT 1
90320: PPUSH
90321: LD_VAR 0 1
90325: PPUSH
90326: CALL_OW 12
90330: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90331: LD_ADDR_VAR 0 2
90335: PUSH
90336: LD_VAR 0 2
90340: PPUSH
90341: LD_VAR 0 2
90345: PUSH
90346: LD_INT 1
90348: PLUS
90349: PPUSH
90350: LD_VAR 0 1
90354: PUSH
90355: LD_VAR 0 4
90359: ARRAY
90360: PPUSH
90361: CALL_OW 2
90365: ST_TO_ADDR
// array := Delete ( array , index ) ;
90366: LD_ADDR_VAR 0 1
90370: PUSH
90371: LD_VAR 0 1
90375: PPUSH
90376: LD_VAR 0 4
90380: PPUSH
90381: CALL_OW 3
90385: ST_TO_ADDR
// end ;
90386: GO 90310
90388: POP
90389: POP
// end ;
90390: LD_VAR 0 2
90394: RET
// export function GetBaseMaterials ( base ) ; begin
90395: LD_INT 0
90397: PPUSH
// result := [ 0 , 0 , 0 ] ;
90398: LD_ADDR_VAR 0 2
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: LD_INT 0
90408: PUSH
90409: LD_INT 0
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// if not base then
90417: LD_VAR 0 1
90421: NOT
90422: IFFALSE 90426
// exit ;
90424: GO 90475
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90426: LD_ADDR_VAR 0 2
90430: PUSH
90431: LD_VAR 0 1
90435: PPUSH
90436: LD_INT 1
90438: PPUSH
90439: CALL_OW 275
90443: PUSH
90444: LD_VAR 0 1
90448: PPUSH
90449: LD_INT 2
90451: PPUSH
90452: CALL_OW 275
90456: PUSH
90457: LD_VAR 0 1
90461: PPUSH
90462: LD_INT 3
90464: PPUSH
90465: CALL_OW 275
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: LIST
90474: ST_TO_ADDR
// end ; end_of_file
90475: LD_VAR 0 2
90479: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
90480: GO 90482
90482: DISABLE
// begin ru_radar := 98 ;
90483: LD_ADDR_EXP 93
90487: PUSH
90488: LD_INT 98
90490: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
90491: LD_ADDR_EXP 94
90495: PUSH
90496: LD_INT 89
90498: ST_TO_ADDR
// us_hack := 99 ;
90499: LD_ADDR_EXP 95
90503: PUSH
90504: LD_INT 99
90506: ST_TO_ADDR
// us_artillery := 97 ;
90507: LD_ADDR_EXP 96
90511: PUSH
90512: LD_INT 97
90514: ST_TO_ADDR
// ar_bio_bomb := 91 ;
90515: LD_ADDR_EXP 97
90519: PUSH
90520: LD_INT 91
90522: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
90523: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
90524: LD_INT 0
90526: PPUSH
90527: PPUSH
90528: PPUSH
90529: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90530: LD_VAR 0 1
90534: PPUSH
90535: CALL_OW 264
90539: PUSH
90540: LD_EXP 97
90544: EQUAL
90545: IFFALSE 90617
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90547: LD_INT 68
90549: PPUSH
90550: LD_VAR 0 1
90554: PPUSH
90555: CALL_OW 255
90559: PPUSH
90560: CALL_OW 321
90564: PUSH
90565: LD_INT 2
90567: EQUAL
90568: IFFALSE 90580
// eff := 70 else
90570: LD_ADDR_VAR 0 6
90574: PUSH
90575: LD_INT 70
90577: ST_TO_ADDR
90578: GO 90588
// eff := 30 ;
90580: LD_ADDR_VAR 0 6
90584: PUSH
90585: LD_INT 30
90587: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90588: LD_VAR 0 1
90592: PPUSH
90593: CALL_OW 250
90597: PPUSH
90598: LD_VAR 0 1
90602: PPUSH
90603: CALL_OW 251
90607: PPUSH
90608: LD_VAR 0 6
90612: PPUSH
90613: CALL_OW 495
// end ; end ;
90617: LD_VAR 0 4
90621: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
90622: LD_INT 0
90624: PPUSH
90625: PPUSH
90626: PPUSH
90627: PPUSH
90628: PPUSH
90629: PPUSH
// if cmd = 124 then
90630: LD_VAR 0 1
90634: PUSH
90635: LD_INT 124
90637: EQUAL
90638: IFFALSE 90844
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
90640: LD_ADDR_VAR 0 5
90644: PUSH
90645: LD_INT 2
90647: PUSH
90648: LD_INT 34
90650: PUSH
90651: LD_INT 53
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 34
90660: PUSH
90661: LD_INT 14
90663: PUSH
90664: EMPTY
90665: LIST
90666: LIST
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: LIST
90672: PPUSH
90673: CALL_OW 69
90677: ST_TO_ADDR
// if not tmp then
90678: LD_VAR 0 5
90682: NOT
90683: IFFALSE 90687
// exit ;
90685: GO 90844
// for i in tmp do
90687: LD_ADDR_VAR 0 3
90691: PUSH
90692: LD_VAR 0 5
90696: PUSH
90697: FOR_IN
90698: IFFALSE 90842
// begin taskList := GetTaskList ( i ) ;
90700: LD_ADDR_VAR 0 6
90704: PUSH
90705: LD_VAR 0 3
90709: PPUSH
90710: CALL_OW 437
90714: ST_TO_ADDR
// if not taskList then
90715: LD_VAR 0 6
90719: NOT
90720: IFFALSE 90724
// continue ;
90722: GO 90697
// for j = 1 to taskList do
90724: LD_ADDR_VAR 0 4
90728: PUSH
90729: DOUBLE
90730: LD_INT 1
90732: DEC
90733: ST_TO_ADDR
90734: LD_VAR 0 6
90738: PUSH
90739: FOR_TO
90740: IFFALSE 90838
// if taskList [ j ] [ 1 ] = | then
90742: LD_VAR 0 6
90746: PUSH
90747: LD_VAR 0 4
90751: ARRAY
90752: PUSH
90753: LD_INT 1
90755: ARRAY
90756: PUSH
90757: LD_STRING |
90759: EQUAL
90760: IFFALSE 90836
// begin _taskList := Delete ( taskList , 1 ) ;
90762: LD_ADDR_VAR 0 7
90766: PUSH
90767: LD_VAR 0 6
90771: PPUSH
90772: LD_INT 1
90774: PPUSH
90775: CALL_OW 3
90779: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
90780: LD_VAR 0 3
90784: PPUSH
90785: LD_VAR 0 7
90789: PPUSH
90790: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
90794: LD_VAR 0 3
90798: PPUSH
90799: LD_VAR 0 6
90803: PUSH
90804: LD_VAR 0 4
90808: ARRAY
90809: PUSH
90810: LD_INT 2
90812: ARRAY
90813: PPUSH
90814: LD_VAR 0 6
90818: PUSH
90819: LD_VAR 0 4
90823: ARRAY
90824: PUSH
90825: LD_INT 3
90827: ARRAY
90828: PPUSH
90829: LD_INT 8
90831: PPUSH
90832: CALL 90849 0 4
// end ;
90836: GO 90739
90838: POP
90839: POP
// end ;
90840: GO 90697
90842: POP
90843: POP
// end ; end ;
90844: LD_VAR 0 2
90848: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90849: LD_INT 0
90851: PPUSH
90852: PPUSH
90853: PPUSH
90854: PPUSH
90855: PPUSH
90856: PPUSH
90857: PPUSH
90858: PPUSH
90859: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90860: LD_VAR 0 1
90864: NOT
90865: PUSH
90866: LD_VAR 0 2
90870: PPUSH
90871: LD_VAR 0 3
90875: PPUSH
90876: CALL_OW 488
90880: NOT
90881: OR
90882: PUSH
90883: LD_VAR 0 4
90887: NOT
90888: OR
90889: IFFALSE 90893
// exit ;
90891: GO 91233
// list := [ ] ;
90893: LD_ADDR_VAR 0 13
90897: PUSH
90898: EMPTY
90899: ST_TO_ADDR
// if x - r < 0 then
90900: LD_VAR 0 2
90904: PUSH
90905: LD_VAR 0 4
90909: MINUS
90910: PUSH
90911: LD_INT 0
90913: LESS
90914: IFFALSE 90926
// min_x := 0 else
90916: LD_ADDR_VAR 0 7
90920: PUSH
90921: LD_INT 0
90923: ST_TO_ADDR
90924: GO 90942
// min_x := x - r ;
90926: LD_ADDR_VAR 0 7
90930: PUSH
90931: LD_VAR 0 2
90935: PUSH
90936: LD_VAR 0 4
90940: MINUS
90941: ST_TO_ADDR
// if y - r < 0 then
90942: LD_VAR 0 3
90946: PUSH
90947: LD_VAR 0 4
90951: MINUS
90952: PUSH
90953: LD_INT 0
90955: LESS
90956: IFFALSE 90968
// min_y := 0 else
90958: LD_ADDR_VAR 0 8
90962: PUSH
90963: LD_INT 0
90965: ST_TO_ADDR
90966: GO 90984
// min_y := y - r ;
90968: LD_ADDR_VAR 0 8
90972: PUSH
90973: LD_VAR 0 3
90977: PUSH
90978: LD_VAR 0 4
90982: MINUS
90983: ST_TO_ADDR
// max_x := x + r ;
90984: LD_ADDR_VAR 0 9
90988: PUSH
90989: LD_VAR 0 2
90993: PUSH
90994: LD_VAR 0 4
90998: PLUS
90999: ST_TO_ADDR
// max_y := y + r ;
91000: LD_ADDR_VAR 0 10
91004: PUSH
91005: LD_VAR 0 3
91009: PUSH
91010: LD_VAR 0 4
91014: PLUS
91015: ST_TO_ADDR
// for _x = min_x to max_x do
91016: LD_ADDR_VAR 0 11
91020: PUSH
91021: DOUBLE
91022: LD_VAR 0 7
91026: DEC
91027: ST_TO_ADDR
91028: LD_VAR 0 9
91032: PUSH
91033: FOR_TO
91034: IFFALSE 91151
// for _y = min_y to max_y do
91036: LD_ADDR_VAR 0 12
91040: PUSH
91041: DOUBLE
91042: LD_VAR 0 8
91046: DEC
91047: ST_TO_ADDR
91048: LD_VAR 0 10
91052: PUSH
91053: FOR_TO
91054: IFFALSE 91147
// begin if not ValidHex ( _x , _y ) then
91056: LD_VAR 0 11
91060: PPUSH
91061: LD_VAR 0 12
91065: PPUSH
91066: CALL_OW 488
91070: NOT
91071: IFFALSE 91075
// continue ;
91073: GO 91053
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91075: LD_VAR 0 11
91079: PPUSH
91080: LD_VAR 0 12
91084: PPUSH
91085: CALL_OW 351
91089: PUSH
91090: LD_VAR 0 11
91094: PPUSH
91095: LD_VAR 0 12
91099: PPUSH
91100: CALL_OW 554
91104: AND
91105: IFFALSE 91145
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91107: LD_ADDR_VAR 0 13
91111: PUSH
91112: LD_VAR 0 13
91116: PPUSH
91117: LD_VAR 0 13
91121: PUSH
91122: LD_INT 1
91124: PLUS
91125: PPUSH
91126: LD_VAR 0 11
91130: PUSH
91131: LD_VAR 0 12
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PPUSH
91140: CALL_OW 2
91144: ST_TO_ADDR
// end ;
91145: GO 91053
91147: POP
91148: POP
91149: GO 91033
91151: POP
91152: POP
// if not list then
91153: LD_VAR 0 13
91157: NOT
91158: IFFALSE 91162
// exit ;
91160: GO 91233
// for i in list do
91162: LD_ADDR_VAR 0 6
91166: PUSH
91167: LD_VAR 0 13
91171: PUSH
91172: FOR_IN
91173: IFFALSE 91231
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91175: LD_VAR 0 1
91179: PPUSH
91180: LD_STRING M
91182: PUSH
91183: LD_VAR 0 6
91187: PUSH
91188: LD_INT 1
91190: ARRAY
91191: PUSH
91192: LD_VAR 0 6
91196: PUSH
91197: LD_INT 2
91199: ARRAY
91200: PUSH
91201: LD_INT 0
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: LD_INT 0
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: PUSH
91222: EMPTY
91223: LIST
91224: PPUSH
91225: CALL_OW 447
91229: GO 91172
91231: POP
91232: POP
// end ;
91233: LD_VAR 0 5
91237: RET
