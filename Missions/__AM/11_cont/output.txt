// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 85764 0 0
// InitMacro ;
  23: CALL 17849 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81056 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 20014 0 0
// Action ;
  93: CALL 8495 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41379 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41379 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41379 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41805 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 100
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 100
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41697 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 100
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41697 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 48108 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 48108 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 48108 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 48108 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 48108 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 48108 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 48108 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 48108 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 48108 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 48108 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 48108 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 48108 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 48108 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 48108 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 48108 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56373 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56373 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 10
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56373 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56373 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 10
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56373 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 52932 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 52932 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 53054 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 42093 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41697 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 53950 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7871
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41697 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_EXP 100
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 34
5318: PUSH
5319: LD_INT 32
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: LIST
5330: PPUSH
5331: CALL_OW 69
5335: DIFF
5336: PPUSH
5337: CALL_OW 1
5341: ST_TO_ADDR
// for i = 1 to Difficulty do
5342: LD_ADDR_VAR 0 1
5346: PUSH
5347: DOUBLE
5348: LD_INT 1
5350: DEC
5351: ST_TO_ADDR
5352: LD_OWVAR 67
5356: PUSH
5357: FOR_TO
5358: IFFALSE 5496
// begin uc_side := 2 ;
5360: LD_ADDR_OWVAR 20
5364: PUSH
5365: LD_INT 2
5367: ST_TO_ADDR
// uc_nation := 2 ;
5368: LD_ADDR_OWVAR 21
5372: PUSH
5373: LD_INT 2
5375: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5376: LD_INT 13
5378: PPUSH
5379: LD_INT 3
5381: PPUSH
5382: LD_INT 5
5384: PPUSH
5385: LD_INT 29
5387: PPUSH
5388: LD_INT 100
5390: PPUSH
5391: CALL 52932 0 5
// un := CreateVehicle ;
5395: LD_ADDR_VAR 0 2
5399: PUSH
5400: CALL_OW 45
5404: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5405: LD_ADDR_VAR 0 3
5409: PUSH
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_INT 1
5417: PUSH
5418: LD_VAR 0 3
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: PLUS
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PPUSH
5435: LD_VAR 0 2
5439: PPUSH
5440: CALL 53054 0 3
5444: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5445: LD_VAR 0 2
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_INT 16
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5472: LD_VAR 0 2
5476: PPUSH
5477: LD_INT 51
5479: PPUSH
5480: LD_INT 10
5482: PPUSH
5483: CALL_OW 111
// wait ( 0 0$2 ) ;
5487: LD_INT 70
5489: PPUSH
5490: CALL_OW 67
// end ;
5494: GO 5357
5496: POP
5497: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5498: LD_ADDR_VAR 0 5
5502: PUSH
5503: LD_INT 51
5505: PUSH
5506: LD_INT 24
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 75
5515: PUSH
5516: LD_INT 90
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5527: LD_INT 1
5529: PPUSH
5530: LD_VAR 0 3
5534: PUSH
5535: LD_INT 1
5537: ARRAY
5538: PPUSH
5539: LD_VAR 0 5
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL 41930 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5553: LD_ADDR_VAR 0 1
5557: PUSH
5558: DOUBLE
5559: LD_INT 1
5561: DEC
5562: ST_TO_ADDR
5563: LD_INT 1
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: LD_INT 3
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_OWVAR 67
5581: ARRAY
5582: PUSH
5583: FOR_TO
5584: IFFALSE 5684
// begin uc_side := 2 ;
5586: LD_ADDR_OWVAR 20
5590: PUSH
5591: LD_INT 2
5593: ST_TO_ADDR
// uc_nation := 2 ;
5594: LD_ADDR_OWVAR 21
5598: PUSH
5599: LD_INT 2
5601: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5602: LD_INT 0
5604: PPUSH
5605: LD_INT 17
5607: PPUSH
5608: LD_VAR 0 4
5612: PPUSH
5613: CALL_OW 380
// un := CreateHuman ;
5617: LD_ADDR_VAR 0 2
5621: PUSH
5622: CALL_OW 44
5626: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5627: LD_ADDR_VAR 0 3
5631: PUSH
5632: LD_VAR 0 3
5636: PPUSH
5637: LD_INT 2
5639: PUSH
5640: LD_VAR 0 3
5644: PUSH
5645: LD_INT 2
5647: ARRAY
5648: PUSH
5649: LD_INT 1
5651: PLUS
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: LD_VAR 0 2
5661: PPUSH
5662: CALL 53054 0 3
5666: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 13
5674: PPUSH
5675: LD_INT 0
5677: PPUSH
5678: CALL_OW 49
// end ;
5682: GO 5583
5684: POP
5685: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5686: LD_ADDR_VAR 0 1
5690: PUSH
5691: DOUBLE
5692: LD_INT 1
5694: DEC
5695: ST_TO_ADDR
5696: LD_INT 3
5698: PUSH
5699: LD_INT 4
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: FOR_TO
5717: IFFALSE 5838
// begin uc_side := 2 ;
5719: LD_ADDR_OWVAR 20
5723: PUSH
5724: LD_INT 2
5726: ST_TO_ADDR
// uc_nation := 2 ;
5727: LD_ADDR_OWVAR 21
5731: PUSH
5732: LD_INT 2
5734: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5735: LD_INT 0
5737: PPUSH
5738: LD_INT 1
5740: PUSH
5741: LD_INT 8
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_VAR 0 1
5752: PUSH
5753: LD_INT 2
5755: MOD
5756: PUSH
5757: LD_INT 1
5759: PLUS
5760: ARRAY
5761: PPUSH
5762: LD_VAR 0 4
5766: PPUSH
5767: CALL_OW 380
// un := CreateHuman ;
5771: LD_ADDR_VAR 0 2
5775: PUSH
5776: CALL_OW 44
5780: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_VAR 0 3
5790: PPUSH
5791: LD_INT 2
5793: PUSH
5794: LD_VAR 0 3
5798: PUSH
5799: LD_INT 2
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: PLUS
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: LD_VAR 0 2
5815: PPUSH
5816: CALL 53054 0 3
5820: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 13
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// end ;
5836: GO 5716
5838: POP
5839: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5840: LD_ADDR_VAR 0 5
5844: PUSH
5845: LD_INT 67
5847: PUSH
5848: LD_INT 112
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 85
5857: PUSH
5858: LD_INT 130
5860: PUSH
5861: EMPTY
5862: LIST
5863: LIST
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5869: LD_INT 2
5871: PPUSH
5872: LD_VAR 0 3
5876: PUSH
5877: LD_INT 2
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 5
5885: PPUSH
5886: LD_VAR 0 6
5890: PPUSH
5891: CALL 41930 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: DOUBLE
5901: LD_INT 1
5903: DEC
5904: ST_TO_ADDR
5905: LD_INT 1
5907: PUSH
5908: LD_INT 2
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_OWVAR 67
5923: ARRAY
5924: PUSH
5925: FOR_TO
5926: IFFALSE 6026
// begin uc_side := 2 ;
5928: LD_ADDR_OWVAR 20
5932: PUSH
5933: LD_INT 2
5935: ST_TO_ADDR
// uc_nation := 2 ;
5936: LD_ADDR_OWVAR 21
5940: PUSH
5941: LD_INT 2
5943: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5944: LD_INT 0
5946: PPUSH
5947: LD_INT 17
5949: PPUSH
5950: LD_VAR 0 4
5954: PPUSH
5955: CALL_OW 380
// un := CreateHuman ;
5959: LD_ADDR_VAR 0 2
5963: PUSH
5964: CALL_OW 44
5968: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5969: LD_ADDR_VAR 0 3
5973: PUSH
5974: LD_VAR 0 3
5978: PPUSH
5979: LD_INT 3
5981: PUSH
5982: LD_VAR 0 3
5986: PUSH
5987: LD_INT 3
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PLUS
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 53054 0 3
6008: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 14
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// end ;
6024: GO 5925
6026: POP
6027: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6028: LD_ADDR_VAR 0 5
6032: PUSH
6033: LD_INT 148
6035: PUSH
6036: LD_INT 158
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 148
6045: PUSH
6046: LD_INT 158
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6057: LD_INT 3
6059: PPUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PPUSH
6069: LD_VAR 0 5
6073: PPUSH
6074: LD_VAR 0 6
6078: PPUSH
6079: CALL 41930 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6083: LD_ADDR_VAR 0 1
6087: PUSH
6088: DOUBLE
6089: LD_INT 1
6091: DEC
6092: ST_TO_ADDR
6093: LD_INT 2
6095: PUSH
6096: LD_INT 4
6098: PUSH
6099: LD_INT 4
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_OWVAR 67
6111: ARRAY
6112: PUSH
6113: FOR_TO
6114: IFFALSE 6338
// begin uc_side := 2 ;
6116: LD_ADDR_OWVAR 20
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// uc_nation := 2 ;
6124: LD_ADDR_OWVAR 21
6128: PUSH
6129: LD_INT 2
6131: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6132: LD_INT 14
6134: PPUSH
6135: LD_INT 3
6137: PPUSH
6138: LD_INT 1
6140: PUSH
6141: LD_INT 5
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 1
6150: PPUSH
6151: LD_INT 2
6153: PPUSH
6154: CALL_OW 12
6158: ARRAY
6159: PPUSH
6160: LD_INT 27
6162: PUSH
6163: LD_INT 26
6165: PUSH
6166: LD_INT 28
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 1
6176: PPUSH
6177: LD_INT 3
6179: PPUSH
6180: CALL_OW 12
6184: ARRAY
6185: PPUSH
6186: LD_INT 100
6188: PPUSH
6189: CALL 52932 0 5
// un := CreateVehicle ;
6193: LD_ADDR_VAR 0 2
6197: PUSH
6198: CALL_OW 45
6202: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_VAR 0 3
6212: PPUSH
6213: LD_INT 4
6215: PUSH
6216: LD_VAR 0 3
6220: PUSH
6221: LD_INT 4
6223: ARRAY
6224: PUSH
6225: LD_INT 1
6227: PLUS
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PPUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: CALL 53054 0 3
6242: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6243: LD_VAR 0 2
6247: PPUSH
6248: LD_INT 5
6250: PPUSH
6251: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6255: LD_VAR 0 2
6259: PPUSH
6260: LD_INT 15
6262: PPUSH
6263: LD_INT 0
6265: PPUSH
6266: CALL_OW 49
// if GetControl ( un ) = control_manual then
6270: LD_VAR 0 2
6274: PPUSH
6275: CALL_OW 263
6279: PUSH
6280: LD_INT 1
6282: EQUAL
6283: IFFALSE 6314
// begin PrepareHuman ( false , 3 , skill ) ;
6285: LD_INT 0
6287: PPUSH
6288: LD_INT 3
6290: PPUSH
6291: LD_VAR 0 4
6295: PPUSH
6296: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6300: CALL_OW 44
6304: PPUSH
6305: LD_VAR 0 2
6309: PPUSH
6310: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6314: LD_VAR 0 2
6318: PPUSH
6319: LD_INT 179
6321: PPUSH
6322: LD_INT 135
6324: PPUSH
6325: CALL_OW 111
// wait ( 0 0$2 ) ;
6329: LD_INT 70
6331: PPUSH
6332: CALL_OW 67
// end ;
6336: GO 6113
6338: POP
6339: POP
// vc_chassis := 15 ;
6340: LD_ADDR_OWVAR 37
6344: PUSH
6345: LD_INT 15
6347: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6348: LD_ADDR_VAR 0 3
6352: PUSH
6353: LD_VAR 0 3
6357: PPUSH
6358: LD_INT 4
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: LD_INT 4
6368: ARRAY
6369: PUSH
6370: LD_INT 1
6372: PLUS
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PPUSH
6378: CALL_OW 45
6382: PPUSH
6383: CALL 53054 0 3
6387: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6388: LD_VAR 0 3
6392: PUSH
6393: LD_INT 4
6395: ARRAY
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_INT 4
6404: ARRAY
6405: ARRAY
6406: PPUSH
6407: LD_INT 15
6409: PPUSH
6410: LD_INT 0
6412: PPUSH
6413: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6417: LD_INT 0
6419: PPUSH
6420: LD_INT 11
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: LD_VAR 0 3
6441: PPUSH
6442: LD_INT 4
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: PUSH
6454: LD_INT 1
6456: PLUS
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 44
6466: PPUSH
6467: CALL 53054 0 3
6471: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6472: LD_VAR 0 3
6476: PUSH
6477: LD_INT 4
6479: ARRAY
6480: PUSH
6481: LD_VAR 0 3
6485: PUSH
6486: LD_INT 4
6488: ARRAY
6489: ARRAY
6490: PPUSH
6491: LD_VAR 0 3
6495: PUSH
6496: LD_INT 4
6498: ARRAY
6499: PUSH
6500: LD_VAR 0 3
6504: PUSH
6505: LD_INT 4
6507: ARRAY
6508: PUSH
6509: LD_INT 1
6511: MINUS
6512: ARRAY
6513: PPUSH
6514: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6518: LD_ADDR_VAR 0 5
6522: PUSH
6523: LD_INT 148
6525: PUSH
6526: LD_INT 140
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PUSH
6533: EMPTY
6534: LIST
6535: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6536: LD_INT 1
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PPUSH
6548: LD_VAR 0 5
6552: PPUSH
6553: LD_VAR 0 6
6557: PPUSH
6558: CALL 41930 0 4
// if gensher_active then
6562: LD_EXP 18
6566: IFFALSE 6968
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6568: LD_EXP 45
6572: PPUSH
6573: LD_STRING D10-Diet-1
6575: PPUSH
6576: CALL_OW 94
// for i = 1 to 2 do
6580: LD_ADDR_VAR 0 1
6584: PUSH
6585: DOUBLE
6586: LD_INT 1
6588: DEC
6589: ST_TO_ADDR
6590: LD_INT 2
6592: PUSH
6593: FOR_TO
6594: IFFALSE 6732
// begin uc_side := 2 ;
6596: LD_ADDR_OWVAR 20
6600: PUSH
6601: LD_INT 2
6603: ST_TO_ADDR
// uc_nation := 2 ;
6604: LD_ADDR_OWVAR 21
6608: PUSH
6609: LD_INT 2
6611: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6612: LD_INT 13
6614: PPUSH
6615: LD_INT 3
6617: PPUSH
6618: LD_INT 5
6620: PPUSH
6621: LD_INT 29
6623: PPUSH
6624: LD_INT 100
6626: PPUSH
6627: CALL 52932 0 5
// un := CreateVehicle ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: CALL_OW 45
6640: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PPUSH
6651: LD_INT 5
6653: PUSH
6654: LD_VAR 0 3
6658: PUSH
6659: LD_INT 5
6661: ARRAY
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: PPUSH
6671: LD_VAR 0 2
6675: PPUSH
6676: CALL 53054 0 3
6680: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_INT 0
6688: PPUSH
6689: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6693: LD_VAR 0 2
6697: PPUSH
6698: LD_INT 23
6700: PPUSH
6701: LD_INT 0
6703: PPUSH
6704: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6708: LD_VAR 0 2
6712: PPUSH
6713: LD_INT 85
6715: PPUSH
6716: LD_INT 152
6718: PPUSH
6719: CALL_OW 111
// wait ( 0 0$2 ) ;
6723: LD_INT 70
6725: PPUSH
6726: CALL_OW 67
// end ;
6730: GO 6593
6732: POP
6733: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6734: LD_ADDR_VAR 0 1
6738: PUSH
6739: DOUBLE
6740: LD_INT 1
6742: DEC
6743: ST_TO_ADDR
6744: LD_INT 2
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 3
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: LD_OWVAR 67
6762: ARRAY
6763: PUSH
6764: FOR_TO
6765: IFFALSE 6922
// begin uc_side := 2 ;
6767: LD_ADDR_OWVAR 20
6771: PUSH
6772: LD_INT 2
6774: ST_TO_ADDR
// uc_nation := 2 ;
6775: LD_ADDR_OWVAR 21
6779: PUSH
6780: LD_INT 2
6782: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6783: LD_INT 14
6785: PPUSH
6786: LD_INT 3
6788: PPUSH
6789: LD_INT 5
6791: PPUSH
6792: LD_INT 27
6794: PUSH
6795: LD_INT 28
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_INT 2
6807: PPUSH
6808: CALL_OW 12
6812: ARRAY
6813: PPUSH
6814: LD_INT 100
6816: PPUSH
6817: CALL 52932 0 5
// un := CreateVehicle ;
6821: LD_ADDR_VAR 0 2
6825: PUSH
6826: CALL_OW 45
6830: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6831: LD_ADDR_VAR 0 3
6835: PUSH
6836: LD_VAR 0 3
6840: PPUSH
6841: LD_INT 5
6843: PUSH
6844: LD_VAR 0 3
6848: PUSH
6849: LD_INT 5
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_VAR 0 2
6865: PPUSH
6866: CALL 53054 0 3
6870: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 0
6878: PPUSH
6879: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6883: LD_VAR 0 2
6887: PPUSH
6888: LD_INT 23
6890: PPUSH
6891: LD_INT 0
6893: PPUSH
6894: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6898: LD_VAR 0 2
6902: PPUSH
6903: LD_INT 85
6905: PPUSH
6906: LD_INT 152
6908: PPUSH
6909: CALL_OW 111
// wait ( 0 0$2 ) ;
6913: LD_INT 70
6915: PPUSH
6916: CALL_OW 67
// end ;
6920: GO 6764
6922: POP
6923: POP
// coords := [ [ 97 , 143 ] ] ;
6924: LD_ADDR_VAR 0 5
6928: PUSH
6929: LD_INT 97
6931: PUSH
6932: LD_INT 143
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6942: LD_INT 1
6944: PPUSH
6945: LD_VAR 0 3
6949: PUSH
6950: LD_INT 5
6952: ARRAY
6953: PPUSH
6954: LD_VAR 0 5
6958: PPUSH
6959: LD_VAR 0 6
6963: PPUSH
6964: CALL 41930 0 4
// end ; Wait ( 13 13$00 ) ;
6968: LD_INT 27300
6970: PPUSH
6971: CALL_OW 67
// tmp := [ ] ;
6975: LD_ADDR_VAR 0 3
6979: PUSH
6980: EMPTY
6981: ST_TO_ADDR
// w := 1 ;
6982: LD_ADDR_VAR 0 7
6986: PUSH
6987: LD_INT 1
6989: ST_TO_ADDR
// repeat tmp := [ ] ;
6990: LD_ADDR_VAR 0 3
6994: PUSH
6995: EMPTY
6996: ST_TO_ADDR
// if w mod 4 = 0 then
6997: LD_VAR 0 7
7001: PUSH
7002: LD_INT 4
7004: MOD
7005: PUSH
7006: LD_INT 0
7008: EQUAL
7009: IFFALSE 7096
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7011: LD_ADDR_VAR 0 8
7015: PUSH
7016: LD_INT 11
7018: PUSH
7019: LD_INT 1
7021: PUSH
7022: LD_INT 2
7024: PUSH
7025: LD_INT 24
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 11
7036: PUSH
7037: LD_INT 1
7039: PUSH
7040: LD_INT 2
7042: PUSH
7043: LD_INT 24
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 11
7054: PUSH
7055: LD_INT 1
7057: PUSH
7058: LD_INT 2
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 11
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: LD_INT 2
7078: PUSH
7079: LD_INT 24
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: ST_TO_ADDR
7094: GO 7198
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7096: LD_ADDR_VAR 0 8
7100: PUSH
7101: LD_INT 14
7103: PUSH
7104: LD_INT 1
7106: PUSH
7107: LD_INT 2
7109: PUSH
7110: LD_INT 28
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 14
7121: PUSH
7122: LD_INT 1
7124: PUSH
7125: LD_INT 2
7127: PUSH
7128: LD_INT 25
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: LIST
7136: PUSH
7137: LD_INT 14
7139: PUSH
7140: LD_INT 1
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: LD_INT 28
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 14
7157: PUSH
7158: LD_INT 1
7160: PUSH
7161: LD_INT 2
7163: PUSH
7164: LD_INT 29
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 11
7175: PUSH
7176: LD_INT 1
7178: PUSH
7179: LD_INT 2
7181: PUSH
7182: LD_INT 24
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: LIST
7196: LIST
7197: ST_TO_ADDR
// if w mod 3 = 0 then
7198: LD_VAR 0 7
7202: PUSH
7203: LD_INT 3
7205: MOD
7206: PUSH
7207: LD_INT 0
7209: EQUAL
7210: IFFALSE 7286
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7212: LD_ADDR_VAR 0 8
7216: PUSH
7217: LD_VAR 0 8
7221: PPUSH
7222: LD_INT 1
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_VAR 0 1
7234: ARRAY
7235: PUSH
7236: LD_INT 1
7238: PLUS
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 14
7246: PUSH
7247: LD_INT 1
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 25
7255: PUSH
7256: LD_INT 28
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 1
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 12
7273: ARRAY
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL 53054 0 3
7285: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_VAR 0 8
7293: PPUSH
7294: CALL 41697 0 2
// if GetSide ( ar_dep_w ) = 2 then
7298: LD_INT 45
7300: PPUSH
7301: CALL_OW 255
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7394
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7311: LD_ADDR_VAR 0 8
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 27
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7375: LD_INT 2
7377: PPUSH
7378: LD_VAR 0 8
7382: PPUSH
7383: CALL 41697 0 2
// wait ( 0 0$50 ) ;
7387: LD_INT 1750
7389: PPUSH
7390: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7401: LD_EXP 69
7405: PUSH
7406: LD_INT 1
7408: ARRAY
7409: PPUSH
7410: LD_INT 3
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: LD_INT 34
7418: PUSH
7419: LD_INT 32
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 34
7428: PUSH
7429: LD_EXP 100
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: PUSH
7452: LD_INT 4
7454: GREATEREQUAL
7455: IFFALSE 7394
// wait ( 0 0$10 ) ;
7457: LD_INT 350
7459: PPUSH
7460: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_EXP 69
7473: PUSH
7474: LD_INT 1
7476: ARRAY
7477: PPUSH
7478: LD_INT 3
7480: PUSH
7481: LD_INT 2
7483: PUSH
7484: LD_INT 34
7486: PUSH
7487: LD_INT 32
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 34
7496: PUSH
7497: LD_EXP 100
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PPUSH
7515: CALL_OW 72
7519: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7520: LD_INT 100
7522: PPUSH
7523: CALL_OW 13
7527: PUSH
7528: LD_INT 50
7530: LESS
7531: IFFALSE 7564
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7533: LD_ADDR_VAR 0 5
7537: PUSH
7538: LD_INT 55
7540: PUSH
7541: LD_INT 7
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 75
7550: PUSH
7551: LD_INT 90
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: ST_TO_ADDR
7562: GO 7593
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7564: LD_ADDR_VAR 0 5
7568: PUSH
7569: LD_INT 128
7571: PUSH
7572: LD_INT 94
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 180
7581: PUSH
7582: LD_INT 135
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: ST_TO_ADDR
// if w mod 4 = 0 then
7593: LD_VAR 0 7
7597: PUSH
7598: LD_INT 4
7600: MOD
7601: PUSH
7602: LD_INT 0
7604: EQUAL
7605: IFFALSE 7636
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7607: LD_ADDR_VAR 0 5
7611: PUSH
7612: LD_INT 91
7614: PUSH
7615: LD_INT 58
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 117
7624: PUSH
7625: LD_INT 107
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: LD_VAR 0 5
7645: PUSH
7646: LD_INT 1
7648: ARRAY
7649: PPUSH
7650: LD_VAR 0 5
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 60
7677: PUSH
7678: EMPTY
7679: LIST
7680: PPUSH
7681: CALL_OW 72
7685: PUSH
7686: LD_INT 0
7688: EQUAL
7689: IFFALSE 7663
// repeat wait ( 0 0$2 ) ;
7691: LD_INT 70
7693: PPUSH
7694: CALL_OW 67
// for i in tmp do
7698: LD_ADDR_VAR 0 1
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: FOR_IN
7709: IFFALSE 7798
// if GetChassis ( i ) = ar_hovercraft then
7711: LD_VAR 0 1
7715: PPUSH
7716: CALL_OW 265
7720: PUSH
7721: LD_INT 11
7723: EQUAL
7724: IFFALSE 7762
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7726: LD_VAR 0 1
7730: PPUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: PPUSH
7756: CALL 80575 0 2
7760: GO 7796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 22
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PPUSH
7777: CALL_OW 69
7781: PPUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 74
7791: PPUSH
7792: CALL_OW 115
7796: GO 7708
7798: POP
7799: POP
// until not tmp ;
7800: LD_VAR 0 3
7804: NOT
7805: IFFALSE 7691
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7807: LD_INT 22050
7809: PPUSH
7810: LD_INT 28350
7812: PPUSH
7813: CALL_OW 12
7817: PPUSH
7818: CALL_OW 67
// w := w + 1 ;
7822: LD_ADDR_VAR 0 7
7826: PUSH
7827: LD_VAR 0 7
7831: PUSH
7832: LD_INT 1
7834: PLUS
7835: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7836: LD_INT 94
7838: PPUSH
7839: CALL_OW 301
7843: PUSH
7844: LD_EXP 50
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_INT 30
7855: PUSH
7856: LD_INT 3
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 72
7867: NOT
7868: OR
7869: IFFALSE 6990
// end ;
7871: PPOPN 8
7873: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7874: LD_INT 204
7876: IFFALSE 8342
7878: GO 7880
7880: DISABLE
7881: LD_INT 0
7883: PPUSH
7884: PPUSH
7885: PPUSH
7886: PPUSH
// begin enable ;
7887: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7888: LD_INT 35
7890: PPUSH
7891: LD_INT 1190
7893: PPUSH
7894: CALL_OW 12
7898: PPUSH
7899: CALL_OW 67
// tmp := [ ] ;
7903: LD_ADDR_VAR 0 2
7907: PUSH
7908: EMPTY
7909: ST_TO_ADDR
// uc_side := 8 ;
7910: LD_ADDR_OWVAR 20
7914: PUSH
7915: LD_INT 8
7917: ST_TO_ADDR
// uc_nation := 2 ;
7918: LD_ADDR_OWVAR 21
7922: PUSH
7923: LD_INT 2
7925: ST_TO_ADDR
// InitHc ;
7926: CALL_OW 19
// for i = 1 to 3 do
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: DOUBLE
7936: LD_INT 1
7938: DEC
7939: ST_TO_ADDR
7940: LD_INT 3
7942: PUSH
7943: FOR_TO
7944: IFFALSE 8071
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7946: LD_INT 13
7948: PUSH
7949: LD_INT 14
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: PUSH
7956: LD_INT 1
7958: PPUSH
7959: LD_INT 2
7961: PPUSH
7962: CALL_OW 12
7966: ARRAY
7967: PPUSH
7968: LD_INT 3
7970: PPUSH
7971: LD_INT 5
7973: PPUSH
7974: LD_INT 27
7976: PUSH
7977: LD_INT 28
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PUSH
7984: LD_INT 1
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: CALL_OW 12
7994: ARRAY
7995: PPUSH
7996: LD_INT 100
7998: PPUSH
7999: CALL 52932 0 5
// un := CreateVehicle ;
8003: LD_ADDR_VAR 0 3
8007: PUSH
8008: CALL_OW 45
8012: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8013: LD_VAR 0 3
8017: PPUSH
8018: LD_INT 4
8020: PPUSH
8021: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8025: LD_VAR 0 3
8029: PPUSH
8030: LD_INT 15
8032: PPUSH
8033: LD_INT 0
8035: PPUSH
8036: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8040: LD_ADDR_VAR 0 2
8044: PUSH
8045: LD_VAR 0 2
8049: PPUSH
8050: LD_VAR 0 2
8054: PUSH
8055: LD_INT 1
8057: PLUS
8058: PPUSH
8059: LD_VAR 0 3
8063: PPUSH
8064: CALL_OW 1
8068: ST_TO_ADDR
// end ;
8069: GO 7943
8071: POP
8072: POP
// for i = 1 to 4 do
8073: LD_ADDR_VAR 0 1
8077: PUSH
8078: DOUBLE
8079: LD_INT 1
8081: DEC
8082: ST_TO_ADDR
8083: LD_INT 4
8085: PUSH
8086: FOR_TO
8087: IFFALSE 8158
// begin PrepareHuman ( false , 1 , 6 ) ;
8089: LD_INT 0
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: LD_INT 6
8097: PPUSH
8098: CALL_OW 380
// un := CreateHuman ;
8102: LD_ADDR_VAR 0 3
8106: PUSH
8107: CALL_OW 44
8111: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8112: LD_VAR 0 3
8116: PPUSH
8117: LD_INT 15
8119: PPUSH
8120: LD_INT 0
8122: PPUSH
8123: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8127: LD_ADDR_VAR 0 2
8131: PUSH
8132: LD_VAR 0 2
8136: PPUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 1
8144: PLUS
8145: PPUSH
8146: LD_VAR 0 3
8150: PPUSH
8151: CALL_OW 1
8155: ST_TO_ADDR
// end ;
8156: GO 8086
8158: POP
8159: POP
// wait ( 0 0$3 ) ;
8160: LD_INT 105
8162: PPUSH
8163: CALL_OW 67
// for i in tmp do
8167: LD_ADDR_VAR 0 1
8171: PUSH
8172: LD_VAR 0 2
8176: PUSH
8177: FOR_IN
8178: IFFALSE 8246
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 257
8189: PUSH
8190: LD_INT 1
8192: EQUAL
8193: PUSH
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 247
8203: PUSH
8204: LD_INT 2
8206: EQUAL
8207: OR
8208: IFFALSE 8244
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8210: LD_VAR 0 1
8214: PPUSH
8215: LD_INT 81
8217: PUSH
8218: LD_INT 8
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PPUSH
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 74
8239: PPUSH
8240: CALL_OW 115
8244: GO 8177
8246: POP
8247: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_INT 210
8255: PPUSH
8256: LD_INT 178
8258: PPUSH
8259: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8263: LD_ADDR_VAR 0 4
8267: PUSH
8268: LD_INT 10
8270: PPUSH
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 70
8285: ST_TO_ADDR
// if x then
8286: LD_VAR 0 4
8290: IFFALSE 8318
// for i in x do
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_VAR 0 4
8301: PUSH
8302: FOR_IN
8303: IFFALSE 8316
// RemoveUnit ( i ) ;
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 64
8314: GO 8302
8316: POP
8317: POP
// wait ( 0 0$1 ) ;
8318: LD_INT 35
8320: PPUSH
8321: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8325: LD_INT 22
8327: PUSH
8328: LD_INT 8
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PPUSH
8335: CALL_OW 69
8339: NOT
8340: IFFALSE 8248
// end ;
8342: PPOPN 4
8344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 2
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 31
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: LD_INT 3
8367: PUSH
8368: LD_INT 24
8370: PUSH
8371: LD_INT 1000
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: IFFALSE 8494
8393: GO 8395
8395: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8396: LD_INT 45
8398: PPUSH
8399: CALL_OW 302
8403: PUSH
8404: LD_INT 45
8406: PPUSH
8407: CALL_OW 255
8411: AND
8412: IFFALSE 8455
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8414: LD_INT 22
8416: PUSH
8417: LD_INT 2
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: PUSH
8424: LD_INT 34
8426: PUSH
8427: LD_INT 31
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 69
8442: PPUSH
8443: LD_INT 18
8445: PPUSH
8446: LD_INT 8
8448: PPUSH
8449: CALL_OW 111
8453: GO 8494
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8455: LD_INT 22
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 34
8467: PUSH
8468: LD_INT 31
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PPUSH
8479: CALL_OW 69
8483: PPUSH
8484: LD_INT 106
8486: PPUSH
8487: LD_INT 14
8489: PPUSH
8490: CALL_OW 111
// end ; end_of_file
8494: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8495: LD_INT 0
8497: PPUSH
8498: PPUSH
8499: PPUSH
8500: PPUSH
8501: PPUSH
8502: PPUSH
// InGameOn ;
8503: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8507: LD_EXP 21
8511: PPUSH
8512: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8516: LD_INT 2
8518: PPUSH
8519: LD_INT 1
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 1
8527: PPUSH
8528: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8532: LD_ADDR_VAR 0 2
8536: PUSH
8537: LD_INT 22
8539: PUSH
8540: LD_INT 1
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: PUSH
8547: LD_INT 25
8549: PUSH
8550: LD_INT 1
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PPUSH
8561: CALL_OW 69
8565: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 22
8573: PUSH
8574: LD_INT 1
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 34
8583: PUSH
8584: LD_INT 11
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PPUSH
8595: CALL_OW 69
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: ST_TO_ADDR
// for i = 1 to tmp do
8604: LD_ADDR_VAR 0 6
8608: PUSH
8609: DOUBLE
8610: LD_INT 1
8612: DEC
8613: ST_TO_ADDR
8614: LD_VAR 0 2
8618: PUSH
8619: FOR_TO
8620: IFFALSE 8667
// begin if i = 5 then
8622: LD_VAR 0 6
8626: PUSH
8627: LD_INT 5
8629: EQUAL
8630: IFFALSE 8634
// break ;
8632: GO 8667
// sols := Replace ( sols , i , tmp [ i ] ) ;
8634: LD_ADDR_VAR 0 5
8638: PUSH
8639: LD_VAR 0 5
8643: PPUSH
8644: LD_VAR 0 6
8648: PPUSH
8649: LD_VAR 0 2
8653: PUSH
8654: LD_VAR 0 6
8658: ARRAY
8659: PPUSH
8660: CALL_OW 1
8664: ST_TO_ADDR
// end ;
8665: GO 8619
8667: POP
8668: POP
// tmp := ar_force_tmp ;
8669: LD_ADDR_VAR 0 2
8673: PUSH
8674: LD_EXP 40
8678: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8679: LD_VAR 0 2
8683: PUSH
8684: LD_INT 1
8686: ARRAY
8687: PPUSH
8688: LD_INT 108
8690: PPUSH
8691: LD_INT 139
8693: PPUSH
8694: LD_INT 0
8696: PPUSH
8697: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8701: LD_VAR 0 2
8705: PUSH
8706: LD_INT 1
8708: ARRAY
8709: PPUSH
8710: LD_EXP 21
8714: PPUSH
8715: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8719: LD_VAR 0 2
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 114
8730: PPUSH
8731: LD_INT 132
8733: PPUSH
8734: LD_INT 0
8736: PPUSH
8737: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8741: LD_VAR 0 2
8745: PUSH
8746: LD_INT 3
8748: ARRAY
8749: PPUSH
8750: LD_INT 115
8752: PPUSH
8753: LD_INT 132
8755: PPUSH
8756: LD_INT 0
8758: PPUSH
8759: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8763: LD_VAR 0 2
8767: PUSH
8768: LD_INT 2
8770: ARRAY
8771: PUSH
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 3
8779: ARRAY
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PPUSH
8785: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8789: LD_VAR 0 4
8793: PPUSH
8794: LD_INT 83
8796: PPUSH
8797: LD_INT 123
8799: PPUSH
8800: CALL_OW 111
// Wait ( 0 0$01 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8811: LD_INT 90
8813: PPUSH
8814: LD_INT 144
8816: PPUSH
8817: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8821: LD_VAR 0 5
8825: PPUSH
8826: LD_INT 88
8828: PPUSH
8829: LD_INT 129
8831: PPUSH
8832: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8836: LD_ADDR_VAR 0 3
8840: PUSH
8841: LD_INT 92
8843: PUSH
8844: LD_INT 131
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 88
8853: PUSH
8854: LD_INT 127
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: LD_INT 91
8863: PUSH
8864: LD_INT 132
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: LD_INT 92
8873: PUSH
8874: LD_INT 134
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: ST_TO_ADDR
// for i = 1 to sols do
8887: LD_ADDR_VAR 0 6
8891: PUSH
8892: DOUBLE
8893: LD_INT 1
8895: DEC
8896: ST_TO_ADDR
8897: LD_VAR 0 5
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8976
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8905: LD_VAR 0 5
8909: PUSH
8910: LD_VAR 0 6
8914: ARRAY
8915: PPUSH
8916: LD_VAR 0 3
8920: PUSH
8921: LD_VAR 0 6
8925: ARRAY
8926: PUSH
8927: LD_INT 1
8929: ARRAY
8930: PPUSH
8931: LD_VAR 0 3
8935: PUSH
8936: LD_VAR 0 6
8940: ARRAY
8941: PUSH
8942: LD_INT 2
8944: ARRAY
8945: PPUSH
8946: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: CALL_OW 197
// AddComHold ( sols ) ;
8965: LD_VAR 0 5
8969: PPUSH
8970: CALL_OW 200
// end ;
8974: GO 8902
8976: POP
8977: POP
// repeat wait ( 0 0$1 ) ;
8978: LD_INT 35
8980: PPUSH
8981: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8985: LD_VAR 0 5
8989: PUSH
8990: LD_INT 1
8992: ARRAY
8993: PPUSH
8994: LD_INT 92
8996: PPUSH
8997: LD_INT 131
8999: PPUSH
9000: CALL_OW 297
9004: PUSH
9005: LD_INT 4
9007: LESS
9008: IFFALSE 8978
// CenterOnXY ( 96 , 139 ) ;
9010: LD_INT 96
9012: PPUSH
9013: LD_INT 139
9015: PPUSH
9016: CALL_OW 84
// wait ( 0 0$3 ) ;
9020: LD_INT 105
9022: PPUSH
9023: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9027: LD_INT 111
9029: PPUSH
9030: LD_INT 135
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: LD_INT 25
9038: NEG
9039: PPUSH
9040: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9044: LD_VAR 0 2
9048: PUSH
9049: LD_INT 2
9051: ARRAY
9052: PPUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PPUSH
9062: CALL_OW 250
9066: PUSH
9067: LD_INT 3
9069: PLUS
9070: PPUSH
9071: LD_VAR 0 2
9075: PUSH
9076: LD_INT 1
9078: ARRAY
9079: PPUSH
9080: CALL_OW 251
9084: PPUSH
9085: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 3
9096: ARRAY
9097: PPUSH
9098: LD_INT 7
9100: PPUSH
9101: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9127: LD_INT 35
9129: PPUSH
9130: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: PPUSH
9143: LD_VAR 0 2
9147: PUSH
9148: LD_INT 2
9150: ARRAY
9151: PPUSH
9152: CALL_OW 296
9156: PUSH
9157: LD_INT 5
9159: LESS
9160: IFFALSE 9127
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 2
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PPUSH
9180: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9184: LD_VAR 0 2
9188: PUSH
9189: LD_INT 1
9191: ARRAY
9192: PPUSH
9193: LD_STRING D1a-Merc1-1
9195: PPUSH
9196: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9200: LD_VAR 0 2
9204: PUSH
9205: LD_INT 2
9207: ARRAY
9208: PPUSH
9209: LD_STRING D1a-FMerc2-1
9211: PPUSH
9212: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: LD_VAR 0 2
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9238: LD_VAR 0 2
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_INT 500
9249: PPUSH
9250: CALL_OW 234
// wait ( 0 0$2 ) ;
9254: LD_INT 70
9256: PPUSH
9257: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: PPUSH
9270: LD_INT 2
9272: PPUSH
9273: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9277: LD_INT 10
9279: PPUSH
9280: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 1
9291: ARRAY
9292: PPUSH
9293: LD_STRING D1a-Merc1-2
9295: PPUSH
9296: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9300: LD_INT 7
9302: PPUSH
9303: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9320: LD_VAR 0 2
9324: PUSH
9325: LD_INT 2
9327: ARRAY
9328: PPUSH
9329: LD_INT 10
9331: PPUSH
9332: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9336: LD_VAR 0 2
9340: PUSH
9341: LD_INT 2
9343: ARRAY
9344: PPUSH
9345: LD_STRING D1a-FMerc2-2
9347: PPUSH
9348: CALL_OW 88
// wait ( 0 0$1 ) ;
9352: LD_INT 35
9354: PPUSH
9355: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9359: LD_INT 7
9361: PPUSH
9362: CALL_OW 85
// wait ( 0 0$2 ) ;
9366: LD_INT 70
9368: PPUSH
9369: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9373: LD_EXP 44
9377: PPUSH
9378: LD_STRING D1a-Saliba-1
9380: PPUSH
9381: CALL_OW 91
// KillUnit ( Saliba ) ;
9385: LD_EXP 44
9389: PPUSH
9390: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9394: LD_VAR 0 2
9398: PUSH
9399: LD_INT 3
9401: ARRAY
9402: PPUSH
9403: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9407: LD_EXP 21
9411: PPUSH
9412: CALL_OW 85
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9423: LD_VAR 0 5
9427: PPUSH
9428: LD_INT 88
9430: PPUSH
9431: LD_INT 141
9433: PPUSH
9434: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9438: LD_VAR 0 5
9442: PPUSH
9443: LD_INT 70
9445: PPUSH
9446: CALL_OW 202
// wait ( 0 0$2 ) ;
9450: LD_INT 70
9452: PPUSH
9453: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9457: LD_INT 2
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: LD_INT 1
9468: PPUSH
9469: CALL_OW 80
// InGameOff ;
9473: CALL_OW 9
// ComWalk ( sols ) ;
9477: LD_VAR 0 5
9481: PPUSH
9482: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9486: LD_STRING M1
9488: PPUSH
9489: CALL_OW 337
// game_speed := 4 ;
9493: LD_ADDR_OWVAR 65
9497: PUSH
9498: LD_INT 4
9500: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9501: LD_INT 111
9503: PPUSH
9504: LD_INT 135
9506: PPUSH
9507: LD_INT 1
9509: PPUSH
9510: CALL_OW 331
// SaveForQuickRestart ;
9514: CALL_OW 22
// ar_run := true ;
9518: LD_ADDR_EXP 5
9522: PUSH
9523: LD_INT 1
9525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9526: LD_INT 35
9528: PPUSH
9529: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9533: LD_INT 22
9535: PUSH
9536: LD_INT 1
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 91
9545: PUSH
9546: LD_INT 7
9548: PUSH
9549: LD_INT 10
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 69
9565: PUSH
9566: LD_INT 7
9568: PPUSH
9569: CALL_OW 256
9573: PUSH
9574: LD_INT 999
9576: LESS
9577: OR
9578: IFFALSE 9526
// if GetSide ( ar_dep_s ) = 2 then
9580: LD_INT 7
9582: PPUSH
9583: CALL_OW 255
9587: PUSH
9588: LD_INT 2
9590: EQUAL
9591: IFFALSE 9603
// SetSide ( ar_dep_s , 1 ) ;
9593: LD_INT 7
9595: PPUSH
9596: LD_INT 1
9598: PPUSH
9599: CALL_OW 235
// end ;
9603: LD_VAR 0 1
9607: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9608: LD_EXP 5
9612: IFFALSE 9972
9614: GO 9616
9616: DISABLE
9617: LD_INT 0
9619: PPUSH
9620: PPUSH
9621: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_EXP 40
9631: PUSH
9632: LD_EXP 36
9636: PPUSH
9637: LD_INT 2
9639: PUSH
9640: LD_INT 21
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 72
9669: ADD
9670: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9671: LD_VAR 0 2
9675: PPUSH
9676: LD_INT 5
9678: PPUSH
9679: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9683: LD_INT 5
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 343
// k := 1 ;
9693: LD_ADDR_VAR 0 3
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// for i in tmp do
9701: LD_ADDR_VAR 0 1
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: FOR_IN
9712: IFFALSE 9797
// begin if IsInUnit ( i ) then
9714: LD_VAR 0 1
9718: PPUSH
9719: CALL_OW 310
9723: IFFALSE 9734
// ComExitBuilding ( i ) ;
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 122
// if GetClass ( i ) = 3 then
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 257
9743: PUSH
9744: LD_INT 3
9746: EQUAL
9747: IFFALSE 9783
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9749: LD_VAR 0 1
9753: PPUSH
9754: LD_EXP 41
9758: PUSH
9759: LD_VAR 0 3
9763: ARRAY
9764: PPUSH
9765: CALL_OW 180
// k := k + 1 ;
9769: LD_ADDR_VAR 0 3
9773: PUSH
9774: LD_VAR 0 3
9778: PUSH
9779: LD_INT 1
9781: PLUS
9782: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_INT 10
9790: PPUSH
9791: CALL_OW 173
// end ;
9795: GO 9711
9797: POP
9798: POP
// ar_patrol := true ;
9799: LD_ADDR_EXP 7
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9807: LD_INT 10
9809: PPUSH
9810: CALL_OW 67
// for i in tmp do
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_VAR 0 2
9823: PUSH
9824: FOR_IN
9825: IFFALSE 9853
// if not HasTask ( i ) then
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 314
9836: NOT
9837: IFFALSE 9851
// ComMoveToArea ( i , escape_area ) ;
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 10
9846: PPUSH
9847: CALL_OW 113
9851: GO 9824
9853: POP
9854: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9855: LD_ADDR_VAR 0 3
9859: PUSH
9860: LD_VAR 0 2
9864: PPUSH
9865: LD_INT 95
9867: PUSH
9868: LD_INT 10
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: PPUSH
9875: CALL_OW 72
9879: ST_TO_ADDR
// if k then
9880: LD_VAR 0 3
9884: IFFALSE 9953
// for i in k do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 3
9895: PUSH
9896: FOR_IN
9897: IFFALSE 9951
// begin if IsInUnit ( i ) then
9899: LD_VAR 0 1
9903: PPUSH
9904: CALL_OW 310
9908: IFFALSE 9924
// RemoveUnit ( IsInUnit ( i ) ) ;
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 310
9919: PPUSH
9920: CALL_OW 64
// RemoveUnit ( i ) ;
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 64
// tmp := tmp diff i ;
9933: LD_ADDR_VAR 0 2
9937: PUSH
9938: LD_VAR 0 2
9942: PUSH
9943: LD_VAR 0 1
9947: DIFF
9948: ST_TO_ADDR
// end ;
9949: GO 9896
9951: POP
9952: POP
// until tmp = [ ] ;
9953: LD_VAR 0 2
9957: PUSH
9958: EMPTY
9959: EQUAL
9960: IFFALSE 9807
// ChangeSideFog ( 5 , 5 ) ;
9962: LD_INT 5
9964: PPUSH
9965: LD_INT 5
9967: PPUSH
9968: CALL_OW 343
// end ;
9972: PPOPN 3
9974: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9975: LD_EXP 7
9979: IFFALSE 10269
9981: GO 9983
9983: DISABLE
9984: LD_INT 0
9986: PPUSH
9987: PPUSH
9988: PPUSH
// begin uc_side := 2 ;
9989: LD_ADDR_OWVAR 20
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// uc_nation := 2 ;
9997: LD_ADDR_OWVAR 21
10001: PUSH
10002: LD_INT 2
10004: ST_TO_ADDR
// InitHc ;
10005: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10009: LD_INT 1
10011: PPUSH
10012: LD_INT 1
10014: PPUSH
10015: LD_INT 6
10017: PPUSH
10018: CALL_OW 380
// un := CreateHuman ;
10022: LD_ADDR_VAR 0 2
10026: PUSH
10027: CALL_OW 44
10031: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10032: LD_INT 14
10034: PPUSH
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 27
10043: PPUSH
10044: LD_INT 98
10046: PPUSH
10047: CALL 52932 0 5
// veh := CreateVehicle ;
10051: LD_ADDR_VAR 0 3
10055: PUSH
10056: CALL_OW 45
10060: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 4
10068: PPUSH
10069: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_INT 179
10080: PPUSH
10081: LD_INT 135
10083: PPUSH
10084: LD_INT 0
10086: PPUSH
10087: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10091: LD_VAR 0 2
10095: PPUSH
10096: LD_VAR 0 3
10100: PPUSH
10101: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10105: LD_VAR 0 2
10109: PPUSH
10110: LD_INT 126
10112: PPUSH
10113: LD_INT 133
10115: PPUSH
10116: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10120: LD_INT 10
10122: PPUSH
10123: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10127: LD_INT 1
10129: PPUSH
10130: LD_VAR 0 3
10134: PPUSH
10135: CALL_OW 292
10139: PUSH
10140: LD_VAR 0 3
10144: PPUSH
10145: LD_INT 7
10147: PPUSH
10148: CALL_OW 296
10152: PUSH
10153: LD_INT 9
10155: LESS
10156: OR
10157: IFFALSE 10120
// ComHold ( veh ) ;
10159: LD_VAR 0 3
10163: PPUSH
10164: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10168: LD_VAR 0 2
10172: PPUSH
10173: LD_STRING D2aa-Ar1-1
10175: PPUSH
10176: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: LD_INT 177
10187: PPUSH
10188: LD_INT 96
10190: PPUSH
10191: CALL_OW 111
// AddComExitVehicle ( un ) ;
10195: LD_VAR 0 2
10199: PPUSH
10200: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10204: LD_INT 35
10206: PPUSH
10207: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10211: LD_VAR 0 2
10215: PPUSH
10216: LD_INT 204
10218: PPUSH
10219: CALL_OW 296
10223: PUSH
10224: LD_INT 15
10226: LESS
10227: IFFALSE 10204
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10229: LD_ADDR_EXP 50
10233: PUSH
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 3
10241: PUSH
10242: LD_EXP 50
10246: PUSH
10247: LD_INT 3
10249: ARRAY
10250: PUSH
10251: LD_INT 1
10253: PLUS
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL 53054 0 3
10268: ST_TO_ADDR
// end ;
10269: PPOPN 3
10271: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10272: LD_INT 7
10274: PPUSH
10275: CALL_OW 255
10279: PUSH
10280: LD_INT 1
10282: EQUAL
10283: PUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 301
10291: OR
10292: IFFALSE 12696
10294: GO 10296
10296: DISABLE
10297: LD_INT 0
10299: PPUSH
10300: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10301: LD_ADDR_VAR 0 1
10305: PUSH
10306: LD_EXP 36
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 3
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 72
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 1 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10345: LD_ADDR_VAR 0 2
10349: PUSH
10350: LD_INT 46
10352: PUSH
10353: LD_INT 41
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 50
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 57
10372: PUSH
10373: LD_INT 75
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 75
10382: PUSH
10383: LD_INT 89
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 51
10392: PUSH
10393: LD_INT 45
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 95
10402: PUSH
10403: LD_INT 95
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: LD_INT 84
10412: PUSH
10413: LD_INT 77
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PUSH
10420: LD_INT 101
10422: PUSH
10423: LD_INT 76
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: PUSH
10430: LD_INT 118
10432: PUSH
10433: LD_INT 81
10435: PUSH
10436: EMPTY
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 139
10442: PUSH
10443: LD_INT 97
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 129
10452: PUSH
10453: LD_INT 114
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 154
10462: PUSH
10463: LD_INT 111
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: ST_TO_ADDR
// base_captured := true ;
10484: LD_ADDR_EXP 6
10488: PUSH
10489: LD_INT 1
10491: ST_TO_ADDR
// DialogueOn ;
10492: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10496: LD_EXP 21
10500: PPUSH
10501: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10505: LD_EXP 21
10509: PPUSH
10510: LD_STRING D2-JMM-1
10512: PPUSH
10513: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10517: LD_EXP 30
10521: PPUSH
10522: LD_STRING D2-Pow-1
10524: PPUSH
10525: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10529: LD_EXP 21
10533: PPUSH
10534: LD_STRING D2-JMM-2
10536: PPUSH
10537: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10541: LD_EXP 30
10545: PPUSH
10546: LD_STRING D2-Pow-2
10548: PPUSH
10549: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10553: LD_EXP 21
10557: PPUSH
10558: LD_STRING D2-JMM-3
10560: PPUSH
10561: CALL_OW 88
// DialogueOff ;
10565: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10569: LD_STRING M2
10571: PPUSH
10572: CALL_OW 337
// Wait ( 0 0$2 ) ;
10576: LD_INT 70
10578: PPUSH
10579: CALL_OW 67
// if IsOk ( Gary ) then
10583: LD_EXP 32
10587: PPUSH
10588: CALL_OW 302
10592: IFFALSE 10606
// Say ( Gary , D2a-Gary-1 ) ;
10594: LD_EXP 32
10598: PPUSH
10599: LD_STRING D2a-Gary-1
10601: PPUSH
10602: CALL_OW 88
// if IsOk ( Bobby ) then
10606: LD_EXP 24
10610: PPUSH
10611: CALL_OW 302
10615: IFFALSE 10629
// Say ( Bobby , D2a-Bobby-1 ) ;
10617: LD_EXP 24
10621: PPUSH
10622: LD_STRING D2a-Bobby-1
10624: PPUSH
10625: CALL_OW 88
// if IsOk ( Cyrus ) then
10629: LD_EXP 25
10633: PPUSH
10634: CALL_OW 302
10638: IFFALSE 10652
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10640: LD_EXP 25
10644: PPUSH
10645: LD_STRING D2a-Cyrus-1
10647: PPUSH
10648: CALL_OW 88
// if IsOk ( Lisa ) then
10652: LD_EXP 22
10656: PPUSH
10657: CALL_OW 302
10661: IFFALSE 10675
// Say ( Lisa , D2a-Lisa-1 ) ;
10663: LD_EXP 22
10667: PPUSH
10668: LD_STRING D2a-Lisa-1
10670: PPUSH
10671: CALL_OW 88
// if IsOk ( Frank ) then
10675: LD_EXP 33
10679: PPUSH
10680: CALL_OW 302
10684: IFFALSE 10698
// Say ( Frank , D2a-Frank-1 ) ;
10686: LD_EXP 33
10690: PPUSH
10691: LD_STRING D2a-Frank-1
10693: PPUSH
10694: CALL_OW 88
// if IsOk ( Cornel ) then
10698: LD_EXP 31
10702: PPUSH
10703: CALL_OW 302
10707: IFFALSE 10721
// Say ( Cornel , D2a-Corn-1 ) ;
10709: LD_EXP 31
10713: PPUSH
10714: LD_STRING D2a-Corn-1
10716: PPUSH
10717: CALL_OW 88
// if IsOk ( Donaldson ) then
10721: LD_EXP 23
10725: PPUSH
10726: CALL_OW 302
10730: IFFALSE 10744
// Say ( Donaldson , D2a-Don-1 ) ;
10732: LD_EXP 23
10736: PPUSH
10737: LD_STRING D2a-Don-1
10739: PPUSH
10740: CALL_OW 88
// if IsOk ( Brown ) then
10744: LD_EXP 27
10748: PPUSH
10749: CALL_OW 302
10753: IFFALSE 10767
// Say ( Brown , D2a-Brown-1 ) ;
10755: LD_EXP 27
10759: PPUSH
10760: LD_STRING D2a-Brown-1
10762: PPUSH
10763: CALL_OW 88
// Wait ( 0 0$30 ) ;
10767: LD_INT 1050
10769: PPUSH
10770: CALL_OW 67
// if IsOk ( Frank ) then
10774: LD_EXP 33
10778: PPUSH
10779: CALL_OW 302
10783: IFFALSE 11049
// begin DialogueOn ;
10785: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10789: LD_EXP 21
10793: PUSH
10794: LD_EXP 33
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PPUSH
10803: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10807: LD_EXP 33
10811: PPUSH
10812: LD_STRING D3F-Frank-1
10814: PPUSH
10815: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10819: LD_EXP 21
10823: PPUSH
10824: LD_STRING D3F-JMM-1
10826: PPUSH
10827: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10831: LD_EXP 33
10835: PPUSH
10836: LD_STRING D3F-Frank-2
10838: PPUSH
10839: CALL_OW 88
// case Query ( QFrank ) of 1 :
10843: LD_STRING QFrank
10845: PPUSH
10846: CALL_OW 97
10850: PUSH
10851: LD_INT 1
10853: DOUBLE
10854: EQUAL
10855: IFTRUE 10859
10857: GO 10882
10859: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10860: LD_EXP 21
10864: PPUSH
10865: LD_STRING D3Fa-JMM-1
10867: PPUSH
10868: CALL_OW 88
// us_scout := 1 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 1
10879: ST_TO_ADDR
// end ; 2 :
10880: GO 11045
10882: LD_INT 2
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 11012
10890: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10891: LD_EXP 21
10895: PPUSH
10896: LD_STRING D3Fb-JMM-1
10898: PPUSH
10899: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10903: LD_EXP 33
10907: PPUSH
10908: LD_STRING D3Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10915: LD_STRING QFrank2
10917: PPUSH
10918: CALL_OW 97
10922: PUSH
10923: LD_INT 1
10925: DOUBLE
10926: EQUAL
10927: IFTRUE 10931
10929: GO 10978
10931: POP
// begin us_scout := 2 ;
10932: LD_ADDR_EXP 8
10936: PUSH
10937: LD_INT 2
10939: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fba-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fba-Frank-1
10959: PPUSH
10960: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10964: LD_EXP 21
10968: PPUSH
10969: LD_STRING D3Fba-JMM-2
10971: PPUSH
10972: CALL_OW 88
// end ; 2 :
10976: GO 11010
10978: LD_INT 2
10980: DOUBLE
10981: EQUAL
10982: IFTRUE 10986
10984: GO 11009
10986: POP
// begin us_scout := 0 ;
10987: LD_ADDR_EXP 8
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10995: LD_EXP 21
10999: PPUSH
11000: LD_STRING D3Fbb-JMM-1
11002: PPUSH
11003: CALL_OW 88
// end ; end ;
11007: GO 11010
11009: POP
// end ; 3 :
11010: GO 11045
11012: LD_INT 3
11014: DOUBLE
11015: EQUAL
11016: IFTRUE 11020
11018: GO 11044
11020: POP
// begin us_scout := - 1 ;
11021: LD_ADDR_EXP 8
11025: PUSH
11026: LD_INT 1
11028: NEG
11029: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11030: LD_EXP 21
11034: PPUSH
11035: LD_STRING D3Fc-JMM-1
11037: PPUSH
11038: CALL_OW 88
// end ; end ;
11042: GO 11045
11044: POP
// DialogueOff ;
11045: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11049: LD_EXP 8
11053: PUSH
11054: LD_INT 1
11056: NEG
11057: PUSH
11058: LD_INT 0
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: IN
11065: IFFALSE 11069
// exit ;
11067: GO 12696
// if us_scout in [ 1 , 2 ] then
11069: LD_EXP 8
11073: PUSH
11074: LD_INT 1
11076: PUSH
11077: LD_INT 2
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: IN
11084: IFFALSE 11763
// begin if IsInUnit ( Frank ) then
11086: LD_EXP 33
11090: PPUSH
11091: CALL_OW 310
11095: IFFALSE 11106
// ComExit ( Frank ) ;
11097: LD_EXP 33
11101: PPUSH
11102: CALL 84818 0 1
// SetSide ( Frank , 4 ) ;
11106: LD_EXP 33
11110: PPUSH
11111: LD_INT 4
11113: PPUSH
11114: CALL_OW 235
// wait ( 0 0$1 ) ;
11118: LD_INT 35
11120: PPUSH
11121: CALL_OW 67
// if us_scout = 2 then
11125: LD_EXP 8
11129: PUSH
11130: LD_INT 2
11132: EQUAL
11133: IFFALSE 11501
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11135: LD_EXP 33
11139: PPUSH
11140: LD_INT 75
11142: PPUSH
11143: LD_INT 63
11145: PPUSH
11146: CALL_OW 111
// AddComHold ( Frank ) ;
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 770
11166: PPUSH
11167: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 100
11178: PPUSH
11179: LD_INT 75
11181: PPUSH
11182: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11186: LD_EXP 33
11190: PPUSH
11191: LD_INT 123
11193: PPUSH
11194: LD_INT 103
11196: PPUSH
11197: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11201: LD_EXP 33
11205: PPUSH
11206: LD_INT 138
11208: PPUSH
11209: LD_INT 108
11211: PPUSH
11212: CALL_OW 171
// AddComHold ( Frank ) ;
11216: LD_EXP 33
11220: PPUSH
11221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11225: LD_INT 35
11227: PPUSH
11228: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11232: LD_EXP 33
11236: PPUSH
11237: LD_INT 138
11239: PPUSH
11240: LD_INT 108
11242: PPUSH
11243: CALL_OW 307
11247: IFFALSE 11225
// AddComMoveXY ( Frank , 125 , 132 ) ;
11249: LD_EXP 33
11253: PPUSH
11254: LD_INT 125
11256: PPUSH
11257: LD_INT 132
11259: PPUSH
11260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11264: LD_INT 35
11266: PPUSH
11267: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11271: LD_INT 1
11273: PPUSH
11274: LD_EXP 33
11278: PPUSH
11279: CALL_OW 292
11283: PUSH
11284: LD_EXP 33
11288: PPUSH
11289: LD_INT 7
11291: PPUSH
11292: CALL_OW 296
11296: PUSH
11297: LD_INT 7
11299: LESS
11300: OR
11301: IFFALSE 11264
// DialogueOn ;
11303: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11307: LD_EXP 33
11311: PPUSH
11312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11316: LD_INT 10
11318: PPUSH
11319: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11323: LD_EXP 21
11327: PPUSH
11328: LD_STRING D4Fa-JMM-1
11330: PPUSH
11331: CALL_OW 88
// for i in points do
11335: LD_ADDR_VAR 0 1
11339: PUSH
11340: LD_VAR 0 2
11344: PUSH
11345: FOR_IN
11346: IFFALSE 11404
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11348: LD_VAR 0 1
11352: PUSH
11353: LD_INT 1
11355: ARRAY
11356: PPUSH
11357: LD_VAR 0 1
11361: PUSH
11362: LD_INT 2
11364: ARRAY
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: LD_INT 20
11371: NEG
11372: PPUSH
11373: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11377: LD_VAR 0 1
11381: PUSH
11382: LD_INT 1
11384: ARRAY
11385: PPUSH
11386: LD_VAR 0 1
11390: PUSH
11391: LD_INT 2
11393: ARRAY
11394: PPUSH
11395: LD_INT 1
11397: PPUSH
11398: CALL_OW 331
// end ;
11402: GO 11345
11404: POP
11405: POP
// dwait ( 0 0$0.5 ) ;
11406: LD_INT 18
11408: PPUSH
11409: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11413: LD_INT 42
11415: PPUSH
11416: LD_INT 27
11418: PPUSH
11419: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11423: LD_EXP 33
11427: PPUSH
11428: LD_STRING D4Fa-Frank-1
11430: PPUSH
11431: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11435: LD_INT 18
11437: PPUSH
11438: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11442: LD_EXP 21
11446: PPUSH
11447: LD_STRING D4Fa-JMM-2
11449: PPUSH
11450: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11454: LD_INT 118
11456: PPUSH
11457: LD_INT 80
11459: PPUSH
11460: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11464: LD_EXP 33
11468: PPUSH
11469: LD_STRING D4Fa-Frank-2
11471: PPUSH
11472: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11476: LD_INT 10
11478: PPUSH
11479: CALL_OW 68
// DialogueOff ;
11483: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_INT 1
11494: PPUSH
11495: CALL_OW 235
// end else
11499: GO 11763
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11501: LD_INT 2
11503: PPUSH
11504: LD_INT 4
11506: PPUSH
11507: LD_INT 2
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11517: LD_EXP 33
11521: PPUSH
11522: LD_INT 75
11524: PPUSH
11525: LD_INT 63
11527: PPUSH
11528: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 175
11539: PPUSH
11540: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11544: LD_EXP 33
11548: PPUSH
11549: LD_INT 102
11551: PPUSH
11552: LD_INT 76
11554: PPUSH
11555: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11559: LD_EXP 33
11563: PPUSH
11564: LD_INT 108
11566: PPUSH
11567: LD_INT 70
11569: PPUSH
11570: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11574: LD_INT 35
11576: PPUSH
11577: CALL_OW 67
// until See ( 2 , Frank ) ;
11581: LD_INT 2
11583: PPUSH
11584: LD_EXP 33
11588: PPUSH
11589: CALL_OW 292
11593: IFFALSE 11574
// ComMoveXY ( Frank , 112 , 118 ) ;
11595: LD_EXP 33
11599: PPUSH
11600: LD_INT 112
11602: PPUSH
11603: LD_INT 118
11605: PPUSH
11606: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11610: LD_EXP 33
11614: PPUSH
11615: CALL_OW 256
11619: PUSH
11620: LD_INT 750
11622: GREATEREQUAL
11623: IFFALSE 11637
// SetLives ( Frank , 700 ) ;
11625: LD_EXP 33
11629: PPUSH
11630: LD_INT 700
11632: PPUSH
11633: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11637: LD_INT 35
11639: PPUSH
11640: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11644: LD_INT 1
11646: PPUSH
11647: LD_EXP 33
11651: PPUSH
11652: CALL_OW 292
11656: PUSH
11657: LD_EXP 33
11661: PPUSH
11662: LD_INT 7
11664: PPUSH
11665: CALL_OW 296
11669: PUSH
11670: LD_INT 17
11672: LESS
11673: OR
11674: IFFALSE 11637
// DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11680: LD_EXP 33
11684: PPUSH
11685: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_STRING D4Fb-Frank-1
11696: PPUSH
11697: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11701: LD_EXP 21
11705: PPUSH
11706: LD_STRING D4Fb-JMM-1
11708: PPUSH
11709: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11713: LD_INT 2
11715: PPUSH
11716: LD_STRING D4Fb-FSci1-1
11718: PPUSH
11719: CALL 16611 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11723: LD_EXP 33
11727: PPUSH
11728: LD_STRING D4Fb-Frank-2
11730: PPUSH
11731: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11735: LD_EXP 21
11739: PPUSH
11740: LD_STRING D4Fb-JMM-2
11742: PPUSH
11743: CALL_OW 88
// DialogueOff ;
11747: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11751: LD_EXP 33
11755: PPUSH
11756: LD_INT 1
11758: PPUSH
11759: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11763: LD_EXP 34
11767: PPUSH
11768: CALL_OW 302
11772: PUSH
11773: LD_EXP 33
11777: NOT
11778: AND
11779: IFFALSE 11927
// begin DialogueOn ;
11781: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11785: LD_EXP 21
11789: PUSH
11790: LD_EXP 34
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11803: LD_EXP 34
11807: PPUSH
11808: LD_STRING D3Y-Yam-1
11810: PPUSH
11811: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11815: LD_EXP 21
11819: PPUSH
11820: LD_STRING D3Y-JMM-1
11822: PPUSH
11823: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11827: LD_EXP 34
11831: PPUSH
11832: LD_STRING D3Y-Yam-2
11834: PPUSH
11835: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11839: LD_STRING QYamoko
11841: PPUSH
11842: CALL_OW 97
11846: PUSH
11847: LD_INT 1
11849: DOUBLE
11850: EQUAL
11851: IFTRUE 11855
11853: GO 11890
11855: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11856: LD_EXP 21
11860: PPUSH
11861: LD_STRING D3Ya-JMM-1
11863: PPUSH
11864: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Ya-Yam-1
11875: PPUSH
11876: CALL_OW 88
// us_scout := 1 ;
11880: LD_ADDR_EXP 8
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// end ; 2 :
11888: GO 11923
11890: LD_INT 2
11892: DOUBLE
11893: EQUAL
11894: IFTRUE 11898
11896: GO 11922
11898: POP
// begin us_scout := - 1 ;
11899: LD_ADDR_EXP 8
11903: PUSH
11904: LD_INT 1
11906: NEG
11907: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11908: LD_EXP 21
11912: PPUSH
11913: LD_STRING D3Yb-JMM-1
11915: PPUSH
11916: CALL_OW 88
// end ; end ;
11920: GO 11923
11922: POP
// DialogueOff ;
11923: CALL_OW 7
// end ; if Frank then
11927: LD_EXP 33
11931: IFFALSE 11935
// exit ;
11933: GO 12696
// if us_scout in [ - 1 , 0 ] then
11935: LD_EXP 8
11939: PUSH
11940: LD_INT 1
11942: NEG
11943: PUSH
11944: LD_INT 0
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: IN
11951: IFFALSE 11955
// exit ;
11953: GO 12696
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11955: LD_ADDR_EXP 8
11959: PUSH
11960: LD_INT 2
11962: PUSH
11963: LD_INT 2
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: LD_OWVAR 67
11978: ARRAY
11979: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11980: LD_EXP 8
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: LD_INT 2
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: IN
11995: IFFALSE 12696
// begin if IsInUnit ( Kikuchi ) then
11997: LD_EXP 34
12001: PPUSH
12002: CALL_OW 310
12006: IFFALSE 12017
// ComExitBuilding ( Kikuchi ) ;
12008: LD_EXP 34
12012: PPUSH
12013: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 311
12026: IFFALSE 12037
// ComExitVehicle ( Kikuchi ) ;
12028: LD_EXP 34
12032: PPUSH
12033: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12037: LD_EXP 34
12041: PPUSH
12042: LD_INT 4
12044: PPUSH
12045: CALL_OW 235
// wait ( 0 0$1 ) ;
12049: LD_INT 35
12051: PPUSH
12052: CALL_OW 67
// if us_scout = 2 then
12056: LD_EXP 8
12060: PUSH
12061: LD_INT 2
12063: EQUAL
12064: IFFALSE 12444
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12066: LD_EXP 34
12070: PPUSH
12071: LD_INT 75
12073: PPUSH
12074: LD_INT 63
12076: PPUSH
12077: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 770
12097: PPUSH
12098: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12102: LD_EXP 34
12106: PPUSH
12107: LD_INT 100
12109: PPUSH
12110: LD_INT 75
12112: PPUSH
12113: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12117: LD_EXP 34
12121: PPUSH
12122: LD_INT 123
12124: PPUSH
12125: LD_INT 103
12127: PPUSH
12128: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12132: LD_EXP 34
12136: PPUSH
12137: LD_INT 138
12139: PPUSH
12140: LD_INT 108
12142: PPUSH
12143: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12147: LD_EXP 34
12151: PPUSH
12152: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12156: LD_INT 35
12158: PPUSH
12159: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 138
12170: PPUSH
12171: LD_INT 108
12173: PPUSH
12174: CALL_OW 307
12178: IFFALSE 12156
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12180: LD_EXP 34
12184: PPUSH
12185: LD_INT 125
12187: PPUSH
12188: LD_INT 132
12190: PPUSH
12191: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12195: LD_INT 35
12197: PPUSH
12198: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12202: LD_INT 1
12204: PPUSH
12205: LD_EXP 34
12209: PPUSH
12210: CALL_OW 292
12214: PUSH
12215: LD_EXP 34
12219: PPUSH
12220: LD_INT 7
12222: PPUSH
12223: CALL_OW 296
12227: PUSH
12228: LD_INT 7
12230: LESS
12231: OR
12232: IFFALSE 12195
// DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12238: LD_EXP 34
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12254: LD_EXP 34
12258: PPUSH
12259: LD_STRING D4Ya-Yam-1
12261: PPUSH
12262: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12266: LD_EXP 21
12270: PPUSH
12271: LD_STRING D4Ya-JMM-1
12273: PPUSH
12274: CALL_OW 88
// for i in points do
12278: LD_ADDR_VAR 0 1
12282: PUSH
12283: LD_VAR 0 2
12287: PUSH
12288: FOR_IN
12289: IFFALSE 12347
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12291: LD_VAR 0 1
12295: PUSH
12296: LD_INT 1
12298: ARRAY
12299: PPUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_INT 2
12307: ARRAY
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: LD_INT 20
12314: NEG
12315: PPUSH
12316: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12320: LD_VAR 0 1
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 1
12333: PUSH
12334: LD_INT 2
12336: ARRAY
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 331
// end ;
12345: GO 12288
12347: POP
12348: POP
// dwait ( 0 0$0.5 ) ;
12349: LD_INT 18
12351: PPUSH
12352: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12356: LD_INT 42
12358: PPUSH
12359: LD_INT 27
12361: PPUSH
12362: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12366: LD_EXP 34
12370: PPUSH
12371: LD_STRING D4Ya-Yam-2
12373: PPUSH
12374: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12378: LD_INT 18
12380: PPUSH
12381: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12385: LD_INT 118
12387: PPUSH
12388: LD_INT 80
12390: PPUSH
12391: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12395: LD_EXP 21
12399: PPUSH
12400: LD_STRING D4Ya-JMM-2
12402: PPUSH
12403: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12407: LD_EXP 34
12411: PPUSH
12412: LD_STRING D4Ya-Yam-3
12414: PPUSH
12415: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12419: LD_INT 10
12421: PPUSH
12422: CALL_OW 68
// DialogueOff ;
12426: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12430: LD_EXP 34
12434: PPUSH
12435: LD_INT 1
12437: PPUSH
12438: CALL_OW 235
// end else
12442: GO 12696
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12444: LD_INT 2
12446: PPUSH
12447: LD_INT 4
12449: PPUSH
12450: LD_INT 2
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_INT 75
12467: PPUSH
12468: LD_INT 63
12470: PPUSH
12471: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_INT 175
12482: PPUSH
12483: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12487: LD_EXP 34
12491: PPUSH
12492: LD_INT 102
12494: PPUSH
12495: LD_INT 76
12497: PPUSH
12498: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12502: LD_EXP 34
12506: PPUSH
12507: LD_INT 108
12509: PPUSH
12510: LD_INT 70
12512: PPUSH
12513: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12517: LD_INT 35
12519: PPUSH
12520: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12524: LD_INT 2
12526: PPUSH
12527: LD_EXP 34
12531: PPUSH
12532: CALL_OW 292
12536: IFFALSE 12517
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12538: LD_EXP 34
12542: PPUSH
12543: LD_INT 112
12545: PPUSH
12546: LD_INT 118
12548: PPUSH
12549: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12553: LD_EXP 34
12557: PPUSH
12558: CALL_OW 256
12562: PUSH
12563: LD_INT 750
12565: GREATEREQUAL
12566: IFFALSE 12580
// SetLives ( Kikuchi , 700 ) ;
12568: LD_EXP 34
12572: PPUSH
12573: LD_INT 700
12575: PPUSH
12576: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12580: LD_INT 35
12582: PPUSH
12583: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 34
12594: PPUSH
12595: CALL_OW 292
12599: PUSH
12600: LD_EXP 34
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 296
12612: PUSH
12613: LD_INT 17
12615: LESS
12616: OR
12617: IFFALSE 12580
// DialogueOn ;
12619: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12623: LD_EXP 34
12627: PPUSH
12628: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12632: LD_EXP 34
12636: PPUSH
12637: LD_STRING D4Yb-Yam-1
12639: PPUSH
12640: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12644: LD_EXP 21
12648: PPUSH
12649: LD_STRING D4Yb-JMM-1
12651: PPUSH
12652: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12656: LD_EXP 34
12660: PPUSH
12661: LD_STRING D4Yb-Yam-2
12663: PPUSH
12664: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12668: LD_EXP 21
12672: PPUSH
12673: LD_STRING D4Yb-JMM-2
12675: PPUSH
12676: CALL_OW 88
// DialogueOff ;
12680: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12684: LD_EXP 34
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL_OW 235
// end ; end ; end ;
12696: PPOPN 2
12698: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12699: LD_EXP 6
12703: IFFALSE 13736
12705: GO 12707
12707: DISABLE
12708: LD_INT 0
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// begin enable ;
12714: ENABLE
// if not seen [ 1 ] then
12715: LD_EXP 9
12719: PUSH
12720: LD_INT 1
12722: ARRAY
12723: NOT
12724: IFFALSE 12904
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_INT 2
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: LD_INT 2
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 11
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 33
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PPUSH
12773: CALL_OW 69
12777: ST_TO_ADDR
// if tmp then
12778: LD_VAR 0 2
12782: IFFALSE 12904
// for i in tmp do
12784: LD_ADDR_VAR 0 1
12788: PUSH
12789: LD_VAR 0 2
12793: PUSH
12794: FOR_IN
12795: IFFALSE 12902
// if See ( 1 , i ) then
12797: LD_INT 1
12799: PPUSH
12800: LD_VAR 0 1
12804: PPUSH
12805: CALL_OW 292
12809: IFFALSE 12900
// begin seen := Replace ( seen , 1 , true ) ;
12811: LD_ADDR_EXP 9
12815: PUSH
12816: LD_EXP 9
12820: PPUSH
12821: LD_INT 1
12823: PPUSH
12824: LD_INT 1
12826: PPUSH
12827: CALL_OW 1
12831: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12832: LD_INT 1
12834: PPUSH
12835: CALL 16433 0 1
12839: IFFALSE 12900
// begin DialogueOn ;
12841: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12845: LD_VAR 0 1
12849: PPUSH
12850: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12854: LD_INT 10
12856: PPUSH
12857: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12861: LD_ADDR_VAR 0 3
12865: PUSH
12866: LD_INT 1
12868: PPUSH
12869: LD_STRING D5a-Sol2-1
12871: PPUSH
12872: CALL 16611 0 2
12876: ST_TO_ADDR
// if not un then
12877: LD_VAR 0 3
12881: NOT
12882: IFFALSE 12894
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12884: LD_INT 2
12886: PPUSH
12887: LD_STRING D5a-FSol2-1
12889: PPUSH
12890: CALL 16611 0 2
// DialogueOff ;
12894: CALL_OW 7
// break ;
12898: GO 12902
// end ; end ;
12900: GO 12794
12902: POP
12903: POP
// end ; if not seen [ 2 ] then
12904: LD_EXP 9
12908: PUSH
12909: LD_INT 2
12911: ARRAY
12912: NOT
12913: IFFALSE 13138
// begin can_kamikazed := true ;
12915: LD_ADDR_EXP 10
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12923: LD_ADDR_VAR 0 2
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 2
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: LD_INT 25
12940: PUSH
12941: LD_INT 17
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: ST_TO_ADDR
// if tmp then
12957: LD_VAR 0 2
12961: IFFALSE 13138
// for i in tmp do
12963: LD_ADDR_VAR 0 1
12967: PUSH
12968: LD_VAR 0 2
12972: PUSH
12973: FOR_IN
12974: IFFALSE 13136
// if See ( 1 , i ) then
12976: LD_INT 1
12978: PPUSH
12979: LD_VAR 0 1
12983: PPUSH
12984: CALL_OW 292
12988: IFFALSE 13134
// begin seen := Replace ( seen , 2 , true ) ;
12990: LD_ADDR_EXP 9
12994: PUSH
12995: LD_EXP 9
12999: PPUSH
13000: LD_INT 2
13002: PPUSH
13003: LD_INT 1
13005: PPUSH
13006: CALL_OW 1
13010: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13011: LD_INT 1
13013: PPUSH
13014: CALL 16433 0 1
13018: IFFALSE 13134
// begin DialogueOn ;
13020: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13024: LD_VAR 0 1
13028: PPUSH
13029: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13033: LD_INT 10
13035: PPUSH
13036: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_INT 1
13047: PPUSH
13048: LD_STRING D5b-Sol1-1
13050: PPUSH
13051: CALL 16611 0 2
13055: ST_TO_ADDR
// if not un then
13056: LD_VAR 0 3
13060: NOT
13061: IFFALSE 13079
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13063: LD_ADDR_VAR 0 3
13067: PUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_STRING D5b-FSol1-1
13073: PPUSH
13074: CALL 16611 0 2
13078: ST_TO_ADDR
// if un then
13079: LD_VAR 0 3
13083: IFFALSE 13128
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13085: LD_ADDR_VAR 0 4
13089: PUSH
13090: LD_INT 1
13092: PPUSH
13093: LD_STRING D5b-Sol2-1
13095: PPUSH
13096: LD_VAR 0 3
13100: PPUSH
13101: CALL 16837 0 3
13105: ST_TO_ADDR
// if not un2 then
13106: LD_VAR 0 4
13110: NOT
13111: IFFALSE 13128
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13113: LD_INT 2
13115: PPUSH
13116: LD_STRING D5b-FSol2-1
13118: PPUSH
13119: LD_VAR 0 3
13123: PPUSH
13124: CALL 16837 0 3
// end ; DialogueOff ;
13128: CALL_OW 7
// break ;
13132: GO 13136
// end ; end ;
13134: GO 12973
13136: POP
13137: POP
// end ; if not seen [ 3 ] then
13138: LD_EXP 9
13142: PUSH
13143: LD_INT 3
13145: ARRAY
13146: NOT
13147: IFFALSE 13321
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13149: LD_ADDR_VAR 0 2
13153: PUSH
13154: LD_INT 22
13156: PUSH
13157: LD_INT 2
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 33
13166: PUSH
13167: LD_INT 2
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: ST_TO_ADDR
// if tmp then
13183: LD_VAR 0 2
13187: IFFALSE 13321
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13319
// if See ( 1 , i ) then
13202: LD_INT 1
13204: PPUSH
13205: LD_VAR 0 1
13209: PPUSH
13210: CALL_OW 292
13214: IFFALSE 13317
// begin seen := Replace ( seen , 3 , true ) ;
13216: LD_ADDR_EXP 9
13220: PUSH
13221: LD_EXP 9
13225: PPUSH
13226: LD_INT 3
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: CALL_OW 1
13236: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13237: LD_INT 1
13239: PPUSH
13240: CALL 16433 0 1
13244: IFFALSE 13317
// begin DialogueOn ;
13246: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13250: LD_VAR 0 1
13254: PPUSH
13255: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13259: LD_INT 10
13261: PPUSH
13262: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13266: LD_ADDR_VAR 0 3
13270: PUSH
13271: LD_INT 1
13273: PPUSH
13274: LD_STRING D8-Sol1-1
13276: PPUSH
13277: CALL 16611 0 2
13281: ST_TO_ADDR
// if not un then
13282: LD_VAR 0 3
13286: NOT
13287: IFFALSE 13299
// SayRand ( sex_female , D8-FSol1-1 ) ;
13289: LD_INT 2
13291: PPUSH
13292: LD_STRING D8-FSol1-1
13294: PPUSH
13295: CALL 16611 0 2
// Say ( JMM , D8-JMM-1 ) ;
13299: LD_EXP 21
13303: PPUSH
13304: LD_STRING D8-JMM-1
13306: PPUSH
13307: CALL_OW 88
// DialogueOff ;
13311: CALL_OW 7
// break ;
13315: GO 13319
// end ; end ;
13317: GO 13199
13319: POP
13320: POP
// end ; if not seen [ 4 ] then
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 4
13328: ARRAY
13329: NOT
13330: IFFALSE 13492
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13332: LD_ADDR_VAR 0 2
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 33
13349: PUSH
13350: LD_INT 5
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: ST_TO_ADDR
// if tmp then
13366: LD_VAR 0 2
13370: IFFALSE 13492
// for i in tmp do
13372: LD_ADDR_VAR 0 1
13376: PUSH
13377: LD_VAR 0 2
13381: PUSH
13382: FOR_IN
13383: IFFALSE 13490
// if See ( 1 , i ) then
13385: LD_INT 1
13387: PPUSH
13388: LD_VAR 0 1
13392: PPUSH
13393: CALL_OW 292
13397: IFFALSE 13488
// begin seen := Replace ( seen , 4 , true ) ;
13399: LD_ADDR_EXP 9
13403: PUSH
13404: LD_EXP 9
13408: PPUSH
13409: LD_INT 4
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 1
13419: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13420: LD_INT 1
13422: PPUSH
13423: CALL 16433 0 1
13427: IFFALSE 13488
// begin DialogueOn ;
13429: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13433: LD_VAR 0 1
13437: PPUSH
13438: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13442: LD_INT 10
13444: PPUSH
13445: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: LD_INT 1
13456: PPUSH
13457: LD_STRING D5a-Sol1-1
13459: PPUSH
13460: CALL 16611 0 2
13464: ST_TO_ADDR
// if not un then
13465: LD_VAR 0 3
13469: NOT
13470: IFFALSE 13482
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13472: LD_INT 2
13474: PPUSH
13475: LD_STRING D5a-FSol1-1
13477: PPUSH
13478: CALL 16611 0 2
// DialogueOff ;
13482: CALL_OW 7
// break ;
13486: GO 13490
// end ; end ;
13488: GO 13382
13490: POP
13491: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13492: LD_EXP 9
13496: PUSH
13497: LD_INT 5
13499: ARRAY
13500: NOT
13501: PUSH
13502: LD_EXP 9
13506: PUSH
13507: LD_INT 3
13509: ARRAY
13510: AND
13511: IFFALSE 13685
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13513: LD_ADDR_VAR 0 2
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 2
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 34
13530: PUSH
13531: LD_INT 31
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 69
13546: ST_TO_ADDR
// if tmp then
13547: LD_VAR 0 2
13551: IFFALSE 13685
// for i in tmp do
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_VAR 0 2
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13683
// if See ( 1 , i ) then
13566: LD_INT 1
13568: PPUSH
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 292
13578: IFFALSE 13681
// begin seen := Replace ( seen , 5 , true ) ;
13580: LD_ADDR_EXP 9
13584: PUSH
13585: LD_EXP 9
13589: PPUSH
13590: LD_INT 5
13592: PPUSH
13593: LD_INT 1
13595: PPUSH
13596: CALL_OW 1
13600: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13601: LD_INT 1
13603: PPUSH
13604: CALL 16433 0 1
13608: IFFALSE 13681
// begin DialogueOn ;
13610: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13614: LD_VAR 0 1
13618: PPUSH
13619: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13623: LD_INT 10
13625: PPUSH
13626: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: LD_INT 1
13637: PPUSH
13638: LD_STRING D8a-Sol2-1
13640: PPUSH
13641: CALL 16611 0 2
13645: ST_TO_ADDR
// if not un then
13646: LD_VAR 0 3
13650: NOT
13651: IFFALSE 13663
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13653: LD_INT 2
13655: PPUSH
13656: LD_STRING D8a-FSol2-1
13658: PPUSH
13659: CALL 16611 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D8a-JMM-1
13670: PPUSH
13671: CALL_OW 88
// DialogueOff ;
13675: CALL_OW 7
// break ;
13679: GO 13683
// end ; end ;
13681: GO 13563
13683: POP
13684: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13685: LD_EXP 9
13689: PUSH
13690: LD_INT 1
13692: ARRAY
13693: PUSH
13694: LD_EXP 9
13698: PUSH
13699: LD_INT 2
13701: ARRAY
13702: AND
13703: PUSH
13704: LD_EXP 9
13708: PUSH
13709: LD_INT 3
13711: ARRAY
13712: AND
13713: PUSH
13714: LD_EXP 9
13718: PUSH
13719: LD_INT 4
13721: ARRAY
13722: AND
13723: PUSH
13724: LD_EXP 9
13728: PUSH
13729: LD_INT 5
13731: ARRAY
13732: AND
13733: IFFALSE 13736
// disable ;
13735: DISABLE
// end ;
13736: PPOPN 4
13738: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13739: LD_EXP 10
13743: PUSH
13744: LD_EXP 11
13748: AND
13749: IFFALSE 13947
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin DialogueOn ;
13757: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13761: LD_EXP 11
13765: PPUSH
13766: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_INT 1
13777: PPUSH
13778: LD_STRING D5c-Sol1-1
13780: PPUSH
13781: CALL 16611 0 2
13785: ST_TO_ADDR
// if not un then
13786: LD_VAR 0 1
13790: NOT
13791: IFFALSE 13809
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13793: LD_ADDR_VAR 0 1
13797: PUSH
13798: LD_INT 2
13800: PPUSH
13801: LD_STRING D5c-FSol1-1
13803: PPUSH
13804: CALL 16611 0 2
13808: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13809: LD_EXP 21
13813: PPUSH
13814: LD_STRING D5c-JMM-1
13816: PPUSH
13817: CALL_OW 88
// if IsOk ( Lisa ) then
13821: LD_EXP 22
13825: PPUSH
13826: CALL_OW 302
13830: IFFALSE 13846
// Say ( Lisa , D5d-Lisa-1 ) else
13832: LD_EXP 22
13836: PPUSH
13837: LD_STRING D5d-Lisa-1
13839: PPUSH
13840: CALL_OW 88
13844: GO 13931
// if IsOk ( Cyrus ) then
13846: LD_EXP 25
13850: PPUSH
13851: CALL_OW 302
13855: IFFALSE 13871
// Say ( Cyrus , D5d-Cyrus-1 ) else
13857: LD_EXP 25
13861: PPUSH
13862: LD_STRING D5d-Cyrus-1
13864: PPUSH
13865: CALL_OW 88
13869: GO 13931
// if IsOk ( Gary ) then
13871: LD_EXP 32
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Gary , D5d-Gary-1 ) else
13882: LD_EXP 32
13886: PPUSH
13887: LD_STRING D5d-Gary-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13931
// if GetSex ( un ) = sex_male then
13896: LD_VAR 0 1
13900: PPUSH
13901: CALL_OW 258
13905: PUSH
13906: LD_INT 1
13908: EQUAL
13909: IFFALSE 13925
// Say ( un , D5d-Sol1-1 ) else
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_STRING D5d-Sol1-1
13918: PPUSH
13919: CALL_OW 88
13923: GO 13931
// begin DialogueOff ;
13925: CALL_OW 7
// exit ;
13929: GO 13947
// end ; Say ( JMM , D5d-JMM-1 ) ;
13931: LD_EXP 21
13935: PPUSH
13936: LD_STRING D5d-JMM-1
13938: PPUSH
13939: CALL_OW 88
// DialogueOff ;
13943: CALL_OW 7
// end ;
13947: PPOPN 1
13949: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13950: LD_INT 1
13952: PPUSH
13953: LD_INT 17
13955: PPUSH
13956: CALL_OW 294
13960: PUSH
13961: LD_INT 2
13963: GREATEREQUAL
13964: IFFALSE 14096
13966: GO 13968
13968: DISABLE
13969: LD_INT 0
13971: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13972: LD_INT 10
13974: PPUSH
13975: LD_INT 5
13977: PPUSH
13978: LD_INT 1
13980: PPUSH
13981: LD_INT 10
13983: NEG
13984: PPUSH
13985: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13989: LD_INT 10
13991: PPUSH
13992: LD_INT 5
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14002: LD_INT 10
14004: PPUSH
14005: LD_INT 5
14007: PPUSH
14008: CALL_OW 86
// DialogueOn ;
14012: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14016: LD_ADDR_VAR 0 1
14020: PUSH
14021: LD_INT 1
14023: PPUSH
14024: LD_STRING D6-Sci1-1
14026: PPUSH
14027: CALL 16611 0 2
14031: ST_TO_ADDR
// if un then
14032: LD_VAR 0 1
14036: IFFALSE 14074
// begin Say ( JMM , D6-JMM-1 ) ;
14038: LD_EXP 21
14042: PPUSH
14043: LD_STRING D6-JMM-1
14045: PPUSH
14046: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14050: LD_VAR 0 1
14054: PPUSH
14055: LD_STRING D6-Sci1-2
14057: PPUSH
14058: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14062: LD_EXP 21
14066: PPUSH
14067: LD_STRING D6-JMM-2
14069: PPUSH
14070: CALL_OW 88
// end ; DialogueOff ;
14074: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14078: LD_STRING M3
14080: PPUSH
14081: CALL_OW 337
// wait ( 0 0$30 ) ;
14085: LD_INT 1050
14087: PPUSH
14088: CALL_OW 67
// AmericanReinforcements ;
14092: CALL 2319 0 0
// end ;
14096: PPOPN 1
14098: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14099: LD_OWVAR 1
14103: PUSH
14104: LD_INT 42000
14106: GREATEREQUAL
14107: PUSH
14108: LD_INT 2
14110: PPUSH
14111: LD_INT 169
14113: PPUSH
14114: LD_INT 90
14116: PPUSH
14117: LD_INT 10
14119: PPUSH
14120: CALL 53950 0 4
14124: PUSH
14125: LD_INT 4
14127: ARRAY
14128: PUSH
14129: LD_INT 0
14131: EQUAL
14132: PUSH
14133: LD_INT 45
14135: PPUSH
14136: CALL_OW 301
14140: OR
14141: PUSH
14142: LD_INT 45
14144: PPUSH
14145: CALL_OW 255
14149: PUSH
14150: LD_INT 1
14152: EQUAL
14153: OR
14154: AND
14155: PUSH
14156: LD_INT 94
14158: PPUSH
14159: CALL_OW 301
14163: NOT
14164: AND
14165: IFFALSE 15370
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// begin uc_side := 5 ;
14177: LD_ADDR_OWVAR 20
14181: PUSH
14182: LD_INT 5
14184: ST_TO_ADDR
// uc_nation := 2 ;
14185: LD_ADDR_OWVAR 21
14189: PUSH
14190: LD_INT 2
14192: ST_TO_ADDR
// InitHc ;
14193: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_INT 8
14205: PPUSH
14206: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14210: LD_ADDR_OWVAR 29
14214: PUSH
14215: LD_INT 12
14217: PUSH
14218: LD_INT 12
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: ST_TO_ADDR
// hc_name := Hans Fliege ;
14225: LD_ADDR_OWVAR 26
14229: PUSH
14230: LD_STRING Hans Fliege
14232: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14233: LD_ADDR_OWVAR 33
14237: PUSH
14238: LD_STRING SecondCharsGal
14240: ST_TO_ADDR
// hc_face_number := 7 ;
14241: LD_ADDR_OWVAR 34
14245: PUSH
14246: LD_INT 7
14248: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14249: LD_ADDR_EXP 46
14253: PUSH
14254: CALL_OW 44
14258: ST_TO_ADDR
// InitHc ;
14259: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14263: LD_INT 1
14265: PPUSH
14266: LD_INT 16
14268: PPUSH
14269: LD_INT 2
14271: PPUSH
14272: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14276: LD_ADDR_OWVAR 29
14280: PUSH
14281: LD_INT 12
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: ST_TO_ADDR
// hc_name :=  ;
14291: LD_ADDR_OWVAR 26
14295: PUSH
14296: LD_STRING 
14298: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14299: LD_ADDR_EXP 47
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14313: LD_INT 35
14315: PPUSH
14316: CALL_OW 67
// until not InBattle ( 1 ) ;
14320: LD_INT 1
14322: PPUSH
14323: CALL_OW 463
14327: NOT
14328: IFFALSE 14313
// wait ( 0 0$5 ) ;
14330: LD_INT 175
14332: PPUSH
14333: CALL_OW 67
// DialogueOn ;
14337: CALL_OW 6
// InGameOn ;
14341: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14345: LD_ADDR_VAR 0 1
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_INT 1
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 2
14362: PUSH
14363: LD_INT 25
14365: PUSH
14366: LD_INT 1
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 25
14375: PUSH
14376: LD_INT 2
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 3
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 25
14395: PUSH
14396: LD_INT 4
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 25
14405: PUSH
14406: LD_INT 5
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 8
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PPUSH
14436: CALL_OW 69
14440: PUSH
14441: LD_EXP 21
14445: PUSH
14446: LD_EXP 22
14450: PUSH
14451: LD_EXP 23
14455: PUSH
14456: LD_EXP 24
14460: PUSH
14461: LD_EXP 25
14465: PUSH
14466: LD_EXP 26
14470: PUSH
14471: LD_EXP 27
14475: PUSH
14476: LD_EXP 28
14480: PUSH
14481: LD_EXP 29
14485: PUSH
14486: LD_EXP 31
14490: PUSH
14491: LD_EXP 32
14495: PUSH
14496: LD_EXP 33
14500: PUSH
14501: LD_EXP 34
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: DIFF
14521: PPUSH
14522: LD_INT 26
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PPUSH
14532: CALL_OW 72
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: ST_TO_ADDR
// if Brown then
14541: LD_EXP 27
14545: IFFALSE 14557
// un := Brown ;
14547: LD_ADDR_VAR 0 1
14551: PUSH
14552: LD_EXP 27
14556: ST_TO_ADDR
// if un then
14557: LD_VAR 0 1
14561: IFFALSE 14587
// begin Say ( un , D7-Sol1-1 ) ;
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_STRING D7-Sol1-1
14570: PPUSH
14571: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14575: LD_EXP 21
14579: PPUSH
14580: LD_STRING D7-JMM-1
14582: PPUSH
14583: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14587: LD_EXP 46
14591: PPUSH
14592: LD_STRING D7-Ar1-1
14594: PPUSH
14595: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14599: LD_EXP 21
14603: PPUSH
14604: LD_STRING D7-JMM-2
14606: PPUSH
14607: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14611: LD_EXP 46
14615: PPUSH
14616: LD_STRING D7-Ar1-2
14618: PPUSH
14619: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14623: LD_EXP 21
14627: PPUSH
14628: LD_STRING D7-JMM-3
14630: PPUSH
14631: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14635: LD_EXP 46
14639: PPUSH
14640: LD_STRING D7-Ar1-3
14642: PPUSH
14643: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING D7-JMM-4
14654: PPUSH
14655: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14659: LD_EXP 46
14663: PPUSH
14664: LD_STRING D7-Ar1-4
14666: PPUSH
14667: CALL_OW 94
// InGameOff ;
14671: CALL_OW 9
// DialogueOff ;
14675: CALL_OW 7
// case Query ( QCameras ) of 1 :
14679: LD_STRING QCameras
14681: PPUSH
14682: CALL_OW 97
14686: PUSH
14687: LD_INT 1
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14698
14695: POP
// ; 2 :
14696: GO 14712
14698: LD_INT 2
14700: DOUBLE
14701: EQUAL
14702: IFTRUE 14706
14704: GO 14711
14706: POP
// exit ; end ;
14707: GO 15370
14709: GO 14712
14711: POP
// ChangeMissionObjectives ( MCar ) ;
14712: LD_STRING MCar
14714: PPUSH
14715: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14719: LD_INT 124
14721: PPUSH
14722: LD_INT 90
14724: PPUSH
14725: LD_INT 1
14727: PPUSH
14728: LD_INT 6
14730: NEG
14731: PPUSH
14732: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14736: LD_INT 124
14738: PPUSH
14739: LD_INT 90
14741: PPUSH
14742: LD_INT 1
14744: PPUSH
14745: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14749: LD_INT 12
14751: PPUSH
14752: LD_INT 1
14754: PPUSH
14755: CALL_OW 424
// wait ( 3 ) ;
14759: LD_INT 3
14761: PPUSH
14762: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14766: LD_INT 124
14768: PPUSH
14769: LD_INT 90
14771: PPUSH
14772: CALL_OW 86
// cargo := false ;
14776: LD_ADDR_VAR 0 3
14780: PUSH
14781: LD_INT 0
14783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14784: LD_INT 35
14786: PPUSH
14787: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: LD_INT 12
14798: PPUSH
14799: LD_INT 32
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 34
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 58
14821: PUSH
14822: EMPTY
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 70
14834: ST_TO_ADDR
// until cargo ;
14835: LD_VAR 0 3
14839: IFFALSE 14784
// cargo := cargo [ 1 ] ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_INT 1
14853: ARRAY
14854: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14855: LD_VAR 0 3
14859: PPUSH
14860: LD_INT 5
14862: PPUSH
14863: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14867: LD_INT 12
14869: PPUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14877: LD_EXP 46
14881: PPUSH
14882: LD_INT 11
14884: PPUSH
14885: LD_INT 0
14887: PPUSH
14888: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14892: LD_EXP 47
14896: PPUSH
14897: LD_INT 11
14899: PPUSH
14900: LD_INT 0
14902: PPUSH
14903: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14907: LD_EXP 46
14911: PUSH
14912: LD_EXP 47
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PPUSH
14921: LD_INT 12
14923: PPUSH
14924: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14928: LD_EXP 46
14932: PPUSH
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14942: LD_EXP 46
14946: PUSH
14947: LD_EXP 47
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: LD_INT 209
14958: PPUSH
14959: LD_INT 178
14961: PPUSH
14962: CALL_OW 171
// escaped := 0 ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_INT 0
14973: ST_TO_ADDR
// while ( true ) do
14974: LD_INT 1
14976: IFFALSE 15192
// begin wait ( 0 0$1 ) ;
14978: LD_INT 35
14980: PPUSH
14981: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14985: LD_EXP 46
14989: PPUSH
14990: CALL_OW 314
14994: NOT
14995: PUSH
14996: LD_EXP 47
15000: PPUSH
15001: CALL_OW 314
15005: NOT
15006: OR
15007: IFFALSE 15033
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15009: LD_EXP 46
15013: PUSH
15014: LD_EXP 47
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PPUSH
15023: LD_INT 209
15025: PPUSH
15026: LD_INT 178
15028: PPUSH
15029: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15033: LD_EXP 46
15037: PPUSH
15038: LD_INT 10
15040: PPUSH
15041: CALL_OW 308
15045: IFFALSE 15070
// begin RemoveUnit ( ar_mechanic ) ;
15047: LD_EXP 46
15051: PPUSH
15052: CALL_OW 64
// escaped := escaped + 1 ;
15056: LD_ADDR_VAR 0 5
15060: PUSH
15061: LD_VAR 0 5
15065: PUSH
15066: LD_INT 1
15068: PLUS
15069: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15070: LD_EXP 47
15074: PPUSH
15075: LD_INT 10
15077: PPUSH
15078: CALL_OW 308
15082: IFFALSE 15107
// begin RemoveUnit ( ar_mechanic_friend ) ;
15084: LD_EXP 47
15088: PPUSH
15089: CALL_OW 64
// escaped := escaped + 1 ;
15093: LD_ADDR_VAR 0 5
15097: PUSH
15098: LD_VAR 0 5
15102: PUSH
15103: LD_INT 1
15105: PLUS
15106: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15107: LD_VAR 0 3
15111: PPUSH
15112: LD_INT 10
15114: PPUSH
15115: CALL_OW 308
15119: IFFALSE 15130
// RemoveUnit ( cargo ) ;
15121: LD_VAR 0 3
15125: PPUSH
15126: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15130: LD_EXP 46
15134: PPUSH
15135: CALL_OW 305
15139: NOT
15140: PUSH
15141: LD_VAR 0 5
15145: PUSH
15146: LD_INT 2
15148: GREATEREQUAL
15149: AND
15150: IFFALSE 15154
// break ;
15152: GO 15192
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15154: LD_EXP 46
15158: PPUSH
15159: CALL_OW 305
15163: NOT
15164: PUSH
15165: LD_EXP 47
15169: PPUSH
15170: CALL_OW 305
15174: NOT
15175: AND
15176: PUSH
15177: LD_VAR 0 5
15181: PUSH
15182: LD_INT 2
15184: LESS
15185: AND
15186: IFFALSE 15190
// exit ;
15188: GO 15370
// end ;
15190: GO 14974
// wait ( 0 0$2 ) ;
15192: LD_INT 70
15194: PPUSH
15195: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15199: LD_EXP 46
15203: PPUSH
15204: LD_STRING D7a-Ar1-1
15206: PPUSH
15207: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 129
15218: PUSH
15219: LD_INT 10
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 103
15228: PUSH
15229: LD_INT 6
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: LD_INT 148
15238: PUSH
15239: LD_INT 47
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 155
15248: PUSH
15249: LD_INT 16
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: ST_TO_ADDR
// if Difficulty = 1 then
15262: LD_OWVAR 67
15266: PUSH
15267: LD_INT 1
15269: EQUAL
15270: IFFALSE 15307
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_VAR 0 4
15281: PUSH
15282: LD_INT 78
15284: PUSH
15285: LD_INT 7
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 104
15294: PUSH
15295: LD_INT 43
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: ADD
15306: ST_TO_ADDR
// for i in tmp do
15307: LD_ADDR_VAR 0 2
15311: PUSH
15312: LD_VAR 0 4
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15351
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15320: LD_VAR 0 2
15324: PUSH
15325: LD_INT 1
15327: ARRAY
15328: PPUSH
15329: LD_VAR 0 2
15333: PUSH
15334: LD_INT 2
15336: ARRAY
15337: PPUSH
15338: LD_INT 1
15340: PPUSH
15341: LD_INT 9
15343: NEG
15344: PPUSH
15345: CALL_OW 330
15349: GO 15317
15351: POP
15352: POP
// SetAchievement ( ACH_FRIEND ) ;
15353: LD_STRING ACH_FRIEND
15355: PPUSH
15356: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15360: LD_INT 129
15362: PPUSH
15363: LD_INT 10
15365: PPUSH
15366: CALL_OW 84
// end ;
15370: PPOPN 5
15372: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15373: LD_EXP 15
15377: PUSH
15378: LD_INT 21000
15380: MINUS
15381: PUSH
15382: LD_OWVAR 1
15386: LESSEQUAL
15387: IFFALSE 15427
15389: GO 15391
15391: DISABLE
// begin powell_warn := true ;
15392: LD_ADDR_EXP 16
15396: PUSH
15397: LD_INT 1
15399: ST_TO_ADDR
// DialogueOn ;
15400: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15404: LD_EXP 30
15408: PPUSH
15409: LD_STRING D9-Pow-1
15411: PPUSH
15412: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 68
// DialogueOff ;
15423: CALL_OW 7
// end ;
15427: END
// every 0 0$1 trigger game_time <= tick do
15428: LD_EXP 15
15432: PUSH
15433: LD_OWVAR 1
15437: LESSEQUAL
15438: IFFALSE 15477
15440: GO 15442
15442: DISABLE
// begin DialogueOn ;
15443: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15447: LD_EXP 30
15451: PPUSH
15452: LD_STRING D9a-Pow-1
15454: PPUSH
15455: CALL_OW 94
// dwait ( 0 0$2 ) ;
15459: LD_INT 70
15461: PPUSH
15462: CALL_OW 68
// DialogueOff ;
15466: CALL_OW 7
// YouLost ( Command ) ;
15470: LD_STRING Command
15472: PPUSH
15473: CALL_OW 104
// end ;
15477: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15478: LD_INT 22
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 30
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PPUSH
15502: CALL_OW 69
15506: PUSH
15507: LD_INT 0
15509: EQUAL
15510: PUSH
15511: LD_EXP 21
15515: PPUSH
15516: CALL_OW 302
15520: AND
15521: IFFALSE 16430
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
15531: PPUSH
// begin m1 := false ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 0
15539: ST_TO_ADDR
// m2 := false ;
15540: LD_ADDR_VAR 0 3
15544: PUSH
15545: LD_INT 0
15547: ST_TO_ADDR
// m3 := false ;
15548: LD_ADDR_VAR 0 4
15552: PUSH
15553: LD_INT 0
15555: ST_TO_ADDR
// if not am_veh_consturcted then
15556: LD_EXP 20
15560: NOT
15561: IFFALSE 15570
// SetAchievement ( ACH_ARABTECH ) ;
15563: LD_STRING ACH_ARABTECH
15565: PPUSH
15566: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15570: LD_OWVAR 1
15574: PUSH
15575: LD_INT 252000
15577: PUSH
15578: LD_INT 210000
15580: PUSH
15581: LD_INT 199500
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: LIST
15588: PUSH
15589: LD_OWVAR 67
15593: ARRAY
15594: LESS
15595: IFFALSE 15617
// begin m3 := true ;
15597: LD_ADDR_VAR 0 4
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15605: LD_STRING Time1
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: CALL_OW 101
// end else
15615: GO 15648
// if not powell_warn then
15617: LD_EXP 16
15621: NOT
15622: IFFALSE 15637
// AddMedal ( Time1 , - 1 ) else
15624: LD_STRING Time1
15626: PPUSH
15627: LD_INT 1
15629: NEG
15630: PPUSH
15631: CALL_OW 101
15635: GO 15648
// AddMedal ( Time1 , - 2 ) ;
15637: LD_STRING Time1
15639: PPUSH
15640: LD_INT 2
15642: NEG
15643: PPUSH
15644: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15648: LD_EXP 17
15652: PUSH
15653: LD_INT 5
15655: PUSH
15656: LD_INT 4
15658: PUSH
15659: LD_INT 3
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: LIST
15666: PUSH
15667: LD_OWVAR 67
15671: ARRAY
15672: GREATEREQUAL
15673: IFFALSE 15688
// AddMedal ( Destroy , - 2 ) else
15675: LD_STRING Destroy
15677: PPUSH
15678: LD_INT 2
15680: NEG
15681: PPUSH
15682: CALL_OW 101
15686: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15688: LD_INT 22
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 21
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 50
15710: PUSH
15711: EMPTY
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_INT 25
15726: GREATEREQUAL
15727: IFFALSE 15742
// AddMedal ( Destroy , - 1 ) else
15729: LD_STRING Destroy
15731: PPUSH
15732: LD_INT 1
15734: NEG
15735: PPUSH
15736: CALL_OW 101
15740: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15742: LD_INT 22
15744: PUSH
15745: LD_INT 2
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 21
15754: PUSH
15755: LD_INT 3
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 50
15764: PUSH
15765: EMPTY
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: PUSH
15778: LD_INT 15
15780: GREATEREQUAL
15781: IFFALSE 15803
// begin m1 := true ;
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15791: LD_STRING Destroy
15793: PPUSH
15794: LD_INT 1
15796: PPUSH
15797: CALL_OW 101
// end else
15801: GO 15821
// begin m1 := true ;
15803: LD_ADDR_VAR 0 2
15807: PUSH
15808: LD_INT 1
15810: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15811: LD_STRING Destroy
15813: PPUSH
15814: LD_INT 2
15816: PPUSH
15817: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15821: LD_EXP 13
15825: PPUSH
15826: LD_STRING 11_artifact_captured
15828: PPUSH
15829: CALL_OW 39
// if artifact_get then
15833: LD_EXP 13
15837: IFFALSE 15859
// begin m2 := true ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 1
15846: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15847: LD_STRING Artefact
15849: PPUSH
15850: LD_INT 1
15852: PPUSH
15853: CALL_OW 101
// end else
15857: GO 15870
// AddMedal ( Artefact , - 1 ) ;
15859: LD_STRING Artefact
15861: PPUSH
15862: LD_INT 1
15864: NEG
15865: PPUSH
15866: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15870: LD_VAR 0 2
15874: PUSH
15875: LD_VAR 0 3
15879: AND
15880: PUSH
15881: LD_VAR 0 4
15885: AND
15886: PUSH
15887: LD_OWVAR 67
15891: PUSH
15892: LD_INT 3
15894: EQUAL
15895: AND
15896: IFFALSE 15908
// SetAchievementEX ( ACH_AMER , 11 ) ;
15898: LD_STRING ACH_AMER
15900: PPUSH
15901: LD_INT 11
15903: PPUSH
15904: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15908: LD_VAR 0 2
15912: PUSH
15913: LD_VAR 0 3
15917: AND
15918: PUSH
15919: LD_VAR 0 4
15923: AND
15924: PUSH
15925: LD_EXP 17
15929: PUSH
15930: LD_INT 0
15932: EQUAL
15933: AND
15934: IFFALSE 15950
// begin wait ( 3 ) ;
15936: LD_INT 3
15938: PPUSH
15939: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15943: LD_STRING ACH_GENERAL
15945: PPUSH
15946: CALL_OW 543
// end ; if tick <= 100 100$00 then
15950: LD_OWVAR 1
15954: PUSH
15955: LD_INT 210000
15957: LESSEQUAL
15958: IFFALSE 15974
// begin wait ( 3 ) ;
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15967: LD_STRING ACH_ASPEED_11
15969: PPUSH
15970: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15974: LD_STRING MAIN
15976: PPUSH
15977: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15981: LD_ADDR_EXP 19
15985: PUSH
15986: LD_EXP 19
15990: PPUSH
15991: LD_INT 51
15993: PUSH
15994: EMPTY
15995: LIST
15996: PPUSH
15997: CALL_OW 72
16001: ST_TO_ADDR
// tmp := JMM ^ selected ;
16002: LD_ADDR_VAR 0 1
16006: PUSH
16007: LD_EXP 21
16011: PUSH
16012: LD_EXP 19
16016: ADD
16017: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16027: LD_VAR 0 1
16031: PUSH
16032: LD_EXP 21
16036: PUSH
16037: LD_EXP 22
16041: PUSH
16042: LD_EXP 23
16046: PUSH
16047: LD_EXP 24
16051: PUSH
16052: LD_EXP 25
16056: PUSH
16057: LD_EXP 26
16061: PUSH
16062: LD_EXP 27
16066: PUSH
16067: LD_EXP 28
16071: PUSH
16072: LD_EXP 29
16076: PUSH
16077: LD_EXP 31
16081: PUSH
16082: LD_EXP 32
16086: PUSH
16087: LD_EXP 33
16091: PUSH
16092: LD_EXP 34
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: LIST
16101: LIST
16102: LIST
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: LIST
16110: LIST
16111: DIFF
16112: PPUSH
16113: LD_STRING 11c_others
16115: PPUSH
16116: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16120: LD_EXP 21
16124: PPUSH
16125: LD_EXP 3
16129: PUSH
16130: LD_STRING JMM
16132: STR
16133: PPUSH
16134: CALL_OW 38
// if Lisa then
16138: LD_EXP 22
16142: IFFALSE 16162
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16144: LD_EXP 22
16148: PPUSH
16149: LD_EXP 3
16153: PUSH
16154: LD_STRING Lisa
16156: STR
16157: PPUSH
16158: CALL_OW 38
// if Donaldson then
16162: LD_EXP 23
16166: IFFALSE 16186
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16168: LD_EXP 23
16172: PPUSH
16173: LD_EXP 3
16177: PUSH
16178: LD_STRING Donaldson
16180: STR
16181: PPUSH
16182: CALL_OW 38
// if Bobby then
16186: LD_EXP 24
16190: IFFALSE 16210
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16192: LD_EXP 24
16196: PPUSH
16197: LD_EXP 3
16201: PUSH
16202: LD_STRING Bobby
16204: STR
16205: PPUSH
16206: CALL_OW 38
// if Cyrus then
16210: LD_EXP 25
16214: IFFALSE 16234
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16216: LD_EXP 25
16220: PPUSH
16221: LD_EXP 3
16225: PUSH
16226: LD_STRING Cyrus
16228: STR
16229: PPUSH
16230: CALL_OW 38
// if Denis then
16234: LD_EXP 26
16238: IFFALSE 16258
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16240: LD_EXP 26
16244: PPUSH
16245: LD_EXP 3
16249: PUSH
16250: LD_STRING Denis
16252: STR
16253: PPUSH
16254: CALL_OW 38
// if Brown then
16258: LD_EXP 27
16262: IFFALSE 16282
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16264: LD_EXP 27
16268: PPUSH
16269: LD_EXP 3
16273: PUSH
16274: LD_STRING Brown
16276: STR
16277: PPUSH
16278: CALL_OW 38
// if Gladstone then
16282: LD_EXP 28
16286: IFFALSE 16306
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16288: LD_EXP 28
16292: PPUSH
16293: LD_EXP 3
16297: PUSH
16298: LD_STRING Gladstone
16300: STR
16301: PPUSH
16302: CALL_OW 38
// if Houten then
16306: LD_EXP 29
16310: IFFALSE 16330
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16312: LD_EXP 29
16316: PPUSH
16317: LD_EXP 3
16321: PUSH
16322: LD_STRING Houten
16324: STR
16325: PPUSH
16326: CALL_OW 38
// if Cornel then
16330: LD_EXP 31
16334: IFFALSE 16354
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16336: LD_EXP 31
16340: PPUSH
16341: LD_EXP 3
16345: PUSH
16346: LD_STRING Cornell
16348: STR
16349: PPUSH
16350: CALL_OW 38
// if Gary then
16354: LD_EXP 32
16358: IFFALSE 16378
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16360: LD_EXP 32
16364: PPUSH
16365: LD_EXP 3
16369: PUSH
16370: LD_STRING Gary
16372: STR
16373: PPUSH
16374: CALL_OW 38
// if Frank then
16378: LD_EXP 33
16382: IFFALSE 16402
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16384: LD_EXP 33
16388: PPUSH
16389: LD_EXP 3
16393: PUSH
16394: LD_STRING Frank
16396: STR
16397: PPUSH
16398: CALL_OW 38
// if Kikuchi then
16402: LD_EXP 34
16406: IFFALSE 16426
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16408: LD_EXP 34
16412: PPUSH
16413: LD_EXP 3
16417: PUSH
16418: LD_STRING Kikuchi
16420: STR
16421: PPUSH
16422: CALL_OW 38
// YouWin ;
16426: CALL_OW 103
// end ;
16430: PPOPN 4
16432: END
// export function CanSayRand ( side ) ; begin
16433: LD_INT 0
16435: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16436: LD_ADDR_VAR 0 2
16440: PUSH
16441: LD_INT 52
16443: PUSH
16444: EMPTY
16445: LIST
16446: PUSH
16447: LD_INT 22
16449: PUSH
16450: LD_VAR 0 1
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: LD_INT 2
16461: PUSH
16462: LD_INT 25
16464: PUSH
16465: LD_INT 1
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 25
16474: PUSH
16475: LD_INT 2
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 25
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 25
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: LIST
16513: PPUSH
16514: CALL_OW 69
16518: PUSH
16519: LD_EXP 21
16523: PUSH
16524: LD_EXP 33
16528: PUSH
16529: LD_EXP 22
16533: PUSH
16534: LD_EXP 23
16538: PUSH
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 25
16548: PUSH
16549: LD_EXP 26
16553: PUSH
16554: LD_EXP 27
16558: PUSH
16559: LD_EXP 28
16563: PUSH
16564: LD_EXP 29
16568: PUSH
16569: LD_EXP 30
16573: PUSH
16574: LD_EXP 31
16578: PUSH
16579: LD_EXP 32
16583: PUSH
16584: LD_EXP 34
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: LIST
16599: LIST
16600: LIST
16601: LIST
16602: LIST
16603: LIST
16604: DIFF
16605: ST_TO_ADDR
// end ;
16606: LD_VAR 0 2
16610: RET
// export function SayRand ( sex , dial ) ; begin
16611: LD_INT 0
16613: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16614: LD_ADDR_VAR 0 3
16618: PUSH
16619: LD_INT 52
16621: PUSH
16622: EMPTY
16623: LIST
16624: PUSH
16625: LD_INT 22
16627: PUSH
16628: LD_INT 1
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PUSH
16635: LD_INT 26
16637: PUSH
16638: LD_VAR 0 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 2
16649: PUSH
16650: LD_INT 25
16652: PUSH
16653: LD_INT 1
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: PUSH
16660: LD_INT 25
16662: PUSH
16663: LD_INT 2
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 25
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 25
16682: PUSH
16683: LD_INT 4
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: PUSH
16708: LD_EXP 21
16712: PUSH
16713: LD_EXP 33
16717: PUSH
16718: LD_EXP 22
16722: PUSH
16723: LD_EXP 23
16727: PUSH
16728: LD_EXP 24
16732: PUSH
16733: LD_EXP 25
16737: PUSH
16738: LD_EXP 26
16742: PUSH
16743: LD_EXP 27
16747: PUSH
16748: LD_EXP 28
16752: PUSH
16753: LD_EXP 29
16757: PUSH
16758: LD_EXP 30
16762: PUSH
16763: LD_EXP 31
16767: PUSH
16768: LD_EXP 32
16772: PUSH
16773: LD_EXP 34
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: DIFF
16794: ST_TO_ADDR
// if not result then
16795: LD_VAR 0 3
16799: NOT
16800: IFFALSE 16804
// exit ;
16802: GO 16832
// result := result [ 1 ] ;
16804: LD_ADDR_VAR 0 3
16808: PUSH
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 1
16816: ARRAY
16817: ST_TO_ADDR
// Say ( result , dial ) ;
16818: LD_VAR 0 3
16822: PPUSH
16823: LD_VAR 0 2
16827: PPUSH
16828: CALL_OW 88
// end ;
16832: LD_VAR 0 3
16836: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16837: LD_INT 0
16839: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16840: LD_ADDR_VAR 0 4
16844: PUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 26
16857: PUSH
16858: LD_VAR 0 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 2
16869: PUSH
16870: LD_INT 25
16872: PUSH
16873: LD_INT 1
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 25
16882: PUSH
16883: LD_INT 2
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 25
16892: PUSH
16893: LD_INT 3
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 25
16902: PUSH
16903: LD_INT 4
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PUSH
16927: LD_EXP 21
16931: PUSH
16932: LD_EXP 33
16936: PUSH
16937: LD_EXP 22
16941: PUSH
16942: LD_EXP 23
16946: PUSH
16947: LD_EXP 24
16951: PUSH
16952: LD_EXP 25
16956: PUSH
16957: LD_EXP 26
16961: PUSH
16962: LD_EXP 27
16966: PUSH
16967: LD_EXP 28
16971: PUSH
16972: LD_EXP 29
16976: PUSH
16977: LD_EXP 30
16981: PUSH
16982: LD_EXP 31
16986: PUSH
16987: LD_EXP 32
16991: PUSH
16992: LD_EXP 34
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: PUSH
17013: LD_VAR 0 3
17017: ADD
17018: DIFF
17019: ST_TO_ADDR
// if not result then
17020: LD_VAR 0 4
17024: NOT
17025: IFFALSE 17029
// exit ;
17027: GO 17057
// result := result [ 1 ] ;
17029: LD_ADDR_VAR 0 4
17033: PUSH
17034: LD_VAR 0 4
17038: PUSH
17039: LD_INT 1
17041: ARRAY
17042: ST_TO_ADDR
// Say ( result , dial ) ;
17043: LD_VAR 0 4
17047: PPUSH
17048: LD_VAR 0 2
17052: PPUSH
17053: CALL_OW 88
// end ; end_of_file
17057: LD_VAR 0 4
17061: RET
// export function CustomEvent ( event ) ; begin
17062: LD_INT 0
17064: PPUSH
// end ;
17065: LD_VAR 0 2
17069: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17070: LD_VAR 0 1
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 1
17082: EQUAL
17083: IFFALSE 17093
// artifact_get := true ;
17085: LD_ADDR_EXP 13
17089: PUSH
17090: LD_INT 1
17092: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL_OW 255
17102: PUSH
17103: LD_INT 2
17105: EQUAL
17106: IFFALSE 17124
// begin artifact_get := false ;
17108: LD_ADDR_EXP 13
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// artifact_stolen := true ;
17116: LD_ADDR_EXP 12
17120: PUSH
17121: LD_INT 1
17123: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17124: LD_ADDR_EXP 14
17128: PUSH
17129: LD_INT 1
17131: ST_TO_ADDR
// end ;
17132: PPOPN 2
17134: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17135: LD_ADDR_EXP 14
17139: PUSH
17140: LD_INT 0
17142: ST_TO_ADDR
// end ;
17143: PPOPN 2
17145: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17146: LD_VAR 0 1
17150: PUSH
17151: LD_EXP 21
17155: EQUAL
17156: IFFALSE 17167
// begin YouLost ( JMM ) ;
17158: LD_STRING JMM
17160: PPUSH
17161: CALL_OW 104
// exit ;
17165: GO 17299
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17167: LD_VAR 0 1
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: LD_INT 21
17184: PUSH
17185: LD_INT 1
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 2
17194: PUSH
17195: LD_INT 25
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 25
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: LD_INT 25
17217: PUSH
17218: LD_INT 3
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: PUSH
17225: LD_INT 25
17227: PUSH
17228: LD_INT 4
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: LD_INT 25
17237: PUSH
17238: LD_INT 5
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 25
17247: PUSH
17248: LD_INT 8
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: IN
17274: IFFALSE 17290
// loses_counter := loses_counter + 1 ;
17276: LD_ADDR_EXP 17
17280: PUSH
17281: LD_EXP 17
17285: PUSH
17286: LD_INT 1
17288: PLUS
17289: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 45156 0 1
// end ;
17299: PPOPN 1
17301: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17302: LD_VAR 0 1
17306: PPUSH
17307: LD_VAR 0 2
17311: PPUSH
17312: CALL 47490 0 2
// end ;
17316: PPOPN 2
17318: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL 46799 0 1
// end ;
17328: PPOPN 1
17330: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17331: LD_VAR 0 1
17335: PPUSH
17336: LD_VAR 0 2
17340: PPUSH
17341: LD_VAR 0 3
17345: PPUSH
17346: LD_VAR 0 4
17350: PPUSH
17351: LD_VAR 0 5
17355: PPUSH
17356: CALL 44472 0 5
// end ;
17360: PPOPN 5
17362: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17363: LD_VAR 0 1
17367: PPUSH
17368: CALL_OW 248
17372: PUSH
17373: LD_INT 1
17375: EQUAL
17376: IFFALSE 17386
// am_veh_consturcted := true ;
17378: LD_ADDR_EXP 20
17382: PUSH
17383: LD_INT 1
17385: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_VAR 0 2
17395: PPUSH
17396: CALL 44062 0 2
// end ;
17400: PPOPN 2
17402: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 247
17412: PUSH
17413: LD_INT 2
17415: EQUAL
17416: IFFALSE 17420
// exit ;
17418: GO 17437
// if not kamikazed then
17420: LD_EXP 11
17424: NOT
17425: IFFALSE 17437
// kamikazed := unit ;
17427: LD_ADDR_EXP 11
17431: PUSH
17432: LD_VAR 0 1
17436: ST_TO_ADDR
// end ;
17437: PPOPN 1
17439: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17444: LD_VAR 0 1
17448: PPUSH
17449: LD_VAR 0 2
17453: PPUSH
17454: LD_VAR 0 3
17458: PPUSH
17459: LD_VAR 0 4
17463: PPUSH
17464: CALL 43900 0 4
// end ;
17468: PPOPN 6
17470: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17471: LD_VAR 0 1
17475: PPUSH
17476: LD_VAR 0 2
17480: PPUSH
17481: LD_VAR 0 3
17485: PPUSH
17486: CALL 43675 0 3
// end ;
17490: PPOPN 3
17492: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17493: LD_VAR 0 1
17497: PPUSH
17498: LD_VAR 0 2
17502: PPUSH
17503: CALL 44852 0 2
// end ;
17507: PPOPN 2
17509: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17510: LD_VAR 0 1
17514: PPUSH
17515: LD_VAR 0 2
17519: PPUSH
17520: CALL 43369 0 2
// end ;
17524: PPOPN 2
17526: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17527: LD_VAR 0 1
17531: PPUSH
17532: LD_VAR 0 2
17536: PPUSH
17537: CALL 43560 0 2
// end ;
17541: PPOPN 2
17543: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: CALL 46558 0 1
// end ;
17553: PPOPN 1
17555: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17556: LD_VAR 0 1
17560: PPUSH
17561: LD_VAR 0 2
17565: PPUSH
17566: CALL 47751 0 2
// end ;
17570: PPOPN 2
17572: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17573: LD_VAR 0 1
17577: PPUSH
17578: LD_VAR 0 2
17582: PPUSH
17583: LD_VAR 0 3
17587: PPUSH
17588: LD_VAR 0 4
17592: PPUSH
17593: CALL 47967 0 4
// end ;
17597: PPOPN 4
17599: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL 99202 0 1
// end ; end_of_file
17609: PPOPN 1
17611: END
// every 0 0$1 trigger game do
17612: LD_EXP 2
17616: IFFALSE 17646
17618: GO 17620
17620: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17621: LD_INT 7
17623: PUSH
17624: LD_INT 6
17626: PUSH
17627: LD_INT 4
17629: PUSH
17630: LD_INT 6
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: PPUSH
17639: LD_INT 1750
17641: PPUSH
17642: CALL 17647 0 2
17646: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17647: LD_INT 0
17649: PPUSH
17650: PPUSH
17651: PPUSH
// if not areas then
17652: LD_VAR 0 1
17656: NOT
17657: IFFALSE 17661
// exit ;
17659: GO 17791
// repeat wait ( time ) ;
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL_OW 67
// for i in areas do
17670: LD_ADDR_VAR 0 4
17674: PUSH
17675: LD_VAR 0 1
17679: PUSH
17680: FOR_IN
17681: IFFALSE 17750
// begin p := rand ( 1 , 90 ) ;
17683: LD_ADDR_VAR 0 5
17687: PUSH
17688: LD_INT 1
17690: PPUSH
17691: LD_INT 90
17693: PPUSH
17694: CALL_OW 12
17698: ST_TO_ADDR
// if Prob ( p ) then
17699: LD_VAR 0 5
17703: PPUSH
17704: CALL_OW 13
17708: IFFALSE 17748
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17710: LD_INT 2
17712: PPUSH
17713: LD_INT 5
17715: PPUSH
17716: CALL_OW 12
17720: PPUSH
17721: LD_VAR 0 4
17725: PPUSH
17726: LD_INT 1
17728: PPUSH
17729: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17733: LD_INT 735
17735: PPUSH
17736: LD_INT 1295
17738: PPUSH
17739: CALL_OW 12
17743: PPUSH
17744: CALL_OW 67
// end ; end ;
17748: GO 17680
17750: POP
17751: POP
// time := time + 0 0$3 ;
17752: LD_ADDR_VAR 0 2
17756: PUSH
17757: LD_VAR 0 2
17761: PUSH
17762: LD_INT 105
17764: PLUS
17765: ST_TO_ADDR
// if time > 6 6$00 then
17766: LD_VAR 0 2
17770: PUSH
17771: LD_INT 12600
17773: GREATER
17774: IFFALSE 17784
// time := 0 0$40 ;
17776: LD_ADDR_VAR 0 2
17780: PUSH
17781: LD_INT 1400
17783: ST_TO_ADDR
// until not game ;
17784: LD_EXP 2
17788: NOT
17789: IFFALSE 17661
// end ;
17791: LD_VAR 0 3
17795: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17796: LD_OWVAR 1
17800: PUSH
17801: LD_INT 84000
17803: PUSH
17804: LD_INT 73500
17806: PUSH
17807: LD_INT 63000
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: LIST
17814: PUSH
17815: LD_OWVAR 67
17819: ARRAY
17820: LESS
17821: IFFALSE 17848
17823: GO 17825
17825: DISABLE
// begin enable ;
17826: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17827: LD_INT 1
17829: PPUSH
17830: LD_INT 5
17832: PPUSH
17833: CALL_OW 12
17837: PPUSH
17838: LD_INT 7
17840: PPUSH
17841: LD_INT 1
17843: PPUSH
17844: CALL_OW 55
// end ; end_of_file
17848: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// skirmish := false ;
17853: LD_ADDR_EXP 48
17857: PUSH
17858: LD_INT 0
17860: ST_TO_ADDR
// debug_mc := false ;
17861: LD_ADDR_EXP 49
17865: PUSH
17866: LD_INT 0
17868: ST_TO_ADDR
// mc_bases := [ ] ;
17869: LD_ADDR_EXP 50
17873: PUSH
17874: EMPTY
17875: ST_TO_ADDR
// mc_sides := [ ] ;
17876: LD_ADDR_EXP 76
17880: PUSH
17881: EMPTY
17882: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17883: LD_ADDR_EXP 51
17887: PUSH
17888: EMPTY
17889: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17890: LD_ADDR_EXP 52
17894: PUSH
17895: EMPTY
17896: ST_TO_ADDR
// mc_need_heal := [ ] ;
17897: LD_ADDR_EXP 53
17901: PUSH
17902: EMPTY
17903: ST_TO_ADDR
// mc_healers := [ ] ;
17904: LD_ADDR_EXP 54
17908: PUSH
17909: EMPTY
17910: ST_TO_ADDR
// mc_build_list := [ ] ;
17911: LD_ADDR_EXP 55
17915: PUSH
17916: EMPTY
17917: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17918: LD_ADDR_EXP 82
17922: PUSH
17923: EMPTY
17924: ST_TO_ADDR
// mc_builders := [ ] ;
17925: LD_ADDR_EXP 56
17929: PUSH
17930: EMPTY
17931: ST_TO_ADDR
// mc_construct_list := [ ] ;
17932: LD_ADDR_EXP 57
17936: PUSH
17937: EMPTY
17938: ST_TO_ADDR
// mc_turret_list := [ ] ;
17939: LD_ADDR_EXP 58
17943: PUSH
17944: EMPTY
17945: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17946: LD_ADDR_EXP 59
17950: PUSH
17951: EMPTY
17952: ST_TO_ADDR
// mc_miners := [ ] ;
17953: LD_ADDR_EXP 64
17957: PUSH
17958: EMPTY
17959: ST_TO_ADDR
// mc_mines := [ ] ;
17960: LD_ADDR_EXP 63
17964: PUSH
17965: EMPTY
17966: ST_TO_ADDR
// mc_minefields := [ ] ;
17967: LD_ADDR_EXP 65
17971: PUSH
17972: EMPTY
17973: ST_TO_ADDR
// mc_crates := [ ] ;
17974: LD_ADDR_EXP 66
17978: PUSH
17979: EMPTY
17980: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17981: LD_ADDR_EXP 67
17985: PUSH
17986: EMPTY
17987: ST_TO_ADDR
// mc_crates_area := [ ] ;
17988: LD_ADDR_EXP 68
17992: PUSH
17993: EMPTY
17994: ST_TO_ADDR
// mc_vehicles := [ ] ;
17995: LD_ADDR_EXP 69
17999: PUSH
18000: EMPTY
18001: ST_TO_ADDR
// mc_attack := [ ] ;
18002: LD_ADDR_EXP 70
18006: PUSH
18007: EMPTY
18008: ST_TO_ADDR
// mc_produce := [ ] ;
18009: LD_ADDR_EXP 71
18013: PUSH
18014: EMPTY
18015: ST_TO_ADDR
// mc_defender := [ ] ;
18016: LD_ADDR_EXP 72
18020: PUSH
18021: EMPTY
18022: ST_TO_ADDR
// mc_parking := [ ] ;
18023: LD_ADDR_EXP 74
18027: PUSH
18028: EMPTY
18029: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18030: LD_ADDR_EXP 60
18034: PUSH
18035: EMPTY
18036: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18037: LD_ADDR_EXP 62
18041: PUSH
18042: EMPTY
18043: ST_TO_ADDR
// mc_scan := [ ] ;
18044: LD_ADDR_EXP 73
18048: PUSH
18049: EMPTY
18050: ST_TO_ADDR
// mc_scan_area := [ ] ;
18051: LD_ADDR_EXP 75
18055: PUSH
18056: EMPTY
18057: ST_TO_ADDR
// mc_tech := [ ] ;
18058: LD_ADDR_EXP 77
18062: PUSH
18063: EMPTY
18064: ST_TO_ADDR
// mc_class := [ ] ;
18065: LD_ADDR_EXP 91
18069: PUSH
18070: EMPTY
18071: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18072: LD_ADDR_EXP 92
18076: PUSH
18077: EMPTY
18078: ST_TO_ADDR
// mc_is_defending := [ ] ;
18079: LD_ADDR_EXP 93
18083: PUSH
18084: EMPTY
18085: ST_TO_ADDR
// end ;
18086: LD_VAR 0 1
18090: RET
// export function MC_Kill ( base ) ; begin
18091: LD_INT 0
18093: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18094: LD_ADDR_EXP 50
18098: PUSH
18099: LD_EXP 50
18103: PPUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: EMPTY
18110: PPUSH
18111: CALL_OW 1
18115: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18116: LD_ADDR_EXP 51
18120: PUSH
18121: LD_EXP 51
18125: PPUSH
18126: LD_VAR 0 1
18130: PPUSH
18131: EMPTY
18132: PPUSH
18133: CALL_OW 1
18137: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18138: LD_ADDR_EXP 52
18142: PUSH
18143: LD_EXP 52
18147: PPUSH
18148: LD_VAR 0 1
18152: PPUSH
18153: EMPTY
18154: PPUSH
18155: CALL_OW 1
18159: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18160: LD_ADDR_EXP 53
18164: PUSH
18165: LD_EXP 53
18169: PPUSH
18170: LD_VAR 0 1
18174: PPUSH
18175: EMPTY
18176: PPUSH
18177: CALL_OW 1
18181: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18182: LD_ADDR_EXP 54
18186: PUSH
18187: LD_EXP 54
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: EMPTY
18198: PPUSH
18199: CALL_OW 1
18203: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18204: LD_ADDR_EXP 55
18208: PUSH
18209: LD_EXP 55
18213: PPUSH
18214: LD_VAR 0 1
18218: PPUSH
18219: EMPTY
18220: PPUSH
18221: CALL_OW 1
18225: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18226: LD_ADDR_EXP 56
18230: PUSH
18231: LD_EXP 56
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: EMPTY
18242: PPUSH
18243: CALL_OW 1
18247: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18248: LD_ADDR_EXP 57
18252: PUSH
18253: LD_EXP 57
18257: PPUSH
18258: LD_VAR 0 1
18262: PPUSH
18263: EMPTY
18264: PPUSH
18265: CALL_OW 1
18269: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18270: LD_ADDR_EXP 58
18274: PUSH
18275: LD_EXP 58
18279: PPUSH
18280: LD_VAR 0 1
18284: PPUSH
18285: EMPTY
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18292: LD_ADDR_EXP 59
18296: PUSH
18297: LD_EXP 59
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18314: LD_ADDR_EXP 60
18318: PUSH
18319: LD_EXP 60
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18336: LD_ADDR_EXP 61
18340: PUSH
18341: LD_EXP 61
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: LD_INT 0
18353: PPUSH
18354: CALL_OW 1
18358: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18359: LD_ADDR_EXP 62
18363: PUSH
18364: LD_EXP 62
18368: PPUSH
18369: LD_VAR 0 1
18373: PPUSH
18374: EMPTY
18375: PPUSH
18376: CALL_OW 1
18380: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18381: LD_ADDR_EXP 63
18385: PUSH
18386: LD_EXP 63
18390: PPUSH
18391: LD_VAR 0 1
18395: PPUSH
18396: EMPTY
18397: PPUSH
18398: CALL_OW 1
18402: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18403: LD_ADDR_EXP 64
18407: PUSH
18408: LD_EXP 64
18412: PPUSH
18413: LD_VAR 0 1
18417: PPUSH
18418: EMPTY
18419: PPUSH
18420: CALL_OW 1
18424: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18425: LD_ADDR_EXP 65
18429: PUSH
18430: LD_EXP 65
18434: PPUSH
18435: LD_VAR 0 1
18439: PPUSH
18440: EMPTY
18441: PPUSH
18442: CALL_OW 1
18446: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18447: LD_ADDR_EXP 66
18451: PUSH
18452: LD_EXP 66
18456: PPUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: EMPTY
18463: PPUSH
18464: CALL_OW 1
18468: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18469: LD_ADDR_EXP 67
18473: PUSH
18474: LD_EXP 67
18478: PPUSH
18479: LD_VAR 0 1
18483: PPUSH
18484: EMPTY
18485: PPUSH
18486: CALL_OW 1
18490: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18491: LD_ADDR_EXP 68
18495: PUSH
18496: LD_EXP 68
18500: PPUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: EMPTY
18507: PPUSH
18508: CALL_OW 1
18512: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18513: LD_ADDR_EXP 69
18517: PUSH
18518: LD_EXP 69
18522: PPUSH
18523: LD_VAR 0 1
18527: PPUSH
18528: EMPTY
18529: PPUSH
18530: CALL_OW 1
18534: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18535: LD_ADDR_EXP 70
18539: PUSH
18540: LD_EXP 70
18544: PPUSH
18545: LD_VAR 0 1
18549: PPUSH
18550: EMPTY
18551: PPUSH
18552: CALL_OW 1
18556: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: LD_EXP 71
18566: PPUSH
18567: LD_VAR 0 1
18571: PPUSH
18572: EMPTY
18573: PPUSH
18574: CALL_OW 1
18578: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18579: LD_ADDR_EXP 72
18583: PUSH
18584: LD_EXP 72
18588: PPUSH
18589: LD_VAR 0 1
18593: PPUSH
18594: EMPTY
18595: PPUSH
18596: CALL_OW 1
18600: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18601: LD_ADDR_EXP 73
18605: PUSH
18606: LD_EXP 73
18610: PPUSH
18611: LD_VAR 0 1
18615: PPUSH
18616: EMPTY
18617: PPUSH
18618: CALL_OW 1
18622: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18623: LD_ADDR_EXP 74
18627: PUSH
18628: LD_EXP 74
18632: PPUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: EMPTY
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18645: LD_ADDR_EXP 75
18649: PUSH
18650: LD_EXP 75
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: EMPTY
18661: PPUSH
18662: CALL_OW 1
18666: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18667: LD_ADDR_EXP 77
18671: PUSH
18672: LD_EXP 77
18676: PPUSH
18677: LD_VAR 0 1
18681: PPUSH
18682: EMPTY
18683: PPUSH
18684: CALL_OW 1
18688: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18689: LD_ADDR_EXP 79
18693: PUSH
18694: LD_EXP 79
18698: PPUSH
18699: LD_VAR 0 1
18703: PPUSH
18704: EMPTY
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18711: LD_ADDR_EXP 80
18715: PUSH
18716: LD_EXP 80
18720: PPUSH
18721: LD_VAR 0 1
18725: PPUSH
18726: EMPTY
18727: PPUSH
18728: CALL_OW 1
18732: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18733: LD_ADDR_EXP 81
18737: PUSH
18738: LD_EXP 81
18742: PPUSH
18743: LD_VAR 0 1
18747: PPUSH
18748: EMPTY
18749: PPUSH
18750: CALL_OW 1
18754: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18755: LD_ADDR_EXP 82
18759: PUSH
18760: LD_EXP 82
18764: PPUSH
18765: LD_VAR 0 1
18769: PPUSH
18770: EMPTY
18771: PPUSH
18772: CALL_OW 1
18776: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18777: LD_ADDR_EXP 83
18781: PUSH
18782: LD_EXP 83
18786: PPUSH
18787: LD_VAR 0 1
18791: PPUSH
18792: EMPTY
18793: PPUSH
18794: CALL_OW 1
18798: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18799: LD_ADDR_EXP 84
18803: PUSH
18804: LD_EXP 84
18808: PPUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: EMPTY
18815: PPUSH
18816: CALL_OW 1
18820: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18821: LD_ADDR_EXP 85
18825: PUSH
18826: LD_EXP 85
18830: PPUSH
18831: LD_VAR 0 1
18835: PPUSH
18836: EMPTY
18837: PPUSH
18838: CALL_OW 1
18842: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18843: LD_ADDR_EXP 86
18847: PUSH
18848: LD_EXP 86
18852: PPUSH
18853: LD_VAR 0 1
18857: PPUSH
18858: EMPTY
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18865: LD_ADDR_EXP 87
18869: PUSH
18870: LD_EXP 87
18874: PPUSH
18875: LD_VAR 0 1
18879: PPUSH
18880: EMPTY
18881: PPUSH
18882: CALL_OW 1
18886: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18887: LD_ADDR_EXP 88
18891: PUSH
18892: LD_EXP 88
18896: PPUSH
18897: LD_VAR 0 1
18901: PPUSH
18902: EMPTY
18903: PPUSH
18904: CALL_OW 1
18908: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18909: LD_ADDR_EXP 89
18913: PUSH
18914: LD_EXP 89
18918: PPUSH
18919: LD_VAR 0 1
18923: PPUSH
18924: EMPTY
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18931: LD_ADDR_EXP 90
18935: PUSH
18936: LD_EXP 90
18940: PPUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: EMPTY
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18953: LD_ADDR_EXP 91
18957: PUSH
18958: LD_EXP 91
18962: PPUSH
18963: LD_VAR 0 1
18967: PPUSH
18968: EMPTY
18969: PPUSH
18970: CALL_OW 1
18974: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18975: LD_ADDR_EXP 92
18979: PUSH
18980: LD_EXP 92
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: LD_INT 0
18992: PPUSH
18993: CALL_OW 1
18997: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
18998: LD_ADDR_EXP 93
19002: PUSH
19003: LD_EXP 93
19007: PPUSH
19008: LD_VAR 0 1
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: CALL_OW 1
19020: ST_TO_ADDR
// end ;
19021: LD_VAR 0 2
19025: RET
// export function MC_Add ( side , units ) ; var base ; begin
19026: LD_INT 0
19028: PPUSH
19029: PPUSH
// base := mc_bases + 1 ;
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_EXP 50
19039: PUSH
19040: LD_INT 1
19042: PLUS
19043: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19044: LD_ADDR_EXP 76
19048: PUSH
19049: LD_EXP 76
19053: PPUSH
19054: LD_VAR 0 4
19058: PPUSH
19059: LD_VAR 0 1
19063: PPUSH
19064: CALL_OW 1
19068: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19069: LD_ADDR_EXP 50
19073: PUSH
19074: LD_EXP 50
19078: PPUSH
19079: LD_VAR 0 4
19083: PPUSH
19084: LD_VAR 0 2
19088: PPUSH
19089: CALL_OW 1
19093: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19094: LD_ADDR_EXP 51
19098: PUSH
19099: LD_EXP 51
19103: PPUSH
19104: LD_VAR 0 4
19108: PPUSH
19109: EMPTY
19110: PPUSH
19111: CALL_OW 1
19115: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19116: LD_ADDR_EXP 52
19120: PUSH
19121: LD_EXP 52
19125: PPUSH
19126: LD_VAR 0 4
19130: PPUSH
19131: EMPTY
19132: PPUSH
19133: CALL_OW 1
19137: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19138: LD_ADDR_EXP 53
19142: PUSH
19143: LD_EXP 53
19147: PPUSH
19148: LD_VAR 0 4
19152: PPUSH
19153: EMPTY
19154: PPUSH
19155: CALL_OW 1
19159: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19160: LD_ADDR_EXP 54
19164: PUSH
19165: LD_EXP 54
19169: PPUSH
19170: LD_VAR 0 4
19174: PPUSH
19175: EMPTY
19176: PPUSH
19177: CALL_OW 1
19181: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19182: LD_ADDR_EXP 55
19186: PUSH
19187: LD_EXP 55
19191: PPUSH
19192: LD_VAR 0 4
19196: PPUSH
19197: EMPTY
19198: PPUSH
19199: CALL_OW 1
19203: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19204: LD_ADDR_EXP 56
19208: PUSH
19209: LD_EXP 56
19213: PPUSH
19214: LD_VAR 0 4
19218: PPUSH
19219: EMPTY
19220: PPUSH
19221: CALL_OW 1
19225: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19226: LD_ADDR_EXP 57
19230: PUSH
19231: LD_EXP 57
19235: PPUSH
19236: LD_VAR 0 4
19240: PPUSH
19241: EMPTY
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19248: LD_ADDR_EXP 58
19252: PUSH
19253: LD_EXP 58
19257: PPUSH
19258: LD_VAR 0 4
19262: PPUSH
19263: EMPTY
19264: PPUSH
19265: CALL_OW 1
19269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19270: LD_ADDR_EXP 59
19274: PUSH
19275: LD_EXP 59
19279: PPUSH
19280: LD_VAR 0 4
19284: PPUSH
19285: EMPTY
19286: PPUSH
19287: CALL_OW 1
19291: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19292: LD_ADDR_EXP 60
19296: PUSH
19297: LD_EXP 60
19301: PPUSH
19302: LD_VAR 0 4
19306: PPUSH
19307: EMPTY
19308: PPUSH
19309: CALL_OW 1
19313: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19314: LD_ADDR_EXP 61
19318: PUSH
19319: LD_EXP 61
19323: PPUSH
19324: LD_VAR 0 4
19328: PPUSH
19329: LD_INT 0
19331: PPUSH
19332: CALL_OW 1
19336: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19337: LD_ADDR_EXP 62
19341: PUSH
19342: LD_EXP 62
19346: PPUSH
19347: LD_VAR 0 4
19351: PPUSH
19352: EMPTY
19353: PPUSH
19354: CALL_OW 1
19358: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19359: LD_ADDR_EXP 63
19363: PUSH
19364: LD_EXP 63
19368: PPUSH
19369: LD_VAR 0 4
19373: PPUSH
19374: EMPTY
19375: PPUSH
19376: CALL_OW 1
19380: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19381: LD_ADDR_EXP 64
19385: PUSH
19386: LD_EXP 64
19390: PPUSH
19391: LD_VAR 0 4
19395: PPUSH
19396: EMPTY
19397: PPUSH
19398: CALL_OW 1
19402: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19403: LD_ADDR_EXP 65
19407: PUSH
19408: LD_EXP 65
19412: PPUSH
19413: LD_VAR 0 4
19417: PPUSH
19418: EMPTY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19425: LD_ADDR_EXP 66
19429: PUSH
19430: LD_EXP 66
19434: PPUSH
19435: LD_VAR 0 4
19439: PPUSH
19440: EMPTY
19441: PPUSH
19442: CALL_OW 1
19446: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19447: LD_ADDR_EXP 67
19451: PUSH
19452: LD_EXP 67
19456: PPUSH
19457: LD_VAR 0 4
19461: PPUSH
19462: EMPTY
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19469: LD_ADDR_EXP 68
19473: PUSH
19474: LD_EXP 68
19478: PPUSH
19479: LD_VAR 0 4
19483: PPUSH
19484: EMPTY
19485: PPUSH
19486: CALL_OW 1
19490: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19491: LD_ADDR_EXP 69
19495: PUSH
19496: LD_EXP 69
19500: PPUSH
19501: LD_VAR 0 4
19505: PPUSH
19506: EMPTY
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19513: LD_ADDR_EXP 70
19517: PUSH
19518: LD_EXP 70
19522: PPUSH
19523: LD_VAR 0 4
19527: PPUSH
19528: EMPTY
19529: PPUSH
19530: CALL_OW 1
19534: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19535: LD_ADDR_EXP 71
19539: PUSH
19540: LD_EXP 71
19544: PPUSH
19545: LD_VAR 0 4
19549: PPUSH
19550: EMPTY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19557: LD_ADDR_EXP 72
19561: PUSH
19562: LD_EXP 72
19566: PPUSH
19567: LD_VAR 0 4
19571: PPUSH
19572: EMPTY
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19579: LD_ADDR_EXP 73
19583: PUSH
19584: LD_EXP 73
19588: PPUSH
19589: LD_VAR 0 4
19593: PPUSH
19594: EMPTY
19595: PPUSH
19596: CALL_OW 1
19600: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19601: LD_ADDR_EXP 74
19605: PUSH
19606: LD_EXP 74
19610: PPUSH
19611: LD_VAR 0 4
19615: PPUSH
19616: EMPTY
19617: PPUSH
19618: CALL_OW 1
19622: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19623: LD_ADDR_EXP 75
19627: PUSH
19628: LD_EXP 75
19632: PPUSH
19633: LD_VAR 0 4
19637: PPUSH
19638: EMPTY
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19645: LD_ADDR_EXP 77
19649: PUSH
19650: LD_EXP 77
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19667: LD_ADDR_EXP 79
19671: PUSH
19672: LD_EXP 79
19676: PPUSH
19677: LD_VAR 0 4
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19689: LD_ADDR_EXP 80
19693: PUSH
19694: LD_EXP 80
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19711: LD_ADDR_EXP 81
19715: PUSH
19716: LD_EXP 81
19720: PPUSH
19721: LD_VAR 0 4
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19733: LD_ADDR_EXP 82
19737: PUSH
19738: LD_EXP 82
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: EMPTY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19755: LD_ADDR_EXP 83
19759: PUSH
19760: LD_EXP 83
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: EMPTY
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19777: LD_ADDR_EXP 84
19781: PUSH
19782: LD_EXP 84
19786: PPUSH
19787: LD_VAR 0 4
19791: PPUSH
19792: EMPTY
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19799: LD_ADDR_EXP 85
19803: PUSH
19804: LD_EXP 85
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: EMPTY
19815: PPUSH
19816: CALL_OW 1
19820: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19821: LD_ADDR_EXP 86
19825: PUSH
19826: LD_EXP 86
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: EMPTY
19837: PPUSH
19838: CALL_OW 1
19842: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19843: LD_ADDR_EXP 87
19847: PUSH
19848: LD_EXP 87
19852: PPUSH
19853: LD_VAR 0 4
19857: PPUSH
19858: EMPTY
19859: PPUSH
19860: CALL_OW 1
19864: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19865: LD_ADDR_EXP 88
19869: PUSH
19870: LD_EXP 88
19874: PPUSH
19875: LD_VAR 0 4
19879: PPUSH
19880: EMPTY
19881: PPUSH
19882: CALL_OW 1
19886: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19887: LD_ADDR_EXP 89
19891: PUSH
19892: LD_EXP 89
19896: PPUSH
19897: LD_VAR 0 4
19901: PPUSH
19902: EMPTY
19903: PPUSH
19904: CALL_OW 1
19908: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19909: LD_ADDR_EXP 90
19913: PUSH
19914: LD_EXP 90
19918: PPUSH
19919: LD_VAR 0 4
19923: PPUSH
19924: EMPTY
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19931: LD_ADDR_EXP 91
19935: PUSH
19936: LD_EXP 91
19940: PPUSH
19941: LD_VAR 0 4
19945: PPUSH
19946: EMPTY
19947: PPUSH
19948: CALL_OW 1
19952: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19953: LD_ADDR_EXP 92
19957: PUSH
19958: LD_EXP 92
19962: PPUSH
19963: LD_VAR 0 4
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: CALL_OW 1
19975: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19976: LD_ADDR_EXP 93
19980: PUSH
19981: LD_EXP 93
19985: PPUSH
19986: LD_VAR 0 4
19990: PPUSH
19991: LD_INT 0
19993: PPUSH
19994: CALL_OW 1
19998: ST_TO_ADDR
// result := base ;
19999: LD_ADDR_VAR 0 3
20003: PUSH
20004: LD_VAR 0 4
20008: ST_TO_ADDR
// end ;
20009: LD_VAR 0 3
20013: RET
// export function MC_Start ( ) ; var i ; begin
20014: LD_INT 0
20016: PPUSH
20017: PPUSH
// for i = 1 to mc_bases do
20018: LD_ADDR_VAR 0 2
20022: PUSH
20023: DOUBLE
20024: LD_INT 1
20026: DEC
20027: ST_TO_ADDR
20028: LD_EXP 50
20032: PUSH
20033: FOR_TO
20034: IFFALSE 21111
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20036: LD_ADDR_EXP 50
20040: PUSH
20041: LD_EXP 50
20045: PPUSH
20046: LD_VAR 0 2
20050: PPUSH
20051: LD_EXP 50
20055: PUSH
20056: LD_VAR 0 2
20060: ARRAY
20061: PUSH
20062: LD_INT 0
20064: DIFF
20065: PPUSH
20066: CALL_OW 1
20070: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20071: LD_ADDR_EXP 51
20075: PUSH
20076: LD_EXP 51
20080: PPUSH
20081: LD_VAR 0 2
20085: PPUSH
20086: EMPTY
20087: PPUSH
20088: CALL_OW 1
20092: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20093: LD_ADDR_EXP 52
20097: PUSH
20098: LD_EXP 52
20102: PPUSH
20103: LD_VAR 0 2
20107: PPUSH
20108: EMPTY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20115: LD_ADDR_EXP 53
20119: PUSH
20120: LD_EXP 53
20124: PPUSH
20125: LD_VAR 0 2
20129: PPUSH
20130: EMPTY
20131: PPUSH
20132: CALL_OW 1
20136: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20137: LD_ADDR_EXP 54
20141: PUSH
20142: LD_EXP 54
20146: PPUSH
20147: LD_VAR 0 2
20151: PPUSH
20152: EMPTY
20153: PUSH
20154: EMPTY
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PPUSH
20160: CALL_OW 1
20164: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20165: LD_ADDR_EXP 55
20169: PUSH
20170: LD_EXP 55
20174: PPUSH
20175: LD_VAR 0 2
20179: PPUSH
20180: EMPTY
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20187: LD_ADDR_EXP 82
20191: PUSH
20192: LD_EXP 82
20196: PPUSH
20197: LD_VAR 0 2
20201: PPUSH
20202: EMPTY
20203: PPUSH
20204: CALL_OW 1
20208: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20209: LD_ADDR_EXP 56
20213: PUSH
20214: LD_EXP 56
20218: PPUSH
20219: LD_VAR 0 2
20223: PPUSH
20224: EMPTY
20225: PPUSH
20226: CALL_OW 1
20230: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20231: LD_ADDR_EXP 57
20235: PUSH
20236: LD_EXP 57
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: EMPTY
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20253: LD_ADDR_EXP 58
20257: PUSH
20258: LD_EXP 58
20262: PPUSH
20263: LD_VAR 0 2
20267: PPUSH
20268: LD_EXP 50
20272: PUSH
20273: LD_VAR 0 2
20277: ARRAY
20278: PPUSH
20279: LD_INT 2
20281: PUSH
20282: LD_INT 30
20284: PUSH
20285: LD_INT 32
20287: PUSH
20288: EMPTY
20289: LIST
20290: LIST
20291: PUSH
20292: LD_INT 30
20294: PUSH
20295: LD_INT 33
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: LIST
20306: PPUSH
20307: CALL_OW 72
20311: PPUSH
20312: CALL_OW 1
20316: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20317: LD_ADDR_EXP 59
20321: PUSH
20322: LD_EXP 59
20326: PPUSH
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_EXP 50
20336: PUSH
20337: LD_VAR 0 2
20341: ARRAY
20342: PPUSH
20343: LD_INT 2
20345: PUSH
20346: LD_INT 30
20348: PUSH
20349: LD_INT 32
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: PUSH
20356: LD_INT 30
20358: PUSH
20359: LD_INT 31
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: LIST
20370: PUSH
20371: LD_INT 58
20373: PUSH
20374: EMPTY
20375: LIST
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PPUSH
20381: CALL_OW 72
20385: PPUSH
20386: CALL_OW 1
20390: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20391: LD_ADDR_EXP 60
20395: PUSH
20396: LD_EXP 60
20400: PPUSH
20401: LD_VAR 0 2
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL_OW 1
20412: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20413: LD_ADDR_EXP 64
20417: PUSH
20418: LD_EXP 64
20422: PPUSH
20423: LD_VAR 0 2
20427: PPUSH
20428: EMPTY
20429: PPUSH
20430: CALL_OW 1
20434: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20435: LD_ADDR_EXP 63
20439: PUSH
20440: LD_EXP 63
20444: PPUSH
20445: LD_VAR 0 2
20449: PPUSH
20450: EMPTY
20451: PPUSH
20452: CALL_OW 1
20456: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20457: LD_ADDR_EXP 65
20461: PUSH
20462: LD_EXP 65
20466: PPUSH
20467: LD_VAR 0 2
20471: PPUSH
20472: EMPTY
20473: PPUSH
20474: CALL_OW 1
20478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20479: LD_ADDR_EXP 66
20483: PUSH
20484: LD_EXP 66
20488: PPUSH
20489: LD_VAR 0 2
20493: PPUSH
20494: EMPTY
20495: PPUSH
20496: CALL_OW 1
20500: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20501: LD_ADDR_EXP 67
20505: PUSH
20506: LD_EXP 67
20510: PPUSH
20511: LD_VAR 0 2
20515: PPUSH
20516: EMPTY
20517: PPUSH
20518: CALL_OW 1
20522: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20523: LD_ADDR_EXP 68
20527: PUSH
20528: LD_EXP 68
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: EMPTY
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20545: LD_ADDR_EXP 69
20549: PUSH
20550: LD_EXP 69
20554: PPUSH
20555: LD_VAR 0 2
20559: PPUSH
20560: EMPTY
20561: PPUSH
20562: CALL_OW 1
20566: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20567: LD_ADDR_EXP 70
20571: PUSH
20572: LD_EXP 70
20576: PPUSH
20577: LD_VAR 0 2
20581: PPUSH
20582: EMPTY
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20589: LD_ADDR_EXP 71
20593: PUSH
20594: LD_EXP 71
20598: PPUSH
20599: LD_VAR 0 2
20603: PPUSH
20604: EMPTY
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20611: LD_ADDR_EXP 72
20615: PUSH
20616: LD_EXP 72
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20633: LD_ADDR_EXP 61
20637: PUSH
20638: LD_EXP 61
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: LD_INT 0
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20656: LD_ADDR_EXP 74
20660: PUSH
20661: LD_EXP 74
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: LD_INT 0
20673: PPUSH
20674: CALL_OW 1
20678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20679: LD_ADDR_EXP 62
20683: PUSH
20684: LD_EXP 62
20688: PPUSH
20689: LD_VAR 0 2
20693: PPUSH
20694: EMPTY
20695: PPUSH
20696: CALL_OW 1
20700: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20701: LD_ADDR_EXP 73
20705: PUSH
20706: LD_EXP 73
20710: PPUSH
20711: LD_VAR 0 2
20715: PPUSH
20716: LD_INT 0
20718: PPUSH
20719: CALL_OW 1
20723: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20724: LD_ADDR_EXP 75
20728: PUSH
20729: LD_EXP 75
20733: PPUSH
20734: LD_VAR 0 2
20738: PPUSH
20739: EMPTY
20740: PPUSH
20741: CALL_OW 1
20745: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20746: LD_ADDR_EXP 78
20750: PUSH
20751: LD_EXP 78
20755: PPUSH
20756: LD_VAR 0 2
20760: PPUSH
20761: LD_INT 0
20763: PPUSH
20764: CALL_OW 1
20768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20769: LD_ADDR_EXP 79
20773: PUSH
20774: LD_EXP 79
20778: PPUSH
20779: LD_VAR 0 2
20783: PPUSH
20784: EMPTY
20785: PPUSH
20786: CALL_OW 1
20790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20791: LD_ADDR_EXP 80
20795: PUSH
20796: LD_EXP 80
20800: PPUSH
20801: LD_VAR 0 2
20805: PPUSH
20806: EMPTY
20807: PPUSH
20808: CALL_OW 1
20812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20813: LD_ADDR_EXP 81
20817: PUSH
20818: LD_EXP 81
20822: PPUSH
20823: LD_VAR 0 2
20827: PPUSH
20828: EMPTY
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20835: LD_ADDR_EXP 83
20839: PUSH
20840: LD_EXP 83
20844: PPUSH
20845: LD_VAR 0 2
20849: PPUSH
20850: LD_EXP 50
20854: PUSH
20855: LD_VAR 0 2
20859: ARRAY
20860: PPUSH
20861: LD_INT 2
20863: PUSH
20864: LD_INT 30
20866: PUSH
20867: LD_INT 6
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: LD_INT 30
20876: PUSH
20877: LD_INT 7
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: LD_INT 30
20886: PUSH
20887: LD_INT 8
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: PPUSH
20900: CALL_OW 72
20904: PPUSH
20905: CALL_OW 1
20909: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20910: LD_ADDR_EXP 84
20914: PUSH
20915: LD_EXP 84
20919: PPUSH
20920: LD_VAR 0 2
20924: PPUSH
20925: EMPTY
20926: PPUSH
20927: CALL_OW 1
20931: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20932: LD_ADDR_EXP 85
20936: PUSH
20937: LD_EXP 85
20941: PPUSH
20942: LD_VAR 0 2
20946: PPUSH
20947: EMPTY
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20954: LD_ADDR_EXP 86
20958: PUSH
20959: LD_EXP 86
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20976: LD_ADDR_EXP 87
20980: PUSH
20981: LD_EXP 87
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20998: LD_ADDR_EXP 88
21002: PUSH
21003: LD_EXP 88
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21020: LD_ADDR_EXP 89
21024: PUSH
21025: LD_EXP 89
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21042: LD_ADDR_EXP 90
21046: PUSH
21047: LD_EXP 90
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21064: LD_ADDR_EXP 91
21068: PUSH
21069: LD_EXP 91
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21086: LD_ADDR_EXP 92
21090: PUSH
21091: LD_EXP 92
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: LD_INT 0
21103: PPUSH
21104: CALL_OW 1
21108: ST_TO_ADDR
// end ;
21109: GO 20033
21111: POP
21112: POP
// MC_InitSides ( ) ;
21113: CALL 21399 0 0
// MC_InitResearch ( ) ;
21117: CALL 21138 0 0
// CustomInitMacro ( ) ;
21121: CALL 304 0 0
// skirmish := true ;
21125: LD_ADDR_EXP 48
21129: PUSH
21130: LD_INT 1
21132: ST_TO_ADDR
// end ;
21133: LD_VAR 0 1
21137: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21138: LD_INT 0
21140: PPUSH
21141: PPUSH
21142: PPUSH
21143: PPUSH
21144: PPUSH
21145: PPUSH
// if not mc_bases then
21146: LD_EXP 50
21150: NOT
21151: IFFALSE 21155
// exit ;
21153: GO 21394
// for i = 1 to 8 do
21155: LD_ADDR_VAR 0 2
21159: PUSH
21160: DOUBLE
21161: LD_INT 1
21163: DEC
21164: ST_TO_ADDR
21165: LD_INT 8
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21195
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21171: LD_ADDR_EXP 77
21175: PUSH
21176: LD_EXP 77
21180: PPUSH
21181: LD_VAR 0 2
21185: PPUSH
21186: EMPTY
21187: PPUSH
21188: CALL_OW 1
21192: ST_TO_ADDR
21193: GO 21168
21195: POP
21196: POP
// tmp := [ ] ;
21197: LD_ADDR_VAR 0 5
21201: PUSH
21202: EMPTY
21203: ST_TO_ADDR
// for i = 1 to mc_sides do
21204: LD_ADDR_VAR 0 2
21208: PUSH
21209: DOUBLE
21210: LD_INT 1
21212: DEC
21213: ST_TO_ADDR
21214: LD_EXP 76
21218: PUSH
21219: FOR_TO
21220: IFFALSE 21278
// if not mc_sides [ i ] in tmp then
21222: LD_EXP 76
21226: PUSH
21227: LD_VAR 0 2
21231: ARRAY
21232: PUSH
21233: LD_VAR 0 5
21237: IN
21238: NOT
21239: IFFALSE 21276
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21241: LD_ADDR_VAR 0 5
21245: PUSH
21246: LD_VAR 0 5
21250: PPUSH
21251: LD_VAR 0 5
21255: PUSH
21256: LD_INT 1
21258: PLUS
21259: PPUSH
21260: LD_EXP 76
21264: PUSH
21265: LD_VAR 0 2
21269: ARRAY
21270: PPUSH
21271: CALL_OW 2
21275: ST_TO_ADDR
21276: GO 21219
21278: POP
21279: POP
// if not tmp then
21280: LD_VAR 0 5
21284: NOT
21285: IFFALSE 21289
// exit ;
21287: GO 21394
// for j in tmp do
21289: LD_ADDR_VAR 0 3
21293: PUSH
21294: LD_VAR 0 5
21298: PUSH
21299: FOR_IN
21300: IFFALSE 21392
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21302: LD_ADDR_VAR 0 6
21306: PUSH
21307: LD_INT 22
21309: PUSH
21310: LD_VAR 0 3
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PPUSH
21319: CALL_OW 69
21323: ST_TO_ADDR
// if not un then
21324: LD_VAR 0 6
21328: NOT
21329: IFFALSE 21333
// continue ;
21331: GO 21299
// nation := GetNation ( un [ 1 ] ) ;
21333: LD_ADDR_VAR 0 4
21337: PUSH
21338: LD_VAR 0 6
21342: PUSH
21343: LD_INT 1
21345: ARRAY
21346: PPUSH
21347: CALL_OW 248
21351: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21352: LD_ADDR_EXP 77
21356: PUSH
21357: LD_EXP 77
21361: PPUSH
21362: LD_VAR 0 3
21366: PPUSH
21367: LD_VAR 0 3
21371: PPUSH
21372: LD_VAR 0 4
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL 48171 0 3
21384: PPUSH
21385: CALL_OW 1
21389: ST_TO_ADDR
// end ;
21390: GO 21299
21392: POP
21393: POP
// end ;
21394: LD_VAR 0 1
21398: RET
// export function MC_InitSides ( ) ; var i ; begin
21399: LD_INT 0
21401: PPUSH
21402: PPUSH
// if not mc_bases then
21403: LD_EXP 50
21407: NOT
21408: IFFALSE 21412
// exit ;
21410: GO 21486
// for i = 1 to mc_bases do
21412: LD_ADDR_VAR 0 2
21416: PUSH
21417: DOUBLE
21418: LD_INT 1
21420: DEC
21421: ST_TO_ADDR
21422: LD_EXP 50
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21484
// if mc_bases [ i ] then
21430: LD_EXP 50
21434: PUSH
21435: LD_VAR 0 2
21439: ARRAY
21440: IFFALSE 21482
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21442: LD_ADDR_EXP 76
21446: PUSH
21447: LD_EXP 76
21451: PPUSH
21452: LD_VAR 0 2
21456: PPUSH
21457: LD_EXP 50
21461: PUSH
21462: LD_VAR 0 2
21466: ARRAY
21467: PUSH
21468: LD_INT 1
21470: ARRAY
21471: PPUSH
21472: CALL_OW 255
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
21482: GO 21427
21484: POP
21485: POP
// end ;
21486: LD_VAR 0 1
21490: RET
// every 0 0$03 trigger skirmish do
21491: LD_EXP 48
21495: IFFALSE 21649
21497: GO 21499
21499: DISABLE
// begin enable ;
21500: ENABLE
// MC_CheckBuildings ( ) ;
21501: CALL 26147 0 0
// MC_CheckPeopleLife ( ) ;
21505: CALL 26272 0 0
// RaiseSailEvent ( 100 ) ;
21509: LD_INT 100
21511: PPUSH
21512: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21516: LD_INT 103
21518: PPUSH
21519: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21523: LD_INT 104
21525: PPUSH
21526: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21530: LD_INT 105
21532: PPUSH
21533: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21537: LD_INT 106
21539: PPUSH
21540: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21544: LD_INT 107
21546: PPUSH
21547: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21551: LD_INT 108
21553: PPUSH
21554: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21558: LD_INT 109
21560: PPUSH
21561: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21565: LD_INT 110
21567: PPUSH
21568: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21572: LD_INT 111
21574: PPUSH
21575: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21579: LD_INT 112
21581: PPUSH
21582: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21586: LD_INT 113
21588: PPUSH
21589: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21593: LD_INT 120
21595: PPUSH
21596: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21600: LD_INT 121
21602: PPUSH
21603: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21607: LD_INT 122
21609: PPUSH
21610: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21614: LD_INT 123
21616: PPUSH
21617: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21621: LD_INT 124
21623: PPUSH
21624: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21628: LD_INT 125
21630: PPUSH
21631: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21635: LD_INT 126
21637: PPUSH
21638: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21642: LD_INT 200
21644: PPUSH
21645: CALL_OW 427
// end ;
21649: END
// on SailEvent ( event ) do begin if event < 100 then
21650: LD_VAR 0 1
21654: PUSH
21655: LD_INT 100
21657: LESS
21658: IFFALSE 21669
// CustomEvent ( event ) ;
21660: LD_VAR 0 1
21664: PPUSH
21665: CALL 17062 0 1
// if event = 100 then
21669: LD_VAR 0 1
21673: PUSH
21674: LD_INT 100
21676: EQUAL
21677: IFFALSE 21683
// MC_ClassManager ( ) ;
21679: CALL 22075 0 0
// if event = 101 then
21683: LD_VAR 0 1
21687: PUSH
21688: LD_INT 101
21690: EQUAL
21691: IFFALSE 21697
// MC_RepairBuildings ( ) ;
21693: CALL 26857 0 0
// if event = 102 then
21697: LD_VAR 0 1
21701: PUSH
21702: LD_INT 102
21704: EQUAL
21705: IFFALSE 21711
// MC_Heal ( ) ;
21707: CALL 27742 0 0
// if event = 103 then
21711: LD_VAR 0 1
21715: PUSH
21716: LD_INT 103
21718: EQUAL
21719: IFFALSE 21725
// MC_Build ( ) ;
21721: CALL 28164 0 0
// if event = 104 then
21725: LD_VAR 0 1
21729: PUSH
21730: LD_INT 104
21732: EQUAL
21733: IFFALSE 21739
// MC_TurretWeapon ( ) ;
21735: CALL 29805 0 0
// if event = 105 then
21739: LD_VAR 0 1
21743: PUSH
21744: LD_INT 105
21746: EQUAL
21747: IFFALSE 21753
// MC_BuildUpgrade ( ) ;
21749: CALL 29356 0 0
// if event = 106 then
21753: LD_VAR 0 1
21757: PUSH
21758: LD_INT 106
21760: EQUAL
21761: IFFALSE 21767
// MC_PlantMines ( ) ;
21763: CALL 30235 0 0
// if event = 107 then
21767: LD_VAR 0 1
21771: PUSH
21772: LD_INT 107
21774: EQUAL
21775: IFFALSE 21781
// MC_CollectCrates ( ) ;
21777: CALL 31026 0 0
// if event = 108 then
21781: LD_VAR 0 1
21785: PUSH
21786: LD_INT 108
21788: EQUAL
21789: IFFALSE 21795
// MC_LinkRemoteControl ( ) ;
21791: CALL 32802 0 0
// if event = 109 then
21795: LD_VAR 0 1
21799: PUSH
21800: LD_INT 109
21802: EQUAL
21803: IFFALSE 21809
// MC_ProduceVehicle ( ) ;
21805: CALL 32983 0 0
// if event = 110 then
21809: LD_VAR 0 1
21813: PUSH
21814: LD_INT 110
21816: EQUAL
21817: IFFALSE 21823
// MC_SendAttack ( ) ;
21819: CALL 33449 0 0
// if event = 111 then
21823: LD_VAR 0 1
21827: PUSH
21828: LD_INT 111
21830: EQUAL
21831: IFFALSE 21837
// MC_Defend ( ) ;
21833: CALL 33557 0 0
// if event = 112 then
21837: LD_VAR 0 1
21841: PUSH
21842: LD_INT 112
21844: EQUAL
21845: IFFALSE 21851
// MC_Research ( ) ;
21847: CALL 34279 0 0
// if event = 113 then
21851: LD_VAR 0 1
21855: PUSH
21856: LD_INT 113
21858: EQUAL
21859: IFFALSE 21865
// MC_MinesTrigger ( ) ;
21861: CALL 35393 0 0
// if event = 120 then
21865: LD_VAR 0 1
21869: PUSH
21870: LD_INT 120
21872: EQUAL
21873: IFFALSE 21879
// MC_RepairVehicle ( ) ;
21875: CALL 35492 0 0
// if event = 121 then
21879: LD_VAR 0 1
21883: PUSH
21884: LD_INT 121
21886: EQUAL
21887: IFFALSE 21893
// MC_TameApe ( ) ;
21889: CALL 36222 0 0
// if event = 122 then
21893: LD_VAR 0 1
21897: PUSH
21898: LD_INT 122
21900: EQUAL
21901: IFFALSE 21907
// MC_ChangeApeClass ( ) ;
21903: CALL 37051 0 0
// if event = 123 then
21907: LD_VAR 0 1
21911: PUSH
21912: LD_INT 123
21914: EQUAL
21915: IFFALSE 21921
// MC_Bazooka ( ) ;
21917: CALL 37701 0 0
// if event = 124 then
21921: LD_VAR 0 1
21925: PUSH
21926: LD_INT 124
21928: EQUAL
21929: IFFALSE 21935
// MC_TeleportExit ( ) ;
21931: CALL 37899 0 0
// if event = 125 then
21935: LD_VAR 0 1
21939: PUSH
21940: LD_INT 125
21942: EQUAL
21943: IFFALSE 21949
// MC_Deposits ( ) ;
21945: CALL 38546 0 0
// if event = 126 then
21949: LD_VAR 0 1
21953: PUSH
21954: LD_INT 126
21956: EQUAL
21957: IFFALSE 21963
// MC_RemoteDriver ( ) ;
21959: CALL 39171 0 0
// if event = 200 then
21963: LD_VAR 0 1
21967: PUSH
21968: LD_INT 200
21970: EQUAL
21971: IFFALSE 21977
// MC_Idle ( ) ;
21973: CALL 41120 0 0
// end ;
21977: PPOPN 1
21979: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
// if not mc_bases [ base ] or not tag then
21984: LD_EXP 50
21988: PUSH
21989: LD_VAR 0 1
21993: ARRAY
21994: NOT
21995: PUSH
21996: LD_VAR 0 2
22000: NOT
22001: OR
22002: IFFALSE 22006
// exit ;
22004: GO 22070
// for i in mc_bases [ base ] union mc_ape [ base ] do
22006: LD_ADDR_VAR 0 4
22010: PUSH
22011: LD_EXP 50
22015: PUSH
22016: LD_VAR 0 1
22020: ARRAY
22021: PUSH
22022: LD_EXP 79
22026: PUSH
22027: LD_VAR 0 1
22031: ARRAY
22032: UNION
22033: PUSH
22034: FOR_IN
22035: IFFALSE 22068
// if GetTag ( i ) = tag then
22037: LD_VAR 0 4
22041: PPUSH
22042: CALL_OW 110
22046: PUSH
22047: LD_VAR 0 2
22051: EQUAL
22052: IFFALSE 22066
// SetTag ( i , 0 ) ;
22054: LD_VAR 0 4
22058: PPUSH
22059: LD_INT 0
22061: PPUSH
22062: CALL_OW 109
22066: GO 22034
22068: POP
22069: POP
// end ;
22070: LD_VAR 0 3
22074: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22075: LD_INT 0
22077: PPUSH
22078: PPUSH
22079: PPUSH
22080: PPUSH
22081: PPUSH
22082: PPUSH
22083: PPUSH
22084: PPUSH
// if not mc_bases then
22085: LD_EXP 50
22089: NOT
22090: IFFALSE 22094
// exit ;
22092: GO 22552
// for i = 1 to mc_bases do
22094: LD_ADDR_VAR 0 2
22098: PUSH
22099: DOUBLE
22100: LD_INT 1
22102: DEC
22103: ST_TO_ADDR
22104: LD_EXP 50
22108: PUSH
22109: FOR_TO
22110: IFFALSE 22550
// begin tmp := MC_ClassCheckReq ( i ) ;
22112: LD_ADDR_VAR 0 4
22116: PUSH
22117: LD_VAR 0 2
22121: PPUSH
22122: CALL 22557 0 1
22126: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22127: LD_ADDR_EXP 91
22131: PUSH
22132: LD_EXP 91
22136: PPUSH
22137: LD_VAR 0 2
22141: PPUSH
22142: LD_VAR 0 4
22146: PPUSH
22147: CALL_OW 1
22151: ST_TO_ADDR
// if not tmp then
22152: LD_VAR 0 4
22156: NOT
22157: IFFALSE 22161
// continue ;
22159: GO 22109
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22161: LD_ADDR_VAR 0 6
22165: PUSH
22166: LD_EXP 50
22170: PUSH
22171: LD_VAR 0 2
22175: ARRAY
22176: PPUSH
22177: LD_INT 2
22179: PUSH
22180: LD_INT 30
22182: PUSH
22183: LD_INT 4
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: PUSH
22190: LD_INT 30
22192: PUSH
22193: LD_INT 5
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: PPUSH
22205: CALL_OW 72
22209: PUSH
22210: LD_EXP 50
22214: PUSH
22215: LD_VAR 0 2
22219: ARRAY
22220: PPUSH
22221: LD_INT 2
22223: PUSH
22224: LD_INT 30
22226: PUSH
22227: LD_INT 0
22229: PUSH
22230: EMPTY
22231: LIST
22232: LIST
22233: PUSH
22234: LD_INT 30
22236: PUSH
22237: LD_INT 1
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: LIST
22248: PPUSH
22249: CALL_OW 72
22253: PUSH
22254: LD_EXP 50
22258: PUSH
22259: LD_VAR 0 2
22263: ARRAY
22264: PPUSH
22265: LD_INT 30
22267: PUSH
22268: LD_INT 3
22270: PUSH
22271: EMPTY
22272: LIST
22273: LIST
22274: PPUSH
22275: CALL_OW 72
22279: PUSH
22280: LD_EXP 50
22284: PUSH
22285: LD_VAR 0 2
22289: ARRAY
22290: PPUSH
22291: LD_INT 2
22293: PUSH
22294: LD_INT 30
22296: PUSH
22297: LD_INT 6
22299: PUSH
22300: EMPTY
22301: LIST
22302: LIST
22303: PUSH
22304: LD_INT 30
22306: PUSH
22307: LD_INT 7
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 30
22316: PUSH
22317: LD_INT 8
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 72
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: LIST
22339: LIST
22340: ST_TO_ADDR
// for j = 1 to 4 do
22341: LD_ADDR_VAR 0 3
22345: PUSH
22346: DOUBLE
22347: LD_INT 1
22349: DEC
22350: ST_TO_ADDR
22351: LD_INT 4
22353: PUSH
22354: FOR_TO
22355: IFFALSE 22546
// begin if not tmp [ j ] then
22357: LD_VAR 0 4
22361: PUSH
22362: LD_VAR 0 3
22366: ARRAY
22367: NOT
22368: IFFALSE 22372
// continue ;
22370: GO 22354
// for p in tmp [ j ] do
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 4
22381: PUSH
22382: LD_VAR 0 3
22386: ARRAY
22387: PUSH
22388: FOR_IN
22389: IFFALSE 22542
// begin if not b [ j ] then
22391: LD_VAR 0 6
22395: PUSH
22396: LD_VAR 0 3
22400: ARRAY
22401: NOT
22402: IFFALSE 22406
// break ;
22404: GO 22542
// e := 0 ;
22406: LD_ADDR_VAR 0 7
22410: PUSH
22411: LD_INT 0
22413: ST_TO_ADDR
// for k in b [ j ] do
22414: LD_ADDR_VAR 0 8
22418: PUSH
22419: LD_VAR 0 6
22423: PUSH
22424: LD_VAR 0 3
22428: ARRAY
22429: PUSH
22430: FOR_IN
22431: IFFALSE 22458
// if IsNotFull ( k ) then
22433: LD_VAR 0 8
22437: PPUSH
22438: CALL 50320 0 1
22442: IFFALSE 22456
// begin e := k ;
22444: LD_ADDR_VAR 0 7
22448: PUSH
22449: LD_VAR 0 8
22453: ST_TO_ADDR
// break ;
22454: GO 22458
// end ;
22456: GO 22430
22458: POP
22459: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22460: LD_VAR 0 7
22464: PUSH
22465: LD_VAR 0 5
22469: PPUSH
22470: LD_VAR 0 7
22474: PPUSH
22475: CALL 83073 0 2
22479: NOT
22480: AND
22481: IFFALSE 22540
// begin if IsInUnit ( p ) then
22483: LD_VAR 0 5
22487: PPUSH
22488: CALL_OW 310
22492: IFFALSE 22503
// ComExitBuilding ( p ) ;
22494: LD_VAR 0 5
22498: PPUSH
22499: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22503: LD_VAR 0 5
22507: PPUSH
22508: LD_VAR 0 7
22512: PPUSH
22513: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22517: LD_VAR 0 5
22521: PPUSH
22522: LD_VAR 0 3
22526: PPUSH
22527: CALL_OW 183
// AddComExitBuilding ( p ) ;
22531: LD_VAR 0 5
22535: PPUSH
22536: CALL_OW 182
// end ; end ;
22540: GO 22388
22542: POP
22543: POP
// end ;
22544: GO 22354
22546: POP
22547: POP
// end ;
22548: GO 22109
22550: POP
22551: POP
// end ;
22552: LD_VAR 0 1
22556: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22557: LD_INT 0
22559: PPUSH
22560: PPUSH
22561: PPUSH
22562: PPUSH
22563: PPUSH
22564: PPUSH
22565: PPUSH
22566: PPUSH
22567: PPUSH
22568: PPUSH
22569: PPUSH
22570: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22571: LD_VAR 0 1
22575: NOT
22576: PUSH
22577: LD_EXP 50
22581: PUSH
22582: LD_VAR 0 1
22586: ARRAY
22587: NOT
22588: OR
22589: PUSH
22590: LD_EXP 50
22594: PUSH
22595: LD_VAR 0 1
22599: ARRAY
22600: PPUSH
22601: LD_INT 2
22603: PUSH
22604: LD_INT 30
22606: PUSH
22607: LD_INT 0
22609: PUSH
22610: EMPTY
22611: LIST
22612: LIST
22613: PUSH
22614: LD_INT 30
22616: PUSH
22617: LD_INT 1
22619: PUSH
22620: EMPTY
22621: LIST
22622: LIST
22623: PUSH
22624: EMPTY
22625: LIST
22626: LIST
22627: LIST
22628: PPUSH
22629: CALL_OW 72
22633: NOT
22634: OR
22635: IFFALSE 22639
// exit ;
22637: GO 26142
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22639: LD_ADDR_VAR 0 4
22643: PUSH
22644: LD_EXP 50
22648: PUSH
22649: LD_VAR 0 1
22653: ARRAY
22654: PPUSH
22655: LD_INT 2
22657: PUSH
22658: LD_INT 25
22660: PUSH
22661: LD_INT 1
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 25
22670: PUSH
22671: LD_INT 2
22673: PUSH
22674: EMPTY
22675: LIST
22676: LIST
22677: PUSH
22678: LD_INT 25
22680: PUSH
22681: LD_INT 3
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 25
22690: PUSH
22691: LD_INT 4
22693: PUSH
22694: EMPTY
22695: LIST
22696: LIST
22697: PUSH
22698: LD_INT 25
22700: PUSH
22701: LD_INT 5
22703: PUSH
22704: EMPTY
22705: LIST
22706: LIST
22707: PUSH
22708: LD_INT 25
22710: PUSH
22711: LD_INT 8
22713: PUSH
22714: EMPTY
22715: LIST
22716: LIST
22717: PUSH
22718: LD_INT 25
22720: PUSH
22721: LD_INT 9
22723: PUSH
22724: EMPTY
22725: LIST
22726: LIST
22727: PUSH
22728: EMPTY
22729: LIST
22730: LIST
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: LIST
22736: LIST
22737: PPUSH
22738: CALL_OW 72
22742: ST_TO_ADDR
// if not tmp then
22743: LD_VAR 0 4
22747: NOT
22748: IFFALSE 22752
// exit ;
22750: GO 26142
// for i in tmp do
22752: LD_ADDR_VAR 0 3
22756: PUSH
22757: LD_VAR 0 4
22761: PUSH
22762: FOR_IN
22763: IFFALSE 22794
// if GetTag ( i ) then
22765: LD_VAR 0 3
22769: PPUSH
22770: CALL_OW 110
22774: IFFALSE 22792
// tmp := tmp diff i ;
22776: LD_ADDR_VAR 0 4
22780: PUSH
22781: LD_VAR 0 4
22785: PUSH
22786: LD_VAR 0 3
22790: DIFF
22791: ST_TO_ADDR
22792: GO 22762
22794: POP
22795: POP
// if not tmp then
22796: LD_VAR 0 4
22800: NOT
22801: IFFALSE 22805
// exit ;
22803: GO 26142
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22805: LD_ADDR_VAR 0 5
22809: PUSH
22810: LD_EXP 50
22814: PUSH
22815: LD_VAR 0 1
22819: ARRAY
22820: PPUSH
22821: LD_INT 2
22823: PUSH
22824: LD_INT 25
22826: PUSH
22827: LD_INT 1
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: PUSH
22834: LD_INT 25
22836: PUSH
22837: LD_INT 5
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PUSH
22844: LD_INT 25
22846: PUSH
22847: LD_INT 8
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: LD_INT 25
22856: PUSH
22857: LD_INT 9
22859: PUSH
22860: EMPTY
22861: LIST
22862: LIST
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: LIST
22868: LIST
22869: LIST
22870: PPUSH
22871: CALL_OW 72
22875: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22876: LD_ADDR_VAR 0 6
22880: PUSH
22881: LD_EXP 50
22885: PUSH
22886: LD_VAR 0 1
22890: ARRAY
22891: PPUSH
22892: LD_INT 25
22894: PUSH
22895: LD_INT 2
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: PPUSH
22902: CALL_OW 72
22906: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22907: LD_ADDR_VAR 0 7
22911: PUSH
22912: LD_EXP 50
22916: PUSH
22917: LD_VAR 0 1
22921: ARRAY
22922: PPUSH
22923: LD_INT 25
22925: PUSH
22926: LD_INT 3
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: PPUSH
22933: CALL_OW 72
22937: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22938: LD_ADDR_VAR 0 8
22942: PUSH
22943: LD_EXP 50
22947: PUSH
22948: LD_VAR 0 1
22952: ARRAY
22953: PPUSH
22954: LD_INT 25
22956: PUSH
22957: LD_INT 4
22959: PUSH
22960: EMPTY
22961: LIST
22962: LIST
22963: PUSH
22964: LD_INT 24
22966: PUSH
22967: LD_INT 251
22969: PUSH
22970: EMPTY
22971: LIST
22972: LIST
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: PPUSH
22978: CALL_OW 72
22982: ST_TO_ADDR
// if mc_scan [ base ] then
22983: LD_EXP 73
22987: PUSH
22988: LD_VAR 0 1
22992: ARRAY
22993: IFFALSE 23454
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22995: LD_ADDR_EXP 92
22999: PUSH
23000: LD_EXP 92
23004: PPUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: LD_INT 4
23012: PPUSH
23013: CALL_OW 1
23017: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23018: LD_ADDR_VAR 0 12
23022: PUSH
23023: LD_EXP 50
23027: PUSH
23028: LD_VAR 0 1
23032: ARRAY
23033: PPUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 4
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 5
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: LIST
23061: PPUSH
23062: CALL_OW 72
23066: ST_TO_ADDR
// if not b then
23067: LD_VAR 0 12
23071: NOT
23072: IFFALSE 23076
// exit ;
23074: GO 26142
// p := [ ] ;
23076: LD_ADDR_VAR 0 11
23080: PUSH
23081: EMPTY
23082: ST_TO_ADDR
// if sci >= 2 then
23083: LD_VAR 0 8
23087: PUSH
23088: LD_INT 2
23090: GREATEREQUAL
23091: IFFALSE 23122
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23093: LD_ADDR_VAR 0 8
23097: PUSH
23098: LD_VAR 0 8
23102: PUSH
23103: LD_INT 1
23105: ARRAY
23106: PUSH
23107: LD_VAR 0 8
23111: PUSH
23112: LD_INT 2
23114: ARRAY
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: ST_TO_ADDR
23120: GO 23183
// if sci = 1 then
23122: LD_VAR 0 8
23126: PUSH
23127: LD_INT 1
23129: EQUAL
23130: IFFALSE 23151
// sci := [ sci [ 1 ] ] else
23132: LD_ADDR_VAR 0 8
23136: PUSH
23137: LD_VAR 0 8
23141: PUSH
23142: LD_INT 1
23144: ARRAY
23145: PUSH
23146: EMPTY
23147: LIST
23148: ST_TO_ADDR
23149: GO 23183
// if sci = 0 then
23151: LD_VAR 0 8
23155: PUSH
23156: LD_INT 0
23158: EQUAL
23159: IFFALSE 23183
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23161: LD_ADDR_VAR 0 11
23165: PUSH
23166: LD_VAR 0 4
23170: PPUSH
23171: LD_INT 4
23173: PPUSH
23174: CALL 82936 0 2
23178: PUSH
23179: LD_INT 1
23181: ARRAY
23182: ST_TO_ADDR
// if eng > 4 then
23183: LD_VAR 0 6
23187: PUSH
23188: LD_INT 4
23190: GREATER
23191: IFFALSE 23237
// for i = eng downto 4 do
23193: LD_ADDR_VAR 0 3
23197: PUSH
23198: DOUBLE
23199: LD_VAR 0 6
23203: INC
23204: ST_TO_ADDR
23205: LD_INT 4
23207: PUSH
23208: FOR_DOWNTO
23209: IFFALSE 23235
// eng := eng diff eng [ i ] ;
23211: LD_ADDR_VAR 0 6
23215: PUSH
23216: LD_VAR 0 6
23220: PUSH
23221: LD_VAR 0 6
23225: PUSH
23226: LD_VAR 0 3
23230: ARRAY
23231: DIFF
23232: ST_TO_ADDR
23233: GO 23208
23235: POP
23236: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23237: LD_ADDR_VAR 0 4
23241: PUSH
23242: LD_VAR 0 4
23246: PUSH
23247: LD_VAR 0 5
23251: PUSH
23252: LD_VAR 0 6
23256: UNION
23257: PUSH
23258: LD_VAR 0 7
23262: UNION
23263: PUSH
23264: LD_VAR 0 8
23268: UNION
23269: DIFF
23270: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23271: LD_ADDR_VAR 0 13
23275: PUSH
23276: LD_EXP 50
23280: PUSH
23281: LD_VAR 0 1
23285: ARRAY
23286: PPUSH
23287: LD_INT 2
23289: PUSH
23290: LD_INT 30
23292: PUSH
23293: LD_INT 32
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: PUSH
23300: LD_INT 30
23302: PUSH
23303: LD_INT 31
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: LIST
23314: PPUSH
23315: CALL_OW 72
23319: PUSH
23320: LD_EXP 50
23324: PUSH
23325: LD_VAR 0 1
23329: ARRAY
23330: PPUSH
23331: LD_INT 2
23333: PUSH
23334: LD_INT 30
23336: PUSH
23337: LD_INT 4
23339: PUSH
23340: EMPTY
23341: LIST
23342: LIST
23343: PUSH
23344: LD_INT 30
23346: PUSH
23347: LD_INT 5
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: LIST
23358: PPUSH
23359: CALL_OW 72
23363: PUSH
23364: LD_INT 6
23366: MUL
23367: PLUS
23368: ST_TO_ADDR
// if bcount < tmp then
23369: LD_VAR 0 13
23373: PUSH
23374: LD_VAR 0 4
23378: LESS
23379: IFFALSE 23425
// for i = tmp downto bcount do
23381: LD_ADDR_VAR 0 3
23385: PUSH
23386: DOUBLE
23387: LD_VAR 0 4
23391: INC
23392: ST_TO_ADDR
23393: LD_VAR 0 13
23397: PUSH
23398: FOR_DOWNTO
23399: IFFALSE 23423
// tmp := Delete ( tmp , tmp ) ;
23401: LD_ADDR_VAR 0 4
23405: PUSH
23406: LD_VAR 0 4
23410: PPUSH
23411: LD_VAR 0 4
23415: PPUSH
23416: CALL_OW 3
23420: ST_TO_ADDR
23421: GO 23398
23423: POP
23424: POP
// result := [ tmp , 0 , 0 , p ] ;
23425: LD_ADDR_VAR 0 2
23429: PUSH
23430: LD_VAR 0 4
23434: PUSH
23435: LD_INT 0
23437: PUSH
23438: LD_INT 0
23440: PUSH
23441: LD_VAR 0 11
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: ST_TO_ADDR
// exit ;
23452: GO 26142
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23454: LD_EXP 50
23458: PUSH
23459: LD_VAR 0 1
23463: ARRAY
23464: PPUSH
23465: LD_INT 2
23467: PUSH
23468: LD_INT 30
23470: PUSH
23471: LD_INT 6
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: PUSH
23478: LD_INT 30
23480: PUSH
23481: LD_INT 7
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: PUSH
23488: LD_INT 30
23490: PUSH
23491: LD_INT 8
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: NOT
23509: PUSH
23510: LD_EXP 50
23514: PUSH
23515: LD_VAR 0 1
23519: ARRAY
23520: PPUSH
23521: LD_INT 30
23523: PUSH
23524: LD_INT 3
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PPUSH
23531: CALL_OW 72
23535: NOT
23536: AND
23537: IFFALSE 23609
// begin if eng = tmp then
23539: LD_VAR 0 6
23543: PUSH
23544: LD_VAR 0 4
23548: EQUAL
23549: IFFALSE 23553
// exit ;
23551: GO 26142
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23553: LD_ADDR_EXP 92
23557: PUSH
23558: LD_EXP 92
23562: PPUSH
23563: LD_VAR 0 1
23567: PPUSH
23568: LD_INT 1
23570: PPUSH
23571: CALL_OW 1
23575: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23576: LD_ADDR_VAR 0 2
23580: PUSH
23581: LD_INT 0
23583: PUSH
23584: LD_VAR 0 4
23588: PUSH
23589: LD_VAR 0 6
23593: DIFF
23594: PUSH
23595: LD_INT 0
23597: PUSH
23598: LD_INT 0
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: ST_TO_ADDR
// exit ;
23607: GO 26142
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23609: LD_EXP 77
23613: PUSH
23614: LD_EXP 76
23618: PUSH
23619: LD_VAR 0 1
23623: ARRAY
23624: ARRAY
23625: PUSH
23626: LD_EXP 50
23630: PUSH
23631: LD_VAR 0 1
23635: ARRAY
23636: PPUSH
23637: LD_INT 2
23639: PUSH
23640: LD_INT 30
23642: PUSH
23643: LD_INT 6
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 7
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 8
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: PPUSH
23676: CALL_OW 72
23680: AND
23681: PUSH
23682: LD_EXP 50
23686: PUSH
23687: LD_VAR 0 1
23691: ARRAY
23692: PPUSH
23693: LD_INT 30
23695: PUSH
23696: LD_INT 3
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PPUSH
23703: CALL_OW 72
23707: NOT
23708: AND
23709: IFFALSE 23923
// begin if sci >= 6 then
23711: LD_VAR 0 8
23715: PUSH
23716: LD_INT 6
23718: GREATEREQUAL
23719: IFFALSE 23723
// exit ;
23721: GO 26142
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23723: LD_ADDR_EXP 92
23727: PUSH
23728: LD_EXP 92
23732: PPUSH
23733: LD_VAR 0 1
23737: PPUSH
23738: LD_INT 2
23740: PPUSH
23741: CALL_OW 1
23745: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23746: LD_ADDR_VAR 0 9
23750: PUSH
23751: LD_VAR 0 4
23755: PUSH
23756: LD_VAR 0 8
23760: DIFF
23761: PPUSH
23762: LD_INT 4
23764: PPUSH
23765: CALL 82936 0 2
23769: ST_TO_ADDR
// p := [ ] ;
23770: LD_ADDR_VAR 0 11
23774: PUSH
23775: EMPTY
23776: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23777: LD_VAR 0 8
23781: PUSH
23782: LD_INT 6
23784: LESS
23785: PUSH
23786: LD_VAR 0 9
23790: PUSH
23791: LD_INT 6
23793: GREATER
23794: AND
23795: IFFALSE 23876
// begin for i = 1 to 6 - sci do
23797: LD_ADDR_VAR 0 3
23801: PUSH
23802: DOUBLE
23803: LD_INT 1
23805: DEC
23806: ST_TO_ADDR
23807: LD_INT 6
23809: PUSH
23810: LD_VAR 0 8
23814: MINUS
23815: PUSH
23816: FOR_TO
23817: IFFALSE 23872
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23819: LD_ADDR_VAR 0 11
23823: PUSH
23824: LD_VAR 0 11
23828: PPUSH
23829: LD_VAR 0 11
23833: PUSH
23834: LD_INT 1
23836: PLUS
23837: PPUSH
23838: LD_VAR 0 9
23842: PUSH
23843: LD_INT 1
23845: ARRAY
23846: PPUSH
23847: CALL_OW 2
23851: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23852: LD_ADDR_VAR 0 9
23856: PUSH
23857: LD_VAR 0 9
23861: PPUSH
23862: LD_INT 1
23864: PPUSH
23865: CALL_OW 3
23869: ST_TO_ADDR
// end ;
23870: GO 23816
23872: POP
23873: POP
// end else
23874: GO 23896
// if sort then
23876: LD_VAR 0 9
23880: IFFALSE 23896
// p := sort [ 1 ] ;
23882: LD_ADDR_VAR 0 11
23886: PUSH
23887: LD_VAR 0 9
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23896: LD_ADDR_VAR 0 2
23900: PUSH
23901: LD_INT 0
23903: PUSH
23904: LD_INT 0
23906: PUSH
23907: LD_INT 0
23909: PUSH
23910: LD_VAR 0 11
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: LIST
23919: LIST
23920: ST_TO_ADDR
// exit ;
23921: GO 26142
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23923: LD_EXP 77
23927: PUSH
23928: LD_EXP 76
23932: PUSH
23933: LD_VAR 0 1
23937: ARRAY
23938: ARRAY
23939: PUSH
23940: LD_EXP 50
23944: PUSH
23945: LD_VAR 0 1
23949: ARRAY
23950: PPUSH
23951: LD_INT 2
23953: PUSH
23954: LD_INT 30
23956: PUSH
23957: LD_INT 6
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: LD_INT 30
23966: PUSH
23967: LD_INT 7
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 30
23976: PUSH
23977: LD_INT 8
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: LIST
23989: PPUSH
23990: CALL_OW 72
23994: AND
23995: PUSH
23996: LD_EXP 50
24000: PUSH
24001: LD_VAR 0 1
24005: ARRAY
24006: PPUSH
24007: LD_INT 30
24009: PUSH
24010: LD_INT 3
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: PPUSH
24017: CALL_OW 72
24021: AND
24022: IFFALSE 24756
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24024: LD_ADDR_EXP 92
24028: PUSH
24029: LD_EXP 92
24033: PPUSH
24034: LD_VAR 0 1
24038: PPUSH
24039: LD_INT 3
24041: PPUSH
24042: CALL_OW 1
24046: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24047: LD_ADDR_VAR 0 2
24051: PUSH
24052: LD_INT 0
24054: PUSH
24055: LD_INT 0
24057: PUSH
24058: LD_INT 0
24060: PUSH
24061: LD_INT 0
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: LIST
24068: LIST
24069: ST_TO_ADDR
// if not eng then
24070: LD_VAR 0 6
24074: NOT
24075: IFFALSE 24138
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24077: LD_ADDR_VAR 0 11
24081: PUSH
24082: LD_VAR 0 4
24086: PPUSH
24087: LD_INT 2
24089: PPUSH
24090: CALL 82936 0 2
24094: PUSH
24095: LD_INT 1
24097: ARRAY
24098: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24099: LD_ADDR_VAR 0 2
24103: PUSH
24104: LD_VAR 0 2
24108: PPUSH
24109: LD_INT 2
24111: PPUSH
24112: LD_VAR 0 11
24116: PPUSH
24117: CALL_OW 1
24121: ST_TO_ADDR
// tmp := tmp diff p ;
24122: LD_ADDR_VAR 0 4
24126: PUSH
24127: LD_VAR 0 4
24131: PUSH
24132: LD_VAR 0 11
24136: DIFF
24137: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24138: LD_VAR 0 4
24142: PUSH
24143: LD_VAR 0 8
24147: PUSH
24148: LD_INT 6
24150: LESS
24151: AND
24152: IFFALSE 24340
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24154: LD_ADDR_VAR 0 9
24158: PUSH
24159: LD_VAR 0 4
24163: PUSH
24164: LD_VAR 0 8
24168: PUSH
24169: LD_VAR 0 7
24173: UNION
24174: DIFF
24175: PPUSH
24176: LD_INT 4
24178: PPUSH
24179: CALL 82936 0 2
24183: ST_TO_ADDR
// p := [ ] ;
24184: LD_ADDR_VAR 0 11
24188: PUSH
24189: EMPTY
24190: ST_TO_ADDR
// if sort then
24191: LD_VAR 0 9
24195: IFFALSE 24311
// for i = 1 to 6 - sci do
24197: LD_ADDR_VAR 0 3
24201: PUSH
24202: DOUBLE
24203: LD_INT 1
24205: DEC
24206: ST_TO_ADDR
24207: LD_INT 6
24209: PUSH
24210: LD_VAR 0 8
24214: MINUS
24215: PUSH
24216: FOR_TO
24217: IFFALSE 24309
// begin if i = sort then
24219: LD_VAR 0 3
24223: PUSH
24224: LD_VAR 0 9
24228: EQUAL
24229: IFFALSE 24233
// break ;
24231: GO 24309
// if GetClass ( i ) = 4 then
24233: LD_VAR 0 3
24237: PPUSH
24238: CALL_OW 257
24242: PUSH
24243: LD_INT 4
24245: EQUAL
24246: IFFALSE 24250
// continue ;
24248: GO 24216
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24250: LD_ADDR_VAR 0 11
24254: PUSH
24255: LD_VAR 0 11
24259: PPUSH
24260: LD_VAR 0 11
24264: PUSH
24265: LD_INT 1
24267: PLUS
24268: PPUSH
24269: LD_VAR 0 9
24273: PUSH
24274: LD_VAR 0 3
24278: ARRAY
24279: PPUSH
24280: CALL_OW 2
24284: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24285: LD_ADDR_VAR 0 4
24289: PUSH
24290: LD_VAR 0 4
24294: PUSH
24295: LD_VAR 0 9
24299: PUSH
24300: LD_VAR 0 3
24304: ARRAY
24305: DIFF
24306: ST_TO_ADDR
// end ;
24307: GO 24216
24309: POP
24310: POP
// if p then
24311: LD_VAR 0 11
24315: IFFALSE 24340
// result := Replace ( result , 4 , p ) ;
24317: LD_ADDR_VAR 0 2
24321: PUSH
24322: LD_VAR 0 2
24326: PPUSH
24327: LD_INT 4
24329: PPUSH
24330: LD_VAR 0 11
24334: PPUSH
24335: CALL_OW 1
24339: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24340: LD_VAR 0 4
24344: PUSH
24345: LD_VAR 0 7
24349: PUSH
24350: LD_INT 6
24352: LESS
24353: AND
24354: IFFALSE 24542
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_VAR 0 4
24365: PUSH
24366: LD_VAR 0 8
24370: PUSH
24371: LD_VAR 0 7
24375: UNION
24376: DIFF
24377: PPUSH
24378: LD_INT 3
24380: PPUSH
24381: CALL 82936 0 2
24385: ST_TO_ADDR
// p := [ ] ;
24386: LD_ADDR_VAR 0 11
24390: PUSH
24391: EMPTY
24392: ST_TO_ADDR
// if sort then
24393: LD_VAR 0 9
24397: IFFALSE 24513
// for i = 1 to 6 - mech do
24399: LD_ADDR_VAR 0 3
24403: PUSH
24404: DOUBLE
24405: LD_INT 1
24407: DEC
24408: ST_TO_ADDR
24409: LD_INT 6
24411: PUSH
24412: LD_VAR 0 7
24416: MINUS
24417: PUSH
24418: FOR_TO
24419: IFFALSE 24511
// begin if i = sort then
24421: LD_VAR 0 3
24425: PUSH
24426: LD_VAR 0 9
24430: EQUAL
24431: IFFALSE 24435
// break ;
24433: GO 24511
// if GetClass ( i ) = 3 then
24435: LD_VAR 0 3
24439: PPUSH
24440: CALL_OW 257
24444: PUSH
24445: LD_INT 3
24447: EQUAL
24448: IFFALSE 24452
// continue ;
24450: GO 24418
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24452: LD_ADDR_VAR 0 11
24456: PUSH
24457: LD_VAR 0 11
24461: PPUSH
24462: LD_VAR 0 11
24466: PUSH
24467: LD_INT 1
24469: PLUS
24470: PPUSH
24471: LD_VAR 0 9
24475: PUSH
24476: LD_VAR 0 3
24480: ARRAY
24481: PPUSH
24482: CALL_OW 2
24486: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24487: LD_ADDR_VAR 0 4
24491: PUSH
24492: LD_VAR 0 4
24496: PUSH
24497: LD_VAR 0 9
24501: PUSH
24502: LD_VAR 0 3
24506: ARRAY
24507: DIFF
24508: ST_TO_ADDR
// end ;
24509: GO 24418
24511: POP
24512: POP
// if p then
24513: LD_VAR 0 11
24517: IFFALSE 24542
// result := Replace ( result , 3 , p ) ;
24519: LD_ADDR_VAR 0 2
24523: PUSH
24524: LD_VAR 0 2
24528: PPUSH
24529: LD_INT 3
24531: PPUSH
24532: LD_VAR 0 11
24536: PPUSH
24537: CALL_OW 1
24541: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24542: LD_VAR 0 4
24546: PUSH
24547: LD_INT 6
24549: GREATER
24550: PUSH
24551: LD_VAR 0 6
24555: PUSH
24556: LD_INT 6
24558: LESS
24559: AND
24560: IFFALSE 24754
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24562: LD_ADDR_VAR 0 9
24566: PUSH
24567: LD_VAR 0 4
24571: PUSH
24572: LD_VAR 0 8
24576: PUSH
24577: LD_VAR 0 7
24581: UNION
24582: PUSH
24583: LD_VAR 0 6
24587: UNION
24588: DIFF
24589: PPUSH
24590: LD_INT 2
24592: PPUSH
24593: CALL 82936 0 2
24597: ST_TO_ADDR
// p := [ ] ;
24598: LD_ADDR_VAR 0 11
24602: PUSH
24603: EMPTY
24604: ST_TO_ADDR
// if sort then
24605: LD_VAR 0 9
24609: IFFALSE 24725
// for i = 1 to 6 - eng do
24611: LD_ADDR_VAR 0 3
24615: PUSH
24616: DOUBLE
24617: LD_INT 1
24619: DEC
24620: ST_TO_ADDR
24621: LD_INT 6
24623: PUSH
24624: LD_VAR 0 6
24628: MINUS
24629: PUSH
24630: FOR_TO
24631: IFFALSE 24723
// begin if i = sort then
24633: LD_VAR 0 3
24637: PUSH
24638: LD_VAR 0 9
24642: EQUAL
24643: IFFALSE 24647
// break ;
24645: GO 24723
// if GetClass ( i ) = 2 then
24647: LD_VAR 0 3
24651: PPUSH
24652: CALL_OW 257
24656: PUSH
24657: LD_INT 2
24659: EQUAL
24660: IFFALSE 24664
// continue ;
24662: GO 24630
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24664: LD_ADDR_VAR 0 11
24668: PUSH
24669: LD_VAR 0 11
24673: PPUSH
24674: LD_VAR 0 11
24678: PUSH
24679: LD_INT 1
24681: PLUS
24682: PPUSH
24683: LD_VAR 0 9
24687: PUSH
24688: LD_VAR 0 3
24692: ARRAY
24693: PPUSH
24694: CALL_OW 2
24698: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24699: LD_ADDR_VAR 0 4
24703: PUSH
24704: LD_VAR 0 4
24708: PUSH
24709: LD_VAR 0 9
24713: PUSH
24714: LD_VAR 0 3
24718: ARRAY
24719: DIFF
24720: ST_TO_ADDR
// end ;
24721: GO 24630
24723: POP
24724: POP
// if p then
24725: LD_VAR 0 11
24729: IFFALSE 24754
// result := Replace ( result , 2 , p ) ;
24731: LD_ADDR_VAR 0 2
24735: PUSH
24736: LD_VAR 0 2
24740: PPUSH
24741: LD_INT 2
24743: PPUSH
24744: LD_VAR 0 11
24748: PPUSH
24749: CALL_OW 1
24753: ST_TO_ADDR
// end ; exit ;
24754: GO 26142
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24756: LD_EXP 77
24760: PUSH
24761: LD_EXP 76
24765: PUSH
24766: LD_VAR 0 1
24770: ARRAY
24771: ARRAY
24772: NOT
24773: PUSH
24774: LD_EXP 50
24778: PUSH
24779: LD_VAR 0 1
24783: ARRAY
24784: PPUSH
24785: LD_INT 30
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PPUSH
24795: CALL_OW 72
24799: AND
24800: PUSH
24801: LD_EXP 55
24805: PUSH
24806: LD_VAR 0 1
24810: ARRAY
24811: AND
24812: IFFALSE 25420
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24814: LD_ADDR_EXP 92
24818: PUSH
24819: LD_EXP 92
24823: PPUSH
24824: LD_VAR 0 1
24828: PPUSH
24829: LD_INT 5
24831: PPUSH
24832: CALL_OW 1
24836: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24837: LD_ADDR_VAR 0 2
24841: PUSH
24842: LD_INT 0
24844: PUSH
24845: LD_INT 0
24847: PUSH
24848: LD_INT 0
24850: PUSH
24851: LD_INT 0
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: ST_TO_ADDR
// if sci > 1 then
24860: LD_VAR 0 8
24864: PUSH
24865: LD_INT 1
24867: GREATER
24868: IFFALSE 24896
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24870: LD_ADDR_VAR 0 4
24874: PUSH
24875: LD_VAR 0 4
24879: PUSH
24880: LD_VAR 0 8
24884: PUSH
24885: LD_VAR 0 8
24889: PUSH
24890: LD_INT 1
24892: ARRAY
24893: DIFF
24894: DIFF
24895: ST_TO_ADDR
// if tmp and not sci then
24896: LD_VAR 0 4
24900: PUSH
24901: LD_VAR 0 8
24905: NOT
24906: AND
24907: IFFALSE 24976
// begin sort := SortBySkill ( tmp , 4 ) ;
24909: LD_ADDR_VAR 0 9
24913: PUSH
24914: LD_VAR 0 4
24918: PPUSH
24919: LD_INT 4
24921: PPUSH
24922: CALL 82936 0 2
24926: ST_TO_ADDR
// if sort then
24927: LD_VAR 0 9
24931: IFFALSE 24947
// p := sort [ 1 ] ;
24933: LD_ADDR_VAR 0 11
24937: PUSH
24938: LD_VAR 0 9
24942: PUSH
24943: LD_INT 1
24945: ARRAY
24946: ST_TO_ADDR
// if p then
24947: LD_VAR 0 11
24951: IFFALSE 24976
// result := Replace ( result , 4 , p ) ;
24953: LD_ADDR_VAR 0 2
24957: PUSH
24958: LD_VAR 0 2
24962: PPUSH
24963: LD_INT 4
24965: PPUSH
24966: LD_VAR 0 11
24970: PPUSH
24971: CALL_OW 1
24975: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24976: LD_ADDR_VAR 0 4
24980: PUSH
24981: LD_VAR 0 4
24985: PUSH
24986: LD_VAR 0 7
24990: DIFF
24991: ST_TO_ADDR
// if tmp and mech < 6 then
24992: LD_VAR 0 4
24996: PUSH
24997: LD_VAR 0 7
25001: PUSH
25002: LD_INT 6
25004: LESS
25005: AND
25006: IFFALSE 25194
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25008: LD_ADDR_VAR 0 9
25012: PUSH
25013: LD_VAR 0 4
25017: PUSH
25018: LD_VAR 0 8
25022: PUSH
25023: LD_VAR 0 7
25027: UNION
25028: DIFF
25029: PPUSH
25030: LD_INT 3
25032: PPUSH
25033: CALL 82936 0 2
25037: ST_TO_ADDR
// p := [ ] ;
25038: LD_ADDR_VAR 0 11
25042: PUSH
25043: EMPTY
25044: ST_TO_ADDR
// if sort then
25045: LD_VAR 0 9
25049: IFFALSE 25165
// for i = 1 to 6 - mech do
25051: LD_ADDR_VAR 0 3
25055: PUSH
25056: DOUBLE
25057: LD_INT 1
25059: DEC
25060: ST_TO_ADDR
25061: LD_INT 6
25063: PUSH
25064: LD_VAR 0 7
25068: MINUS
25069: PUSH
25070: FOR_TO
25071: IFFALSE 25163
// begin if i = sort then
25073: LD_VAR 0 3
25077: PUSH
25078: LD_VAR 0 9
25082: EQUAL
25083: IFFALSE 25087
// break ;
25085: GO 25163
// if GetClass ( i ) = 3 then
25087: LD_VAR 0 3
25091: PPUSH
25092: CALL_OW 257
25096: PUSH
25097: LD_INT 3
25099: EQUAL
25100: IFFALSE 25104
// continue ;
25102: GO 25070
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25104: LD_ADDR_VAR 0 11
25108: PUSH
25109: LD_VAR 0 11
25113: PPUSH
25114: LD_VAR 0 11
25118: PUSH
25119: LD_INT 1
25121: PLUS
25122: PPUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_VAR 0 3
25132: ARRAY
25133: PPUSH
25134: CALL_OW 2
25138: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25139: LD_ADDR_VAR 0 4
25143: PUSH
25144: LD_VAR 0 4
25148: PUSH
25149: LD_VAR 0 9
25153: PUSH
25154: LD_VAR 0 3
25158: ARRAY
25159: DIFF
25160: ST_TO_ADDR
// end ;
25161: GO 25070
25163: POP
25164: POP
// if p then
25165: LD_VAR 0 11
25169: IFFALSE 25194
// result := Replace ( result , 3 , p ) ;
25171: LD_ADDR_VAR 0 2
25175: PUSH
25176: LD_VAR 0 2
25180: PPUSH
25181: LD_INT 3
25183: PPUSH
25184: LD_VAR 0 11
25188: PPUSH
25189: CALL_OW 1
25193: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25194: LD_ADDR_VAR 0 4
25198: PUSH
25199: LD_VAR 0 4
25203: PUSH
25204: LD_VAR 0 6
25208: DIFF
25209: ST_TO_ADDR
// if tmp and eng < 6 then
25210: LD_VAR 0 4
25214: PUSH
25215: LD_VAR 0 6
25219: PUSH
25220: LD_INT 6
25222: LESS
25223: AND
25224: IFFALSE 25418
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25226: LD_ADDR_VAR 0 9
25230: PUSH
25231: LD_VAR 0 4
25235: PUSH
25236: LD_VAR 0 8
25240: PUSH
25241: LD_VAR 0 7
25245: UNION
25246: PUSH
25247: LD_VAR 0 6
25251: UNION
25252: DIFF
25253: PPUSH
25254: LD_INT 2
25256: PPUSH
25257: CALL 82936 0 2
25261: ST_TO_ADDR
// p := [ ] ;
25262: LD_ADDR_VAR 0 11
25266: PUSH
25267: EMPTY
25268: ST_TO_ADDR
// if sort then
25269: LD_VAR 0 9
25273: IFFALSE 25389
// for i = 1 to 6 - eng do
25275: LD_ADDR_VAR 0 3
25279: PUSH
25280: DOUBLE
25281: LD_INT 1
25283: DEC
25284: ST_TO_ADDR
25285: LD_INT 6
25287: PUSH
25288: LD_VAR 0 6
25292: MINUS
25293: PUSH
25294: FOR_TO
25295: IFFALSE 25387
// begin if i = sort then
25297: LD_VAR 0 3
25301: PUSH
25302: LD_VAR 0 9
25306: EQUAL
25307: IFFALSE 25311
// break ;
25309: GO 25387
// if GetClass ( i ) = 2 then
25311: LD_VAR 0 3
25315: PPUSH
25316: CALL_OW 257
25320: PUSH
25321: LD_INT 2
25323: EQUAL
25324: IFFALSE 25328
// continue ;
25326: GO 25294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25328: LD_ADDR_VAR 0 11
25332: PUSH
25333: LD_VAR 0 11
25337: PPUSH
25338: LD_VAR 0 11
25342: PUSH
25343: LD_INT 1
25345: PLUS
25346: PPUSH
25347: LD_VAR 0 9
25351: PUSH
25352: LD_VAR 0 3
25356: ARRAY
25357: PPUSH
25358: CALL_OW 2
25362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25363: LD_ADDR_VAR 0 4
25367: PUSH
25368: LD_VAR 0 4
25372: PUSH
25373: LD_VAR 0 9
25377: PUSH
25378: LD_VAR 0 3
25382: ARRAY
25383: DIFF
25384: ST_TO_ADDR
// end ;
25385: GO 25294
25387: POP
25388: POP
// if p then
25389: LD_VAR 0 11
25393: IFFALSE 25418
// result := Replace ( result , 2 , p ) ;
25395: LD_ADDR_VAR 0 2
25399: PUSH
25400: LD_VAR 0 2
25404: PPUSH
25405: LD_INT 2
25407: PPUSH
25408: LD_VAR 0 11
25412: PPUSH
25413: CALL_OW 1
25417: ST_TO_ADDR
// end ; exit ;
25418: GO 26142
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25420: LD_EXP 77
25424: PUSH
25425: LD_EXP 76
25429: PUSH
25430: LD_VAR 0 1
25434: ARRAY
25435: ARRAY
25436: NOT
25437: PUSH
25438: LD_EXP 50
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: PPUSH
25449: LD_INT 30
25451: PUSH
25452: LD_INT 3
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: PPUSH
25459: CALL_OW 72
25463: AND
25464: PUSH
25465: LD_EXP 55
25469: PUSH
25470: LD_VAR 0 1
25474: ARRAY
25475: NOT
25476: AND
25477: IFFALSE 26142
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25479: LD_ADDR_EXP 92
25483: PUSH
25484: LD_EXP 92
25488: PPUSH
25489: LD_VAR 0 1
25493: PPUSH
25494: LD_INT 6
25496: PPUSH
25497: CALL_OW 1
25501: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25502: LD_ADDR_VAR 0 2
25506: PUSH
25507: LD_INT 0
25509: PUSH
25510: LD_INT 0
25512: PUSH
25513: LD_INT 0
25515: PUSH
25516: LD_INT 0
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: ST_TO_ADDR
// if sci >= 1 then
25525: LD_VAR 0 8
25529: PUSH
25530: LD_INT 1
25532: GREATEREQUAL
25533: IFFALSE 25555
// tmp := tmp diff sci [ 1 ] ;
25535: LD_ADDR_VAR 0 4
25539: PUSH
25540: LD_VAR 0 4
25544: PUSH
25545: LD_VAR 0 8
25549: PUSH
25550: LD_INT 1
25552: ARRAY
25553: DIFF
25554: ST_TO_ADDR
// if tmp and not sci then
25555: LD_VAR 0 4
25559: PUSH
25560: LD_VAR 0 8
25564: NOT
25565: AND
25566: IFFALSE 25635
// begin sort := SortBySkill ( tmp , 4 ) ;
25568: LD_ADDR_VAR 0 9
25572: PUSH
25573: LD_VAR 0 4
25577: PPUSH
25578: LD_INT 4
25580: PPUSH
25581: CALL 82936 0 2
25585: ST_TO_ADDR
// if sort then
25586: LD_VAR 0 9
25590: IFFALSE 25606
// p := sort [ 1 ] ;
25592: LD_ADDR_VAR 0 11
25596: PUSH
25597: LD_VAR 0 9
25601: PUSH
25602: LD_INT 1
25604: ARRAY
25605: ST_TO_ADDR
// if p then
25606: LD_VAR 0 11
25610: IFFALSE 25635
// result := Replace ( result , 4 , p ) ;
25612: LD_ADDR_VAR 0 2
25616: PUSH
25617: LD_VAR 0 2
25621: PPUSH
25622: LD_INT 4
25624: PPUSH
25625: LD_VAR 0 11
25629: PPUSH
25630: CALL_OW 1
25634: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25635: LD_ADDR_VAR 0 4
25639: PUSH
25640: LD_VAR 0 4
25644: PUSH
25645: LD_VAR 0 7
25649: DIFF
25650: ST_TO_ADDR
// if tmp and mech < 6 then
25651: LD_VAR 0 4
25655: PUSH
25656: LD_VAR 0 7
25660: PUSH
25661: LD_INT 6
25663: LESS
25664: AND
25665: IFFALSE 25847
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25667: LD_ADDR_VAR 0 9
25671: PUSH
25672: LD_VAR 0 4
25676: PUSH
25677: LD_VAR 0 7
25681: DIFF
25682: PPUSH
25683: LD_INT 3
25685: PPUSH
25686: CALL 82936 0 2
25690: ST_TO_ADDR
// p := [ ] ;
25691: LD_ADDR_VAR 0 11
25695: PUSH
25696: EMPTY
25697: ST_TO_ADDR
// if sort then
25698: LD_VAR 0 9
25702: IFFALSE 25818
// for i = 1 to 6 - mech do
25704: LD_ADDR_VAR 0 3
25708: PUSH
25709: DOUBLE
25710: LD_INT 1
25712: DEC
25713: ST_TO_ADDR
25714: LD_INT 6
25716: PUSH
25717: LD_VAR 0 7
25721: MINUS
25722: PUSH
25723: FOR_TO
25724: IFFALSE 25816
// begin if i = sort then
25726: LD_VAR 0 3
25730: PUSH
25731: LD_VAR 0 9
25735: EQUAL
25736: IFFALSE 25740
// break ;
25738: GO 25816
// if GetClass ( i ) = 3 then
25740: LD_VAR 0 3
25744: PPUSH
25745: CALL_OW 257
25749: PUSH
25750: LD_INT 3
25752: EQUAL
25753: IFFALSE 25757
// continue ;
25755: GO 25723
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25757: LD_ADDR_VAR 0 11
25761: PUSH
25762: LD_VAR 0 11
25766: PPUSH
25767: LD_VAR 0 11
25771: PUSH
25772: LD_INT 1
25774: PLUS
25775: PPUSH
25776: LD_VAR 0 9
25780: PUSH
25781: LD_VAR 0 3
25785: ARRAY
25786: PPUSH
25787: CALL_OW 2
25791: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25792: LD_ADDR_VAR 0 4
25796: PUSH
25797: LD_VAR 0 4
25801: PUSH
25802: LD_VAR 0 9
25806: PUSH
25807: LD_VAR 0 3
25811: ARRAY
25812: DIFF
25813: ST_TO_ADDR
// end ;
25814: GO 25723
25816: POP
25817: POP
// if p then
25818: LD_VAR 0 11
25822: IFFALSE 25847
// result := Replace ( result , 3 , p ) ;
25824: LD_ADDR_VAR 0 2
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: LD_INT 3
25836: PPUSH
25837: LD_VAR 0 11
25841: PPUSH
25842: CALL_OW 1
25846: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25847: LD_ADDR_VAR 0 4
25851: PUSH
25852: LD_VAR 0 4
25856: PUSH
25857: LD_VAR 0 6
25861: DIFF
25862: ST_TO_ADDR
// if tmp and eng < 4 then
25863: LD_VAR 0 4
25867: PUSH
25868: LD_VAR 0 6
25872: PUSH
25873: LD_INT 4
25875: LESS
25876: AND
25877: IFFALSE 26067
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25879: LD_ADDR_VAR 0 9
25883: PUSH
25884: LD_VAR 0 4
25888: PUSH
25889: LD_VAR 0 7
25893: PUSH
25894: LD_VAR 0 6
25898: UNION
25899: DIFF
25900: PPUSH
25901: LD_INT 2
25903: PPUSH
25904: CALL 82936 0 2
25908: ST_TO_ADDR
// p := [ ] ;
25909: LD_ADDR_VAR 0 11
25913: PUSH
25914: EMPTY
25915: ST_TO_ADDR
// if sort then
25916: LD_VAR 0 9
25920: IFFALSE 26036
// for i = 1 to 4 - eng do
25922: LD_ADDR_VAR 0 3
25926: PUSH
25927: DOUBLE
25928: LD_INT 1
25930: DEC
25931: ST_TO_ADDR
25932: LD_INT 4
25934: PUSH
25935: LD_VAR 0 6
25939: MINUS
25940: PUSH
25941: FOR_TO
25942: IFFALSE 26034
// begin if i = sort then
25944: LD_VAR 0 3
25948: PUSH
25949: LD_VAR 0 9
25953: EQUAL
25954: IFFALSE 25958
// break ;
25956: GO 26034
// if GetClass ( i ) = 2 then
25958: LD_VAR 0 3
25962: PPUSH
25963: CALL_OW 257
25967: PUSH
25968: LD_INT 2
25970: EQUAL
25971: IFFALSE 25975
// continue ;
25973: GO 25941
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25975: LD_ADDR_VAR 0 11
25979: PUSH
25980: LD_VAR 0 11
25984: PPUSH
25985: LD_VAR 0 11
25989: PUSH
25990: LD_INT 1
25992: PLUS
25993: PPUSH
25994: LD_VAR 0 9
25998: PUSH
25999: LD_VAR 0 3
26003: ARRAY
26004: PPUSH
26005: CALL_OW 2
26009: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26010: LD_ADDR_VAR 0 4
26014: PUSH
26015: LD_VAR 0 4
26019: PUSH
26020: LD_VAR 0 9
26024: PUSH
26025: LD_VAR 0 3
26029: ARRAY
26030: DIFF
26031: ST_TO_ADDR
// end ;
26032: GO 25941
26034: POP
26035: POP
// if p then
26036: LD_VAR 0 11
26040: IFFALSE 26065
// result := Replace ( result , 2 , p ) ;
26042: LD_ADDR_VAR 0 2
26046: PUSH
26047: LD_VAR 0 2
26051: PPUSH
26052: LD_INT 2
26054: PPUSH
26055: LD_VAR 0 11
26059: PPUSH
26060: CALL_OW 1
26064: ST_TO_ADDR
// end else
26065: GO 26111
// for i = eng downto 5 do
26067: LD_ADDR_VAR 0 3
26071: PUSH
26072: DOUBLE
26073: LD_VAR 0 6
26077: INC
26078: ST_TO_ADDR
26079: LD_INT 5
26081: PUSH
26082: FOR_DOWNTO
26083: IFFALSE 26109
// tmp := tmp union eng [ i ] ;
26085: LD_ADDR_VAR 0 4
26089: PUSH
26090: LD_VAR 0 4
26094: PUSH
26095: LD_VAR 0 6
26099: PUSH
26100: LD_VAR 0 3
26104: ARRAY
26105: UNION
26106: ST_TO_ADDR
26107: GO 26082
26109: POP
26110: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26111: LD_ADDR_VAR 0 2
26115: PUSH
26116: LD_VAR 0 2
26120: PPUSH
26121: LD_INT 1
26123: PPUSH
26124: LD_VAR 0 4
26128: PUSH
26129: LD_VAR 0 5
26133: DIFF
26134: PPUSH
26135: CALL_OW 1
26139: ST_TO_ADDR
// exit ;
26140: GO 26142
// end ; end ;
26142: LD_VAR 0 2
26146: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26147: LD_INT 0
26149: PPUSH
26150: PPUSH
26151: PPUSH
// if not mc_bases then
26152: LD_EXP 50
26156: NOT
26157: IFFALSE 26161
// exit ;
26159: GO 26267
// for i = 1 to mc_bases do
26161: LD_ADDR_VAR 0 2
26165: PUSH
26166: DOUBLE
26167: LD_INT 1
26169: DEC
26170: ST_TO_ADDR
26171: LD_EXP 50
26175: PUSH
26176: FOR_TO
26177: IFFALSE 26258
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26179: LD_ADDR_VAR 0 3
26183: PUSH
26184: LD_EXP 50
26188: PUSH
26189: LD_VAR 0 2
26193: ARRAY
26194: PPUSH
26195: LD_INT 21
26197: PUSH
26198: LD_INT 3
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: PUSH
26205: LD_INT 3
26207: PUSH
26208: LD_INT 24
26210: PUSH
26211: LD_INT 1000
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PPUSH
26226: CALL_OW 72
26230: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26231: LD_ADDR_EXP 51
26235: PUSH
26236: LD_EXP 51
26240: PPUSH
26241: LD_VAR 0 2
26245: PPUSH
26246: LD_VAR 0 3
26250: PPUSH
26251: CALL_OW 1
26255: ST_TO_ADDR
// end ;
26256: GO 26176
26258: POP
26259: POP
// RaiseSailEvent ( 101 ) ;
26260: LD_INT 101
26262: PPUSH
26263: CALL_OW 427
// end ;
26267: LD_VAR 0 1
26271: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26272: LD_INT 0
26274: PPUSH
26275: PPUSH
26276: PPUSH
26277: PPUSH
26278: PPUSH
26279: PPUSH
26280: PPUSH
// if not mc_bases then
26281: LD_EXP 50
26285: NOT
26286: IFFALSE 26290
// exit ;
26288: GO 26852
// for i = 1 to mc_bases do
26290: LD_ADDR_VAR 0 2
26294: PUSH
26295: DOUBLE
26296: LD_INT 1
26298: DEC
26299: ST_TO_ADDR
26300: LD_EXP 50
26304: PUSH
26305: FOR_TO
26306: IFFALSE 26843
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26308: LD_ADDR_VAR 0 5
26312: PUSH
26313: LD_EXP 50
26317: PUSH
26318: LD_VAR 0 2
26322: ARRAY
26323: PUSH
26324: LD_EXP 79
26328: PUSH
26329: LD_VAR 0 2
26333: ARRAY
26334: UNION
26335: PPUSH
26336: LD_INT 21
26338: PUSH
26339: LD_INT 1
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: LD_INT 3
26351: PUSH
26352: LD_INT 54
26354: PUSH
26355: EMPTY
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 3
26364: PUSH
26365: LD_INT 24
26367: PUSH
26368: LD_INT 1000
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: LIST
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PPUSH
26388: CALL_OW 72
26392: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26393: LD_ADDR_VAR 0 6
26397: PUSH
26398: LD_EXP 50
26402: PUSH
26403: LD_VAR 0 2
26407: ARRAY
26408: PPUSH
26409: LD_INT 21
26411: PUSH
26412: LD_INT 1
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: PUSH
26419: LD_INT 1
26421: PUSH
26422: LD_INT 3
26424: PUSH
26425: LD_INT 54
26427: PUSH
26428: EMPTY
26429: LIST
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: LD_INT 3
26437: PUSH
26438: LD_INT 24
26440: PUSH
26441: LD_INT 250
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PPUSH
26461: CALL_OW 72
26465: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26466: LD_ADDR_VAR 0 7
26470: PUSH
26471: LD_VAR 0 5
26475: PUSH
26476: LD_VAR 0 6
26480: DIFF
26481: ST_TO_ADDR
// if not need_heal_1 then
26482: LD_VAR 0 6
26486: NOT
26487: IFFALSE 26520
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26489: LD_ADDR_EXP 53
26493: PUSH
26494: LD_EXP 53
26498: PPUSH
26499: LD_VAR 0 2
26503: PUSH
26504: LD_INT 1
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PPUSH
26511: EMPTY
26512: PPUSH
26513: CALL 53054 0 3
26517: ST_TO_ADDR
26518: GO 26590
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26520: LD_ADDR_EXP 53
26524: PUSH
26525: LD_EXP 53
26529: PPUSH
26530: LD_VAR 0 2
26534: PUSH
26535: LD_INT 1
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PPUSH
26542: LD_EXP 53
26546: PUSH
26547: LD_VAR 0 2
26551: ARRAY
26552: PUSH
26553: LD_INT 1
26555: ARRAY
26556: PPUSH
26557: LD_INT 3
26559: PUSH
26560: LD_INT 24
26562: PUSH
26563: LD_INT 1000
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PPUSH
26574: CALL_OW 72
26578: PUSH
26579: LD_VAR 0 6
26583: UNION
26584: PPUSH
26585: CALL 53054 0 3
26589: ST_TO_ADDR
// if not need_heal_2 then
26590: LD_VAR 0 7
26594: NOT
26595: IFFALSE 26628
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26597: LD_ADDR_EXP 53
26601: PUSH
26602: LD_EXP 53
26606: PPUSH
26607: LD_VAR 0 2
26611: PUSH
26612: LD_INT 2
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PPUSH
26619: EMPTY
26620: PPUSH
26621: CALL 53054 0 3
26625: ST_TO_ADDR
26626: GO 26660
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26628: LD_ADDR_EXP 53
26632: PUSH
26633: LD_EXP 53
26637: PPUSH
26638: LD_VAR 0 2
26642: PUSH
26643: LD_INT 2
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PPUSH
26650: LD_VAR 0 7
26654: PPUSH
26655: CALL 53054 0 3
26659: ST_TO_ADDR
// if need_heal_2 then
26660: LD_VAR 0 7
26664: IFFALSE 26825
// for j in need_heal_2 do
26666: LD_ADDR_VAR 0 3
26670: PUSH
26671: LD_VAR 0 7
26675: PUSH
26676: FOR_IN
26677: IFFALSE 26823
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26679: LD_ADDR_VAR 0 5
26683: PUSH
26684: LD_EXP 50
26688: PUSH
26689: LD_VAR 0 2
26693: ARRAY
26694: PPUSH
26695: LD_INT 2
26697: PUSH
26698: LD_INT 30
26700: PUSH
26701: LD_INT 6
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 30
26710: PUSH
26711: LD_INT 7
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 30
26720: PUSH
26721: LD_INT 8
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: LD_INT 30
26730: PUSH
26731: LD_INT 0
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: LD_INT 30
26740: PUSH
26741: LD_INT 1
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: LIST
26752: LIST
26753: LIST
26754: LIST
26755: PPUSH
26756: CALL_OW 72
26760: ST_TO_ADDR
// if tmp then
26761: LD_VAR 0 5
26765: IFFALSE 26821
// begin k := NearestUnitToUnit ( tmp , j ) ;
26767: LD_ADDR_VAR 0 4
26771: PUSH
26772: LD_VAR 0 5
26776: PPUSH
26777: LD_VAR 0 3
26781: PPUSH
26782: CALL_OW 74
26786: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26787: LD_VAR 0 3
26791: PPUSH
26792: LD_VAR 0 4
26796: PPUSH
26797: CALL_OW 296
26801: PUSH
26802: LD_INT 5
26804: GREATER
26805: IFFALSE 26821
// ComMoveToNearbyEntrance ( j , k ) ;
26807: LD_VAR 0 3
26811: PPUSH
26812: LD_VAR 0 4
26816: PPUSH
26817: CALL 85297 0 2
// end ; end ;
26821: GO 26676
26823: POP
26824: POP
// if not need_heal_1 and not need_heal_2 then
26825: LD_VAR 0 6
26829: NOT
26830: PUSH
26831: LD_VAR 0 7
26835: NOT
26836: AND
26837: IFFALSE 26841
// continue ;
26839: GO 26305
// end ;
26841: GO 26305
26843: POP
26844: POP
// RaiseSailEvent ( 102 ) ;
26845: LD_INT 102
26847: PPUSH
26848: CALL_OW 427
// end ;
26852: LD_VAR 0 1
26856: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26857: LD_INT 0
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
26866: PPUSH
// if not mc_bases then
26867: LD_EXP 50
26871: NOT
26872: IFFALSE 26876
// exit ;
26874: GO 27737
// for i = 1 to mc_bases do
26876: LD_ADDR_VAR 0 2
26880: PUSH
26881: DOUBLE
26882: LD_INT 1
26884: DEC
26885: ST_TO_ADDR
26886: LD_EXP 50
26890: PUSH
26891: FOR_TO
26892: IFFALSE 27735
// begin if not mc_building_need_repair [ i ] then
26894: LD_EXP 51
26898: PUSH
26899: LD_VAR 0 2
26903: ARRAY
26904: NOT
26905: IFFALSE 27092
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_EXP 69
26916: PUSH
26917: LD_VAR 0 2
26921: ARRAY
26922: PPUSH
26923: LD_INT 3
26925: PUSH
26926: LD_INT 24
26928: PUSH
26929: LD_INT 1000
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 2
26942: PUSH
26943: LD_INT 34
26945: PUSH
26946: LD_INT 13
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: PUSH
26953: LD_INT 34
26955: PUSH
26956: LD_INT 52
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 34
26965: PUSH
26966: LD_EXP 100
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PPUSH
26985: CALL_OW 72
26989: ST_TO_ADDR
// if cranes then
26990: LD_VAR 0 6
26994: IFFALSE 27056
// for j in cranes do
26996: LD_ADDR_VAR 0 3
27000: PUSH
27001: LD_VAR 0 6
27005: PUSH
27006: FOR_IN
27007: IFFALSE 27054
// if not IsInArea ( j , mc_parking [ i ] ) then
27009: LD_VAR 0 3
27013: PPUSH
27014: LD_EXP 74
27018: PUSH
27019: LD_VAR 0 2
27023: ARRAY
27024: PPUSH
27025: CALL_OW 308
27029: NOT
27030: IFFALSE 27052
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27032: LD_VAR 0 3
27036: PPUSH
27037: LD_EXP 74
27041: PUSH
27042: LD_VAR 0 2
27046: ARRAY
27047: PPUSH
27048: CALL_OW 113
27052: GO 27006
27054: POP
27055: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27056: LD_ADDR_EXP 52
27060: PUSH
27061: LD_EXP 52
27065: PPUSH
27066: LD_VAR 0 2
27070: PPUSH
27071: EMPTY
27072: PPUSH
27073: CALL_OW 1
27077: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27078: LD_VAR 0 2
27082: PPUSH
27083: LD_INT 101
27085: PPUSH
27086: CALL 21980 0 2
// continue ;
27090: GO 26891
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27092: LD_ADDR_EXP 56
27096: PUSH
27097: LD_EXP 56
27101: PPUSH
27102: LD_VAR 0 2
27106: PPUSH
27107: EMPTY
27108: PPUSH
27109: CALL_OW 1
27113: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27114: LD_VAR 0 2
27118: PPUSH
27119: LD_INT 103
27121: PPUSH
27122: CALL 21980 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27126: LD_ADDR_VAR 0 5
27130: PUSH
27131: LD_EXP 50
27135: PUSH
27136: LD_VAR 0 2
27140: ARRAY
27141: PUSH
27142: LD_EXP 79
27146: PUSH
27147: LD_VAR 0 2
27151: ARRAY
27152: UNION
27153: PPUSH
27154: LD_INT 2
27156: PUSH
27157: LD_INT 25
27159: PUSH
27160: LD_INT 2
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: LD_INT 25
27169: PUSH
27170: LD_INT 16
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: LIST
27181: PUSH
27182: EMPTY
27183: LIST
27184: PPUSH
27185: CALL_OW 72
27189: PUSH
27190: LD_EXP 53
27194: PUSH
27195: LD_VAR 0 2
27199: ARRAY
27200: PUSH
27201: LD_INT 1
27203: ARRAY
27204: PUSH
27205: LD_EXP 53
27209: PUSH
27210: LD_VAR 0 2
27214: ARRAY
27215: PUSH
27216: LD_INT 2
27218: ARRAY
27219: UNION
27220: DIFF
27221: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27222: LD_ADDR_VAR 0 6
27226: PUSH
27227: LD_EXP 69
27231: PUSH
27232: LD_VAR 0 2
27236: ARRAY
27237: PPUSH
27238: LD_INT 2
27240: PUSH
27241: LD_INT 34
27243: PUSH
27244: LD_INT 13
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 34
27253: PUSH
27254: LD_INT 52
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: LD_INT 34
27263: PUSH
27264: LD_EXP 100
27268: PUSH
27269: EMPTY
27270: LIST
27271: LIST
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: LIST
27277: LIST
27278: PPUSH
27279: CALL_OW 72
27283: ST_TO_ADDR
// if cranes then
27284: LD_VAR 0 6
27288: IFFALSE 27424
// begin for j in cranes do
27290: LD_ADDR_VAR 0 3
27294: PUSH
27295: LD_VAR 0 6
27299: PUSH
27300: FOR_IN
27301: IFFALSE 27422
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27303: LD_VAR 0 3
27307: PPUSH
27308: CALL_OW 256
27312: PUSH
27313: LD_INT 1000
27315: EQUAL
27316: PUSH
27317: LD_VAR 0 3
27321: PPUSH
27322: CALL_OW 314
27326: NOT
27327: AND
27328: IFFALSE 27362
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27330: LD_VAR 0 3
27334: PPUSH
27335: LD_EXP 51
27339: PUSH
27340: LD_VAR 0 2
27344: ARRAY
27345: PPUSH
27346: LD_VAR 0 3
27350: PPUSH
27351: CALL_OW 74
27355: PPUSH
27356: CALL_OW 130
27360: GO 27420
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27362: LD_VAR 0 3
27366: PPUSH
27367: CALL_OW 256
27371: PUSH
27372: LD_INT 500
27374: LESS
27375: PUSH
27376: LD_VAR 0 3
27380: PPUSH
27381: LD_EXP 74
27385: PUSH
27386: LD_VAR 0 2
27390: ARRAY
27391: PPUSH
27392: CALL_OW 308
27396: NOT
27397: AND
27398: IFFALSE 27420
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27400: LD_VAR 0 3
27404: PPUSH
27405: LD_EXP 74
27409: PUSH
27410: LD_VAR 0 2
27414: ARRAY
27415: PPUSH
27416: CALL_OW 113
// end ;
27420: GO 27300
27422: POP
27423: POP
// end ; if tmp > 3 then
27424: LD_VAR 0 5
27428: PUSH
27429: LD_INT 3
27431: GREATER
27432: IFFALSE 27452
// tmp := ShrinkArray ( tmp , 4 ) ;
27434: LD_ADDR_VAR 0 5
27438: PUSH
27439: LD_VAR 0 5
27443: PPUSH
27444: LD_INT 4
27446: PPUSH
27447: CALL 84745 0 2
27451: ST_TO_ADDR
// if not tmp then
27452: LD_VAR 0 5
27456: NOT
27457: IFFALSE 27461
// continue ;
27459: GO 26891
// for j in tmp do
27461: LD_ADDR_VAR 0 3
27465: PUSH
27466: LD_VAR 0 5
27470: PUSH
27471: FOR_IN
27472: IFFALSE 27731
// begin if IsInUnit ( j ) then
27474: LD_VAR 0 3
27478: PPUSH
27479: CALL_OW 310
27483: IFFALSE 27494
// ComExitBuilding ( j ) ;
27485: LD_VAR 0 3
27489: PPUSH
27490: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27494: LD_VAR 0 3
27498: PUSH
27499: LD_EXP 52
27503: PUSH
27504: LD_VAR 0 2
27508: ARRAY
27509: IN
27510: NOT
27511: IFFALSE 27569
// begin SetTag ( j , 101 ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: LD_INT 101
27520: PPUSH
27521: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27525: LD_ADDR_EXP 52
27529: PUSH
27530: LD_EXP 52
27534: PPUSH
27535: LD_VAR 0 2
27539: PUSH
27540: LD_EXP 52
27544: PUSH
27545: LD_VAR 0 2
27549: ARRAY
27550: PUSH
27551: LD_INT 1
27553: PLUS
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PPUSH
27559: LD_VAR 0 3
27563: PPUSH
27564: CALL 53054 0 3
27568: ST_TO_ADDR
// end ; wait ( 1 ) ;
27569: LD_INT 1
27571: PPUSH
27572: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27576: LD_ADDR_VAR 0 7
27580: PUSH
27581: LD_EXP 51
27585: PUSH
27586: LD_VAR 0 2
27590: ARRAY
27591: ST_TO_ADDR
// if mc_scan [ i ] then
27592: LD_EXP 73
27596: PUSH
27597: LD_VAR 0 2
27601: ARRAY
27602: IFFALSE 27664
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27604: LD_ADDR_VAR 0 7
27608: PUSH
27609: LD_EXP 51
27613: PUSH
27614: LD_VAR 0 2
27618: ARRAY
27619: PPUSH
27620: LD_INT 3
27622: PUSH
27623: LD_INT 30
27625: PUSH
27626: LD_INT 32
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 30
27635: PUSH
27636: LD_INT 33
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 30
27645: PUSH
27646: LD_INT 31
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: PPUSH
27659: CALL_OW 72
27663: ST_TO_ADDR
// if not to_repair_tmp then
27664: LD_VAR 0 7
27668: NOT
27669: IFFALSE 27673
// continue ;
27671: GO 27471
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27673: LD_ADDR_VAR 0 8
27677: PUSH
27678: LD_VAR 0 7
27682: PPUSH
27683: LD_VAR 0 3
27687: PPUSH
27688: CALL_OW 74
27692: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27693: LD_VAR 0 8
27697: PPUSH
27698: LD_INT 16
27700: PPUSH
27701: CALL 55647 0 2
27705: PUSH
27706: LD_INT 4
27708: ARRAY
27709: PUSH
27710: LD_INT 10
27712: LESS
27713: IFFALSE 27729
// ComRepairBuilding ( j , to_repair ) ;
27715: LD_VAR 0 3
27719: PPUSH
27720: LD_VAR 0 8
27724: PPUSH
27725: CALL_OW 130
// end ;
27729: GO 27471
27731: POP
27732: POP
// end ;
27733: GO 26891
27735: POP
27736: POP
// end ;
27737: LD_VAR 0 1
27741: RET
// export function MC_Heal ; var i , j , tmp ; begin
27742: LD_INT 0
27744: PPUSH
27745: PPUSH
27746: PPUSH
27747: PPUSH
// if not mc_bases then
27748: LD_EXP 50
27752: NOT
27753: IFFALSE 27757
// exit ;
27755: GO 28159
// for i = 1 to mc_bases do
27757: LD_ADDR_VAR 0 2
27761: PUSH
27762: DOUBLE
27763: LD_INT 1
27765: DEC
27766: ST_TO_ADDR
27767: LD_EXP 50
27771: PUSH
27772: FOR_TO
27773: IFFALSE 28157
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27775: LD_EXP 53
27779: PUSH
27780: LD_VAR 0 2
27784: ARRAY
27785: PUSH
27786: LD_INT 1
27788: ARRAY
27789: NOT
27790: PUSH
27791: LD_EXP 53
27795: PUSH
27796: LD_VAR 0 2
27800: ARRAY
27801: PUSH
27802: LD_INT 2
27804: ARRAY
27805: NOT
27806: AND
27807: IFFALSE 27845
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27809: LD_ADDR_EXP 54
27813: PUSH
27814: LD_EXP 54
27818: PPUSH
27819: LD_VAR 0 2
27823: PPUSH
27824: EMPTY
27825: PPUSH
27826: CALL_OW 1
27830: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27831: LD_VAR 0 2
27835: PPUSH
27836: LD_INT 102
27838: PPUSH
27839: CALL 21980 0 2
// continue ;
27843: GO 27772
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27845: LD_ADDR_VAR 0 4
27849: PUSH
27850: LD_EXP 50
27854: PUSH
27855: LD_VAR 0 2
27859: ARRAY
27860: PPUSH
27861: LD_INT 25
27863: PUSH
27864: LD_INT 4
27866: PUSH
27867: EMPTY
27868: LIST
27869: LIST
27870: PPUSH
27871: CALL_OW 72
27875: ST_TO_ADDR
// if not tmp then
27876: LD_VAR 0 4
27880: NOT
27881: IFFALSE 27885
// continue ;
27883: GO 27772
// if mc_taming [ i ] then
27885: LD_EXP 81
27889: PUSH
27890: LD_VAR 0 2
27894: ARRAY
27895: IFFALSE 27919
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27897: LD_ADDR_EXP 81
27901: PUSH
27902: LD_EXP 81
27906: PPUSH
27907: LD_VAR 0 2
27911: PPUSH
27912: EMPTY
27913: PPUSH
27914: CALL_OW 1
27918: ST_TO_ADDR
// for j in tmp do
27919: LD_ADDR_VAR 0 3
27923: PUSH
27924: LD_VAR 0 4
27928: PUSH
27929: FOR_IN
27930: IFFALSE 28153
// begin if IsInUnit ( j ) then
27932: LD_VAR 0 3
27936: PPUSH
27937: CALL_OW 310
27941: IFFALSE 27952
// ComExitBuilding ( j ) ;
27943: LD_VAR 0 3
27947: PPUSH
27948: CALL_OW 122
// if not j in mc_healers [ i ] then
27952: LD_VAR 0 3
27956: PUSH
27957: LD_EXP 54
27961: PUSH
27962: LD_VAR 0 2
27966: ARRAY
27967: IN
27968: NOT
27969: IFFALSE 28015
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27971: LD_ADDR_EXP 54
27975: PUSH
27976: LD_EXP 54
27980: PPUSH
27981: LD_VAR 0 2
27985: PUSH
27986: LD_EXP 54
27990: PUSH
27991: LD_VAR 0 2
27995: ARRAY
27996: PUSH
27997: LD_INT 1
27999: PLUS
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PPUSH
28005: LD_VAR 0 3
28009: PPUSH
28010: CALL 53054 0 3
28014: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28015: LD_VAR 0 3
28019: PPUSH
28020: CALL_OW 110
28024: PUSH
28025: LD_INT 102
28027: NONEQUAL
28028: IFFALSE 28042
// SetTag ( j , 102 ) ;
28030: LD_VAR 0 3
28034: PPUSH
28035: LD_INT 102
28037: PPUSH
28038: CALL_OW 109
// Wait ( 3 ) ;
28042: LD_INT 3
28044: PPUSH
28045: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28049: LD_EXP 53
28053: PUSH
28054: LD_VAR 0 2
28058: ARRAY
28059: PUSH
28060: LD_INT 1
28062: ARRAY
28063: IFFALSE 28095
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28065: LD_VAR 0 3
28069: PPUSH
28070: LD_EXP 53
28074: PUSH
28075: LD_VAR 0 2
28079: ARRAY
28080: PUSH
28081: LD_INT 1
28083: ARRAY
28084: PUSH
28085: LD_INT 1
28087: ARRAY
28088: PPUSH
28089: CALL_OW 128
28093: GO 28151
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28095: LD_VAR 0 3
28099: PPUSH
28100: CALL_OW 314
28104: NOT
28105: PUSH
28106: LD_EXP 53
28110: PUSH
28111: LD_VAR 0 2
28115: ARRAY
28116: PUSH
28117: LD_INT 2
28119: ARRAY
28120: AND
28121: IFFALSE 28151
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28123: LD_VAR 0 3
28127: PPUSH
28128: LD_EXP 53
28132: PUSH
28133: LD_VAR 0 2
28137: ARRAY
28138: PUSH
28139: LD_INT 2
28141: ARRAY
28142: PUSH
28143: LD_INT 1
28145: ARRAY
28146: PPUSH
28147: CALL_OW 128
// end ;
28151: GO 27929
28153: POP
28154: POP
// end ;
28155: GO 27772
28157: POP
28158: POP
// end ;
28159: LD_VAR 0 1
28163: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28164: LD_INT 0
28166: PPUSH
28167: PPUSH
28168: PPUSH
28169: PPUSH
28170: PPUSH
// if not mc_bases then
28171: LD_EXP 50
28175: NOT
28176: IFFALSE 28180
// exit ;
28178: GO 29351
// for i = 1 to mc_bases do
28180: LD_ADDR_VAR 0 2
28184: PUSH
28185: DOUBLE
28186: LD_INT 1
28188: DEC
28189: ST_TO_ADDR
28190: LD_EXP 50
28194: PUSH
28195: FOR_TO
28196: IFFALSE 29349
// begin if mc_scan [ i ] then
28198: LD_EXP 73
28202: PUSH
28203: LD_VAR 0 2
28207: ARRAY
28208: IFFALSE 28212
// continue ;
28210: GO 28195
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28212: LD_EXP 55
28216: PUSH
28217: LD_VAR 0 2
28221: ARRAY
28222: NOT
28223: PUSH
28224: LD_EXP 57
28228: PUSH
28229: LD_VAR 0 2
28233: ARRAY
28234: NOT
28235: AND
28236: PUSH
28237: LD_EXP 56
28241: PUSH
28242: LD_VAR 0 2
28246: ARRAY
28247: AND
28248: IFFALSE 28286
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28250: LD_ADDR_EXP 56
28254: PUSH
28255: LD_EXP 56
28259: PPUSH
28260: LD_VAR 0 2
28264: PPUSH
28265: EMPTY
28266: PPUSH
28267: CALL_OW 1
28271: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28272: LD_VAR 0 2
28276: PPUSH
28277: LD_INT 103
28279: PPUSH
28280: CALL 21980 0 2
// continue ;
28284: GO 28195
// end ; if mc_construct_list [ i ] then
28286: LD_EXP 57
28290: PUSH
28291: LD_VAR 0 2
28295: ARRAY
28296: IFFALSE 28516
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28298: LD_ADDR_VAR 0 4
28302: PUSH
28303: LD_EXP 50
28307: PUSH
28308: LD_VAR 0 2
28312: ARRAY
28313: PPUSH
28314: LD_INT 25
28316: PUSH
28317: LD_INT 2
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PPUSH
28324: CALL_OW 72
28328: PUSH
28329: LD_EXP 52
28333: PUSH
28334: LD_VAR 0 2
28338: ARRAY
28339: DIFF
28340: ST_TO_ADDR
// if not tmp then
28341: LD_VAR 0 4
28345: NOT
28346: IFFALSE 28350
// continue ;
28348: GO 28195
// for j in tmp do
28350: LD_ADDR_VAR 0 3
28354: PUSH
28355: LD_VAR 0 4
28359: PUSH
28360: FOR_IN
28361: IFFALSE 28512
// begin if not mc_builders [ i ] then
28363: LD_EXP 56
28367: PUSH
28368: LD_VAR 0 2
28372: ARRAY
28373: NOT
28374: IFFALSE 28432
// begin SetTag ( j , 103 ) ;
28376: LD_VAR 0 3
28380: PPUSH
28381: LD_INT 103
28383: PPUSH
28384: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28388: LD_ADDR_EXP 56
28392: PUSH
28393: LD_EXP 56
28397: PPUSH
28398: LD_VAR 0 2
28402: PUSH
28403: LD_EXP 56
28407: PUSH
28408: LD_VAR 0 2
28412: ARRAY
28413: PUSH
28414: LD_INT 1
28416: PLUS
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PPUSH
28422: LD_VAR 0 3
28426: PPUSH
28427: CALL 53054 0 3
28431: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28432: LD_VAR 0 3
28436: PPUSH
28437: CALL_OW 310
28441: IFFALSE 28452
// ComExitBuilding ( j ) ;
28443: LD_VAR 0 3
28447: PPUSH
28448: CALL_OW 122
// wait ( 3 ) ;
28452: LD_INT 3
28454: PPUSH
28455: CALL_OW 67
// if not mc_construct_list [ i ] then
28459: LD_EXP 57
28463: PUSH
28464: LD_VAR 0 2
28468: ARRAY
28469: NOT
28470: IFFALSE 28474
// break ;
28472: GO 28512
// if not HasTask ( j ) then
28474: LD_VAR 0 3
28478: PPUSH
28479: CALL_OW 314
28483: NOT
28484: IFFALSE 28510
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28486: LD_VAR 0 3
28490: PPUSH
28491: LD_EXP 57
28495: PUSH
28496: LD_VAR 0 2
28500: ARRAY
28501: PUSH
28502: LD_INT 1
28504: ARRAY
28505: PPUSH
28506: CALL 55911 0 2
// end ;
28510: GO 28360
28512: POP
28513: POP
// end else
28514: GO 29347
// if mc_build_list [ i ] then
28516: LD_EXP 55
28520: PUSH
28521: LD_VAR 0 2
28525: ARRAY
28526: IFFALSE 29347
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28528: LD_ADDR_VAR 0 5
28532: PUSH
28533: LD_EXP 50
28537: PUSH
28538: LD_VAR 0 2
28542: ARRAY
28543: PPUSH
28544: LD_INT 2
28546: PUSH
28547: LD_INT 30
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 30
28559: PUSH
28560: LD_INT 1
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: LIST
28571: PPUSH
28572: CALL_OW 72
28576: ST_TO_ADDR
// if depot then
28577: LD_VAR 0 5
28581: IFFALSE 28599
// depot := depot [ 1 ] else
28583: LD_ADDR_VAR 0 5
28587: PUSH
28588: LD_VAR 0 5
28592: PUSH
28593: LD_INT 1
28595: ARRAY
28596: ST_TO_ADDR
28597: GO 28607
// depot := 0 ;
28599: LD_ADDR_VAR 0 5
28603: PUSH
28604: LD_INT 0
28606: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28607: LD_EXP 55
28611: PUSH
28612: LD_VAR 0 2
28616: ARRAY
28617: PUSH
28618: LD_INT 1
28620: ARRAY
28621: PUSH
28622: LD_INT 1
28624: ARRAY
28625: PPUSH
28626: CALL 55735 0 1
28630: PUSH
28631: LD_EXP 50
28635: PUSH
28636: LD_VAR 0 2
28640: ARRAY
28641: PPUSH
28642: LD_INT 2
28644: PUSH
28645: LD_INT 30
28647: PUSH
28648: LD_INT 2
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: LD_INT 30
28657: PUSH
28658: LD_INT 3
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: LIST
28669: PPUSH
28670: CALL_OW 72
28674: NOT
28675: AND
28676: IFFALSE 28781
// begin for j = 1 to mc_build_list [ i ] do
28678: LD_ADDR_VAR 0 3
28682: PUSH
28683: DOUBLE
28684: LD_INT 1
28686: DEC
28687: ST_TO_ADDR
28688: LD_EXP 55
28692: PUSH
28693: LD_VAR 0 2
28697: ARRAY
28698: PUSH
28699: FOR_TO
28700: IFFALSE 28779
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28702: LD_EXP 55
28706: PUSH
28707: LD_VAR 0 2
28711: ARRAY
28712: PUSH
28713: LD_VAR 0 3
28717: ARRAY
28718: PUSH
28719: LD_INT 1
28721: ARRAY
28722: PUSH
28723: LD_INT 2
28725: EQUAL
28726: IFFALSE 28777
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28728: LD_ADDR_EXP 55
28732: PUSH
28733: LD_EXP 55
28737: PPUSH
28738: LD_VAR 0 2
28742: PPUSH
28743: LD_EXP 55
28747: PUSH
28748: LD_VAR 0 2
28752: ARRAY
28753: PPUSH
28754: LD_VAR 0 3
28758: PPUSH
28759: LD_INT 1
28761: PPUSH
28762: LD_INT 0
28764: PPUSH
28765: CALL 52472 0 4
28769: PPUSH
28770: CALL_OW 1
28774: ST_TO_ADDR
// break ;
28775: GO 28779
// end ;
28777: GO 28699
28779: POP
28780: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28781: LD_EXP 55
28785: PUSH
28786: LD_VAR 0 2
28790: ARRAY
28791: PUSH
28792: LD_INT 1
28794: ARRAY
28795: PUSH
28796: LD_INT 1
28798: ARRAY
28799: PUSH
28800: LD_INT 0
28802: EQUAL
28803: PUSH
28804: LD_VAR 0 5
28808: PUSH
28809: LD_VAR 0 5
28813: PPUSH
28814: LD_EXP 55
28818: PUSH
28819: LD_VAR 0 2
28823: ARRAY
28824: PUSH
28825: LD_INT 1
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PPUSH
28833: LD_EXP 55
28837: PUSH
28838: LD_VAR 0 2
28842: ARRAY
28843: PUSH
28844: LD_INT 1
28846: ARRAY
28847: PUSH
28848: LD_INT 2
28850: ARRAY
28851: PPUSH
28852: LD_EXP 55
28856: PUSH
28857: LD_VAR 0 2
28861: ARRAY
28862: PUSH
28863: LD_INT 1
28865: ARRAY
28866: PUSH
28867: LD_INT 3
28869: ARRAY
28870: PPUSH
28871: LD_EXP 55
28875: PUSH
28876: LD_VAR 0 2
28880: ARRAY
28881: PUSH
28882: LD_INT 1
28884: ARRAY
28885: PUSH
28886: LD_INT 4
28888: ARRAY
28889: PPUSH
28890: CALL 60802 0 5
28894: AND
28895: OR
28896: IFFALSE 29177
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28898: LD_ADDR_VAR 0 4
28902: PUSH
28903: LD_EXP 50
28907: PUSH
28908: LD_VAR 0 2
28912: ARRAY
28913: PPUSH
28914: LD_INT 25
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PPUSH
28924: CALL_OW 72
28928: PUSH
28929: LD_EXP 52
28933: PUSH
28934: LD_VAR 0 2
28938: ARRAY
28939: DIFF
28940: ST_TO_ADDR
// if not tmp then
28941: LD_VAR 0 4
28945: NOT
28946: IFFALSE 28950
// continue ;
28948: GO 28195
// for j in tmp do
28950: LD_ADDR_VAR 0 3
28954: PUSH
28955: LD_VAR 0 4
28959: PUSH
28960: FOR_IN
28961: IFFALSE 29173
// begin if not mc_builders [ i ] then
28963: LD_EXP 56
28967: PUSH
28968: LD_VAR 0 2
28972: ARRAY
28973: NOT
28974: IFFALSE 29032
// begin SetTag ( j , 103 ) ;
28976: LD_VAR 0 3
28980: PPUSH
28981: LD_INT 103
28983: PPUSH
28984: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28988: LD_ADDR_EXP 56
28992: PUSH
28993: LD_EXP 56
28997: PPUSH
28998: LD_VAR 0 2
29002: PUSH
29003: LD_EXP 56
29007: PUSH
29008: LD_VAR 0 2
29012: ARRAY
29013: PUSH
29014: LD_INT 1
29016: PLUS
29017: PUSH
29018: EMPTY
29019: LIST
29020: LIST
29021: PPUSH
29022: LD_VAR 0 3
29026: PPUSH
29027: CALL 53054 0 3
29031: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29032: LD_VAR 0 3
29036: PPUSH
29037: CALL_OW 310
29041: IFFALSE 29052
// ComExitBuilding ( j ) ;
29043: LD_VAR 0 3
29047: PPUSH
29048: CALL_OW 122
// wait ( 3 ) ;
29052: LD_INT 3
29054: PPUSH
29055: CALL_OW 67
// if not mc_build_list [ i ] then
29059: LD_EXP 55
29063: PUSH
29064: LD_VAR 0 2
29068: ARRAY
29069: NOT
29070: IFFALSE 29074
// break ;
29072: GO 29173
// if not HasTask ( j ) then
29074: LD_VAR 0 3
29078: PPUSH
29079: CALL_OW 314
29083: NOT
29084: IFFALSE 29171
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29086: LD_VAR 0 3
29090: PPUSH
29091: LD_EXP 55
29095: PUSH
29096: LD_VAR 0 2
29100: ARRAY
29101: PUSH
29102: LD_INT 1
29104: ARRAY
29105: PUSH
29106: LD_INT 1
29108: ARRAY
29109: PPUSH
29110: LD_EXP 55
29114: PUSH
29115: LD_VAR 0 2
29119: ARRAY
29120: PUSH
29121: LD_INT 1
29123: ARRAY
29124: PUSH
29125: LD_INT 2
29127: ARRAY
29128: PPUSH
29129: LD_EXP 55
29133: PUSH
29134: LD_VAR 0 2
29138: ARRAY
29139: PUSH
29140: LD_INT 1
29142: ARRAY
29143: PUSH
29144: LD_INT 3
29146: ARRAY
29147: PPUSH
29148: LD_EXP 55
29152: PUSH
29153: LD_VAR 0 2
29157: ARRAY
29158: PUSH
29159: LD_INT 1
29161: ARRAY
29162: PUSH
29163: LD_INT 4
29165: ARRAY
29166: PPUSH
29167: CALL_OW 145
// end ;
29171: GO 28960
29173: POP
29174: POP
// end else
29175: GO 29347
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29177: LD_EXP 50
29181: PUSH
29182: LD_VAR 0 2
29186: ARRAY
29187: PPUSH
29188: LD_EXP 55
29192: PUSH
29193: LD_VAR 0 2
29197: ARRAY
29198: PUSH
29199: LD_INT 1
29201: ARRAY
29202: PUSH
29203: LD_INT 1
29205: ARRAY
29206: PPUSH
29207: LD_EXP 55
29211: PUSH
29212: LD_VAR 0 2
29216: ARRAY
29217: PUSH
29218: LD_INT 1
29220: ARRAY
29221: PUSH
29222: LD_INT 2
29224: ARRAY
29225: PPUSH
29226: LD_EXP 55
29230: PUSH
29231: LD_VAR 0 2
29235: ARRAY
29236: PUSH
29237: LD_INT 1
29239: ARRAY
29240: PUSH
29241: LD_INT 3
29243: ARRAY
29244: PPUSH
29245: LD_EXP 55
29249: PUSH
29250: LD_VAR 0 2
29254: ARRAY
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PUSH
29260: LD_INT 4
29262: ARRAY
29263: PPUSH
29264: LD_EXP 50
29268: PUSH
29269: LD_VAR 0 2
29273: ARRAY
29274: PPUSH
29275: LD_INT 21
29277: PUSH
29278: LD_INT 3
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PPUSH
29285: CALL_OW 72
29289: PPUSH
29290: EMPTY
29291: PPUSH
29292: CALL 59932 0 7
29296: NOT
29297: IFFALSE 29347
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29299: LD_ADDR_EXP 55
29303: PUSH
29304: LD_EXP 55
29308: PPUSH
29309: LD_VAR 0 2
29313: PPUSH
29314: LD_EXP 55
29318: PUSH
29319: LD_VAR 0 2
29323: ARRAY
29324: PPUSH
29325: LD_INT 1
29327: PPUSH
29328: LD_INT 1
29330: NEG
29331: PPUSH
29332: LD_INT 0
29334: PPUSH
29335: CALL 52472 0 4
29339: PPUSH
29340: CALL_OW 1
29344: ST_TO_ADDR
// continue ;
29345: GO 28195
// end ; end ; end ;
29347: GO 28195
29349: POP
29350: POP
// end ;
29351: LD_VAR 0 1
29355: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29356: LD_INT 0
29358: PPUSH
29359: PPUSH
29360: PPUSH
29361: PPUSH
29362: PPUSH
29363: PPUSH
// if not mc_bases then
29364: LD_EXP 50
29368: NOT
29369: IFFALSE 29373
// exit ;
29371: GO 29800
// for i = 1 to mc_bases do
29373: LD_ADDR_VAR 0 2
29377: PUSH
29378: DOUBLE
29379: LD_INT 1
29381: DEC
29382: ST_TO_ADDR
29383: LD_EXP 50
29387: PUSH
29388: FOR_TO
29389: IFFALSE 29798
// begin tmp := mc_build_upgrade [ i ] ;
29391: LD_ADDR_VAR 0 4
29395: PUSH
29396: LD_EXP 82
29400: PUSH
29401: LD_VAR 0 2
29405: ARRAY
29406: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29407: LD_ADDR_VAR 0 6
29411: PUSH
29412: LD_EXP 83
29416: PUSH
29417: LD_VAR 0 2
29421: ARRAY
29422: PPUSH
29423: LD_INT 2
29425: PUSH
29426: LD_INT 30
29428: PUSH
29429: LD_INT 6
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 30
29438: PUSH
29439: LD_INT 7
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: LIST
29450: PPUSH
29451: CALL_OW 72
29455: ST_TO_ADDR
// if not tmp and not lab then
29456: LD_VAR 0 4
29460: NOT
29461: PUSH
29462: LD_VAR 0 6
29466: NOT
29467: AND
29468: IFFALSE 29472
// continue ;
29470: GO 29388
// if tmp then
29472: LD_VAR 0 4
29476: IFFALSE 29596
// for j in tmp do
29478: LD_ADDR_VAR 0 3
29482: PUSH
29483: LD_VAR 0 4
29487: PUSH
29488: FOR_IN
29489: IFFALSE 29594
// begin if UpgradeCost ( j ) then
29491: LD_VAR 0 3
29495: PPUSH
29496: CALL 59592 0 1
29500: IFFALSE 29592
// begin ComUpgrade ( j ) ;
29502: LD_VAR 0 3
29506: PPUSH
29507: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29511: LD_ADDR_EXP 82
29515: PUSH
29516: LD_EXP 82
29520: PPUSH
29521: LD_VAR 0 2
29525: PPUSH
29526: LD_EXP 82
29530: PUSH
29531: LD_VAR 0 2
29535: ARRAY
29536: PUSH
29537: LD_VAR 0 3
29541: DIFF
29542: PPUSH
29543: CALL_OW 1
29547: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29548: LD_ADDR_EXP 57
29552: PUSH
29553: LD_EXP 57
29557: PPUSH
29558: LD_VAR 0 2
29562: PUSH
29563: LD_EXP 57
29567: PUSH
29568: LD_VAR 0 2
29572: ARRAY
29573: PUSH
29574: LD_INT 1
29576: PLUS
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PPUSH
29582: LD_VAR 0 3
29586: PPUSH
29587: CALL 53054 0 3
29591: ST_TO_ADDR
// end ; end ;
29592: GO 29488
29594: POP
29595: POP
// if not lab or not mc_lab_upgrade [ i ] then
29596: LD_VAR 0 6
29600: NOT
29601: PUSH
29602: LD_EXP 84
29606: PUSH
29607: LD_VAR 0 2
29611: ARRAY
29612: NOT
29613: OR
29614: IFFALSE 29618
// continue ;
29616: GO 29388
// for j in lab do
29618: LD_ADDR_VAR 0 3
29622: PUSH
29623: LD_VAR 0 6
29627: PUSH
29628: FOR_IN
29629: IFFALSE 29794
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29631: LD_VAR 0 3
29635: PPUSH
29636: CALL_OW 266
29640: PUSH
29641: LD_INT 6
29643: PUSH
29644: LD_INT 7
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: IN
29651: PUSH
29652: LD_VAR 0 3
29656: PPUSH
29657: CALL_OW 461
29661: PUSH
29662: LD_INT 1
29664: NONEQUAL
29665: AND
29666: IFFALSE 29792
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29668: LD_VAR 0 3
29672: PPUSH
29673: LD_EXP 84
29677: PUSH
29678: LD_VAR 0 2
29682: ARRAY
29683: PUSH
29684: LD_INT 1
29686: ARRAY
29687: PPUSH
29688: CALL 59797 0 2
29692: IFFALSE 29792
// begin ComCancel ( j ) ;
29694: LD_VAR 0 3
29698: PPUSH
29699: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29703: LD_VAR 0 3
29707: PPUSH
29708: LD_EXP 84
29712: PUSH
29713: LD_VAR 0 2
29717: ARRAY
29718: PUSH
29719: LD_INT 1
29721: ARRAY
29722: PPUSH
29723: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29727: LD_VAR 0 3
29731: PUSH
29732: LD_EXP 57
29736: PUSH
29737: LD_VAR 0 2
29741: ARRAY
29742: IN
29743: NOT
29744: IFFALSE 29790
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29746: LD_ADDR_EXP 57
29750: PUSH
29751: LD_EXP 57
29755: PPUSH
29756: LD_VAR 0 2
29760: PUSH
29761: LD_EXP 57
29765: PUSH
29766: LD_VAR 0 2
29770: ARRAY
29771: PUSH
29772: LD_INT 1
29774: PLUS
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PPUSH
29780: LD_VAR 0 3
29784: PPUSH
29785: CALL 53054 0 3
29789: ST_TO_ADDR
// break ;
29790: GO 29794
// end ; end ; end ;
29792: GO 29628
29794: POP
29795: POP
// end ;
29796: GO 29388
29798: POP
29799: POP
// end ;
29800: LD_VAR 0 1
29804: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29805: LD_INT 0
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
29811: PPUSH
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
// if not mc_bases then
29816: LD_EXP 50
29820: NOT
29821: IFFALSE 29825
// exit ;
29823: GO 30230
// for i = 1 to mc_bases do
29825: LD_ADDR_VAR 0 2
29829: PUSH
29830: DOUBLE
29831: LD_INT 1
29833: DEC
29834: ST_TO_ADDR
29835: LD_EXP 50
29839: PUSH
29840: FOR_TO
29841: IFFALSE 30228
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29843: LD_EXP 58
29847: PUSH
29848: LD_VAR 0 2
29852: ARRAY
29853: NOT
29854: PUSH
29855: LD_EXP 50
29859: PUSH
29860: LD_VAR 0 2
29864: ARRAY
29865: PPUSH
29866: LD_INT 30
29868: PUSH
29869: LD_INT 3
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PPUSH
29876: CALL_OW 72
29880: NOT
29881: OR
29882: IFFALSE 29886
// continue ;
29884: GO 29840
// busy := false ;
29886: LD_ADDR_VAR 0 8
29890: PUSH
29891: LD_INT 0
29893: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29894: LD_ADDR_VAR 0 4
29898: PUSH
29899: LD_EXP 50
29903: PUSH
29904: LD_VAR 0 2
29908: ARRAY
29909: PPUSH
29910: LD_INT 30
29912: PUSH
29913: LD_INT 3
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PPUSH
29920: CALL_OW 72
29924: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29925: LD_ADDR_VAR 0 6
29929: PUSH
29930: LD_EXP 58
29934: PUSH
29935: LD_VAR 0 2
29939: ARRAY
29940: PPUSH
29941: LD_INT 2
29943: PUSH
29944: LD_INT 30
29946: PUSH
29947: LD_INT 32
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: LD_INT 30
29956: PUSH
29957: LD_INT 33
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: LIST
29968: PPUSH
29969: CALL_OW 72
29973: ST_TO_ADDR
// if not t then
29974: LD_VAR 0 6
29978: NOT
29979: IFFALSE 29983
// continue ;
29981: GO 29840
// for j in tmp do
29983: LD_ADDR_VAR 0 3
29987: PUSH
29988: LD_VAR 0 4
29992: PUSH
29993: FOR_IN
29994: IFFALSE 30024
// if not BuildingStatus ( j ) = bs_idle then
29996: LD_VAR 0 3
30000: PPUSH
30001: CALL_OW 461
30005: PUSH
30006: LD_INT 2
30008: EQUAL
30009: NOT
30010: IFFALSE 30022
// begin busy := true ;
30012: LD_ADDR_VAR 0 8
30016: PUSH
30017: LD_INT 1
30019: ST_TO_ADDR
// break ;
30020: GO 30024
// end ;
30022: GO 29993
30024: POP
30025: POP
// if busy then
30026: LD_VAR 0 8
30030: IFFALSE 30034
// continue ;
30032: GO 29840
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30034: LD_ADDR_VAR 0 7
30038: PUSH
30039: LD_VAR 0 6
30043: PPUSH
30044: LD_INT 35
30046: PUSH
30047: LD_INT 0
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PPUSH
30054: CALL_OW 72
30058: ST_TO_ADDR
// if tw then
30059: LD_VAR 0 7
30063: IFFALSE 30140
// begin tw := tw [ 1 ] ;
30065: LD_ADDR_VAR 0 7
30069: PUSH
30070: LD_VAR 0 7
30074: PUSH
30075: LD_INT 1
30077: ARRAY
30078: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30079: LD_ADDR_VAR 0 9
30083: PUSH
30084: LD_VAR 0 7
30088: PPUSH
30089: LD_EXP 75
30093: PUSH
30094: LD_VAR 0 2
30098: ARRAY
30099: PPUSH
30100: CALL 58059 0 2
30104: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30105: LD_EXP 89
30109: PUSH
30110: LD_VAR 0 2
30114: ARRAY
30115: IFFALSE 30138
// if not weapon in mc_allowed_tower_weapons [ i ] then
30117: LD_VAR 0 9
30121: PUSH
30122: LD_EXP 89
30126: PUSH
30127: LD_VAR 0 2
30131: ARRAY
30132: IN
30133: NOT
30134: IFFALSE 30138
// continue ;
30136: GO 29840
// end else
30138: GO 30203
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30140: LD_ADDR_VAR 0 5
30144: PUSH
30145: LD_EXP 58
30149: PUSH
30150: LD_VAR 0 2
30154: ARRAY
30155: PPUSH
30156: LD_VAR 0 4
30160: PPUSH
30161: CALL 83978 0 2
30165: ST_TO_ADDR
// if not tmp2 then
30166: LD_VAR 0 5
30170: NOT
30171: IFFALSE 30175
// continue ;
30173: GO 29840
// tw := tmp2 [ 1 ] ;
30175: LD_ADDR_VAR 0 7
30179: PUSH
30180: LD_VAR 0 5
30184: PUSH
30185: LD_INT 1
30187: ARRAY
30188: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30189: LD_ADDR_VAR 0 9
30193: PUSH
30194: LD_VAR 0 5
30198: PUSH
30199: LD_INT 2
30201: ARRAY
30202: ST_TO_ADDR
// end ; if not weapon then
30203: LD_VAR 0 9
30207: NOT
30208: IFFALSE 30212
// continue ;
30210: GO 29840
// ComPlaceWeapon ( tw , weapon ) ;
30212: LD_VAR 0 7
30216: PPUSH
30217: LD_VAR 0 9
30221: PPUSH
30222: CALL_OW 148
// end ;
30226: GO 29840
30228: POP
30229: POP
// end ;
30230: LD_VAR 0 1
30234: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30235: LD_INT 0
30237: PPUSH
30238: PPUSH
30239: PPUSH
30240: PPUSH
30241: PPUSH
30242: PPUSH
30243: PPUSH
// if not mc_bases then
30244: LD_EXP 50
30248: NOT
30249: IFFALSE 30253
// exit ;
30251: GO 31021
// for i = 1 to mc_bases do
30253: LD_ADDR_VAR 0 2
30257: PUSH
30258: DOUBLE
30259: LD_INT 1
30261: DEC
30262: ST_TO_ADDR
30263: LD_EXP 50
30267: PUSH
30268: FOR_TO
30269: IFFALSE 31019
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30271: LD_EXP 63
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: NOT
30282: PUSH
30283: LD_EXP 63
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: PUSH
30294: LD_EXP 64
30298: PUSH
30299: LD_VAR 0 2
30303: ARRAY
30304: EQUAL
30305: OR
30306: PUSH
30307: LD_EXP 73
30311: PUSH
30312: LD_VAR 0 2
30316: ARRAY
30317: OR
30318: IFFALSE 30322
// continue ;
30320: GO 30268
// if mc_miners [ i ] then
30322: LD_EXP 64
30326: PUSH
30327: LD_VAR 0 2
30331: ARRAY
30332: IFFALSE 30706
// begin for j = mc_miners [ i ] downto 1 do
30334: LD_ADDR_VAR 0 3
30338: PUSH
30339: DOUBLE
30340: LD_EXP 64
30344: PUSH
30345: LD_VAR 0 2
30349: ARRAY
30350: INC
30351: ST_TO_ADDR
30352: LD_INT 1
30354: PUSH
30355: FOR_DOWNTO
30356: IFFALSE 30704
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30358: LD_EXP 64
30362: PUSH
30363: LD_VAR 0 2
30367: ARRAY
30368: PUSH
30369: LD_VAR 0 3
30373: ARRAY
30374: PPUSH
30375: CALL_OW 301
30379: PUSH
30380: LD_EXP 64
30384: PUSH
30385: LD_VAR 0 2
30389: ARRAY
30390: PUSH
30391: LD_VAR 0 3
30395: ARRAY
30396: PPUSH
30397: CALL_OW 257
30401: PUSH
30402: LD_INT 1
30404: NONEQUAL
30405: OR
30406: IFFALSE 30469
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30408: LD_ADDR_VAR 0 5
30412: PUSH
30413: LD_EXP 64
30417: PUSH
30418: LD_VAR 0 2
30422: ARRAY
30423: PUSH
30424: LD_EXP 64
30428: PUSH
30429: LD_VAR 0 2
30433: ARRAY
30434: PUSH
30435: LD_VAR 0 3
30439: ARRAY
30440: DIFF
30441: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30442: LD_ADDR_EXP 64
30446: PUSH
30447: LD_EXP 64
30451: PPUSH
30452: LD_VAR 0 2
30456: PPUSH
30457: LD_VAR 0 5
30461: PPUSH
30462: CALL_OW 1
30466: ST_TO_ADDR
// continue ;
30467: GO 30355
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30469: LD_EXP 64
30473: PUSH
30474: LD_VAR 0 2
30478: ARRAY
30479: PUSH
30480: LD_VAR 0 3
30484: ARRAY
30485: PPUSH
30486: CALL_OW 257
30490: PUSH
30491: LD_INT 1
30493: EQUAL
30494: PUSH
30495: LD_EXP 64
30499: PUSH
30500: LD_VAR 0 2
30504: ARRAY
30505: PUSH
30506: LD_VAR 0 3
30510: ARRAY
30511: PPUSH
30512: CALL_OW 459
30516: NOT
30517: AND
30518: PUSH
30519: LD_EXP 64
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_VAR 0 3
30534: ARRAY
30535: PPUSH
30536: CALL_OW 314
30540: NOT
30541: AND
30542: IFFALSE 30702
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30544: LD_EXP 64
30548: PUSH
30549: LD_VAR 0 2
30553: ARRAY
30554: PUSH
30555: LD_VAR 0 3
30559: ARRAY
30560: PPUSH
30561: CALL_OW 310
30565: IFFALSE 30588
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30567: LD_EXP 64
30571: PUSH
30572: LD_VAR 0 2
30576: ARRAY
30577: PUSH
30578: LD_VAR 0 3
30582: ARRAY
30583: PPUSH
30584: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30588: LD_EXP 64
30592: PUSH
30593: LD_VAR 0 2
30597: ARRAY
30598: PUSH
30599: LD_VAR 0 3
30603: ARRAY
30604: PPUSH
30605: CALL_OW 314
30609: NOT
30610: IFFALSE 30702
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30612: LD_ADDR_VAR 0 7
30616: PUSH
30617: LD_INT 1
30619: PPUSH
30620: LD_EXP 63
30624: PUSH
30625: LD_VAR 0 2
30629: ARRAY
30630: PPUSH
30631: CALL_OW 12
30635: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30636: LD_EXP 64
30640: PUSH
30641: LD_VAR 0 2
30645: ARRAY
30646: PUSH
30647: LD_VAR 0 3
30651: ARRAY
30652: PPUSH
30653: LD_EXP 63
30657: PUSH
30658: LD_VAR 0 2
30662: ARRAY
30663: PUSH
30664: LD_VAR 0 7
30668: ARRAY
30669: PUSH
30670: LD_INT 1
30672: ARRAY
30673: PPUSH
30674: LD_EXP 63
30678: PUSH
30679: LD_VAR 0 2
30683: ARRAY
30684: PUSH
30685: LD_VAR 0 7
30689: ARRAY
30690: PUSH
30691: LD_INT 2
30693: ARRAY
30694: PPUSH
30695: LD_INT 0
30697: PPUSH
30698: CALL_OW 193
// end ; end ; end ;
30702: GO 30355
30704: POP
30705: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30706: LD_ADDR_VAR 0 5
30710: PUSH
30711: LD_EXP 50
30715: PUSH
30716: LD_VAR 0 2
30720: ARRAY
30721: PPUSH
30722: LD_INT 2
30724: PUSH
30725: LD_INT 30
30727: PUSH
30728: LD_INT 4
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 30
30737: PUSH
30738: LD_INT 5
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 30
30747: PUSH
30748: LD_INT 32
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: PPUSH
30761: CALL_OW 72
30765: ST_TO_ADDR
// if not tmp then
30766: LD_VAR 0 5
30770: NOT
30771: IFFALSE 30775
// continue ;
30773: GO 30268
// list := [ ] ;
30775: LD_ADDR_VAR 0 6
30779: PUSH
30780: EMPTY
30781: ST_TO_ADDR
// for j in tmp do
30782: LD_ADDR_VAR 0 3
30786: PUSH
30787: LD_VAR 0 5
30791: PUSH
30792: FOR_IN
30793: IFFALSE 30862
// begin for k in UnitsInside ( j ) do
30795: LD_ADDR_VAR 0 4
30799: PUSH
30800: LD_VAR 0 3
30804: PPUSH
30805: CALL_OW 313
30809: PUSH
30810: FOR_IN
30811: IFFALSE 30858
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30813: LD_VAR 0 4
30817: PPUSH
30818: CALL_OW 257
30822: PUSH
30823: LD_INT 1
30825: EQUAL
30826: PUSH
30827: LD_VAR 0 4
30831: PPUSH
30832: CALL_OW 459
30836: NOT
30837: AND
30838: IFFALSE 30856
// list := list ^ k ;
30840: LD_ADDR_VAR 0 6
30844: PUSH
30845: LD_VAR 0 6
30849: PUSH
30850: LD_VAR 0 4
30854: ADD
30855: ST_TO_ADDR
30856: GO 30810
30858: POP
30859: POP
// end ;
30860: GO 30792
30862: POP
30863: POP
// list := list diff mc_miners [ i ] ;
30864: LD_ADDR_VAR 0 6
30868: PUSH
30869: LD_VAR 0 6
30873: PUSH
30874: LD_EXP 64
30878: PUSH
30879: LD_VAR 0 2
30883: ARRAY
30884: DIFF
30885: ST_TO_ADDR
// if not list then
30886: LD_VAR 0 6
30890: NOT
30891: IFFALSE 30895
// continue ;
30893: GO 30268
// k := mc_mines [ i ] - mc_miners [ i ] ;
30895: LD_ADDR_VAR 0 4
30899: PUSH
30900: LD_EXP 63
30904: PUSH
30905: LD_VAR 0 2
30909: ARRAY
30910: PUSH
30911: LD_EXP 64
30915: PUSH
30916: LD_VAR 0 2
30920: ARRAY
30921: MINUS
30922: ST_TO_ADDR
// if k > list then
30923: LD_VAR 0 4
30927: PUSH
30928: LD_VAR 0 6
30932: GREATER
30933: IFFALSE 30945
// k := list ;
30935: LD_ADDR_VAR 0 4
30939: PUSH
30940: LD_VAR 0 6
30944: ST_TO_ADDR
// for j = 1 to k do
30945: LD_ADDR_VAR 0 3
30949: PUSH
30950: DOUBLE
30951: LD_INT 1
30953: DEC
30954: ST_TO_ADDR
30955: LD_VAR 0 4
30959: PUSH
30960: FOR_TO
30961: IFFALSE 31015
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30963: LD_ADDR_EXP 64
30967: PUSH
30968: LD_EXP 64
30972: PPUSH
30973: LD_VAR 0 2
30977: PUSH
30978: LD_EXP 64
30982: PUSH
30983: LD_VAR 0 2
30987: ARRAY
30988: PUSH
30989: LD_INT 1
30991: PLUS
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PPUSH
30997: LD_VAR 0 6
31001: PUSH
31002: LD_VAR 0 3
31006: ARRAY
31007: PPUSH
31008: CALL 53054 0 3
31012: ST_TO_ADDR
31013: GO 30960
31015: POP
31016: POP
// end ;
31017: GO 30268
31019: POP
31020: POP
// end ;
31021: LD_VAR 0 1
31025: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
31026: LD_INT 0
31028: PPUSH
31029: PPUSH
31030: PPUSH
31031: PPUSH
31032: PPUSH
31033: PPUSH
31034: PPUSH
31035: PPUSH
31036: PPUSH
31037: PPUSH
// if not mc_bases then
31038: LD_EXP 50
31042: NOT
31043: IFFALSE 31047
// exit ;
31045: GO 32797
// for i = 1 to mc_bases do
31047: LD_ADDR_VAR 0 2
31051: PUSH
31052: DOUBLE
31053: LD_INT 1
31055: DEC
31056: ST_TO_ADDR
31057: LD_EXP 50
31061: PUSH
31062: FOR_TO
31063: IFFALSE 32795
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31065: LD_EXP 50
31069: PUSH
31070: LD_VAR 0 2
31074: ARRAY
31075: NOT
31076: PUSH
31077: LD_EXP 57
31081: PUSH
31082: LD_VAR 0 2
31086: ARRAY
31087: OR
31088: IFFALSE 31092
// continue ;
31090: GO 31062
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31092: LD_EXP 66
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: NOT
31103: PUSH
31104: LD_EXP 67
31108: PUSH
31109: LD_VAR 0 2
31113: ARRAY
31114: AND
31115: IFFALSE 31153
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31117: LD_ADDR_EXP 67
31121: PUSH
31122: LD_EXP 67
31126: PPUSH
31127: LD_VAR 0 2
31131: PPUSH
31132: EMPTY
31133: PPUSH
31134: CALL_OW 1
31138: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31139: LD_VAR 0 2
31143: PPUSH
31144: LD_INT 107
31146: PPUSH
31147: CALL 21980 0 2
// continue ;
31151: GO 31062
// end ; target := [ ] ;
31153: LD_ADDR_VAR 0 6
31157: PUSH
31158: EMPTY
31159: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31160: LD_ADDR_VAR 0 3
31164: PUSH
31165: DOUBLE
31166: LD_EXP 66
31170: PUSH
31171: LD_VAR 0 2
31175: ARRAY
31176: INC
31177: ST_TO_ADDR
31178: LD_INT 1
31180: PUSH
31181: FOR_DOWNTO
31182: IFFALSE 31442
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31184: LD_EXP 66
31188: PUSH
31189: LD_VAR 0 2
31193: ARRAY
31194: PUSH
31195: LD_VAR 0 3
31199: ARRAY
31200: PUSH
31201: LD_INT 2
31203: ARRAY
31204: PPUSH
31205: LD_EXP 66
31209: PUSH
31210: LD_VAR 0 2
31214: ARRAY
31215: PUSH
31216: LD_VAR 0 3
31220: ARRAY
31221: PUSH
31222: LD_INT 3
31224: ARRAY
31225: PPUSH
31226: CALL_OW 488
31230: PUSH
31231: LD_EXP 66
31235: PUSH
31236: LD_VAR 0 2
31240: ARRAY
31241: PUSH
31242: LD_VAR 0 3
31246: ARRAY
31247: PUSH
31248: LD_INT 2
31250: ARRAY
31251: PPUSH
31252: LD_EXP 66
31256: PUSH
31257: LD_VAR 0 2
31261: ARRAY
31262: PUSH
31263: LD_VAR 0 3
31267: ARRAY
31268: PUSH
31269: LD_INT 3
31271: ARRAY
31272: PPUSH
31273: CALL_OW 284
31277: PUSH
31278: LD_INT 0
31280: EQUAL
31281: AND
31282: IFFALSE 31337
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31284: LD_ADDR_VAR 0 5
31288: PUSH
31289: LD_EXP 66
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PPUSH
31300: LD_VAR 0 3
31304: PPUSH
31305: CALL_OW 3
31309: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31310: LD_ADDR_EXP 66
31314: PUSH
31315: LD_EXP 66
31319: PPUSH
31320: LD_VAR 0 2
31324: PPUSH
31325: LD_VAR 0 5
31329: PPUSH
31330: CALL_OW 1
31334: ST_TO_ADDR
// continue ;
31335: GO 31181
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31337: LD_EXP 50
31341: PUSH
31342: LD_VAR 0 2
31346: ARRAY
31347: PUSH
31348: LD_INT 1
31350: ARRAY
31351: PPUSH
31352: CALL_OW 255
31356: PPUSH
31357: LD_EXP 66
31361: PUSH
31362: LD_VAR 0 2
31366: ARRAY
31367: PUSH
31368: LD_VAR 0 3
31372: ARRAY
31373: PUSH
31374: LD_INT 2
31376: ARRAY
31377: PPUSH
31378: LD_EXP 66
31382: PUSH
31383: LD_VAR 0 2
31387: ARRAY
31388: PUSH
31389: LD_VAR 0 3
31393: ARRAY
31394: PUSH
31395: LD_INT 3
31397: ARRAY
31398: PPUSH
31399: LD_INT 30
31401: PPUSH
31402: CALL 53950 0 4
31406: PUSH
31407: LD_INT 4
31409: ARRAY
31410: PUSH
31411: LD_INT 0
31413: EQUAL
31414: IFFALSE 31440
// begin target := mc_crates [ i ] [ j ] ;
31416: LD_ADDR_VAR 0 6
31420: PUSH
31421: LD_EXP 66
31425: PUSH
31426: LD_VAR 0 2
31430: ARRAY
31431: PUSH
31432: LD_VAR 0 3
31436: ARRAY
31437: ST_TO_ADDR
// break ;
31438: GO 31442
// end ; end ;
31440: GO 31181
31442: POP
31443: POP
// if not target then
31444: LD_VAR 0 6
31448: NOT
31449: IFFALSE 31453
// continue ;
31451: GO 31062
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31453: LD_ADDR_VAR 0 7
31457: PUSH
31458: LD_EXP 69
31462: PUSH
31463: LD_VAR 0 2
31467: ARRAY
31468: PPUSH
31469: LD_INT 2
31471: PUSH
31472: LD_INT 3
31474: PUSH
31475: LD_INT 58
31477: PUSH
31478: EMPTY
31479: LIST
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 61
31487: PUSH
31488: EMPTY
31489: LIST
31490: PUSH
31491: LD_INT 33
31493: PUSH
31494: LD_INT 5
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 33
31503: PUSH
31504: LD_INT 3
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 2
31520: PUSH
31521: LD_INT 34
31523: PUSH
31524: LD_INT 32
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 34
31533: PUSH
31534: LD_INT 51
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: LD_INT 34
31543: PUSH
31544: LD_INT 12
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PPUSH
31561: CALL_OW 72
31565: ST_TO_ADDR
// if not cargo then
31566: LD_VAR 0 7
31570: NOT
31571: IFFALSE 32214
// begin if mc_crates_collector [ i ] < 5 then
31573: LD_EXP 67
31577: PUSH
31578: LD_VAR 0 2
31582: ARRAY
31583: PUSH
31584: LD_INT 5
31586: LESS
31587: IFFALSE 31953
// begin if mc_ape [ i ] then
31589: LD_EXP 79
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: IFFALSE 31646
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31601: LD_ADDR_VAR 0 5
31605: PUSH
31606: LD_EXP 79
31610: PUSH
31611: LD_VAR 0 2
31615: ARRAY
31616: PPUSH
31617: LD_INT 25
31619: PUSH
31620: LD_INT 16
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 24
31629: PUSH
31630: LD_INT 750
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PPUSH
31641: CALL_OW 72
31645: ST_TO_ADDR
// if not tmp then
31646: LD_VAR 0 5
31650: NOT
31651: IFFALSE 31698
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31653: LD_ADDR_VAR 0 5
31657: PUSH
31658: LD_EXP 50
31662: PUSH
31663: LD_VAR 0 2
31667: ARRAY
31668: PPUSH
31669: LD_INT 25
31671: PUSH
31672: LD_INT 2
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 24
31681: PUSH
31682: LD_INT 750
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PPUSH
31693: CALL_OW 72
31697: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31698: LD_EXP 79
31702: PUSH
31703: LD_VAR 0 2
31707: ARRAY
31708: PUSH
31709: LD_EXP 50
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: PPUSH
31720: LD_INT 25
31722: PUSH
31723: LD_INT 2
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 24
31732: PUSH
31733: LD_INT 750
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PPUSH
31744: CALL_OW 72
31748: AND
31749: PUSH
31750: LD_VAR 0 5
31754: PUSH
31755: LD_INT 5
31757: LESS
31758: AND
31759: IFFALSE 31841
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31761: LD_ADDR_VAR 0 3
31765: PUSH
31766: LD_EXP 50
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: PPUSH
31777: LD_INT 25
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 24
31789: PUSH
31790: LD_INT 750
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PPUSH
31801: CALL_OW 72
31805: PUSH
31806: FOR_IN
31807: IFFALSE 31839
// begin tmp := tmp union j ;
31809: LD_ADDR_VAR 0 5
31813: PUSH
31814: LD_VAR 0 5
31818: PUSH
31819: LD_VAR 0 3
31823: UNION
31824: ST_TO_ADDR
// if tmp >= 5 then
31825: LD_VAR 0 5
31829: PUSH
31830: LD_INT 5
31832: GREATEREQUAL
31833: IFFALSE 31837
// break ;
31835: GO 31839
// end ;
31837: GO 31806
31839: POP
31840: POP
// end ; if not tmp then
31841: LD_VAR 0 5
31845: NOT
31846: IFFALSE 31850
// continue ;
31848: GO 31062
// for j in tmp do
31850: LD_ADDR_VAR 0 3
31854: PUSH
31855: LD_VAR 0 5
31859: PUSH
31860: FOR_IN
31861: IFFALSE 31951
// if not GetTag ( j ) then
31863: LD_VAR 0 3
31867: PPUSH
31868: CALL_OW 110
31872: NOT
31873: IFFALSE 31949
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31875: LD_ADDR_EXP 67
31879: PUSH
31880: LD_EXP 67
31884: PPUSH
31885: LD_VAR 0 2
31889: PUSH
31890: LD_EXP 67
31894: PUSH
31895: LD_VAR 0 2
31899: ARRAY
31900: PUSH
31901: LD_INT 1
31903: PLUS
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PPUSH
31909: LD_VAR 0 3
31913: PPUSH
31914: CALL 53054 0 3
31918: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31919: LD_VAR 0 3
31923: PPUSH
31924: LD_INT 107
31926: PPUSH
31927: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31931: LD_EXP 67
31935: PUSH
31936: LD_VAR 0 2
31940: ARRAY
31941: PUSH
31942: LD_INT 5
31944: GREATEREQUAL
31945: IFFALSE 31949
// break ;
31947: GO 31951
// end ;
31949: GO 31860
31951: POP
31952: POP
// end ; if mc_crates_collector [ i ] and target then
31953: LD_EXP 67
31957: PUSH
31958: LD_VAR 0 2
31962: ARRAY
31963: PUSH
31964: LD_VAR 0 6
31968: AND
31969: IFFALSE 32212
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31971: LD_EXP 67
31975: PUSH
31976: LD_VAR 0 2
31980: ARRAY
31981: PUSH
31982: LD_VAR 0 6
31986: PUSH
31987: LD_INT 1
31989: ARRAY
31990: LESS
31991: IFFALSE 32011
// tmp := mc_crates_collector [ i ] else
31993: LD_ADDR_VAR 0 5
31997: PUSH
31998: LD_EXP 67
32002: PUSH
32003: LD_VAR 0 2
32007: ARRAY
32008: ST_TO_ADDR
32009: GO 32025
// tmp := target [ 1 ] ;
32011: LD_ADDR_VAR 0 5
32015: PUSH
32016: LD_VAR 0 6
32020: PUSH
32021: LD_INT 1
32023: ARRAY
32024: ST_TO_ADDR
// k := 0 ;
32025: LD_ADDR_VAR 0 4
32029: PUSH
32030: LD_INT 0
32032: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32033: LD_ADDR_VAR 0 3
32037: PUSH
32038: LD_EXP 67
32042: PUSH
32043: LD_VAR 0 2
32047: ARRAY
32048: PUSH
32049: FOR_IN
32050: IFFALSE 32210
// begin k := k + 1 ;
32052: LD_ADDR_VAR 0 4
32056: PUSH
32057: LD_VAR 0 4
32061: PUSH
32062: LD_INT 1
32064: PLUS
32065: ST_TO_ADDR
// if k > tmp then
32066: LD_VAR 0 4
32070: PUSH
32071: LD_VAR 0 5
32075: GREATER
32076: IFFALSE 32080
// break ;
32078: GO 32210
// if not GetClass ( j ) in [ 2 , 16 ] then
32080: LD_VAR 0 3
32084: PPUSH
32085: CALL_OW 257
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: LD_INT 16
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: IN
32100: NOT
32101: IFFALSE 32154
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32103: LD_ADDR_EXP 67
32107: PUSH
32108: LD_EXP 67
32112: PPUSH
32113: LD_VAR 0 2
32117: PPUSH
32118: LD_EXP 67
32122: PUSH
32123: LD_VAR 0 2
32127: ARRAY
32128: PUSH
32129: LD_VAR 0 3
32133: DIFF
32134: PPUSH
32135: CALL_OW 1
32139: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32140: LD_VAR 0 3
32144: PPUSH
32145: LD_INT 0
32147: PPUSH
32148: CALL_OW 109
// continue ;
32152: GO 32049
// end ; if IsInUnit ( j ) then
32154: LD_VAR 0 3
32158: PPUSH
32159: CALL_OW 310
32163: IFFALSE 32174
// ComExitBuilding ( j ) ;
32165: LD_VAR 0 3
32169: PPUSH
32170: CALL_OW 122
// wait ( 3 ) ;
32174: LD_INT 3
32176: PPUSH
32177: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32181: LD_VAR 0 3
32185: PPUSH
32186: LD_VAR 0 6
32190: PUSH
32191: LD_INT 2
32193: ARRAY
32194: PPUSH
32195: LD_VAR 0 6
32199: PUSH
32200: LD_INT 3
32202: ARRAY
32203: PPUSH
32204: CALL_OW 117
// end ;
32208: GO 32049
32210: POP
32211: POP
// end ; end else
32212: GO 32793
// begin for j in cargo do
32214: LD_ADDR_VAR 0 3
32218: PUSH
32219: LD_VAR 0 7
32223: PUSH
32224: FOR_IN
32225: IFFALSE 32791
// begin if GetTag ( j ) <> 0 then
32227: LD_VAR 0 3
32231: PPUSH
32232: CALL_OW 110
32236: PUSH
32237: LD_INT 0
32239: NONEQUAL
32240: IFFALSE 32244
// continue ;
32242: GO 32224
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32244: LD_VAR 0 3
32248: PPUSH
32249: CALL_OW 256
32253: PUSH
32254: LD_INT 1000
32256: LESS
32257: PUSH
32258: LD_VAR 0 3
32262: PPUSH
32263: LD_EXP 74
32267: PUSH
32268: LD_VAR 0 2
32272: ARRAY
32273: PPUSH
32274: CALL_OW 308
32278: NOT
32279: AND
32280: IFFALSE 32302
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32282: LD_VAR 0 3
32286: PPUSH
32287: LD_EXP 74
32291: PUSH
32292: LD_VAR 0 2
32296: ARRAY
32297: PPUSH
32298: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32302: LD_VAR 0 3
32306: PPUSH
32307: CALL_OW 256
32311: PUSH
32312: LD_INT 1000
32314: LESS
32315: PUSH
32316: LD_VAR 0 3
32320: PPUSH
32321: LD_EXP 74
32325: PUSH
32326: LD_VAR 0 2
32330: ARRAY
32331: PPUSH
32332: CALL_OW 308
32336: AND
32337: IFFALSE 32341
// continue ;
32339: GO 32224
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32341: LD_VAR 0 3
32345: PPUSH
32346: CALL_OW 262
32350: PUSH
32351: LD_INT 2
32353: EQUAL
32354: PUSH
32355: LD_VAR 0 3
32359: PPUSH
32360: CALL_OW 261
32364: PUSH
32365: LD_INT 15
32367: LESS
32368: AND
32369: IFFALSE 32373
// continue ;
32371: GO 32224
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32373: LD_VAR 0 3
32377: PPUSH
32378: CALL_OW 262
32382: PUSH
32383: LD_INT 1
32385: EQUAL
32386: PUSH
32387: LD_VAR 0 3
32391: PPUSH
32392: CALL_OW 261
32396: PUSH
32397: LD_INT 10
32399: LESS
32400: AND
32401: IFFALSE 32730
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32403: LD_ADDR_VAR 0 8
32407: PUSH
32408: LD_EXP 50
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PPUSH
32419: LD_INT 2
32421: PUSH
32422: LD_INT 30
32424: PUSH
32425: LD_INT 0
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 30
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: LIST
32446: PPUSH
32447: CALL_OW 72
32451: ST_TO_ADDR
// if not depot then
32452: LD_VAR 0 8
32456: NOT
32457: IFFALSE 32461
// continue ;
32459: GO 32224
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32461: LD_VAR 0 3
32465: PPUSH
32466: LD_VAR 0 8
32470: PPUSH
32471: LD_VAR 0 3
32475: PPUSH
32476: CALL_OW 74
32480: PPUSH
32481: CALL_OW 296
32485: PUSH
32486: LD_INT 6
32488: LESS
32489: IFFALSE 32505
// SetFuel ( j , 100 ) else
32491: LD_VAR 0 3
32495: PPUSH
32496: LD_INT 100
32498: PPUSH
32499: CALL_OW 240
32503: GO 32730
// if GetFuel ( j ) = 0 then
32505: LD_VAR 0 3
32509: PPUSH
32510: CALL_OW 261
32514: PUSH
32515: LD_INT 0
32517: EQUAL
32518: IFFALSE 32730
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32520: LD_ADDR_EXP 69
32524: PUSH
32525: LD_EXP 69
32529: PPUSH
32530: LD_VAR 0 2
32534: PPUSH
32535: LD_EXP 69
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PUSH
32546: LD_VAR 0 3
32550: DIFF
32551: PPUSH
32552: CALL_OW 1
32556: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32557: LD_VAR 0 3
32561: PPUSH
32562: CALL_OW 263
32566: PUSH
32567: LD_INT 1
32569: EQUAL
32570: IFFALSE 32586
// ComExitVehicle ( IsInUnit ( j ) ) ;
32572: LD_VAR 0 3
32576: PPUSH
32577: CALL_OW 310
32581: PPUSH
32582: CALL_OW 121
// if GetControl ( j ) = control_remote then
32586: LD_VAR 0 3
32590: PPUSH
32591: CALL_OW 263
32595: PUSH
32596: LD_INT 2
32598: EQUAL
32599: IFFALSE 32610
// ComUnlink ( j ) ;
32601: LD_VAR 0 3
32605: PPUSH
32606: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32610: LD_ADDR_VAR 0 9
32614: PUSH
32615: LD_VAR 0 2
32619: PPUSH
32620: LD_INT 3
32622: PPUSH
32623: CALL 42200 0 2
32627: ST_TO_ADDR
// if fac then
32628: LD_VAR 0 9
32632: IFFALSE 32728
// begin for k in fac do
32634: LD_ADDR_VAR 0 4
32638: PUSH
32639: LD_VAR 0 9
32643: PUSH
32644: FOR_IN
32645: IFFALSE 32726
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32647: LD_ADDR_VAR 0 10
32651: PUSH
32652: LD_VAR 0 9
32656: PPUSH
32657: LD_VAR 0 3
32661: PPUSH
32662: CALL_OW 265
32666: PPUSH
32667: LD_VAR 0 3
32671: PPUSH
32672: CALL_OW 262
32676: PPUSH
32677: LD_VAR 0 3
32681: PPUSH
32682: CALL_OW 263
32686: PPUSH
32687: LD_VAR 0 3
32691: PPUSH
32692: CALL_OW 264
32696: PPUSH
32697: CALL 50586 0 5
32701: ST_TO_ADDR
// if components then
32702: LD_VAR 0 10
32706: IFFALSE 32724
// begin MC_InsertProduceList ( i , components ) ;
32708: LD_VAR 0 2
32712: PPUSH
32713: LD_VAR 0 10
32717: PPUSH
32718: CALL 41745 0 2
// break ;
32722: GO 32726
// end ; end ;
32724: GO 32644
32726: POP
32727: POP
// end ; continue ;
32728: GO 32224
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32730: LD_VAR 0 3
32734: PPUSH
32735: LD_INT 1
32737: PPUSH
32738: CALL_OW 289
32742: PUSH
32743: LD_INT 100
32745: LESS
32746: PUSH
32747: LD_VAR 0 3
32751: PPUSH
32752: CALL_OW 314
32756: NOT
32757: AND
32758: IFFALSE 32787
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32760: LD_VAR 0 3
32764: PPUSH
32765: LD_VAR 0 6
32769: PUSH
32770: LD_INT 2
32772: ARRAY
32773: PPUSH
32774: LD_VAR 0 6
32778: PUSH
32779: LD_INT 3
32781: ARRAY
32782: PPUSH
32783: CALL_OW 117
// break ;
32787: GO 32791
// end ;
32789: GO 32224
32791: POP
32792: POP
// end ; end ;
32793: GO 31062
32795: POP
32796: POP
// end ;
32797: LD_VAR 0 1
32801: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32802: LD_INT 0
32804: PPUSH
32805: PPUSH
32806: PPUSH
32807: PPUSH
// if not mc_bases then
32808: LD_EXP 50
32812: NOT
32813: IFFALSE 32817
// exit ;
32815: GO 32978
// for i = 1 to mc_bases do
32817: LD_ADDR_VAR 0 2
32821: PUSH
32822: DOUBLE
32823: LD_INT 1
32825: DEC
32826: ST_TO_ADDR
32827: LD_EXP 50
32831: PUSH
32832: FOR_TO
32833: IFFALSE 32976
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32835: LD_ADDR_VAR 0 4
32839: PUSH
32840: LD_EXP 69
32844: PUSH
32845: LD_VAR 0 2
32849: ARRAY
32850: PUSH
32851: LD_EXP 72
32855: PUSH
32856: LD_VAR 0 2
32860: ARRAY
32861: UNION
32862: PPUSH
32863: LD_INT 33
32865: PUSH
32866: LD_INT 2
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PPUSH
32873: CALL_OW 72
32877: ST_TO_ADDR
// if tmp then
32878: LD_VAR 0 4
32882: IFFALSE 32974
// for j in tmp do
32884: LD_ADDR_VAR 0 3
32888: PUSH
32889: LD_VAR 0 4
32893: PUSH
32894: FOR_IN
32895: IFFALSE 32972
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32897: LD_VAR 0 3
32901: PPUSH
32902: CALL_OW 312
32906: NOT
32907: PUSH
32908: LD_VAR 0 3
32912: PPUSH
32913: CALL_OW 256
32917: PUSH
32918: LD_INT 250
32920: GREATEREQUAL
32921: AND
32922: IFFALSE 32935
// Connect ( j ) else
32924: LD_VAR 0 3
32928: PPUSH
32929: CALL 56019 0 1
32933: GO 32970
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 256
32944: PUSH
32945: LD_INT 250
32947: LESS
32948: PUSH
32949: LD_VAR 0 3
32953: PPUSH
32954: CALL_OW 312
32958: AND
32959: IFFALSE 32970
// ComUnlink ( j ) ;
32961: LD_VAR 0 3
32965: PPUSH
32966: CALL_OW 136
32970: GO 32894
32972: POP
32973: POP
// end ;
32974: GO 32832
32976: POP
32977: POP
// end ;
32978: LD_VAR 0 1
32982: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32983: LD_INT 0
32985: PPUSH
32986: PPUSH
32987: PPUSH
32988: PPUSH
32989: PPUSH
// if not mc_bases then
32990: LD_EXP 50
32994: NOT
32995: IFFALSE 32999
// exit ;
32997: GO 33444
// for i = 1 to mc_bases do
32999: LD_ADDR_VAR 0 2
33003: PUSH
33004: DOUBLE
33005: LD_INT 1
33007: DEC
33008: ST_TO_ADDR
33009: LD_EXP 50
33013: PUSH
33014: FOR_TO
33015: IFFALSE 33442
// begin if not mc_produce [ i ] then
33017: LD_EXP 71
33021: PUSH
33022: LD_VAR 0 2
33026: ARRAY
33027: NOT
33028: IFFALSE 33032
// continue ;
33030: GO 33014
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33032: LD_ADDR_VAR 0 5
33036: PUSH
33037: LD_EXP 50
33041: PUSH
33042: LD_VAR 0 2
33046: ARRAY
33047: PPUSH
33048: LD_INT 30
33050: PUSH
33051: LD_INT 3
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PPUSH
33058: CALL_OW 72
33062: ST_TO_ADDR
// if not fac then
33063: LD_VAR 0 5
33067: NOT
33068: IFFALSE 33072
// continue ;
33070: GO 33014
// for j in fac do
33072: LD_ADDR_VAR 0 3
33076: PUSH
33077: LD_VAR 0 5
33081: PUSH
33082: FOR_IN
33083: IFFALSE 33438
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33085: LD_VAR 0 3
33089: PPUSH
33090: CALL_OW 461
33094: PUSH
33095: LD_INT 2
33097: NONEQUAL
33098: PUSH
33099: LD_VAR 0 3
33103: PPUSH
33104: LD_INT 15
33106: PPUSH
33107: CALL 55647 0 2
33111: PUSH
33112: LD_INT 4
33114: ARRAY
33115: OR
33116: IFFALSE 33120
// continue ;
33118: GO 33082
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33120: LD_VAR 0 3
33124: PPUSH
33125: LD_EXP 71
33129: PUSH
33130: LD_VAR 0 2
33134: ARRAY
33135: PUSH
33136: LD_INT 1
33138: ARRAY
33139: PUSH
33140: LD_INT 1
33142: ARRAY
33143: PPUSH
33144: LD_EXP 71
33148: PUSH
33149: LD_VAR 0 2
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: ARRAY
33158: PUSH
33159: LD_INT 2
33161: ARRAY
33162: PPUSH
33163: LD_EXP 71
33167: PUSH
33168: LD_VAR 0 2
33172: ARRAY
33173: PUSH
33174: LD_INT 1
33176: ARRAY
33177: PUSH
33178: LD_INT 3
33180: ARRAY
33181: PPUSH
33182: LD_EXP 71
33186: PUSH
33187: LD_VAR 0 2
33191: ARRAY
33192: PUSH
33193: LD_INT 1
33195: ARRAY
33196: PUSH
33197: LD_INT 4
33199: ARRAY
33200: PPUSH
33201: CALL_OW 448
33205: PUSH
33206: LD_VAR 0 3
33210: PPUSH
33211: LD_EXP 71
33215: PUSH
33216: LD_VAR 0 2
33220: ARRAY
33221: PUSH
33222: LD_INT 1
33224: ARRAY
33225: PUSH
33226: LD_INT 1
33228: ARRAY
33229: PUSH
33230: LD_EXP 71
33234: PUSH
33235: LD_VAR 0 2
33239: ARRAY
33240: PUSH
33241: LD_INT 1
33243: ARRAY
33244: PUSH
33245: LD_INT 2
33247: ARRAY
33248: PUSH
33249: LD_EXP 71
33253: PUSH
33254: LD_VAR 0 2
33258: ARRAY
33259: PUSH
33260: LD_INT 1
33262: ARRAY
33263: PUSH
33264: LD_INT 3
33266: ARRAY
33267: PUSH
33268: LD_EXP 71
33272: PUSH
33273: LD_VAR 0 2
33277: ARRAY
33278: PUSH
33279: LD_INT 1
33281: ARRAY
33282: PUSH
33283: LD_INT 4
33285: ARRAY
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: PPUSH
33293: CALL 59445 0 2
33297: AND
33298: IFFALSE 33436
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33300: LD_VAR 0 3
33304: PPUSH
33305: LD_EXP 71
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: PUSH
33316: LD_INT 1
33318: ARRAY
33319: PUSH
33320: LD_INT 1
33322: ARRAY
33323: PPUSH
33324: LD_EXP 71
33328: PUSH
33329: LD_VAR 0 2
33333: ARRAY
33334: PUSH
33335: LD_INT 1
33337: ARRAY
33338: PUSH
33339: LD_INT 2
33341: ARRAY
33342: PPUSH
33343: LD_EXP 71
33347: PUSH
33348: LD_VAR 0 2
33352: ARRAY
33353: PUSH
33354: LD_INT 1
33356: ARRAY
33357: PUSH
33358: LD_INT 3
33360: ARRAY
33361: PPUSH
33362: LD_EXP 71
33366: PUSH
33367: LD_VAR 0 2
33371: ARRAY
33372: PUSH
33373: LD_INT 1
33375: ARRAY
33376: PUSH
33377: LD_INT 4
33379: ARRAY
33380: PPUSH
33381: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33385: LD_ADDR_VAR 0 4
33389: PUSH
33390: LD_EXP 71
33394: PUSH
33395: LD_VAR 0 2
33399: ARRAY
33400: PPUSH
33401: LD_INT 1
33403: PPUSH
33404: CALL_OW 3
33408: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33409: LD_ADDR_EXP 71
33413: PUSH
33414: LD_EXP 71
33418: PPUSH
33419: LD_VAR 0 2
33423: PPUSH
33424: LD_VAR 0 4
33428: PPUSH
33429: CALL_OW 1
33433: ST_TO_ADDR
// break ;
33434: GO 33438
// end ; end ;
33436: GO 33082
33438: POP
33439: POP
// end ;
33440: GO 33014
33442: POP
33443: POP
// end ;
33444: LD_VAR 0 1
33448: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33449: LD_INT 0
33451: PPUSH
33452: PPUSH
33453: PPUSH
// if not mc_bases then
33454: LD_EXP 50
33458: NOT
33459: IFFALSE 33463
// exit ;
33461: GO 33552
// for i = 1 to mc_bases do
33463: LD_ADDR_VAR 0 2
33467: PUSH
33468: DOUBLE
33469: LD_INT 1
33471: DEC
33472: ST_TO_ADDR
33473: LD_EXP 50
33477: PUSH
33478: FOR_TO
33479: IFFALSE 33550
// begin if mc_attack [ i ] then
33481: LD_EXP 70
33485: PUSH
33486: LD_VAR 0 2
33490: ARRAY
33491: IFFALSE 33548
// begin tmp := mc_attack [ i ] [ 1 ] ;
33493: LD_ADDR_VAR 0 3
33497: PUSH
33498: LD_EXP 70
33502: PUSH
33503: LD_VAR 0 2
33507: ARRAY
33508: PUSH
33509: LD_INT 1
33511: ARRAY
33512: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33513: LD_ADDR_EXP 70
33517: PUSH
33518: LD_EXP 70
33522: PPUSH
33523: LD_VAR 0 2
33527: PPUSH
33528: EMPTY
33529: PPUSH
33530: CALL_OW 1
33534: ST_TO_ADDR
// Attack ( tmp ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: CALL 103111 0 1
// exit ;
33544: POP
33545: POP
33546: GO 33552
// end ; end ;
33548: GO 33478
33550: POP
33551: POP
// end ;
33552: LD_VAR 0 1
33556: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33557: LD_INT 0
33559: PPUSH
33560: PPUSH
33561: PPUSH
33562: PPUSH
33563: PPUSH
33564: PPUSH
33565: PPUSH
// if not mc_bases then
33566: LD_EXP 50
33570: NOT
33571: IFFALSE 33575
// exit ;
33573: GO 34274
// for i = 1 to mc_bases do
33575: LD_ADDR_VAR 0 2
33579: PUSH
33580: DOUBLE
33581: LD_INT 1
33583: DEC
33584: ST_TO_ADDR
33585: LD_EXP 50
33589: PUSH
33590: FOR_TO
33591: IFFALSE 34272
// begin if not mc_bases [ i ] then
33593: LD_EXP 50
33597: PUSH
33598: LD_VAR 0 2
33602: ARRAY
33603: NOT
33604: IFFALSE 33608
// continue ;
33606: GO 33590
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33608: LD_ADDR_VAR 0 7
33612: PUSH
33613: LD_EXP 50
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PUSH
33624: LD_INT 1
33626: ARRAY
33627: PPUSH
33628: CALL 49890 0 1
33632: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33633: LD_ADDR_EXP 73
33637: PUSH
33638: LD_EXP 73
33642: PPUSH
33643: LD_VAR 0 2
33647: PPUSH
33648: LD_EXP 50
33652: PUSH
33653: LD_VAR 0 2
33657: ARRAY
33658: PUSH
33659: LD_INT 1
33661: ARRAY
33662: PPUSH
33663: CALL_OW 255
33667: PPUSH
33668: LD_EXP 75
33672: PUSH
33673: LD_VAR 0 2
33677: ARRAY
33678: PPUSH
33679: CALL 49855 0 2
33683: PPUSH
33684: CALL_OW 1
33688: ST_TO_ADDR
// if not mc_scan [ i ] then
33689: LD_EXP 73
33693: PUSH
33694: LD_VAR 0 2
33698: ARRAY
33699: NOT
33700: IFFALSE 33878
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33702: LD_ADDR_VAR 0 4
33706: PUSH
33707: LD_EXP 50
33711: PUSH
33712: LD_VAR 0 2
33716: ARRAY
33717: PPUSH
33718: LD_INT 2
33720: PUSH
33721: LD_INT 25
33723: PUSH
33724: LD_INT 5
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 25
33733: PUSH
33734: LD_INT 8
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 25
33743: PUSH
33744: LD_INT 9
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: PPUSH
33757: CALL_OW 72
33761: ST_TO_ADDR
// if not tmp then
33762: LD_VAR 0 4
33766: NOT
33767: IFFALSE 33771
// continue ;
33769: GO 33590
// for j in tmp do
33771: LD_ADDR_VAR 0 3
33775: PUSH
33776: LD_VAR 0 4
33780: PUSH
33781: FOR_IN
33782: IFFALSE 33853
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33784: LD_VAR 0 3
33788: PPUSH
33789: CALL_OW 310
33793: PPUSH
33794: CALL_OW 266
33798: PUSH
33799: LD_INT 5
33801: EQUAL
33802: PUSH
33803: LD_VAR 0 3
33807: PPUSH
33808: CALL_OW 257
33812: PUSH
33813: LD_INT 1
33815: EQUAL
33816: AND
33817: PUSH
33818: LD_VAR 0 3
33822: PPUSH
33823: CALL_OW 459
33827: NOT
33828: AND
33829: PUSH
33830: LD_VAR 0 7
33834: AND
33835: IFFALSE 33851
// ComChangeProfession ( j , class ) ;
33837: LD_VAR 0 3
33841: PPUSH
33842: LD_VAR 0 7
33846: PPUSH
33847: CALL_OW 123
33851: GO 33781
33853: POP
33854: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33855: LD_ADDR_EXP 93
33859: PUSH
33860: LD_EXP 93
33864: PPUSH
33865: LD_VAR 0 2
33869: PPUSH
33870: LD_INT 0
33872: PPUSH
33873: CALL_OW 1
33877: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33878: LD_EXP 73
33882: PUSH
33883: LD_VAR 0 2
33887: ARRAY
33888: PUSH
33889: LD_EXP 93
33893: PUSH
33894: LD_VAR 0 2
33898: ARRAY
33899: NOT
33900: AND
33901: PUSH
33902: LD_EXP 72
33906: PUSH
33907: LD_VAR 0 2
33911: ARRAY
33912: NOT
33913: AND
33914: PUSH
33915: LD_EXP 50
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: PPUSH
33926: LD_INT 30
33928: PUSH
33929: LD_INT 32
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PPUSH
33936: CALL_OW 72
33940: NOT
33941: AND
33942: PUSH
33943: LD_EXP 50
33947: PUSH
33948: LD_VAR 0 2
33952: ARRAY
33953: PPUSH
33954: LD_INT 2
33956: PUSH
33957: LD_INT 30
33959: PUSH
33960: LD_INT 4
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 30
33969: PUSH
33970: LD_INT 5
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: LIST
33981: PPUSH
33982: CALL_OW 72
33986: NOT
33987: AND
33988: IFFALSE 34143
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33990: LD_ADDR_VAR 0 4
33994: PUSH
33995: LD_EXP 50
33999: PUSH
34000: LD_VAR 0 2
34004: ARRAY
34005: PPUSH
34006: LD_INT 2
34008: PUSH
34009: LD_INT 25
34011: PUSH
34012: LD_INT 1
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 25
34021: PUSH
34022: LD_INT 5
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 25
34031: PUSH
34032: LD_INT 8
34034: PUSH
34035: EMPTY
34036: LIST
34037: LIST
34038: PUSH
34039: LD_INT 25
34041: PUSH
34042: LD_INT 9
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: PPUSH
34056: CALL_OW 72
34060: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34061: LD_ADDR_VAR 0 4
34065: PUSH
34066: LD_VAR 0 4
34070: PUSH
34071: LD_VAR 0 4
34075: PPUSH
34076: LD_INT 18
34078: PPUSH
34079: CALL 81948 0 2
34083: DIFF
34084: ST_TO_ADDR
// if tmp then
34085: LD_VAR 0 4
34089: IFFALSE 34143
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34091: LD_ADDR_EXP 93
34095: PUSH
34096: LD_EXP 93
34100: PPUSH
34101: LD_VAR 0 2
34105: PPUSH
34106: LD_INT 1
34108: PPUSH
34109: CALL_OW 1
34113: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
34114: LD_VAR 0 2
34118: PPUSH
34119: LD_VAR 0 4
34123: PPUSH
34124: LD_EXP 75
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: PPUSH
34135: CALL 107820 0 3
// exit ;
34139: POP
34140: POP
34141: GO 34274
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34143: LD_EXP 73
34147: PUSH
34148: LD_VAR 0 2
34152: ARRAY
34153: PUSH
34154: LD_EXP 93
34158: PUSH
34159: LD_VAR 0 2
34163: ARRAY
34164: NOT
34165: AND
34166: PUSH
34167: LD_EXP 72
34171: PUSH
34172: LD_VAR 0 2
34176: ARRAY
34177: AND
34178: IFFALSE 34270
// begin tmp := mc_defender [ i ] ;
34180: LD_ADDR_VAR 0 4
34184: PUSH
34185: LD_EXP 72
34189: PUSH
34190: LD_VAR 0 2
34194: ARRAY
34195: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34196: LD_ADDR_EXP 72
34200: PUSH
34201: LD_EXP 72
34205: PPUSH
34206: LD_VAR 0 2
34210: PPUSH
34211: EMPTY
34212: PPUSH
34213: CALL_OW 1
34217: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34218: LD_ADDR_EXP 93
34222: PUSH
34223: LD_EXP 93
34227: PPUSH
34228: LD_VAR 0 2
34232: PPUSH
34233: LD_INT 1
34235: PPUSH
34236: CALL_OW 1
34240: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
34241: LD_VAR 0 2
34245: PPUSH
34246: LD_VAR 0 4
34250: PPUSH
34251: LD_EXP 73
34255: PUSH
34256: LD_VAR 0 2
34260: ARRAY
34261: PPUSH
34262: CALL 108381 0 3
// exit ;
34266: POP
34267: POP
34268: GO 34274
// end ; end ;
34270: GO 33590
34272: POP
34273: POP
// end ;
34274: LD_VAR 0 1
34278: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34279: LD_INT 0
34281: PPUSH
34282: PPUSH
34283: PPUSH
34284: PPUSH
34285: PPUSH
34286: PPUSH
34287: PPUSH
34288: PPUSH
34289: PPUSH
34290: PPUSH
34291: PPUSH
// if not mc_bases then
34292: LD_EXP 50
34296: NOT
34297: IFFALSE 34301
// exit ;
34299: GO 35388
// for i = 1 to mc_bases do
34301: LD_ADDR_VAR 0 2
34305: PUSH
34306: DOUBLE
34307: LD_INT 1
34309: DEC
34310: ST_TO_ADDR
34311: LD_EXP 50
34315: PUSH
34316: FOR_TO
34317: IFFALSE 35386
// begin tmp := mc_lab [ i ] ;
34319: LD_ADDR_VAR 0 6
34323: PUSH
34324: LD_EXP 83
34328: PUSH
34329: LD_VAR 0 2
34333: ARRAY
34334: ST_TO_ADDR
// if not tmp then
34335: LD_VAR 0 6
34339: NOT
34340: IFFALSE 34344
// continue ;
34342: GO 34316
// idle_lab := 0 ;
34344: LD_ADDR_VAR 0 11
34348: PUSH
34349: LD_INT 0
34351: ST_TO_ADDR
// for j in tmp do
34352: LD_ADDR_VAR 0 3
34356: PUSH
34357: LD_VAR 0 6
34361: PUSH
34362: FOR_IN
34363: IFFALSE 35382
// begin researching := false ;
34365: LD_ADDR_VAR 0 10
34369: PUSH
34370: LD_INT 0
34372: ST_TO_ADDR
// side := GetSide ( j ) ;
34373: LD_ADDR_VAR 0 4
34377: PUSH
34378: LD_VAR 0 3
34382: PPUSH
34383: CALL_OW 255
34387: ST_TO_ADDR
// if not mc_tech [ side ] then
34388: LD_EXP 77
34392: PUSH
34393: LD_VAR 0 4
34397: ARRAY
34398: NOT
34399: IFFALSE 34403
// continue ;
34401: GO 34362
// if BuildingStatus ( j ) = bs_idle then
34403: LD_VAR 0 3
34407: PPUSH
34408: CALL_OW 461
34412: PUSH
34413: LD_INT 2
34415: EQUAL
34416: IFFALSE 34604
// begin if idle_lab and UnitsInside ( j ) < 6 then
34418: LD_VAR 0 11
34422: PUSH
34423: LD_VAR 0 3
34427: PPUSH
34428: CALL_OW 313
34432: PUSH
34433: LD_INT 6
34435: LESS
34436: AND
34437: IFFALSE 34508
// begin tmp2 := UnitsInside ( idle_lab ) ;
34439: LD_ADDR_VAR 0 9
34443: PUSH
34444: LD_VAR 0 11
34448: PPUSH
34449: CALL_OW 313
34453: ST_TO_ADDR
// if tmp2 then
34454: LD_VAR 0 9
34458: IFFALSE 34500
// for x in tmp2 do
34460: LD_ADDR_VAR 0 7
34464: PUSH
34465: LD_VAR 0 9
34469: PUSH
34470: FOR_IN
34471: IFFALSE 34498
// begin ComExitBuilding ( x ) ;
34473: LD_VAR 0 7
34477: PPUSH
34478: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34482: LD_VAR 0 7
34486: PPUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: CALL_OW 180
// end ;
34496: GO 34470
34498: POP
34499: POP
// idle_lab := 0 ;
34500: LD_ADDR_VAR 0 11
34504: PUSH
34505: LD_INT 0
34507: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34508: LD_ADDR_VAR 0 5
34512: PUSH
34513: LD_EXP 77
34517: PUSH
34518: LD_VAR 0 4
34522: ARRAY
34523: PUSH
34524: FOR_IN
34525: IFFALSE 34585
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34527: LD_VAR 0 3
34531: PPUSH
34532: LD_VAR 0 5
34536: PPUSH
34537: CALL_OW 430
34541: PUSH
34542: LD_VAR 0 4
34546: PPUSH
34547: LD_VAR 0 5
34551: PPUSH
34552: CALL 48960 0 2
34556: AND
34557: IFFALSE 34583
// begin researching := true ;
34559: LD_ADDR_VAR 0 10
34563: PUSH
34564: LD_INT 1
34566: ST_TO_ADDR
// ComResearch ( j , t ) ;
34567: LD_VAR 0 3
34571: PPUSH
34572: LD_VAR 0 5
34576: PPUSH
34577: CALL_OW 124
// break ;
34581: GO 34585
// end ;
34583: GO 34524
34585: POP
34586: POP
// if not researching then
34587: LD_VAR 0 10
34591: NOT
34592: IFFALSE 34604
// idle_lab := j ;
34594: LD_ADDR_VAR 0 11
34598: PUSH
34599: LD_VAR 0 3
34603: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34604: LD_VAR 0 3
34608: PPUSH
34609: CALL_OW 461
34613: PUSH
34614: LD_INT 10
34616: EQUAL
34617: IFFALSE 35205
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34619: LD_EXP 79
34623: PUSH
34624: LD_VAR 0 2
34628: ARRAY
34629: NOT
34630: PUSH
34631: LD_EXP 80
34635: PUSH
34636: LD_VAR 0 2
34640: ARRAY
34641: NOT
34642: AND
34643: PUSH
34644: LD_EXP 77
34648: PUSH
34649: LD_VAR 0 4
34653: ARRAY
34654: PUSH
34655: LD_INT 1
34657: GREATER
34658: AND
34659: IFFALSE 34790
// begin ComCancel ( j ) ;
34661: LD_VAR 0 3
34665: PPUSH
34666: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34670: LD_ADDR_EXP 77
34674: PUSH
34675: LD_EXP 77
34679: PPUSH
34680: LD_VAR 0 4
34684: PPUSH
34685: LD_EXP 77
34689: PUSH
34690: LD_VAR 0 4
34694: ARRAY
34695: PPUSH
34696: LD_EXP 77
34700: PUSH
34701: LD_VAR 0 4
34705: ARRAY
34706: PUSH
34707: LD_INT 1
34709: MINUS
34710: PPUSH
34711: LD_EXP 77
34715: PUSH
34716: LD_VAR 0 4
34720: ARRAY
34721: PPUSH
34722: LD_INT 0
34724: PPUSH
34725: CALL 52472 0 4
34729: PPUSH
34730: CALL_OW 1
34734: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34735: LD_ADDR_EXP 77
34739: PUSH
34740: LD_EXP 77
34744: PPUSH
34745: LD_VAR 0 4
34749: PPUSH
34750: LD_EXP 77
34754: PUSH
34755: LD_VAR 0 4
34759: ARRAY
34760: PPUSH
34761: LD_EXP 77
34765: PUSH
34766: LD_VAR 0 4
34770: ARRAY
34771: PPUSH
34772: LD_INT 1
34774: PPUSH
34775: LD_INT 0
34777: PPUSH
34778: CALL 52472 0 4
34782: PPUSH
34783: CALL_OW 1
34787: ST_TO_ADDR
// continue ;
34788: GO 34362
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34790: LD_EXP 79
34794: PUSH
34795: LD_VAR 0 2
34799: ARRAY
34800: PUSH
34801: LD_EXP 80
34805: PUSH
34806: LD_VAR 0 2
34810: ARRAY
34811: NOT
34812: AND
34813: IFFALSE 34940
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34815: LD_ADDR_EXP 80
34819: PUSH
34820: LD_EXP 80
34824: PPUSH
34825: LD_VAR 0 2
34829: PUSH
34830: LD_EXP 80
34834: PUSH
34835: LD_VAR 0 2
34839: ARRAY
34840: PUSH
34841: LD_INT 1
34843: PLUS
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PPUSH
34849: LD_EXP 79
34853: PUSH
34854: LD_VAR 0 2
34858: ARRAY
34859: PUSH
34860: LD_INT 1
34862: ARRAY
34863: PPUSH
34864: CALL 53054 0 3
34868: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34869: LD_EXP 79
34873: PUSH
34874: LD_VAR 0 2
34878: ARRAY
34879: PUSH
34880: LD_INT 1
34882: ARRAY
34883: PPUSH
34884: LD_INT 112
34886: PPUSH
34887: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34891: LD_ADDR_VAR 0 9
34895: PUSH
34896: LD_EXP 79
34900: PUSH
34901: LD_VAR 0 2
34905: ARRAY
34906: PPUSH
34907: LD_INT 1
34909: PPUSH
34910: CALL_OW 3
34914: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34915: LD_ADDR_EXP 79
34919: PUSH
34920: LD_EXP 79
34924: PPUSH
34925: LD_VAR 0 2
34929: PPUSH
34930: LD_VAR 0 9
34934: PPUSH
34935: CALL_OW 1
34939: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34940: LD_EXP 79
34944: PUSH
34945: LD_VAR 0 2
34949: ARRAY
34950: PUSH
34951: LD_EXP 80
34955: PUSH
34956: LD_VAR 0 2
34960: ARRAY
34961: AND
34962: PUSH
34963: LD_EXP 80
34967: PUSH
34968: LD_VAR 0 2
34972: ARRAY
34973: PUSH
34974: LD_INT 1
34976: ARRAY
34977: PPUSH
34978: CALL_OW 310
34982: NOT
34983: AND
34984: PUSH
34985: LD_VAR 0 3
34989: PPUSH
34990: CALL_OW 313
34994: PUSH
34995: LD_INT 6
34997: EQUAL
34998: AND
34999: IFFALSE 35055
// begin tmp2 := UnitsInside ( j ) ;
35001: LD_ADDR_VAR 0 9
35005: PUSH
35006: LD_VAR 0 3
35010: PPUSH
35011: CALL_OW 313
35015: ST_TO_ADDR
// if tmp2 = 6 then
35016: LD_VAR 0 9
35020: PUSH
35021: LD_INT 6
35023: EQUAL
35024: IFFALSE 35055
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35026: LD_VAR 0 9
35030: PUSH
35031: LD_INT 1
35033: ARRAY
35034: PPUSH
35035: LD_INT 112
35037: PPUSH
35038: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35042: LD_VAR 0 9
35046: PUSH
35047: LD_INT 1
35049: ARRAY
35050: PPUSH
35051: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35055: LD_EXP 80
35059: PUSH
35060: LD_VAR 0 2
35064: ARRAY
35065: PUSH
35066: LD_EXP 80
35070: PUSH
35071: LD_VAR 0 2
35075: ARRAY
35076: PUSH
35077: LD_INT 1
35079: ARRAY
35080: PPUSH
35081: CALL_OW 314
35085: NOT
35086: AND
35087: PUSH
35088: LD_EXP 80
35092: PUSH
35093: LD_VAR 0 2
35097: ARRAY
35098: PUSH
35099: LD_INT 1
35101: ARRAY
35102: PPUSH
35103: CALL_OW 310
35107: NOT
35108: AND
35109: IFFALSE 35135
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35111: LD_EXP 80
35115: PUSH
35116: LD_VAR 0 2
35120: ARRAY
35121: PUSH
35122: LD_INT 1
35124: ARRAY
35125: PPUSH
35126: LD_VAR 0 3
35130: PPUSH
35131: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35135: LD_EXP 80
35139: PUSH
35140: LD_VAR 0 2
35144: ARRAY
35145: PUSH
35146: LD_INT 1
35148: ARRAY
35149: PPUSH
35150: CALL_OW 310
35154: PUSH
35155: LD_EXP 80
35159: PUSH
35160: LD_VAR 0 2
35164: ARRAY
35165: PUSH
35166: LD_INT 1
35168: ARRAY
35169: PPUSH
35170: CALL_OW 310
35174: PPUSH
35175: CALL_OW 461
35179: PUSH
35180: LD_INT 3
35182: NONEQUAL
35183: AND
35184: IFFALSE 35205
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35186: LD_EXP 80
35190: PUSH
35191: LD_VAR 0 2
35195: ARRAY
35196: PUSH
35197: LD_INT 1
35199: ARRAY
35200: PPUSH
35201: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35205: LD_VAR 0 3
35209: PPUSH
35210: CALL_OW 461
35214: PUSH
35215: LD_INT 6
35217: EQUAL
35218: PUSH
35219: LD_VAR 0 6
35223: PUSH
35224: LD_INT 1
35226: GREATER
35227: AND
35228: IFFALSE 35380
// begin sci := [ ] ;
35230: LD_ADDR_VAR 0 8
35234: PUSH
35235: EMPTY
35236: ST_TO_ADDR
// for x in ( tmp diff j ) do
35237: LD_ADDR_VAR 0 7
35241: PUSH
35242: LD_VAR 0 6
35246: PUSH
35247: LD_VAR 0 3
35251: DIFF
35252: PUSH
35253: FOR_IN
35254: IFFALSE 35306
// begin if sci = 6 then
35256: LD_VAR 0 8
35260: PUSH
35261: LD_INT 6
35263: EQUAL
35264: IFFALSE 35268
// break ;
35266: GO 35306
// if BuildingStatus ( x ) = bs_idle then
35268: LD_VAR 0 7
35272: PPUSH
35273: CALL_OW 461
35277: PUSH
35278: LD_INT 2
35280: EQUAL
35281: IFFALSE 35304
// sci := sci ^ UnitsInside ( x ) ;
35283: LD_ADDR_VAR 0 8
35287: PUSH
35288: LD_VAR 0 8
35292: PUSH
35293: LD_VAR 0 7
35297: PPUSH
35298: CALL_OW 313
35302: ADD
35303: ST_TO_ADDR
// end ;
35304: GO 35253
35306: POP
35307: POP
// if not sci then
35308: LD_VAR 0 8
35312: NOT
35313: IFFALSE 35317
// continue ;
35315: GO 34362
// for x in sci do
35317: LD_ADDR_VAR 0 7
35321: PUSH
35322: LD_VAR 0 8
35326: PUSH
35327: FOR_IN
35328: IFFALSE 35378
// if IsInUnit ( x ) and not HasTask ( x ) then
35330: LD_VAR 0 7
35334: PPUSH
35335: CALL_OW 310
35339: PUSH
35340: LD_VAR 0 7
35344: PPUSH
35345: CALL_OW 314
35349: NOT
35350: AND
35351: IFFALSE 35376
// begin ComExitBuilding ( x ) ;
35353: LD_VAR 0 7
35357: PPUSH
35358: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35362: LD_VAR 0 7
35366: PPUSH
35367: LD_VAR 0 3
35371: PPUSH
35372: CALL_OW 180
// end ;
35376: GO 35327
35378: POP
35379: POP
// end ; end ;
35380: GO 34362
35382: POP
35383: POP
// end ;
35384: GO 34316
35386: POP
35387: POP
// end ;
35388: LD_VAR 0 1
35392: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35393: LD_INT 0
35395: PPUSH
35396: PPUSH
// if not mc_bases then
35397: LD_EXP 50
35401: NOT
35402: IFFALSE 35406
// exit ;
35404: GO 35487
// for i = 1 to mc_bases do
35406: LD_ADDR_VAR 0 2
35410: PUSH
35411: DOUBLE
35412: LD_INT 1
35414: DEC
35415: ST_TO_ADDR
35416: LD_EXP 50
35420: PUSH
35421: FOR_TO
35422: IFFALSE 35485
// if mc_mines [ i ] and mc_miners [ i ] then
35424: LD_EXP 63
35428: PUSH
35429: LD_VAR 0 2
35433: ARRAY
35434: PUSH
35435: LD_EXP 64
35439: PUSH
35440: LD_VAR 0 2
35444: ARRAY
35445: AND
35446: IFFALSE 35483
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35448: LD_EXP 64
35452: PUSH
35453: LD_VAR 0 2
35457: ARRAY
35458: PUSH
35459: LD_INT 1
35461: ARRAY
35462: PPUSH
35463: CALL_OW 255
35467: PPUSH
35468: LD_EXP 63
35472: PUSH
35473: LD_VAR 0 2
35477: ARRAY
35478: PPUSH
35479: CALL 50043 0 2
35483: GO 35421
35485: POP
35486: POP
// end ;
35487: LD_VAR 0 1
35491: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35492: LD_INT 0
35494: PPUSH
35495: PPUSH
35496: PPUSH
35497: PPUSH
35498: PPUSH
35499: PPUSH
35500: PPUSH
35501: PPUSH
// if not mc_bases or not mc_parking then
35502: LD_EXP 50
35506: NOT
35507: PUSH
35508: LD_EXP 74
35512: NOT
35513: OR
35514: IFFALSE 35518
// exit ;
35516: GO 36217
// for i = 1 to mc_bases do
35518: LD_ADDR_VAR 0 2
35522: PUSH
35523: DOUBLE
35524: LD_INT 1
35526: DEC
35527: ST_TO_ADDR
35528: LD_EXP 50
35532: PUSH
35533: FOR_TO
35534: IFFALSE 36215
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35536: LD_EXP 50
35540: PUSH
35541: LD_VAR 0 2
35545: ARRAY
35546: NOT
35547: PUSH
35548: LD_EXP 74
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: NOT
35559: OR
35560: IFFALSE 35564
// continue ;
35562: GO 35533
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35564: LD_ADDR_VAR 0 5
35568: PUSH
35569: LD_EXP 50
35573: PUSH
35574: LD_VAR 0 2
35578: ARRAY
35579: PUSH
35580: LD_INT 1
35582: ARRAY
35583: PPUSH
35584: CALL_OW 255
35588: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35589: LD_ADDR_VAR 0 6
35593: PUSH
35594: LD_EXP 50
35598: PUSH
35599: LD_VAR 0 2
35603: ARRAY
35604: PPUSH
35605: LD_INT 30
35607: PUSH
35608: LD_INT 3
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PPUSH
35615: CALL_OW 72
35619: ST_TO_ADDR
// if not fac then
35620: LD_VAR 0 6
35624: NOT
35625: IFFALSE 35676
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35627: LD_ADDR_VAR 0 6
35631: PUSH
35632: LD_EXP 50
35636: PUSH
35637: LD_VAR 0 2
35641: ARRAY
35642: PPUSH
35643: LD_INT 2
35645: PUSH
35646: LD_INT 30
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 30
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: LIST
35670: PPUSH
35671: CALL_OW 72
35675: ST_TO_ADDR
// if not fac then
35676: LD_VAR 0 6
35680: NOT
35681: IFFALSE 35685
// continue ;
35683: GO 35533
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35685: LD_ADDR_VAR 0 7
35689: PUSH
35690: LD_EXP 74
35694: PUSH
35695: LD_VAR 0 2
35699: ARRAY
35700: PPUSH
35701: LD_INT 22
35703: PUSH
35704: LD_VAR 0 5
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 21
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 3
35725: PUSH
35726: LD_INT 24
35728: PUSH
35729: LD_INT 1000
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: LIST
35744: PPUSH
35745: CALL_OW 70
35749: ST_TO_ADDR
// for j in fac do
35750: LD_ADDR_VAR 0 3
35754: PUSH
35755: LD_VAR 0 6
35759: PUSH
35760: FOR_IN
35761: IFFALSE 35842
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35763: LD_ADDR_VAR 0 7
35767: PUSH
35768: LD_VAR 0 7
35772: PUSH
35773: LD_INT 22
35775: PUSH
35776: LD_VAR 0 5
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 91
35787: PUSH
35788: LD_VAR 0 3
35792: PUSH
35793: LD_INT 15
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 21
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 3
35813: PUSH
35814: LD_INT 24
35816: PUSH
35817: LD_INT 1000
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: PPUSH
35834: CALL_OW 69
35838: UNION
35839: ST_TO_ADDR
35840: GO 35760
35842: POP
35843: POP
// if not vehs then
35844: LD_VAR 0 7
35848: NOT
35849: IFFALSE 35875
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35851: LD_ADDR_EXP 62
35855: PUSH
35856: LD_EXP 62
35860: PPUSH
35861: LD_VAR 0 2
35865: PPUSH
35866: EMPTY
35867: PPUSH
35868: CALL_OW 1
35872: ST_TO_ADDR
// continue ;
35873: GO 35533
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35875: LD_ADDR_VAR 0 8
35879: PUSH
35880: LD_EXP 50
35884: PUSH
35885: LD_VAR 0 2
35889: ARRAY
35890: PPUSH
35891: LD_INT 30
35893: PUSH
35894: LD_INT 3
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PPUSH
35901: CALL_OW 72
35905: ST_TO_ADDR
// if tmp then
35906: LD_VAR 0 8
35910: IFFALSE 36013
// begin for j in tmp do
35912: LD_ADDR_VAR 0 3
35916: PUSH
35917: LD_VAR 0 8
35921: PUSH
35922: FOR_IN
35923: IFFALSE 36011
// for k in UnitsInside ( j ) do
35925: LD_ADDR_VAR 0 4
35929: PUSH
35930: LD_VAR 0 3
35934: PPUSH
35935: CALL_OW 313
35939: PUSH
35940: FOR_IN
35941: IFFALSE 36007
// if k then
35943: LD_VAR 0 4
35947: IFFALSE 36005
// if not k in mc_repair_vehicle [ i ] then
35949: LD_VAR 0 4
35953: PUSH
35954: LD_EXP 62
35958: PUSH
35959: LD_VAR 0 2
35963: ARRAY
35964: IN
35965: NOT
35966: IFFALSE 36005
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35968: LD_ADDR_EXP 62
35972: PUSH
35973: LD_EXP 62
35977: PPUSH
35978: LD_VAR 0 2
35982: PPUSH
35983: LD_EXP 62
35987: PUSH
35988: LD_VAR 0 2
35992: ARRAY
35993: PUSH
35994: LD_VAR 0 4
35998: UNION
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
36005: GO 35940
36007: POP
36008: POP
36009: GO 35922
36011: POP
36012: POP
// end ; if not mc_repair_vehicle [ i ] then
36013: LD_EXP 62
36017: PUSH
36018: LD_VAR 0 2
36022: ARRAY
36023: NOT
36024: IFFALSE 36028
// continue ;
36026: GO 35533
// for j in mc_repair_vehicle [ i ] do
36028: LD_ADDR_VAR 0 3
36032: PUSH
36033: LD_EXP 62
36037: PUSH
36038: LD_VAR 0 2
36042: ARRAY
36043: PUSH
36044: FOR_IN
36045: IFFALSE 36211
// begin if GetClass ( j ) <> 3 then
36047: LD_VAR 0 3
36051: PPUSH
36052: CALL_OW 257
36056: PUSH
36057: LD_INT 3
36059: NONEQUAL
36060: IFFALSE 36101
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36062: LD_ADDR_EXP 62
36066: PUSH
36067: LD_EXP 62
36071: PPUSH
36072: LD_VAR 0 2
36076: PPUSH
36077: LD_EXP 62
36081: PUSH
36082: LD_VAR 0 2
36086: ARRAY
36087: PUSH
36088: LD_VAR 0 3
36092: DIFF
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// continue ;
36099: GO 36044
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36101: LD_VAR 0 3
36105: PPUSH
36106: CALL_OW 311
36110: NOT
36111: PUSH
36112: LD_VAR 0 3
36116: PUSH
36117: LD_EXP 53
36121: PUSH
36122: LD_VAR 0 2
36126: ARRAY
36127: PUSH
36128: LD_INT 1
36130: ARRAY
36131: IN
36132: NOT
36133: AND
36134: PUSH
36135: LD_VAR 0 3
36139: PUSH
36140: LD_EXP 53
36144: PUSH
36145: LD_VAR 0 2
36149: ARRAY
36150: PUSH
36151: LD_INT 2
36153: ARRAY
36154: IN
36155: NOT
36156: AND
36157: IFFALSE 36209
// begin if IsInUnit ( j ) then
36159: LD_VAR 0 3
36163: PPUSH
36164: CALL_OW 310
36168: IFFALSE 36179
// ComExitBuilding ( j ) ;
36170: LD_VAR 0 3
36174: PPUSH
36175: CALL_OW 122
// if not HasTask ( j ) then
36179: LD_VAR 0 3
36183: PPUSH
36184: CALL_OW 314
36188: NOT
36189: IFFALSE 36209
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
36191: LD_VAR 0 3
36195: PPUSH
36196: LD_VAR 0 7
36200: PUSH
36201: LD_INT 1
36203: ARRAY
36204: PPUSH
36205: CALL_OW 189
// end ; end ;
36209: GO 36044
36211: POP
36212: POP
// end ;
36213: GO 35533
36215: POP
36216: POP
// end ;
36217: LD_VAR 0 1
36221: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36222: LD_INT 0
36224: PPUSH
36225: PPUSH
36226: PPUSH
36227: PPUSH
36228: PPUSH
36229: PPUSH
36230: PPUSH
36231: PPUSH
36232: PPUSH
36233: PPUSH
36234: PPUSH
// if not mc_bases then
36235: LD_EXP 50
36239: NOT
36240: IFFALSE 36244
// exit ;
36242: GO 37046
// for i = 1 to mc_bases do
36244: LD_ADDR_VAR 0 2
36248: PUSH
36249: DOUBLE
36250: LD_INT 1
36252: DEC
36253: ST_TO_ADDR
36254: LD_EXP 50
36258: PUSH
36259: FOR_TO
36260: IFFALSE 37044
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36262: LD_EXP 78
36266: PUSH
36267: LD_VAR 0 2
36271: ARRAY
36272: NOT
36273: PUSH
36274: LD_EXP 53
36278: PUSH
36279: LD_VAR 0 2
36283: ARRAY
36284: PUSH
36285: LD_INT 1
36287: ARRAY
36288: OR
36289: PUSH
36290: LD_EXP 53
36294: PUSH
36295: LD_VAR 0 2
36299: ARRAY
36300: PUSH
36301: LD_INT 2
36303: ARRAY
36304: OR
36305: PUSH
36306: LD_EXP 76
36310: PUSH
36311: LD_VAR 0 2
36315: ARRAY
36316: PPUSH
36317: LD_INT 1
36319: PPUSH
36320: CALL_OW 325
36324: NOT
36325: OR
36326: PUSH
36327: LD_EXP 73
36331: PUSH
36332: LD_VAR 0 2
36336: ARRAY
36337: OR
36338: IFFALSE 36342
// continue ;
36340: GO 36259
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36342: LD_ADDR_VAR 0 8
36346: PUSH
36347: LD_EXP 50
36351: PUSH
36352: LD_VAR 0 2
36356: ARRAY
36357: PPUSH
36358: LD_INT 25
36360: PUSH
36361: LD_INT 4
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 50
36370: PUSH
36371: EMPTY
36372: LIST
36373: PUSH
36374: LD_INT 3
36376: PUSH
36377: LD_INT 60
36379: PUSH
36380: EMPTY
36381: LIST
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: LIST
36391: PPUSH
36392: CALL_OW 72
36396: PUSH
36397: LD_EXP 54
36401: PUSH
36402: LD_VAR 0 2
36406: ARRAY
36407: DIFF
36408: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36409: LD_ADDR_VAR 0 9
36413: PUSH
36414: LD_EXP 50
36418: PUSH
36419: LD_VAR 0 2
36423: ARRAY
36424: PPUSH
36425: LD_INT 2
36427: PUSH
36428: LD_INT 30
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 30
36440: PUSH
36441: LD_INT 1
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: LIST
36452: PPUSH
36453: CALL_OW 72
36457: ST_TO_ADDR
// if not tmp or not dep then
36458: LD_VAR 0 8
36462: NOT
36463: PUSH
36464: LD_VAR 0 9
36468: NOT
36469: OR
36470: IFFALSE 36474
// continue ;
36472: GO 36259
// side := GetSide ( tmp [ 1 ] ) ;
36474: LD_ADDR_VAR 0 11
36478: PUSH
36479: LD_VAR 0 8
36483: PUSH
36484: LD_INT 1
36486: ARRAY
36487: PPUSH
36488: CALL_OW 255
36492: ST_TO_ADDR
// dep := dep [ 1 ] ;
36493: LD_ADDR_VAR 0 9
36497: PUSH
36498: LD_VAR 0 9
36502: PUSH
36503: LD_INT 1
36505: ARRAY
36506: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36507: LD_ADDR_VAR 0 7
36511: PUSH
36512: LD_EXP 78
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 22
36525: PUSH
36526: LD_INT 0
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 25
36535: PUSH
36536: LD_INT 12
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PPUSH
36547: CALL_OW 70
36551: PUSH
36552: LD_INT 22
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 25
36564: PUSH
36565: LD_INT 12
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 91
36574: PUSH
36575: LD_VAR 0 9
36579: PUSH
36580: LD_INT 20
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: LIST
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: LIST
36592: PPUSH
36593: CALL_OW 69
36597: UNION
36598: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36599: LD_ADDR_VAR 0 10
36603: PUSH
36604: LD_EXP 78
36608: PUSH
36609: LD_VAR 0 2
36613: ARRAY
36614: PPUSH
36615: LD_INT 81
36617: PUSH
36618: LD_VAR 0 11
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PPUSH
36627: CALL_OW 70
36631: ST_TO_ADDR
// if not apes or danger_at_area then
36632: LD_VAR 0 7
36636: NOT
36637: PUSH
36638: LD_VAR 0 10
36642: OR
36643: IFFALSE 36693
// begin if mc_taming [ i ] then
36645: LD_EXP 81
36649: PUSH
36650: LD_VAR 0 2
36654: ARRAY
36655: IFFALSE 36691
// begin MC_Reset ( i , 121 ) ;
36657: LD_VAR 0 2
36661: PPUSH
36662: LD_INT 121
36664: PPUSH
36665: CALL 21980 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36669: LD_ADDR_EXP 81
36673: PUSH
36674: LD_EXP 81
36678: PPUSH
36679: LD_VAR 0 2
36683: PPUSH
36684: EMPTY
36685: PPUSH
36686: CALL_OW 1
36690: ST_TO_ADDR
// end ; continue ;
36691: GO 36259
// end ; for j in tmp do
36693: LD_ADDR_VAR 0 3
36697: PUSH
36698: LD_VAR 0 8
36702: PUSH
36703: FOR_IN
36704: IFFALSE 37040
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36706: LD_VAR 0 3
36710: PUSH
36711: LD_EXP 81
36715: PUSH
36716: LD_VAR 0 2
36720: ARRAY
36721: IN
36722: NOT
36723: PUSH
36724: LD_EXP 81
36728: PUSH
36729: LD_VAR 0 2
36733: ARRAY
36734: PUSH
36735: LD_INT 3
36737: LESS
36738: AND
36739: IFFALSE 36797
// begin SetTag ( j , 121 ) ;
36741: LD_VAR 0 3
36745: PPUSH
36746: LD_INT 121
36748: PPUSH
36749: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36753: LD_ADDR_EXP 81
36757: PUSH
36758: LD_EXP 81
36762: PPUSH
36763: LD_VAR 0 2
36767: PUSH
36768: LD_EXP 81
36772: PUSH
36773: LD_VAR 0 2
36777: ARRAY
36778: PUSH
36779: LD_INT 1
36781: PLUS
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: PPUSH
36787: LD_VAR 0 3
36791: PPUSH
36792: CALL 53054 0 3
36796: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36797: LD_VAR 0 3
36801: PUSH
36802: LD_EXP 81
36806: PUSH
36807: LD_VAR 0 2
36811: ARRAY
36812: IN
36813: IFFALSE 37038
// begin if GetClass ( j ) <> 4 then
36815: LD_VAR 0 3
36819: PPUSH
36820: CALL_OW 257
36824: PUSH
36825: LD_INT 4
36827: NONEQUAL
36828: IFFALSE 36881
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36830: LD_ADDR_EXP 81
36834: PUSH
36835: LD_EXP 81
36839: PPUSH
36840: LD_VAR 0 2
36844: PPUSH
36845: LD_EXP 81
36849: PUSH
36850: LD_VAR 0 2
36854: ARRAY
36855: PUSH
36856: LD_VAR 0 3
36860: DIFF
36861: PPUSH
36862: CALL_OW 1
36866: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36867: LD_VAR 0 3
36871: PPUSH
36872: LD_INT 0
36874: PPUSH
36875: CALL_OW 109
// continue ;
36879: GO 36703
// end ; if IsInUnit ( j ) then
36881: LD_VAR 0 3
36885: PPUSH
36886: CALL_OW 310
36890: IFFALSE 36901
// ComExitBuilding ( j ) ;
36892: LD_VAR 0 3
36896: PPUSH
36897: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36901: LD_ADDR_VAR 0 6
36905: PUSH
36906: LD_VAR 0 7
36910: PPUSH
36911: LD_VAR 0 3
36915: PPUSH
36916: CALL_OW 74
36920: ST_TO_ADDR
// if not ape then
36921: LD_VAR 0 6
36925: NOT
36926: IFFALSE 36930
// break ;
36928: GO 37040
// x := GetX ( ape ) ;
36930: LD_ADDR_VAR 0 4
36934: PUSH
36935: LD_VAR 0 6
36939: PPUSH
36940: CALL_OW 250
36944: ST_TO_ADDR
// y := GetY ( ape ) ;
36945: LD_ADDR_VAR 0 5
36949: PUSH
36950: LD_VAR 0 6
36954: PPUSH
36955: CALL_OW 251
36959: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36960: LD_VAR 0 4
36964: PPUSH
36965: LD_VAR 0 5
36969: PPUSH
36970: CALL_OW 488
36974: NOT
36975: PUSH
36976: LD_VAR 0 11
36980: PPUSH
36981: LD_VAR 0 4
36985: PPUSH
36986: LD_VAR 0 5
36990: PPUSH
36991: LD_INT 20
36993: PPUSH
36994: CALL 53950 0 4
36998: PUSH
36999: LD_INT 4
37001: ARRAY
37002: OR
37003: IFFALSE 37007
// break ;
37005: GO 37040
// if not HasTask ( j ) then
37007: LD_VAR 0 3
37011: PPUSH
37012: CALL_OW 314
37016: NOT
37017: IFFALSE 37038
// ComTameXY ( j , x , y ) ;
37019: LD_VAR 0 3
37023: PPUSH
37024: LD_VAR 0 4
37028: PPUSH
37029: LD_VAR 0 5
37033: PPUSH
37034: CALL_OW 131
// end ; end ;
37038: GO 36703
37040: POP
37041: POP
// end ;
37042: GO 36259
37044: POP
37045: POP
// end ;
37046: LD_VAR 0 1
37050: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37051: LD_INT 0
37053: PPUSH
37054: PPUSH
37055: PPUSH
37056: PPUSH
37057: PPUSH
37058: PPUSH
37059: PPUSH
37060: PPUSH
// if not mc_bases then
37061: LD_EXP 50
37065: NOT
37066: IFFALSE 37070
// exit ;
37068: GO 37696
// for i = 1 to mc_bases do
37070: LD_ADDR_VAR 0 2
37074: PUSH
37075: DOUBLE
37076: LD_INT 1
37078: DEC
37079: ST_TO_ADDR
37080: LD_EXP 50
37084: PUSH
37085: FOR_TO
37086: IFFALSE 37694
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37088: LD_EXP 79
37092: PUSH
37093: LD_VAR 0 2
37097: ARRAY
37098: NOT
37099: PUSH
37100: LD_EXP 79
37104: PUSH
37105: LD_VAR 0 2
37109: ARRAY
37110: PPUSH
37111: LD_INT 25
37113: PUSH
37114: LD_INT 12
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PPUSH
37121: CALL_OW 72
37125: NOT
37126: OR
37127: IFFALSE 37131
// continue ;
37129: GO 37085
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37131: LD_ADDR_VAR 0 5
37135: PUSH
37136: LD_EXP 79
37140: PUSH
37141: LD_VAR 0 2
37145: ARRAY
37146: PUSH
37147: LD_INT 1
37149: ARRAY
37150: PPUSH
37151: CALL_OW 255
37155: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37156: LD_VAR 0 5
37160: PPUSH
37161: LD_INT 2
37163: PPUSH
37164: CALL_OW 325
37168: IFFALSE 37421
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37170: LD_ADDR_VAR 0 4
37174: PUSH
37175: LD_EXP 79
37179: PUSH
37180: LD_VAR 0 2
37184: ARRAY
37185: PPUSH
37186: LD_INT 25
37188: PUSH
37189: LD_INT 16
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PPUSH
37196: CALL_OW 72
37200: ST_TO_ADDR
// if tmp < 6 then
37201: LD_VAR 0 4
37205: PUSH
37206: LD_INT 6
37208: LESS
37209: IFFALSE 37421
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37211: LD_ADDR_VAR 0 6
37215: PUSH
37216: LD_EXP 50
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: PPUSH
37227: LD_INT 2
37229: PUSH
37230: LD_INT 30
37232: PUSH
37233: LD_INT 0
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 30
37242: PUSH
37243: LD_INT 1
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: LIST
37254: PPUSH
37255: CALL_OW 72
37259: ST_TO_ADDR
// if depot then
37260: LD_VAR 0 6
37264: IFFALSE 37421
// begin selected := 0 ;
37266: LD_ADDR_VAR 0 7
37270: PUSH
37271: LD_INT 0
37273: ST_TO_ADDR
// for j in depot do
37274: LD_ADDR_VAR 0 3
37278: PUSH
37279: LD_VAR 0 6
37283: PUSH
37284: FOR_IN
37285: IFFALSE 37316
// begin if UnitsInside ( j ) < 6 then
37287: LD_VAR 0 3
37291: PPUSH
37292: CALL_OW 313
37296: PUSH
37297: LD_INT 6
37299: LESS
37300: IFFALSE 37314
// begin selected := j ;
37302: LD_ADDR_VAR 0 7
37306: PUSH
37307: LD_VAR 0 3
37311: ST_TO_ADDR
// break ;
37312: GO 37316
// end ; end ;
37314: GO 37284
37316: POP
37317: POP
// if selected then
37318: LD_VAR 0 7
37322: IFFALSE 37421
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37324: LD_ADDR_VAR 0 3
37328: PUSH
37329: LD_EXP 79
37333: PUSH
37334: LD_VAR 0 2
37338: ARRAY
37339: PPUSH
37340: LD_INT 25
37342: PUSH
37343: LD_INT 12
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PPUSH
37350: CALL_OW 72
37354: PUSH
37355: FOR_IN
37356: IFFALSE 37419
// if not HasTask ( j ) then
37358: LD_VAR 0 3
37362: PPUSH
37363: CALL_OW 314
37367: NOT
37368: IFFALSE 37417
// begin if not IsInUnit ( j ) then
37370: LD_VAR 0 3
37374: PPUSH
37375: CALL_OW 310
37379: NOT
37380: IFFALSE 37396
// ComEnterUnit ( j , selected ) ;
37382: LD_VAR 0 3
37386: PPUSH
37387: LD_VAR 0 7
37391: PPUSH
37392: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37396: LD_VAR 0 3
37400: PPUSH
37401: LD_INT 16
37403: PPUSH
37404: CALL_OW 183
// AddComExitBuilding ( j ) ;
37408: LD_VAR 0 3
37412: PPUSH
37413: CALL_OW 182
// end ;
37417: GO 37355
37419: POP
37420: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37421: LD_VAR 0 5
37425: PPUSH
37426: LD_INT 11
37428: PPUSH
37429: CALL_OW 325
37433: IFFALSE 37692
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37435: LD_ADDR_VAR 0 4
37439: PUSH
37440: LD_EXP 79
37444: PUSH
37445: LD_VAR 0 2
37449: ARRAY
37450: PPUSH
37451: LD_INT 25
37453: PUSH
37454: LD_INT 16
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PPUSH
37461: CALL_OW 72
37465: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37466: LD_VAR 0 4
37470: PUSH
37471: LD_INT 6
37473: GREATEREQUAL
37474: PUSH
37475: LD_VAR 0 5
37479: PPUSH
37480: LD_INT 2
37482: PPUSH
37483: CALL_OW 325
37487: NOT
37488: OR
37489: IFFALSE 37692
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37491: LD_ADDR_VAR 0 8
37495: PUSH
37496: LD_EXP 50
37500: PUSH
37501: LD_VAR 0 2
37505: ARRAY
37506: PPUSH
37507: LD_INT 2
37509: PUSH
37510: LD_INT 30
37512: PUSH
37513: LD_INT 4
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 30
37522: PUSH
37523: LD_INT 5
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: PPUSH
37535: CALL_OW 72
37539: ST_TO_ADDR
// if barracks then
37540: LD_VAR 0 8
37544: IFFALSE 37692
// begin selected := 0 ;
37546: LD_ADDR_VAR 0 7
37550: PUSH
37551: LD_INT 0
37553: ST_TO_ADDR
// for j in barracks do
37554: LD_ADDR_VAR 0 3
37558: PUSH
37559: LD_VAR 0 8
37563: PUSH
37564: FOR_IN
37565: IFFALSE 37596
// begin if UnitsInside ( j ) < 6 then
37567: LD_VAR 0 3
37571: PPUSH
37572: CALL_OW 313
37576: PUSH
37577: LD_INT 6
37579: LESS
37580: IFFALSE 37594
// begin selected := j ;
37582: LD_ADDR_VAR 0 7
37586: PUSH
37587: LD_VAR 0 3
37591: ST_TO_ADDR
// break ;
37592: GO 37596
// end ; end ;
37594: GO 37564
37596: POP
37597: POP
// if selected then
37598: LD_VAR 0 7
37602: IFFALSE 37692
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37604: LD_ADDR_VAR 0 3
37608: PUSH
37609: LD_EXP 79
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PPUSH
37620: LD_INT 25
37622: PUSH
37623: LD_INT 12
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PPUSH
37630: CALL_OW 72
37634: PUSH
37635: FOR_IN
37636: IFFALSE 37690
// if not IsInUnit ( j ) and not HasTask ( j ) then
37638: LD_VAR 0 3
37642: PPUSH
37643: CALL_OW 310
37647: NOT
37648: PUSH
37649: LD_VAR 0 3
37653: PPUSH
37654: CALL_OW 314
37658: NOT
37659: AND
37660: IFFALSE 37688
// begin ComEnterUnit ( j , selected ) ;
37662: LD_VAR 0 3
37666: PPUSH
37667: LD_VAR 0 7
37671: PPUSH
37672: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37676: LD_VAR 0 3
37680: PPUSH
37681: LD_INT 15
37683: PPUSH
37684: CALL_OW 183
// end ;
37688: GO 37635
37690: POP
37691: POP
// end ; end ; end ; end ; end ;
37692: GO 37085
37694: POP
37695: POP
// end ;
37696: LD_VAR 0 1
37700: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37701: LD_INT 0
37703: PPUSH
37704: PPUSH
37705: PPUSH
37706: PPUSH
// if not mc_bases then
37707: LD_EXP 50
37711: NOT
37712: IFFALSE 37716
// exit ;
37714: GO 37894
// for i = 1 to mc_bases do
37716: LD_ADDR_VAR 0 2
37720: PUSH
37721: DOUBLE
37722: LD_INT 1
37724: DEC
37725: ST_TO_ADDR
37726: LD_EXP 50
37730: PUSH
37731: FOR_TO
37732: IFFALSE 37892
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37734: LD_ADDR_VAR 0 4
37738: PUSH
37739: LD_EXP 50
37743: PUSH
37744: LD_VAR 0 2
37748: ARRAY
37749: PPUSH
37750: LD_INT 25
37752: PUSH
37753: LD_INT 9
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PPUSH
37760: CALL_OW 72
37764: ST_TO_ADDR
// if not tmp then
37765: LD_VAR 0 4
37769: NOT
37770: IFFALSE 37774
// continue ;
37772: GO 37731
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37774: LD_EXP 76
37778: PUSH
37779: LD_VAR 0 2
37783: ARRAY
37784: PPUSH
37785: LD_INT 29
37787: PPUSH
37788: CALL_OW 325
37792: NOT
37793: PUSH
37794: LD_EXP 76
37798: PUSH
37799: LD_VAR 0 2
37803: ARRAY
37804: PPUSH
37805: LD_INT 28
37807: PPUSH
37808: CALL_OW 325
37812: NOT
37813: AND
37814: IFFALSE 37818
// continue ;
37816: GO 37731
// for j in tmp do
37818: LD_ADDR_VAR 0 3
37822: PUSH
37823: LD_VAR 0 4
37827: PUSH
37828: FOR_IN
37829: IFFALSE 37888
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37831: LD_VAR 0 3
37835: PUSH
37836: LD_EXP 53
37840: PUSH
37841: LD_VAR 0 2
37845: ARRAY
37846: PUSH
37847: LD_INT 1
37849: ARRAY
37850: IN
37851: NOT
37852: PUSH
37853: LD_VAR 0 3
37857: PUSH
37858: LD_EXP 53
37862: PUSH
37863: LD_VAR 0 2
37867: ARRAY
37868: PUSH
37869: LD_INT 2
37871: ARRAY
37872: IN
37873: NOT
37874: AND
37875: IFFALSE 37886
// ComSpaceTimeShoot ( j ) ;
37877: LD_VAR 0 3
37881: PPUSH
37882: CALL 49051 0 1
37886: GO 37828
37888: POP
37889: POP
// end ;
37890: GO 37731
37892: POP
37893: POP
// end ;
37894: LD_VAR 0 1
37898: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37899: LD_INT 0
37901: PPUSH
37902: PPUSH
37903: PPUSH
37904: PPUSH
37905: PPUSH
37906: PPUSH
37907: PPUSH
37908: PPUSH
37909: PPUSH
// if not mc_bases then
37910: LD_EXP 50
37914: NOT
37915: IFFALSE 37919
// exit ;
37917: GO 38541
// for i = 1 to mc_bases do
37919: LD_ADDR_VAR 0 2
37923: PUSH
37924: DOUBLE
37925: LD_INT 1
37927: DEC
37928: ST_TO_ADDR
37929: LD_EXP 50
37933: PUSH
37934: FOR_TO
37935: IFFALSE 38539
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37937: LD_EXP 85
37941: PUSH
37942: LD_VAR 0 2
37946: ARRAY
37947: NOT
37948: PUSH
37949: LD_INT 38
37951: PPUSH
37952: LD_EXP 76
37956: PUSH
37957: LD_VAR 0 2
37961: ARRAY
37962: PPUSH
37963: CALL_OW 321
37967: PUSH
37968: LD_INT 2
37970: NONEQUAL
37971: OR
37972: IFFALSE 37976
// continue ;
37974: GO 37934
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37976: LD_ADDR_VAR 0 8
37980: PUSH
37981: LD_EXP 50
37985: PUSH
37986: LD_VAR 0 2
37990: ARRAY
37991: PPUSH
37992: LD_INT 30
37994: PUSH
37995: LD_INT 34
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PPUSH
38002: CALL_OW 72
38006: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38007: LD_ADDR_VAR 0 9
38011: PUSH
38012: LD_EXP 50
38016: PUSH
38017: LD_VAR 0 2
38021: ARRAY
38022: PPUSH
38023: LD_INT 25
38025: PUSH
38026: LD_INT 4
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PPUSH
38033: CALL_OW 72
38037: PPUSH
38038: LD_INT 0
38040: PPUSH
38041: CALL 81948 0 2
38045: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38046: LD_VAR 0 9
38050: NOT
38051: PUSH
38052: LD_VAR 0 8
38056: NOT
38057: OR
38058: PUSH
38059: LD_EXP 50
38063: PUSH
38064: LD_VAR 0 2
38068: ARRAY
38069: PPUSH
38070: LD_INT 124
38072: PPUSH
38073: CALL 81948 0 2
38077: OR
38078: IFFALSE 38082
// continue ;
38080: GO 37934
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38082: LD_EXP 86
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: PUSH
38093: LD_EXP 85
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: LESS
38104: PUSH
38105: LD_EXP 86
38109: PUSH
38110: LD_VAR 0 2
38114: ARRAY
38115: PUSH
38116: LD_VAR 0 8
38120: LESS
38121: AND
38122: IFFALSE 38537
// begin tmp := sci [ 1 ] ;
38124: LD_ADDR_VAR 0 7
38128: PUSH
38129: LD_VAR 0 9
38133: PUSH
38134: LD_INT 1
38136: ARRAY
38137: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38138: LD_VAR 0 7
38142: PPUSH
38143: LD_INT 124
38145: PPUSH
38146: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38150: LD_ADDR_VAR 0 3
38154: PUSH
38155: DOUBLE
38156: LD_EXP 85
38160: PUSH
38161: LD_VAR 0 2
38165: ARRAY
38166: INC
38167: ST_TO_ADDR
38168: LD_EXP 85
38172: PUSH
38173: LD_VAR 0 2
38177: ARRAY
38178: PUSH
38179: FOR_DOWNTO
38180: IFFALSE 38523
// begin if IsInUnit ( tmp ) then
38182: LD_VAR 0 7
38186: PPUSH
38187: CALL_OW 310
38191: IFFALSE 38202
// ComExitBuilding ( tmp ) ;
38193: LD_VAR 0 7
38197: PPUSH
38198: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38202: LD_INT 35
38204: PPUSH
38205: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38209: LD_VAR 0 7
38213: PPUSH
38214: CALL_OW 310
38218: NOT
38219: PUSH
38220: LD_VAR 0 7
38224: PPUSH
38225: CALL_OW 314
38229: NOT
38230: AND
38231: IFFALSE 38202
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38233: LD_ADDR_VAR 0 6
38237: PUSH
38238: LD_VAR 0 7
38242: PPUSH
38243: CALL_OW 250
38247: PUSH
38248: LD_VAR 0 7
38252: PPUSH
38253: CALL_OW 251
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38262: LD_INT 35
38264: PPUSH
38265: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38269: LD_ADDR_VAR 0 4
38273: PUSH
38274: LD_EXP 85
38278: PUSH
38279: LD_VAR 0 2
38283: ARRAY
38284: PUSH
38285: LD_VAR 0 3
38289: ARRAY
38290: PUSH
38291: LD_INT 1
38293: ARRAY
38294: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38295: LD_ADDR_VAR 0 5
38299: PUSH
38300: LD_EXP 85
38304: PUSH
38305: LD_VAR 0 2
38309: ARRAY
38310: PUSH
38311: LD_VAR 0 3
38315: ARRAY
38316: PUSH
38317: LD_INT 2
38319: ARRAY
38320: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38321: LD_VAR 0 7
38325: PPUSH
38326: LD_INT 10
38328: PPUSH
38329: CALL 55647 0 2
38333: PUSH
38334: LD_INT 4
38336: ARRAY
38337: IFFALSE 38375
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38339: LD_VAR 0 7
38343: PPUSH
38344: LD_VAR 0 6
38348: PUSH
38349: LD_INT 1
38351: ARRAY
38352: PPUSH
38353: LD_VAR 0 6
38357: PUSH
38358: LD_INT 2
38360: ARRAY
38361: PPUSH
38362: CALL_OW 111
// wait ( 0 0$10 ) ;
38366: LD_INT 350
38368: PPUSH
38369: CALL_OW 67
// end else
38373: GO 38401
// begin ComMoveXY ( tmp , x , y ) ;
38375: LD_VAR 0 7
38379: PPUSH
38380: LD_VAR 0 4
38384: PPUSH
38385: LD_VAR 0 5
38389: PPUSH
38390: CALL_OW 111
// wait ( 0 0$3 ) ;
38394: LD_INT 105
38396: PPUSH
38397: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38401: LD_VAR 0 7
38405: PPUSH
38406: LD_VAR 0 4
38410: PPUSH
38411: LD_VAR 0 5
38415: PPUSH
38416: CALL_OW 307
38420: IFFALSE 38262
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38422: LD_VAR 0 7
38426: PPUSH
38427: LD_VAR 0 4
38431: PPUSH
38432: LD_VAR 0 5
38436: PPUSH
38437: LD_VAR 0 8
38441: PUSH
38442: LD_VAR 0 3
38446: ARRAY
38447: PPUSH
38448: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38452: LD_INT 35
38454: PPUSH
38455: CALL_OW 67
// until not HasTask ( tmp ) ;
38459: LD_VAR 0 7
38463: PPUSH
38464: CALL_OW 314
38468: NOT
38469: IFFALSE 38452
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38471: LD_ADDR_EXP 86
38475: PUSH
38476: LD_EXP 86
38480: PPUSH
38481: LD_VAR 0 2
38485: PUSH
38486: LD_EXP 86
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PUSH
38497: LD_INT 1
38499: PLUS
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PPUSH
38505: LD_VAR 0 8
38509: PUSH
38510: LD_VAR 0 3
38514: ARRAY
38515: PPUSH
38516: CALL 53054 0 3
38520: ST_TO_ADDR
// end ;
38521: GO 38179
38523: POP
38524: POP
// MC_Reset ( i , 124 ) ;
38525: LD_VAR 0 2
38529: PPUSH
38530: LD_INT 124
38532: PPUSH
38533: CALL 21980 0 2
// end ; end ;
38537: GO 37934
38539: POP
38540: POP
// end ;
38541: LD_VAR 0 1
38545: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38546: LD_INT 0
38548: PPUSH
38549: PPUSH
38550: PPUSH
// if not mc_bases then
38551: LD_EXP 50
38555: NOT
38556: IFFALSE 38560
// exit ;
38558: GO 39166
// for i = 1 to mc_bases do
38560: LD_ADDR_VAR 0 2
38564: PUSH
38565: DOUBLE
38566: LD_INT 1
38568: DEC
38569: ST_TO_ADDR
38570: LD_EXP 50
38574: PUSH
38575: FOR_TO
38576: IFFALSE 39164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38578: LD_ADDR_VAR 0 3
38582: PUSH
38583: LD_EXP 50
38587: PUSH
38588: LD_VAR 0 2
38592: ARRAY
38593: PPUSH
38594: LD_INT 25
38596: PUSH
38597: LD_INT 4
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PPUSH
38604: CALL_OW 72
38608: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38609: LD_VAR 0 3
38613: NOT
38614: PUSH
38615: LD_EXP 87
38619: PUSH
38620: LD_VAR 0 2
38624: ARRAY
38625: NOT
38626: OR
38627: PUSH
38628: LD_EXP 50
38632: PUSH
38633: LD_VAR 0 2
38637: ARRAY
38638: PPUSH
38639: LD_INT 2
38641: PUSH
38642: LD_INT 30
38644: PUSH
38645: LD_INT 0
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 30
38654: PUSH
38655: LD_INT 1
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: LIST
38666: PPUSH
38667: CALL_OW 72
38671: NOT
38672: OR
38673: IFFALSE 38723
// begin if mc_deposits_finder [ i ] then
38675: LD_EXP 88
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: IFFALSE 38721
// begin MC_Reset ( i , 125 ) ;
38687: LD_VAR 0 2
38691: PPUSH
38692: LD_INT 125
38694: PPUSH
38695: CALL 21980 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38699: LD_ADDR_EXP 88
38703: PUSH
38704: LD_EXP 88
38708: PPUSH
38709: LD_VAR 0 2
38713: PPUSH
38714: EMPTY
38715: PPUSH
38716: CALL_OW 1
38720: ST_TO_ADDR
// end ; continue ;
38721: GO 38575
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38723: LD_EXP 87
38727: PUSH
38728: LD_VAR 0 2
38732: ARRAY
38733: PUSH
38734: LD_INT 1
38736: ARRAY
38737: PUSH
38738: LD_INT 3
38740: ARRAY
38741: PUSH
38742: LD_INT 1
38744: EQUAL
38745: PUSH
38746: LD_INT 20
38748: PPUSH
38749: LD_EXP 76
38753: PUSH
38754: LD_VAR 0 2
38758: ARRAY
38759: PPUSH
38760: CALL_OW 321
38764: PUSH
38765: LD_INT 2
38767: NONEQUAL
38768: AND
38769: IFFALSE 38819
// begin if mc_deposits_finder [ i ] then
38771: LD_EXP 88
38775: PUSH
38776: LD_VAR 0 2
38780: ARRAY
38781: IFFALSE 38817
// begin MC_Reset ( i , 125 ) ;
38783: LD_VAR 0 2
38787: PPUSH
38788: LD_INT 125
38790: PPUSH
38791: CALL 21980 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38795: LD_ADDR_EXP 88
38799: PUSH
38800: LD_EXP 88
38804: PPUSH
38805: LD_VAR 0 2
38809: PPUSH
38810: EMPTY
38811: PPUSH
38812: CALL_OW 1
38816: ST_TO_ADDR
// end ; continue ;
38817: GO 38575
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38819: LD_EXP 87
38823: PUSH
38824: LD_VAR 0 2
38828: ARRAY
38829: PUSH
38830: LD_INT 1
38832: ARRAY
38833: PUSH
38834: LD_INT 1
38836: ARRAY
38837: PPUSH
38838: LD_EXP 87
38842: PUSH
38843: LD_VAR 0 2
38847: ARRAY
38848: PUSH
38849: LD_INT 1
38851: ARRAY
38852: PUSH
38853: LD_INT 2
38855: ARRAY
38856: PPUSH
38857: LD_EXP 76
38861: PUSH
38862: LD_VAR 0 2
38866: ARRAY
38867: PPUSH
38868: CALL_OW 440
38872: IFFALSE 38915
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38874: LD_ADDR_EXP 87
38878: PUSH
38879: LD_EXP 87
38883: PPUSH
38884: LD_VAR 0 2
38888: PPUSH
38889: LD_EXP 87
38893: PUSH
38894: LD_VAR 0 2
38898: ARRAY
38899: PPUSH
38900: LD_INT 1
38902: PPUSH
38903: CALL_OW 3
38907: PPUSH
38908: CALL_OW 1
38912: ST_TO_ADDR
38913: GO 39162
// begin if not mc_deposits_finder [ i ] then
38915: LD_EXP 88
38919: PUSH
38920: LD_VAR 0 2
38924: ARRAY
38925: NOT
38926: IFFALSE 38978
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38928: LD_ADDR_EXP 88
38932: PUSH
38933: LD_EXP 88
38937: PPUSH
38938: LD_VAR 0 2
38942: PPUSH
38943: LD_VAR 0 3
38947: PUSH
38948: LD_INT 1
38950: ARRAY
38951: PUSH
38952: EMPTY
38953: LIST
38954: PPUSH
38955: CALL_OW 1
38959: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38960: LD_VAR 0 3
38964: PUSH
38965: LD_INT 1
38967: ARRAY
38968: PPUSH
38969: LD_INT 125
38971: PPUSH
38972: CALL_OW 109
// end else
38976: GO 39162
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38978: LD_EXP 88
38982: PUSH
38983: LD_VAR 0 2
38987: ARRAY
38988: PUSH
38989: LD_INT 1
38991: ARRAY
38992: PPUSH
38993: CALL_OW 310
38997: IFFALSE 39020
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38999: LD_EXP 88
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: PUSH
39010: LD_INT 1
39012: ARRAY
39013: PPUSH
39014: CALL_OW 122
39018: GO 39162
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39020: LD_EXP 88
39024: PUSH
39025: LD_VAR 0 2
39029: ARRAY
39030: PUSH
39031: LD_INT 1
39033: ARRAY
39034: PPUSH
39035: CALL_OW 314
39039: NOT
39040: PUSH
39041: LD_EXP 88
39045: PUSH
39046: LD_VAR 0 2
39050: ARRAY
39051: PUSH
39052: LD_INT 1
39054: ARRAY
39055: PPUSH
39056: LD_EXP 87
39060: PUSH
39061: LD_VAR 0 2
39065: ARRAY
39066: PUSH
39067: LD_INT 1
39069: ARRAY
39070: PUSH
39071: LD_INT 1
39073: ARRAY
39074: PPUSH
39075: LD_EXP 87
39079: PUSH
39080: LD_VAR 0 2
39084: ARRAY
39085: PUSH
39086: LD_INT 1
39088: ARRAY
39089: PUSH
39090: LD_INT 2
39092: ARRAY
39093: PPUSH
39094: CALL_OW 297
39098: PUSH
39099: LD_INT 6
39101: GREATER
39102: AND
39103: IFFALSE 39162
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39105: LD_EXP 88
39109: PUSH
39110: LD_VAR 0 2
39114: ARRAY
39115: PUSH
39116: LD_INT 1
39118: ARRAY
39119: PPUSH
39120: LD_EXP 87
39124: PUSH
39125: LD_VAR 0 2
39129: ARRAY
39130: PUSH
39131: LD_INT 1
39133: ARRAY
39134: PUSH
39135: LD_INT 1
39137: ARRAY
39138: PPUSH
39139: LD_EXP 87
39143: PUSH
39144: LD_VAR 0 2
39148: ARRAY
39149: PUSH
39150: LD_INT 1
39152: ARRAY
39153: PUSH
39154: LD_INT 2
39156: ARRAY
39157: PPUSH
39158: CALL_OW 111
// end ; end ; end ;
39162: GO 38575
39164: POP
39165: POP
// end ;
39166: LD_VAR 0 1
39170: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39171: LD_INT 0
39173: PPUSH
39174: PPUSH
39175: PPUSH
39176: PPUSH
39177: PPUSH
39178: PPUSH
39179: PPUSH
39180: PPUSH
39181: PPUSH
39182: PPUSH
39183: PPUSH
// if not mc_bases then
39184: LD_EXP 50
39188: NOT
39189: IFFALSE 39193
// exit ;
39191: GO 40133
// for i = 1 to mc_bases do
39193: LD_ADDR_VAR 0 2
39197: PUSH
39198: DOUBLE
39199: LD_INT 1
39201: DEC
39202: ST_TO_ADDR
39203: LD_EXP 50
39207: PUSH
39208: FOR_TO
39209: IFFALSE 40131
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39211: LD_EXP 50
39215: PUSH
39216: LD_VAR 0 2
39220: ARRAY
39221: NOT
39222: PUSH
39223: LD_EXP 73
39227: PUSH
39228: LD_VAR 0 2
39232: ARRAY
39233: OR
39234: IFFALSE 39238
// continue ;
39236: GO 39208
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39238: LD_ADDR_VAR 0 7
39242: PUSH
39243: LD_EXP 50
39247: PUSH
39248: LD_VAR 0 2
39252: ARRAY
39253: PUSH
39254: LD_INT 1
39256: ARRAY
39257: PPUSH
39258: CALL_OW 248
39262: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39263: LD_VAR 0 7
39267: PUSH
39268: LD_INT 3
39270: EQUAL
39271: PUSH
39272: LD_EXP 69
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: PUSH
39283: LD_EXP 72
39287: PUSH
39288: LD_VAR 0 2
39292: ARRAY
39293: UNION
39294: PPUSH
39295: LD_INT 33
39297: PUSH
39298: LD_INT 2
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PPUSH
39305: CALL_OW 72
39309: NOT
39310: OR
39311: IFFALSE 39315
// continue ;
39313: GO 39208
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39315: LD_ADDR_VAR 0 9
39319: PUSH
39320: LD_EXP 50
39324: PUSH
39325: LD_VAR 0 2
39329: ARRAY
39330: PPUSH
39331: LD_INT 30
39333: PUSH
39334: LD_INT 36
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PPUSH
39341: CALL_OW 72
39345: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39346: LD_ADDR_VAR 0 10
39350: PUSH
39351: LD_EXP 69
39355: PUSH
39356: LD_VAR 0 2
39360: ARRAY
39361: PPUSH
39362: LD_INT 34
39364: PUSH
39365: LD_INT 31
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PPUSH
39372: CALL_OW 72
39376: ST_TO_ADDR
// if not cts and not mcts then
39377: LD_VAR 0 9
39381: NOT
39382: PUSH
39383: LD_VAR 0 10
39387: NOT
39388: AND
39389: IFFALSE 39393
// continue ;
39391: GO 39208
// x := cts ;
39393: LD_ADDR_VAR 0 11
39397: PUSH
39398: LD_VAR 0 9
39402: ST_TO_ADDR
// if not x then
39403: LD_VAR 0 11
39407: NOT
39408: IFFALSE 39420
// x := mcts ;
39410: LD_ADDR_VAR 0 11
39414: PUSH
39415: LD_VAR 0 10
39419: ST_TO_ADDR
// if not x then
39420: LD_VAR 0 11
39424: NOT
39425: IFFALSE 39429
// continue ;
39427: GO 39208
// if mc_remote_driver [ i ] then
39429: LD_EXP 90
39433: PUSH
39434: LD_VAR 0 2
39438: ARRAY
39439: IFFALSE 39826
// for j in mc_remote_driver [ i ] do
39441: LD_ADDR_VAR 0 3
39445: PUSH
39446: LD_EXP 90
39450: PUSH
39451: LD_VAR 0 2
39455: ARRAY
39456: PUSH
39457: FOR_IN
39458: IFFALSE 39824
// begin if GetClass ( j ) <> 3 then
39460: LD_VAR 0 3
39464: PPUSH
39465: CALL_OW 257
39469: PUSH
39470: LD_INT 3
39472: NONEQUAL
39473: IFFALSE 39526
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39475: LD_ADDR_EXP 90
39479: PUSH
39480: LD_EXP 90
39484: PPUSH
39485: LD_VAR 0 2
39489: PPUSH
39490: LD_EXP 90
39494: PUSH
39495: LD_VAR 0 2
39499: ARRAY
39500: PUSH
39501: LD_VAR 0 3
39505: DIFF
39506: PPUSH
39507: CALL_OW 1
39511: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39512: LD_VAR 0 3
39516: PPUSH
39517: LD_INT 0
39519: PPUSH
39520: CALL_OW 109
// continue ;
39524: GO 39457
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39526: LD_EXP 69
39530: PUSH
39531: LD_VAR 0 2
39535: ARRAY
39536: PPUSH
39537: LD_INT 34
39539: PUSH
39540: LD_INT 31
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 58
39549: PUSH
39550: EMPTY
39551: LIST
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PPUSH
39557: CALL_OW 72
39561: PUSH
39562: LD_VAR 0 3
39566: PPUSH
39567: CALL 82036 0 1
39571: NOT
39572: AND
39573: IFFALSE 39644
// begin if IsInUnit ( j ) then
39575: LD_VAR 0 3
39579: PPUSH
39580: CALL_OW 310
39584: IFFALSE 39595
// ComExitBuilding ( j ) ;
39586: LD_VAR 0 3
39590: PPUSH
39591: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39595: LD_VAR 0 3
39599: PPUSH
39600: LD_EXP 69
39604: PUSH
39605: LD_VAR 0 2
39609: ARRAY
39610: PPUSH
39611: LD_INT 34
39613: PUSH
39614: LD_INT 31
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 58
39623: PUSH
39624: EMPTY
39625: LIST
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PPUSH
39631: CALL_OW 72
39635: PUSH
39636: LD_INT 1
39638: ARRAY
39639: PPUSH
39640: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39644: LD_VAR 0 3
39648: PPUSH
39649: CALL_OW 310
39653: NOT
39654: PUSH
39655: LD_VAR 0 3
39659: PPUSH
39660: CALL_OW 310
39664: PPUSH
39665: CALL_OW 266
39669: PUSH
39670: LD_INT 36
39672: NONEQUAL
39673: PUSH
39674: LD_VAR 0 3
39678: PPUSH
39679: CALL 82036 0 1
39683: NOT
39684: AND
39685: OR
39686: IFFALSE 39822
// begin if IsInUnit ( j ) then
39688: LD_VAR 0 3
39692: PPUSH
39693: CALL_OW 310
39697: IFFALSE 39708
// ComExitBuilding ( j ) ;
39699: LD_VAR 0 3
39703: PPUSH
39704: CALL_OW 122
// ct := 0 ;
39708: LD_ADDR_VAR 0 8
39712: PUSH
39713: LD_INT 0
39715: ST_TO_ADDR
// for k in x do
39716: LD_ADDR_VAR 0 4
39720: PUSH
39721: LD_VAR 0 11
39725: PUSH
39726: FOR_IN
39727: IFFALSE 39800
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39729: LD_VAR 0 4
39733: PPUSH
39734: CALL_OW 264
39738: PUSH
39739: LD_INT 31
39741: EQUAL
39742: PUSH
39743: LD_VAR 0 4
39747: PPUSH
39748: CALL_OW 311
39752: NOT
39753: AND
39754: PUSH
39755: LD_VAR 0 4
39759: PPUSH
39760: CALL_OW 266
39764: PUSH
39765: LD_INT 36
39767: EQUAL
39768: PUSH
39769: LD_VAR 0 4
39773: PPUSH
39774: CALL_OW 313
39778: PUSH
39779: LD_INT 3
39781: LESS
39782: AND
39783: OR
39784: IFFALSE 39798
// begin ct := k ;
39786: LD_ADDR_VAR 0 8
39790: PUSH
39791: LD_VAR 0 4
39795: ST_TO_ADDR
// break ;
39796: GO 39800
// end ;
39798: GO 39726
39800: POP
39801: POP
// if ct then
39802: LD_VAR 0 8
39806: IFFALSE 39822
// ComEnterUnit ( j , ct ) ;
39808: LD_VAR 0 3
39812: PPUSH
39813: LD_VAR 0 8
39817: PPUSH
39818: CALL_OW 120
// end ; end ;
39822: GO 39457
39824: POP
39825: POP
// places := 0 ;
39826: LD_ADDR_VAR 0 5
39830: PUSH
39831: LD_INT 0
39833: ST_TO_ADDR
// for j = 1 to x do
39834: LD_ADDR_VAR 0 3
39838: PUSH
39839: DOUBLE
39840: LD_INT 1
39842: DEC
39843: ST_TO_ADDR
39844: LD_VAR 0 11
39848: PUSH
39849: FOR_TO
39850: IFFALSE 39926
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39852: LD_VAR 0 11
39856: PUSH
39857: LD_VAR 0 3
39861: ARRAY
39862: PPUSH
39863: CALL_OW 264
39867: PUSH
39868: LD_INT 31
39870: EQUAL
39871: IFFALSE 39889
// places := places + 1 else
39873: LD_ADDR_VAR 0 5
39877: PUSH
39878: LD_VAR 0 5
39882: PUSH
39883: LD_INT 1
39885: PLUS
39886: ST_TO_ADDR
39887: GO 39924
// if GetBType ( x [ j ] ) = b_control_tower then
39889: LD_VAR 0 11
39893: PUSH
39894: LD_VAR 0 3
39898: ARRAY
39899: PPUSH
39900: CALL_OW 266
39904: PUSH
39905: LD_INT 36
39907: EQUAL
39908: IFFALSE 39924
// places := places + 3 ;
39910: LD_ADDR_VAR 0 5
39914: PUSH
39915: LD_VAR 0 5
39919: PUSH
39920: LD_INT 3
39922: PLUS
39923: ST_TO_ADDR
39924: GO 39849
39926: POP
39927: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39928: LD_VAR 0 5
39932: PUSH
39933: LD_INT 0
39935: EQUAL
39936: PUSH
39937: LD_VAR 0 5
39941: PUSH
39942: LD_EXP 90
39946: PUSH
39947: LD_VAR 0 2
39951: ARRAY
39952: LESSEQUAL
39953: OR
39954: IFFALSE 39958
// continue ;
39956: GO 39208
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39958: LD_ADDR_VAR 0 6
39962: PUSH
39963: LD_EXP 50
39967: PUSH
39968: LD_VAR 0 2
39972: ARRAY
39973: PPUSH
39974: LD_INT 25
39976: PUSH
39977: LD_INT 3
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PPUSH
39984: CALL_OW 72
39988: PUSH
39989: LD_EXP 90
39993: PUSH
39994: LD_VAR 0 2
39998: ARRAY
39999: DIFF
40000: PPUSH
40001: LD_INT 3
40003: PPUSH
40004: CALL 82936 0 2
40008: ST_TO_ADDR
// for j in tmp do
40009: LD_ADDR_VAR 0 3
40013: PUSH
40014: LD_VAR 0 6
40018: PUSH
40019: FOR_IN
40020: IFFALSE 40055
// if GetTag ( j ) > 0 then
40022: LD_VAR 0 3
40026: PPUSH
40027: CALL_OW 110
40031: PUSH
40032: LD_INT 0
40034: GREATER
40035: IFFALSE 40053
// tmp := tmp diff j ;
40037: LD_ADDR_VAR 0 6
40041: PUSH
40042: LD_VAR 0 6
40046: PUSH
40047: LD_VAR 0 3
40051: DIFF
40052: ST_TO_ADDR
40053: GO 40019
40055: POP
40056: POP
// if not tmp then
40057: LD_VAR 0 6
40061: NOT
40062: IFFALSE 40066
// continue ;
40064: GO 39208
// if places then
40066: LD_VAR 0 5
40070: IFFALSE 40129
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40072: LD_ADDR_EXP 90
40076: PUSH
40077: LD_EXP 90
40081: PPUSH
40082: LD_VAR 0 2
40086: PPUSH
40087: LD_EXP 90
40091: PUSH
40092: LD_VAR 0 2
40096: ARRAY
40097: PUSH
40098: LD_VAR 0 6
40102: PUSH
40103: LD_INT 1
40105: ARRAY
40106: UNION
40107: PPUSH
40108: CALL_OW 1
40112: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40113: LD_VAR 0 6
40117: PUSH
40118: LD_INT 1
40120: ARRAY
40121: PPUSH
40122: LD_INT 126
40124: PPUSH
40125: CALL_OW 109
// end ; end ;
40129: GO 39208
40131: POP
40132: POP
// end ;
40133: LD_VAR 0 1
40137: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40138: LD_INT 0
40140: PPUSH
40141: PPUSH
40142: PPUSH
40143: PPUSH
40144: PPUSH
40145: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40146: LD_VAR 0 1
40150: NOT
40151: PUSH
40152: LD_VAR 0 2
40156: NOT
40157: OR
40158: PUSH
40159: LD_VAR 0 3
40163: NOT
40164: OR
40165: PUSH
40166: LD_VAR 0 4
40170: PUSH
40171: LD_INT 1
40173: PUSH
40174: LD_INT 2
40176: PUSH
40177: LD_INT 3
40179: PUSH
40180: LD_INT 4
40182: PUSH
40183: LD_INT 5
40185: PUSH
40186: LD_INT 8
40188: PUSH
40189: LD_INT 9
40191: PUSH
40192: LD_INT 15
40194: PUSH
40195: LD_INT 16
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: IN
40209: NOT
40210: OR
40211: IFFALSE 40215
// exit ;
40213: GO 41115
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40215: LD_ADDR_VAR 0 2
40219: PUSH
40220: LD_VAR 0 2
40224: PPUSH
40225: LD_INT 21
40227: PUSH
40228: LD_INT 3
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 24
40237: PUSH
40238: LD_INT 250
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PPUSH
40249: CALL_OW 72
40253: ST_TO_ADDR
// case class of 1 , 15 :
40254: LD_VAR 0 4
40258: PUSH
40259: LD_INT 1
40261: DOUBLE
40262: EQUAL
40263: IFTRUE 40273
40265: LD_INT 15
40267: DOUBLE
40268: EQUAL
40269: IFTRUE 40273
40271: GO 40358
40273: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40274: LD_ADDR_VAR 0 8
40278: PUSH
40279: LD_VAR 0 2
40283: PPUSH
40284: LD_INT 2
40286: PUSH
40287: LD_INT 30
40289: PUSH
40290: LD_INT 32
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 30
40299: PUSH
40300: LD_INT 31
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: LIST
40311: PPUSH
40312: CALL_OW 72
40316: PUSH
40317: LD_VAR 0 2
40321: PPUSH
40322: LD_INT 2
40324: PUSH
40325: LD_INT 30
40327: PUSH
40328: LD_INT 4
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 30
40337: PUSH
40338: LD_INT 5
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: LIST
40349: PPUSH
40350: CALL_OW 72
40354: ADD
40355: ST_TO_ADDR
40356: GO 40604
40358: LD_INT 2
40360: DOUBLE
40361: EQUAL
40362: IFTRUE 40372
40364: LD_INT 16
40366: DOUBLE
40367: EQUAL
40368: IFTRUE 40372
40370: GO 40418
40372: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40373: LD_ADDR_VAR 0 8
40377: PUSH
40378: LD_VAR 0 2
40382: PPUSH
40383: LD_INT 2
40385: PUSH
40386: LD_INT 30
40388: PUSH
40389: LD_INT 0
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 30
40398: PUSH
40399: LD_INT 1
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: ST_TO_ADDR
40416: GO 40604
40418: LD_INT 3
40420: DOUBLE
40421: EQUAL
40422: IFTRUE 40426
40424: GO 40472
40426: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40427: LD_ADDR_VAR 0 8
40431: PUSH
40432: LD_VAR 0 2
40436: PPUSH
40437: LD_INT 2
40439: PUSH
40440: LD_INT 30
40442: PUSH
40443: LD_INT 2
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 30
40452: PUSH
40453: LD_INT 3
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: LIST
40464: PPUSH
40465: CALL_OW 72
40469: ST_TO_ADDR
40470: GO 40604
40472: LD_INT 4
40474: DOUBLE
40475: EQUAL
40476: IFTRUE 40480
40478: GO 40537
40480: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40481: LD_ADDR_VAR 0 8
40485: PUSH
40486: LD_VAR 0 2
40490: PPUSH
40491: LD_INT 2
40493: PUSH
40494: LD_INT 30
40496: PUSH
40497: LD_INT 6
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 30
40506: PUSH
40507: LD_INT 7
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 30
40516: PUSH
40517: LD_INT 8
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: PPUSH
40530: CALL_OW 72
40534: ST_TO_ADDR
40535: GO 40604
40537: LD_INT 5
40539: DOUBLE
40540: EQUAL
40541: IFTRUE 40557
40543: LD_INT 8
40545: DOUBLE
40546: EQUAL
40547: IFTRUE 40557
40549: LD_INT 9
40551: DOUBLE
40552: EQUAL
40553: IFTRUE 40557
40555: GO 40603
40557: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40558: LD_ADDR_VAR 0 8
40562: PUSH
40563: LD_VAR 0 2
40567: PPUSH
40568: LD_INT 2
40570: PUSH
40571: LD_INT 30
40573: PUSH
40574: LD_INT 4
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 30
40583: PUSH
40584: LD_INT 5
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: LIST
40595: PPUSH
40596: CALL_OW 72
40600: ST_TO_ADDR
40601: GO 40604
40603: POP
// if not tmp then
40604: LD_VAR 0 8
40608: NOT
40609: IFFALSE 40613
// exit ;
40611: GO 41115
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40613: LD_VAR 0 4
40617: PUSH
40618: LD_INT 1
40620: PUSH
40621: LD_INT 15
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: IN
40628: PUSH
40629: LD_EXP 59
40633: PUSH
40634: LD_VAR 0 1
40638: ARRAY
40639: AND
40640: IFFALSE 40796
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40642: LD_ADDR_VAR 0 9
40646: PUSH
40647: LD_EXP 59
40651: PUSH
40652: LD_VAR 0 1
40656: ARRAY
40657: PUSH
40658: LD_INT 1
40660: ARRAY
40661: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40662: LD_VAR 0 9
40666: PUSH
40667: LD_EXP 60
40671: PUSH
40672: LD_VAR 0 1
40676: ARRAY
40677: IN
40678: NOT
40679: IFFALSE 40794
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40681: LD_ADDR_EXP 60
40685: PUSH
40686: LD_EXP 60
40690: PPUSH
40691: LD_VAR 0 1
40695: PUSH
40696: LD_EXP 60
40700: PUSH
40701: LD_VAR 0 1
40705: ARRAY
40706: PUSH
40707: LD_INT 1
40709: PLUS
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PPUSH
40715: LD_VAR 0 9
40719: PPUSH
40720: CALL 53054 0 3
40724: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40725: LD_ADDR_EXP 59
40729: PUSH
40730: LD_EXP 59
40734: PPUSH
40735: LD_VAR 0 1
40739: PPUSH
40740: LD_EXP 59
40744: PUSH
40745: LD_VAR 0 1
40749: ARRAY
40750: PUSH
40751: LD_VAR 0 9
40755: DIFF
40756: PPUSH
40757: CALL_OW 1
40761: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40762: LD_VAR 0 3
40766: PPUSH
40767: LD_EXP 60
40771: PUSH
40772: LD_VAR 0 1
40776: ARRAY
40777: PUSH
40778: LD_EXP 60
40782: PUSH
40783: LD_VAR 0 1
40787: ARRAY
40788: ARRAY
40789: PPUSH
40790: CALL_OW 120
// end ; exit ;
40794: GO 41115
// end ; if tmp > 1 then
40796: LD_VAR 0 8
40800: PUSH
40801: LD_INT 1
40803: GREATER
40804: IFFALSE 40908
// for i = 2 to tmp do
40806: LD_ADDR_VAR 0 6
40810: PUSH
40811: DOUBLE
40812: LD_INT 2
40814: DEC
40815: ST_TO_ADDR
40816: LD_VAR 0 8
40820: PUSH
40821: FOR_TO
40822: IFFALSE 40906
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40824: LD_VAR 0 8
40828: PUSH
40829: LD_VAR 0 6
40833: ARRAY
40834: PPUSH
40835: CALL_OW 461
40839: PUSH
40840: LD_INT 6
40842: EQUAL
40843: IFFALSE 40904
// begin x := tmp [ i ] ;
40845: LD_ADDR_VAR 0 9
40849: PUSH
40850: LD_VAR 0 8
40854: PUSH
40855: LD_VAR 0 6
40859: ARRAY
40860: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40861: LD_ADDR_VAR 0 8
40865: PUSH
40866: LD_VAR 0 8
40870: PPUSH
40871: LD_VAR 0 6
40875: PPUSH
40876: CALL_OW 3
40880: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40881: LD_ADDR_VAR 0 8
40885: PUSH
40886: LD_VAR 0 8
40890: PPUSH
40891: LD_INT 1
40893: PPUSH
40894: LD_VAR 0 9
40898: PPUSH
40899: CALL_OW 2
40903: ST_TO_ADDR
// end ;
40904: GO 40821
40906: POP
40907: POP
// for i in tmp do
40908: LD_ADDR_VAR 0 6
40912: PUSH
40913: LD_VAR 0 8
40917: PUSH
40918: FOR_IN
40919: IFFALSE 40988
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40921: LD_VAR 0 6
40925: PPUSH
40926: CALL_OW 313
40930: PUSH
40931: LD_INT 6
40933: LESS
40934: PUSH
40935: LD_VAR 0 6
40939: PPUSH
40940: CALL_OW 266
40944: PUSH
40945: LD_INT 31
40947: PUSH
40948: LD_INT 32
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: IN
40955: NOT
40956: AND
40957: PUSH
40958: LD_VAR 0 6
40962: PPUSH
40963: CALL_OW 313
40967: PUSH
40968: LD_INT 0
40970: EQUAL
40971: OR
40972: IFFALSE 40986
// begin j := i ;
40974: LD_ADDR_VAR 0 7
40978: PUSH
40979: LD_VAR 0 6
40983: ST_TO_ADDR
// break ;
40984: GO 40988
// end ; end ;
40986: GO 40918
40988: POP
40989: POP
// if j then
40990: LD_VAR 0 7
40994: IFFALSE 41012
// ComEnterUnit ( unit , j ) else
40996: LD_VAR 0 3
41000: PPUSH
41001: LD_VAR 0 7
41005: PPUSH
41006: CALL_OW 120
41010: GO 41115
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41012: LD_ADDR_VAR 0 10
41016: PUSH
41017: LD_VAR 0 2
41021: PPUSH
41022: LD_INT 2
41024: PUSH
41025: LD_INT 30
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 30
41037: PUSH
41038: LD_INT 1
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: LIST
41049: PPUSH
41050: CALL_OW 72
41054: ST_TO_ADDR
// if depot then
41055: LD_VAR 0 10
41059: IFFALSE 41115
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41061: LD_ADDR_VAR 0 10
41065: PUSH
41066: LD_VAR 0 10
41070: PPUSH
41071: LD_VAR 0 3
41075: PPUSH
41076: CALL_OW 74
41080: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41081: LD_VAR 0 3
41085: PPUSH
41086: LD_VAR 0 10
41090: PPUSH
41091: CALL_OW 296
41095: PUSH
41096: LD_INT 10
41098: GREATER
41099: IFFALSE 41115
// ComStandNearbyBuilding ( unit , depot ) ;
41101: LD_VAR 0 3
41105: PPUSH
41106: LD_VAR 0 10
41110: PPUSH
41111: CALL 49668 0 2
// end ; end ; end ;
41115: LD_VAR 0 5
41119: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41120: LD_INT 0
41122: PPUSH
41123: PPUSH
41124: PPUSH
41125: PPUSH
// if not mc_bases then
41126: LD_EXP 50
41130: NOT
41131: IFFALSE 41135
// exit ;
41133: GO 41374
// for i = 1 to mc_bases do
41135: LD_ADDR_VAR 0 2
41139: PUSH
41140: DOUBLE
41141: LD_INT 1
41143: DEC
41144: ST_TO_ADDR
41145: LD_EXP 50
41149: PUSH
41150: FOR_TO
41151: IFFALSE 41372
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41153: LD_ADDR_VAR 0 4
41157: PUSH
41158: LD_EXP 50
41162: PUSH
41163: LD_VAR 0 2
41167: ARRAY
41168: PPUSH
41169: LD_INT 21
41171: PUSH
41172: LD_INT 1
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PPUSH
41179: CALL_OW 72
41183: PUSH
41184: LD_EXP 79
41188: PUSH
41189: LD_VAR 0 2
41193: ARRAY
41194: UNION
41195: ST_TO_ADDR
// if not tmp then
41196: LD_VAR 0 4
41200: NOT
41201: IFFALSE 41205
// continue ;
41203: GO 41150
// for j in tmp do
41205: LD_ADDR_VAR 0 3
41209: PUSH
41210: LD_VAR 0 4
41214: PUSH
41215: FOR_IN
41216: IFFALSE 41368
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41218: LD_VAR 0 3
41222: PPUSH
41223: CALL_OW 110
41227: NOT
41228: PUSH
41229: LD_VAR 0 3
41233: PPUSH
41234: CALL_OW 314
41238: NOT
41239: AND
41240: PUSH
41241: LD_VAR 0 3
41245: PPUSH
41246: CALL_OW 311
41250: NOT
41251: AND
41252: PUSH
41253: LD_VAR 0 3
41257: PPUSH
41258: CALL_OW 310
41262: NOT
41263: AND
41264: PUSH
41265: LD_VAR 0 3
41269: PUSH
41270: LD_EXP 53
41274: PUSH
41275: LD_VAR 0 2
41279: ARRAY
41280: PUSH
41281: LD_INT 1
41283: ARRAY
41284: IN
41285: NOT
41286: AND
41287: PUSH
41288: LD_VAR 0 3
41292: PUSH
41293: LD_EXP 53
41297: PUSH
41298: LD_VAR 0 2
41302: ARRAY
41303: PUSH
41304: LD_INT 2
41306: ARRAY
41307: IN
41308: NOT
41309: AND
41310: PUSH
41311: LD_VAR 0 3
41315: PUSH
41316: LD_EXP 62
41320: PUSH
41321: LD_VAR 0 2
41325: ARRAY
41326: IN
41327: NOT
41328: AND
41329: IFFALSE 41366
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41331: LD_VAR 0 2
41335: PPUSH
41336: LD_EXP 50
41340: PUSH
41341: LD_VAR 0 2
41345: ARRAY
41346: PPUSH
41347: LD_VAR 0 3
41351: PPUSH
41352: LD_VAR 0 3
41356: PPUSH
41357: CALL_OW 257
41361: PPUSH
41362: CALL 40138 0 4
// end ;
41366: GO 41215
41368: POP
41369: POP
// end ;
41370: GO 41150
41372: POP
41373: POP
// end ;
41374: LD_VAR 0 1
41378: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41379: LD_INT 0
41381: PPUSH
41382: PPUSH
41383: PPUSH
41384: PPUSH
41385: PPUSH
41386: PPUSH
// if not mc_bases [ base ] then
41387: LD_EXP 50
41391: PUSH
41392: LD_VAR 0 1
41396: ARRAY
41397: NOT
41398: IFFALSE 41402
// exit ;
41400: GO 41584
// tmp := [ ] ;
41402: LD_ADDR_VAR 0 6
41406: PUSH
41407: EMPTY
41408: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41409: LD_ADDR_VAR 0 7
41413: PUSH
41414: LD_VAR 0 3
41418: PPUSH
41419: LD_INT 0
41421: PPUSH
41422: CALL_OW 517
41426: ST_TO_ADDR
// if not list then
41427: LD_VAR 0 7
41431: NOT
41432: IFFALSE 41436
// exit ;
41434: GO 41584
// for i = 1 to amount do
41436: LD_ADDR_VAR 0 5
41440: PUSH
41441: DOUBLE
41442: LD_INT 1
41444: DEC
41445: ST_TO_ADDR
41446: LD_VAR 0 2
41450: PUSH
41451: FOR_TO
41452: IFFALSE 41532
// begin x := rand ( 1 , list [ 1 ] ) ;
41454: LD_ADDR_VAR 0 8
41458: PUSH
41459: LD_INT 1
41461: PPUSH
41462: LD_VAR 0 7
41466: PUSH
41467: LD_INT 1
41469: ARRAY
41470: PPUSH
41471: CALL_OW 12
41475: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41476: LD_ADDR_VAR 0 6
41480: PUSH
41481: LD_VAR 0 6
41485: PPUSH
41486: LD_VAR 0 5
41490: PPUSH
41491: LD_VAR 0 7
41495: PUSH
41496: LD_INT 1
41498: ARRAY
41499: PUSH
41500: LD_VAR 0 8
41504: ARRAY
41505: PUSH
41506: LD_VAR 0 7
41510: PUSH
41511: LD_INT 2
41513: ARRAY
41514: PUSH
41515: LD_VAR 0 8
41519: ARRAY
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PPUSH
41525: CALL_OW 1
41529: ST_TO_ADDR
// end ;
41530: GO 41451
41532: POP
41533: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41534: LD_ADDR_EXP 63
41538: PUSH
41539: LD_EXP 63
41543: PPUSH
41544: LD_VAR 0 1
41548: PPUSH
41549: LD_VAR 0 6
41553: PPUSH
41554: CALL_OW 1
41558: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41559: LD_ADDR_EXP 65
41563: PUSH
41564: LD_EXP 65
41568: PPUSH
41569: LD_VAR 0 1
41573: PPUSH
41574: LD_VAR 0 3
41578: PPUSH
41579: CALL_OW 1
41583: ST_TO_ADDR
// end ;
41584: LD_VAR 0 4
41588: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41589: LD_INT 0
41591: PPUSH
// if not mc_bases [ base ] then
41592: LD_EXP 50
41596: PUSH
41597: LD_VAR 0 1
41601: ARRAY
41602: NOT
41603: IFFALSE 41607
// exit ;
41605: GO 41632
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41607: LD_ADDR_EXP 55
41611: PUSH
41612: LD_EXP 55
41616: PPUSH
41617: LD_VAR 0 1
41621: PPUSH
41622: LD_VAR 0 2
41626: PPUSH
41627: CALL_OW 1
41631: ST_TO_ADDR
// end ;
41632: LD_VAR 0 3
41636: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41637: LD_INT 0
41639: PPUSH
// if not mc_bases [ base ] then
41640: LD_EXP 50
41644: PUSH
41645: LD_VAR 0 1
41649: ARRAY
41650: NOT
41651: IFFALSE 41655
// exit ;
41653: GO 41692
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41655: LD_ADDR_EXP 55
41659: PUSH
41660: LD_EXP 55
41664: PPUSH
41665: LD_VAR 0 1
41669: PPUSH
41670: LD_EXP 55
41674: PUSH
41675: LD_VAR 0 1
41679: ARRAY
41680: PUSH
41681: LD_VAR 0 2
41685: UNION
41686: PPUSH
41687: CALL_OW 1
41691: ST_TO_ADDR
// end ;
41692: LD_VAR 0 3
41696: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41697: LD_INT 0
41699: PPUSH
// if not mc_bases [ base ] then
41700: LD_EXP 50
41704: PUSH
41705: LD_VAR 0 1
41709: ARRAY
41710: NOT
41711: IFFALSE 41715
// exit ;
41713: GO 41740
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41715: LD_ADDR_EXP 71
41719: PUSH
41720: LD_EXP 71
41724: PPUSH
41725: LD_VAR 0 1
41729: PPUSH
41730: LD_VAR 0 2
41734: PPUSH
41735: CALL_OW 1
41739: ST_TO_ADDR
// end ;
41740: LD_VAR 0 3
41744: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41745: LD_INT 0
41747: PPUSH
// if not mc_bases [ base ] then
41748: LD_EXP 50
41752: PUSH
41753: LD_VAR 0 1
41757: ARRAY
41758: NOT
41759: IFFALSE 41763
// exit ;
41761: GO 41800
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41763: LD_ADDR_EXP 71
41767: PUSH
41768: LD_EXP 71
41772: PPUSH
41773: LD_VAR 0 1
41777: PPUSH
41778: LD_EXP 71
41782: PUSH
41783: LD_VAR 0 1
41787: ARRAY
41788: PUSH
41789: LD_VAR 0 2
41793: ADD
41794: PPUSH
41795: CALL_OW 1
41799: ST_TO_ADDR
// end ;
41800: LD_VAR 0 3
41804: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41805: LD_INT 0
41807: PPUSH
// if not mc_bases [ base ] then
41808: LD_EXP 50
41812: PUSH
41813: LD_VAR 0 1
41817: ARRAY
41818: NOT
41819: IFFALSE 41823
// exit ;
41821: GO 41877
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41823: LD_ADDR_EXP 72
41827: PUSH
41828: LD_EXP 72
41832: PPUSH
41833: LD_VAR 0 1
41837: PPUSH
41838: LD_VAR 0 2
41842: PPUSH
41843: CALL_OW 1
41847: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41848: LD_ADDR_EXP 61
41852: PUSH
41853: LD_EXP 61
41857: PPUSH
41858: LD_VAR 0 1
41862: PPUSH
41863: LD_VAR 0 2
41867: PUSH
41868: LD_INT 0
41870: PLUS
41871: PPUSH
41872: CALL_OW 1
41876: ST_TO_ADDR
// end ;
41877: LD_VAR 0 3
41881: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41882: LD_INT 0
41884: PPUSH
// if not mc_bases [ base ] then
41885: LD_EXP 50
41889: PUSH
41890: LD_VAR 0 1
41894: ARRAY
41895: NOT
41896: IFFALSE 41900
// exit ;
41898: GO 41925
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41900: LD_ADDR_EXP 61
41904: PUSH
41905: LD_EXP 61
41909: PPUSH
41910: LD_VAR 0 1
41914: PPUSH
41915: LD_VAR 0 2
41919: PPUSH
41920: CALL_OW 1
41924: ST_TO_ADDR
// end ;
41925: LD_VAR 0 3
41929: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41930: LD_INT 0
41932: PPUSH
41933: PPUSH
41934: PPUSH
41935: PPUSH
// if not mc_bases [ base ] then
41936: LD_EXP 50
41940: PUSH
41941: LD_VAR 0 1
41945: ARRAY
41946: NOT
41947: IFFALSE 41951
// exit ;
41949: GO 42016
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41951: LD_ADDR_EXP 70
41955: PUSH
41956: LD_EXP 70
41960: PPUSH
41961: LD_VAR 0 1
41965: PUSH
41966: LD_EXP 70
41970: PUSH
41971: LD_VAR 0 1
41975: ARRAY
41976: PUSH
41977: LD_INT 1
41979: PLUS
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PPUSH
41985: LD_VAR 0 1
41989: PUSH
41990: LD_VAR 0 2
41994: PUSH
41995: LD_VAR 0 3
41999: PUSH
42000: LD_VAR 0 4
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: LIST
42009: LIST
42010: PPUSH
42011: CALL 53054 0 3
42015: ST_TO_ADDR
// end ;
42016: LD_VAR 0 5
42020: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42021: LD_INT 0
42023: PPUSH
// if not mc_bases [ base ] then
42024: LD_EXP 50
42028: PUSH
42029: LD_VAR 0 1
42033: ARRAY
42034: NOT
42035: IFFALSE 42039
// exit ;
42037: GO 42064
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42039: LD_ADDR_EXP 87
42043: PUSH
42044: LD_EXP 87
42048: PPUSH
42049: LD_VAR 0 1
42053: PPUSH
42054: LD_VAR 0 2
42058: PPUSH
42059: CALL_OW 1
42063: ST_TO_ADDR
// end ;
42064: LD_VAR 0 3
42068: RET
// export function MC_GetMinesField ( base ) ; begin
42069: LD_INT 0
42071: PPUSH
// result := mc_mines [ base ] ;
42072: LD_ADDR_VAR 0 2
42076: PUSH
42077: LD_EXP 63
42081: PUSH
42082: LD_VAR 0 1
42086: ARRAY
42087: ST_TO_ADDR
// end ;
42088: LD_VAR 0 2
42092: RET
// export function MC_GetProduceList ( base ) ; begin
42093: LD_INT 0
42095: PPUSH
// result := mc_produce [ base ] ;
42096: LD_ADDR_VAR 0 2
42100: PUSH
42101: LD_EXP 71
42105: PUSH
42106: LD_VAR 0 1
42110: ARRAY
42111: ST_TO_ADDR
// end ;
42112: LD_VAR 0 2
42116: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42117: LD_INT 0
42119: PPUSH
42120: PPUSH
// if not mc_bases then
42121: LD_EXP 50
42125: NOT
42126: IFFALSE 42130
// exit ;
42128: GO 42195
// if mc_bases [ base ] then
42130: LD_EXP 50
42134: PUSH
42135: LD_VAR 0 1
42139: ARRAY
42140: IFFALSE 42195
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42142: LD_ADDR_VAR 0 3
42146: PUSH
42147: LD_EXP 50
42151: PUSH
42152: LD_VAR 0 1
42156: ARRAY
42157: PPUSH
42158: LD_INT 30
42160: PUSH
42161: LD_VAR 0 2
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PPUSH
42170: CALL_OW 72
42174: ST_TO_ADDR
// if result then
42175: LD_VAR 0 3
42179: IFFALSE 42195
// result := result [ 1 ] ;
42181: LD_ADDR_VAR 0 3
42185: PUSH
42186: LD_VAR 0 3
42190: PUSH
42191: LD_INT 1
42193: ARRAY
42194: ST_TO_ADDR
// end ; end ;
42195: LD_VAR 0 3
42199: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42200: LD_INT 0
42202: PPUSH
42203: PPUSH
// if not mc_bases then
42204: LD_EXP 50
42208: NOT
42209: IFFALSE 42213
// exit ;
42211: GO 42258
// if mc_bases [ base ] then
42213: LD_EXP 50
42217: PUSH
42218: LD_VAR 0 1
42222: ARRAY
42223: IFFALSE 42258
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42225: LD_ADDR_VAR 0 3
42229: PUSH
42230: LD_EXP 50
42234: PUSH
42235: LD_VAR 0 1
42239: ARRAY
42240: PPUSH
42241: LD_INT 30
42243: PUSH
42244: LD_VAR 0 2
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PPUSH
42253: CALL_OW 72
42257: ST_TO_ADDR
// end ;
42258: LD_VAR 0 3
42262: RET
// export function MC_SetTame ( base , area ) ; begin
42263: LD_INT 0
42265: PPUSH
// if not mc_bases or not base then
42266: LD_EXP 50
42270: NOT
42271: PUSH
42272: LD_VAR 0 1
42276: NOT
42277: OR
42278: IFFALSE 42282
// exit ;
42280: GO 42307
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42282: LD_ADDR_EXP 78
42286: PUSH
42287: LD_EXP 78
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: LD_VAR 0 2
42301: PPUSH
42302: CALL_OW 1
42306: ST_TO_ADDR
// end ;
42307: LD_VAR 0 3
42311: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42312: LD_INT 0
42314: PPUSH
42315: PPUSH
// if not mc_bases or not base then
42316: LD_EXP 50
42320: NOT
42321: PUSH
42322: LD_VAR 0 1
42326: NOT
42327: OR
42328: IFFALSE 42332
// exit ;
42330: GO 42434
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42332: LD_ADDR_VAR 0 4
42336: PUSH
42337: LD_EXP 50
42341: PUSH
42342: LD_VAR 0 1
42346: ARRAY
42347: PPUSH
42348: LD_INT 30
42350: PUSH
42351: LD_VAR 0 2
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PPUSH
42360: CALL_OW 72
42364: ST_TO_ADDR
// if not tmp then
42365: LD_VAR 0 4
42369: NOT
42370: IFFALSE 42374
// exit ;
42372: GO 42434
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42374: LD_ADDR_EXP 82
42378: PUSH
42379: LD_EXP 82
42383: PPUSH
42384: LD_VAR 0 1
42388: PPUSH
42389: LD_EXP 82
42393: PUSH
42394: LD_VAR 0 1
42398: ARRAY
42399: PPUSH
42400: LD_EXP 82
42404: PUSH
42405: LD_VAR 0 1
42409: ARRAY
42410: PUSH
42411: LD_INT 1
42413: PLUS
42414: PPUSH
42415: LD_VAR 0 4
42419: PUSH
42420: LD_INT 1
42422: ARRAY
42423: PPUSH
42424: CALL_OW 2
42428: PPUSH
42429: CALL_OW 1
42433: ST_TO_ADDR
// end ;
42434: LD_VAR 0 3
42438: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42439: LD_INT 0
42441: PPUSH
42442: PPUSH
// if not mc_bases or not base or not kinds then
42443: LD_EXP 50
42447: NOT
42448: PUSH
42449: LD_VAR 0 1
42453: NOT
42454: OR
42455: PUSH
42456: LD_VAR 0 2
42460: NOT
42461: OR
42462: IFFALSE 42466
// exit ;
42464: GO 42527
// for i in kinds do
42466: LD_ADDR_VAR 0 4
42470: PUSH
42471: LD_VAR 0 2
42475: PUSH
42476: FOR_IN
42477: IFFALSE 42525
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42479: LD_ADDR_EXP 84
42483: PUSH
42484: LD_EXP 84
42488: PPUSH
42489: LD_VAR 0 1
42493: PUSH
42494: LD_EXP 84
42498: PUSH
42499: LD_VAR 0 1
42503: ARRAY
42504: PUSH
42505: LD_INT 1
42507: PLUS
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PPUSH
42513: LD_VAR 0 4
42517: PPUSH
42518: CALL 53054 0 3
42522: ST_TO_ADDR
42523: GO 42476
42525: POP
42526: POP
// end ;
42527: LD_VAR 0 3
42531: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42532: LD_INT 0
42534: PPUSH
// if not mc_bases or not base or not areas then
42535: LD_EXP 50
42539: NOT
42540: PUSH
42541: LD_VAR 0 1
42545: NOT
42546: OR
42547: PUSH
42548: LD_VAR 0 2
42552: NOT
42553: OR
42554: IFFALSE 42558
// exit ;
42556: GO 42583
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42558: LD_ADDR_EXP 68
42562: PUSH
42563: LD_EXP 68
42567: PPUSH
42568: LD_VAR 0 1
42572: PPUSH
42573: LD_VAR 0 2
42577: PPUSH
42578: CALL_OW 1
42582: ST_TO_ADDR
// end ;
42583: LD_VAR 0 3
42587: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42588: LD_INT 0
42590: PPUSH
// if not mc_bases or not base or not teleports_exit then
42591: LD_EXP 50
42595: NOT
42596: PUSH
42597: LD_VAR 0 1
42601: NOT
42602: OR
42603: PUSH
42604: LD_VAR 0 2
42608: NOT
42609: OR
42610: IFFALSE 42614
// exit ;
42612: GO 42639
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42614: LD_ADDR_EXP 85
42618: PUSH
42619: LD_EXP 85
42623: PPUSH
42624: LD_VAR 0 1
42628: PPUSH
42629: LD_VAR 0 2
42633: PPUSH
42634: CALL_OW 1
42638: ST_TO_ADDR
// end ;
42639: LD_VAR 0 3
42643: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42644: LD_INT 0
42646: PPUSH
42647: PPUSH
42648: PPUSH
// if not mc_bases or not base or not ext_list then
42649: LD_EXP 50
42653: NOT
42654: PUSH
42655: LD_VAR 0 1
42659: NOT
42660: OR
42661: PUSH
42662: LD_VAR 0 5
42666: NOT
42667: OR
42668: IFFALSE 42672
// exit ;
42670: GO 42845
// tmp := GetFacExtXYD ( x , y , d ) ;
42672: LD_ADDR_VAR 0 8
42676: PUSH
42677: LD_VAR 0 2
42681: PPUSH
42682: LD_VAR 0 3
42686: PPUSH
42687: LD_VAR 0 4
42691: PPUSH
42692: CALL 82066 0 3
42696: ST_TO_ADDR
// if not tmp then
42697: LD_VAR 0 8
42701: NOT
42702: IFFALSE 42706
// exit ;
42704: GO 42845
// for i in tmp do
42706: LD_ADDR_VAR 0 7
42710: PUSH
42711: LD_VAR 0 8
42715: PUSH
42716: FOR_IN
42717: IFFALSE 42843
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42719: LD_ADDR_EXP 55
42723: PUSH
42724: LD_EXP 55
42728: PPUSH
42729: LD_VAR 0 1
42733: PPUSH
42734: LD_EXP 55
42738: PUSH
42739: LD_VAR 0 1
42743: ARRAY
42744: PPUSH
42745: LD_EXP 55
42749: PUSH
42750: LD_VAR 0 1
42754: ARRAY
42755: PUSH
42756: LD_INT 1
42758: PLUS
42759: PPUSH
42760: LD_VAR 0 5
42764: PUSH
42765: LD_INT 1
42767: ARRAY
42768: PUSH
42769: LD_VAR 0 7
42773: PUSH
42774: LD_INT 1
42776: ARRAY
42777: PUSH
42778: LD_VAR 0 7
42782: PUSH
42783: LD_INT 2
42785: ARRAY
42786: PUSH
42787: LD_VAR 0 7
42791: PUSH
42792: LD_INT 3
42794: ARRAY
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: PPUSH
42802: CALL_OW 2
42806: PPUSH
42807: CALL_OW 1
42811: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42812: LD_ADDR_VAR 0 5
42816: PUSH
42817: LD_VAR 0 5
42821: PPUSH
42822: LD_INT 1
42824: PPUSH
42825: CALL_OW 3
42829: ST_TO_ADDR
// if not ext_list then
42830: LD_VAR 0 5
42834: NOT
42835: IFFALSE 42841
// exit ;
42837: POP
42838: POP
42839: GO 42845
// end ;
42841: GO 42716
42843: POP
42844: POP
// end ;
42845: LD_VAR 0 6
42849: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42850: LD_INT 0
42852: PPUSH
// if not mc_bases or not base or not weapon_list then
42853: LD_EXP 50
42857: NOT
42858: PUSH
42859: LD_VAR 0 1
42863: NOT
42864: OR
42865: PUSH
42866: LD_VAR 0 2
42870: NOT
42871: OR
42872: IFFALSE 42876
// exit ;
42874: GO 42901
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42876: LD_ADDR_EXP 89
42880: PUSH
42881: LD_EXP 89
42885: PPUSH
42886: LD_VAR 0 1
42890: PPUSH
42891: LD_VAR 0 2
42895: PPUSH
42896: CALL_OW 1
42900: ST_TO_ADDR
// end ;
42901: LD_VAR 0 3
42905: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42906: LD_INT 0
42908: PPUSH
// if not mc_bases or not base or not tech_list then
42909: LD_EXP 50
42913: NOT
42914: PUSH
42915: LD_VAR 0 1
42919: NOT
42920: OR
42921: PUSH
42922: LD_VAR 0 2
42926: NOT
42927: OR
42928: IFFALSE 42932
// exit ;
42930: GO 42957
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42932: LD_ADDR_EXP 77
42936: PUSH
42937: LD_EXP 77
42941: PPUSH
42942: LD_VAR 0 1
42946: PPUSH
42947: LD_VAR 0 2
42951: PPUSH
42952: CALL_OW 1
42956: ST_TO_ADDR
// end ;
42957: LD_VAR 0 3
42961: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42962: LD_INT 0
42964: PPUSH
// if not mc_bases or not parking_area or not base then
42965: LD_EXP 50
42969: NOT
42970: PUSH
42971: LD_VAR 0 2
42975: NOT
42976: OR
42977: PUSH
42978: LD_VAR 0 1
42982: NOT
42983: OR
42984: IFFALSE 42988
// exit ;
42986: GO 43013
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42988: LD_ADDR_EXP 74
42992: PUSH
42993: LD_EXP 74
42997: PPUSH
42998: LD_VAR 0 1
43002: PPUSH
43003: LD_VAR 0 2
43007: PPUSH
43008: CALL_OW 1
43012: ST_TO_ADDR
// end ;
43013: LD_VAR 0 3
43017: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43018: LD_INT 0
43020: PPUSH
// if not mc_bases or not base or not scan_area then
43021: LD_EXP 50
43025: NOT
43026: PUSH
43027: LD_VAR 0 1
43031: NOT
43032: OR
43033: PUSH
43034: LD_VAR 0 2
43038: NOT
43039: OR
43040: IFFALSE 43044
// exit ;
43042: GO 43069
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43044: LD_ADDR_EXP 75
43048: PUSH
43049: LD_EXP 75
43053: PPUSH
43054: LD_VAR 0 1
43058: PPUSH
43059: LD_VAR 0 2
43063: PPUSH
43064: CALL_OW 1
43068: ST_TO_ADDR
// end ;
43069: LD_VAR 0 3
43073: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43074: LD_INT 0
43076: PPUSH
43077: PPUSH
// if not mc_bases or not base then
43078: LD_EXP 50
43082: NOT
43083: PUSH
43084: LD_VAR 0 1
43088: NOT
43089: OR
43090: IFFALSE 43094
// exit ;
43092: GO 43158
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43094: LD_ADDR_VAR 0 3
43098: PUSH
43099: LD_INT 1
43101: PUSH
43102: LD_INT 2
43104: PUSH
43105: LD_INT 3
43107: PUSH
43108: LD_INT 4
43110: PUSH
43111: LD_INT 11
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43121: LD_ADDR_EXP 77
43125: PUSH
43126: LD_EXP 77
43130: PPUSH
43131: LD_VAR 0 1
43135: PPUSH
43136: LD_EXP 77
43140: PUSH
43141: LD_VAR 0 1
43145: ARRAY
43146: PUSH
43147: LD_VAR 0 3
43151: DIFF
43152: PPUSH
43153: CALL_OW 1
43157: ST_TO_ADDR
// end ;
43158: LD_VAR 0 2
43162: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43163: LD_INT 0
43165: PPUSH
// result := mc_vehicles [ base ] ;
43166: LD_ADDR_VAR 0 3
43170: PUSH
43171: LD_EXP 69
43175: PUSH
43176: LD_VAR 0 1
43180: ARRAY
43181: ST_TO_ADDR
// if onlyCombat then
43182: LD_VAR 0 2
43186: IFFALSE 43364
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43188: LD_ADDR_VAR 0 3
43192: PUSH
43193: LD_VAR 0 3
43197: PUSH
43198: LD_VAR 0 3
43202: PPUSH
43203: LD_INT 2
43205: PUSH
43206: LD_INT 34
43208: PUSH
43209: LD_INT 12
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 34
43218: PUSH
43219: LD_INT 51
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 34
43228: PUSH
43229: LD_EXP 95
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 34
43240: PUSH
43241: LD_INT 32
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 34
43250: PUSH
43251: LD_INT 13
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 34
43260: PUSH
43261: LD_INT 52
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: LD_INT 34
43270: PUSH
43271: LD_EXP 100
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 34
43282: PUSH
43283: LD_INT 14
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 34
43292: PUSH
43293: LD_INT 53
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 34
43302: PUSH
43303: LD_EXP 94
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 34
43314: PUSH
43315: LD_INT 31
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 34
43324: PUSH
43325: LD_INT 48
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 34
43334: PUSH
43335: LD_INT 8
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: LIST
43346: LIST
43347: LIST
43348: LIST
43349: LIST
43350: LIST
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: PPUSH
43358: CALL_OW 72
43362: DIFF
43363: ST_TO_ADDR
// end ; end_of_file
43364: LD_VAR 0 3
43368: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43369: LD_INT 0
43371: PPUSH
43372: PPUSH
43373: PPUSH
// if not mc_bases or not skirmish then
43374: LD_EXP 50
43378: NOT
43379: PUSH
43380: LD_EXP 48
43384: NOT
43385: OR
43386: IFFALSE 43390
// exit ;
43388: GO 43555
// for i = 1 to mc_bases do
43390: LD_ADDR_VAR 0 4
43394: PUSH
43395: DOUBLE
43396: LD_INT 1
43398: DEC
43399: ST_TO_ADDR
43400: LD_EXP 50
43404: PUSH
43405: FOR_TO
43406: IFFALSE 43553
// begin if sci in mc_bases [ i ] then
43408: LD_VAR 0 2
43412: PUSH
43413: LD_EXP 50
43417: PUSH
43418: LD_VAR 0 4
43422: ARRAY
43423: IN
43424: IFFALSE 43551
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43426: LD_ADDR_EXP 79
43430: PUSH
43431: LD_EXP 79
43435: PPUSH
43436: LD_VAR 0 4
43440: PUSH
43441: LD_EXP 79
43445: PUSH
43446: LD_VAR 0 4
43450: ARRAY
43451: PUSH
43452: LD_INT 1
43454: PLUS
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PPUSH
43460: LD_VAR 0 1
43464: PPUSH
43465: CALL 53054 0 3
43469: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43470: LD_ADDR_VAR 0 5
43474: PUSH
43475: LD_EXP 50
43479: PUSH
43480: LD_VAR 0 4
43484: ARRAY
43485: PPUSH
43486: LD_INT 2
43488: PUSH
43489: LD_INT 30
43491: PUSH
43492: LD_INT 0
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 30
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: LIST
43513: PPUSH
43514: CALL_OW 72
43518: PPUSH
43519: LD_VAR 0 1
43523: PPUSH
43524: CALL_OW 74
43528: ST_TO_ADDR
// if tmp then
43529: LD_VAR 0 5
43533: IFFALSE 43549
// ComStandNearbyBuilding ( ape , tmp ) ;
43535: LD_VAR 0 1
43539: PPUSH
43540: LD_VAR 0 5
43544: PPUSH
43545: CALL 49668 0 2
// break ;
43549: GO 43553
// end ; end ;
43551: GO 43405
43553: POP
43554: POP
// end ;
43555: LD_VAR 0 3
43559: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43560: LD_INT 0
43562: PPUSH
43563: PPUSH
43564: PPUSH
// if not mc_bases or not skirmish then
43565: LD_EXP 50
43569: NOT
43570: PUSH
43571: LD_EXP 48
43575: NOT
43576: OR
43577: IFFALSE 43581
// exit ;
43579: GO 43670
// for i = 1 to mc_bases do
43581: LD_ADDR_VAR 0 4
43585: PUSH
43586: DOUBLE
43587: LD_INT 1
43589: DEC
43590: ST_TO_ADDR
43591: LD_EXP 50
43595: PUSH
43596: FOR_TO
43597: IFFALSE 43668
// begin if building in mc_busy_turret_list [ i ] then
43599: LD_VAR 0 1
43603: PUSH
43604: LD_EXP 60
43608: PUSH
43609: LD_VAR 0 4
43613: ARRAY
43614: IN
43615: IFFALSE 43666
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43617: LD_ADDR_VAR 0 5
43621: PUSH
43622: LD_EXP 60
43626: PUSH
43627: LD_VAR 0 4
43631: ARRAY
43632: PUSH
43633: LD_VAR 0 1
43637: DIFF
43638: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43639: LD_ADDR_EXP 60
43643: PUSH
43644: LD_EXP 60
43648: PPUSH
43649: LD_VAR 0 4
43653: PPUSH
43654: LD_VAR 0 5
43658: PPUSH
43659: CALL_OW 1
43663: ST_TO_ADDR
// break ;
43664: GO 43668
// end ; end ;
43666: GO 43596
43668: POP
43669: POP
// end ;
43670: LD_VAR 0 3
43674: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43675: LD_INT 0
43677: PPUSH
43678: PPUSH
43679: PPUSH
// if not mc_bases or not skirmish then
43680: LD_EXP 50
43684: NOT
43685: PUSH
43686: LD_EXP 48
43690: NOT
43691: OR
43692: IFFALSE 43696
// exit ;
43694: GO 43895
// for i = 1 to mc_bases do
43696: LD_ADDR_VAR 0 5
43700: PUSH
43701: DOUBLE
43702: LD_INT 1
43704: DEC
43705: ST_TO_ADDR
43706: LD_EXP 50
43710: PUSH
43711: FOR_TO
43712: IFFALSE 43893
// if building in mc_bases [ i ] then
43714: LD_VAR 0 1
43718: PUSH
43719: LD_EXP 50
43723: PUSH
43724: LD_VAR 0 5
43728: ARRAY
43729: IN
43730: IFFALSE 43891
// begin tmp := mc_bases [ i ] diff building ;
43732: LD_ADDR_VAR 0 6
43736: PUSH
43737: LD_EXP 50
43741: PUSH
43742: LD_VAR 0 5
43746: ARRAY
43747: PUSH
43748: LD_VAR 0 1
43752: DIFF
43753: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43754: LD_ADDR_EXP 50
43758: PUSH
43759: LD_EXP 50
43763: PPUSH
43764: LD_VAR 0 5
43768: PPUSH
43769: LD_VAR 0 6
43773: PPUSH
43774: CALL_OW 1
43778: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43779: LD_VAR 0 1
43783: PUSH
43784: LD_EXP 58
43788: PUSH
43789: LD_VAR 0 5
43793: ARRAY
43794: IN
43795: IFFALSE 43834
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43797: LD_ADDR_EXP 58
43801: PUSH
43802: LD_EXP 58
43806: PPUSH
43807: LD_VAR 0 5
43811: PPUSH
43812: LD_EXP 58
43816: PUSH
43817: LD_VAR 0 5
43821: ARRAY
43822: PUSH
43823: LD_VAR 0 1
43827: DIFF
43828: PPUSH
43829: CALL_OW 1
43833: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43834: LD_VAR 0 1
43838: PUSH
43839: LD_EXP 59
43843: PUSH
43844: LD_VAR 0 5
43848: ARRAY
43849: IN
43850: IFFALSE 43889
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43852: LD_ADDR_EXP 59
43856: PUSH
43857: LD_EXP 59
43861: PPUSH
43862: LD_VAR 0 5
43866: PPUSH
43867: LD_EXP 59
43871: PUSH
43872: LD_VAR 0 5
43876: ARRAY
43877: PUSH
43878: LD_VAR 0 1
43882: DIFF
43883: PPUSH
43884: CALL_OW 1
43888: ST_TO_ADDR
// break ;
43889: GO 43893
// end ;
43891: GO 43711
43893: POP
43894: POP
// end ;
43895: LD_VAR 0 4
43899: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43900: LD_INT 0
43902: PPUSH
43903: PPUSH
43904: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43905: LD_EXP 50
43909: NOT
43910: PUSH
43911: LD_EXP 48
43915: NOT
43916: OR
43917: PUSH
43918: LD_VAR 0 3
43922: PUSH
43923: LD_EXP 76
43927: IN
43928: NOT
43929: OR
43930: IFFALSE 43934
// exit ;
43932: GO 44057
// for i = 1 to mc_vehicles do
43934: LD_ADDR_VAR 0 6
43938: PUSH
43939: DOUBLE
43940: LD_INT 1
43942: DEC
43943: ST_TO_ADDR
43944: LD_EXP 69
43948: PUSH
43949: FOR_TO
43950: IFFALSE 44055
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43952: LD_VAR 0 2
43956: PUSH
43957: LD_EXP 69
43961: PUSH
43962: LD_VAR 0 6
43966: ARRAY
43967: IN
43968: PUSH
43969: LD_VAR 0 1
43973: PUSH
43974: LD_EXP 69
43978: PUSH
43979: LD_VAR 0 6
43983: ARRAY
43984: IN
43985: OR
43986: IFFALSE 44053
// begin tmp := mc_vehicles [ i ] diff old ;
43988: LD_ADDR_VAR 0 7
43992: PUSH
43993: LD_EXP 69
43997: PUSH
43998: LD_VAR 0 6
44002: ARRAY
44003: PUSH
44004: LD_VAR 0 2
44008: DIFF
44009: ST_TO_ADDR
// tmp := tmp diff new ;
44010: LD_ADDR_VAR 0 7
44014: PUSH
44015: LD_VAR 0 7
44019: PUSH
44020: LD_VAR 0 1
44024: DIFF
44025: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44026: LD_ADDR_EXP 69
44030: PUSH
44031: LD_EXP 69
44035: PPUSH
44036: LD_VAR 0 6
44040: PPUSH
44041: LD_VAR 0 7
44045: PPUSH
44046: CALL_OW 1
44050: ST_TO_ADDR
// break ;
44051: GO 44055
// end ;
44053: GO 43949
44055: POP
44056: POP
// end ;
44057: LD_VAR 0 5
44061: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44062: LD_INT 0
44064: PPUSH
44065: PPUSH
44066: PPUSH
44067: PPUSH
// if not mc_bases or not skirmish then
44068: LD_EXP 50
44072: NOT
44073: PUSH
44074: LD_EXP 48
44078: NOT
44079: OR
44080: IFFALSE 44084
// exit ;
44082: GO 44467
// side := GetSide ( vehicle ) ;
44084: LD_ADDR_VAR 0 5
44088: PUSH
44089: LD_VAR 0 1
44093: PPUSH
44094: CALL_OW 255
44098: ST_TO_ADDR
// for i = 1 to mc_bases do
44099: LD_ADDR_VAR 0 4
44103: PUSH
44104: DOUBLE
44105: LD_INT 1
44107: DEC
44108: ST_TO_ADDR
44109: LD_EXP 50
44113: PUSH
44114: FOR_TO
44115: IFFALSE 44465
// begin if factory in mc_bases [ i ] then
44117: LD_VAR 0 2
44121: PUSH
44122: LD_EXP 50
44126: PUSH
44127: LD_VAR 0 4
44131: ARRAY
44132: IN
44133: IFFALSE 44463
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44135: LD_EXP 72
44139: PUSH
44140: LD_VAR 0 4
44144: ARRAY
44145: PUSH
44146: LD_EXP 61
44150: PUSH
44151: LD_VAR 0 4
44155: ARRAY
44156: LESS
44157: PUSH
44158: LD_VAR 0 1
44162: PPUSH
44163: CALL_OW 264
44167: PUSH
44168: LD_INT 31
44170: PUSH
44171: LD_INT 32
44173: PUSH
44174: LD_INT 51
44176: PUSH
44177: LD_EXP 95
44181: PUSH
44182: LD_INT 12
44184: PUSH
44185: LD_INT 30
44187: PUSH
44188: LD_EXP 94
44192: PUSH
44193: LD_INT 11
44195: PUSH
44196: LD_INT 53
44198: PUSH
44199: LD_INT 14
44201: PUSH
44202: LD_EXP 98
44206: PUSH
44207: LD_INT 29
44209: PUSH
44210: LD_EXP 96
44214: PUSH
44215: LD_INT 13
44217: PUSH
44218: LD_INT 52
44220: PUSH
44221: LD_EXP 100
44225: PUSH
44226: LD_INT 48
44228: PUSH
44229: LD_INT 8
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: IN
44252: NOT
44253: AND
44254: IFFALSE 44302
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44256: LD_ADDR_EXP 72
44260: PUSH
44261: LD_EXP 72
44265: PPUSH
44266: LD_VAR 0 4
44270: PUSH
44271: LD_EXP 72
44275: PUSH
44276: LD_VAR 0 4
44280: ARRAY
44281: PUSH
44282: LD_INT 1
44284: PLUS
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PPUSH
44290: LD_VAR 0 1
44294: PPUSH
44295: CALL 53054 0 3
44299: ST_TO_ADDR
44300: GO 44346
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44302: LD_ADDR_EXP 69
44306: PUSH
44307: LD_EXP 69
44311: PPUSH
44312: LD_VAR 0 4
44316: PUSH
44317: LD_EXP 69
44321: PUSH
44322: LD_VAR 0 4
44326: ARRAY
44327: PUSH
44328: LD_INT 1
44330: PLUS
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PPUSH
44336: LD_VAR 0 1
44340: PPUSH
44341: CALL 53054 0 3
44345: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44346: LD_VAR 0 1
44350: PPUSH
44351: CALL_OW 263
44355: PUSH
44356: LD_INT 2
44358: EQUAL
44359: IFFALSE 44379
// begin repeat wait ( 0 0$1 ) ;
44361: LD_INT 35
44363: PPUSH
44364: CALL_OW 67
// until IsControledBy ( vehicle ) ;
44368: LD_VAR 0 1
44372: PPUSH
44373: CALL_OW 312
44377: IFFALSE 44361
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44379: LD_VAR 0 1
44383: PPUSH
44384: LD_EXP 74
44388: PUSH
44389: LD_VAR 0 4
44393: ARRAY
44394: PPUSH
44395: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44399: LD_VAR 0 1
44403: PPUSH
44404: CALL_OW 263
44408: PUSH
44409: LD_INT 1
44411: NONEQUAL
44412: IFFALSE 44416
// break ;
44414: GO 44465
// repeat wait ( 0 0$1 ) ;
44416: LD_INT 35
44418: PPUSH
44419: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44423: LD_VAR 0 1
44427: PPUSH
44428: LD_EXP 74
44432: PUSH
44433: LD_VAR 0 4
44437: ARRAY
44438: PPUSH
44439: CALL_OW 308
44443: IFFALSE 44416
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44445: LD_VAR 0 1
44449: PPUSH
44450: CALL_OW 311
44454: PPUSH
44455: CALL_OW 121
// exit ;
44459: POP
44460: POP
44461: GO 44467
// end ; end ;
44463: GO 44114
44465: POP
44466: POP
// end ;
44467: LD_VAR 0 3
44471: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44472: LD_INT 0
44474: PPUSH
44475: PPUSH
44476: PPUSH
44477: PPUSH
// if not mc_bases or not skirmish then
44478: LD_EXP 50
44482: NOT
44483: PUSH
44484: LD_EXP 48
44488: NOT
44489: OR
44490: IFFALSE 44494
// exit ;
44492: GO 44847
// repeat wait ( 0 0$1 ) ;
44494: LD_INT 35
44496: PPUSH
44497: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44501: LD_VAR 0 2
44505: PPUSH
44506: LD_VAR 0 3
44510: PPUSH
44511: CALL_OW 284
44515: IFFALSE 44494
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44517: LD_VAR 0 2
44521: PPUSH
44522: LD_VAR 0 3
44526: PPUSH
44527: CALL_OW 283
44531: PUSH
44532: LD_INT 4
44534: EQUAL
44535: IFFALSE 44539
// exit ;
44537: GO 44847
// for i = 1 to mc_bases do
44539: LD_ADDR_VAR 0 7
44543: PUSH
44544: DOUBLE
44545: LD_INT 1
44547: DEC
44548: ST_TO_ADDR
44549: LD_EXP 50
44553: PUSH
44554: FOR_TO
44555: IFFALSE 44845
// begin if mc_crates_area [ i ] then
44557: LD_EXP 68
44561: PUSH
44562: LD_VAR 0 7
44566: ARRAY
44567: IFFALSE 44678
// for j in mc_crates_area [ i ] do
44569: LD_ADDR_VAR 0 8
44573: PUSH
44574: LD_EXP 68
44578: PUSH
44579: LD_VAR 0 7
44583: ARRAY
44584: PUSH
44585: FOR_IN
44586: IFFALSE 44676
// if InArea ( x , y , j ) then
44588: LD_VAR 0 2
44592: PPUSH
44593: LD_VAR 0 3
44597: PPUSH
44598: LD_VAR 0 8
44602: PPUSH
44603: CALL_OW 309
44607: IFFALSE 44674
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44609: LD_ADDR_EXP 66
44613: PUSH
44614: LD_EXP 66
44618: PPUSH
44619: LD_VAR 0 7
44623: PUSH
44624: LD_EXP 66
44628: PUSH
44629: LD_VAR 0 7
44633: ARRAY
44634: PUSH
44635: LD_INT 1
44637: PLUS
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PPUSH
44643: LD_VAR 0 4
44647: PUSH
44648: LD_VAR 0 2
44652: PUSH
44653: LD_VAR 0 3
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: LIST
44662: PPUSH
44663: CALL 53054 0 3
44667: ST_TO_ADDR
// exit ;
44668: POP
44669: POP
44670: POP
44671: POP
44672: GO 44847
// end ;
44674: GO 44585
44676: POP
44677: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44678: LD_ADDR_VAR 0 9
44682: PUSH
44683: LD_EXP 50
44687: PUSH
44688: LD_VAR 0 7
44692: ARRAY
44693: PPUSH
44694: LD_INT 2
44696: PUSH
44697: LD_INT 30
44699: PUSH
44700: LD_INT 0
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 30
44709: PUSH
44710: LD_INT 1
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: LIST
44721: PPUSH
44722: CALL_OW 72
44726: ST_TO_ADDR
// if not depot then
44727: LD_VAR 0 9
44731: NOT
44732: IFFALSE 44736
// continue ;
44734: GO 44554
// for j in depot do
44736: LD_ADDR_VAR 0 8
44740: PUSH
44741: LD_VAR 0 9
44745: PUSH
44746: FOR_IN
44747: IFFALSE 44841
// if GetDistUnitXY ( j , x , y ) < 30 then
44749: LD_VAR 0 8
44753: PPUSH
44754: LD_VAR 0 2
44758: PPUSH
44759: LD_VAR 0 3
44763: PPUSH
44764: CALL_OW 297
44768: PUSH
44769: LD_INT 30
44771: LESS
44772: IFFALSE 44839
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44774: LD_ADDR_EXP 66
44778: PUSH
44779: LD_EXP 66
44783: PPUSH
44784: LD_VAR 0 7
44788: PUSH
44789: LD_EXP 66
44793: PUSH
44794: LD_VAR 0 7
44798: ARRAY
44799: PUSH
44800: LD_INT 1
44802: PLUS
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PPUSH
44808: LD_VAR 0 4
44812: PUSH
44813: LD_VAR 0 2
44817: PUSH
44818: LD_VAR 0 3
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: LIST
44827: PPUSH
44828: CALL 53054 0 3
44832: ST_TO_ADDR
// exit ;
44833: POP
44834: POP
44835: POP
44836: POP
44837: GO 44847
// end ;
44839: GO 44746
44841: POP
44842: POP
// end ;
44843: GO 44554
44845: POP
44846: POP
// end ;
44847: LD_VAR 0 6
44851: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44852: LD_INT 0
44854: PPUSH
44855: PPUSH
44856: PPUSH
44857: PPUSH
// if not mc_bases or not skirmish then
44858: LD_EXP 50
44862: NOT
44863: PUSH
44864: LD_EXP 48
44868: NOT
44869: OR
44870: IFFALSE 44874
// exit ;
44872: GO 45151
// side := GetSide ( lab ) ;
44874: LD_ADDR_VAR 0 4
44878: PUSH
44879: LD_VAR 0 2
44883: PPUSH
44884: CALL_OW 255
44888: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44889: LD_VAR 0 4
44893: PUSH
44894: LD_EXP 76
44898: IN
44899: NOT
44900: PUSH
44901: LD_EXP 77
44905: NOT
44906: OR
44907: PUSH
44908: LD_EXP 50
44912: NOT
44913: OR
44914: IFFALSE 44918
// exit ;
44916: GO 45151
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44918: LD_ADDR_EXP 77
44922: PUSH
44923: LD_EXP 77
44927: PPUSH
44928: LD_VAR 0 4
44932: PPUSH
44933: LD_EXP 77
44937: PUSH
44938: LD_VAR 0 4
44942: ARRAY
44943: PUSH
44944: LD_VAR 0 1
44948: DIFF
44949: PPUSH
44950: CALL_OW 1
44954: ST_TO_ADDR
// for i = 1 to mc_bases do
44955: LD_ADDR_VAR 0 5
44959: PUSH
44960: DOUBLE
44961: LD_INT 1
44963: DEC
44964: ST_TO_ADDR
44965: LD_EXP 50
44969: PUSH
44970: FOR_TO
44971: IFFALSE 45149
// begin if lab in mc_bases [ i ] then
44973: LD_VAR 0 2
44977: PUSH
44978: LD_EXP 50
44982: PUSH
44983: LD_VAR 0 5
44987: ARRAY
44988: IN
44989: IFFALSE 45147
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44991: LD_VAR 0 1
44995: PUSH
44996: LD_INT 11
44998: PUSH
44999: LD_INT 4
45001: PUSH
45002: LD_INT 3
45004: PUSH
45005: LD_INT 2
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: LIST
45012: LIST
45013: IN
45014: PUSH
45015: LD_EXP 80
45019: PUSH
45020: LD_VAR 0 5
45024: ARRAY
45025: AND
45026: IFFALSE 45147
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45028: LD_ADDR_VAR 0 6
45032: PUSH
45033: LD_EXP 80
45037: PUSH
45038: LD_VAR 0 5
45042: ARRAY
45043: PUSH
45044: LD_INT 1
45046: ARRAY
45047: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45048: LD_ADDR_EXP 80
45052: PUSH
45053: LD_EXP 80
45057: PPUSH
45058: LD_VAR 0 5
45062: PPUSH
45063: EMPTY
45064: PPUSH
45065: CALL_OW 1
45069: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45070: LD_VAR 0 6
45074: PPUSH
45075: LD_INT 0
45077: PPUSH
45078: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45082: LD_VAR 0 6
45086: PPUSH
45087: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45091: LD_ADDR_EXP 79
45095: PUSH
45096: LD_EXP 79
45100: PPUSH
45101: LD_VAR 0 5
45105: PPUSH
45106: LD_EXP 79
45110: PUSH
45111: LD_VAR 0 5
45115: ARRAY
45116: PPUSH
45117: LD_INT 1
45119: PPUSH
45120: LD_VAR 0 6
45124: PPUSH
45125: CALL_OW 2
45129: PPUSH
45130: CALL_OW 1
45134: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45135: LD_VAR 0 5
45139: PPUSH
45140: LD_INT 112
45142: PPUSH
45143: CALL 21980 0 2
// end ; end ; end ;
45147: GO 44970
45149: POP
45150: POP
// end ;
45151: LD_VAR 0 3
45155: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45156: LD_INT 0
45158: PPUSH
45159: PPUSH
45160: PPUSH
45161: PPUSH
45162: PPUSH
45163: PPUSH
45164: PPUSH
45165: PPUSH
// if not mc_bases or not skirmish then
45166: LD_EXP 50
45170: NOT
45171: PUSH
45172: LD_EXP 48
45176: NOT
45177: OR
45178: IFFALSE 45182
// exit ;
45180: GO 46553
// for i = 1 to mc_bases do
45182: LD_ADDR_VAR 0 3
45186: PUSH
45187: DOUBLE
45188: LD_INT 1
45190: DEC
45191: ST_TO_ADDR
45192: LD_EXP 50
45196: PUSH
45197: FOR_TO
45198: IFFALSE 46551
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45200: LD_VAR 0 1
45204: PUSH
45205: LD_EXP 50
45209: PUSH
45210: LD_VAR 0 3
45214: ARRAY
45215: IN
45216: PUSH
45217: LD_VAR 0 1
45221: PUSH
45222: LD_EXP 57
45226: PUSH
45227: LD_VAR 0 3
45231: ARRAY
45232: IN
45233: OR
45234: PUSH
45235: LD_VAR 0 1
45239: PUSH
45240: LD_EXP 72
45244: PUSH
45245: LD_VAR 0 3
45249: ARRAY
45250: IN
45251: OR
45252: PUSH
45253: LD_VAR 0 1
45257: PUSH
45258: LD_EXP 69
45262: PUSH
45263: LD_VAR 0 3
45267: ARRAY
45268: IN
45269: OR
45270: PUSH
45271: LD_VAR 0 1
45275: PUSH
45276: LD_EXP 79
45280: PUSH
45281: LD_VAR 0 3
45285: ARRAY
45286: IN
45287: OR
45288: PUSH
45289: LD_VAR 0 1
45293: PUSH
45294: LD_EXP 80
45298: PUSH
45299: LD_VAR 0 3
45303: ARRAY
45304: IN
45305: OR
45306: IFFALSE 46549
// begin if un in mc_ape [ i ] then
45308: LD_VAR 0 1
45312: PUSH
45313: LD_EXP 79
45317: PUSH
45318: LD_VAR 0 3
45322: ARRAY
45323: IN
45324: IFFALSE 45363
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45326: LD_ADDR_EXP 79
45330: PUSH
45331: LD_EXP 79
45335: PPUSH
45336: LD_VAR 0 3
45340: PPUSH
45341: LD_EXP 79
45345: PUSH
45346: LD_VAR 0 3
45350: ARRAY
45351: PUSH
45352: LD_VAR 0 1
45356: DIFF
45357: PPUSH
45358: CALL_OW 1
45362: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45363: LD_VAR 0 1
45367: PUSH
45368: LD_EXP 80
45372: PUSH
45373: LD_VAR 0 3
45377: ARRAY
45378: IN
45379: IFFALSE 45403
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45381: LD_ADDR_EXP 80
45385: PUSH
45386: LD_EXP 80
45390: PPUSH
45391: LD_VAR 0 3
45395: PPUSH
45396: EMPTY
45397: PPUSH
45398: CALL_OW 1
45402: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45403: LD_VAR 0 1
45407: PPUSH
45408: CALL_OW 247
45412: PUSH
45413: LD_INT 2
45415: EQUAL
45416: PUSH
45417: LD_VAR 0 1
45421: PPUSH
45422: CALL_OW 110
45426: PUSH
45427: LD_INT 20
45429: EQUAL
45430: PUSH
45431: LD_VAR 0 1
45435: PUSH
45436: LD_EXP 72
45440: PUSH
45441: LD_VAR 0 3
45445: ARRAY
45446: IN
45447: OR
45448: PUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: CALL_OW 264
45458: PUSH
45459: LD_INT 12
45461: PUSH
45462: LD_INT 51
45464: PUSH
45465: LD_EXP 95
45469: PUSH
45470: LD_INT 32
45472: PUSH
45473: LD_INT 13
45475: PUSH
45476: LD_INT 52
45478: PUSH
45479: LD_INT 31
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: IN
45491: OR
45492: AND
45493: IFFALSE 45801
// begin if un in mc_defender [ i ] then
45495: LD_VAR 0 1
45499: PUSH
45500: LD_EXP 72
45504: PUSH
45505: LD_VAR 0 3
45509: ARRAY
45510: IN
45511: IFFALSE 45550
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45513: LD_ADDR_EXP 72
45517: PUSH
45518: LD_EXP 72
45522: PPUSH
45523: LD_VAR 0 3
45527: PPUSH
45528: LD_EXP 72
45532: PUSH
45533: LD_VAR 0 3
45537: ARRAY
45538: PUSH
45539: LD_VAR 0 1
45543: DIFF
45544: PPUSH
45545: CALL_OW 1
45549: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45550: LD_ADDR_VAR 0 8
45554: PUSH
45555: LD_VAR 0 3
45559: PPUSH
45560: LD_INT 3
45562: PPUSH
45563: CALL 42200 0 2
45567: ST_TO_ADDR
// if fac then
45568: LD_VAR 0 8
45572: IFFALSE 45801
// begin for j in fac do
45574: LD_ADDR_VAR 0 4
45578: PUSH
45579: LD_VAR 0 8
45583: PUSH
45584: FOR_IN
45585: IFFALSE 45799
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45587: LD_ADDR_VAR 0 9
45591: PUSH
45592: LD_VAR 0 8
45596: PPUSH
45597: LD_VAR 0 1
45601: PPUSH
45602: CALL_OW 265
45606: PPUSH
45607: LD_VAR 0 1
45611: PPUSH
45612: CALL_OW 262
45616: PPUSH
45617: LD_VAR 0 1
45621: PPUSH
45622: CALL_OW 263
45626: PPUSH
45627: LD_VAR 0 1
45631: PPUSH
45632: CALL_OW 264
45636: PPUSH
45637: CALL 50586 0 5
45641: ST_TO_ADDR
// if components then
45642: LD_VAR 0 9
45646: IFFALSE 45797
// begin if GetWeapon ( un ) = ar_control_tower then
45648: LD_VAR 0 1
45652: PPUSH
45653: CALL_OW 264
45657: PUSH
45658: LD_INT 31
45660: EQUAL
45661: IFFALSE 45778
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45663: LD_VAR 0 1
45667: PPUSH
45668: CALL_OW 311
45672: PPUSH
45673: LD_INT 0
45675: PPUSH
45676: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45680: LD_ADDR_EXP 90
45684: PUSH
45685: LD_EXP 90
45689: PPUSH
45690: LD_VAR 0 3
45694: PPUSH
45695: LD_EXP 90
45699: PUSH
45700: LD_VAR 0 3
45704: ARRAY
45705: PUSH
45706: LD_VAR 0 1
45710: PPUSH
45711: CALL_OW 311
45715: DIFF
45716: PPUSH
45717: CALL_OW 1
45721: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45722: LD_ADDR_VAR 0 7
45726: PUSH
45727: LD_EXP 71
45731: PUSH
45732: LD_VAR 0 3
45736: ARRAY
45737: PPUSH
45738: LD_INT 1
45740: PPUSH
45741: LD_VAR 0 9
45745: PPUSH
45746: CALL_OW 2
45750: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45751: LD_ADDR_EXP 71
45755: PUSH
45756: LD_EXP 71
45760: PPUSH
45761: LD_VAR 0 3
45765: PPUSH
45766: LD_VAR 0 7
45770: PPUSH
45771: CALL_OW 1
45775: ST_TO_ADDR
// end else
45776: GO 45795
// MC_InsertProduceList ( i , [ components ] ) ;
45778: LD_VAR 0 3
45782: PPUSH
45783: LD_VAR 0 9
45787: PUSH
45788: EMPTY
45789: LIST
45790: PPUSH
45791: CALL 41745 0 2
// break ;
45795: GO 45799
// end ; end ;
45797: GO 45584
45799: POP
45800: POP
// end ; end ; if GetType ( un ) = unit_building then
45801: LD_VAR 0 1
45805: PPUSH
45806: CALL_OW 247
45810: PUSH
45811: LD_INT 3
45813: EQUAL
45814: IFFALSE 46217
// begin btype := GetBType ( un ) ;
45816: LD_ADDR_VAR 0 5
45820: PUSH
45821: LD_VAR 0 1
45825: PPUSH
45826: CALL_OW 266
45830: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45831: LD_VAR 0 5
45835: PUSH
45836: LD_INT 29
45838: PUSH
45839: LD_INT 30
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: IN
45846: IFFALSE 45919
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45848: LD_VAR 0 1
45852: PPUSH
45853: CALL_OW 250
45857: PPUSH
45858: LD_VAR 0 1
45862: PPUSH
45863: CALL_OW 251
45867: PPUSH
45868: LD_VAR 0 1
45872: PPUSH
45873: CALL_OW 255
45877: PPUSH
45878: CALL_OW 440
45882: NOT
45883: IFFALSE 45919
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45885: LD_VAR 0 1
45889: PPUSH
45890: CALL_OW 250
45894: PPUSH
45895: LD_VAR 0 1
45899: PPUSH
45900: CALL_OW 251
45904: PPUSH
45905: LD_VAR 0 1
45909: PPUSH
45910: CALL_OW 255
45914: PPUSH
45915: CALL_OW 441
// end ; if btype = b_warehouse then
45919: LD_VAR 0 5
45923: PUSH
45924: LD_INT 1
45926: EQUAL
45927: IFFALSE 45945
// begin btype := b_depot ;
45929: LD_ADDR_VAR 0 5
45933: PUSH
45934: LD_INT 0
45936: ST_TO_ADDR
// pos := 1 ;
45937: LD_ADDR_VAR 0 6
45941: PUSH
45942: LD_INT 1
45944: ST_TO_ADDR
// end ; if btype = b_factory then
45945: LD_VAR 0 5
45949: PUSH
45950: LD_INT 3
45952: EQUAL
45953: IFFALSE 45971
// begin btype := b_workshop ;
45955: LD_ADDR_VAR 0 5
45959: PUSH
45960: LD_INT 2
45962: ST_TO_ADDR
// pos := 1 ;
45963: LD_ADDR_VAR 0 6
45967: PUSH
45968: LD_INT 1
45970: ST_TO_ADDR
// end ; if btype = b_barracks then
45971: LD_VAR 0 5
45975: PUSH
45976: LD_INT 5
45978: EQUAL
45979: IFFALSE 45989
// btype := b_armoury ;
45981: LD_ADDR_VAR 0 5
45985: PUSH
45986: LD_INT 4
45988: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45989: LD_VAR 0 5
45993: PUSH
45994: LD_INT 7
45996: PUSH
45997: LD_INT 8
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: IN
46004: IFFALSE 46014
// btype := b_lab ;
46006: LD_ADDR_VAR 0 5
46010: PUSH
46011: LD_INT 6
46013: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46014: LD_ADDR_EXP 55
46018: PUSH
46019: LD_EXP 55
46023: PPUSH
46024: LD_VAR 0 3
46028: PUSH
46029: LD_EXP 55
46033: PUSH
46034: LD_VAR 0 3
46038: ARRAY
46039: PUSH
46040: LD_INT 1
46042: PLUS
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PPUSH
46048: LD_VAR 0 5
46052: PUSH
46053: LD_VAR 0 1
46057: PPUSH
46058: CALL_OW 250
46062: PUSH
46063: LD_VAR 0 1
46067: PPUSH
46068: CALL_OW 251
46072: PUSH
46073: LD_VAR 0 1
46077: PPUSH
46078: CALL_OW 254
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: PPUSH
46089: CALL 53054 0 3
46093: ST_TO_ADDR
// if pos = 1 then
46094: LD_VAR 0 6
46098: PUSH
46099: LD_INT 1
46101: EQUAL
46102: IFFALSE 46217
// begin tmp := mc_build_list [ i ] ;
46104: LD_ADDR_VAR 0 7
46108: PUSH
46109: LD_EXP 55
46113: PUSH
46114: LD_VAR 0 3
46118: ARRAY
46119: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46120: LD_VAR 0 7
46124: PPUSH
46125: LD_INT 2
46127: PUSH
46128: LD_INT 30
46130: PUSH
46131: LD_INT 0
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 30
46140: PUSH
46141: LD_INT 1
46143: PUSH
46144: EMPTY
46145: LIST
46146: LIST
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: LIST
46152: PPUSH
46153: CALL_OW 72
46157: IFFALSE 46167
// pos := 2 ;
46159: LD_ADDR_VAR 0 6
46163: PUSH
46164: LD_INT 2
46166: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46167: LD_ADDR_VAR 0 7
46171: PUSH
46172: LD_VAR 0 7
46176: PPUSH
46177: LD_VAR 0 6
46181: PPUSH
46182: LD_VAR 0 7
46186: PPUSH
46187: CALL 53380 0 3
46191: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46192: LD_ADDR_EXP 55
46196: PUSH
46197: LD_EXP 55
46201: PPUSH
46202: LD_VAR 0 3
46206: PPUSH
46207: LD_VAR 0 7
46211: PPUSH
46212: CALL_OW 1
46216: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46217: LD_VAR 0 1
46221: PUSH
46222: LD_EXP 50
46226: PUSH
46227: LD_VAR 0 3
46231: ARRAY
46232: IN
46233: IFFALSE 46272
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46235: LD_ADDR_EXP 50
46239: PUSH
46240: LD_EXP 50
46244: PPUSH
46245: LD_VAR 0 3
46249: PPUSH
46250: LD_EXP 50
46254: PUSH
46255: LD_VAR 0 3
46259: ARRAY
46260: PUSH
46261: LD_VAR 0 1
46265: DIFF
46266: PPUSH
46267: CALL_OW 1
46271: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46272: LD_VAR 0 1
46276: PUSH
46277: LD_EXP 57
46281: PUSH
46282: LD_VAR 0 3
46286: ARRAY
46287: IN
46288: IFFALSE 46327
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46290: LD_ADDR_EXP 57
46294: PUSH
46295: LD_EXP 57
46299: PPUSH
46300: LD_VAR 0 3
46304: PPUSH
46305: LD_EXP 57
46309: PUSH
46310: LD_VAR 0 3
46314: ARRAY
46315: PUSH
46316: LD_VAR 0 1
46320: DIFF
46321: PPUSH
46322: CALL_OW 1
46326: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46327: LD_VAR 0 1
46331: PUSH
46332: LD_EXP 69
46336: PUSH
46337: LD_VAR 0 3
46341: ARRAY
46342: IN
46343: IFFALSE 46382
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46345: LD_ADDR_EXP 69
46349: PUSH
46350: LD_EXP 69
46354: PPUSH
46355: LD_VAR 0 3
46359: PPUSH
46360: LD_EXP 69
46364: PUSH
46365: LD_VAR 0 3
46369: ARRAY
46370: PUSH
46371: LD_VAR 0 1
46375: DIFF
46376: PPUSH
46377: CALL_OW 1
46381: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46382: LD_VAR 0 1
46386: PUSH
46387: LD_EXP 72
46391: PUSH
46392: LD_VAR 0 3
46396: ARRAY
46397: IN
46398: IFFALSE 46437
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46400: LD_ADDR_EXP 72
46404: PUSH
46405: LD_EXP 72
46409: PPUSH
46410: LD_VAR 0 3
46414: PPUSH
46415: LD_EXP 72
46419: PUSH
46420: LD_VAR 0 3
46424: ARRAY
46425: PUSH
46426: LD_VAR 0 1
46430: DIFF
46431: PPUSH
46432: CALL_OW 1
46436: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46437: LD_VAR 0 1
46441: PUSH
46442: LD_EXP 59
46446: PUSH
46447: LD_VAR 0 3
46451: ARRAY
46452: IN
46453: IFFALSE 46492
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46455: LD_ADDR_EXP 59
46459: PUSH
46460: LD_EXP 59
46464: PPUSH
46465: LD_VAR 0 3
46469: PPUSH
46470: LD_EXP 59
46474: PUSH
46475: LD_VAR 0 3
46479: ARRAY
46480: PUSH
46481: LD_VAR 0 1
46485: DIFF
46486: PPUSH
46487: CALL_OW 1
46491: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46492: LD_VAR 0 1
46496: PUSH
46497: LD_EXP 58
46501: PUSH
46502: LD_VAR 0 3
46506: ARRAY
46507: IN
46508: IFFALSE 46547
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46510: LD_ADDR_EXP 58
46514: PUSH
46515: LD_EXP 58
46519: PPUSH
46520: LD_VAR 0 3
46524: PPUSH
46525: LD_EXP 58
46529: PUSH
46530: LD_VAR 0 3
46534: ARRAY
46535: PUSH
46536: LD_VAR 0 1
46540: DIFF
46541: PPUSH
46542: CALL_OW 1
46546: ST_TO_ADDR
// end ; break ;
46547: GO 46551
// end ;
46549: GO 45197
46551: POP
46552: POP
// end ;
46553: LD_VAR 0 2
46557: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46558: LD_INT 0
46560: PPUSH
46561: PPUSH
46562: PPUSH
// if not mc_bases or not skirmish then
46563: LD_EXP 50
46567: NOT
46568: PUSH
46569: LD_EXP 48
46573: NOT
46574: OR
46575: IFFALSE 46579
// exit ;
46577: GO 46794
// for i = 1 to mc_bases do
46579: LD_ADDR_VAR 0 3
46583: PUSH
46584: DOUBLE
46585: LD_INT 1
46587: DEC
46588: ST_TO_ADDR
46589: LD_EXP 50
46593: PUSH
46594: FOR_TO
46595: IFFALSE 46792
// begin if building in mc_construct_list [ i ] then
46597: LD_VAR 0 1
46601: PUSH
46602: LD_EXP 57
46606: PUSH
46607: LD_VAR 0 3
46611: ARRAY
46612: IN
46613: IFFALSE 46790
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46615: LD_ADDR_EXP 57
46619: PUSH
46620: LD_EXP 57
46624: PPUSH
46625: LD_VAR 0 3
46629: PPUSH
46630: LD_EXP 57
46634: PUSH
46635: LD_VAR 0 3
46639: ARRAY
46640: PUSH
46641: LD_VAR 0 1
46645: DIFF
46646: PPUSH
46647: CALL_OW 1
46651: ST_TO_ADDR
// if building in mc_lab [ i ] then
46652: LD_VAR 0 1
46656: PUSH
46657: LD_EXP 83
46661: PUSH
46662: LD_VAR 0 3
46666: ARRAY
46667: IN
46668: IFFALSE 46723
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46670: LD_ADDR_EXP 84
46674: PUSH
46675: LD_EXP 84
46679: PPUSH
46680: LD_VAR 0 3
46684: PPUSH
46685: LD_EXP 84
46689: PUSH
46690: LD_VAR 0 3
46694: ARRAY
46695: PPUSH
46696: LD_INT 1
46698: PPUSH
46699: LD_EXP 84
46703: PUSH
46704: LD_VAR 0 3
46708: ARRAY
46709: PPUSH
46710: LD_INT 0
46712: PPUSH
46713: CALL 52472 0 4
46717: PPUSH
46718: CALL_OW 1
46722: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46723: LD_VAR 0 1
46727: PUSH
46728: LD_EXP 50
46732: PUSH
46733: LD_VAR 0 3
46737: ARRAY
46738: IN
46739: NOT
46740: IFFALSE 46786
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46742: LD_ADDR_EXP 50
46746: PUSH
46747: LD_EXP 50
46751: PPUSH
46752: LD_VAR 0 3
46756: PUSH
46757: LD_EXP 50
46761: PUSH
46762: LD_VAR 0 3
46766: ARRAY
46767: PUSH
46768: LD_INT 1
46770: PLUS
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PPUSH
46776: LD_VAR 0 1
46780: PPUSH
46781: CALL 53054 0 3
46785: ST_TO_ADDR
// exit ;
46786: POP
46787: POP
46788: GO 46794
// end ; end ;
46790: GO 46594
46792: POP
46793: POP
// end ;
46794: LD_VAR 0 2
46798: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46799: LD_INT 0
46801: PPUSH
46802: PPUSH
46803: PPUSH
46804: PPUSH
46805: PPUSH
46806: PPUSH
46807: PPUSH
// if not mc_bases or not skirmish then
46808: LD_EXP 50
46812: NOT
46813: PUSH
46814: LD_EXP 48
46818: NOT
46819: OR
46820: IFFALSE 46824
// exit ;
46822: GO 47485
// for i = 1 to mc_bases do
46824: LD_ADDR_VAR 0 3
46828: PUSH
46829: DOUBLE
46830: LD_INT 1
46832: DEC
46833: ST_TO_ADDR
46834: LD_EXP 50
46838: PUSH
46839: FOR_TO
46840: IFFALSE 47483
// begin if building in mc_construct_list [ i ] then
46842: LD_VAR 0 1
46846: PUSH
46847: LD_EXP 57
46851: PUSH
46852: LD_VAR 0 3
46856: ARRAY
46857: IN
46858: IFFALSE 47481
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46860: LD_ADDR_EXP 57
46864: PUSH
46865: LD_EXP 57
46869: PPUSH
46870: LD_VAR 0 3
46874: PPUSH
46875: LD_EXP 57
46879: PUSH
46880: LD_VAR 0 3
46884: ARRAY
46885: PUSH
46886: LD_VAR 0 1
46890: DIFF
46891: PPUSH
46892: CALL_OW 1
46896: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46897: LD_ADDR_EXP 50
46901: PUSH
46902: LD_EXP 50
46906: PPUSH
46907: LD_VAR 0 3
46911: PUSH
46912: LD_EXP 50
46916: PUSH
46917: LD_VAR 0 3
46921: ARRAY
46922: PUSH
46923: LD_INT 1
46925: PLUS
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PPUSH
46931: LD_VAR 0 1
46935: PPUSH
46936: CALL 53054 0 3
46940: ST_TO_ADDR
// btype := GetBType ( building ) ;
46941: LD_ADDR_VAR 0 5
46945: PUSH
46946: LD_VAR 0 1
46950: PPUSH
46951: CALL_OW 266
46955: ST_TO_ADDR
// side := GetSide ( building ) ;
46956: LD_ADDR_VAR 0 8
46960: PUSH
46961: LD_VAR 0 1
46965: PPUSH
46966: CALL_OW 255
46970: ST_TO_ADDR
// if btype = b_lab then
46971: LD_VAR 0 5
46975: PUSH
46976: LD_INT 6
46978: EQUAL
46979: IFFALSE 47029
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46981: LD_ADDR_EXP 83
46985: PUSH
46986: LD_EXP 83
46990: PPUSH
46991: LD_VAR 0 3
46995: PUSH
46996: LD_EXP 83
47000: PUSH
47001: LD_VAR 0 3
47005: ARRAY
47006: PUSH
47007: LD_INT 1
47009: PLUS
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PPUSH
47015: LD_VAR 0 1
47019: PPUSH
47020: CALL 53054 0 3
47024: ST_TO_ADDR
// exit ;
47025: POP
47026: POP
47027: GO 47485
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47029: LD_VAR 0 5
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 2
47039: PUSH
47040: LD_INT 4
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: LIST
47047: IN
47048: IFFALSE 47172
// begin if btype = b_armoury then
47050: LD_VAR 0 5
47054: PUSH
47055: LD_INT 4
47057: EQUAL
47058: IFFALSE 47068
// btype := b_barracks ;
47060: LD_ADDR_VAR 0 5
47064: PUSH
47065: LD_INT 5
47067: ST_TO_ADDR
// if btype = b_depot then
47068: LD_VAR 0 5
47072: PUSH
47073: LD_INT 0
47075: EQUAL
47076: IFFALSE 47086
// btype := b_warehouse ;
47078: LD_ADDR_VAR 0 5
47082: PUSH
47083: LD_INT 1
47085: ST_TO_ADDR
// if btype = b_workshop then
47086: LD_VAR 0 5
47090: PUSH
47091: LD_INT 2
47093: EQUAL
47094: IFFALSE 47104
// btype := b_factory ;
47096: LD_ADDR_VAR 0 5
47100: PUSH
47101: LD_INT 3
47103: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47104: LD_VAR 0 5
47108: PPUSH
47109: LD_VAR 0 8
47113: PPUSH
47114: CALL_OW 323
47118: PUSH
47119: LD_INT 1
47121: EQUAL
47122: IFFALSE 47168
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47124: LD_ADDR_EXP 82
47128: PUSH
47129: LD_EXP 82
47133: PPUSH
47134: LD_VAR 0 3
47138: PUSH
47139: LD_EXP 82
47143: PUSH
47144: LD_VAR 0 3
47148: ARRAY
47149: PUSH
47150: LD_INT 1
47152: PLUS
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PPUSH
47158: LD_VAR 0 1
47162: PPUSH
47163: CALL 53054 0 3
47167: ST_TO_ADDR
// exit ;
47168: POP
47169: POP
47170: GO 47485
// end ; if btype in [ b_bunker , b_turret ] then
47172: LD_VAR 0 5
47176: PUSH
47177: LD_INT 32
47179: PUSH
47180: LD_INT 33
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: IN
47187: IFFALSE 47477
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47189: LD_ADDR_EXP 58
47193: PUSH
47194: LD_EXP 58
47198: PPUSH
47199: LD_VAR 0 3
47203: PUSH
47204: LD_EXP 58
47208: PUSH
47209: LD_VAR 0 3
47213: ARRAY
47214: PUSH
47215: LD_INT 1
47217: PLUS
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: PPUSH
47223: LD_VAR 0 1
47227: PPUSH
47228: CALL 53054 0 3
47232: ST_TO_ADDR
// if btype = b_bunker then
47233: LD_VAR 0 5
47237: PUSH
47238: LD_INT 32
47240: EQUAL
47241: IFFALSE 47477
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47243: LD_ADDR_EXP 59
47247: PUSH
47248: LD_EXP 59
47252: PPUSH
47253: LD_VAR 0 3
47257: PUSH
47258: LD_EXP 59
47262: PUSH
47263: LD_VAR 0 3
47267: ARRAY
47268: PUSH
47269: LD_INT 1
47271: PLUS
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PPUSH
47277: LD_VAR 0 1
47281: PPUSH
47282: CALL 53054 0 3
47286: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47287: LD_ADDR_VAR 0 6
47291: PUSH
47292: LD_EXP 50
47296: PUSH
47297: LD_VAR 0 3
47301: ARRAY
47302: PPUSH
47303: LD_INT 25
47305: PUSH
47306: LD_INT 1
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: PUSH
47313: LD_INT 3
47315: PUSH
47316: LD_INT 54
47318: PUSH
47319: EMPTY
47320: LIST
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PPUSH
47330: CALL_OW 72
47334: ST_TO_ADDR
// if tmp then
47335: LD_VAR 0 6
47339: IFFALSE 47345
// exit ;
47341: POP
47342: POP
47343: GO 47485
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47345: LD_ADDR_VAR 0 6
47349: PUSH
47350: LD_EXP 50
47354: PUSH
47355: LD_VAR 0 3
47359: ARRAY
47360: PPUSH
47361: LD_INT 2
47363: PUSH
47364: LD_INT 30
47366: PUSH
47367: LD_INT 4
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: PUSH
47374: LD_INT 30
47376: PUSH
47377: LD_INT 5
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: LIST
47388: PPUSH
47389: CALL_OW 72
47393: ST_TO_ADDR
// if not tmp then
47394: LD_VAR 0 6
47398: NOT
47399: IFFALSE 47405
// exit ;
47401: POP
47402: POP
47403: GO 47485
// for j in tmp do
47405: LD_ADDR_VAR 0 4
47409: PUSH
47410: LD_VAR 0 6
47414: PUSH
47415: FOR_IN
47416: IFFALSE 47475
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47418: LD_ADDR_VAR 0 7
47422: PUSH
47423: LD_VAR 0 4
47427: PPUSH
47428: CALL_OW 313
47432: PPUSH
47433: LD_INT 25
47435: PUSH
47436: LD_INT 1
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PPUSH
47443: CALL_OW 72
47447: ST_TO_ADDR
// if units then
47448: LD_VAR 0 7
47452: IFFALSE 47473
// begin ComExitBuilding ( units [ 1 ] ) ;
47454: LD_VAR 0 7
47458: PUSH
47459: LD_INT 1
47461: ARRAY
47462: PPUSH
47463: CALL_OW 122
// exit ;
47467: POP
47468: POP
47469: POP
47470: POP
47471: GO 47485
// end ; end ;
47473: GO 47415
47475: POP
47476: POP
// end ; end ; exit ;
47477: POP
47478: POP
47479: GO 47485
// end ; end ;
47481: GO 46839
47483: POP
47484: POP
// end ;
47485: LD_VAR 0 2
47489: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47490: LD_INT 0
47492: PPUSH
47493: PPUSH
47494: PPUSH
47495: PPUSH
47496: PPUSH
47497: PPUSH
47498: PPUSH
// if not mc_bases or not skirmish then
47499: LD_EXP 50
47503: NOT
47504: PUSH
47505: LD_EXP 48
47509: NOT
47510: OR
47511: IFFALSE 47515
// exit ;
47513: GO 47746
// btype := GetBType ( building ) ;
47515: LD_ADDR_VAR 0 6
47519: PUSH
47520: LD_VAR 0 1
47524: PPUSH
47525: CALL_OW 266
47529: ST_TO_ADDR
// x := GetX ( building ) ;
47530: LD_ADDR_VAR 0 7
47534: PUSH
47535: LD_VAR 0 1
47539: PPUSH
47540: CALL_OW 250
47544: ST_TO_ADDR
// y := GetY ( building ) ;
47545: LD_ADDR_VAR 0 8
47549: PUSH
47550: LD_VAR 0 1
47554: PPUSH
47555: CALL_OW 251
47559: ST_TO_ADDR
// d := GetDir ( building ) ;
47560: LD_ADDR_VAR 0 9
47564: PUSH
47565: LD_VAR 0 1
47569: PPUSH
47570: CALL_OW 254
47574: ST_TO_ADDR
// for i = 1 to mc_bases do
47575: LD_ADDR_VAR 0 4
47579: PUSH
47580: DOUBLE
47581: LD_INT 1
47583: DEC
47584: ST_TO_ADDR
47585: LD_EXP 50
47589: PUSH
47590: FOR_TO
47591: IFFALSE 47744
// begin if not mc_build_list [ i ] then
47593: LD_EXP 55
47597: PUSH
47598: LD_VAR 0 4
47602: ARRAY
47603: NOT
47604: IFFALSE 47608
// continue ;
47606: GO 47590
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
47608: LD_VAR 0 6
47612: PUSH
47613: LD_VAR 0 7
47617: PUSH
47618: LD_VAR 0 8
47622: PUSH
47623: LD_VAR 0 9
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: PPUSH
47634: LD_EXP 55
47638: PUSH
47639: LD_VAR 0 4
47643: ARRAY
47644: PUSH
47645: LD_INT 1
47647: ARRAY
47648: PPUSH
47649: CALL 59261 0 2
47653: IFFALSE 47742
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
47655: LD_ADDR_EXP 55
47659: PUSH
47660: LD_EXP 55
47664: PPUSH
47665: LD_VAR 0 4
47669: PPUSH
47670: LD_EXP 55
47674: PUSH
47675: LD_VAR 0 4
47679: ARRAY
47680: PPUSH
47681: LD_INT 1
47683: PPUSH
47684: CALL_OW 3
47688: PPUSH
47689: CALL_OW 1
47693: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47694: LD_ADDR_EXP 57
47698: PUSH
47699: LD_EXP 57
47703: PPUSH
47704: LD_VAR 0 4
47708: PUSH
47709: LD_EXP 57
47713: PUSH
47714: LD_VAR 0 4
47718: ARRAY
47719: PUSH
47720: LD_INT 1
47722: PLUS
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PPUSH
47728: LD_VAR 0 1
47732: PPUSH
47733: CALL 53054 0 3
47737: ST_TO_ADDR
// exit ;
47738: POP
47739: POP
47740: GO 47746
// end ; end ;
47742: GO 47590
47744: POP
47745: POP
// end ;
47746: LD_VAR 0 3
47750: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47751: LD_INT 0
47753: PPUSH
47754: PPUSH
47755: PPUSH
// if not mc_bases or not skirmish then
47756: LD_EXP 50
47760: NOT
47761: PUSH
47762: LD_EXP 48
47766: NOT
47767: OR
47768: IFFALSE 47772
// exit ;
47770: GO 47962
// for i = 1 to mc_bases do
47772: LD_ADDR_VAR 0 4
47776: PUSH
47777: DOUBLE
47778: LD_INT 1
47780: DEC
47781: ST_TO_ADDR
47782: LD_EXP 50
47786: PUSH
47787: FOR_TO
47788: IFFALSE 47875
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47790: LD_VAR 0 1
47794: PUSH
47795: LD_EXP 58
47799: PUSH
47800: LD_VAR 0 4
47804: ARRAY
47805: IN
47806: PUSH
47807: LD_VAR 0 1
47811: PUSH
47812: LD_EXP 59
47816: PUSH
47817: LD_VAR 0 4
47821: ARRAY
47822: IN
47823: NOT
47824: AND
47825: IFFALSE 47873
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47827: LD_ADDR_EXP 59
47831: PUSH
47832: LD_EXP 59
47836: PPUSH
47837: LD_VAR 0 4
47841: PUSH
47842: LD_EXP 59
47846: PUSH
47847: LD_VAR 0 4
47851: ARRAY
47852: PUSH
47853: LD_INT 1
47855: PLUS
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PPUSH
47861: LD_VAR 0 1
47865: PPUSH
47866: CALL 53054 0 3
47870: ST_TO_ADDR
// break ;
47871: GO 47875
// end ; end ;
47873: GO 47787
47875: POP
47876: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47877: LD_VAR 0 1
47881: PPUSH
47882: CALL_OW 257
47886: PUSH
47887: LD_EXP 76
47891: IN
47892: PUSH
47893: LD_VAR 0 1
47897: PPUSH
47898: CALL_OW 266
47902: PUSH
47903: LD_INT 5
47905: EQUAL
47906: AND
47907: PUSH
47908: LD_VAR 0 2
47912: PPUSH
47913: CALL_OW 110
47917: PUSH
47918: LD_INT 18
47920: NONEQUAL
47921: AND
47922: IFFALSE 47962
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47924: LD_VAR 0 2
47928: PPUSH
47929: CALL_OW 257
47933: PUSH
47934: LD_INT 5
47936: PUSH
47937: LD_INT 8
47939: PUSH
47940: LD_INT 9
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: LIST
47947: IN
47948: IFFALSE 47962
// SetClass ( unit , 1 ) ;
47950: LD_VAR 0 2
47954: PPUSH
47955: LD_INT 1
47957: PPUSH
47958: CALL_OW 336
// end ;
47962: LD_VAR 0 3
47966: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47967: LD_INT 0
47969: PPUSH
47970: PPUSH
// if not mc_bases or not skirmish then
47971: LD_EXP 50
47975: NOT
47976: PUSH
47977: LD_EXP 48
47981: NOT
47982: OR
47983: IFFALSE 47987
// exit ;
47985: GO 48103
// if GetLives ( abandoned_vehicle ) > 250 then
47987: LD_VAR 0 2
47991: PPUSH
47992: CALL_OW 256
47996: PUSH
47997: LD_INT 250
47999: GREATER
48000: IFFALSE 48004
// exit ;
48002: GO 48103
// for i = 1 to mc_bases do
48004: LD_ADDR_VAR 0 6
48008: PUSH
48009: DOUBLE
48010: LD_INT 1
48012: DEC
48013: ST_TO_ADDR
48014: LD_EXP 50
48018: PUSH
48019: FOR_TO
48020: IFFALSE 48101
// begin if driver in mc_bases [ i ] then
48022: LD_VAR 0 1
48026: PUSH
48027: LD_EXP 50
48031: PUSH
48032: LD_VAR 0 6
48036: ARRAY
48037: IN
48038: IFFALSE 48099
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48040: LD_VAR 0 1
48044: PPUSH
48045: LD_EXP 50
48049: PUSH
48050: LD_VAR 0 6
48054: ARRAY
48055: PPUSH
48056: LD_INT 2
48058: PUSH
48059: LD_INT 30
48061: PUSH
48062: LD_INT 0
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: PUSH
48069: LD_INT 30
48071: PUSH
48072: LD_INT 1
48074: PUSH
48075: EMPTY
48076: LIST
48077: LIST
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: LIST
48083: PPUSH
48084: CALL_OW 72
48088: PUSH
48089: LD_INT 1
48091: ARRAY
48092: PPUSH
48093: CALL 85297 0 2
// break ;
48097: GO 48101
// end ; end ;
48099: GO 48019
48101: POP
48102: POP
// end ; end_of_file
48103: LD_VAR 0 5
48107: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48108: LD_INT 0
48110: PPUSH
48111: PPUSH
// if exist_mode then
48112: LD_VAR 0 2
48116: IFFALSE 48141
// unit := CreateCharacter ( prefix & ident ) else
48118: LD_ADDR_VAR 0 5
48122: PUSH
48123: LD_VAR 0 3
48127: PUSH
48128: LD_VAR 0 1
48132: STR
48133: PPUSH
48134: CALL_OW 34
48138: ST_TO_ADDR
48139: GO 48156
// unit := NewCharacter ( ident ) ;
48141: LD_ADDR_VAR 0 5
48145: PUSH
48146: LD_VAR 0 1
48150: PPUSH
48151: CALL_OW 25
48155: ST_TO_ADDR
// result := unit ;
48156: LD_ADDR_VAR 0 4
48160: PUSH
48161: LD_VAR 0 5
48165: ST_TO_ADDR
// end ;
48166: LD_VAR 0 4
48170: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48171: LD_INT 0
48173: PPUSH
48174: PPUSH
// if not side or not nation then
48175: LD_VAR 0 1
48179: NOT
48180: PUSH
48181: LD_VAR 0 2
48185: NOT
48186: OR
48187: IFFALSE 48191
// exit ;
48189: GO 48955
// case nation of nation_american :
48191: LD_VAR 0 2
48195: PUSH
48196: LD_INT 1
48198: DOUBLE
48199: EQUAL
48200: IFTRUE 48204
48202: GO 48418
48204: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48205: LD_ADDR_VAR 0 4
48209: PUSH
48210: LD_INT 35
48212: PUSH
48213: LD_INT 45
48215: PUSH
48216: LD_INT 46
48218: PUSH
48219: LD_INT 47
48221: PUSH
48222: LD_INT 82
48224: PUSH
48225: LD_INT 83
48227: PUSH
48228: LD_INT 84
48230: PUSH
48231: LD_INT 85
48233: PUSH
48234: LD_INT 86
48236: PUSH
48237: LD_INT 1
48239: PUSH
48240: LD_INT 2
48242: PUSH
48243: LD_INT 6
48245: PUSH
48246: LD_INT 15
48248: PUSH
48249: LD_INT 16
48251: PUSH
48252: LD_INT 7
48254: PUSH
48255: LD_INT 12
48257: PUSH
48258: LD_INT 13
48260: PUSH
48261: LD_INT 10
48263: PUSH
48264: LD_INT 14
48266: PUSH
48267: LD_INT 20
48269: PUSH
48270: LD_INT 21
48272: PUSH
48273: LD_INT 22
48275: PUSH
48276: LD_INT 25
48278: PUSH
48279: LD_INT 32
48281: PUSH
48282: LD_INT 27
48284: PUSH
48285: LD_INT 36
48287: PUSH
48288: LD_INT 69
48290: PUSH
48291: LD_INT 39
48293: PUSH
48294: LD_INT 34
48296: PUSH
48297: LD_INT 40
48299: PUSH
48300: LD_INT 48
48302: PUSH
48303: LD_INT 49
48305: PUSH
48306: LD_INT 50
48308: PUSH
48309: LD_INT 51
48311: PUSH
48312: LD_INT 52
48314: PUSH
48315: LD_INT 53
48317: PUSH
48318: LD_INT 54
48320: PUSH
48321: LD_INT 55
48323: PUSH
48324: LD_INT 56
48326: PUSH
48327: LD_INT 57
48329: PUSH
48330: LD_INT 58
48332: PUSH
48333: LD_INT 59
48335: PUSH
48336: LD_INT 60
48338: PUSH
48339: LD_INT 61
48341: PUSH
48342: LD_INT 62
48344: PUSH
48345: LD_INT 80
48347: PUSH
48348: LD_INT 82
48350: PUSH
48351: LD_INT 83
48353: PUSH
48354: LD_INT 84
48356: PUSH
48357: LD_INT 85
48359: PUSH
48360: LD_INT 86
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: ST_TO_ADDR
48416: GO 48879
48418: LD_INT 2
48420: DOUBLE
48421: EQUAL
48422: IFTRUE 48426
48424: GO 48648
48426: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
48427: LD_ADDR_VAR 0 4
48431: PUSH
48432: LD_INT 35
48434: PUSH
48435: LD_INT 45
48437: PUSH
48438: LD_INT 46
48440: PUSH
48441: LD_INT 47
48443: PUSH
48444: LD_INT 82
48446: PUSH
48447: LD_INT 83
48449: PUSH
48450: LD_INT 84
48452: PUSH
48453: LD_INT 85
48455: PUSH
48456: LD_INT 87
48458: PUSH
48459: LD_INT 70
48461: PUSH
48462: LD_INT 1
48464: PUSH
48465: LD_INT 11
48467: PUSH
48468: LD_INT 3
48470: PUSH
48471: LD_INT 4
48473: PUSH
48474: LD_INT 5
48476: PUSH
48477: LD_INT 6
48479: PUSH
48480: LD_INT 15
48482: PUSH
48483: LD_INT 18
48485: PUSH
48486: LD_INT 7
48488: PUSH
48489: LD_INT 17
48491: PUSH
48492: LD_INT 8
48494: PUSH
48495: LD_INT 20
48497: PUSH
48498: LD_INT 21
48500: PUSH
48501: LD_INT 22
48503: PUSH
48504: LD_INT 72
48506: PUSH
48507: LD_INT 26
48509: PUSH
48510: LD_INT 69
48512: PUSH
48513: LD_INT 39
48515: PUSH
48516: LD_INT 40
48518: PUSH
48519: LD_INT 41
48521: PUSH
48522: LD_INT 42
48524: PUSH
48525: LD_INT 43
48527: PUSH
48528: LD_INT 48
48530: PUSH
48531: LD_INT 49
48533: PUSH
48534: LD_INT 50
48536: PUSH
48537: LD_INT 51
48539: PUSH
48540: LD_INT 52
48542: PUSH
48543: LD_INT 53
48545: PUSH
48546: LD_INT 54
48548: PUSH
48549: LD_INT 55
48551: PUSH
48552: LD_INT 56
48554: PUSH
48555: LD_INT 60
48557: PUSH
48558: LD_INT 61
48560: PUSH
48561: LD_INT 62
48563: PUSH
48564: LD_INT 66
48566: PUSH
48567: LD_INT 67
48569: PUSH
48570: LD_INT 68
48572: PUSH
48573: LD_INT 81
48575: PUSH
48576: LD_INT 82
48578: PUSH
48579: LD_INT 83
48581: PUSH
48582: LD_INT 84
48584: PUSH
48585: LD_INT 85
48587: PUSH
48588: LD_INT 87
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: LIST
48595: LIST
48596: LIST
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: LIST
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: LIST
48633: LIST
48634: LIST
48635: LIST
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: ST_TO_ADDR
48646: GO 48879
48648: LD_INT 3
48650: DOUBLE
48651: EQUAL
48652: IFTRUE 48656
48654: GO 48878
48656: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48657: LD_ADDR_VAR 0 4
48661: PUSH
48662: LD_INT 46
48664: PUSH
48665: LD_INT 47
48667: PUSH
48668: LD_INT 1
48670: PUSH
48671: LD_INT 2
48673: PUSH
48674: LD_INT 82
48676: PUSH
48677: LD_INT 83
48679: PUSH
48680: LD_INT 84
48682: PUSH
48683: LD_INT 85
48685: PUSH
48686: LD_INT 86
48688: PUSH
48689: LD_INT 11
48691: PUSH
48692: LD_INT 9
48694: PUSH
48695: LD_INT 20
48697: PUSH
48698: LD_INT 19
48700: PUSH
48701: LD_INT 21
48703: PUSH
48704: LD_INT 24
48706: PUSH
48707: LD_INT 22
48709: PUSH
48710: LD_INT 25
48712: PUSH
48713: LD_INT 28
48715: PUSH
48716: LD_INT 29
48718: PUSH
48719: LD_INT 30
48721: PUSH
48722: LD_INT 31
48724: PUSH
48725: LD_INT 37
48727: PUSH
48728: LD_INT 38
48730: PUSH
48731: LD_INT 32
48733: PUSH
48734: LD_INT 27
48736: PUSH
48737: LD_INT 33
48739: PUSH
48740: LD_INT 69
48742: PUSH
48743: LD_INT 39
48745: PUSH
48746: LD_INT 34
48748: PUSH
48749: LD_INT 40
48751: PUSH
48752: LD_INT 71
48754: PUSH
48755: LD_INT 23
48757: PUSH
48758: LD_INT 44
48760: PUSH
48761: LD_INT 48
48763: PUSH
48764: LD_INT 49
48766: PUSH
48767: LD_INT 50
48769: PUSH
48770: LD_INT 51
48772: PUSH
48773: LD_INT 52
48775: PUSH
48776: LD_INT 53
48778: PUSH
48779: LD_INT 54
48781: PUSH
48782: LD_INT 55
48784: PUSH
48785: LD_INT 56
48787: PUSH
48788: LD_INT 57
48790: PUSH
48791: LD_INT 58
48793: PUSH
48794: LD_INT 59
48796: PUSH
48797: LD_INT 63
48799: PUSH
48800: LD_INT 64
48802: PUSH
48803: LD_INT 65
48805: PUSH
48806: LD_INT 82
48808: PUSH
48809: LD_INT 83
48811: PUSH
48812: LD_INT 84
48814: PUSH
48815: LD_INT 85
48817: PUSH
48818: LD_INT 86
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: LIST
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: LIST
48870: LIST
48871: LIST
48872: LIST
48873: LIST
48874: LIST
48875: ST_TO_ADDR
48876: GO 48879
48878: POP
// if state > - 1 and state < 3 then
48879: LD_VAR 0 3
48883: PUSH
48884: LD_INT 1
48886: NEG
48887: GREATER
48888: PUSH
48889: LD_VAR 0 3
48893: PUSH
48894: LD_INT 3
48896: LESS
48897: AND
48898: IFFALSE 48955
// for i in result do
48900: LD_ADDR_VAR 0 5
48904: PUSH
48905: LD_VAR 0 4
48909: PUSH
48910: FOR_IN
48911: IFFALSE 48953
// if GetTech ( i , side ) <> state then
48913: LD_VAR 0 5
48917: PPUSH
48918: LD_VAR 0 1
48922: PPUSH
48923: CALL_OW 321
48927: PUSH
48928: LD_VAR 0 3
48932: NONEQUAL
48933: IFFALSE 48951
// result := result diff i ;
48935: LD_ADDR_VAR 0 4
48939: PUSH
48940: LD_VAR 0 4
48944: PUSH
48945: LD_VAR 0 5
48949: DIFF
48950: ST_TO_ADDR
48951: GO 48910
48953: POP
48954: POP
// end ;
48955: LD_VAR 0 4
48959: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48960: LD_INT 0
48962: PPUSH
48963: PPUSH
48964: PPUSH
// result := true ;
48965: LD_ADDR_VAR 0 3
48969: PUSH
48970: LD_INT 1
48972: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48973: LD_ADDR_VAR 0 5
48977: PUSH
48978: LD_VAR 0 2
48982: PPUSH
48983: CALL_OW 480
48987: ST_TO_ADDR
// if not tmp then
48988: LD_VAR 0 5
48992: NOT
48993: IFFALSE 48997
// exit ;
48995: GO 49046
// for i in tmp do
48997: LD_ADDR_VAR 0 4
49001: PUSH
49002: LD_VAR 0 5
49006: PUSH
49007: FOR_IN
49008: IFFALSE 49044
// if GetTech ( i , side ) <> state_researched then
49010: LD_VAR 0 4
49014: PPUSH
49015: LD_VAR 0 1
49019: PPUSH
49020: CALL_OW 321
49024: PUSH
49025: LD_INT 2
49027: NONEQUAL
49028: IFFALSE 49042
// begin result := false ;
49030: LD_ADDR_VAR 0 3
49034: PUSH
49035: LD_INT 0
49037: ST_TO_ADDR
// exit ;
49038: POP
49039: POP
49040: GO 49046
// end ;
49042: GO 49007
49044: POP
49045: POP
// end ;
49046: LD_VAR 0 3
49050: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49051: LD_INT 0
49053: PPUSH
49054: PPUSH
49055: PPUSH
49056: PPUSH
49057: PPUSH
49058: PPUSH
49059: PPUSH
49060: PPUSH
49061: PPUSH
49062: PPUSH
49063: PPUSH
49064: PPUSH
49065: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49066: LD_VAR 0 1
49070: NOT
49071: PUSH
49072: LD_VAR 0 1
49076: PPUSH
49077: CALL_OW 257
49081: PUSH
49082: LD_INT 9
49084: NONEQUAL
49085: OR
49086: IFFALSE 49090
// exit ;
49088: GO 49663
// side := GetSide ( unit ) ;
49090: LD_ADDR_VAR 0 9
49094: PUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: CALL_OW 255
49104: ST_TO_ADDR
// tech_space := tech_spacanom ;
49105: LD_ADDR_VAR 0 12
49109: PUSH
49110: LD_INT 29
49112: ST_TO_ADDR
// tech_time := tech_taurad ;
49113: LD_ADDR_VAR 0 13
49117: PUSH
49118: LD_INT 28
49120: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49121: LD_ADDR_VAR 0 11
49125: PUSH
49126: LD_VAR 0 1
49130: PPUSH
49131: CALL_OW 310
49135: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49136: LD_VAR 0 11
49140: PPUSH
49141: CALL_OW 247
49145: PUSH
49146: LD_INT 2
49148: EQUAL
49149: IFFALSE 49153
// exit ;
49151: GO 49663
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49153: LD_ADDR_VAR 0 8
49157: PUSH
49158: LD_INT 81
49160: PUSH
49161: LD_VAR 0 9
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: PUSH
49170: LD_INT 3
49172: PUSH
49173: LD_INT 21
49175: PUSH
49176: LD_INT 3
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: PPUSH
49191: CALL_OW 69
49195: ST_TO_ADDR
// if not tmp then
49196: LD_VAR 0 8
49200: NOT
49201: IFFALSE 49205
// exit ;
49203: GO 49663
// if in_unit then
49205: LD_VAR 0 11
49209: IFFALSE 49233
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49211: LD_ADDR_VAR 0 10
49215: PUSH
49216: LD_VAR 0 8
49220: PPUSH
49221: LD_VAR 0 11
49225: PPUSH
49226: CALL_OW 74
49230: ST_TO_ADDR
49231: GO 49253
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49233: LD_ADDR_VAR 0 10
49237: PUSH
49238: LD_VAR 0 8
49242: PPUSH
49243: LD_VAR 0 1
49247: PPUSH
49248: CALL_OW 74
49252: ST_TO_ADDR
// if not enemy then
49253: LD_VAR 0 10
49257: NOT
49258: IFFALSE 49262
// exit ;
49260: GO 49663
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49262: LD_VAR 0 11
49266: PUSH
49267: LD_VAR 0 11
49271: PPUSH
49272: LD_VAR 0 10
49276: PPUSH
49277: CALL_OW 296
49281: PUSH
49282: LD_INT 13
49284: GREATER
49285: AND
49286: PUSH
49287: LD_VAR 0 1
49291: PPUSH
49292: LD_VAR 0 10
49296: PPUSH
49297: CALL_OW 296
49301: PUSH
49302: LD_INT 12
49304: GREATER
49305: OR
49306: IFFALSE 49310
// exit ;
49308: GO 49663
// missile := [ 1 ] ;
49310: LD_ADDR_VAR 0 14
49314: PUSH
49315: LD_INT 1
49317: PUSH
49318: EMPTY
49319: LIST
49320: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49321: LD_VAR 0 9
49325: PPUSH
49326: LD_VAR 0 12
49330: PPUSH
49331: CALL_OW 325
49335: IFFALSE 49364
// missile := Insert ( missile , missile + 1 , 2 ) ;
49337: LD_ADDR_VAR 0 14
49341: PUSH
49342: LD_VAR 0 14
49346: PPUSH
49347: LD_VAR 0 14
49351: PUSH
49352: LD_INT 1
49354: PLUS
49355: PPUSH
49356: LD_INT 2
49358: PPUSH
49359: CALL_OW 2
49363: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49364: LD_VAR 0 9
49368: PPUSH
49369: LD_VAR 0 13
49373: PPUSH
49374: CALL_OW 325
49378: PUSH
49379: LD_VAR 0 10
49383: PPUSH
49384: CALL_OW 255
49388: PPUSH
49389: LD_VAR 0 13
49393: PPUSH
49394: CALL_OW 325
49398: NOT
49399: AND
49400: IFFALSE 49429
// missile := Insert ( missile , missile + 1 , 3 ) ;
49402: LD_ADDR_VAR 0 14
49406: PUSH
49407: LD_VAR 0 14
49411: PPUSH
49412: LD_VAR 0 14
49416: PUSH
49417: LD_INT 1
49419: PLUS
49420: PPUSH
49421: LD_INT 3
49423: PPUSH
49424: CALL_OW 2
49428: ST_TO_ADDR
// if missile < 2 then
49429: LD_VAR 0 14
49433: PUSH
49434: LD_INT 2
49436: LESS
49437: IFFALSE 49441
// exit ;
49439: GO 49663
// x := GetX ( enemy ) ;
49441: LD_ADDR_VAR 0 4
49445: PUSH
49446: LD_VAR 0 10
49450: PPUSH
49451: CALL_OW 250
49455: ST_TO_ADDR
// y := GetY ( enemy ) ;
49456: LD_ADDR_VAR 0 5
49460: PUSH
49461: LD_VAR 0 10
49465: PPUSH
49466: CALL_OW 251
49470: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49471: LD_ADDR_VAR 0 6
49475: PUSH
49476: LD_VAR 0 4
49480: PUSH
49481: LD_INT 1
49483: NEG
49484: PPUSH
49485: LD_INT 1
49487: PPUSH
49488: CALL_OW 12
49492: PLUS
49493: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49494: LD_ADDR_VAR 0 7
49498: PUSH
49499: LD_VAR 0 5
49503: PUSH
49504: LD_INT 1
49506: NEG
49507: PPUSH
49508: LD_INT 1
49510: PPUSH
49511: CALL_OW 12
49515: PLUS
49516: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49517: LD_VAR 0 6
49521: PPUSH
49522: LD_VAR 0 7
49526: PPUSH
49527: CALL_OW 488
49531: NOT
49532: IFFALSE 49554
// begin _x := x ;
49534: LD_ADDR_VAR 0 6
49538: PUSH
49539: LD_VAR 0 4
49543: ST_TO_ADDR
// _y := y ;
49544: LD_ADDR_VAR 0 7
49548: PUSH
49549: LD_VAR 0 5
49553: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49554: LD_ADDR_VAR 0 3
49558: PUSH
49559: LD_INT 1
49561: PPUSH
49562: LD_VAR 0 14
49566: PPUSH
49567: CALL_OW 12
49571: ST_TO_ADDR
// case i of 1 :
49572: LD_VAR 0 3
49576: PUSH
49577: LD_INT 1
49579: DOUBLE
49580: EQUAL
49581: IFTRUE 49585
49583: GO 49602
49585: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49586: LD_VAR 0 1
49590: PPUSH
49591: LD_VAR 0 10
49595: PPUSH
49596: CALL_OW 115
49600: GO 49663
49602: LD_INT 2
49604: DOUBLE
49605: EQUAL
49606: IFTRUE 49610
49608: GO 49632
49610: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49611: LD_VAR 0 1
49615: PPUSH
49616: LD_VAR 0 6
49620: PPUSH
49621: LD_VAR 0 7
49625: PPUSH
49626: CALL_OW 153
49630: GO 49663
49632: LD_INT 3
49634: DOUBLE
49635: EQUAL
49636: IFTRUE 49640
49638: GO 49662
49640: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49641: LD_VAR 0 1
49645: PPUSH
49646: LD_VAR 0 6
49650: PPUSH
49651: LD_VAR 0 7
49655: PPUSH
49656: CALL_OW 154
49660: GO 49663
49662: POP
// end ;
49663: LD_VAR 0 2
49667: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49668: LD_INT 0
49670: PPUSH
49671: PPUSH
49672: PPUSH
49673: PPUSH
49674: PPUSH
49675: PPUSH
// if not unit or not building then
49676: LD_VAR 0 1
49680: NOT
49681: PUSH
49682: LD_VAR 0 2
49686: NOT
49687: OR
49688: IFFALSE 49692
// exit ;
49690: GO 49850
// x := GetX ( building ) ;
49692: LD_ADDR_VAR 0 5
49696: PUSH
49697: LD_VAR 0 2
49701: PPUSH
49702: CALL_OW 250
49706: ST_TO_ADDR
// y := GetY ( building ) ;
49707: LD_ADDR_VAR 0 6
49711: PUSH
49712: LD_VAR 0 2
49716: PPUSH
49717: CALL_OW 251
49721: ST_TO_ADDR
// for i = 0 to 5 do
49722: LD_ADDR_VAR 0 4
49726: PUSH
49727: DOUBLE
49728: LD_INT 0
49730: DEC
49731: ST_TO_ADDR
49732: LD_INT 5
49734: PUSH
49735: FOR_TO
49736: IFFALSE 49848
// begin _x := ShiftX ( x , i , 3 ) ;
49738: LD_ADDR_VAR 0 7
49742: PUSH
49743: LD_VAR 0 5
49747: PPUSH
49748: LD_VAR 0 4
49752: PPUSH
49753: LD_INT 3
49755: PPUSH
49756: CALL_OW 272
49760: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49761: LD_ADDR_VAR 0 8
49765: PUSH
49766: LD_VAR 0 6
49770: PPUSH
49771: LD_VAR 0 4
49775: PPUSH
49776: LD_INT 3
49778: PPUSH
49779: CALL_OW 273
49783: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49784: LD_VAR 0 7
49788: PPUSH
49789: LD_VAR 0 8
49793: PPUSH
49794: CALL_OW 488
49798: NOT
49799: IFFALSE 49803
// continue ;
49801: GO 49735
// if HexInfo ( _x , _y ) = 0 then
49803: LD_VAR 0 7
49807: PPUSH
49808: LD_VAR 0 8
49812: PPUSH
49813: CALL_OW 428
49817: PUSH
49818: LD_INT 0
49820: EQUAL
49821: IFFALSE 49846
// begin ComMoveXY ( unit , _x , _y ) ;
49823: LD_VAR 0 1
49827: PPUSH
49828: LD_VAR 0 7
49832: PPUSH
49833: LD_VAR 0 8
49837: PPUSH
49838: CALL_OW 111
// exit ;
49842: POP
49843: POP
49844: GO 49850
// end ; end ;
49846: GO 49735
49848: POP
49849: POP
// end ;
49850: LD_VAR 0 3
49854: RET
// export function ScanBase ( side , base_area ) ; begin
49855: LD_INT 0
49857: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49858: LD_ADDR_VAR 0 3
49862: PUSH
49863: LD_VAR 0 2
49867: PPUSH
49868: LD_INT 81
49870: PUSH
49871: LD_VAR 0 1
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: PPUSH
49880: CALL_OW 70
49884: ST_TO_ADDR
// end ;
49885: LD_VAR 0 3
49889: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49890: LD_INT 0
49892: PPUSH
49893: PPUSH
49894: PPUSH
49895: PPUSH
// result := false ;
49896: LD_ADDR_VAR 0 2
49900: PUSH
49901: LD_INT 0
49903: ST_TO_ADDR
// side := GetSide ( unit ) ;
49904: LD_ADDR_VAR 0 3
49908: PUSH
49909: LD_VAR 0 1
49913: PPUSH
49914: CALL_OW 255
49918: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49919: LD_ADDR_VAR 0 4
49923: PUSH
49924: LD_VAR 0 1
49928: PPUSH
49929: CALL_OW 248
49933: ST_TO_ADDR
// case nat of 1 :
49934: LD_VAR 0 4
49938: PUSH
49939: LD_INT 1
49941: DOUBLE
49942: EQUAL
49943: IFTRUE 49947
49945: GO 49958
49947: POP
// tech := tech_lassight ; 2 :
49948: LD_ADDR_VAR 0 5
49952: PUSH
49953: LD_INT 12
49955: ST_TO_ADDR
49956: GO 49997
49958: LD_INT 2
49960: DOUBLE
49961: EQUAL
49962: IFTRUE 49966
49964: GO 49977
49966: POP
// tech := tech_mortar ; 3 :
49967: LD_ADDR_VAR 0 5
49971: PUSH
49972: LD_INT 41
49974: ST_TO_ADDR
49975: GO 49997
49977: LD_INT 3
49979: DOUBLE
49980: EQUAL
49981: IFTRUE 49985
49983: GO 49996
49985: POP
// tech := tech_bazooka ; end ;
49986: LD_ADDR_VAR 0 5
49990: PUSH
49991: LD_INT 44
49993: ST_TO_ADDR
49994: GO 49997
49996: POP
// if Researched ( side , tech ) then
49997: LD_VAR 0 3
50001: PPUSH
50002: LD_VAR 0 5
50006: PPUSH
50007: CALL_OW 325
50011: IFFALSE 50038
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50013: LD_ADDR_VAR 0 2
50017: PUSH
50018: LD_INT 5
50020: PUSH
50021: LD_INT 8
50023: PUSH
50024: LD_INT 9
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: LIST
50031: PUSH
50032: LD_VAR 0 4
50036: ARRAY
50037: ST_TO_ADDR
// end ;
50038: LD_VAR 0 2
50042: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50043: LD_INT 0
50045: PPUSH
50046: PPUSH
50047: PPUSH
// if not mines then
50048: LD_VAR 0 2
50052: NOT
50053: IFFALSE 50057
// exit ;
50055: GO 50201
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50057: LD_ADDR_VAR 0 5
50061: PUSH
50062: LD_INT 81
50064: PUSH
50065: LD_VAR 0 1
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PUSH
50074: LD_INT 3
50076: PUSH
50077: LD_INT 21
50079: PUSH
50080: LD_INT 3
50082: PUSH
50083: EMPTY
50084: LIST
50085: LIST
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PPUSH
50095: CALL_OW 69
50099: ST_TO_ADDR
// for i in mines do
50100: LD_ADDR_VAR 0 4
50104: PUSH
50105: LD_VAR 0 2
50109: PUSH
50110: FOR_IN
50111: IFFALSE 50199
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50113: LD_VAR 0 4
50117: PUSH
50118: LD_INT 1
50120: ARRAY
50121: PPUSH
50122: LD_VAR 0 4
50126: PUSH
50127: LD_INT 2
50129: ARRAY
50130: PPUSH
50131: CALL_OW 458
50135: NOT
50136: IFFALSE 50140
// continue ;
50138: GO 50110
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50140: LD_VAR 0 4
50144: PUSH
50145: LD_INT 1
50147: ARRAY
50148: PPUSH
50149: LD_VAR 0 4
50153: PUSH
50154: LD_INT 2
50156: ARRAY
50157: PPUSH
50158: CALL_OW 428
50162: PUSH
50163: LD_VAR 0 5
50167: IN
50168: IFFALSE 50197
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50170: LD_VAR 0 4
50174: PUSH
50175: LD_INT 1
50177: ARRAY
50178: PPUSH
50179: LD_VAR 0 4
50183: PUSH
50184: LD_INT 2
50186: ARRAY
50187: PPUSH
50188: LD_VAR 0 1
50192: PPUSH
50193: CALL_OW 456
// end ;
50197: GO 50110
50199: POP
50200: POP
// end ;
50201: LD_VAR 0 3
50205: RET
// export function Count ( array ) ; var i ; begin
50206: LD_INT 0
50208: PPUSH
50209: PPUSH
// result := 0 ;
50210: LD_ADDR_VAR 0 2
50214: PUSH
50215: LD_INT 0
50217: ST_TO_ADDR
// for i in array do
50218: LD_ADDR_VAR 0 3
50222: PUSH
50223: LD_VAR 0 1
50227: PUSH
50228: FOR_IN
50229: IFFALSE 50253
// if i then
50231: LD_VAR 0 3
50235: IFFALSE 50251
// result := result + 1 ;
50237: LD_ADDR_VAR 0 2
50241: PUSH
50242: LD_VAR 0 2
50246: PUSH
50247: LD_INT 1
50249: PLUS
50250: ST_TO_ADDR
50251: GO 50228
50253: POP
50254: POP
// end ;
50255: LD_VAR 0 2
50259: RET
// export function IsEmpty ( building ) ; begin
50260: LD_INT 0
50262: PPUSH
// if not building then
50263: LD_VAR 0 1
50267: NOT
50268: IFFALSE 50272
// exit ;
50270: GO 50315
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50272: LD_ADDR_VAR 0 2
50276: PUSH
50277: LD_VAR 0 1
50281: PUSH
50282: LD_INT 22
50284: PUSH
50285: LD_VAR 0 1
50289: PPUSH
50290: CALL_OW 255
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PUSH
50299: LD_INT 58
50301: PUSH
50302: EMPTY
50303: LIST
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: PPUSH
50309: CALL_OW 69
50313: IN
50314: ST_TO_ADDR
// end ;
50315: LD_VAR 0 2
50319: RET
// export function IsNotFull ( building ) ; begin
50320: LD_INT 0
50322: PPUSH
// if not building then
50323: LD_VAR 0 1
50327: NOT
50328: IFFALSE 50332
// exit ;
50330: GO 50351
// result := UnitsInside ( building ) < 6 ;
50332: LD_ADDR_VAR 0 2
50336: PUSH
50337: LD_VAR 0 1
50341: PPUSH
50342: CALL_OW 313
50346: PUSH
50347: LD_INT 6
50349: LESS
50350: ST_TO_ADDR
// end ;
50351: LD_VAR 0 2
50355: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50356: LD_INT 0
50358: PPUSH
50359: PPUSH
50360: PPUSH
50361: PPUSH
// tmp := [ ] ;
50362: LD_ADDR_VAR 0 3
50366: PUSH
50367: EMPTY
50368: ST_TO_ADDR
// list := [ ] ;
50369: LD_ADDR_VAR 0 5
50373: PUSH
50374: EMPTY
50375: ST_TO_ADDR
// for i = 16 to 25 do
50376: LD_ADDR_VAR 0 4
50380: PUSH
50381: DOUBLE
50382: LD_INT 16
50384: DEC
50385: ST_TO_ADDR
50386: LD_INT 25
50388: PUSH
50389: FOR_TO
50390: IFFALSE 50463
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50392: LD_ADDR_VAR 0 3
50396: PUSH
50397: LD_VAR 0 3
50401: PUSH
50402: LD_INT 22
50404: PUSH
50405: LD_VAR 0 1
50409: PPUSH
50410: CALL_OW 255
50414: PUSH
50415: EMPTY
50416: LIST
50417: LIST
50418: PUSH
50419: LD_INT 91
50421: PUSH
50422: LD_VAR 0 1
50426: PUSH
50427: LD_INT 6
50429: PUSH
50430: EMPTY
50431: LIST
50432: LIST
50433: LIST
50434: PUSH
50435: LD_INT 30
50437: PUSH
50438: LD_VAR 0 4
50442: PUSH
50443: EMPTY
50444: LIST
50445: LIST
50446: PUSH
50447: EMPTY
50448: LIST
50449: LIST
50450: LIST
50451: PUSH
50452: EMPTY
50453: LIST
50454: PPUSH
50455: CALL_OW 69
50459: ADD
50460: ST_TO_ADDR
50461: GO 50389
50463: POP
50464: POP
// for i = 1 to tmp do
50465: LD_ADDR_VAR 0 4
50469: PUSH
50470: DOUBLE
50471: LD_INT 1
50473: DEC
50474: ST_TO_ADDR
50475: LD_VAR 0 3
50479: PUSH
50480: FOR_TO
50481: IFFALSE 50569
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50483: LD_ADDR_VAR 0 5
50487: PUSH
50488: LD_VAR 0 5
50492: PUSH
50493: LD_VAR 0 3
50497: PUSH
50498: LD_VAR 0 4
50502: ARRAY
50503: PPUSH
50504: CALL_OW 266
50508: PUSH
50509: LD_VAR 0 3
50513: PUSH
50514: LD_VAR 0 4
50518: ARRAY
50519: PPUSH
50520: CALL_OW 250
50524: PUSH
50525: LD_VAR 0 3
50529: PUSH
50530: LD_VAR 0 4
50534: ARRAY
50535: PPUSH
50536: CALL_OW 251
50540: PUSH
50541: LD_VAR 0 3
50545: PUSH
50546: LD_VAR 0 4
50550: ARRAY
50551: PPUSH
50552: CALL_OW 254
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: LIST
50561: LIST
50562: PUSH
50563: EMPTY
50564: LIST
50565: ADD
50566: ST_TO_ADDR
50567: GO 50480
50569: POP
50570: POP
// result := list ;
50571: LD_ADDR_VAR 0 2
50575: PUSH
50576: LD_VAR 0 5
50580: ST_TO_ADDR
// end ;
50581: LD_VAR 0 2
50585: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50586: LD_INT 0
50588: PPUSH
50589: PPUSH
50590: PPUSH
50591: PPUSH
50592: PPUSH
50593: PPUSH
50594: PPUSH
// if not factory then
50595: LD_VAR 0 1
50599: NOT
50600: IFFALSE 50604
// exit ;
50602: GO 51197
// if control = control_apeman then
50604: LD_VAR 0 4
50608: PUSH
50609: LD_INT 5
50611: EQUAL
50612: IFFALSE 50721
// begin tmp := UnitsInside ( factory ) ;
50614: LD_ADDR_VAR 0 8
50618: PUSH
50619: LD_VAR 0 1
50623: PPUSH
50624: CALL_OW 313
50628: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50629: LD_VAR 0 8
50633: PPUSH
50634: LD_INT 25
50636: PUSH
50637: LD_INT 12
50639: PUSH
50640: EMPTY
50641: LIST
50642: LIST
50643: PPUSH
50644: CALL_OW 72
50648: NOT
50649: IFFALSE 50659
// control := control_manual ;
50651: LD_ADDR_VAR 0 4
50655: PUSH
50656: LD_INT 1
50658: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50659: LD_ADDR_VAR 0 8
50663: PUSH
50664: LD_VAR 0 1
50668: PPUSH
50669: CALL 50356 0 1
50673: ST_TO_ADDR
// if tmp then
50674: LD_VAR 0 8
50678: IFFALSE 50721
// begin for i in tmp do
50680: LD_ADDR_VAR 0 7
50684: PUSH
50685: LD_VAR 0 8
50689: PUSH
50690: FOR_IN
50691: IFFALSE 50719
// if i [ 1 ] = b_ext_radio then
50693: LD_VAR 0 7
50697: PUSH
50698: LD_INT 1
50700: ARRAY
50701: PUSH
50702: LD_INT 22
50704: EQUAL
50705: IFFALSE 50717
// begin control := control_remote ;
50707: LD_ADDR_VAR 0 4
50711: PUSH
50712: LD_INT 2
50714: ST_TO_ADDR
// break ;
50715: GO 50719
// end ;
50717: GO 50690
50719: POP
50720: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50721: LD_VAR 0 1
50725: PPUSH
50726: LD_VAR 0 2
50730: PPUSH
50731: LD_VAR 0 3
50735: PPUSH
50736: LD_VAR 0 4
50740: PPUSH
50741: LD_VAR 0 5
50745: PPUSH
50746: CALL_OW 448
50750: IFFALSE 50785
// begin result := [ chassis , engine , control , weapon ] ;
50752: LD_ADDR_VAR 0 6
50756: PUSH
50757: LD_VAR 0 2
50761: PUSH
50762: LD_VAR 0 3
50766: PUSH
50767: LD_VAR 0 4
50771: PUSH
50772: LD_VAR 0 5
50776: PUSH
50777: EMPTY
50778: LIST
50779: LIST
50780: LIST
50781: LIST
50782: ST_TO_ADDR
// exit ;
50783: GO 51197
// end ; _chassis := AvailableChassisList ( factory ) ;
50785: LD_ADDR_VAR 0 9
50789: PUSH
50790: LD_VAR 0 1
50794: PPUSH
50795: CALL_OW 475
50799: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50800: LD_ADDR_VAR 0 11
50804: PUSH
50805: LD_VAR 0 1
50809: PPUSH
50810: CALL_OW 476
50814: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50815: LD_ADDR_VAR 0 12
50819: PUSH
50820: LD_VAR 0 1
50824: PPUSH
50825: CALL_OW 477
50829: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50830: LD_ADDR_VAR 0 10
50834: PUSH
50835: LD_VAR 0 1
50839: PPUSH
50840: CALL_OW 478
50844: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50845: LD_VAR 0 9
50849: NOT
50850: PUSH
50851: LD_VAR 0 11
50855: NOT
50856: OR
50857: PUSH
50858: LD_VAR 0 12
50862: NOT
50863: OR
50864: PUSH
50865: LD_VAR 0 10
50869: NOT
50870: OR
50871: IFFALSE 50906
// begin result := [ chassis , engine , control , weapon ] ;
50873: LD_ADDR_VAR 0 6
50877: PUSH
50878: LD_VAR 0 2
50882: PUSH
50883: LD_VAR 0 3
50887: PUSH
50888: LD_VAR 0 4
50892: PUSH
50893: LD_VAR 0 5
50897: PUSH
50898: EMPTY
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: ST_TO_ADDR
// exit ;
50904: GO 51197
// end ; if not chassis in _chassis then
50906: LD_VAR 0 2
50910: PUSH
50911: LD_VAR 0 9
50915: IN
50916: NOT
50917: IFFALSE 50943
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50919: LD_ADDR_VAR 0 2
50923: PUSH
50924: LD_VAR 0 9
50928: PUSH
50929: LD_INT 1
50931: PPUSH
50932: LD_VAR 0 9
50936: PPUSH
50937: CALL_OW 12
50941: ARRAY
50942: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50943: LD_VAR 0 2
50947: PPUSH
50948: LD_VAR 0 3
50952: PPUSH
50953: CALL 51202 0 2
50957: NOT
50958: IFFALSE 51017
// repeat engine := _engine [ 1 ] ;
50960: LD_ADDR_VAR 0 3
50964: PUSH
50965: LD_VAR 0 11
50969: PUSH
50970: LD_INT 1
50972: ARRAY
50973: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50974: LD_ADDR_VAR 0 11
50978: PUSH
50979: LD_VAR 0 11
50983: PPUSH
50984: LD_INT 1
50986: PPUSH
50987: CALL_OW 3
50991: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50992: LD_VAR 0 2
50996: PPUSH
50997: LD_VAR 0 3
51001: PPUSH
51002: CALL 51202 0 2
51006: PUSH
51007: LD_VAR 0 11
51011: PUSH
51012: EMPTY
51013: EQUAL
51014: OR
51015: IFFALSE 50960
// if not control in _control then
51017: LD_VAR 0 4
51021: PUSH
51022: LD_VAR 0 12
51026: IN
51027: NOT
51028: IFFALSE 51054
// control := _control [ rand ( 1 , _control ) ] ;
51030: LD_ADDR_VAR 0 4
51034: PUSH
51035: LD_VAR 0 12
51039: PUSH
51040: LD_INT 1
51042: PPUSH
51043: LD_VAR 0 12
51047: PPUSH
51048: CALL_OW 12
51052: ARRAY
51053: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51054: LD_VAR 0 2
51058: PPUSH
51059: LD_VAR 0 5
51063: PPUSH
51064: CALL 51422 0 2
51068: NOT
51069: IFFALSE 51128
// repeat weapon := _weapon [ 1 ] ;
51071: LD_ADDR_VAR 0 5
51075: PUSH
51076: LD_VAR 0 10
51080: PUSH
51081: LD_INT 1
51083: ARRAY
51084: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51085: LD_ADDR_VAR 0 10
51089: PUSH
51090: LD_VAR 0 10
51094: PPUSH
51095: LD_INT 1
51097: PPUSH
51098: CALL_OW 3
51102: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51103: LD_VAR 0 2
51107: PPUSH
51108: LD_VAR 0 5
51112: PPUSH
51113: CALL 51422 0 2
51117: PUSH
51118: LD_VAR 0 10
51122: PUSH
51123: EMPTY
51124: EQUAL
51125: OR
51126: IFFALSE 51071
// result := [ ] ;
51128: LD_ADDR_VAR 0 6
51132: PUSH
51133: EMPTY
51134: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51135: LD_VAR 0 1
51139: PPUSH
51140: LD_VAR 0 2
51144: PPUSH
51145: LD_VAR 0 3
51149: PPUSH
51150: LD_VAR 0 4
51154: PPUSH
51155: LD_VAR 0 5
51159: PPUSH
51160: CALL_OW 448
51164: IFFALSE 51197
// result := [ chassis , engine , control , weapon ] ;
51166: LD_ADDR_VAR 0 6
51170: PUSH
51171: LD_VAR 0 2
51175: PUSH
51176: LD_VAR 0 3
51180: PUSH
51181: LD_VAR 0 4
51185: PUSH
51186: LD_VAR 0 5
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: ST_TO_ADDR
// end ;
51197: LD_VAR 0 6
51201: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51202: LD_INT 0
51204: PPUSH
// if not chassis or not engine then
51205: LD_VAR 0 1
51209: NOT
51210: PUSH
51211: LD_VAR 0 2
51215: NOT
51216: OR
51217: IFFALSE 51221
// exit ;
51219: GO 51417
// case engine of engine_solar :
51221: LD_VAR 0 2
51225: PUSH
51226: LD_INT 2
51228: DOUBLE
51229: EQUAL
51230: IFTRUE 51234
51232: GO 51272
51234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51235: LD_ADDR_VAR 0 3
51239: PUSH
51240: LD_INT 11
51242: PUSH
51243: LD_INT 12
51245: PUSH
51246: LD_INT 13
51248: PUSH
51249: LD_INT 14
51251: PUSH
51252: LD_INT 1
51254: PUSH
51255: LD_INT 2
51257: PUSH
51258: LD_INT 3
51260: PUSH
51261: EMPTY
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: LIST
51269: ST_TO_ADDR
51270: GO 51401
51272: LD_INT 1
51274: DOUBLE
51275: EQUAL
51276: IFTRUE 51280
51278: GO 51342
51280: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51281: LD_ADDR_VAR 0 3
51285: PUSH
51286: LD_INT 11
51288: PUSH
51289: LD_INT 12
51291: PUSH
51292: LD_INT 13
51294: PUSH
51295: LD_INT 14
51297: PUSH
51298: LD_INT 1
51300: PUSH
51301: LD_INT 2
51303: PUSH
51304: LD_INT 3
51306: PUSH
51307: LD_INT 4
51309: PUSH
51310: LD_INT 5
51312: PUSH
51313: LD_INT 21
51315: PUSH
51316: LD_INT 23
51318: PUSH
51319: LD_INT 22
51321: PUSH
51322: LD_INT 24
51324: PUSH
51325: EMPTY
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: ST_TO_ADDR
51340: GO 51401
51342: LD_INT 3
51344: DOUBLE
51345: EQUAL
51346: IFTRUE 51350
51348: GO 51400
51350: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51351: LD_ADDR_VAR 0 3
51355: PUSH
51356: LD_INT 13
51358: PUSH
51359: LD_INT 14
51361: PUSH
51362: LD_INT 2
51364: PUSH
51365: LD_INT 3
51367: PUSH
51368: LD_INT 4
51370: PUSH
51371: LD_INT 5
51373: PUSH
51374: LD_INT 21
51376: PUSH
51377: LD_INT 22
51379: PUSH
51380: LD_INT 23
51382: PUSH
51383: LD_INT 24
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: ST_TO_ADDR
51398: GO 51401
51400: POP
// result := ( chassis in result ) ;
51401: LD_ADDR_VAR 0 3
51405: PUSH
51406: LD_VAR 0 1
51410: PUSH
51411: LD_VAR 0 3
51415: IN
51416: ST_TO_ADDR
// end ;
51417: LD_VAR 0 3
51421: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51422: LD_INT 0
51424: PPUSH
// if not chassis or not weapon then
51425: LD_VAR 0 1
51429: NOT
51430: PUSH
51431: LD_VAR 0 2
51435: NOT
51436: OR
51437: IFFALSE 51441
// exit ;
51439: GO 52467
// case weapon of us_machine_gun :
51441: LD_VAR 0 2
51445: PUSH
51446: LD_INT 2
51448: DOUBLE
51449: EQUAL
51450: IFTRUE 51454
51452: GO 51484
51454: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51455: LD_ADDR_VAR 0 3
51459: PUSH
51460: LD_INT 1
51462: PUSH
51463: LD_INT 2
51465: PUSH
51466: LD_INT 3
51468: PUSH
51469: LD_INT 4
51471: PUSH
51472: LD_INT 5
51474: PUSH
51475: EMPTY
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: ST_TO_ADDR
51482: GO 52451
51484: LD_INT 3
51486: DOUBLE
51487: EQUAL
51488: IFTRUE 51492
51490: GO 51522
51492: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51493: LD_ADDR_VAR 0 3
51497: PUSH
51498: LD_INT 1
51500: PUSH
51501: LD_INT 2
51503: PUSH
51504: LD_INT 3
51506: PUSH
51507: LD_INT 4
51509: PUSH
51510: LD_INT 5
51512: PUSH
51513: EMPTY
51514: LIST
51515: LIST
51516: LIST
51517: LIST
51518: LIST
51519: ST_TO_ADDR
51520: GO 52451
51522: LD_INT 11
51524: DOUBLE
51525: EQUAL
51526: IFTRUE 51530
51528: GO 51560
51530: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51531: LD_ADDR_VAR 0 3
51535: PUSH
51536: LD_INT 1
51538: PUSH
51539: LD_INT 2
51541: PUSH
51542: LD_INT 3
51544: PUSH
51545: LD_INT 4
51547: PUSH
51548: LD_INT 5
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: LIST
51555: LIST
51556: LIST
51557: ST_TO_ADDR
51558: GO 52451
51560: LD_INT 4
51562: DOUBLE
51563: EQUAL
51564: IFTRUE 51568
51566: GO 51594
51568: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51569: LD_ADDR_VAR 0 3
51573: PUSH
51574: LD_INT 2
51576: PUSH
51577: LD_INT 3
51579: PUSH
51580: LD_INT 4
51582: PUSH
51583: LD_INT 5
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: LIST
51590: LIST
51591: ST_TO_ADDR
51592: GO 52451
51594: LD_INT 5
51596: DOUBLE
51597: EQUAL
51598: IFTRUE 51602
51600: GO 51628
51602: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51603: LD_ADDR_VAR 0 3
51607: PUSH
51608: LD_INT 2
51610: PUSH
51611: LD_INT 3
51613: PUSH
51614: LD_INT 4
51616: PUSH
51617: LD_INT 5
51619: PUSH
51620: EMPTY
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: ST_TO_ADDR
51626: GO 52451
51628: LD_INT 9
51630: DOUBLE
51631: EQUAL
51632: IFTRUE 51636
51634: GO 51662
51636: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51637: LD_ADDR_VAR 0 3
51641: PUSH
51642: LD_INT 2
51644: PUSH
51645: LD_INT 3
51647: PUSH
51648: LD_INT 4
51650: PUSH
51651: LD_INT 5
51653: PUSH
51654: EMPTY
51655: LIST
51656: LIST
51657: LIST
51658: LIST
51659: ST_TO_ADDR
51660: GO 52451
51662: LD_INT 7
51664: DOUBLE
51665: EQUAL
51666: IFTRUE 51670
51668: GO 51696
51670: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51671: LD_ADDR_VAR 0 3
51675: PUSH
51676: LD_INT 2
51678: PUSH
51679: LD_INT 3
51681: PUSH
51682: LD_INT 4
51684: PUSH
51685: LD_INT 5
51687: PUSH
51688: EMPTY
51689: LIST
51690: LIST
51691: LIST
51692: LIST
51693: ST_TO_ADDR
51694: GO 52451
51696: LD_INT 12
51698: DOUBLE
51699: EQUAL
51700: IFTRUE 51704
51702: GO 51730
51704: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51705: LD_ADDR_VAR 0 3
51709: PUSH
51710: LD_INT 2
51712: PUSH
51713: LD_INT 3
51715: PUSH
51716: LD_INT 4
51718: PUSH
51719: LD_INT 5
51721: PUSH
51722: EMPTY
51723: LIST
51724: LIST
51725: LIST
51726: LIST
51727: ST_TO_ADDR
51728: GO 52451
51730: LD_INT 13
51732: DOUBLE
51733: EQUAL
51734: IFTRUE 51738
51736: GO 51764
51738: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51739: LD_ADDR_VAR 0 3
51743: PUSH
51744: LD_INT 2
51746: PUSH
51747: LD_INT 3
51749: PUSH
51750: LD_INT 4
51752: PUSH
51753: LD_INT 5
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: ST_TO_ADDR
51762: GO 52451
51764: LD_INT 14
51766: DOUBLE
51767: EQUAL
51768: IFTRUE 51772
51770: GO 51790
51772: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51773: LD_ADDR_VAR 0 3
51777: PUSH
51778: LD_INT 4
51780: PUSH
51781: LD_INT 5
51783: PUSH
51784: EMPTY
51785: LIST
51786: LIST
51787: ST_TO_ADDR
51788: GO 52451
51790: LD_INT 6
51792: DOUBLE
51793: EQUAL
51794: IFTRUE 51798
51796: GO 51816
51798: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51799: LD_ADDR_VAR 0 3
51803: PUSH
51804: LD_INT 4
51806: PUSH
51807: LD_INT 5
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: ST_TO_ADDR
51814: GO 52451
51816: LD_INT 10
51818: DOUBLE
51819: EQUAL
51820: IFTRUE 51824
51822: GO 51842
51824: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51825: LD_ADDR_VAR 0 3
51829: PUSH
51830: LD_INT 4
51832: PUSH
51833: LD_INT 5
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: ST_TO_ADDR
51840: GO 52451
51842: LD_INT 22
51844: DOUBLE
51845: EQUAL
51846: IFTRUE 51850
51848: GO 51876
51850: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51851: LD_ADDR_VAR 0 3
51855: PUSH
51856: LD_INT 11
51858: PUSH
51859: LD_INT 12
51861: PUSH
51862: LD_INT 13
51864: PUSH
51865: LD_INT 14
51867: PUSH
51868: EMPTY
51869: LIST
51870: LIST
51871: LIST
51872: LIST
51873: ST_TO_ADDR
51874: GO 52451
51876: LD_INT 23
51878: DOUBLE
51879: EQUAL
51880: IFTRUE 51884
51882: GO 51910
51884: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51885: LD_ADDR_VAR 0 3
51889: PUSH
51890: LD_INT 11
51892: PUSH
51893: LD_INT 12
51895: PUSH
51896: LD_INT 13
51898: PUSH
51899: LD_INT 14
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: LIST
51906: LIST
51907: ST_TO_ADDR
51908: GO 52451
51910: LD_INT 24
51912: DOUBLE
51913: EQUAL
51914: IFTRUE 51918
51916: GO 51944
51918: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51919: LD_ADDR_VAR 0 3
51923: PUSH
51924: LD_INT 11
51926: PUSH
51927: LD_INT 12
51929: PUSH
51930: LD_INT 13
51932: PUSH
51933: LD_INT 14
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: LIST
51940: LIST
51941: ST_TO_ADDR
51942: GO 52451
51944: LD_INT 30
51946: DOUBLE
51947: EQUAL
51948: IFTRUE 51952
51950: GO 51978
51952: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51953: LD_ADDR_VAR 0 3
51957: PUSH
51958: LD_INT 11
51960: PUSH
51961: LD_INT 12
51963: PUSH
51964: LD_INT 13
51966: PUSH
51967: LD_INT 14
51969: PUSH
51970: EMPTY
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: ST_TO_ADDR
51976: GO 52451
51978: LD_INT 25
51980: DOUBLE
51981: EQUAL
51982: IFTRUE 51986
51984: GO 52004
51986: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51987: LD_ADDR_VAR 0 3
51991: PUSH
51992: LD_INT 13
51994: PUSH
51995: LD_INT 14
51997: PUSH
51998: EMPTY
51999: LIST
52000: LIST
52001: ST_TO_ADDR
52002: GO 52451
52004: LD_INT 27
52006: DOUBLE
52007: EQUAL
52008: IFTRUE 52012
52010: GO 52030
52012: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52013: LD_ADDR_VAR 0 3
52017: PUSH
52018: LD_INT 13
52020: PUSH
52021: LD_INT 14
52023: PUSH
52024: EMPTY
52025: LIST
52026: LIST
52027: ST_TO_ADDR
52028: GO 52451
52030: LD_INT 28
52032: DOUBLE
52033: EQUAL
52034: IFTRUE 52038
52036: GO 52056
52038: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52039: LD_ADDR_VAR 0 3
52043: PUSH
52044: LD_INT 13
52046: PUSH
52047: LD_INT 14
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: ST_TO_ADDR
52054: GO 52451
52056: LD_INT 29
52058: DOUBLE
52059: EQUAL
52060: IFTRUE 52064
52062: GO 52082
52064: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52065: LD_ADDR_VAR 0 3
52069: PUSH
52070: LD_INT 13
52072: PUSH
52073: LD_INT 14
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: ST_TO_ADDR
52080: GO 52451
52082: LD_INT 31
52084: DOUBLE
52085: EQUAL
52086: IFTRUE 52090
52088: GO 52108
52090: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52091: LD_ADDR_VAR 0 3
52095: PUSH
52096: LD_INT 13
52098: PUSH
52099: LD_INT 14
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: ST_TO_ADDR
52106: GO 52451
52108: LD_INT 26
52110: DOUBLE
52111: EQUAL
52112: IFTRUE 52116
52114: GO 52134
52116: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52117: LD_ADDR_VAR 0 3
52121: PUSH
52122: LD_INT 13
52124: PUSH
52125: LD_INT 14
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: ST_TO_ADDR
52132: GO 52451
52134: LD_INT 42
52136: DOUBLE
52137: EQUAL
52138: IFTRUE 52142
52140: GO 52168
52142: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52143: LD_ADDR_VAR 0 3
52147: PUSH
52148: LD_INT 21
52150: PUSH
52151: LD_INT 22
52153: PUSH
52154: LD_INT 23
52156: PUSH
52157: LD_INT 24
52159: PUSH
52160: EMPTY
52161: LIST
52162: LIST
52163: LIST
52164: LIST
52165: ST_TO_ADDR
52166: GO 52451
52168: LD_INT 43
52170: DOUBLE
52171: EQUAL
52172: IFTRUE 52176
52174: GO 52202
52176: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52177: LD_ADDR_VAR 0 3
52181: PUSH
52182: LD_INT 21
52184: PUSH
52185: LD_INT 22
52187: PUSH
52188: LD_INT 23
52190: PUSH
52191: LD_INT 24
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: LIST
52198: LIST
52199: ST_TO_ADDR
52200: GO 52451
52202: LD_INT 44
52204: DOUBLE
52205: EQUAL
52206: IFTRUE 52210
52208: GO 52236
52210: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52211: LD_ADDR_VAR 0 3
52215: PUSH
52216: LD_INT 21
52218: PUSH
52219: LD_INT 22
52221: PUSH
52222: LD_INT 23
52224: PUSH
52225: LD_INT 24
52227: PUSH
52228: EMPTY
52229: LIST
52230: LIST
52231: LIST
52232: LIST
52233: ST_TO_ADDR
52234: GO 52451
52236: LD_INT 45
52238: DOUBLE
52239: EQUAL
52240: IFTRUE 52244
52242: GO 52270
52244: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52245: LD_ADDR_VAR 0 3
52249: PUSH
52250: LD_INT 21
52252: PUSH
52253: LD_INT 22
52255: PUSH
52256: LD_INT 23
52258: PUSH
52259: LD_INT 24
52261: PUSH
52262: EMPTY
52263: LIST
52264: LIST
52265: LIST
52266: LIST
52267: ST_TO_ADDR
52268: GO 52451
52270: LD_INT 49
52272: DOUBLE
52273: EQUAL
52274: IFTRUE 52278
52276: GO 52304
52278: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52279: LD_ADDR_VAR 0 3
52283: PUSH
52284: LD_INT 21
52286: PUSH
52287: LD_INT 22
52289: PUSH
52290: LD_INT 23
52292: PUSH
52293: LD_INT 24
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: LIST
52300: LIST
52301: ST_TO_ADDR
52302: GO 52451
52304: LD_INT 51
52306: DOUBLE
52307: EQUAL
52308: IFTRUE 52312
52310: GO 52338
52312: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52313: LD_ADDR_VAR 0 3
52317: PUSH
52318: LD_INT 21
52320: PUSH
52321: LD_INT 22
52323: PUSH
52324: LD_INT 23
52326: PUSH
52327: LD_INT 24
52329: PUSH
52330: EMPTY
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: ST_TO_ADDR
52336: GO 52451
52338: LD_INT 52
52340: DOUBLE
52341: EQUAL
52342: IFTRUE 52346
52344: GO 52372
52346: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52347: LD_ADDR_VAR 0 3
52351: PUSH
52352: LD_INT 21
52354: PUSH
52355: LD_INT 22
52357: PUSH
52358: LD_INT 23
52360: PUSH
52361: LD_INT 24
52363: PUSH
52364: EMPTY
52365: LIST
52366: LIST
52367: LIST
52368: LIST
52369: ST_TO_ADDR
52370: GO 52451
52372: LD_INT 53
52374: DOUBLE
52375: EQUAL
52376: IFTRUE 52380
52378: GO 52398
52380: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52381: LD_ADDR_VAR 0 3
52385: PUSH
52386: LD_INT 23
52388: PUSH
52389: LD_INT 24
52391: PUSH
52392: EMPTY
52393: LIST
52394: LIST
52395: ST_TO_ADDR
52396: GO 52451
52398: LD_INT 46
52400: DOUBLE
52401: EQUAL
52402: IFTRUE 52406
52404: GO 52424
52406: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52407: LD_ADDR_VAR 0 3
52411: PUSH
52412: LD_INT 23
52414: PUSH
52415: LD_INT 24
52417: PUSH
52418: EMPTY
52419: LIST
52420: LIST
52421: ST_TO_ADDR
52422: GO 52451
52424: LD_INT 47
52426: DOUBLE
52427: EQUAL
52428: IFTRUE 52432
52430: GO 52450
52432: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52433: LD_ADDR_VAR 0 3
52437: PUSH
52438: LD_INT 23
52440: PUSH
52441: LD_INT 24
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: ST_TO_ADDR
52448: GO 52451
52450: POP
// result := ( chassis in result ) ;
52451: LD_ADDR_VAR 0 3
52455: PUSH
52456: LD_VAR 0 1
52460: PUSH
52461: LD_VAR 0 3
52465: IN
52466: ST_TO_ADDR
// end ;
52467: LD_VAR 0 3
52471: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52472: LD_INT 0
52474: PPUSH
52475: PPUSH
52476: PPUSH
52477: PPUSH
52478: PPUSH
52479: PPUSH
52480: PPUSH
// result := array ;
52481: LD_ADDR_VAR 0 5
52485: PUSH
52486: LD_VAR 0 1
52490: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52491: LD_VAR 0 1
52495: NOT
52496: PUSH
52497: LD_VAR 0 2
52501: NOT
52502: OR
52503: PUSH
52504: LD_VAR 0 3
52508: NOT
52509: OR
52510: PUSH
52511: LD_VAR 0 2
52515: PUSH
52516: LD_VAR 0 1
52520: GREATER
52521: OR
52522: PUSH
52523: LD_VAR 0 3
52527: PUSH
52528: LD_VAR 0 1
52532: GREATER
52533: OR
52534: IFFALSE 52538
// exit ;
52536: GO 52834
// if direction then
52538: LD_VAR 0 4
52542: IFFALSE 52606
// begin d := 1 ;
52544: LD_ADDR_VAR 0 9
52548: PUSH
52549: LD_INT 1
52551: ST_TO_ADDR
// if i_from > i_to then
52552: LD_VAR 0 2
52556: PUSH
52557: LD_VAR 0 3
52561: GREATER
52562: IFFALSE 52588
// length := ( array - i_from ) + i_to else
52564: LD_ADDR_VAR 0 11
52568: PUSH
52569: LD_VAR 0 1
52573: PUSH
52574: LD_VAR 0 2
52578: MINUS
52579: PUSH
52580: LD_VAR 0 3
52584: PLUS
52585: ST_TO_ADDR
52586: GO 52604
// length := i_to - i_from ;
52588: LD_ADDR_VAR 0 11
52592: PUSH
52593: LD_VAR 0 3
52597: PUSH
52598: LD_VAR 0 2
52602: MINUS
52603: ST_TO_ADDR
// end else
52604: GO 52667
// begin d := - 1 ;
52606: LD_ADDR_VAR 0 9
52610: PUSH
52611: LD_INT 1
52613: NEG
52614: ST_TO_ADDR
// if i_from > i_to then
52615: LD_VAR 0 2
52619: PUSH
52620: LD_VAR 0 3
52624: GREATER
52625: IFFALSE 52645
// length := i_from - i_to else
52627: LD_ADDR_VAR 0 11
52631: PUSH
52632: LD_VAR 0 2
52636: PUSH
52637: LD_VAR 0 3
52641: MINUS
52642: ST_TO_ADDR
52643: GO 52667
// length := ( array - i_to ) + i_from ;
52645: LD_ADDR_VAR 0 11
52649: PUSH
52650: LD_VAR 0 1
52654: PUSH
52655: LD_VAR 0 3
52659: MINUS
52660: PUSH
52661: LD_VAR 0 2
52665: PLUS
52666: ST_TO_ADDR
// end ; if not length then
52667: LD_VAR 0 11
52671: NOT
52672: IFFALSE 52676
// exit ;
52674: GO 52834
// tmp := array ;
52676: LD_ADDR_VAR 0 10
52680: PUSH
52681: LD_VAR 0 1
52685: ST_TO_ADDR
// for i = 1 to length do
52686: LD_ADDR_VAR 0 6
52690: PUSH
52691: DOUBLE
52692: LD_INT 1
52694: DEC
52695: ST_TO_ADDR
52696: LD_VAR 0 11
52700: PUSH
52701: FOR_TO
52702: IFFALSE 52822
// begin for j = 1 to array do
52704: LD_ADDR_VAR 0 7
52708: PUSH
52709: DOUBLE
52710: LD_INT 1
52712: DEC
52713: ST_TO_ADDR
52714: LD_VAR 0 1
52718: PUSH
52719: FOR_TO
52720: IFFALSE 52808
// begin k := j + d ;
52722: LD_ADDR_VAR 0 8
52726: PUSH
52727: LD_VAR 0 7
52731: PUSH
52732: LD_VAR 0 9
52736: PLUS
52737: ST_TO_ADDR
// if k > array then
52738: LD_VAR 0 8
52742: PUSH
52743: LD_VAR 0 1
52747: GREATER
52748: IFFALSE 52758
// k := 1 ;
52750: LD_ADDR_VAR 0 8
52754: PUSH
52755: LD_INT 1
52757: ST_TO_ADDR
// if not k then
52758: LD_VAR 0 8
52762: NOT
52763: IFFALSE 52775
// k := array ;
52765: LD_ADDR_VAR 0 8
52769: PUSH
52770: LD_VAR 0 1
52774: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52775: LD_ADDR_VAR 0 10
52779: PUSH
52780: LD_VAR 0 10
52784: PPUSH
52785: LD_VAR 0 8
52789: PPUSH
52790: LD_VAR 0 1
52794: PUSH
52795: LD_VAR 0 7
52799: ARRAY
52800: PPUSH
52801: CALL_OW 1
52805: ST_TO_ADDR
// end ;
52806: GO 52719
52808: POP
52809: POP
// array := tmp ;
52810: LD_ADDR_VAR 0 1
52814: PUSH
52815: LD_VAR 0 10
52819: ST_TO_ADDR
// end ;
52820: GO 52701
52822: POP
52823: POP
// result := array ;
52824: LD_ADDR_VAR 0 5
52828: PUSH
52829: LD_VAR 0 1
52833: ST_TO_ADDR
// end ;
52834: LD_VAR 0 5
52838: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52839: LD_INT 0
52841: PPUSH
52842: PPUSH
// result := 0 ;
52843: LD_ADDR_VAR 0 3
52847: PUSH
52848: LD_INT 0
52850: ST_TO_ADDR
// if not array or not value in array then
52851: LD_VAR 0 1
52855: NOT
52856: PUSH
52857: LD_VAR 0 2
52861: PUSH
52862: LD_VAR 0 1
52866: IN
52867: NOT
52868: OR
52869: IFFALSE 52873
// exit ;
52871: GO 52927
// for i = 1 to array do
52873: LD_ADDR_VAR 0 4
52877: PUSH
52878: DOUBLE
52879: LD_INT 1
52881: DEC
52882: ST_TO_ADDR
52883: LD_VAR 0 1
52887: PUSH
52888: FOR_TO
52889: IFFALSE 52925
// if value = array [ i ] then
52891: LD_VAR 0 2
52895: PUSH
52896: LD_VAR 0 1
52900: PUSH
52901: LD_VAR 0 4
52905: ARRAY
52906: EQUAL
52907: IFFALSE 52923
// begin result := i ;
52909: LD_ADDR_VAR 0 3
52913: PUSH
52914: LD_VAR 0 4
52918: ST_TO_ADDR
// exit ;
52919: POP
52920: POP
52921: GO 52927
// end ;
52923: GO 52888
52925: POP
52926: POP
// end ;
52927: LD_VAR 0 3
52931: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52932: LD_INT 0
52934: PPUSH
// vc_chassis := chassis ;
52935: LD_ADDR_OWVAR 37
52939: PUSH
52940: LD_VAR 0 1
52944: ST_TO_ADDR
// vc_engine := engine ;
52945: LD_ADDR_OWVAR 39
52949: PUSH
52950: LD_VAR 0 2
52954: ST_TO_ADDR
// vc_control := control ;
52955: LD_ADDR_OWVAR 38
52959: PUSH
52960: LD_VAR 0 3
52964: ST_TO_ADDR
// vc_weapon := weapon ;
52965: LD_ADDR_OWVAR 40
52969: PUSH
52970: LD_VAR 0 4
52974: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52975: LD_ADDR_OWVAR 41
52979: PUSH
52980: LD_VAR 0 5
52984: ST_TO_ADDR
// end ;
52985: LD_VAR 0 6
52989: RET
// export function WantPlant ( unit ) ; var task ; begin
52990: LD_INT 0
52992: PPUSH
52993: PPUSH
// result := false ;
52994: LD_ADDR_VAR 0 2
52998: PUSH
52999: LD_INT 0
53001: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53002: LD_ADDR_VAR 0 3
53006: PUSH
53007: LD_VAR 0 1
53011: PPUSH
53012: CALL_OW 437
53016: ST_TO_ADDR
// if task then
53017: LD_VAR 0 3
53021: IFFALSE 53049
// if task [ 1 ] [ 1 ] = p then
53023: LD_VAR 0 3
53027: PUSH
53028: LD_INT 1
53030: ARRAY
53031: PUSH
53032: LD_INT 1
53034: ARRAY
53035: PUSH
53036: LD_STRING p
53038: EQUAL
53039: IFFALSE 53049
// result := true ;
53041: LD_ADDR_VAR 0 2
53045: PUSH
53046: LD_INT 1
53048: ST_TO_ADDR
// end ;
53049: LD_VAR 0 2
53053: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53054: LD_INT 0
53056: PPUSH
53057: PPUSH
53058: PPUSH
53059: PPUSH
// if pos < 1 then
53060: LD_VAR 0 2
53064: PUSH
53065: LD_INT 1
53067: LESS
53068: IFFALSE 53072
// exit ;
53070: GO 53375
// if pos = 1 then
53072: LD_VAR 0 2
53076: PUSH
53077: LD_INT 1
53079: EQUAL
53080: IFFALSE 53113
// result := Replace ( arr , pos [ 1 ] , value ) else
53082: LD_ADDR_VAR 0 4
53086: PUSH
53087: LD_VAR 0 1
53091: PPUSH
53092: LD_VAR 0 2
53096: PUSH
53097: LD_INT 1
53099: ARRAY
53100: PPUSH
53101: LD_VAR 0 3
53105: PPUSH
53106: CALL_OW 1
53110: ST_TO_ADDR
53111: GO 53375
// begin tmp := arr ;
53113: LD_ADDR_VAR 0 6
53117: PUSH
53118: LD_VAR 0 1
53122: ST_TO_ADDR
// s_arr := [ tmp ] ;
53123: LD_ADDR_VAR 0 7
53127: PUSH
53128: LD_VAR 0 6
53132: PUSH
53133: EMPTY
53134: LIST
53135: ST_TO_ADDR
// for i = 1 to pos - 1 do
53136: LD_ADDR_VAR 0 5
53140: PUSH
53141: DOUBLE
53142: LD_INT 1
53144: DEC
53145: ST_TO_ADDR
53146: LD_VAR 0 2
53150: PUSH
53151: LD_INT 1
53153: MINUS
53154: PUSH
53155: FOR_TO
53156: IFFALSE 53201
// begin tmp := tmp [ pos [ i ] ] ;
53158: LD_ADDR_VAR 0 6
53162: PUSH
53163: LD_VAR 0 6
53167: PUSH
53168: LD_VAR 0 2
53172: PUSH
53173: LD_VAR 0 5
53177: ARRAY
53178: ARRAY
53179: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53180: LD_ADDR_VAR 0 7
53184: PUSH
53185: LD_VAR 0 7
53189: PUSH
53190: LD_VAR 0 6
53194: PUSH
53195: EMPTY
53196: LIST
53197: ADD
53198: ST_TO_ADDR
// end ;
53199: GO 53155
53201: POP
53202: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53203: LD_ADDR_VAR 0 6
53207: PUSH
53208: LD_VAR 0 6
53212: PPUSH
53213: LD_VAR 0 2
53217: PUSH
53218: LD_VAR 0 2
53222: ARRAY
53223: PPUSH
53224: LD_VAR 0 3
53228: PPUSH
53229: CALL_OW 1
53233: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53234: LD_ADDR_VAR 0 7
53238: PUSH
53239: LD_VAR 0 7
53243: PPUSH
53244: LD_VAR 0 7
53248: PPUSH
53249: LD_VAR 0 6
53253: PPUSH
53254: CALL_OW 1
53258: ST_TO_ADDR
// for i = s_arr downto 2 do
53259: LD_ADDR_VAR 0 5
53263: PUSH
53264: DOUBLE
53265: LD_VAR 0 7
53269: INC
53270: ST_TO_ADDR
53271: LD_INT 2
53273: PUSH
53274: FOR_DOWNTO
53275: IFFALSE 53359
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53277: LD_ADDR_VAR 0 6
53281: PUSH
53282: LD_VAR 0 7
53286: PUSH
53287: LD_VAR 0 5
53291: PUSH
53292: LD_INT 1
53294: MINUS
53295: ARRAY
53296: PPUSH
53297: LD_VAR 0 2
53301: PUSH
53302: LD_VAR 0 5
53306: PUSH
53307: LD_INT 1
53309: MINUS
53310: ARRAY
53311: PPUSH
53312: LD_VAR 0 7
53316: PUSH
53317: LD_VAR 0 5
53321: ARRAY
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53328: LD_ADDR_VAR 0 7
53332: PUSH
53333: LD_VAR 0 7
53337: PPUSH
53338: LD_VAR 0 5
53342: PUSH
53343: LD_INT 1
53345: MINUS
53346: PPUSH
53347: LD_VAR 0 6
53351: PPUSH
53352: CALL_OW 1
53356: ST_TO_ADDR
// end ;
53357: GO 53274
53359: POP
53360: POP
// result := s_arr [ 1 ] ;
53361: LD_ADDR_VAR 0 4
53365: PUSH
53366: LD_VAR 0 7
53370: PUSH
53371: LD_INT 1
53373: ARRAY
53374: ST_TO_ADDR
// end ; end ;
53375: LD_VAR 0 4
53379: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53380: LD_INT 0
53382: PPUSH
53383: PPUSH
// if not list then
53384: LD_VAR 0 1
53388: NOT
53389: IFFALSE 53393
// exit ;
53391: GO 53484
// i := list [ pos1 ] ;
53393: LD_ADDR_VAR 0 5
53397: PUSH
53398: LD_VAR 0 1
53402: PUSH
53403: LD_VAR 0 2
53407: ARRAY
53408: ST_TO_ADDR
// if not i then
53409: LD_VAR 0 5
53413: NOT
53414: IFFALSE 53418
// exit ;
53416: GO 53484
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53418: LD_ADDR_VAR 0 1
53422: PUSH
53423: LD_VAR 0 1
53427: PPUSH
53428: LD_VAR 0 2
53432: PPUSH
53433: LD_VAR 0 1
53437: PUSH
53438: LD_VAR 0 3
53442: ARRAY
53443: PPUSH
53444: CALL_OW 1
53448: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53449: LD_ADDR_VAR 0 1
53453: PUSH
53454: LD_VAR 0 1
53458: PPUSH
53459: LD_VAR 0 3
53463: PPUSH
53464: LD_VAR 0 5
53468: PPUSH
53469: CALL_OW 1
53473: ST_TO_ADDR
// result := list ;
53474: LD_ADDR_VAR 0 4
53478: PUSH
53479: LD_VAR 0 1
53483: ST_TO_ADDR
// end ;
53484: LD_VAR 0 4
53488: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53489: LD_INT 0
53491: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53492: LD_ADDR_VAR 0 5
53496: PUSH
53497: LD_VAR 0 1
53501: PPUSH
53502: CALL_OW 250
53506: PPUSH
53507: LD_VAR 0 1
53511: PPUSH
53512: CALL_OW 251
53516: PPUSH
53517: LD_VAR 0 2
53521: PPUSH
53522: LD_VAR 0 3
53526: PPUSH
53527: LD_VAR 0 4
53531: PPUSH
53532: CALL 53542 0 5
53536: ST_TO_ADDR
// end ;
53537: LD_VAR 0 5
53541: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53542: LD_INT 0
53544: PPUSH
53545: PPUSH
53546: PPUSH
53547: PPUSH
// if not list then
53548: LD_VAR 0 3
53552: NOT
53553: IFFALSE 53557
// exit ;
53555: GO 53945
// result := [ ] ;
53557: LD_ADDR_VAR 0 6
53561: PUSH
53562: EMPTY
53563: ST_TO_ADDR
// for i in list do
53564: LD_ADDR_VAR 0 7
53568: PUSH
53569: LD_VAR 0 3
53573: PUSH
53574: FOR_IN
53575: IFFALSE 53777
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53577: LD_ADDR_VAR 0 9
53581: PUSH
53582: LD_VAR 0 7
53586: PPUSH
53587: LD_VAR 0 1
53591: PPUSH
53592: LD_VAR 0 2
53596: PPUSH
53597: CALL_OW 297
53601: ST_TO_ADDR
// if not result then
53602: LD_VAR 0 6
53606: NOT
53607: IFFALSE 53633
// result := [ [ i , tmp ] ] else
53609: LD_ADDR_VAR 0 6
53613: PUSH
53614: LD_VAR 0 7
53618: PUSH
53619: LD_VAR 0 9
53623: PUSH
53624: EMPTY
53625: LIST
53626: LIST
53627: PUSH
53628: EMPTY
53629: LIST
53630: ST_TO_ADDR
53631: GO 53775
// begin if result [ result ] [ 2 ] < tmp then
53633: LD_VAR 0 6
53637: PUSH
53638: LD_VAR 0 6
53642: ARRAY
53643: PUSH
53644: LD_INT 2
53646: ARRAY
53647: PUSH
53648: LD_VAR 0 9
53652: LESS
53653: IFFALSE 53695
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53655: LD_ADDR_VAR 0 6
53659: PUSH
53660: LD_VAR 0 6
53664: PPUSH
53665: LD_VAR 0 6
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PPUSH
53674: LD_VAR 0 7
53678: PUSH
53679: LD_VAR 0 9
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: PPUSH
53688: CALL_OW 2
53692: ST_TO_ADDR
53693: GO 53775
// for j = 1 to result do
53695: LD_ADDR_VAR 0 8
53699: PUSH
53700: DOUBLE
53701: LD_INT 1
53703: DEC
53704: ST_TO_ADDR
53705: LD_VAR 0 6
53709: PUSH
53710: FOR_TO
53711: IFFALSE 53773
// begin if tmp < result [ j ] [ 2 ] then
53713: LD_VAR 0 9
53717: PUSH
53718: LD_VAR 0 6
53722: PUSH
53723: LD_VAR 0 8
53727: ARRAY
53728: PUSH
53729: LD_INT 2
53731: ARRAY
53732: LESS
53733: IFFALSE 53771
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53735: LD_ADDR_VAR 0 6
53739: PUSH
53740: LD_VAR 0 6
53744: PPUSH
53745: LD_VAR 0 8
53749: PPUSH
53750: LD_VAR 0 7
53754: PUSH
53755: LD_VAR 0 9
53759: PUSH
53760: EMPTY
53761: LIST
53762: LIST
53763: PPUSH
53764: CALL_OW 2
53768: ST_TO_ADDR
// break ;
53769: GO 53773
// end ; end ;
53771: GO 53710
53773: POP
53774: POP
// end ; end ;
53775: GO 53574
53777: POP
53778: POP
// if result and not asc then
53779: LD_VAR 0 6
53783: PUSH
53784: LD_VAR 0 4
53788: NOT
53789: AND
53790: IFFALSE 53865
// begin tmp := result ;
53792: LD_ADDR_VAR 0 9
53796: PUSH
53797: LD_VAR 0 6
53801: ST_TO_ADDR
// for i = tmp downto 1 do
53802: LD_ADDR_VAR 0 7
53806: PUSH
53807: DOUBLE
53808: LD_VAR 0 9
53812: INC
53813: ST_TO_ADDR
53814: LD_INT 1
53816: PUSH
53817: FOR_DOWNTO
53818: IFFALSE 53863
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53820: LD_ADDR_VAR 0 6
53824: PUSH
53825: LD_VAR 0 6
53829: PPUSH
53830: LD_VAR 0 9
53834: PUSH
53835: LD_VAR 0 7
53839: MINUS
53840: PUSH
53841: LD_INT 1
53843: PLUS
53844: PPUSH
53845: LD_VAR 0 9
53849: PUSH
53850: LD_VAR 0 7
53854: ARRAY
53855: PPUSH
53856: CALL_OW 1
53860: ST_TO_ADDR
53861: GO 53817
53863: POP
53864: POP
// end ; tmp := [ ] ;
53865: LD_ADDR_VAR 0 9
53869: PUSH
53870: EMPTY
53871: ST_TO_ADDR
// if mode then
53872: LD_VAR 0 5
53876: IFFALSE 53945
// begin for i = 1 to result do
53878: LD_ADDR_VAR 0 7
53882: PUSH
53883: DOUBLE
53884: LD_INT 1
53886: DEC
53887: ST_TO_ADDR
53888: LD_VAR 0 6
53892: PUSH
53893: FOR_TO
53894: IFFALSE 53933
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53896: LD_ADDR_VAR 0 9
53900: PUSH
53901: LD_VAR 0 9
53905: PPUSH
53906: LD_VAR 0 7
53910: PPUSH
53911: LD_VAR 0 6
53915: PUSH
53916: LD_VAR 0 7
53920: ARRAY
53921: PUSH
53922: LD_INT 1
53924: ARRAY
53925: PPUSH
53926: CALL_OW 1
53930: ST_TO_ADDR
53931: GO 53893
53933: POP
53934: POP
// result := tmp ;
53935: LD_ADDR_VAR 0 6
53939: PUSH
53940: LD_VAR 0 9
53944: ST_TO_ADDR
// end ; end ;
53945: LD_VAR 0 6
53949: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53950: LD_INT 0
53952: PPUSH
53953: PPUSH
53954: PPUSH
53955: PPUSH
53956: PPUSH
53957: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53958: LD_ADDR_VAR 0 5
53962: PUSH
53963: LD_INT 0
53965: PUSH
53966: LD_INT 0
53968: PUSH
53969: LD_INT 0
53971: PUSH
53972: EMPTY
53973: PUSH
53974: EMPTY
53975: LIST
53976: LIST
53977: LIST
53978: LIST
53979: ST_TO_ADDR
// if not x or not y then
53980: LD_VAR 0 2
53984: NOT
53985: PUSH
53986: LD_VAR 0 3
53990: NOT
53991: OR
53992: IFFALSE 53996
// exit ;
53994: GO 55642
// if not range then
53996: LD_VAR 0 4
54000: NOT
54001: IFFALSE 54011
// range := 10 ;
54003: LD_ADDR_VAR 0 4
54007: PUSH
54008: LD_INT 10
54010: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54011: LD_ADDR_VAR 0 8
54015: PUSH
54016: LD_INT 81
54018: PUSH
54019: LD_VAR 0 1
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PUSH
54028: LD_INT 92
54030: PUSH
54031: LD_VAR 0 2
54035: PUSH
54036: LD_VAR 0 3
54040: PUSH
54041: LD_VAR 0 4
54045: PUSH
54046: EMPTY
54047: LIST
54048: LIST
54049: LIST
54050: LIST
54051: PUSH
54052: LD_INT 3
54054: PUSH
54055: LD_INT 21
54057: PUSH
54058: LD_INT 3
54060: PUSH
54061: EMPTY
54062: LIST
54063: LIST
54064: PUSH
54065: EMPTY
54066: LIST
54067: LIST
54068: PUSH
54069: EMPTY
54070: LIST
54071: LIST
54072: LIST
54073: PPUSH
54074: CALL_OW 69
54078: ST_TO_ADDR
// if not tmp then
54079: LD_VAR 0 8
54083: NOT
54084: IFFALSE 54088
// exit ;
54086: GO 55642
// for i in tmp do
54088: LD_ADDR_VAR 0 6
54092: PUSH
54093: LD_VAR 0 8
54097: PUSH
54098: FOR_IN
54099: IFFALSE 55617
// begin points := [ 0 , 0 , 0 ] ;
54101: LD_ADDR_VAR 0 9
54105: PUSH
54106: LD_INT 0
54108: PUSH
54109: LD_INT 0
54111: PUSH
54112: LD_INT 0
54114: PUSH
54115: EMPTY
54116: LIST
54117: LIST
54118: LIST
54119: ST_TO_ADDR
// bpoints := 1 ;
54120: LD_ADDR_VAR 0 10
54124: PUSH
54125: LD_INT 1
54127: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54128: LD_VAR 0 6
54132: PPUSH
54133: CALL_OW 247
54137: PUSH
54138: LD_INT 1
54140: DOUBLE
54141: EQUAL
54142: IFTRUE 54146
54144: GO 54724
54146: POP
// begin if GetClass ( i ) = 1 then
54147: LD_VAR 0 6
54151: PPUSH
54152: CALL_OW 257
54156: PUSH
54157: LD_INT 1
54159: EQUAL
54160: IFFALSE 54181
// points := [ 10 , 5 , 3 ] ;
54162: LD_ADDR_VAR 0 9
54166: PUSH
54167: LD_INT 10
54169: PUSH
54170: LD_INT 5
54172: PUSH
54173: LD_INT 3
54175: PUSH
54176: EMPTY
54177: LIST
54178: LIST
54179: LIST
54180: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54181: LD_VAR 0 6
54185: PPUSH
54186: CALL_OW 257
54190: PUSH
54191: LD_INT 2
54193: PUSH
54194: LD_INT 3
54196: PUSH
54197: LD_INT 4
54199: PUSH
54200: EMPTY
54201: LIST
54202: LIST
54203: LIST
54204: IN
54205: IFFALSE 54226
// points := [ 3 , 2 , 1 ] ;
54207: LD_ADDR_VAR 0 9
54211: PUSH
54212: LD_INT 3
54214: PUSH
54215: LD_INT 2
54217: PUSH
54218: LD_INT 1
54220: PUSH
54221: EMPTY
54222: LIST
54223: LIST
54224: LIST
54225: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54226: LD_VAR 0 6
54230: PPUSH
54231: CALL_OW 257
54235: PUSH
54236: LD_INT 5
54238: EQUAL
54239: IFFALSE 54260
// points := [ 130 , 5 , 2 ] ;
54241: LD_ADDR_VAR 0 9
54245: PUSH
54246: LD_INT 130
54248: PUSH
54249: LD_INT 5
54251: PUSH
54252: LD_INT 2
54254: PUSH
54255: EMPTY
54256: LIST
54257: LIST
54258: LIST
54259: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54260: LD_VAR 0 6
54264: PPUSH
54265: CALL_OW 257
54269: PUSH
54270: LD_INT 8
54272: EQUAL
54273: IFFALSE 54294
// points := [ 35 , 35 , 30 ] ;
54275: LD_ADDR_VAR 0 9
54279: PUSH
54280: LD_INT 35
54282: PUSH
54283: LD_INT 35
54285: PUSH
54286: LD_INT 30
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: LIST
54293: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54294: LD_VAR 0 6
54298: PPUSH
54299: CALL_OW 257
54303: PUSH
54304: LD_INT 9
54306: EQUAL
54307: IFFALSE 54328
// points := [ 20 , 55 , 40 ] ;
54309: LD_ADDR_VAR 0 9
54313: PUSH
54314: LD_INT 20
54316: PUSH
54317: LD_INT 55
54319: PUSH
54320: LD_INT 40
54322: PUSH
54323: EMPTY
54324: LIST
54325: LIST
54326: LIST
54327: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54328: LD_VAR 0 6
54332: PPUSH
54333: CALL_OW 257
54337: PUSH
54338: LD_INT 12
54340: PUSH
54341: LD_INT 16
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: IN
54348: IFFALSE 54369
// points := [ 5 , 3 , 2 ] ;
54350: LD_ADDR_VAR 0 9
54354: PUSH
54355: LD_INT 5
54357: PUSH
54358: LD_INT 3
54360: PUSH
54361: LD_INT 2
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: LIST
54368: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54369: LD_VAR 0 6
54373: PPUSH
54374: CALL_OW 257
54378: PUSH
54379: LD_INT 17
54381: EQUAL
54382: IFFALSE 54403
// points := [ 100 , 50 , 75 ] ;
54384: LD_ADDR_VAR 0 9
54388: PUSH
54389: LD_INT 100
54391: PUSH
54392: LD_INT 50
54394: PUSH
54395: LD_INT 75
54397: PUSH
54398: EMPTY
54399: LIST
54400: LIST
54401: LIST
54402: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54403: LD_VAR 0 6
54407: PPUSH
54408: CALL_OW 257
54412: PUSH
54413: LD_INT 15
54415: EQUAL
54416: IFFALSE 54437
// points := [ 10 , 5 , 3 ] ;
54418: LD_ADDR_VAR 0 9
54422: PUSH
54423: LD_INT 10
54425: PUSH
54426: LD_INT 5
54428: PUSH
54429: LD_INT 3
54431: PUSH
54432: EMPTY
54433: LIST
54434: LIST
54435: LIST
54436: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54437: LD_VAR 0 6
54441: PPUSH
54442: CALL_OW 257
54446: PUSH
54447: LD_INT 14
54449: EQUAL
54450: IFFALSE 54471
// points := [ 10 , 0 , 0 ] ;
54452: LD_ADDR_VAR 0 9
54456: PUSH
54457: LD_INT 10
54459: PUSH
54460: LD_INT 0
54462: PUSH
54463: LD_INT 0
54465: PUSH
54466: EMPTY
54467: LIST
54468: LIST
54469: LIST
54470: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54471: LD_VAR 0 6
54475: PPUSH
54476: CALL_OW 257
54480: PUSH
54481: LD_INT 11
54483: EQUAL
54484: IFFALSE 54505
// points := [ 30 , 10 , 5 ] ;
54486: LD_ADDR_VAR 0 9
54490: PUSH
54491: LD_INT 30
54493: PUSH
54494: LD_INT 10
54496: PUSH
54497: LD_INT 5
54499: PUSH
54500: EMPTY
54501: LIST
54502: LIST
54503: LIST
54504: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54505: LD_VAR 0 1
54509: PPUSH
54510: LD_INT 5
54512: PPUSH
54513: CALL_OW 321
54517: PUSH
54518: LD_INT 2
54520: EQUAL
54521: IFFALSE 54538
// bpoints := bpoints * 1.8 ;
54523: LD_ADDR_VAR 0 10
54527: PUSH
54528: LD_VAR 0 10
54532: PUSH
54533: LD_REAL  1.80000000000000E+0000
54536: MUL
54537: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54538: LD_VAR 0 6
54542: PPUSH
54543: CALL_OW 257
54547: PUSH
54548: LD_INT 1
54550: PUSH
54551: LD_INT 2
54553: PUSH
54554: LD_INT 3
54556: PUSH
54557: LD_INT 4
54559: PUSH
54560: EMPTY
54561: LIST
54562: LIST
54563: LIST
54564: LIST
54565: IN
54566: PUSH
54567: LD_VAR 0 1
54571: PPUSH
54572: LD_INT 51
54574: PPUSH
54575: CALL_OW 321
54579: PUSH
54580: LD_INT 2
54582: EQUAL
54583: AND
54584: IFFALSE 54601
// bpoints := bpoints * 1.2 ;
54586: LD_ADDR_VAR 0 10
54590: PUSH
54591: LD_VAR 0 10
54595: PUSH
54596: LD_REAL  1.20000000000000E+0000
54599: MUL
54600: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54601: LD_VAR 0 6
54605: PPUSH
54606: CALL_OW 257
54610: PUSH
54611: LD_INT 5
54613: PUSH
54614: LD_INT 7
54616: PUSH
54617: LD_INT 9
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: LIST
54624: IN
54625: PUSH
54626: LD_VAR 0 1
54630: PPUSH
54631: LD_INT 52
54633: PPUSH
54634: CALL_OW 321
54638: PUSH
54639: LD_INT 2
54641: EQUAL
54642: AND
54643: IFFALSE 54660
// bpoints := bpoints * 1.5 ;
54645: LD_ADDR_VAR 0 10
54649: PUSH
54650: LD_VAR 0 10
54654: PUSH
54655: LD_REAL  1.50000000000000E+0000
54658: MUL
54659: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54660: LD_VAR 0 1
54664: PPUSH
54665: LD_INT 66
54667: PPUSH
54668: CALL_OW 321
54672: PUSH
54673: LD_INT 2
54675: EQUAL
54676: IFFALSE 54693
// bpoints := bpoints * 1.1 ;
54678: LD_ADDR_VAR 0 10
54682: PUSH
54683: LD_VAR 0 10
54687: PUSH
54688: LD_REAL  1.10000000000000E+0000
54691: MUL
54692: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54693: LD_ADDR_VAR 0 10
54697: PUSH
54698: LD_VAR 0 10
54702: PUSH
54703: LD_VAR 0 6
54707: PPUSH
54708: LD_INT 1
54710: PPUSH
54711: CALL_OW 259
54715: PUSH
54716: LD_REAL  1.15000000000000E+0000
54719: MUL
54720: MUL
54721: ST_TO_ADDR
// end ; unit_vehicle :
54722: GO 55546
54724: LD_INT 2
54726: DOUBLE
54727: EQUAL
54728: IFTRUE 54732
54730: GO 55534
54732: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54733: LD_VAR 0 6
54737: PPUSH
54738: CALL_OW 264
54742: PUSH
54743: LD_INT 2
54745: PUSH
54746: LD_INT 42
54748: PUSH
54749: LD_INT 24
54751: PUSH
54752: EMPTY
54753: LIST
54754: LIST
54755: LIST
54756: IN
54757: IFFALSE 54778
// points := [ 25 , 5 , 3 ] ;
54759: LD_ADDR_VAR 0 9
54763: PUSH
54764: LD_INT 25
54766: PUSH
54767: LD_INT 5
54769: PUSH
54770: LD_INT 3
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: LIST
54777: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54778: LD_VAR 0 6
54782: PPUSH
54783: CALL_OW 264
54787: PUSH
54788: LD_INT 4
54790: PUSH
54791: LD_INT 43
54793: PUSH
54794: LD_INT 25
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: IN
54802: IFFALSE 54823
// points := [ 40 , 15 , 5 ] ;
54804: LD_ADDR_VAR 0 9
54808: PUSH
54809: LD_INT 40
54811: PUSH
54812: LD_INT 15
54814: PUSH
54815: LD_INT 5
54817: PUSH
54818: EMPTY
54819: LIST
54820: LIST
54821: LIST
54822: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54823: LD_VAR 0 6
54827: PPUSH
54828: CALL_OW 264
54832: PUSH
54833: LD_INT 3
54835: PUSH
54836: LD_INT 23
54838: PUSH
54839: EMPTY
54840: LIST
54841: LIST
54842: IN
54843: IFFALSE 54864
// points := [ 7 , 25 , 8 ] ;
54845: LD_ADDR_VAR 0 9
54849: PUSH
54850: LD_INT 7
54852: PUSH
54853: LD_INT 25
54855: PUSH
54856: LD_INT 8
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: LIST
54863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54864: LD_VAR 0 6
54868: PPUSH
54869: CALL_OW 264
54873: PUSH
54874: LD_INT 5
54876: PUSH
54877: LD_INT 27
54879: PUSH
54880: LD_INT 44
54882: PUSH
54883: EMPTY
54884: LIST
54885: LIST
54886: LIST
54887: IN
54888: IFFALSE 54909
// points := [ 14 , 50 , 16 ] ;
54890: LD_ADDR_VAR 0 9
54894: PUSH
54895: LD_INT 14
54897: PUSH
54898: LD_INT 50
54900: PUSH
54901: LD_INT 16
54903: PUSH
54904: EMPTY
54905: LIST
54906: LIST
54907: LIST
54908: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54909: LD_VAR 0 6
54913: PPUSH
54914: CALL_OW 264
54918: PUSH
54919: LD_INT 6
54921: PUSH
54922: LD_INT 46
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: IN
54929: IFFALSE 54950
// points := [ 32 , 120 , 70 ] ;
54931: LD_ADDR_VAR 0 9
54935: PUSH
54936: LD_INT 32
54938: PUSH
54939: LD_INT 120
54941: PUSH
54942: LD_INT 70
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: LIST
54949: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54950: LD_VAR 0 6
54954: PPUSH
54955: CALL_OW 264
54959: PUSH
54960: LD_INT 7
54962: PUSH
54963: LD_INT 28
54965: PUSH
54966: LD_INT 45
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: LIST
54973: IN
54974: IFFALSE 54995
// points := [ 35 , 20 , 45 ] ;
54976: LD_ADDR_VAR 0 9
54980: PUSH
54981: LD_INT 35
54983: PUSH
54984: LD_INT 20
54986: PUSH
54987: LD_INT 45
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54995: LD_VAR 0 6
54999: PPUSH
55000: CALL_OW 264
55004: PUSH
55005: LD_INT 47
55007: PUSH
55008: EMPTY
55009: LIST
55010: IN
55011: IFFALSE 55032
// points := [ 67 , 45 , 75 ] ;
55013: LD_ADDR_VAR 0 9
55017: PUSH
55018: LD_INT 67
55020: PUSH
55021: LD_INT 45
55023: PUSH
55024: LD_INT 75
55026: PUSH
55027: EMPTY
55028: LIST
55029: LIST
55030: LIST
55031: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55032: LD_VAR 0 6
55036: PPUSH
55037: CALL_OW 264
55041: PUSH
55042: LD_INT 26
55044: PUSH
55045: EMPTY
55046: LIST
55047: IN
55048: IFFALSE 55069
// points := [ 120 , 30 , 80 ] ;
55050: LD_ADDR_VAR 0 9
55054: PUSH
55055: LD_INT 120
55057: PUSH
55058: LD_INT 30
55060: PUSH
55061: LD_INT 80
55063: PUSH
55064: EMPTY
55065: LIST
55066: LIST
55067: LIST
55068: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55069: LD_VAR 0 6
55073: PPUSH
55074: CALL_OW 264
55078: PUSH
55079: LD_INT 22
55081: PUSH
55082: EMPTY
55083: LIST
55084: IN
55085: IFFALSE 55106
// points := [ 40 , 1 , 1 ] ;
55087: LD_ADDR_VAR 0 9
55091: PUSH
55092: LD_INT 40
55094: PUSH
55095: LD_INT 1
55097: PUSH
55098: LD_INT 1
55100: PUSH
55101: EMPTY
55102: LIST
55103: LIST
55104: LIST
55105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55106: LD_VAR 0 6
55110: PPUSH
55111: CALL_OW 264
55115: PUSH
55116: LD_INT 29
55118: PUSH
55119: EMPTY
55120: LIST
55121: IN
55122: IFFALSE 55143
// points := [ 70 , 200 , 400 ] ;
55124: LD_ADDR_VAR 0 9
55128: PUSH
55129: LD_INT 70
55131: PUSH
55132: LD_INT 200
55134: PUSH
55135: LD_INT 400
55137: PUSH
55138: EMPTY
55139: LIST
55140: LIST
55141: LIST
55142: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55143: LD_VAR 0 6
55147: PPUSH
55148: CALL_OW 264
55152: PUSH
55153: LD_INT 14
55155: PUSH
55156: LD_INT 53
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: IN
55163: IFFALSE 55184
// points := [ 40 , 10 , 20 ] ;
55165: LD_ADDR_VAR 0 9
55169: PUSH
55170: LD_INT 40
55172: PUSH
55173: LD_INT 10
55175: PUSH
55176: LD_INT 20
55178: PUSH
55179: EMPTY
55180: LIST
55181: LIST
55182: LIST
55183: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55184: LD_VAR 0 6
55188: PPUSH
55189: CALL_OW 264
55193: PUSH
55194: LD_INT 9
55196: PUSH
55197: EMPTY
55198: LIST
55199: IN
55200: IFFALSE 55221
// points := [ 5 , 70 , 20 ] ;
55202: LD_ADDR_VAR 0 9
55206: PUSH
55207: LD_INT 5
55209: PUSH
55210: LD_INT 70
55212: PUSH
55213: LD_INT 20
55215: PUSH
55216: EMPTY
55217: LIST
55218: LIST
55219: LIST
55220: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55221: LD_VAR 0 6
55225: PPUSH
55226: CALL_OW 264
55230: PUSH
55231: LD_INT 10
55233: PUSH
55234: EMPTY
55235: LIST
55236: IN
55237: IFFALSE 55258
// points := [ 35 , 110 , 70 ] ;
55239: LD_ADDR_VAR 0 9
55243: PUSH
55244: LD_INT 35
55246: PUSH
55247: LD_INT 110
55249: PUSH
55250: LD_INT 70
55252: PUSH
55253: EMPTY
55254: LIST
55255: LIST
55256: LIST
55257: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55258: LD_VAR 0 6
55262: PPUSH
55263: CALL_OW 265
55267: PUSH
55268: LD_INT 25
55270: EQUAL
55271: IFFALSE 55292
// points := [ 80 , 65 , 100 ] ;
55273: LD_ADDR_VAR 0 9
55277: PUSH
55278: LD_INT 80
55280: PUSH
55281: LD_INT 65
55283: PUSH
55284: LD_INT 100
55286: PUSH
55287: EMPTY
55288: LIST
55289: LIST
55290: LIST
55291: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55292: LD_VAR 0 6
55296: PPUSH
55297: CALL_OW 263
55301: PUSH
55302: LD_INT 1
55304: EQUAL
55305: IFFALSE 55340
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55307: LD_ADDR_VAR 0 10
55311: PUSH
55312: LD_VAR 0 10
55316: PUSH
55317: LD_VAR 0 6
55321: PPUSH
55322: CALL_OW 311
55326: PPUSH
55327: LD_INT 3
55329: PPUSH
55330: CALL_OW 259
55334: PUSH
55335: LD_INT 4
55337: MUL
55338: MUL
55339: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55340: LD_VAR 0 6
55344: PPUSH
55345: CALL_OW 263
55349: PUSH
55350: LD_INT 2
55352: EQUAL
55353: IFFALSE 55404
// begin j := IsControledBy ( i ) ;
55355: LD_ADDR_VAR 0 7
55359: PUSH
55360: LD_VAR 0 6
55364: PPUSH
55365: CALL_OW 312
55369: ST_TO_ADDR
// if j then
55370: LD_VAR 0 7
55374: IFFALSE 55404
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55376: LD_ADDR_VAR 0 10
55380: PUSH
55381: LD_VAR 0 10
55385: PUSH
55386: LD_VAR 0 7
55390: PPUSH
55391: LD_INT 3
55393: PPUSH
55394: CALL_OW 259
55398: PUSH
55399: LD_INT 3
55401: MUL
55402: MUL
55403: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55404: LD_VAR 0 6
55408: PPUSH
55409: CALL_OW 264
55413: PUSH
55414: LD_INT 5
55416: PUSH
55417: LD_INT 6
55419: PUSH
55420: LD_INT 46
55422: PUSH
55423: LD_INT 44
55425: PUSH
55426: LD_INT 47
55428: PUSH
55429: LD_INT 45
55431: PUSH
55432: LD_INT 28
55434: PUSH
55435: LD_INT 7
55437: PUSH
55438: LD_INT 27
55440: PUSH
55441: LD_INT 29
55443: PUSH
55444: EMPTY
55445: LIST
55446: LIST
55447: LIST
55448: LIST
55449: LIST
55450: LIST
55451: LIST
55452: LIST
55453: LIST
55454: LIST
55455: IN
55456: PUSH
55457: LD_VAR 0 1
55461: PPUSH
55462: LD_INT 52
55464: PPUSH
55465: CALL_OW 321
55469: PUSH
55470: LD_INT 2
55472: EQUAL
55473: AND
55474: IFFALSE 55491
// bpoints := bpoints * 1.2 ;
55476: LD_ADDR_VAR 0 10
55480: PUSH
55481: LD_VAR 0 10
55485: PUSH
55486: LD_REAL  1.20000000000000E+0000
55489: MUL
55490: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55491: LD_VAR 0 6
55495: PPUSH
55496: CALL_OW 264
55500: PUSH
55501: LD_INT 6
55503: PUSH
55504: LD_INT 46
55506: PUSH
55507: LD_INT 47
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: LIST
55514: IN
55515: IFFALSE 55532
// bpoints := bpoints * 1.2 ;
55517: LD_ADDR_VAR 0 10
55521: PUSH
55522: LD_VAR 0 10
55526: PUSH
55527: LD_REAL  1.20000000000000E+0000
55530: MUL
55531: ST_TO_ADDR
// end ; unit_building :
55532: GO 55546
55534: LD_INT 3
55536: DOUBLE
55537: EQUAL
55538: IFTRUE 55542
55540: GO 55545
55542: POP
// ; end ;
55543: GO 55546
55545: POP
// for j = 1 to 3 do
55546: LD_ADDR_VAR 0 7
55550: PUSH
55551: DOUBLE
55552: LD_INT 1
55554: DEC
55555: ST_TO_ADDR
55556: LD_INT 3
55558: PUSH
55559: FOR_TO
55560: IFFALSE 55613
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55562: LD_ADDR_VAR 0 5
55566: PUSH
55567: LD_VAR 0 5
55571: PPUSH
55572: LD_VAR 0 7
55576: PPUSH
55577: LD_VAR 0 5
55581: PUSH
55582: LD_VAR 0 7
55586: ARRAY
55587: PUSH
55588: LD_VAR 0 9
55592: PUSH
55593: LD_VAR 0 7
55597: ARRAY
55598: PUSH
55599: LD_VAR 0 10
55603: MUL
55604: PLUS
55605: PPUSH
55606: CALL_OW 1
55610: ST_TO_ADDR
55611: GO 55559
55613: POP
55614: POP
// end ;
55615: GO 54098
55617: POP
55618: POP
// result := Replace ( result , 4 , tmp ) ;
55619: LD_ADDR_VAR 0 5
55623: PUSH
55624: LD_VAR 0 5
55628: PPUSH
55629: LD_INT 4
55631: PPUSH
55632: LD_VAR 0 8
55636: PPUSH
55637: CALL_OW 1
55641: ST_TO_ADDR
// end ;
55642: LD_VAR 0 5
55646: RET
// export function DangerAtRange ( unit , range ) ; begin
55647: LD_INT 0
55649: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55650: LD_ADDR_VAR 0 3
55654: PUSH
55655: LD_VAR 0 1
55659: PPUSH
55660: CALL_OW 255
55664: PPUSH
55665: LD_VAR 0 1
55669: PPUSH
55670: CALL_OW 250
55674: PPUSH
55675: LD_VAR 0 1
55679: PPUSH
55680: CALL_OW 251
55684: PPUSH
55685: LD_VAR 0 2
55689: PPUSH
55690: CALL 53950 0 4
55694: ST_TO_ADDR
// end ;
55695: LD_VAR 0 3
55699: RET
// export function DangerInArea ( side , area ) ; begin
55700: LD_INT 0
55702: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55703: LD_ADDR_VAR 0 3
55707: PUSH
55708: LD_VAR 0 2
55712: PPUSH
55713: LD_INT 81
55715: PUSH
55716: LD_VAR 0 1
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PPUSH
55725: CALL_OW 70
55729: ST_TO_ADDR
// end ;
55730: LD_VAR 0 3
55734: RET
// export function IsExtension ( b ) ; begin
55735: LD_INT 0
55737: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55738: LD_ADDR_VAR 0 2
55742: PUSH
55743: LD_VAR 0 1
55747: PUSH
55748: LD_INT 23
55750: PUSH
55751: LD_INT 20
55753: PUSH
55754: LD_INT 22
55756: PUSH
55757: LD_INT 17
55759: PUSH
55760: LD_INT 24
55762: PUSH
55763: LD_INT 21
55765: PUSH
55766: LD_INT 19
55768: PUSH
55769: LD_INT 16
55771: PUSH
55772: LD_INT 25
55774: PUSH
55775: LD_INT 18
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: LIST
55782: LIST
55783: LIST
55784: LIST
55785: LIST
55786: LIST
55787: LIST
55788: LIST
55789: IN
55790: ST_TO_ADDR
// end ;
55791: LD_VAR 0 2
55795: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
55796: LD_INT 0
55798: PPUSH
55799: PPUSH
55800: PPUSH
// result := [ ] ;
55801: LD_ADDR_VAR 0 4
55805: PUSH
55806: EMPTY
55807: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55808: LD_ADDR_VAR 0 5
55812: PUSH
55813: LD_VAR 0 2
55817: PPUSH
55818: LD_INT 21
55820: PUSH
55821: LD_INT 3
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: PPUSH
55828: CALL_OW 70
55832: ST_TO_ADDR
// if not tmp then
55833: LD_VAR 0 5
55837: NOT
55838: IFFALSE 55842
// exit ;
55840: GO 55906
// if checkLink then
55842: LD_VAR 0 3
55846: IFFALSE 55896
// begin for i in tmp do
55848: LD_ADDR_VAR 0 6
55852: PUSH
55853: LD_VAR 0 5
55857: PUSH
55858: FOR_IN
55859: IFFALSE 55894
// if GetBase ( i ) <> base then
55861: LD_VAR 0 6
55865: PPUSH
55866: CALL_OW 274
55870: PUSH
55871: LD_VAR 0 1
55875: NONEQUAL
55876: IFFALSE 55892
// ComLinkToBase ( base , i ) ;
55878: LD_VAR 0 1
55882: PPUSH
55883: LD_VAR 0 6
55887: PPUSH
55888: CALL_OW 169
55892: GO 55858
55894: POP
55895: POP
// end ; result := tmp ;
55896: LD_ADDR_VAR 0 4
55900: PUSH
55901: LD_VAR 0 5
55905: ST_TO_ADDR
// end ;
55906: LD_VAR 0 4
55910: RET
// export function ComComplete ( units , b ) ; var i ; begin
55911: LD_INT 0
55913: PPUSH
55914: PPUSH
// if not units then
55915: LD_VAR 0 1
55919: NOT
55920: IFFALSE 55924
// exit ;
55922: GO 56014
// for i in units do
55924: LD_ADDR_VAR 0 4
55928: PUSH
55929: LD_VAR 0 1
55933: PUSH
55934: FOR_IN
55935: IFFALSE 56012
// if BuildingStatus ( b ) = bs_build then
55937: LD_VAR 0 2
55941: PPUSH
55942: CALL_OW 461
55946: PUSH
55947: LD_INT 1
55949: EQUAL
55950: IFFALSE 56010
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55952: LD_VAR 0 4
55956: PPUSH
55957: LD_STRING h
55959: PUSH
55960: LD_VAR 0 2
55964: PPUSH
55965: CALL_OW 250
55969: PUSH
55970: LD_VAR 0 2
55974: PPUSH
55975: CALL_OW 251
55979: PUSH
55980: LD_VAR 0 2
55984: PUSH
55985: LD_INT 0
55987: PUSH
55988: LD_INT 0
55990: PUSH
55991: LD_INT 0
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: LIST
55998: LIST
55999: LIST
56000: LIST
56001: LIST
56002: PUSH
56003: EMPTY
56004: LIST
56005: PPUSH
56006: CALL_OW 446
56010: GO 55934
56012: POP
56013: POP
// end ;
56014: LD_VAR 0 3
56018: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56019: LD_INT 0
56021: PPUSH
56022: PPUSH
56023: PPUSH
56024: PPUSH
56025: PPUSH
56026: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
56027: LD_VAR 0 1
56031: NOT
56032: PUSH
56033: LD_VAR 0 1
56037: PPUSH
56038: CALL_OW 263
56042: PUSH
56043: LD_INT 2
56045: EQUAL
56046: NOT
56047: OR
56048: IFFALSE 56052
// exit ;
56050: GO 56368
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56052: LD_ADDR_VAR 0 6
56056: PUSH
56057: LD_INT 22
56059: PUSH
56060: LD_VAR 0 1
56064: PPUSH
56065: CALL_OW 255
56069: PUSH
56070: EMPTY
56071: LIST
56072: LIST
56073: PUSH
56074: LD_INT 2
56076: PUSH
56077: LD_INT 30
56079: PUSH
56080: LD_INT 36
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: PUSH
56087: LD_INT 34
56089: PUSH
56090: LD_INT 31
56092: PUSH
56093: EMPTY
56094: LIST
56095: LIST
56096: PUSH
56097: EMPTY
56098: LIST
56099: LIST
56100: LIST
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PPUSH
56106: CALL_OW 69
56110: ST_TO_ADDR
// if not tmp then
56111: LD_VAR 0 6
56115: NOT
56116: IFFALSE 56120
// exit ;
56118: GO 56368
// result := [ ] ;
56120: LD_ADDR_VAR 0 2
56124: PUSH
56125: EMPTY
56126: ST_TO_ADDR
// for i in tmp do
56127: LD_ADDR_VAR 0 3
56131: PUSH
56132: LD_VAR 0 6
56136: PUSH
56137: FOR_IN
56138: IFFALSE 56209
// begin t := UnitsInside ( i ) ;
56140: LD_ADDR_VAR 0 4
56144: PUSH
56145: LD_VAR 0 3
56149: PPUSH
56150: CALL_OW 313
56154: ST_TO_ADDR
// if t then
56155: LD_VAR 0 4
56159: IFFALSE 56207
// for j in t do
56161: LD_ADDR_VAR 0 7
56165: PUSH
56166: LD_VAR 0 4
56170: PUSH
56171: FOR_IN
56172: IFFALSE 56205
// result := Insert ( result , result + 1 , j ) ;
56174: LD_ADDR_VAR 0 2
56178: PUSH
56179: LD_VAR 0 2
56183: PPUSH
56184: LD_VAR 0 2
56188: PUSH
56189: LD_INT 1
56191: PLUS
56192: PPUSH
56193: LD_VAR 0 7
56197: PPUSH
56198: CALL_OW 2
56202: ST_TO_ADDR
56203: GO 56171
56205: POP
56206: POP
// end ;
56207: GO 56137
56209: POP
56210: POP
// if not result then
56211: LD_VAR 0 2
56215: NOT
56216: IFFALSE 56220
// exit ;
56218: GO 56368
// mech := result [ 1 ] ;
56220: LD_ADDR_VAR 0 5
56224: PUSH
56225: LD_VAR 0 2
56229: PUSH
56230: LD_INT 1
56232: ARRAY
56233: ST_TO_ADDR
// if result > 1 then
56234: LD_VAR 0 2
56238: PUSH
56239: LD_INT 1
56241: GREATER
56242: IFFALSE 56354
// for i = 2 to result do
56244: LD_ADDR_VAR 0 3
56248: PUSH
56249: DOUBLE
56250: LD_INT 2
56252: DEC
56253: ST_TO_ADDR
56254: LD_VAR 0 2
56258: PUSH
56259: FOR_TO
56260: IFFALSE 56352
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56262: LD_ADDR_VAR 0 4
56266: PUSH
56267: LD_VAR 0 2
56271: PUSH
56272: LD_VAR 0 3
56276: ARRAY
56277: PPUSH
56278: LD_INT 3
56280: PPUSH
56281: CALL_OW 259
56285: PUSH
56286: LD_VAR 0 2
56290: PUSH
56291: LD_VAR 0 3
56295: ARRAY
56296: PPUSH
56297: CALL_OW 432
56301: MINUS
56302: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56303: LD_VAR 0 4
56307: PUSH
56308: LD_VAR 0 5
56312: PPUSH
56313: LD_INT 3
56315: PPUSH
56316: CALL_OW 259
56320: PUSH
56321: LD_VAR 0 5
56325: PPUSH
56326: CALL_OW 432
56330: MINUS
56331: GREATEREQUAL
56332: IFFALSE 56350
// mech := result [ i ] ;
56334: LD_ADDR_VAR 0 5
56338: PUSH
56339: LD_VAR 0 2
56343: PUSH
56344: LD_VAR 0 3
56348: ARRAY
56349: ST_TO_ADDR
// end ;
56350: GO 56259
56352: POP
56353: POP
// ComLinkTo ( vehicle , mech ) ;
56354: LD_VAR 0 1
56358: PPUSH
56359: LD_VAR 0 5
56363: PPUSH
56364: CALL_OW 135
// end ;
56368: LD_VAR 0 2
56372: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56373: LD_INT 0
56375: PPUSH
56376: PPUSH
56377: PPUSH
56378: PPUSH
56379: PPUSH
56380: PPUSH
56381: PPUSH
56382: PPUSH
56383: PPUSH
56384: PPUSH
56385: PPUSH
56386: PPUSH
56387: PPUSH
// result := [ ] ;
56388: LD_ADDR_VAR 0 7
56392: PUSH
56393: EMPTY
56394: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56395: LD_VAR 0 1
56399: PPUSH
56400: CALL_OW 266
56404: PUSH
56405: LD_INT 0
56407: PUSH
56408: LD_INT 1
56410: PUSH
56411: EMPTY
56412: LIST
56413: LIST
56414: IN
56415: NOT
56416: IFFALSE 56420
// exit ;
56418: GO 58054
// if name then
56420: LD_VAR 0 3
56424: IFFALSE 56440
// SetBName ( base_dep , name ) ;
56426: LD_VAR 0 1
56430: PPUSH
56431: LD_VAR 0 3
56435: PPUSH
56436: CALL_OW 500
// base := GetBase ( base_dep ) ;
56440: LD_ADDR_VAR 0 15
56444: PUSH
56445: LD_VAR 0 1
56449: PPUSH
56450: CALL_OW 274
56454: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56455: LD_ADDR_VAR 0 16
56459: PUSH
56460: LD_VAR 0 1
56464: PPUSH
56465: CALL_OW 255
56469: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56470: LD_ADDR_VAR 0 17
56474: PUSH
56475: LD_VAR 0 1
56479: PPUSH
56480: CALL_OW 248
56484: ST_TO_ADDR
// if sources then
56485: LD_VAR 0 5
56489: IFFALSE 56536
// for i = 1 to 3 do
56491: LD_ADDR_VAR 0 8
56495: PUSH
56496: DOUBLE
56497: LD_INT 1
56499: DEC
56500: ST_TO_ADDR
56501: LD_INT 3
56503: PUSH
56504: FOR_TO
56505: IFFALSE 56534
// AddResourceType ( base , i , sources [ i ] ) ;
56507: LD_VAR 0 15
56511: PPUSH
56512: LD_VAR 0 8
56516: PPUSH
56517: LD_VAR 0 5
56521: PUSH
56522: LD_VAR 0 8
56526: ARRAY
56527: PPUSH
56528: CALL_OW 276
56532: GO 56504
56534: POP
56535: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
56536: LD_ADDR_VAR 0 18
56540: PUSH
56541: LD_VAR 0 15
56545: PPUSH
56546: LD_VAR 0 2
56550: PPUSH
56551: LD_INT 1
56553: PPUSH
56554: CALL 55796 0 3
56558: ST_TO_ADDR
// InitHc ;
56559: CALL_OW 19
// InitUc ;
56563: CALL_OW 18
// uc_side := side ;
56567: LD_ADDR_OWVAR 20
56571: PUSH
56572: LD_VAR 0 16
56576: ST_TO_ADDR
// uc_nation := nation ;
56577: LD_ADDR_OWVAR 21
56581: PUSH
56582: LD_VAR 0 17
56586: ST_TO_ADDR
// if buildings then
56587: LD_VAR 0 18
56591: IFFALSE 57913
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56593: LD_ADDR_VAR 0 19
56597: PUSH
56598: LD_VAR 0 18
56602: PPUSH
56603: LD_INT 2
56605: PUSH
56606: LD_INT 30
56608: PUSH
56609: LD_INT 29
56611: PUSH
56612: EMPTY
56613: LIST
56614: LIST
56615: PUSH
56616: LD_INT 30
56618: PUSH
56619: LD_INT 30
56621: PUSH
56622: EMPTY
56623: LIST
56624: LIST
56625: PUSH
56626: EMPTY
56627: LIST
56628: LIST
56629: LIST
56630: PPUSH
56631: CALL_OW 72
56635: ST_TO_ADDR
// if tmp then
56636: LD_VAR 0 19
56640: IFFALSE 56688
// for i in tmp do
56642: LD_ADDR_VAR 0 8
56646: PUSH
56647: LD_VAR 0 19
56651: PUSH
56652: FOR_IN
56653: IFFALSE 56686
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56655: LD_VAR 0 8
56659: PPUSH
56660: CALL_OW 250
56664: PPUSH
56665: LD_VAR 0 8
56669: PPUSH
56670: CALL_OW 251
56674: PPUSH
56675: LD_VAR 0 16
56679: PPUSH
56680: CALL_OW 441
56684: GO 56652
56686: POP
56687: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56688: LD_VAR 0 18
56692: PPUSH
56693: LD_INT 2
56695: PUSH
56696: LD_INT 30
56698: PUSH
56699: LD_INT 32
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: PUSH
56706: LD_INT 30
56708: PUSH
56709: LD_INT 33
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: LIST
56720: PPUSH
56721: CALL_OW 72
56725: IFFALSE 56813
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56727: LD_ADDR_VAR 0 8
56731: PUSH
56732: LD_VAR 0 18
56736: PPUSH
56737: LD_INT 2
56739: PUSH
56740: LD_INT 30
56742: PUSH
56743: LD_INT 32
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: PUSH
56750: LD_INT 30
56752: PUSH
56753: LD_INT 33
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: LIST
56764: PPUSH
56765: CALL_OW 72
56769: PUSH
56770: FOR_IN
56771: IFFALSE 56811
// begin if not GetBWeapon ( i ) then
56773: LD_VAR 0 8
56777: PPUSH
56778: CALL_OW 269
56782: NOT
56783: IFFALSE 56809
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56785: LD_VAR 0 8
56789: PPUSH
56790: LD_VAR 0 8
56794: PPUSH
56795: LD_VAR 0 2
56799: PPUSH
56800: CALL 58059 0 2
56804: PPUSH
56805: CALL_OW 431
// end ;
56809: GO 56770
56811: POP
56812: POP
// end ; for i = 1 to personel do
56813: LD_ADDR_VAR 0 8
56817: PUSH
56818: DOUBLE
56819: LD_INT 1
56821: DEC
56822: ST_TO_ADDR
56823: LD_VAR 0 6
56827: PUSH
56828: FOR_TO
56829: IFFALSE 57893
// begin if i > 4 then
56831: LD_VAR 0 8
56835: PUSH
56836: LD_INT 4
56838: GREATER
56839: IFFALSE 56843
// break ;
56841: GO 57893
// case i of 1 :
56843: LD_VAR 0 8
56847: PUSH
56848: LD_INT 1
56850: DOUBLE
56851: EQUAL
56852: IFTRUE 56856
56854: GO 56936
56856: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56857: LD_ADDR_VAR 0 12
56861: PUSH
56862: LD_VAR 0 18
56866: PPUSH
56867: LD_INT 22
56869: PUSH
56870: LD_VAR 0 16
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: PUSH
56879: LD_INT 58
56881: PUSH
56882: EMPTY
56883: LIST
56884: PUSH
56885: LD_INT 2
56887: PUSH
56888: LD_INT 30
56890: PUSH
56891: LD_INT 32
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: PUSH
56898: LD_INT 30
56900: PUSH
56901: LD_INT 4
56903: PUSH
56904: EMPTY
56905: LIST
56906: LIST
56907: PUSH
56908: LD_INT 30
56910: PUSH
56911: LD_INT 5
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: PUSH
56918: EMPTY
56919: LIST
56920: LIST
56921: LIST
56922: LIST
56923: PUSH
56924: EMPTY
56925: LIST
56926: LIST
56927: LIST
56928: PPUSH
56929: CALL_OW 72
56933: ST_TO_ADDR
56934: GO 57158
56936: LD_INT 2
56938: DOUBLE
56939: EQUAL
56940: IFTRUE 56944
56942: GO 57006
56944: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56945: LD_ADDR_VAR 0 12
56949: PUSH
56950: LD_VAR 0 18
56954: PPUSH
56955: LD_INT 22
56957: PUSH
56958: LD_VAR 0 16
56962: PUSH
56963: EMPTY
56964: LIST
56965: LIST
56966: PUSH
56967: LD_INT 2
56969: PUSH
56970: LD_INT 30
56972: PUSH
56973: LD_INT 0
56975: PUSH
56976: EMPTY
56977: LIST
56978: LIST
56979: PUSH
56980: LD_INT 30
56982: PUSH
56983: LD_INT 1
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: EMPTY
56991: LIST
56992: LIST
56993: LIST
56994: PUSH
56995: EMPTY
56996: LIST
56997: LIST
56998: PPUSH
56999: CALL_OW 72
57003: ST_TO_ADDR
57004: GO 57158
57006: LD_INT 3
57008: DOUBLE
57009: EQUAL
57010: IFTRUE 57014
57012: GO 57076
57014: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57015: LD_ADDR_VAR 0 12
57019: PUSH
57020: LD_VAR 0 18
57024: PPUSH
57025: LD_INT 22
57027: PUSH
57028: LD_VAR 0 16
57032: PUSH
57033: EMPTY
57034: LIST
57035: LIST
57036: PUSH
57037: LD_INT 2
57039: PUSH
57040: LD_INT 30
57042: PUSH
57043: LD_INT 2
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: LD_INT 30
57052: PUSH
57053: LD_INT 3
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: LIST
57064: PUSH
57065: EMPTY
57066: LIST
57067: LIST
57068: PPUSH
57069: CALL_OW 72
57073: ST_TO_ADDR
57074: GO 57158
57076: LD_INT 4
57078: DOUBLE
57079: EQUAL
57080: IFTRUE 57084
57082: GO 57157
57084: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57085: LD_ADDR_VAR 0 12
57089: PUSH
57090: LD_VAR 0 18
57094: PPUSH
57095: LD_INT 22
57097: PUSH
57098: LD_VAR 0 16
57102: PUSH
57103: EMPTY
57104: LIST
57105: LIST
57106: PUSH
57107: LD_INT 2
57109: PUSH
57110: LD_INT 30
57112: PUSH
57113: LD_INT 6
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: PUSH
57120: LD_INT 30
57122: PUSH
57123: LD_INT 7
57125: PUSH
57126: EMPTY
57127: LIST
57128: LIST
57129: PUSH
57130: LD_INT 30
57132: PUSH
57133: LD_INT 8
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: LIST
57144: LIST
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PPUSH
57150: CALL_OW 72
57154: ST_TO_ADDR
57155: GO 57158
57157: POP
// if i = 1 then
57158: LD_VAR 0 8
57162: PUSH
57163: LD_INT 1
57165: EQUAL
57166: IFFALSE 57277
// begin tmp := [ ] ;
57168: LD_ADDR_VAR 0 19
57172: PUSH
57173: EMPTY
57174: ST_TO_ADDR
// for j in f do
57175: LD_ADDR_VAR 0 9
57179: PUSH
57180: LD_VAR 0 12
57184: PUSH
57185: FOR_IN
57186: IFFALSE 57259
// if GetBType ( j ) = b_bunker then
57188: LD_VAR 0 9
57192: PPUSH
57193: CALL_OW 266
57197: PUSH
57198: LD_INT 32
57200: EQUAL
57201: IFFALSE 57228
// tmp := Insert ( tmp , 1 , j ) else
57203: LD_ADDR_VAR 0 19
57207: PUSH
57208: LD_VAR 0 19
57212: PPUSH
57213: LD_INT 1
57215: PPUSH
57216: LD_VAR 0 9
57220: PPUSH
57221: CALL_OW 2
57225: ST_TO_ADDR
57226: GO 57257
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57228: LD_ADDR_VAR 0 19
57232: PUSH
57233: LD_VAR 0 19
57237: PPUSH
57238: LD_VAR 0 19
57242: PUSH
57243: LD_INT 1
57245: PLUS
57246: PPUSH
57247: LD_VAR 0 9
57251: PPUSH
57252: CALL_OW 2
57256: ST_TO_ADDR
57257: GO 57185
57259: POP
57260: POP
// if tmp then
57261: LD_VAR 0 19
57265: IFFALSE 57277
// f := tmp ;
57267: LD_ADDR_VAR 0 12
57271: PUSH
57272: LD_VAR 0 19
57276: ST_TO_ADDR
// end ; x := personel [ i ] ;
57277: LD_ADDR_VAR 0 13
57281: PUSH
57282: LD_VAR 0 6
57286: PUSH
57287: LD_VAR 0 8
57291: ARRAY
57292: ST_TO_ADDR
// if x = - 1 then
57293: LD_VAR 0 13
57297: PUSH
57298: LD_INT 1
57300: NEG
57301: EQUAL
57302: IFFALSE 57511
// begin for j in f do
57304: LD_ADDR_VAR 0 9
57308: PUSH
57309: LD_VAR 0 12
57313: PUSH
57314: FOR_IN
57315: IFFALSE 57507
// repeat InitHc ;
57317: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57321: LD_VAR 0 9
57325: PPUSH
57326: CALL_OW 266
57330: PUSH
57331: LD_INT 5
57333: EQUAL
57334: IFFALSE 57404
// begin if UnitsInside ( j ) < 3 then
57336: LD_VAR 0 9
57340: PPUSH
57341: CALL_OW 313
57345: PUSH
57346: LD_INT 3
57348: LESS
57349: IFFALSE 57385
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57351: LD_INT 0
57353: PPUSH
57354: LD_INT 5
57356: PUSH
57357: LD_INT 8
57359: PUSH
57360: LD_INT 9
57362: PUSH
57363: EMPTY
57364: LIST
57365: LIST
57366: LIST
57367: PUSH
57368: LD_VAR 0 17
57372: ARRAY
57373: PPUSH
57374: LD_VAR 0 4
57378: PPUSH
57379: CALL_OW 380
57383: GO 57402
// PrepareHuman ( false , i , skill ) ;
57385: LD_INT 0
57387: PPUSH
57388: LD_VAR 0 8
57392: PPUSH
57393: LD_VAR 0 4
57397: PPUSH
57398: CALL_OW 380
// end else
57402: GO 57421
// PrepareHuman ( false , i , skill ) ;
57404: LD_INT 0
57406: PPUSH
57407: LD_VAR 0 8
57411: PPUSH
57412: LD_VAR 0 4
57416: PPUSH
57417: CALL_OW 380
// un := CreateHuman ;
57421: LD_ADDR_VAR 0 14
57425: PUSH
57426: CALL_OW 44
57430: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57431: LD_ADDR_VAR 0 7
57435: PUSH
57436: LD_VAR 0 7
57440: PPUSH
57441: LD_INT 1
57443: PPUSH
57444: LD_VAR 0 14
57448: PPUSH
57449: CALL_OW 2
57453: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57454: LD_VAR 0 14
57458: PPUSH
57459: LD_VAR 0 9
57463: PPUSH
57464: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57468: LD_VAR 0 9
57472: PPUSH
57473: CALL_OW 313
57477: PUSH
57478: LD_INT 6
57480: EQUAL
57481: PUSH
57482: LD_VAR 0 9
57486: PPUSH
57487: CALL_OW 266
57491: PUSH
57492: LD_INT 32
57494: PUSH
57495: LD_INT 31
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: IN
57502: OR
57503: IFFALSE 57317
57505: GO 57314
57507: POP
57508: POP
// end else
57509: GO 57891
// for j = 1 to x do
57511: LD_ADDR_VAR 0 9
57515: PUSH
57516: DOUBLE
57517: LD_INT 1
57519: DEC
57520: ST_TO_ADDR
57521: LD_VAR 0 13
57525: PUSH
57526: FOR_TO
57527: IFFALSE 57889
// begin InitHc ;
57529: CALL_OW 19
// if not f then
57533: LD_VAR 0 12
57537: NOT
57538: IFFALSE 57627
// begin PrepareHuman ( false , i , skill ) ;
57540: LD_INT 0
57542: PPUSH
57543: LD_VAR 0 8
57547: PPUSH
57548: LD_VAR 0 4
57552: PPUSH
57553: CALL_OW 380
// un := CreateHuman ;
57557: LD_ADDR_VAR 0 14
57561: PUSH
57562: CALL_OW 44
57566: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57567: LD_ADDR_VAR 0 7
57571: PUSH
57572: LD_VAR 0 7
57576: PPUSH
57577: LD_INT 1
57579: PPUSH
57580: LD_VAR 0 14
57584: PPUSH
57585: CALL_OW 2
57589: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57590: LD_VAR 0 14
57594: PPUSH
57595: LD_VAR 0 1
57599: PPUSH
57600: CALL_OW 250
57604: PPUSH
57605: LD_VAR 0 1
57609: PPUSH
57610: CALL_OW 251
57614: PPUSH
57615: LD_INT 10
57617: PPUSH
57618: LD_INT 0
57620: PPUSH
57621: CALL_OW 50
// continue ;
57625: GO 57526
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57627: LD_VAR 0 12
57631: PUSH
57632: LD_INT 1
57634: ARRAY
57635: PPUSH
57636: CALL_OW 313
57640: PUSH
57641: LD_VAR 0 12
57645: PUSH
57646: LD_INT 1
57648: ARRAY
57649: PPUSH
57650: CALL_OW 266
57654: PUSH
57655: LD_INT 32
57657: PUSH
57658: LD_INT 31
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: IN
57665: AND
57666: PUSH
57667: LD_VAR 0 12
57671: PUSH
57672: LD_INT 1
57674: ARRAY
57675: PPUSH
57676: CALL_OW 313
57680: PUSH
57681: LD_INT 6
57683: EQUAL
57684: OR
57685: IFFALSE 57705
// f := Delete ( f , 1 ) ;
57687: LD_ADDR_VAR 0 12
57691: PUSH
57692: LD_VAR 0 12
57696: PPUSH
57697: LD_INT 1
57699: PPUSH
57700: CALL_OW 3
57704: ST_TO_ADDR
// if not f then
57705: LD_VAR 0 12
57709: NOT
57710: IFFALSE 57728
// begin x := x + 2 ;
57712: LD_ADDR_VAR 0 13
57716: PUSH
57717: LD_VAR 0 13
57721: PUSH
57722: LD_INT 2
57724: PLUS
57725: ST_TO_ADDR
// continue ;
57726: GO 57526
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57728: LD_VAR 0 12
57732: PUSH
57733: LD_INT 1
57735: ARRAY
57736: PPUSH
57737: CALL_OW 266
57741: PUSH
57742: LD_INT 5
57744: EQUAL
57745: IFFALSE 57819
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57747: LD_VAR 0 12
57751: PUSH
57752: LD_INT 1
57754: ARRAY
57755: PPUSH
57756: CALL_OW 313
57760: PUSH
57761: LD_INT 3
57763: LESS
57764: IFFALSE 57800
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57766: LD_INT 0
57768: PPUSH
57769: LD_INT 5
57771: PUSH
57772: LD_INT 8
57774: PUSH
57775: LD_INT 9
57777: PUSH
57778: EMPTY
57779: LIST
57780: LIST
57781: LIST
57782: PUSH
57783: LD_VAR 0 17
57787: ARRAY
57788: PPUSH
57789: LD_VAR 0 4
57793: PPUSH
57794: CALL_OW 380
57798: GO 57817
// PrepareHuman ( false , i , skill ) ;
57800: LD_INT 0
57802: PPUSH
57803: LD_VAR 0 8
57807: PPUSH
57808: LD_VAR 0 4
57812: PPUSH
57813: CALL_OW 380
// end else
57817: GO 57836
// PrepareHuman ( false , i , skill ) ;
57819: LD_INT 0
57821: PPUSH
57822: LD_VAR 0 8
57826: PPUSH
57827: LD_VAR 0 4
57831: PPUSH
57832: CALL_OW 380
// un := CreateHuman ;
57836: LD_ADDR_VAR 0 14
57840: PUSH
57841: CALL_OW 44
57845: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57846: LD_ADDR_VAR 0 7
57850: PUSH
57851: LD_VAR 0 7
57855: PPUSH
57856: LD_INT 1
57858: PPUSH
57859: LD_VAR 0 14
57863: PPUSH
57864: CALL_OW 2
57868: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57869: LD_VAR 0 14
57873: PPUSH
57874: LD_VAR 0 12
57878: PUSH
57879: LD_INT 1
57881: ARRAY
57882: PPUSH
57883: CALL_OW 52
// end ;
57887: GO 57526
57889: POP
57890: POP
// end ;
57891: GO 56828
57893: POP
57894: POP
// result := result ^ buildings ;
57895: LD_ADDR_VAR 0 7
57899: PUSH
57900: LD_VAR 0 7
57904: PUSH
57905: LD_VAR 0 18
57909: ADD
57910: ST_TO_ADDR
// end else
57911: GO 58054
// begin for i = 1 to personel do
57913: LD_ADDR_VAR 0 8
57917: PUSH
57918: DOUBLE
57919: LD_INT 1
57921: DEC
57922: ST_TO_ADDR
57923: LD_VAR 0 6
57927: PUSH
57928: FOR_TO
57929: IFFALSE 58052
// begin if i > 4 then
57931: LD_VAR 0 8
57935: PUSH
57936: LD_INT 4
57938: GREATER
57939: IFFALSE 57943
// break ;
57941: GO 58052
// x := personel [ i ] ;
57943: LD_ADDR_VAR 0 13
57947: PUSH
57948: LD_VAR 0 6
57952: PUSH
57953: LD_VAR 0 8
57957: ARRAY
57958: ST_TO_ADDR
// if x = - 1 then
57959: LD_VAR 0 13
57963: PUSH
57964: LD_INT 1
57966: NEG
57967: EQUAL
57968: IFFALSE 57972
// continue ;
57970: GO 57928
// PrepareHuman ( false , i , skill ) ;
57972: LD_INT 0
57974: PPUSH
57975: LD_VAR 0 8
57979: PPUSH
57980: LD_VAR 0 4
57984: PPUSH
57985: CALL_OW 380
// un := CreateHuman ;
57989: LD_ADDR_VAR 0 14
57993: PUSH
57994: CALL_OW 44
57998: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57999: LD_VAR 0 14
58003: PPUSH
58004: LD_VAR 0 1
58008: PPUSH
58009: CALL_OW 250
58013: PPUSH
58014: LD_VAR 0 1
58018: PPUSH
58019: CALL_OW 251
58023: PPUSH
58024: LD_INT 10
58026: PPUSH
58027: LD_INT 0
58029: PPUSH
58030: CALL_OW 50
// result := result ^ un ;
58034: LD_ADDR_VAR 0 7
58038: PUSH
58039: LD_VAR 0 7
58043: PUSH
58044: LD_VAR 0 14
58048: ADD
58049: ST_TO_ADDR
// end ;
58050: GO 57928
58052: POP
58053: POP
// end ; end ;
58054: LD_VAR 0 7
58058: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58059: LD_INT 0
58061: PPUSH
58062: PPUSH
58063: PPUSH
58064: PPUSH
58065: PPUSH
58066: PPUSH
58067: PPUSH
58068: PPUSH
58069: PPUSH
58070: PPUSH
58071: PPUSH
58072: PPUSH
58073: PPUSH
58074: PPUSH
58075: PPUSH
58076: PPUSH
// result := false ;
58077: LD_ADDR_VAR 0 3
58081: PUSH
58082: LD_INT 0
58084: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58085: LD_VAR 0 1
58089: NOT
58090: PUSH
58091: LD_VAR 0 1
58095: PPUSH
58096: CALL_OW 266
58100: PUSH
58101: LD_INT 32
58103: PUSH
58104: LD_INT 33
58106: PUSH
58107: EMPTY
58108: LIST
58109: LIST
58110: IN
58111: NOT
58112: OR
58113: IFFALSE 58117
// exit ;
58115: GO 59256
// nat := GetNation ( tower ) ;
58117: LD_ADDR_VAR 0 12
58121: PUSH
58122: LD_VAR 0 1
58126: PPUSH
58127: CALL_OW 248
58131: ST_TO_ADDR
// side := GetSide ( tower ) ;
58132: LD_ADDR_VAR 0 16
58136: PUSH
58137: LD_VAR 0 1
58141: PPUSH
58142: CALL_OW 255
58146: ST_TO_ADDR
// x := GetX ( tower ) ;
58147: LD_ADDR_VAR 0 10
58151: PUSH
58152: LD_VAR 0 1
58156: PPUSH
58157: CALL_OW 250
58161: ST_TO_ADDR
// y := GetY ( tower ) ;
58162: LD_ADDR_VAR 0 11
58166: PUSH
58167: LD_VAR 0 1
58171: PPUSH
58172: CALL_OW 251
58176: ST_TO_ADDR
// if not x or not y then
58177: LD_VAR 0 10
58181: NOT
58182: PUSH
58183: LD_VAR 0 11
58187: NOT
58188: OR
58189: IFFALSE 58193
// exit ;
58191: GO 59256
// weapon := 0 ;
58193: LD_ADDR_VAR 0 18
58197: PUSH
58198: LD_INT 0
58200: ST_TO_ADDR
// fac_list := [ ] ;
58201: LD_ADDR_VAR 0 17
58205: PUSH
58206: EMPTY
58207: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58208: LD_ADDR_VAR 0 6
58212: PUSH
58213: LD_VAR 0 1
58217: PPUSH
58218: CALL_OW 274
58222: PPUSH
58223: LD_VAR 0 2
58227: PPUSH
58228: LD_INT 0
58230: PPUSH
58231: CALL 55796 0 3
58235: PPUSH
58236: LD_INT 30
58238: PUSH
58239: LD_INT 3
58241: PUSH
58242: EMPTY
58243: LIST
58244: LIST
58245: PPUSH
58246: CALL_OW 72
58250: ST_TO_ADDR
// if not factories then
58251: LD_VAR 0 6
58255: NOT
58256: IFFALSE 58260
// exit ;
58258: GO 59256
// for i in factories do
58260: LD_ADDR_VAR 0 8
58264: PUSH
58265: LD_VAR 0 6
58269: PUSH
58270: FOR_IN
58271: IFFALSE 58296
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58273: LD_ADDR_VAR 0 17
58277: PUSH
58278: LD_VAR 0 17
58282: PUSH
58283: LD_VAR 0 8
58287: PPUSH
58288: CALL_OW 478
58292: UNION
58293: ST_TO_ADDR
58294: GO 58270
58296: POP
58297: POP
// if not fac_list then
58298: LD_VAR 0 17
58302: NOT
58303: IFFALSE 58307
// exit ;
58305: GO 59256
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58307: LD_ADDR_VAR 0 5
58311: PUSH
58312: LD_INT 4
58314: PUSH
58315: LD_INT 5
58317: PUSH
58318: LD_INT 9
58320: PUSH
58321: LD_INT 10
58323: PUSH
58324: LD_INT 6
58326: PUSH
58327: LD_INT 7
58329: PUSH
58330: LD_INT 11
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: LIST
58337: LIST
58338: LIST
58339: LIST
58340: LIST
58341: PUSH
58342: LD_INT 27
58344: PUSH
58345: LD_INT 28
58347: PUSH
58348: LD_INT 26
58350: PUSH
58351: LD_INT 30
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: LIST
58358: LIST
58359: PUSH
58360: LD_INT 43
58362: PUSH
58363: LD_INT 44
58365: PUSH
58366: LD_INT 46
58368: PUSH
58369: LD_INT 45
58371: PUSH
58372: LD_INT 47
58374: PUSH
58375: LD_INT 49
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: LIST
58382: LIST
58383: LIST
58384: LIST
58385: PUSH
58386: EMPTY
58387: LIST
58388: LIST
58389: LIST
58390: PUSH
58391: LD_VAR 0 12
58395: ARRAY
58396: ST_TO_ADDR
// for i in list do
58397: LD_ADDR_VAR 0 8
58401: PUSH
58402: LD_VAR 0 5
58406: PUSH
58407: FOR_IN
58408: IFFALSE 58441
// if not i in fac_list then
58410: LD_VAR 0 8
58414: PUSH
58415: LD_VAR 0 17
58419: IN
58420: NOT
58421: IFFALSE 58439
// list := list diff i ;
58423: LD_ADDR_VAR 0 5
58427: PUSH
58428: LD_VAR 0 5
58432: PUSH
58433: LD_VAR 0 8
58437: DIFF
58438: ST_TO_ADDR
58439: GO 58407
58441: POP
58442: POP
// if not list then
58443: LD_VAR 0 5
58447: NOT
58448: IFFALSE 58452
// exit ;
58450: GO 59256
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58452: LD_VAR 0 12
58456: PUSH
58457: LD_INT 3
58459: EQUAL
58460: PUSH
58461: LD_INT 49
58463: PUSH
58464: LD_VAR 0 5
58468: IN
58469: AND
58470: PUSH
58471: LD_INT 31
58473: PPUSH
58474: LD_VAR 0 16
58478: PPUSH
58479: CALL_OW 321
58483: PUSH
58484: LD_INT 2
58486: EQUAL
58487: AND
58488: IFFALSE 58548
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58490: LD_INT 22
58492: PUSH
58493: LD_VAR 0 16
58497: PUSH
58498: EMPTY
58499: LIST
58500: LIST
58501: PUSH
58502: LD_INT 35
58504: PUSH
58505: LD_INT 49
58507: PUSH
58508: EMPTY
58509: LIST
58510: LIST
58511: PUSH
58512: LD_INT 91
58514: PUSH
58515: LD_VAR 0 1
58519: PUSH
58520: LD_INT 10
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: LIST
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: LIST
58532: PPUSH
58533: CALL_OW 69
58537: NOT
58538: IFFALSE 58548
// weapon := ru_time_lapser ;
58540: LD_ADDR_VAR 0 18
58544: PUSH
58545: LD_INT 49
58547: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58548: LD_VAR 0 12
58552: PUSH
58553: LD_INT 1
58555: PUSH
58556: LD_INT 2
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: IN
58563: PUSH
58564: LD_INT 11
58566: PUSH
58567: LD_VAR 0 5
58571: IN
58572: PUSH
58573: LD_INT 30
58575: PUSH
58576: LD_VAR 0 5
58580: IN
58581: OR
58582: AND
58583: PUSH
58584: LD_INT 6
58586: PPUSH
58587: LD_VAR 0 16
58591: PPUSH
58592: CALL_OW 321
58596: PUSH
58597: LD_INT 2
58599: EQUAL
58600: AND
58601: IFFALSE 58766
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58603: LD_INT 22
58605: PUSH
58606: LD_VAR 0 16
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: PUSH
58615: LD_INT 2
58617: PUSH
58618: LD_INT 35
58620: PUSH
58621: LD_INT 11
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: PUSH
58628: LD_INT 35
58630: PUSH
58631: LD_INT 30
58633: PUSH
58634: EMPTY
58635: LIST
58636: LIST
58637: PUSH
58638: EMPTY
58639: LIST
58640: LIST
58641: LIST
58642: PUSH
58643: LD_INT 91
58645: PUSH
58646: LD_VAR 0 1
58650: PUSH
58651: LD_INT 18
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: LIST
58663: PPUSH
58664: CALL_OW 69
58668: NOT
58669: PUSH
58670: LD_INT 22
58672: PUSH
58673: LD_VAR 0 16
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: PUSH
58682: LD_INT 2
58684: PUSH
58685: LD_INT 30
58687: PUSH
58688: LD_INT 32
58690: PUSH
58691: EMPTY
58692: LIST
58693: LIST
58694: PUSH
58695: LD_INT 30
58697: PUSH
58698: LD_INT 33
58700: PUSH
58701: EMPTY
58702: LIST
58703: LIST
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: LIST
58709: PUSH
58710: LD_INT 91
58712: PUSH
58713: LD_VAR 0 1
58717: PUSH
58718: LD_INT 12
58720: PUSH
58721: EMPTY
58722: LIST
58723: LIST
58724: LIST
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: LIST
58730: PUSH
58731: EMPTY
58732: LIST
58733: PPUSH
58734: CALL_OW 69
58738: PUSH
58739: LD_INT 2
58741: GREATER
58742: AND
58743: IFFALSE 58766
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58745: LD_ADDR_VAR 0 18
58749: PUSH
58750: LD_INT 11
58752: PUSH
58753: LD_INT 30
58755: PUSH
58756: EMPTY
58757: LIST
58758: LIST
58759: PUSH
58760: LD_VAR 0 12
58764: ARRAY
58765: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58766: LD_VAR 0 18
58770: NOT
58771: PUSH
58772: LD_INT 40
58774: PPUSH
58775: LD_VAR 0 16
58779: PPUSH
58780: CALL_OW 321
58784: PUSH
58785: LD_INT 2
58787: EQUAL
58788: AND
58789: PUSH
58790: LD_INT 7
58792: PUSH
58793: LD_VAR 0 5
58797: IN
58798: PUSH
58799: LD_INT 28
58801: PUSH
58802: LD_VAR 0 5
58806: IN
58807: OR
58808: PUSH
58809: LD_INT 45
58811: PUSH
58812: LD_VAR 0 5
58816: IN
58817: OR
58818: AND
58819: IFFALSE 59073
// begin hex := GetHexInfo ( x , y ) ;
58821: LD_ADDR_VAR 0 4
58825: PUSH
58826: LD_VAR 0 10
58830: PPUSH
58831: LD_VAR 0 11
58835: PPUSH
58836: CALL_OW 546
58840: ST_TO_ADDR
// if hex [ 1 ] then
58841: LD_VAR 0 4
58845: PUSH
58846: LD_INT 1
58848: ARRAY
58849: IFFALSE 58853
// exit ;
58851: GO 59256
// height := hex [ 2 ] ;
58853: LD_ADDR_VAR 0 15
58857: PUSH
58858: LD_VAR 0 4
58862: PUSH
58863: LD_INT 2
58865: ARRAY
58866: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58867: LD_ADDR_VAR 0 14
58871: PUSH
58872: LD_INT 0
58874: PUSH
58875: LD_INT 2
58877: PUSH
58878: LD_INT 3
58880: PUSH
58881: LD_INT 5
58883: PUSH
58884: EMPTY
58885: LIST
58886: LIST
58887: LIST
58888: LIST
58889: ST_TO_ADDR
// for i in tmp do
58890: LD_ADDR_VAR 0 8
58894: PUSH
58895: LD_VAR 0 14
58899: PUSH
58900: FOR_IN
58901: IFFALSE 59071
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58903: LD_ADDR_VAR 0 9
58907: PUSH
58908: LD_VAR 0 10
58912: PPUSH
58913: LD_VAR 0 8
58917: PPUSH
58918: LD_INT 5
58920: PPUSH
58921: CALL_OW 272
58925: PUSH
58926: LD_VAR 0 11
58930: PPUSH
58931: LD_VAR 0 8
58935: PPUSH
58936: LD_INT 5
58938: PPUSH
58939: CALL_OW 273
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58948: LD_VAR 0 9
58952: PUSH
58953: LD_INT 1
58955: ARRAY
58956: PPUSH
58957: LD_VAR 0 9
58961: PUSH
58962: LD_INT 2
58964: ARRAY
58965: PPUSH
58966: CALL_OW 488
58970: IFFALSE 59069
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58972: LD_ADDR_VAR 0 4
58976: PUSH
58977: LD_VAR 0 9
58981: PUSH
58982: LD_INT 1
58984: ARRAY
58985: PPUSH
58986: LD_VAR 0 9
58990: PUSH
58991: LD_INT 2
58993: ARRAY
58994: PPUSH
58995: CALL_OW 546
58999: ST_TO_ADDR
// if hex [ 1 ] then
59000: LD_VAR 0 4
59004: PUSH
59005: LD_INT 1
59007: ARRAY
59008: IFFALSE 59012
// continue ;
59010: GO 58900
// h := hex [ 2 ] ;
59012: LD_ADDR_VAR 0 13
59016: PUSH
59017: LD_VAR 0 4
59021: PUSH
59022: LD_INT 2
59024: ARRAY
59025: ST_TO_ADDR
// if h + 7 < height then
59026: LD_VAR 0 13
59030: PUSH
59031: LD_INT 7
59033: PLUS
59034: PUSH
59035: LD_VAR 0 15
59039: LESS
59040: IFFALSE 59069
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59042: LD_ADDR_VAR 0 18
59046: PUSH
59047: LD_INT 7
59049: PUSH
59050: LD_INT 28
59052: PUSH
59053: LD_INT 45
59055: PUSH
59056: EMPTY
59057: LIST
59058: LIST
59059: LIST
59060: PUSH
59061: LD_VAR 0 12
59065: ARRAY
59066: ST_TO_ADDR
// break ;
59067: GO 59071
// end ; end ; end ;
59069: GO 58900
59071: POP
59072: POP
// end ; if not weapon then
59073: LD_VAR 0 18
59077: NOT
59078: IFFALSE 59138
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59080: LD_ADDR_VAR 0 5
59084: PUSH
59085: LD_VAR 0 5
59089: PUSH
59090: LD_INT 11
59092: PUSH
59093: LD_INT 30
59095: PUSH
59096: LD_INT 49
59098: PUSH
59099: EMPTY
59100: LIST
59101: LIST
59102: LIST
59103: DIFF
59104: ST_TO_ADDR
// if not list then
59105: LD_VAR 0 5
59109: NOT
59110: IFFALSE 59114
// exit ;
59112: GO 59256
// weapon := list [ rand ( 1 , list ) ] ;
59114: LD_ADDR_VAR 0 18
59118: PUSH
59119: LD_VAR 0 5
59123: PUSH
59124: LD_INT 1
59126: PPUSH
59127: LD_VAR 0 5
59131: PPUSH
59132: CALL_OW 12
59136: ARRAY
59137: ST_TO_ADDR
// end ; if weapon then
59138: LD_VAR 0 18
59142: IFFALSE 59256
// begin tmp := CostOfWeapon ( weapon ) ;
59144: LD_ADDR_VAR 0 14
59148: PUSH
59149: LD_VAR 0 18
59153: PPUSH
59154: CALL_OW 451
59158: ST_TO_ADDR
// j := GetBase ( tower ) ;
59159: LD_ADDR_VAR 0 9
59163: PUSH
59164: LD_VAR 0 1
59168: PPUSH
59169: CALL_OW 274
59173: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59174: LD_VAR 0 9
59178: PPUSH
59179: LD_INT 1
59181: PPUSH
59182: CALL_OW 275
59186: PUSH
59187: LD_VAR 0 14
59191: PUSH
59192: LD_INT 1
59194: ARRAY
59195: GREATEREQUAL
59196: PUSH
59197: LD_VAR 0 9
59201: PPUSH
59202: LD_INT 2
59204: PPUSH
59205: CALL_OW 275
59209: PUSH
59210: LD_VAR 0 14
59214: PUSH
59215: LD_INT 2
59217: ARRAY
59218: GREATEREQUAL
59219: AND
59220: PUSH
59221: LD_VAR 0 9
59225: PPUSH
59226: LD_INT 3
59228: PPUSH
59229: CALL_OW 275
59233: PUSH
59234: LD_VAR 0 14
59238: PUSH
59239: LD_INT 3
59241: ARRAY
59242: GREATEREQUAL
59243: AND
59244: IFFALSE 59256
// result := weapon ;
59246: LD_ADDR_VAR 0 3
59250: PUSH
59251: LD_VAR 0 18
59255: ST_TO_ADDR
// end ; end ;
59256: LD_VAR 0 3
59260: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59261: LD_INT 0
59263: PPUSH
59264: PPUSH
// result := true ;
59265: LD_ADDR_VAR 0 3
59269: PUSH
59270: LD_INT 1
59272: ST_TO_ADDR
// if array1 = array2 then
59273: LD_VAR 0 1
59277: PUSH
59278: LD_VAR 0 2
59282: EQUAL
59283: IFFALSE 59343
// begin for i = 1 to array1 do
59285: LD_ADDR_VAR 0 4
59289: PUSH
59290: DOUBLE
59291: LD_INT 1
59293: DEC
59294: ST_TO_ADDR
59295: LD_VAR 0 1
59299: PUSH
59300: FOR_TO
59301: IFFALSE 59339
// if array1 [ i ] <> array2 [ i ] then
59303: LD_VAR 0 1
59307: PUSH
59308: LD_VAR 0 4
59312: ARRAY
59313: PUSH
59314: LD_VAR 0 2
59318: PUSH
59319: LD_VAR 0 4
59323: ARRAY
59324: NONEQUAL
59325: IFFALSE 59337
// begin result := false ;
59327: LD_ADDR_VAR 0 3
59331: PUSH
59332: LD_INT 0
59334: ST_TO_ADDR
// break ;
59335: GO 59339
// end ;
59337: GO 59300
59339: POP
59340: POP
// end else
59341: GO 59351
// result := false ;
59343: LD_ADDR_VAR 0 3
59347: PUSH
59348: LD_INT 0
59350: ST_TO_ADDR
// end ;
59351: LD_VAR 0 3
59355: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59356: LD_INT 0
59358: PPUSH
59359: PPUSH
// if not array1 or not array2 then
59360: LD_VAR 0 1
59364: NOT
59365: PUSH
59366: LD_VAR 0 2
59370: NOT
59371: OR
59372: IFFALSE 59376
// exit ;
59374: GO 59440
// result := true ;
59376: LD_ADDR_VAR 0 3
59380: PUSH
59381: LD_INT 1
59383: ST_TO_ADDR
// for i = 1 to array1 do
59384: LD_ADDR_VAR 0 4
59388: PUSH
59389: DOUBLE
59390: LD_INT 1
59392: DEC
59393: ST_TO_ADDR
59394: LD_VAR 0 1
59398: PUSH
59399: FOR_TO
59400: IFFALSE 59438
// if array1 [ i ] <> array2 [ i ] then
59402: LD_VAR 0 1
59406: PUSH
59407: LD_VAR 0 4
59411: ARRAY
59412: PUSH
59413: LD_VAR 0 2
59417: PUSH
59418: LD_VAR 0 4
59422: ARRAY
59423: NONEQUAL
59424: IFFALSE 59436
// begin result := false ;
59426: LD_ADDR_VAR 0 3
59430: PUSH
59431: LD_INT 0
59433: ST_TO_ADDR
// break ;
59434: GO 59438
// end ;
59436: GO 59399
59438: POP
59439: POP
// end ;
59440: LD_VAR 0 3
59444: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59445: LD_INT 0
59447: PPUSH
59448: PPUSH
59449: PPUSH
// pom := GetBase ( fac ) ;
59450: LD_ADDR_VAR 0 5
59454: PUSH
59455: LD_VAR 0 1
59459: PPUSH
59460: CALL_OW 274
59464: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59465: LD_ADDR_VAR 0 4
59469: PUSH
59470: LD_VAR 0 2
59474: PUSH
59475: LD_INT 1
59477: ARRAY
59478: PPUSH
59479: LD_VAR 0 2
59483: PUSH
59484: LD_INT 2
59486: ARRAY
59487: PPUSH
59488: LD_VAR 0 2
59492: PUSH
59493: LD_INT 3
59495: ARRAY
59496: PPUSH
59497: LD_VAR 0 2
59501: PUSH
59502: LD_INT 4
59504: ARRAY
59505: PPUSH
59506: CALL_OW 449
59510: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59511: LD_ADDR_VAR 0 3
59515: PUSH
59516: LD_VAR 0 5
59520: PPUSH
59521: LD_INT 1
59523: PPUSH
59524: CALL_OW 275
59528: PUSH
59529: LD_VAR 0 4
59533: PUSH
59534: LD_INT 1
59536: ARRAY
59537: GREATEREQUAL
59538: PUSH
59539: LD_VAR 0 5
59543: PPUSH
59544: LD_INT 2
59546: PPUSH
59547: CALL_OW 275
59551: PUSH
59552: LD_VAR 0 4
59556: PUSH
59557: LD_INT 2
59559: ARRAY
59560: GREATEREQUAL
59561: AND
59562: PUSH
59563: LD_VAR 0 5
59567: PPUSH
59568: LD_INT 3
59570: PPUSH
59571: CALL_OW 275
59575: PUSH
59576: LD_VAR 0 4
59580: PUSH
59581: LD_INT 3
59583: ARRAY
59584: GREATEREQUAL
59585: AND
59586: ST_TO_ADDR
// end ;
59587: LD_VAR 0 3
59591: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59592: LD_INT 0
59594: PPUSH
59595: PPUSH
59596: PPUSH
59597: PPUSH
// pom := GetBase ( building ) ;
59598: LD_ADDR_VAR 0 3
59602: PUSH
59603: LD_VAR 0 1
59607: PPUSH
59608: CALL_OW 274
59612: ST_TO_ADDR
// if not pom then
59613: LD_VAR 0 3
59617: NOT
59618: IFFALSE 59622
// exit ;
59620: GO 59792
// btype := GetBType ( building ) ;
59622: LD_ADDR_VAR 0 5
59626: PUSH
59627: LD_VAR 0 1
59631: PPUSH
59632: CALL_OW 266
59636: ST_TO_ADDR
// if btype = b_armoury then
59637: LD_VAR 0 5
59641: PUSH
59642: LD_INT 4
59644: EQUAL
59645: IFFALSE 59655
// btype := b_barracks ;
59647: LD_ADDR_VAR 0 5
59651: PUSH
59652: LD_INT 5
59654: ST_TO_ADDR
// if btype = b_depot then
59655: LD_VAR 0 5
59659: PUSH
59660: LD_INT 0
59662: EQUAL
59663: IFFALSE 59673
// btype := b_warehouse ;
59665: LD_ADDR_VAR 0 5
59669: PUSH
59670: LD_INT 1
59672: ST_TO_ADDR
// if btype = b_workshop then
59673: LD_VAR 0 5
59677: PUSH
59678: LD_INT 2
59680: EQUAL
59681: IFFALSE 59691
// btype := b_factory ;
59683: LD_ADDR_VAR 0 5
59687: PUSH
59688: LD_INT 3
59690: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59691: LD_ADDR_VAR 0 4
59695: PUSH
59696: LD_VAR 0 5
59700: PPUSH
59701: LD_VAR 0 1
59705: PPUSH
59706: CALL_OW 248
59710: PPUSH
59711: CALL_OW 450
59715: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59716: LD_ADDR_VAR 0 2
59720: PUSH
59721: LD_VAR 0 3
59725: PPUSH
59726: LD_INT 1
59728: PPUSH
59729: CALL_OW 275
59733: PUSH
59734: LD_VAR 0 4
59738: PUSH
59739: LD_INT 1
59741: ARRAY
59742: GREATEREQUAL
59743: PUSH
59744: LD_VAR 0 3
59748: PPUSH
59749: LD_INT 2
59751: PPUSH
59752: CALL_OW 275
59756: PUSH
59757: LD_VAR 0 4
59761: PUSH
59762: LD_INT 2
59764: ARRAY
59765: GREATEREQUAL
59766: AND
59767: PUSH
59768: LD_VAR 0 3
59772: PPUSH
59773: LD_INT 3
59775: PPUSH
59776: CALL_OW 275
59780: PUSH
59781: LD_VAR 0 4
59785: PUSH
59786: LD_INT 3
59788: ARRAY
59789: GREATEREQUAL
59790: AND
59791: ST_TO_ADDR
// end ;
59792: LD_VAR 0 2
59796: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59797: LD_INT 0
59799: PPUSH
59800: PPUSH
59801: PPUSH
// pom := GetBase ( building ) ;
59802: LD_ADDR_VAR 0 4
59806: PUSH
59807: LD_VAR 0 1
59811: PPUSH
59812: CALL_OW 274
59816: ST_TO_ADDR
// if not pom then
59817: LD_VAR 0 4
59821: NOT
59822: IFFALSE 59826
// exit ;
59824: GO 59927
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59826: LD_ADDR_VAR 0 5
59830: PUSH
59831: LD_VAR 0 2
59835: PPUSH
59836: LD_VAR 0 1
59840: PPUSH
59841: CALL_OW 248
59845: PPUSH
59846: CALL_OW 450
59850: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59851: LD_ADDR_VAR 0 3
59855: PUSH
59856: LD_VAR 0 4
59860: PPUSH
59861: LD_INT 1
59863: PPUSH
59864: CALL_OW 275
59868: PUSH
59869: LD_VAR 0 5
59873: PUSH
59874: LD_INT 1
59876: ARRAY
59877: GREATEREQUAL
59878: PUSH
59879: LD_VAR 0 4
59883: PPUSH
59884: LD_INT 2
59886: PPUSH
59887: CALL_OW 275
59891: PUSH
59892: LD_VAR 0 5
59896: PUSH
59897: LD_INT 2
59899: ARRAY
59900: GREATEREQUAL
59901: AND
59902: PUSH
59903: LD_VAR 0 4
59907: PPUSH
59908: LD_INT 3
59910: PPUSH
59911: CALL_OW 275
59915: PUSH
59916: LD_VAR 0 5
59920: PUSH
59921: LD_INT 3
59923: ARRAY
59924: GREATEREQUAL
59925: AND
59926: ST_TO_ADDR
// end ;
59927: LD_VAR 0 3
59931: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
59932: LD_INT 0
59934: PPUSH
59935: PPUSH
59936: PPUSH
59937: PPUSH
59938: PPUSH
59939: PPUSH
59940: PPUSH
59941: PPUSH
59942: PPUSH
59943: PPUSH
59944: PPUSH
// result := false ;
59945: LD_ADDR_VAR 0 8
59949: PUSH
59950: LD_INT 0
59952: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
59953: LD_VAR 0 5
59957: NOT
59958: PUSH
59959: LD_VAR 0 1
59963: NOT
59964: OR
59965: PUSH
59966: LD_VAR 0 2
59970: NOT
59971: OR
59972: PUSH
59973: LD_VAR 0 3
59977: NOT
59978: OR
59979: IFFALSE 59983
// exit ;
59981: GO 60797
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
59983: LD_ADDR_VAR 0 14
59987: PUSH
59988: LD_VAR 0 1
59992: PPUSH
59993: LD_VAR 0 2
59997: PPUSH
59998: LD_VAR 0 3
60002: PPUSH
60003: LD_VAR 0 4
60007: PPUSH
60008: LD_VAR 0 5
60012: PUSH
60013: LD_INT 1
60015: ARRAY
60016: PPUSH
60017: CALL_OW 248
60021: PPUSH
60022: LD_INT 0
60024: PPUSH
60025: CALL 61634 0 6
60029: ST_TO_ADDR
// if not hexes then
60030: LD_VAR 0 14
60034: NOT
60035: IFFALSE 60039
// exit ;
60037: GO 60797
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60039: LD_ADDR_VAR 0 17
60043: PUSH
60044: LD_VAR 0 5
60048: PPUSH
60049: LD_INT 22
60051: PUSH
60052: LD_VAR 0 13
60056: PPUSH
60057: CALL_OW 255
60061: PUSH
60062: EMPTY
60063: LIST
60064: LIST
60065: PUSH
60066: LD_INT 2
60068: PUSH
60069: LD_INT 30
60071: PUSH
60072: LD_INT 0
60074: PUSH
60075: EMPTY
60076: LIST
60077: LIST
60078: PUSH
60079: LD_INT 30
60081: PUSH
60082: LD_INT 1
60084: PUSH
60085: EMPTY
60086: LIST
60087: LIST
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: LIST
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: PPUSH
60098: CALL_OW 72
60102: ST_TO_ADDR
// for i = 1 to hexes do
60103: LD_ADDR_VAR 0 9
60107: PUSH
60108: DOUBLE
60109: LD_INT 1
60111: DEC
60112: ST_TO_ADDR
60113: LD_VAR 0 14
60117: PUSH
60118: FOR_TO
60119: IFFALSE 60795
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60121: LD_ADDR_VAR 0 13
60125: PUSH
60126: LD_VAR 0 14
60130: PUSH
60131: LD_VAR 0 9
60135: ARRAY
60136: PUSH
60137: LD_INT 1
60139: ARRAY
60140: PPUSH
60141: LD_VAR 0 14
60145: PUSH
60146: LD_VAR 0 9
60150: ARRAY
60151: PUSH
60152: LD_INT 2
60154: ARRAY
60155: PPUSH
60156: CALL_OW 428
60160: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60161: LD_VAR 0 14
60165: PUSH
60166: LD_VAR 0 9
60170: ARRAY
60171: PUSH
60172: LD_INT 1
60174: ARRAY
60175: PPUSH
60176: LD_VAR 0 14
60180: PUSH
60181: LD_VAR 0 9
60185: ARRAY
60186: PUSH
60187: LD_INT 2
60189: ARRAY
60190: PPUSH
60191: CALL_OW 351
60195: PUSH
60196: LD_VAR 0 14
60200: PUSH
60201: LD_VAR 0 9
60205: ARRAY
60206: PUSH
60207: LD_INT 1
60209: ARRAY
60210: PPUSH
60211: LD_VAR 0 14
60215: PUSH
60216: LD_VAR 0 9
60220: ARRAY
60221: PUSH
60222: LD_INT 2
60224: ARRAY
60225: PPUSH
60226: CALL_OW 488
60230: NOT
60231: OR
60232: PUSH
60233: LD_VAR 0 13
60237: PPUSH
60238: CALL_OW 247
60242: PUSH
60243: LD_INT 3
60245: EQUAL
60246: OR
60247: IFFALSE 60253
// exit ;
60249: POP
60250: POP
60251: GO 60797
// if not tmp then
60253: LD_VAR 0 13
60257: NOT
60258: IFFALSE 60262
// continue ;
60260: GO 60118
// result := true ;
60262: LD_ADDR_VAR 0 8
60266: PUSH
60267: LD_INT 1
60269: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60270: LD_VAR 0 6
60274: PUSH
60275: LD_VAR 0 13
60279: PPUSH
60280: CALL_OW 247
60284: PUSH
60285: LD_INT 2
60287: EQUAL
60288: AND
60289: PUSH
60290: LD_VAR 0 13
60294: PPUSH
60295: CALL_OW 263
60299: PUSH
60300: LD_INT 1
60302: EQUAL
60303: AND
60304: IFFALSE 60468
// begin if IsDrivenBy ( tmp ) then
60306: LD_VAR 0 13
60310: PPUSH
60311: CALL_OW 311
60315: IFFALSE 60319
// continue ;
60317: GO 60118
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60319: LD_VAR 0 6
60323: PPUSH
60324: LD_INT 3
60326: PUSH
60327: LD_INT 60
60329: PUSH
60330: EMPTY
60331: LIST
60332: PUSH
60333: EMPTY
60334: LIST
60335: LIST
60336: PUSH
60337: LD_INT 3
60339: PUSH
60340: LD_INT 55
60342: PUSH
60343: EMPTY
60344: LIST
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PPUSH
60354: CALL_OW 72
60358: IFFALSE 60466
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60360: LD_ADDR_VAR 0 18
60364: PUSH
60365: LD_VAR 0 6
60369: PPUSH
60370: LD_INT 3
60372: PUSH
60373: LD_INT 60
60375: PUSH
60376: EMPTY
60377: LIST
60378: PUSH
60379: EMPTY
60380: LIST
60381: LIST
60382: PUSH
60383: LD_INT 3
60385: PUSH
60386: LD_INT 55
60388: PUSH
60389: EMPTY
60390: LIST
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: EMPTY
60397: LIST
60398: LIST
60399: PPUSH
60400: CALL_OW 72
60404: PUSH
60405: LD_INT 1
60407: ARRAY
60408: ST_TO_ADDR
// if IsInUnit ( driver ) then
60409: LD_VAR 0 18
60413: PPUSH
60414: CALL_OW 310
60418: IFFALSE 60429
// ComExit ( driver ) ;
60420: LD_VAR 0 18
60424: PPUSH
60425: CALL 84818 0 1
// AddComEnterUnit ( driver , tmp ) ;
60429: LD_VAR 0 18
60433: PPUSH
60434: LD_VAR 0 13
60438: PPUSH
60439: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60443: LD_VAR 0 18
60447: PPUSH
60448: LD_VAR 0 7
60452: PPUSH
60453: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60457: LD_VAR 0 18
60461: PPUSH
60462: CALL_OW 181
// end ; continue ;
60466: GO 60118
// end ; if not cleaners or not tmp in cleaners then
60468: LD_VAR 0 6
60472: NOT
60473: PUSH
60474: LD_VAR 0 13
60478: PUSH
60479: LD_VAR 0 6
60483: IN
60484: NOT
60485: OR
60486: IFFALSE 60793
// begin if dep then
60488: LD_VAR 0 17
60492: IFFALSE 60628
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60494: LD_ADDR_VAR 0 16
60498: PUSH
60499: LD_VAR 0 17
60503: PUSH
60504: LD_INT 1
60506: ARRAY
60507: PPUSH
60508: CALL_OW 250
60512: PPUSH
60513: LD_VAR 0 17
60517: PUSH
60518: LD_INT 1
60520: ARRAY
60521: PPUSH
60522: CALL_OW 254
60526: PPUSH
60527: LD_INT 5
60529: PPUSH
60530: CALL_OW 272
60534: PUSH
60535: LD_VAR 0 17
60539: PUSH
60540: LD_INT 1
60542: ARRAY
60543: PPUSH
60544: CALL_OW 251
60548: PPUSH
60549: LD_VAR 0 17
60553: PUSH
60554: LD_INT 1
60556: ARRAY
60557: PPUSH
60558: CALL_OW 254
60562: PPUSH
60563: LD_INT 5
60565: PPUSH
60566: CALL_OW 273
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60575: LD_VAR 0 16
60579: PUSH
60580: LD_INT 1
60582: ARRAY
60583: PPUSH
60584: LD_VAR 0 16
60588: PUSH
60589: LD_INT 2
60591: ARRAY
60592: PPUSH
60593: CALL_OW 488
60597: IFFALSE 60628
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60599: LD_VAR 0 13
60603: PPUSH
60604: LD_VAR 0 16
60608: PUSH
60609: LD_INT 1
60611: ARRAY
60612: PPUSH
60613: LD_VAR 0 16
60617: PUSH
60618: LD_INT 2
60620: ARRAY
60621: PPUSH
60622: CALL_OW 111
// continue ;
60626: GO 60118
// end ; end ; r := GetDir ( tmp ) ;
60628: LD_ADDR_VAR 0 15
60632: PUSH
60633: LD_VAR 0 13
60637: PPUSH
60638: CALL_OW 254
60642: ST_TO_ADDR
// if r = 5 then
60643: LD_VAR 0 15
60647: PUSH
60648: LD_INT 5
60650: EQUAL
60651: IFFALSE 60661
// r := 0 ;
60653: LD_ADDR_VAR 0 15
60657: PUSH
60658: LD_INT 0
60660: ST_TO_ADDR
// for j = r to 5 do
60661: LD_ADDR_VAR 0 10
60665: PUSH
60666: DOUBLE
60667: LD_VAR 0 15
60671: DEC
60672: ST_TO_ADDR
60673: LD_INT 5
60675: PUSH
60676: FOR_TO
60677: IFFALSE 60791
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60679: LD_ADDR_VAR 0 11
60683: PUSH
60684: LD_VAR 0 13
60688: PPUSH
60689: CALL_OW 250
60693: PPUSH
60694: LD_VAR 0 10
60698: PPUSH
60699: LD_INT 2
60701: PPUSH
60702: CALL_OW 272
60706: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60707: LD_ADDR_VAR 0 12
60711: PUSH
60712: LD_VAR 0 13
60716: PPUSH
60717: CALL_OW 251
60721: PPUSH
60722: LD_VAR 0 10
60726: PPUSH
60727: LD_INT 2
60729: PPUSH
60730: CALL_OW 273
60734: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60735: LD_VAR 0 11
60739: PPUSH
60740: LD_VAR 0 12
60744: PPUSH
60745: CALL_OW 488
60749: PUSH
60750: LD_VAR 0 11
60754: PPUSH
60755: LD_VAR 0 12
60759: PPUSH
60760: CALL_OW 428
60764: NOT
60765: AND
60766: IFFALSE 60789
// begin ComMoveXY ( tmp , _x , _y ) ;
60768: LD_VAR 0 13
60772: PPUSH
60773: LD_VAR 0 11
60777: PPUSH
60778: LD_VAR 0 12
60782: PPUSH
60783: CALL_OW 111
// break ;
60787: GO 60791
// end ; end ;
60789: GO 60676
60791: POP
60792: POP
// end ; end ;
60793: GO 60118
60795: POP
60796: POP
// end ;
60797: LD_VAR 0 8
60801: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
60802: LD_INT 0
60804: PPUSH
60805: PPUSH
60806: PPUSH
60807: PPUSH
60808: PPUSH
60809: PPUSH
60810: PPUSH
60811: PPUSH
60812: PPUSH
60813: PPUSH
// result := false ;
60814: LD_ADDR_VAR 0 6
60818: PUSH
60819: LD_INT 0
60821: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
60822: LD_VAR 0 1
60826: NOT
60827: PUSH
60828: LD_VAR 0 1
60832: PPUSH
60833: CALL_OW 266
60837: PUSH
60838: LD_INT 0
60840: PUSH
60841: LD_INT 1
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: IN
60848: NOT
60849: OR
60850: PUSH
60851: LD_VAR 0 2
60855: NOT
60856: OR
60857: PUSH
60858: LD_VAR 0 5
60862: PUSH
60863: LD_INT 0
60865: PUSH
60866: LD_INT 1
60868: PUSH
60869: LD_INT 2
60871: PUSH
60872: LD_INT 3
60874: PUSH
60875: LD_INT 4
60877: PUSH
60878: LD_INT 5
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: IN
60889: NOT
60890: OR
60891: PUSH
60892: LD_VAR 0 3
60896: PPUSH
60897: LD_VAR 0 4
60901: PPUSH
60902: CALL_OW 488
60906: NOT
60907: OR
60908: IFFALSE 60912
// exit ;
60910: GO 61629
// pom := GetBase ( depot ) ;
60912: LD_ADDR_VAR 0 10
60916: PUSH
60917: LD_VAR 0 1
60921: PPUSH
60922: CALL_OW 274
60926: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
60927: LD_ADDR_VAR 0 11
60931: PUSH
60932: LD_VAR 0 2
60936: PPUSH
60937: LD_VAR 0 1
60941: PPUSH
60942: CALL_OW 248
60946: PPUSH
60947: CALL_OW 450
60951: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
60952: LD_VAR 0 10
60956: PPUSH
60957: LD_INT 1
60959: PPUSH
60960: CALL_OW 275
60964: PUSH
60965: LD_VAR 0 11
60969: PUSH
60970: LD_INT 1
60972: ARRAY
60973: GREATEREQUAL
60974: PUSH
60975: LD_VAR 0 10
60979: PPUSH
60980: LD_INT 2
60982: PPUSH
60983: CALL_OW 275
60987: PUSH
60988: LD_VAR 0 11
60992: PUSH
60993: LD_INT 2
60995: ARRAY
60996: GREATEREQUAL
60997: AND
60998: PUSH
60999: LD_VAR 0 10
61003: PPUSH
61004: LD_INT 3
61006: PPUSH
61007: CALL_OW 275
61011: PUSH
61012: LD_VAR 0 11
61016: PUSH
61017: LD_INT 3
61019: ARRAY
61020: GREATEREQUAL
61021: AND
61022: NOT
61023: IFFALSE 61027
// exit ;
61025: GO 61629
// if GetBType ( depot ) = b_depot then
61027: LD_VAR 0 1
61031: PPUSH
61032: CALL_OW 266
61036: PUSH
61037: LD_INT 0
61039: EQUAL
61040: IFFALSE 61052
// dist := 28 else
61042: LD_ADDR_VAR 0 14
61046: PUSH
61047: LD_INT 28
61049: ST_TO_ADDR
61050: GO 61060
// dist := 36 ;
61052: LD_ADDR_VAR 0 14
61056: PUSH
61057: LD_INT 36
61059: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61060: LD_VAR 0 1
61064: PPUSH
61065: LD_VAR 0 3
61069: PPUSH
61070: LD_VAR 0 4
61074: PPUSH
61075: CALL_OW 297
61079: PUSH
61080: LD_VAR 0 14
61084: GREATER
61085: IFFALSE 61089
// exit ;
61087: GO 61629
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61089: LD_ADDR_VAR 0 12
61093: PUSH
61094: LD_VAR 0 2
61098: PPUSH
61099: LD_VAR 0 3
61103: PPUSH
61104: LD_VAR 0 4
61108: PPUSH
61109: LD_VAR 0 5
61113: PPUSH
61114: LD_VAR 0 1
61118: PPUSH
61119: CALL_OW 248
61123: PPUSH
61124: LD_INT 0
61126: PPUSH
61127: CALL 61634 0 6
61131: ST_TO_ADDR
// if not hexes then
61132: LD_VAR 0 12
61136: NOT
61137: IFFALSE 61141
// exit ;
61139: GO 61629
// hex := GetHexInfo ( x , y ) ;
61141: LD_ADDR_VAR 0 15
61145: PUSH
61146: LD_VAR 0 3
61150: PPUSH
61151: LD_VAR 0 4
61155: PPUSH
61156: CALL_OW 546
61160: ST_TO_ADDR
// if hex [ 1 ] then
61161: LD_VAR 0 15
61165: PUSH
61166: LD_INT 1
61168: ARRAY
61169: IFFALSE 61173
// exit ;
61171: GO 61629
// height := hex [ 2 ] ;
61173: LD_ADDR_VAR 0 13
61177: PUSH
61178: LD_VAR 0 15
61182: PUSH
61183: LD_INT 2
61185: ARRAY
61186: ST_TO_ADDR
// for i = 1 to hexes do
61187: LD_ADDR_VAR 0 7
61191: PUSH
61192: DOUBLE
61193: LD_INT 1
61195: DEC
61196: ST_TO_ADDR
61197: LD_VAR 0 12
61201: PUSH
61202: FOR_TO
61203: IFFALSE 61533
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61205: LD_VAR 0 12
61209: PUSH
61210: LD_VAR 0 7
61214: ARRAY
61215: PUSH
61216: LD_INT 1
61218: ARRAY
61219: PPUSH
61220: LD_VAR 0 12
61224: PUSH
61225: LD_VAR 0 7
61229: ARRAY
61230: PUSH
61231: LD_INT 2
61233: ARRAY
61234: PPUSH
61235: CALL_OW 488
61239: NOT
61240: PUSH
61241: LD_VAR 0 12
61245: PUSH
61246: LD_VAR 0 7
61250: ARRAY
61251: PUSH
61252: LD_INT 1
61254: ARRAY
61255: PPUSH
61256: LD_VAR 0 12
61260: PUSH
61261: LD_VAR 0 7
61265: ARRAY
61266: PUSH
61267: LD_INT 2
61269: ARRAY
61270: PPUSH
61271: CALL_OW 428
61275: PUSH
61276: LD_INT 0
61278: GREATER
61279: OR
61280: PUSH
61281: LD_VAR 0 12
61285: PUSH
61286: LD_VAR 0 7
61290: ARRAY
61291: PUSH
61292: LD_INT 1
61294: ARRAY
61295: PPUSH
61296: LD_VAR 0 12
61300: PUSH
61301: LD_VAR 0 7
61305: ARRAY
61306: PUSH
61307: LD_INT 2
61309: ARRAY
61310: PPUSH
61311: CALL_OW 351
61315: OR
61316: IFFALSE 61322
// exit ;
61318: POP
61319: POP
61320: GO 61629
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61322: LD_ADDR_VAR 0 8
61326: PUSH
61327: LD_VAR 0 12
61331: PUSH
61332: LD_VAR 0 7
61336: ARRAY
61337: PUSH
61338: LD_INT 1
61340: ARRAY
61341: PPUSH
61342: LD_VAR 0 12
61346: PUSH
61347: LD_VAR 0 7
61351: ARRAY
61352: PUSH
61353: LD_INT 2
61355: ARRAY
61356: PPUSH
61357: CALL_OW 546
61361: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
61362: LD_VAR 0 8
61366: PUSH
61367: LD_INT 1
61369: ARRAY
61370: PUSH
61371: LD_VAR 0 8
61375: PUSH
61376: LD_INT 2
61378: ARRAY
61379: PUSH
61380: LD_VAR 0 13
61384: PUSH
61385: LD_INT 2
61387: PLUS
61388: GREATER
61389: OR
61390: PUSH
61391: LD_VAR 0 8
61395: PUSH
61396: LD_INT 2
61398: ARRAY
61399: PUSH
61400: LD_VAR 0 13
61404: PUSH
61405: LD_INT 2
61407: MINUS
61408: LESS
61409: OR
61410: PUSH
61411: LD_VAR 0 8
61415: PUSH
61416: LD_INT 3
61418: ARRAY
61419: PUSH
61420: LD_INT 0
61422: PUSH
61423: LD_INT 8
61425: PUSH
61426: LD_INT 9
61428: PUSH
61429: LD_INT 10
61431: PUSH
61432: LD_INT 11
61434: PUSH
61435: LD_INT 12
61437: PUSH
61438: LD_INT 13
61440: PUSH
61441: LD_INT 16
61443: PUSH
61444: LD_INT 17
61446: PUSH
61447: LD_INT 18
61449: PUSH
61450: LD_INT 19
61452: PUSH
61453: LD_INT 20
61455: PUSH
61456: LD_INT 21
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: LIST
61463: LIST
61464: LIST
61465: LIST
61466: LIST
61467: LIST
61468: LIST
61469: LIST
61470: LIST
61471: LIST
61472: LIST
61473: IN
61474: NOT
61475: OR
61476: PUSH
61477: LD_VAR 0 8
61481: PUSH
61482: LD_INT 5
61484: ARRAY
61485: NOT
61486: OR
61487: PUSH
61488: LD_VAR 0 8
61492: PUSH
61493: LD_INT 6
61495: ARRAY
61496: PUSH
61497: LD_INT 1
61499: PUSH
61500: LD_INT 2
61502: PUSH
61503: LD_INT 7
61505: PUSH
61506: LD_INT 9
61508: PUSH
61509: LD_INT 10
61511: PUSH
61512: LD_INT 11
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: LIST
61519: LIST
61520: LIST
61521: LIST
61522: IN
61523: NOT
61524: OR
61525: IFFALSE 61531
// exit ;
61527: POP
61528: POP
61529: GO 61629
// end ;
61531: GO 61202
61533: POP
61534: POP
// side := GetSide ( depot ) ;
61535: LD_ADDR_VAR 0 9
61539: PUSH
61540: LD_VAR 0 1
61544: PPUSH
61545: CALL_OW 255
61549: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
61550: LD_VAR 0 9
61554: PPUSH
61555: LD_VAR 0 3
61559: PPUSH
61560: LD_VAR 0 4
61564: PPUSH
61565: LD_INT 20
61567: PPUSH
61568: CALL 53950 0 4
61572: PUSH
61573: LD_INT 4
61575: ARRAY
61576: IFFALSE 61580
// exit ;
61578: GO 61629
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
61580: LD_VAR 0 2
61584: PUSH
61585: LD_INT 29
61587: PUSH
61588: LD_INT 30
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: IN
61595: PUSH
61596: LD_VAR 0 3
61600: PPUSH
61601: LD_VAR 0 4
61605: PPUSH
61606: LD_VAR 0 9
61610: PPUSH
61611: CALL_OW 440
61615: NOT
61616: AND
61617: IFFALSE 61621
// exit ;
61619: GO 61629
// result := true ;
61621: LD_ADDR_VAR 0 6
61625: PUSH
61626: LD_INT 1
61628: ST_TO_ADDR
// end ;
61629: LD_VAR 0 6
61633: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
61634: LD_INT 0
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
61640: PPUSH
61641: PPUSH
61642: PPUSH
61643: PPUSH
61644: PPUSH
61645: PPUSH
61646: PPUSH
61647: PPUSH
61648: PPUSH
61649: PPUSH
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
61655: PPUSH
61656: PPUSH
61657: PPUSH
61658: PPUSH
61659: PPUSH
61660: PPUSH
61661: PPUSH
61662: PPUSH
61663: PPUSH
61664: PPUSH
61665: PPUSH
61666: PPUSH
61667: PPUSH
61668: PPUSH
61669: PPUSH
61670: PPUSH
61671: PPUSH
61672: PPUSH
61673: PPUSH
61674: PPUSH
61675: PPUSH
61676: PPUSH
61677: PPUSH
61678: PPUSH
61679: PPUSH
61680: PPUSH
61681: PPUSH
61682: PPUSH
61683: PPUSH
61684: PPUSH
61685: PPUSH
61686: PPUSH
61687: PPUSH
61688: PPUSH
61689: PPUSH
61690: PPUSH
61691: PPUSH
61692: PPUSH
61693: PPUSH
// result = [ ] ;
61694: LD_ADDR_VAR 0 7
61698: PUSH
61699: EMPTY
61700: ST_TO_ADDR
// temp_list = [ ] ;
61701: LD_ADDR_VAR 0 9
61705: PUSH
61706: EMPTY
61707: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
61708: LD_VAR 0 4
61712: PUSH
61713: LD_INT 0
61715: PUSH
61716: LD_INT 1
61718: PUSH
61719: LD_INT 2
61721: PUSH
61722: LD_INT 3
61724: PUSH
61725: LD_INT 4
61727: PUSH
61728: LD_INT 5
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: LIST
61735: LIST
61736: LIST
61737: LIST
61738: IN
61739: NOT
61740: PUSH
61741: LD_VAR 0 1
61745: PUSH
61746: LD_INT 0
61748: PUSH
61749: LD_INT 1
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: IN
61756: PUSH
61757: LD_VAR 0 5
61761: PUSH
61762: LD_INT 1
61764: PUSH
61765: LD_INT 2
61767: PUSH
61768: LD_INT 3
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: LIST
61775: IN
61776: NOT
61777: AND
61778: OR
61779: IFFALSE 61783
// exit ;
61781: GO 80174
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
61783: LD_VAR 0 1
61787: PUSH
61788: LD_INT 6
61790: PUSH
61791: LD_INT 7
61793: PUSH
61794: LD_INT 8
61796: PUSH
61797: LD_INT 13
61799: PUSH
61800: LD_INT 12
61802: PUSH
61803: LD_INT 15
61805: PUSH
61806: LD_INT 11
61808: PUSH
61809: LD_INT 14
61811: PUSH
61812: LD_INT 10
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: IN
61826: IFFALSE 61836
// btype = b_lab ;
61828: LD_ADDR_VAR 0 1
61832: PUSH
61833: LD_INT 6
61835: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
61836: LD_VAR 0 6
61840: PUSH
61841: LD_INT 0
61843: PUSH
61844: LD_INT 1
61846: PUSH
61847: LD_INT 2
61849: PUSH
61850: EMPTY
61851: LIST
61852: LIST
61853: LIST
61854: IN
61855: NOT
61856: PUSH
61857: LD_VAR 0 1
61861: PUSH
61862: LD_INT 0
61864: PUSH
61865: LD_INT 1
61867: PUSH
61868: LD_INT 2
61870: PUSH
61871: LD_INT 3
61873: PUSH
61874: LD_INT 6
61876: PUSH
61877: LD_INT 36
61879: PUSH
61880: LD_INT 4
61882: PUSH
61883: LD_INT 5
61885: PUSH
61886: LD_INT 31
61888: PUSH
61889: LD_INT 32
61891: PUSH
61892: LD_INT 33
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: IN
61908: NOT
61909: PUSH
61910: LD_VAR 0 6
61914: PUSH
61915: LD_INT 1
61917: EQUAL
61918: AND
61919: OR
61920: PUSH
61921: LD_VAR 0 1
61925: PUSH
61926: LD_INT 2
61928: PUSH
61929: LD_INT 3
61931: PUSH
61932: EMPTY
61933: LIST
61934: LIST
61935: IN
61936: NOT
61937: PUSH
61938: LD_VAR 0 6
61942: PUSH
61943: LD_INT 2
61945: EQUAL
61946: AND
61947: OR
61948: IFFALSE 61958
// mode = 0 ;
61950: LD_ADDR_VAR 0 6
61954: PUSH
61955: LD_INT 0
61957: ST_TO_ADDR
// case mode of 0 :
61958: LD_VAR 0 6
61962: PUSH
61963: LD_INT 0
61965: DOUBLE
61966: EQUAL
61967: IFTRUE 61971
61969: GO 73424
61971: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
61972: LD_ADDR_VAR 0 11
61976: PUSH
61977: LD_INT 0
61979: PUSH
61980: LD_INT 0
61982: PUSH
61983: EMPTY
61984: LIST
61985: LIST
61986: PUSH
61987: LD_INT 0
61989: PUSH
61990: LD_INT 1
61992: NEG
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 1
62000: PUSH
62001: LD_INT 0
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 1
62010: PUSH
62011: LD_INT 1
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: PUSH
62018: LD_INT 0
62020: PUSH
62021: LD_INT 1
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PUSH
62028: LD_INT 1
62030: NEG
62031: PUSH
62032: LD_INT 0
62034: PUSH
62035: EMPTY
62036: LIST
62037: LIST
62038: PUSH
62039: LD_INT 1
62041: NEG
62042: PUSH
62043: LD_INT 1
62045: NEG
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: PUSH
62051: LD_INT 1
62053: NEG
62054: PUSH
62055: LD_INT 2
62057: NEG
62058: PUSH
62059: EMPTY
62060: LIST
62061: LIST
62062: PUSH
62063: LD_INT 0
62065: PUSH
62066: LD_INT 2
62068: NEG
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: LD_INT 1
62076: PUSH
62077: LD_INT 1
62079: NEG
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: PUSH
62085: LD_INT 1
62087: PUSH
62088: LD_INT 2
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: PUSH
62095: LD_INT 0
62097: PUSH
62098: LD_INT 2
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: PUSH
62105: LD_INT 1
62107: NEG
62108: PUSH
62109: LD_INT 1
62111: PUSH
62112: EMPTY
62113: LIST
62114: LIST
62115: PUSH
62116: LD_INT 1
62118: PUSH
62119: LD_INT 3
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: PUSH
62126: LD_INT 0
62128: PUSH
62129: LD_INT 3
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: PUSH
62136: LD_INT 1
62138: NEG
62139: PUSH
62140: LD_INT 2
62142: PUSH
62143: EMPTY
62144: LIST
62145: LIST
62146: PUSH
62147: EMPTY
62148: LIST
62149: LIST
62150: LIST
62151: LIST
62152: LIST
62153: LIST
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62165: LD_ADDR_VAR 0 12
62169: PUSH
62170: LD_INT 0
62172: PUSH
62173: LD_INT 0
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: PUSH
62180: LD_INT 0
62182: PUSH
62183: LD_INT 1
62185: NEG
62186: PUSH
62187: EMPTY
62188: LIST
62189: LIST
62190: PUSH
62191: LD_INT 1
62193: PUSH
62194: LD_INT 0
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: PUSH
62201: LD_INT 1
62203: PUSH
62204: LD_INT 1
62206: PUSH
62207: EMPTY
62208: LIST
62209: LIST
62210: PUSH
62211: LD_INT 0
62213: PUSH
62214: LD_INT 1
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 1
62223: NEG
62224: PUSH
62225: LD_INT 0
62227: PUSH
62228: EMPTY
62229: LIST
62230: LIST
62231: PUSH
62232: LD_INT 1
62234: NEG
62235: PUSH
62236: LD_INT 1
62238: NEG
62239: PUSH
62240: EMPTY
62241: LIST
62242: LIST
62243: PUSH
62244: LD_INT 1
62246: PUSH
62247: LD_INT 1
62249: NEG
62250: PUSH
62251: EMPTY
62252: LIST
62253: LIST
62254: PUSH
62255: LD_INT 2
62257: PUSH
62258: LD_INT 0
62260: PUSH
62261: EMPTY
62262: LIST
62263: LIST
62264: PUSH
62265: LD_INT 2
62267: PUSH
62268: LD_INT 1
62270: PUSH
62271: EMPTY
62272: LIST
62273: LIST
62274: PUSH
62275: LD_INT 1
62277: NEG
62278: PUSH
62279: LD_INT 1
62281: PUSH
62282: EMPTY
62283: LIST
62284: LIST
62285: PUSH
62286: LD_INT 2
62288: NEG
62289: PUSH
62290: LD_INT 0
62292: PUSH
62293: EMPTY
62294: LIST
62295: LIST
62296: PUSH
62297: LD_INT 2
62299: NEG
62300: PUSH
62301: LD_INT 1
62303: NEG
62304: PUSH
62305: EMPTY
62306: LIST
62307: LIST
62308: PUSH
62309: LD_INT 2
62311: NEG
62312: PUSH
62313: LD_INT 1
62315: PUSH
62316: EMPTY
62317: LIST
62318: LIST
62319: PUSH
62320: LD_INT 3
62322: NEG
62323: PUSH
62324: LD_INT 0
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: LD_INT 3
62333: NEG
62334: PUSH
62335: LD_INT 1
62337: NEG
62338: PUSH
62339: EMPTY
62340: LIST
62341: LIST
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: LIST
62354: LIST
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: LIST
62360: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62361: LD_ADDR_VAR 0 13
62365: PUSH
62366: LD_INT 0
62368: PUSH
62369: LD_INT 0
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: PUSH
62376: LD_INT 0
62378: PUSH
62379: LD_INT 1
62381: NEG
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: PUSH
62387: LD_INT 1
62389: PUSH
62390: LD_INT 0
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PUSH
62397: LD_INT 1
62399: PUSH
62400: LD_INT 1
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 0
62409: PUSH
62410: LD_INT 1
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 1
62419: NEG
62420: PUSH
62421: LD_INT 0
62423: PUSH
62424: EMPTY
62425: LIST
62426: LIST
62427: PUSH
62428: LD_INT 1
62430: NEG
62431: PUSH
62432: LD_INT 1
62434: NEG
62435: PUSH
62436: EMPTY
62437: LIST
62438: LIST
62439: PUSH
62440: LD_INT 1
62442: NEG
62443: PUSH
62444: LD_INT 2
62446: NEG
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: PUSH
62452: LD_INT 2
62454: PUSH
62455: LD_INT 1
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: PUSH
62462: LD_INT 2
62464: PUSH
62465: LD_INT 2
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: PUSH
62472: LD_INT 1
62474: PUSH
62475: LD_INT 2
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: PUSH
62482: LD_INT 2
62484: NEG
62485: PUSH
62486: LD_INT 1
62488: NEG
62489: PUSH
62490: EMPTY
62491: LIST
62492: LIST
62493: PUSH
62494: LD_INT 2
62496: NEG
62497: PUSH
62498: LD_INT 2
62500: NEG
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PUSH
62506: LD_INT 2
62508: NEG
62509: PUSH
62510: LD_INT 3
62512: NEG
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: PUSH
62518: LD_INT 3
62520: NEG
62521: PUSH
62522: LD_INT 2
62524: NEG
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: LD_INT 3
62532: NEG
62533: PUSH
62534: LD_INT 3
62536: NEG
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: EMPTY
62543: LIST
62544: LIST
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: LIST
62554: LIST
62555: LIST
62556: LIST
62557: LIST
62558: LIST
62559: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
62560: LD_ADDR_VAR 0 14
62564: PUSH
62565: LD_INT 0
62567: PUSH
62568: LD_INT 0
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: PUSH
62575: LD_INT 0
62577: PUSH
62578: LD_INT 1
62580: NEG
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 1
62588: PUSH
62589: LD_INT 0
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: LD_INT 1
62598: PUSH
62599: LD_INT 1
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: LD_INT 0
62608: PUSH
62609: LD_INT 1
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: LD_INT 1
62618: NEG
62619: PUSH
62620: LD_INT 0
62622: PUSH
62623: EMPTY
62624: LIST
62625: LIST
62626: PUSH
62627: LD_INT 1
62629: NEG
62630: PUSH
62631: LD_INT 1
62633: NEG
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 1
62641: NEG
62642: PUSH
62643: LD_INT 2
62645: NEG
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: PUSH
62651: LD_INT 0
62653: PUSH
62654: LD_INT 2
62656: NEG
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: PUSH
62662: LD_INT 1
62664: PUSH
62665: LD_INT 1
62667: NEG
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: PUSH
62673: LD_INT 1
62675: PUSH
62676: LD_INT 2
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: PUSH
62683: LD_INT 0
62685: PUSH
62686: LD_INT 2
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_INT 1
62695: NEG
62696: PUSH
62697: LD_INT 1
62699: PUSH
62700: EMPTY
62701: LIST
62702: LIST
62703: PUSH
62704: LD_INT 1
62706: NEG
62707: PUSH
62708: LD_INT 3
62710: NEG
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: LD_INT 0
62718: PUSH
62719: LD_INT 3
62721: NEG
62722: PUSH
62723: EMPTY
62724: LIST
62725: LIST
62726: PUSH
62727: LD_INT 1
62729: PUSH
62730: LD_INT 2
62732: NEG
62733: PUSH
62734: EMPTY
62735: LIST
62736: LIST
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: LIST
62742: LIST
62743: LIST
62744: LIST
62745: LIST
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: LIST
62755: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
62756: LD_ADDR_VAR 0 15
62760: PUSH
62761: LD_INT 0
62763: PUSH
62764: LD_INT 0
62766: PUSH
62767: EMPTY
62768: LIST
62769: LIST
62770: PUSH
62771: LD_INT 0
62773: PUSH
62774: LD_INT 1
62776: NEG
62777: PUSH
62778: EMPTY
62779: LIST
62780: LIST
62781: PUSH
62782: LD_INT 1
62784: PUSH
62785: LD_INT 0
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: PUSH
62792: LD_INT 1
62794: PUSH
62795: LD_INT 1
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: PUSH
62802: LD_INT 0
62804: PUSH
62805: LD_INT 1
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: PUSH
62812: LD_INT 1
62814: NEG
62815: PUSH
62816: LD_INT 0
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 1
62825: NEG
62826: PUSH
62827: LD_INT 1
62829: NEG
62830: PUSH
62831: EMPTY
62832: LIST
62833: LIST
62834: PUSH
62835: LD_INT 1
62837: PUSH
62838: LD_INT 1
62840: NEG
62841: PUSH
62842: EMPTY
62843: LIST
62844: LIST
62845: PUSH
62846: LD_INT 2
62848: PUSH
62849: LD_INT 0
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 2
62858: PUSH
62859: LD_INT 1
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 1
62868: NEG
62869: PUSH
62870: LD_INT 1
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: PUSH
62877: LD_INT 2
62879: NEG
62880: PUSH
62881: LD_INT 0
62883: PUSH
62884: EMPTY
62885: LIST
62886: LIST
62887: PUSH
62888: LD_INT 2
62890: NEG
62891: PUSH
62892: LD_INT 1
62894: NEG
62895: PUSH
62896: EMPTY
62897: LIST
62898: LIST
62899: PUSH
62900: LD_INT 2
62902: PUSH
62903: LD_INT 1
62905: NEG
62906: PUSH
62907: EMPTY
62908: LIST
62909: LIST
62910: PUSH
62911: LD_INT 3
62913: PUSH
62914: LD_INT 0
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: PUSH
62921: LD_INT 3
62923: PUSH
62924: LD_INT 1
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: LIST
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: LIST
62947: LIST
62948: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
62949: LD_ADDR_VAR 0 16
62953: PUSH
62954: LD_INT 0
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: PUSH
62964: LD_INT 0
62966: PUSH
62967: LD_INT 1
62969: NEG
62970: PUSH
62971: EMPTY
62972: LIST
62973: LIST
62974: PUSH
62975: LD_INT 1
62977: PUSH
62978: LD_INT 0
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PUSH
62985: LD_INT 1
62987: PUSH
62988: LD_INT 1
62990: PUSH
62991: EMPTY
62992: LIST
62993: LIST
62994: PUSH
62995: LD_INT 0
62997: PUSH
62998: LD_INT 1
63000: PUSH
63001: EMPTY
63002: LIST
63003: LIST
63004: PUSH
63005: LD_INT 1
63007: NEG
63008: PUSH
63009: LD_INT 0
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PUSH
63016: LD_INT 1
63018: NEG
63019: PUSH
63020: LD_INT 1
63022: NEG
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: PUSH
63028: LD_INT 1
63030: NEG
63031: PUSH
63032: LD_INT 2
63034: NEG
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PUSH
63040: LD_INT 2
63042: PUSH
63043: LD_INT 1
63045: PUSH
63046: EMPTY
63047: LIST
63048: LIST
63049: PUSH
63050: LD_INT 2
63052: PUSH
63053: LD_INT 2
63055: PUSH
63056: EMPTY
63057: LIST
63058: LIST
63059: PUSH
63060: LD_INT 1
63062: PUSH
63063: LD_INT 2
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: PUSH
63070: LD_INT 2
63072: NEG
63073: PUSH
63074: LD_INT 1
63076: NEG
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: PUSH
63082: LD_INT 2
63084: NEG
63085: PUSH
63086: LD_INT 2
63088: NEG
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: PUSH
63094: LD_INT 3
63096: PUSH
63097: LD_INT 2
63099: PUSH
63100: EMPTY
63101: LIST
63102: LIST
63103: PUSH
63104: LD_INT 3
63106: PUSH
63107: LD_INT 3
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PUSH
63114: LD_INT 2
63116: PUSH
63117: LD_INT 3
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PUSH
63124: EMPTY
63125: LIST
63126: LIST
63127: LIST
63128: LIST
63129: LIST
63130: LIST
63131: LIST
63132: LIST
63133: LIST
63134: LIST
63135: LIST
63136: LIST
63137: LIST
63138: LIST
63139: LIST
63140: LIST
63141: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63142: LD_ADDR_VAR 0 17
63146: PUSH
63147: LD_INT 0
63149: PUSH
63150: LD_INT 0
63152: PUSH
63153: EMPTY
63154: LIST
63155: LIST
63156: PUSH
63157: LD_INT 0
63159: PUSH
63160: LD_INT 1
63162: NEG
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: PUSH
63168: LD_INT 1
63170: PUSH
63171: LD_INT 0
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: PUSH
63178: LD_INT 1
63180: PUSH
63181: LD_INT 1
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PUSH
63188: LD_INT 0
63190: PUSH
63191: LD_INT 1
63193: PUSH
63194: EMPTY
63195: LIST
63196: LIST
63197: PUSH
63198: LD_INT 1
63200: NEG
63201: PUSH
63202: LD_INT 0
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 1
63211: NEG
63212: PUSH
63213: LD_INT 1
63215: NEG
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 1
63223: NEG
63224: PUSH
63225: LD_INT 2
63227: NEG
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: PUSH
63233: LD_INT 0
63235: PUSH
63236: LD_INT 2
63238: NEG
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: LD_INT 1
63246: PUSH
63247: LD_INT 1
63249: NEG
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: PUSH
63255: LD_INT 2
63257: PUSH
63258: LD_INT 0
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: PUSH
63265: LD_INT 2
63267: PUSH
63268: LD_INT 1
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: PUSH
63275: LD_INT 2
63277: PUSH
63278: LD_INT 2
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: LD_INT 1
63287: PUSH
63288: LD_INT 2
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PUSH
63295: LD_INT 0
63297: PUSH
63298: LD_INT 2
63300: PUSH
63301: EMPTY
63302: LIST
63303: LIST
63304: PUSH
63305: LD_INT 1
63307: NEG
63308: PUSH
63309: LD_INT 1
63311: PUSH
63312: EMPTY
63313: LIST
63314: LIST
63315: PUSH
63316: LD_INT 2
63318: NEG
63319: PUSH
63320: LD_INT 0
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 2
63329: NEG
63330: PUSH
63331: LD_INT 1
63333: NEG
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 2
63341: NEG
63342: PUSH
63343: LD_INT 2
63345: NEG
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: LIST
63363: LIST
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63372: LD_ADDR_VAR 0 18
63376: PUSH
63377: LD_INT 0
63379: PUSH
63380: LD_INT 0
63382: PUSH
63383: EMPTY
63384: LIST
63385: LIST
63386: PUSH
63387: LD_INT 0
63389: PUSH
63390: LD_INT 1
63392: NEG
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 1
63400: PUSH
63401: LD_INT 0
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: PUSH
63408: LD_INT 1
63410: PUSH
63411: LD_INT 1
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: PUSH
63418: LD_INT 0
63420: PUSH
63421: LD_INT 1
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: PUSH
63428: LD_INT 1
63430: NEG
63431: PUSH
63432: LD_INT 0
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: PUSH
63439: LD_INT 1
63441: NEG
63442: PUSH
63443: LD_INT 1
63445: NEG
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PUSH
63451: LD_INT 1
63453: NEG
63454: PUSH
63455: LD_INT 2
63457: NEG
63458: PUSH
63459: EMPTY
63460: LIST
63461: LIST
63462: PUSH
63463: LD_INT 0
63465: PUSH
63466: LD_INT 2
63468: NEG
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PUSH
63474: LD_INT 1
63476: PUSH
63477: LD_INT 1
63479: NEG
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 2
63487: PUSH
63488: LD_INT 0
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: PUSH
63495: LD_INT 2
63497: PUSH
63498: LD_INT 1
63500: PUSH
63501: EMPTY
63502: LIST
63503: LIST
63504: PUSH
63505: LD_INT 2
63507: PUSH
63508: LD_INT 2
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: PUSH
63515: LD_INT 1
63517: PUSH
63518: LD_INT 2
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: PUSH
63525: LD_INT 0
63527: PUSH
63528: LD_INT 2
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 1
63537: NEG
63538: PUSH
63539: LD_INT 1
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: LD_INT 2
63548: NEG
63549: PUSH
63550: LD_INT 0
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 2
63559: NEG
63560: PUSH
63561: LD_INT 1
63563: NEG
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 2
63571: NEG
63572: PUSH
63573: LD_INT 2
63575: NEG
63576: PUSH
63577: EMPTY
63578: LIST
63579: LIST
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: LIST
63587: LIST
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: LIST
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: LIST
63601: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63602: LD_ADDR_VAR 0 19
63606: PUSH
63607: LD_INT 0
63609: PUSH
63610: LD_INT 0
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PUSH
63617: LD_INT 0
63619: PUSH
63620: LD_INT 1
63622: NEG
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: LD_INT 1
63630: PUSH
63631: LD_INT 0
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: PUSH
63638: LD_INT 1
63640: PUSH
63641: LD_INT 1
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PUSH
63648: LD_INT 0
63650: PUSH
63651: LD_INT 1
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PUSH
63658: LD_INT 1
63660: NEG
63661: PUSH
63662: LD_INT 0
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: PUSH
63669: LD_INT 1
63671: NEG
63672: PUSH
63673: LD_INT 1
63675: NEG
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PUSH
63681: LD_INT 1
63683: NEG
63684: PUSH
63685: LD_INT 2
63687: NEG
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: PUSH
63693: LD_INT 0
63695: PUSH
63696: LD_INT 2
63698: NEG
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 1
63706: PUSH
63707: LD_INT 1
63709: NEG
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: PUSH
63715: LD_INT 2
63717: PUSH
63718: LD_INT 0
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: PUSH
63725: LD_INT 2
63727: PUSH
63728: LD_INT 1
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 2
63737: PUSH
63738: LD_INT 2
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: LD_INT 2
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: LD_INT 2
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: LD_INT 1
63767: NEG
63768: PUSH
63769: LD_INT 1
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: PUSH
63776: LD_INT 2
63778: NEG
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 2
63789: NEG
63790: PUSH
63791: LD_INT 1
63793: NEG
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: LD_INT 2
63801: NEG
63802: PUSH
63803: LD_INT 2
63805: NEG
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: LIST
63815: LIST
63816: LIST
63817: LIST
63818: LIST
63819: LIST
63820: LIST
63821: LIST
63822: LIST
63823: LIST
63824: LIST
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63832: LD_ADDR_VAR 0 20
63836: PUSH
63837: LD_INT 0
63839: PUSH
63840: LD_INT 0
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: LD_INT 0
63849: PUSH
63850: LD_INT 1
63852: NEG
63853: PUSH
63854: EMPTY
63855: LIST
63856: LIST
63857: PUSH
63858: LD_INT 1
63860: PUSH
63861: LD_INT 0
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PUSH
63868: LD_INT 1
63870: PUSH
63871: LD_INT 1
63873: PUSH
63874: EMPTY
63875: LIST
63876: LIST
63877: PUSH
63878: LD_INT 0
63880: PUSH
63881: LD_INT 1
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 1
63890: NEG
63891: PUSH
63892: LD_INT 0
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 1
63901: NEG
63902: PUSH
63903: LD_INT 1
63905: NEG
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: PUSH
63911: LD_INT 1
63913: NEG
63914: PUSH
63915: LD_INT 2
63917: NEG
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PUSH
63923: LD_INT 0
63925: PUSH
63926: LD_INT 2
63928: NEG
63929: PUSH
63930: EMPTY
63931: LIST
63932: LIST
63933: PUSH
63934: LD_INT 1
63936: PUSH
63937: LD_INT 1
63939: NEG
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 2
63947: PUSH
63948: LD_INT 0
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 2
63957: PUSH
63958: LD_INT 1
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: PUSH
63965: LD_INT 2
63967: PUSH
63968: LD_INT 2
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: PUSH
63978: LD_INT 2
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PUSH
63985: LD_INT 0
63987: PUSH
63988: LD_INT 2
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: PUSH
63995: LD_INT 1
63997: NEG
63998: PUSH
63999: LD_INT 1
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 2
64008: NEG
64009: PUSH
64010: LD_INT 0
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 2
64019: NEG
64020: PUSH
64021: LD_INT 1
64023: NEG
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PUSH
64029: LD_INT 2
64031: NEG
64032: PUSH
64033: LD_INT 2
64035: NEG
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64062: LD_ADDR_VAR 0 21
64066: PUSH
64067: LD_INT 0
64069: PUSH
64070: LD_INT 0
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: LD_INT 0
64079: PUSH
64080: LD_INT 1
64082: NEG
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PUSH
64088: LD_INT 1
64090: PUSH
64091: LD_INT 0
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: LD_INT 1
64100: PUSH
64101: LD_INT 1
64103: PUSH
64104: EMPTY
64105: LIST
64106: LIST
64107: PUSH
64108: LD_INT 0
64110: PUSH
64111: LD_INT 1
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: PUSH
64118: LD_INT 1
64120: NEG
64121: PUSH
64122: LD_INT 0
64124: PUSH
64125: EMPTY
64126: LIST
64127: LIST
64128: PUSH
64129: LD_INT 1
64131: NEG
64132: PUSH
64133: LD_INT 1
64135: NEG
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PUSH
64141: LD_INT 1
64143: NEG
64144: PUSH
64145: LD_INT 2
64147: NEG
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 0
64155: PUSH
64156: LD_INT 2
64158: NEG
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 1
64166: PUSH
64167: LD_INT 1
64169: NEG
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: PUSH
64175: LD_INT 2
64177: PUSH
64178: LD_INT 0
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 2
64187: PUSH
64188: LD_INT 1
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PUSH
64195: LD_INT 2
64197: PUSH
64198: LD_INT 2
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 1
64207: PUSH
64208: LD_INT 2
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: LD_INT 0
64217: PUSH
64218: LD_INT 2
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 1
64227: NEG
64228: PUSH
64229: LD_INT 1
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 2
64238: NEG
64239: PUSH
64240: LD_INT 0
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: PUSH
64247: LD_INT 2
64249: NEG
64250: PUSH
64251: LD_INT 1
64253: NEG
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: PUSH
64259: LD_INT 2
64261: NEG
64262: PUSH
64263: LD_INT 2
64265: NEG
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64292: LD_ADDR_VAR 0 22
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: LD_INT 0
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: LD_INT 0
64309: PUSH
64310: LD_INT 1
64312: NEG
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PUSH
64318: LD_INT 1
64320: PUSH
64321: LD_INT 0
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: LD_INT 1
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: EMPTY
64335: LIST
64336: LIST
64337: PUSH
64338: LD_INT 0
64340: PUSH
64341: LD_INT 1
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 1
64350: NEG
64351: PUSH
64352: LD_INT 0
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 1
64361: NEG
64362: PUSH
64363: LD_INT 1
64365: NEG
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: LD_INT 1
64373: NEG
64374: PUSH
64375: LD_INT 2
64377: NEG
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 0
64385: PUSH
64386: LD_INT 2
64388: NEG
64389: PUSH
64390: EMPTY
64391: LIST
64392: LIST
64393: PUSH
64394: LD_INT 1
64396: PUSH
64397: LD_INT 1
64399: NEG
64400: PUSH
64401: EMPTY
64402: LIST
64403: LIST
64404: PUSH
64405: LD_INT 2
64407: PUSH
64408: LD_INT 0
64410: PUSH
64411: EMPTY
64412: LIST
64413: LIST
64414: PUSH
64415: LD_INT 2
64417: PUSH
64418: LD_INT 1
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 2
64427: PUSH
64428: LD_INT 2
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 1
64437: PUSH
64438: LD_INT 2
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 0
64447: PUSH
64448: LD_INT 2
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 1
64457: NEG
64458: PUSH
64459: LD_INT 1
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 2
64468: NEG
64469: PUSH
64470: LD_INT 0
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PUSH
64477: LD_INT 2
64479: NEG
64480: PUSH
64481: LD_INT 1
64483: NEG
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PUSH
64489: LD_INT 2
64491: NEG
64492: PUSH
64493: LD_INT 2
64495: NEG
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
64522: LD_ADDR_VAR 0 23
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: LD_INT 0
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PUSH
64537: LD_INT 0
64539: PUSH
64540: LD_INT 1
64542: NEG
64543: PUSH
64544: EMPTY
64545: LIST
64546: LIST
64547: PUSH
64548: LD_INT 1
64550: PUSH
64551: LD_INT 0
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 1
64560: PUSH
64561: LD_INT 1
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: LD_INT 1
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PUSH
64578: LD_INT 1
64580: NEG
64581: PUSH
64582: LD_INT 0
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: NEG
64592: PUSH
64593: LD_INT 1
64595: NEG
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: PUSH
64601: LD_INT 1
64603: NEG
64604: PUSH
64605: LD_INT 2
64607: NEG
64608: PUSH
64609: EMPTY
64610: LIST
64611: LIST
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: LD_INT 2
64618: NEG
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: PUSH
64624: LD_INT 1
64626: PUSH
64627: LD_INT 1
64629: NEG
64630: PUSH
64631: EMPTY
64632: LIST
64633: LIST
64634: PUSH
64635: LD_INT 2
64637: PUSH
64638: LD_INT 0
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 2
64647: PUSH
64648: LD_INT 1
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 2
64657: PUSH
64658: LD_INT 2
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: LD_INT 1
64667: PUSH
64668: LD_INT 2
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: PUSH
64675: LD_INT 0
64677: PUSH
64678: LD_INT 2
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 1
64687: NEG
64688: PUSH
64689: LD_INT 1
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 2
64698: NEG
64699: PUSH
64700: LD_INT 0
64702: PUSH
64703: EMPTY
64704: LIST
64705: LIST
64706: PUSH
64707: LD_INT 2
64709: NEG
64710: PUSH
64711: LD_INT 1
64713: NEG
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: LD_INT 2
64721: NEG
64722: PUSH
64723: LD_INT 2
64725: NEG
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: LD_INT 2
64733: NEG
64734: PUSH
64735: LD_INT 3
64737: NEG
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 1
64745: NEG
64746: PUSH
64747: LD_INT 3
64749: NEG
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 1
64757: PUSH
64758: LD_INT 2
64760: NEG
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 2
64768: PUSH
64769: LD_INT 1
64771: NEG
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: LIST
64788: LIST
64789: LIST
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
64802: LD_ADDR_VAR 0 24
64806: PUSH
64807: LD_INT 0
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 0
64819: PUSH
64820: LD_INT 1
64822: NEG
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 1
64830: PUSH
64831: LD_INT 0
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 1
64840: PUSH
64841: LD_INT 1
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: LD_INT 1
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PUSH
64858: LD_INT 1
64860: NEG
64861: PUSH
64862: LD_INT 0
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: NEG
64872: PUSH
64873: LD_INT 1
64875: NEG
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 1
64883: NEG
64884: PUSH
64885: LD_INT 2
64887: NEG
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: LD_INT 0
64895: PUSH
64896: LD_INT 2
64898: NEG
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: PUSH
64904: LD_INT 1
64906: PUSH
64907: LD_INT 1
64909: NEG
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 2
64917: PUSH
64918: LD_INT 0
64920: PUSH
64921: EMPTY
64922: LIST
64923: LIST
64924: PUSH
64925: LD_INT 2
64927: PUSH
64928: LD_INT 1
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: LD_INT 2
64937: PUSH
64938: LD_INT 2
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PUSH
64945: LD_INT 1
64947: PUSH
64948: LD_INT 2
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: PUSH
64955: LD_INT 0
64957: PUSH
64958: LD_INT 2
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 1
64967: NEG
64968: PUSH
64969: LD_INT 1
64971: PUSH
64972: EMPTY
64973: LIST
64974: LIST
64975: PUSH
64976: LD_INT 2
64978: NEG
64979: PUSH
64980: LD_INT 0
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 2
64989: NEG
64990: PUSH
64991: LD_INT 1
64993: NEG
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 2
65001: NEG
65002: PUSH
65003: LD_INT 2
65005: NEG
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 1
65013: PUSH
65014: LD_INT 2
65016: NEG
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: LD_INT 2
65024: PUSH
65025: LD_INT 1
65027: NEG
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PUSH
65033: LD_INT 3
65035: PUSH
65036: LD_INT 1
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 3
65045: PUSH
65046: LD_INT 2
65048: PUSH
65049: EMPTY
65050: LIST
65051: LIST
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: LIST
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: LIST
65062: LIST
65063: LIST
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: LIST
65075: LIST
65076: LIST
65077: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65078: LD_ADDR_VAR 0 25
65082: PUSH
65083: LD_INT 0
65085: PUSH
65086: LD_INT 0
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: PUSH
65093: LD_INT 0
65095: PUSH
65096: LD_INT 1
65098: NEG
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 1
65106: PUSH
65107: LD_INT 0
65109: PUSH
65110: EMPTY
65111: LIST
65112: LIST
65113: PUSH
65114: LD_INT 1
65116: PUSH
65117: LD_INT 1
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 0
65126: PUSH
65127: LD_INT 1
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: LD_INT 1
65136: NEG
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 1
65147: NEG
65148: PUSH
65149: LD_INT 1
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 1
65159: NEG
65160: PUSH
65161: LD_INT 2
65163: NEG
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: LD_INT 2
65174: NEG
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 1
65185: NEG
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 2
65193: PUSH
65194: LD_INT 0
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: LD_INT 2
65203: PUSH
65204: LD_INT 1
65206: PUSH
65207: EMPTY
65208: LIST
65209: LIST
65210: PUSH
65211: LD_INT 2
65213: PUSH
65214: LD_INT 2
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: PUSH
65224: LD_INT 2
65226: PUSH
65227: EMPTY
65228: LIST
65229: LIST
65230: PUSH
65231: LD_INT 0
65233: PUSH
65234: LD_INT 2
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: LD_INT 1
65243: NEG
65244: PUSH
65245: LD_INT 1
65247: PUSH
65248: EMPTY
65249: LIST
65250: LIST
65251: PUSH
65252: LD_INT 2
65254: NEG
65255: PUSH
65256: LD_INT 0
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: LD_INT 2
65265: NEG
65266: PUSH
65267: LD_INT 1
65269: NEG
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 2
65277: NEG
65278: PUSH
65279: LD_INT 2
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 3
65289: PUSH
65290: LD_INT 1
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 3
65299: PUSH
65300: LD_INT 2
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: LD_INT 3
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 1
65319: PUSH
65320: LD_INT 3
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
65352: LD_ADDR_VAR 0 26
65356: PUSH
65357: LD_INT 0
65359: PUSH
65360: LD_INT 0
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 0
65369: PUSH
65370: LD_INT 1
65372: NEG
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: LD_INT 1
65380: PUSH
65381: LD_INT 0
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: LD_INT 1
65390: PUSH
65391: LD_INT 1
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 0
65400: PUSH
65401: LD_INT 1
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 1
65410: NEG
65411: PUSH
65412: LD_INT 0
65414: PUSH
65415: EMPTY
65416: LIST
65417: LIST
65418: PUSH
65419: LD_INT 1
65421: NEG
65422: PUSH
65423: LD_INT 1
65425: NEG
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: LD_INT 2
65437: NEG
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 0
65445: PUSH
65446: LD_INT 2
65448: NEG
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 1
65456: PUSH
65457: LD_INT 1
65459: NEG
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PUSH
65465: LD_INT 2
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 2
65477: PUSH
65478: LD_INT 1
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 2
65487: PUSH
65488: LD_INT 2
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 1
65497: PUSH
65498: LD_INT 2
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 0
65507: PUSH
65508: LD_INT 2
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 1
65517: NEG
65518: PUSH
65519: LD_INT 1
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PUSH
65526: LD_INT 2
65528: NEG
65529: PUSH
65530: LD_INT 0
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 2
65539: NEG
65540: PUSH
65541: LD_INT 1
65543: NEG
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 2
65551: NEG
65552: PUSH
65553: LD_INT 2
65555: NEG
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 2
65563: PUSH
65564: LD_INT 3
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 1
65573: PUSH
65574: LD_INT 3
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 1
65583: NEG
65584: PUSH
65585: LD_INT 2
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 2
65594: NEG
65595: PUSH
65596: LD_INT 1
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65628: LD_ADDR_VAR 0 27
65632: PUSH
65633: LD_INT 0
65635: PUSH
65636: LD_INT 0
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 0
65645: PUSH
65646: LD_INT 1
65648: NEG
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: LD_INT 1
65656: PUSH
65657: LD_INT 0
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: LD_INT 1
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 0
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 1
65686: NEG
65687: PUSH
65688: LD_INT 0
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 1
65697: NEG
65698: PUSH
65699: LD_INT 1
65701: NEG
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: PUSH
65707: LD_INT 1
65709: NEG
65710: PUSH
65711: LD_INT 2
65713: NEG
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 0
65721: PUSH
65722: LD_INT 2
65724: NEG
65725: PUSH
65726: EMPTY
65727: LIST
65728: LIST
65729: PUSH
65730: LD_INT 1
65732: PUSH
65733: LD_INT 1
65735: NEG
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: LD_INT 2
65743: PUSH
65744: LD_INT 0
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 2
65753: PUSH
65754: LD_INT 1
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: LD_INT 2
65763: PUSH
65764: LD_INT 2
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: PUSH
65771: LD_INT 1
65773: PUSH
65774: LD_INT 2
65776: PUSH
65777: EMPTY
65778: LIST
65779: LIST
65780: PUSH
65781: LD_INT 0
65783: PUSH
65784: LD_INT 2
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 1
65793: NEG
65794: PUSH
65795: LD_INT 1
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 2
65804: NEG
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 2
65815: NEG
65816: PUSH
65817: LD_INT 1
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 2
65827: NEG
65828: PUSH
65829: LD_INT 2
65831: NEG
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 1
65839: NEG
65840: PUSH
65841: LD_INT 2
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 2
65850: NEG
65851: PUSH
65852: LD_INT 1
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 3
65861: NEG
65862: PUSH
65863: LD_INT 1
65865: NEG
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 3
65873: NEG
65874: PUSH
65875: LD_INT 2
65877: NEG
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65908: LD_ADDR_VAR 0 28
65912: PUSH
65913: LD_INT 0
65915: PUSH
65916: LD_INT 0
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PUSH
65923: LD_INT 0
65925: PUSH
65926: LD_INT 1
65928: NEG
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 1
65936: PUSH
65937: LD_INT 0
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 1
65946: PUSH
65947: LD_INT 1
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 0
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 1
65966: NEG
65967: PUSH
65968: LD_INT 0
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: NEG
65978: PUSH
65979: LD_INT 1
65981: NEG
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: LD_INT 2
65993: NEG
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: LD_INT 2
66004: NEG
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 1
66012: PUSH
66013: LD_INT 1
66015: NEG
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 2
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 2
66033: PUSH
66034: LD_INT 1
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 2
66043: PUSH
66044: LD_INT 2
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: LD_INT 1
66053: PUSH
66054: LD_INT 2
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 0
66063: PUSH
66064: LD_INT 2
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 1
66073: NEG
66074: PUSH
66075: LD_INT 1
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: LD_INT 2
66095: NEG
66096: PUSH
66097: LD_INT 1
66099: NEG
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 2
66107: NEG
66108: PUSH
66109: LD_INT 2
66111: NEG
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 2
66119: NEG
66120: PUSH
66121: LD_INT 3
66123: NEG
66124: PUSH
66125: EMPTY
66126: LIST
66127: LIST
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: LD_INT 3
66135: NEG
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 3
66143: NEG
66144: PUSH
66145: LD_INT 1
66147: NEG
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 3
66155: NEG
66156: PUSH
66157: LD_INT 2
66159: NEG
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66190: LD_ADDR_VAR 0 29
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 0
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 0
66207: PUSH
66208: LD_INT 1
66210: NEG
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: PUSH
66219: LD_INT 0
66221: PUSH
66222: EMPTY
66223: LIST
66224: LIST
66225: PUSH
66226: LD_INT 1
66228: PUSH
66229: LD_INT 1
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 0
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 1
66248: NEG
66249: PUSH
66250: LD_INT 0
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 1
66259: NEG
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 1
66271: NEG
66272: PUSH
66273: LD_INT 2
66275: NEG
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 0
66283: PUSH
66284: LD_INT 2
66286: NEG
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: PUSH
66295: LD_INT 1
66297: NEG
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 2
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 2
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 1
66325: PUSH
66326: LD_INT 2
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: LD_INT 0
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 1
66345: NEG
66346: PUSH
66347: LD_INT 1
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: PUSH
66354: LD_INT 2
66356: NEG
66357: PUSH
66358: LD_INT 1
66360: NEG
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 2
66368: NEG
66369: PUSH
66370: LD_INT 2
66372: NEG
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PUSH
66378: LD_INT 2
66380: NEG
66381: PUSH
66382: LD_INT 3
66384: NEG
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 2
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 3
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: LD_INT 3
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 1
66423: NEG
66424: PUSH
66425: LD_INT 2
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 3
66434: NEG
66435: PUSH
66436: LD_INT 2
66438: NEG
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: LIST
66468: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66469: LD_ADDR_VAR 0 30
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: LD_INT 0
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 0
66486: PUSH
66487: LD_INT 1
66489: NEG
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: LD_INT 1
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 0
66517: PUSH
66518: LD_INT 1
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 1
66527: NEG
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 1
66538: NEG
66539: PUSH
66540: LD_INT 1
66542: NEG
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 1
66550: NEG
66551: PUSH
66552: LD_INT 2
66554: NEG
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 2
66565: NEG
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 1
66573: PUSH
66574: LD_INT 1
66576: NEG
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 2
66584: PUSH
66585: LD_INT 0
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 2
66594: PUSH
66595: LD_INT 1
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: LD_INT 2
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: LD_INT 2
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: LD_INT 1
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 2
66635: NEG
66636: PUSH
66637: LD_INT 0
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 2
66646: NEG
66647: PUSH
66648: LD_INT 1
66650: NEG
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 1
66658: NEG
66659: PUSH
66660: LD_INT 3
66662: NEG
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 1
66670: PUSH
66671: LD_INT 2
66673: NEG
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: PUSH
66679: LD_INT 3
66681: PUSH
66682: LD_INT 2
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 2
66691: PUSH
66692: LD_INT 3
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: LD_INT 1
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PUSH
66710: LD_INT 3
66712: NEG
66713: PUSH
66714: LD_INT 1
66716: NEG
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66747: LD_ADDR_VAR 0 31
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: LD_INT 0
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 0
66764: PUSH
66765: LD_INT 1
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: LD_INT 1
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 0
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: NEG
66806: PUSH
66807: LD_INT 0
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 1
66816: NEG
66817: PUSH
66818: LD_INT 1
66820: NEG
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: NEG
66829: PUSH
66830: LD_INT 2
66832: NEG
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 1
66840: PUSH
66841: LD_INT 1
66843: NEG
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 2
66851: PUSH
66852: LD_INT 0
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 2
66861: PUSH
66862: LD_INT 1
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 2
66871: PUSH
66872: LD_INT 2
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 1
66881: PUSH
66882: LD_INT 2
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: LD_INT 2
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 1
66901: NEG
66902: PUSH
66903: LD_INT 1
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 2
66912: NEG
66913: PUSH
66914: LD_INT 1
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 2
66924: NEG
66925: PUSH
66926: LD_INT 2
66928: NEG
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 2
66936: NEG
66937: PUSH
66938: LD_INT 3
66940: NEG
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 2
66948: PUSH
66949: LD_INT 1
66951: NEG
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 3
66959: PUSH
66960: LD_INT 1
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 1
66969: PUSH
66970: LD_INT 3
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 1
66979: NEG
66980: PUSH
66981: LD_INT 2
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 3
66990: NEG
66991: PUSH
66992: LD_INT 2
66994: NEG
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67025: LD_ADDR_VAR 0 32
67029: PUSH
67030: LD_INT 0
67032: PUSH
67033: LD_INT 0
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 0
67042: PUSH
67043: LD_INT 1
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 1
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 0
67073: PUSH
67074: LD_INT 1
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 1
67083: NEG
67084: PUSH
67085: LD_INT 0
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 1
67094: NEG
67095: PUSH
67096: LD_INT 1
67098: NEG
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 1
67106: NEG
67107: PUSH
67108: LD_INT 2
67110: NEG
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: PUSH
67116: LD_INT 0
67118: PUSH
67119: LD_INT 2
67121: NEG
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: LD_INT 1
67129: PUSH
67130: LD_INT 1
67132: NEG
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 2
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 2
67150: PUSH
67151: LD_INT 2
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 1
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 0
67170: PUSH
67171: LD_INT 2
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: NEG
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: NEG
67192: PUSH
67193: LD_INT 0
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: PUSH
67200: LD_INT 2
67202: NEG
67203: PUSH
67204: LD_INT 1
67206: NEG
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PUSH
67212: LD_INT 1
67214: NEG
67215: PUSH
67216: LD_INT 3
67218: NEG
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: LD_INT 2
67229: NEG
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: PUSH
67235: LD_INT 3
67237: PUSH
67238: LD_INT 2
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 2
67247: PUSH
67248: LD_INT 3
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 2
67257: NEG
67258: PUSH
67259: LD_INT 1
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 3
67268: NEG
67269: PUSH
67270: LD_INT 1
67272: NEG
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67303: LD_ADDR_VAR 0 33
67307: PUSH
67308: LD_INT 0
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 0
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: LD_INT 0
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: LD_INT 1
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 0
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 1
67361: NEG
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 1
67372: NEG
67373: PUSH
67374: LD_INT 1
67376: NEG
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 1
67384: NEG
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: LD_INT 1
67399: NEG
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 2
67407: PUSH
67408: LD_INT 0
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 2
67417: PUSH
67418: LD_INT 1
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 1
67427: PUSH
67428: LD_INT 2
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 0
67437: PUSH
67438: LD_INT 2
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 1
67447: NEG
67448: PUSH
67449: LD_INT 1
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 2
67458: NEG
67459: PUSH
67460: LD_INT 0
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: LD_INT 2
67469: NEG
67470: PUSH
67471: LD_INT 1
67473: NEG
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: PUSH
67479: LD_INT 2
67481: NEG
67482: PUSH
67483: LD_INT 2
67485: NEG
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 2
67493: NEG
67494: PUSH
67495: LD_INT 3
67497: NEG
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 2
67505: PUSH
67506: LD_INT 1
67508: NEG
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 3
67516: PUSH
67517: LD_INT 1
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: LD_INT 3
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: LD_INT 2
67540: PUSH
67541: EMPTY
67542: LIST
67543: LIST
67544: PUSH
67545: LD_INT 3
67547: NEG
67548: PUSH
67549: LD_INT 2
67551: NEG
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67582: LD_ADDR_VAR 0 34
67586: PUSH
67587: LD_INT 0
67589: PUSH
67590: LD_INT 0
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: LD_INT 0
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 1
67610: PUSH
67611: LD_INT 0
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 1
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 1
67651: NEG
67652: PUSH
67653: LD_INT 1
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: LD_INT 2
67667: NEG
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 0
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 1
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 2
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: LD_INT 2
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 1
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 1
67727: NEG
67728: PUSH
67729: LD_INT 1
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 2
67738: NEG
67739: PUSH
67740: LD_INT 0
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 2
67749: NEG
67750: PUSH
67751: LD_INT 1
67753: NEG
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 2
67761: NEG
67762: PUSH
67763: LD_INT 2
67765: NEG
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 1
67773: NEG
67774: PUSH
67775: LD_INT 3
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: PUSH
67786: LD_INT 2
67788: NEG
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 3
67796: PUSH
67797: LD_INT 2
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 2
67806: PUSH
67807: LD_INT 3
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 3
67827: NEG
67828: PUSH
67829: LD_INT 1
67831: NEG
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67862: LD_ADDR_VAR 0 35
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: LD_INT 0
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 0
67879: PUSH
67880: LD_INT 1
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 1
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: LD_INT 1
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: LD_INT 1
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: LD_INT 1
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 2
67943: PUSH
67944: LD_INT 1
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 2
67953: NEG
67954: PUSH
67955: LD_INT 1
67957: NEG
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67974: LD_ADDR_VAR 0 36
67978: PUSH
67979: LD_INT 0
67981: PUSH
67982: LD_INT 0
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 0
67991: PUSH
67992: LD_INT 1
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 1
68002: PUSH
68003: LD_INT 0
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 1
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 0
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 1
68032: NEG
68033: PUSH
68034: LD_INT 0
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: PUSH
68045: LD_INT 1
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 1
68055: NEG
68056: PUSH
68057: LD_INT 2
68059: NEG
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 1
68067: PUSH
68068: LD_INT 2
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68086: LD_ADDR_VAR 0 37
68090: PUSH
68091: LD_INT 0
68093: PUSH
68094: LD_INT 0
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 1
68106: NEG
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PUSH
68112: LD_INT 1
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: PUSH
68125: LD_INT 1
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 0
68134: PUSH
68135: LD_INT 1
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 1
68144: NEG
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 1
68155: NEG
68156: PUSH
68157: LD_INT 1
68159: NEG
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: LD_INT 1
68170: NEG
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 1
68178: NEG
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68198: LD_ADDR_VAR 0 38
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: LD_INT 0
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 0
68215: PUSH
68216: LD_INT 1
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 0
68246: PUSH
68247: LD_INT 1
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: NEG
68257: PUSH
68258: LD_INT 0
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 1
68267: NEG
68268: PUSH
68269: LD_INT 1
68271: NEG
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 2
68289: NEG
68290: PUSH
68291: LD_INT 1
68293: NEG
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68310: LD_ADDR_VAR 0 39
68314: PUSH
68315: LD_INT 0
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 0
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 1
68368: NEG
68369: PUSH
68370: LD_INT 0
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: LD_INT 1
68383: NEG
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 1
68391: NEG
68392: PUSH
68393: LD_INT 2
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 1
68403: PUSH
68404: LD_INT 2
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68422: LD_ADDR_VAR 0 40
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: LD_INT 0
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: LD_INT 1
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 0
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 1
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 0
68470: PUSH
68471: LD_INT 1
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 1
68480: NEG
68481: PUSH
68482: LD_INT 0
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: LD_INT 1
68506: NEG
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 1
68514: NEG
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68534: LD_ADDR_VAR 0 41
68538: PUSH
68539: LD_INT 0
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 0
68551: PUSH
68552: LD_INT 1
68554: NEG
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: LD_INT 0
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: LD_INT 1
68572: PUSH
68573: LD_INT 1
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 0
68582: PUSH
68583: LD_INT 1
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 1
68592: NEG
68593: PUSH
68594: LD_INT 0
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 1
68603: NEG
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: LD_INT 2
68619: NEG
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: LD_INT 1
68630: NEG
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: PUSH
68636: LD_INT 2
68638: PUSH
68639: LD_INT 0
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 2
68648: PUSH
68649: LD_INT 1
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 2
68658: PUSH
68659: LD_INT 2
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: LD_INT 2
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: NEG
68679: PUSH
68680: LD_INT 1
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 2
68689: NEG
68690: PUSH
68691: LD_INT 0
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 2
68700: NEG
68701: PUSH
68702: LD_INT 1
68704: NEG
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 2
68712: NEG
68713: PUSH
68714: LD_INT 2
68716: NEG
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 2
68724: NEG
68725: PUSH
68726: LD_INT 3
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: PUSH
68737: LD_INT 1
68739: NEG
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 3
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 3
68757: PUSH
68758: LD_INT 1
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 3
68767: PUSH
68768: LD_INT 2
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 3
68777: PUSH
68778: LD_INT 3
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 2
68787: PUSH
68788: LD_INT 3
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: NEG
68798: PUSH
68799: LD_INT 1
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 3
68808: NEG
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 3
68819: NEG
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 3
68831: NEG
68832: PUSH
68833: LD_INT 2
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 3
68843: NEG
68844: PUSH
68845: LD_INT 3
68847: NEG
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68884: LD_ADDR_VAR 0 42
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: LD_INT 0
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 0
68901: PUSH
68902: LD_INT 1
68904: NEG
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 1
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: LD_INT 1
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 0
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 1
68942: NEG
68943: PUSH
68944: LD_INT 0
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: NEG
68954: PUSH
68955: LD_INT 1
68957: NEG
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: LD_INT 2
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 0
68977: PUSH
68978: LD_INT 2
68980: NEG
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 2
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 2
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: LD_INT 2
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 0
69029: PUSH
69030: LD_INT 2
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: LD_INT 1
69039: NEG
69040: PUSH
69041: LD_INT 1
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: NEG
69051: PUSH
69052: LD_INT 1
69054: NEG
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 2
69062: NEG
69063: PUSH
69064: LD_INT 2
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 2
69074: NEG
69075: PUSH
69076: LD_INT 3
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: LD_INT 3
69090: NEG
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: LD_INT 3
69101: NEG
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: LD_INT 2
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 3
69120: PUSH
69121: LD_INT 2
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 3
69130: PUSH
69131: LD_INT 3
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 2
69140: PUSH
69141: LD_INT 3
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 1
69150: PUSH
69151: LD_INT 3
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 0
69160: PUSH
69161: LD_INT 3
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 3
69181: NEG
69182: PUSH
69183: LD_INT 2
69185: NEG
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 3
69193: NEG
69194: PUSH
69195: LD_INT 3
69197: NEG
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69234: LD_ADDR_VAR 0 43
69238: PUSH
69239: LD_INT 0
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 0
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 0
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 1
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 0
69282: PUSH
69283: LD_INT 1
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 1
69292: NEG
69293: PUSH
69294: LD_INT 0
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 1
69303: NEG
69304: PUSH
69305: LD_INT 1
69307: NEG
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: LD_INT 2
69319: NEG
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: LD_INT 2
69330: NEG
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: PUSH
69339: LD_INT 1
69341: NEG
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 2
69349: PUSH
69350: LD_INT 0
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 2
69359: PUSH
69360: LD_INT 1
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: PUSH
69370: LD_INT 2
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: PUSH
69377: LD_INT 0
69379: PUSH
69380: LD_INT 2
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: LD_INT 1
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: LD_INT 2
69400: NEG
69401: PUSH
69402: LD_INT 0
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: LD_INT 2
69411: NEG
69412: PUSH
69413: LD_INT 1
69415: NEG
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 1
69423: NEG
69424: PUSH
69425: LD_INT 3
69427: NEG
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 0
69435: PUSH
69436: LD_INT 3
69438: NEG
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PUSH
69444: LD_INT 1
69446: PUSH
69447: LD_INT 2
69449: NEG
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 2
69457: PUSH
69458: LD_INT 1
69460: NEG
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 3
69468: PUSH
69469: LD_INT 0
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 3
69478: PUSH
69479: LD_INT 1
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 1
69488: PUSH
69489: LD_INT 3
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 0
69498: PUSH
69499: LD_INT 3
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 1
69508: NEG
69509: PUSH
69510: LD_INT 2
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: LD_INT 1
69523: PUSH
69524: EMPTY
69525: LIST
69526: LIST
69527: PUSH
69528: LD_INT 3
69530: NEG
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 3
69541: NEG
69542: PUSH
69543: LD_INT 1
69545: NEG
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69582: LD_ADDR_VAR 0 44
69586: PUSH
69587: LD_INT 0
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 1
69610: PUSH
69611: LD_INT 0
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 1
69620: PUSH
69621: LD_INT 1
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 0
69630: PUSH
69631: LD_INT 1
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: PUSH
69638: LD_INT 1
69640: NEG
69641: PUSH
69642: LD_INT 0
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 1
69651: NEG
69652: PUSH
69653: LD_INT 1
69655: NEG
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 1
69663: NEG
69664: PUSH
69665: LD_INT 2
69667: NEG
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 2
69686: PUSH
69687: LD_INT 0
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 2
69696: PUSH
69697: LD_INT 1
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: PUSH
69704: LD_INT 2
69706: PUSH
69707: LD_INT 2
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 1
69716: PUSH
69717: LD_INT 2
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: LD_INT 1
69726: NEG
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 2
69737: NEG
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 2
69748: NEG
69749: PUSH
69750: LD_INT 1
69752: NEG
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 2
69760: NEG
69761: PUSH
69762: LD_INT 2
69764: NEG
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 2
69772: NEG
69773: PUSH
69774: LD_INT 3
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 2
69784: PUSH
69785: LD_INT 1
69787: NEG
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 3
69795: PUSH
69796: LD_INT 0
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 3
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 3
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 3
69825: PUSH
69826: LD_INT 3
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 2
69835: PUSH
69836: LD_INT 3
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 2
69845: NEG
69846: PUSH
69847: LD_INT 1
69849: PUSH
69850: EMPTY
69851: LIST
69852: LIST
69853: PUSH
69854: LD_INT 3
69856: NEG
69857: PUSH
69858: LD_INT 0
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 3
69867: NEG
69868: PUSH
69869: LD_INT 1
69871: NEG
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 3
69879: NEG
69880: PUSH
69881: LD_INT 2
69883: NEG
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 3
69891: NEG
69892: PUSH
69893: LD_INT 3
69895: NEG
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: LIST
69924: LIST
69925: LIST
69926: LIST
69927: LIST
69928: LIST
69929: LIST
69930: LIST
69931: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69932: LD_ADDR_VAR 0 45
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: LD_INT 0
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 0
69949: PUSH
69950: LD_INT 1
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 1
69960: PUSH
69961: LD_INT 0
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 1
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: PUSH
69988: LD_INT 1
69990: NEG
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 1
70001: NEG
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 1
70013: NEG
70014: PUSH
70015: LD_INT 2
70017: NEG
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: LD_INT 0
70025: PUSH
70026: LD_INT 2
70028: NEG
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 2
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 2
70057: PUSH
70058: LD_INT 2
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 1
70067: PUSH
70068: LD_INT 2
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: LD_INT 2
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PUSH
70085: LD_INT 1
70087: NEG
70088: PUSH
70089: LD_INT 1
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 2
70098: NEG
70099: PUSH
70100: LD_INT 1
70102: NEG
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 2
70110: NEG
70111: PUSH
70112: LD_INT 2
70114: NEG
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 2
70122: NEG
70123: PUSH
70124: LD_INT 3
70126: NEG
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: NEG
70135: PUSH
70136: LD_INT 3
70138: NEG
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 0
70146: PUSH
70147: LD_INT 3
70149: NEG
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 3
70168: PUSH
70169: LD_INT 2
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 3
70178: PUSH
70179: LD_INT 3
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 2
70188: PUSH
70189: LD_INT 3
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 0
70208: PUSH
70209: LD_INT 3
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 1
70218: NEG
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 3
70229: NEG
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 3
70241: NEG
70242: PUSH
70243: LD_INT 3
70245: NEG
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70282: LD_ADDR_VAR 0 46
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: LD_INT 0
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 0
70299: PUSH
70300: LD_INT 1
70302: NEG
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: LD_INT 0
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 1
70320: PUSH
70321: LD_INT 1
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 1
70340: NEG
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: NEG
70352: PUSH
70353: LD_INT 1
70355: NEG
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 1
70363: NEG
70364: PUSH
70365: LD_INT 2
70367: NEG
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: LD_INT 2
70378: NEG
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 1
70389: NEG
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: LD_INT 2
70397: PUSH
70398: LD_INT 0
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 2
70407: PUSH
70408: LD_INT 1
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: PUSH
70418: LD_INT 2
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 2
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PUSH
70439: LD_INT 1
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 2
70448: NEG
70449: PUSH
70450: LD_INT 0
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: NEG
70460: PUSH
70461: LD_INT 1
70463: NEG
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: LD_INT 3
70475: NEG
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 0
70483: PUSH
70484: LD_INT 3
70486: NEG
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 1
70494: PUSH
70495: LD_INT 2
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 3
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 1
70536: PUSH
70537: LD_INT 3
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 0
70546: PUSH
70547: LD_INT 3
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 1
70556: NEG
70557: PUSH
70558: LD_INT 2
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 2
70567: NEG
70568: PUSH
70569: LD_INT 1
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 3
70578: NEG
70579: PUSH
70580: LD_INT 0
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 3
70589: NEG
70590: PUSH
70591: LD_INT 1
70593: NEG
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70630: LD_ADDR_VAR 0 47
70634: PUSH
70635: LD_INT 0
70637: PUSH
70638: LD_INT 0
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 0
70647: PUSH
70648: LD_INT 1
70650: NEG
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 1
70658: PUSH
70659: LD_INT 0
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 1
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 0
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PUSH
70686: LD_INT 1
70688: NEG
70689: PUSH
70690: LD_INT 0
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 1
70699: NEG
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: LD_INT 2
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 0
70723: PUSH
70724: LD_INT 2
70726: NEG
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 1
70734: PUSH
70735: LD_INT 1
70737: NEG
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 2
70745: NEG
70746: PUSH
70747: LD_INT 1
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 2
70757: NEG
70758: PUSH
70759: LD_INT 2
70761: NEG
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
70781: LD_ADDR_VAR 0 48
70785: PUSH
70786: LD_INT 0
70788: PUSH
70789: LD_INT 0
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 0
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 1
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 0
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: NEG
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 1
70850: NEG
70851: PUSH
70852: LD_INT 1
70854: NEG
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: LD_INT 1
70862: NEG
70863: PUSH
70864: LD_INT 2
70866: NEG
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 0
70874: PUSH
70875: LD_INT 2
70877: NEG
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: LD_INT 1
70888: NEG
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 2
70896: PUSH
70897: LD_INT 0
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 2
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70928: LD_ADDR_VAR 0 49
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: LD_INT 0
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 0
70945: PUSH
70946: LD_INT 1
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 1
70956: PUSH
70957: LD_INT 0
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: LD_INT 1
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 1
70986: NEG
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 1
70997: NEG
70998: PUSH
70999: LD_INT 1
71001: NEG
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 2
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 2
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 2
71040: PUSH
71041: LD_INT 2
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 1
71050: PUSH
71051: LD_INT 2
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71072: LD_ADDR_VAR 0 50
71076: PUSH
71077: LD_INT 0
71079: PUSH
71080: LD_INT 0
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 0
71089: PUSH
71090: LD_INT 1
71092: NEG
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PUSH
71098: LD_INT 1
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 1
71110: PUSH
71111: LD_INT 1
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 0
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 1
71130: NEG
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 1
71141: NEG
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 2
71153: PUSH
71154: LD_INT 1
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 2
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: PUSH
71174: LD_INT 2
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 0
71183: PUSH
71184: LD_INT 2
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 1
71193: NEG
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: LIST
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: LIST
71214: LIST
71215: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71216: LD_ADDR_VAR 0 51
71220: PUSH
71221: LD_INT 0
71223: PUSH
71224: LD_INT 0
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 0
71233: PUSH
71234: LD_INT 1
71236: NEG
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 1
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 1
71254: PUSH
71255: LD_INT 1
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 0
71264: PUSH
71265: LD_INT 1
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 1
71285: NEG
71286: PUSH
71287: LD_INT 1
71289: NEG
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 1
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 0
71307: PUSH
71308: LD_INT 2
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: NEG
71318: PUSH
71319: LD_INT 1
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 2
71328: NEG
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 2
71339: NEG
71340: PUSH
71341: LD_INT 1
71343: NEG
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71363: LD_ADDR_VAR 0 52
71367: PUSH
71368: LD_INT 0
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 0
71380: PUSH
71381: LD_INT 1
71383: NEG
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: LD_INT 0
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: LD_INT 1
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 0
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 1
71421: NEG
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 1
71432: NEG
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 2
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: NEG
71457: PUSH
71458: LD_INT 1
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 2
71467: NEG
71468: PUSH
71469: LD_INT 0
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 2
71478: NEG
71479: PUSH
71480: LD_INT 1
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 2
71490: NEG
71491: PUSH
71492: LD_INT 2
71494: NEG
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: LIST
71512: LIST
71513: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71514: LD_ADDR_VAR 0 53
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 0
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: LD_INT 1
71534: NEG
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: LD_INT 0
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 1
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: LD_INT 1
71565: PUSH
71566: EMPTY
71567: LIST
71568: LIST
71569: PUSH
71570: LD_INT 1
71572: NEG
71573: PUSH
71574: LD_INT 0
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 1
71587: NEG
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 1
71595: NEG
71596: PUSH
71597: LD_INT 2
71599: NEG
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 0
71607: PUSH
71608: LD_INT 2
71610: NEG
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 1
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 2
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 2
71639: PUSH
71640: LD_INT 1
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: LD_INT 2
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 1
71659: PUSH
71660: LD_INT 2
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 0
71669: PUSH
71670: LD_INT 2
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 1
71679: NEG
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 2
71690: NEG
71691: PUSH
71692: LD_INT 0
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 2
71701: NEG
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 2
71713: NEG
71714: PUSH
71715: LD_INT 2
71717: NEG
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: LIST
71742: LIST
71743: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71744: LD_ADDR_VAR 0 54
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: LD_INT 1
71764: NEG
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 1
71782: PUSH
71783: LD_INT 1
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 0
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 1
71802: NEG
71803: PUSH
71804: LD_INT 0
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: LD_INT 1
71813: NEG
71814: PUSH
71815: LD_INT 1
71817: NEG
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 1
71825: NEG
71826: PUSH
71827: LD_INT 2
71829: NEG
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 0
71837: PUSH
71838: LD_INT 2
71840: NEG
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: PUSH
71849: LD_INT 1
71851: NEG
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 2
71859: PUSH
71860: LD_INT 0
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 2
71869: PUSH
71870: LD_INT 1
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 2
71879: PUSH
71880: LD_INT 2
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 1
71889: PUSH
71890: LD_INT 2
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: LD_INT 2
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: NEG
71910: PUSH
71911: LD_INT 1
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 2
71920: NEG
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 2
71931: NEG
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 2
71943: NEG
71944: PUSH
71945: LD_INT 2
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71974: LD_ADDR_VAR 0 55
71978: PUSH
71979: LD_INT 0
71981: PUSH
71982: LD_INT 0
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 0
71991: PUSH
71992: LD_INT 1
71994: NEG
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 1
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 1
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: LD_INT 1
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: LD_INT 1
72032: NEG
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: NEG
72044: PUSH
72045: LD_INT 1
72047: NEG
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 1
72055: NEG
72056: PUSH
72057: LD_INT 2
72059: NEG
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: LD_INT 2
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: LD_INT 1
72081: NEG
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 2
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 2
72099: PUSH
72100: LD_INT 1
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 2
72109: PUSH
72110: LD_INT 2
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 1
72119: PUSH
72120: LD_INT 2
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: LD_INT 2
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 1
72139: NEG
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 2
72150: NEG
72151: PUSH
72152: LD_INT 0
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 2
72161: NEG
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 2
72173: NEG
72174: PUSH
72175: LD_INT 2
72177: NEG
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72204: LD_ADDR_VAR 0 56
72208: PUSH
72209: LD_INT 0
72211: PUSH
72212: LD_INT 0
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: LD_INT 1
72224: NEG
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: PUSH
72230: LD_INT 1
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 1
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 0
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 1
72262: NEG
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: NEG
72274: PUSH
72275: LD_INT 1
72277: NEG
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 1
72285: NEG
72286: PUSH
72287: LD_INT 2
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 0
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 1
72308: PUSH
72309: LD_INT 1
72311: NEG
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 2
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 2
72329: PUSH
72330: LD_INT 1
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: LD_INT 2
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: LD_INT 2
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 0
72359: PUSH
72360: LD_INT 2
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: LD_INT 1
72369: NEG
72370: PUSH
72371: LD_INT 1
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 2
72380: NEG
72381: PUSH
72382: LD_INT 0
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 2
72391: NEG
72392: PUSH
72393: LD_INT 1
72395: NEG
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 2
72403: NEG
72404: PUSH
72405: LD_INT 2
72407: NEG
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72434: LD_ADDR_VAR 0 57
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: LD_INT 0
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 0
72451: PUSH
72452: LD_INT 1
72454: NEG
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: LD_INT 0
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 1
72472: PUSH
72473: LD_INT 1
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: LD_INT 1
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: NEG
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: LD_INT 2
72519: NEG
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: LD_INT 2
72530: NEG
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 1
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 2
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 2
72559: PUSH
72560: LD_INT 1
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 2
72569: PUSH
72570: LD_INT 2
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 1
72579: PUSH
72580: LD_INT 2
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 0
72589: PUSH
72590: LD_INT 2
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PUSH
72597: LD_INT 1
72599: NEG
72600: PUSH
72601: LD_INT 1
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 2
72610: NEG
72611: PUSH
72612: LD_INT 0
72614: PUSH
72615: EMPTY
72616: LIST
72617: LIST
72618: PUSH
72619: LD_INT 2
72621: NEG
72622: PUSH
72623: LD_INT 1
72625: NEG
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 2
72633: NEG
72634: PUSH
72635: LD_INT 2
72637: NEG
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72664: LD_ADDR_VAR 0 58
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: LD_INT 0
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 0
72681: PUSH
72682: LD_INT 1
72684: NEG
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: PUSH
72693: LD_INT 0
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 1
72702: PUSH
72703: LD_INT 1
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 0
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 1
72722: NEG
72723: PUSH
72724: LD_INT 0
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: NEG
72746: PUSH
72747: LD_INT 2
72749: NEG
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: LD_INT 2
72760: NEG
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 2
72779: PUSH
72780: LD_INT 0
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 2
72789: PUSH
72790: LD_INT 1
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 2
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 1
72809: PUSH
72810: LD_INT 2
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 0
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: NEG
72830: PUSH
72831: LD_INT 1
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: LD_INT 2
72840: NEG
72841: PUSH
72842: LD_INT 0
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: LD_INT 2
72851: NEG
72852: PUSH
72853: LD_INT 1
72855: NEG
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: LD_INT 2
72863: NEG
72864: PUSH
72865: LD_INT 2
72867: NEG
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72894: LD_ADDR_VAR 0 59
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: LD_INT 0
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: LD_INT 1
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 1
72922: PUSH
72923: LD_INT 0
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 1
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: NEG
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: LIST
72981: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72982: LD_ADDR_VAR 0 60
72986: PUSH
72987: LD_INT 0
72989: PUSH
72990: LD_INT 0
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 0
72999: PUSH
73000: LD_INT 1
73002: NEG
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 1
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 1
73020: PUSH
73021: LD_INT 1
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 0
73030: PUSH
73031: LD_INT 1
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 1
73040: NEG
73041: PUSH
73042: LD_INT 0
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 1
73051: NEG
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73070: LD_ADDR_VAR 0 61
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 0
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 1
73098: PUSH
73099: LD_INT 0
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 1
73108: PUSH
73109: LD_INT 1
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 0
73118: PUSH
73119: LD_INT 1
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 1
73128: NEG
73129: PUSH
73130: LD_INT 0
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: LD_INT 1
73143: NEG
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73158: LD_ADDR_VAR 0 62
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 0
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: LD_INT 1
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 0
73206: PUSH
73207: LD_INT 1
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 1
73216: NEG
73217: PUSH
73218: LD_INT 0
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 1
73227: NEG
73228: PUSH
73229: LD_INT 1
73231: NEG
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: LIST
73243: LIST
73244: LIST
73245: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73246: LD_ADDR_VAR 0 63
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: LD_INT 0
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 0
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 1
73274: PUSH
73275: LD_INT 0
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: LD_INT 1
73284: PUSH
73285: LD_INT 1
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 0
73294: PUSH
73295: LD_INT 1
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: NEG
73305: PUSH
73306: LD_INT 0
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: LD_INT 1
73319: NEG
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: LIST
73329: LIST
73330: LIST
73331: LIST
73332: LIST
73333: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73334: LD_ADDR_VAR 0 64
73338: PUSH
73339: LD_INT 0
73341: PUSH
73342: LD_INT 0
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: LD_INT 1
73354: NEG
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: LD_INT 0
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 1
73372: PUSH
73373: LD_INT 1
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: LD_INT 1
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: LD_INT 0
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 1
73403: NEG
73404: PUSH
73405: LD_INT 1
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: ST_TO_ADDR
// end ; 1 :
73422: GO 79319
73424: LD_INT 1
73426: DOUBLE
73427: EQUAL
73428: IFTRUE 73432
73430: GO 76055
73432: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73433: LD_ADDR_VAR 0 11
73437: PUSH
73438: LD_INT 1
73440: NEG
73441: PUSH
73442: LD_INT 3
73444: NEG
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 0
73452: PUSH
73453: LD_INT 3
73455: NEG
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 1
73463: PUSH
73464: LD_INT 2
73466: NEG
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: LIST
73476: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73477: LD_ADDR_VAR 0 12
73481: PUSH
73482: LD_INT 2
73484: PUSH
73485: LD_INT 1
73487: NEG
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 3
73495: PUSH
73496: LD_INT 0
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: LD_INT 3
73505: PUSH
73506: LD_INT 1
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: LIST
73517: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73518: LD_ADDR_VAR 0 13
73522: PUSH
73523: LD_INT 3
73525: PUSH
73526: LD_INT 2
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 3
73535: PUSH
73536: LD_INT 3
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 2
73545: PUSH
73546: LD_INT 3
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: LIST
73557: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73558: LD_ADDR_VAR 0 14
73562: PUSH
73563: LD_INT 1
73565: PUSH
73566: LD_INT 3
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 0
73575: PUSH
73576: LD_INT 3
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 1
73585: NEG
73586: PUSH
73587: LD_INT 2
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73599: LD_ADDR_VAR 0 15
73603: PUSH
73604: LD_INT 2
73606: NEG
73607: PUSH
73608: LD_INT 1
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: PUSH
73615: LD_INT 3
73617: NEG
73618: PUSH
73619: LD_INT 0
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 3
73628: NEG
73629: PUSH
73630: LD_INT 1
73632: NEG
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: LIST
73642: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73643: LD_ADDR_VAR 0 16
73647: PUSH
73648: LD_INT 2
73650: NEG
73651: PUSH
73652: LD_INT 3
73654: NEG
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: LD_INT 3
73662: NEG
73663: PUSH
73664: LD_INT 2
73666: NEG
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 3
73674: NEG
73675: PUSH
73676: LD_INT 3
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: LIST
73688: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73689: LD_ADDR_VAR 0 17
73693: PUSH
73694: LD_INT 1
73696: NEG
73697: PUSH
73698: LD_INT 3
73700: NEG
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: LD_INT 3
73711: NEG
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: LD_INT 2
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: LIST
73732: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73733: LD_ADDR_VAR 0 18
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: LD_INT 1
73743: NEG
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 3
73751: PUSH
73752: LD_INT 0
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 3
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: LIST
73773: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73774: LD_ADDR_VAR 0 19
73778: PUSH
73779: LD_INT 3
73781: PUSH
73782: LD_INT 2
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 3
73791: PUSH
73792: LD_INT 3
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 2
73801: PUSH
73802: LD_INT 3
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: LIST
73813: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73814: LD_ADDR_VAR 0 20
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: LD_INT 3
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: LD_INT 2
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: LIST
73854: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73855: LD_ADDR_VAR 0 21
73859: PUSH
73860: LD_INT 2
73862: NEG
73863: PUSH
73864: LD_INT 1
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 3
73873: NEG
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 3
73884: NEG
73885: PUSH
73886: LD_INT 1
73888: NEG
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: LIST
73898: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73899: LD_ADDR_VAR 0 22
73903: PUSH
73904: LD_INT 2
73906: NEG
73907: PUSH
73908: LD_INT 3
73910: NEG
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 3
73918: NEG
73919: PUSH
73920: LD_INT 2
73922: NEG
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PUSH
73928: LD_INT 3
73930: NEG
73931: PUSH
73932: LD_INT 3
73934: NEG
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: LIST
73944: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
73945: LD_ADDR_VAR 0 23
73949: PUSH
73950: LD_INT 0
73952: PUSH
73953: LD_INT 3
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: PUSH
73965: LD_INT 4
73967: NEG
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: PUSH
73976: LD_INT 3
73978: NEG
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: LIST
73988: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
73989: LD_ADDR_VAR 0 24
73993: PUSH
73994: LD_INT 3
73996: PUSH
73997: LD_INT 0
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 3
74006: PUSH
74007: LD_INT 1
74009: NEG
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 4
74017: PUSH
74018: LD_INT 1
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: LIST
74029: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74030: LD_ADDR_VAR 0 25
74034: PUSH
74035: LD_INT 3
74037: PUSH
74038: LD_INT 3
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 4
74047: PUSH
74048: LD_INT 3
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 3
74057: PUSH
74058: LD_INT 4
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: LIST
74069: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74070: LD_ADDR_VAR 0 26
74074: PUSH
74075: LD_INT 0
74077: PUSH
74078: LD_INT 3
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 1
74087: PUSH
74088: LD_INT 4
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 1
74097: NEG
74098: PUSH
74099: LD_INT 3
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: LIST
74110: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74111: LD_ADDR_VAR 0 27
74115: PUSH
74116: LD_INT 3
74118: NEG
74119: PUSH
74120: LD_INT 0
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 3
74129: NEG
74130: PUSH
74131: LD_INT 1
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 4
74140: NEG
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: LIST
74154: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74155: LD_ADDR_VAR 0 28
74159: PUSH
74160: LD_INT 3
74162: NEG
74163: PUSH
74164: LD_INT 3
74166: NEG
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 3
74174: NEG
74175: PUSH
74176: LD_INT 4
74178: NEG
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 4
74186: NEG
74187: PUSH
74188: LD_INT 3
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: LIST
74200: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74201: LD_ADDR_VAR 0 29
74205: PUSH
74206: LD_INT 1
74208: NEG
74209: PUSH
74210: LD_INT 3
74212: NEG
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: LD_INT 3
74223: NEG
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 1
74231: PUSH
74232: LD_INT 2
74234: NEG
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 1
74242: NEG
74243: PUSH
74244: LD_INT 4
74246: NEG
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 0
74254: PUSH
74255: LD_INT 4
74257: NEG
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: PUSH
74266: LD_INT 3
74268: NEG
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: LD_INT 5
74280: NEG
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 0
74288: PUSH
74289: LD_INT 5
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 1
74299: PUSH
74300: LD_INT 4
74302: NEG
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 1
74310: NEG
74311: PUSH
74312: LD_INT 6
74314: NEG
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: LD_INT 6
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 1
74333: PUSH
74334: LD_INT 5
74336: NEG
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
74356: LD_ADDR_VAR 0 30
74360: PUSH
74361: LD_INT 2
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 3
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 3
74384: PUSH
74385: LD_INT 1
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 3
74394: PUSH
74395: LD_INT 1
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 4
74405: PUSH
74406: LD_INT 0
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 4
74415: PUSH
74416: LD_INT 1
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 4
74425: PUSH
74426: LD_INT 1
74428: NEG
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 5
74436: PUSH
74437: LD_INT 0
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 5
74446: PUSH
74447: LD_INT 1
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 5
74456: PUSH
74457: LD_INT 1
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 6
74467: PUSH
74468: LD_INT 0
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 6
74477: PUSH
74478: LD_INT 1
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
74499: LD_ADDR_VAR 0 31
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: LD_INT 2
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 3
74516: PUSH
74517: LD_INT 3
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 2
74526: PUSH
74527: LD_INT 3
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 4
74536: PUSH
74537: LD_INT 3
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 4
74546: PUSH
74547: LD_INT 4
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 3
74556: PUSH
74557: LD_INT 4
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 5
74566: PUSH
74567: LD_INT 4
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 5
74576: PUSH
74577: LD_INT 5
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 4
74586: PUSH
74587: LD_INT 5
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 6
74596: PUSH
74597: LD_INT 5
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 6
74606: PUSH
74607: LD_INT 6
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 5
74616: PUSH
74617: LD_INT 6
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
74638: LD_ADDR_VAR 0 32
74642: PUSH
74643: LD_INT 1
74645: PUSH
74646: LD_INT 3
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: LD_INT 3
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: PUSH
74663: LD_INT 1
74665: NEG
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: LD_INT 4
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 0
74686: PUSH
74687: LD_INT 4
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 3
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 1
74707: PUSH
74708: LD_INT 5
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 0
74717: PUSH
74718: LD_INT 5
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 1
74727: NEG
74728: PUSH
74729: LD_INT 4
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 1
74738: PUSH
74739: LD_INT 6
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 0
74748: PUSH
74749: LD_INT 6
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 1
74758: NEG
74759: PUSH
74760: LD_INT 5
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
74781: LD_ADDR_VAR 0 33
74785: PUSH
74786: LD_INT 2
74788: NEG
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 3
74799: NEG
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 3
74810: NEG
74811: PUSH
74812: LD_INT 1
74814: NEG
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 3
74822: NEG
74823: PUSH
74824: LD_INT 1
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 4
74833: NEG
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 4
74844: NEG
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 4
74856: NEG
74857: PUSH
74858: LD_INT 1
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 5
74867: NEG
74868: PUSH
74869: LD_INT 0
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 5
74878: NEG
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 5
74890: NEG
74891: PUSH
74892: LD_INT 1
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 6
74901: NEG
74902: PUSH
74903: LD_INT 0
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 6
74912: NEG
74913: PUSH
74914: LD_INT 1
74916: NEG
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: LIST
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
74936: LD_ADDR_VAR 0 34
74940: PUSH
74941: LD_INT 2
74943: NEG
74944: PUSH
74945: LD_INT 3
74947: NEG
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 3
74955: NEG
74956: PUSH
74957: LD_INT 2
74959: NEG
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 3
74967: NEG
74968: PUSH
74969: LD_INT 3
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 3
74979: NEG
74980: PUSH
74981: LD_INT 4
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 4
74991: NEG
74992: PUSH
74993: LD_INT 3
74995: NEG
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 4
75003: NEG
75004: PUSH
75005: LD_INT 4
75007: NEG
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 4
75015: NEG
75016: PUSH
75017: LD_INT 5
75019: NEG
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 5
75027: NEG
75028: PUSH
75029: LD_INT 4
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 5
75039: NEG
75040: PUSH
75041: LD_INT 5
75043: NEG
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 5
75051: NEG
75052: PUSH
75053: LD_INT 6
75055: NEG
75056: PUSH
75057: EMPTY
75058: LIST
75059: LIST
75060: PUSH
75061: LD_INT 6
75063: NEG
75064: PUSH
75065: LD_INT 5
75067: NEG
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 6
75075: NEG
75076: PUSH
75077: LD_INT 6
75079: NEG
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75099: LD_ADDR_VAR 0 41
75103: PUSH
75104: LD_INT 0
75106: PUSH
75107: LD_INT 2
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 1
75117: NEG
75118: PUSH
75119: LD_INT 3
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 1
75129: PUSH
75130: LD_INT 2
75132: NEG
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: LIST
75142: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75143: LD_ADDR_VAR 0 42
75147: PUSH
75148: LD_INT 2
75150: PUSH
75151: LD_INT 0
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 2
75160: PUSH
75161: LD_INT 1
75163: NEG
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 3
75171: PUSH
75172: LD_INT 1
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: LIST
75183: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75184: LD_ADDR_VAR 0 43
75188: PUSH
75189: LD_INT 2
75191: PUSH
75192: LD_INT 2
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 3
75201: PUSH
75202: LD_INT 2
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 2
75211: PUSH
75212: LD_INT 3
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: LIST
75223: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75224: LD_ADDR_VAR 0 44
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: LD_INT 2
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 1
75241: PUSH
75242: LD_INT 3
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 2
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: LIST
75264: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75265: LD_ADDR_VAR 0 45
75269: PUSH
75270: LD_INT 2
75272: NEG
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: LD_INT 1
75298: NEG
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: LIST
75308: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
75309: LD_ADDR_VAR 0 46
75313: PUSH
75314: LD_INT 2
75316: NEG
75317: PUSH
75318: LD_INT 2
75320: NEG
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 2
75328: NEG
75329: PUSH
75330: LD_INT 3
75332: NEG
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 3
75340: NEG
75341: PUSH
75342: LD_INT 2
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: LIST
75354: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
75355: LD_ADDR_VAR 0 47
75359: PUSH
75360: LD_INT 2
75362: NEG
75363: PUSH
75364: LD_INT 3
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 1
75374: NEG
75375: PUSH
75376: LD_INT 3
75378: NEG
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
75388: LD_ADDR_VAR 0 48
75392: PUSH
75393: LD_INT 1
75395: PUSH
75396: LD_INT 2
75398: NEG
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 2
75406: PUSH
75407: LD_INT 1
75409: NEG
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
75419: LD_ADDR_VAR 0 49
75423: PUSH
75424: LD_INT 3
75426: PUSH
75427: LD_INT 1
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 3
75436: PUSH
75437: LD_INT 2
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
75448: LD_ADDR_VAR 0 50
75452: PUSH
75453: LD_INT 2
75455: PUSH
75456: LD_INT 3
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 1
75465: PUSH
75466: LD_INT 3
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
75477: LD_ADDR_VAR 0 51
75481: PUSH
75482: LD_INT 1
75484: NEG
75485: PUSH
75486: LD_INT 2
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 2
75495: NEG
75496: PUSH
75497: LD_INT 1
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75508: LD_ADDR_VAR 0 52
75512: PUSH
75513: LD_INT 3
75515: NEG
75516: PUSH
75517: LD_INT 1
75519: NEG
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 3
75527: NEG
75528: PUSH
75529: LD_INT 2
75531: NEG
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75541: LD_ADDR_VAR 0 53
75545: PUSH
75546: LD_INT 1
75548: NEG
75549: PUSH
75550: LD_INT 3
75552: NEG
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 0
75560: PUSH
75561: LD_INT 3
75563: NEG
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 1
75571: PUSH
75572: LD_INT 2
75574: NEG
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: LIST
75584: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75585: LD_ADDR_VAR 0 54
75589: PUSH
75590: LD_INT 2
75592: PUSH
75593: LD_INT 1
75595: NEG
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 3
75603: PUSH
75604: LD_INT 0
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: LD_INT 1
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: LIST
75625: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75626: LD_ADDR_VAR 0 55
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: LD_INT 2
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 3
75643: PUSH
75644: LD_INT 3
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 2
75653: PUSH
75654: LD_INT 3
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: LIST
75665: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75666: LD_ADDR_VAR 0 56
75670: PUSH
75671: LD_INT 1
75673: PUSH
75674: LD_INT 3
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 0
75683: PUSH
75684: LD_INT 3
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: LD_INT 2
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: LIST
75706: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75707: LD_ADDR_VAR 0 57
75711: PUSH
75712: LD_INT 2
75714: NEG
75715: PUSH
75716: LD_INT 1
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 3
75725: NEG
75726: PUSH
75727: LD_INT 0
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 3
75736: NEG
75737: PUSH
75738: LD_INT 1
75740: NEG
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: LIST
75750: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75751: LD_ADDR_VAR 0 58
75755: PUSH
75756: LD_INT 2
75758: NEG
75759: PUSH
75760: LD_INT 3
75762: NEG
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 3
75770: NEG
75771: PUSH
75772: LD_INT 2
75774: NEG
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 3
75782: NEG
75783: PUSH
75784: LD_INT 3
75786: NEG
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: LIST
75796: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
75797: LD_ADDR_VAR 0 59
75801: PUSH
75802: LD_INT 1
75804: NEG
75805: PUSH
75806: LD_INT 2
75808: NEG
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 0
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: LIST
75840: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75841: LD_ADDR_VAR 0 60
75845: PUSH
75846: LD_INT 1
75848: PUSH
75849: LD_INT 1
75851: NEG
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 2
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 2
75869: PUSH
75870: LD_INT 1
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: EMPTY
75878: LIST
75879: LIST
75880: LIST
75881: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75882: LD_ADDR_VAR 0 61
75886: PUSH
75887: LD_INT 2
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 2
75899: PUSH
75900: LD_INT 2
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 1
75909: PUSH
75910: LD_INT 2
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: LIST
75921: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75922: LD_ADDR_VAR 0 62
75926: PUSH
75927: LD_INT 1
75929: PUSH
75930: LD_INT 2
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 0
75939: PUSH
75940: LD_INT 2
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 1
75949: NEG
75950: PUSH
75951: LD_INT 1
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: LIST
75962: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75963: LD_ADDR_VAR 0 63
75967: PUSH
75968: LD_INT 1
75970: NEG
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 2
75981: NEG
75982: PUSH
75983: LD_INT 0
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 2
75992: NEG
75993: PUSH
75994: LD_INT 1
75996: NEG
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: LIST
76006: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76007: LD_ADDR_VAR 0 64
76011: PUSH
76012: LD_INT 1
76014: NEG
76015: PUSH
76016: LD_INT 2
76018: NEG
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 2
76026: NEG
76027: PUSH
76028: LD_INT 1
76030: NEG
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 2
76038: NEG
76039: PUSH
76040: LD_INT 2
76042: NEG
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: LIST
76052: ST_TO_ADDR
// end ; 2 :
76053: GO 79319
76055: LD_INT 2
76057: DOUBLE
76058: EQUAL
76059: IFTRUE 76063
76061: GO 79318
76063: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76064: LD_ADDR_VAR 0 29
76068: PUSH
76069: LD_INT 4
76071: PUSH
76072: LD_INT 0
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 4
76081: PUSH
76082: LD_INT 1
76084: NEG
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 5
76092: PUSH
76093: LD_INT 0
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: LD_INT 5
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 4
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 3
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 3
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 3
76143: PUSH
76144: LD_INT 2
76146: NEG
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 5
76154: PUSH
76155: LD_INT 2
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 3
76164: PUSH
76165: LD_INT 3
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 3
76174: PUSH
76175: LD_INT 2
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 4
76184: PUSH
76185: LD_INT 3
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 4
76194: PUSH
76195: LD_INT 4
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 3
76204: PUSH
76205: LD_INT 4
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 2
76214: PUSH
76215: LD_INT 3
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 2
76224: PUSH
76225: LD_INT 2
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 4
76234: PUSH
76235: LD_INT 2
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 2
76244: PUSH
76245: LD_INT 4
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 0
76254: PUSH
76255: LD_INT 4
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 0
76264: PUSH
76265: LD_INT 3
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 1
76274: PUSH
76275: LD_INT 4
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 1
76284: PUSH
76285: LD_INT 5
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 0
76294: PUSH
76295: LD_INT 5
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 1
76304: NEG
76305: PUSH
76306: LD_INT 4
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 1
76315: NEG
76316: PUSH
76317: LD_INT 3
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 2
76326: PUSH
76327: LD_INT 5
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 2
76336: NEG
76337: PUSH
76338: LD_INT 3
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 3
76347: NEG
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 3
76358: NEG
76359: PUSH
76360: LD_INT 1
76362: NEG
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 2
76370: NEG
76371: PUSH
76372: LD_INT 0
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 2
76381: NEG
76382: PUSH
76383: LD_INT 1
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: LD_INT 3
76392: NEG
76393: PUSH
76394: LD_INT 1
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 4
76403: NEG
76404: PUSH
76405: LD_INT 0
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 4
76414: NEG
76415: PUSH
76416: LD_INT 1
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 4
76426: NEG
76427: PUSH
76428: LD_INT 2
76430: NEG
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 2
76438: NEG
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 4
76449: NEG
76450: PUSH
76451: LD_INT 4
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 4
76461: NEG
76462: PUSH
76463: LD_INT 5
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 3
76473: NEG
76474: PUSH
76475: LD_INT 4
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 3
76485: NEG
76486: PUSH
76487: LD_INT 3
76489: NEG
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 4
76497: NEG
76498: PUSH
76499: LD_INT 3
76501: NEG
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: LD_INT 5
76509: NEG
76510: PUSH
76511: LD_INT 4
76513: NEG
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 5
76521: NEG
76522: PUSH
76523: LD_INT 5
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 3
76533: NEG
76534: PUSH
76535: LD_INT 5
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 5
76545: NEG
76546: PUSH
76547: LD_INT 3
76549: NEG
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: LIST
76588: LIST
76589: LIST
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
76602: LD_ADDR_VAR 0 30
76606: PUSH
76607: LD_INT 4
76609: PUSH
76610: LD_INT 4
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: LD_INT 4
76619: PUSH
76620: LD_INT 3
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 5
76629: PUSH
76630: LD_INT 4
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 5
76639: PUSH
76640: LD_INT 5
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 4
76649: PUSH
76650: LD_INT 5
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: LD_INT 4
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 3
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 5
76679: PUSH
76680: LD_INT 3
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 3
76689: PUSH
76690: LD_INT 5
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 3
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: LD_INT 3
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 1
76729: PUSH
76730: LD_INT 4
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: LD_INT 4
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 1
76749: NEG
76750: PUSH
76751: LD_INT 3
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 1
76760: NEG
76761: PUSH
76762: LD_INT 2
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 2
76771: PUSH
76772: LD_INT 4
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 2
76781: NEG
76782: PUSH
76783: LD_INT 2
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: PUSH
76790: LD_INT 4
76792: NEG
76793: PUSH
76794: LD_INT 0
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: PUSH
76801: LD_INT 4
76803: NEG
76804: PUSH
76805: LD_INT 1
76807: NEG
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 3
76815: NEG
76816: PUSH
76817: LD_INT 0
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 3
76826: NEG
76827: PUSH
76828: LD_INT 1
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 4
76837: NEG
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 5
76848: NEG
76849: PUSH
76850: LD_INT 0
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 5
76859: NEG
76860: PUSH
76861: LD_INT 1
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 5
76871: NEG
76872: PUSH
76873: LD_INT 2
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 3
76883: NEG
76884: PUSH
76885: LD_INT 2
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 3
76894: NEG
76895: PUSH
76896: LD_INT 3
76898: NEG
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 3
76906: NEG
76907: PUSH
76908: LD_INT 4
76910: NEG
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 2
76918: NEG
76919: PUSH
76920: LD_INT 3
76922: NEG
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 2
76930: NEG
76931: PUSH
76932: LD_INT 2
76934: NEG
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 3
76942: NEG
76943: PUSH
76944: LD_INT 2
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 4
76954: NEG
76955: PUSH
76956: LD_INT 3
76958: NEG
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 4
76966: NEG
76967: PUSH
76968: LD_INT 4
76970: NEG
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 2
76978: NEG
76979: PUSH
76980: LD_INT 4
76982: NEG
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 4
76990: NEG
76991: PUSH
76992: LD_INT 2
76994: NEG
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: LD_INT 4
77005: NEG
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 0
77013: PUSH
77014: LD_INT 5
77016: NEG
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 1
77024: PUSH
77025: LD_INT 4
77027: NEG
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 1
77035: PUSH
77036: LD_INT 3
77038: NEG
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 0
77046: PUSH
77047: LD_INT 3
77049: NEG
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 1
77057: NEG
77058: PUSH
77059: LD_INT 4
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: NEG
77070: PUSH
77071: LD_INT 5
77073: NEG
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 2
77081: PUSH
77082: LD_INT 3
77084: NEG
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 2
77092: NEG
77093: PUSH
77094: LD_INT 5
77096: NEG
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77149: LD_ADDR_VAR 0 31
77153: PUSH
77154: LD_INT 0
77156: PUSH
77157: LD_INT 4
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PUSH
77164: LD_INT 0
77166: PUSH
77167: LD_INT 3
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: LD_INT 4
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 1
77186: PUSH
77187: LD_INT 5
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 0
77196: PUSH
77197: LD_INT 5
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 1
77206: NEG
77207: PUSH
77208: LD_INT 4
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: LD_INT 3
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 2
77228: PUSH
77229: LD_INT 5
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 2
77238: NEG
77239: PUSH
77240: LD_INT 3
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 3
77249: NEG
77250: PUSH
77251: LD_INT 0
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 3
77260: NEG
77261: PUSH
77262: LD_INT 1
77264: NEG
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 2
77272: NEG
77273: PUSH
77274: LD_INT 0
77276: PUSH
77277: EMPTY
77278: LIST
77279: LIST
77280: PUSH
77281: LD_INT 2
77283: NEG
77284: PUSH
77285: LD_INT 1
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 3
77294: NEG
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 4
77305: NEG
77306: PUSH
77307: LD_INT 0
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 4
77316: NEG
77317: PUSH
77318: LD_INT 1
77320: NEG
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 4
77328: NEG
77329: PUSH
77330: LD_INT 2
77332: NEG
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 2
77340: NEG
77341: PUSH
77342: LD_INT 2
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 4
77351: NEG
77352: PUSH
77353: LD_INT 4
77355: NEG
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 4
77363: NEG
77364: PUSH
77365: LD_INT 5
77367: NEG
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 3
77375: NEG
77376: PUSH
77377: LD_INT 4
77379: NEG
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 3
77387: NEG
77388: PUSH
77389: LD_INT 3
77391: NEG
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 4
77399: NEG
77400: PUSH
77401: LD_INT 3
77403: NEG
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 5
77411: NEG
77412: PUSH
77413: LD_INT 4
77415: NEG
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 5
77423: NEG
77424: PUSH
77425: LD_INT 5
77427: NEG
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 3
77435: NEG
77436: PUSH
77437: LD_INT 5
77439: NEG
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 5
77447: NEG
77448: PUSH
77449: LD_INT 3
77451: NEG
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: LD_INT 3
77462: NEG
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: LD_INT 4
77473: NEG
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: PUSH
77482: LD_INT 3
77484: NEG
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 1
77492: PUSH
77493: LD_INT 2
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 2
77506: NEG
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 1
77514: NEG
77515: PUSH
77516: LD_INT 3
77518: NEG
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 1
77526: NEG
77527: PUSH
77528: LD_INT 4
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 2
77538: PUSH
77539: LD_INT 2
77541: NEG
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 2
77549: NEG
77550: PUSH
77551: LD_INT 4
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 4
77561: PUSH
77562: LD_INT 0
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 4
77571: PUSH
77572: LD_INT 1
77574: NEG
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 5
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 5
77592: PUSH
77593: LD_INT 1
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: LD_INT 4
77602: PUSH
77603: LD_INT 1
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 3
77612: PUSH
77613: LD_INT 0
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 3
77622: PUSH
77623: LD_INT 1
77625: NEG
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 3
77633: PUSH
77634: LD_INT 2
77636: NEG
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 5
77644: PUSH
77645: LD_INT 2
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
77699: LD_ADDR_VAR 0 32
77703: PUSH
77704: LD_INT 4
77706: NEG
77707: PUSH
77708: LD_INT 0
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 4
77717: NEG
77718: PUSH
77719: LD_INT 1
77721: NEG
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 3
77729: NEG
77730: PUSH
77731: LD_INT 0
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 3
77740: NEG
77741: PUSH
77742: LD_INT 1
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 4
77751: NEG
77752: PUSH
77753: LD_INT 1
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 5
77762: NEG
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 5
77773: NEG
77774: PUSH
77775: LD_INT 1
77777: NEG
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 5
77785: NEG
77786: PUSH
77787: LD_INT 2
77789: NEG
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 3
77797: NEG
77798: PUSH
77799: LD_INT 2
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 3
77808: NEG
77809: PUSH
77810: LD_INT 3
77812: NEG
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 3
77820: NEG
77821: PUSH
77822: LD_INT 4
77824: NEG
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 2
77832: NEG
77833: PUSH
77834: LD_INT 3
77836: NEG
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 2
77844: NEG
77845: PUSH
77846: LD_INT 2
77848: NEG
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 3
77856: NEG
77857: PUSH
77858: LD_INT 2
77860: NEG
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 4
77868: NEG
77869: PUSH
77870: LD_INT 3
77872: NEG
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 4
77880: NEG
77881: PUSH
77882: LD_INT 4
77884: NEG
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 2
77892: NEG
77893: PUSH
77894: LD_INT 4
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 4
77904: NEG
77905: PUSH
77906: LD_INT 2
77908: NEG
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 0
77916: PUSH
77917: LD_INT 4
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 0
77927: PUSH
77928: LD_INT 5
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 1
77938: PUSH
77939: LD_INT 4
77941: NEG
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 1
77949: PUSH
77950: LD_INT 3
77952: NEG
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 0
77960: PUSH
77961: LD_INT 3
77963: NEG
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 1
77971: NEG
77972: PUSH
77973: LD_INT 4
77975: NEG
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: PUSH
77981: LD_INT 1
77983: NEG
77984: PUSH
77985: LD_INT 5
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 2
77995: PUSH
77996: LD_INT 3
77998: NEG
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: LD_INT 2
78006: NEG
78007: PUSH
78008: LD_INT 5
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: PUSH
78019: LD_INT 0
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 3
78028: PUSH
78029: LD_INT 1
78031: NEG
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: LD_INT 4
78039: PUSH
78040: LD_INT 0
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 4
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 3
78059: PUSH
78060: LD_INT 1
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 2
78069: PUSH
78070: LD_INT 0
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 2
78079: PUSH
78080: LD_INT 1
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 2
78090: PUSH
78091: LD_INT 2
78093: NEG
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 4
78101: PUSH
78102: LD_INT 2
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 4
78111: PUSH
78112: LD_INT 4
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 4
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 5
78131: PUSH
78132: LD_INT 4
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 5
78141: PUSH
78142: LD_INT 5
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 4
78151: PUSH
78152: LD_INT 5
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 3
78161: PUSH
78162: LD_INT 4
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 3
78171: PUSH
78172: LD_INT 3
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 5
78181: PUSH
78182: LD_INT 3
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 3
78191: PUSH
78192: LD_INT 5
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: EMPTY
78200: LIST
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78246: LD_ADDR_VAR 0 33
78250: PUSH
78251: LD_INT 4
78253: NEG
78254: PUSH
78255: LD_INT 4
78257: NEG
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 4
78265: NEG
78266: PUSH
78267: LD_INT 5
78269: NEG
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: PUSH
78275: LD_INT 3
78277: NEG
78278: PUSH
78279: LD_INT 4
78281: NEG
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 3
78289: NEG
78290: PUSH
78291: LD_INT 3
78293: NEG
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 4
78301: NEG
78302: PUSH
78303: LD_INT 3
78305: NEG
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 5
78313: NEG
78314: PUSH
78315: LD_INT 4
78317: NEG
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 5
78325: NEG
78326: PUSH
78327: LD_INT 5
78329: NEG
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 3
78337: NEG
78338: PUSH
78339: LD_INT 5
78341: NEG
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: PUSH
78347: LD_INT 5
78349: NEG
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 0
78361: PUSH
78362: LD_INT 3
78364: NEG
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 0
78372: PUSH
78373: LD_INT 4
78375: NEG
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 1
78383: PUSH
78384: LD_INT 3
78386: NEG
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: LD_INT 2
78397: NEG
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 0
78405: PUSH
78406: LD_INT 2
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 1
78416: NEG
78417: PUSH
78418: LD_INT 3
78420: NEG
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 1
78428: NEG
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 2
78440: PUSH
78441: LD_INT 2
78443: NEG
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 2
78451: NEG
78452: PUSH
78453: LD_INT 4
78455: NEG
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 4
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 4
78473: PUSH
78474: LD_INT 1
78476: NEG
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 5
78484: PUSH
78485: LD_INT 0
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 5
78494: PUSH
78495: LD_INT 1
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 4
78504: PUSH
78505: LD_INT 1
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 3
78514: PUSH
78515: LD_INT 0
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 3
78524: PUSH
78525: LD_INT 1
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 3
78535: PUSH
78536: LD_INT 2
78538: NEG
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 5
78546: PUSH
78547: LD_INT 2
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 3
78556: PUSH
78557: LD_INT 3
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 3
78566: PUSH
78567: LD_INT 2
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 4
78576: PUSH
78577: LD_INT 3
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 4
78586: PUSH
78587: LD_INT 4
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 3
78596: PUSH
78597: LD_INT 4
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 2
78606: PUSH
78607: LD_INT 3
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 2
78616: PUSH
78617: LD_INT 2
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 4
78626: PUSH
78627: LD_INT 2
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 2
78636: PUSH
78637: LD_INT 4
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 0
78646: PUSH
78647: LD_INT 4
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PUSH
78654: LD_INT 0
78656: PUSH
78657: LD_INT 3
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 1
78666: PUSH
78667: LD_INT 4
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: LD_INT 5
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 0
78686: PUSH
78687: LD_INT 5
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 1
78696: NEG
78697: PUSH
78698: LD_INT 4
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 1
78707: NEG
78708: PUSH
78709: LD_INT 3
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 2
78718: PUSH
78719: LD_INT 5
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 2
78728: NEG
78729: PUSH
78730: LD_INT 3
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
78784: LD_ADDR_VAR 0 34
78788: PUSH
78789: LD_INT 0
78791: PUSH
78792: LD_INT 4
78794: NEG
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: LD_INT 5
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: LD_INT 4
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 1
78824: PUSH
78825: LD_INT 3
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 0
78835: PUSH
78836: LD_INT 3
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 1
78846: NEG
78847: PUSH
78848: LD_INT 4
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 1
78858: NEG
78859: PUSH
78860: LD_INT 5
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 2
78870: PUSH
78871: LD_INT 3
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 2
78881: NEG
78882: PUSH
78883: LD_INT 5
78885: NEG
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 3
78893: PUSH
78894: LD_INT 0
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 3
78903: PUSH
78904: LD_INT 1
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 4
78914: PUSH
78915: LD_INT 0
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 4
78924: PUSH
78925: LD_INT 1
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 3
78934: PUSH
78935: LD_INT 1
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 2
78944: PUSH
78945: LD_INT 0
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 2
78954: PUSH
78955: LD_INT 1
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 2
78965: PUSH
78966: LD_INT 2
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 4
78976: PUSH
78977: LD_INT 2
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 4
78986: PUSH
78987: LD_INT 4
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 4
78996: PUSH
78997: LD_INT 3
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: PUSH
79004: LD_INT 5
79006: PUSH
79007: LD_INT 4
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 5
79016: PUSH
79017: LD_INT 5
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: LD_INT 5
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 3
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: LD_INT 3
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 5
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 3
79066: PUSH
79067: LD_INT 5
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 0
79076: PUSH
79077: LD_INT 3
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 0
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 1
79096: PUSH
79097: LD_INT 3
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: PUSH
79107: LD_INT 4
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 0
79116: PUSH
79117: LD_INT 4
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 1
79126: NEG
79127: PUSH
79128: LD_INT 3
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: NEG
79138: PUSH
79139: LD_INT 2
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 2
79148: PUSH
79149: LD_INT 4
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 2
79158: NEG
79159: PUSH
79160: LD_INT 2
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 4
79169: NEG
79170: PUSH
79171: LD_INT 0
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 4
79180: NEG
79181: PUSH
79182: LD_INT 1
79184: NEG
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 3
79192: NEG
79193: PUSH
79194: LD_INT 0
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 3
79203: NEG
79204: PUSH
79205: LD_INT 1
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 4
79214: NEG
79215: PUSH
79216: LD_INT 1
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 5
79225: NEG
79226: PUSH
79227: LD_INT 0
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 5
79236: NEG
79237: PUSH
79238: LD_INT 1
79240: NEG
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 5
79248: NEG
79249: PUSH
79250: LD_INT 2
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 3
79260: NEG
79261: PUSH
79262: LD_INT 2
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: ST_TO_ADDR
// end ; end ;
79316: GO 79319
79318: POP
// case btype of b_depot , b_warehouse :
79319: LD_VAR 0 1
79323: PUSH
79324: LD_INT 0
79326: DOUBLE
79327: EQUAL
79328: IFTRUE 79338
79330: LD_INT 1
79332: DOUBLE
79333: EQUAL
79334: IFTRUE 79338
79336: GO 79539
79338: POP
// case nation of nation_american :
79339: LD_VAR 0 5
79343: PUSH
79344: LD_INT 1
79346: DOUBLE
79347: EQUAL
79348: IFTRUE 79352
79350: GO 79408
79352: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
79353: LD_ADDR_VAR 0 9
79357: PUSH
79358: LD_VAR 0 11
79362: PUSH
79363: LD_VAR 0 12
79367: PUSH
79368: LD_VAR 0 13
79372: PUSH
79373: LD_VAR 0 14
79377: PUSH
79378: LD_VAR 0 15
79382: PUSH
79383: LD_VAR 0 16
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: PUSH
79396: LD_VAR 0 4
79400: PUSH
79401: LD_INT 1
79403: PLUS
79404: ARRAY
79405: ST_TO_ADDR
79406: GO 79537
79408: LD_INT 2
79410: DOUBLE
79411: EQUAL
79412: IFTRUE 79416
79414: GO 79472
79416: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
79417: LD_ADDR_VAR 0 9
79421: PUSH
79422: LD_VAR 0 17
79426: PUSH
79427: LD_VAR 0 18
79431: PUSH
79432: LD_VAR 0 19
79436: PUSH
79437: LD_VAR 0 20
79441: PUSH
79442: LD_VAR 0 21
79446: PUSH
79447: LD_VAR 0 22
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: PUSH
79460: LD_VAR 0 4
79464: PUSH
79465: LD_INT 1
79467: PLUS
79468: ARRAY
79469: ST_TO_ADDR
79470: GO 79537
79472: LD_INT 3
79474: DOUBLE
79475: EQUAL
79476: IFTRUE 79480
79478: GO 79536
79480: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
79481: LD_ADDR_VAR 0 9
79485: PUSH
79486: LD_VAR 0 23
79490: PUSH
79491: LD_VAR 0 24
79495: PUSH
79496: LD_VAR 0 25
79500: PUSH
79501: LD_VAR 0 26
79505: PUSH
79506: LD_VAR 0 27
79510: PUSH
79511: LD_VAR 0 28
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: PUSH
79524: LD_VAR 0 4
79528: PUSH
79529: LD_INT 1
79531: PLUS
79532: ARRAY
79533: ST_TO_ADDR
79534: GO 79537
79536: POP
79537: GO 80092
79539: LD_INT 2
79541: DOUBLE
79542: EQUAL
79543: IFTRUE 79553
79545: LD_INT 3
79547: DOUBLE
79548: EQUAL
79549: IFTRUE 79553
79551: GO 79609
79553: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
79554: LD_ADDR_VAR 0 9
79558: PUSH
79559: LD_VAR 0 29
79563: PUSH
79564: LD_VAR 0 30
79568: PUSH
79569: LD_VAR 0 31
79573: PUSH
79574: LD_VAR 0 32
79578: PUSH
79579: LD_VAR 0 33
79583: PUSH
79584: LD_VAR 0 34
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: PUSH
79597: LD_VAR 0 4
79601: PUSH
79602: LD_INT 1
79604: PLUS
79605: ARRAY
79606: ST_TO_ADDR
79607: GO 80092
79609: LD_INT 16
79611: DOUBLE
79612: EQUAL
79613: IFTRUE 79671
79615: LD_INT 17
79617: DOUBLE
79618: EQUAL
79619: IFTRUE 79671
79621: LD_INT 18
79623: DOUBLE
79624: EQUAL
79625: IFTRUE 79671
79627: LD_INT 19
79629: DOUBLE
79630: EQUAL
79631: IFTRUE 79671
79633: LD_INT 22
79635: DOUBLE
79636: EQUAL
79637: IFTRUE 79671
79639: LD_INT 20
79641: DOUBLE
79642: EQUAL
79643: IFTRUE 79671
79645: LD_INT 21
79647: DOUBLE
79648: EQUAL
79649: IFTRUE 79671
79651: LD_INT 23
79653: DOUBLE
79654: EQUAL
79655: IFTRUE 79671
79657: LD_INT 24
79659: DOUBLE
79660: EQUAL
79661: IFTRUE 79671
79663: LD_INT 25
79665: DOUBLE
79666: EQUAL
79667: IFTRUE 79671
79669: GO 79727
79671: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
79672: LD_ADDR_VAR 0 9
79676: PUSH
79677: LD_VAR 0 35
79681: PUSH
79682: LD_VAR 0 36
79686: PUSH
79687: LD_VAR 0 37
79691: PUSH
79692: LD_VAR 0 38
79696: PUSH
79697: LD_VAR 0 39
79701: PUSH
79702: LD_VAR 0 40
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: PUSH
79715: LD_VAR 0 4
79719: PUSH
79720: LD_INT 1
79722: PLUS
79723: ARRAY
79724: ST_TO_ADDR
79725: GO 80092
79727: LD_INT 6
79729: DOUBLE
79730: EQUAL
79731: IFTRUE 79783
79733: LD_INT 7
79735: DOUBLE
79736: EQUAL
79737: IFTRUE 79783
79739: LD_INT 8
79741: DOUBLE
79742: EQUAL
79743: IFTRUE 79783
79745: LD_INT 13
79747: DOUBLE
79748: EQUAL
79749: IFTRUE 79783
79751: LD_INT 12
79753: DOUBLE
79754: EQUAL
79755: IFTRUE 79783
79757: LD_INT 15
79759: DOUBLE
79760: EQUAL
79761: IFTRUE 79783
79763: LD_INT 11
79765: DOUBLE
79766: EQUAL
79767: IFTRUE 79783
79769: LD_INT 14
79771: DOUBLE
79772: EQUAL
79773: IFTRUE 79783
79775: LD_INT 10
79777: DOUBLE
79778: EQUAL
79779: IFTRUE 79783
79781: GO 79839
79783: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
79784: LD_ADDR_VAR 0 9
79788: PUSH
79789: LD_VAR 0 41
79793: PUSH
79794: LD_VAR 0 42
79798: PUSH
79799: LD_VAR 0 43
79803: PUSH
79804: LD_VAR 0 44
79808: PUSH
79809: LD_VAR 0 45
79813: PUSH
79814: LD_VAR 0 46
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: PUSH
79827: LD_VAR 0 4
79831: PUSH
79832: LD_INT 1
79834: PLUS
79835: ARRAY
79836: ST_TO_ADDR
79837: GO 80092
79839: LD_INT 36
79841: DOUBLE
79842: EQUAL
79843: IFTRUE 79847
79845: GO 79903
79847: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
79848: LD_ADDR_VAR 0 9
79852: PUSH
79853: LD_VAR 0 47
79857: PUSH
79858: LD_VAR 0 48
79862: PUSH
79863: LD_VAR 0 49
79867: PUSH
79868: LD_VAR 0 50
79872: PUSH
79873: LD_VAR 0 51
79877: PUSH
79878: LD_VAR 0 52
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: PUSH
79891: LD_VAR 0 4
79895: PUSH
79896: LD_INT 1
79898: PLUS
79899: ARRAY
79900: ST_TO_ADDR
79901: GO 80092
79903: LD_INT 4
79905: DOUBLE
79906: EQUAL
79907: IFTRUE 79929
79909: LD_INT 5
79911: DOUBLE
79912: EQUAL
79913: IFTRUE 79929
79915: LD_INT 34
79917: DOUBLE
79918: EQUAL
79919: IFTRUE 79929
79921: LD_INT 37
79923: DOUBLE
79924: EQUAL
79925: IFTRUE 79929
79927: GO 79985
79929: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
79930: LD_ADDR_VAR 0 9
79934: PUSH
79935: LD_VAR 0 53
79939: PUSH
79940: LD_VAR 0 54
79944: PUSH
79945: LD_VAR 0 55
79949: PUSH
79950: LD_VAR 0 56
79954: PUSH
79955: LD_VAR 0 57
79959: PUSH
79960: LD_VAR 0 58
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: PUSH
79973: LD_VAR 0 4
79977: PUSH
79978: LD_INT 1
79980: PLUS
79981: ARRAY
79982: ST_TO_ADDR
79983: GO 80092
79985: LD_INT 31
79987: DOUBLE
79988: EQUAL
79989: IFTRUE 80035
79991: LD_INT 32
79993: DOUBLE
79994: EQUAL
79995: IFTRUE 80035
79997: LD_INT 33
79999: DOUBLE
80000: EQUAL
80001: IFTRUE 80035
80003: LD_INT 27
80005: DOUBLE
80006: EQUAL
80007: IFTRUE 80035
80009: LD_INT 26
80011: DOUBLE
80012: EQUAL
80013: IFTRUE 80035
80015: LD_INT 28
80017: DOUBLE
80018: EQUAL
80019: IFTRUE 80035
80021: LD_INT 29
80023: DOUBLE
80024: EQUAL
80025: IFTRUE 80035
80027: LD_INT 30
80029: DOUBLE
80030: EQUAL
80031: IFTRUE 80035
80033: GO 80091
80035: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80036: LD_ADDR_VAR 0 9
80040: PUSH
80041: LD_VAR 0 59
80045: PUSH
80046: LD_VAR 0 60
80050: PUSH
80051: LD_VAR 0 61
80055: PUSH
80056: LD_VAR 0 62
80060: PUSH
80061: LD_VAR 0 63
80065: PUSH
80066: LD_VAR 0 64
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: PUSH
80079: LD_VAR 0 4
80083: PUSH
80084: LD_INT 1
80086: PLUS
80087: ARRAY
80088: ST_TO_ADDR
80089: GO 80092
80091: POP
// temp_list2 = [ ] ;
80092: LD_ADDR_VAR 0 10
80096: PUSH
80097: EMPTY
80098: ST_TO_ADDR
// for i in temp_list do
80099: LD_ADDR_VAR 0 8
80103: PUSH
80104: LD_VAR 0 9
80108: PUSH
80109: FOR_IN
80110: IFFALSE 80162
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80112: LD_ADDR_VAR 0 10
80116: PUSH
80117: LD_VAR 0 10
80121: PUSH
80122: LD_VAR 0 8
80126: PUSH
80127: LD_INT 1
80129: ARRAY
80130: PUSH
80131: LD_VAR 0 2
80135: PLUS
80136: PUSH
80137: LD_VAR 0 8
80141: PUSH
80142: LD_INT 2
80144: ARRAY
80145: PUSH
80146: LD_VAR 0 3
80150: PLUS
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: EMPTY
80157: LIST
80158: ADD
80159: ST_TO_ADDR
80160: GO 80109
80162: POP
80163: POP
// result = temp_list2 ;
80164: LD_ADDR_VAR 0 7
80168: PUSH
80169: LD_VAR 0 10
80173: ST_TO_ADDR
// end ;
80174: LD_VAR 0 7
80178: RET
// export function EnemyInRange ( unit , dist ) ; begin
80179: LD_INT 0
80181: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80182: LD_ADDR_VAR 0 3
80186: PUSH
80187: LD_VAR 0 1
80191: PPUSH
80192: CALL_OW 255
80196: PPUSH
80197: LD_VAR 0 1
80201: PPUSH
80202: CALL_OW 250
80206: PPUSH
80207: LD_VAR 0 1
80211: PPUSH
80212: CALL_OW 251
80216: PPUSH
80217: LD_VAR 0 2
80221: PPUSH
80222: CALL 53950 0 4
80226: PUSH
80227: LD_INT 4
80229: ARRAY
80230: ST_TO_ADDR
// end ;
80231: LD_VAR 0 3
80235: RET
// export function PlayerSeeMe ( unit ) ; begin
80236: LD_INT 0
80238: PPUSH
// result := See ( your_side , unit ) ;
80239: LD_ADDR_VAR 0 2
80243: PUSH
80244: LD_OWVAR 2
80248: PPUSH
80249: LD_VAR 0 1
80253: PPUSH
80254: CALL_OW 292
80258: ST_TO_ADDR
// end ;
80259: LD_VAR 0 2
80263: RET
// export function ReverseDir ( unit ) ; begin
80264: LD_INT 0
80266: PPUSH
// if not unit then
80267: LD_VAR 0 1
80271: NOT
80272: IFFALSE 80276
// exit ;
80274: GO 80299
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
80276: LD_ADDR_VAR 0 2
80280: PUSH
80281: LD_VAR 0 1
80285: PPUSH
80286: CALL_OW 254
80290: PUSH
80291: LD_INT 3
80293: PLUS
80294: PUSH
80295: LD_INT 6
80297: MOD
80298: ST_TO_ADDR
// end ;
80299: LD_VAR 0 2
80303: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
80304: LD_INT 0
80306: PPUSH
80307: PPUSH
80308: PPUSH
80309: PPUSH
80310: PPUSH
// if not hexes then
80311: LD_VAR 0 2
80315: NOT
80316: IFFALSE 80320
// exit ;
80318: GO 80468
// dist := 9999 ;
80320: LD_ADDR_VAR 0 5
80324: PUSH
80325: LD_INT 9999
80327: ST_TO_ADDR
// for i = 1 to hexes do
80328: LD_ADDR_VAR 0 4
80332: PUSH
80333: DOUBLE
80334: LD_INT 1
80336: DEC
80337: ST_TO_ADDR
80338: LD_VAR 0 2
80342: PUSH
80343: FOR_TO
80344: IFFALSE 80456
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
80346: LD_VAR 0 1
80350: PPUSH
80351: LD_VAR 0 2
80355: PUSH
80356: LD_VAR 0 4
80360: ARRAY
80361: PUSH
80362: LD_INT 1
80364: ARRAY
80365: PPUSH
80366: LD_VAR 0 2
80370: PUSH
80371: LD_VAR 0 4
80375: ARRAY
80376: PUSH
80377: LD_INT 2
80379: ARRAY
80380: PPUSH
80381: CALL_OW 297
80385: PUSH
80386: LD_VAR 0 5
80390: LESS
80391: IFFALSE 80454
// begin hex := hexes [ i ] ;
80393: LD_ADDR_VAR 0 7
80397: PUSH
80398: LD_VAR 0 2
80402: PUSH
80403: LD_VAR 0 4
80407: ARRAY
80408: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80409: LD_ADDR_VAR 0 5
80413: PUSH
80414: LD_VAR 0 1
80418: PPUSH
80419: LD_VAR 0 2
80423: PUSH
80424: LD_VAR 0 4
80428: ARRAY
80429: PUSH
80430: LD_INT 1
80432: ARRAY
80433: PPUSH
80434: LD_VAR 0 2
80438: PUSH
80439: LD_VAR 0 4
80443: ARRAY
80444: PUSH
80445: LD_INT 2
80447: ARRAY
80448: PPUSH
80449: CALL_OW 297
80453: ST_TO_ADDR
// end ; end ;
80454: GO 80343
80456: POP
80457: POP
// result := hex ;
80458: LD_ADDR_VAR 0 3
80462: PUSH
80463: LD_VAR 0 7
80467: ST_TO_ADDR
// end ;
80468: LD_VAR 0 3
80472: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
80473: LD_INT 0
80475: PPUSH
80476: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80477: LD_VAR 0 1
80481: NOT
80482: PUSH
80483: LD_VAR 0 1
80487: PUSH
80488: LD_INT 21
80490: PUSH
80491: LD_INT 2
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 23
80500: PUSH
80501: LD_INT 2
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PPUSH
80512: CALL_OW 69
80516: IN
80517: NOT
80518: OR
80519: IFFALSE 80523
// exit ;
80521: GO 80570
// for i = 1 to 3 do
80523: LD_ADDR_VAR 0 3
80527: PUSH
80528: DOUBLE
80529: LD_INT 1
80531: DEC
80532: ST_TO_ADDR
80533: LD_INT 3
80535: PUSH
80536: FOR_TO
80537: IFFALSE 80568
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
80539: LD_VAR 0 1
80543: PPUSH
80544: CALL_OW 250
80548: PPUSH
80549: LD_VAR 0 1
80553: PPUSH
80554: CALL_OW 251
80558: PPUSH
80559: LD_INT 1
80561: PPUSH
80562: CALL_OW 453
80566: GO 80536
80568: POP
80569: POP
// end ;
80570: LD_VAR 0 2
80574: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
80575: LD_INT 0
80577: PPUSH
80578: PPUSH
80579: PPUSH
80580: PPUSH
80581: PPUSH
80582: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
80583: LD_VAR 0 1
80587: NOT
80588: PUSH
80589: LD_VAR 0 2
80593: NOT
80594: OR
80595: PUSH
80596: LD_VAR 0 1
80600: PPUSH
80601: CALL_OW 314
80605: OR
80606: IFFALSE 80610
// exit ;
80608: GO 81051
// x := GetX ( enemy_unit ) ;
80610: LD_ADDR_VAR 0 7
80614: PUSH
80615: LD_VAR 0 2
80619: PPUSH
80620: CALL_OW 250
80624: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
80625: LD_ADDR_VAR 0 8
80629: PUSH
80630: LD_VAR 0 2
80634: PPUSH
80635: CALL_OW 251
80639: ST_TO_ADDR
// if not x or not y then
80640: LD_VAR 0 7
80644: NOT
80645: PUSH
80646: LD_VAR 0 8
80650: NOT
80651: OR
80652: IFFALSE 80656
// exit ;
80654: GO 81051
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
80656: LD_ADDR_VAR 0 6
80660: PUSH
80661: LD_VAR 0 7
80665: PPUSH
80666: LD_INT 0
80668: PPUSH
80669: LD_INT 4
80671: PPUSH
80672: CALL_OW 272
80676: PUSH
80677: LD_VAR 0 8
80681: PPUSH
80682: LD_INT 0
80684: PPUSH
80685: LD_INT 4
80687: PPUSH
80688: CALL_OW 273
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_VAR 0 7
80701: PPUSH
80702: LD_INT 1
80704: PPUSH
80705: LD_INT 4
80707: PPUSH
80708: CALL_OW 272
80712: PUSH
80713: LD_VAR 0 8
80717: PPUSH
80718: LD_INT 1
80720: PPUSH
80721: LD_INT 4
80723: PPUSH
80724: CALL_OW 273
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_VAR 0 7
80737: PPUSH
80738: LD_INT 2
80740: PPUSH
80741: LD_INT 4
80743: PPUSH
80744: CALL_OW 272
80748: PUSH
80749: LD_VAR 0 8
80753: PPUSH
80754: LD_INT 2
80756: PPUSH
80757: LD_INT 4
80759: PPUSH
80760: CALL_OW 273
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_VAR 0 7
80773: PPUSH
80774: LD_INT 3
80776: PPUSH
80777: LD_INT 4
80779: PPUSH
80780: CALL_OW 272
80784: PUSH
80785: LD_VAR 0 8
80789: PPUSH
80790: LD_INT 3
80792: PPUSH
80793: LD_INT 4
80795: PPUSH
80796: CALL_OW 273
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_VAR 0 7
80809: PPUSH
80810: LD_INT 4
80812: PPUSH
80813: LD_INT 4
80815: PPUSH
80816: CALL_OW 272
80820: PUSH
80821: LD_VAR 0 8
80825: PPUSH
80826: LD_INT 4
80828: PPUSH
80829: LD_INT 4
80831: PPUSH
80832: CALL_OW 273
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_VAR 0 7
80845: PPUSH
80846: LD_INT 5
80848: PPUSH
80849: LD_INT 4
80851: PPUSH
80852: CALL_OW 272
80856: PUSH
80857: LD_VAR 0 8
80861: PPUSH
80862: LD_INT 5
80864: PPUSH
80865: LD_INT 4
80867: PPUSH
80868: CALL_OW 273
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: ST_TO_ADDR
// for i = tmp downto 1 do
80885: LD_ADDR_VAR 0 4
80889: PUSH
80890: DOUBLE
80891: LD_VAR 0 6
80895: INC
80896: ST_TO_ADDR
80897: LD_INT 1
80899: PUSH
80900: FOR_DOWNTO
80901: IFFALSE 81002
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
80903: LD_VAR 0 6
80907: PUSH
80908: LD_VAR 0 4
80912: ARRAY
80913: PUSH
80914: LD_INT 1
80916: ARRAY
80917: PPUSH
80918: LD_VAR 0 6
80922: PUSH
80923: LD_VAR 0 4
80927: ARRAY
80928: PUSH
80929: LD_INT 2
80931: ARRAY
80932: PPUSH
80933: CALL_OW 488
80937: NOT
80938: PUSH
80939: LD_VAR 0 6
80943: PUSH
80944: LD_VAR 0 4
80948: ARRAY
80949: PUSH
80950: LD_INT 1
80952: ARRAY
80953: PPUSH
80954: LD_VAR 0 6
80958: PUSH
80959: LD_VAR 0 4
80963: ARRAY
80964: PUSH
80965: LD_INT 2
80967: ARRAY
80968: PPUSH
80969: CALL_OW 428
80973: PUSH
80974: LD_INT 0
80976: NONEQUAL
80977: OR
80978: IFFALSE 81000
// tmp := Delete ( tmp , i ) ;
80980: LD_ADDR_VAR 0 6
80984: PUSH
80985: LD_VAR 0 6
80989: PPUSH
80990: LD_VAR 0 4
80994: PPUSH
80995: CALL_OW 3
80999: ST_TO_ADDR
81000: GO 80900
81002: POP
81003: POP
// j := GetClosestHex ( unit , tmp ) ;
81004: LD_ADDR_VAR 0 5
81008: PUSH
81009: LD_VAR 0 1
81013: PPUSH
81014: LD_VAR 0 6
81018: PPUSH
81019: CALL 80304 0 2
81023: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81024: LD_VAR 0 1
81028: PPUSH
81029: LD_VAR 0 5
81033: PUSH
81034: LD_INT 1
81036: ARRAY
81037: PPUSH
81038: LD_VAR 0 5
81042: PUSH
81043: LD_INT 2
81045: ARRAY
81046: PPUSH
81047: CALL_OW 111
// end ;
81051: LD_VAR 0 3
81055: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81056: LD_INT 0
81058: PPUSH
81059: PPUSH
81060: PPUSH
// uc_side = 0 ;
81061: LD_ADDR_OWVAR 20
81065: PUSH
81066: LD_INT 0
81068: ST_TO_ADDR
// uc_nation = 0 ;
81069: LD_ADDR_OWVAR 21
81073: PUSH
81074: LD_INT 0
81076: ST_TO_ADDR
// InitHc_All ( ) ;
81077: CALL_OW 584
// InitVc ;
81081: CALL_OW 20
// if mastodonts then
81085: LD_VAR 0 6
81089: IFFALSE 81156
// for i = 1 to mastodonts do
81091: LD_ADDR_VAR 0 11
81095: PUSH
81096: DOUBLE
81097: LD_INT 1
81099: DEC
81100: ST_TO_ADDR
81101: LD_VAR 0 6
81105: PUSH
81106: FOR_TO
81107: IFFALSE 81154
// begin vc_chassis := 31 ;
81109: LD_ADDR_OWVAR 37
81113: PUSH
81114: LD_INT 31
81116: ST_TO_ADDR
// vc_control := control_rider ;
81117: LD_ADDR_OWVAR 38
81121: PUSH
81122: LD_INT 4
81124: ST_TO_ADDR
// animal := CreateVehicle ;
81125: LD_ADDR_VAR 0 12
81129: PUSH
81130: CALL_OW 45
81134: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81135: LD_VAR 0 12
81139: PPUSH
81140: LD_VAR 0 8
81144: PPUSH
81145: LD_INT 0
81147: PPUSH
81148: CALL 83344 0 3
// end ;
81152: GO 81106
81154: POP
81155: POP
// if horses then
81156: LD_VAR 0 5
81160: IFFALSE 81227
// for i = 1 to horses do
81162: LD_ADDR_VAR 0 11
81166: PUSH
81167: DOUBLE
81168: LD_INT 1
81170: DEC
81171: ST_TO_ADDR
81172: LD_VAR 0 5
81176: PUSH
81177: FOR_TO
81178: IFFALSE 81225
// begin hc_class := 21 ;
81180: LD_ADDR_OWVAR 28
81184: PUSH
81185: LD_INT 21
81187: ST_TO_ADDR
// hc_gallery :=  ;
81188: LD_ADDR_OWVAR 33
81192: PUSH
81193: LD_STRING 
81195: ST_TO_ADDR
// animal := CreateHuman ;
81196: LD_ADDR_VAR 0 12
81200: PUSH
81201: CALL_OW 44
81205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81206: LD_VAR 0 12
81210: PPUSH
81211: LD_VAR 0 8
81215: PPUSH
81216: LD_INT 0
81218: PPUSH
81219: CALL 83344 0 3
// end ;
81223: GO 81177
81225: POP
81226: POP
// if birds then
81227: LD_VAR 0 1
81231: IFFALSE 81298
// for i = 1 to birds do
81233: LD_ADDR_VAR 0 11
81237: PUSH
81238: DOUBLE
81239: LD_INT 1
81241: DEC
81242: ST_TO_ADDR
81243: LD_VAR 0 1
81247: PUSH
81248: FOR_TO
81249: IFFALSE 81296
// begin hc_class = 18 ;
81251: LD_ADDR_OWVAR 28
81255: PUSH
81256: LD_INT 18
81258: ST_TO_ADDR
// hc_gallery =  ;
81259: LD_ADDR_OWVAR 33
81263: PUSH
81264: LD_STRING 
81266: ST_TO_ADDR
// animal := CreateHuman ;
81267: LD_ADDR_VAR 0 12
81271: PUSH
81272: CALL_OW 44
81276: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81277: LD_VAR 0 12
81281: PPUSH
81282: LD_VAR 0 8
81286: PPUSH
81287: LD_INT 0
81289: PPUSH
81290: CALL 83344 0 3
// end ;
81294: GO 81248
81296: POP
81297: POP
// if tigers then
81298: LD_VAR 0 2
81302: IFFALSE 81386
// for i = 1 to tigers do
81304: LD_ADDR_VAR 0 11
81308: PUSH
81309: DOUBLE
81310: LD_INT 1
81312: DEC
81313: ST_TO_ADDR
81314: LD_VAR 0 2
81318: PUSH
81319: FOR_TO
81320: IFFALSE 81384
// begin hc_class = class_tiger ;
81322: LD_ADDR_OWVAR 28
81326: PUSH
81327: LD_INT 14
81329: ST_TO_ADDR
// hc_gallery =  ;
81330: LD_ADDR_OWVAR 33
81334: PUSH
81335: LD_STRING 
81337: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
81338: LD_ADDR_OWVAR 35
81342: PUSH
81343: LD_INT 7
81345: NEG
81346: PPUSH
81347: LD_INT 7
81349: PPUSH
81350: CALL_OW 12
81354: ST_TO_ADDR
// animal := CreateHuman ;
81355: LD_ADDR_VAR 0 12
81359: PUSH
81360: CALL_OW 44
81364: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81365: LD_VAR 0 12
81369: PPUSH
81370: LD_VAR 0 8
81374: PPUSH
81375: LD_INT 0
81377: PPUSH
81378: CALL 83344 0 3
// end ;
81382: GO 81319
81384: POP
81385: POP
// if apemans then
81386: LD_VAR 0 3
81390: IFFALSE 81513
// for i = 1 to apemans do
81392: LD_ADDR_VAR 0 11
81396: PUSH
81397: DOUBLE
81398: LD_INT 1
81400: DEC
81401: ST_TO_ADDR
81402: LD_VAR 0 3
81406: PUSH
81407: FOR_TO
81408: IFFALSE 81511
// begin hc_class = class_apeman ;
81410: LD_ADDR_OWVAR 28
81414: PUSH
81415: LD_INT 12
81417: ST_TO_ADDR
// hc_gallery =  ;
81418: LD_ADDR_OWVAR 33
81422: PUSH
81423: LD_STRING 
81425: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
81426: LD_ADDR_OWVAR 35
81430: PUSH
81431: LD_INT 5
81433: NEG
81434: PPUSH
81435: LD_INT 5
81437: PPUSH
81438: CALL_OW 12
81442: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
81443: LD_ADDR_OWVAR 31
81447: PUSH
81448: LD_INT 1
81450: PPUSH
81451: LD_INT 3
81453: PPUSH
81454: CALL_OW 12
81458: PUSH
81459: LD_INT 1
81461: PPUSH
81462: LD_INT 3
81464: PPUSH
81465: CALL_OW 12
81469: PUSH
81470: LD_INT 0
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: ST_TO_ADDR
// animal := CreateHuman ;
81482: LD_ADDR_VAR 0 12
81486: PUSH
81487: CALL_OW 44
81491: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81492: LD_VAR 0 12
81496: PPUSH
81497: LD_VAR 0 8
81501: PPUSH
81502: LD_INT 0
81504: PPUSH
81505: CALL 83344 0 3
// end ;
81509: GO 81407
81511: POP
81512: POP
// if enchidnas then
81513: LD_VAR 0 4
81517: IFFALSE 81584
// for i = 1 to enchidnas do
81519: LD_ADDR_VAR 0 11
81523: PUSH
81524: DOUBLE
81525: LD_INT 1
81527: DEC
81528: ST_TO_ADDR
81529: LD_VAR 0 4
81533: PUSH
81534: FOR_TO
81535: IFFALSE 81582
// begin hc_class = 13 ;
81537: LD_ADDR_OWVAR 28
81541: PUSH
81542: LD_INT 13
81544: ST_TO_ADDR
// hc_gallery =  ;
81545: LD_ADDR_OWVAR 33
81549: PUSH
81550: LD_STRING 
81552: ST_TO_ADDR
// animal := CreateHuman ;
81553: LD_ADDR_VAR 0 12
81557: PUSH
81558: CALL_OW 44
81562: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81563: LD_VAR 0 12
81567: PPUSH
81568: LD_VAR 0 8
81572: PPUSH
81573: LD_INT 0
81575: PPUSH
81576: CALL 83344 0 3
// end ;
81580: GO 81534
81582: POP
81583: POP
// if fishes then
81584: LD_VAR 0 7
81588: IFFALSE 81655
// for i = 1 to fishes do
81590: LD_ADDR_VAR 0 11
81594: PUSH
81595: DOUBLE
81596: LD_INT 1
81598: DEC
81599: ST_TO_ADDR
81600: LD_VAR 0 7
81604: PUSH
81605: FOR_TO
81606: IFFALSE 81653
// begin hc_class = 20 ;
81608: LD_ADDR_OWVAR 28
81612: PUSH
81613: LD_INT 20
81615: ST_TO_ADDR
// hc_gallery =  ;
81616: LD_ADDR_OWVAR 33
81620: PUSH
81621: LD_STRING 
81623: ST_TO_ADDR
// animal := CreateHuman ;
81624: LD_ADDR_VAR 0 12
81628: PUSH
81629: CALL_OW 44
81633: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
81634: LD_VAR 0 12
81638: PPUSH
81639: LD_VAR 0 9
81643: PPUSH
81644: LD_INT 0
81646: PPUSH
81647: CALL 83344 0 3
// end ;
81651: GO 81605
81653: POP
81654: POP
// end ;
81655: LD_VAR 0 10
81659: RET
// export function WantHeal ( sci , unit ) ; begin
81660: LD_INT 0
81662: PPUSH
// if GetTaskList ( sci ) > 0 then
81663: LD_VAR 0 1
81667: PPUSH
81668: CALL_OW 437
81672: PUSH
81673: LD_INT 0
81675: GREATER
81676: IFFALSE 81746
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
81678: LD_VAR 0 1
81682: PPUSH
81683: CALL_OW 437
81687: PUSH
81688: LD_INT 1
81690: ARRAY
81691: PUSH
81692: LD_INT 1
81694: ARRAY
81695: PUSH
81696: LD_STRING l
81698: EQUAL
81699: PUSH
81700: LD_VAR 0 1
81704: PPUSH
81705: CALL_OW 437
81709: PUSH
81710: LD_INT 1
81712: ARRAY
81713: PUSH
81714: LD_INT 4
81716: ARRAY
81717: PUSH
81718: LD_VAR 0 2
81722: EQUAL
81723: AND
81724: IFFALSE 81736
// result := true else
81726: LD_ADDR_VAR 0 3
81730: PUSH
81731: LD_INT 1
81733: ST_TO_ADDR
81734: GO 81744
// result := false ;
81736: LD_ADDR_VAR 0 3
81740: PUSH
81741: LD_INT 0
81743: ST_TO_ADDR
// end else
81744: GO 81754
// result := false ;
81746: LD_ADDR_VAR 0 3
81750: PUSH
81751: LD_INT 0
81753: ST_TO_ADDR
// end ;
81754: LD_VAR 0 3
81758: RET
// export function HealTarget ( sci ) ; begin
81759: LD_INT 0
81761: PPUSH
// if not sci then
81762: LD_VAR 0 1
81766: NOT
81767: IFFALSE 81771
// exit ;
81769: GO 81836
// result := 0 ;
81771: LD_ADDR_VAR 0 2
81775: PUSH
81776: LD_INT 0
81778: ST_TO_ADDR
// if GetTaskList ( sci ) then
81779: LD_VAR 0 1
81783: PPUSH
81784: CALL_OW 437
81788: IFFALSE 81836
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
81790: LD_VAR 0 1
81794: PPUSH
81795: CALL_OW 437
81799: PUSH
81800: LD_INT 1
81802: ARRAY
81803: PUSH
81804: LD_INT 1
81806: ARRAY
81807: PUSH
81808: LD_STRING l
81810: EQUAL
81811: IFFALSE 81836
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
81813: LD_ADDR_VAR 0 2
81817: PUSH
81818: LD_VAR 0 1
81822: PPUSH
81823: CALL_OW 437
81827: PUSH
81828: LD_INT 1
81830: ARRAY
81831: PUSH
81832: LD_INT 4
81834: ARRAY
81835: ST_TO_ADDR
// end ;
81836: LD_VAR 0 2
81840: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
81841: LD_INT 0
81843: PPUSH
81844: PPUSH
81845: PPUSH
81846: PPUSH
// if not base_units then
81847: LD_VAR 0 1
81851: NOT
81852: IFFALSE 81856
// exit ;
81854: GO 81943
// result := false ;
81856: LD_ADDR_VAR 0 2
81860: PUSH
81861: LD_INT 0
81863: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
81864: LD_ADDR_VAR 0 5
81868: PUSH
81869: LD_VAR 0 1
81873: PPUSH
81874: LD_INT 21
81876: PUSH
81877: LD_INT 3
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PPUSH
81884: CALL_OW 72
81888: ST_TO_ADDR
// if not tmp then
81889: LD_VAR 0 5
81893: NOT
81894: IFFALSE 81898
// exit ;
81896: GO 81943
// for i in tmp do
81898: LD_ADDR_VAR 0 3
81902: PUSH
81903: LD_VAR 0 5
81907: PUSH
81908: FOR_IN
81909: IFFALSE 81941
// begin result := EnemyInRange ( i , 22 ) ;
81911: LD_ADDR_VAR 0 2
81915: PUSH
81916: LD_VAR 0 3
81920: PPUSH
81921: LD_INT 22
81923: PPUSH
81924: CALL 80179 0 2
81928: ST_TO_ADDR
// if result then
81929: LD_VAR 0 2
81933: IFFALSE 81939
// exit ;
81935: POP
81936: POP
81937: GO 81943
// end ;
81939: GO 81908
81941: POP
81942: POP
// end ;
81943: LD_VAR 0 2
81947: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
81948: LD_INT 0
81950: PPUSH
81951: PPUSH
// if not units then
81952: LD_VAR 0 1
81956: NOT
81957: IFFALSE 81961
// exit ;
81959: GO 82031
// result := [ ] ;
81961: LD_ADDR_VAR 0 3
81965: PUSH
81966: EMPTY
81967: ST_TO_ADDR
// for i in units do
81968: LD_ADDR_VAR 0 4
81972: PUSH
81973: LD_VAR 0 1
81977: PUSH
81978: FOR_IN
81979: IFFALSE 82029
// if GetTag ( i ) = tag then
81981: LD_VAR 0 4
81985: PPUSH
81986: CALL_OW 110
81990: PUSH
81991: LD_VAR 0 2
81995: EQUAL
81996: IFFALSE 82027
// result := Insert ( result , result + 1 , i ) ;
81998: LD_ADDR_VAR 0 3
82002: PUSH
82003: LD_VAR 0 3
82007: PPUSH
82008: LD_VAR 0 3
82012: PUSH
82013: LD_INT 1
82015: PLUS
82016: PPUSH
82017: LD_VAR 0 4
82021: PPUSH
82022: CALL_OW 2
82026: ST_TO_ADDR
82027: GO 81978
82029: POP
82030: POP
// end ;
82031: LD_VAR 0 3
82035: RET
// export function IsDriver ( un ) ; begin
82036: LD_INT 0
82038: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82039: LD_ADDR_VAR 0 2
82043: PUSH
82044: LD_VAR 0 1
82048: PUSH
82049: LD_INT 55
82051: PUSH
82052: EMPTY
82053: LIST
82054: PPUSH
82055: CALL_OW 69
82059: IN
82060: ST_TO_ADDR
// end ;
82061: LD_VAR 0 2
82065: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82066: LD_INT 0
82068: PPUSH
82069: PPUSH
// list := [ ] ;
82070: LD_ADDR_VAR 0 5
82074: PUSH
82075: EMPTY
82076: ST_TO_ADDR
// case d of 0 :
82077: LD_VAR 0 3
82081: PUSH
82082: LD_INT 0
82084: DOUBLE
82085: EQUAL
82086: IFTRUE 82090
82088: GO 82223
82090: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82091: LD_ADDR_VAR 0 5
82095: PUSH
82096: LD_VAR 0 1
82100: PUSH
82101: LD_INT 4
82103: MINUS
82104: PUSH
82105: LD_VAR 0 2
82109: PUSH
82110: LD_INT 4
82112: MINUS
82113: PUSH
82114: LD_INT 2
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: LIST
82121: PUSH
82122: LD_VAR 0 1
82126: PUSH
82127: LD_INT 3
82129: MINUS
82130: PUSH
82131: LD_VAR 0 2
82135: PUSH
82136: LD_INT 1
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: LIST
82143: PUSH
82144: LD_VAR 0 1
82148: PUSH
82149: LD_INT 4
82151: PLUS
82152: PUSH
82153: LD_VAR 0 2
82157: PUSH
82158: LD_INT 4
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: LIST
82165: PUSH
82166: LD_VAR 0 1
82170: PUSH
82171: LD_INT 3
82173: PLUS
82174: PUSH
82175: LD_VAR 0 2
82179: PUSH
82180: LD_INT 3
82182: PLUS
82183: PUSH
82184: LD_INT 5
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: LIST
82191: PUSH
82192: LD_VAR 0 1
82196: PUSH
82197: LD_VAR 0 2
82201: PUSH
82202: LD_INT 4
82204: PLUS
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: LIST
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: ST_TO_ADDR
// end ; 1 :
82221: GO 82921
82223: LD_INT 1
82225: DOUBLE
82226: EQUAL
82227: IFTRUE 82231
82229: GO 82364
82231: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82232: LD_ADDR_VAR 0 5
82236: PUSH
82237: LD_VAR 0 1
82241: PUSH
82242: LD_VAR 0 2
82246: PUSH
82247: LD_INT 4
82249: MINUS
82250: PUSH
82251: LD_INT 3
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: LIST
82258: PUSH
82259: LD_VAR 0 1
82263: PUSH
82264: LD_INT 3
82266: MINUS
82267: PUSH
82268: LD_VAR 0 2
82272: PUSH
82273: LD_INT 3
82275: MINUS
82276: PUSH
82277: LD_INT 2
82279: PUSH
82280: EMPTY
82281: LIST
82282: LIST
82283: LIST
82284: PUSH
82285: LD_VAR 0 1
82289: PUSH
82290: LD_INT 4
82292: MINUS
82293: PUSH
82294: LD_VAR 0 2
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: LIST
82306: PUSH
82307: LD_VAR 0 1
82311: PUSH
82312: LD_VAR 0 2
82316: PUSH
82317: LD_INT 3
82319: PLUS
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: LIST
82328: PUSH
82329: LD_VAR 0 1
82333: PUSH
82334: LD_INT 4
82336: PLUS
82337: PUSH
82338: LD_VAR 0 2
82342: PUSH
82343: LD_INT 4
82345: PLUS
82346: PUSH
82347: LD_INT 5
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: LIST
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: ST_TO_ADDR
// end ; 2 :
82362: GO 82921
82364: LD_INT 2
82366: DOUBLE
82367: EQUAL
82368: IFTRUE 82372
82370: GO 82501
82372: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
82373: LD_ADDR_VAR 0 5
82377: PUSH
82378: LD_VAR 0 1
82382: PUSH
82383: LD_VAR 0 2
82387: PUSH
82388: LD_INT 3
82390: MINUS
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: LIST
82399: PUSH
82400: LD_VAR 0 1
82404: PUSH
82405: LD_INT 4
82407: PLUS
82408: PUSH
82409: LD_VAR 0 2
82413: PUSH
82414: LD_INT 4
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: LIST
82421: PUSH
82422: LD_VAR 0 1
82426: PUSH
82427: LD_VAR 0 2
82431: PUSH
82432: LD_INT 4
82434: PLUS
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: LIST
82443: PUSH
82444: LD_VAR 0 1
82448: PUSH
82449: LD_INT 3
82451: MINUS
82452: PUSH
82453: LD_VAR 0 2
82457: PUSH
82458: LD_INT 1
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: LIST
82465: PUSH
82466: LD_VAR 0 1
82470: PUSH
82471: LD_INT 4
82473: MINUS
82474: PUSH
82475: LD_VAR 0 2
82479: PUSH
82480: LD_INT 4
82482: MINUS
82483: PUSH
82484: LD_INT 2
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: LIST
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: ST_TO_ADDR
// end ; 3 :
82499: GO 82921
82501: LD_INT 3
82503: DOUBLE
82504: EQUAL
82505: IFTRUE 82509
82507: GO 82642
82509: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
82510: LD_ADDR_VAR 0 5
82514: PUSH
82515: LD_VAR 0 1
82519: PUSH
82520: LD_INT 3
82522: PLUS
82523: PUSH
82524: LD_VAR 0 2
82528: PUSH
82529: LD_INT 4
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: PUSH
82537: LD_VAR 0 1
82541: PUSH
82542: LD_INT 4
82544: PLUS
82545: PUSH
82546: LD_VAR 0 2
82550: PUSH
82551: LD_INT 4
82553: PLUS
82554: PUSH
82555: LD_INT 5
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: LIST
82562: PUSH
82563: LD_VAR 0 1
82567: PUSH
82568: LD_INT 4
82570: MINUS
82571: PUSH
82572: LD_VAR 0 2
82576: PUSH
82577: LD_INT 1
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: LIST
82584: PUSH
82585: LD_VAR 0 1
82589: PUSH
82590: LD_VAR 0 2
82594: PUSH
82595: LD_INT 4
82597: MINUS
82598: PUSH
82599: LD_INT 3
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: LIST
82606: PUSH
82607: LD_VAR 0 1
82611: PUSH
82612: LD_INT 3
82614: MINUS
82615: PUSH
82616: LD_VAR 0 2
82620: PUSH
82621: LD_INT 3
82623: MINUS
82624: PUSH
82625: LD_INT 2
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: LIST
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: ST_TO_ADDR
// end ; 4 :
82640: GO 82921
82642: LD_INT 4
82644: DOUBLE
82645: EQUAL
82646: IFTRUE 82650
82648: GO 82783
82650: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
82651: LD_ADDR_VAR 0 5
82655: PUSH
82656: LD_VAR 0 1
82660: PUSH
82661: LD_VAR 0 2
82665: PUSH
82666: LD_INT 4
82668: PLUS
82669: PUSH
82670: LD_INT 0
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: LIST
82677: PUSH
82678: LD_VAR 0 1
82682: PUSH
82683: LD_INT 3
82685: PLUS
82686: PUSH
82687: LD_VAR 0 2
82691: PUSH
82692: LD_INT 3
82694: PLUS
82695: PUSH
82696: LD_INT 5
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: LIST
82703: PUSH
82704: LD_VAR 0 1
82708: PUSH
82709: LD_INT 4
82711: PLUS
82712: PUSH
82713: LD_VAR 0 2
82717: PUSH
82718: LD_INT 4
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: LIST
82725: PUSH
82726: LD_VAR 0 1
82730: PUSH
82731: LD_VAR 0 2
82735: PUSH
82736: LD_INT 3
82738: MINUS
82739: PUSH
82740: LD_INT 3
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: LIST
82747: PUSH
82748: LD_VAR 0 1
82752: PUSH
82753: LD_INT 4
82755: MINUS
82756: PUSH
82757: LD_VAR 0 2
82761: PUSH
82762: LD_INT 4
82764: MINUS
82765: PUSH
82766: LD_INT 2
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: LIST
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: ST_TO_ADDR
// end ; 5 :
82781: GO 82921
82783: LD_INT 5
82785: DOUBLE
82786: EQUAL
82787: IFTRUE 82791
82789: GO 82920
82791: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
82792: LD_ADDR_VAR 0 5
82796: PUSH
82797: LD_VAR 0 1
82801: PUSH
82802: LD_INT 4
82804: MINUS
82805: PUSH
82806: LD_VAR 0 2
82810: PUSH
82811: LD_INT 1
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: LIST
82818: PUSH
82819: LD_VAR 0 1
82823: PUSH
82824: LD_VAR 0 2
82828: PUSH
82829: LD_INT 4
82831: MINUS
82832: PUSH
82833: LD_INT 3
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: LIST
82840: PUSH
82841: LD_VAR 0 1
82845: PUSH
82846: LD_INT 4
82848: PLUS
82849: PUSH
82850: LD_VAR 0 2
82854: PUSH
82855: LD_INT 4
82857: PLUS
82858: PUSH
82859: LD_INT 5
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: LIST
82866: PUSH
82867: LD_VAR 0 1
82871: PUSH
82872: LD_INT 3
82874: PLUS
82875: PUSH
82876: LD_VAR 0 2
82880: PUSH
82881: LD_INT 4
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: LIST
82888: PUSH
82889: LD_VAR 0 1
82893: PUSH
82894: LD_VAR 0 2
82898: PUSH
82899: LD_INT 3
82901: PLUS
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: LIST
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: ST_TO_ADDR
// end ; end ;
82918: GO 82921
82920: POP
// result := list ;
82921: LD_ADDR_VAR 0 4
82925: PUSH
82926: LD_VAR 0 5
82930: ST_TO_ADDR
// end ;
82931: LD_VAR 0 4
82935: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
82936: LD_INT 0
82938: PPUSH
82939: PPUSH
82940: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
82941: LD_VAR 0 1
82945: NOT
82946: PUSH
82947: LD_VAR 0 2
82951: PUSH
82952: LD_INT 1
82954: PUSH
82955: LD_INT 2
82957: PUSH
82958: LD_INT 3
82960: PUSH
82961: LD_INT 4
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: IN
82970: NOT
82971: OR
82972: IFFALSE 82976
// exit ;
82974: GO 83068
// tmp := [ ] ;
82976: LD_ADDR_VAR 0 5
82980: PUSH
82981: EMPTY
82982: ST_TO_ADDR
// for i in units do
82983: LD_ADDR_VAR 0 4
82987: PUSH
82988: LD_VAR 0 1
82992: PUSH
82993: FOR_IN
82994: IFFALSE 83037
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
82996: LD_ADDR_VAR 0 5
83000: PUSH
83001: LD_VAR 0 5
83005: PPUSH
83006: LD_VAR 0 5
83010: PUSH
83011: LD_INT 1
83013: PLUS
83014: PPUSH
83015: LD_VAR 0 4
83019: PPUSH
83020: LD_VAR 0 2
83024: PPUSH
83025: CALL_OW 259
83029: PPUSH
83030: CALL_OW 2
83034: ST_TO_ADDR
83035: GO 82993
83037: POP
83038: POP
// if not tmp then
83039: LD_VAR 0 5
83043: NOT
83044: IFFALSE 83048
// exit ;
83046: GO 83068
// result := SortListByListDesc ( units , tmp ) ;
83048: LD_ADDR_VAR 0 3
83052: PUSH
83053: LD_VAR 0 1
83057: PPUSH
83058: LD_VAR 0 5
83062: PPUSH
83063: CALL_OW 77
83067: ST_TO_ADDR
// end ;
83068: LD_VAR 0 3
83072: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83073: LD_INT 0
83075: PPUSH
83076: PPUSH
83077: PPUSH
// result := false ;
83078: LD_ADDR_VAR 0 3
83082: PUSH
83083: LD_INT 0
83085: ST_TO_ADDR
// x := GetX ( building ) ;
83086: LD_ADDR_VAR 0 4
83090: PUSH
83091: LD_VAR 0 2
83095: PPUSH
83096: CALL_OW 250
83100: ST_TO_ADDR
// y := GetY ( building ) ;
83101: LD_ADDR_VAR 0 5
83105: PUSH
83106: LD_VAR 0 2
83110: PPUSH
83111: CALL_OW 251
83115: ST_TO_ADDR
// if not building or not x or not y then
83116: LD_VAR 0 2
83120: NOT
83121: PUSH
83122: LD_VAR 0 4
83126: NOT
83127: OR
83128: PUSH
83129: LD_VAR 0 5
83133: NOT
83134: OR
83135: IFFALSE 83139
// exit ;
83137: GO 83231
// if GetTaskList ( unit ) then
83139: LD_VAR 0 1
83143: PPUSH
83144: CALL_OW 437
83148: IFFALSE 83231
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83150: LD_STRING e
83152: PUSH
83153: LD_VAR 0 1
83157: PPUSH
83158: CALL_OW 437
83162: PUSH
83163: LD_INT 1
83165: ARRAY
83166: PUSH
83167: LD_INT 1
83169: ARRAY
83170: EQUAL
83171: PUSH
83172: LD_VAR 0 4
83176: PUSH
83177: LD_VAR 0 1
83181: PPUSH
83182: CALL_OW 437
83186: PUSH
83187: LD_INT 1
83189: ARRAY
83190: PUSH
83191: LD_INT 2
83193: ARRAY
83194: EQUAL
83195: AND
83196: PUSH
83197: LD_VAR 0 5
83201: PUSH
83202: LD_VAR 0 1
83206: PPUSH
83207: CALL_OW 437
83211: PUSH
83212: LD_INT 1
83214: ARRAY
83215: PUSH
83216: LD_INT 3
83218: ARRAY
83219: EQUAL
83220: AND
83221: IFFALSE 83231
// result := true end ;
83223: LD_ADDR_VAR 0 3
83227: PUSH
83228: LD_INT 1
83230: ST_TO_ADDR
// end ;
83231: LD_VAR 0 3
83235: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
83236: LD_INT 0
83238: PPUSH
// result := false ;
83239: LD_ADDR_VAR 0 4
83243: PUSH
83244: LD_INT 0
83246: ST_TO_ADDR
// if GetTaskList ( unit ) then
83247: LD_VAR 0 1
83251: PPUSH
83252: CALL_OW 437
83256: IFFALSE 83339
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83258: LD_STRING M
83260: PUSH
83261: LD_VAR 0 1
83265: PPUSH
83266: CALL_OW 437
83270: PUSH
83271: LD_INT 1
83273: ARRAY
83274: PUSH
83275: LD_INT 1
83277: ARRAY
83278: EQUAL
83279: PUSH
83280: LD_VAR 0 2
83284: PUSH
83285: LD_VAR 0 1
83289: PPUSH
83290: CALL_OW 437
83294: PUSH
83295: LD_INT 1
83297: ARRAY
83298: PUSH
83299: LD_INT 2
83301: ARRAY
83302: EQUAL
83303: AND
83304: PUSH
83305: LD_VAR 0 3
83309: PUSH
83310: LD_VAR 0 1
83314: PPUSH
83315: CALL_OW 437
83319: PUSH
83320: LD_INT 1
83322: ARRAY
83323: PUSH
83324: LD_INT 3
83326: ARRAY
83327: EQUAL
83328: AND
83329: IFFALSE 83339
// result := true ;
83331: LD_ADDR_VAR 0 4
83335: PUSH
83336: LD_INT 1
83338: ST_TO_ADDR
// end ; end ;
83339: LD_VAR 0 4
83343: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
83344: LD_INT 0
83346: PPUSH
83347: PPUSH
83348: PPUSH
83349: PPUSH
// if not unit or not area then
83350: LD_VAR 0 1
83354: NOT
83355: PUSH
83356: LD_VAR 0 2
83360: NOT
83361: OR
83362: IFFALSE 83366
// exit ;
83364: GO 83530
// tmp := AreaToList ( area , i ) ;
83366: LD_ADDR_VAR 0 6
83370: PUSH
83371: LD_VAR 0 2
83375: PPUSH
83376: LD_VAR 0 5
83380: PPUSH
83381: CALL_OW 517
83385: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
83386: LD_ADDR_VAR 0 5
83390: PUSH
83391: DOUBLE
83392: LD_INT 1
83394: DEC
83395: ST_TO_ADDR
83396: LD_VAR 0 6
83400: PUSH
83401: LD_INT 1
83403: ARRAY
83404: PUSH
83405: FOR_TO
83406: IFFALSE 83528
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
83408: LD_ADDR_VAR 0 7
83412: PUSH
83413: LD_VAR 0 6
83417: PUSH
83418: LD_INT 1
83420: ARRAY
83421: PUSH
83422: LD_VAR 0 5
83426: ARRAY
83427: PUSH
83428: LD_VAR 0 6
83432: PUSH
83433: LD_INT 2
83435: ARRAY
83436: PUSH
83437: LD_VAR 0 5
83441: ARRAY
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
83447: LD_VAR 0 7
83451: PUSH
83452: LD_INT 1
83454: ARRAY
83455: PPUSH
83456: LD_VAR 0 7
83460: PUSH
83461: LD_INT 2
83463: ARRAY
83464: PPUSH
83465: CALL_OW 428
83469: PUSH
83470: LD_INT 0
83472: EQUAL
83473: IFFALSE 83526
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
83475: LD_VAR 0 1
83479: PPUSH
83480: LD_VAR 0 7
83484: PUSH
83485: LD_INT 1
83487: ARRAY
83488: PPUSH
83489: LD_VAR 0 7
83493: PUSH
83494: LD_INT 2
83496: ARRAY
83497: PPUSH
83498: LD_VAR 0 3
83502: PPUSH
83503: CALL_OW 48
// result := IsPlaced ( unit ) ;
83507: LD_ADDR_VAR 0 4
83511: PUSH
83512: LD_VAR 0 1
83516: PPUSH
83517: CALL_OW 305
83521: ST_TO_ADDR
// exit ;
83522: POP
83523: POP
83524: GO 83530
// end ; end ;
83526: GO 83405
83528: POP
83529: POP
// end ;
83530: LD_VAR 0 4
83534: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
83535: LD_INT 0
83537: PPUSH
83538: PPUSH
83539: PPUSH
// if not side or side > 8 then
83540: LD_VAR 0 1
83544: NOT
83545: PUSH
83546: LD_VAR 0 1
83550: PUSH
83551: LD_INT 8
83553: GREATER
83554: OR
83555: IFFALSE 83559
// exit ;
83557: GO 83746
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
83559: LD_ADDR_VAR 0 4
83563: PUSH
83564: LD_INT 22
83566: PUSH
83567: LD_VAR 0 1
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 21
83578: PUSH
83579: LD_INT 3
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PPUSH
83590: CALL_OW 69
83594: ST_TO_ADDR
// if not tmp then
83595: LD_VAR 0 4
83599: NOT
83600: IFFALSE 83604
// exit ;
83602: GO 83746
// enable_addtolog := true ;
83604: LD_ADDR_OWVAR 81
83608: PUSH
83609: LD_INT 1
83611: ST_TO_ADDR
// AddToLog ( [ ) ;
83612: LD_STRING [
83614: PPUSH
83615: CALL_OW 561
// for i in tmp do
83619: LD_ADDR_VAR 0 3
83623: PUSH
83624: LD_VAR 0 4
83628: PUSH
83629: FOR_IN
83630: IFFALSE 83737
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
83632: LD_STRING [
83634: PUSH
83635: LD_VAR 0 3
83639: PPUSH
83640: CALL_OW 266
83644: STR
83645: PUSH
83646: LD_STRING , 
83648: STR
83649: PUSH
83650: LD_VAR 0 3
83654: PPUSH
83655: CALL_OW 250
83659: STR
83660: PUSH
83661: LD_STRING , 
83663: STR
83664: PUSH
83665: LD_VAR 0 3
83669: PPUSH
83670: CALL_OW 251
83674: STR
83675: PUSH
83676: LD_STRING , 
83678: STR
83679: PUSH
83680: LD_VAR 0 3
83684: PPUSH
83685: CALL_OW 254
83689: STR
83690: PUSH
83691: LD_STRING , 
83693: STR
83694: PUSH
83695: LD_VAR 0 3
83699: PPUSH
83700: LD_INT 1
83702: PPUSH
83703: CALL_OW 268
83707: STR
83708: PUSH
83709: LD_STRING , 
83711: STR
83712: PUSH
83713: LD_VAR 0 3
83717: PPUSH
83718: LD_INT 2
83720: PPUSH
83721: CALL_OW 268
83725: STR
83726: PUSH
83727: LD_STRING ],
83729: STR
83730: PPUSH
83731: CALL_OW 561
// end ;
83735: GO 83629
83737: POP
83738: POP
// AddToLog ( ]; ) ;
83739: LD_STRING ];
83741: PPUSH
83742: CALL_OW 561
// end ;
83746: LD_VAR 0 2
83750: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
83751: LD_INT 0
83753: PPUSH
83754: PPUSH
83755: PPUSH
83756: PPUSH
83757: PPUSH
// if not area or not rate or not max then
83758: LD_VAR 0 1
83762: NOT
83763: PUSH
83764: LD_VAR 0 2
83768: NOT
83769: OR
83770: PUSH
83771: LD_VAR 0 4
83775: NOT
83776: OR
83777: IFFALSE 83781
// exit ;
83779: GO 83973
// while 1 do
83781: LD_INT 1
83783: IFFALSE 83973
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
83785: LD_ADDR_VAR 0 9
83789: PUSH
83790: LD_VAR 0 1
83794: PPUSH
83795: LD_INT 1
83797: PPUSH
83798: CALL_OW 287
83802: PUSH
83803: LD_INT 10
83805: MUL
83806: ST_TO_ADDR
// r := rate / 10 ;
83807: LD_ADDR_VAR 0 7
83811: PUSH
83812: LD_VAR 0 2
83816: PUSH
83817: LD_INT 10
83819: DIVREAL
83820: ST_TO_ADDR
// time := 1 1$00 ;
83821: LD_ADDR_VAR 0 8
83825: PUSH
83826: LD_INT 2100
83828: ST_TO_ADDR
// if amount < min then
83829: LD_VAR 0 9
83833: PUSH
83834: LD_VAR 0 3
83838: LESS
83839: IFFALSE 83857
// r := r * 2 else
83841: LD_ADDR_VAR 0 7
83845: PUSH
83846: LD_VAR 0 7
83850: PUSH
83851: LD_INT 2
83853: MUL
83854: ST_TO_ADDR
83855: GO 83883
// if amount > max then
83857: LD_VAR 0 9
83861: PUSH
83862: LD_VAR 0 4
83866: GREATER
83867: IFFALSE 83883
// r := r / 2 ;
83869: LD_ADDR_VAR 0 7
83873: PUSH
83874: LD_VAR 0 7
83878: PUSH
83879: LD_INT 2
83881: DIVREAL
83882: ST_TO_ADDR
// time := time / r ;
83883: LD_ADDR_VAR 0 8
83887: PUSH
83888: LD_VAR 0 8
83892: PUSH
83893: LD_VAR 0 7
83897: DIVREAL
83898: ST_TO_ADDR
// if time < 0 then
83899: LD_VAR 0 8
83903: PUSH
83904: LD_INT 0
83906: LESS
83907: IFFALSE 83924
// time := time * - 1 ;
83909: LD_ADDR_VAR 0 8
83913: PUSH
83914: LD_VAR 0 8
83918: PUSH
83919: LD_INT 1
83921: NEG
83922: MUL
83923: ST_TO_ADDR
// wait ( time ) ;
83924: LD_VAR 0 8
83928: PPUSH
83929: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
83933: LD_INT 35
83935: PPUSH
83936: LD_INT 875
83938: PPUSH
83939: CALL_OW 12
83943: PPUSH
83944: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
83948: LD_INT 1
83950: PPUSH
83951: LD_INT 5
83953: PPUSH
83954: CALL_OW 12
83958: PPUSH
83959: LD_VAR 0 1
83963: PPUSH
83964: LD_INT 1
83966: PPUSH
83967: CALL_OW 55
// end ;
83971: GO 83781
// end ;
83973: LD_VAR 0 5
83977: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
83978: LD_INT 0
83980: PPUSH
83981: PPUSH
83982: PPUSH
83983: PPUSH
83984: PPUSH
83985: PPUSH
83986: PPUSH
83987: PPUSH
// if not turrets or not factories then
83988: LD_VAR 0 1
83992: NOT
83993: PUSH
83994: LD_VAR 0 2
83998: NOT
83999: OR
84000: IFFALSE 84004
// exit ;
84002: GO 84311
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84004: LD_ADDR_VAR 0 10
84008: PUSH
84009: LD_INT 5
84011: PUSH
84012: LD_INT 6
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 2
84021: PUSH
84022: LD_INT 4
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 3
84031: PUSH
84032: LD_INT 5
84034: PUSH
84035: EMPTY
84036: LIST
84037: LIST
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 24
84046: PUSH
84047: LD_INT 25
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 23
84056: PUSH
84057: LD_INT 27
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 42
84070: PUSH
84071: LD_INT 43
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 44
84080: PUSH
84081: LD_INT 46
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 45
84090: PUSH
84091: LD_INT 47
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: LIST
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: LIST
84107: ST_TO_ADDR
// result := [ ] ;
84108: LD_ADDR_VAR 0 3
84112: PUSH
84113: EMPTY
84114: ST_TO_ADDR
// for i in turrets do
84115: LD_ADDR_VAR 0 4
84119: PUSH
84120: LD_VAR 0 1
84124: PUSH
84125: FOR_IN
84126: IFFALSE 84309
// begin nat := GetNation ( i ) ;
84128: LD_ADDR_VAR 0 7
84132: PUSH
84133: LD_VAR 0 4
84137: PPUSH
84138: CALL_OW 248
84142: ST_TO_ADDR
// weapon := 0 ;
84143: LD_ADDR_VAR 0 8
84147: PUSH
84148: LD_INT 0
84150: ST_TO_ADDR
// if not nat then
84151: LD_VAR 0 7
84155: NOT
84156: IFFALSE 84160
// continue ;
84158: GO 84125
// for j in list [ nat ] do
84160: LD_ADDR_VAR 0 5
84164: PUSH
84165: LD_VAR 0 10
84169: PUSH
84170: LD_VAR 0 7
84174: ARRAY
84175: PUSH
84176: FOR_IN
84177: IFFALSE 84218
// if GetBWeapon ( i ) = j [ 1 ] then
84179: LD_VAR 0 4
84183: PPUSH
84184: CALL_OW 269
84188: PUSH
84189: LD_VAR 0 5
84193: PUSH
84194: LD_INT 1
84196: ARRAY
84197: EQUAL
84198: IFFALSE 84216
// begin weapon := j [ 2 ] ;
84200: LD_ADDR_VAR 0 8
84204: PUSH
84205: LD_VAR 0 5
84209: PUSH
84210: LD_INT 2
84212: ARRAY
84213: ST_TO_ADDR
// break ;
84214: GO 84218
// end ;
84216: GO 84176
84218: POP
84219: POP
// if not weapon then
84220: LD_VAR 0 8
84224: NOT
84225: IFFALSE 84229
// continue ;
84227: GO 84125
// for k in factories do
84229: LD_ADDR_VAR 0 6
84233: PUSH
84234: LD_VAR 0 2
84238: PUSH
84239: FOR_IN
84240: IFFALSE 84305
// begin weapons := AvailableWeaponList ( k ) ;
84242: LD_ADDR_VAR 0 9
84246: PUSH
84247: LD_VAR 0 6
84251: PPUSH
84252: CALL_OW 478
84256: ST_TO_ADDR
// if not weapons then
84257: LD_VAR 0 9
84261: NOT
84262: IFFALSE 84266
// continue ;
84264: GO 84239
// if weapon in weapons then
84266: LD_VAR 0 8
84270: PUSH
84271: LD_VAR 0 9
84275: IN
84276: IFFALSE 84303
// begin result := [ i , weapon ] ;
84278: LD_ADDR_VAR 0 3
84282: PUSH
84283: LD_VAR 0 4
84287: PUSH
84288: LD_VAR 0 8
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: ST_TO_ADDR
// exit ;
84297: POP
84298: POP
84299: POP
84300: POP
84301: GO 84311
// end ; end ;
84303: GO 84239
84305: POP
84306: POP
// end ;
84307: GO 84125
84309: POP
84310: POP
// end ;
84311: LD_VAR 0 3
84315: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
84316: LD_INT 0
84318: PPUSH
// if not side or side > 8 then
84319: LD_VAR 0 3
84323: NOT
84324: PUSH
84325: LD_VAR 0 3
84329: PUSH
84330: LD_INT 8
84332: GREATER
84333: OR
84334: IFFALSE 84338
// exit ;
84336: GO 84397
// if not range then
84338: LD_VAR 0 4
84342: NOT
84343: IFFALSE 84354
// range := - 12 ;
84345: LD_ADDR_VAR 0 4
84349: PUSH
84350: LD_INT 12
84352: NEG
84353: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
84354: LD_VAR 0 1
84358: PPUSH
84359: LD_VAR 0 2
84363: PPUSH
84364: LD_VAR 0 3
84368: PPUSH
84369: LD_VAR 0 4
84373: PPUSH
84374: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
84378: LD_VAR 0 1
84382: PPUSH
84383: LD_VAR 0 2
84387: PPUSH
84388: LD_VAR 0 3
84392: PPUSH
84393: CALL_OW 331
// end ;
84397: LD_VAR 0 5
84401: RET
// export function Video ( mode ) ; begin
84402: LD_INT 0
84404: PPUSH
// ingame_video = mode ;
84405: LD_ADDR_OWVAR 52
84409: PUSH
84410: LD_VAR 0 1
84414: ST_TO_ADDR
// interface_hidden = mode ;
84415: LD_ADDR_OWVAR 54
84419: PUSH
84420: LD_VAR 0 1
84424: ST_TO_ADDR
// end ;
84425: LD_VAR 0 2
84429: RET
// export function Join ( array , element ) ; begin
84430: LD_INT 0
84432: PPUSH
// result := Replace ( array , array + 1 , element ) ;
84433: LD_ADDR_VAR 0 3
84437: PUSH
84438: LD_VAR 0 1
84442: PPUSH
84443: LD_VAR 0 1
84447: PUSH
84448: LD_INT 1
84450: PLUS
84451: PPUSH
84452: LD_VAR 0 2
84456: PPUSH
84457: CALL_OW 1
84461: ST_TO_ADDR
// end ;
84462: LD_VAR 0 3
84466: RET
// export function JoinUnion ( array , element ) ; begin
84467: LD_INT 0
84469: PPUSH
// result := array union element ;
84470: LD_ADDR_VAR 0 3
84474: PUSH
84475: LD_VAR 0 1
84479: PUSH
84480: LD_VAR 0 2
84484: UNION
84485: ST_TO_ADDR
// end ;
84486: LD_VAR 0 3
84490: RET
// export function GetBehemoths ( side ) ; begin
84491: LD_INT 0
84493: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
84494: LD_ADDR_VAR 0 2
84498: PUSH
84499: LD_INT 22
84501: PUSH
84502: LD_VAR 0 1
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 31
84513: PUSH
84514: LD_INT 25
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PPUSH
84525: CALL_OW 69
84529: ST_TO_ADDR
// end ;
84530: LD_VAR 0 2
84534: RET
// export function Shuffle ( array ) ; var i , index ; begin
84535: LD_INT 0
84537: PPUSH
84538: PPUSH
84539: PPUSH
// result := [ ] ;
84540: LD_ADDR_VAR 0 2
84544: PUSH
84545: EMPTY
84546: ST_TO_ADDR
// if not array then
84547: LD_VAR 0 1
84551: NOT
84552: IFFALSE 84556
// exit ;
84554: GO 84655
// Randomize ;
84556: CALL_OW 10
// for i = array downto 1 do
84560: LD_ADDR_VAR 0 3
84564: PUSH
84565: DOUBLE
84566: LD_VAR 0 1
84570: INC
84571: ST_TO_ADDR
84572: LD_INT 1
84574: PUSH
84575: FOR_DOWNTO
84576: IFFALSE 84653
// begin index := rand ( 1 , array ) ;
84578: LD_ADDR_VAR 0 4
84582: PUSH
84583: LD_INT 1
84585: PPUSH
84586: LD_VAR 0 1
84590: PPUSH
84591: CALL_OW 12
84595: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
84596: LD_ADDR_VAR 0 2
84600: PUSH
84601: LD_VAR 0 2
84605: PPUSH
84606: LD_VAR 0 2
84610: PUSH
84611: LD_INT 1
84613: PLUS
84614: PPUSH
84615: LD_VAR 0 1
84619: PUSH
84620: LD_VAR 0 4
84624: ARRAY
84625: PPUSH
84626: CALL_OW 2
84630: ST_TO_ADDR
// array := Delete ( array , index ) ;
84631: LD_ADDR_VAR 0 1
84635: PUSH
84636: LD_VAR 0 1
84640: PPUSH
84641: LD_VAR 0 4
84645: PPUSH
84646: CALL_OW 3
84650: ST_TO_ADDR
// end ;
84651: GO 84575
84653: POP
84654: POP
// end ;
84655: LD_VAR 0 2
84659: RET
// export function GetBaseMaterials ( base ) ; begin
84660: LD_INT 0
84662: PPUSH
// result := [ 0 , 0 , 0 ] ;
84663: LD_ADDR_VAR 0 2
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: LIST
84681: ST_TO_ADDR
// if not base then
84682: LD_VAR 0 1
84686: NOT
84687: IFFALSE 84691
// exit ;
84689: GO 84740
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
84691: LD_ADDR_VAR 0 2
84695: PUSH
84696: LD_VAR 0 1
84700: PPUSH
84701: LD_INT 1
84703: PPUSH
84704: CALL_OW 275
84708: PUSH
84709: LD_VAR 0 1
84713: PPUSH
84714: LD_INT 2
84716: PPUSH
84717: CALL_OW 275
84721: PUSH
84722: LD_VAR 0 1
84726: PPUSH
84727: LD_INT 3
84729: PPUSH
84730: CALL_OW 275
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: LIST
84739: ST_TO_ADDR
// end ;
84740: LD_VAR 0 2
84744: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
84745: LD_INT 0
84747: PPUSH
84748: PPUSH
// result := array ;
84749: LD_ADDR_VAR 0 3
84753: PUSH
84754: LD_VAR 0 1
84758: ST_TO_ADDR
// if size > 0 then
84759: LD_VAR 0 2
84763: PUSH
84764: LD_INT 0
84766: GREATER
84767: IFFALSE 84813
// for i := array downto size do
84769: LD_ADDR_VAR 0 4
84773: PUSH
84774: DOUBLE
84775: LD_VAR 0 1
84779: INC
84780: ST_TO_ADDR
84781: LD_VAR 0 2
84785: PUSH
84786: FOR_DOWNTO
84787: IFFALSE 84811
// result := Delete ( result , result ) ;
84789: LD_ADDR_VAR 0 3
84793: PUSH
84794: LD_VAR 0 3
84798: PPUSH
84799: LD_VAR 0 3
84803: PPUSH
84804: CALL_OW 3
84808: ST_TO_ADDR
84809: GO 84786
84811: POP
84812: POP
// end ;
84813: LD_VAR 0 3
84817: RET
// export function ComExit ( unit ) ; var tmp ; begin
84818: LD_INT 0
84820: PPUSH
84821: PPUSH
// if not IsInUnit ( unit ) then
84822: LD_VAR 0 1
84826: PPUSH
84827: CALL_OW 310
84831: NOT
84832: IFFALSE 84836
// exit ;
84834: GO 84896
// tmp := IsInUnit ( unit ) ;
84836: LD_ADDR_VAR 0 3
84840: PUSH
84841: LD_VAR 0 1
84845: PPUSH
84846: CALL_OW 310
84850: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
84851: LD_VAR 0 3
84855: PPUSH
84856: CALL_OW 247
84860: PUSH
84861: LD_INT 2
84863: EQUAL
84864: IFFALSE 84877
// ComExitVehicle ( unit ) else
84866: LD_VAR 0 1
84870: PPUSH
84871: CALL_OW 121
84875: GO 84886
// ComExitBuilding ( unit ) ;
84877: LD_VAR 0 1
84881: PPUSH
84882: CALL_OW 122
// result := tmp ;
84886: LD_ADDR_VAR 0 2
84890: PUSH
84891: LD_VAR 0 3
84895: ST_TO_ADDR
// end ;
84896: LD_VAR 0 2
84900: RET
// export function ComExitAll ( units ) ; var i ; begin
84901: LD_INT 0
84903: PPUSH
84904: PPUSH
// if not units then
84905: LD_VAR 0 1
84909: NOT
84910: IFFALSE 84914
// exit ;
84912: GO 84940
// for i in units do
84914: LD_ADDR_VAR 0 3
84918: PUSH
84919: LD_VAR 0 1
84923: PUSH
84924: FOR_IN
84925: IFFALSE 84938
// ComExit ( i ) ;
84927: LD_VAR 0 3
84931: PPUSH
84932: CALL 84818 0 1
84936: GO 84924
84938: POP
84939: POP
// end ;
84940: LD_VAR 0 2
84944: RET
// export function ResetHc ; begin
84945: LD_INT 0
84947: PPUSH
// InitHc ;
84948: CALL_OW 19
// hc_importance := 0 ;
84952: LD_ADDR_OWVAR 32
84956: PUSH
84957: LD_INT 0
84959: ST_TO_ADDR
// end ;
84960: LD_VAR 0 1
84964: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
84965: LD_INT 0
84967: PPUSH
84968: PPUSH
84969: PPUSH
// _x := ( x1 + x2 ) div 2 ;
84970: LD_ADDR_VAR 0 6
84974: PUSH
84975: LD_VAR 0 1
84979: PUSH
84980: LD_VAR 0 3
84984: PLUS
84985: PUSH
84986: LD_INT 2
84988: DIV
84989: ST_TO_ADDR
// if _x < 0 then
84990: LD_VAR 0 6
84994: PUSH
84995: LD_INT 0
84997: LESS
84998: IFFALSE 85015
// _x := _x * - 1 ;
85000: LD_ADDR_VAR 0 6
85004: PUSH
85005: LD_VAR 0 6
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: MUL
85014: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85015: LD_ADDR_VAR 0 7
85019: PUSH
85020: LD_VAR 0 2
85024: PUSH
85025: LD_VAR 0 4
85029: PLUS
85030: PUSH
85031: LD_INT 2
85033: DIV
85034: ST_TO_ADDR
// if _y < 0 then
85035: LD_VAR 0 7
85039: PUSH
85040: LD_INT 0
85042: LESS
85043: IFFALSE 85060
// _y := _y * - 1 ;
85045: LD_ADDR_VAR 0 7
85049: PUSH
85050: LD_VAR 0 7
85054: PUSH
85055: LD_INT 1
85057: NEG
85058: MUL
85059: ST_TO_ADDR
// result := [ _x , _y ] ;
85060: LD_ADDR_VAR 0 5
85064: PUSH
85065: LD_VAR 0 6
85069: PUSH
85070: LD_VAR 0 7
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: ST_TO_ADDR
// end ;
85079: LD_VAR 0 5
85083: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85084: LD_INT 0
85086: PPUSH
85087: PPUSH
85088: PPUSH
85089: PPUSH
// task := GetTaskList ( unit ) ;
85090: LD_ADDR_VAR 0 7
85094: PUSH
85095: LD_VAR 0 1
85099: PPUSH
85100: CALL_OW 437
85104: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85105: LD_VAR 0 7
85109: NOT
85110: PUSH
85111: LD_VAR 0 1
85115: PPUSH
85116: LD_VAR 0 2
85120: PPUSH
85121: CALL_OW 308
85125: NOT
85126: AND
85127: IFFALSE 85131
// exit ;
85129: GO 85249
// if IsInArea ( unit , area ) then
85131: LD_VAR 0 1
85135: PPUSH
85136: LD_VAR 0 2
85140: PPUSH
85141: CALL_OW 308
85145: IFFALSE 85163
// begin ComMoveToArea ( unit , goAway ) ;
85147: LD_VAR 0 1
85151: PPUSH
85152: LD_VAR 0 3
85156: PPUSH
85157: CALL_OW 113
// exit ;
85161: GO 85249
// end ; if task [ 1 ] [ 1 ] <> M then
85163: LD_VAR 0 7
85167: PUSH
85168: LD_INT 1
85170: ARRAY
85171: PUSH
85172: LD_INT 1
85174: ARRAY
85175: PUSH
85176: LD_STRING M
85178: NONEQUAL
85179: IFFALSE 85183
// exit ;
85181: GO 85249
// x := task [ 1 ] [ 2 ] ;
85183: LD_ADDR_VAR 0 5
85187: PUSH
85188: LD_VAR 0 7
85192: PUSH
85193: LD_INT 1
85195: ARRAY
85196: PUSH
85197: LD_INT 2
85199: ARRAY
85200: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
85201: LD_ADDR_VAR 0 6
85205: PUSH
85206: LD_VAR 0 7
85210: PUSH
85211: LD_INT 1
85213: ARRAY
85214: PUSH
85215: LD_INT 3
85217: ARRAY
85218: ST_TO_ADDR
// if InArea ( x , y , area ) then
85219: LD_VAR 0 5
85223: PPUSH
85224: LD_VAR 0 6
85228: PPUSH
85229: LD_VAR 0 2
85233: PPUSH
85234: CALL_OW 309
85238: IFFALSE 85249
// ComStop ( unit ) ;
85240: LD_VAR 0 1
85244: PPUSH
85245: CALL_OW 141
// end ;
85249: LD_VAR 0 4
85253: RET
// export function Abs ( value ) ; begin
85254: LD_INT 0
85256: PPUSH
// result := value ;
85257: LD_ADDR_VAR 0 2
85261: PUSH
85262: LD_VAR 0 1
85266: ST_TO_ADDR
// if value < 0 then
85267: LD_VAR 0 1
85271: PUSH
85272: LD_INT 0
85274: LESS
85275: IFFALSE 85292
// result := value * - 1 ;
85277: LD_ADDR_VAR 0 2
85281: PUSH
85282: LD_VAR 0 1
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: MUL
85291: ST_TO_ADDR
// end ;
85292: LD_VAR 0 2
85296: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
85297: LD_INT 0
85299: PPUSH
85300: PPUSH
85301: PPUSH
85302: PPUSH
85303: PPUSH
85304: PPUSH
85305: PPUSH
85306: PPUSH
// if not unit or not building then
85307: LD_VAR 0 1
85311: NOT
85312: PUSH
85313: LD_VAR 0 2
85317: NOT
85318: OR
85319: IFFALSE 85323
// exit ;
85321: GO 85549
// x := GetX ( building ) ;
85323: LD_ADDR_VAR 0 4
85327: PUSH
85328: LD_VAR 0 2
85332: PPUSH
85333: CALL_OW 250
85337: ST_TO_ADDR
// y := GetY ( building ) ;
85338: LD_ADDR_VAR 0 6
85342: PUSH
85343: LD_VAR 0 2
85347: PPUSH
85348: CALL_OW 251
85352: ST_TO_ADDR
// d := GetDir ( building ) ;
85353: LD_ADDR_VAR 0 8
85357: PUSH
85358: LD_VAR 0 2
85362: PPUSH
85363: CALL_OW 254
85367: ST_TO_ADDR
// r := 4 ;
85368: LD_ADDR_VAR 0 9
85372: PUSH
85373: LD_INT 4
85375: ST_TO_ADDR
// for i := 1 to 5 do
85376: LD_ADDR_VAR 0 10
85380: PUSH
85381: DOUBLE
85382: LD_INT 1
85384: DEC
85385: ST_TO_ADDR
85386: LD_INT 5
85388: PUSH
85389: FOR_TO
85390: IFFALSE 85547
// begin _x := ShiftX ( x , d , r + i ) ;
85392: LD_ADDR_VAR 0 5
85396: PUSH
85397: LD_VAR 0 4
85401: PPUSH
85402: LD_VAR 0 8
85406: PPUSH
85407: LD_VAR 0 9
85411: PUSH
85412: LD_VAR 0 10
85416: PLUS
85417: PPUSH
85418: CALL_OW 272
85422: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
85423: LD_ADDR_VAR 0 7
85427: PUSH
85428: LD_VAR 0 6
85432: PPUSH
85433: LD_VAR 0 8
85437: PPUSH
85438: LD_VAR 0 9
85442: PUSH
85443: LD_VAR 0 10
85447: PLUS
85448: PPUSH
85449: CALL_OW 273
85453: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
85454: LD_VAR 0 5
85458: PPUSH
85459: LD_VAR 0 7
85463: PPUSH
85464: CALL_OW 488
85468: PUSH
85469: LD_VAR 0 5
85473: PPUSH
85474: LD_VAR 0 7
85478: PPUSH
85479: CALL_OW 428
85483: PPUSH
85484: CALL_OW 247
85488: PUSH
85489: LD_INT 3
85491: PUSH
85492: LD_INT 2
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: IN
85499: NOT
85500: AND
85501: IFFALSE 85545
// begin ComMoveXY ( unit , _x , _y ) ;
85503: LD_VAR 0 1
85507: PPUSH
85508: LD_VAR 0 5
85512: PPUSH
85513: LD_VAR 0 7
85517: PPUSH
85518: CALL_OW 111
// result := [ _x , _y ] ;
85522: LD_ADDR_VAR 0 3
85526: PUSH
85527: LD_VAR 0 5
85531: PUSH
85532: LD_VAR 0 7
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: ST_TO_ADDR
// exit ;
85541: POP
85542: POP
85543: GO 85549
// end ; end ;
85545: GO 85389
85547: POP
85548: POP
// end ;
85549: LD_VAR 0 3
85553: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
85554: LD_INT 0
85556: PPUSH
85557: PPUSH
85558: PPUSH
// result := 0 ;
85559: LD_ADDR_VAR 0 3
85563: PUSH
85564: LD_INT 0
85566: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
85567: LD_VAR 0 1
85571: PUSH
85572: LD_INT 0
85574: LESS
85575: PUSH
85576: LD_VAR 0 1
85580: PUSH
85581: LD_INT 8
85583: GREATER
85584: OR
85585: PUSH
85586: LD_VAR 0 2
85590: PUSH
85591: LD_INT 0
85593: LESS
85594: OR
85595: PUSH
85596: LD_VAR 0 2
85600: PUSH
85601: LD_INT 8
85603: GREATER
85604: OR
85605: IFFALSE 85609
// exit ;
85607: GO 85684
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
85609: LD_ADDR_VAR 0 4
85613: PUSH
85614: LD_INT 22
85616: PUSH
85617: LD_VAR 0 2
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PPUSH
85626: CALL_OW 69
85630: PUSH
85631: FOR_IN
85632: IFFALSE 85682
// begin un := UnitShoot ( i ) ;
85634: LD_ADDR_VAR 0 5
85638: PUSH
85639: LD_VAR 0 4
85643: PPUSH
85644: CALL_OW 504
85648: ST_TO_ADDR
// if GetSide ( un ) = side1 then
85649: LD_VAR 0 5
85653: PPUSH
85654: CALL_OW 255
85658: PUSH
85659: LD_VAR 0 1
85663: EQUAL
85664: IFFALSE 85680
// begin result := un ;
85666: LD_ADDR_VAR 0 3
85670: PUSH
85671: LD_VAR 0 5
85675: ST_TO_ADDR
// exit ;
85676: POP
85677: POP
85678: GO 85684
// end ; end ;
85680: GO 85631
85682: POP
85683: POP
// end ;
85684: LD_VAR 0 3
85688: RET
// export function GetCargoBay ( units ) ; begin
85689: LD_INT 0
85691: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
85692: LD_ADDR_VAR 0 2
85696: PUSH
85697: LD_VAR 0 1
85701: PPUSH
85702: LD_INT 2
85704: PUSH
85705: LD_INT 34
85707: PUSH
85708: LD_INT 12
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 34
85717: PUSH
85718: LD_INT 51
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 34
85727: PUSH
85728: LD_INT 32
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 34
85737: PUSH
85738: LD_EXP 95
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: PPUSH
85754: CALL_OW 72
85758: ST_TO_ADDR
// end ; end_of_file
85759: LD_VAR 0 2
85763: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
85764: LD_INT 0
85766: PPUSH
// ar_miner := 81 ;
85767: LD_ADDR_EXP 101
85771: PUSH
85772: LD_INT 81
85774: ST_TO_ADDR
// ar_crane := 88 ;
85775: LD_ADDR_EXP 100
85779: PUSH
85780: LD_INT 88
85782: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85783: LD_ADDR_EXP 95
85787: PUSH
85788: LD_INT 89
85790: ST_TO_ADDR
// us_hack := 99 ;
85791: LD_ADDR_EXP 96
85795: PUSH
85796: LD_INT 99
85798: ST_TO_ADDR
// us_artillery := 97 ;
85799: LD_ADDR_EXP 97
85803: PUSH
85804: LD_INT 97
85806: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85807: LD_ADDR_EXP 98
85811: PUSH
85812: LD_INT 91
85814: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
85815: LD_ADDR_EXP 99
85819: PUSH
85820: LD_INT 92
85822: ST_TO_ADDR
// ru_radar := 98 ;
85823: LD_ADDR_EXP 94
85827: PUSH
85828: LD_INT 98
85830: ST_TO_ADDR
// tech_Artillery := 80 ;
85831: LD_ADDR_EXP 102
85835: PUSH
85836: LD_INT 80
85838: ST_TO_ADDR
// tech_RadMat := 81 ;
85839: LD_ADDR_EXP 103
85843: PUSH
85844: LD_INT 81
85846: ST_TO_ADDR
// tech_BasicTools := 82 ;
85847: LD_ADDR_EXP 104
85851: PUSH
85852: LD_INT 82
85854: ST_TO_ADDR
// tech_Cargo := 83 ;
85855: LD_ADDR_EXP 105
85859: PUSH
85860: LD_INT 83
85862: ST_TO_ADDR
// tech_Track := 84 ;
85863: LD_ADDR_EXP 106
85867: PUSH
85868: LD_INT 84
85870: ST_TO_ADDR
// tech_Crane := 85 ;
85871: LD_ADDR_EXP 107
85875: PUSH
85876: LD_INT 85
85878: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85879: LD_ADDR_EXP 108
85883: PUSH
85884: LD_INT 86
85886: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85887: LD_ADDR_EXP 109
85891: PUSH
85892: LD_INT 87
85894: ST_TO_ADDR
// class_mastodont := 31 ;
85895: LD_ADDR_EXP 110
85899: PUSH
85900: LD_INT 31
85902: ST_TO_ADDR
// class_horse := 21 ;
85903: LD_ADDR_EXP 111
85907: PUSH
85908: LD_INT 21
85910: ST_TO_ADDR
// end ;
85911: LD_VAR 0 1
85915: RET
// every 1 do
85916: GO 85918
85918: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85919: CALL 85764 0 0
85923: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85924: LD_INT 0
85926: PPUSH
// if p2 = 100 then
85927: LD_VAR 0 2
85931: PUSH
85932: LD_INT 100
85934: EQUAL
85935: IFFALSE 86884
// begin if not StreamModeActive then
85937: LD_EXP 112
85941: NOT
85942: IFFALSE 85952
// StreamModeActive := true ;
85944: LD_ADDR_EXP 112
85948: PUSH
85949: LD_INT 1
85951: ST_TO_ADDR
// if p3 = 0 then
85952: LD_VAR 0 3
85956: PUSH
85957: LD_INT 0
85959: EQUAL
85960: IFFALSE 85966
// InitStreamMode ;
85962: CALL 87044 0 0
// if p3 = 1 then
85966: LD_VAR 0 3
85970: PUSH
85971: LD_INT 1
85973: EQUAL
85974: IFFALSE 85984
// sRocket := true ;
85976: LD_ADDR_EXP 117
85980: PUSH
85981: LD_INT 1
85983: ST_TO_ADDR
// if p3 = 2 then
85984: LD_VAR 0 3
85988: PUSH
85989: LD_INT 2
85991: EQUAL
85992: IFFALSE 86002
// sSpeed := true ;
85994: LD_ADDR_EXP 116
85998: PUSH
85999: LD_INT 1
86001: ST_TO_ADDR
// if p3 = 3 then
86002: LD_VAR 0 3
86006: PUSH
86007: LD_INT 3
86009: EQUAL
86010: IFFALSE 86020
// sEngine := true ;
86012: LD_ADDR_EXP 118
86016: PUSH
86017: LD_INT 1
86019: ST_TO_ADDR
// if p3 = 4 then
86020: LD_VAR 0 3
86024: PUSH
86025: LD_INT 4
86027: EQUAL
86028: IFFALSE 86038
// sSpec := true ;
86030: LD_ADDR_EXP 115
86034: PUSH
86035: LD_INT 1
86037: ST_TO_ADDR
// if p3 = 5 then
86038: LD_VAR 0 3
86042: PUSH
86043: LD_INT 5
86045: EQUAL
86046: IFFALSE 86056
// sLevel := true ;
86048: LD_ADDR_EXP 119
86052: PUSH
86053: LD_INT 1
86055: ST_TO_ADDR
// if p3 = 6 then
86056: LD_VAR 0 3
86060: PUSH
86061: LD_INT 6
86063: EQUAL
86064: IFFALSE 86074
// sArmoury := true ;
86066: LD_ADDR_EXP 120
86070: PUSH
86071: LD_INT 1
86073: ST_TO_ADDR
// if p3 = 7 then
86074: LD_VAR 0 3
86078: PUSH
86079: LD_INT 7
86081: EQUAL
86082: IFFALSE 86092
// sRadar := true ;
86084: LD_ADDR_EXP 121
86088: PUSH
86089: LD_INT 1
86091: ST_TO_ADDR
// if p3 = 8 then
86092: LD_VAR 0 3
86096: PUSH
86097: LD_INT 8
86099: EQUAL
86100: IFFALSE 86110
// sBunker := true ;
86102: LD_ADDR_EXP 122
86106: PUSH
86107: LD_INT 1
86109: ST_TO_ADDR
// if p3 = 9 then
86110: LD_VAR 0 3
86114: PUSH
86115: LD_INT 9
86117: EQUAL
86118: IFFALSE 86128
// sHack := true ;
86120: LD_ADDR_EXP 123
86124: PUSH
86125: LD_INT 1
86127: ST_TO_ADDR
// if p3 = 10 then
86128: LD_VAR 0 3
86132: PUSH
86133: LD_INT 10
86135: EQUAL
86136: IFFALSE 86146
// sFire := true ;
86138: LD_ADDR_EXP 124
86142: PUSH
86143: LD_INT 1
86145: ST_TO_ADDR
// if p3 = 11 then
86146: LD_VAR 0 3
86150: PUSH
86151: LD_INT 11
86153: EQUAL
86154: IFFALSE 86164
// sRefresh := true ;
86156: LD_ADDR_EXP 125
86160: PUSH
86161: LD_INT 1
86163: ST_TO_ADDR
// if p3 = 12 then
86164: LD_VAR 0 3
86168: PUSH
86169: LD_INT 12
86171: EQUAL
86172: IFFALSE 86182
// sExp := true ;
86174: LD_ADDR_EXP 126
86178: PUSH
86179: LD_INT 1
86181: ST_TO_ADDR
// if p3 = 13 then
86182: LD_VAR 0 3
86186: PUSH
86187: LD_INT 13
86189: EQUAL
86190: IFFALSE 86200
// sDepot := true ;
86192: LD_ADDR_EXP 127
86196: PUSH
86197: LD_INT 1
86199: ST_TO_ADDR
// if p3 = 14 then
86200: LD_VAR 0 3
86204: PUSH
86205: LD_INT 14
86207: EQUAL
86208: IFFALSE 86218
// sFlag := true ;
86210: LD_ADDR_EXP 128
86214: PUSH
86215: LD_INT 1
86217: ST_TO_ADDR
// if p3 = 15 then
86218: LD_VAR 0 3
86222: PUSH
86223: LD_INT 15
86225: EQUAL
86226: IFFALSE 86236
// sKamikadze := true ;
86228: LD_ADDR_EXP 136
86232: PUSH
86233: LD_INT 1
86235: ST_TO_ADDR
// if p3 = 16 then
86236: LD_VAR 0 3
86240: PUSH
86241: LD_INT 16
86243: EQUAL
86244: IFFALSE 86254
// sTroll := true ;
86246: LD_ADDR_EXP 137
86250: PUSH
86251: LD_INT 1
86253: ST_TO_ADDR
// if p3 = 17 then
86254: LD_VAR 0 3
86258: PUSH
86259: LD_INT 17
86261: EQUAL
86262: IFFALSE 86272
// sSlow := true ;
86264: LD_ADDR_EXP 138
86268: PUSH
86269: LD_INT 1
86271: ST_TO_ADDR
// if p3 = 18 then
86272: LD_VAR 0 3
86276: PUSH
86277: LD_INT 18
86279: EQUAL
86280: IFFALSE 86290
// sLack := true ;
86282: LD_ADDR_EXP 139
86286: PUSH
86287: LD_INT 1
86289: ST_TO_ADDR
// if p3 = 19 then
86290: LD_VAR 0 3
86294: PUSH
86295: LD_INT 19
86297: EQUAL
86298: IFFALSE 86308
// sTank := true ;
86300: LD_ADDR_EXP 141
86304: PUSH
86305: LD_INT 1
86307: ST_TO_ADDR
// if p3 = 20 then
86308: LD_VAR 0 3
86312: PUSH
86313: LD_INT 20
86315: EQUAL
86316: IFFALSE 86326
// sRemote := true ;
86318: LD_ADDR_EXP 142
86322: PUSH
86323: LD_INT 1
86325: ST_TO_ADDR
// if p3 = 21 then
86326: LD_VAR 0 3
86330: PUSH
86331: LD_INT 21
86333: EQUAL
86334: IFFALSE 86344
// sPowell := true ;
86336: LD_ADDR_EXP 143
86340: PUSH
86341: LD_INT 1
86343: ST_TO_ADDR
// if p3 = 22 then
86344: LD_VAR 0 3
86348: PUSH
86349: LD_INT 22
86351: EQUAL
86352: IFFALSE 86362
// sTeleport := true ;
86354: LD_ADDR_EXP 146
86358: PUSH
86359: LD_INT 1
86361: ST_TO_ADDR
// if p3 = 23 then
86362: LD_VAR 0 3
86366: PUSH
86367: LD_INT 23
86369: EQUAL
86370: IFFALSE 86380
// sOilTower := true ;
86372: LD_ADDR_EXP 148
86376: PUSH
86377: LD_INT 1
86379: ST_TO_ADDR
// if p3 = 24 then
86380: LD_VAR 0 3
86384: PUSH
86385: LD_INT 24
86387: EQUAL
86388: IFFALSE 86398
// sShovel := true ;
86390: LD_ADDR_EXP 149
86394: PUSH
86395: LD_INT 1
86397: ST_TO_ADDR
// if p3 = 25 then
86398: LD_VAR 0 3
86402: PUSH
86403: LD_INT 25
86405: EQUAL
86406: IFFALSE 86416
// sSheik := true ;
86408: LD_ADDR_EXP 150
86412: PUSH
86413: LD_INT 1
86415: ST_TO_ADDR
// if p3 = 26 then
86416: LD_VAR 0 3
86420: PUSH
86421: LD_INT 26
86423: EQUAL
86424: IFFALSE 86434
// sEarthquake := true ;
86426: LD_ADDR_EXP 152
86430: PUSH
86431: LD_INT 1
86433: ST_TO_ADDR
// if p3 = 27 then
86434: LD_VAR 0 3
86438: PUSH
86439: LD_INT 27
86441: EQUAL
86442: IFFALSE 86452
// sAI := true ;
86444: LD_ADDR_EXP 153
86448: PUSH
86449: LD_INT 1
86451: ST_TO_ADDR
// if p3 = 28 then
86452: LD_VAR 0 3
86456: PUSH
86457: LD_INT 28
86459: EQUAL
86460: IFFALSE 86470
// sCargo := true ;
86462: LD_ADDR_EXP 156
86466: PUSH
86467: LD_INT 1
86469: ST_TO_ADDR
// if p3 = 29 then
86470: LD_VAR 0 3
86474: PUSH
86475: LD_INT 29
86477: EQUAL
86478: IFFALSE 86488
// sDLaser := true ;
86480: LD_ADDR_EXP 157
86484: PUSH
86485: LD_INT 1
86487: ST_TO_ADDR
// if p3 = 30 then
86488: LD_VAR 0 3
86492: PUSH
86493: LD_INT 30
86495: EQUAL
86496: IFFALSE 86506
// sExchange := true ;
86498: LD_ADDR_EXP 158
86502: PUSH
86503: LD_INT 1
86505: ST_TO_ADDR
// if p3 = 31 then
86506: LD_VAR 0 3
86510: PUSH
86511: LD_INT 31
86513: EQUAL
86514: IFFALSE 86524
// sFac := true ;
86516: LD_ADDR_EXP 159
86520: PUSH
86521: LD_INT 1
86523: ST_TO_ADDR
// if p3 = 32 then
86524: LD_VAR 0 3
86528: PUSH
86529: LD_INT 32
86531: EQUAL
86532: IFFALSE 86542
// sPower := true ;
86534: LD_ADDR_EXP 160
86538: PUSH
86539: LD_INT 1
86541: ST_TO_ADDR
// if p3 = 33 then
86542: LD_VAR 0 3
86546: PUSH
86547: LD_INT 33
86549: EQUAL
86550: IFFALSE 86560
// sRandom := true ;
86552: LD_ADDR_EXP 161
86556: PUSH
86557: LD_INT 1
86559: ST_TO_ADDR
// if p3 = 34 then
86560: LD_VAR 0 3
86564: PUSH
86565: LD_INT 34
86567: EQUAL
86568: IFFALSE 86578
// sShield := true ;
86570: LD_ADDR_EXP 162
86574: PUSH
86575: LD_INT 1
86577: ST_TO_ADDR
// if p3 = 35 then
86578: LD_VAR 0 3
86582: PUSH
86583: LD_INT 35
86585: EQUAL
86586: IFFALSE 86596
// sTime := true ;
86588: LD_ADDR_EXP 163
86592: PUSH
86593: LD_INT 1
86595: ST_TO_ADDR
// if p3 = 36 then
86596: LD_VAR 0 3
86600: PUSH
86601: LD_INT 36
86603: EQUAL
86604: IFFALSE 86614
// sTools := true ;
86606: LD_ADDR_EXP 164
86610: PUSH
86611: LD_INT 1
86613: ST_TO_ADDR
// if p3 = 101 then
86614: LD_VAR 0 3
86618: PUSH
86619: LD_INT 101
86621: EQUAL
86622: IFFALSE 86632
// sSold := true ;
86624: LD_ADDR_EXP 129
86628: PUSH
86629: LD_INT 1
86631: ST_TO_ADDR
// if p3 = 102 then
86632: LD_VAR 0 3
86636: PUSH
86637: LD_INT 102
86639: EQUAL
86640: IFFALSE 86650
// sDiff := true ;
86642: LD_ADDR_EXP 130
86646: PUSH
86647: LD_INT 1
86649: ST_TO_ADDR
// if p3 = 103 then
86650: LD_VAR 0 3
86654: PUSH
86655: LD_INT 103
86657: EQUAL
86658: IFFALSE 86668
// sFog := true ;
86660: LD_ADDR_EXP 133
86664: PUSH
86665: LD_INT 1
86667: ST_TO_ADDR
// if p3 = 104 then
86668: LD_VAR 0 3
86672: PUSH
86673: LD_INT 104
86675: EQUAL
86676: IFFALSE 86686
// sReset := true ;
86678: LD_ADDR_EXP 134
86682: PUSH
86683: LD_INT 1
86685: ST_TO_ADDR
// if p3 = 105 then
86686: LD_VAR 0 3
86690: PUSH
86691: LD_INT 105
86693: EQUAL
86694: IFFALSE 86704
// sSun := true ;
86696: LD_ADDR_EXP 135
86700: PUSH
86701: LD_INT 1
86703: ST_TO_ADDR
// if p3 = 106 then
86704: LD_VAR 0 3
86708: PUSH
86709: LD_INT 106
86711: EQUAL
86712: IFFALSE 86722
// sTiger := true ;
86714: LD_ADDR_EXP 131
86718: PUSH
86719: LD_INT 1
86721: ST_TO_ADDR
// if p3 = 107 then
86722: LD_VAR 0 3
86726: PUSH
86727: LD_INT 107
86729: EQUAL
86730: IFFALSE 86740
// sBomb := true ;
86732: LD_ADDR_EXP 132
86736: PUSH
86737: LD_INT 1
86739: ST_TO_ADDR
// if p3 = 108 then
86740: LD_VAR 0 3
86744: PUSH
86745: LD_INT 108
86747: EQUAL
86748: IFFALSE 86758
// sWound := true ;
86750: LD_ADDR_EXP 140
86754: PUSH
86755: LD_INT 1
86757: ST_TO_ADDR
// if p3 = 109 then
86758: LD_VAR 0 3
86762: PUSH
86763: LD_INT 109
86765: EQUAL
86766: IFFALSE 86776
// sBetray := true ;
86768: LD_ADDR_EXP 144
86772: PUSH
86773: LD_INT 1
86775: ST_TO_ADDR
// if p3 = 110 then
86776: LD_VAR 0 3
86780: PUSH
86781: LD_INT 110
86783: EQUAL
86784: IFFALSE 86794
// sContamin := true ;
86786: LD_ADDR_EXP 145
86790: PUSH
86791: LD_INT 1
86793: ST_TO_ADDR
// if p3 = 111 then
86794: LD_VAR 0 3
86798: PUSH
86799: LD_INT 111
86801: EQUAL
86802: IFFALSE 86812
// sOil := true ;
86804: LD_ADDR_EXP 147
86808: PUSH
86809: LD_INT 1
86811: ST_TO_ADDR
// if p3 = 112 then
86812: LD_VAR 0 3
86816: PUSH
86817: LD_INT 112
86819: EQUAL
86820: IFFALSE 86830
// sStu := true ;
86822: LD_ADDR_EXP 151
86826: PUSH
86827: LD_INT 1
86829: ST_TO_ADDR
// if p3 = 113 then
86830: LD_VAR 0 3
86834: PUSH
86835: LD_INT 113
86837: EQUAL
86838: IFFALSE 86848
// sBazooka := true ;
86840: LD_ADDR_EXP 154
86844: PUSH
86845: LD_INT 1
86847: ST_TO_ADDR
// if p3 = 114 then
86848: LD_VAR 0 3
86852: PUSH
86853: LD_INT 114
86855: EQUAL
86856: IFFALSE 86866
// sMortar := true ;
86858: LD_ADDR_EXP 155
86862: PUSH
86863: LD_INT 1
86865: ST_TO_ADDR
// if p3 = 115 then
86866: LD_VAR 0 3
86870: PUSH
86871: LD_INT 115
86873: EQUAL
86874: IFFALSE 86884
// sRanger := true ;
86876: LD_ADDR_EXP 165
86880: PUSH
86881: LD_INT 1
86883: ST_TO_ADDR
// end ; if p2 = 101 then
86884: LD_VAR 0 2
86888: PUSH
86889: LD_INT 101
86891: EQUAL
86892: IFFALSE 87020
// begin case p3 of 1 :
86894: LD_VAR 0 3
86898: PUSH
86899: LD_INT 1
86901: DOUBLE
86902: EQUAL
86903: IFTRUE 86907
86905: GO 86914
86907: POP
// hHackUnlimitedResources ; 2 :
86908: CALL 98057 0 0
86912: GO 87020
86914: LD_INT 2
86916: DOUBLE
86917: EQUAL
86918: IFTRUE 86922
86920: GO 86929
86922: POP
// hHackSetLevel10 ; 3 :
86923: CALL 98190 0 0
86927: GO 87020
86929: LD_INT 3
86931: DOUBLE
86932: EQUAL
86933: IFTRUE 86937
86935: GO 86944
86937: POP
// hHackSetLevel10YourUnits ; 4 :
86938: CALL 98275 0 0
86942: GO 87020
86944: LD_INT 4
86946: DOUBLE
86947: EQUAL
86948: IFTRUE 86952
86950: GO 86959
86952: POP
// hHackInvincible ; 5 :
86953: CALL 98723 0 0
86957: GO 87020
86959: LD_INT 5
86961: DOUBLE
86962: EQUAL
86963: IFTRUE 86967
86965: GO 86974
86967: POP
// hHackInvisible ; 6 :
86968: CALL 98834 0 0
86972: GO 87020
86974: LD_INT 6
86976: DOUBLE
86977: EQUAL
86978: IFTRUE 86982
86980: GO 86989
86982: POP
// hHackChangeYourSide ; 7 :
86983: CALL 98891 0 0
86987: GO 87020
86989: LD_INT 7
86991: DOUBLE
86992: EQUAL
86993: IFTRUE 86997
86995: GO 87004
86997: POP
// hHackChangeUnitSide ; 8 :
86998: CALL 98933 0 0
87002: GO 87020
87004: LD_INT 8
87006: DOUBLE
87007: EQUAL
87008: IFTRUE 87012
87010: GO 87019
87012: POP
// hHackFog ; end ;
87013: CALL 99034 0 0
87017: GO 87020
87019: POP
// end ; end ;
87020: LD_VAR 0 7
87024: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87025: GO 87027
87027: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87028: LD_STRING initStreamRollete();
87030: PPUSH
87031: CALL_OW 559
// InitStreamMode ;
87035: CALL 87044 0 0
// DefineStreamItems ( ) ;
87039: CALL 87484 0 0
// end ;
87043: END
// function InitStreamMode ; begin
87044: LD_INT 0
87046: PPUSH
// streamModeActive := false ;
87047: LD_ADDR_EXP 112
87051: PUSH
87052: LD_INT 0
87054: ST_TO_ADDR
// normalCounter := 36 ;
87055: LD_ADDR_EXP 113
87059: PUSH
87060: LD_INT 36
87062: ST_TO_ADDR
// hardcoreCounter := 16 ;
87063: LD_ADDR_EXP 114
87067: PUSH
87068: LD_INT 16
87070: ST_TO_ADDR
// sRocket := false ;
87071: LD_ADDR_EXP 117
87075: PUSH
87076: LD_INT 0
87078: ST_TO_ADDR
// sSpeed := false ;
87079: LD_ADDR_EXP 116
87083: PUSH
87084: LD_INT 0
87086: ST_TO_ADDR
// sEngine := false ;
87087: LD_ADDR_EXP 118
87091: PUSH
87092: LD_INT 0
87094: ST_TO_ADDR
// sSpec := false ;
87095: LD_ADDR_EXP 115
87099: PUSH
87100: LD_INT 0
87102: ST_TO_ADDR
// sLevel := false ;
87103: LD_ADDR_EXP 119
87107: PUSH
87108: LD_INT 0
87110: ST_TO_ADDR
// sArmoury := false ;
87111: LD_ADDR_EXP 120
87115: PUSH
87116: LD_INT 0
87118: ST_TO_ADDR
// sRadar := false ;
87119: LD_ADDR_EXP 121
87123: PUSH
87124: LD_INT 0
87126: ST_TO_ADDR
// sBunker := false ;
87127: LD_ADDR_EXP 122
87131: PUSH
87132: LD_INT 0
87134: ST_TO_ADDR
// sHack := false ;
87135: LD_ADDR_EXP 123
87139: PUSH
87140: LD_INT 0
87142: ST_TO_ADDR
// sFire := false ;
87143: LD_ADDR_EXP 124
87147: PUSH
87148: LD_INT 0
87150: ST_TO_ADDR
// sRefresh := false ;
87151: LD_ADDR_EXP 125
87155: PUSH
87156: LD_INT 0
87158: ST_TO_ADDR
// sExp := false ;
87159: LD_ADDR_EXP 126
87163: PUSH
87164: LD_INT 0
87166: ST_TO_ADDR
// sDepot := false ;
87167: LD_ADDR_EXP 127
87171: PUSH
87172: LD_INT 0
87174: ST_TO_ADDR
// sFlag := false ;
87175: LD_ADDR_EXP 128
87179: PUSH
87180: LD_INT 0
87182: ST_TO_ADDR
// sKamikadze := false ;
87183: LD_ADDR_EXP 136
87187: PUSH
87188: LD_INT 0
87190: ST_TO_ADDR
// sTroll := false ;
87191: LD_ADDR_EXP 137
87195: PUSH
87196: LD_INT 0
87198: ST_TO_ADDR
// sSlow := false ;
87199: LD_ADDR_EXP 138
87203: PUSH
87204: LD_INT 0
87206: ST_TO_ADDR
// sLack := false ;
87207: LD_ADDR_EXP 139
87211: PUSH
87212: LD_INT 0
87214: ST_TO_ADDR
// sTank := false ;
87215: LD_ADDR_EXP 141
87219: PUSH
87220: LD_INT 0
87222: ST_TO_ADDR
// sRemote := false ;
87223: LD_ADDR_EXP 142
87227: PUSH
87228: LD_INT 0
87230: ST_TO_ADDR
// sPowell := false ;
87231: LD_ADDR_EXP 143
87235: PUSH
87236: LD_INT 0
87238: ST_TO_ADDR
// sTeleport := false ;
87239: LD_ADDR_EXP 146
87243: PUSH
87244: LD_INT 0
87246: ST_TO_ADDR
// sOilTower := false ;
87247: LD_ADDR_EXP 148
87251: PUSH
87252: LD_INT 0
87254: ST_TO_ADDR
// sShovel := false ;
87255: LD_ADDR_EXP 149
87259: PUSH
87260: LD_INT 0
87262: ST_TO_ADDR
// sSheik := false ;
87263: LD_ADDR_EXP 150
87267: PUSH
87268: LD_INT 0
87270: ST_TO_ADDR
// sEarthquake := false ;
87271: LD_ADDR_EXP 152
87275: PUSH
87276: LD_INT 0
87278: ST_TO_ADDR
// sAI := false ;
87279: LD_ADDR_EXP 153
87283: PUSH
87284: LD_INT 0
87286: ST_TO_ADDR
// sCargo := false ;
87287: LD_ADDR_EXP 156
87291: PUSH
87292: LD_INT 0
87294: ST_TO_ADDR
// sDLaser := false ;
87295: LD_ADDR_EXP 157
87299: PUSH
87300: LD_INT 0
87302: ST_TO_ADDR
// sExchange := false ;
87303: LD_ADDR_EXP 158
87307: PUSH
87308: LD_INT 0
87310: ST_TO_ADDR
// sFac := false ;
87311: LD_ADDR_EXP 159
87315: PUSH
87316: LD_INT 0
87318: ST_TO_ADDR
// sPower := false ;
87319: LD_ADDR_EXP 160
87323: PUSH
87324: LD_INT 0
87326: ST_TO_ADDR
// sRandom := false ;
87327: LD_ADDR_EXP 161
87331: PUSH
87332: LD_INT 0
87334: ST_TO_ADDR
// sShield := false ;
87335: LD_ADDR_EXP 162
87339: PUSH
87340: LD_INT 0
87342: ST_TO_ADDR
// sTime := false ;
87343: LD_ADDR_EXP 163
87347: PUSH
87348: LD_INT 0
87350: ST_TO_ADDR
// sTools := false ;
87351: LD_ADDR_EXP 164
87355: PUSH
87356: LD_INT 0
87358: ST_TO_ADDR
// sSold := false ;
87359: LD_ADDR_EXP 129
87363: PUSH
87364: LD_INT 0
87366: ST_TO_ADDR
// sDiff := false ;
87367: LD_ADDR_EXP 130
87371: PUSH
87372: LD_INT 0
87374: ST_TO_ADDR
// sFog := false ;
87375: LD_ADDR_EXP 133
87379: PUSH
87380: LD_INT 0
87382: ST_TO_ADDR
// sReset := false ;
87383: LD_ADDR_EXP 134
87387: PUSH
87388: LD_INT 0
87390: ST_TO_ADDR
// sSun := false ;
87391: LD_ADDR_EXP 135
87395: PUSH
87396: LD_INT 0
87398: ST_TO_ADDR
// sTiger := false ;
87399: LD_ADDR_EXP 131
87403: PUSH
87404: LD_INT 0
87406: ST_TO_ADDR
// sBomb := false ;
87407: LD_ADDR_EXP 132
87411: PUSH
87412: LD_INT 0
87414: ST_TO_ADDR
// sWound := false ;
87415: LD_ADDR_EXP 140
87419: PUSH
87420: LD_INT 0
87422: ST_TO_ADDR
// sBetray := false ;
87423: LD_ADDR_EXP 144
87427: PUSH
87428: LD_INT 0
87430: ST_TO_ADDR
// sContamin := false ;
87431: LD_ADDR_EXP 145
87435: PUSH
87436: LD_INT 0
87438: ST_TO_ADDR
// sOil := false ;
87439: LD_ADDR_EXP 147
87443: PUSH
87444: LD_INT 0
87446: ST_TO_ADDR
// sStu := false ;
87447: LD_ADDR_EXP 151
87451: PUSH
87452: LD_INT 0
87454: ST_TO_ADDR
// sBazooka := false ;
87455: LD_ADDR_EXP 154
87459: PUSH
87460: LD_INT 0
87462: ST_TO_ADDR
// sMortar := false ;
87463: LD_ADDR_EXP 155
87467: PUSH
87468: LD_INT 0
87470: ST_TO_ADDR
// sRanger := false ;
87471: LD_ADDR_EXP 165
87475: PUSH
87476: LD_INT 0
87478: ST_TO_ADDR
// end ;
87479: LD_VAR 0 1
87483: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
87484: LD_INT 0
87486: PPUSH
87487: PPUSH
87488: PPUSH
87489: PPUSH
87490: PPUSH
// result := [ ] ;
87491: LD_ADDR_VAR 0 1
87495: PUSH
87496: EMPTY
87497: ST_TO_ADDR
// if campaign_id = 1 then
87498: LD_OWVAR 69
87502: PUSH
87503: LD_INT 1
87505: EQUAL
87506: IFFALSE 90444
// begin case mission_number of 1 :
87508: LD_OWVAR 70
87512: PUSH
87513: LD_INT 1
87515: DOUBLE
87516: EQUAL
87517: IFTRUE 87521
87519: GO 87585
87521: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
87522: LD_ADDR_VAR 0 1
87526: PUSH
87527: LD_INT 2
87529: PUSH
87530: LD_INT 4
87532: PUSH
87533: LD_INT 11
87535: PUSH
87536: LD_INT 12
87538: PUSH
87539: LD_INT 15
87541: PUSH
87542: LD_INT 16
87544: PUSH
87545: LD_INT 22
87547: PUSH
87548: LD_INT 23
87550: PUSH
87551: LD_INT 26
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 101
87567: PUSH
87568: LD_INT 102
87570: PUSH
87571: LD_INT 106
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: LIST
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: ST_TO_ADDR
87583: GO 90442
87585: LD_INT 2
87587: DOUBLE
87588: EQUAL
87589: IFTRUE 87593
87591: GO 87665
87593: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
87594: LD_ADDR_VAR 0 1
87598: PUSH
87599: LD_INT 2
87601: PUSH
87602: LD_INT 4
87604: PUSH
87605: LD_INT 11
87607: PUSH
87608: LD_INT 12
87610: PUSH
87611: LD_INT 15
87613: PUSH
87614: LD_INT 16
87616: PUSH
87617: LD_INT 22
87619: PUSH
87620: LD_INT 23
87622: PUSH
87623: LD_INT 26
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 101
87639: PUSH
87640: LD_INT 102
87642: PUSH
87643: LD_INT 105
87645: PUSH
87646: LD_INT 106
87648: PUSH
87649: LD_INT 108
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: ST_TO_ADDR
87663: GO 90442
87665: LD_INT 3
87667: DOUBLE
87668: EQUAL
87669: IFTRUE 87673
87671: GO 87749
87673: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
87674: LD_ADDR_VAR 0 1
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: LD_INT 4
87684: PUSH
87685: LD_INT 5
87687: PUSH
87688: LD_INT 11
87690: PUSH
87691: LD_INT 12
87693: PUSH
87694: LD_INT 15
87696: PUSH
87697: LD_INT 16
87699: PUSH
87700: LD_INT 22
87702: PUSH
87703: LD_INT 26
87705: PUSH
87706: LD_INT 36
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 101
87723: PUSH
87724: LD_INT 102
87726: PUSH
87727: LD_INT 105
87729: PUSH
87730: LD_INT 106
87732: PUSH
87733: LD_INT 108
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: ST_TO_ADDR
87747: GO 90442
87749: LD_INT 4
87751: DOUBLE
87752: EQUAL
87753: IFTRUE 87757
87755: GO 87841
87757: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
87758: LD_ADDR_VAR 0 1
87762: PUSH
87763: LD_INT 2
87765: PUSH
87766: LD_INT 4
87768: PUSH
87769: LD_INT 5
87771: PUSH
87772: LD_INT 8
87774: PUSH
87775: LD_INT 11
87777: PUSH
87778: LD_INT 12
87780: PUSH
87781: LD_INT 15
87783: PUSH
87784: LD_INT 16
87786: PUSH
87787: LD_INT 22
87789: PUSH
87790: LD_INT 23
87792: PUSH
87793: LD_INT 26
87795: PUSH
87796: LD_INT 36
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 101
87815: PUSH
87816: LD_INT 102
87818: PUSH
87819: LD_INT 105
87821: PUSH
87822: LD_INT 106
87824: PUSH
87825: LD_INT 108
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: ST_TO_ADDR
87839: GO 90442
87841: LD_INT 5
87843: DOUBLE
87844: EQUAL
87845: IFTRUE 87849
87847: GO 87949
87849: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
87850: LD_ADDR_VAR 0 1
87854: PUSH
87855: LD_INT 2
87857: PUSH
87858: LD_INT 4
87860: PUSH
87861: LD_INT 5
87863: PUSH
87864: LD_INT 6
87866: PUSH
87867: LD_INT 8
87869: PUSH
87870: LD_INT 11
87872: PUSH
87873: LD_INT 12
87875: PUSH
87876: LD_INT 15
87878: PUSH
87879: LD_INT 16
87881: PUSH
87882: LD_INT 22
87884: PUSH
87885: LD_INT 23
87887: PUSH
87888: LD_INT 25
87890: PUSH
87891: LD_INT 26
87893: PUSH
87894: LD_INT 36
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 101
87915: PUSH
87916: LD_INT 102
87918: PUSH
87919: LD_INT 105
87921: PUSH
87922: LD_INT 106
87924: PUSH
87925: LD_INT 108
87927: PUSH
87928: LD_INT 109
87930: PUSH
87931: LD_INT 112
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: ST_TO_ADDR
87947: GO 90442
87949: LD_INT 6
87951: DOUBLE
87952: EQUAL
87953: IFTRUE 87957
87955: GO 88077
87957: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87958: LD_ADDR_VAR 0 1
87962: PUSH
87963: LD_INT 2
87965: PUSH
87966: LD_INT 4
87968: PUSH
87969: LD_INT 5
87971: PUSH
87972: LD_INT 6
87974: PUSH
87975: LD_INT 8
87977: PUSH
87978: LD_INT 11
87980: PUSH
87981: LD_INT 12
87983: PUSH
87984: LD_INT 15
87986: PUSH
87987: LD_INT 16
87989: PUSH
87990: LD_INT 20
87992: PUSH
87993: LD_INT 21
87995: PUSH
87996: LD_INT 22
87998: PUSH
87999: LD_INT 23
88001: PUSH
88002: LD_INT 25
88004: PUSH
88005: LD_INT 26
88007: PUSH
88008: LD_INT 30
88010: PUSH
88011: LD_INT 31
88013: PUSH
88014: LD_INT 32
88016: PUSH
88017: LD_INT 36
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 101
88043: PUSH
88044: LD_INT 102
88046: PUSH
88047: LD_INT 105
88049: PUSH
88050: LD_INT 106
88052: PUSH
88053: LD_INT 108
88055: PUSH
88056: LD_INT 109
88058: PUSH
88059: LD_INT 112
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: ST_TO_ADDR
88075: GO 90442
88077: LD_INT 7
88079: DOUBLE
88080: EQUAL
88081: IFTRUE 88085
88083: GO 88185
88085: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88086: LD_ADDR_VAR 0 1
88090: PUSH
88091: LD_INT 2
88093: PUSH
88094: LD_INT 4
88096: PUSH
88097: LD_INT 5
88099: PUSH
88100: LD_INT 7
88102: PUSH
88103: LD_INT 11
88105: PUSH
88106: LD_INT 12
88108: PUSH
88109: LD_INT 15
88111: PUSH
88112: LD_INT 16
88114: PUSH
88115: LD_INT 20
88117: PUSH
88118: LD_INT 21
88120: PUSH
88121: LD_INT 22
88123: PUSH
88124: LD_INT 23
88126: PUSH
88127: LD_INT 25
88129: PUSH
88130: LD_INT 26
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 101
88151: PUSH
88152: LD_INT 102
88154: PUSH
88155: LD_INT 103
88157: PUSH
88158: LD_INT 105
88160: PUSH
88161: LD_INT 106
88163: PUSH
88164: LD_INT 108
88166: PUSH
88167: LD_INT 112
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: ST_TO_ADDR
88183: GO 90442
88185: LD_INT 8
88187: DOUBLE
88188: EQUAL
88189: IFTRUE 88193
88191: GO 88321
88193: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88194: LD_ADDR_VAR 0 1
88198: PUSH
88199: LD_INT 2
88201: PUSH
88202: LD_INT 4
88204: PUSH
88205: LD_INT 5
88207: PUSH
88208: LD_INT 6
88210: PUSH
88211: LD_INT 7
88213: PUSH
88214: LD_INT 8
88216: PUSH
88217: LD_INT 11
88219: PUSH
88220: LD_INT 12
88222: PUSH
88223: LD_INT 15
88225: PUSH
88226: LD_INT 16
88228: PUSH
88229: LD_INT 20
88231: PUSH
88232: LD_INT 21
88234: PUSH
88235: LD_INT 22
88237: PUSH
88238: LD_INT 23
88240: PUSH
88241: LD_INT 25
88243: PUSH
88244: LD_INT 26
88246: PUSH
88247: LD_INT 30
88249: PUSH
88250: LD_INT 31
88252: PUSH
88253: LD_INT 32
88255: PUSH
88256: LD_INT 36
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 101
88283: PUSH
88284: LD_INT 102
88286: PUSH
88287: LD_INT 103
88289: PUSH
88290: LD_INT 105
88292: PUSH
88293: LD_INT 106
88295: PUSH
88296: LD_INT 108
88298: PUSH
88299: LD_INT 109
88301: PUSH
88302: LD_INT 112
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: ST_TO_ADDR
88319: GO 90442
88321: LD_INT 9
88323: DOUBLE
88324: EQUAL
88325: IFTRUE 88329
88327: GO 88465
88329: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88330: LD_ADDR_VAR 0 1
88334: PUSH
88335: LD_INT 2
88337: PUSH
88338: LD_INT 4
88340: PUSH
88341: LD_INT 5
88343: PUSH
88344: LD_INT 6
88346: PUSH
88347: LD_INT 7
88349: PUSH
88350: LD_INT 8
88352: PUSH
88353: LD_INT 11
88355: PUSH
88356: LD_INT 12
88358: PUSH
88359: LD_INT 15
88361: PUSH
88362: LD_INT 16
88364: PUSH
88365: LD_INT 20
88367: PUSH
88368: LD_INT 21
88370: PUSH
88371: LD_INT 22
88373: PUSH
88374: LD_INT 23
88376: PUSH
88377: LD_INT 25
88379: PUSH
88380: LD_INT 26
88382: PUSH
88383: LD_INT 28
88385: PUSH
88386: LD_INT 30
88388: PUSH
88389: LD_INT 31
88391: PUSH
88392: LD_INT 32
88394: PUSH
88395: LD_INT 36
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 101
88423: PUSH
88424: LD_INT 102
88426: PUSH
88427: LD_INT 103
88429: PUSH
88430: LD_INT 105
88432: PUSH
88433: LD_INT 106
88435: PUSH
88436: LD_INT 108
88438: PUSH
88439: LD_INT 109
88441: PUSH
88442: LD_INT 112
88444: PUSH
88445: LD_INT 114
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: ST_TO_ADDR
88463: GO 90442
88465: LD_INT 10
88467: DOUBLE
88468: EQUAL
88469: IFTRUE 88473
88471: GO 88657
88473: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
88474: LD_ADDR_VAR 0 1
88478: PUSH
88479: LD_INT 2
88481: PUSH
88482: LD_INT 4
88484: PUSH
88485: LD_INT 5
88487: PUSH
88488: LD_INT 6
88490: PUSH
88491: LD_INT 7
88493: PUSH
88494: LD_INT 8
88496: PUSH
88497: LD_INT 9
88499: PUSH
88500: LD_INT 10
88502: PUSH
88503: LD_INT 11
88505: PUSH
88506: LD_INT 12
88508: PUSH
88509: LD_INT 13
88511: PUSH
88512: LD_INT 14
88514: PUSH
88515: LD_INT 15
88517: PUSH
88518: LD_INT 16
88520: PUSH
88521: LD_INT 17
88523: PUSH
88524: LD_INT 18
88526: PUSH
88527: LD_INT 19
88529: PUSH
88530: LD_INT 20
88532: PUSH
88533: LD_INT 21
88535: PUSH
88536: LD_INT 22
88538: PUSH
88539: LD_INT 23
88541: PUSH
88542: LD_INT 24
88544: PUSH
88545: LD_INT 25
88547: PUSH
88548: LD_INT 26
88550: PUSH
88551: LD_INT 28
88553: PUSH
88554: LD_INT 30
88556: PUSH
88557: LD_INT 31
88559: PUSH
88560: LD_INT 32
88562: PUSH
88563: LD_INT 36
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 101
88599: PUSH
88600: LD_INT 102
88602: PUSH
88603: LD_INT 103
88605: PUSH
88606: LD_INT 104
88608: PUSH
88609: LD_INT 105
88611: PUSH
88612: LD_INT 106
88614: PUSH
88615: LD_INT 107
88617: PUSH
88618: LD_INT 108
88620: PUSH
88621: LD_INT 109
88623: PUSH
88624: LD_INT 110
88626: PUSH
88627: LD_INT 111
88629: PUSH
88630: LD_INT 112
88632: PUSH
88633: LD_INT 114
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: ST_TO_ADDR
88655: GO 90442
88657: LD_INT 11
88659: DOUBLE
88660: EQUAL
88661: IFTRUE 88665
88663: GO 88857
88665: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
88666: LD_ADDR_VAR 0 1
88670: PUSH
88671: LD_INT 2
88673: PUSH
88674: LD_INT 3
88676: PUSH
88677: LD_INT 4
88679: PUSH
88680: LD_INT 5
88682: PUSH
88683: LD_INT 6
88685: PUSH
88686: LD_INT 7
88688: PUSH
88689: LD_INT 8
88691: PUSH
88692: LD_INT 9
88694: PUSH
88695: LD_INT 10
88697: PUSH
88698: LD_INT 11
88700: PUSH
88701: LD_INT 12
88703: PUSH
88704: LD_INT 13
88706: PUSH
88707: LD_INT 14
88709: PUSH
88710: LD_INT 15
88712: PUSH
88713: LD_INT 16
88715: PUSH
88716: LD_INT 17
88718: PUSH
88719: LD_INT 18
88721: PUSH
88722: LD_INT 19
88724: PUSH
88725: LD_INT 20
88727: PUSH
88728: LD_INT 21
88730: PUSH
88731: LD_INT 22
88733: PUSH
88734: LD_INT 23
88736: PUSH
88737: LD_INT 24
88739: PUSH
88740: LD_INT 25
88742: PUSH
88743: LD_INT 26
88745: PUSH
88746: LD_INT 28
88748: PUSH
88749: LD_INT 30
88751: PUSH
88752: LD_INT 31
88754: PUSH
88755: LD_INT 32
88757: PUSH
88758: LD_INT 34
88760: PUSH
88761: LD_INT 36
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 101
88799: PUSH
88800: LD_INT 102
88802: PUSH
88803: LD_INT 103
88805: PUSH
88806: LD_INT 104
88808: PUSH
88809: LD_INT 105
88811: PUSH
88812: LD_INT 106
88814: PUSH
88815: LD_INT 107
88817: PUSH
88818: LD_INT 108
88820: PUSH
88821: LD_INT 109
88823: PUSH
88824: LD_INT 110
88826: PUSH
88827: LD_INT 111
88829: PUSH
88830: LD_INT 112
88832: PUSH
88833: LD_INT 114
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: ST_TO_ADDR
88855: GO 90442
88857: LD_INT 12
88859: DOUBLE
88860: EQUAL
88861: IFTRUE 88865
88863: GO 89073
88865: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88866: LD_ADDR_VAR 0 1
88870: PUSH
88871: LD_INT 1
88873: PUSH
88874: LD_INT 2
88876: PUSH
88877: LD_INT 3
88879: PUSH
88880: LD_INT 4
88882: PUSH
88883: LD_INT 5
88885: PUSH
88886: LD_INT 6
88888: PUSH
88889: LD_INT 7
88891: PUSH
88892: LD_INT 8
88894: PUSH
88895: LD_INT 9
88897: PUSH
88898: LD_INT 10
88900: PUSH
88901: LD_INT 11
88903: PUSH
88904: LD_INT 12
88906: PUSH
88907: LD_INT 13
88909: PUSH
88910: LD_INT 14
88912: PUSH
88913: LD_INT 15
88915: PUSH
88916: LD_INT 16
88918: PUSH
88919: LD_INT 17
88921: PUSH
88922: LD_INT 18
88924: PUSH
88925: LD_INT 19
88927: PUSH
88928: LD_INT 20
88930: PUSH
88931: LD_INT 21
88933: PUSH
88934: LD_INT 22
88936: PUSH
88937: LD_INT 23
88939: PUSH
88940: LD_INT 24
88942: PUSH
88943: LD_INT 25
88945: PUSH
88946: LD_INT 26
88948: PUSH
88949: LD_INT 27
88951: PUSH
88952: LD_INT 28
88954: PUSH
88955: LD_INT 30
88957: PUSH
88958: LD_INT 31
88960: PUSH
88961: LD_INT 32
88963: PUSH
88964: LD_INT 33
88966: PUSH
88967: LD_INT 34
88969: PUSH
88970: LD_INT 36
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 101
89011: PUSH
89012: LD_INT 102
89014: PUSH
89015: LD_INT 103
89017: PUSH
89018: LD_INT 104
89020: PUSH
89021: LD_INT 105
89023: PUSH
89024: LD_INT 106
89026: PUSH
89027: LD_INT 107
89029: PUSH
89030: LD_INT 108
89032: PUSH
89033: LD_INT 109
89035: PUSH
89036: LD_INT 110
89038: PUSH
89039: LD_INT 111
89041: PUSH
89042: LD_INT 112
89044: PUSH
89045: LD_INT 113
89047: PUSH
89048: LD_INT 114
89050: PUSH
89051: EMPTY
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: ST_TO_ADDR
89071: GO 90442
89073: LD_INT 13
89075: DOUBLE
89076: EQUAL
89077: IFTRUE 89081
89079: GO 89277
89081: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89082: LD_ADDR_VAR 0 1
89086: PUSH
89087: LD_INT 1
89089: PUSH
89090: LD_INT 2
89092: PUSH
89093: LD_INT 3
89095: PUSH
89096: LD_INT 4
89098: PUSH
89099: LD_INT 5
89101: PUSH
89102: LD_INT 8
89104: PUSH
89105: LD_INT 9
89107: PUSH
89108: LD_INT 10
89110: PUSH
89111: LD_INT 11
89113: PUSH
89114: LD_INT 12
89116: PUSH
89117: LD_INT 14
89119: PUSH
89120: LD_INT 15
89122: PUSH
89123: LD_INT 16
89125: PUSH
89126: LD_INT 17
89128: PUSH
89129: LD_INT 18
89131: PUSH
89132: LD_INT 19
89134: PUSH
89135: LD_INT 20
89137: PUSH
89138: LD_INT 21
89140: PUSH
89141: LD_INT 22
89143: PUSH
89144: LD_INT 23
89146: PUSH
89147: LD_INT 24
89149: PUSH
89150: LD_INT 25
89152: PUSH
89153: LD_INT 26
89155: PUSH
89156: LD_INT 27
89158: PUSH
89159: LD_INT 28
89161: PUSH
89162: LD_INT 30
89164: PUSH
89165: LD_INT 31
89167: PUSH
89168: LD_INT 32
89170: PUSH
89171: LD_INT 33
89173: PUSH
89174: LD_INT 34
89176: PUSH
89177: LD_INT 36
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 101
89215: PUSH
89216: LD_INT 102
89218: PUSH
89219: LD_INT 103
89221: PUSH
89222: LD_INT 104
89224: PUSH
89225: LD_INT 105
89227: PUSH
89228: LD_INT 106
89230: PUSH
89231: LD_INT 107
89233: PUSH
89234: LD_INT 108
89236: PUSH
89237: LD_INT 109
89239: PUSH
89240: LD_INT 110
89242: PUSH
89243: LD_INT 111
89245: PUSH
89246: LD_INT 112
89248: PUSH
89249: LD_INT 113
89251: PUSH
89252: LD_INT 114
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: LIST
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: ST_TO_ADDR
89275: GO 90442
89277: LD_INT 14
89279: DOUBLE
89280: EQUAL
89281: IFTRUE 89285
89283: GO 89497
89285: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89286: LD_ADDR_VAR 0 1
89290: PUSH
89291: LD_INT 1
89293: PUSH
89294: LD_INT 2
89296: PUSH
89297: LD_INT 3
89299: PUSH
89300: LD_INT 4
89302: PUSH
89303: LD_INT 5
89305: PUSH
89306: LD_INT 6
89308: PUSH
89309: LD_INT 7
89311: PUSH
89312: LD_INT 8
89314: PUSH
89315: LD_INT 9
89317: PUSH
89318: LD_INT 10
89320: PUSH
89321: LD_INT 11
89323: PUSH
89324: LD_INT 12
89326: PUSH
89327: LD_INT 13
89329: PUSH
89330: LD_INT 14
89332: PUSH
89333: LD_INT 15
89335: PUSH
89336: LD_INT 16
89338: PUSH
89339: LD_INT 17
89341: PUSH
89342: LD_INT 18
89344: PUSH
89345: LD_INT 19
89347: PUSH
89348: LD_INT 20
89350: PUSH
89351: LD_INT 21
89353: PUSH
89354: LD_INT 22
89356: PUSH
89357: LD_INT 23
89359: PUSH
89360: LD_INT 24
89362: PUSH
89363: LD_INT 25
89365: PUSH
89366: LD_INT 26
89368: PUSH
89369: LD_INT 27
89371: PUSH
89372: LD_INT 28
89374: PUSH
89375: LD_INT 29
89377: PUSH
89378: LD_INT 30
89380: PUSH
89381: LD_INT 31
89383: PUSH
89384: LD_INT 32
89386: PUSH
89387: LD_INT 33
89389: PUSH
89390: LD_INT 34
89392: PUSH
89393: LD_INT 36
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: PUSH
89433: LD_INT 101
89435: PUSH
89436: LD_INT 102
89438: PUSH
89439: LD_INT 103
89441: PUSH
89442: LD_INT 104
89444: PUSH
89445: LD_INT 105
89447: PUSH
89448: LD_INT 106
89450: PUSH
89451: LD_INT 107
89453: PUSH
89454: LD_INT 108
89456: PUSH
89457: LD_INT 109
89459: PUSH
89460: LD_INT 110
89462: PUSH
89463: LD_INT 111
89465: PUSH
89466: LD_INT 112
89468: PUSH
89469: LD_INT 113
89471: PUSH
89472: LD_INT 114
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: ST_TO_ADDR
89495: GO 90442
89497: LD_INT 15
89499: DOUBLE
89500: EQUAL
89501: IFTRUE 89505
89503: GO 89717
89505: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
89506: LD_ADDR_VAR 0 1
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: LD_INT 2
89516: PUSH
89517: LD_INT 3
89519: PUSH
89520: LD_INT 4
89522: PUSH
89523: LD_INT 5
89525: PUSH
89526: LD_INT 6
89528: PUSH
89529: LD_INT 7
89531: PUSH
89532: LD_INT 8
89534: PUSH
89535: LD_INT 9
89537: PUSH
89538: LD_INT 10
89540: PUSH
89541: LD_INT 11
89543: PUSH
89544: LD_INT 12
89546: PUSH
89547: LD_INT 13
89549: PUSH
89550: LD_INT 14
89552: PUSH
89553: LD_INT 15
89555: PUSH
89556: LD_INT 16
89558: PUSH
89559: LD_INT 17
89561: PUSH
89562: LD_INT 18
89564: PUSH
89565: LD_INT 19
89567: PUSH
89568: LD_INT 20
89570: PUSH
89571: LD_INT 21
89573: PUSH
89574: LD_INT 22
89576: PUSH
89577: LD_INT 23
89579: PUSH
89580: LD_INT 24
89582: PUSH
89583: LD_INT 25
89585: PUSH
89586: LD_INT 26
89588: PUSH
89589: LD_INT 27
89591: PUSH
89592: LD_INT 28
89594: PUSH
89595: LD_INT 29
89597: PUSH
89598: LD_INT 30
89600: PUSH
89601: LD_INT 31
89603: PUSH
89604: LD_INT 32
89606: PUSH
89607: LD_INT 33
89609: PUSH
89610: LD_INT 34
89612: PUSH
89613: LD_INT 36
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 101
89655: PUSH
89656: LD_INT 102
89658: PUSH
89659: LD_INT 103
89661: PUSH
89662: LD_INT 104
89664: PUSH
89665: LD_INT 105
89667: PUSH
89668: LD_INT 106
89670: PUSH
89671: LD_INT 107
89673: PUSH
89674: LD_INT 108
89676: PUSH
89677: LD_INT 109
89679: PUSH
89680: LD_INT 110
89682: PUSH
89683: LD_INT 111
89685: PUSH
89686: LD_INT 112
89688: PUSH
89689: LD_INT 113
89691: PUSH
89692: LD_INT 114
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: ST_TO_ADDR
89715: GO 90442
89717: LD_INT 16
89719: DOUBLE
89720: EQUAL
89721: IFTRUE 89725
89723: GO 89849
89725: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
89726: LD_ADDR_VAR 0 1
89730: PUSH
89731: LD_INT 2
89733: PUSH
89734: LD_INT 4
89736: PUSH
89737: LD_INT 5
89739: PUSH
89740: LD_INT 7
89742: PUSH
89743: LD_INT 11
89745: PUSH
89746: LD_INT 12
89748: PUSH
89749: LD_INT 15
89751: PUSH
89752: LD_INT 16
89754: PUSH
89755: LD_INT 20
89757: PUSH
89758: LD_INT 21
89760: PUSH
89761: LD_INT 22
89763: PUSH
89764: LD_INT 23
89766: PUSH
89767: LD_INT 25
89769: PUSH
89770: LD_INT 26
89772: PUSH
89773: LD_INT 30
89775: PUSH
89776: LD_INT 31
89778: PUSH
89779: LD_INT 32
89781: PUSH
89782: LD_INT 33
89784: PUSH
89785: LD_INT 34
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: PUSH
89809: LD_INT 101
89811: PUSH
89812: LD_INT 102
89814: PUSH
89815: LD_INT 103
89817: PUSH
89818: LD_INT 106
89820: PUSH
89821: LD_INT 108
89823: PUSH
89824: LD_INT 112
89826: PUSH
89827: LD_INT 113
89829: PUSH
89830: LD_INT 114
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: ST_TO_ADDR
89847: GO 90442
89849: LD_INT 17
89851: DOUBLE
89852: EQUAL
89853: IFTRUE 89857
89855: GO 90069
89857: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
89858: LD_ADDR_VAR 0 1
89862: PUSH
89863: LD_INT 1
89865: PUSH
89866: LD_INT 2
89868: PUSH
89869: LD_INT 3
89871: PUSH
89872: LD_INT 4
89874: PUSH
89875: LD_INT 5
89877: PUSH
89878: LD_INT 6
89880: PUSH
89881: LD_INT 7
89883: PUSH
89884: LD_INT 8
89886: PUSH
89887: LD_INT 9
89889: PUSH
89890: LD_INT 10
89892: PUSH
89893: LD_INT 11
89895: PUSH
89896: LD_INT 12
89898: PUSH
89899: LD_INT 13
89901: PUSH
89902: LD_INT 14
89904: PUSH
89905: LD_INT 15
89907: PUSH
89908: LD_INT 16
89910: PUSH
89911: LD_INT 17
89913: PUSH
89914: LD_INT 18
89916: PUSH
89917: LD_INT 19
89919: PUSH
89920: LD_INT 20
89922: PUSH
89923: LD_INT 21
89925: PUSH
89926: LD_INT 22
89928: PUSH
89929: LD_INT 23
89931: PUSH
89932: LD_INT 24
89934: PUSH
89935: LD_INT 25
89937: PUSH
89938: LD_INT 26
89940: PUSH
89941: LD_INT 27
89943: PUSH
89944: LD_INT 28
89946: PUSH
89947: LD_INT 29
89949: PUSH
89950: LD_INT 30
89952: PUSH
89953: LD_INT 31
89955: PUSH
89956: LD_INT 32
89958: PUSH
89959: LD_INT 33
89961: PUSH
89962: LD_INT 34
89964: PUSH
89965: LD_INT 36
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 101
90007: PUSH
90008: LD_INT 102
90010: PUSH
90011: LD_INT 103
90013: PUSH
90014: LD_INT 104
90016: PUSH
90017: LD_INT 105
90019: PUSH
90020: LD_INT 106
90022: PUSH
90023: LD_INT 107
90025: PUSH
90026: LD_INT 108
90028: PUSH
90029: LD_INT 109
90031: PUSH
90032: LD_INT 110
90034: PUSH
90035: LD_INT 111
90037: PUSH
90038: LD_INT 112
90040: PUSH
90041: LD_INT 113
90043: PUSH
90044: LD_INT 114
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: ST_TO_ADDR
90067: GO 90442
90069: LD_INT 18
90071: DOUBLE
90072: EQUAL
90073: IFTRUE 90077
90075: GO 90213
90077: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90078: LD_ADDR_VAR 0 1
90082: PUSH
90083: LD_INT 2
90085: PUSH
90086: LD_INT 4
90088: PUSH
90089: LD_INT 5
90091: PUSH
90092: LD_INT 7
90094: PUSH
90095: LD_INT 11
90097: PUSH
90098: LD_INT 12
90100: PUSH
90101: LD_INT 15
90103: PUSH
90104: LD_INT 16
90106: PUSH
90107: LD_INT 20
90109: PUSH
90110: LD_INT 21
90112: PUSH
90113: LD_INT 22
90115: PUSH
90116: LD_INT 23
90118: PUSH
90119: LD_INT 25
90121: PUSH
90122: LD_INT 26
90124: PUSH
90125: LD_INT 30
90127: PUSH
90128: LD_INT 31
90130: PUSH
90131: LD_INT 32
90133: PUSH
90134: LD_INT 33
90136: PUSH
90137: LD_INT 34
90139: PUSH
90140: LD_INT 35
90142: PUSH
90143: LD_INT 36
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 101
90171: PUSH
90172: LD_INT 102
90174: PUSH
90175: LD_INT 103
90177: PUSH
90178: LD_INT 106
90180: PUSH
90181: LD_INT 108
90183: PUSH
90184: LD_INT 112
90186: PUSH
90187: LD_INT 113
90189: PUSH
90190: LD_INT 114
90192: PUSH
90193: LD_INT 115
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: ST_TO_ADDR
90211: GO 90442
90213: LD_INT 19
90215: DOUBLE
90216: EQUAL
90217: IFTRUE 90221
90219: GO 90441
90221: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90222: LD_ADDR_VAR 0 1
90226: PUSH
90227: LD_INT 1
90229: PUSH
90230: LD_INT 2
90232: PUSH
90233: LD_INT 3
90235: PUSH
90236: LD_INT 4
90238: PUSH
90239: LD_INT 5
90241: PUSH
90242: LD_INT 6
90244: PUSH
90245: LD_INT 7
90247: PUSH
90248: LD_INT 8
90250: PUSH
90251: LD_INT 9
90253: PUSH
90254: LD_INT 10
90256: PUSH
90257: LD_INT 11
90259: PUSH
90260: LD_INT 12
90262: PUSH
90263: LD_INT 13
90265: PUSH
90266: LD_INT 14
90268: PUSH
90269: LD_INT 15
90271: PUSH
90272: LD_INT 16
90274: PUSH
90275: LD_INT 17
90277: PUSH
90278: LD_INT 18
90280: PUSH
90281: LD_INT 19
90283: PUSH
90284: LD_INT 20
90286: PUSH
90287: LD_INT 21
90289: PUSH
90290: LD_INT 22
90292: PUSH
90293: LD_INT 23
90295: PUSH
90296: LD_INT 24
90298: PUSH
90299: LD_INT 25
90301: PUSH
90302: LD_INT 26
90304: PUSH
90305: LD_INT 27
90307: PUSH
90308: LD_INT 28
90310: PUSH
90311: LD_INT 29
90313: PUSH
90314: LD_INT 30
90316: PUSH
90317: LD_INT 31
90319: PUSH
90320: LD_INT 32
90322: PUSH
90323: LD_INT 33
90325: PUSH
90326: LD_INT 34
90328: PUSH
90329: LD_INT 35
90331: PUSH
90332: LD_INT 36
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 101
90375: PUSH
90376: LD_INT 102
90378: PUSH
90379: LD_INT 103
90381: PUSH
90382: LD_INT 104
90384: PUSH
90385: LD_INT 105
90387: PUSH
90388: LD_INT 106
90390: PUSH
90391: LD_INT 107
90393: PUSH
90394: LD_INT 108
90396: PUSH
90397: LD_INT 109
90399: PUSH
90400: LD_INT 110
90402: PUSH
90403: LD_INT 111
90405: PUSH
90406: LD_INT 112
90408: PUSH
90409: LD_INT 113
90411: PUSH
90412: LD_INT 114
90414: PUSH
90415: LD_INT 115
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: ST_TO_ADDR
90439: GO 90442
90441: POP
// end else
90442: GO 90661
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
90444: LD_ADDR_VAR 0 1
90448: PUSH
90449: LD_INT 1
90451: PUSH
90452: LD_INT 2
90454: PUSH
90455: LD_INT 3
90457: PUSH
90458: LD_INT 4
90460: PUSH
90461: LD_INT 5
90463: PUSH
90464: LD_INT 6
90466: PUSH
90467: LD_INT 7
90469: PUSH
90470: LD_INT 8
90472: PUSH
90473: LD_INT 9
90475: PUSH
90476: LD_INT 10
90478: PUSH
90479: LD_INT 11
90481: PUSH
90482: LD_INT 12
90484: PUSH
90485: LD_INT 13
90487: PUSH
90488: LD_INT 14
90490: PUSH
90491: LD_INT 15
90493: PUSH
90494: LD_INT 16
90496: PUSH
90497: LD_INT 17
90499: PUSH
90500: LD_INT 18
90502: PUSH
90503: LD_INT 19
90505: PUSH
90506: LD_INT 20
90508: PUSH
90509: LD_INT 21
90511: PUSH
90512: LD_INT 22
90514: PUSH
90515: LD_INT 23
90517: PUSH
90518: LD_INT 24
90520: PUSH
90521: LD_INT 25
90523: PUSH
90524: LD_INT 26
90526: PUSH
90527: LD_INT 27
90529: PUSH
90530: LD_INT 28
90532: PUSH
90533: LD_INT 29
90535: PUSH
90536: LD_INT 30
90538: PUSH
90539: LD_INT 31
90541: PUSH
90542: LD_INT 32
90544: PUSH
90545: LD_INT 33
90547: PUSH
90548: LD_INT 34
90550: PUSH
90551: LD_INT 35
90553: PUSH
90554: LD_INT 36
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: PUSH
90595: LD_INT 101
90597: PUSH
90598: LD_INT 102
90600: PUSH
90601: LD_INT 103
90603: PUSH
90604: LD_INT 104
90606: PUSH
90607: LD_INT 105
90609: PUSH
90610: LD_INT 106
90612: PUSH
90613: LD_INT 107
90615: PUSH
90616: LD_INT 108
90618: PUSH
90619: LD_INT 109
90621: PUSH
90622: LD_INT 110
90624: PUSH
90625: LD_INT 111
90627: PUSH
90628: LD_INT 112
90630: PUSH
90631: LD_INT 113
90633: PUSH
90634: LD_INT 114
90636: PUSH
90637: LD_INT 115
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: ST_TO_ADDR
// if result then
90661: LD_VAR 0 1
90665: IFFALSE 90954
// begin normal :=  ;
90667: LD_ADDR_VAR 0 3
90671: PUSH
90672: LD_STRING 
90674: ST_TO_ADDR
// hardcore :=  ;
90675: LD_ADDR_VAR 0 4
90679: PUSH
90680: LD_STRING 
90682: ST_TO_ADDR
// for i = 1 to normalCounter do
90683: LD_ADDR_VAR 0 5
90687: PUSH
90688: DOUBLE
90689: LD_INT 1
90691: DEC
90692: ST_TO_ADDR
90693: LD_EXP 113
90697: PUSH
90698: FOR_TO
90699: IFFALSE 90800
// begin tmp := 0 ;
90701: LD_ADDR_VAR 0 2
90705: PUSH
90706: LD_STRING 0
90708: ST_TO_ADDR
// if result [ 1 ] then
90709: LD_VAR 0 1
90713: PUSH
90714: LD_INT 1
90716: ARRAY
90717: IFFALSE 90782
// if result [ 1 ] [ 1 ] = i then
90719: LD_VAR 0 1
90723: PUSH
90724: LD_INT 1
90726: ARRAY
90727: PUSH
90728: LD_INT 1
90730: ARRAY
90731: PUSH
90732: LD_VAR 0 5
90736: EQUAL
90737: IFFALSE 90782
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90739: LD_ADDR_VAR 0 1
90743: PUSH
90744: LD_VAR 0 1
90748: PPUSH
90749: LD_INT 1
90751: PPUSH
90752: LD_VAR 0 1
90756: PUSH
90757: LD_INT 1
90759: ARRAY
90760: PPUSH
90761: LD_INT 1
90763: PPUSH
90764: CALL_OW 3
90768: PPUSH
90769: CALL_OW 1
90773: ST_TO_ADDR
// tmp := 1 ;
90774: LD_ADDR_VAR 0 2
90778: PUSH
90779: LD_STRING 1
90781: ST_TO_ADDR
// end ; normal := normal & tmp ;
90782: LD_ADDR_VAR 0 3
90786: PUSH
90787: LD_VAR 0 3
90791: PUSH
90792: LD_VAR 0 2
90796: STR
90797: ST_TO_ADDR
// end ;
90798: GO 90698
90800: POP
90801: POP
// for i = 1 to hardcoreCounter do
90802: LD_ADDR_VAR 0 5
90806: PUSH
90807: DOUBLE
90808: LD_INT 1
90810: DEC
90811: ST_TO_ADDR
90812: LD_EXP 114
90816: PUSH
90817: FOR_TO
90818: IFFALSE 90923
// begin tmp := 0 ;
90820: LD_ADDR_VAR 0 2
90824: PUSH
90825: LD_STRING 0
90827: ST_TO_ADDR
// if result [ 2 ] then
90828: LD_VAR 0 1
90832: PUSH
90833: LD_INT 2
90835: ARRAY
90836: IFFALSE 90905
// if result [ 2 ] [ 1 ] = 100 + i then
90838: LD_VAR 0 1
90842: PUSH
90843: LD_INT 2
90845: ARRAY
90846: PUSH
90847: LD_INT 1
90849: ARRAY
90850: PUSH
90851: LD_INT 100
90853: PUSH
90854: LD_VAR 0 5
90858: PLUS
90859: EQUAL
90860: IFFALSE 90905
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90862: LD_ADDR_VAR 0 1
90866: PUSH
90867: LD_VAR 0 1
90871: PPUSH
90872: LD_INT 2
90874: PPUSH
90875: LD_VAR 0 1
90879: PUSH
90880: LD_INT 2
90882: ARRAY
90883: PPUSH
90884: LD_INT 1
90886: PPUSH
90887: CALL_OW 3
90891: PPUSH
90892: CALL_OW 1
90896: ST_TO_ADDR
// tmp := 1 ;
90897: LD_ADDR_VAR 0 2
90901: PUSH
90902: LD_STRING 1
90904: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90905: LD_ADDR_VAR 0 4
90909: PUSH
90910: LD_VAR 0 4
90914: PUSH
90915: LD_VAR 0 2
90919: STR
90920: ST_TO_ADDR
// end ;
90921: GO 90817
90923: POP
90924: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90925: LD_STRING getStreamItemsFromMission("
90927: PUSH
90928: LD_VAR 0 3
90932: STR
90933: PUSH
90934: LD_STRING ","
90936: STR
90937: PUSH
90938: LD_VAR 0 4
90942: STR
90943: PUSH
90944: LD_STRING ")
90946: STR
90947: PPUSH
90948: CALL_OW 559
// end else
90952: GO 90961
// ToLua ( getStreamItemsFromMission("","") ) ;
90954: LD_STRING getStreamItemsFromMission("","")
90956: PPUSH
90957: CALL_OW 559
// end ;
90961: LD_VAR 0 1
90965: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90966: LD_EXP 112
90970: PUSH
90971: LD_EXP 117
90975: AND
90976: IFFALSE 91100
90978: GO 90980
90980: DISABLE
90981: LD_INT 0
90983: PPUSH
90984: PPUSH
// begin enable ;
90985: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90986: LD_ADDR_VAR 0 2
90990: PUSH
90991: LD_INT 22
90993: PUSH
90994: LD_OWVAR 2
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 2
91005: PUSH
91006: LD_INT 34
91008: PUSH
91009: LD_INT 7
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 34
91018: PUSH
91019: LD_INT 45
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 34
91028: PUSH
91029: LD_INT 28
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 34
91038: PUSH
91039: LD_INT 47
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PPUSH
91057: CALL_OW 69
91061: ST_TO_ADDR
// if not tmp then
91062: LD_VAR 0 2
91066: NOT
91067: IFFALSE 91071
// exit ;
91069: GO 91100
// for i in tmp do
91071: LD_ADDR_VAR 0 1
91075: PUSH
91076: LD_VAR 0 2
91080: PUSH
91081: FOR_IN
91082: IFFALSE 91098
// begin SetLives ( i , 0 ) ;
91084: LD_VAR 0 1
91088: PPUSH
91089: LD_INT 0
91091: PPUSH
91092: CALL_OW 234
// end ;
91096: GO 91081
91098: POP
91099: POP
// end ;
91100: PPOPN 2
91102: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91103: LD_EXP 112
91107: PUSH
91108: LD_EXP 118
91112: AND
91113: IFFALSE 91197
91115: GO 91117
91117: DISABLE
91118: LD_INT 0
91120: PPUSH
91121: PPUSH
// begin enable ;
91122: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91123: LD_ADDR_VAR 0 2
91127: PUSH
91128: LD_INT 22
91130: PUSH
91131: LD_OWVAR 2
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PUSH
91140: LD_INT 32
91142: PUSH
91143: LD_INT 3
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PPUSH
91154: CALL_OW 69
91158: ST_TO_ADDR
// if not tmp then
91159: LD_VAR 0 2
91163: NOT
91164: IFFALSE 91168
// exit ;
91166: GO 91197
// for i in tmp do
91168: LD_ADDR_VAR 0 1
91172: PUSH
91173: LD_VAR 0 2
91177: PUSH
91178: FOR_IN
91179: IFFALSE 91195
// begin SetLives ( i , 0 ) ;
91181: LD_VAR 0 1
91185: PPUSH
91186: LD_INT 0
91188: PPUSH
91189: CALL_OW 234
// end ;
91193: GO 91178
91195: POP
91196: POP
// end ;
91197: PPOPN 2
91199: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91200: LD_EXP 112
91204: PUSH
91205: LD_EXP 115
91209: AND
91210: IFFALSE 91303
91212: GO 91214
91214: DISABLE
91215: LD_INT 0
91217: PPUSH
// begin enable ;
91218: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91219: LD_ADDR_VAR 0 1
91223: PUSH
91224: LD_INT 22
91226: PUSH
91227: LD_OWVAR 2
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 2
91238: PUSH
91239: LD_INT 25
91241: PUSH
91242: LD_INT 5
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 25
91251: PUSH
91252: LD_INT 9
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PUSH
91259: LD_INT 25
91261: PUSH
91262: LD_INT 8
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PPUSH
91279: CALL_OW 69
91283: PUSH
91284: FOR_IN
91285: IFFALSE 91301
// begin SetClass ( i , 1 ) ;
91287: LD_VAR 0 1
91291: PPUSH
91292: LD_INT 1
91294: PPUSH
91295: CALL_OW 336
// end ;
91299: GO 91284
91301: POP
91302: POP
// end ;
91303: PPOPN 1
91305: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91306: LD_EXP 112
91310: PUSH
91311: LD_EXP 116
91315: AND
91316: PUSH
91317: LD_OWVAR 65
91321: PUSH
91322: LD_INT 7
91324: LESS
91325: AND
91326: IFFALSE 91340
91328: GO 91330
91330: DISABLE
// begin enable ;
91331: ENABLE
// game_speed := 7 ;
91332: LD_ADDR_OWVAR 65
91336: PUSH
91337: LD_INT 7
91339: ST_TO_ADDR
// end ;
91340: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91341: LD_EXP 112
91345: PUSH
91346: LD_EXP 119
91350: AND
91351: IFFALSE 91553
91353: GO 91355
91355: DISABLE
91356: LD_INT 0
91358: PPUSH
91359: PPUSH
91360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91361: LD_ADDR_VAR 0 3
91365: PUSH
91366: LD_INT 81
91368: PUSH
91369: LD_OWVAR 2
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 21
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PPUSH
91392: CALL_OW 69
91396: ST_TO_ADDR
// if not tmp then
91397: LD_VAR 0 3
91401: NOT
91402: IFFALSE 91406
// exit ;
91404: GO 91553
// if tmp > 5 then
91406: LD_VAR 0 3
91410: PUSH
91411: LD_INT 5
91413: GREATER
91414: IFFALSE 91426
// k := 5 else
91416: LD_ADDR_VAR 0 2
91420: PUSH
91421: LD_INT 5
91423: ST_TO_ADDR
91424: GO 91436
// k := tmp ;
91426: LD_ADDR_VAR 0 2
91430: PUSH
91431: LD_VAR 0 3
91435: ST_TO_ADDR
// for i := 1 to k do
91436: LD_ADDR_VAR 0 1
91440: PUSH
91441: DOUBLE
91442: LD_INT 1
91444: DEC
91445: ST_TO_ADDR
91446: LD_VAR 0 2
91450: PUSH
91451: FOR_TO
91452: IFFALSE 91551
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
91454: LD_VAR 0 3
91458: PUSH
91459: LD_VAR 0 1
91463: ARRAY
91464: PPUSH
91465: LD_VAR 0 1
91469: PUSH
91470: LD_INT 4
91472: MOD
91473: PUSH
91474: LD_INT 1
91476: PLUS
91477: PPUSH
91478: CALL_OW 259
91482: PUSH
91483: LD_INT 10
91485: LESS
91486: IFFALSE 91549
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
91488: LD_VAR 0 3
91492: PUSH
91493: LD_VAR 0 1
91497: ARRAY
91498: PPUSH
91499: LD_VAR 0 1
91503: PUSH
91504: LD_INT 4
91506: MOD
91507: PUSH
91508: LD_INT 1
91510: PLUS
91511: PPUSH
91512: LD_VAR 0 3
91516: PUSH
91517: LD_VAR 0 1
91521: ARRAY
91522: PPUSH
91523: LD_VAR 0 1
91527: PUSH
91528: LD_INT 4
91530: MOD
91531: PUSH
91532: LD_INT 1
91534: PLUS
91535: PPUSH
91536: CALL_OW 259
91540: PUSH
91541: LD_INT 1
91543: PLUS
91544: PPUSH
91545: CALL_OW 237
91549: GO 91451
91551: POP
91552: POP
// end ;
91553: PPOPN 3
91555: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
91556: LD_EXP 112
91560: PUSH
91561: LD_EXP 120
91565: AND
91566: IFFALSE 91586
91568: GO 91570
91570: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
91571: LD_INT 4
91573: PPUSH
91574: LD_OWVAR 2
91578: PPUSH
91579: LD_INT 0
91581: PPUSH
91582: CALL_OW 324
91586: END
// every 0 0$1 trigger StreamModeActive and sShovel do
91587: LD_EXP 112
91591: PUSH
91592: LD_EXP 149
91596: AND
91597: IFFALSE 91617
91599: GO 91601
91601: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
91602: LD_INT 19
91604: PPUSH
91605: LD_OWVAR 2
91609: PPUSH
91610: LD_INT 0
91612: PPUSH
91613: CALL_OW 324
91617: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91618: LD_EXP 112
91622: PUSH
91623: LD_EXP 121
91627: AND
91628: IFFALSE 91730
91630: GO 91632
91632: DISABLE
91633: LD_INT 0
91635: PPUSH
91636: PPUSH
// begin enable ;
91637: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91638: LD_ADDR_VAR 0 2
91642: PUSH
91643: LD_INT 22
91645: PUSH
91646: LD_OWVAR 2
91650: PUSH
91651: EMPTY
91652: LIST
91653: LIST
91654: PUSH
91655: LD_INT 2
91657: PUSH
91658: LD_INT 34
91660: PUSH
91661: LD_INT 11
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 34
91670: PUSH
91671: LD_INT 30
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: LIST
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PPUSH
91687: CALL_OW 69
91691: ST_TO_ADDR
// if not tmp then
91692: LD_VAR 0 2
91696: NOT
91697: IFFALSE 91701
// exit ;
91699: GO 91730
// for i in tmp do
91701: LD_ADDR_VAR 0 1
91705: PUSH
91706: LD_VAR 0 2
91710: PUSH
91711: FOR_IN
91712: IFFALSE 91728
// begin SetLives ( i , 0 ) ;
91714: LD_VAR 0 1
91718: PPUSH
91719: LD_INT 0
91721: PPUSH
91722: CALL_OW 234
// end ;
91726: GO 91711
91728: POP
91729: POP
// end ;
91730: PPOPN 2
91732: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91733: LD_EXP 112
91737: PUSH
91738: LD_EXP 122
91742: AND
91743: IFFALSE 91763
91745: GO 91747
91747: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91748: LD_INT 32
91750: PPUSH
91751: LD_OWVAR 2
91755: PPUSH
91756: LD_INT 0
91758: PPUSH
91759: CALL_OW 324
91763: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
91764: LD_EXP 112
91768: PUSH
91769: LD_EXP 123
91773: AND
91774: IFFALSE 91955
91776: GO 91778
91778: DISABLE
91779: LD_INT 0
91781: PPUSH
91782: PPUSH
91783: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
91784: LD_ADDR_VAR 0 2
91788: PUSH
91789: LD_INT 22
91791: PUSH
91792: LD_OWVAR 2
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 33
91803: PUSH
91804: LD_INT 3
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: EMPTY
91812: LIST
91813: LIST
91814: PPUSH
91815: CALL_OW 69
91819: ST_TO_ADDR
// if not tmp then
91820: LD_VAR 0 2
91824: NOT
91825: IFFALSE 91829
// exit ;
91827: GO 91955
// side := 0 ;
91829: LD_ADDR_VAR 0 3
91833: PUSH
91834: LD_INT 0
91836: ST_TO_ADDR
// for i := 1 to 8 do
91837: LD_ADDR_VAR 0 1
91841: PUSH
91842: DOUBLE
91843: LD_INT 1
91845: DEC
91846: ST_TO_ADDR
91847: LD_INT 8
91849: PUSH
91850: FOR_TO
91851: IFFALSE 91899
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91853: LD_OWVAR 2
91857: PUSH
91858: LD_VAR 0 1
91862: NONEQUAL
91863: PUSH
91864: LD_OWVAR 2
91868: PPUSH
91869: LD_VAR 0 1
91873: PPUSH
91874: CALL_OW 81
91878: PUSH
91879: LD_INT 2
91881: EQUAL
91882: AND
91883: IFFALSE 91897
// begin side := i ;
91885: LD_ADDR_VAR 0 3
91889: PUSH
91890: LD_VAR 0 1
91894: ST_TO_ADDR
// break ;
91895: GO 91899
// end ;
91897: GO 91850
91899: POP
91900: POP
// if not side then
91901: LD_VAR 0 3
91905: NOT
91906: IFFALSE 91910
// exit ;
91908: GO 91955
// for i := 1 to tmp do
91910: LD_ADDR_VAR 0 1
91914: PUSH
91915: DOUBLE
91916: LD_INT 1
91918: DEC
91919: ST_TO_ADDR
91920: LD_VAR 0 2
91924: PUSH
91925: FOR_TO
91926: IFFALSE 91953
// if Prob ( 60 ) then
91928: LD_INT 60
91930: PPUSH
91931: CALL_OW 13
91935: IFFALSE 91951
// SetSide ( i , side ) ;
91937: LD_VAR 0 1
91941: PPUSH
91942: LD_VAR 0 3
91946: PPUSH
91947: CALL_OW 235
91951: GO 91925
91953: POP
91954: POP
// end ;
91955: PPOPN 3
91957: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91958: LD_EXP 112
91962: PUSH
91963: LD_EXP 125
91967: AND
91968: IFFALSE 92087
91970: GO 91972
91972: DISABLE
91973: LD_INT 0
91975: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91976: LD_ADDR_VAR 0 1
91980: PUSH
91981: LD_INT 22
91983: PUSH
91984: LD_OWVAR 2
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: LD_INT 21
91995: PUSH
91996: LD_INT 1
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 3
92005: PUSH
92006: LD_INT 23
92008: PUSH
92009: LD_INT 0
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: LIST
92024: PPUSH
92025: CALL_OW 69
92029: PUSH
92030: FOR_IN
92031: IFFALSE 92085
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92033: LD_VAR 0 1
92037: PPUSH
92038: CALL_OW 257
92042: PUSH
92043: LD_INT 1
92045: PUSH
92046: LD_INT 2
92048: PUSH
92049: LD_INT 3
92051: PUSH
92052: LD_INT 4
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: IN
92061: IFFALSE 92083
// SetClass ( un , rand ( 1 , 4 ) ) ;
92063: LD_VAR 0 1
92067: PPUSH
92068: LD_INT 1
92070: PPUSH
92071: LD_INT 4
92073: PPUSH
92074: CALL_OW 12
92078: PPUSH
92079: CALL_OW 336
92083: GO 92030
92085: POP
92086: POP
// end ;
92087: PPOPN 1
92089: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92090: LD_EXP 112
92094: PUSH
92095: LD_EXP 124
92099: AND
92100: IFFALSE 92179
92102: GO 92104
92104: DISABLE
92105: LD_INT 0
92107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92108: LD_ADDR_VAR 0 1
92112: PUSH
92113: LD_INT 22
92115: PUSH
92116: LD_OWVAR 2
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 21
92127: PUSH
92128: LD_INT 3
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PPUSH
92139: CALL_OW 69
92143: ST_TO_ADDR
// if not tmp then
92144: LD_VAR 0 1
92148: NOT
92149: IFFALSE 92153
// exit ;
92151: GO 92179
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92153: LD_VAR 0 1
92157: PUSH
92158: LD_INT 1
92160: PPUSH
92161: LD_VAR 0 1
92165: PPUSH
92166: CALL_OW 12
92170: ARRAY
92171: PPUSH
92172: LD_INT 100
92174: PPUSH
92175: CALL_OW 234
// end ;
92179: PPOPN 1
92181: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92182: LD_EXP 112
92186: PUSH
92187: LD_EXP 126
92191: AND
92192: IFFALSE 92290
92194: GO 92196
92196: DISABLE
92197: LD_INT 0
92199: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92200: LD_ADDR_VAR 0 1
92204: PUSH
92205: LD_INT 22
92207: PUSH
92208: LD_OWVAR 2
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: LD_INT 21
92219: PUSH
92220: LD_INT 1
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: EMPTY
92228: LIST
92229: LIST
92230: PPUSH
92231: CALL_OW 69
92235: ST_TO_ADDR
// if not tmp then
92236: LD_VAR 0 1
92240: NOT
92241: IFFALSE 92245
// exit ;
92243: GO 92290
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92245: LD_VAR 0 1
92249: PUSH
92250: LD_INT 1
92252: PPUSH
92253: LD_VAR 0 1
92257: PPUSH
92258: CALL_OW 12
92262: ARRAY
92263: PPUSH
92264: LD_INT 1
92266: PPUSH
92267: LD_INT 4
92269: PPUSH
92270: CALL_OW 12
92274: PPUSH
92275: LD_INT 3000
92277: PPUSH
92278: LD_INT 9000
92280: PPUSH
92281: CALL_OW 12
92285: PPUSH
92286: CALL_OW 492
// end ;
92290: PPOPN 1
92292: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92293: LD_EXP 112
92297: PUSH
92298: LD_EXP 127
92302: AND
92303: IFFALSE 92323
92305: GO 92307
92307: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92308: LD_INT 1
92310: PPUSH
92311: LD_OWVAR 2
92315: PPUSH
92316: LD_INT 0
92318: PPUSH
92319: CALL_OW 324
92323: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92324: LD_EXP 112
92328: PUSH
92329: LD_EXP 128
92333: AND
92334: IFFALSE 92417
92336: GO 92338
92338: DISABLE
92339: LD_INT 0
92341: PPUSH
92342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92343: LD_ADDR_VAR 0 2
92347: PUSH
92348: LD_INT 22
92350: PUSH
92351: LD_OWVAR 2
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 21
92362: PUSH
92363: LD_INT 3
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PPUSH
92374: CALL_OW 69
92378: ST_TO_ADDR
// if not tmp then
92379: LD_VAR 0 2
92383: NOT
92384: IFFALSE 92388
// exit ;
92386: GO 92417
// for i in tmp do
92388: LD_ADDR_VAR 0 1
92392: PUSH
92393: LD_VAR 0 2
92397: PUSH
92398: FOR_IN
92399: IFFALSE 92415
// SetBLevel ( i , 10 ) ;
92401: LD_VAR 0 1
92405: PPUSH
92406: LD_INT 10
92408: PPUSH
92409: CALL_OW 241
92413: GO 92398
92415: POP
92416: POP
// end ;
92417: PPOPN 2
92419: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
92420: LD_EXP 112
92424: PUSH
92425: LD_EXP 129
92429: AND
92430: IFFALSE 92541
92432: GO 92434
92434: DISABLE
92435: LD_INT 0
92437: PPUSH
92438: PPUSH
92439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92440: LD_ADDR_VAR 0 3
92444: PUSH
92445: LD_INT 22
92447: PUSH
92448: LD_OWVAR 2
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 25
92459: PUSH
92460: LD_INT 1
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PPUSH
92471: CALL_OW 69
92475: ST_TO_ADDR
// if not tmp then
92476: LD_VAR 0 3
92480: NOT
92481: IFFALSE 92485
// exit ;
92483: GO 92541
// un := tmp [ rand ( 1 , tmp ) ] ;
92485: LD_ADDR_VAR 0 2
92489: PUSH
92490: LD_VAR 0 3
92494: PUSH
92495: LD_INT 1
92497: PPUSH
92498: LD_VAR 0 3
92502: PPUSH
92503: CALL_OW 12
92507: ARRAY
92508: ST_TO_ADDR
// if Crawls ( un ) then
92509: LD_VAR 0 2
92513: PPUSH
92514: CALL_OW 318
92518: IFFALSE 92529
// ComWalk ( un ) ;
92520: LD_VAR 0 2
92524: PPUSH
92525: CALL_OW 138
// SetClass ( un , class_sniper ) ;
92529: LD_VAR 0 2
92533: PPUSH
92534: LD_INT 5
92536: PPUSH
92537: CALL_OW 336
// end ;
92541: PPOPN 3
92543: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
92544: LD_EXP 112
92548: PUSH
92549: LD_EXP 130
92553: AND
92554: PUSH
92555: LD_OWVAR 67
92559: PUSH
92560: LD_INT 3
92562: LESS
92563: AND
92564: IFFALSE 92583
92566: GO 92568
92568: DISABLE
// Difficulty := Difficulty + 1 ;
92569: LD_ADDR_OWVAR 67
92573: PUSH
92574: LD_OWVAR 67
92578: PUSH
92579: LD_INT 1
92581: PLUS
92582: ST_TO_ADDR
92583: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92584: LD_EXP 112
92588: PUSH
92589: LD_EXP 131
92593: AND
92594: IFFALSE 92697
92596: GO 92598
92598: DISABLE
92599: LD_INT 0
92601: PPUSH
// begin for i := 1 to 5 do
92602: LD_ADDR_VAR 0 1
92606: PUSH
92607: DOUBLE
92608: LD_INT 1
92610: DEC
92611: ST_TO_ADDR
92612: LD_INT 5
92614: PUSH
92615: FOR_TO
92616: IFFALSE 92695
// begin uc_nation := nation_nature ;
92618: LD_ADDR_OWVAR 21
92622: PUSH
92623: LD_INT 0
92625: ST_TO_ADDR
// uc_side := 0 ;
92626: LD_ADDR_OWVAR 20
92630: PUSH
92631: LD_INT 0
92633: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92634: LD_ADDR_OWVAR 29
92638: PUSH
92639: LD_INT 12
92641: PUSH
92642: LD_INT 12
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: ST_TO_ADDR
// hc_agressivity := 20 ;
92649: LD_ADDR_OWVAR 35
92653: PUSH
92654: LD_INT 20
92656: ST_TO_ADDR
// hc_class := class_tiger ;
92657: LD_ADDR_OWVAR 28
92661: PUSH
92662: LD_INT 14
92664: ST_TO_ADDR
// hc_gallery :=  ;
92665: LD_ADDR_OWVAR 33
92669: PUSH
92670: LD_STRING 
92672: ST_TO_ADDR
// hc_name :=  ;
92673: LD_ADDR_OWVAR 26
92677: PUSH
92678: LD_STRING 
92680: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92681: CALL_OW 44
92685: PPUSH
92686: LD_INT 0
92688: PPUSH
92689: CALL_OW 51
// end ;
92693: GO 92615
92695: POP
92696: POP
// end ;
92697: PPOPN 1
92699: END
// every 0 0$1 trigger StreamModeActive and sBomb do
92700: LD_EXP 112
92704: PUSH
92705: LD_EXP 132
92709: AND
92710: IFFALSE 92719
92712: GO 92714
92714: DISABLE
// StreamSibBomb ;
92715: CALL 92720 0 0
92719: END
// export function StreamSibBomb ; var i , x , y ; begin
92720: LD_INT 0
92722: PPUSH
92723: PPUSH
92724: PPUSH
92725: PPUSH
// result := false ;
92726: LD_ADDR_VAR 0 1
92730: PUSH
92731: LD_INT 0
92733: ST_TO_ADDR
// for i := 1 to 16 do
92734: LD_ADDR_VAR 0 2
92738: PUSH
92739: DOUBLE
92740: LD_INT 1
92742: DEC
92743: ST_TO_ADDR
92744: LD_INT 16
92746: PUSH
92747: FOR_TO
92748: IFFALSE 92947
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92750: LD_ADDR_VAR 0 3
92754: PUSH
92755: LD_INT 10
92757: PUSH
92758: LD_INT 20
92760: PUSH
92761: LD_INT 30
92763: PUSH
92764: LD_INT 40
92766: PUSH
92767: LD_INT 50
92769: PUSH
92770: LD_INT 60
92772: PUSH
92773: LD_INT 70
92775: PUSH
92776: LD_INT 80
92778: PUSH
92779: LD_INT 90
92781: PUSH
92782: LD_INT 100
92784: PUSH
92785: LD_INT 110
92787: PUSH
92788: LD_INT 120
92790: PUSH
92791: LD_INT 130
92793: PUSH
92794: LD_INT 140
92796: PUSH
92797: LD_INT 150
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 1
92819: PPUSH
92820: LD_INT 15
92822: PPUSH
92823: CALL_OW 12
92827: ARRAY
92828: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92829: LD_ADDR_VAR 0 4
92833: PUSH
92834: LD_INT 10
92836: PUSH
92837: LD_INT 20
92839: PUSH
92840: LD_INT 30
92842: PUSH
92843: LD_INT 40
92845: PUSH
92846: LD_INT 50
92848: PUSH
92849: LD_INT 60
92851: PUSH
92852: LD_INT 70
92854: PUSH
92855: LD_INT 80
92857: PUSH
92858: LD_INT 90
92860: PUSH
92861: LD_INT 100
92863: PUSH
92864: LD_INT 110
92866: PUSH
92867: LD_INT 120
92869: PUSH
92870: LD_INT 130
92872: PUSH
92873: LD_INT 140
92875: PUSH
92876: LD_INT 150
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: PUSH
92896: LD_INT 1
92898: PPUSH
92899: LD_INT 15
92901: PPUSH
92902: CALL_OW 12
92906: ARRAY
92907: ST_TO_ADDR
// if ValidHex ( x , y ) then
92908: LD_VAR 0 3
92912: PPUSH
92913: LD_VAR 0 4
92917: PPUSH
92918: CALL_OW 488
92922: IFFALSE 92945
// begin result := [ x , y ] ;
92924: LD_ADDR_VAR 0 1
92928: PUSH
92929: LD_VAR 0 3
92933: PUSH
92934: LD_VAR 0 4
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: ST_TO_ADDR
// break ;
92943: GO 92947
// end ; end ;
92945: GO 92747
92947: POP
92948: POP
// if result then
92949: LD_VAR 0 1
92953: IFFALSE 93013
// begin ToLua ( playSibBomb() ) ;
92955: LD_STRING playSibBomb()
92957: PPUSH
92958: CALL_OW 559
// wait ( 0 0$14 ) ;
92962: LD_INT 490
92964: PPUSH
92965: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92969: LD_VAR 0 1
92973: PUSH
92974: LD_INT 1
92976: ARRAY
92977: PPUSH
92978: LD_VAR 0 1
92982: PUSH
92983: LD_INT 2
92985: ARRAY
92986: PPUSH
92987: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92991: LD_VAR 0 1
92995: PUSH
92996: LD_INT 1
92998: ARRAY
92999: PPUSH
93000: LD_VAR 0 1
93004: PUSH
93005: LD_INT 2
93007: ARRAY
93008: PPUSH
93009: CALL_OW 429
// end ; end ;
93013: LD_VAR 0 1
93017: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93018: LD_EXP 112
93022: PUSH
93023: LD_EXP 134
93027: AND
93028: IFFALSE 93040
93030: GO 93032
93032: DISABLE
// YouLost (  ) ;
93033: LD_STRING 
93035: PPUSH
93036: CALL_OW 104
93040: END
// every 0 0$1 trigger StreamModeActive and sFog do
93041: LD_EXP 112
93045: PUSH
93046: LD_EXP 133
93050: AND
93051: IFFALSE 93065
93053: GO 93055
93055: DISABLE
// FogOff ( your_side ) ;
93056: LD_OWVAR 2
93060: PPUSH
93061: CALL_OW 344
93065: END
// every 0 0$1 trigger StreamModeActive and sSun do
93066: LD_EXP 112
93070: PUSH
93071: LD_EXP 135
93075: AND
93076: IFFALSE 93104
93078: GO 93080
93080: DISABLE
// begin solar_recharge_percent := 0 ;
93081: LD_ADDR_OWVAR 79
93085: PUSH
93086: LD_INT 0
93088: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93089: LD_INT 10500
93091: PPUSH
93092: CALL_OW 67
// solar_recharge_percent := 100 ;
93096: LD_ADDR_OWVAR 79
93100: PUSH
93101: LD_INT 100
93103: ST_TO_ADDR
// end ;
93104: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93105: LD_EXP 112
93109: PUSH
93110: LD_EXP 136
93114: AND
93115: IFFALSE 93354
93117: GO 93119
93119: DISABLE
93120: LD_INT 0
93122: PPUSH
93123: PPUSH
93124: PPUSH
// begin tmp := [ ] ;
93125: LD_ADDR_VAR 0 3
93129: PUSH
93130: EMPTY
93131: ST_TO_ADDR
// for i := 1 to 6 do
93132: LD_ADDR_VAR 0 1
93136: PUSH
93137: DOUBLE
93138: LD_INT 1
93140: DEC
93141: ST_TO_ADDR
93142: LD_INT 6
93144: PUSH
93145: FOR_TO
93146: IFFALSE 93251
// begin uc_nation := nation_nature ;
93148: LD_ADDR_OWVAR 21
93152: PUSH
93153: LD_INT 0
93155: ST_TO_ADDR
// uc_side := 0 ;
93156: LD_ADDR_OWVAR 20
93160: PUSH
93161: LD_INT 0
93163: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93164: LD_ADDR_OWVAR 29
93168: PUSH
93169: LD_INT 12
93171: PUSH
93172: LD_INT 12
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: ST_TO_ADDR
// hc_agressivity := 20 ;
93179: LD_ADDR_OWVAR 35
93183: PUSH
93184: LD_INT 20
93186: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93187: LD_ADDR_OWVAR 28
93191: PUSH
93192: LD_INT 17
93194: ST_TO_ADDR
// hc_gallery :=  ;
93195: LD_ADDR_OWVAR 33
93199: PUSH
93200: LD_STRING 
93202: ST_TO_ADDR
// hc_name :=  ;
93203: LD_ADDR_OWVAR 26
93207: PUSH
93208: LD_STRING 
93210: ST_TO_ADDR
// un := CreateHuman ;
93211: LD_ADDR_VAR 0 2
93215: PUSH
93216: CALL_OW 44
93220: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93221: LD_VAR 0 2
93225: PPUSH
93226: LD_INT 1
93228: PPUSH
93229: CALL_OW 51
// tmp := tmp ^ un ;
93233: LD_ADDR_VAR 0 3
93237: PUSH
93238: LD_VAR 0 3
93242: PUSH
93243: LD_VAR 0 2
93247: ADD
93248: ST_TO_ADDR
// end ;
93249: GO 93145
93251: POP
93252: POP
// repeat wait ( 0 0$1 ) ;
93253: LD_INT 35
93255: PPUSH
93256: CALL_OW 67
// for un in tmp do
93260: LD_ADDR_VAR 0 2
93264: PUSH
93265: LD_VAR 0 3
93269: PUSH
93270: FOR_IN
93271: IFFALSE 93345
// begin if IsDead ( un ) then
93273: LD_VAR 0 2
93277: PPUSH
93278: CALL_OW 301
93282: IFFALSE 93302
// begin tmp := tmp diff un ;
93284: LD_ADDR_VAR 0 3
93288: PUSH
93289: LD_VAR 0 3
93293: PUSH
93294: LD_VAR 0 2
93298: DIFF
93299: ST_TO_ADDR
// continue ;
93300: GO 93270
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93302: LD_VAR 0 2
93306: PPUSH
93307: LD_INT 3
93309: PUSH
93310: LD_INT 22
93312: PUSH
93313: LD_INT 0
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PPUSH
93324: CALL_OW 69
93328: PPUSH
93329: LD_VAR 0 2
93333: PPUSH
93334: CALL_OW 74
93338: PPUSH
93339: CALL_OW 115
// end ;
93343: GO 93270
93345: POP
93346: POP
// until not tmp ;
93347: LD_VAR 0 3
93351: NOT
93352: IFFALSE 93253
// end ;
93354: PPOPN 3
93356: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93357: LD_EXP 112
93361: PUSH
93362: LD_EXP 137
93366: AND
93367: IFFALSE 93421
93369: GO 93371
93371: DISABLE
// begin ToLua ( displayTroll(); ) ;
93372: LD_STRING displayTroll();
93374: PPUSH
93375: CALL_OW 559
// wait ( 3 3$00 ) ;
93379: LD_INT 6300
93381: PPUSH
93382: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93386: LD_STRING hideTroll();
93388: PPUSH
93389: CALL_OW 559
// wait ( 1 1$00 ) ;
93393: LD_INT 2100
93395: PPUSH
93396: CALL_OW 67
// ToLua ( displayTroll(); ) ;
93400: LD_STRING displayTroll();
93402: PPUSH
93403: CALL_OW 559
// wait ( 1 1$00 ) ;
93407: LD_INT 2100
93409: PPUSH
93410: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93414: LD_STRING hideTroll();
93416: PPUSH
93417: CALL_OW 559
// end ;
93421: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
93422: LD_EXP 112
93426: PUSH
93427: LD_EXP 138
93431: AND
93432: IFFALSE 93495
93434: GO 93436
93436: DISABLE
93437: LD_INT 0
93439: PPUSH
// begin p := 0 ;
93440: LD_ADDR_VAR 0 1
93444: PUSH
93445: LD_INT 0
93447: ST_TO_ADDR
// repeat game_speed := 1 ;
93448: LD_ADDR_OWVAR 65
93452: PUSH
93453: LD_INT 1
93455: ST_TO_ADDR
// wait ( 0 0$1 ) ;
93456: LD_INT 35
93458: PPUSH
93459: CALL_OW 67
// p := p + 1 ;
93463: LD_ADDR_VAR 0 1
93467: PUSH
93468: LD_VAR 0 1
93472: PUSH
93473: LD_INT 1
93475: PLUS
93476: ST_TO_ADDR
// until p >= 60 ;
93477: LD_VAR 0 1
93481: PUSH
93482: LD_INT 60
93484: GREATEREQUAL
93485: IFFALSE 93448
// game_speed := 4 ;
93487: LD_ADDR_OWVAR 65
93491: PUSH
93492: LD_INT 4
93494: ST_TO_ADDR
// end ;
93495: PPOPN 1
93497: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
93498: LD_EXP 112
93502: PUSH
93503: LD_EXP 139
93507: AND
93508: IFFALSE 93654
93510: GO 93512
93512: DISABLE
93513: LD_INT 0
93515: PPUSH
93516: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93517: LD_ADDR_VAR 0 1
93521: PUSH
93522: LD_INT 22
93524: PUSH
93525: LD_OWVAR 2
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: LD_INT 2
93536: PUSH
93537: LD_INT 30
93539: PUSH
93540: LD_INT 0
93542: PUSH
93543: EMPTY
93544: LIST
93545: LIST
93546: PUSH
93547: LD_INT 30
93549: PUSH
93550: LD_INT 1
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: LIST
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: PPUSH
93566: CALL_OW 69
93570: ST_TO_ADDR
// if not depot then
93571: LD_VAR 0 1
93575: NOT
93576: IFFALSE 93580
// exit ;
93578: GO 93654
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
93580: LD_ADDR_VAR 0 2
93584: PUSH
93585: LD_VAR 0 1
93589: PUSH
93590: LD_INT 1
93592: PPUSH
93593: LD_VAR 0 1
93597: PPUSH
93598: CALL_OW 12
93602: ARRAY
93603: PPUSH
93604: CALL_OW 274
93608: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
93609: LD_VAR 0 2
93613: PPUSH
93614: LD_INT 1
93616: PPUSH
93617: LD_INT 0
93619: PPUSH
93620: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
93624: LD_VAR 0 2
93628: PPUSH
93629: LD_INT 2
93631: PPUSH
93632: LD_INT 0
93634: PPUSH
93635: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
93639: LD_VAR 0 2
93643: PPUSH
93644: LD_INT 3
93646: PPUSH
93647: LD_INT 0
93649: PPUSH
93650: CALL_OW 277
// end ;
93654: PPOPN 2
93656: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
93657: LD_EXP 112
93661: PUSH
93662: LD_EXP 140
93666: AND
93667: IFFALSE 93764
93669: GO 93671
93671: DISABLE
93672: LD_INT 0
93674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93675: LD_ADDR_VAR 0 1
93679: PUSH
93680: LD_INT 22
93682: PUSH
93683: LD_OWVAR 2
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 21
93694: PUSH
93695: LD_INT 1
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PUSH
93702: LD_INT 3
93704: PUSH
93705: LD_INT 23
93707: PUSH
93708: LD_INT 0
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: LIST
93723: PPUSH
93724: CALL_OW 69
93728: ST_TO_ADDR
// if not tmp then
93729: LD_VAR 0 1
93733: NOT
93734: IFFALSE 93738
// exit ;
93736: GO 93764
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
93738: LD_VAR 0 1
93742: PUSH
93743: LD_INT 1
93745: PPUSH
93746: LD_VAR 0 1
93750: PPUSH
93751: CALL_OW 12
93755: ARRAY
93756: PPUSH
93757: LD_INT 200
93759: PPUSH
93760: CALL_OW 234
// end ;
93764: PPOPN 1
93766: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
93767: LD_EXP 112
93771: PUSH
93772: LD_EXP 141
93776: AND
93777: IFFALSE 93856
93779: GO 93781
93781: DISABLE
93782: LD_INT 0
93784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
93785: LD_ADDR_VAR 0 1
93789: PUSH
93790: LD_INT 22
93792: PUSH
93793: LD_OWVAR 2
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PUSH
93802: LD_INT 21
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PPUSH
93816: CALL_OW 69
93820: ST_TO_ADDR
// if not tmp then
93821: LD_VAR 0 1
93825: NOT
93826: IFFALSE 93830
// exit ;
93828: GO 93856
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
93830: LD_VAR 0 1
93834: PUSH
93835: LD_INT 1
93837: PPUSH
93838: LD_VAR 0 1
93842: PPUSH
93843: CALL_OW 12
93847: ARRAY
93848: PPUSH
93849: LD_INT 60
93851: PPUSH
93852: CALL_OW 234
// end ;
93856: PPOPN 1
93858: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93859: LD_EXP 112
93863: PUSH
93864: LD_EXP 142
93868: AND
93869: IFFALSE 93968
93871: GO 93873
93873: DISABLE
93874: LD_INT 0
93876: PPUSH
93877: PPUSH
// begin enable ;
93878: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93879: LD_ADDR_VAR 0 1
93883: PUSH
93884: LD_INT 22
93886: PUSH
93887: LD_OWVAR 2
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 61
93898: PUSH
93899: EMPTY
93900: LIST
93901: PUSH
93902: LD_INT 33
93904: PUSH
93905: LD_INT 2
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: LIST
93916: PPUSH
93917: CALL_OW 69
93921: ST_TO_ADDR
// if not tmp then
93922: LD_VAR 0 1
93926: NOT
93927: IFFALSE 93931
// exit ;
93929: GO 93968
// for i in tmp do
93931: LD_ADDR_VAR 0 2
93935: PUSH
93936: LD_VAR 0 1
93940: PUSH
93941: FOR_IN
93942: IFFALSE 93966
// if IsControledBy ( i ) then
93944: LD_VAR 0 2
93948: PPUSH
93949: CALL_OW 312
93953: IFFALSE 93964
// ComUnlink ( i ) ;
93955: LD_VAR 0 2
93959: PPUSH
93960: CALL_OW 136
93964: GO 93941
93966: POP
93967: POP
// end ;
93968: PPOPN 2
93970: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93971: LD_EXP 112
93975: PUSH
93976: LD_EXP 143
93980: AND
93981: IFFALSE 94121
93983: GO 93985
93985: DISABLE
93986: LD_INT 0
93988: PPUSH
93989: PPUSH
// begin ToLua ( displayPowell(); ) ;
93990: LD_STRING displayPowell();
93992: PPUSH
93993: CALL_OW 559
// uc_side := 0 ;
93997: LD_ADDR_OWVAR 20
94001: PUSH
94002: LD_INT 0
94004: ST_TO_ADDR
// uc_nation := 2 ;
94005: LD_ADDR_OWVAR 21
94009: PUSH
94010: LD_INT 2
94012: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94013: LD_ADDR_OWVAR 37
94017: PUSH
94018: LD_INT 14
94020: ST_TO_ADDR
// vc_engine := engine_siberite ;
94021: LD_ADDR_OWVAR 39
94025: PUSH
94026: LD_INT 3
94028: ST_TO_ADDR
// vc_control := control_apeman ;
94029: LD_ADDR_OWVAR 38
94033: PUSH
94034: LD_INT 5
94036: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94037: LD_ADDR_OWVAR 40
94041: PUSH
94042: LD_INT 29
94044: ST_TO_ADDR
// un := CreateVehicle ;
94045: LD_ADDR_VAR 0 2
94049: PUSH
94050: CALL_OW 45
94054: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94055: LD_VAR 0 2
94059: PPUSH
94060: LD_INT 1
94062: PPUSH
94063: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94067: LD_INT 35
94069: PPUSH
94070: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94074: LD_VAR 0 2
94078: PPUSH
94079: LD_INT 22
94081: PUSH
94082: LD_OWVAR 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PPUSH
94091: CALL_OW 69
94095: PPUSH
94096: LD_VAR 0 2
94100: PPUSH
94101: CALL_OW 74
94105: PPUSH
94106: CALL_OW 115
// until IsDead ( un ) ;
94110: LD_VAR 0 2
94114: PPUSH
94115: CALL_OW 301
94119: IFFALSE 94067
// end ;
94121: PPOPN 2
94123: END
// every 0 0$1 trigger StreamModeActive and sStu do
94124: LD_EXP 112
94128: PUSH
94129: LD_EXP 151
94133: AND
94134: IFFALSE 94150
94136: GO 94138
94138: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94139: LD_STRING displayStucuk();
94141: PPUSH
94142: CALL_OW 559
// ResetFog ;
94146: CALL_OW 335
// end ;
94150: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94151: LD_EXP 112
94155: PUSH
94156: LD_EXP 144
94160: AND
94161: IFFALSE 94302
94163: GO 94165
94165: DISABLE
94166: LD_INT 0
94168: PPUSH
94169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: LD_INT 22
94177: PUSH
94178: LD_OWVAR 2
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 21
94189: PUSH
94190: LD_INT 1
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PPUSH
94201: CALL_OW 69
94205: ST_TO_ADDR
// if not tmp then
94206: LD_VAR 0 2
94210: NOT
94211: IFFALSE 94215
// exit ;
94213: GO 94302
// un := tmp [ rand ( 1 , tmp ) ] ;
94215: LD_ADDR_VAR 0 1
94219: PUSH
94220: LD_VAR 0 2
94224: PUSH
94225: LD_INT 1
94227: PPUSH
94228: LD_VAR 0 2
94232: PPUSH
94233: CALL_OW 12
94237: ARRAY
94238: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94239: LD_VAR 0 1
94243: PPUSH
94244: LD_INT 0
94246: PPUSH
94247: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94251: LD_VAR 0 1
94255: PPUSH
94256: LD_OWVAR 3
94260: PUSH
94261: LD_VAR 0 1
94265: DIFF
94266: PPUSH
94267: LD_VAR 0 1
94271: PPUSH
94272: CALL_OW 74
94276: PPUSH
94277: CALL_OW 115
// wait ( 0 0$20 ) ;
94281: LD_INT 700
94283: PPUSH
94284: CALL_OW 67
// SetSide ( un , your_side ) ;
94288: LD_VAR 0 1
94292: PPUSH
94293: LD_OWVAR 2
94297: PPUSH
94298: CALL_OW 235
// end ;
94302: PPOPN 2
94304: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94305: LD_EXP 112
94309: PUSH
94310: LD_EXP 145
94314: AND
94315: IFFALSE 94421
94317: GO 94319
94319: DISABLE
94320: LD_INT 0
94322: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94323: LD_ADDR_VAR 0 1
94327: PUSH
94328: LD_INT 22
94330: PUSH
94331: LD_OWVAR 2
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 2
94342: PUSH
94343: LD_INT 30
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 30
94355: PUSH
94356: LD_INT 1
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: LIST
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PPUSH
94372: CALL_OW 69
94376: ST_TO_ADDR
// if not depot then
94377: LD_VAR 0 1
94381: NOT
94382: IFFALSE 94386
// exit ;
94384: GO 94421
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
94386: LD_VAR 0 1
94390: PUSH
94391: LD_INT 1
94393: ARRAY
94394: PPUSH
94395: CALL_OW 250
94399: PPUSH
94400: LD_VAR 0 1
94404: PUSH
94405: LD_INT 1
94407: ARRAY
94408: PPUSH
94409: CALL_OW 251
94413: PPUSH
94414: LD_INT 70
94416: PPUSH
94417: CALL_OW 495
// end ;
94421: PPOPN 1
94423: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
94424: LD_EXP 112
94428: PUSH
94429: LD_EXP 146
94433: AND
94434: IFFALSE 94645
94436: GO 94438
94438: DISABLE
94439: LD_INT 0
94441: PPUSH
94442: PPUSH
94443: PPUSH
94444: PPUSH
94445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94446: LD_ADDR_VAR 0 5
94450: PUSH
94451: LD_INT 22
94453: PUSH
94454: LD_OWVAR 2
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 21
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PPUSH
94477: CALL_OW 69
94481: ST_TO_ADDR
// if not tmp then
94482: LD_VAR 0 5
94486: NOT
94487: IFFALSE 94491
// exit ;
94489: GO 94645
// for i in tmp do
94491: LD_ADDR_VAR 0 1
94495: PUSH
94496: LD_VAR 0 5
94500: PUSH
94501: FOR_IN
94502: IFFALSE 94643
// begin d := rand ( 0 , 5 ) ;
94504: LD_ADDR_VAR 0 4
94508: PUSH
94509: LD_INT 0
94511: PPUSH
94512: LD_INT 5
94514: PPUSH
94515: CALL_OW 12
94519: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
94520: LD_ADDR_VAR 0 2
94524: PUSH
94525: LD_VAR 0 1
94529: PPUSH
94530: CALL_OW 250
94534: PPUSH
94535: LD_VAR 0 4
94539: PPUSH
94540: LD_INT 3
94542: PPUSH
94543: LD_INT 12
94545: PPUSH
94546: CALL_OW 12
94550: PPUSH
94551: CALL_OW 272
94555: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
94556: LD_ADDR_VAR 0 3
94560: PUSH
94561: LD_VAR 0 1
94565: PPUSH
94566: CALL_OW 251
94570: PPUSH
94571: LD_VAR 0 4
94575: PPUSH
94576: LD_INT 3
94578: PPUSH
94579: LD_INT 12
94581: PPUSH
94582: CALL_OW 12
94586: PPUSH
94587: CALL_OW 273
94591: ST_TO_ADDR
// if ValidHex ( x , y ) then
94592: LD_VAR 0 2
94596: PPUSH
94597: LD_VAR 0 3
94601: PPUSH
94602: CALL_OW 488
94606: IFFALSE 94641
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
94608: LD_VAR 0 1
94612: PPUSH
94613: LD_VAR 0 2
94617: PPUSH
94618: LD_VAR 0 3
94622: PPUSH
94623: LD_INT 3
94625: PPUSH
94626: LD_INT 6
94628: PPUSH
94629: CALL_OW 12
94633: PPUSH
94634: LD_INT 1
94636: PPUSH
94637: CALL_OW 483
// end ;
94641: GO 94501
94643: POP
94644: POP
// end ;
94645: PPOPN 5
94647: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
94648: LD_EXP 112
94652: PUSH
94653: LD_EXP 147
94657: AND
94658: IFFALSE 94752
94660: GO 94662
94662: DISABLE
94663: LD_INT 0
94665: PPUSH
94666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
94667: LD_ADDR_VAR 0 2
94671: PUSH
94672: LD_INT 22
94674: PUSH
94675: LD_OWVAR 2
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 32
94686: PUSH
94687: LD_INT 1
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 21
94696: PUSH
94697: LD_INT 2
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: LIST
94708: PPUSH
94709: CALL_OW 69
94713: ST_TO_ADDR
// if not tmp then
94714: LD_VAR 0 2
94718: NOT
94719: IFFALSE 94723
// exit ;
94721: GO 94752
// for i in tmp do
94723: LD_ADDR_VAR 0 1
94727: PUSH
94728: LD_VAR 0 2
94732: PUSH
94733: FOR_IN
94734: IFFALSE 94750
// SetFuel ( i , 0 ) ;
94736: LD_VAR 0 1
94740: PPUSH
94741: LD_INT 0
94743: PPUSH
94744: CALL_OW 240
94748: GO 94733
94750: POP
94751: POP
// end ;
94752: PPOPN 2
94754: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
94755: LD_EXP 112
94759: PUSH
94760: LD_EXP 148
94764: AND
94765: IFFALSE 94831
94767: GO 94769
94769: DISABLE
94770: LD_INT 0
94772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94773: LD_ADDR_VAR 0 1
94777: PUSH
94778: LD_INT 22
94780: PUSH
94781: LD_OWVAR 2
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 30
94792: PUSH
94793: LD_INT 29
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PPUSH
94804: CALL_OW 69
94808: ST_TO_ADDR
// if not tmp then
94809: LD_VAR 0 1
94813: NOT
94814: IFFALSE 94818
// exit ;
94816: GO 94831
// DestroyUnit ( tmp [ 1 ] ) ;
94818: LD_VAR 0 1
94822: PUSH
94823: LD_INT 1
94825: ARRAY
94826: PPUSH
94827: CALL_OW 65
// end ;
94831: PPOPN 1
94833: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
94834: LD_EXP 112
94838: PUSH
94839: LD_EXP 150
94843: AND
94844: IFFALSE 94973
94846: GO 94848
94848: DISABLE
94849: LD_INT 0
94851: PPUSH
// begin uc_side := 0 ;
94852: LD_ADDR_OWVAR 20
94856: PUSH
94857: LD_INT 0
94859: ST_TO_ADDR
// uc_nation := nation_arabian ;
94860: LD_ADDR_OWVAR 21
94864: PUSH
94865: LD_INT 2
94867: ST_TO_ADDR
// hc_gallery :=  ;
94868: LD_ADDR_OWVAR 33
94872: PUSH
94873: LD_STRING 
94875: ST_TO_ADDR
// hc_name :=  ;
94876: LD_ADDR_OWVAR 26
94880: PUSH
94881: LD_STRING 
94883: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94884: LD_INT 1
94886: PPUSH
94887: LD_INT 11
94889: PPUSH
94890: LD_INT 10
94892: PPUSH
94893: CALL_OW 380
// un := CreateHuman ;
94897: LD_ADDR_VAR 0 1
94901: PUSH
94902: CALL_OW 44
94906: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94907: LD_VAR 0 1
94911: PPUSH
94912: LD_INT 1
94914: PPUSH
94915: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94919: LD_INT 35
94921: PPUSH
94922: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94926: LD_VAR 0 1
94930: PPUSH
94931: LD_INT 22
94933: PUSH
94934: LD_OWVAR 2
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: PPUSH
94943: CALL_OW 69
94947: PPUSH
94948: LD_VAR 0 1
94952: PPUSH
94953: CALL_OW 74
94957: PPUSH
94958: CALL_OW 115
// until IsDead ( un ) ;
94962: LD_VAR 0 1
94966: PPUSH
94967: CALL_OW 301
94971: IFFALSE 94919
// end ;
94973: PPOPN 1
94975: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94976: LD_EXP 112
94980: PUSH
94981: LD_EXP 152
94985: AND
94986: IFFALSE 94998
94988: GO 94990
94990: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94991: LD_STRING earthquake(getX(game), 0, 32)
94993: PPUSH
94994: CALL_OW 559
94998: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94999: LD_EXP 112
95003: PUSH
95004: LD_EXP 153
95008: AND
95009: IFFALSE 95100
95011: GO 95013
95013: DISABLE
95014: LD_INT 0
95016: PPUSH
// begin enable ;
95017: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95018: LD_ADDR_VAR 0 1
95022: PUSH
95023: LD_INT 22
95025: PUSH
95026: LD_OWVAR 2
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 21
95037: PUSH
95038: LD_INT 2
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 33
95047: PUSH
95048: LD_INT 3
95050: PUSH
95051: EMPTY
95052: LIST
95053: LIST
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: LIST
95059: PPUSH
95060: CALL_OW 69
95064: ST_TO_ADDR
// if not tmp then
95065: LD_VAR 0 1
95069: NOT
95070: IFFALSE 95074
// exit ;
95072: GO 95100
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95074: LD_VAR 0 1
95078: PUSH
95079: LD_INT 1
95081: PPUSH
95082: LD_VAR 0 1
95086: PPUSH
95087: CALL_OW 12
95091: ARRAY
95092: PPUSH
95093: LD_INT 1
95095: PPUSH
95096: CALL_OW 234
// end ;
95100: PPOPN 1
95102: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95103: LD_EXP 112
95107: PUSH
95108: LD_EXP 154
95112: AND
95113: IFFALSE 95254
95115: GO 95117
95117: DISABLE
95118: LD_INT 0
95120: PPUSH
95121: PPUSH
95122: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95123: LD_ADDR_VAR 0 3
95127: PUSH
95128: LD_INT 22
95130: PUSH
95131: LD_OWVAR 2
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: LD_INT 25
95142: PUSH
95143: LD_INT 1
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PPUSH
95154: CALL_OW 69
95158: ST_TO_ADDR
// if not tmp then
95159: LD_VAR 0 3
95163: NOT
95164: IFFALSE 95168
// exit ;
95166: GO 95254
// un := tmp [ rand ( 1 , tmp ) ] ;
95168: LD_ADDR_VAR 0 2
95172: PUSH
95173: LD_VAR 0 3
95177: PUSH
95178: LD_INT 1
95180: PPUSH
95181: LD_VAR 0 3
95185: PPUSH
95186: CALL_OW 12
95190: ARRAY
95191: ST_TO_ADDR
// if Crawls ( un ) then
95192: LD_VAR 0 2
95196: PPUSH
95197: CALL_OW 318
95201: IFFALSE 95212
// ComWalk ( un ) ;
95203: LD_VAR 0 2
95207: PPUSH
95208: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95212: LD_VAR 0 2
95216: PPUSH
95217: LD_INT 9
95219: PPUSH
95220: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95224: LD_INT 28
95226: PPUSH
95227: LD_OWVAR 2
95231: PPUSH
95232: LD_INT 2
95234: PPUSH
95235: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95239: LD_INT 29
95241: PPUSH
95242: LD_OWVAR 2
95246: PPUSH
95247: LD_INT 2
95249: PPUSH
95250: CALL_OW 322
// end ;
95254: PPOPN 3
95256: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95257: LD_EXP 112
95261: PUSH
95262: LD_EXP 155
95266: AND
95267: IFFALSE 95378
95269: GO 95271
95271: DISABLE
95272: LD_INT 0
95274: PPUSH
95275: PPUSH
95276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95277: LD_ADDR_VAR 0 3
95281: PUSH
95282: LD_INT 22
95284: PUSH
95285: LD_OWVAR 2
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 25
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PPUSH
95308: CALL_OW 69
95312: ST_TO_ADDR
// if not tmp then
95313: LD_VAR 0 3
95317: NOT
95318: IFFALSE 95322
// exit ;
95320: GO 95378
// un := tmp [ rand ( 1 , tmp ) ] ;
95322: LD_ADDR_VAR 0 2
95326: PUSH
95327: LD_VAR 0 3
95331: PUSH
95332: LD_INT 1
95334: PPUSH
95335: LD_VAR 0 3
95339: PPUSH
95340: CALL_OW 12
95344: ARRAY
95345: ST_TO_ADDR
// if Crawls ( un ) then
95346: LD_VAR 0 2
95350: PPUSH
95351: CALL_OW 318
95355: IFFALSE 95366
// ComWalk ( un ) ;
95357: LD_VAR 0 2
95361: PPUSH
95362: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95366: LD_VAR 0 2
95370: PPUSH
95371: LD_INT 8
95373: PPUSH
95374: CALL_OW 336
// end ;
95378: PPOPN 3
95380: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
95381: LD_EXP 112
95385: PUSH
95386: LD_EXP 156
95390: AND
95391: IFFALSE 95535
95393: GO 95395
95395: DISABLE
95396: LD_INT 0
95398: PPUSH
95399: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
95400: LD_ADDR_VAR 0 2
95404: PUSH
95405: LD_INT 22
95407: PUSH
95408: LD_OWVAR 2
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 21
95419: PUSH
95420: LD_INT 2
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 2
95429: PUSH
95430: LD_INT 34
95432: PUSH
95433: LD_INT 12
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 34
95442: PUSH
95443: LD_INT 51
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 34
95452: PUSH
95453: LD_INT 32
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: LIST
95470: PPUSH
95471: CALL_OW 69
95475: ST_TO_ADDR
// if not tmp then
95476: LD_VAR 0 2
95480: NOT
95481: IFFALSE 95485
// exit ;
95483: GO 95535
// for i in tmp do
95485: LD_ADDR_VAR 0 1
95489: PUSH
95490: LD_VAR 0 2
95494: PUSH
95495: FOR_IN
95496: IFFALSE 95533
// if GetCargo ( i , mat_artifact ) = 0 then
95498: LD_VAR 0 1
95502: PPUSH
95503: LD_INT 4
95505: PPUSH
95506: CALL_OW 289
95510: PUSH
95511: LD_INT 0
95513: EQUAL
95514: IFFALSE 95531
// SetCargo ( i , mat_siberit , 100 ) ;
95516: LD_VAR 0 1
95520: PPUSH
95521: LD_INT 3
95523: PPUSH
95524: LD_INT 100
95526: PPUSH
95527: CALL_OW 290
95531: GO 95495
95533: POP
95534: POP
// end ;
95535: PPOPN 2
95537: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
95538: LD_EXP 112
95542: PUSH
95543: LD_EXP 157
95547: AND
95548: IFFALSE 95731
95550: GO 95552
95552: DISABLE
95553: LD_INT 0
95555: PPUSH
95556: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95557: LD_ADDR_VAR 0 2
95561: PUSH
95562: LD_INT 22
95564: PUSH
95565: LD_OWVAR 2
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PPUSH
95574: CALL_OW 69
95578: ST_TO_ADDR
// if not tmp then
95579: LD_VAR 0 2
95583: NOT
95584: IFFALSE 95588
// exit ;
95586: GO 95731
// for i := 1 to 2 do
95588: LD_ADDR_VAR 0 1
95592: PUSH
95593: DOUBLE
95594: LD_INT 1
95596: DEC
95597: ST_TO_ADDR
95598: LD_INT 2
95600: PUSH
95601: FOR_TO
95602: IFFALSE 95729
// begin uc_side := your_side ;
95604: LD_ADDR_OWVAR 20
95608: PUSH
95609: LD_OWVAR 2
95613: ST_TO_ADDR
// uc_nation := nation_american ;
95614: LD_ADDR_OWVAR 21
95618: PUSH
95619: LD_INT 1
95621: ST_TO_ADDR
// vc_chassis := us_morphling ;
95622: LD_ADDR_OWVAR 37
95626: PUSH
95627: LD_INT 5
95629: ST_TO_ADDR
// vc_engine := engine_siberite ;
95630: LD_ADDR_OWVAR 39
95634: PUSH
95635: LD_INT 3
95637: ST_TO_ADDR
// vc_control := control_computer ;
95638: LD_ADDR_OWVAR 38
95642: PUSH
95643: LD_INT 3
95645: ST_TO_ADDR
// vc_weapon := us_double_laser ;
95646: LD_ADDR_OWVAR 40
95650: PUSH
95651: LD_INT 10
95653: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
95654: LD_VAR 0 2
95658: PUSH
95659: LD_INT 1
95661: ARRAY
95662: PPUSH
95663: CALL_OW 310
95667: NOT
95668: IFFALSE 95715
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
95670: CALL_OW 45
95674: PPUSH
95675: LD_VAR 0 2
95679: PUSH
95680: LD_INT 1
95682: ARRAY
95683: PPUSH
95684: CALL_OW 250
95688: PPUSH
95689: LD_VAR 0 2
95693: PUSH
95694: LD_INT 1
95696: ARRAY
95697: PPUSH
95698: CALL_OW 251
95702: PPUSH
95703: LD_INT 12
95705: PPUSH
95706: LD_INT 1
95708: PPUSH
95709: CALL_OW 50
95713: GO 95727
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95715: CALL_OW 45
95719: PPUSH
95720: LD_INT 1
95722: PPUSH
95723: CALL_OW 51
// end ;
95727: GO 95601
95729: POP
95730: POP
// end ;
95731: PPOPN 2
95733: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
95734: LD_EXP 112
95738: PUSH
95739: LD_EXP 158
95743: AND
95744: IFFALSE 95966
95746: GO 95748
95748: DISABLE
95749: LD_INT 0
95751: PPUSH
95752: PPUSH
95753: PPUSH
95754: PPUSH
95755: PPUSH
95756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95757: LD_ADDR_VAR 0 6
95761: PUSH
95762: LD_INT 22
95764: PUSH
95765: LD_OWVAR 2
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 21
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 3
95786: PUSH
95787: LD_INT 23
95789: PUSH
95790: LD_INT 0
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: LIST
95805: PPUSH
95806: CALL_OW 69
95810: ST_TO_ADDR
// if not tmp then
95811: LD_VAR 0 6
95815: NOT
95816: IFFALSE 95820
// exit ;
95818: GO 95966
// s1 := rand ( 1 , 4 ) ;
95820: LD_ADDR_VAR 0 2
95824: PUSH
95825: LD_INT 1
95827: PPUSH
95828: LD_INT 4
95830: PPUSH
95831: CALL_OW 12
95835: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
95836: LD_ADDR_VAR 0 4
95840: PUSH
95841: LD_VAR 0 6
95845: PUSH
95846: LD_INT 1
95848: ARRAY
95849: PPUSH
95850: LD_VAR 0 2
95854: PPUSH
95855: CALL_OW 259
95859: ST_TO_ADDR
// if s1 = 1 then
95860: LD_VAR 0 2
95864: PUSH
95865: LD_INT 1
95867: EQUAL
95868: IFFALSE 95888
// s2 := rand ( 2 , 4 ) else
95870: LD_ADDR_VAR 0 3
95874: PUSH
95875: LD_INT 2
95877: PPUSH
95878: LD_INT 4
95880: PPUSH
95881: CALL_OW 12
95885: ST_TO_ADDR
95886: GO 95896
// s2 := 1 ;
95888: LD_ADDR_VAR 0 3
95892: PUSH
95893: LD_INT 1
95895: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95896: LD_ADDR_VAR 0 5
95900: PUSH
95901: LD_VAR 0 6
95905: PUSH
95906: LD_INT 1
95908: ARRAY
95909: PPUSH
95910: LD_VAR 0 3
95914: PPUSH
95915: CALL_OW 259
95919: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95920: LD_VAR 0 6
95924: PUSH
95925: LD_INT 1
95927: ARRAY
95928: PPUSH
95929: LD_VAR 0 2
95933: PPUSH
95934: LD_VAR 0 5
95938: PPUSH
95939: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95943: LD_VAR 0 6
95947: PUSH
95948: LD_INT 1
95950: ARRAY
95951: PPUSH
95952: LD_VAR 0 3
95956: PPUSH
95957: LD_VAR 0 4
95961: PPUSH
95962: CALL_OW 237
// end ;
95966: PPOPN 6
95968: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95969: LD_EXP 112
95973: PUSH
95974: LD_EXP 159
95978: AND
95979: IFFALSE 96058
95981: GO 95983
95983: DISABLE
95984: LD_INT 0
95986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95987: LD_ADDR_VAR 0 1
95991: PUSH
95992: LD_INT 22
95994: PUSH
95995: LD_OWVAR 2
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 30
96006: PUSH
96007: LD_INT 3
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PPUSH
96018: CALL_OW 69
96022: ST_TO_ADDR
// if not tmp then
96023: LD_VAR 0 1
96027: NOT
96028: IFFALSE 96032
// exit ;
96030: GO 96058
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96032: LD_VAR 0 1
96036: PUSH
96037: LD_INT 1
96039: PPUSH
96040: LD_VAR 0 1
96044: PPUSH
96045: CALL_OW 12
96049: ARRAY
96050: PPUSH
96051: LD_INT 1
96053: PPUSH
96054: CALL_OW 234
// end ;
96058: PPOPN 1
96060: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96061: LD_EXP 112
96065: PUSH
96066: LD_EXP 160
96070: AND
96071: IFFALSE 96183
96073: GO 96075
96075: DISABLE
96076: LD_INT 0
96078: PPUSH
96079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96080: LD_ADDR_VAR 0 2
96084: PUSH
96085: LD_INT 22
96087: PUSH
96088: LD_OWVAR 2
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 2
96099: PUSH
96100: LD_INT 30
96102: PUSH
96103: LD_INT 27
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: PUSH
96110: LD_INT 30
96112: PUSH
96113: LD_INT 26
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 30
96122: PUSH
96123: LD_INT 28
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PPUSH
96140: CALL_OW 69
96144: ST_TO_ADDR
// if not tmp then
96145: LD_VAR 0 2
96149: NOT
96150: IFFALSE 96154
// exit ;
96152: GO 96183
// for i in tmp do
96154: LD_ADDR_VAR 0 1
96158: PUSH
96159: LD_VAR 0 2
96163: PUSH
96164: FOR_IN
96165: IFFALSE 96181
// SetLives ( i , 1 ) ;
96167: LD_VAR 0 1
96171: PPUSH
96172: LD_INT 1
96174: PPUSH
96175: CALL_OW 234
96179: GO 96164
96181: POP
96182: POP
// end ;
96183: PPOPN 2
96185: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96186: LD_EXP 112
96190: PUSH
96191: LD_EXP 161
96195: AND
96196: IFFALSE 96470
96198: GO 96200
96200: DISABLE
96201: LD_INT 0
96203: PPUSH
96204: PPUSH
96205: PPUSH
// begin i := rand ( 1 , 7 ) ;
96206: LD_ADDR_VAR 0 1
96210: PUSH
96211: LD_INT 1
96213: PPUSH
96214: LD_INT 7
96216: PPUSH
96217: CALL_OW 12
96221: ST_TO_ADDR
// case i of 1 :
96222: LD_VAR 0 1
96226: PUSH
96227: LD_INT 1
96229: DOUBLE
96230: EQUAL
96231: IFTRUE 96235
96233: GO 96245
96235: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96236: LD_STRING earthquake(getX(game), 0, 32)
96238: PPUSH
96239: CALL_OW 559
96243: GO 96470
96245: LD_INT 2
96247: DOUBLE
96248: EQUAL
96249: IFTRUE 96253
96251: GO 96267
96253: POP
// begin ToLua ( displayStucuk(); ) ;
96254: LD_STRING displayStucuk();
96256: PPUSH
96257: CALL_OW 559
// ResetFog ;
96261: CALL_OW 335
// end ; 3 :
96265: GO 96470
96267: LD_INT 3
96269: DOUBLE
96270: EQUAL
96271: IFTRUE 96275
96273: GO 96379
96275: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96276: LD_ADDR_VAR 0 2
96280: PUSH
96281: LD_INT 22
96283: PUSH
96284: LD_OWVAR 2
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 25
96295: PUSH
96296: LD_INT 1
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: EMPTY
96304: LIST
96305: LIST
96306: PPUSH
96307: CALL_OW 69
96311: ST_TO_ADDR
// if not tmp then
96312: LD_VAR 0 2
96316: NOT
96317: IFFALSE 96321
// exit ;
96319: GO 96470
// un := tmp [ rand ( 1 , tmp ) ] ;
96321: LD_ADDR_VAR 0 3
96325: PUSH
96326: LD_VAR 0 2
96330: PUSH
96331: LD_INT 1
96333: PPUSH
96334: LD_VAR 0 2
96338: PPUSH
96339: CALL_OW 12
96343: ARRAY
96344: ST_TO_ADDR
// if Crawls ( un ) then
96345: LD_VAR 0 3
96349: PPUSH
96350: CALL_OW 318
96354: IFFALSE 96365
// ComWalk ( un ) ;
96356: LD_VAR 0 3
96360: PPUSH
96361: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96365: LD_VAR 0 3
96369: PPUSH
96370: LD_INT 8
96372: PPUSH
96373: CALL_OW 336
// end ; 4 :
96377: GO 96470
96379: LD_INT 4
96381: DOUBLE
96382: EQUAL
96383: IFTRUE 96387
96385: GO 96448
96387: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96388: LD_ADDR_VAR 0 2
96392: PUSH
96393: LD_INT 22
96395: PUSH
96396: LD_OWVAR 2
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 30
96407: PUSH
96408: LD_INT 29
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: PPUSH
96419: CALL_OW 69
96423: ST_TO_ADDR
// if not tmp then
96424: LD_VAR 0 2
96428: NOT
96429: IFFALSE 96433
// exit ;
96431: GO 96470
// DestroyUnit ( tmp [ 1 ] ) ;
96433: LD_VAR 0 2
96437: PUSH
96438: LD_INT 1
96440: ARRAY
96441: PPUSH
96442: CALL_OW 65
// end ; 5 .. 7 :
96446: GO 96470
96448: LD_INT 5
96450: DOUBLE
96451: GREATEREQUAL
96452: IFFALSE 96460
96454: LD_INT 7
96456: DOUBLE
96457: LESSEQUAL
96458: IFTRUE 96462
96460: GO 96469
96462: POP
// StreamSibBomb ; end ;
96463: CALL 92720 0 0
96467: GO 96470
96469: POP
// end ;
96470: PPOPN 3
96472: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
96473: LD_EXP 112
96477: PUSH
96478: LD_EXP 162
96482: AND
96483: IFFALSE 96639
96485: GO 96487
96487: DISABLE
96488: LD_INT 0
96490: PPUSH
96491: PPUSH
96492: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
96493: LD_ADDR_VAR 0 2
96497: PUSH
96498: LD_INT 81
96500: PUSH
96501: LD_OWVAR 2
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 2
96512: PUSH
96513: LD_INT 21
96515: PUSH
96516: LD_INT 1
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 21
96525: PUSH
96526: LD_INT 2
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: LIST
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: PPUSH
96542: CALL_OW 69
96546: ST_TO_ADDR
// if not tmp then
96547: LD_VAR 0 2
96551: NOT
96552: IFFALSE 96556
// exit ;
96554: GO 96639
// p := 0 ;
96556: LD_ADDR_VAR 0 3
96560: PUSH
96561: LD_INT 0
96563: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96564: LD_INT 35
96566: PPUSH
96567: CALL_OW 67
// p := p + 1 ;
96571: LD_ADDR_VAR 0 3
96575: PUSH
96576: LD_VAR 0 3
96580: PUSH
96581: LD_INT 1
96583: PLUS
96584: ST_TO_ADDR
// for i in tmp do
96585: LD_ADDR_VAR 0 1
96589: PUSH
96590: LD_VAR 0 2
96594: PUSH
96595: FOR_IN
96596: IFFALSE 96627
// if GetLives ( i ) < 1000 then
96598: LD_VAR 0 1
96602: PPUSH
96603: CALL_OW 256
96607: PUSH
96608: LD_INT 1000
96610: LESS
96611: IFFALSE 96625
// SetLives ( i , 1000 ) ;
96613: LD_VAR 0 1
96617: PPUSH
96618: LD_INT 1000
96620: PPUSH
96621: CALL_OW 234
96625: GO 96595
96627: POP
96628: POP
// until p > 20 ;
96629: LD_VAR 0 3
96633: PUSH
96634: LD_INT 20
96636: GREATER
96637: IFFALSE 96564
// end ;
96639: PPOPN 3
96641: END
// every 0 0$1 trigger StreamModeActive and sTime do
96642: LD_EXP 112
96646: PUSH
96647: LD_EXP 163
96651: AND
96652: IFFALSE 96687
96654: GO 96656
96656: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
96657: LD_INT 28
96659: PPUSH
96660: LD_OWVAR 2
96664: PPUSH
96665: LD_INT 2
96667: PPUSH
96668: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
96672: LD_INT 30
96674: PPUSH
96675: LD_OWVAR 2
96679: PPUSH
96680: LD_INT 2
96682: PPUSH
96683: CALL_OW 322
// end ;
96687: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
96688: LD_EXP 112
96692: PUSH
96693: LD_EXP 164
96697: AND
96698: IFFALSE 96819
96700: GO 96702
96702: DISABLE
96703: LD_INT 0
96705: PPUSH
96706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96707: LD_ADDR_VAR 0 2
96711: PUSH
96712: LD_INT 22
96714: PUSH
96715: LD_OWVAR 2
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: PUSH
96724: LD_INT 21
96726: PUSH
96727: LD_INT 1
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: LD_INT 3
96736: PUSH
96737: LD_INT 23
96739: PUSH
96740: LD_INT 0
96742: PUSH
96743: EMPTY
96744: LIST
96745: LIST
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: LIST
96755: PPUSH
96756: CALL_OW 69
96760: ST_TO_ADDR
// if not tmp then
96761: LD_VAR 0 2
96765: NOT
96766: IFFALSE 96770
// exit ;
96768: GO 96819
// for i in tmp do
96770: LD_ADDR_VAR 0 1
96774: PUSH
96775: LD_VAR 0 2
96779: PUSH
96780: FOR_IN
96781: IFFALSE 96817
// begin if Crawls ( i ) then
96783: LD_VAR 0 1
96787: PPUSH
96788: CALL_OW 318
96792: IFFALSE 96803
// ComWalk ( i ) ;
96794: LD_VAR 0 1
96798: PPUSH
96799: CALL_OW 138
// SetClass ( i , 2 ) ;
96803: LD_VAR 0 1
96807: PPUSH
96808: LD_INT 2
96810: PPUSH
96811: CALL_OW 336
// end ;
96815: GO 96780
96817: POP
96818: POP
// end ;
96819: PPOPN 2
96821: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
96822: LD_EXP 112
96826: PUSH
96827: LD_EXP 165
96831: AND
96832: IFFALSE 97113
96834: GO 96836
96836: DISABLE
96837: LD_INT 0
96839: PPUSH
96840: PPUSH
96841: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96842: LD_OWVAR 2
96846: PPUSH
96847: LD_INT 9
96849: PPUSH
96850: LD_INT 1
96852: PPUSH
96853: LD_INT 1
96855: PPUSH
96856: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96860: LD_INT 9
96862: PPUSH
96863: LD_OWVAR 2
96867: PPUSH
96868: CALL_OW 343
// uc_side := 9 ;
96872: LD_ADDR_OWVAR 20
96876: PUSH
96877: LD_INT 9
96879: ST_TO_ADDR
// uc_nation := 2 ;
96880: LD_ADDR_OWVAR 21
96884: PUSH
96885: LD_INT 2
96887: ST_TO_ADDR
// hc_name := Dark Warrior ;
96888: LD_ADDR_OWVAR 26
96892: PUSH
96893: LD_STRING Dark Warrior
96895: ST_TO_ADDR
// hc_gallery :=  ;
96896: LD_ADDR_OWVAR 33
96900: PUSH
96901: LD_STRING 
96903: ST_TO_ADDR
// hc_noskilllimit := true ;
96904: LD_ADDR_OWVAR 76
96908: PUSH
96909: LD_INT 1
96911: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96912: LD_ADDR_OWVAR 31
96916: PUSH
96917: LD_INT 30
96919: PUSH
96920: LD_INT 30
96922: PUSH
96923: LD_INT 30
96925: PUSH
96926: LD_INT 30
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: ST_TO_ADDR
// un := CreateHuman ;
96935: LD_ADDR_VAR 0 3
96939: PUSH
96940: CALL_OW 44
96944: ST_TO_ADDR
// hc_noskilllimit := false ;
96945: LD_ADDR_OWVAR 76
96949: PUSH
96950: LD_INT 0
96952: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96953: LD_VAR 0 3
96957: PPUSH
96958: LD_INT 1
96960: PPUSH
96961: CALL_OW 51
// p := 0 ;
96965: LD_ADDR_VAR 0 2
96969: PUSH
96970: LD_INT 0
96972: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96973: LD_INT 35
96975: PPUSH
96976: CALL_OW 67
// p := p + 1 ;
96980: LD_ADDR_VAR 0 2
96984: PUSH
96985: LD_VAR 0 2
96989: PUSH
96990: LD_INT 1
96992: PLUS
96993: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96994: LD_VAR 0 3
96998: PPUSH
96999: CALL_OW 256
97003: PUSH
97004: LD_INT 1000
97006: LESS
97007: IFFALSE 97021
// SetLives ( un , 1000 ) ;
97009: LD_VAR 0 3
97013: PPUSH
97014: LD_INT 1000
97016: PPUSH
97017: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97021: LD_VAR 0 3
97025: PPUSH
97026: LD_INT 81
97028: PUSH
97029: LD_OWVAR 2
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: LD_INT 91
97040: PUSH
97041: LD_VAR 0 3
97045: PUSH
97046: LD_INT 30
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: LIST
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PPUSH
97058: CALL_OW 69
97062: PPUSH
97063: LD_VAR 0 3
97067: PPUSH
97068: CALL_OW 74
97072: PPUSH
97073: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
97077: LD_VAR 0 2
97081: PUSH
97082: LD_INT 60
97084: GREATER
97085: PUSH
97086: LD_VAR 0 3
97090: PPUSH
97091: CALL_OW 301
97095: OR
97096: IFFALSE 96973
// if un then
97098: LD_VAR 0 3
97102: IFFALSE 97113
// RemoveUnit ( un ) ;
97104: LD_VAR 0 3
97108: PPUSH
97109: CALL_OW 64
// end ;
97113: PPOPN 3
97115: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
97116: LD_INT 0
97118: PPUSH
// case cmd of 301 :
97119: LD_VAR 0 1
97123: PUSH
97124: LD_INT 301
97126: DOUBLE
97127: EQUAL
97128: IFTRUE 97132
97130: GO 97164
97132: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
97133: LD_VAR 0 6
97137: PPUSH
97138: LD_VAR 0 7
97142: PPUSH
97143: LD_VAR 0 8
97147: PPUSH
97148: LD_VAR 0 4
97152: PPUSH
97153: LD_VAR 0 5
97157: PPUSH
97158: CALL 98365 0 5
97162: GO 97285
97164: LD_INT 302
97166: DOUBLE
97167: EQUAL
97168: IFTRUE 97172
97170: GO 97209
97172: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
97173: LD_VAR 0 6
97177: PPUSH
97178: LD_VAR 0 7
97182: PPUSH
97183: LD_VAR 0 8
97187: PPUSH
97188: LD_VAR 0 9
97192: PPUSH
97193: LD_VAR 0 4
97197: PPUSH
97198: LD_VAR 0 5
97202: PPUSH
97203: CALL 98456 0 6
97207: GO 97285
97209: LD_INT 303
97211: DOUBLE
97212: EQUAL
97213: IFTRUE 97217
97215: GO 97254
97217: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
97218: LD_VAR 0 6
97222: PPUSH
97223: LD_VAR 0 7
97227: PPUSH
97228: LD_VAR 0 8
97232: PPUSH
97233: LD_VAR 0 9
97237: PPUSH
97238: LD_VAR 0 4
97242: PPUSH
97243: LD_VAR 0 5
97247: PPUSH
97248: CALL 97290 0 6
97252: GO 97285
97254: LD_INT 304
97256: DOUBLE
97257: EQUAL
97258: IFTRUE 97262
97260: GO 97284
97262: POP
// hHackTeleport ( unit , x , y ) ; end ;
97263: LD_VAR 0 2
97267: PPUSH
97268: LD_VAR 0 4
97272: PPUSH
97273: LD_VAR 0 5
97277: PPUSH
97278: CALL 99049 0 3
97282: GO 97285
97284: POP
// end ;
97285: LD_VAR 0 12
97289: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
97290: LD_INT 0
97292: PPUSH
97293: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
97294: LD_VAR 0 1
97298: PUSH
97299: LD_INT 1
97301: LESS
97302: PUSH
97303: LD_VAR 0 1
97307: PUSH
97308: LD_INT 3
97310: GREATER
97311: OR
97312: PUSH
97313: LD_VAR 0 5
97317: PPUSH
97318: LD_VAR 0 6
97322: PPUSH
97323: CALL_OW 428
97327: OR
97328: IFFALSE 97332
// exit ;
97330: GO 98052
// uc_side := your_side ;
97332: LD_ADDR_OWVAR 20
97336: PUSH
97337: LD_OWVAR 2
97341: ST_TO_ADDR
// uc_nation := nation ;
97342: LD_ADDR_OWVAR 21
97346: PUSH
97347: LD_VAR 0 1
97351: ST_TO_ADDR
// bc_level = 1 ;
97352: LD_ADDR_OWVAR 43
97356: PUSH
97357: LD_INT 1
97359: ST_TO_ADDR
// case btype of 1 :
97360: LD_VAR 0 2
97364: PUSH
97365: LD_INT 1
97367: DOUBLE
97368: EQUAL
97369: IFTRUE 97373
97371: GO 97384
97373: POP
// bc_type := b_depot ; 2 :
97374: LD_ADDR_OWVAR 42
97378: PUSH
97379: LD_INT 0
97381: ST_TO_ADDR
97382: GO 97996
97384: LD_INT 2
97386: DOUBLE
97387: EQUAL
97388: IFTRUE 97392
97390: GO 97403
97392: POP
// bc_type := b_warehouse ; 3 :
97393: LD_ADDR_OWVAR 42
97397: PUSH
97398: LD_INT 1
97400: ST_TO_ADDR
97401: GO 97996
97403: LD_INT 3
97405: DOUBLE
97406: EQUAL
97407: IFTRUE 97411
97409: GO 97422
97411: POP
// bc_type := b_lab ; 4 .. 9 :
97412: LD_ADDR_OWVAR 42
97416: PUSH
97417: LD_INT 6
97419: ST_TO_ADDR
97420: GO 97996
97422: LD_INT 4
97424: DOUBLE
97425: GREATEREQUAL
97426: IFFALSE 97434
97428: LD_INT 9
97430: DOUBLE
97431: LESSEQUAL
97432: IFTRUE 97436
97434: GO 97488
97436: POP
// begin bc_type := b_lab_half ;
97437: LD_ADDR_OWVAR 42
97441: PUSH
97442: LD_INT 7
97444: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
97445: LD_ADDR_OWVAR 44
97449: PUSH
97450: LD_INT 10
97452: PUSH
97453: LD_INT 11
97455: PUSH
97456: LD_INT 12
97458: PUSH
97459: LD_INT 15
97461: PUSH
97462: LD_INT 14
97464: PUSH
97465: LD_INT 13
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: PUSH
97476: LD_VAR 0 2
97480: PUSH
97481: LD_INT 3
97483: MINUS
97484: ARRAY
97485: ST_TO_ADDR
// end ; 10 .. 13 :
97486: GO 97996
97488: LD_INT 10
97490: DOUBLE
97491: GREATEREQUAL
97492: IFFALSE 97500
97494: LD_INT 13
97496: DOUBLE
97497: LESSEQUAL
97498: IFTRUE 97502
97500: GO 97579
97502: POP
// begin bc_type := b_lab_full ;
97503: LD_ADDR_OWVAR 42
97507: PUSH
97508: LD_INT 8
97510: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
97511: LD_ADDR_OWVAR 44
97515: PUSH
97516: LD_INT 10
97518: PUSH
97519: LD_INT 12
97521: PUSH
97522: LD_INT 14
97524: PUSH
97525: LD_INT 13
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: PUSH
97534: LD_VAR 0 2
97538: PUSH
97539: LD_INT 9
97541: MINUS
97542: ARRAY
97543: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
97544: LD_ADDR_OWVAR 45
97548: PUSH
97549: LD_INT 11
97551: PUSH
97552: LD_INT 15
97554: PUSH
97555: LD_INT 12
97557: PUSH
97558: LD_INT 15
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: PUSH
97567: LD_VAR 0 2
97571: PUSH
97572: LD_INT 9
97574: MINUS
97575: ARRAY
97576: ST_TO_ADDR
// end ; 14 :
97577: GO 97996
97579: LD_INT 14
97581: DOUBLE
97582: EQUAL
97583: IFTRUE 97587
97585: GO 97598
97587: POP
// bc_type := b_workshop ; 15 :
97588: LD_ADDR_OWVAR 42
97592: PUSH
97593: LD_INT 2
97595: ST_TO_ADDR
97596: GO 97996
97598: LD_INT 15
97600: DOUBLE
97601: EQUAL
97602: IFTRUE 97606
97604: GO 97617
97606: POP
// bc_type := b_factory ; 16 :
97607: LD_ADDR_OWVAR 42
97611: PUSH
97612: LD_INT 3
97614: ST_TO_ADDR
97615: GO 97996
97617: LD_INT 16
97619: DOUBLE
97620: EQUAL
97621: IFTRUE 97625
97623: GO 97636
97625: POP
// bc_type := b_ext_gun ; 17 :
97626: LD_ADDR_OWVAR 42
97630: PUSH
97631: LD_INT 17
97633: ST_TO_ADDR
97634: GO 97996
97636: LD_INT 17
97638: DOUBLE
97639: EQUAL
97640: IFTRUE 97644
97642: GO 97672
97644: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
97645: LD_ADDR_OWVAR 42
97649: PUSH
97650: LD_INT 19
97652: PUSH
97653: LD_INT 23
97655: PUSH
97656: LD_INT 19
97658: PUSH
97659: EMPTY
97660: LIST
97661: LIST
97662: LIST
97663: PUSH
97664: LD_VAR 0 1
97668: ARRAY
97669: ST_TO_ADDR
97670: GO 97996
97672: LD_INT 18
97674: DOUBLE
97675: EQUAL
97676: IFTRUE 97680
97678: GO 97691
97680: POP
// bc_type := b_ext_radar ; 19 :
97681: LD_ADDR_OWVAR 42
97685: PUSH
97686: LD_INT 20
97688: ST_TO_ADDR
97689: GO 97996
97691: LD_INT 19
97693: DOUBLE
97694: EQUAL
97695: IFTRUE 97699
97697: GO 97710
97699: POP
// bc_type := b_ext_radio ; 20 :
97700: LD_ADDR_OWVAR 42
97704: PUSH
97705: LD_INT 22
97707: ST_TO_ADDR
97708: GO 97996
97710: LD_INT 20
97712: DOUBLE
97713: EQUAL
97714: IFTRUE 97718
97716: GO 97729
97718: POP
// bc_type := b_ext_siberium ; 21 :
97719: LD_ADDR_OWVAR 42
97723: PUSH
97724: LD_INT 21
97726: ST_TO_ADDR
97727: GO 97996
97729: LD_INT 21
97731: DOUBLE
97732: EQUAL
97733: IFTRUE 97737
97735: GO 97748
97737: POP
// bc_type := b_ext_computer ; 22 :
97738: LD_ADDR_OWVAR 42
97742: PUSH
97743: LD_INT 24
97745: ST_TO_ADDR
97746: GO 97996
97748: LD_INT 22
97750: DOUBLE
97751: EQUAL
97752: IFTRUE 97756
97754: GO 97767
97756: POP
// bc_type := b_ext_track ; 23 :
97757: LD_ADDR_OWVAR 42
97761: PUSH
97762: LD_INT 16
97764: ST_TO_ADDR
97765: GO 97996
97767: LD_INT 23
97769: DOUBLE
97770: EQUAL
97771: IFTRUE 97775
97773: GO 97786
97775: POP
// bc_type := b_ext_laser ; 24 :
97776: LD_ADDR_OWVAR 42
97780: PUSH
97781: LD_INT 25
97783: ST_TO_ADDR
97784: GO 97996
97786: LD_INT 24
97788: DOUBLE
97789: EQUAL
97790: IFTRUE 97794
97792: GO 97805
97794: POP
// bc_type := b_control_tower ; 25 :
97795: LD_ADDR_OWVAR 42
97799: PUSH
97800: LD_INT 36
97802: ST_TO_ADDR
97803: GO 97996
97805: LD_INT 25
97807: DOUBLE
97808: EQUAL
97809: IFTRUE 97813
97811: GO 97824
97813: POP
// bc_type := b_breastwork ; 26 :
97814: LD_ADDR_OWVAR 42
97818: PUSH
97819: LD_INT 31
97821: ST_TO_ADDR
97822: GO 97996
97824: LD_INT 26
97826: DOUBLE
97827: EQUAL
97828: IFTRUE 97832
97830: GO 97843
97832: POP
// bc_type := b_bunker ; 27 :
97833: LD_ADDR_OWVAR 42
97837: PUSH
97838: LD_INT 32
97840: ST_TO_ADDR
97841: GO 97996
97843: LD_INT 27
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97851
97849: GO 97862
97851: POP
// bc_type := b_turret ; 28 :
97852: LD_ADDR_OWVAR 42
97856: PUSH
97857: LD_INT 33
97859: ST_TO_ADDR
97860: GO 97996
97862: LD_INT 28
97864: DOUBLE
97865: EQUAL
97866: IFTRUE 97870
97868: GO 97881
97870: POP
// bc_type := b_armoury ; 29 :
97871: LD_ADDR_OWVAR 42
97875: PUSH
97876: LD_INT 4
97878: ST_TO_ADDR
97879: GO 97996
97881: LD_INT 29
97883: DOUBLE
97884: EQUAL
97885: IFTRUE 97889
97887: GO 97900
97889: POP
// bc_type := b_barracks ; 30 :
97890: LD_ADDR_OWVAR 42
97894: PUSH
97895: LD_INT 5
97897: ST_TO_ADDR
97898: GO 97996
97900: LD_INT 30
97902: DOUBLE
97903: EQUAL
97904: IFTRUE 97908
97906: GO 97919
97908: POP
// bc_type := b_solar_power ; 31 :
97909: LD_ADDR_OWVAR 42
97913: PUSH
97914: LD_INT 27
97916: ST_TO_ADDR
97917: GO 97996
97919: LD_INT 31
97921: DOUBLE
97922: EQUAL
97923: IFTRUE 97927
97925: GO 97938
97927: POP
// bc_type := b_oil_power ; 32 :
97928: LD_ADDR_OWVAR 42
97932: PUSH
97933: LD_INT 26
97935: ST_TO_ADDR
97936: GO 97996
97938: LD_INT 32
97940: DOUBLE
97941: EQUAL
97942: IFTRUE 97946
97944: GO 97957
97946: POP
// bc_type := b_siberite_power ; 33 :
97947: LD_ADDR_OWVAR 42
97951: PUSH
97952: LD_INT 28
97954: ST_TO_ADDR
97955: GO 97996
97957: LD_INT 33
97959: DOUBLE
97960: EQUAL
97961: IFTRUE 97965
97963: GO 97976
97965: POP
// bc_type := b_oil_mine ; 34 :
97966: LD_ADDR_OWVAR 42
97970: PUSH
97971: LD_INT 29
97973: ST_TO_ADDR
97974: GO 97996
97976: LD_INT 34
97978: DOUBLE
97979: EQUAL
97980: IFTRUE 97984
97982: GO 97995
97984: POP
// bc_type := b_siberite_mine ; end ;
97985: LD_ADDR_OWVAR 42
97989: PUSH
97990: LD_INT 30
97992: ST_TO_ADDR
97993: GO 97996
97995: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97996: LD_ADDR_VAR 0 8
98000: PUSH
98001: LD_VAR 0 5
98005: PPUSH
98006: LD_VAR 0 6
98010: PPUSH
98011: LD_VAR 0 3
98015: PPUSH
98016: CALL_OW 47
98020: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98021: LD_OWVAR 42
98025: PUSH
98026: LD_INT 32
98028: PUSH
98029: LD_INT 33
98031: PUSH
98032: EMPTY
98033: LIST
98034: LIST
98035: IN
98036: IFFALSE 98052
// PlaceWeaponTurret ( b , weapon ) ;
98038: LD_VAR 0 8
98042: PPUSH
98043: LD_VAR 0 4
98047: PPUSH
98048: CALL_OW 431
// end ;
98052: LD_VAR 0 7
98056: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98057: LD_INT 0
98059: PPUSH
98060: PPUSH
98061: PPUSH
98062: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98063: LD_ADDR_VAR 0 4
98067: PUSH
98068: LD_INT 22
98070: PUSH
98071: LD_OWVAR 2
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: PUSH
98080: LD_INT 2
98082: PUSH
98083: LD_INT 30
98085: PUSH
98086: LD_INT 0
98088: PUSH
98089: EMPTY
98090: LIST
98091: LIST
98092: PUSH
98093: LD_INT 30
98095: PUSH
98096: LD_INT 1
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: PUSH
98103: EMPTY
98104: LIST
98105: LIST
98106: LIST
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PPUSH
98112: CALL_OW 69
98116: ST_TO_ADDR
// if not tmp then
98117: LD_VAR 0 4
98121: NOT
98122: IFFALSE 98126
// exit ;
98124: GO 98185
// for i in tmp do
98126: LD_ADDR_VAR 0 2
98130: PUSH
98131: LD_VAR 0 4
98135: PUSH
98136: FOR_IN
98137: IFFALSE 98183
// for j = 1 to 3 do
98139: LD_ADDR_VAR 0 3
98143: PUSH
98144: DOUBLE
98145: LD_INT 1
98147: DEC
98148: ST_TO_ADDR
98149: LD_INT 3
98151: PUSH
98152: FOR_TO
98153: IFFALSE 98179
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
98155: LD_VAR 0 2
98159: PPUSH
98160: CALL_OW 274
98164: PPUSH
98165: LD_VAR 0 3
98169: PPUSH
98170: LD_INT 99999
98172: PPUSH
98173: CALL_OW 277
98177: GO 98152
98179: POP
98180: POP
98181: GO 98136
98183: POP
98184: POP
// end ;
98185: LD_VAR 0 1
98189: RET
// export function hHackSetLevel10 ; var i , j ; begin
98190: LD_INT 0
98192: PPUSH
98193: PPUSH
98194: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98195: LD_ADDR_VAR 0 2
98199: PUSH
98200: LD_INT 21
98202: PUSH
98203: LD_INT 1
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: PPUSH
98210: CALL_OW 69
98214: PUSH
98215: FOR_IN
98216: IFFALSE 98268
// if IsSelected ( i ) then
98218: LD_VAR 0 2
98222: PPUSH
98223: CALL_OW 306
98227: IFFALSE 98266
// begin for j := 1 to 4 do
98229: LD_ADDR_VAR 0 3
98233: PUSH
98234: DOUBLE
98235: LD_INT 1
98237: DEC
98238: ST_TO_ADDR
98239: LD_INT 4
98241: PUSH
98242: FOR_TO
98243: IFFALSE 98264
// SetSkill ( i , j , 10 ) ;
98245: LD_VAR 0 2
98249: PPUSH
98250: LD_VAR 0 3
98254: PPUSH
98255: LD_INT 10
98257: PPUSH
98258: CALL_OW 237
98262: GO 98242
98264: POP
98265: POP
// end ;
98266: GO 98215
98268: POP
98269: POP
// end ;
98270: LD_VAR 0 1
98274: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98275: LD_INT 0
98277: PPUSH
98278: PPUSH
98279: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98280: LD_ADDR_VAR 0 2
98284: PUSH
98285: LD_INT 22
98287: PUSH
98288: LD_OWVAR 2
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PUSH
98297: LD_INT 21
98299: PUSH
98300: LD_INT 1
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PPUSH
98311: CALL_OW 69
98315: PUSH
98316: FOR_IN
98317: IFFALSE 98358
// begin for j := 1 to 4 do
98319: LD_ADDR_VAR 0 3
98323: PUSH
98324: DOUBLE
98325: LD_INT 1
98327: DEC
98328: ST_TO_ADDR
98329: LD_INT 4
98331: PUSH
98332: FOR_TO
98333: IFFALSE 98354
// SetSkill ( i , j , 10 ) ;
98335: LD_VAR 0 2
98339: PPUSH
98340: LD_VAR 0 3
98344: PPUSH
98345: LD_INT 10
98347: PPUSH
98348: CALL_OW 237
98352: GO 98332
98354: POP
98355: POP
// end ;
98356: GO 98316
98358: POP
98359: POP
// end ;
98360: LD_VAR 0 1
98364: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
98365: LD_INT 0
98367: PPUSH
// uc_side := your_side ;
98368: LD_ADDR_OWVAR 20
98372: PUSH
98373: LD_OWVAR 2
98377: ST_TO_ADDR
// uc_nation := nation ;
98378: LD_ADDR_OWVAR 21
98382: PUSH
98383: LD_VAR 0 1
98387: ST_TO_ADDR
// InitHc ;
98388: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98392: LD_INT 0
98394: PPUSH
98395: LD_VAR 0 2
98399: PPUSH
98400: LD_VAR 0 3
98404: PPUSH
98405: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
98409: LD_VAR 0 4
98413: PPUSH
98414: LD_VAR 0 5
98418: PPUSH
98419: CALL_OW 428
98423: PUSH
98424: LD_INT 0
98426: EQUAL
98427: IFFALSE 98451
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
98429: CALL_OW 44
98433: PPUSH
98434: LD_VAR 0 4
98438: PPUSH
98439: LD_VAR 0 5
98443: PPUSH
98444: LD_INT 1
98446: PPUSH
98447: CALL_OW 48
// end ;
98451: LD_VAR 0 6
98455: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
98456: LD_INT 0
98458: PPUSH
98459: PPUSH
// uc_side := your_side ;
98460: LD_ADDR_OWVAR 20
98464: PUSH
98465: LD_OWVAR 2
98469: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
98470: LD_VAR 0 1
98474: PUSH
98475: LD_INT 1
98477: PUSH
98478: LD_INT 2
98480: PUSH
98481: LD_INT 3
98483: PUSH
98484: LD_INT 4
98486: PUSH
98487: LD_INT 5
98489: PUSH
98490: EMPTY
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: IN
98497: IFFALSE 98509
// uc_nation := nation_american else
98499: LD_ADDR_OWVAR 21
98503: PUSH
98504: LD_INT 1
98506: ST_TO_ADDR
98507: GO 98552
// if chassis in [ 11 , 12 , 13 , 14 ] then
98509: LD_VAR 0 1
98513: PUSH
98514: LD_INT 11
98516: PUSH
98517: LD_INT 12
98519: PUSH
98520: LD_INT 13
98522: PUSH
98523: LD_INT 14
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: IN
98532: IFFALSE 98544
// uc_nation := nation_arabian else
98534: LD_ADDR_OWVAR 21
98538: PUSH
98539: LD_INT 2
98541: ST_TO_ADDR
98542: GO 98552
// uc_nation := nation_russian ;
98544: LD_ADDR_OWVAR 21
98548: PUSH
98549: LD_INT 3
98551: ST_TO_ADDR
// vc_chassis := chassis ;
98552: LD_ADDR_OWVAR 37
98556: PUSH
98557: LD_VAR 0 1
98561: ST_TO_ADDR
// vc_engine := engine ;
98562: LD_ADDR_OWVAR 39
98566: PUSH
98567: LD_VAR 0 2
98571: ST_TO_ADDR
// vc_control := control ;
98572: LD_ADDR_OWVAR 38
98576: PUSH
98577: LD_VAR 0 3
98581: ST_TO_ADDR
// vc_weapon := weapon ;
98582: LD_ADDR_OWVAR 40
98586: PUSH
98587: LD_VAR 0 4
98591: ST_TO_ADDR
// un := CreateVehicle ;
98592: LD_ADDR_VAR 0 8
98596: PUSH
98597: CALL_OW 45
98601: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
98602: LD_VAR 0 8
98606: PPUSH
98607: LD_INT 0
98609: PPUSH
98610: LD_INT 5
98612: PPUSH
98613: CALL_OW 12
98617: PPUSH
98618: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
98622: LD_VAR 0 8
98626: PPUSH
98627: LD_VAR 0 5
98631: PPUSH
98632: LD_VAR 0 6
98636: PPUSH
98637: LD_INT 1
98639: PPUSH
98640: CALL_OW 48
// end ;
98644: LD_VAR 0 7
98648: RET
// export hInvincible ; every 1 do
98649: GO 98651
98651: DISABLE
// hInvincible := [ ] ;
98652: LD_ADDR_EXP 166
98656: PUSH
98657: EMPTY
98658: ST_TO_ADDR
98659: END
// every 10 do var i ;
98660: GO 98662
98662: DISABLE
98663: LD_INT 0
98665: PPUSH
// begin enable ;
98666: ENABLE
// if not hInvincible then
98667: LD_EXP 166
98671: NOT
98672: IFFALSE 98676
// exit ;
98674: GO 98720
// for i in hInvincible do
98676: LD_ADDR_VAR 0 1
98680: PUSH
98681: LD_EXP 166
98685: PUSH
98686: FOR_IN
98687: IFFALSE 98718
// if GetLives ( i ) < 1000 then
98689: LD_VAR 0 1
98693: PPUSH
98694: CALL_OW 256
98698: PUSH
98699: LD_INT 1000
98701: LESS
98702: IFFALSE 98716
// SetLives ( i , 1000 ) ;
98704: LD_VAR 0 1
98708: PPUSH
98709: LD_INT 1000
98711: PPUSH
98712: CALL_OW 234
98716: GO 98686
98718: POP
98719: POP
// end ;
98720: PPOPN 1
98722: END
// export function hHackInvincible ; var i ; begin
98723: LD_INT 0
98725: PPUSH
98726: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
98727: LD_ADDR_VAR 0 2
98731: PUSH
98732: LD_INT 2
98734: PUSH
98735: LD_INT 21
98737: PUSH
98738: LD_INT 1
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 21
98747: PUSH
98748: LD_INT 2
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: LIST
98759: PPUSH
98760: CALL_OW 69
98764: PUSH
98765: FOR_IN
98766: IFFALSE 98827
// if IsSelected ( i ) then
98768: LD_VAR 0 2
98772: PPUSH
98773: CALL_OW 306
98777: IFFALSE 98825
// begin if i in hInvincible then
98779: LD_VAR 0 2
98783: PUSH
98784: LD_EXP 166
98788: IN
98789: IFFALSE 98809
// hInvincible := hInvincible diff i else
98791: LD_ADDR_EXP 166
98795: PUSH
98796: LD_EXP 166
98800: PUSH
98801: LD_VAR 0 2
98805: DIFF
98806: ST_TO_ADDR
98807: GO 98825
// hInvincible := hInvincible union i ;
98809: LD_ADDR_EXP 166
98813: PUSH
98814: LD_EXP 166
98818: PUSH
98819: LD_VAR 0 2
98823: UNION
98824: ST_TO_ADDR
// end ;
98825: GO 98765
98827: POP
98828: POP
// end ;
98829: LD_VAR 0 1
98833: RET
// export function hHackInvisible ; var i , j ; begin
98834: LD_INT 0
98836: PPUSH
98837: PPUSH
98838: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98839: LD_ADDR_VAR 0 2
98843: PUSH
98844: LD_INT 21
98846: PUSH
98847: LD_INT 1
98849: PUSH
98850: EMPTY
98851: LIST
98852: LIST
98853: PPUSH
98854: CALL_OW 69
98858: PUSH
98859: FOR_IN
98860: IFFALSE 98884
// if IsSelected ( i ) then
98862: LD_VAR 0 2
98866: PPUSH
98867: CALL_OW 306
98871: IFFALSE 98882
// ComForceInvisible ( i ) ;
98873: LD_VAR 0 2
98877: PPUSH
98878: CALL_OW 496
98882: GO 98859
98884: POP
98885: POP
// end ;
98886: LD_VAR 0 1
98890: RET
// export function hHackChangeYourSide ; begin
98891: LD_INT 0
98893: PPUSH
// if your_side = 8 then
98894: LD_OWVAR 2
98898: PUSH
98899: LD_INT 8
98901: EQUAL
98902: IFFALSE 98914
// your_side := 0 else
98904: LD_ADDR_OWVAR 2
98908: PUSH
98909: LD_INT 0
98911: ST_TO_ADDR
98912: GO 98928
// your_side := your_side + 1 ;
98914: LD_ADDR_OWVAR 2
98918: PUSH
98919: LD_OWVAR 2
98923: PUSH
98924: LD_INT 1
98926: PLUS
98927: ST_TO_ADDR
// end ;
98928: LD_VAR 0 1
98932: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98933: LD_INT 0
98935: PPUSH
98936: PPUSH
98937: PPUSH
// for i in all_units do
98938: LD_ADDR_VAR 0 2
98942: PUSH
98943: LD_OWVAR 3
98947: PUSH
98948: FOR_IN
98949: IFFALSE 99027
// if IsSelected ( i ) then
98951: LD_VAR 0 2
98955: PPUSH
98956: CALL_OW 306
98960: IFFALSE 99025
// begin j := GetSide ( i ) ;
98962: LD_ADDR_VAR 0 3
98966: PUSH
98967: LD_VAR 0 2
98971: PPUSH
98972: CALL_OW 255
98976: ST_TO_ADDR
// if j = 8 then
98977: LD_VAR 0 3
98981: PUSH
98982: LD_INT 8
98984: EQUAL
98985: IFFALSE 98997
// j := 0 else
98987: LD_ADDR_VAR 0 3
98991: PUSH
98992: LD_INT 0
98994: ST_TO_ADDR
98995: GO 99011
// j := j + 1 ;
98997: LD_ADDR_VAR 0 3
99001: PUSH
99002: LD_VAR 0 3
99006: PUSH
99007: LD_INT 1
99009: PLUS
99010: ST_TO_ADDR
// SetSide ( i , j ) ;
99011: LD_VAR 0 2
99015: PPUSH
99016: LD_VAR 0 3
99020: PPUSH
99021: CALL_OW 235
// end ;
99025: GO 98948
99027: POP
99028: POP
// end ;
99029: LD_VAR 0 1
99033: RET
// export function hHackFog ; begin
99034: LD_INT 0
99036: PPUSH
// FogOff ( true ) ;
99037: LD_INT 1
99039: PPUSH
99040: CALL_OW 344
// end ;
99044: LD_VAR 0 1
99048: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99049: LD_INT 0
99051: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99052: LD_VAR 0 1
99056: PPUSH
99057: LD_VAR 0 2
99061: PPUSH
99062: LD_VAR 0 3
99066: PPUSH
99067: LD_INT 1
99069: PPUSH
99070: LD_INT 1
99072: PPUSH
99073: CALL_OW 483
// CenterOnXY ( x , y ) ;
99077: LD_VAR 0 2
99081: PPUSH
99082: LD_VAR 0 3
99086: PPUSH
99087: CALL_OW 84
// end ; end_of_file
99091: LD_VAR 0 4
99095: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
99096: LD_INT 0
99098: PPUSH
99099: PPUSH
99100: PPUSH
99101: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
99102: LD_VAR 0 1
99106: PPUSH
99107: CALL_OW 264
99111: PUSH
99112: LD_EXP 98
99116: EQUAL
99117: IFFALSE 99189
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
99119: LD_INT 68
99121: PPUSH
99122: LD_VAR 0 1
99126: PPUSH
99127: CALL_OW 255
99131: PPUSH
99132: CALL_OW 321
99136: PUSH
99137: LD_INT 2
99139: EQUAL
99140: IFFALSE 99152
// eff := 70 else
99142: LD_ADDR_VAR 0 4
99146: PUSH
99147: LD_INT 70
99149: ST_TO_ADDR
99150: GO 99160
// eff := 30 ;
99152: LD_ADDR_VAR 0 4
99156: PUSH
99157: LD_INT 30
99159: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
99160: LD_VAR 0 1
99164: PPUSH
99165: CALL_OW 250
99169: PPUSH
99170: LD_VAR 0 1
99174: PPUSH
99175: CALL_OW 251
99179: PPUSH
99180: LD_VAR 0 4
99184: PPUSH
99185: CALL_OW 495
// end ; end ;
99189: LD_VAR 0 2
99193: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
99194: LD_INT 0
99196: PPUSH
// end ;
99197: LD_VAR 0 4
99201: RET
// export function SOS_Command ( cmd ) ; begin
99202: LD_INT 0
99204: PPUSH
// end ;
99205: LD_VAR 0 2
99209: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
99210: LD_INT 0
99212: PPUSH
// if cmd = 121 then
99213: LD_VAR 0 1
99217: PUSH
99218: LD_INT 121
99220: EQUAL
99221: IFFALSE 99223
// end ;
99223: LD_VAR 0 6
99227: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99228: LD_INT 0
99230: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
99231: LD_VAR 0 1
99235: PUSH
99236: LD_INT 250
99238: EQUAL
99239: PUSH
99240: LD_VAR 0 2
99244: PPUSH
99245: CALL_OW 264
99249: PUSH
99250: LD_EXP 101
99254: EQUAL
99255: AND
99256: IFFALSE 99277
// MinerPlaceMine ( unit , x , y ) ;
99258: LD_VAR 0 2
99262: PPUSH
99263: LD_VAR 0 4
99267: PPUSH
99268: LD_VAR 0 5
99272: PPUSH
99273: CALL 101626 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
99277: LD_VAR 0 1
99281: PUSH
99282: LD_INT 251
99284: EQUAL
99285: PUSH
99286: LD_VAR 0 2
99290: PPUSH
99291: CALL_OW 264
99295: PUSH
99296: LD_EXP 101
99300: EQUAL
99301: AND
99302: IFFALSE 99323
// MinerDetonateMine ( unit , x , y ) ;
99304: LD_VAR 0 2
99308: PPUSH
99309: LD_VAR 0 4
99313: PPUSH
99314: LD_VAR 0 5
99318: PPUSH
99319: CALL 101903 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
99323: LD_VAR 0 1
99327: PUSH
99328: LD_INT 252
99330: EQUAL
99331: PUSH
99332: LD_VAR 0 2
99336: PPUSH
99337: CALL_OW 264
99341: PUSH
99342: LD_EXP 101
99346: EQUAL
99347: AND
99348: IFFALSE 99369
// MinerCreateMinefield ( unit , x , y ) ;
99350: LD_VAR 0 2
99354: PPUSH
99355: LD_VAR 0 4
99359: PPUSH
99360: LD_VAR 0 5
99364: PPUSH
99365: CALL 102320 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
99369: LD_VAR 0 1
99373: PUSH
99374: LD_INT 253
99376: EQUAL
99377: PUSH
99378: LD_VAR 0 2
99382: PPUSH
99383: CALL_OW 257
99387: PUSH
99388: LD_INT 5
99390: EQUAL
99391: AND
99392: IFFALSE 99413
// ComBinocular ( unit , x , y ) ;
99394: LD_VAR 0 2
99398: PPUSH
99399: LD_VAR 0 4
99403: PPUSH
99404: LD_VAR 0 5
99408: PPUSH
99409: CALL 102691 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99413: LD_VAR 0 1
99417: PUSH
99418: LD_INT 254
99420: EQUAL
99421: PUSH
99422: LD_VAR 0 2
99426: PPUSH
99427: CALL_OW 264
99431: PUSH
99432: LD_EXP 96
99436: EQUAL
99437: AND
99438: PUSH
99439: LD_VAR 0 3
99443: PPUSH
99444: CALL_OW 263
99448: PUSH
99449: LD_INT 3
99451: EQUAL
99452: AND
99453: IFFALSE 99469
// HackDestroyVehicle ( unit , selectedUnit ) ;
99455: LD_VAR 0 2
99459: PPUSH
99460: LD_VAR 0 3
99464: PPUSH
99465: CALL 100986 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99469: LD_VAR 0 1
99473: PUSH
99474: LD_INT 255
99476: EQUAL
99477: PUSH
99478: LD_VAR 0 2
99482: PPUSH
99483: CALL_OW 264
99487: PUSH
99488: LD_INT 14
99490: PUSH
99491: LD_INT 53
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: IN
99498: AND
99499: PUSH
99500: LD_VAR 0 4
99504: PPUSH
99505: LD_VAR 0 5
99509: PPUSH
99510: CALL_OW 488
99514: AND
99515: IFFALSE 99539
// CutTreeXYR ( unit , x , y , 12 ) ;
99517: LD_VAR 0 2
99521: PPUSH
99522: LD_VAR 0 4
99526: PPUSH
99527: LD_VAR 0 5
99531: PPUSH
99532: LD_INT 12
99534: PPUSH
99535: CALL 99552 0 4
// end ;
99539: LD_VAR 0 6
99543: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
99544: LD_INT 0
99546: PPUSH
// end ;
99547: LD_VAR 0 4
99551: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99552: LD_INT 0
99554: PPUSH
99555: PPUSH
99556: PPUSH
99557: PPUSH
99558: PPUSH
99559: PPUSH
99560: PPUSH
99561: PPUSH
99562: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99563: LD_VAR 0 1
99567: NOT
99568: PUSH
99569: LD_VAR 0 2
99573: PPUSH
99574: LD_VAR 0 3
99578: PPUSH
99579: CALL_OW 488
99583: NOT
99584: OR
99585: PUSH
99586: LD_VAR 0 4
99590: NOT
99591: OR
99592: IFFALSE 99596
// exit ;
99594: GO 99936
// list := [ ] ;
99596: LD_ADDR_VAR 0 13
99600: PUSH
99601: EMPTY
99602: ST_TO_ADDR
// if x - r < 0 then
99603: LD_VAR 0 2
99607: PUSH
99608: LD_VAR 0 4
99612: MINUS
99613: PUSH
99614: LD_INT 0
99616: LESS
99617: IFFALSE 99629
// min_x := 0 else
99619: LD_ADDR_VAR 0 7
99623: PUSH
99624: LD_INT 0
99626: ST_TO_ADDR
99627: GO 99645
// min_x := x - r ;
99629: LD_ADDR_VAR 0 7
99633: PUSH
99634: LD_VAR 0 2
99638: PUSH
99639: LD_VAR 0 4
99643: MINUS
99644: ST_TO_ADDR
// if y - r < 0 then
99645: LD_VAR 0 3
99649: PUSH
99650: LD_VAR 0 4
99654: MINUS
99655: PUSH
99656: LD_INT 0
99658: LESS
99659: IFFALSE 99671
// min_y := 0 else
99661: LD_ADDR_VAR 0 8
99665: PUSH
99666: LD_INT 0
99668: ST_TO_ADDR
99669: GO 99687
// min_y := y - r ;
99671: LD_ADDR_VAR 0 8
99675: PUSH
99676: LD_VAR 0 3
99680: PUSH
99681: LD_VAR 0 4
99685: MINUS
99686: ST_TO_ADDR
// max_x := x + r ;
99687: LD_ADDR_VAR 0 9
99691: PUSH
99692: LD_VAR 0 2
99696: PUSH
99697: LD_VAR 0 4
99701: PLUS
99702: ST_TO_ADDR
// max_y := y + r ;
99703: LD_ADDR_VAR 0 10
99707: PUSH
99708: LD_VAR 0 3
99712: PUSH
99713: LD_VAR 0 4
99717: PLUS
99718: ST_TO_ADDR
// for _x = min_x to max_x do
99719: LD_ADDR_VAR 0 11
99723: PUSH
99724: DOUBLE
99725: LD_VAR 0 7
99729: DEC
99730: ST_TO_ADDR
99731: LD_VAR 0 9
99735: PUSH
99736: FOR_TO
99737: IFFALSE 99854
// for _y = min_y to max_y do
99739: LD_ADDR_VAR 0 12
99743: PUSH
99744: DOUBLE
99745: LD_VAR 0 8
99749: DEC
99750: ST_TO_ADDR
99751: LD_VAR 0 10
99755: PUSH
99756: FOR_TO
99757: IFFALSE 99850
// begin if not ValidHex ( _x , _y ) then
99759: LD_VAR 0 11
99763: PPUSH
99764: LD_VAR 0 12
99768: PPUSH
99769: CALL_OW 488
99773: NOT
99774: IFFALSE 99778
// continue ;
99776: GO 99756
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
99778: LD_VAR 0 11
99782: PPUSH
99783: LD_VAR 0 12
99787: PPUSH
99788: CALL_OW 351
99792: PUSH
99793: LD_VAR 0 11
99797: PPUSH
99798: LD_VAR 0 12
99802: PPUSH
99803: CALL_OW 554
99807: AND
99808: IFFALSE 99848
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
99810: LD_ADDR_VAR 0 13
99814: PUSH
99815: LD_VAR 0 13
99819: PPUSH
99820: LD_VAR 0 13
99824: PUSH
99825: LD_INT 1
99827: PLUS
99828: PPUSH
99829: LD_VAR 0 11
99833: PUSH
99834: LD_VAR 0 12
99838: PUSH
99839: EMPTY
99840: LIST
99841: LIST
99842: PPUSH
99843: CALL_OW 2
99847: ST_TO_ADDR
// end ;
99848: GO 99756
99850: POP
99851: POP
99852: GO 99736
99854: POP
99855: POP
// if not list then
99856: LD_VAR 0 13
99860: NOT
99861: IFFALSE 99865
// exit ;
99863: GO 99936
// for i in list do
99865: LD_ADDR_VAR 0 6
99869: PUSH
99870: LD_VAR 0 13
99874: PUSH
99875: FOR_IN
99876: IFFALSE 99934
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99878: LD_VAR 0 1
99882: PPUSH
99883: LD_STRING M
99885: PUSH
99886: LD_VAR 0 6
99890: PUSH
99891: LD_INT 1
99893: ARRAY
99894: PUSH
99895: LD_VAR 0 6
99899: PUSH
99900: LD_INT 2
99902: ARRAY
99903: PUSH
99904: LD_INT 0
99906: PUSH
99907: LD_INT 0
99909: PUSH
99910: LD_INT 0
99912: PUSH
99913: LD_INT 0
99915: PUSH
99916: EMPTY
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: PUSH
99925: EMPTY
99926: LIST
99927: PPUSH
99928: CALL_OW 447
99932: GO 99875
99934: POP
99935: POP
// end ;
99936: LD_VAR 0 5
99940: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99941: LD_EXP 169
99945: NOT
99946: IFFALSE 99996
99948: GO 99950
99950: DISABLE
// begin initHack := true ;
99951: LD_ADDR_EXP 169
99955: PUSH
99956: LD_INT 1
99958: ST_TO_ADDR
// hackTanks := [ ] ;
99959: LD_ADDR_EXP 170
99963: PUSH
99964: EMPTY
99965: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99966: LD_ADDR_EXP 171
99970: PUSH
99971: EMPTY
99972: ST_TO_ADDR
// hackLimit := 3 ;
99973: LD_ADDR_EXP 172
99977: PUSH
99978: LD_INT 3
99980: ST_TO_ADDR
// hackDist := 12 ;
99981: LD_ADDR_EXP 173
99985: PUSH
99986: LD_INT 12
99988: ST_TO_ADDR
// hackCounter := [ ] ;
99989: LD_ADDR_EXP 174
99993: PUSH
99994: EMPTY
99995: ST_TO_ADDR
// end ;
99996: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99997: LD_EXP 169
100001: PUSH
100002: LD_INT 34
100004: PUSH
100005: LD_EXP 96
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: PPUSH
100014: CALL_OW 69
100018: AND
100019: IFFALSE 100274
100021: GO 100023
100023: DISABLE
100024: LD_INT 0
100026: PPUSH
100027: PPUSH
// begin enable ;
100028: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100029: LD_ADDR_VAR 0 1
100033: PUSH
100034: LD_INT 34
100036: PUSH
100037: LD_EXP 96
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PPUSH
100046: CALL_OW 69
100050: PUSH
100051: FOR_IN
100052: IFFALSE 100272
// begin if not i in hackTanks then
100054: LD_VAR 0 1
100058: PUSH
100059: LD_EXP 170
100063: IN
100064: NOT
100065: IFFALSE 100148
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100067: LD_ADDR_EXP 170
100071: PUSH
100072: LD_EXP 170
100076: PPUSH
100077: LD_EXP 170
100081: PUSH
100082: LD_INT 1
100084: PLUS
100085: PPUSH
100086: LD_VAR 0 1
100090: PPUSH
100091: CALL_OW 1
100095: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100096: LD_ADDR_EXP 171
100100: PUSH
100101: LD_EXP 171
100105: PPUSH
100106: LD_EXP 171
100110: PUSH
100111: LD_INT 1
100113: PLUS
100114: PPUSH
100115: EMPTY
100116: PPUSH
100117: CALL_OW 1
100121: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
100122: LD_ADDR_EXP 174
100126: PUSH
100127: LD_EXP 174
100131: PPUSH
100132: LD_EXP 174
100136: PUSH
100137: LD_INT 1
100139: PLUS
100140: PPUSH
100141: EMPTY
100142: PPUSH
100143: CALL_OW 1
100147: ST_TO_ADDR
// end ; if not IsOk ( i ) then
100148: LD_VAR 0 1
100152: PPUSH
100153: CALL_OW 302
100157: NOT
100158: IFFALSE 100171
// begin HackUnlinkAll ( i ) ;
100160: LD_VAR 0 1
100164: PPUSH
100165: CALL 100277 0 1
// continue ;
100169: GO 100051
// end ; HackCheckCapturedStatus ( i ) ;
100171: LD_VAR 0 1
100175: PPUSH
100176: CALL 100720 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100180: LD_ADDR_VAR 0 2
100184: PUSH
100185: LD_INT 81
100187: PUSH
100188: LD_VAR 0 1
100192: PPUSH
100193: CALL_OW 255
100197: PUSH
100198: EMPTY
100199: LIST
100200: LIST
100201: PUSH
100202: LD_INT 33
100204: PUSH
100205: LD_INT 3
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PUSH
100212: LD_INT 91
100214: PUSH
100215: LD_VAR 0 1
100219: PUSH
100220: LD_EXP 173
100224: PUSH
100225: EMPTY
100226: LIST
100227: LIST
100228: LIST
100229: PUSH
100230: LD_INT 50
100232: PUSH
100233: EMPTY
100234: LIST
100235: PUSH
100236: EMPTY
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: PPUSH
100242: CALL_OW 69
100246: ST_TO_ADDR
// if not tmp then
100247: LD_VAR 0 2
100251: NOT
100252: IFFALSE 100256
// continue ;
100254: GO 100051
// HackLink ( i , tmp ) ;
100256: LD_VAR 0 1
100260: PPUSH
100261: LD_VAR 0 2
100265: PPUSH
100266: CALL 100413 0 2
// end ;
100270: GO 100051
100272: POP
100273: POP
// end ;
100274: PPOPN 2
100276: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100277: LD_INT 0
100279: PPUSH
100280: PPUSH
100281: PPUSH
// if not hack in hackTanks then
100282: LD_VAR 0 1
100286: PUSH
100287: LD_EXP 170
100291: IN
100292: NOT
100293: IFFALSE 100297
// exit ;
100295: GO 100408
// index := GetElementIndex ( hackTanks , hack ) ;
100297: LD_ADDR_VAR 0 4
100301: PUSH
100302: LD_EXP 170
100306: PPUSH
100307: LD_VAR 0 1
100311: PPUSH
100312: CALL 52839 0 2
100316: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100317: LD_EXP 171
100321: PUSH
100322: LD_VAR 0 4
100326: ARRAY
100327: IFFALSE 100408
// begin for i in hackTanksCaptured [ index ] do
100329: LD_ADDR_VAR 0 3
100333: PUSH
100334: LD_EXP 171
100338: PUSH
100339: LD_VAR 0 4
100343: ARRAY
100344: PUSH
100345: FOR_IN
100346: IFFALSE 100372
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100348: LD_VAR 0 3
100352: PUSH
100353: LD_INT 1
100355: ARRAY
100356: PPUSH
100357: LD_VAR 0 3
100361: PUSH
100362: LD_INT 2
100364: ARRAY
100365: PPUSH
100366: CALL_OW 235
100370: GO 100345
100372: POP
100373: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100374: LD_ADDR_EXP 171
100378: PUSH
100379: LD_EXP 171
100383: PPUSH
100384: LD_VAR 0 4
100388: PPUSH
100389: EMPTY
100390: PPUSH
100391: CALL_OW 1
100395: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100396: LD_VAR 0 1
100400: PPUSH
100401: LD_INT 0
100403: PPUSH
100404: CALL_OW 505
// end ; end ;
100408: LD_VAR 0 2
100412: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100413: LD_INT 0
100415: PPUSH
100416: PPUSH
100417: PPUSH
// if not hack in hackTanks or not vehicles then
100418: LD_VAR 0 1
100422: PUSH
100423: LD_EXP 170
100427: IN
100428: NOT
100429: PUSH
100430: LD_VAR 0 2
100434: NOT
100435: OR
100436: IFFALSE 100440
// exit ;
100438: GO 100715
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100440: LD_ADDR_VAR 0 2
100444: PUSH
100445: LD_VAR 0 1
100449: PPUSH
100450: LD_VAR 0 2
100454: PPUSH
100455: LD_INT 1
100457: PPUSH
100458: LD_INT 1
100460: PPUSH
100461: CALL 53489 0 4
100465: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100466: LD_ADDR_VAR 0 5
100470: PUSH
100471: LD_EXP 170
100475: PPUSH
100476: LD_VAR 0 1
100480: PPUSH
100481: CALL 52839 0 2
100485: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100486: LD_EXP 171
100490: PUSH
100491: LD_VAR 0 5
100495: ARRAY
100496: PUSH
100497: LD_EXP 172
100501: LESS
100502: IFFALSE 100691
// begin for i := 1 to vehicles do
100504: LD_ADDR_VAR 0 4
100508: PUSH
100509: DOUBLE
100510: LD_INT 1
100512: DEC
100513: ST_TO_ADDR
100514: LD_VAR 0 2
100518: PUSH
100519: FOR_TO
100520: IFFALSE 100689
// begin if hackTanksCaptured [ index ] = hackLimit then
100522: LD_EXP 171
100526: PUSH
100527: LD_VAR 0 5
100531: ARRAY
100532: PUSH
100533: LD_EXP 172
100537: EQUAL
100538: IFFALSE 100542
// break ;
100540: GO 100689
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100542: LD_ADDR_EXP 174
100546: PUSH
100547: LD_EXP 174
100551: PPUSH
100552: LD_VAR 0 5
100556: PPUSH
100557: LD_EXP 174
100561: PUSH
100562: LD_VAR 0 5
100566: ARRAY
100567: PUSH
100568: LD_INT 1
100570: PLUS
100571: PPUSH
100572: CALL_OW 1
100576: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100577: LD_ADDR_EXP 171
100581: PUSH
100582: LD_EXP 171
100586: PPUSH
100587: LD_VAR 0 5
100591: PUSH
100592: LD_EXP 171
100596: PUSH
100597: LD_VAR 0 5
100601: ARRAY
100602: PUSH
100603: LD_INT 1
100605: PLUS
100606: PUSH
100607: EMPTY
100608: LIST
100609: LIST
100610: PPUSH
100611: LD_VAR 0 2
100615: PUSH
100616: LD_VAR 0 4
100620: ARRAY
100621: PUSH
100622: LD_VAR 0 2
100626: PUSH
100627: LD_VAR 0 4
100631: ARRAY
100632: PPUSH
100633: CALL_OW 255
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PPUSH
100642: CALL 53054 0 3
100646: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
100647: LD_VAR 0 2
100651: PUSH
100652: LD_VAR 0 4
100656: ARRAY
100657: PPUSH
100658: LD_VAR 0 1
100662: PPUSH
100663: CALL_OW 255
100667: PPUSH
100668: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
100672: LD_VAR 0 2
100676: PUSH
100677: LD_VAR 0 4
100681: ARRAY
100682: PPUSH
100683: CALL_OW 141
// end ;
100687: GO 100519
100689: POP
100690: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100691: LD_VAR 0 1
100695: PPUSH
100696: LD_EXP 171
100700: PUSH
100701: LD_VAR 0 5
100705: ARRAY
100706: PUSH
100707: LD_INT 0
100709: PLUS
100710: PPUSH
100711: CALL_OW 505
// end ;
100715: LD_VAR 0 3
100719: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
100720: LD_INT 0
100722: PPUSH
100723: PPUSH
100724: PPUSH
100725: PPUSH
// if not hack in hackTanks then
100726: LD_VAR 0 1
100730: PUSH
100731: LD_EXP 170
100735: IN
100736: NOT
100737: IFFALSE 100741
// exit ;
100739: GO 100981
// index := GetElementIndex ( hackTanks , hack ) ;
100741: LD_ADDR_VAR 0 4
100745: PUSH
100746: LD_EXP 170
100750: PPUSH
100751: LD_VAR 0 1
100755: PPUSH
100756: CALL 52839 0 2
100760: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
100761: LD_ADDR_VAR 0 3
100765: PUSH
100766: DOUBLE
100767: LD_EXP 171
100771: PUSH
100772: LD_VAR 0 4
100776: ARRAY
100777: INC
100778: ST_TO_ADDR
100779: LD_INT 1
100781: PUSH
100782: FOR_DOWNTO
100783: IFFALSE 100955
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
100785: LD_ADDR_VAR 0 5
100789: PUSH
100790: LD_EXP 171
100794: PUSH
100795: LD_VAR 0 4
100799: ARRAY
100800: PUSH
100801: LD_VAR 0 3
100805: ARRAY
100806: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
100807: LD_VAR 0 5
100811: PUSH
100812: LD_INT 1
100814: ARRAY
100815: PPUSH
100816: CALL_OW 302
100820: NOT
100821: PUSH
100822: LD_VAR 0 5
100826: PUSH
100827: LD_INT 1
100829: ARRAY
100830: PPUSH
100831: CALL_OW 255
100835: PUSH
100836: LD_VAR 0 1
100840: PPUSH
100841: CALL_OW 255
100845: NONEQUAL
100846: OR
100847: IFFALSE 100953
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
100849: LD_VAR 0 5
100853: PUSH
100854: LD_INT 1
100856: ARRAY
100857: PPUSH
100858: CALL_OW 305
100862: PUSH
100863: LD_VAR 0 5
100867: PUSH
100868: LD_INT 1
100870: ARRAY
100871: PPUSH
100872: CALL_OW 255
100876: PUSH
100877: LD_VAR 0 1
100881: PPUSH
100882: CALL_OW 255
100886: EQUAL
100887: AND
100888: IFFALSE 100912
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100890: LD_VAR 0 5
100894: PUSH
100895: LD_INT 1
100897: ARRAY
100898: PPUSH
100899: LD_VAR 0 5
100903: PUSH
100904: LD_INT 2
100906: ARRAY
100907: PPUSH
100908: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100912: LD_ADDR_EXP 171
100916: PUSH
100917: LD_EXP 171
100921: PPUSH
100922: LD_VAR 0 4
100926: PPUSH
100927: LD_EXP 171
100931: PUSH
100932: LD_VAR 0 4
100936: ARRAY
100937: PPUSH
100938: LD_VAR 0 3
100942: PPUSH
100943: CALL_OW 3
100947: PPUSH
100948: CALL_OW 1
100952: ST_TO_ADDR
// end ; end ;
100953: GO 100782
100955: POP
100956: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100957: LD_VAR 0 1
100961: PPUSH
100962: LD_EXP 171
100966: PUSH
100967: LD_VAR 0 4
100971: ARRAY
100972: PUSH
100973: LD_INT 0
100975: PLUS
100976: PPUSH
100977: CALL_OW 505
// end ;
100981: LD_VAR 0 2
100985: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100986: LD_INT 0
100988: PPUSH
100989: PPUSH
100990: PPUSH
100991: PPUSH
// if not hack in hackTanks then
100992: LD_VAR 0 1
100996: PUSH
100997: LD_EXP 170
101001: IN
101002: NOT
101003: IFFALSE 101007
// exit ;
101005: GO 101092
// index := GetElementIndex ( hackTanks , hack ) ;
101007: LD_ADDR_VAR 0 5
101011: PUSH
101012: LD_EXP 170
101016: PPUSH
101017: LD_VAR 0 1
101021: PPUSH
101022: CALL 52839 0 2
101026: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101027: LD_ADDR_VAR 0 4
101031: PUSH
101032: DOUBLE
101033: LD_INT 1
101035: DEC
101036: ST_TO_ADDR
101037: LD_EXP 171
101041: PUSH
101042: LD_VAR 0 5
101046: ARRAY
101047: PUSH
101048: FOR_TO
101049: IFFALSE 101090
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101051: LD_EXP 171
101055: PUSH
101056: LD_VAR 0 5
101060: ARRAY
101061: PUSH
101062: LD_VAR 0 4
101066: ARRAY
101067: PUSH
101068: LD_INT 1
101070: ARRAY
101071: PUSH
101072: LD_VAR 0 2
101076: EQUAL
101077: IFFALSE 101088
// KillUnit ( vehicle ) ;
101079: LD_VAR 0 2
101083: PPUSH
101084: CALL_OW 66
101088: GO 101048
101090: POP
101091: POP
// end ;
101092: LD_VAR 0 3
101096: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
101097: LD_EXP 175
101101: NOT
101102: IFFALSE 101137
101104: GO 101106
101106: DISABLE
// begin initMiner := true ;
101107: LD_ADDR_EXP 175
101111: PUSH
101112: LD_INT 1
101114: ST_TO_ADDR
// minersList := [ ] ;
101115: LD_ADDR_EXP 176
101119: PUSH
101120: EMPTY
101121: ST_TO_ADDR
// minerMinesList := [ ] ;
101122: LD_ADDR_EXP 177
101126: PUSH
101127: EMPTY
101128: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
101129: LD_ADDR_EXP 178
101133: PUSH
101134: LD_INT 5
101136: ST_TO_ADDR
// end ;
101137: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
101138: LD_EXP 175
101142: PUSH
101143: LD_INT 34
101145: PUSH
101146: LD_EXP 101
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PPUSH
101155: CALL_OW 69
101159: AND
101160: IFFALSE 101623
101162: GO 101164
101164: DISABLE
101165: LD_INT 0
101167: PPUSH
101168: PPUSH
101169: PPUSH
101170: PPUSH
// begin enable ;
101171: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
101172: LD_ADDR_VAR 0 1
101176: PUSH
101177: LD_INT 34
101179: PUSH
101180: LD_EXP 101
101184: PUSH
101185: EMPTY
101186: LIST
101187: LIST
101188: PPUSH
101189: CALL_OW 69
101193: PUSH
101194: FOR_IN
101195: IFFALSE 101267
// begin if not i in minersList then
101197: LD_VAR 0 1
101201: PUSH
101202: LD_EXP 176
101206: IN
101207: NOT
101208: IFFALSE 101265
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
101210: LD_ADDR_EXP 176
101214: PUSH
101215: LD_EXP 176
101219: PPUSH
101220: LD_EXP 176
101224: PUSH
101225: LD_INT 1
101227: PLUS
101228: PPUSH
101229: LD_VAR 0 1
101233: PPUSH
101234: CALL_OW 1
101238: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
101239: LD_ADDR_EXP 177
101243: PUSH
101244: LD_EXP 177
101248: PPUSH
101249: LD_EXP 177
101253: PUSH
101254: LD_INT 1
101256: PLUS
101257: PPUSH
101258: EMPTY
101259: PPUSH
101260: CALL_OW 1
101264: ST_TO_ADDR
// end end ;
101265: GO 101194
101267: POP
101268: POP
// for i := minerMinesList downto 1 do
101269: LD_ADDR_VAR 0 1
101273: PUSH
101274: DOUBLE
101275: LD_EXP 177
101279: INC
101280: ST_TO_ADDR
101281: LD_INT 1
101283: PUSH
101284: FOR_DOWNTO
101285: IFFALSE 101621
// begin if IsLive ( minersList [ i ] ) then
101287: LD_EXP 176
101291: PUSH
101292: LD_VAR 0 1
101296: ARRAY
101297: PPUSH
101298: CALL_OW 300
101302: IFFALSE 101330
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
101304: LD_EXP 176
101308: PUSH
101309: LD_VAR 0 1
101313: ARRAY
101314: PPUSH
101315: LD_EXP 177
101319: PUSH
101320: LD_VAR 0 1
101324: ARRAY
101325: PPUSH
101326: CALL_OW 505
// if not minerMinesList [ i ] then
101330: LD_EXP 177
101334: PUSH
101335: LD_VAR 0 1
101339: ARRAY
101340: NOT
101341: IFFALSE 101345
// continue ;
101343: GO 101284
// for j := minerMinesList [ i ] downto 1 do
101345: LD_ADDR_VAR 0 2
101349: PUSH
101350: DOUBLE
101351: LD_EXP 177
101355: PUSH
101356: LD_VAR 0 1
101360: ARRAY
101361: INC
101362: ST_TO_ADDR
101363: LD_INT 1
101365: PUSH
101366: FOR_DOWNTO
101367: IFFALSE 101617
// begin side := GetSide ( minersList [ i ] ) ;
101369: LD_ADDR_VAR 0 3
101373: PUSH
101374: LD_EXP 176
101378: PUSH
101379: LD_VAR 0 1
101383: ARRAY
101384: PPUSH
101385: CALL_OW 255
101389: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
101390: LD_ADDR_VAR 0 4
101394: PUSH
101395: LD_EXP 177
101399: PUSH
101400: LD_VAR 0 1
101404: ARRAY
101405: PUSH
101406: LD_VAR 0 2
101410: ARRAY
101411: PUSH
101412: LD_INT 1
101414: ARRAY
101415: PPUSH
101416: LD_EXP 177
101420: PUSH
101421: LD_VAR 0 1
101425: ARRAY
101426: PUSH
101427: LD_VAR 0 2
101431: ARRAY
101432: PUSH
101433: LD_INT 2
101435: ARRAY
101436: PPUSH
101437: CALL_OW 428
101441: ST_TO_ADDR
// if not tmp then
101442: LD_VAR 0 4
101446: NOT
101447: IFFALSE 101451
// continue ;
101449: GO 101366
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
101451: LD_VAR 0 4
101455: PUSH
101456: LD_INT 81
101458: PUSH
101459: LD_VAR 0 3
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PPUSH
101468: CALL_OW 69
101472: IN
101473: PUSH
101474: LD_EXP 177
101478: PUSH
101479: LD_VAR 0 1
101483: ARRAY
101484: PUSH
101485: LD_VAR 0 2
101489: ARRAY
101490: PUSH
101491: LD_INT 1
101493: ARRAY
101494: PPUSH
101495: LD_EXP 177
101499: PUSH
101500: LD_VAR 0 1
101504: ARRAY
101505: PUSH
101506: LD_VAR 0 2
101510: ARRAY
101511: PUSH
101512: LD_INT 2
101514: ARRAY
101515: PPUSH
101516: CALL_OW 458
101520: AND
101521: IFFALSE 101615
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
101523: LD_EXP 177
101527: PUSH
101528: LD_VAR 0 1
101532: ARRAY
101533: PUSH
101534: LD_VAR 0 2
101538: ARRAY
101539: PUSH
101540: LD_INT 1
101542: ARRAY
101543: PPUSH
101544: LD_EXP 177
101548: PUSH
101549: LD_VAR 0 1
101553: ARRAY
101554: PUSH
101555: LD_VAR 0 2
101559: ARRAY
101560: PUSH
101561: LD_INT 2
101563: ARRAY
101564: PPUSH
101565: LD_VAR 0 3
101569: PPUSH
101570: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
101574: LD_ADDR_EXP 177
101578: PUSH
101579: LD_EXP 177
101583: PPUSH
101584: LD_VAR 0 1
101588: PPUSH
101589: LD_EXP 177
101593: PUSH
101594: LD_VAR 0 1
101598: ARRAY
101599: PPUSH
101600: LD_VAR 0 2
101604: PPUSH
101605: CALL_OW 3
101609: PPUSH
101610: CALL_OW 1
101614: ST_TO_ADDR
// end ; end ;
101615: GO 101366
101617: POP
101618: POP
// end ;
101619: GO 101284
101621: POP
101622: POP
// end ;
101623: PPOPN 4
101625: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
101626: LD_INT 0
101628: PPUSH
101629: PPUSH
// result := false ;
101630: LD_ADDR_VAR 0 4
101634: PUSH
101635: LD_INT 0
101637: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
101638: LD_VAR 0 1
101642: PPUSH
101643: CALL_OW 264
101647: PUSH
101648: LD_EXP 101
101652: EQUAL
101653: NOT
101654: IFFALSE 101658
// exit ;
101656: GO 101898
// index := GetElementIndex ( minersList , unit ) ;
101658: LD_ADDR_VAR 0 5
101662: PUSH
101663: LD_EXP 176
101667: PPUSH
101668: LD_VAR 0 1
101672: PPUSH
101673: CALL 52839 0 2
101677: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
101678: LD_EXP 177
101682: PUSH
101683: LD_VAR 0 5
101687: ARRAY
101688: PUSH
101689: LD_EXP 178
101693: GREATEREQUAL
101694: IFFALSE 101698
// exit ;
101696: GO 101898
// ComMoveXY ( unit , x , y ) ;
101698: LD_VAR 0 1
101702: PPUSH
101703: LD_VAR 0 2
101707: PPUSH
101708: LD_VAR 0 3
101712: PPUSH
101713: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101717: LD_INT 35
101719: PPUSH
101720: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
101724: LD_VAR 0 1
101728: PPUSH
101729: LD_VAR 0 2
101733: PPUSH
101734: LD_VAR 0 3
101738: PPUSH
101739: CALL 83236 0 3
101743: NOT
101744: PUSH
101745: LD_VAR 0 1
101749: PPUSH
101750: CALL_OW 314
101754: AND
101755: IFFALSE 101759
// exit ;
101757: GO 101898
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
101759: LD_VAR 0 2
101763: PPUSH
101764: LD_VAR 0 3
101768: PPUSH
101769: CALL_OW 428
101773: PUSH
101774: LD_VAR 0 1
101778: EQUAL
101779: PUSH
101780: LD_VAR 0 1
101784: PPUSH
101785: CALL_OW 314
101789: NOT
101790: AND
101791: IFFALSE 101717
// PlaySoundXY ( x , y , PlantMine ) ;
101793: LD_VAR 0 2
101797: PPUSH
101798: LD_VAR 0 3
101802: PPUSH
101803: LD_STRING PlantMine
101805: PPUSH
101806: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
101810: LD_VAR 0 2
101814: PPUSH
101815: LD_VAR 0 3
101819: PPUSH
101820: LD_VAR 0 1
101824: PPUSH
101825: CALL_OW 255
101829: PPUSH
101830: LD_INT 0
101832: PPUSH
101833: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
101837: LD_ADDR_EXP 177
101841: PUSH
101842: LD_EXP 177
101846: PPUSH
101847: LD_VAR 0 5
101851: PUSH
101852: LD_EXP 177
101856: PUSH
101857: LD_VAR 0 5
101861: ARRAY
101862: PUSH
101863: LD_INT 1
101865: PLUS
101866: PUSH
101867: EMPTY
101868: LIST
101869: LIST
101870: PPUSH
101871: LD_VAR 0 2
101875: PUSH
101876: LD_VAR 0 3
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: PPUSH
101885: CALL 53054 0 3
101889: ST_TO_ADDR
// result := true ;
101890: LD_ADDR_VAR 0 4
101894: PUSH
101895: LD_INT 1
101897: ST_TO_ADDR
// end ;
101898: LD_VAR 0 4
101902: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101903: LD_INT 0
101905: PPUSH
101906: PPUSH
101907: PPUSH
// if not unit in minersList then
101908: LD_VAR 0 1
101912: PUSH
101913: LD_EXP 176
101917: IN
101918: NOT
101919: IFFALSE 101923
// exit ;
101921: GO 102315
// index := GetElementIndex ( minersList , unit ) ;
101923: LD_ADDR_VAR 0 6
101927: PUSH
101928: LD_EXP 176
101932: PPUSH
101933: LD_VAR 0 1
101937: PPUSH
101938: CALL 52839 0 2
101942: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101943: LD_ADDR_VAR 0 5
101947: PUSH
101948: DOUBLE
101949: LD_EXP 177
101953: PUSH
101954: LD_VAR 0 6
101958: ARRAY
101959: INC
101960: ST_TO_ADDR
101961: LD_INT 1
101963: PUSH
101964: FOR_DOWNTO
101965: IFFALSE 102126
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101967: LD_EXP 177
101971: PUSH
101972: LD_VAR 0 6
101976: ARRAY
101977: PUSH
101978: LD_VAR 0 5
101982: ARRAY
101983: PUSH
101984: LD_INT 1
101986: ARRAY
101987: PUSH
101988: LD_VAR 0 2
101992: EQUAL
101993: PUSH
101994: LD_EXP 177
101998: PUSH
101999: LD_VAR 0 6
102003: ARRAY
102004: PUSH
102005: LD_VAR 0 5
102009: ARRAY
102010: PUSH
102011: LD_INT 2
102013: ARRAY
102014: PUSH
102015: LD_VAR 0 3
102019: EQUAL
102020: AND
102021: IFFALSE 102124
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102023: LD_EXP 177
102027: PUSH
102028: LD_VAR 0 6
102032: ARRAY
102033: PUSH
102034: LD_VAR 0 5
102038: ARRAY
102039: PUSH
102040: LD_INT 1
102042: ARRAY
102043: PPUSH
102044: LD_EXP 177
102048: PUSH
102049: LD_VAR 0 6
102053: ARRAY
102054: PUSH
102055: LD_VAR 0 5
102059: ARRAY
102060: PUSH
102061: LD_INT 2
102063: ARRAY
102064: PPUSH
102065: LD_VAR 0 1
102069: PPUSH
102070: CALL_OW 255
102074: PPUSH
102075: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102079: LD_ADDR_EXP 177
102083: PUSH
102084: LD_EXP 177
102088: PPUSH
102089: LD_VAR 0 6
102093: PPUSH
102094: LD_EXP 177
102098: PUSH
102099: LD_VAR 0 6
102103: ARRAY
102104: PPUSH
102105: LD_VAR 0 5
102109: PPUSH
102110: CALL_OW 3
102114: PPUSH
102115: CALL_OW 1
102119: ST_TO_ADDR
// exit ;
102120: POP
102121: POP
102122: GO 102315
// end ; end ;
102124: GO 101964
102126: POP
102127: POP
// for i := minerMinesList [ index ] downto 1 do
102128: LD_ADDR_VAR 0 5
102132: PUSH
102133: DOUBLE
102134: LD_EXP 177
102138: PUSH
102139: LD_VAR 0 6
102143: ARRAY
102144: INC
102145: ST_TO_ADDR
102146: LD_INT 1
102148: PUSH
102149: FOR_DOWNTO
102150: IFFALSE 102313
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
102152: LD_EXP 177
102156: PUSH
102157: LD_VAR 0 6
102161: ARRAY
102162: PUSH
102163: LD_VAR 0 5
102167: ARRAY
102168: PUSH
102169: LD_INT 1
102171: ARRAY
102172: PPUSH
102173: LD_EXP 177
102177: PUSH
102178: LD_VAR 0 6
102182: ARRAY
102183: PUSH
102184: LD_VAR 0 5
102188: ARRAY
102189: PUSH
102190: LD_INT 2
102192: ARRAY
102193: PPUSH
102194: LD_VAR 0 2
102198: PPUSH
102199: LD_VAR 0 3
102203: PPUSH
102204: CALL_OW 298
102208: PUSH
102209: LD_INT 6
102211: LESS
102212: IFFALSE 102311
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102214: LD_EXP 177
102218: PUSH
102219: LD_VAR 0 6
102223: ARRAY
102224: PUSH
102225: LD_VAR 0 5
102229: ARRAY
102230: PUSH
102231: LD_INT 1
102233: ARRAY
102234: PPUSH
102235: LD_EXP 177
102239: PUSH
102240: LD_VAR 0 6
102244: ARRAY
102245: PUSH
102246: LD_VAR 0 5
102250: ARRAY
102251: PUSH
102252: LD_INT 2
102254: ARRAY
102255: PPUSH
102256: LD_VAR 0 1
102260: PPUSH
102261: CALL_OW 255
102265: PPUSH
102266: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102270: LD_ADDR_EXP 177
102274: PUSH
102275: LD_EXP 177
102279: PPUSH
102280: LD_VAR 0 6
102284: PPUSH
102285: LD_EXP 177
102289: PUSH
102290: LD_VAR 0 6
102294: ARRAY
102295: PPUSH
102296: LD_VAR 0 5
102300: PPUSH
102301: CALL_OW 3
102305: PPUSH
102306: CALL_OW 1
102310: ST_TO_ADDR
// end ; end ;
102311: GO 102149
102313: POP
102314: POP
// end ;
102315: LD_VAR 0 4
102319: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
102320: LD_INT 0
102322: PPUSH
102323: PPUSH
102324: PPUSH
102325: PPUSH
102326: PPUSH
102327: PPUSH
102328: PPUSH
102329: PPUSH
102330: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
102331: LD_VAR 0 1
102335: PPUSH
102336: CALL_OW 264
102340: PUSH
102341: LD_EXP 101
102345: EQUAL
102346: NOT
102347: PUSH
102348: LD_VAR 0 1
102352: PUSH
102353: LD_EXP 176
102357: IN
102358: NOT
102359: OR
102360: IFFALSE 102364
// exit ;
102362: GO 102686
// index := GetElementIndex ( minersList , unit ) ;
102364: LD_ADDR_VAR 0 6
102368: PUSH
102369: LD_EXP 176
102373: PPUSH
102374: LD_VAR 0 1
102378: PPUSH
102379: CALL 52839 0 2
102383: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
102384: LD_ADDR_VAR 0 8
102388: PUSH
102389: LD_EXP 178
102393: PUSH
102394: LD_EXP 177
102398: PUSH
102399: LD_VAR 0 6
102403: ARRAY
102404: MINUS
102405: ST_TO_ADDR
// if not minesFreeAmount then
102406: LD_VAR 0 8
102410: NOT
102411: IFFALSE 102415
// exit ;
102413: GO 102686
// tmp := [ ] ;
102415: LD_ADDR_VAR 0 7
102419: PUSH
102420: EMPTY
102421: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
102422: LD_ADDR_VAR 0 5
102426: PUSH
102427: DOUBLE
102428: LD_INT 1
102430: DEC
102431: ST_TO_ADDR
102432: LD_VAR 0 8
102436: PUSH
102437: FOR_TO
102438: IFFALSE 102633
// begin _d := rand ( 0 , 5 ) ;
102440: LD_ADDR_VAR 0 11
102444: PUSH
102445: LD_INT 0
102447: PPUSH
102448: LD_INT 5
102450: PPUSH
102451: CALL_OW 12
102455: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
102456: LD_ADDR_VAR 0 12
102460: PUSH
102461: LD_INT 2
102463: PPUSH
102464: LD_INT 6
102466: PPUSH
102467: CALL_OW 12
102471: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
102472: LD_ADDR_VAR 0 9
102476: PUSH
102477: LD_VAR 0 2
102481: PPUSH
102482: LD_VAR 0 11
102486: PPUSH
102487: LD_VAR 0 12
102491: PPUSH
102492: CALL_OW 272
102496: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
102497: LD_ADDR_VAR 0 10
102501: PUSH
102502: LD_VAR 0 3
102506: PPUSH
102507: LD_VAR 0 11
102511: PPUSH
102512: LD_VAR 0 12
102516: PPUSH
102517: CALL_OW 273
102521: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
102522: LD_VAR 0 9
102526: PPUSH
102527: LD_VAR 0 10
102531: PPUSH
102532: CALL_OW 488
102536: PUSH
102537: LD_VAR 0 9
102541: PUSH
102542: LD_VAR 0 10
102546: PUSH
102547: EMPTY
102548: LIST
102549: LIST
102550: PUSH
102551: LD_VAR 0 7
102555: IN
102556: NOT
102557: AND
102558: PUSH
102559: LD_VAR 0 9
102563: PPUSH
102564: LD_VAR 0 10
102568: PPUSH
102569: CALL_OW 458
102573: NOT
102574: AND
102575: IFFALSE 102617
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
102577: LD_ADDR_VAR 0 7
102581: PUSH
102582: LD_VAR 0 7
102586: PPUSH
102587: LD_VAR 0 7
102591: PUSH
102592: LD_INT 1
102594: PLUS
102595: PPUSH
102596: LD_VAR 0 9
102600: PUSH
102601: LD_VAR 0 10
102605: PUSH
102606: EMPTY
102607: LIST
102608: LIST
102609: PPUSH
102610: CALL_OW 1
102614: ST_TO_ADDR
102615: GO 102631
// i := i - 1 ;
102617: LD_ADDR_VAR 0 5
102621: PUSH
102622: LD_VAR 0 5
102626: PUSH
102627: LD_INT 1
102629: MINUS
102630: ST_TO_ADDR
// end ;
102631: GO 102437
102633: POP
102634: POP
// for i in tmp do
102635: LD_ADDR_VAR 0 5
102639: PUSH
102640: LD_VAR 0 7
102644: PUSH
102645: FOR_IN
102646: IFFALSE 102684
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
102648: LD_VAR 0 1
102652: PPUSH
102653: LD_VAR 0 5
102657: PUSH
102658: LD_INT 1
102660: ARRAY
102661: PPUSH
102662: LD_VAR 0 5
102666: PUSH
102667: LD_INT 2
102669: ARRAY
102670: PPUSH
102671: CALL 101626 0 3
102675: NOT
102676: IFFALSE 102682
// exit ;
102678: POP
102679: POP
102680: GO 102686
102682: GO 102645
102684: POP
102685: POP
// end ;
102686: LD_VAR 0 4
102690: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
102691: LD_INT 0
102693: PPUSH
102694: PPUSH
102695: PPUSH
102696: PPUSH
102697: PPUSH
102698: PPUSH
102699: PPUSH
// if not GetClass ( unit ) = class_sniper then
102700: LD_VAR 0 1
102704: PPUSH
102705: CALL_OW 257
102709: PUSH
102710: LD_INT 5
102712: EQUAL
102713: NOT
102714: IFFALSE 102718
// exit ;
102716: GO 103106
// dist := 8 ;
102718: LD_ADDR_VAR 0 5
102722: PUSH
102723: LD_INT 8
102725: ST_TO_ADDR
// viewRange := 12 ;
102726: LD_ADDR_VAR 0 7
102730: PUSH
102731: LD_INT 12
102733: ST_TO_ADDR
// side := GetSide ( unit ) ;
102734: LD_ADDR_VAR 0 6
102738: PUSH
102739: LD_VAR 0 1
102743: PPUSH
102744: CALL_OW 255
102748: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
102749: LD_INT 61
102751: PPUSH
102752: LD_VAR 0 6
102756: PPUSH
102757: CALL_OW 321
102761: PUSH
102762: LD_INT 2
102764: EQUAL
102765: IFFALSE 102775
// viewRange := 16 ;
102767: LD_ADDR_VAR 0 7
102771: PUSH
102772: LD_INT 16
102774: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
102775: LD_VAR 0 1
102779: PPUSH
102780: LD_VAR 0 2
102784: PPUSH
102785: LD_VAR 0 3
102789: PPUSH
102790: CALL_OW 297
102794: PUSH
102795: LD_VAR 0 5
102799: GREATER
102800: IFFALSE 102879
// begin ComMoveXY ( unit , x , y ) ;
102802: LD_VAR 0 1
102806: PPUSH
102807: LD_VAR 0 2
102811: PPUSH
102812: LD_VAR 0 3
102816: PPUSH
102817: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102821: LD_INT 35
102823: PPUSH
102824: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
102828: LD_VAR 0 1
102832: PPUSH
102833: LD_VAR 0 2
102837: PPUSH
102838: LD_VAR 0 3
102842: PPUSH
102843: CALL 83236 0 3
102847: NOT
102848: IFFALSE 102852
// exit ;
102850: GO 103106
// until GetDistUnitXY ( unit , x , y ) < dist ;
102852: LD_VAR 0 1
102856: PPUSH
102857: LD_VAR 0 2
102861: PPUSH
102862: LD_VAR 0 3
102866: PPUSH
102867: CALL_OW 297
102871: PUSH
102872: LD_VAR 0 5
102876: LESS
102877: IFFALSE 102821
// end ; ComTurnXY ( unit , x , y ) ;
102879: LD_VAR 0 1
102883: PPUSH
102884: LD_VAR 0 2
102888: PPUSH
102889: LD_VAR 0 3
102893: PPUSH
102894: CALL_OW 118
// wait ( 5 ) ;
102898: LD_INT 5
102900: PPUSH
102901: CALL_OW 67
// _d := GetDir ( unit ) ;
102905: LD_ADDR_VAR 0 10
102909: PUSH
102910: LD_VAR 0 1
102914: PPUSH
102915: CALL_OW 254
102919: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102920: LD_ADDR_VAR 0 8
102924: PUSH
102925: LD_VAR 0 1
102929: PPUSH
102930: CALL_OW 250
102934: PPUSH
102935: LD_VAR 0 10
102939: PPUSH
102940: LD_VAR 0 5
102944: PPUSH
102945: CALL_OW 272
102949: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102950: LD_ADDR_VAR 0 9
102954: PUSH
102955: LD_VAR 0 1
102959: PPUSH
102960: CALL_OW 251
102964: PPUSH
102965: LD_VAR 0 10
102969: PPUSH
102970: LD_VAR 0 5
102974: PPUSH
102975: CALL_OW 273
102979: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102980: LD_VAR 0 8
102984: PPUSH
102985: LD_VAR 0 9
102989: PPUSH
102990: CALL_OW 488
102994: NOT
102995: IFFALSE 102999
// exit ;
102997: GO 103106
// ComAnimCustom ( unit , 1 ) ;
102999: LD_VAR 0 1
103003: PPUSH
103004: LD_INT 1
103006: PPUSH
103007: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
103011: LD_VAR 0 8
103015: PPUSH
103016: LD_VAR 0 9
103020: PPUSH
103021: LD_VAR 0 6
103025: PPUSH
103026: LD_VAR 0 7
103030: PPUSH
103031: CALL_OW 330
// repeat wait ( 1 ) ;
103035: LD_INT 1
103037: PPUSH
103038: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
103042: LD_VAR 0 1
103046: PPUSH
103047: CALL_OW 316
103051: PUSH
103052: LD_VAR 0 1
103056: PPUSH
103057: CALL_OW 314
103061: OR
103062: PUSH
103063: LD_VAR 0 1
103067: PPUSH
103068: CALL_OW 302
103072: NOT
103073: OR
103074: PUSH
103075: LD_VAR 0 1
103079: PPUSH
103080: CALL_OW 301
103084: OR
103085: IFFALSE 103035
// RemoveSeeing ( _x , _y , side ) ;
103087: LD_VAR 0 8
103091: PPUSH
103092: LD_VAR 0 9
103096: PPUSH
103097: LD_VAR 0 6
103101: PPUSH
103102: CALL_OW 331
// end ; end_of_file
103106: LD_VAR 0 4
103110: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
103111: LD_INT 0
103113: PPUSH
103114: PPUSH
103115: PPUSH
103116: PPUSH
103117: PPUSH
103118: PPUSH
103119: PPUSH
103120: PPUSH
103121: PPUSH
103122: PPUSH
103123: PPUSH
103124: PPUSH
103125: PPUSH
103126: PPUSH
103127: PPUSH
103128: PPUSH
103129: PPUSH
103130: PPUSH
103131: PPUSH
103132: PPUSH
103133: PPUSH
103134: PPUSH
103135: PPUSH
103136: PPUSH
103137: PPUSH
103138: PPUSH
103139: PPUSH
103140: PPUSH
103141: PPUSH
103142: PPUSH
103143: PPUSH
103144: PPUSH
103145: PPUSH
103146: PPUSH
// if not list then
103147: LD_VAR 0 1
103151: NOT
103152: IFFALSE 103156
// exit ;
103154: GO 107815
// base := list [ 1 ] ;
103156: LD_ADDR_VAR 0 3
103160: PUSH
103161: LD_VAR 0 1
103165: PUSH
103166: LD_INT 1
103168: ARRAY
103169: ST_TO_ADDR
// group := list [ 2 ] ;
103170: LD_ADDR_VAR 0 4
103174: PUSH
103175: LD_VAR 0 1
103179: PUSH
103180: LD_INT 2
103182: ARRAY
103183: ST_TO_ADDR
// path := list [ 3 ] ;
103184: LD_ADDR_VAR 0 5
103188: PUSH
103189: LD_VAR 0 1
103193: PUSH
103194: LD_INT 3
103196: ARRAY
103197: ST_TO_ADDR
// flags := list [ 4 ] ;
103198: LD_ADDR_VAR 0 6
103202: PUSH
103203: LD_VAR 0 1
103207: PUSH
103208: LD_INT 4
103210: ARRAY
103211: ST_TO_ADDR
// mined := [ ] ;
103212: LD_ADDR_VAR 0 27
103216: PUSH
103217: EMPTY
103218: ST_TO_ADDR
// bombed := [ ] ;
103219: LD_ADDR_VAR 0 28
103223: PUSH
103224: EMPTY
103225: ST_TO_ADDR
// healers := [ ] ;
103226: LD_ADDR_VAR 0 31
103230: PUSH
103231: EMPTY
103232: ST_TO_ADDR
// to_heal := [ ] ;
103233: LD_ADDR_VAR 0 30
103237: PUSH
103238: EMPTY
103239: ST_TO_ADDR
// repairs := [ ] ;
103240: LD_ADDR_VAR 0 33
103244: PUSH
103245: EMPTY
103246: ST_TO_ADDR
// to_repair := [ ] ;
103247: LD_ADDR_VAR 0 32
103251: PUSH
103252: EMPTY
103253: ST_TO_ADDR
// if not group or not path then
103254: LD_VAR 0 4
103258: NOT
103259: PUSH
103260: LD_VAR 0 5
103264: NOT
103265: OR
103266: IFFALSE 103270
// exit ;
103268: GO 107815
// side := GetSide ( group [ 1 ] ) ;
103270: LD_ADDR_VAR 0 35
103274: PUSH
103275: LD_VAR 0 4
103279: PUSH
103280: LD_INT 1
103282: ARRAY
103283: PPUSH
103284: CALL_OW 255
103288: ST_TO_ADDR
// if flags then
103289: LD_VAR 0 6
103293: IFFALSE 103437
// begin f_ignore_area := flags [ 1 ] ;
103295: LD_ADDR_VAR 0 17
103299: PUSH
103300: LD_VAR 0 6
103304: PUSH
103305: LD_INT 1
103307: ARRAY
103308: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
103309: LD_ADDR_VAR 0 18
103313: PUSH
103314: LD_VAR 0 6
103318: PUSH
103319: LD_INT 2
103321: ARRAY
103322: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
103323: LD_ADDR_VAR 0 19
103327: PUSH
103328: LD_VAR 0 6
103332: PUSH
103333: LD_INT 3
103335: ARRAY
103336: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
103337: LD_ADDR_VAR 0 20
103341: PUSH
103342: LD_VAR 0 6
103346: PUSH
103347: LD_INT 4
103349: ARRAY
103350: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
103351: LD_ADDR_VAR 0 21
103355: PUSH
103356: LD_VAR 0 6
103360: PUSH
103361: LD_INT 5
103363: ARRAY
103364: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
103365: LD_ADDR_VAR 0 22
103369: PUSH
103370: LD_VAR 0 6
103374: PUSH
103375: LD_INT 6
103377: ARRAY
103378: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
103379: LD_ADDR_VAR 0 23
103383: PUSH
103384: LD_VAR 0 6
103388: PUSH
103389: LD_INT 7
103391: ARRAY
103392: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
103393: LD_ADDR_VAR 0 24
103397: PUSH
103398: LD_VAR 0 6
103402: PUSH
103403: LD_INT 8
103405: ARRAY
103406: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
103407: LD_ADDR_VAR 0 25
103411: PUSH
103412: LD_VAR 0 6
103416: PUSH
103417: LD_INT 9
103419: ARRAY
103420: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
103421: LD_ADDR_VAR 0 26
103425: PUSH
103426: LD_VAR 0 6
103430: PUSH
103431: LD_INT 10
103433: ARRAY
103434: ST_TO_ADDR
// end else
103435: GO 103517
// begin f_ignore_area := false ;
103437: LD_ADDR_VAR 0 17
103441: PUSH
103442: LD_INT 0
103444: ST_TO_ADDR
// f_capture := false ;
103445: LD_ADDR_VAR 0 18
103449: PUSH
103450: LD_INT 0
103452: ST_TO_ADDR
// f_ignore_civ := false ;
103453: LD_ADDR_VAR 0 19
103457: PUSH
103458: LD_INT 0
103460: ST_TO_ADDR
// f_murder := false ;
103461: LD_ADDR_VAR 0 20
103465: PUSH
103466: LD_INT 0
103468: ST_TO_ADDR
// f_mines := false ;
103469: LD_ADDR_VAR 0 21
103473: PUSH
103474: LD_INT 0
103476: ST_TO_ADDR
// f_repair := false ;
103477: LD_ADDR_VAR 0 22
103481: PUSH
103482: LD_INT 0
103484: ST_TO_ADDR
// f_heal := false ;
103485: LD_ADDR_VAR 0 23
103489: PUSH
103490: LD_INT 0
103492: ST_TO_ADDR
// f_spacetime := false ;
103493: LD_ADDR_VAR 0 24
103497: PUSH
103498: LD_INT 0
103500: ST_TO_ADDR
// f_attack_depot := false ;
103501: LD_ADDR_VAR 0 25
103505: PUSH
103506: LD_INT 0
103508: ST_TO_ADDR
// f_crawl := false ;
103509: LD_ADDR_VAR 0 26
103513: PUSH
103514: LD_INT 0
103516: ST_TO_ADDR
// end ; if f_heal then
103517: LD_VAR 0 23
103521: IFFALSE 103548
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
103523: LD_ADDR_VAR 0 31
103527: PUSH
103528: LD_VAR 0 4
103532: PPUSH
103533: LD_INT 25
103535: PUSH
103536: LD_INT 4
103538: PUSH
103539: EMPTY
103540: LIST
103541: LIST
103542: PPUSH
103543: CALL_OW 72
103547: ST_TO_ADDR
// if f_repair then
103548: LD_VAR 0 22
103552: IFFALSE 103579
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
103554: LD_ADDR_VAR 0 33
103558: PUSH
103559: LD_VAR 0 4
103563: PPUSH
103564: LD_INT 25
103566: PUSH
103567: LD_INT 3
103569: PUSH
103570: EMPTY
103571: LIST
103572: LIST
103573: PPUSH
103574: CALL_OW 72
103578: ST_TO_ADDR
// units_path := [ ] ;
103579: LD_ADDR_VAR 0 16
103583: PUSH
103584: EMPTY
103585: ST_TO_ADDR
// for i = 1 to group do
103586: LD_ADDR_VAR 0 7
103590: PUSH
103591: DOUBLE
103592: LD_INT 1
103594: DEC
103595: ST_TO_ADDR
103596: LD_VAR 0 4
103600: PUSH
103601: FOR_TO
103602: IFFALSE 103631
// units_path := Replace ( units_path , i , path ) ;
103604: LD_ADDR_VAR 0 16
103608: PUSH
103609: LD_VAR 0 16
103613: PPUSH
103614: LD_VAR 0 7
103618: PPUSH
103619: LD_VAR 0 5
103623: PPUSH
103624: CALL_OW 1
103628: ST_TO_ADDR
103629: GO 103601
103631: POP
103632: POP
// repeat for i = group downto 1 do
103633: LD_ADDR_VAR 0 7
103637: PUSH
103638: DOUBLE
103639: LD_VAR 0 4
103643: INC
103644: ST_TO_ADDR
103645: LD_INT 1
103647: PUSH
103648: FOR_DOWNTO
103649: IFFALSE 107771
// begin wait ( 5 ) ;
103651: LD_INT 5
103653: PPUSH
103654: CALL_OW 67
// tmp := [ ] ;
103658: LD_ADDR_VAR 0 14
103662: PUSH
103663: EMPTY
103664: ST_TO_ADDR
// attacking := false ;
103665: LD_ADDR_VAR 0 29
103669: PUSH
103670: LD_INT 0
103672: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
103673: LD_VAR 0 4
103677: PUSH
103678: LD_VAR 0 7
103682: ARRAY
103683: PPUSH
103684: CALL_OW 301
103688: PUSH
103689: LD_VAR 0 4
103693: PUSH
103694: LD_VAR 0 7
103698: ARRAY
103699: NOT
103700: OR
103701: IFFALSE 103810
// begin if GetType ( group [ i ] ) = unit_human then
103703: LD_VAR 0 4
103707: PUSH
103708: LD_VAR 0 7
103712: ARRAY
103713: PPUSH
103714: CALL_OW 247
103718: PUSH
103719: LD_INT 1
103721: EQUAL
103722: IFFALSE 103768
// begin to_heal := to_heal diff group [ i ] ;
103724: LD_ADDR_VAR 0 30
103728: PUSH
103729: LD_VAR 0 30
103733: PUSH
103734: LD_VAR 0 4
103738: PUSH
103739: LD_VAR 0 7
103743: ARRAY
103744: DIFF
103745: ST_TO_ADDR
// healers := healers diff group [ i ] ;
103746: LD_ADDR_VAR 0 31
103750: PUSH
103751: LD_VAR 0 31
103755: PUSH
103756: LD_VAR 0 4
103760: PUSH
103761: LD_VAR 0 7
103765: ARRAY
103766: DIFF
103767: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
103768: LD_ADDR_VAR 0 4
103772: PUSH
103773: LD_VAR 0 4
103777: PPUSH
103778: LD_VAR 0 7
103782: PPUSH
103783: CALL_OW 3
103787: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
103788: LD_ADDR_VAR 0 16
103792: PUSH
103793: LD_VAR 0 16
103797: PPUSH
103798: LD_VAR 0 7
103802: PPUSH
103803: CALL_OW 3
103807: ST_TO_ADDR
// continue ;
103808: GO 103648
// end ; if f_repair then
103810: LD_VAR 0 22
103814: IFFALSE 104303
// begin if GetType ( group [ i ] ) = unit_vehicle then
103816: LD_VAR 0 4
103820: PUSH
103821: LD_VAR 0 7
103825: ARRAY
103826: PPUSH
103827: CALL_OW 247
103831: PUSH
103832: LD_INT 2
103834: EQUAL
103835: IFFALSE 104025
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
103837: LD_VAR 0 4
103841: PUSH
103842: LD_VAR 0 7
103846: ARRAY
103847: PPUSH
103848: CALL_OW 256
103852: PUSH
103853: LD_INT 700
103855: LESS
103856: PUSH
103857: LD_VAR 0 4
103861: PUSH
103862: LD_VAR 0 7
103866: ARRAY
103867: PUSH
103868: LD_VAR 0 32
103872: IN
103873: NOT
103874: AND
103875: IFFALSE 103899
// to_repair := to_repair union group [ i ] ;
103877: LD_ADDR_VAR 0 32
103881: PUSH
103882: LD_VAR 0 32
103886: PUSH
103887: LD_VAR 0 4
103891: PUSH
103892: LD_VAR 0 7
103896: ARRAY
103897: UNION
103898: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103899: LD_VAR 0 4
103903: PUSH
103904: LD_VAR 0 7
103908: ARRAY
103909: PPUSH
103910: CALL_OW 256
103914: PUSH
103915: LD_INT 1000
103917: EQUAL
103918: PUSH
103919: LD_VAR 0 4
103923: PUSH
103924: LD_VAR 0 7
103928: ARRAY
103929: PUSH
103930: LD_VAR 0 32
103934: IN
103935: AND
103936: IFFALSE 103960
// to_repair := to_repair diff group [ i ] ;
103938: LD_ADDR_VAR 0 32
103942: PUSH
103943: LD_VAR 0 32
103947: PUSH
103948: LD_VAR 0 4
103952: PUSH
103953: LD_VAR 0 7
103957: ARRAY
103958: DIFF
103959: ST_TO_ADDR
// if group [ i ] in to_repair then
103960: LD_VAR 0 4
103964: PUSH
103965: LD_VAR 0 7
103969: ARRAY
103970: PUSH
103971: LD_VAR 0 32
103975: IN
103976: IFFALSE 104023
// begin if not IsInArea ( group [ i ] , f_repair ) then
103978: LD_VAR 0 4
103982: PUSH
103983: LD_VAR 0 7
103987: ARRAY
103988: PPUSH
103989: LD_VAR 0 22
103993: PPUSH
103994: CALL_OW 308
103998: NOT
103999: IFFALSE 104021
// ComMoveToArea ( group [ i ] , f_repair ) ;
104001: LD_VAR 0 4
104005: PUSH
104006: LD_VAR 0 7
104010: ARRAY
104011: PPUSH
104012: LD_VAR 0 22
104016: PPUSH
104017: CALL_OW 113
// continue ;
104021: GO 103648
// end ; end else
104023: GO 104303
// if group [ i ] in repairs then
104025: LD_VAR 0 4
104029: PUSH
104030: LD_VAR 0 7
104034: ARRAY
104035: PUSH
104036: LD_VAR 0 33
104040: IN
104041: IFFALSE 104303
// begin if IsInUnit ( group [ i ] ) then
104043: LD_VAR 0 4
104047: PUSH
104048: LD_VAR 0 7
104052: ARRAY
104053: PPUSH
104054: CALL_OW 310
104058: IFFALSE 104126
// begin z := IsInUnit ( group [ i ] ) ;
104060: LD_ADDR_VAR 0 13
104064: PUSH
104065: LD_VAR 0 4
104069: PUSH
104070: LD_VAR 0 7
104074: ARRAY
104075: PPUSH
104076: CALL_OW 310
104080: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
104081: LD_VAR 0 13
104085: PUSH
104086: LD_VAR 0 32
104090: IN
104091: PUSH
104092: LD_VAR 0 13
104096: PPUSH
104097: LD_VAR 0 22
104101: PPUSH
104102: CALL_OW 308
104106: AND
104107: IFFALSE 104124
// ComExitVehicle ( group [ i ] ) ;
104109: LD_VAR 0 4
104113: PUSH
104114: LD_VAR 0 7
104118: ARRAY
104119: PPUSH
104120: CALL_OW 121
// end else
104124: GO 104303
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
104126: LD_ADDR_VAR 0 13
104130: PUSH
104131: LD_VAR 0 4
104135: PPUSH
104136: LD_INT 95
104138: PUSH
104139: LD_VAR 0 22
104143: PUSH
104144: EMPTY
104145: LIST
104146: LIST
104147: PUSH
104148: LD_INT 58
104150: PUSH
104151: EMPTY
104152: LIST
104153: PUSH
104154: EMPTY
104155: LIST
104156: LIST
104157: PPUSH
104158: CALL_OW 72
104162: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
104163: LD_VAR 0 4
104167: PUSH
104168: LD_VAR 0 7
104172: ARRAY
104173: PPUSH
104174: CALL_OW 314
104178: NOT
104179: IFFALSE 104301
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
104181: LD_ADDR_VAR 0 10
104185: PUSH
104186: LD_VAR 0 13
104190: PPUSH
104191: LD_VAR 0 4
104195: PUSH
104196: LD_VAR 0 7
104200: ARRAY
104201: PPUSH
104202: CALL_OW 74
104206: ST_TO_ADDR
// if not x then
104207: LD_VAR 0 10
104211: NOT
104212: IFFALSE 104216
// continue ;
104214: GO 103648
// if GetLives ( x ) < 1000 then
104216: LD_VAR 0 10
104220: PPUSH
104221: CALL_OW 256
104225: PUSH
104226: LD_INT 1000
104228: LESS
104229: IFFALSE 104253
// ComRepairVehicle ( group [ i ] , x ) else
104231: LD_VAR 0 4
104235: PUSH
104236: LD_VAR 0 7
104240: ARRAY
104241: PPUSH
104242: LD_VAR 0 10
104246: PPUSH
104247: CALL_OW 129
104251: GO 104301
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
104253: LD_VAR 0 23
104257: PUSH
104258: LD_VAR 0 4
104262: PUSH
104263: LD_VAR 0 7
104267: ARRAY
104268: PPUSH
104269: CALL_OW 256
104273: PUSH
104274: LD_INT 1000
104276: LESS
104277: AND
104278: NOT
104279: IFFALSE 104301
// ComEnterUnit ( group [ i ] , x ) ;
104281: LD_VAR 0 4
104285: PUSH
104286: LD_VAR 0 7
104290: ARRAY
104291: PPUSH
104292: LD_VAR 0 10
104296: PPUSH
104297: CALL_OW 120
// end ; continue ;
104301: GO 103648
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
104303: LD_VAR 0 23
104307: PUSH
104308: LD_VAR 0 4
104312: PUSH
104313: LD_VAR 0 7
104317: ARRAY
104318: PPUSH
104319: CALL_OW 247
104323: PUSH
104324: LD_INT 1
104326: EQUAL
104327: AND
104328: IFFALSE 104806
// begin if group [ i ] in healers then
104330: LD_VAR 0 4
104334: PUSH
104335: LD_VAR 0 7
104339: ARRAY
104340: PUSH
104341: LD_VAR 0 31
104345: IN
104346: IFFALSE 104619
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
104348: LD_VAR 0 4
104352: PUSH
104353: LD_VAR 0 7
104357: ARRAY
104358: PPUSH
104359: LD_VAR 0 23
104363: PPUSH
104364: CALL_OW 308
104368: NOT
104369: PUSH
104370: LD_VAR 0 4
104374: PUSH
104375: LD_VAR 0 7
104379: ARRAY
104380: PPUSH
104381: CALL_OW 314
104385: NOT
104386: AND
104387: IFFALSE 104411
// ComMoveToArea ( group [ i ] , f_heal ) else
104389: LD_VAR 0 4
104393: PUSH
104394: LD_VAR 0 7
104398: ARRAY
104399: PPUSH
104400: LD_VAR 0 23
104404: PPUSH
104405: CALL_OW 113
104409: GO 104617
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
104411: LD_VAR 0 4
104415: PUSH
104416: LD_VAR 0 7
104420: ARRAY
104421: PPUSH
104422: CALL 81759 0 1
104426: PPUSH
104427: CALL_OW 256
104431: PUSH
104432: LD_INT 1000
104434: EQUAL
104435: IFFALSE 104454
// ComStop ( group [ i ] ) else
104437: LD_VAR 0 4
104441: PUSH
104442: LD_VAR 0 7
104446: ARRAY
104447: PPUSH
104448: CALL_OW 141
104452: GO 104617
// if not HasTask ( group [ i ] ) and to_heal then
104454: LD_VAR 0 4
104458: PUSH
104459: LD_VAR 0 7
104463: ARRAY
104464: PPUSH
104465: CALL_OW 314
104469: NOT
104470: PUSH
104471: LD_VAR 0 30
104475: AND
104476: IFFALSE 104617
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
104478: LD_ADDR_VAR 0 13
104482: PUSH
104483: LD_VAR 0 30
104487: PPUSH
104488: LD_INT 3
104490: PUSH
104491: LD_INT 54
104493: PUSH
104494: EMPTY
104495: LIST
104496: PUSH
104497: EMPTY
104498: LIST
104499: LIST
104500: PPUSH
104501: CALL_OW 72
104505: PPUSH
104506: LD_VAR 0 4
104510: PUSH
104511: LD_VAR 0 7
104515: ARRAY
104516: PPUSH
104517: CALL_OW 74
104521: ST_TO_ADDR
// if z then
104522: LD_VAR 0 13
104526: IFFALSE 104617
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
104528: LD_INT 91
104530: PUSH
104531: LD_VAR 0 13
104535: PUSH
104536: LD_INT 10
104538: PUSH
104539: EMPTY
104540: LIST
104541: LIST
104542: LIST
104543: PUSH
104544: LD_INT 81
104546: PUSH
104547: LD_VAR 0 13
104551: PPUSH
104552: CALL_OW 255
104556: PUSH
104557: EMPTY
104558: LIST
104559: LIST
104560: PUSH
104561: EMPTY
104562: LIST
104563: LIST
104564: PPUSH
104565: CALL_OW 69
104569: PUSH
104570: LD_INT 0
104572: EQUAL
104573: IFFALSE 104597
// ComHeal ( group [ i ] , z ) else
104575: LD_VAR 0 4
104579: PUSH
104580: LD_VAR 0 7
104584: ARRAY
104585: PPUSH
104586: LD_VAR 0 13
104590: PPUSH
104591: CALL_OW 128
104595: GO 104617
// ComMoveToArea ( group [ i ] , f_heal ) ;
104597: LD_VAR 0 4
104601: PUSH
104602: LD_VAR 0 7
104606: ARRAY
104607: PPUSH
104608: LD_VAR 0 23
104612: PPUSH
104613: CALL_OW 113
// end ; continue ;
104617: GO 103648
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
104619: LD_VAR 0 4
104623: PUSH
104624: LD_VAR 0 7
104628: ARRAY
104629: PPUSH
104630: CALL_OW 256
104634: PUSH
104635: LD_INT 700
104637: LESS
104638: PUSH
104639: LD_VAR 0 4
104643: PUSH
104644: LD_VAR 0 7
104648: ARRAY
104649: PUSH
104650: LD_VAR 0 30
104654: IN
104655: NOT
104656: AND
104657: IFFALSE 104681
// to_heal := to_heal union group [ i ] ;
104659: LD_ADDR_VAR 0 30
104663: PUSH
104664: LD_VAR 0 30
104668: PUSH
104669: LD_VAR 0 4
104673: PUSH
104674: LD_VAR 0 7
104678: ARRAY
104679: UNION
104680: ST_TO_ADDR
// if group [ i ] in to_heal then
104681: LD_VAR 0 4
104685: PUSH
104686: LD_VAR 0 7
104690: ARRAY
104691: PUSH
104692: LD_VAR 0 30
104696: IN
104697: IFFALSE 104806
// begin if GetLives ( group [ i ] ) = 1000 then
104699: LD_VAR 0 4
104703: PUSH
104704: LD_VAR 0 7
104708: ARRAY
104709: PPUSH
104710: CALL_OW 256
104714: PUSH
104715: LD_INT 1000
104717: EQUAL
104718: IFFALSE 104744
// to_heal := to_heal diff group [ i ] else
104720: LD_ADDR_VAR 0 30
104724: PUSH
104725: LD_VAR 0 30
104729: PUSH
104730: LD_VAR 0 4
104734: PUSH
104735: LD_VAR 0 7
104739: ARRAY
104740: DIFF
104741: ST_TO_ADDR
104742: GO 104806
// begin if not IsInArea ( group [ i ] , to_heal ) then
104744: LD_VAR 0 4
104748: PUSH
104749: LD_VAR 0 7
104753: ARRAY
104754: PPUSH
104755: LD_VAR 0 30
104759: PPUSH
104760: CALL_OW 308
104764: NOT
104765: IFFALSE 104789
// ComMoveToArea ( group [ i ] , f_heal ) else
104767: LD_VAR 0 4
104771: PUSH
104772: LD_VAR 0 7
104776: ARRAY
104777: PPUSH
104778: LD_VAR 0 23
104782: PPUSH
104783: CALL_OW 113
104787: GO 104804
// ComHold ( group [ i ] ) ;
104789: LD_VAR 0 4
104793: PUSH
104794: LD_VAR 0 7
104798: ARRAY
104799: PPUSH
104800: CALL_OW 140
// continue ;
104804: GO 103648
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
104806: LD_VAR 0 4
104810: PUSH
104811: LD_VAR 0 7
104815: ARRAY
104816: PPUSH
104817: LD_INT 10
104819: PPUSH
104820: CALL 80179 0 2
104824: NOT
104825: PUSH
104826: LD_VAR 0 16
104830: PUSH
104831: LD_VAR 0 7
104835: ARRAY
104836: PUSH
104837: EMPTY
104838: EQUAL
104839: NOT
104840: AND
104841: IFFALSE 105107
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
104843: LD_VAR 0 4
104847: PUSH
104848: LD_VAR 0 7
104852: ARRAY
104853: PPUSH
104854: CALL_OW 262
104858: PUSH
104859: LD_INT 1
104861: PUSH
104862: LD_INT 2
104864: PUSH
104865: EMPTY
104866: LIST
104867: LIST
104868: IN
104869: IFFALSE 104910
// if GetFuel ( group [ i ] ) < 10 then
104871: LD_VAR 0 4
104875: PUSH
104876: LD_VAR 0 7
104880: ARRAY
104881: PPUSH
104882: CALL_OW 261
104886: PUSH
104887: LD_INT 10
104889: LESS
104890: IFFALSE 104910
// SetFuel ( group [ i ] , 12 ) ;
104892: LD_VAR 0 4
104896: PUSH
104897: LD_VAR 0 7
104901: ARRAY
104902: PPUSH
104903: LD_INT 12
104905: PPUSH
104906: CALL_OW 240
// if units_path [ i ] then
104910: LD_VAR 0 16
104914: PUSH
104915: LD_VAR 0 7
104919: ARRAY
104920: IFFALSE 105105
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104922: LD_VAR 0 4
104926: PUSH
104927: LD_VAR 0 7
104931: ARRAY
104932: PPUSH
104933: LD_VAR 0 16
104937: PUSH
104938: LD_VAR 0 7
104942: ARRAY
104943: PUSH
104944: LD_INT 1
104946: ARRAY
104947: PUSH
104948: LD_INT 1
104950: ARRAY
104951: PPUSH
104952: LD_VAR 0 16
104956: PUSH
104957: LD_VAR 0 7
104961: ARRAY
104962: PUSH
104963: LD_INT 1
104965: ARRAY
104966: PUSH
104967: LD_INT 2
104969: ARRAY
104970: PPUSH
104971: CALL_OW 297
104975: PUSH
104976: LD_INT 6
104978: GREATER
104979: IFFALSE 105054
// begin if not HasTask ( group [ i ] ) then
104981: LD_VAR 0 4
104985: PUSH
104986: LD_VAR 0 7
104990: ARRAY
104991: PPUSH
104992: CALL_OW 314
104996: NOT
104997: IFFALSE 105052
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104999: LD_VAR 0 4
105003: PUSH
105004: LD_VAR 0 7
105008: ARRAY
105009: PPUSH
105010: LD_VAR 0 16
105014: PUSH
105015: LD_VAR 0 7
105019: ARRAY
105020: PUSH
105021: LD_INT 1
105023: ARRAY
105024: PUSH
105025: LD_INT 1
105027: ARRAY
105028: PPUSH
105029: LD_VAR 0 16
105033: PUSH
105034: LD_VAR 0 7
105038: ARRAY
105039: PUSH
105040: LD_INT 1
105042: ARRAY
105043: PUSH
105044: LD_INT 2
105046: ARRAY
105047: PPUSH
105048: CALL_OW 114
// end else
105052: GO 105105
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
105054: LD_ADDR_VAR 0 15
105058: PUSH
105059: LD_VAR 0 16
105063: PUSH
105064: LD_VAR 0 7
105068: ARRAY
105069: PPUSH
105070: LD_INT 1
105072: PPUSH
105073: CALL_OW 3
105077: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
105078: LD_ADDR_VAR 0 16
105082: PUSH
105083: LD_VAR 0 16
105087: PPUSH
105088: LD_VAR 0 7
105092: PPUSH
105093: LD_VAR 0 15
105097: PPUSH
105098: CALL_OW 1
105102: ST_TO_ADDR
// continue ;
105103: GO 103648
// end ; end ; end else
105105: GO 107769
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
105107: LD_ADDR_VAR 0 14
105111: PUSH
105112: LD_INT 81
105114: PUSH
105115: LD_VAR 0 4
105119: PUSH
105120: LD_VAR 0 7
105124: ARRAY
105125: PPUSH
105126: CALL_OW 255
105130: PUSH
105131: EMPTY
105132: LIST
105133: LIST
105134: PPUSH
105135: CALL_OW 69
105139: ST_TO_ADDR
// if not tmp then
105140: LD_VAR 0 14
105144: NOT
105145: IFFALSE 105149
// continue ;
105147: GO 103648
// if f_ignore_area then
105149: LD_VAR 0 17
105153: IFFALSE 105241
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
105155: LD_ADDR_VAR 0 15
105159: PUSH
105160: LD_VAR 0 14
105164: PPUSH
105165: LD_INT 3
105167: PUSH
105168: LD_INT 92
105170: PUSH
105171: LD_VAR 0 17
105175: PUSH
105176: LD_INT 1
105178: ARRAY
105179: PUSH
105180: LD_VAR 0 17
105184: PUSH
105185: LD_INT 2
105187: ARRAY
105188: PUSH
105189: LD_VAR 0 17
105193: PUSH
105194: LD_INT 3
105196: ARRAY
105197: PUSH
105198: EMPTY
105199: LIST
105200: LIST
105201: LIST
105202: LIST
105203: PUSH
105204: EMPTY
105205: LIST
105206: LIST
105207: PPUSH
105208: CALL_OW 72
105212: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105213: LD_VAR 0 14
105217: PUSH
105218: LD_VAR 0 15
105222: DIFF
105223: IFFALSE 105241
// tmp := tmp diff tmp2 ;
105225: LD_ADDR_VAR 0 14
105229: PUSH
105230: LD_VAR 0 14
105234: PUSH
105235: LD_VAR 0 15
105239: DIFF
105240: ST_TO_ADDR
// end ; if not f_murder then
105241: LD_VAR 0 20
105245: NOT
105246: IFFALSE 105304
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
105248: LD_ADDR_VAR 0 15
105252: PUSH
105253: LD_VAR 0 14
105257: PPUSH
105258: LD_INT 3
105260: PUSH
105261: LD_INT 50
105263: PUSH
105264: EMPTY
105265: LIST
105266: PUSH
105267: EMPTY
105268: LIST
105269: LIST
105270: PPUSH
105271: CALL_OW 72
105275: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105276: LD_VAR 0 14
105280: PUSH
105281: LD_VAR 0 15
105285: DIFF
105286: IFFALSE 105304
// tmp := tmp diff tmp2 ;
105288: LD_ADDR_VAR 0 14
105292: PUSH
105293: LD_VAR 0 14
105297: PUSH
105298: LD_VAR 0 15
105302: DIFF
105303: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
105304: LD_ADDR_VAR 0 14
105308: PUSH
105309: LD_VAR 0 4
105313: PUSH
105314: LD_VAR 0 7
105318: ARRAY
105319: PPUSH
105320: LD_VAR 0 14
105324: PPUSH
105325: LD_INT 1
105327: PPUSH
105328: LD_INT 1
105330: PPUSH
105331: CALL 53489 0 4
105335: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
105336: LD_VAR 0 4
105340: PUSH
105341: LD_VAR 0 7
105345: ARRAY
105346: PPUSH
105347: CALL_OW 257
105351: PUSH
105352: LD_INT 1
105354: EQUAL
105355: IFFALSE 105803
// begin if WantPlant ( group [ i ] ) then
105357: LD_VAR 0 4
105361: PUSH
105362: LD_VAR 0 7
105366: ARRAY
105367: PPUSH
105368: CALL 52990 0 1
105372: IFFALSE 105376
// continue ;
105374: GO 103648
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
105376: LD_VAR 0 18
105380: PUSH
105381: LD_VAR 0 4
105385: PUSH
105386: LD_VAR 0 7
105390: ARRAY
105391: PPUSH
105392: CALL_OW 310
105396: NOT
105397: AND
105398: PUSH
105399: LD_VAR 0 14
105403: PUSH
105404: LD_INT 1
105406: ARRAY
105407: PUSH
105408: LD_VAR 0 14
105412: PPUSH
105413: LD_INT 21
105415: PUSH
105416: LD_INT 2
105418: PUSH
105419: EMPTY
105420: LIST
105421: LIST
105422: PUSH
105423: LD_INT 58
105425: PUSH
105426: EMPTY
105427: LIST
105428: PUSH
105429: EMPTY
105430: LIST
105431: LIST
105432: PPUSH
105433: CALL_OW 72
105437: IN
105438: AND
105439: IFFALSE 105475
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
105441: LD_VAR 0 4
105445: PUSH
105446: LD_VAR 0 7
105450: ARRAY
105451: PPUSH
105452: LD_VAR 0 14
105456: PUSH
105457: LD_INT 1
105459: ARRAY
105460: PPUSH
105461: CALL_OW 120
// attacking := true ;
105465: LD_ADDR_VAR 0 29
105469: PUSH
105470: LD_INT 1
105472: ST_TO_ADDR
// continue ;
105473: GO 103648
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
105475: LD_VAR 0 26
105479: PUSH
105480: LD_VAR 0 4
105484: PUSH
105485: LD_VAR 0 7
105489: ARRAY
105490: PPUSH
105491: CALL_OW 257
105495: PUSH
105496: LD_INT 1
105498: EQUAL
105499: AND
105500: PUSH
105501: LD_VAR 0 4
105505: PUSH
105506: LD_VAR 0 7
105510: ARRAY
105511: PPUSH
105512: CALL_OW 256
105516: PUSH
105517: LD_INT 800
105519: LESS
105520: AND
105521: PUSH
105522: LD_VAR 0 4
105526: PUSH
105527: LD_VAR 0 7
105531: ARRAY
105532: PPUSH
105533: CALL_OW 318
105537: NOT
105538: AND
105539: IFFALSE 105556
// ComCrawl ( group [ i ] ) ;
105541: LD_VAR 0 4
105545: PUSH
105546: LD_VAR 0 7
105550: ARRAY
105551: PPUSH
105552: CALL_OW 137
// if f_mines then
105556: LD_VAR 0 21
105560: IFFALSE 105803
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
105562: LD_VAR 0 14
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: CALL_OW 247
105575: PUSH
105576: LD_INT 3
105578: EQUAL
105579: PUSH
105580: LD_VAR 0 14
105584: PUSH
105585: LD_INT 1
105587: ARRAY
105588: PUSH
105589: LD_VAR 0 27
105593: IN
105594: NOT
105595: AND
105596: IFFALSE 105803
// begin x := GetX ( tmp [ 1 ] ) ;
105598: LD_ADDR_VAR 0 10
105602: PUSH
105603: LD_VAR 0 14
105607: PUSH
105608: LD_INT 1
105610: ARRAY
105611: PPUSH
105612: CALL_OW 250
105616: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
105617: LD_ADDR_VAR 0 11
105621: PUSH
105622: LD_VAR 0 14
105626: PUSH
105627: LD_INT 1
105629: ARRAY
105630: PPUSH
105631: CALL_OW 251
105635: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
105636: LD_ADDR_VAR 0 12
105640: PUSH
105641: LD_VAR 0 4
105645: PUSH
105646: LD_VAR 0 7
105650: ARRAY
105651: PPUSH
105652: CALL 80264 0 1
105656: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
105657: LD_VAR 0 4
105661: PUSH
105662: LD_VAR 0 7
105666: ARRAY
105667: PPUSH
105668: LD_VAR 0 10
105672: PPUSH
105673: LD_VAR 0 11
105677: PPUSH
105678: LD_VAR 0 14
105682: PUSH
105683: LD_INT 1
105685: ARRAY
105686: PPUSH
105687: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
105691: LD_VAR 0 4
105695: PUSH
105696: LD_VAR 0 7
105700: ARRAY
105701: PPUSH
105702: LD_VAR 0 10
105706: PPUSH
105707: LD_VAR 0 12
105711: PPUSH
105712: LD_INT 7
105714: PPUSH
105715: CALL_OW 272
105719: PPUSH
105720: LD_VAR 0 11
105724: PPUSH
105725: LD_VAR 0 12
105729: PPUSH
105730: LD_INT 7
105732: PPUSH
105733: CALL_OW 273
105737: PPUSH
105738: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
105742: LD_VAR 0 4
105746: PUSH
105747: LD_VAR 0 7
105751: ARRAY
105752: PPUSH
105753: LD_INT 71
105755: PPUSH
105756: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
105760: LD_ADDR_VAR 0 27
105764: PUSH
105765: LD_VAR 0 27
105769: PPUSH
105770: LD_VAR 0 27
105774: PUSH
105775: LD_INT 1
105777: PLUS
105778: PPUSH
105779: LD_VAR 0 14
105783: PUSH
105784: LD_INT 1
105786: ARRAY
105787: PPUSH
105788: CALL_OW 1
105792: ST_TO_ADDR
// attacking := true ;
105793: LD_ADDR_VAR 0 29
105797: PUSH
105798: LD_INT 1
105800: ST_TO_ADDR
// continue ;
105801: GO 103648
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
105803: LD_VAR 0 4
105807: PUSH
105808: LD_VAR 0 7
105812: ARRAY
105813: PPUSH
105814: CALL_OW 257
105818: PUSH
105819: LD_INT 17
105821: EQUAL
105822: PUSH
105823: LD_VAR 0 4
105827: PUSH
105828: LD_VAR 0 7
105832: ARRAY
105833: PPUSH
105834: CALL_OW 110
105838: PUSH
105839: LD_INT 71
105841: EQUAL
105842: NOT
105843: AND
105844: IFFALSE 105990
// begin attacking := false ;
105846: LD_ADDR_VAR 0 29
105850: PUSH
105851: LD_INT 0
105853: ST_TO_ADDR
// k := 5 ;
105854: LD_ADDR_VAR 0 9
105858: PUSH
105859: LD_INT 5
105861: ST_TO_ADDR
// if tmp < k then
105862: LD_VAR 0 14
105866: PUSH
105867: LD_VAR 0 9
105871: LESS
105872: IFFALSE 105884
// k := tmp ;
105874: LD_ADDR_VAR 0 9
105878: PUSH
105879: LD_VAR 0 14
105883: ST_TO_ADDR
// for j = 1 to k do
105884: LD_ADDR_VAR 0 8
105888: PUSH
105889: DOUBLE
105890: LD_INT 1
105892: DEC
105893: ST_TO_ADDR
105894: LD_VAR 0 9
105898: PUSH
105899: FOR_TO
105900: IFFALSE 105988
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105902: LD_VAR 0 14
105906: PUSH
105907: LD_VAR 0 8
105911: ARRAY
105912: PUSH
105913: LD_VAR 0 14
105917: PPUSH
105918: LD_INT 58
105920: PUSH
105921: EMPTY
105922: LIST
105923: PPUSH
105924: CALL_OW 72
105928: IN
105929: NOT
105930: IFFALSE 105986
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105932: LD_VAR 0 4
105936: PUSH
105937: LD_VAR 0 7
105941: ARRAY
105942: PPUSH
105943: LD_VAR 0 14
105947: PUSH
105948: LD_VAR 0 8
105952: ARRAY
105953: PPUSH
105954: CALL_OW 115
// attacking := true ;
105958: LD_ADDR_VAR 0 29
105962: PUSH
105963: LD_INT 1
105965: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105966: LD_VAR 0 4
105970: PUSH
105971: LD_VAR 0 7
105975: ARRAY
105976: PPUSH
105977: LD_INT 71
105979: PPUSH
105980: CALL_OW 109
// continue ;
105984: GO 105899
// end ; end ;
105986: GO 105899
105988: POP
105989: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105990: LD_VAR 0 4
105994: PUSH
105995: LD_VAR 0 7
105999: ARRAY
106000: PPUSH
106001: CALL_OW 257
106005: PUSH
106006: LD_INT 8
106008: EQUAL
106009: PUSH
106010: LD_VAR 0 4
106014: PUSH
106015: LD_VAR 0 7
106019: ARRAY
106020: PPUSH
106021: CALL_OW 264
106025: PUSH
106026: LD_INT 28
106028: PUSH
106029: LD_INT 45
106031: PUSH
106032: LD_INT 7
106034: PUSH
106035: LD_INT 47
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: LIST
106042: LIST
106043: IN
106044: OR
106045: IFFALSE 106301
// begin attacking := false ;
106047: LD_ADDR_VAR 0 29
106051: PUSH
106052: LD_INT 0
106054: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
106055: LD_VAR 0 14
106059: PUSH
106060: LD_INT 1
106062: ARRAY
106063: PPUSH
106064: CALL_OW 266
106068: PUSH
106069: LD_INT 32
106071: PUSH
106072: LD_INT 31
106074: PUSH
106075: LD_INT 33
106077: PUSH
106078: LD_INT 4
106080: PUSH
106081: LD_INT 5
106083: PUSH
106084: EMPTY
106085: LIST
106086: LIST
106087: LIST
106088: LIST
106089: LIST
106090: IN
106091: IFFALSE 106277
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
106093: LD_ADDR_VAR 0 9
106097: PUSH
106098: LD_VAR 0 14
106102: PUSH
106103: LD_INT 1
106105: ARRAY
106106: PPUSH
106107: CALL_OW 266
106111: PPUSH
106112: LD_VAR 0 14
106116: PUSH
106117: LD_INT 1
106119: ARRAY
106120: PPUSH
106121: CALL_OW 250
106125: PPUSH
106126: LD_VAR 0 14
106130: PUSH
106131: LD_INT 1
106133: ARRAY
106134: PPUSH
106135: CALL_OW 251
106139: PPUSH
106140: LD_VAR 0 14
106144: PUSH
106145: LD_INT 1
106147: ARRAY
106148: PPUSH
106149: CALL_OW 254
106153: PPUSH
106154: LD_VAR 0 14
106158: PUSH
106159: LD_INT 1
106161: ARRAY
106162: PPUSH
106163: CALL_OW 248
106167: PPUSH
106168: LD_INT 0
106170: PPUSH
106171: CALL 61634 0 6
106175: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
106176: LD_ADDR_VAR 0 8
106180: PUSH
106181: LD_VAR 0 4
106185: PUSH
106186: LD_VAR 0 7
106190: ARRAY
106191: PPUSH
106192: LD_VAR 0 9
106196: PPUSH
106197: CALL 80304 0 2
106201: ST_TO_ADDR
// if j then
106202: LD_VAR 0 8
106206: IFFALSE 106275
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
106208: LD_VAR 0 8
106212: PUSH
106213: LD_INT 1
106215: ARRAY
106216: PPUSH
106217: LD_VAR 0 8
106221: PUSH
106222: LD_INT 2
106224: ARRAY
106225: PPUSH
106226: CALL_OW 488
106230: IFFALSE 106275
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
106232: LD_VAR 0 4
106236: PUSH
106237: LD_VAR 0 7
106241: ARRAY
106242: PPUSH
106243: LD_VAR 0 8
106247: PUSH
106248: LD_INT 1
106250: ARRAY
106251: PPUSH
106252: LD_VAR 0 8
106256: PUSH
106257: LD_INT 2
106259: ARRAY
106260: PPUSH
106261: CALL_OW 116
// attacking := true ;
106265: LD_ADDR_VAR 0 29
106269: PUSH
106270: LD_INT 1
106272: ST_TO_ADDR
// continue ;
106273: GO 103648
// end ; end else
106275: GO 106301
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106277: LD_VAR 0 4
106281: PUSH
106282: LD_VAR 0 7
106286: ARRAY
106287: PPUSH
106288: LD_VAR 0 14
106292: PUSH
106293: LD_INT 1
106295: ARRAY
106296: PPUSH
106297: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
106301: LD_VAR 0 4
106305: PUSH
106306: LD_VAR 0 7
106310: ARRAY
106311: PPUSH
106312: CALL_OW 265
106316: PUSH
106317: LD_INT 11
106319: EQUAL
106320: IFFALSE 106598
// begin k := 10 ;
106322: LD_ADDR_VAR 0 9
106326: PUSH
106327: LD_INT 10
106329: ST_TO_ADDR
// x := 0 ;
106330: LD_ADDR_VAR 0 10
106334: PUSH
106335: LD_INT 0
106337: ST_TO_ADDR
// if tmp < k then
106338: LD_VAR 0 14
106342: PUSH
106343: LD_VAR 0 9
106347: LESS
106348: IFFALSE 106360
// k := tmp ;
106350: LD_ADDR_VAR 0 9
106354: PUSH
106355: LD_VAR 0 14
106359: ST_TO_ADDR
// for j = k downto 1 do
106360: LD_ADDR_VAR 0 8
106364: PUSH
106365: DOUBLE
106366: LD_VAR 0 9
106370: INC
106371: ST_TO_ADDR
106372: LD_INT 1
106374: PUSH
106375: FOR_DOWNTO
106376: IFFALSE 106451
// begin if GetType ( tmp [ j ] ) = unit_human then
106378: LD_VAR 0 14
106382: PUSH
106383: LD_VAR 0 8
106387: ARRAY
106388: PPUSH
106389: CALL_OW 247
106393: PUSH
106394: LD_INT 1
106396: EQUAL
106397: IFFALSE 106449
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
106399: LD_VAR 0 4
106403: PUSH
106404: LD_VAR 0 7
106408: ARRAY
106409: PPUSH
106410: LD_VAR 0 14
106414: PUSH
106415: LD_VAR 0 8
106419: ARRAY
106420: PPUSH
106421: CALL 80575 0 2
// x := tmp [ j ] ;
106425: LD_ADDR_VAR 0 10
106429: PUSH
106430: LD_VAR 0 14
106434: PUSH
106435: LD_VAR 0 8
106439: ARRAY
106440: ST_TO_ADDR
// attacking := true ;
106441: LD_ADDR_VAR 0 29
106445: PUSH
106446: LD_INT 1
106448: ST_TO_ADDR
// end ; end ;
106449: GO 106375
106451: POP
106452: POP
// if not x then
106453: LD_VAR 0 10
106457: NOT
106458: IFFALSE 106598
// begin attacking := true ;
106460: LD_ADDR_VAR 0 29
106464: PUSH
106465: LD_INT 1
106467: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
106468: LD_VAR 0 4
106472: PUSH
106473: LD_VAR 0 7
106477: ARRAY
106478: PPUSH
106479: CALL_OW 250
106483: PPUSH
106484: LD_VAR 0 4
106488: PUSH
106489: LD_VAR 0 7
106493: ARRAY
106494: PPUSH
106495: CALL_OW 251
106499: PPUSH
106500: CALL_OW 546
106504: PUSH
106505: LD_INT 2
106507: ARRAY
106508: PUSH
106509: LD_VAR 0 14
106513: PUSH
106514: LD_INT 1
106516: ARRAY
106517: PPUSH
106518: CALL_OW 250
106522: PPUSH
106523: LD_VAR 0 14
106527: PUSH
106528: LD_INT 1
106530: ARRAY
106531: PPUSH
106532: CALL_OW 251
106536: PPUSH
106537: CALL_OW 546
106541: PUSH
106542: LD_INT 2
106544: ARRAY
106545: EQUAL
106546: IFFALSE 106574
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
106548: LD_VAR 0 4
106552: PUSH
106553: LD_VAR 0 7
106557: ARRAY
106558: PPUSH
106559: LD_VAR 0 14
106563: PUSH
106564: LD_INT 1
106566: ARRAY
106567: PPUSH
106568: CALL 80575 0 2
106572: GO 106598
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106574: LD_VAR 0 4
106578: PUSH
106579: LD_VAR 0 7
106583: ARRAY
106584: PPUSH
106585: LD_VAR 0 14
106589: PUSH
106590: LD_INT 1
106592: ARRAY
106593: PPUSH
106594: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
106598: LD_VAR 0 4
106602: PUSH
106603: LD_VAR 0 7
106607: ARRAY
106608: PPUSH
106609: CALL_OW 264
106613: PUSH
106614: LD_INT 29
106616: EQUAL
106617: IFFALSE 106983
// begin if WantsToAttack ( group [ i ] ) in bombed then
106619: LD_VAR 0 4
106623: PUSH
106624: LD_VAR 0 7
106628: ARRAY
106629: PPUSH
106630: CALL_OW 319
106634: PUSH
106635: LD_VAR 0 28
106639: IN
106640: IFFALSE 106644
// continue ;
106642: GO 103648
// k := 8 ;
106644: LD_ADDR_VAR 0 9
106648: PUSH
106649: LD_INT 8
106651: ST_TO_ADDR
// x := 0 ;
106652: LD_ADDR_VAR 0 10
106656: PUSH
106657: LD_INT 0
106659: ST_TO_ADDR
// if tmp < k then
106660: LD_VAR 0 14
106664: PUSH
106665: LD_VAR 0 9
106669: LESS
106670: IFFALSE 106682
// k := tmp ;
106672: LD_ADDR_VAR 0 9
106676: PUSH
106677: LD_VAR 0 14
106681: ST_TO_ADDR
// for j = 1 to k do
106682: LD_ADDR_VAR 0 8
106686: PUSH
106687: DOUBLE
106688: LD_INT 1
106690: DEC
106691: ST_TO_ADDR
106692: LD_VAR 0 9
106696: PUSH
106697: FOR_TO
106698: IFFALSE 106830
// begin if GetType ( tmp [ j ] ) = unit_building then
106700: LD_VAR 0 14
106704: PUSH
106705: LD_VAR 0 8
106709: ARRAY
106710: PPUSH
106711: CALL_OW 247
106715: PUSH
106716: LD_INT 3
106718: EQUAL
106719: IFFALSE 106828
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
106721: LD_VAR 0 14
106725: PUSH
106726: LD_VAR 0 8
106730: ARRAY
106731: PUSH
106732: LD_VAR 0 28
106736: IN
106737: NOT
106738: PUSH
106739: LD_VAR 0 14
106743: PUSH
106744: LD_VAR 0 8
106748: ARRAY
106749: PPUSH
106750: CALL_OW 313
106754: AND
106755: IFFALSE 106828
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106757: LD_VAR 0 4
106761: PUSH
106762: LD_VAR 0 7
106766: ARRAY
106767: PPUSH
106768: LD_VAR 0 14
106772: PUSH
106773: LD_VAR 0 8
106777: ARRAY
106778: PPUSH
106779: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
106783: LD_ADDR_VAR 0 28
106787: PUSH
106788: LD_VAR 0 28
106792: PPUSH
106793: LD_VAR 0 28
106797: PUSH
106798: LD_INT 1
106800: PLUS
106801: PPUSH
106802: LD_VAR 0 14
106806: PUSH
106807: LD_VAR 0 8
106811: ARRAY
106812: PPUSH
106813: CALL_OW 1
106817: ST_TO_ADDR
// attacking := true ;
106818: LD_ADDR_VAR 0 29
106822: PUSH
106823: LD_INT 1
106825: ST_TO_ADDR
// break ;
106826: GO 106830
// end ; end ;
106828: GO 106697
106830: POP
106831: POP
// if not attacking and f_attack_depot then
106832: LD_VAR 0 29
106836: NOT
106837: PUSH
106838: LD_VAR 0 25
106842: AND
106843: IFFALSE 106938
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106845: LD_ADDR_VAR 0 13
106849: PUSH
106850: LD_VAR 0 14
106854: PPUSH
106855: LD_INT 2
106857: PUSH
106858: LD_INT 30
106860: PUSH
106861: LD_INT 0
106863: PUSH
106864: EMPTY
106865: LIST
106866: LIST
106867: PUSH
106868: LD_INT 30
106870: PUSH
106871: LD_INT 1
106873: PUSH
106874: EMPTY
106875: LIST
106876: LIST
106877: PUSH
106878: EMPTY
106879: LIST
106880: LIST
106881: LIST
106882: PPUSH
106883: CALL_OW 72
106887: ST_TO_ADDR
// if z then
106888: LD_VAR 0 13
106892: IFFALSE 106938
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106894: LD_VAR 0 4
106898: PUSH
106899: LD_VAR 0 7
106903: ARRAY
106904: PPUSH
106905: LD_VAR 0 13
106909: PPUSH
106910: LD_VAR 0 4
106914: PUSH
106915: LD_VAR 0 7
106919: ARRAY
106920: PPUSH
106921: CALL_OW 74
106925: PPUSH
106926: CALL_OW 115
// attacking := true ;
106930: LD_ADDR_VAR 0 29
106934: PUSH
106935: LD_INT 1
106937: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106938: LD_VAR 0 4
106942: PUSH
106943: LD_VAR 0 7
106947: ARRAY
106948: PPUSH
106949: CALL_OW 256
106953: PUSH
106954: LD_INT 500
106956: LESS
106957: IFFALSE 106983
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106959: LD_VAR 0 4
106963: PUSH
106964: LD_VAR 0 7
106968: ARRAY
106969: PPUSH
106970: LD_VAR 0 14
106974: PUSH
106975: LD_INT 1
106977: ARRAY
106978: PPUSH
106979: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106983: LD_VAR 0 4
106987: PUSH
106988: LD_VAR 0 7
106992: ARRAY
106993: PPUSH
106994: CALL_OW 264
106998: PUSH
106999: LD_INT 49
107001: EQUAL
107002: IFFALSE 107123
// begin if not HasTask ( group [ i ] ) then
107004: LD_VAR 0 4
107008: PUSH
107009: LD_VAR 0 7
107013: ARRAY
107014: PPUSH
107015: CALL_OW 314
107019: NOT
107020: IFFALSE 107123
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
107022: LD_ADDR_VAR 0 9
107026: PUSH
107027: LD_INT 81
107029: PUSH
107030: LD_VAR 0 4
107034: PUSH
107035: LD_VAR 0 7
107039: ARRAY
107040: PPUSH
107041: CALL_OW 255
107045: PUSH
107046: EMPTY
107047: LIST
107048: LIST
107049: PPUSH
107050: CALL_OW 69
107054: PPUSH
107055: LD_VAR 0 4
107059: PUSH
107060: LD_VAR 0 7
107064: ARRAY
107065: PPUSH
107066: CALL_OW 74
107070: ST_TO_ADDR
// if k then
107071: LD_VAR 0 9
107075: IFFALSE 107123
// if GetDistUnits ( group [ i ] , k ) > 10 then
107077: LD_VAR 0 4
107081: PUSH
107082: LD_VAR 0 7
107086: ARRAY
107087: PPUSH
107088: LD_VAR 0 9
107092: PPUSH
107093: CALL_OW 296
107097: PUSH
107098: LD_INT 10
107100: GREATER
107101: IFFALSE 107123
// ComMoveUnit ( group [ i ] , k ) ;
107103: LD_VAR 0 4
107107: PUSH
107108: LD_VAR 0 7
107112: ARRAY
107113: PPUSH
107114: LD_VAR 0 9
107118: PPUSH
107119: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
107123: LD_VAR 0 4
107127: PUSH
107128: LD_VAR 0 7
107132: ARRAY
107133: PPUSH
107134: CALL_OW 256
107138: PUSH
107139: LD_INT 250
107141: LESS
107142: PUSH
107143: LD_VAR 0 4
107147: PUSH
107148: LD_VAR 0 7
107152: ARRAY
107153: PUSH
107154: LD_INT 21
107156: PUSH
107157: LD_INT 2
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: PUSH
107164: LD_INT 23
107166: PUSH
107167: LD_INT 2
107169: PUSH
107170: EMPTY
107171: LIST
107172: LIST
107173: PUSH
107174: EMPTY
107175: LIST
107176: LIST
107177: PPUSH
107178: CALL_OW 69
107182: IN
107183: AND
107184: IFFALSE 107309
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
107186: LD_ADDR_VAR 0 9
107190: PUSH
107191: LD_OWVAR 3
107195: PUSH
107196: LD_VAR 0 4
107200: PUSH
107201: LD_VAR 0 7
107205: ARRAY
107206: DIFF
107207: PPUSH
107208: LD_VAR 0 4
107212: PUSH
107213: LD_VAR 0 7
107217: ARRAY
107218: PPUSH
107219: CALL_OW 74
107223: ST_TO_ADDR
// if not k then
107224: LD_VAR 0 9
107228: NOT
107229: IFFALSE 107233
// continue ;
107231: GO 103648
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
107233: LD_VAR 0 9
107237: PUSH
107238: LD_INT 81
107240: PUSH
107241: LD_VAR 0 4
107245: PUSH
107246: LD_VAR 0 7
107250: ARRAY
107251: PPUSH
107252: CALL_OW 255
107256: PUSH
107257: EMPTY
107258: LIST
107259: LIST
107260: PPUSH
107261: CALL_OW 69
107265: IN
107266: PUSH
107267: LD_VAR 0 9
107271: PPUSH
107272: LD_VAR 0 4
107276: PUSH
107277: LD_VAR 0 7
107281: ARRAY
107282: PPUSH
107283: CALL_OW 296
107287: PUSH
107288: LD_INT 5
107290: LESS
107291: AND
107292: IFFALSE 107309
// ComAutodestruct ( group [ i ] ) ;
107294: LD_VAR 0 4
107298: PUSH
107299: LD_VAR 0 7
107303: ARRAY
107304: PPUSH
107305: CALL 80473 0 1
// end ; if f_attack_depot then
107309: LD_VAR 0 25
107313: IFFALSE 107425
// begin k := 6 ;
107315: LD_ADDR_VAR 0 9
107319: PUSH
107320: LD_INT 6
107322: ST_TO_ADDR
// if tmp < k then
107323: LD_VAR 0 14
107327: PUSH
107328: LD_VAR 0 9
107332: LESS
107333: IFFALSE 107345
// k := tmp ;
107335: LD_ADDR_VAR 0 9
107339: PUSH
107340: LD_VAR 0 14
107344: ST_TO_ADDR
// for j = 1 to k do
107345: LD_ADDR_VAR 0 8
107349: PUSH
107350: DOUBLE
107351: LD_INT 1
107353: DEC
107354: ST_TO_ADDR
107355: LD_VAR 0 9
107359: PUSH
107360: FOR_TO
107361: IFFALSE 107423
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
107363: LD_VAR 0 8
107367: PPUSH
107368: CALL_OW 266
107372: PUSH
107373: LD_INT 0
107375: PUSH
107376: LD_INT 1
107378: PUSH
107379: EMPTY
107380: LIST
107381: LIST
107382: IN
107383: IFFALSE 107421
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107385: LD_VAR 0 4
107389: PUSH
107390: LD_VAR 0 7
107394: ARRAY
107395: PPUSH
107396: LD_VAR 0 14
107400: PUSH
107401: LD_VAR 0 8
107405: ARRAY
107406: PPUSH
107407: CALL_OW 115
// attacking := true ;
107411: LD_ADDR_VAR 0 29
107415: PUSH
107416: LD_INT 1
107418: ST_TO_ADDR
// break ;
107419: GO 107423
// end ;
107421: GO 107360
107423: POP
107424: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
107425: LD_VAR 0 4
107429: PUSH
107430: LD_VAR 0 7
107434: ARRAY
107435: PPUSH
107436: CALL_OW 302
107440: PUSH
107441: LD_VAR 0 29
107445: NOT
107446: AND
107447: IFFALSE 107769
// begin if GetTag ( group [ i ] ) = 71 then
107449: LD_VAR 0 4
107453: PUSH
107454: LD_VAR 0 7
107458: ARRAY
107459: PPUSH
107460: CALL_OW 110
107464: PUSH
107465: LD_INT 71
107467: EQUAL
107468: IFFALSE 107509
// begin if HasTask ( group [ i ] ) then
107470: LD_VAR 0 4
107474: PUSH
107475: LD_VAR 0 7
107479: ARRAY
107480: PPUSH
107481: CALL_OW 314
107485: IFFALSE 107491
// continue else
107487: GO 103648
107489: GO 107509
// SetTag ( group [ i ] , 0 ) ;
107491: LD_VAR 0 4
107495: PUSH
107496: LD_VAR 0 7
107500: ARRAY
107501: PPUSH
107502: LD_INT 0
107504: PPUSH
107505: CALL_OW 109
// end ; k := 8 ;
107509: LD_ADDR_VAR 0 9
107513: PUSH
107514: LD_INT 8
107516: ST_TO_ADDR
// x := 0 ;
107517: LD_ADDR_VAR 0 10
107521: PUSH
107522: LD_INT 0
107524: ST_TO_ADDR
// if tmp < k then
107525: LD_VAR 0 14
107529: PUSH
107530: LD_VAR 0 9
107534: LESS
107535: IFFALSE 107547
// k := tmp ;
107537: LD_ADDR_VAR 0 9
107541: PUSH
107542: LD_VAR 0 14
107546: ST_TO_ADDR
// for j = 1 to k do
107547: LD_ADDR_VAR 0 8
107551: PUSH
107552: DOUBLE
107553: LD_INT 1
107555: DEC
107556: ST_TO_ADDR
107557: LD_VAR 0 9
107561: PUSH
107562: FOR_TO
107563: IFFALSE 107661
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
107565: LD_VAR 0 14
107569: PUSH
107570: LD_VAR 0 8
107574: ARRAY
107575: PPUSH
107576: CALL_OW 247
107580: PUSH
107581: LD_INT 1
107583: EQUAL
107584: PUSH
107585: LD_VAR 0 14
107589: PUSH
107590: LD_VAR 0 8
107594: ARRAY
107595: PPUSH
107596: CALL_OW 256
107600: PUSH
107601: LD_INT 250
107603: LESS
107604: PUSH
107605: LD_VAR 0 20
107609: AND
107610: PUSH
107611: LD_VAR 0 20
107615: NOT
107616: PUSH
107617: LD_VAR 0 14
107621: PUSH
107622: LD_VAR 0 8
107626: ARRAY
107627: PPUSH
107628: CALL_OW 256
107632: PUSH
107633: LD_INT 250
107635: GREATEREQUAL
107636: AND
107637: OR
107638: AND
107639: IFFALSE 107659
// begin x := tmp [ j ] ;
107641: LD_ADDR_VAR 0 10
107645: PUSH
107646: LD_VAR 0 14
107650: PUSH
107651: LD_VAR 0 8
107655: ARRAY
107656: ST_TO_ADDR
// break ;
107657: GO 107661
// end ;
107659: GO 107562
107661: POP
107662: POP
// if x then
107663: LD_VAR 0 10
107667: IFFALSE 107691
// ComAttackUnit ( group [ i ] , x ) else
107669: LD_VAR 0 4
107673: PUSH
107674: LD_VAR 0 7
107678: ARRAY
107679: PPUSH
107680: LD_VAR 0 10
107684: PPUSH
107685: CALL_OW 115
107689: GO 107715
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107691: LD_VAR 0 4
107695: PUSH
107696: LD_VAR 0 7
107700: ARRAY
107701: PPUSH
107702: LD_VAR 0 14
107706: PUSH
107707: LD_INT 1
107709: ARRAY
107710: PPUSH
107711: CALL_OW 115
// if not HasTask ( group [ i ] ) then
107715: LD_VAR 0 4
107719: PUSH
107720: LD_VAR 0 7
107724: ARRAY
107725: PPUSH
107726: CALL_OW 314
107730: NOT
107731: IFFALSE 107769
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
107733: LD_VAR 0 4
107737: PUSH
107738: LD_VAR 0 7
107742: ARRAY
107743: PPUSH
107744: LD_VAR 0 14
107748: PPUSH
107749: LD_VAR 0 4
107753: PUSH
107754: LD_VAR 0 7
107758: ARRAY
107759: PPUSH
107760: CALL_OW 74
107764: PPUSH
107765: CALL_OW 115
// end ; end ; end ;
107769: GO 103648
107771: POP
107772: POP
// wait ( 0 0$2 ) ;
107773: LD_INT 70
107775: PPUSH
107776: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
107780: LD_VAR 0 4
107784: NOT
107785: PUSH
107786: LD_VAR 0 4
107790: PUSH
107791: EMPTY
107792: EQUAL
107793: OR
107794: PUSH
107795: LD_INT 81
107797: PUSH
107798: LD_VAR 0 35
107802: PUSH
107803: EMPTY
107804: LIST
107805: LIST
107806: PPUSH
107807: CALL_OW 69
107811: NOT
107812: OR
107813: IFFALSE 103633
// end ;
107815: LD_VAR 0 2
107819: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
107820: LD_INT 0
107822: PPUSH
107823: PPUSH
107824: PPUSH
107825: PPUSH
107826: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
107827: LD_VAR 0 1
107831: NOT
107832: PUSH
107833: LD_EXP 50
107837: PUSH
107838: LD_VAR 0 1
107842: ARRAY
107843: NOT
107844: OR
107845: PUSH
107846: LD_VAR 0 2
107850: NOT
107851: OR
107852: PUSH
107853: LD_VAR 0 3
107857: NOT
107858: OR
107859: IFFALSE 107863
// exit ;
107861: GO 108376
// side := mc_sides [ base ] ;
107863: LD_ADDR_VAR 0 6
107867: PUSH
107868: LD_EXP 76
107872: PUSH
107873: LD_VAR 0 1
107877: ARRAY
107878: ST_TO_ADDR
// if not side then
107879: LD_VAR 0 6
107883: NOT
107884: IFFALSE 107888
// exit ;
107886: GO 108376
// for i in solds do
107888: LD_ADDR_VAR 0 7
107892: PUSH
107893: LD_VAR 0 2
107897: PUSH
107898: FOR_IN
107899: IFFALSE 107960
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107901: LD_VAR 0 7
107905: PPUSH
107906: CALL_OW 310
107910: PPUSH
107911: CALL_OW 266
107915: PUSH
107916: LD_INT 32
107918: PUSH
107919: LD_INT 31
107921: PUSH
107922: EMPTY
107923: LIST
107924: LIST
107925: IN
107926: IFFALSE 107946
// solds := solds diff i else
107928: LD_ADDR_VAR 0 2
107932: PUSH
107933: LD_VAR 0 2
107937: PUSH
107938: LD_VAR 0 7
107942: DIFF
107943: ST_TO_ADDR
107944: GO 107958
// SetTag ( i , 18 ) ;
107946: LD_VAR 0 7
107950: PPUSH
107951: LD_INT 18
107953: PPUSH
107954: CALL_OW 109
107958: GO 107898
107960: POP
107961: POP
// if not solds then
107962: LD_VAR 0 2
107966: NOT
107967: IFFALSE 107971
// exit ;
107969: GO 108376
// repeat wait ( 0 0$2 ) ;
107971: LD_INT 70
107973: PPUSH
107974: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
107978: LD_ADDR_VAR 0 5
107982: PUSH
107983: LD_VAR 0 6
107987: PPUSH
107988: LD_VAR 0 3
107992: PPUSH
107993: CALL 49855 0 2
107997: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107998: LD_EXP 50
108002: PUSH
108003: LD_VAR 0 1
108007: ARRAY
108008: NOT
108009: PUSH
108010: LD_EXP 50
108014: PUSH
108015: LD_VAR 0 1
108019: ARRAY
108020: PUSH
108021: EMPTY
108022: EQUAL
108023: OR
108024: IFFALSE 108061
// begin for i in solds do
108026: LD_ADDR_VAR 0 7
108030: PUSH
108031: LD_VAR 0 2
108035: PUSH
108036: FOR_IN
108037: IFFALSE 108050
// ComStop ( i ) ;
108039: LD_VAR 0 7
108043: PPUSH
108044: CALL_OW 141
108048: GO 108036
108050: POP
108051: POP
// solds := [ ] ;
108052: LD_ADDR_VAR 0 2
108056: PUSH
108057: EMPTY
108058: ST_TO_ADDR
// exit ;
108059: GO 108376
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
108061: LD_VAR 0 5
108065: NOT
108066: PUSH
108067: LD_VAR 0 5
108071: PUSH
108072: LD_INT 3
108074: GREATER
108075: OR
108076: PUSH
108077: LD_EXP 72
108081: PUSH
108082: LD_VAR 0 1
108086: ARRAY
108087: OR
108088: IFFALSE 108129
// begin for i in solds do
108090: LD_ADDR_VAR 0 7
108094: PUSH
108095: LD_VAR 0 2
108099: PUSH
108100: FOR_IN
108101: IFFALSE 108125
// if HasTask ( i ) then
108103: LD_VAR 0 7
108107: PPUSH
108108: CALL_OW 314
108112: IFFALSE 108123
// ComStop ( i ) ;
108114: LD_VAR 0 7
108118: PPUSH
108119: CALL_OW 141
108123: GO 108100
108125: POP
108126: POP
// break ;
108127: GO 108364
// end ; for i in solds do
108129: LD_ADDR_VAR 0 7
108133: PUSH
108134: LD_VAR 0 2
108138: PUSH
108139: FOR_IN
108140: IFFALSE 108356
// begin if IsInUnit ( i ) then
108142: LD_VAR 0 7
108146: PPUSH
108147: CALL_OW 310
108151: IFFALSE 108162
// ComExitBuilding ( i ) ;
108153: LD_VAR 0 7
108157: PPUSH
108158: CALL_OW 122
// if GetLives ( i ) > 333 then
108162: LD_VAR 0 7
108166: PPUSH
108167: CALL_OW 256
108171: PUSH
108172: LD_INT 333
108174: GREATER
108175: IFFALSE 108203
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108177: LD_VAR 0 7
108181: PPUSH
108182: LD_VAR 0 5
108186: PPUSH
108187: LD_VAR 0 7
108191: PPUSH
108192: CALL_OW 74
108196: PPUSH
108197: CALL_OW 115
108201: GO 108354
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
108203: LD_ADDR_VAR 0 8
108207: PUSH
108208: LD_EXP 50
108212: PUSH
108213: LD_VAR 0 1
108217: ARRAY
108218: PPUSH
108219: LD_INT 2
108221: PUSH
108222: LD_INT 30
108224: PUSH
108225: LD_INT 0
108227: PUSH
108228: EMPTY
108229: LIST
108230: LIST
108231: PUSH
108232: LD_INT 30
108234: PUSH
108235: LD_INT 1
108237: PUSH
108238: EMPTY
108239: LIST
108240: LIST
108241: PUSH
108242: LD_INT 30
108244: PUSH
108245: LD_INT 6
108247: PUSH
108248: EMPTY
108249: LIST
108250: LIST
108251: PUSH
108252: EMPTY
108253: LIST
108254: LIST
108255: LIST
108256: LIST
108257: PPUSH
108258: CALL_OW 72
108262: PPUSH
108263: LD_VAR 0 7
108267: PPUSH
108268: CALL_OW 74
108272: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
108273: LD_VAR 0 7
108277: PPUSH
108278: LD_VAR 0 8
108282: PPUSH
108283: CALL_OW 250
108287: PPUSH
108288: LD_INT 3
108290: PPUSH
108291: LD_INT 5
108293: PPUSH
108294: CALL_OW 272
108298: PPUSH
108299: LD_VAR 0 8
108303: PPUSH
108304: CALL_OW 251
108308: PPUSH
108309: LD_INT 3
108311: PPUSH
108312: LD_INT 5
108314: PPUSH
108315: CALL_OW 273
108319: PPUSH
108320: CALL_OW 111
// SetTag ( i , 0 ) ;
108324: LD_VAR 0 7
108328: PPUSH
108329: LD_INT 0
108331: PPUSH
108332: CALL_OW 109
// solds := solds diff i ;
108336: LD_ADDR_VAR 0 2
108340: PUSH
108341: LD_VAR 0 2
108345: PUSH
108346: LD_VAR 0 7
108350: DIFF
108351: ST_TO_ADDR
// continue ;
108352: GO 108139
// end ; end ;
108354: GO 108139
108356: POP
108357: POP
// until solds ;
108358: LD_VAR 0 2
108362: IFFALSE 107971
// MC_Reset ( base , 18 ) ;
108364: LD_VAR 0 1
108368: PPUSH
108369: LD_INT 18
108371: PPUSH
108372: CALL 21980 0 2
// end ;
108376: LD_VAR 0 4
108380: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
108381: LD_INT 0
108383: PPUSH
108384: PPUSH
108385: PPUSH
108386: PPUSH
108387: PPUSH
108388: PPUSH
108389: PPUSH
108390: PPUSH
108391: PPUSH
108392: PPUSH
108393: PPUSH
108394: PPUSH
108395: PPUSH
108396: PPUSH
108397: PPUSH
108398: PPUSH
108399: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
108400: LD_ADDR_VAR 0 13
108404: PUSH
108405: LD_EXP 50
108409: PUSH
108410: LD_VAR 0 1
108414: ARRAY
108415: PPUSH
108416: LD_INT 25
108418: PUSH
108419: LD_INT 3
108421: PUSH
108422: EMPTY
108423: LIST
108424: LIST
108425: PPUSH
108426: CALL_OW 72
108430: ST_TO_ADDR
// if mc_remote_driver [ base ] then
108431: LD_EXP 90
108435: PUSH
108436: LD_VAR 0 1
108440: ARRAY
108441: IFFALSE 108465
// mechs := mechs diff mc_remote_driver [ base ] ;
108443: LD_ADDR_VAR 0 13
108447: PUSH
108448: LD_VAR 0 13
108452: PUSH
108453: LD_EXP 90
108457: PUSH
108458: LD_VAR 0 1
108462: ARRAY
108463: DIFF
108464: ST_TO_ADDR
// for i in mechs do
108465: LD_ADDR_VAR 0 5
108469: PUSH
108470: LD_VAR 0 13
108474: PUSH
108475: FOR_IN
108476: IFFALSE 108511
// if GetTag ( i ) > 0 then
108478: LD_VAR 0 5
108482: PPUSH
108483: CALL_OW 110
108487: PUSH
108488: LD_INT 0
108490: GREATER
108491: IFFALSE 108509
// mechs := mechs diff i ;
108493: LD_ADDR_VAR 0 13
108497: PUSH
108498: LD_VAR 0 13
108502: PUSH
108503: LD_VAR 0 5
108507: DIFF
108508: ST_TO_ADDR
108509: GO 108475
108511: POP
108512: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108513: LD_ADDR_VAR 0 9
108517: PUSH
108518: LD_EXP 50
108522: PUSH
108523: LD_VAR 0 1
108527: ARRAY
108528: PPUSH
108529: LD_INT 2
108531: PUSH
108532: LD_INT 25
108534: PUSH
108535: LD_INT 1
108537: PUSH
108538: EMPTY
108539: LIST
108540: LIST
108541: PUSH
108542: LD_INT 25
108544: PUSH
108545: LD_INT 5
108547: PUSH
108548: EMPTY
108549: LIST
108550: LIST
108551: PUSH
108552: LD_INT 25
108554: PUSH
108555: LD_INT 8
108557: PUSH
108558: EMPTY
108559: LIST
108560: LIST
108561: PUSH
108562: LD_INT 25
108564: PUSH
108565: LD_INT 9
108567: PUSH
108568: EMPTY
108569: LIST
108570: LIST
108571: PUSH
108572: EMPTY
108573: LIST
108574: LIST
108575: LIST
108576: LIST
108577: LIST
108578: PPUSH
108579: CALL_OW 72
108583: ST_TO_ADDR
// if not defenders and not solds then
108584: LD_VAR 0 2
108588: NOT
108589: PUSH
108590: LD_VAR 0 9
108594: NOT
108595: AND
108596: IFFALSE 108600
// exit ;
108598: GO 110290
// depot_under_attack := false ;
108600: LD_ADDR_VAR 0 17
108604: PUSH
108605: LD_INT 0
108607: ST_TO_ADDR
// sold_defenders := [ ] ;
108608: LD_ADDR_VAR 0 18
108612: PUSH
108613: EMPTY
108614: ST_TO_ADDR
// if mechs then
108615: LD_VAR 0 13
108619: IFFALSE 108772
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
108621: LD_ADDR_VAR 0 5
108625: PUSH
108626: LD_VAR 0 2
108630: PPUSH
108631: LD_INT 21
108633: PUSH
108634: LD_INT 2
108636: PUSH
108637: EMPTY
108638: LIST
108639: LIST
108640: PPUSH
108641: CALL_OW 72
108645: PUSH
108646: FOR_IN
108647: IFFALSE 108770
// begin if GetTag ( i ) <> 20 then
108649: LD_VAR 0 5
108653: PPUSH
108654: CALL_OW 110
108658: PUSH
108659: LD_INT 20
108661: NONEQUAL
108662: IFFALSE 108676
// SetTag ( i , 20 ) ;
108664: LD_VAR 0 5
108668: PPUSH
108669: LD_INT 20
108671: PPUSH
108672: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
108676: LD_VAR 0 5
108680: PPUSH
108681: CALL_OW 263
108685: PUSH
108686: LD_INT 1
108688: EQUAL
108689: PUSH
108690: LD_VAR 0 5
108694: PPUSH
108695: CALL_OW 311
108699: NOT
108700: AND
108701: IFFALSE 108768
// begin un := mechs [ 1 ] ;
108703: LD_ADDR_VAR 0 11
108707: PUSH
108708: LD_VAR 0 13
108712: PUSH
108713: LD_INT 1
108715: ARRAY
108716: ST_TO_ADDR
// ComExit ( un ) ;
108717: LD_VAR 0 11
108721: PPUSH
108722: CALL 84818 0 1
// AddComEnterUnit ( un , i ) ;
108726: LD_VAR 0 11
108730: PPUSH
108731: LD_VAR 0 5
108735: PPUSH
108736: CALL_OW 180
// SetTag ( un , 19 ) ;
108740: LD_VAR 0 11
108744: PPUSH
108745: LD_INT 19
108747: PPUSH
108748: CALL_OW 109
// mechs := mechs diff un ;
108752: LD_ADDR_VAR 0 13
108756: PUSH
108757: LD_VAR 0 13
108761: PUSH
108762: LD_VAR 0 11
108766: DIFF
108767: ST_TO_ADDR
// end ; end ;
108768: GO 108646
108770: POP
108771: POP
// if solds then
108772: LD_VAR 0 9
108776: IFFALSE 108835
// for i in solds do
108778: LD_ADDR_VAR 0 5
108782: PUSH
108783: LD_VAR 0 9
108787: PUSH
108788: FOR_IN
108789: IFFALSE 108833
// if not GetTag ( i ) then
108791: LD_VAR 0 5
108795: PPUSH
108796: CALL_OW 110
108800: NOT
108801: IFFALSE 108831
// begin defenders := defenders union i ;
108803: LD_ADDR_VAR 0 2
108807: PUSH
108808: LD_VAR 0 2
108812: PUSH
108813: LD_VAR 0 5
108817: UNION
108818: ST_TO_ADDR
// SetTag ( i , 18 ) ;
108819: LD_VAR 0 5
108823: PPUSH
108824: LD_INT 18
108826: PPUSH
108827: CALL_OW 109
// end ;
108831: GO 108788
108833: POP
108834: POP
// repeat wait ( 0 0$2 ) ;
108835: LD_INT 70
108837: PPUSH
108838: CALL_OW 67
// enemy := mc_scan [ base ] ;
108842: LD_ADDR_VAR 0 3
108846: PUSH
108847: LD_EXP 73
108851: PUSH
108852: LD_VAR 0 1
108856: ARRAY
108857: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108858: LD_EXP 50
108862: PUSH
108863: LD_VAR 0 1
108867: ARRAY
108868: NOT
108869: PUSH
108870: LD_EXP 50
108874: PUSH
108875: LD_VAR 0 1
108879: ARRAY
108880: PUSH
108881: EMPTY
108882: EQUAL
108883: OR
108884: IFFALSE 108921
// begin for i in defenders do
108886: LD_ADDR_VAR 0 5
108890: PUSH
108891: LD_VAR 0 2
108895: PUSH
108896: FOR_IN
108897: IFFALSE 108910
// ComStop ( i ) ;
108899: LD_VAR 0 5
108903: PPUSH
108904: CALL_OW 141
108908: GO 108896
108910: POP
108911: POP
// defenders := [ ] ;
108912: LD_ADDR_VAR 0 2
108916: PUSH
108917: EMPTY
108918: ST_TO_ADDR
// exit ;
108919: GO 110290
// end ; for i in defenders do
108921: LD_ADDR_VAR 0 5
108925: PUSH
108926: LD_VAR 0 2
108930: PUSH
108931: FOR_IN
108932: IFFALSE 109750
// begin e := NearestUnitToUnit ( enemy , i ) ;
108934: LD_ADDR_VAR 0 14
108938: PUSH
108939: LD_VAR 0 3
108943: PPUSH
108944: LD_VAR 0 5
108948: PPUSH
108949: CALL_OW 74
108953: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108954: LD_ADDR_VAR 0 8
108958: PUSH
108959: LD_EXP 50
108963: PUSH
108964: LD_VAR 0 1
108968: ARRAY
108969: PPUSH
108970: LD_INT 2
108972: PUSH
108973: LD_INT 30
108975: PUSH
108976: LD_INT 0
108978: PUSH
108979: EMPTY
108980: LIST
108981: LIST
108982: PUSH
108983: LD_INT 30
108985: PUSH
108986: LD_INT 1
108988: PUSH
108989: EMPTY
108990: LIST
108991: LIST
108992: PUSH
108993: EMPTY
108994: LIST
108995: LIST
108996: LIST
108997: PPUSH
108998: CALL_OW 72
109002: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
109003: LD_ADDR_VAR 0 17
109007: PUSH
109008: LD_VAR 0 8
109012: NOT
109013: PUSH
109014: LD_VAR 0 8
109018: PPUSH
109019: LD_INT 3
109021: PUSH
109022: LD_INT 24
109024: PUSH
109025: LD_INT 600
109027: PUSH
109028: EMPTY
109029: LIST
109030: LIST
109031: PUSH
109032: EMPTY
109033: LIST
109034: LIST
109035: PPUSH
109036: CALL_OW 72
109040: OR
109041: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
109042: LD_VAR 0 5
109046: PPUSH
109047: CALL_OW 247
109051: PUSH
109052: LD_INT 2
109054: DOUBLE
109055: EQUAL
109056: IFTRUE 109060
109058: GO 109456
109060: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
109061: LD_VAR 0 5
109065: PPUSH
109066: CALL_OW 256
109070: PUSH
109071: LD_INT 1000
109073: EQUAL
109074: PUSH
109075: LD_VAR 0 5
109079: PPUSH
109080: LD_VAR 0 14
109084: PPUSH
109085: CALL_OW 296
109089: PUSH
109090: LD_INT 40
109092: LESS
109093: PUSH
109094: LD_VAR 0 14
109098: PPUSH
109099: LD_EXP 75
109103: PUSH
109104: LD_VAR 0 1
109108: ARRAY
109109: PPUSH
109110: CALL_OW 308
109114: OR
109115: AND
109116: IFFALSE 109238
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
109118: LD_VAR 0 5
109122: PPUSH
109123: CALL_OW 262
109127: PUSH
109128: LD_INT 1
109130: EQUAL
109131: PUSH
109132: LD_VAR 0 5
109136: PPUSH
109137: CALL_OW 261
109141: PUSH
109142: LD_INT 30
109144: LESS
109145: AND
109146: PUSH
109147: LD_VAR 0 8
109151: AND
109152: IFFALSE 109222
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
109154: LD_VAR 0 5
109158: PPUSH
109159: LD_VAR 0 8
109163: PPUSH
109164: LD_VAR 0 5
109168: PPUSH
109169: CALL_OW 74
109173: PPUSH
109174: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
109178: LD_VAR 0 5
109182: PPUSH
109183: LD_VAR 0 8
109187: PPUSH
109188: LD_VAR 0 5
109192: PPUSH
109193: CALL_OW 74
109197: PPUSH
109198: CALL_OW 296
109202: PUSH
109203: LD_INT 6
109205: LESS
109206: IFFALSE 109220
// SetFuel ( i , 100 ) ;
109208: LD_VAR 0 5
109212: PPUSH
109213: LD_INT 100
109215: PPUSH
109216: CALL_OW 240
// end else
109220: GO 109236
// ComAttackUnit ( i , e ) ;
109222: LD_VAR 0 5
109226: PPUSH
109227: LD_VAR 0 14
109231: PPUSH
109232: CALL_OW 115
// end else
109236: GO 109339
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
109238: LD_VAR 0 14
109242: PPUSH
109243: LD_EXP 75
109247: PUSH
109248: LD_VAR 0 1
109252: ARRAY
109253: PPUSH
109254: CALL_OW 308
109258: NOT
109259: PUSH
109260: LD_VAR 0 5
109264: PPUSH
109265: LD_VAR 0 14
109269: PPUSH
109270: CALL_OW 296
109274: PUSH
109275: LD_INT 40
109277: GREATEREQUAL
109278: AND
109279: PUSH
109280: LD_VAR 0 5
109284: PPUSH
109285: CALL_OW 256
109289: PUSH
109290: LD_INT 650
109292: LESSEQUAL
109293: OR
109294: PUSH
109295: LD_VAR 0 5
109299: PPUSH
109300: LD_EXP 74
109304: PUSH
109305: LD_VAR 0 1
109309: ARRAY
109310: PPUSH
109311: CALL_OW 308
109315: NOT
109316: AND
109317: IFFALSE 109339
// ComMoveToArea ( i , mc_parking [ base ] ) ;
109319: LD_VAR 0 5
109323: PPUSH
109324: LD_EXP 74
109328: PUSH
109329: LD_VAR 0 1
109333: ARRAY
109334: PPUSH
109335: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
109339: LD_VAR 0 5
109343: PPUSH
109344: CALL_OW 256
109348: PUSH
109349: LD_INT 1000
109351: LESS
109352: PUSH
109353: LD_VAR 0 5
109357: PPUSH
109358: CALL_OW 263
109362: PUSH
109363: LD_INT 1
109365: EQUAL
109366: AND
109367: PUSH
109368: LD_VAR 0 5
109372: PPUSH
109373: CALL_OW 311
109377: AND
109378: PUSH
109379: LD_VAR 0 5
109383: PPUSH
109384: LD_EXP 74
109388: PUSH
109389: LD_VAR 0 1
109393: ARRAY
109394: PPUSH
109395: CALL_OW 308
109399: AND
109400: IFFALSE 109454
// begin mech := IsDrivenBy ( i ) ;
109402: LD_ADDR_VAR 0 10
109406: PUSH
109407: LD_VAR 0 5
109411: PPUSH
109412: CALL_OW 311
109416: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
109417: LD_VAR 0 10
109421: PPUSH
109422: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
109426: LD_VAR 0 10
109430: PPUSH
109431: LD_VAR 0 5
109435: PPUSH
109436: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
109440: LD_VAR 0 10
109444: PPUSH
109445: LD_VAR 0 5
109449: PPUSH
109450: CALL_OW 180
// end ; end ; unit_human :
109454: GO 109721
109456: LD_INT 1
109458: DOUBLE
109459: EQUAL
109460: IFTRUE 109464
109462: GO 109720
109464: POP
// begin b := IsInUnit ( i ) ;
109465: LD_ADDR_VAR 0 19
109469: PUSH
109470: LD_VAR 0 5
109474: PPUSH
109475: CALL_OW 310
109479: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
109480: LD_ADDR_VAR 0 20
109484: PUSH
109485: LD_VAR 0 19
109489: NOT
109490: PUSH
109491: LD_VAR 0 19
109495: PPUSH
109496: CALL_OW 266
109500: PUSH
109501: LD_INT 32
109503: PUSH
109504: LD_INT 31
109506: PUSH
109507: EMPTY
109508: LIST
109509: LIST
109510: IN
109511: OR
109512: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
109513: LD_VAR 0 17
109517: PUSH
109518: LD_VAR 0 2
109522: PPUSH
109523: LD_INT 21
109525: PUSH
109526: LD_INT 2
109528: PUSH
109529: EMPTY
109530: LIST
109531: LIST
109532: PPUSH
109533: CALL_OW 72
109537: PUSH
109538: LD_INT 1
109540: LESSEQUAL
109541: OR
109542: PUSH
109543: LD_VAR 0 20
109547: AND
109548: PUSH
109549: LD_VAR 0 5
109553: PUSH
109554: LD_VAR 0 18
109558: IN
109559: NOT
109560: AND
109561: IFFALSE 109654
// begin if b then
109563: LD_VAR 0 19
109567: IFFALSE 109616
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
109569: LD_VAR 0 19
109573: PPUSH
109574: LD_VAR 0 3
109578: PPUSH
109579: LD_VAR 0 19
109583: PPUSH
109584: CALL_OW 74
109588: PPUSH
109589: CALL_OW 296
109593: PUSH
109594: LD_INT 10
109596: LESS
109597: PUSH
109598: LD_VAR 0 19
109602: PPUSH
109603: CALL_OW 461
109607: PUSH
109608: LD_INT 7
109610: NONEQUAL
109611: AND
109612: IFFALSE 109616
// continue ;
109614: GO 108931
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
109616: LD_ADDR_VAR 0 18
109620: PUSH
109621: LD_VAR 0 18
109625: PPUSH
109626: LD_VAR 0 18
109630: PUSH
109631: LD_INT 1
109633: PLUS
109634: PPUSH
109635: LD_VAR 0 5
109639: PPUSH
109640: CALL_OW 1
109644: ST_TO_ADDR
// ComExitBuilding ( i ) ;
109645: LD_VAR 0 5
109649: PPUSH
109650: CALL_OW 122
// end ; if sold_defenders then
109654: LD_VAR 0 18
109658: IFFALSE 109718
// if i in sold_defenders then
109660: LD_VAR 0 5
109664: PUSH
109665: LD_VAR 0 18
109669: IN
109670: IFFALSE 109718
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
109672: LD_VAR 0 5
109676: PPUSH
109677: CALL_OW 314
109681: NOT
109682: PUSH
109683: LD_VAR 0 5
109687: PPUSH
109688: LD_VAR 0 14
109692: PPUSH
109693: CALL_OW 296
109697: PUSH
109698: LD_INT 30
109700: LESS
109701: AND
109702: IFFALSE 109718
// ComAttackUnit ( i , e ) ;
109704: LD_VAR 0 5
109708: PPUSH
109709: LD_VAR 0 14
109713: PPUSH
109714: CALL_OW 115
// end ; end ; end ;
109718: GO 109721
109720: POP
// if IsDead ( i ) then
109721: LD_VAR 0 5
109725: PPUSH
109726: CALL_OW 301
109730: IFFALSE 109748
// defenders := defenders diff i ;
109732: LD_ADDR_VAR 0 2
109736: PUSH
109737: LD_VAR 0 2
109741: PUSH
109742: LD_VAR 0 5
109746: DIFF
109747: ST_TO_ADDR
// end ;
109748: GO 108931
109750: POP
109751: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
109752: LD_VAR 0 3
109756: NOT
109757: PUSH
109758: LD_VAR 0 2
109762: NOT
109763: OR
109764: PUSH
109765: LD_EXP 50
109769: PUSH
109770: LD_VAR 0 1
109774: ARRAY
109775: NOT
109776: OR
109777: IFFALSE 108835
// MC_Reset ( base , 18 ) ;
109779: LD_VAR 0 1
109783: PPUSH
109784: LD_INT 18
109786: PPUSH
109787: CALL 21980 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109791: LD_ADDR_VAR 0 2
109795: PUSH
109796: LD_VAR 0 2
109800: PUSH
109801: LD_VAR 0 2
109805: PPUSH
109806: LD_INT 2
109808: PUSH
109809: LD_INT 25
109811: PUSH
109812: LD_INT 1
109814: PUSH
109815: EMPTY
109816: LIST
109817: LIST
109818: PUSH
109819: LD_INT 25
109821: PUSH
109822: LD_INT 5
109824: PUSH
109825: EMPTY
109826: LIST
109827: LIST
109828: PUSH
109829: LD_INT 25
109831: PUSH
109832: LD_INT 8
109834: PUSH
109835: EMPTY
109836: LIST
109837: LIST
109838: PUSH
109839: LD_INT 25
109841: PUSH
109842: LD_INT 9
109844: PUSH
109845: EMPTY
109846: LIST
109847: LIST
109848: PUSH
109849: EMPTY
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: PPUSH
109856: CALL_OW 72
109860: DIFF
109861: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
109862: LD_VAR 0 3
109866: NOT
109867: PUSH
109868: LD_VAR 0 2
109872: PPUSH
109873: LD_INT 21
109875: PUSH
109876: LD_INT 2
109878: PUSH
109879: EMPTY
109880: LIST
109881: LIST
109882: PPUSH
109883: CALL_OW 72
109887: AND
109888: IFFALSE 110226
// begin tmp := FilterByTag ( defenders , 19 ) ;
109890: LD_ADDR_VAR 0 12
109894: PUSH
109895: LD_VAR 0 2
109899: PPUSH
109900: LD_INT 19
109902: PPUSH
109903: CALL 81948 0 2
109907: ST_TO_ADDR
// if tmp then
109908: LD_VAR 0 12
109912: IFFALSE 109982
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109914: LD_ADDR_VAR 0 12
109918: PUSH
109919: LD_VAR 0 12
109923: PPUSH
109924: LD_INT 25
109926: PUSH
109927: LD_INT 3
109929: PUSH
109930: EMPTY
109931: LIST
109932: LIST
109933: PPUSH
109934: CALL_OW 72
109938: ST_TO_ADDR
// if tmp then
109939: LD_VAR 0 12
109943: IFFALSE 109982
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109945: LD_ADDR_EXP 62
109949: PUSH
109950: LD_EXP 62
109954: PPUSH
109955: LD_VAR 0 1
109959: PPUSH
109960: LD_EXP 62
109964: PUSH
109965: LD_VAR 0 1
109969: ARRAY
109970: PUSH
109971: LD_VAR 0 12
109975: UNION
109976: PPUSH
109977: CALL_OW 1
109981: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109982: LD_VAR 0 1
109986: PPUSH
109987: LD_INT 19
109989: PPUSH
109990: CALL 21980 0 2
// repeat wait ( 0 0$1 ) ;
109994: LD_INT 35
109996: PPUSH
109997: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110001: LD_EXP 50
110005: PUSH
110006: LD_VAR 0 1
110010: ARRAY
110011: NOT
110012: PUSH
110013: LD_EXP 50
110017: PUSH
110018: LD_VAR 0 1
110022: ARRAY
110023: PUSH
110024: EMPTY
110025: EQUAL
110026: OR
110027: IFFALSE 110064
// begin for i in defenders do
110029: LD_ADDR_VAR 0 5
110033: PUSH
110034: LD_VAR 0 2
110038: PUSH
110039: FOR_IN
110040: IFFALSE 110053
// ComStop ( i ) ;
110042: LD_VAR 0 5
110046: PPUSH
110047: CALL_OW 141
110051: GO 110039
110053: POP
110054: POP
// defenders := [ ] ;
110055: LD_ADDR_VAR 0 2
110059: PUSH
110060: EMPTY
110061: ST_TO_ADDR
// exit ;
110062: GO 110290
// end ; for i in defenders do
110064: LD_ADDR_VAR 0 5
110068: PUSH
110069: LD_VAR 0 2
110073: PUSH
110074: FOR_IN
110075: IFFALSE 110164
// begin if not IsInArea ( i , mc_parking [ base ] ) then
110077: LD_VAR 0 5
110081: PPUSH
110082: LD_EXP 74
110086: PUSH
110087: LD_VAR 0 1
110091: ARRAY
110092: PPUSH
110093: CALL_OW 308
110097: NOT
110098: IFFALSE 110122
// ComMoveToArea ( i , mc_parking [ base ] ) else
110100: LD_VAR 0 5
110104: PPUSH
110105: LD_EXP 74
110109: PUSH
110110: LD_VAR 0 1
110114: ARRAY
110115: PPUSH
110116: CALL_OW 113
110120: GO 110162
// if GetControl ( i ) = control_manual then
110122: LD_VAR 0 5
110126: PPUSH
110127: CALL_OW 263
110131: PUSH
110132: LD_INT 1
110134: EQUAL
110135: IFFALSE 110162
// if IsDrivenBy ( i ) then
110137: LD_VAR 0 5
110141: PPUSH
110142: CALL_OW 311
110146: IFFALSE 110162
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
110148: LD_VAR 0 5
110152: PPUSH
110153: CALL_OW 311
110157: PPUSH
110158: CALL_OW 121
// end ;
110162: GO 110074
110164: POP
110165: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
110166: LD_VAR 0 2
110170: PPUSH
110171: LD_INT 95
110173: PUSH
110174: LD_EXP 74
110178: PUSH
110179: LD_VAR 0 1
110183: ARRAY
110184: PUSH
110185: EMPTY
110186: LIST
110187: LIST
110188: PPUSH
110189: CALL_OW 72
110193: PUSH
110194: LD_VAR 0 2
110198: EQUAL
110199: PUSH
110200: LD_EXP 73
110204: PUSH
110205: LD_VAR 0 1
110209: ARRAY
110210: OR
110211: PUSH
110212: LD_EXP 50
110216: PUSH
110217: LD_VAR 0 1
110221: ARRAY
110222: NOT
110223: OR
110224: IFFALSE 109994
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
110226: LD_ADDR_EXP 72
110230: PUSH
110231: LD_EXP 72
110235: PPUSH
110236: LD_VAR 0 1
110240: PPUSH
110241: LD_VAR 0 2
110245: PPUSH
110246: LD_INT 21
110248: PUSH
110249: LD_INT 2
110251: PUSH
110252: EMPTY
110253: LIST
110254: LIST
110255: PPUSH
110256: CALL_OW 72
110260: PPUSH
110261: CALL_OW 1
110265: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
110266: LD_VAR 0 1
110270: PPUSH
110271: LD_INT 19
110273: PPUSH
110274: CALL 21980 0 2
// MC_Reset ( base , 20 ) ;
110278: LD_VAR 0 1
110282: PPUSH
110283: LD_INT 20
110285: PPUSH
110286: CALL 21980 0 2
// end ; end_of_file
110290: LD_VAR 0 4
110294: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
110295: LD_VAR 0 1
110299: PUSH
110300: LD_INT 200
110302: DOUBLE
110303: GREATEREQUAL
110304: IFFALSE 110312
110306: LD_INT 299
110308: DOUBLE
110309: LESSEQUAL
110310: IFTRUE 110314
110312: GO 110346
110314: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
110315: LD_VAR 0 1
110319: PPUSH
110320: LD_VAR 0 2
110324: PPUSH
110325: LD_VAR 0 3
110329: PPUSH
110330: LD_VAR 0 4
110334: PPUSH
110335: LD_VAR 0 5
110339: PPUSH
110340: CALL 99228 0 5
110344: GO 110423
110346: LD_INT 300
110348: DOUBLE
110349: GREATEREQUAL
110350: IFFALSE 110358
110352: LD_INT 399
110354: DOUBLE
110355: LESSEQUAL
110356: IFTRUE 110360
110358: GO 110422
110360: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
110361: LD_VAR 0 1
110365: PPUSH
110366: LD_VAR 0 2
110370: PPUSH
110371: LD_VAR 0 3
110375: PPUSH
110376: LD_VAR 0 4
110380: PPUSH
110381: LD_VAR 0 5
110385: PPUSH
110386: LD_VAR 0 6
110390: PPUSH
110391: LD_VAR 0 7
110395: PPUSH
110396: LD_VAR 0 8
110400: PPUSH
110401: LD_VAR 0 9
110405: PPUSH
110406: LD_VAR 0 10
110410: PPUSH
110411: LD_VAR 0 11
110415: PPUSH
110416: CALL 97116 0 11
110420: GO 110423
110422: POP
// end ;
110423: PPOPN 11
110425: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
110426: LD_VAR 0 1
110430: PPUSH
110431: LD_VAR 0 2
110435: PPUSH
110436: LD_VAR 0 3
110440: PPUSH
110441: LD_VAR 0 4
110445: PPUSH
110446: LD_VAR 0 5
110450: PPUSH
110451: CALL 99210 0 5
// end ; end_of_file
110455: PPOPN 5
110457: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110458: LD_VAR 0 1
110462: PPUSH
110463: LD_VAR 0 2
110467: PPUSH
110468: LD_VAR 0 3
110472: PPUSH
110473: LD_VAR 0 4
110477: PPUSH
110478: LD_VAR 0 5
110482: PPUSH
110483: LD_VAR 0 6
110487: PPUSH
110488: CALL 85924 0 6
// end ;
110492: PPOPN 6
110494: END
