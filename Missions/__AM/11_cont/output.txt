// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 88977 0 0
// InitMacro ;
  23: CALL 17953 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81942 0 9
// PrepareAmerican ;
  81: CALL 663 0 0
// PrepareArabian ;
  85: CALL 2615 0 0
// MC_Start ( ) ;
  89: CALL 20118 0 0
// Action ;
  93: CALL 8560 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: LD_INT 235200
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: ST_TO_ADDR
// powell_warn := false ;
 245: LD_ADDR_EXP 16
 249: PUSH
 250: LD_INT 0
 252: ST_TO_ADDR
// loses_counter := 0 ;
 253: LD_ADDR_EXP 17
 257: PUSH
 258: LD_INT 0
 260: ST_TO_ADDR
// artifact_oncargo := false ;
 261: LD_ADDR_EXP 14
 265: PUSH
 266: LD_INT 0
 268: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 269: LD_ADDR_EXP 18
 273: PUSH
 274: LD_STRING 10_GensherEscape_1
 276: PPUSH
 277: LD_EXP 1
 281: PPUSH
 282: CALL_OW 30
 286: ST_TO_ADDR
// can_kamikazed := false ;
 287: LD_ADDR_EXP 10
 291: PUSH
 292: LD_INT 0
 294: ST_TO_ADDR
// am_veh_consturcted := false ;
 295: LD_ADDR_EXP 20
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// end ;
 303: LD_VAR 0 1
 307: RET
// export function CustomInitMacro ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 312: LD_ADDR_EXP 74
 316: PUSH
 317: LD_INT 20
 319: PUSH
 320: LD_INT 21
 322: PUSH
 323: LD_INT 22
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 331: LD_ADDR_EXP 75
 335: PUSH
 336: LD_INT 28
 338: PUSH
 339: LD_INT 24
 341: PUSH
 342: LD_INT 26
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PUSH
 356: LD_INT 6
 358: PUSH
 359: LD_INT 8
 361: PUSH
 362: LD_INT 9
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PUSH
 371: LD_OWVAR 67
 375: ARRAY
 376: PPUSH
 377: LD_INT 3
 379: PPUSH
 380: CALL 41807 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 384: LD_INT 2
 386: PPUSH
 387: LD_INT 4
 389: PUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 8
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: LIST
 404: PUSH
 405: LD_OWVAR 67
 409: ARRAY
 410: PPUSH
 411: LD_INT 2
 413: PPUSH
 414: CALL 41807 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 418: LD_INT 3
 420: PPUSH
 421: LD_INT 4
 423: PUSH
 424: LD_INT 6
 426: PUSH
 427: LD_INT 8
 429: PUSH
 430: LD_INT 9
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_OWVAR 67
 443: ARRAY
 444: PPUSH
 445: LD_INT 1
 447: PPUSH
 448: CALL 41807 0 3
// for i = 1 to mc_bases do
 452: LD_ADDR_VAR 0 2
 456: PUSH
 457: DOUBLE
 458: LD_INT 1
 460: DEC
 461: ST_TO_ADDR
 462: LD_EXP 50
 466: PUSH
 467: FOR_TO
 468: IFFALSE 492
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 470: LD_VAR 0 2
 474: PPUSH
 475: LD_EXP 43
 479: PUSH
 480: LD_VAR 0 2
 484: ARRAY
 485: PPUSH
 486: CALL 42233 0 2
 490: GO 467
 492: POP
 493: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 494: LD_INT 1
 496: PPUSH
 497: LD_INT 14
 499: PUSH
 500: LD_INT 1
 502: PUSH
 503: LD_INT 2
 505: PUSH
 506: LD_EXP 100
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: PUSH
 517: LD_INT 14
 519: PUSH
 520: LD_INT 1
 522: PUSH
 523: LD_INT 2
 525: PUSH
 526: LD_EXP 100
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL 42125 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 545: LD_INT 2
 547: PPUSH
 548: LD_INT 14
 550: PUSH
 551: LD_INT 1
 553: PUSH
 554: LD_INT 2
 556: PUSH
 557: LD_EXP 100
 561: PUSH
 562: EMPTY
 563: LIST
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: EMPTY
 569: LIST
 570: PPUSH
 571: CALL 42125 0 2
// end ;
 575: LD_VAR 0 1
 579: RET
// function Debuger ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// if not debug then
 584: LD_EXP 1
 588: NOT
 589: IFFALSE 593
// exit ;
 591: GO 629
// game_speed := 5 ;
 593: LD_ADDR_OWVAR 65
 597: PUSH
 598: LD_INT 5
 600: ST_TO_ADDR
// uc_side := 1 ;
 601: LD_ADDR_OWVAR 20
 605: PUSH
 606: LD_INT 1
 608: ST_TO_ADDR
// uc_nation := 1 ;
 609: LD_ADDR_OWVAR 21
 613: PUSH
 614: LD_INT 1
 616: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 617: LD_EXP 36
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 235
// end ;
 629: LD_VAR 0 1
 633: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 634: LD_INT 94
 636: PPUSH
 637: CALL_OW 301
 641: PUSH
 642: LD_INT 45
 644: PPUSH
 645: CALL_OW 302
 649: AND
 650: IFFALSE 662
 652: GO 654
 654: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 655: LD_STRING ACH_EAST
 657: PPUSH
 658: CALL_OW 543
 662: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 663: LD_INT 0
 665: PPUSH
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
 671: PPUSH
 672: PPUSH
// uc_side := 4 ;
 673: LD_ADDR_OWVAR 20
 677: PUSH
 678: LD_INT 4
 680: ST_TO_ADDR
// uc_nation := 1 ;
 681: LD_ADDR_OWVAR 21
 685: PUSH
 686: LD_INT 1
 688: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 689: LD_ADDR_EXP 30
 693: PUSH
 694: LD_STRING Powell
 696: PPUSH
 697: LD_INT 0
 699: PPUSH
 700: LD_STRING 
 702: PPUSH
 703: CALL 48579 0 3
 707: ST_TO_ADDR
// uc_side := 1 ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 716: LD_ADDR_EXP 21
 720: PUSH
 721: LD_STRING JMM
 723: PPUSH
 724: LD_EXP 1
 728: NOT
 729: PPUSH
 730: LD_EXP 4
 734: PPUSH
 735: CALL 48579 0 3
 739: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 740: LD_EXP 21
 744: PPUSH
 745: CALL_OW 257
 749: PUSH
 750: LD_INT 4
 752: GREATER
 753: IFFALSE 767
// SetClass ( JMM , 1 ) ;
 755: LD_EXP 21
 759: PPUSH
 760: LD_INT 1
 762: PPUSH
 763: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 767: LD_ADDR_EXP 22
 771: PUSH
 772: LD_STRING Lisa
 774: PPUSH
 775: LD_EXP 1
 779: NOT
 780: PPUSH
 781: LD_EXP 4
 785: PPUSH
 786: CALL 48579 0 3
 790: ST_TO_ADDR
// if not Lisa then
 791: LD_EXP 22
 795: NOT
 796: IFFALSE 811
// Lisa := CreateCharacter ( 10_Lisa ) ;
 798: LD_ADDR_EXP 22
 802: PUSH
 803: LD_STRING 10_Lisa
 805: PPUSH
 806: CALL_OW 34
 810: ST_TO_ADDR
// if not Lisa then
 811: LD_EXP 22
 815: NOT
 816: IFFALSE 831
// Lisa := CreateCharacter ( 09_Lisa ) ;
 818: LD_ADDR_EXP 22
 822: PUSH
 823: LD_STRING 09_Lisa
 825: PPUSH
 826: CALL_OW 34
 830: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 831: LD_ADDR_EXP 31
 835: PUSH
 836: LD_STRING Cornel
 838: PPUSH
 839: LD_EXP 1
 843: NOT
 844: PPUSH
 845: LD_EXP 4
 849: PPUSH
 850: CALL 48579 0 3
 854: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 855: LD_ADDR_EXP 23
 859: PUSH
 860: LD_STRING Donaldson
 862: PPUSH
 863: LD_EXP 1
 867: NOT
 868: PPUSH
 869: LD_EXP 4
 873: PPUSH
 874: CALL 48579 0 3
 878: ST_TO_ADDR
// if not Donaldson then
 879: LD_EXP 23
 883: NOT
 884: IFFALSE 899
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 886: LD_ADDR_EXP 23
 890: PUSH
 891: LD_STRING 10_Donaldson
 893: PPUSH
 894: CALL_OW 34
 898: ST_TO_ADDR
// if not Donaldson then
 899: LD_EXP 23
 903: NOT
 904: IFFALSE 919
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 906: LD_ADDR_EXP 23
 910: PUSH
 911: LD_STRING 09_Donaldson
 913: PPUSH
 914: CALL_OW 34
 918: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 919: LD_ADDR_EXP 24
 923: PUSH
 924: LD_STRING Bobby
 926: PPUSH
 927: LD_EXP 1
 931: NOT
 932: PPUSH
 933: LD_EXP 4
 937: PPUSH
 938: CALL 48579 0 3
 942: ST_TO_ADDR
// if not Bobby then
 943: LD_EXP 24
 947: NOT
 948: IFFALSE 963
// Bobby := CreateCharacter ( 10_Bobby ) ;
 950: LD_ADDR_EXP 24
 954: PUSH
 955: LD_STRING 10_Bobby
 957: PPUSH
 958: CALL_OW 34
 962: ST_TO_ADDR
// if not Bobby then
 963: LD_EXP 24
 967: NOT
 968: IFFALSE 983
// Bobby := CreateCharacter ( 09_Bobby ) ;
 970: LD_ADDR_EXP 24
 974: PUSH
 975: LD_STRING 09_Bobby
 977: PPUSH
 978: CALL_OW 34
 982: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 983: LD_ADDR_EXP 25
 987: PUSH
 988: LD_STRING Cyrus
 990: PPUSH
 991: LD_EXP 1
 995: NOT
 996: PPUSH
 997: LD_EXP 4
1001: PPUSH
1002: CALL 48579 0 3
1006: ST_TO_ADDR
// if not Cyrus then
1007: LD_EXP 25
1011: NOT
1012: IFFALSE 1027
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1014: LD_ADDR_EXP 25
1018: PUSH
1019: LD_STRING 10_Cyrus
1021: PPUSH
1022: CALL_OW 34
1026: ST_TO_ADDR
// if not Cyrus then
1027: LD_EXP 25
1031: NOT
1032: IFFALSE 1047
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1034: LD_ADDR_EXP 25
1038: PUSH
1039: LD_STRING 09_Cyrus
1041: PPUSH
1042: CALL_OW 34
1046: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1047: LD_ADDR_EXP 26
1051: PUSH
1052: LD_STRING Denis
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_EXP 4
1065: PPUSH
1066: CALL 48579 0 3
1070: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1071: LD_ADDR_EXP 27
1075: PUSH
1076: LD_STRING Brown
1078: PPUSH
1079: LD_EXP 1
1083: NOT
1084: PPUSH
1085: LD_EXP 4
1089: PPUSH
1090: CALL 48579 0 3
1094: ST_TO_ADDR
// if not Brown then
1095: LD_EXP 27
1099: NOT
1100: IFFALSE 1115
// Brown := CreateCharacter ( 10_Brown ) ;
1102: LD_ADDR_EXP 27
1106: PUSH
1107: LD_STRING 10_Brown
1109: PPUSH
1110: CALL_OW 34
1114: ST_TO_ADDR
// if not Brown then
1115: LD_EXP 27
1119: NOT
1120: IFFALSE 1135
// Brown := CreateCharacter ( 08_Brown ) ;
1122: LD_ADDR_EXP 27
1126: PUSH
1127: LD_STRING 08_Brown
1129: PPUSH
1130: CALL_OW 34
1134: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1135: LD_ADDR_EXP 28
1139: PUSH
1140: LD_STRING Gladstone
1142: PPUSH
1143: LD_EXP 1
1147: NOT
1148: PPUSH
1149: LD_EXP 4
1153: PPUSH
1154: CALL 48579 0 3
1158: ST_TO_ADDR
// if not Gladstone then
1159: LD_EXP 28
1163: NOT
1164: IFFALSE 1179
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1166: LD_ADDR_EXP 28
1170: PUSH
1171: LD_STRING 10_Gladstone
1173: PPUSH
1174: CALL_OW 34
1178: ST_TO_ADDR
// if not Gladstone then
1179: LD_EXP 28
1183: NOT
1184: IFFALSE 1199
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1186: LD_ADDR_EXP 28
1190: PUSH
1191: LD_STRING 08_Gladstone
1193: PPUSH
1194: CALL_OW 34
1198: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1199: LD_ADDR_EXP 29
1203: PUSH
1204: LD_STRING Houten
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_EXP 4
1217: PPUSH
1218: CALL 48579 0 3
1222: ST_TO_ADDR
// if not Houten then
1223: LD_EXP 29
1227: NOT
1228: IFFALSE 1243
// Houten := CreateCharacter ( 10_Houten ) ;
1230: LD_ADDR_EXP 29
1234: PUSH
1235: LD_STRING 10_Houten
1237: PPUSH
1238: CALL_OW 34
1242: ST_TO_ADDR
// if not Houten then
1243: LD_EXP 29
1247: NOT
1248: IFFALSE 1263
// Houten := CreateCharacter ( 09_Houten ) ;
1250: LD_ADDR_EXP 29
1254: PUSH
1255: LD_STRING 09_Houten
1257: PPUSH
1258: CALL_OW 34
1262: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1263: LD_ADDR_EXP 31
1267: PUSH
1268: LD_STRING Cornell
1270: PPUSH
1271: LD_EXP 1
1275: NOT
1276: PPUSH
1277: LD_EXP 4
1281: PPUSH
1282: CALL 48579 0 3
1286: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1287: LD_ADDR_EXP 32
1291: PUSH
1292: LD_STRING Gary
1294: PPUSH
1295: LD_EXP 1
1299: NOT
1300: PPUSH
1301: LD_EXP 4
1305: PPUSH
1306: CALL 48579 0 3
1310: ST_TO_ADDR
// if not Gary then
1311: LD_EXP 32
1315: NOT
1316: IFFALSE 1331
// Gary := CreateCharacter ( 10_Gary ) ;
1318: LD_ADDR_EXP 32
1322: PUSH
1323: LD_STRING 10_Gary
1325: PPUSH
1326: CALL_OW 34
1330: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1331: LD_ADDR_EXP 33
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: LD_EXP 4
1349: PPUSH
1350: CALL 48579 0 3
1354: ST_TO_ADDR
// if not Frank then
1355: LD_EXP 33
1359: NOT
1360: IFFALSE 1375
// Frank := CreateCharacter ( 08_Frank ) ;
1362: LD_ADDR_EXP 33
1366: PUSH
1367: LD_STRING 08_Frank
1369: PPUSH
1370: CALL_OW 34
1374: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1375: LD_ADDR_EXP 34
1379: PUSH
1380: LD_STRING Kikuchi
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_EXP 4
1393: PPUSH
1394: CALL 48579 0 3
1398: ST_TO_ADDR
// if not Kikuchi then
1399: LD_EXP 34
1403: NOT
1404: IFFALSE 1419
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1406: LD_ADDR_EXP 34
1410: PUSH
1411: LD_STRING 08_Kikuchi
1413: PPUSH
1414: CALL_OW 34
1418: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1419: LD_ADDR_VAR 0 5
1423: PUSH
1424: LD_EXP 22
1428: PUSH
1429: LD_EXP 23
1433: PUSH
1434: LD_EXP 24
1438: PUSH
1439: LD_EXP 25
1443: PUSH
1444: LD_EXP 26
1448: PUSH
1449: LD_EXP 27
1453: PUSH
1454: LD_EXP 28
1458: PUSH
1459: LD_EXP 29
1463: PUSH
1464: LD_EXP 31
1468: PUSH
1469: LD_EXP 32
1473: PUSH
1474: LD_EXP 33
1478: PUSH
1479: LD_EXP 34
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: ST_TO_ADDR
// tmp := tmp diff 0 ;
1498: LD_ADDR_VAR 0 5
1502: PUSH
1503: LD_VAR 0 5
1507: PUSH
1508: LD_INT 0
1510: DIFF
1511: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1512: LD_ADDR_VAR 0 5
1516: PUSH
1517: LD_VAR 0 5
1521: PUSH
1522: LD_STRING 10_lock
1524: PPUSH
1525: CALL_OW 31
1529: UNION
1530: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1531: LD_ADDR_VAR 0 5
1535: PUSH
1536: LD_VAR 0 5
1540: PUSH
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 31
1548: UNION
1549: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1550: LD_STRING 10_lock
1552: PPUSH
1553: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1557: LD_STRING 10c_lock
1559: PPUSH
1560: CALL_OW 40
// for i in tmp do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: LD_VAR 0 5
1573: PUSH
1574: FOR_IN
1575: IFFALSE 1613
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1577: LD_VAR 0 2
1581: PPUSH
1582: CALL_OW 257
1586: PUSH
1587: LD_INT 8
1589: PUSH
1590: LD_INT 2
1592: PUSH
1593: EMPTY
1594: LIST
1595: LIST
1596: IN
1597: IFFALSE 1611
// SetClass ( i , class_soldier ) ;
1599: LD_VAR 0 2
1603: PPUSH
1604: LD_INT 1
1606: PPUSH
1607: CALL_OW 336
1611: GO 1574
1613: POP
1614: POP
// if tmp < 12 then
1615: LD_VAR 0 5
1619: PUSH
1620: LD_INT 12
1622: LESS
1623: IFFALSE 1717
// begin k := 16 - tmp ;
1625: LD_ADDR_VAR 0 3
1629: PUSH
1630: LD_INT 16
1632: PUSH
1633: LD_VAR 0 5
1637: MINUS
1638: ST_TO_ADDR
// for i = 1 to k do
1639: LD_ADDR_VAR 0 2
1643: PUSH
1644: DOUBLE
1645: LD_INT 1
1647: DEC
1648: ST_TO_ADDR
1649: LD_VAR 0 3
1653: PUSH
1654: FOR_TO
1655: IFFALSE 1715
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1657: LD_INT 0
1659: PPUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 1
1665: PUSH
1666: LD_INT 3
1668: PUSH
1669: LD_INT 4
1671: PUSH
1672: EMPTY
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 1
1680: PPUSH
1681: LD_INT 4
1683: PPUSH
1684: CALL_OW 12
1688: ARRAY
1689: PPUSH
1690: LD_INT 6
1692: PPUSH
1693: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_VAR 0 5
1706: PUSH
1707: CALL_OW 44
1711: ADD
1712: ST_TO_ADDR
// end ;
1713: GO 1654
1715: POP
1716: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1717: LD_ADDR_EXP 19
1721: PUSH
1722: LD_STRING 1
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 12
1730: PPUSH
1731: LD_INT -5
1733: PUSH
1734: LD_EXP 21
1738: PUSH
1739: LD_INT -2
1741: PUSH
1742: LD_INT -3
1744: PUSH
1745: LD_INT -5
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PUSH
1755: LD_VAR 0 5
1759: ADD
1760: PUSH
1761: LD_INT -6
1763: PUSH
1764: LD_INT -4
1766: PUSH
1767: LD_EXP 30
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: LIST
1776: ADD
1777: PPUSH
1778: LD_INT 1
1780: PUSH
1781: LD_INT 4
1783: PUSH
1784: EMPTY
1785: LIST
1786: LIST
1787: PUSH
1788: LD_INT 3
1790: PUSH
1791: LD_INT 0
1793: PUSH
1794: LD_INT 5
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: PUSH
1802: LD_INT 4
1804: PUSH
1805: LD_INT 0
1807: PUSH
1808: LD_INT 3
1810: PUSH
1811: EMPTY
1812: LIST
1813: LIST
1814: LIST
1815: PUSH
1816: LD_INT 5
1818: PUSH
1819: LD_INT 0
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: PUSH
1830: EMPTY
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: PPUSH
1836: CALL_OW 42
1840: ST_TO_ADDR
// others := tmp diff selected ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 19
1855: DIFF
1856: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1857: LD_ADDR_VAR 0 8
1861: PUSH
1862: LD_VAR 0 8
1866: PUSH
1867: LD_EXP 22
1871: PUSH
1872: LD_EXP 23
1876: PUSH
1877: LD_EXP 24
1881: PUSH
1882: LD_EXP 25
1886: PUSH
1887: LD_EXP 26
1891: PUSH
1892: LD_EXP 27
1896: PUSH
1897: LD_EXP 28
1901: PUSH
1902: LD_EXP 29
1906: PUSH
1907: LD_EXP 31
1911: PUSH
1912: LD_EXP 32
1916: PUSH
1917: LD_EXP 33
1921: PUSH
1922: LD_EXP 34
1926: PUSH
1927: EMPTY
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: DIFF
1941: ST_TO_ADDR
// if others then
1942: LD_VAR 0 8
1946: IFFALSE 1960
// SaveCharacters ( others , 11_others ) ;
1948: LD_VAR 0 8
1952: PPUSH
1953: LD_STRING 11_others
1955: PPUSH
1956: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1960: LD_ADDR_VAR 0 6
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 1
1970: PUSH
1971: LD_INT 1
1973: PUSH
1974: LD_INT 4
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 2
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: LD_INT 1
1991: PUSH
1992: LD_INT 5
1994: PUSH
1995: EMPTY
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 1
2006: PUSH
2007: LD_INT 1
2009: PUSH
2010: LD_INT 5
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 2
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 1
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: PUSH
2037: LD_INT 3
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 7
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PUSH
2055: EMPTY
2056: LIST
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: ST_TO_ADDR
// for i in JMM ^ selected do
2062: LD_ADDR_VAR 0 2
2066: PUSH
2067: LD_EXP 21
2071: PUSH
2072: LD_EXP 19
2076: ADD
2077: PUSH
2078: FOR_IN
2079: IFFALSE 2269
// begin if GetClass ( i ) = 3 then
2081: LD_VAR 0 2
2085: PPUSH
2086: CALL_OW 257
2090: PUSH
2091: LD_INT 3
2093: EQUAL
2094: IFFALSE 2252
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2096: LD_ADDR_OWVAR 37
2100: PUSH
2101: LD_VAR 0 6
2105: PUSH
2106: LD_INT 1
2108: ARRAY
2109: PUSH
2110: LD_INT 1
2112: ARRAY
2113: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2114: LD_ADDR_OWVAR 39
2118: PUSH
2119: LD_VAR 0 6
2123: PUSH
2124: LD_INT 1
2126: ARRAY
2127: PUSH
2128: LD_INT 2
2130: ARRAY
2131: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2132: LD_ADDR_OWVAR 38
2136: PUSH
2137: LD_VAR 0 6
2141: PUSH
2142: LD_INT 1
2144: ARRAY
2145: PUSH
2146: LD_INT 3
2148: ARRAY
2149: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2150: LD_ADDR_OWVAR 40
2154: PUSH
2155: LD_VAR 0 6
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PUSH
2164: LD_INT 4
2166: ARRAY
2167: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2168: LD_ADDR_VAR 0 6
2172: PUSH
2173: LD_VAR 0 6
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: CALL_OW 3
2185: ST_TO_ADDR
// veh := CreateVehicle ;
2186: LD_ADDR_VAR 0 7
2190: PUSH
2191: CALL_OW 45
2195: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2196: LD_VAR 0 7
2200: PPUSH
2201: LD_INT 8
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_VAR 0 7
2220: PPUSH
2221: CALL_OW 52
// if i = JMM then
2225: LD_VAR 0 2
2229: PUSH
2230: LD_EXP 21
2234: EQUAL
2235: IFFALSE 2250
// SetMark ( veh , - 1 ) ;
2237: LD_VAR 0 7
2241: PPUSH
2242: LD_INT 1
2244: NEG
2245: PPUSH
2246: CALL_OW 242
// end else
2250: GO 2267
// PlaceUnitArea ( i , am_hum_start , false ) ;
2252: LD_VAR 0 2
2256: PPUSH
2257: LD_INT 9
2259: PPUSH
2260: LD_INT 0
2262: PPUSH
2263: CALL_OW 49
// end ;
2267: GO 2078
2269: POP
2270: POP
// vc_chassis := us_medium_tracked ;
2271: LD_ADDR_OWVAR 37
2275: PUSH
2276: LD_INT 3
2278: ST_TO_ADDR
// vc_engine := engine_solar ;
2279: LD_ADDR_OWVAR 39
2283: PUSH
2284: LD_INT 2
2286: ST_TO_ADDR
// vc_control := control_computer ;
2287: LD_ADDR_OWVAR 38
2291: PUSH
2292: LD_INT 3
2294: ST_TO_ADDR
// vc_weapon := us_radar ;
2295: LD_ADDR_OWVAR 40
2299: PUSH
2300: LD_INT 11
2302: ST_TO_ADDR
// veh := CreateVehicle ;
2303: LD_ADDR_VAR 0 7
2307: PUSH
2308: CALL_OW 45
2312: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2313: LD_VAR 0 7
2317: PPUSH
2318: LD_INT 87
2320: PPUSH
2321: LD_INT 142
2323: PPUSH
2324: LD_INT 0
2326: PPUSH
2327: CALL_OW 48
// end ;
2331: LD_VAR 0 1
2335: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2336: LD_INT 0
2338: PPUSH
2339: PPUSH
2340: PPUSH
2341: PPUSH
// uc_side := 1 ;
2342: LD_ADDR_OWVAR 20
2346: PUSH
2347: LD_INT 1
2349: ST_TO_ADDR
// uc_nation := 1 ;
2350: LD_ADDR_OWVAR 21
2354: PUSH
2355: LD_INT 1
2357: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2358: LD_ADDR_VAR 0 3
2362: PUSH
2363: LD_INT 3
2365: PUSH
2366: LD_INT 1
2368: PUSH
2369: LD_INT 3
2371: PUSH
2372: LD_INT 5
2374: PUSH
2375: EMPTY
2376: LIST
2377: LIST
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 1
2386: PUSH
2387: LD_INT 3
2389: PUSH
2390: LD_INT 7
2392: PUSH
2393: EMPTY
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: PUSH
2399: LD_INT 3
2401: PUSH
2402: LD_INT 1
2404: PUSH
2405: LD_INT 3
2407: PUSH
2408: LD_INT 7
2410: PUSH
2411: EMPTY
2412: LIST
2413: LIST
2414: LIST
2415: LIST
2416: PUSH
2417: LD_INT 3
2419: PUSH
2420: LD_INT 1
2422: PUSH
2423: LD_INT 3
2425: PUSH
2426: LD_INT 11
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: PUSH
2435: LD_INT 4
2437: PUSH
2438: LD_INT 1
2440: PUSH
2441: LD_INT 3
2443: PUSH
2444: LD_INT 6
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: LIST
2451: LIST
2452: PUSH
2453: LD_INT 4
2455: PUSH
2456: LD_INT 1
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 5
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: PUSH
2471: EMPTY
2472: LIST
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: LIST
2478: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2479: LD_ADDR_VAR 0 2
2483: PUSH
2484: DOUBLE
2485: LD_INT 1
2487: DEC
2488: ST_TO_ADDR
2489: LD_INT 7
2491: PUSH
2492: LD_OWVAR 67
2496: MINUS
2497: PUSH
2498: FOR_TO
2499: IFFALSE 2608
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2501: LD_ADDR_OWVAR 37
2505: PUSH
2506: LD_VAR 0 3
2510: PUSH
2511: LD_VAR 0 2
2515: ARRAY
2516: PUSH
2517: LD_INT 1
2519: ARRAY
2520: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2521: LD_ADDR_OWVAR 39
2525: PUSH
2526: LD_VAR 0 3
2530: PUSH
2531: LD_VAR 0 2
2535: ARRAY
2536: PUSH
2537: LD_INT 2
2539: ARRAY
2540: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2541: LD_ADDR_OWVAR 38
2545: PUSH
2546: LD_VAR 0 3
2550: PUSH
2551: LD_VAR 0 2
2555: ARRAY
2556: PUSH
2557: LD_INT 3
2559: ARRAY
2560: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2561: LD_ADDR_OWVAR 40
2565: PUSH
2566: LD_VAR 0 3
2570: PUSH
2571: LD_VAR 0 2
2575: ARRAY
2576: PUSH
2577: LD_INT 4
2579: ARRAY
2580: ST_TO_ADDR
// veh := CreateVehicle ;
2581: LD_ADDR_VAR 0 4
2585: PUSH
2586: CALL_OW 45
2590: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2591: LD_VAR 0 4
2595: PPUSH
2596: LD_INT 8
2598: PPUSH
2599: LD_INT 0
2601: PPUSH
2602: CALL_OW 49
// end ;
2606: GO 2498
2608: POP
2609: POP
// end ; end_of_file
2610: LD_VAR 0 1
2614: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2615: LD_INT 0
2617: PPUSH
2618: PPUSH
2619: PPUSH
2620: PPUSH
2621: PPUSH
2622: PPUSH
// if Difficulty = 1 then
2623: LD_OWVAR 67
2627: PUSH
2628: LD_INT 1
2630: EQUAL
2631: IFFALSE 2728
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2633: LD_ADDR_VAR 0 6
2637: PUSH
2638: LD_INT 129
2640: PUSH
2641: LD_INT 45
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 143
2650: PUSH
2651: LD_INT 58
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 184
2660: PUSH
2661: LD_INT 113
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: LD_INT 163
2670: PUSH
2671: LD_INT 107
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: PUSH
2678: EMPTY
2679: LIST
2680: LIST
2681: LIST
2682: LIST
2683: ST_TO_ADDR
// for i in tmp do
2684: LD_ADDR_VAR 0 2
2688: PUSH
2689: LD_VAR 0 6
2693: PUSH
2694: FOR_IN
2695: IFFALSE 2726
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2697: LD_VAR 0 2
2701: PUSH
2702: LD_INT 1
2704: ARRAY
2705: PPUSH
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 2
2713: ARRAY
2714: PPUSH
2715: CALL_OW 428
2719: PPUSH
2720: CALL_OW 64
2724: GO 2694
2726: POP
2727: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2728: LD_ADDR_VAR 0 2
2732: PUSH
2733: LD_INT 21
2735: PUSH
2736: LD_INT 3
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2786
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: LD_INT 7
2764: PUSH
2765: LD_INT 8
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: LIST
2772: LIST
2773: PUSH
2774: LD_OWVAR 67
2778: ARRAY
2779: PPUSH
2780: CALL_OW 241
2784: GO 2748
2786: POP
2787: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2788: LD_ADDR_VAR 0 5
2792: PUSH
2793: LD_INT 5
2795: PUSH
2796: LD_INT 6
2798: PUSH
2799: LD_INT 7
2801: PUSH
2802: LD_INT 8
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_OWVAR 67
2815: ARRAY
2816: ST_TO_ADDR
// uc_side := 2 ;
2817: LD_ADDR_OWVAR 20
2821: PUSH
2822: LD_INT 2
2824: ST_TO_ADDR
// uc_nation := 2 ;
2825: LD_ADDR_OWVAR 21
2829: PUSH
2830: LD_INT 2
2832: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2833: LD_ADDR_OWVAR 37
2837: PUSH
2838: LD_INT 14
2840: ST_TO_ADDR
// vc_engine := engine_siberite ;
2841: LD_ADDR_OWVAR 39
2845: PUSH
2846: LD_INT 3
2848: ST_TO_ADDR
// vc_control := control_manual ;
2849: LD_ADDR_OWVAR 38
2853: PUSH
2854: LD_INT 1
2856: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2857: LD_ADDR_OWVAR 40
2861: PUSH
2862: LD_INT 31
2864: ST_TO_ADDR
// for i = 1 to 3 do
2865: LD_ADDR_VAR 0 2
2869: PUSH
2870: DOUBLE
2871: LD_INT 1
2873: DEC
2874: ST_TO_ADDR
2875: LD_INT 3
2877: PUSH
2878: FOR_TO
2879: IFFALSE 2963
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2881: LD_INT 0
2883: PPUSH
2884: LD_INT 3
2886: PPUSH
2887: LD_VAR 0 5
2891: PPUSH
2892: CALL_OW 380
// un := CreateVehicle ;
2896: LD_ADDR_VAR 0 4
2900: PUSH
2901: CALL_OW 45
2905: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2906: LD_VAR 0 4
2910: PPUSH
2911: LD_INT 0
2913: PPUSH
2914: LD_INT 5
2916: PPUSH
2917: CALL_OW 12
2921: PPUSH
2922: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2926: LD_VAR 0 4
2930: PPUSH
2931: LD_INT 156
2933: PPUSH
2934: LD_INT 15
2936: PPUSH
2937: LD_INT 6
2939: PPUSH
2940: LD_INT 0
2942: PPUSH
2943: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2947: CALL_OW 44
2951: PPUSH
2952: LD_VAR 0 4
2956: PPUSH
2957: CALL_OW 52
// end ;
2961: GO 2878
2963: POP
2964: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2965: LD_ADDR_EXP 37
2969: PUSH
2970: LD_INT 94
2972: PPUSH
2973: LD_INT 28
2975: PPUSH
2976: LD_STRING dammam
2978: PPUSH
2979: LD_VAR 0 5
2983: PPUSH
2984: LD_INT 10000
2986: PUSH
2987: LD_INT 1000
2989: PUSH
2990: LD_INT 300
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: LIST
2997: PPUSH
2998: LD_INT 12
3000: PUSH
3001: LD_INT 2
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 4
3009: PUSH
3010: LD_INT 4
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: PUSH
3019: LD_OWVAR 67
3023: ARRAY
3024: PUSH
3025: LD_INT 1
3027: NEG
3028: PUSH
3029: LD_INT 4
3031: PUSH
3032: EMPTY
3033: LIST
3034: LIST
3035: LIST
3036: LIST
3037: PPUSH
3038: CALL 56889 0 6
3042: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3043: LD_ADDR_EXP 37
3047: PUSH
3048: LD_EXP 37
3052: PUSH
3053: LD_INT 122
3055: PPUSH
3056: LD_INT 25
3058: PPUSH
3059: LD_STRING 
3061: PPUSH
3062: LD_VAR 0 5
3066: PPUSH
3067: LD_INT 500
3069: PUSH
3070: LD_INT 60
3072: PUSH
3073: LD_INT 0
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: PPUSH
3081: LD_INT 8
3083: PUSH
3084: LD_INT 2
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: LD_INT 4
3092: PUSH
3093: LD_INT 5
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: PUSH
3102: LD_OWVAR 67
3106: ARRAY
3107: PUSH
3108: LD_INT 2
3110: PUSH
3111: LD_INT 0
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 56889 0 6
3124: UNION
3125: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3126: LD_ADDR_EXP 35
3130: PUSH
3131: LD_INT 45
3133: PPUSH
3134: LD_INT 24
3136: PPUSH
3137: LD_STRING jeddah
3139: PPUSH
3140: LD_VAR 0 5
3144: PPUSH
3145: LD_INT 700
3147: PUSH
3148: LD_INT 300
3150: PUSH
3151: LD_INT 10
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: PPUSH
3159: LD_INT 9
3161: PUSH
3162: LD_INT 4
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 2
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PPUSH
3177: CALL 56889 0 6
3181: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3182: LD_ADDR_EXP 36
3186: PUSH
3187: LD_INT 7
3189: PPUSH
3190: LD_INT 27
3192: PPUSH
3193: LD_STRING riyadh
3195: PPUSH
3196: LD_VAR 0 5
3200: PPUSH
3201: LD_INT 500
3203: PUSH
3204: LD_INT 60
3206: PUSH
3207: LD_INT 0
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: LIST
3214: PPUSH
3215: LD_INT 4
3217: PUSH
3218: LD_INT 2
3220: PUSH
3221: LD_INT 3
3223: PUSH
3224: LD_INT 1
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: PPUSH
3233: CALL 56889 0 6
3237: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3238: LD_ADDR_EXP 39
3242: PUSH
3243: LD_INT 204
3245: PPUSH
3246: LD_INT 26
3248: PPUSH
3249: LD_STRING 
3251: PPUSH
3252: LD_VAR 0 5
3256: PPUSH
3257: LD_INT 500
3259: PUSH
3260: LD_INT 50
3262: PUSH
3263: LD_INT 0
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: LIST
3270: PPUSH
3271: LD_INT 9
3273: PUSH
3274: LD_INT 2
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 1
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PPUSH
3289: CALL 56889 0 6
3293: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3294: LD_ADDR_EXP 50
3298: PUSH
3299: LD_EXP 37
3303: PUSH
3304: LD_EXP 35
3308: PUSH
3309: LD_EXP 39
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3319: LD_ADDR_VAR 0 2
3323: PUSH
3324: LD_INT 22
3326: PUSH
3327: LD_INT 2
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 30
3336: PUSH
3337: LD_INT 31
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 58
3346: PUSH
3347: EMPTY
3348: LIST
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: LIST
3354: PPUSH
3355: CALL_OW 69
3359: PUSH
3360: FOR_IN
3361: IFFALSE 3486
// begin if GetBase ( i ) then
3363: LD_VAR 0 2
3367: PPUSH
3368: CALL_OW 274
3372: IFFALSE 3376
// continue ;
3374: GO 3360
// d := GetDir ( i ) ;
3376: LD_ADDR_VAR 0 3
3380: PUSH
3381: LD_VAR 0 2
3385: PPUSH
3386: CALL_OW 254
3390: ST_TO_ADDR
// if d < 3 then
3391: LD_VAR 0 3
3395: PUSH
3396: LD_INT 3
3398: LESS
3399: IFFALSE 3417
// d := d + 3 else
3401: LD_ADDR_VAR 0 3
3405: PUSH
3406: LD_VAR 0 3
3410: PUSH
3411: LD_INT 3
3413: PLUS
3414: ST_TO_ADDR
3415: GO 3431
// d := d - 3 ;
3417: LD_ADDR_VAR 0 3
3421: PUSH
3422: LD_VAR 0 3
3426: PUSH
3427: LD_INT 3
3429: MINUS
3430: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3431: LD_INT 0
3433: PPUSH
3434: LD_INT 8
3436: PPUSH
3437: LD_VAR 0 5
3441: PPUSH
3442: CALL_OW 380
// un := CreateHuman ;
3446: LD_ADDR_VAR 0 4
3450: PUSH
3451: CALL_OW 44
3455: ST_TO_ADDR
// SetDir ( un , d ) ;
3456: LD_VAR 0 4
3460: PPUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3470: LD_VAR 0 4
3474: PPUSH
3475: LD_VAR 0 2
3479: PPUSH
3480: CALL_OW 52
// end ;
3484: GO 3360
3486: POP
3487: POP
// if Difficulty > 1 then
3488: LD_OWVAR 67
3492: PUSH
3493: LD_INT 1
3495: GREATER
3496: IFFALSE 3867
// begin ar_kamikadze := [ ] ;
3498: LD_ADDR_EXP 42
3502: PUSH
3503: EMPTY
3504: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 1
3510: PPUSH
3511: LD_VAR 0 5
3515: PPUSH
3516: CALL_OW 380
// un := CreateHuman ;
3520: LD_ADDR_VAR 0 4
3524: PUSH
3525: CALL_OW 44
3529: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3530: LD_VAR 0 4
3534: PPUSH
3535: LD_INT 3
3537: PPUSH
3538: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3542: LD_VAR 0 4
3546: PPUSH
3547: LD_INT 23
3549: PPUSH
3550: LD_INT 44
3552: PPUSH
3553: LD_INT 0
3555: PPUSH
3556: CALL_OW 48
// ComCrawl ( un ) ;
3560: LD_VAR 0 4
3564: PPUSH
3565: CALL_OW 137
// un := CreateHuman ;
3569: LD_ADDR_VAR 0 4
3573: PUSH
3574: CALL_OW 44
3578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3579: LD_VAR 0 4
3583: PPUSH
3584: LD_INT 3
3586: PPUSH
3587: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3591: LD_VAR 0 4
3595: PPUSH
3596: LD_INT 30
3598: PPUSH
3599: LD_INT 39
3601: PPUSH
3602: LD_INT 0
3604: PPUSH
3605: CALL_OW 48
// ComCrawl ( un ) ;
3609: LD_VAR 0 4
3613: PPUSH
3614: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3618: LD_INT 0
3620: PPUSH
3621: LD_INT 17
3623: PPUSH
3624: LD_VAR 0 5
3628: PPUSH
3629: CALL_OW 380
// un := CreateHuman ;
3633: LD_ADDR_VAR 0 4
3637: PUSH
3638: CALL_OW 44
3642: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3643: LD_VAR 0 4
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3655: LD_VAR 0 4
3659: PPUSH
3660: LD_INT 45
3662: PPUSH
3663: LD_INT 86
3665: PPUSH
3666: LD_INT 0
3668: PPUSH
3669: CALL_OW 48
// ComHold ( un ) ;
3673: LD_VAR 0 4
3677: PPUSH
3678: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3682: LD_ADDR_EXP 42
3686: PUSH
3687: LD_EXP 42
3691: PPUSH
3692: LD_EXP 42
3696: PUSH
3697: LD_INT 1
3699: PLUS
3700: PPUSH
3701: LD_VAR 0 4
3705: PPUSH
3706: CALL_OW 1
3710: ST_TO_ADDR
// un := CreateHuman ;
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: CALL_OW 44
3720: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3721: LD_VAR 0 4
3725: PPUSH
3726: LD_INT 3
3728: PPUSH
3729: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3733: LD_VAR 0 4
3737: PPUSH
3738: LD_INT 60
3740: PPUSH
3741: LD_INT 85
3743: PPUSH
3744: LD_INT 0
3746: PPUSH
3747: CALL_OW 48
// ComHold ( un ) ;
3751: LD_VAR 0 4
3755: PPUSH
3756: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3760: LD_ADDR_EXP 42
3764: PUSH
3765: LD_EXP 42
3769: PPUSH
3770: LD_EXP 42
3774: PUSH
3775: LD_INT 1
3777: PLUS
3778: PPUSH
3779: LD_VAR 0 4
3783: PPUSH
3784: CALL_OW 1
3788: ST_TO_ADDR
// un := CreateHuman ;
3789: LD_ADDR_VAR 0 4
3793: PUSH
3794: CALL_OW 44
3798: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3799: LD_VAR 0 4
3803: PPUSH
3804: LD_INT 3
3806: PPUSH
3807: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3811: LD_VAR 0 4
3815: PPUSH
3816: LD_INT 222
3818: PPUSH
3819: LD_INT 166
3821: PPUSH
3822: LD_INT 0
3824: PPUSH
3825: CALL_OW 48
// ComHold ( un ) ;
3829: LD_VAR 0 4
3833: PPUSH
3834: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3838: LD_ADDR_EXP 42
3842: PUSH
3843: LD_EXP 42
3847: PPUSH
3848: LD_EXP 42
3852: PUSH
3853: LD_INT 1
3855: PLUS
3856: PPUSH
3857: LD_VAR 0 4
3861: PPUSH
3862: CALL_OW 1
3866: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3867: LD_ADDR_EXP 40
3871: PUSH
3872: EMPTY
3873: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3874: LD_INT 1
3876: PPUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_VAR 0 5
3884: PPUSH
3885: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3889: LD_ADDR_OWVAR 26
3893: PUSH
3894: LD_STRING Pavel Grigorovic
3896: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3897: LD_ADDR_OWVAR 33
3901: PUSH
3902: LD_STRING SecondCharsGal
3904: ST_TO_ADDR
// hc_face_number := 4 ;
3905: LD_ADDR_OWVAR 34
3909: PUSH
3910: LD_INT 4
3912: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3913: LD_ADDR_EXP 40
3917: PUSH
3918: LD_EXP 40
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: CALL_OW 44
3930: PPUSH
3931: CALL_OW 1
3935: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3936: LD_INT 2
3938: PPUSH
3939: LD_INT 4
3941: PPUSH
3942: LD_INT 2
3944: PPUSH
3945: CALL_OW 380
// hc_name := Lucy Sebel ;
3949: LD_ADDR_OWVAR 26
3953: PUSH
3954: LD_STRING Lucy Sebel
3956: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3957: LD_ADDR_OWVAR 33
3961: PUSH
3962: LD_STRING SecondCharsGal
3964: ST_TO_ADDR
// hc_face_number := 15 ;
3965: LD_ADDR_OWVAR 34
3969: PUSH
3970: LD_INT 15
3972: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3973: LD_ADDR_EXP 40
3977: PUSH
3978: LD_EXP 40
3982: PPUSH
3983: LD_INT 2
3985: PPUSH
3986: CALL_OW 44
3990: PPUSH
3991: CALL_OW 1
3995: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3996: LD_INT 2
3998: PPUSH
3999: LD_INT 4
4001: PPUSH
4002: LD_INT 2
4004: PPUSH
4005: CALL_OW 380
// hc_gallery :=  ;
4009: LD_ADDR_OWVAR 33
4013: PUSH
4014: LD_STRING 
4016: ST_TO_ADDR
// hc_name :=  ;
4017: LD_ADDR_OWVAR 26
4021: PUSH
4022: LD_STRING 
4024: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4025: LD_ADDR_EXP 40
4029: PUSH
4030: LD_EXP 40
4034: PPUSH
4035: LD_INT 3
4037: PPUSH
4038: CALL_OW 44
4042: PPUSH
4043: CALL_OW 1
4047: ST_TO_ADDR
// hc_sex := sex_male ;
4048: LD_ADDR_OWVAR 27
4052: PUSH
4053: LD_INT 1
4055: ST_TO_ADDR
// hc_class = 11 ;
4056: LD_ADDR_OWVAR 28
4060: PUSH
4061: LD_INT 11
4063: ST_TO_ADDR
// hc_gallery = sandar ;
4064: LD_ADDR_OWVAR 33
4068: PUSH
4069: LD_STRING sandar
4071: ST_TO_ADDR
// hc_face_number = 33 ;
4072: LD_ADDR_OWVAR 34
4076: PUSH
4077: LD_INT 33
4079: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4080: LD_ADDR_OWVAR 26
4084: PUSH
4085: LD_STRING Thabit Muhair Saliba
4087: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4088: LD_ADDR_OWVAR 31
4092: PUSH
4093: LD_INT 0
4095: PUSH
4096: LD_INT 0
4098: PUSH
4099: LD_INT 0
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: LIST
4109: LIST
4110: ST_TO_ADDR
// Saliba = CreateHuman ;
4111: LD_ADDR_EXP 44
4115: PUSH
4116: CALL_OW 44
4120: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4121: LD_EXP 44
4125: PPUSH
4126: LD_INT 7
4128: PPUSH
4129: CALL_OW 52
// if gensher_active then
4133: LD_EXP 18
4137: IFFALSE 4164
// begin Gensher = NewCharacter ( Dietrich ) ;
4139: LD_ADDR_EXP 45
4143: PUSH
4144: LD_STRING Dietrich
4146: PPUSH
4147: CALL_OW 25
4151: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4152: LD_EXP 45
4156: PPUSH
4157: LD_INT 94
4159: PPUSH
4160: CALL_OW 52
// end ; InitHc ;
4164: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4168: LD_ADDR_EXP 41
4172: PUSH
4173: EMPTY
4174: ST_TO_ADDR
// for i = 1 to 5 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 5
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4361
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4191: LD_INT 13
4193: PUSH
4194: LD_INT 14
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: PUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 2
4206: PPUSH
4207: CALL_OW 12
4211: ARRAY
4212: PPUSH
4213: LD_INT 1
4215: PUSH
4216: LD_INT 2
4218: PUSH
4219: EMPTY
4220: LIST
4221: LIST
4222: PUSH
4223: LD_INT 1
4225: PPUSH
4226: LD_INT 2
4228: PPUSH
4229: CALL_OW 12
4233: ARRAY
4234: PPUSH
4235: LD_INT 1
4237: PPUSH
4238: LD_INT 25
4240: PUSH
4241: LD_INT 27
4243: PUSH
4244: LD_INT 26
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 1
4254: PPUSH
4255: LD_INT 3
4257: PPUSH
4258: CALL_OW 12
4262: ARRAY
4263: PPUSH
4264: LD_INT 60
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 12
4274: PPUSH
4275: CALL 53443 0 5
// un := CreateVehicle ;
4279: LD_ADDR_VAR 0 4
4283: PUSH
4284: CALL_OW 45
4288: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4289: LD_ADDR_EXP 41
4293: PUSH
4294: LD_EXP 41
4298: PPUSH
4299: LD_EXP 41
4303: PUSH
4304: LD_INT 1
4306: PLUS
4307: PPUSH
4308: LD_VAR 0 4
4312: PPUSH
4313: CALL_OW 1
4317: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4318: LD_VAR 0 4
4322: PPUSH
4323: LD_INT 0
4325: PPUSH
4326: LD_INT 5
4328: PPUSH
4329: CALL_OW 12
4333: PPUSH
4334: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4338: LD_VAR 0 4
4342: PPUSH
4343: LD_INT 124
4345: PPUSH
4346: LD_INT 141
4348: PPUSH
4349: LD_INT 8
4351: PPUSH
4352: LD_INT 0
4354: PPUSH
4355: CALL_OW 50
// end ;
4359: GO 4188
4361: POP
4362: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4363: LD_ADDR_EXP 43
4367: PUSH
4368: EMPTY
4369: PUSH
4370: EMPTY
4371: PUSH
4372: EMPTY
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: LIST
4378: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4379: LD_ADDR_VAR 0 3
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: LD_INT 3
4394: PUSH
4395: LD_INT 4
4397: PUSH
4398: LD_INT 4
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: LIST
4405: LIST
4406: PUSH
4407: LD_OWVAR 67
4411: ARRAY
4412: PUSH
4413: FOR_TO
4414: IFFALSE 4628
// for i = 1 to 3 do
4416: LD_ADDR_VAR 0 2
4420: PUSH
4421: DOUBLE
4422: LD_INT 1
4424: DEC
4425: ST_TO_ADDR
4426: LD_INT 3
4428: PUSH
4429: FOR_TO
4430: IFFALSE 4624
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4432: LD_INT 14
4434: PPUSH
4435: LD_INT 3
4437: PUSH
4438: LD_INT 2
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PUSH
4445: LD_INT 1
4447: PPUSH
4448: LD_INT 2
4450: PPUSH
4451: CALL_OW 12
4455: ARRAY
4456: PPUSH
4457: LD_INT 1
4459: PUSH
4460: LD_INT 5
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PUSH
4467: LD_INT 1
4469: PPUSH
4470: LD_INT 2
4472: PPUSH
4473: CALL_OW 12
4477: ARRAY
4478: PPUSH
4479: LD_INT 25
4481: PUSH
4482: LD_INT 27
4484: PUSH
4485: LD_INT 26
4487: PUSH
4488: LD_INT 28
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 4
4502: PPUSH
4503: CALL_OW 12
4507: ARRAY
4508: PPUSH
4509: LD_INT 100
4511: PPUSH
4512: CALL 53443 0 5
// un := CreateVehicle ;
4516: LD_ADDR_VAR 0 4
4520: PUSH
4521: CALL_OW 45
4525: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4526: LD_ADDR_EXP 43
4530: PUSH
4531: LD_EXP 43
4535: PPUSH
4536: LD_VAR 0 2
4540: PUSH
4541: LD_EXP 43
4545: PUSH
4546: LD_VAR 0 2
4550: ARRAY
4551: PUSH
4552: LD_INT 1
4554: PLUS
4555: PUSH
4556: EMPTY
4557: LIST
4558: LIST
4559: PPUSH
4560: LD_VAR 0 4
4564: PPUSH
4565: CALL 53565 0 3
4569: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4570: LD_VAR 0 4
4574: PPUSH
4575: LD_INT 0
4577: PPUSH
4578: LD_INT 5
4580: PPUSH
4581: CALL_OW 12
4585: PPUSH
4586: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4590: LD_VAR 0 4
4594: PPUSH
4595: LD_INT 20
4597: PUSH
4598: LD_INT 21
4600: PUSH
4601: LD_INT 22
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: LIST
4608: PUSH
4609: LD_VAR 0 2
4613: ARRAY
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 49
// end ;
4622: GO 4429
4624: POP
4625: POP
4626: GO 4413
4628: POP
4629: POP
// InitHc ;
4630: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4634: LD_INT 4
4636: PPUSH
4637: LD_INT 5
4639: PPUSH
4640: LD_INT 10
4642: PPUSH
4643: LD_INT 5
4645: PPUSH
4646: LD_INT 0
4648: PPUSH
4649: CALL_OW 58
// end ;
4653: LD_VAR 0 1
4657: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4658: LD_EXP 42
4662: IFFALSE 4736
4664: GO 4666
4666: DISABLE
4667: LD_INT 0
4669: PPUSH
// begin enable ;
4670: ENABLE
// for i in ar_kamikadze do
4671: LD_ADDR_VAR 0 1
4675: PUSH
4676: LD_EXP 42
4680: PUSH
4681: FOR_IN
4682: IFFALSE 4734
// if See ( 1 , i ) then
4684: LD_INT 1
4686: PPUSH
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 292
4696: IFFALSE 4732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4698: LD_VAR 0 1
4702: PPUSH
4703: LD_INT 81
4705: PUSH
4706: LD_INT 2
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PPUSH
4713: CALL_OW 69
4717: PPUSH
4718: LD_VAR 0 1
4722: PPUSH
4723: CALL_OW 74
4727: PPUSH
4728: CALL_OW 115
4732: GO 4681
4734: POP
4735: POP
// end ;
4736: PPOPN 1
4738: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4739: LD_EXP 13
4743: IFFALSE 5060
4745: GO 4747
4747: DISABLE
4748: LD_INT 0
4750: PPUSH
4751: PPUSH
4752: PPUSH
4753: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4754: LD_INT 35
4756: PPUSH
4757: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4761: LD_INT 1
4763: PPUSH
4764: CALL 42521 0 1
4768: PUSH
4769: LD_INT 0
4771: EQUAL
4772: IFFALSE 4754
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4774: LD_INT 1
4776: PPUSH
4777: LD_INT 14
4779: PUSH
4780: LD_INT 3
4782: PUSH
4783: LD_INT 2
4785: PUSH
4786: LD_INT 32
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: PPUSH
4798: CALL 42125 0 2
// repeat wait ( 0 0$1 ) ;
4802: LD_INT 35
4804: PPUSH
4805: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4809: LD_EXP 69
4813: PUSH
4814: LD_INT 1
4816: ARRAY
4817: PPUSH
4818: LD_INT 33
4820: PUSH
4821: LD_INT 2
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 34
4830: PUSH
4831: LD_INT 32
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PPUSH
4842: CALL_OW 72
4846: IFFALSE 4802
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4848: LD_ADDR_VAR 0 2
4852: PUSH
4853: LD_EXP 69
4857: PUSH
4858: LD_INT 1
4860: ARRAY
4861: PPUSH
4862: LD_INT 33
4864: PUSH
4865: LD_INT 2
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: LD_INT 34
4874: PUSH
4875: LD_INT 32
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PPUSH
4886: CALL_OW 72
4890: PUSH
4891: LD_INT 1
4893: ARRAY
4894: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4895: LD_ADDR_VAR 0 4
4899: PUSH
4900: LD_INT 5
4902: PPUSH
4903: CALL_OW 469
4907: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4908: LD_INT 35
4910: PPUSH
4911: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4915: LD_ADDR_VAR 0 4
4919: PUSH
4920: LD_INT 5
4922: PPUSH
4923: CALL_OW 469
4927: ST_TO_ADDR
// tmp := 100 ;
4928: LD_ADDR_VAR 0 3
4932: PUSH
4933: LD_INT 100
4935: ST_TO_ADDR
// if pos then
4936: LD_VAR 0 4
4940: IFFALSE 4980
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4942: LD_ADDR_VAR 0 3
4946: PUSH
4947: LD_INT 2
4949: PPUSH
4950: LD_VAR 0 4
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 2
4966: ARRAY
4967: PPUSH
4968: LD_INT 20
4970: PPUSH
4971: CALL 54461 0 4
4975: PUSH
4976: LD_INT 4
4978: ARRAY
4979: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4980: LD_VAR 0 4
4984: PUSH
4985: LD_EXP 14
4989: NOT
4990: AND
4991: PUSH
4992: LD_VAR 0 3
4996: PUSH
4997: LD_INT 10
4999: LESS
5000: AND
5001: IFFALSE 4908
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5003: LD_VAR 0 2
5007: PPUSH
5008: LD_VAR 0 4
5012: PUSH
5013: LD_INT 1
5015: ARRAY
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 2
5024: ARRAY
5025: PPUSH
5026: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5030: LD_VAR 0 2
5034: PPUSH
5035: LD_INT 198
5037: PPUSH
5038: LD_INT 113
5040: PPUSH
5041: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5045: LD_VAR 0 2
5049: PPUSH
5050: LD_INT 124
5052: PPUSH
5053: LD_INT 7
5055: PPUSH
5056: CALL_OW 171
// end ;
5060: PPOPN 4
5062: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5063: LD_EXP 6
5067: IFFALSE 7936
5069: GO 5071
5071: DISABLE
5072: LD_INT 0
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
5079: PPUSH
5080: PPUSH
5081: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5082: LD_ADDR_VAR 0 4
5086: PUSH
5087: LD_INT 5
5089: PUSH
5090: LD_INT 6
5092: PUSH
5093: LD_INT 7
5095: PUSH
5096: LD_INT 8
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_OWVAR 67
5109: ARRAY
5110: ST_TO_ADDR
// coords := [ ] ;
5111: LD_ADDR_VAR 0 5
5115: PUSH
5116: EMPTY
5117: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5118: LD_ADDR_VAR 0 6
5122: PUSH
5123: LD_INT 0
5125: PUSH
5126: LD_INT 0
5128: PUSH
5129: LD_INT 0
5131: PUSH
5132: LD_INT 0
5134: PUSH
5135: LD_INT 1
5137: PUSH
5138: LD_INT 0
5140: PUSH
5141: LD_INT 0
5143: PUSH
5144: LD_INT 0
5146: PUSH
5147: LD_INT 1
5149: PUSH
5150: LD_INT 0
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5165: LD_INT 1
5167: PPUSH
5168: LD_INT 14
5170: PUSH
5171: LD_INT 1
5173: PUSH
5174: LD_INT 2
5176: PUSH
5177: LD_INT 28
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 14
5188: PUSH
5189: LD_INT 1
5191: PUSH
5192: LD_INT 2
5194: PUSH
5195: LD_INT 25
5197: PUSH
5198: EMPTY
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: PUSH
5204: LD_INT 14
5206: PUSH
5207: LD_INT 1
5209: PUSH
5210: LD_INT 2
5212: PUSH
5213: LD_INT 28
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_INT 14
5224: PUSH
5225: LD_INT 1
5227: PUSH
5228: LD_INT 2
5230: PUSH
5231: LD_INT 29
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: PPUSH
5246: CALL 42125 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5250: LD_INT 21000
5252: PUSH
5253: LD_INT 19950
5255: PUSH
5256: LD_INT 18900
5258: PUSH
5259: LD_INT 18200
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: PUSH
5268: LD_OWVAR 67
5272: ARRAY
5273: PPUSH
5274: CALL_OW 67
// InitHc ;
5278: CALL_OW 19
// InitUc ;
5282: CALL_OW 18
// uc_side := 2 ;
5286: LD_ADDR_OWVAR 20
5290: PUSH
5291: LD_INT 2
5293: ST_TO_ADDR
// uc_nation := 2 ;
5294: LD_ADDR_OWVAR 21
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: EMPTY
5308: PUSH
5309: EMPTY
5310: PUSH
5311: EMPTY
5312: PUSH
5313: EMPTY
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: LIST
5323: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5324: LD_ADDR_VAR 0 3
5328: PUSH
5329: LD_VAR 0 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_EXP 69
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PUSH
5346: LD_INT 2
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_EXP 100
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: PUSH
5361: LD_INT 34
5363: PUSH
5364: LD_INT 32
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: LIST
5375: PPUSH
5376: CALL_OW 69
5380: DIFF
5381: PPUSH
5382: CALL_OW 1
5386: ST_TO_ADDR
// for i = 1 to Difficulty do
5387: LD_ADDR_VAR 0 1
5391: PUSH
5392: DOUBLE
5393: LD_INT 1
5395: DEC
5396: ST_TO_ADDR
5397: LD_OWVAR 67
5401: PUSH
5402: FOR_TO
5403: IFFALSE 5541
// begin uc_side := 2 ;
5405: LD_ADDR_OWVAR 20
5409: PUSH
5410: LD_INT 2
5412: ST_TO_ADDR
// uc_nation := 2 ;
5413: LD_ADDR_OWVAR 21
5417: PUSH
5418: LD_INT 2
5420: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5421: LD_INT 13
5423: PPUSH
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 5
5429: PPUSH
5430: LD_INT 29
5432: PPUSH
5433: LD_INT 100
5435: PPUSH
5436: CALL 53443 0 5
// un := CreateVehicle ;
5440: LD_ADDR_VAR 0 2
5444: PUSH
5445: CALL_OW 45
5449: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5450: LD_ADDR_VAR 0 3
5454: PUSH
5455: LD_VAR 0 3
5459: PPUSH
5460: LD_INT 1
5462: PUSH
5463: LD_VAR 0 3
5467: PUSH
5468: LD_INT 1
5470: ARRAY
5471: PUSH
5472: LD_INT 1
5474: PLUS
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PPUSH
5480: LD_VAR 0 2
5484: PPUSH
5485: CALL 53565 0 3
5489: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 3
5497: PPUSH
5498: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5502: LD_VAR 0 2
5506: PPUSH
5507: LD_INT 16
5509: PPUSH
5510: LD_INT 0
5512: PPUSH
5513: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5517: LD_VAR 0 2
5521: PPUSH
5522: LD_INT 51
5524: PPUSH
5525: LD_INT 10
5527: PPUSH
5528: CALL_OW 111
// wait ( 0 0$2 ) ;
5532: LD_INT 70
5534: PPUSH
5535: CALL_OW 67
// end ;
5539: GO 5402
5541: POP
5542: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5543: LD_ADDR_VAR 0 5
5547: PUSH
5548: LD_INT 51
5550: PUSH
5551: LD_INT 24
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: LD_INT 75
5560: PUSH
5561: LD_INT 90
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5572: LD_INT 1
5574: PPUSH
5575: LD_VAR 0 3
5579: PUSH
5580: LD_INT 1
5582: ARRAY
5583: PPUSH
5584: LD_VAR 0 5
5588: PPUSH
5589: LD_VAR 0 6
5593: PPUSH
5594: CALL 42358 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5598: LD_ADDR_VAR 0 1
5602: PUSH
5603: DOUBLE
5604: LD_INT 1
5606: DEC
5607: ST_TO_ADDR
5608: LD_INT 1
5610: PUSH
5611: LD_INT 3
5613: PUSH
5614: LD_INT 3
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: LIST
5625: PUSH
5626: LD_OWVAR 67
5630: ARRAY
5631: PUSH
5632: FOR_TO
5633: IFFALSE 5733
// begin uc_side := 2 ;
5635: LD_ADDR_OWVAR 20
5639: PUSH
5640: LD_INT 2
5642: ST_TO_ADDR
// uc_nation := 2 ;
5643: LD_ADDR_OWVAR 21
5647: PUSH
5648: LD_INT 2
5650: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5651: LD_INT 0
5653: PPUSH
5654: LD_INT 17
5656: PPUSH
5657: LD_VAR 0 4
5661: PPUSH
5662: CALL_OW 380
// un := CreateHuman ;
5666: LD_ADDR_VAR 0 2
5670: PUSH
5671: CALL_OW 44
5675: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5676: LD_ADDR_VAR 0 3
5680: PUSH
5681: LD_VAR 0 3
5685: PPUSH
5686: LD_INT 2
5688: PUSH
5689: LD_VAR 0 3
5693: PUSH
5694: LD_INT 2
5696: ARRAY
5697: PUSH
5698: LD_INT 1
5700: PLUS
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PPUSH
5706: LD_VAR 0 2
5710: PPUSH
5711: CALL 53565 0 3
5715: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5716: LD_VAR 0 2
5720: PPUSH
5721: LD_INT 13
5723: PPUSH
5724: LD_INT 0
5726: PPUSH
5727: CALL_OW 49
// end ;
5731: GO 5632
5733: POP
5734: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5735: LD_ADDR_VAR 0 1
5739: PUSH
5740: DOUBLE
5741: LD_INT 1
5743: DEC
5744: ST_TO_ADDR
5745: LD_INT 3
5747: PUSH
5748: LD_INT 4
5750: PUSH
5751: LD_INT 4
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: PUSH
5763: LD_OWVAR 67
5767: ARRAY
5768: PUSH
5769: FOR_TO
5770: IFFALSE 5891
// begin uc_side := 2 ;
5772: LD_ADDR_OWVAR 20
5776: PUSH
5777: LD_INT 2
5779: ST_TO_ADDR
// uc_nation := 2 ;
5780: LD_ADDR_OWVAR 21
5784: PUSH
5785: LD_INT 2
5787: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5788: LD_INT 0
5790: PPUSH
5791: LD_INT 1
5793: PUSH
5794: LD_INT 8
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PUSH
5801: LD_VAR 0 1
5805: PUSH
5806: LD_INT 2
5808: MOD
5809: PUSH
5810: LD_INT 1
5812: PLUS
5813: ARRAY
5814: PPUSH
5815: LD_VAR 0 4
5819: PPUSH
5820: CALL_OW 380
// un := CreateHuman ;
5824: LD_ADDR_VAR 0 2
5828: PUSH
5829: CALL_OW 44
5833: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5834: LD_ADDR_VAR 0 3
5838: PUSH
5839: LD_VAR 0 3
5843: PPUSH
5844: LD_INT 2
5846: PUSH
5847: LD_VAR 0 3
5851: PUSH
5852: LD_INT 2
5854: ARRAY
5855: PUSH
5856: LD_INT 1
5858: PLUS
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: PPUSH
5864: LD_VAR 0 2
5868: PPUSH
5869: CALL 53565 0 3
5873: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5874: LD_VAR 0 2
5878: PPUSH
5879: LD_INT 13
5881: PPUSH
5882: LD_INT 0
5884: PPUSH
5885: CALL_OW 49
// end ;
5889: GO 5769
5891: POP
5892: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5893: LD_ADDR_VAR 0 5
5897: PUSH
5898: LD_INT 67
5900: PUSH
5901: LD_INT 112
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 85
5910: PUSH
5911: LD_INT 130
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5922: LD_INT 2
5924: PPUSH
5925: LD_VAR 0 3
5929: PUSH
5930: LD_INT 2
5932: ARRAY
5933: PPUSH
5934: LD_VAR 0 5
5938: PPUSH
5939: LD_VAR 0 6
5943: PPUSH
5944: CALL 42358 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5948: LD_ADDR_VAR 0 1
5952: PUSH
5953: DOUBLE
5954: LD_INT 1
5956: DEC
5957: ST_TO_ADDR
5958: LD_INT 1
5960: PUSH
5961: LD_INT 2
5963: PUSH
5964: LD_INT 3
5966: PUSH
5967: LD_INT 4
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: PUSH
5976: LD_OWVAR 67
5980: ARRAY
5981: PUSH
5982: FOR_TO
5983: IFFALSE 6083
// begin uc_side := 2 ;
5985: LD_ADDR_OWVAR 20
5989: PUSH
5990: LD_INT 2
5992: ST_TO_ADDR
// uc_nation := 2 ;
5993: LD_ADDR_OWVAR 21
5997: PUSH
5998: LD_INT 2
6000: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6001: LD_INT 0
6003: PPUSH
6004: LD_INT 17
6006: PPUSH
6007: LD_VAR 0 4
6011: PPUSH
6012: CALL_OW 380
// un := CreateHuman ;
6016: LD_ADDR_VAR 0 2
6020: PUSH
6021: CALL_OW 44
6025: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6026: LD_ADDR_VAR 0 3
6030: PUSH
6031: LD_VAR 0 3
6035: PPUSH
6036: LD_INT 3
6038: PUSH
6039: LD_VAR 0 3
6043: PUSH
6044: LD_INT 3
6046: ARRAY
6047: PUSH
6048: LD_INT 1
6050: PLUS
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: PPUSH
6056: LD_VAR 0 2
6060: PPUSH
6061: CALL 53565 0 3
6065: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_INT 14
6073: PPUSH
6074: LD_INT 0
6076: PPUSH
6077: CALL_OW 49
// end ;
6081: GO 5982
6083: POP
6084: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6085: LD_ADDR_VAR 0 5
6089: PUSH
6090: LD_INT 148
6092: PUSH
6093: LD_INT 158
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 148
6102: PUSH
6103: LD_INT 158
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6114: LD_INT 3
6116: PPUSH
6117: LD_VAR 0 3
6121: PUSH
6122: LD_INT 3
6124: ARRAY
6125: PPUSH
6126: LD_VAR 0 5
6130: PPUSH
6131: LD_VAR 0 6
6135: PPUSH
6136: CALL 42358 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6140: LD_ADDR_VAR 0 1
6144: PUSH
6145: DOUBLE
6146: LD_INT 1
6148: DEC
6149: ST_TO_ADDR
6150: LD_INT 2
6152: PUSH
6153: LD_INT 3
6155: PUSH
6156: LD_INT 4
6158: PUSH
6159: LD_INT 4
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: LIST
6167: PUSH
6168: LD_OWVAR 67
6172: ARRAY
6173: PUSH
6174: FOR_TO
6175: IFFALSE 6399
// begin uc_side := 2 ;
6177: LD_ADDR_OWVAR 20
6181: PUSH
6182: LD_INT 2
6184: ST_TO_ADDR
// uc_nation := 2 ;
6185: LD_ADDR_OWVAR 21
6189: PUSH
6190: LD_INT 2
6192: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6193: LD_INT 14
6195: PPUSH
6196: LD_INT 3
6198: PPUSH
6199: LD_INT 1
6201: PUSH
6202: LD_INT 5
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 1
6211: PPUSH
6212: LD_INT 2
6214: PPUSH
6215: CALL_OW 12
6219: ARRAY
6220: PPUSH
6221: LD_INT 27
6223: PUSH
6224: LD_INT 26
6226: PUSH
6227: LD_INT 28
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 1
6237: PPUSH
6238: LD_INT 3
6240: PPUSH
6241: CALL_OW 12
6245: ARRAY
6246: PPUSH
6247: LD_INT 100
6249: PPUSH
6250: CALL 53443 0 5
// un := CreateVehicle ;
6254: LD_ADDR_VAR 0 2
6258: PUSH
6259: CALL_OW 45
6263: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6264: LD_ADDR_VAR 0 3
6268: PUSH
6269: LD_VAR 0 3
6273: PPUSH
6274: LD_INT 4
6276: PUSH
6277: LD_VAR 0 3
6281: PUSH
6282: LD_INT 4
6284: ARRAY
6285: PUSH
6286: LD_INT 1
6288: PLUS
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_VAR 0 2
6298: PPUSH
6299: CALL 53565 0 3
6303: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 5
6311: PPUSH
6312: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6316: LD_VAR 0 2
6320: PPUSH
6321: LD_INT 15
6323: PPUSH
6324: LD_INT 0
6326: PPUSH
6327: CALL_OW 49
// if GetControl ( un ) = control_manual then
6331: LD_VAR 0 2
6335: PPUSH
6336: CALL_OW 263
6340: PUSH
6341: LD_INT 1
6343: EQUAL
6344: IFFALSE 6375
// begin PrepareHuman ( false , 3 , skill ) ;
6346: LD_INT 0
6348: PPUSH
6349: LD_INT 3
6351: PPUSH
6352: LD_VAR 0 4
6356: PPUSH
6357: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6361: CALL_OW 44
6365: PPUSH
6366: LD_VAR 0 2
6370: PPUSH
6371: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6375: LD_VAR 0 2
6379: PPUSH
6380: LD_INT 179
6382: PPUSH
6383: LD_INT 135
6385: PPUSH
6386: CALL_OW 111
// wait ( 0 0$2 ) ;
6390: LD_INT 70
6392: PPUSH
6393: CALL_OW 67
// end ;
6397: GO 6174
6399: POP
6400: POP
// vc_chassis := 15 ;
6401: LD_ADDR_OWVAR 37
6405: PUSH
6406: LD_INT 15
6408: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6409: LD_ADDR_VAR 0 3
6413: PUSH
6414: LD_VAR 0 3
6418: PPUSH
6419: LD_INT 4
6421: PUSH
6422: LD_VAR 0 3
6426: PUSH
6427: LD_INT 4
6429: ARRAY
6430: PUSH
6431: LD_INT 1
6433: PLUS
6434: PUSH
6435: EMPTY
6436: LIST
6437: LIST
6438: PPUSH
6439: CALL_OW 45
6443: PPUSH
6444: CALL 53565 0 3
6448: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6449: LD_VAR 0 3
6453: PUSH
6454: LD_INT 4
6456: ARRAY
6457: PUSH
6458: LD_VAR 0 3
6462: PUSH
6463: LD_INT 4
6465: ARRAY
6466: ARRAY
6467: PPUSH
6468: LD_INT 15
6470: PPUSH
6471: LD_INT 0
6473: PPUSH
6474: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6478: LD_INT 0
6480: PPUSH
6481: LD_INT 11
6483: PPUSH
6484: LD_VAR 0 4
6488: PPUSH
6489: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6493: LD_ADDR_VAR 0 3
6497: PUSH
6498: LD_VAR 0 3
6502: PPUSH
6503: LD_INT 4
6505: PUSH
6506: LD_VAR 0 3
6510: PUSH
6511: LD_INT 4
6513: ARRAY
6514: PUSH
6515: LD_INT 1
6517: PLUS
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PPUSH
6523: CALL_OW 44
6527: PPUSH
6528: CALL 53565 0 3
6532: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6533: LD_VAR 0 3
6537: PUSH
6538: LD_INT 4
6540: ARRAY
6541: PUSH
6542: LD_VAR 0 3
6546: PUSH
6547: LD_INT 4
6549: ARRAY
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 3
6556: PUSH
6557: LD_INT 4
6559: ARRAY
6560: PUSH
6561: LD_VAR 0 3
6565: PUSH
6566: LD_INT 4
6568: ARRAY
6569: PUSH
6570: LD_INT 1
6572: MINUS
6573: ARRAY
6574: PPUSH
6575: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6579: LD_ADDR_VAR 0 5
6583: PUSH
6584: LD_INT 148
6586: PUSH
6587: LD_INT 140
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6597: LD_INT 1
6599: PPUSH
6600: LD_VAR 0 3
6604: PUSH
6605: LD_INT 4
6607: ARRAY
6608: PPUSH
6609: LD_VAR 0 5
6613: PPUSH
6614: LD_VAR 0 6
6618: PPUSH
6619: CALL 42358 0 4
// if gensher_active then
6623: LD_EXP 18
6627: IFFALSE 7033
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6629: LD_EXP 45
6633: PPUSH
6634: LD_STRING D10-Diet-1
6636: PPUSH
6637: CALL_OW 94
// for i = 1 to 2 do
6641: LD_ADDR_VAR 0 1
6645: PUSH
6646: DOUBLE
6647: LD_INT 1
6649: DEC
6650: ST_TO_ADDR
6651: LD_INT 2
6653: PUSH
6654: FOR_TO
6655: IFFALSE 6793
// begin uc_side := 2 ;
6657: LD_ADDR_OWVAR 20
6661: PUSH
6662: LD_INT 2
6664: ST_TO_ADDR
// uc_nation := 2 ;
6665: LD_ADDR_OWVAR 21
6669: PUSH
6670: LD_INT 2
6672: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6673: LD_INT 13
6675: PPUSH
6676: LD_INT 3
6678: PPUSH
6679: LD_INT 5
6681: PPUSH
6682: LD_INT 29
6684: PPUSH
6685: LD_INT 100
6687: PPUSH
6688: CALL 53443 0 5
// un := CreateVehicle ;
6692: LD_ADDR_VAR 0 2
6696: PUSH
6697: CALL_OW 45
6701: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6702: LD_ADDR_VAR 0 3
6706: PUSH
6707: LD_VAR 0 3
6711: PPUSH
6712: LD_INT 5
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_INT 5
6722: ARRAY
6723: PUSH
6724: LD_INT 1
6726: PLUS
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PPUSH
6732: LD_VAR 0 2
6736: PPUSH
6737: CALL 53565 0 3
6741: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 0
6749: PPUSH
6750: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6754: LD_VAR 0 2
6758: PPUSH
6759: LD_INT 23
6761: PPUSH
6762: LD_INT 0
6764: PPUSH
6765: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6769: LD_VAR 0 2
6773: PPUSH
6774: LD_INT 85
6776: PPUSH
6777: LD_INT 152
6779: PPUSH
6780: CALL_OW 111
// wait ( 0 0$2 ) ;
6784: LD_INT 70
6786: PPUSH
6787: CALL_OW 67
// end ;
6791: GO 6654
6793: POP
6794: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6795: LD_ADDR_VAR 0 1
6799: PUSH
6800: DOUBLE
6801: LD_INT 1
6803: DEC
6804: ST_TO_ADDR
6805: LD_INT 2
6807: PUSH
6808: LD_INT 3
6810: PUSH
6811: LD_INT 3
6813: PUSH
6814: LD_INT 4
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: LD_OWVAR 67
6827: ARRAY
6828: PUSH
6829: FOR_TO
6830: IFFALSE 6987
// begin uc_side := 2 ;
6832: LD_ADDR_OWVAR 20
6836: PUSH
6837: LD_INT 2
6839: ST_TO_ADDR
// uc_nation := 2 ;
6840: LD_ADDR_OWVAR 21
6844: PUSH
6845: LD_INT 2
6847: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6848: LD_INT 14
6850: PPUSH
6851: LD_INT 3
6853: PPUSH
6854: LD_INT 5
6856: PPUSH
6857: LD_INT 27
6859: PUSH
6860: LD_INT 28
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: PUSH
6867: LD_INT 1
6869: PPUSH
6870: LD_INT 2
6872: PPUSH
6873: CALL_OW 12
6877: ARRAY
6878: PPUSH
6879: LD_INT 100
6881: PPUSH
6882: CALL 53443 0 5
// un := CreateVehicle ;
6886: LD_ADDR_VAR 0 2
6890: PUSH
6891: CALL_OW 45
6895: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6896: LD_ADDR_VAR 0 3
6900: PUSH
6901: LD_VAR 0 3
6905: PPUSH
6906: LD_INT 5
6908: PUSH
6909: LD_VAR 0 3
6913: PUSH
6914: LD_INT 5
6916: ARRAY
6917: PUSH
6918: LD_INT 1
6920: PLUS
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PPUSH
6926: LD_VAR 0 2
6930: PPUSH
6931: CALL 53565 0 3
6935: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 0
6943: PPUSH
6944: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: LD_INT 23
6955: PPUSH
6956: LD_INT 0
6958: PPUSH
6959: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6963: LD_VAR 0 2
6967: PPUSH
6968: LD_INT 85
6970: PPUSH
6971: LD_INT 152
6973: PPUSH
6974: CALL_OW 111
// wait ( 0 0$2 ) ;
6978: LD_INT 70
6980: PPUSH
6981: CALL_OW 67
// end ;
6985: GO 6829
6987: POP
6988: POP
// coords := [ [ 97 , 143 ] ] ;
6989: LD_ADDR_VAR 0 5
6993: PUSH
6994: LD_INT 97
6996: PUSH
6997: LD_INT 143
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: EMPTY
7005: LIST
7006: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7007: LD_INT 1
7009: PPUSH
7010: LD_VAR 0 3
7014: PUSH
7015: LD_INT 5
7017: ARRAY
7018: PPUSH
7019: LD_VAR 0 5
7023: PPUSH
7024: LD_VAR 0 6
7028: PPUSH
7029: CALL 42358 0 4
// end ; Wait ( 13 13$00 ) ;
7033: LD_INT 27300
7035: PPUSH
7036: CALL_OW 67
// tmp := [ ] ;
7040: LD_ADDR_VAR 0 3
7044: PUSH
7045: EMPTY
7046: ST_TO_ADDR
// w := 1 ;
7047: LD_ADDR_VAR 0 7
7051: PUSH
7052: LD_INT 1
7054: ST_TO_ADDR
// repeat tmp := [ ] ;
7055: LD_ADDR_VAR 0 3
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// if w mod 4 = 0 then
7062: LD_VAR 0 7
7066: PUSH
7067: LD_INT 4
7069: MOD
7070: PUSH
7071: LD_INT 0
7073: EQUAL
7074: IFFALSE 7161
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7076: LD_ADDR_VAR 0 8
7080: PUSH
7081: LD_INT 11
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: LD_INT 2
7089: PUSH
7090: LD_INT 24
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 11
7101: PUSH
7102: LD_INT 1
7104: PUSH
7105: LD_INT 2
7107: PUSH
7108: LD_INT 24
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 11
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 24
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 11
7137: PUSH
7138: LD_INT 1
7140: PUSH
7141: LD_INT 2
7143: PUSH
7144: LD_INT 24
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: LIST
7151: LIST
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: ST_TO_ADDR
7159: GO 7263
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7161: LD_ADDR_VAR 0 8
7165: PUSH
7166: LD_INT 14
7168: PUSH
7169: LD_INT 1
7171: PUSH
7172: LD_INT 2
7174: PUSH
7175: LD_INT 28
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_INT 14
7186: PUSH
7187: LD_INT 1
7189: PUSH
7190: LD_INT 2
7192: PUSH
7193: LD_INT 25
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 14
7204: PUSH
7205: LD_INT 1
7207: PUSH
7208: LD_INT 2
7210: PUSH
7211: LD_INT 28
7213: PUSH
7214: EMPTY
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 14
7222: PUSH
7223: LD_INT 1
7225: PUSH
7226: LD_INT 2
7228: PUSH
7229: LD_INT 29
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PUSH
7238: LD_INT 11
7240: PUSH
7241: LD_INT 1
7243: PUSH
7244: LD_INT 2
7246: PUSH
7247: LD_INT 24
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: LIST
7262: ST_TO_ADDR
// if w mod 3 = 0 then
7263: LD_VAR 0 7
7267: PUSH
7268: LD_INT 3
7270: MOD
7271: PUSH
7272: LD_INT 0
7274: EQUAL
7275: IFFALSE 7351
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7277: LD_ADDR_VAR 0 8
7281: PUSH
7282: LD_VAR 0 8
7286: PPUSH
7287: LD_INT 1
7289: PUSH
7290: LD_VAR 0 8
7294: PUSH
7295: LD_VAR 0 1
7299: ARRAY
7300: PUSH
7301: LD_INT 1
7303: PLUS
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: PPUSH
7309: LD_INT 14
7311: PUSH
7312: LD_INT 1
7314: PUSH
7315: LD_INT 2
7317: PUSH
7318: LD_INT 25
7320: PUSH
7321: LD_INT 28
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: LIST
7344: LIST
7345: PPUSH
7346: CALL 53565 0 3
7350: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7351: LD_INT 1
7353: PPUSH
7354: LD_VAR 0 8
7358: PPUSH
7359: CALL 42125 0 2
// if GetSide ( ar_dep_w ) = 2 then
7363: LD_INT 45
7365: PPUSH
7366: CALL_OW 255
7370: PUSH
7371: LD_INT 2
7373: EQUAL
7374: IFFALSE 7459
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7376: LD_ADDR_VAR 0 8
7380: PUSH
7381: LD_INT 14
7383: PUSH
7384: LD_INT 1
7386: PUSH
7387: LD_INT 2
7389: PUSH
7390: LD_INT 28
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: LIST
7398: PUSH
7399: LD_INT 14
7401: PUSH
7402: LD_INT 1
7404: PUSH
7405: LD_INT 2
7407: PUSH
7408: LD_INT 27
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 14
7419: PUSH
7420: LD_INT 1
7422: PUSH
7423: LD_INT 2
7425: PUSH
7426: LD_INT 27
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: LIST
7433: LIST
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: LIST
7439: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7440: LD_INT 2
7442: PPUSH
7443: LD_VAR 0 8
7447: PPUSH
7448: CALL 42125 0 2
// wait ( 0 0$50 ) ;
7452: LD_INT 1750
7454: PPUSH
7455: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7459: LD_INT 35
7461: PPUSH
7462: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7466: LD_EXP 69
7470: PUSH
7471: LD_INT 1
7473: ARRAY
7474: PPUSH
7475: LD_INT 3
7477: PUSH
7478: LD_INT 2
7480: PUSH
7481: LD_INT 34
7483: PUSH
7484: LD_INT 32
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 34
7493: PUSH
7494: LD_EXP 100
7498: PUSH
7499: EMPTY
7500: LIST
7501: LIST
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PPUSH
7512: CALL_OW 72
7516: PUSH
7517: LD_INT 4
7519: GREATEREQUAL
7520: IFFALSE 7459
// wait ( 0 0$10 ) ;
7522: LD_INT 350
7524: PPUSH
7525: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7529: LD_ADDR_VAR 0 3
7533: PUSH
7534: LD_EXP 69
7538: PUSH
7539: LD_INT 1
7541: ARRAY
7542: PPUSH
7543: LD_INT 3
7545: PUSH
7546: LD_INT 2
7548: PUSH
7549: LD_INT 34
7551: PUSH
7552: LD_INT 32
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 34
7561: PUSH
7562: LD_EXP 100
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 72
7584: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7585: LD_INT 100
7587: PPUSH
7588: CALL_OW 13
7592: PUSH
7593: LD_INT 50
7595: LESS
7596: IFFALSE 7629
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7598: LD_ADDR_VAR 0 5
7602: PUSH
7603: LD_INT 55
7605: PUSH
7606: LD_INT 7
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 75
7615: PUSH
7616: LD_INT 90
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: ST_TO_ADDR
7627: GO 7658
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7629: LD_ADDR_VAR 0 5
7633: PUSH
7634: LD_INT 128
7636: PUSH
7637: LD_INT 94
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: LD_INT 180
7646: PUSH
7647: LD_INT 135
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: ST_TO_ADDR
// if w mod 4 = 0 then
7658: LD_VAR 0 7
7662: PUSH
7663: LD_INT 4
7665: MOD
7666: PUSH
7667: LD_INT 0
7669: EQUAL
7670: IFFALSE 7701
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7672: LD_ADDR_VAR 0 5
7676: PUSH
7677: LD_INT 91
7679: PUSH
7680: LD_INT 58
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: PUSH
7687: LD_INT 117
7689: PUSH
7690: LD_INT 107
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7701: LD_VAR 0 3
7705: PPUSH
7706: LD_VAR 0 5
7710: PUSH
7711: LD_INT 1
7713: ARRAY
7714: PPUSH
7715: LD_VAR 0 5
7719: PUSH
7720: LD_INT 2
7722: ARRAY
7723: PPUSH
7724: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7728: LD_INT 35
7730: PPUSH
7731: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7735: LD_VAR 0 3
7739: PPUSH
7740: LD_INT 60
7742: PUSH
7743: EMPTY
7744: LIST
7745: PPUSH
7746: CALL_OW 72
7750: PUSH
7751: LD_INT 0
7753: EQUAL
7754: IFFALSE 7728
// repeat wait ( 0 0$2 ) ;
7756: LD_INT 70
7758: PPUSH
7759: CALL_OW 67
// for i in tmp do
7763: LD_ADDR_VAR 0 1
7767: PUSH
7768: LD_VAR 0 3
7772: PUSH
7773: FOR_IN
7774: IFFALSE 7863
// if GetChassis ( i ) = ar_hovercraft then
7776: LD_VAR 0 1
7780: PPUSH
7781: CALL_OW 265
7785: PUSH
7786: LD_INT 11
7788: EQUAL
7789: IFFALSE 7827
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7791: LD_VAR 0 1
7795: PPUSH
7796: LD_INT 22
7798: PUSH
7799: LD_INT 1
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 69
7810: PPUSH
7811: LD_VAR 0 1
7815: PPUSH
7816: CALL_OW 74
7820: PPUSH
7821: CALL 81461 0 2
7825: GO 7861
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7827: LD_VAR 0 1
7831: PPUSH
7832: LD_INT 22
7834: PUSH
7835: LD_INT 1
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 69
7846: PPUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: CALL_OW 74
7856: PPUSH
7857: CALL_OW 115
7861: GO 7773
7863: POP
7864: POP
// until not tmp ;
7865: LD_VAR 0 3
7869: NOT
7870: IFFALSE 7756
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7872: LD_INT 22050
7874: PPUSH
7875: LD_INT 28350
7877: PPUSH
7878: CALL_OW 12
7882: PPUSH
7883: CALL_OW 67
// w := w + 1 ;
7887: LD_ADDR_VAR 0 7
7891: PUSH
7892: LD_VAR 0 7
7896: PUSH
7897: LD_INT 1
7899: PLUS
7900: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7901: LD_INT 94
7903: PPUSH
7904: CALL_OW 301
7908: PUSH
7909: LD_EXP 50
7913: PUSH
7914: LD_INT 1
7916: ARRAY
7917: PPUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 3
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 72
7932: NOT
7933: OR
7934: IFFALSE 7055
// end ;
7936: PPOPN 8
7938: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7939: LD_INT 204
7941: IFFALSE 8407
7943: GO 7945
7945: DISABLE
7946: LD_INT 0
7948: PPUSH
7949: PPUSH
7950: PPUSH
7951: PPUSH
// begin enable ;
7952: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7953: LD_INT 35
7955: PPUSH
7956: LD_INT 1190
7958: PPUSH
7959: CALL_OW 12
7963: PPUSH
7964: CALL_OW 67
// tmp := [ ] ;
7968: LD_ADDR_VAR 0 2
7972: PUSH
7973: EMPTY
7974: ST_TO_ADDR
// uc_side := 8 ;
7975: LD_ADDR_OWVAR 20
7979: PUSH
7980: LD_INT 8
7982: ST_TO_ADDR
// uc_nation := 2 ;
7983: LD_ADDR_OWVAR 21
7987: PUSH
7988: LD_INT 2
7990: ST_TO_ADDR
// InitHc ;
7991: CALL_OW 19
// for i = 1 to 3 do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: DOUBLE
8001: LD_INT 1
8003: DEC
8004: ST_TO_ADDR
8005: LD_INT 3
8007: PUSH
8008: FOR_TO
8009: IFFALSE 8136
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8011: LD_INT 13
8013: PUSH
8014: LD_INT 14
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 1
8023: PPUSH
8024: LD_INT 2
8026: PPUSH
8027: CALL_OW 12
8031: ARRAY
8032: PPUSH
8033: LD_INT 3
8035: PPUSH
8036: LD_INT 5
8038: PPUSH
8039: LD_INT 27
8041: PUSH
8042: LD_INT 28
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: LD_INT 1
8051: PPUSH
8052: LD_INT 2
8054: PPUSH
8055: CALL_OW 12
8059: ARRAY
8060: PPUSH
8061: LD_INT 100
8063: PPUSH
8064: CALL 53443 0 5
// un := CreateVehicle ;
8068: LD_ADDR_VAR 0 3
8072: PUSH
8073: CALL_OW 45
8077: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8078: LD_VAR 0 3
8082: PPUSH
8083: LD_INT 4
8085: PPUSH
8086: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8090: LD_VAR 0 3
8094: PPUSH
8095: LD_INT 15
8097: PPUSH
8098: LD_INT 0
8100: PPUSH
8101: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8105: LD_ADDR_VAR 0 2
8109: PUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: LD_VAR 0 2
8119: PUSH
8120: LD_INT 1
8122: PLUS
8123: PPUSH
8124: LD_VAR 0 3
8128: PPUSH
8129: CALL_OW 1
8133: ST_TO_ADDR
// end ;
8134: GO 8008
8136: POP
8137: POP
// for i = 1 to 4 do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: DOUBLE
8144: LD_INT 1
8146: DEC
8147: ST_TO_ADDR
8148: LD_INT 4
8150: PUSH
8151: FOR_TO
8152: IFFALSE 8223
// begin PrepareHuman ( false , 1 , 6 ) ;
8154: LD_INT 0
8156: PPUSH
8157: LD_INT 1
8159: PPUSH
8160: LD_INT 6
8162: PPUSH
8163: CALL_OW 380
// un := CreateHuman ;
8167: LD_ADDR_VAR 0 3
8171: PUSH
8172: CALL_OW 44
8176: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8177: LD_VAR 0 3
8181: PPUSH
8182: LD_INT 15
8184: PPUSH
8185: LD_INT 0
8187: PPUSH
8188: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8192: LD_ADDR_VAR 0 2
8196: PUSH
8197: LD_VAR 0 2
8201: PPUSH
8202: LD_VAR 0 2
8206: PUSH
8207: LD_INT 1
8209: PLUS
8210: PPUSH
8211: LD_VAR 0 3
8215: PPUSH
8216: CALL_OW 1
8220: ST_TO_ADDR
// end ;
8221: GO 8151
8223: POP
8224: POP
// wait ( 0 0$3 ) ;
8225: LD_INT 105
8227: PPUSH
8228: CALL_OW 67
// for i in tmp do
8232: LD_ADDR_VAR 0 1
8236: PUSH
8237: LD_VAR 0 2
8241: PUSH
8242: FOR_IN
8243: IFFALSE 8311
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 257
8254: PUSH
8255: LD_INT 1
8257: EQUAL
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 247
8268: PUSH
8269: LD_INT 2
8271: EQUAL
8272: OR
8273: IFFALSE 8309
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8275: LD_VAR 0 1
8279: PPUSH
8280: LD_INT 81
8282: PUSH
8283: LD_INT 8
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PPUSH
8290: CALL_OW 69
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 74
8304: PPUSH
8305: CALL_OW 115
8309: GO 8242
8311: POP
8312: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8313: LD_VAR 0 2
8317: PPUSH
8318: LD_INT 210
8320: PPUSH
8321: LD_INT 178
8323: PPUSH
8324: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8328: LD_ADDR_VAR 0 4
8332: PUSH
8333: LD_INT 10
8335: PPUSH
8336: LD_INT 22
8338: PUSH
8339: LD_INT 8
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PPUSH
8346: CALL_OW 70
8350: ST_TO_ADDR
// if x then
8351: LD_VAR 0 4
8355: IFFALSE 8383
// for i in x do
8357: LD_ADDR_VAR 0 1
8361: PUSH
8362: LD_VAR 0 4
8366: PUSH
8367: FOR_IN
8368: IFFALSE 8381
// RemoveUnit ( i ) ;
8370: LD_VAR 0 1
8374: PPUSH
8375: CALL_OW 64
8379: GO 8367
8381: POP
8382: POP
// wait ( 0 0$1 ) ;
8383: LD_INT 35
8385: PPUSH
8386: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8390: LD_INT 22
8392: PUSH
8393: LD_INT 8
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PPUSH
8400: CALL_OW 69
8404: NOT
8405: IFFALSE 8313
// end ;
8407: PPOPN 4
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8410: LD_INT 22
8412: PUSH
8413: LD_INT 2
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 34
8422: PUSH
8423: LD_INT 31
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: LD_INT 3
8432: PUSH
8433: LD_INT 24
8435: PUSH
8436: LD_INT 1000
8438: PUSH
8439: EMPTY
8440: LIST
8441: LIST
8442: PUSH
8443: EMPTY
8444: LIST
8445: LIST
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: PPUSH
8452: CALL_OW 69
8456: IFFALSE 8559
8458: GO 8460
8460: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8461: LD_INT 45
8463: PPUSH
8464: CALL_OW 302
8468: PUSH
8469: LD_INT 45
8471: PPUSH
8472: CALL_OW 255
8476: AND
8477: IFFALSE 8520
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8479: LD_INT 22
8481: PUSH
8482: LD_INT 2
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: PUSH
8489: LD_INT 34
8491: PUSH
8492: LD_INT 31
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: PUSH
8499: EMPTY
8500: LIST
8501: LIST
8502: PPUSH
8503: CALL_OW 69
8507: PPUSH
8508: LD_INT 18
8510: PPUSH
8511: LD_INT 8
8513: PPUSH
8514: CALL_OW 111
8518: GO 8559
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8520: LD_INT 22
8522: PUSH
8523: LD_INT 2
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 34
8532: PUSH
8533: LD_INT 31
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: PUSH
8540: EMPTY
8541: LIST
8542: LIST
8543: PPUSH
8544: CALL_OW 69
8548: PPUSH
8549: LD_INT 106
8551: PPUSH
8552: LD_INT 14
8554: PPUSH
8555: CALL_OW 111
// end ; end_of_file
8559: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8560: LD_INT 0
8562: PPUSH
8563: PPUSH
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// InGameOn ;
8568: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8572: LD_EXP 21
8576: PPUSH
8577: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8581: LD_INT 2
8583: PPUSH
8584: LD_INT 1
8586: PPUSH
8587: LD_INT 1
8589: PPUSH
8590: LD_INT 1
8592: PPUSH
8593: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: LD_INT 22
8604: PUSH
8605: LD_INT 1
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PUSH
8612: LD_INT 25
8614: PUSH
8615: LD_INT 1
8617: PUSH
8618: EMPTY
8619: LIST
8620: LIST
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: PPUSH
8626: CALL_OW 69
8630: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8631: LD_ADDR_VAR 0 4
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 34
8648: PUSH
8649: LD_INT 11
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: PUSH
8665: LD_INT 1
8667: ARRAY
8668: ST_TO_ADDR
// for i = 1 to tmp do
8669: LD_ADDR_VAR 0 6
8673: PUSH
8674: DOUBLE
8675: LD_INT 1
8677: DEC
8678: ST_TO_ADDR
8679: LD_VAR 0 2
8683: PUSH
8684: FOR_TO
8685: IFFALSE 8732
// begin if i = 5 then
8687: LD_VAR 0 6
8691: PUSH
8692: LD_INT 5
8694: EQUAL
8695: IFFALSE 8699
// break ;
8697: GO 8732
// sols := Replace ( sols , i , tmp [ i ] ) ;
8699: LD_ADDR_VAR 0 5
8703: PUSH
8704: LD_VAR 0 5
8708: PPUSH
8709: LD_VAR 0 6
8713: PPUSH
8714: LD_VAR 0 2
8718: PUSH
8719: LD_VAR 0 6
8723: ARRAY
8724: PPUSH
8725: CALL_OW 1
8729: ST_TO_ADDR
// end ;
8730: GO 8684
8732: POP
8733: POP
// tmp := ar_force_tmp ;
8734: LD_ADDR_VAR 0 2
8738: PUSH
8739: LD_EXP 40
8743: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8744: LD_VAR 0 2
8748: PUSH
8749: LD_INT 1
8751: ARRAY
8752: PPUSH
8753: LD_INT 108
8755: PPUSH
8756: LD_INT 139
8758: PPUSH
8759: LD_INT 0
8761: PPUSH
8762: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8766: LD_VAR 0 2
8770: PUSH
8771: LD_INT 1
8773: ARRAY
8774: PPUSH
8775: LD_EXP 21
8779: PPUSH
8780: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8784: LD_VAR 0 2
8788: PUSH
8789: LD_INT 2
8791: ARRAY
8792: PPUSH
8793: LD_INT 114
8795: PPUSH
8796: LD_INT 132
8798: PPUSH
8799: LD_INT 0
8801: PPUSH
8802: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8806: LD_VAR 0 2
8810: PUSH
8811: LD_INT 3
8813: ARRAY
8814: PPUSH
8815: LD_INT 115
8817: PPUSH
8818: LD_INT 132
8820: PPUSH
8821: LD_INT 0
8823: PPUSH
8824: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8828: LD_VAR 0 2
8832: PUSH
8833: LD_INT 2
8835: ARRAY
8836: PUSH
8837: LD_VAR 0 2
8841: PUSH
8842: LD_INT 3
8844: ARRAY
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PPUSH
8850: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8854: LD_VAR 0 4
8858: PPUSH
8859: LD_INT 83
8861: PPUSH
8862: LD_INT 123
8864: PPUSH
8865: CALL_OW 111
// Wait ( 0 0$01 ) ;
8869: LD_INT 35
8871: PPUSH
8872: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8876: LD_INT 90
8878: PPUSH
8879: LD_INT 144
8881: PPUSH
8882: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8886: LD_VAR 0 5
8890: PPUSH
8891: LD_INT 88
8893: PPUSH
8894: LD_INT 129
8896: PPUSH
8897: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8901: LD_ADDR_VAR 0 3
8905: PUSH
8906: LD_INT 92
8908: PUSH
8909: LD_INT 131
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: LD_INT 88
8918: PUSH
8919: LD_INT 127
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 91
8928: PUSH
8929: LD_INT 132
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: LD_INT 92
8938: PUSH
8939: LD_INT 134
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PUSH
8946: EMPTY
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: ST_TO_ADDR
// for i = 1 to sols do
8952: LD_ADDR_VAR 0 6
8956: PUSH
8957: DOUBLE
8958: LD_INT 1
8960: DEC
8961: ST_TO_ADDR
8962: LD_VAR 0 5
8966: PUSH
8967: FOR_TO
8968: IFFALSE 9041
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8970: LD_VAR 0 5
8974: PUSH
8975: LD_VAR 0 6
8979: ARRAY
8980: PPUSH
8981: LD_VAR 0 3
8985: PUSH
8986: LD_VAR 0 6
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PPUSH
8996: LD_VAR 0 3
9000: PUSH
9001: LD_VAR 0 6
9005: ARRAY
9006: PUSH
9007: LD_INT 2
9009: ARRAY
9010: PPUSH
9011: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9015: LD_VAR 0 5
9019: PUSH
9020: LD_VAR 0 6
9024: ARRAY
9025: PPUSH
9026: CALL_OW 197
// AddComHold ( sols ) ;
9030: LD_VAR 0 5
9034: PPUSH
9035: CALL_OW 200
// end ;
9039: GO 8967
9041: POP
9042: POP
// repeat wait ( 0 0$1 ) ;
9043: LD_INT 35
9045: PPUSH
9046: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9050: LD_VAR 0 5
9054: PUSH
9055: LD_INT 1
9057: ARRAY
9058: PPUSH
9059: LD_INT 92
9061: PPUSH
9062: LD_INT 131
9064: PPUSH
9065: CALL_OW 297
9069: PUSH
9070: LD_INT 4
9072: LESS
9073: IFFALSE 9043
// CenterOnXY ( 96 , 139 ) ;
9075: LD_INT 96
9077: PPUSH
9078: LD_INT 139
9080: PPUSH
9081: CALL_OW 84
// wait ( 0 0$3 ) ;
9085: LD_INT 105
9087: PPUSH
9088: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9092: LD_INT 111
9094: PPUSH
9095: LD_INT 135
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 25
9103: NEG
9104: PPUSH
9105: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9109: LD_VAR 0 2
9113: PUSH
9114: LD_INT 2
9116: ARRAY
9117: PPUSH
9118: LD_VAR 0 2
9122: PUSH
9123: LD_INT 1
9125: ARRAY
9126: PPUSH
9127: CALL_OW 250
9131: PUSH
9132: LD_INT 3
9134: PLUS
9135: PPUSH
9136: LD_VAR 0 2
9140: PUSH
9141: LD_INT 1
9143: ARRAY
9144: PPUSH
9145: CALL_OW 251
9149: PPUSH
9150: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 3
9161: ARRAY
9162: PPUSH
9163: LD_INT 7
9165: PPUSH
9166: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9170: LD_VAR 0 2
9174: PUSH
9175: LD_INT 2
9177: ARRAY
9178: PPUSH
9179: LD_VAR 0 2
9183: PUSH
9184: LD_INT 1
9186: ARRAY
9187: PPUSH
9188: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9192: LD_INT 35
9194: PPUSH
9195: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9199: LD_VAR 0 2
9203: PUSH
9204: LD_INT 1
9206: ARRAY
9207: PPUSH
9208: LD_VAR 0 2
9212: PUSH
9213: LD_INT 2
9215: ARRAY
9216: PPUSH
9217: CALL_OW 296
9221: PUSH
9222: LD_INT 5
9224: LESS
9225: IFFALSE 9192
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9227: LD_VAR 0 2
9231: PUSH
9232: LD_INT 1
9234: ARRAY
9235: PPUSH
9236: LD_VAR 0 2
9240: PUSH
9241: LD_INT 2
9243: ARRAY
9244: PPUSH
9245: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 1
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-Merc1-1
9260: PPUSH
9261: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_STRING D1a-FMerc2-1
9276: PPUSH
9277: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9281: LD_VAR 0 2
9285: PUSH
9286: LD_INT 2
9288: ARRAY
9289: PPUSH
9290: LD_VAR 0 2
9294: PUSH
9295: LD_INT 1
9297: ARRAY
9298: PPUSH
9299: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9303: LD_VAR 0 2
9307: PUSH
9308: LD_INT 1
9310: ARRAY
9311: PPUSH
9312: LD_INT 500
9314: PPUSH
9315: CALL_OW 234
// wait ( 0 0$2 ) ;
9319: LD_INT 70
9321: PPUSH
9322: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9342: LD_INT 10
9344: PPUSH
9345: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9349: LD_VAR 0 2
9353: PUSH
9354: LD_INT 1
9356: ARRAY
9357: PPUSH
9358: LD_STRING D1a-Merc1-2
9360: PPUSH
9361: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9365: LD_INT 7
9367: PPUSH
9368: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9372: LD_VAR 0 2
9376: PUSH
9377: LD_INT 1
9379: ARRAY
9380: PPUSH
9381: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_INT 10
9396: PPUSH
9397: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9401: LD_VAR 0 2
9405: PUSH
9406: LD_INT 2
9408: ARRAY
9409: PPUSH
9410: LD_STRING D1a-FMerc2-2
9412: PPUSH
9413: CALL_OW 88
// wait ( 0 0$1 ) ;
9417: LD_INT 35
9419: PPUSH
9420: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9424: LD_INT 7
9426: PPUSH
9427: CALL_OW 85
// wait ( 0 0$2 ) ;
9431: LD_INT 70
9433: PPUSH
9434: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9438: LD_EXP 44
9442: PPUSH
9443: LD_STRING D1a-Saliba-1
9445: PPUSH
9446: CALL_OW 91
// KillUnit ( Saliba ) ;
9450: LD_EXP 44
9454: PPUSH
9455: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: ARRAY
9467: PPUSH
9468: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9472: LD_EXP 21
9476: PPUSH
9477: CALL_OW 85
// wait ( 0 0$1 ) ;
9481: LD_INT 35
9483: PPUSH
9484: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9488: LD_VAR 0 5
9492: PPUSH
9493: LD_INT 88
9495: PPUSH
9496: LD_INT 141
9498: PPUSH
9499: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9503: LD_VAR 0 5
9507: PPUSH
9508: LD_INT 70
9510: PPUSH
9511: CALL_OW 202
// wait ( 0 0$2 ) ;
9515: LD_INT 70
9517: PPUSH
9518: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9522: LD_INT 2
9524: PPUSH
9525: LD_INT 1
9527: PPUSH
9528: LD_INT 2
9530: PPUSH
9531: LD_INT 1
9533: PPUSH
9534: CALL_OW 80
// InGameOff ;
9538: CALL_OW 9
// ComWalk ( sols ) ;
9542: LD_VAR 0 5
9546: PPUSH
9547: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9551: LD_STRING M1
9553: PPUSH
9554: CALL_OW 337
// game_speed := 4 ;
9558: LD_ADDR_OWVAR 65
9562: PUSH
9563: LD_INT 4
9565: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9566: LD_INT 111
9568: PPUSH
9569: LD_INT 135
9571: PPUSH
9572: LD_INT 1
9574: PPUSH
9575: CALL_OW 331
// SaveForQuickRestart ;
9579: CALL_OW 22
// ar_run := true ;
9583: LD_ADDR_EXP 5
9587: PUSH
9588: LD_INT 1
9590: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9591: LD_INT 35
9593: PPUSH
9594: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9598: LD_INT 22
9600: PUSH
9601: LD_INT 1
9603: PUSH
9604: EMPTY
9605: LIST
9606: LIST
9607: PUSH
9608: LD_INT 91
9610: PUSH
9611: LD_INT 7
9613: PUSH
9614: LD_INT 10
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: PPUSH
9626: CALL_OW 69
9630: PUSH
9631: LD_INT 7
9633: PPUSH
9634: CALL_OW 256
9638: PUSH
9639: LD_INT 999
9641: LESS
9642: OR
9643: IFFALSE 9591
// if GetSide ( ar_dep_s ) = 2 then
9645: LD_INT 7
9647: PPUSH
9648: CALL_OW 255
9652: PUSH
9653: LD_INT 2
9655: EQUAL
9656: IFFALSE 9668
// SetSide ( ar_dep_s , 1 ) ;
9658: LD_INT 7
9660: PPUSH
9661: LD_INT 1
9663: PPUSH
9664: CALL_OW 235
// end ;
9668: LD_VAR 0 1
9672: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9673: LD_EXP 5
9677: IFFALSE 10037
9679: GO 9681
9681: DISABLE
9682: LD_INT 0
9684: PPUSH
9685: PPUSH
9686: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9687: LD_ADDR_VAR 0 2
9691: PUSH
9692: LD_EXP 40
9696: PUSH
9697: LD_EXP 36
9701: PPUSH
9702: LD_INT 2
9704: PUSH
9705: LD_INT 21
9707: PUSH
9708: LD_INT 2
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PUSH
9715: LD_INT 21
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PUSH
9725: EMPTY
9726: LIST
9727: LIST
9728: LIST
9729: PPUSH
9730: CALL_OW 72
9734: ADD
9735: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9736: LD_VAR 0 2
9740: PPUSH
9741: LD_INT 5
9743: PPUSH
9744: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9748: LD_INT 5
9750: PPUSH
9751: LD_INT 1
9753: PPUSH
9754: CALL_OW 343
// k := 1 ;
9758: LD_ADDR_VAR 0 3
9762: PUSH
9763: LD_INT 1
9765: ST_TO_ADDR
// for i in tmp do
9766: LD_ADDR_VAR 0 1
9770: PUSH
9771: LD_VAR 0 2
9775: PUSH
9776: FOR_IN
9777: IFFALSE 9862
// begin if IsInUnit ( i ) then
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 310
9788: IFFALSE 9799
// ComExitBuilding ( i ) ;
9790: LD_VAR 0 1
9794: PPUSH
9795: CALL_OW 122
// if GetClass ( i ) = 3 then
9799: LD_VAR 0 1
9803: PPUSH
9804: CALL_OW 257
9808: PUSH
9809: LD_INT 3
9811: EQUAL
9812: IFFALSE 9848
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_EXP 41
9823: PUSH
9824: LD_VAR 0 3
9828: ARRAY
9829: PPUSH
9830: CALL_OW 180
// k := k + 1 ;
9834: LD_ADDR_VAR 0 3
9838: PUSH
9839: LD_VAR 0 3
9843: PUSH
9844: LD_INT 1
9846: PLUS
9847: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9848: LD_VAR 0 1
9852: PPUSH
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 173
// end ;
9860: GO 9776
9862: POP
9863: POP
// ar_patrol := true ;
9864: LD_ADDR_EXP 7
9868: PUSH
9869: LD_INT 1
9871: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9872: LD_INT 10
9874: PPUSH
9875: CALL_OW 67
// for i in tmp do
9879: LD_ADDR_VAR 0 1
9883: PUSH
9884: LD_VAR 0 2
9888: PUSH
9889: FOR_IN
9890: IFFALSE 9918
// if not HasTask ( i ) then
9892: LD_VAR 0 1
9896: PPUSH
9897: CALL_OW 314
9901: NOT
9902: IFFALSE 9916
// ComMoveToArea ( i , escape_area ) ;
9904: LD_VAR 0 1
9908: PPUSH
9909: LD_INT 10
9911: PPUSH
9912: CALL_OW 113
9916: GO 9889
9918: POP
9919: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9920: LD_ADDR_VAR 0 3
9924: PUSH
9925: LD_VAR 0 2
9929: PPUSH
9930: LD_INT 95
9932: PUSH
9933: LD_INT 10
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: PPUSH
9940: CALL_OW 72
9944: ST_TO_ADDR
// if k then
9945: LD_VAR 0 3
9949: IFFALSE 10018
// for i in k do
9951: LD_ADDR_VAR 0 1
9955: PUSH
9956: LD_VAR 0 3
9960: PUSH
9961: FOR_IN
9962: IFFALSE 10016
// begin if IsInUnit ( i ) then
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 310
9973: IFFALSE 9989
// RemoveUnit ( IsInUnit ( i ) ) ;
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 310
9984: PPUSH
9985: CALL_OW 64
// RemoveUnit ( i ) ;
9989: LD_VAR 0 1
9993: PPUSH
9994: CALL_OW 64
// tmp := tmp diff i ;
9998: LD_ADDR_VAR 0 2
10002: PUSH
10003: LD_VAR 0 2
10007: PUSH
10008: LD_VAR 0 1
10012: DIFF
10013: ST_TO_ADDR
// end ;
10014: GO 9961
10016: POP
10017: POP
// until tmp = [ ] ;
10018: LD_VAR 0 2
10022: PUSH
10023: EMPTY
10024: EQUAL
10025: IFFALSE 9872
// ChangeSideFog ( 5 , 5 ) ;
10027: LD_INT 5
10029: PPUSH
10030: LD_INT 5
10032: PPUSH
10033: CALL_OW 343
// end ;
10037: PPOPN 3
10039: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10040: LD_EXP 7
10044: IFFALSE 10334
10046: GO 10048
10048: DISABLE
10049: LD_INT 0
10051: PPUSH
10052: PPUSH
10053: PPUSH
// begin uc_side := 2 ;
10054: LD_ADDR_OWVAR 20
10058: PUSH
10059: LD_INT 2
10061: ST_TO_ADDR
// uc_nation := 2 ;
10062: LD_ADDR_OWVAR 21
10066: PUSH
10067: LD_INT 2
10069: ST_TO_ADDR
// InitHc ;
10070: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10074: LD_INT 1
10076: PPUSH
10077: LD_INT 1
10079: PPUSH
10080: LD_INT 6
10082: PPUSH
10083: CALL_OW 380
// un := CreateHuman ;
10087: LD_ADDR_VAR 0 2
10091: PUSH
10092: CALL_OW 44
10096: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10097: LD_INT 14
10099: PPUSH
10100: LD_INT 1
10102: PPUSH
10103: LD_INT 1
10105: PPUSH
10106: LD_INT 27
10108: PPUSH
10109: LD_INT 98
10111: PPUSH
10112: CALL 53443 0 5
// veh := CreateVehicle ;
10116: LD_ADDR_VAR 0 3
10120: PUSH
10121: CALL_OW 45
10125: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10126: LD_VAR 0 3
10130: PPUSH
10131: LD_INT 4
10133: PPUSH
10134: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10138: LD_VAR 0 3
10142: PPUSH
10143: LD_INT 179
10145: PPUSH
10146: LD_INT 135
10148: PPUSH
10149: LD_INT 0
10151: PPUSH
10152: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10156: LD_VAR 0 2
10160: PPUSH
10161: LD_VAR 0 3
10165: PPUSH
10166: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10170: LD_VAR 0 2
10174: PPUSH
10175: LD_INT 126
10177: PPUSH
10178: LD_INT 133
10180: PPUSH
10181: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10185: LD_INT 10
10187: PPUSH
10188: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10192: LD_INT 1
10194: PPUSH
10195: LD_VAR 0 3
10199: PPUSH
10200: CALL_OW 292
10204: PUSH
10205: LD_VAR 0 3
10209: PPUSH
10210: LD_INT 7
10212: PPUSH
10213: CALL_OW 296
10217: PUSH
10218: LD_INT 9
10220: LESS
10221: OR
10222: IFFALSE 10185
// ComHold ( veh ) ;
10224: LD_VAR 0 3
10228: PPUSH
10229: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10233: LD_VAR 0 2
10237: PPUSH
10238: LD_STRING D2aa-Ar1-1
10240: PPUSH
10241: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10245: LD_VAR 0 2
10249: PPUSH
10250: LD_INT 177
10252: PPUSH
10253: LD_INT 96
10255: PPUSH
10256: CALL_OW 111
// AddComExitVehicle ( un ) ;
10260: LD_VAR 0 2
10264: PPUSH
10265: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10269: LD_INT 35
10271: PPUSH
10272: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10276: LD_VAR 0 2
10280: PPUSH
10281: LD_INT 204
10283: PPUSH
10284: CALL_OW 296
10288: PUSH
10289: LD_INT 15
10291: LESS
10292: IFFALSE 10269
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10294: LD_ADDR_EXP 50
10298: PUSH
10299: LD_EXP 50
10303: PPUSH
10304: LD_INT 3
10306: PUSH
10307: LD_EXP 50
10311: PUSH
10312: LD_INT 3
10314: ARRAY
10315: PUSH
10316: LD_INT 1
10318: PLUS
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: LD_VAR 0 2
10328: PPUSH
10329: CALL 53565 0 3
10333: ST_TO_ADDR
// end ;
10334: PPOPN 3
10336: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10337: LD_INT 7
10339: PPUSH
10340: CALL_OW 255
10344: PUSH
10345: LD_INT 1
10347: EQUAL
10348: PUSH
10349: LD_INT 7
10351: PPUSH
10352: CALL_OW 301
10356: OR
10357: IFFALSE 12765
10359: GO 10361
10361: DISABLE
10362: LD_INT 0
10364: PPUSH
10365: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10366: LD_ADDR_VAR 0 1
10370: PUSH
10371: LD_EXP 36
10375: PPUSH
10376: LD_INT 21
10378: PUSH
10379: LD_INT 3
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PPUSH
10386: CALL_OW 72
10390: PUSH
10391: FOR_IN
10392: IFFALSE 10408
// SetSide ( i , 1 ) ;
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_INT 1
10401: PPUSH
10402: CALL_OW 235
10406: GO 10391
10408: POP
10409: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10410: LD_ADDR_VAR 0 2
10414: PUSH
10415: LD_INT 46
10417: PUSH
10418: LD_INT 41
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 50
10427: PUSH
10428: LD_INT 25
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: LD_INT 57
10437: PUSH
10438: LD_INT 75
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 75
10447: PUSH
10448: LD_INT 89
10450: PUSH
10451: EMPTY
10452: LIST
10453: LIST
10454: PUSH
10455: LD_INT 51
10457: PUSH
10458: LD_INT 45
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: PUSH
10465: LD_INT 95
10467: PUSH
10468: LD_INT 95
10470: PUSH
10471: EMPTY
10472: LIST
10473: LIST
10474: PUSH
10475: LD_INT 84
10477: PUSH
10478: LD_INT 77
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PUSH
10485: LD_INT 101
10487: PUSH
10488: LD_INT 76
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: LD_INT 118
10497: PUSH
10498: LD_INT 81
10500: PUSH
10501: EMPTY
10502: LIST
10503: LIST
10504: PUSH
10505: LD_INT 139
10507: PUSH
10508: LD_INT 97
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PUSH
10515: LD_INT 129
10517: PUSH
10518: LD_INT 114
10520: PUSH
10521: EMPTY
10522: LIST
10523: LIST
10524: PUSH
10525: LD_INT 154
10527: PUSH
10528: LD_INT 111
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: ST_TO_ADDR
// base_captured := true ;
10549: LD_ADDR_EXP 6
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// DialogueOn ;
10557: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10561: LD_EXP 21
10565: PPUSH
10566: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10570: LD_EXP 21
10574: PPUSH
10575: LD_STRING D2-JMM-1
10577: PPUSH
10578: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10582: LD_EXP 30
10586: PPUSH
10587: LD_STRING D2-Pow-1
10589: PPUSH
10590: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10594: LD_EXP 21
10598: PPUSH
10599: LD_STRING D2-JMM-2
10601: PPUSH
10602: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10606: LD_EXP 30
10610: PPUSH
10611: LD_STRING D2-Pow-2
10613: PPUSH
10614: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10618: LD_EXP 21
10622: PPUSH
10623: LD_STRING D2-JMM-3
10625: PPUSH
10626: CALL_OW 88
// DialogueOff ;
10630: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10634: LD_STRING M2
10636: PPUSH
10637: CALL_OW 337
// Wait ( 0 0$2 ) ;
10641: LD_INT 70
10643: PPUSH
10644: CALL_OW 67
// if IsOk ( Gary ) then
10648: LD_EXP 32
10652: PPUSH
10653: CALL_OW 302
10657: IFFALSE 10671
// Say ( Gary , D2a-Gary-1 ) ;
10659: LD_EXP 32
10663: PPUSH
10664: LD_STRING D2a-Gary-1
10666: PPUSH
10667: CALL_OW 88
// if IsOk ( Bobby ) then
10671: LD_EXP 24
10675: PPUSH
10676: CALL_OW 302
10680: IFFALSE 10694
// Say ( Bobby , D2a-Bobby-1 ) ;
10682: LD_EXP 24
10686: PPUSH
10687: LD_STRING D2a-Bobby-1
10689: PPUSH
10690: CALL_OW 88
// if IsOk ( Cyrus ) then
10694: LD_EXP 25
10698: PPUSH
10699: CALL_OW 302
10703: IFFALSE 10717
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10705: LD_EXP 25
10709: PPUSH
10710: LD_STRING D2a-Cyrus-1
10712: PPUSH
10713: CALL_OW 88
// if IsOk ( Lisa ) then
10717: LD_EXP 22
10721: PPUSH
10722: CALL_OW 302
10726: IFFALSE 10740
// Say ( Lisa , D2a-Lisa-1 ) ;
10728: LD_EXP 22
10732: PPUSH
10733: LD_STRING D2a-Lisa-1
10735: PPUSH
10736: CALL_OW 88
// if IsOk ( Frank ) then
10740: LD_EXP 33
10744: PPUSH
10745: CALL_OW 302
10749: IFFALSE 10763
// Say ( Frank , D2a-Frank-1 ) ;
10751: LD_EXP 33
10755: PPUSH
10756: LD_STRING D2a-Frank-1
10758: PPUSH
10759: CALL_OW 88
// if IsOk ( Cornel ) then
10763: LD_EXP 31
10767: PPUSH
10768: CALL_OW 302
10772: IFFALSE 10786
// Say ( Cornel , D2a-Corn-1 ) ;
10774: LD_EXP 31
10778: PPUSH
10779: LD_STRING D2a-Corn-1
10781: PPUSH
10782: CALL_OW 88
// if IsOk ( Donaldson ) then
10786: LD_EXP 23
10790: PPUSH
10791: CALL_OW 302
10795: IFFALSE 10809
// Say ( Donaldson , D2a-Don-1 ) ;
10797: LD_EXP 23
10801: PPUSH
10802: LD_STRING D2a-Don-1
10804: PPUSH
10805: CALL_OW 88
// if IsOk ( Brown ) then
10809: LD_EXP 27
10813: PPUSH
10814: CALL_OW 302
10818: IFFALSE 10832
// Say ( Brown , D2a-Brown-1 ) ;
10820: LD_EXP 27
10824: PPUSH
10825: LD_STRING D2a-Brown-1
10827: PPUSH
10828: CALL_OW 88
// Wait ( 0 0$30 ) ;
10832: LD_INT 1050
10834: PPUSH
10835: CALL_OW 67
// if IsOk ( Frank ) then
10839: LD_EXP 33
10843: PPUSH
10844: CALL_OW 302
10848: IFFALSE 11114
// begin DialogueOn ;
10850: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10854: LD_EXP 21
10858: PUSH
10859: LD_EXP 33
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: PPUSH
10868: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10872: LD_EXP 33
10876: PPUSH
10877: LD_STRING D3F-Frank-1
10879: PPUSH
10880: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10884: LD_EXP 21
10888: PPUSH
10889: LD_STRING D3F-JMM-1
10891: PPUSH
10892: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10896: LD_EXP 33
10900: PPUSH
10901: LD_STRING D3F-Frank-2
10903: PPUSH
10904: CALL_OW 88
// case Query ( QFrank ) of 1 :
10908: LD_STRING QFrank
10910: PPUSH
10911: CALL_OW 97
10915: PUSH
10916: LD_INT 1
10918: DOUBLE
10919: EQUAL
10920: IFTRUE 10924
10922: GO 10947
10924: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10925: LD_EXP 21
10929: PPUSH
10930: LD_STRING D3Fa-JMM-1
10932: PPUSH
10933: CALL_OW 88
// us_scout := 1 ;
10937: LD_ADDR_EXP 8
10941: PUSH
10942: LD_INT 1
10944: ST_TO_ADDR
// end ; 2 :
10945: GO 11110
10947: LD_INT 2
10949: DOUBLE
10950: EQUAL
10951: IFTRUE 10955
10953: GO 11077
10955: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10956: LD_EXP 21
10960: PPUSH
10961: LD_STRING D3Fb-JMM-1
10963: PPUSH
10964: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10968: LD_EXP 33
10972: PPUSH
10973: LD_STRING D3Fb-Frank-1
10975: PPUSH
10976: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10980: LD_STRING QFrank2
10982: PPUSH
10983: CALL_OW 97
10987: PUSH
10988: LD_INT 1
10990: DOUBLE
10991: EQUAL
10992: IFTRUE 10996
10994: GO 11043
10996: POP
// begin us_scout := 2 ;
10997: LD_ADDR_EXP 8
11001: PUSH
11002: LD_INT 2
11004: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11005: LD_EXP 21
11009: PPUSH
11010: LD_STRING D3Fba-JMM-1
11012: PPUSH
11013: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11017: LD_EXP 33
11021: PPUSH
11022: LD_STRING D3Fba-Frank-1
11024: PPUSH
11025: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11029: LD_EXP 21
11033: PPUSH
11034: LD_STRING D3Fba-JMM-2
11036: PPUSH
11037: CALL_OW 88
// end ; 2 :
11041: GO 11075
11043: LD_INT 2
11045: DOUBLE
11046: EQUAL
11047: IFTRUE 11051
11049: GO 11074
11051: POP
// begin us_scout := 0 ;
11052: LD_ADDR_EXP 8
11056: PUSH
11057: LD_INT 0
11059: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11060: LD_EXP 21
11064: PPUSH
11065: LD_STRING D3Fbb-JMM-1
11067: PPUSH
11068: CALL_OW 88
// end ; end ;
11072: GO 11075
11074: POP
// end ; 3 :
11075: GO 11110
11077: LD_INT 3
11079: DOUBLE
11080: EQUAL
11081: IFTRUE 11085
11083: GO 11109
11085: POP
// begin us_scout := - 1 ;
11086: LD_ADDR_EXP 8
11090: PUSH
11091: LD_INT 1
11093: NEG
11094: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11095: LD_EXP 21
11099: PPUSH
11100: LD_STRING D3Fc-JMM-1
11102: PPUSH
11103: CALL_OW 88
// end ; end ;
11107: GO 11110
11109: POP
// DialogueOff ;
11110: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11114: LD_EXP 8
11118: PUSH
11119: LD_INT 1
11121: NEG
11122: PUSH
11123: LD_INT 0
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11134
// exit ;
11132: GO 12765
// if us_scout in [ 1 , 2 ] then
11134: LD_EXP 8
11138: PUSH
11139: LD_INT 1
11141: PUSH
11142: LD_INT 2
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: IN
11149: IFFALSE 11828
// begin if IsInUnit ( Frank ) then
11151: LD_EXP 33
11155: PPUSH
11156: CALL_OW 310
11160: IFFALSE 11171
// ComExit ( Frank ) ;
11162: LD_EXP 33
11166: PPUSH
11167: CALL 85648 0 1
// SetSide ( Frank , 4 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 4
11178: PPUSH
11179: CALL_OW 235
// wait ( 0 0$1 ) ;
11183: LD_INT 35
11185: PPUSH
11186: CALL_OW 67
// if us_scout = 2 then
11190: LD_EXP 8
11194: PUSH
11195: LD_INT 2
11197: EQUAL
11198: IFFALSE 11566
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11200: LD_EXP 33
11204: PPUSH
11205: LD_INT 75
11207: PPUSH
11208: LD_INT 63
11210: PPUSH
11211: CALL_OW 111
// AddComHold ( Frank ) ;
11215: LD_EXP 33
11219: PPUSH
11220: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11224: LD_EXP 33
11228: PPUSH
11229: LD_INT 770
11231: PPUSH
11232: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11236: LD_EXP 33
11240: PPUSH
11241: LD_INT 100
11243: PPUSH
11244: LD_INT 75
11246: PPUSH
11247: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11251: LD_EXP 33
11255: PPUSH
11256: LD_INT 123
11258: PPUSH
11259: LD_INT 103
11261: PPUSH
11262: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11266: LD_EXP 33
11270: PPUSH
11271: LD_INT 138
11273: PPUSH
11274: LD_INT 108
11276: PPUSH
11277: CALL_OW 171
// AddComHold ( Frank ) ;
11281: LD_EXP 33
11285: PPUSH
11286: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11290: LD_INT 35
11292: PPUSH
11293: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11297: LD_EXP 33
11301: PPUSH
11302: LD_INT 138
11304: PPUSH
11305: LD_INT 108
11307: PPUSH
11308: CALL_OW 307
11312: IFFALSE 11290
// AddComMoveXY ( Frank , 125 , 132 ) ;
11314: LD_EXP 33
11318: PPUSH
11319: LD_INT 125
11321: PPUSH
11322: LD_INT 132
11324: PPUSH
11325: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11329: LD_INT 35
11331: PPUSH
11332: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11336: LD_INT 1
11338: PPUSH
11339: LD_EXP 33
11343: PPUSH
11344: CALL_OW 292
11348: PUSH
11349: LD_EXP 33
11353: PPUSH
11354: LD_INT 7
11356: PPUSH
11357: CALL_OW 296
11361: PUSH
11362: LD_INT 7
11364: LESS
11365: OR
11366: IFFALSE 11329
// DialogueOn ;
11368: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11372: LD_EXP 33
11376: PPUSH
11377: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11381: LD_INT 10
11383: PPUSH
11384: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11388: LD_EXP 21
11392: PPUSH
11393: LD_STRING D4Fa-JMM-1
11395: PPUSH
11396: CALL_OW 88
// for i in points do
11400: LD_ADDR_VAR 0 1
11404: PUSH
11405: LD_VAR 0 2
11409: PUSH
11410: FOR_IN
11411: IFFALSE 11469
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11413: LD_VAR 0 1
11417: PUSH
11418: LD_INT 1
11420: ARRAY
11421: PPUSH
11422: LD_VAR 0 1
11426: PUSH
11427: LD_INT 2
11429: ARRAY
11430: PPUSH
11431: LD_INT 1
11433: PPUSH
11434: LD_INT 20
11436: NEG
11437: PPUSH
11438: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11442: LD_VAR 0 1
11446: PUSH
11447: LD_INT 1
11449: ARRAY
11450: PPUSH
11451: LD_VAR 0 1
11455: PUSH
11456: LD_INT 2
11458: ARRAY
11459: PPUSH
11460: LD_INT 1
11462: PPUSH
11463: CALL_OW 331
// end ;
11467: GO 11410
11469: POP
11470: POP
// dwait ( 0 0$0.5 ) ;
11471: LD_INT 18
11473: PPUSH
11474: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11478: LD_INT 42
11480: PPUSH
11481: LD_INT 27
11483: PPUSH
11484: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11488: LD_EXP 33
11492: PPUSH
11493: LD_STRING D4Fa-Frank-1
11495: PPUSH
11496: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11500: LD_INT 18
11502: PPUSH
11503: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11507: LD_EXP 21
11511: PPUSH
11512: LD_STRING D4Fa-JMM-2
11514: PPUSH
11515: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11519: LD_INT 118
11521: PPUSH
11522: LD_INT 80
11524: PPUSH
11525: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11529: LD_EXP 33
11533: PPUSH
11534: LD_STRING D4Fa-Frank-2
11536: PPUSH
11537: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11541: LD_INT 10
11543: PPUSH
11544: CALL_OW 68
// DialogueOff ;
11548: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11552: LD_EXP 33
11556: PPUSH
11557: LD_INT 1
11559: PPUSH
11560: CALL_OW 235
// end else
11564: GO 11828
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11566: LD_INT 2
11568: PPUSH
11569: LD_INT 4
11571: PPUSH
11572: LD_INT 2
11574: PPUSH
11575: LD_INT 1
11577: PPUSH
11578: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11582: LD_EXP 33
11586: PPUSH
11587: LD_INT 75
11589: PPUSH
11590: LD_INT 63
11592: PPUSH
11593: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11597: LD_EXP 33
11601: PPUSH
11602: LD_INT 175
11604: PPUSH
11605: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11609: LD_EXP 33
11613: PPUSH
11614: LD_INT 102
11616: PPUSH
11617: LD_INT 76
11619: PPUSH
11620: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11624: LD_EXP 33
11628: PPUSH
11629: LD_INT 108
11631: PPUSH
11632: LD_INT 70
11634: PPUSH
11635: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11639: LD_INT 35
11641: PPUSH
11642: CALL_OW 67
// until See ( 2 , Frank ) ;
11646: LD_INT 2
11648: PPUSH
11649: LD_EXP 33
11653: PPUSH
11654: CALL_OW 292
11658: IFFALSE 11639
// ComMoveXY ( Frank , 112 , 118 ) ;
11660: LD_EXP 33
11664: PPUSH
11665: LD_INT 112
11667: PPUSH
11668: LD_INT 118
11670: PPUSH
11671: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11675: LD_EXP 33
11679: PPUSH
11680: CALL_OW 256
11684: PUSH
11685: LD_INT 750
11687: GREATEREQUAL
11688: IFFALSE 11702
// SetLives ( Frank , 700 ) ;
11690: LD_EXP 33
11694: PPUSH
11695: LD_INT 700
11697: PPUSH
11698: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11702: LD_INT 35
11704: PPUSH
11705: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11709: LD_INT 1
11711: PPUSH
11712: LD_EXP 33
11716: PPUSH
11717: CALL_OW 292
11721: PUSH
11722: LD_EXP 33
11726: PPUSH
11727: LD_INT 7
11729: PPUSH
11730: CALL_OW 296
11734: PUSH
11735: LD_INT 17
11737: LESS
11738: OR
11739: IFFALSE 11702
// DialogueOn ;
11741: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11745: LD_EXP 33
11749: PPUSH
11750: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11754: LD_EXP 33
11758: PPUSH
11759: LD_STRING D4Fb-Frank-1
11761: PPUSH
11762: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11766: LD_EXP 21
11770: PPUSH
11771: LD_STRING D4Fb-JMM-1
11773: PPUSH
11774: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11778: LD_INT 2
11780: PPUSH
11781: LD_STRING D4Fb-FSci1-1
11783: PPUSH
11784: CALL 16688 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11788: LD_EXP 33
11792: PPUSH
11793: LD_STRING D4Fb-Frank-2
11795: PPUSH
11796: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11800: LD_EXP 21
11804: PPUSH
11805: LD_STRING D4Fb-JMM-2
11807: PPUSH
11808: CALL_OW 88
// DialogueOff ;
11812: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11816: LD_EXP 33
11820: PPUSH
11821: LD_INT 1
11823: PPUSH
11824: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11828: LD_EXP 34
11832: PPUSH
11833: CALL_OW 302
11837: PUSH
11838: LD_EXP 33
11842: NOT
11843: AND
11844: IFFALSE 11992
// begin DialogueOn ;
11846: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11850: LD_EXP 21
11854: PUSH
11855: LD_EXP 34
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Y-Yam-1
11875: PPUSH
11876: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11880: LD_EXP 21
11884: PPUSH
11885: LD_STRING D3Y-JMM-1
11887: PPUSH
11888: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D3Y-Yam-2
11899: PPUSH
11900: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11904: LD_STRING QYamoko
11906: PPUSH
11907: CALL_OW 97
11911: PUSH
11912: LD_INT 1
11914: DOUBLE
11915: EQUAL
11916: IFTRUE 11920
11918: GO 11955
11920: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11921: LD_EXP 21
11925: PPUSH
11926: LD_STRING D3Ya-JMM-1
11928: PPUSH
11929: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11933: LD_EXP 34
11937: PPUSH
11938: LD_STRING D3Ya-Yam-1
11940: PPUSH
11941: CALL_OW 88
// us_scout := 1 ;
11945: LD_ADDR_EXP 8
11949: PUSH
11950: LD_INT 1
11952: ST_TO_ADDR
// end ; 2 :
11953: GO 11988
11955: LD_INT 2
11957: DOUBLE
11958: EQUAL
11959: IFTRUE 11963
11961: GO 11987
11963: POP
// begin us_scout := - 1 ;
11964: LD_ADDR_EXP 8
11968: PUSH
11969: LD_INT 1
11971: NEG
11972: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11973: LD_EXP 21
11977: PPUSH
11978: LD_STRING D3Yb-JMM-1
11980: PPUSH
11981: CALL_OW 88
// end ; end ;
11985: GO 11988
11987: POP
// DialogueOff ;
11988: CALL_OW 7
// end ; if Frank then
11992: LD_EXP 33
11996: IFFALSE 12000
// exit ;
11998: GO 12765
// if us_scout in [ - 1 , 0 ] then
12000: LD_EXP 8
12004: PUSH
12005: LD_INT 1
12007: NEG
12008: PUSH
12009: LD_INT 0
12011: PUSH
12012: EMPTY
12013: LIST
12014: LIST
12015: IN
12016: IFFALSE 12020
// exit ;
12018: GO 12765
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12020: LD_ADDR_EXP 8
12024: PUSH
12025: LD_INT 2
12027: PUSH
12028: LD_INT 2
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: LD_INT 1
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: PUSH
12043: LD_OWVAR 67
12047: ARRAY
12048: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12049: LD_EXP 8
12053: PUSH
12054: LD_INT 1
12056: PUSH
12057: LD_INT 2
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: IN
12064: IFFALSE 12765
// begin if IsInUnit ( Kikuchi ) then
12066: LD_EXP 34
12070: PPUSH
12071: CALL_OW 310
12075: IFFALSE 12086
// ComExitBuilding ( Kikuchi ) ;
12077: LD_EXP 34
12081: PPUSH
12082: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12086: LD_EXP 34
12090: PPUSH
12091: CALL_OW 311
12095: IFFALSE 12106
// ComExitVehicle ( Kikuchi ) ;
12097: LD_EXP 34
12101: PPUSH
12102: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12106: LD_EXP 34
12110: PPUSH
12111: LD_INT 4
12113: PPUSH
12114: CALL_OW 235
// wait ( 0 0$1 ) ;
12118: LD_INT 35
12120: PPUSH
12121: CALL_OW 67
// if us_scout = 2 then
12125: LD_EXP 8
12129: PUSH
12130: LD_INT 2
12132: EQUAL
12133: IFFALSE 12513
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12135: LD_EXP 34
12139: PPUSH
12140: LD_INT 75
12142: PPUSH
12143: LD_INT 63
12145: PPUSH
12146: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12150: LD_EXP 34
12154: PPUSH
12155: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12159: LD_EXP 34
12163: PPUSH
12164: LD_INT 770
12166: PPUSH
12167: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12171: LD_EXP 34
12175: PPUSH
12176: LD_INT 100
12178: PPUSH
12179: LD_INT 75
12181: PPUSH
12182: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12186: LD_EXP 34
12190: PPUSH
12191: LD_INT 123
12193: PPUSH
12194: LD_INT 103
12196: PPUSH
12197: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12201: LD_EXP 34
12205: PPUSH
12206: LD_INT 138
12208: PPUSH
12209: LD_INT 108
12211: PPUSH
12212: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12216: LD_EXP 34
12220: PPUSH
12221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12225: LD_INT 35
12227: PPUSH
12228: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12232: LD_EXP 34
12236: PPUSH
12237: LD_INT 138
12239: PPUSH
12240: LD_INT 108
12242: PPUSH
12243: CALL_OW 307
12247: IFFALSE 12225
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12249: LD_EXP 34
12253: PPUSH
12254: LD_INT 125
12256: PPUSH
12257: LD_INT 132
12259: PPUSH
12260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12264: LD_INT 35
12266: PPUSH
12267: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12271: LD_INT 1
12273: PPUSH
12274: LD_EXP 34
12278: PPUSH
12279: CALL_OW 292
12283: PUSH
12284: LD_EXP 34
12288: PPUSH
12289: LD_INT 7
12291: PPUSH
12292: CALL_OW 296
12296: PUSH
12297: LD_INT 7
12299: LESS
12300: OR
12301: IFFALSE 12264
// DialogueOn ;
12303: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12307: LD_EXP 34
12311: PPUSH
12312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12316: LD_INT 10
12318: PPUSH
12319: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12323: LD_EXP 34
12327: PPUSH
12328: LD_STRING D4Ya-Yam-1
12330: PPUSH
12331: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12335: LD_EXP 21
12339: PPUSH
12340: LD_STRING D4Ya-JMM-1
12342: PPUSH
12343: CALL_OW 88
// for i in points do
12347: LD_ADDR_VAR 0 1
12351: PUSH
12352: LD_VAR 0 2
12356: PUSH
12357: FOR_IN
12358: IFFALSE 12416
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12360: LD_VAR 0 1
12364: PUSH
12365: LD_INT 1
12367: ARRAY
12368: PPUSH
12369: LD_VAR 0 1
12373: PUSH
12374: LD_INT 2
12376: ARRAY
12377: PPUSH
12378: LD_INT 1
12380: PPUSH
12381: LD_INT 20
12383: NEG
12384: PPUSH
12385: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12389: LD_VAR 0 1
12393: PUSH
12394: LD_INT 1
12396: ARRAY
12397: PPUSH
12398: LD_VAR 0 1
12402: PUSH
12403: LD_INT 2
12405: ARRAY
12406: PPUSH
12407: LD_INT 1
12409: PPUSH
12410: CALL_OW 331
// end ;
12414: GO 12357
12416: POP
12417: POP
// dwait ( 0 0$0.5 ) ;
12418: LD_INT 18
12420: PPUSH
12421: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12425: LD_INT 42
12427: PPUSH
12428: LD_INT 27
12430: PPUSH
12431: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12435: LD_EXP 34
12439: PPUSH
12440: LD_STRING D4Ya-Yam-2
12442: PPUSH
12443: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12447: LD_INT 18
12449: PPUSH
12450: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12454: LD_INT 118
12456: PPUSH
12457: LD_INT 80
12459: PPUSH
12460: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12464: LD_EXP 21
12468: PPUSH
12469: LD_STRING D4Ya-JMM-2
12471: PPUSH
12472: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12476: LD_EXP 34
12480: PPUSH
12481: LD_STRING D4Ya-Yam-3
12483: PPUSH
12484: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12488: LD_INT 10
12490: PPUSH
12491: CALL_OW 68
// DialogueOff ;
12495: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12499: LD_EXP 34
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 235
// end else
12511: GO 12765
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12513: LD_INT 2
12515: PPUSH
12516: LD_INT 4
12518: PPUSH
12519: LD_INT 2
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12529: LD_EXP 34
12533: PPUSH
12534: LD_INT 75
12536: PPUSH
12537: LD_INT 63
12539: PPUSH
12540: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12544: LD_EXP 34
12548: PPUSH
12549: LD_INT 175
12551: PPUSH
12552: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12556: LD_EXP 34
12560: PPUSH
12561: LD_INT 102
12563: PPUSH
12564: LD_INT 76
12566: PPUSH
12567: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12571: LD_EXP 34
12575: PPUSH
12576: LD_INT 108
12578: PPUSH
12579: LD_INT 70
12581: PPUSH
12582: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12586: LD_INT 35
12588: PPUSH
12589: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12593: LD_INT 2
12595: PPUSH
12596: LD_EXP 34
12600: PPUSH
12601: CALL_OW 292
12605: IFFALSE 12586
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12607: LD_EXP 34
12611: PPUSH
12612: LD_INT 112
12614: PPUSH
12615: LD_INT 118
12617: PPUSH
12618: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12622: LD_EXP 34
12626: PPUSH
12627: CALL_OW 256
12631: PUSH
12632: LD_INT 750
12634: GREATEREQUAL
12635: IFFALSE 12649
// SetLives ( Kikuchi , 700 ) ;
12637: LD_EXP 34
12641: PPUSH
12642: LD_INT 700
12644: PPUSH
12645: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12649: LD_INT 35
12651: PPUSH
12652: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12656: LD_INT 1
12658: PPUSH
12659: LD_EXP 34
12663: PPUSH
12664: CALL_OW 292
12668: PUSH
12669: LD_EXP 34
12673: PPUSH
12674: LD_INT 7
12676: PPUSH
12677: CALL_OW 296
12681: PUSH
12682: LD_INT 17
12684: LESS
12685: OR
12686: IFFALSE 12649
// DialogueOn ;
12688: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12692: LD_EXP 34
12696: PPUSH
12697: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12701: LD_EXP 34
12705: PPUSH
12706: LD_STRING D4Yb-Yam-1
12708: PPUSH
12709: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12713: LD_EXP 21
12717: PPUSH
12718: LD_STRING D4Yb-JMM-1
12720: PPUSH
12721: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12725: LD_EXP 34
12729: PPUSH
12730: LD_STRING D4Yb-Yam-2
12732: PPUSH
12733: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12737: LD_EXP 21
12741: PPUSH
12742: LD_STRING D4Yb-JMM-2
12744: PPUSH
12745: CALL_OW 88
// DialogueOff ;
12749: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12753: LD_EXP 34
12757: PPUSH
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 235
// end ; end ; end ;
12765: PPOPN 2
12767: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12768: LD_EXP 6
12772: IFFALSE 13805
12774: GO 12776
12776: DISABLE
12777: LD_INT 0
12779: PPUSH
12780: PPUSH
12781: PPUSH
12782: PPUSH
// begin enable ;
12783: ENABLE
// if not seen [ 1 ] then
12784: LD_EXP 9
12788: PUSH
12789: LD_INT 1
12791: ARRAY
12792: NOT
12793: IFFALSE 12973
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12795: LD_ADDR_VAR 0 2
12799: PUSH
12800: LD_INT 22
12802: PUSH
12803: LD_INT 2
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: LD_INT 25
12815: PUSH
12816: LD_INT 11
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: LD_INT 33
12825: PUSH
12826: LD_INT 4
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PPUSH
12842: CALL_OW 69
12846: ST_TO_ADDR
// if tmp then
12847: LD_VAR 0 2
12851: IFFALSE 12973
// for i in tmp do
12853: LD_ADDR_VAR 0 1
12857: PUSH
12858: LD_VAR 0 2
12862: PUSH
12863: FOR_IN
12864: IFFALSE 12971
// if See ( 1 , i ) then
12866: LD_INT 1
12868: PPUSH
12869: LD_VAR 0 1
12873: PPUSH
12874: CALL_OW 292
12878: IFFALSE 12969
// begin seen := Replace ( seen , 1 , true ) ;
12880: LD_ADDR_EXP 9
12884: PUSH
12885: LD_EXP 9
12889: PPUSH
12890: LD_INT 1
12892: PPUSH
12893: LD_INT 1
12895: PPUSH
12896: CALL_OW 1
12900: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12901: LD_INT 1
12903: PPUSH
12904: CALL 16510 0 1
12908: IFFALSE 12969
// begin DialogueOn ;
12910: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12914: LD_VAR 0 1
12918: PPUSH
12919: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12923: LD_INT 10
12925: PPUSH
12926: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: LD_INT 1
12937: PPUSH
12938: LD_STRING D5a-Sol2-1
12940: PPUSH
12941: CALL 16688 0 2
12945: ST_TO_ADDR
// if not un then
12946: LD_VAR 0 3
12950: NOT
12951: IFFALSE 12963
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12953: LD_INT 2
12955: PPUSH
12956: LD_STRING D5a-FSol2-1
12958: PPUSH
12959: CALL 16688 0 2
// DialogueOff ;
12963: CALL_OW 7
// break ;
12967: GO 12971
// end ; end ;
12969: GO 12863
12971: POP
12972: POP
// end ; if not seen [ 2 ] then
12973: LD_EXP 9
12977: PUSH
12978: LD_INT 2
12980: ARRAY
12981: NOT
12982: IFFALSE 13207
// begin can_kamikazed := true ;
12984: LD_ADDR_EXP 10
12988: PUSH
12989: LD_INT 1
12991: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12992: LD_ADDR_VAR 0 2
12996: PUSH
12997: LD_INT 22
12999: PUSH
13000: LD_INT 2
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PUSH
13007: LD_INT 25
13009: PUSH
13010: LD_INT 17
13012: PUSH
13013: EMPTY
13014: LIST
13015: LIST
13016: PUSH
13017: EMPTY
13018: LIST
13019: LIST
13020: PPUSH
13021: CALL_OW 69
13025: ST_TO_ADDR
// if tmp then
13026: LD_VAR 0 2
13030: IFFALSE 13207
// for i in tmp do
13032: LD_ADDR_VAR 0 1
13036: PUSH
13037: LD_VAR 0 2
13041: PUSH
13042: FOR_IN
13043: IFFALSE 13205
// if See ( 1 , i ) then
13045: LD_INT 1
13047: PPUSH
13048: LD_VAR 0 1
13052: PPUSH
13053: CALL_OW 292
13057: IFFALSE 13203
// begin seen := Replace ( seen , 2 , true ) ;
13059: LD_ADDR_EXP 9
13063: PUSH
13064: LD_EXP 9
13068: PPUSH
13069: LD_INT 2
13071: PPUSH
13072: LD_INT 1
13074: PPUSH
13075: CALL_OW 1
13079: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13080: LD_INT 1
13082: PPUSH
13083: CALL 16510 0 1
13087: IFFALSE 13203
// begin DialogueOn ;
13089: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13093: LD_VAR 0 1
13097: PPUSH
13098: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13102: LD_INT 10
13104: PPUSH
13105: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 1
13116: PPUSH
13117: LD_STRING D5b-Sol1-1
13119: PPUSH
13120: CALL 16688 0 2
13124: ST_TO_ADDR
// if not un then
13125: LD_VAR 0 3
13129: NOT
13130: IFFALSE 13148
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13132: LD_ADDR_VAR 0 3
13136: PUSH
13137: LD_INT 2
13139: PPUSH
13140: LD_STRING D5b-FSol1-1
13142: PPUSH
13143: CALL 16688 0 2
13147: ST_TO_ADDR
// if un then
13148: LD_VAR 0 3
13152: IFFALSE 13197
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13154: LD_ADDR_VAR 0 4
13158: PUSH
13159: LD_INT 1
13161: PPUSH
13162: LD_STRING D5b-Sol2-1
13164: PPUSH
13165: LD_VAR 0 3
13169: PPUSH
13170: CALL 16914 0 3
13174: ST_TO_ADDR
// if not un2 then
13175: LD_VAR 0 4
13179: NOT
13180: IFFALSE 13197
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13182: LD_INT 2
13184: PPUSH
13185: LD_STRING D5b-FSol2-1
13187: PPUSH
13188: LD_VAR 0 3
13192: PPUSH
13193: CALL 16914 0 3
// end ; DialogueOff ;
13197: CALL_OW 7
// break ;
13201: GO 13205
// end ; end ;
13203: GO 13042
13205: POP
13206: POP
// end ; if not seen [ 3 ] then
13207: LD_EXP 9
13211: PUSH
13212: LD_INT 3
13214: ARRAY
13215: NOT
13216: IFFALSE 13390
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13218: LD_ADDR_VAR 0 2
13222: PUSH
13223: LD_INT 22
13225: PUSH
13226: LD_INT 2
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: PUSH
13233: LD_INT 33
13235: PUSH
13236: LD_INT 2
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PPUSH
13247: CALL_OW 69
13251: ST_TO_ADDR
// if tmp then
13252: LD_VAR 0 2
13256: IFFALSE 13390
// for i in tmp do
13258: LD_ADDR_VAR 0 1
13262: PUSH
13263: LD_VAR 0 2
13267: PUSH
13268: FOR_IN
13269: IFFALSE 13388
// if See ( 1 , i ) then
13271: LD_INT 1
13273: PPUSH
13274: LD_VAR 0 1
13278: PPUSH
13279: CALL_OW 292
13283: IFFALSE 13386
// begin seen := Replace ( seen , 3 , true ) ;
13285: LD_ADDR_EXP 9
13289: PUSH
13290: LD_EXP 9
13294: PPUSH
13295: LD_INT 3
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: CALL_OW 1
13305: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13306: LD_INT 1
13308: PPUSH
13309: CALL 16510 0 1
13313: IFFALSE 13386
// begin DialogueOn ;
13315: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13328: LD_INT 10
13330: PPUSH
13331: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13335: LD_ADDR_VAR 0 3
13339: PUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_STRING D8-Sol1-1
13345: PPUSH
13346: CALL 16688 0 2
13350: ST_TO_ADDR
// if not un then
13351: LD_VAR 0 3
13355: NOT
13356: IFFALSE 13368
// SayRand ( sex_female , D8-FSol1-1 ) ;
13358: LD_INT 2
13360: PPUSH
13361: LD_STRING D8-FSol1-1
13363: PPUSH
13364: CALL 16688 0 2
// Say ( JMM , D8-JMM-1 ) ;
13368: LD_EXP 21
13372: PPUSH
13373: LD_STRING D8-JMM-1
13375: PPUSH
13376: CALL_OW 88
// DialogueOff ;
13380: CALL_OW 7
// break ;
13384: GO 13388
// end ; end ;
13386: GO 13268
13388: POP
13389: POP
// end ; if not seen [ 4 ] then
13390: LD_EXP 9
13394: PUSH
13395: LD_INT 4
13397: ARRAY
13398: NOT
13399: IFFALSE 13561
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: LD_INT 22
13408: PUSH
13409: LD_INT 2
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 33
13418: PUSH
13419: LD_INT 5
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PPUSH
13430: CALL_OW 69
13434: ST_TO_ADDR
// if tmp then
13435: LD_VAR 0 2
13439: IFFALSE 13561
// for i in tmp do
13441: LD_ADDR_VAR 0 1
13445: PUSH
13446: LD_VAR 0 2
13450: PUSH
13451: FOR_IN
13452: IFFALSE 13559
// if See ( 1 , i ) then
13454: LD_INT 1
13456: PPUSH
13457: LD_VAR 0 1
13461: PPUSH
13462: CALL_OW 292
13466: IFFALSE 13557
// begin seen := Replace ( seen , 4 , true ) ;
13468: LD_ADDR_EXP 9
13472: PUSH
13473: LD_EXP 9
13477: PPUSH
13478: LD_INT 4
13480: PPUSH
13481: LD_INT 1
13483: PPUSH
13484: CALL_OW 1
13488: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13489: LD_INT 1
13491: PPUSH
13492: CALL 16510 0 1
13496: IFFALSE 13557
// begin DialogueOn ;
13498: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13502: LD_VAR 0 1
13506: PPUSH
13507: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13511: LD_INT 10
13513: PPUSH
13514: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13518: LD_ADDR_VAR 0 3
13522: PUSH
13523: LD_INT 1
13525: PPUSH
13526: LD_STRING D5a-Sol1-1
13528: PPUSH
13529: CALL 16688 0 2
13533: ST_TO_ADDR
// if not un then
13534: LD_VAR 0 3
13538: NOT
13539: IFFALSE 13551
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13541: LD_INT 2
13543: PPUSH
13544: LD_STRING D5a-FSol1-1
13546: PPUSH
13547: CALL 16688 0 2
// DialogueOff ;
13551: CALL_OW 7
// break ;
13555: GO 13559
// end ; end ;
13557: GO 13451
13559: POP
13560: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13561: LD_EXP 9
13565: PUSH
13566: LD_INT 5
13568: ARRAY
13569: NOT
13570: PUSH
13571: LD_EXP 9
13575: PUSH
13576: LD_INT 3
13578: ARRAY
13579: AND
13580: IFFALSE 13754
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_INT 22
13589: PUSH
13590: LD_INT 2
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 34
13599: PUSH
13600: LD_INT 31
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: ST_TO_ADDR
// if tmp then
13616: LD_VAR 0 2
13620: IFFALSE 13754
// for i in tmp do
13622: LD_ADDR_VAR 0 1
13626: PUSH
13627: LD_VAR 0 2
13631: PUSH
13632: FOR_IN
13633: IFFALSE 13752
// if See ( 1 , i ) then
13635: LD_INT 1
13637: PPUSH
13638: LD_VAR 0 1
13642: PPUSH
13643: CALL_OW 292
13647: IFFALSE 13750
// begin seen := Replace ( seen , 5 , true ) ;
13649: LD_ADDR_EXP 9
13653: PUSH
13654: LD_EXP 9
13658: PPUSH
13659: LD_INT 5
13661: PPUSH
13662: LD_INT 1
13664: PPUSH
13665: CALL_OW 1
13669: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13670: LD_INT 1
13672: PPUSH
13673: CALL 16510 0 1
13677: IFFALSE 13750
// begin DialogueOn ;
13679: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13683: LD_VAR 0 1
13687: PPUSH
13688: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13692: LD_INT 10
13694: PPUSH
13695: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 1
13706: PPUSH
13707: LD_STRING D8a-Sol2-1
13709: PPUSH
13710: CALL 16688 0 2
13714: ST_TO_ADDR
// if not un then
13715: LD_VAR 0 3
13719: NOT
13720: IFFALSE 13732
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13722: LD_INT 2
13724: PPUSH
13725: LD_STRING D8a-FSol2-1
13727: PPUSH
13728: CALL 16688 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13732: LD_EXP 21
13736: PPUSH
13737: LD_STRING D8a-JMM-1
13739: PPUSH
13740: CALL_OW 88
// DialogueOff ;
13744: CALL_OW 7
// break ;
13748: GO 13752
// end ; end ;
13750: GO 13632
13752: POP
13753: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13754: LD_EXP 9
13758: PUSH
13759: LD_INT 1
13761: ARRAY
13762: PUSH
13763: LD_EXP 9
13767: PUSH
13768: LD_INT 2
13770: ARRAY
13771: AND
13772: PUSH
13773: LD_EXP 9
13777: PUSH
13778: LD_INT 3
13780: ARRAY
13781: AND
13782: PUSH
13783: LD_EXP 9
13787: PUSH
13788: LD_INT 4
13790: ARRAY
13791: AND
13792: PUSH
13793: LD_EXP 9
13797: PUSH
13798: LD_INT 5
13800: ARRAY
13801: AND
13802: IFFALSE 13805
// disable ;
13804: DISABLE
// end ;
13805: PPOPN 4
13807: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13808: LD_EXP 10
13812: PUSH
13813: LD_EXP 11
13817: AND
13818: IFFALSE 14016
13820: GO 13822
13822: DISABLE
13823: LD_INT 0
13825: PPUSH
// begin DialogueOn ;
13826: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13830: LD_EXP 11
13834: PPUSH
13835: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13839: LD_ADDR_VAR 0 1
13843: PUSH
13844: LD_INT 1
13846: PPUSH
13847: LD_STRING D5c-Sol1-1
13849: PPUSH
13850: CALL 16688 0 2
13854: ST_TO_ADDR
// if not un then
13855: LD_VAR 0 1
13859: NOT
13860: IFFALSE 13878
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13862: LD_ADDR_VAR 0 1
13866: PUSH
13867: LD_INT 2
13869: PPUSH
13870: LD_STRING D5c-FSol1-1
13872: PPUSH
13873: CALL 16688 0 2
13877: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13878: LD_EXP 21
13882: PPUSH
13883: LD_STRING D5c-JMM-1
13885: PPUSH
13886: CALL_OW 88
// if IsOk ( Lisa ) then
13890: LD_EXP 22
13894: PPUSH
13895: CALL_OW 302
13899: IFFALSE 13915
// Say ( Lisa , D5d-Lisa-1 ) else
13901: LD_EXP 22
13905: PPUSH
13906: LD_STRING D5d-Lisa-1
13908: PPUSH
13909: CALL_OW 88
13913: GO 14000
// if IsOk ( Cyrus ) then
13915: LD_EXP 25
13919: PPUSH
13920: CALL_OW 302
13924: IFFALSE 13940
// Say ( Cyrus , D5d-Cyrus-1 ) else
13926: LD_EXP 25
13930: PPUSH
13931: LD_STRING D5d-Cyrus-1
13933: PPUSH
13934: CALL_OW 88
13938: GO 14000
// if IsOk ( Gary ) then
13940: LD_EXP 32
13944: PPUSH
13945: CALL_OW 302
13949: IFFALSE 13965
// Say ( Gary , D5d-Gary-1 ) else
13951: LD_EXP 32
13955: PPUSH
13956: LD_STRING D5d-Gary-1
13958: PPUSH
13959: CALL_OW 88
13963: GO 14000
// if GetSex ( un ) = sex_male then
13965: LD_VAR 0 1
13969: PPUSH
13970: CALL_OW 258
13974: PUSH
13975: LD_INT 1
13977: EQUAL
13978: IFFALSE 13994
// Say ( un , D5d-Sol1-1 ) else
13980: LD_VAR 0 1
13984: PPUSH
13985: LD_STRING D5d-Sol1-1
13987: PPUSH
13988: CALL_OW 88
13992: GO 14000
// begin DialogueOff ;
13994: CALL_OW 7
// exit ;
13998: GO 14016
// end ; Say ( JMM , D5d-JMM-1 ) ;
14000: LD_EXP 21
14004: PPUSH
14005: LD_STRING D5d-JMM-1
14007: PPUSH
14008: CALL_OW 88
// DialogueOff ;
14012: CALL_OW 7
// end ;
14016: PPOPN 1
14018: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14019: LD_INT 1
14021: PPUSH
14022: LD_INT 17
14024: PPUSH
14025: CALL_OW 294
14029: PUSH
14030: LD_INT 2
14032: GREATEREQUAL
14033: IFFALSE 14165
14035: GO 14037
14037: DISABLE
14038: LD_INT 0
14040: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14041: LD_INT 10
14043: PPUSH
14044: LD_INT 5
14046: PPUSH
14047: LD_INT 1
14049: PPUSH
14050: LD_INT 10
14052: NEG
14053: PPUSH
14054: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14058: LD_INT 10
14060: PPUSH
14061: LD_INT 5
14063: PPUSH
14064: LD_INT 1
14066: PPUSH
14067: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14071: LD_INT 10
14073: PPUSH
14074: LD_INT 5
14076: PPUSH
14077: CALL_OW 86
// DialogueOn ;
14081: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14085: LD_ADDR_VAR 0 1
14089: PUSH
14090: LD_INT 1
14092: PPUSH
14093: LD_STRING D6-Sci1-1
14095: PPUSH
14096: CALL 16688 0 2
14100: ST_TO_ADDR
// if un then
14101: LD_VAR 0 1
14105: IFFALSE 14143
// begin Say ( JMM , D6-JMM-1 ) ;
14107: LD_EXP 21
14111: PPUSH
14112: LD_STRING D6-JMM-1
14114: PPUSH
14115: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_STRING D6-Sci1-2
14126: PPUSH
14127: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14131: LD_EXP 21
14135: PPUSH
14136: LD_STRING D6-JMM-2
14138: PPUSH
14139: CALL_OW 88
// end ; DialogueOff ;
14143: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14147: LD_STRING M3
14149: PPUSH
14150: CALL_OW 337
// wait ( 0 0$30 ) ;
14154: LD_INT 1050
14156: PPUSH
14157: CALL_OW 67
// AmericanReinforcements ;
14161: CALL 2336 0 0
// end ;
14165: PPOPN 1
14167: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14168: LD_OWVAR 1
14172: PUSH
14173: LD_INT 42000
14175: GREATEREQUAL
14176: PUSH
14177: LD_INT 2
14179: PPUSH
14180: LD_INT 169
14182: PPUSH
14183: LD_INT 90
14185: PPUSH
14186: LD_INT 10
14188: PPUSH
14189: CALL 54461 0 4
14193: PUSH
14194: LD_INT 4
14196: ARRAY
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: PUSH
14202: LD_INT 45
14204: PPUSH
14205: CALL_OW 301
14209: OR
14210: PUSH
14211: LD_INT 45
14213: PPUSH
14214: CALL_OW 255
14218: PUSH
14219: LD_INT 1
14221: EQUAL
14222: OR
14223: AND
14224: PUSH
14225: LD_INT 94
14227: PPUSH
14228: CALL_OW 301
14232: NOT
14233: AND
14234: IFFALSE 15439
14236: GO 14238
14238: DISABLE
14239: LD_INT 0
14241: PPUSH
14242: PPUSH
14243: PPUSH
14244: PPUSH
14245: PPUSH
// begin uc_side := 5 ;
14246: LD_ADDR_OWVAR 20
14250: PUSH
14251: LD_INT 5
14253: ST_TO_ADDR
// uc_nation := 2 ;
14254: LD_ADDR_OWVAR 21
14258: PUSH
14259: LD_INT 2
14261: ST_TO_ADDR
// InitHc ;
14262: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: LD_INT 8
14274: PPUSH
14275: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14279: LD_ADDR_OWVAR 29
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: LD_INT 12
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: ST_TO_ADDR
// hc_name := Hans Fliege ;
14294: LD_ADDR_OWVAR 26
14298: PUSH
14299: LD_STRING Hans Fliege
14301: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14302: LD_ADDR_OWVAR 33
14306: PUSH
14307: LD_STRING SecondCharsGal
14309: ST_TO_ADDR
// hc_face_number := 7 ;
14310: LD_ADDR_OWVAR 34
14314: PUSH
14315: LD_INT 7
14317: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14318: LD_ADDR_EXP 46
14322: PUSH
14323: CALL_OW 44
14327: ST_TO_ADDR
// InitHc ;
14328: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14332: LD_INT 1
14334: PPUSH
14335: LD_INT 16
14337: PPUSH
14338: LD_INT 2
14340: PPUSH
14341: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14345: LD_ADDR_OWVAR 29
14349: PUSH
14350: LD_INT 12
14352: PUSH
14353: LD_INT 12
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: ST_TO_ADDR
// hc_name :=  ;
14360: LD_ADDR_OWVAR 26
14364: PUSH
14365: LD_STRING 
14367: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14368: LD_ADDR_EXP 47
14372: PUSH
14373: CALL_OW 44
14377: ST_TO_ADDR
// InitHc ;
14378: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14382: LD_INT 35
14384: PPUSH
14385: CALL_OW 67
// until not InBattle ( 1 ) ;
14389: LD_INT 1
14391: PPUSH
14392: CALL_OW 463
14396: NOT
14397: IFFALSE 14382
// wait ( 0 0$5 ) ;
14399: LD_INT 175
14401: PPUSH
14402: CALL_OW 67
// DialogueOn ;
14406: CALL_OW 6
// InGameOn ;
14410: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14414: LD_ADDR_VAR 0 1
14418: PUSH
14419: LD_INT 22
14421: PUSH
14422: LD_INT 1
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 2
14431: PUSH
14432: LD_INT 25
14434: PUSH
14435: LD_INT 1
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: PUSH
14442: LD_INT 25
14444: PUSH
14445: LD_INT 2
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: LD_INT 25
14464: PUSH
14465: LD_INT 4
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PUSH
14472: LD_INT 25
14474: PUSH
14475: LD_INT 5
14477: PUSH
14478: EMPTY
14479: LIST
14480: LIST
14481: PUSH
14482: LD_INT 25
14484: PUSH
14485: LD_INT 8
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PUSH
14492: EMPTY
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: EMPTY
14502: LIST
14503: LIST
14504: PPUSH
14505: CALL_OW 69
14509: PUSH
14510: LD_EXP 21
14514: PUSH
14515: LD_EXP 22
14519: PUSH
14520: LD_EXP 23
14524: PUSH
14525: LD_EXP 24
14529: PUSH
14530: LD_EXP 25
14534: PUSH
14535: LD_EXP 26
14539: PUSH
14540: LD_EXP 27
14544: PUSH
14545: LD_EXP 28
14549: PUSH
14550: LD_EXP 29
14554: PUSH
14555: LD_EXP 31
14559: PUSH
14560: LD_EXP 32
14564: PUSH
14565: LD_EXP 33
14569: PUSH
14570: LD_EXP 34
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: DIFF
14590: PPUSH
14591: LD_INT 26
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 72
14605: PUSH
14606: LD_INT 1
14608: ARRAY
14609: ST_TO_ADDR
// if Brown then
14610: LD_EXP 27
14614: IFFALSE 14626
// un := Brown ;
14616: LD_ADDR_VAR 0 1
14620: PUSH
14621: LD_EXP 27
14625: ST_TO_ADDR
// if un then
14626: LD_VAR 0 1
14630: IFFALSE 14656
// begin Say ( un , D7-Sol1-1 ) ;
14632: LD_VAR 0 1
14636: PPUSH
14637: LD_STRING D7-Sol1-1
14639: PPUSH
14640: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14644: LD_EXP 21
14648: PPUSH
14649: LD_STRING D7-JMM-1
14651: PPUSH
14652: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14656: LD_EXP 46
14660: PPUSH
14661: LD_STRING D7-Ar1-1
14663: PPUSH
14664: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14668: LD_EXP 21
14672: PPUSH
14673: LD_STRING D7-JMM-2
14675: PPUSH
14676: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14680: LD_EXP 46
14684: PPUSH
14685: LD_STRING D7-Ar1-2
14687: PPUSH
14688: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14692: LD_EXP 21
14696: PPUSH
14697: LD_STRING D7-JMM-3
14699: PPUSH
14700: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14704: LD_EXP 46
14708: PPUSH
14709: LD_STRING D7-Ar1-3
14711: PPUSH
14712: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14716: LD_EXP 21
14720: PPUSH
14721: LD_STRING D7-JMM-4
14723: PPUSH
14724: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14728: LD_EXP 46
14732: PPUSH
14733: LD_STRING D7-Ar1-4
14735: PPUSH
14736: CALL_OW 94
// InGameOff ;
14740: CALL_OW 9
// DialogueOff ;
14744: CALL_OW 7
// case Query ( QCameras ) of 1 :
14748: LD_STRING QCameras
14750: PPUSH
14751: CALL_OW 97
14755: PUSH
14756: LD_INT 1
14758: DOUBLE
14759: EQUAL
14760: IFTRUE 14764
14762: GO 14767
14764: POP
// ; 2 :
14765: GO 14781
14767: LD_INT 2
14769: DOUBLE
14770: EQUAL
14771: IFTRUE 14775
14773: GO 14780
14775: POP
// exit ; end ;
14776: GO 15439
14778: GO 14781
14780: POP
// ChangeMissionObjectives ( MCar ) ;
14781: LD_STRING MCar
14783: PPUSH
14784: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14788: LD_INT 124
14790: PPUSH
14791: LD_INT 90
14793: PPUSH
14794: LD_INT 1
14796: PPUSH
14797: LD_INT 6
14799: NEG
14800: PPUSH
14801: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14805: LD_INT 124
14807: PPUSH
14808: LD_INT 90
14810: PPUSH
14811: LD_INT 1
14813: PPUSH
14814: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14818: LD_INT 12
14820: PPUSH
14821: LD_INT 1
14823: PPUSH
14824: CALL_OW 424
// wait ( 3 ) ;
14828: LD_INT 3
14830: PPUSH
14831: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14835: LD_INT 124
14837: PPUSH
14838: LD_INT 90
14840: PPUSH
14841: CALL_OW 86
// cargo := false ;
14845: LD_ADDR_VAR 0 3
14849: PUSH
14850: LD_INT 0
14852: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14853: LD_INT 35
14855: PPUSH
14856: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14860: LD_ADDR_VAR 0 3
14864: PUSH
14865: LD_INT 12
14867: PPUSH
14868: LD_INT 32
14870: PUSH
14871: LD_INT 3
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 34
14880: PUSH
14881: LD_INT 32
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 58
14890: PUSH
14891: EMPTY
14892: LIST
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: LIST
14898: PPUSH
14899: CALL_OW 70
14903: ST_TO_ADDR
// until cargo ;
14904: LD_VAR 0 3
14908: IFFALSE 14853
// cargo := cargo [ 1 ] ;
14910: LD_ADDR_VAR 0 3
14914: PUSH
14915: LD_VAR 0 3
14919: PUSH
14920: LD_INT 1
14922: ARRAY
14923: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14924: LD_VAR 0 3
14928: PPUSH
14929: LD_INT 5
14931: PPUSH
14932: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14936: LD_INT 12
14938: PPUSH
14939: LD_INT 0
14941: PPUSH
14942: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14946: LD_EXP 46
14950: PPUSH
14951: LD_INT 11
14953: PPUSH
14954: LD_INT 0
14956: PPUSH
14957: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14961: LD_EXP 47
14965: PPUSH
14966: LD_INT 11
14968: PPUSH
14969: LD_INT 0
14971: PPUSH
14972: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14976: LD_EXP 46
14980: PUSH
14981: LD_EXP 47
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: PPUSH
14990: LD_INT 12
14992: PPUSH
14993: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14997: LD_EXP 46
15001: PPUSH
15002: LD_VAR 0 3
15006: PPUSH
15007: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15011: LD_EXP 46
15015: PUSH
15016: LD_EXP 47
15020: PUSH
15021: EMPTY
15022: LIST
15023: LIST
15024: PPUSH
15025: LD_INT 209
15027: PPUSH
15028: LD_INT 178
15030: PPUSH
15031: CALL_OW 171
// escaped := 0 ;
15035: LD_ADDR_VAR 0 5
15039: PUSH
15040: LD_INT 0
15042: ST_TO_ADDR
// while ( true ) do
15043: LD_INT 1
15045: IFFALSE 15261
// begin wait ( 0 0$1 ) ;
15047: LD_INT 35
15049: PPUSH
15050: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15054: LD_EXP 46
15058: PPUSH
15059: CALL_OW 314
15063: NOT
15064: PUSH
15065: LD_EXP 47
15069: PPUSH
15070: CALL_OW 314
15074: NOT
15075: OR
15076: IFFALSE 15102
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15078: LD_EXP 46
15082: PUSH
15083: LD_EXP 47
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PPUSH
15092: LD_INT 209
15094: PPUSH
15095: LD_INT 178
15097: PPUSH
15098: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15102: LD_EXP 46
15106: PPUSH
15107: LD_INT 10
15109: PPUSH
15110: CALL_OW 308
15114: IFFALSE 15139
// begin RemoveUnit ( ar_mechanic ) ;
15116: LD_EXP 46
15120: PPUSH
15121: CALL_OW 64
// escaped := escaped + 1 ;
15125: LD_ADDR_VAR 0 5
15129: PUSH
15130: LD_VAR 0 5
15134: PUSH
15135: LD_INT 1
15137: PLUS
15138: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15139: LD_EXP 47
15143: PPUSH
15144: LD_INT 10
15146: PPUSH
15147: CALL_OW 308
15151: IFFALSE 15176
// begin RemoveUnit ( ar_mechanic_friend ) ;
15153: LD_EXP 47
15157: PPUSH
15158: CALL_OW 64
// escaped := escaped + 1 ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 5
15171: PUSH
15172: LD_INT 1
15174: PLUS
15175: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15176: LD_VAR 0 3
15180: PPUSH
15181: LD_INT 10
15183: PPUSH
15184: CALL_OW 308
15188: IFFALSE 15199
// RemoveUnit ( cargo ) ;
15190: LD_VAR 0 3
15194: PPUSH
15195: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15199: LD_EXP 46
15203: PPUSH
15204: CALL_OW 305
15208: NOT
15209: PUSH
15210: LD_VAR 0 5
15214: PUSH
15215: LD_INT 2
15217: GREATEREQUAL
15218: AND
15219: IFFALSE 15223
// break ;
15221: GO 15261
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15223: LD_EXP 46
15227: PPUSH
15228: CALL_OW 305
15232: NOT
15233: PUSH
15234: LD_EXP 47
15238: PPUSH
15239: CALL_OW 305
15243: NOT
15244: AND
15245: PUSH
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: LESS
15254: AND
15255: IFFALSE 15259
// exit ;
15257: GO 15439
// end ;
15259: GO 15043
// wait ( 0 0$2 ) ;
15261: LD_INT 70
15263: PPUSH
15264: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15268: LD_EXP 46
15272: PPUSH
15273: LD_STRING D7a-Ar1-1
15275: PPUSH
15276: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15280: LD_ADDR_VAR 0 4
15284: PUSH
15285: LD_INT 129
15287: PUSH
15288: LD_INT 10
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: PUSH
15295: LD_INT 103
15297: PUSH
15298: LD_INT 6
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 148
15307: PUSH
15308: LD_INT 47
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: PUSH
15315: LD_INT 155
15317: PUSH
15318: LD_INT 16
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: ST_TO_ADDR
// if Difficulty = 1 then
15331: LD_OWVAR 67
15335: PUSH
15336: LD_INT 1
15338: EQUAL
15339: IFFALSE 15376
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15341: LD_ADDR_VAR 0 4
15345: PUSH
15346: LD_VAR 0 4
15350: PUSH
15351: LD_INT 78
15353: PUSH
15354: LD_INT 7
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: PUSH
15361: LD_INT 104
15363: PUSH
15364: LD_INT 43
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: ADD
15375: ST_TO_ADDR
// for i in tmp do
15376: LD_ADDR_VAR 0 2
15380: PUSH
15381: LD_VAR 0 4
15385: PUSH
15386: FOR_IN
15387: IFFALSE 15420
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15389: LD_VAR 0 2
15393: PUSH
15394: LD_INT 1
15396: ARRAY
15397: PPUSH
15398: LD_VAR 0 2
15402: PUSH
15403: LD_INT 2
15405: ARRAY
15406: PPUSH
15407: LD_INT 1
15409: PPUSH
15410: LD_INT 9
15412: NEG
15413: PPUSH
15414: CALL_OW 330
15418: GO 15386
15420: POP
15421: POP
// SetAchievement ( ACH_FRIEND ) ;
15422: LD_STRING ACH_FRIEND
15424: PPUSH
15425: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15429: LD_INT 129
15431: PPUSH
15432: LD_INT 10
15434: PPUSH
15435: CALL_OW 84
// end ;
15439: PPOPN 5
15441: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15442: LD_EXP 15
15446: PUSH
15447: LD_INT 21000
15449: MINUS
15450: PUSH
15451: LD_OWVAR 1
15455: LESSEQUAL
15456: IFFALSE 15496
15458: GO 15460
15460: DISABLE
// begin powell_warn := true ;
15461: LD_ADDR_EXP 16
15465: PUSH
15466: LD_INT 1
15468: ST_TO_ADDR
// DialogueOn ;
15469: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15473: LD_EXP 30
15477: PPUSH
15478: LD_STRING D9-Pow-1
15480: PPUSH
15481: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15485: LD_INT 10
15487: PPUSH
15488: CALL_OW 68
// DialogueOff ;
15492: CALL_OW 7
// end ;
15496: END
// every 0 0$1 trigger game_time <= tick do
15497: LD_EXP 15
15501: PUSH
15502: LD_OWVAR 1
15506: LESSEQUAL
15507: IFFALSE 15546
15509: GO 15511
15511: DISABLE
// begin DialogueOn ;
15512: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15516: LD_EXP 30
15520: PPUSH
15521: LD_STRING D9a-Pow-1
15523: PPUSH
15524: CALL_OW 94
// dwait ( 0 0$2 ) ;
15528: LD_INT 70
15530: PPUSH
15531: CALL_OW 68
// DialogueOff ;
15535: CALL_OW 7
// YouLost ( Command ) ;
15539: LD_STRING Command
15541: PPUSH
15542: CALL_OW 104
// end ;
15546: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15547: LD_INT 22
15549: PUSH
15550: LD_INT 2
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: LD_INT 30
15559: PUSH
15560: LD_INT 1
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PPUSH
15571: CALL_OW 69
15575: PUSH
15576: LD_INT 0
15578: EQUAL
15579: PUSH
15580: LD_EXP 21
15584: PPUSH
15585: CALL_OW 302
15589: AND
15590: IFFALSE 16507
15592: GO 15594
15594: DISABLE
15595: LD_INT 0
15597: PPUSH
15598: PPUSH
15599: PPUSH
15600: PPUSH
// begin m1 := false ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 0
15608: ST_TO_ADDR
// m2 := false ;
15609: LD_ADDR_VAR 0 3
15613: PUSH
15614: LD_INT 0
15616: ST_TO_ADDR
// m3 := false ;
15617: LD_ADDR_VAR 0 4
15621: PUSH
15622: LD_INT 0
15624: ST_TO_ADDR
// if not am_veh_consturcted then
15625: LD_EXP 20
15629: NOT
15630: IFFALSE 15639
// SetAchievement ( ACH_ARABTECH ) ;
15632: LD_STRING ACH_ARABTECH
15634: PPUSH
15635: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15639: LD_OWVAR 1
15643: PUSH
15644: LD_INT 252000
15646: PUSH
15647: LD_INT 210000
15649: PUSH
15650: LD_INT 199500
15652: PUSH
15653: LD_INT 193200
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: LIST
15660: LIST
15661: PUSH
15662: LD_OWVAR 67
15666: ARRAY
15667: LESS
15668: IFFALSE 15690
// begin m3 := true ;
15670: LD_ADDR_VAR 0 4
15674: PUSH
15675: LD_INT 1
15677: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15678: LD_STRING Time1
15680: PPUSH
15681: LD_INT 1
15683: PPUSH
15684: CALL_OW 101
// end else
15688: GO 15721
// if not powell_warn then
15690: LD_EXP 16
15694: NOT
15695: IFFALSE 15710
// AddMedal ( Time1 , - 1 ) else
15697: LD_STRING Time1
15699: PPUSH
15700: LD_INT 1
15702: NEG
15703: PPUSH
15704: CALL_OW 101
15708: GO 15721
// AddMedal ( Time1 , - 2 ) ;
15710: LD_STRING Time1
15712: PPUSH
15713: LD_INT 2
15715: NEG
15716: PPUSH
15717: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15721: LD_EXP 17
15725: PUSH
15726: LD_INT 5
15728: PUSH
15729: LD_INT 4
15731: PUSH
15732: LD_INT 3
15734: PUSH
15735: LD_INT 3
15737: PUSH
15738: EMPTY
15739: LIST
15740: LIST
15741: LIST
15742: LIST
15743: PUSH
15744: LD_OWVAR 67
15748: ARRAY
15749: GREATEREQUAL
15750: IFFALSE 15765
// AddMedal ( Destroy , - 2 ) else
15752: LD_STRING Destroy
15754: PPUSH
15755: LD_INT 2
15757: NEG
15758: PPUSH
15759: CALL_OW 101
15763: GO 15898
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15765: LD_INT 22
15767: PUSH
15768: LD_INT 2
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: LD_INT 21
15777: PUSH
15778: LD_INT 3
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: LD_INT 50
15787: PUSH
15788: EMPTY
15789: LIST
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: LIST
15795: PPUSH
15796: CALL_OW 69
15800: PUSH
15801: LD_INT 25
15803: GREATEREQUAL
15804: IFFALSE 15819
// AddMedal ( Destroy , - 1 ) else
15806: LD_STRING Destroy
15808: PPUSH
15809: LD_INT 1
15811: NEG
15812: PPUSH
15813: CALL_OW 101
15817: GO 15898
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15819: LD_INT 22
15821: PUSH
15822: LD_INT 2
15824: PUSH
15825: EMPTY
15826: LIST
15827: LIST
15828: PUSH
15829: LD_INT 21
15831: PUSH
15832: LD_INT 3
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 50
15841: PUSH
15842: EMPTY
15843: LIST
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: LIST
15849: PPUSH
15850: CALL_OW 69
15854: PUSH
15855: LD_INT 15
15857: GREATEREQUAL
15858: IFFALSE 15880
// begin m1 := true ;
15860: LD_ADDR_VAR 0 2
15864: PUSH
15865: LD_INT 1
15867: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15868: LD_STRING Destroy
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: CALL_OW 101
// end else
15878: GO 15898
// begin m1 := true ;
15880: LD_ADDR_VAR 0 2
15884: PUSH
15885: LD_INT 1
15887: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15888: LD_STRING Destroy
15890: PPUSH
15891: LD_INT 2
15893: PPUSH
15894: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15898: LD_EXP 13
15902: PPUSH
15903: LD_STRING 11_artifact_captured
15905: PPUSH
15906: CALL_OW 39
// if artifact_get then
15910: LD_EXP 13
15914: IFFALSE 15936
// begin m2 := true ;
15916: LD_ADDR_VAR 0 3
15920: PUSH
15921: LD_INT 1
15923: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15924: LD_STRING Artefact
15926: PPUSH
15927: LD_INT 1
15929: PPUSH
15930: CALL_OW 101
// end else
15934: GO 15947
// AddMedal ( Artefact , - 1 ) ;
15936: LD_STRING Artefact
15938: PPUSH
15939: LD_INT 1
15941: NEG
15942: PPUSH
15943: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15947: LD_VAR 0 2
15951: PUSH
15952: LD_VAR 0 3
15956: AND
15957: PUSH
15958: LD_VAR 0 4
15962: AND
15963: PUSH
15964: LD_OWVAR 67
15968: PUSH
15969: LD_INT 3
15971: GREATEREQUAL
15972: AND
15973: IFFALSE 15985
// SetAchievementEX ( ACH_AMER , 11 ) ;
15975: LD_STRING ACH_AMER
15977: PPUSH
15978: LD_INT 11
15980: PPUSH
15981: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15985: LD_VAR 0 2
15989: PUSH
15990: LD_VAR 0 3
15994: AND
15995: PUSH
15996: LD_VAR 0 4
16000: AND
16001: PUSH
16002: LD_EXP 17
16006: PUSH
16007: LD_INT 0
16009: EQUAL
16010: AND
16011: IFFALSE 16027
// begin wait ( 3 ) ;
16013: LD_INT 3
16015: PPUSH
16016: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16020: LD_STRING ACH_GENERAL
16022: PPUSH
16023: CALL_OW 543
// end ; if tick <= 100 100$00 then
16027: LD_OWVAR 1
16031: PUSH
16032: LD_INT 210000
16034: LESSEQUAL
16035: IFFALSE 16051
// begin wait ( 3 ) ;
16037: LD_INT 3
16039: PPUSH
16040: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16044: LD_STRING ACH_ASPEED_11
16046: PPUSH
16047: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16051: LD_STRING MAIN
16053: PPUSH
16054: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16058: LD_ADDR_EXP 19
16062: PUSH
16063: LD_EXP 19
16067: PPUSH
16068: LD_INT 51
16070: PUSH
16071: EMPTY
16072: LIST
16073: PPUSH
16074: CALL_OW 72
16078: ST_TO_ADDR
// tmp := JMM ^ selected ;
16079: LD_ADDR_VAR 0 1
16083: PUSH
16084: LD_EXP 21
16088: PUSH
16089: LD_EXP 19
16093: ADD
16094: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16095: LD_VAR 0 1
16099: PPUSH
16100: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16104: LD_VAR 0 1
16108: PUSH
16109: LD_EXP 21
16113: PUSH
16114: LD_EXP 22
16118: PUSH
16119: LD_EXP 23
16123: PUSH
16124: LD_EXP 24
16128: PUSH
16129: LD_EXP 25
16133: PUSH
16134: LD_EXP 26
16138: PUSH
16139: LD_EXP 27
16143: PUSH
16144: LD_EXP 28
16148: PUSH
16149: LD_EXP 29
16153: PUSH
16154: LD_EXP 31
16158: PUSH
16159: LD_EXP 32
16163: PUSH
16164: LD_EXP 33
16168: PUSH
16169: LD_EXP 34
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: LIST
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: DIFF
16189: PPUSH
16190: LD_STRING 11c_others
16192: PPUSH
16193: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16197: LD_EXP 21
16201: PPUSH
16202: LD_EXP 3
16206: PUSH
16207: LD_STRING JMM
16209: STR
16210: PPUSH
16211: CALL_OW 38
// if Lisa then
16215: LD_EXP 22
16219: IFFALSE 16239
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16221: LD_EXP 22
16225: PPUSH
16226: LD_EXP 3
16230: PUSH
16231: LD_STRING Lisa
16233: STR
16234: PPUSH
16235: CALL_OW 38
// if Donaldson then
16239: LD_EXP 23
16243: IFFALSE 16263
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16245: LD_EXP 23
16249: PPUSH
16250: LD_EXP 3
16254: PUSH
16255: LD_STRING Donaldson
16257: STR
16258: PPUSH
16259: CALL_OW 38
// if Bobby then
16263: LD_EXP 24
16267: IFFALSE 16287
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16269: LD_EXP 24
16273: PPUSH
16274: LD_EXP 3
16278: PUSH
16279: LD_STRING Bobby
16281: STR
16282: PPUSH
16283: CALL_OW 38
// if Cyrus then
16287: LD_EXP 25
16291: IFFALSE 16311
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16293: LD_EXP 25
16297: PPUSH
16298: LD_EXP 3
16302: PUSH
16303: LD_STRING Cyrus
16305: STR
16306: PPUSH
16307: CALL_OW 38
// if Denis then
16311: LD_EXP 26
16315: IFFALSE 16335
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16317: LD_EXP 26
16321: PPUSH
16322: LD_EXP 3
16326: PUSH
16327: LD_STRING Denis
16329: STR
16330: PPUSH
16331: CALL_OW 38
// if Brown then
16335: LD_EXP 27
16339: IFFALSE 16359
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16341: LD_EXP 27
16345: PPUSH
16346: LD_EXP 3
16350: PUSH
16351: LD_STRING Brown
16353: STR
16354: PPUSH
16355: CALL_OW 38
// if Gladstone then
16359: LD_EXP 28
16363: IFFALSE 16383
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16365: LD_EXP 28
16369: PPUSH
16370: LD_EXP 3
16374: PUSH
16375: LD_STRING Gladstone
16377: STR
16378: PPUSH
16379: CALL_OW 38
// if Houten then
16383: LD_EXP 29
16387: IFFALSE 16407
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16389: LD_EXP 29
16393: PPUSH
16394: LD_EXP 3
16398: PUSH
16399: LD_STRING Houten
16401: STR
16402: PPUSH
16403: CALL_OW 38
// if Cornel then
16407: LD_EXP 31
16411: IFFALSE 16431
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16413: LD_EXP 31
16417: PPUSH
16418: LD_EXP 3
16422: PUSH
16423: LD_STRING Cornell
16425: STR
16426: PPUSH
16427: CALL_OW 38
// if Gary then
16431: LD_EXP 32
16435: IFFALSE 16455
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16437: LD_EXP 32
16441: PPUSH
16442: LD_EXP 3
16446: PUSH
16447: LD_STRING Gary
16449: STR
16450: PPUSH
16451: CALL_OW 38
// if Frank then
16455: LD_EXP 33
16459: IFFALSE 16479
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16461: LD_EXP 33
16465: PPUSH
16466: LD_EXP 3
16470: PUSH
16471: LD_STRING Frank
16473: STR
16474: PPUSH
16475: CALL_OW 38
// if Kikuchi then
16479: LD_EXP 34
16483: IFFALSE 16503
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16485: LD_EXP 34
16489: PPUSH
16490: LD_EXP 3
16494: PUSH
16495: LD_STRING Kikuchi
16497: STR
16498: PPUSH
16499: CALL_OW 38
// YouWin ;
16503: CALL_OW 103
// end ;
16507: PPOPN 4
16509: END
// export function CanSayRand ( side ) ; begin
16510: LD_INT 0
16512: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16513: LD_ADDR_VAR 0 2
16517: PUSH
16518: LD_INT 52
16520: PUSH
16521: EMPTY
16522: LIST
16523: PUSH
16524: LD_INT 22
16526: PUSH
16527: LD_VAR 0 1
16531: PUSH
16532: EMPTY
16533: LIST
16534: LIST
16535: PUSH
16536: LD_INT 2
16538: PUSH
16539: LD_INT 25
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: LD_INT 25
16551: PUSH
16552: LD_INT 2
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: PUSH
16559: LD_INT 25
16561: PUSH
16562: LD_INT 3
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PUSH
16569: LD_INT 25
16571: PUSH
16572: LD_INT 4
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: LIST
16583: LIST
16584: LIST
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 69
16595: PUSH
16596: LD_EXP 21
16600: PUSH
16601: LD_EXP 33
16605: PUSH
16606: LD_EXP 22
16610: PUSH
16611: LD_EXP 23
16615: PUSH
16616: LD_EXP 24
16620: PUSH
16621: LD_EXP 25
16625: PUSH
16626: LD_EXP 26
16630: PUSH
16631: LD_EXP 27
16635: PUSH
16636: LD_EXP 28
16640: PUSH
16641: LD_EXP 29
16645: PUSH
16646: LD_EXP 30
16650: PUSH
16651: LD_EXP 31
16655: PUSH
16656: LD_EXP 32
16660: PUSH
16661: LD_EXP 34
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: LIST
16675: LIST
16676: LIST
16677: LIST
16678: LIST
16679: LIST
16680: LIST
16681: DIFF
16682: ST_TO_ADDR
// end ;
16683: LD_VAR 0 2
16687: RET
// export function SayRand ( sex , dial ) ; begin
16688: LD_INT 0
16690: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16691: LD_ADDR_VAR 0 3
16695: PUSH
16696: LD_INT 52
16698: PUSH
16699: EMPTY
16700: LIST
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_INT 1
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 26
16714: PUSH
16715: LD_VAR 0 1
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: LD_INT 2
16726: PUSH
16727: LD_INT 25
16729: PUSH
16730: LD_INT 1
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PUSH
16737: LD_INT 25
16739: PUSH
16740: LD_INT 2
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 25
16749: PUSH
16750: LD_INT 3
16752: PUSH
16753: EMPTY
16754: LIST
16755: LIST
16756: PUSH
16757: LD_INT 25
16759: PUSH
16760: LD_INT 4
16762: PUSH
16763: EMPTY
16764: LIST
16765: LIST
16766: PUSH
16767: EMPTY
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: LIST
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: PPUSH
16780: CALL_OW 69
16784: PUSH
16785: LD_EXP 21
16789: PUSH
16790: LD_EXP 33
16794: PUSH
16795: LD_EXP 22
16799: PUSH
16800: LD_EXP 23
16804: PUSH
16805: LD_EXP 24
16809: PUSH
16810: LD_EXP 25
16814: PUSH
16815: LD_EXP 26
16819: PUSH
16820: LD_EXP 27
16824: PUSH
16825: LD_EXP 28
16829: PUSH
16830: LD_EXP 29
16834: PUSH
16835: LD_EXP 30
16839: PUSH
16840: LD_EXP 31
16844: PUSH
16845: LD_EXP 32
16849: PUSH
16850: LD_EXP 34
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: LIST
16865: LIST
16866: LIST
16867: LIST
16868: LIST
16869: LIST
16870: DIFF
16871: ST_TO_ADDR
// if not result then
16872: LD_VAR 0 3
16876: NOT
16877: IFFALSE 16881
// exit ;
16879: GO 16909
// result := result [ 1 ] ;
16881: LD_ADDR_VAR 0 3
16885: PUSH
16886: LD_VAR 0 3
16890: PUSH
16891: LD_INT 1
16893: ARRAY
16894: ST_TO_ADDR
// Say ( result , dial ) ;
16895: LD_VAR 0 3
16899: PPUSH
16900: LD_VAR 0 2
16904: PPUSH
16905: CALL_OW 88
// end ;
16909: LD_VAR 0 3
16913: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16914: LD_INT 0
16916: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16917: LD_ADDR_VAR 0 4
16921: PUSH
16922: LD_INT 22
16924: PUSH
16925: LD_INT 1
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 26
16934: PUSH
16935: LD_VAR 0 1
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: PUSH
16944: LD_INT 2
16946: PUSH
16947: LD_INT 25
16949: PUSH
16950: LD_INT 1
16952: PUSH
16953: EMPTY
16954: LIST
16955: LIST
16956: PUSH
16957: LD_INT 25
16959: PUSH
16960: LD_INT 2
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: PUSH
16967: LD_INT 25
16969: PUSH
16970: LD_INT 3
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: PUSH
16977: LD_INT 25
16979: PUSH
16980: LD_INT 4
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: EMPTY
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: LIST
16998: PPUSH
16999: CALL_OW 69
17003: PUSH
17004: LD_EXP 21
17008: PUSH
17009: LD_EXP 33
17013: PUSH
17014: LD_EXP 22
17018: PUSH
17019: LD_EXP 23
17023: PUSH
17024: LD_EXP 24
17028: PUSH
17029: LD_EXP 25
17033: PUSH
17034: LD_EXP 26
17038: PUSH
17039: LD_EXP 27
17043: PUSH
17044: LD_EXP 28
17048: PUSH
17049: LD_EXP 29
17053: PUSH
17054: LD_EXP 30
17058: PUSH
17059: LD_EXP 31
17063: PUSH
17064: LD_EXP 32
17068: PUSH
17069: LD_EXP 34
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: LIST
17088: LIST
17089: PUSH
17090: LD_VAR 0 3
17094: ADD
17095: DIFF
17096: ST_TO_ADDR
// if not result then
17097: LD_VAR 0 4
17101: NOT
17102: IFFALSE 17106
// exit ;
17104: GO 17134
// result := result [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_VAR 0 4
17115: PUSH
17116: LD_INT 1
17118: ARRAY
17119: ST_TO_ADDR
// Say ( result , dial ) ;
17120: LD_VAR 0 4
17124: PPUSH
17125: LD_VAR 0 2
17129: PPUSH
17130: CALL_OW 88
// end ; end_of_file
17134: LD_VAR 0 4
17138: RET
// export function CustomEvent ( event ) ; begin
17139: LD_INT 0
17141: PPUSH
// end ;
17142: LD_VAR 0 2
17146: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17147: LD_VAR 0 1
17151: PPUSH
17152: CALL_OW 255
17156: PUSH
17157: LD_INT 1
17159: EQUAL
17160: IFFALSE 17170
// artifact_get := true ;
17162: LD_ADDR_EXP 13
17166: PUSH
17167: LD_INT 1
17169: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL_OW 255
17179: PUSH
17180: LD_INT 2
17182: EQUAL
17183: IFFALSE 17201
// begin artifact_get := false ;
17185: LD_ADDR_EXP 13
17189: PUSH
17190: LD_INT 0
17192: ST_TO_ADDR
// artifact_stolen := true ;
17193: LD_ADDR_EXP 12
17197: PUSH
17198: LD_INT 1
17200: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17201: LD_ADDR_EXP 14
17205: PUSH
17206: LD_INT 1
17208: ST_TO_ADDR
// end ;
17209: PPOPN 2
17211: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17212: LD_ADDR_EXP 14
17216: PUSH
17217: LD_INT 0
17219: ST_TO_ADDR
// end ;
17220: PPOPN 2
17222: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17223: LD_VAR 0 1
17227: PPUSH
17228: CALL 103487 0 1
// if un = JMM then
17232: LD_VAR 0 1
17236: PUSH
17237: LD_EXP 21
17241: EQUAL
17242: IFFALSE 17253
// begin YouLost ( JMM ) ;
17244: LD_STRING JMM
17246: PPUSH
17247: CALL_OW 104
// exit ;
17251: GO 17385
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17253: LD_VAR 0 1
17257: PUSH
17258: LD_INT 22
17260: PUSH
17261: LD_INT 1
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 21
17270: PUSH
17271: LD_INT 1
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PUSH
17278: LD_INT 2
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 1
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 25
17293: PUSH
17294: LD_INT 2
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: LD_INT 25
17303: PUSH
17304: LD_INT 3
17306: PUSH
17307: EMPTY
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 25
17313: PUSH
17314: LD_INT 4
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 25
17323: PUSH
17324: LD_INT 5
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: LD_INT 25
17333: PUSH
17334: LD_INT 8
17336: PUSH
17337: EMPTY
17338: LIST
17339: LIST
17340: PUSH
17341: EMPTY
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: LIST
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: LIST
17354: PPUSH
17355: CALL_OW 69
17359: IN
17360: IFFALSE 17376
// loses_counter := loses_counter + 1 ;
17362: LD_ADDR_EXP 17
17366: PUSH
17367: LD_EXP 17
17371: PUSH
17372: LD_INT 1
17374: PLUS
17375: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 45593 0 1
// end ;
17385: PPOPN 1
17387: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17388: LD_VAR 0 1
17392: PPUSH
17393: LD_VAR 0 2
17397: PPUSH
17398: CALL 47927 0 2
// end ;
17402: PPOPN 2
17404: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17405: LD_VAR 0 1
17409: PPUSH
17410: CALL 47236 0 1
// end ;
17414: PPOPN 1
17416: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17417: LD_VAR 0 1
17421: PPUSH
17422: LD_VAR 0 2
17426: PPUSH
17427: LD_VAR 0 3
17431: PPUSH
17432: LD_VAR 0 4
17436: PPUSH
17437: LD_VAR 0 5
17441: PPUSH
17442: CALL 44909 0 5
// end ;
17446: PPOPN 5
17448: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17449: LD_VAR 0 1
17453: PPUSH
17454: LD_VAR 0 2
17458: PPUSH
17459: CALL 103609 0 2
// if GetNation ( vehicle ) = nation_american then
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL_OW 248
17472: PUSH
17473: LD_INT 1
17475: EQUAL
17476: IFFALSE 17486
// am_veh_consturcted := true ;
17478: LD_ADDR_EXP 20
17482: PUSH
17483: LD_INT 1
17485: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17486: LD_VAR 0 1
17490: PPUSH
17491: LD_VAR 0 2
17495: PPUSH
17496: CALL 44490 0 2
// end ;
17500: PPOPN 2
17502: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17503: LD_VAR 0 1
17507: PPUSH
17508: CALL_OW 247
17512: PUSH
17513: LD_INT 2
17515: EQUAL
17516: IFFALSE 17520
// exit ;
17518: GO 17537
// if not kamikazed then
17520: LD_EXP 11
17524: NOT
17525: IFFALSE 17537
// kamikazed := unit ;
17527: LD_ADDR_EXP 11
17531: PUSH
17532: LD_VAR 0 1
17536: ST_TO_ADDR
// end ;
17537: PPOPN 1
17539: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17540: LD_INT 0
17542: PPUSH
17543: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: LD_VAR 0 2
17553: PPUSH
17554: LD_VAR 0 3
17558: PPUSH
17559: LD_VAR 0 4
17563: PPUSH
17564: CALL 44328 0 4
// end ;
17568: PPOPN 6
17570: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17571: LD_VAR 0 1
17575: PPUSH
17576: LD_VAR 0 2
17580: PPUSH
17581: LD_VAR 0 3
17585: PPUSH
17586: CALL 44103 0 3
// end ;
17590: PPOPN 3
17592: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17593: LD_VAR 0 1
17597: PPUSH
17598: LD_VAR 0 2
17602: PPUSH
17603: CALL 45289 0 2
// end ;
17607: PPOPN 2
17609: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17610: LD_VAR 0 1
17614: PPUSH
17615: LD_VAR 0 2
17619: PPUSH
17620: CALL 43797 0 2
// end ;
17624: PPOPN 2
17626: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17627: LD_VAR 0 1
17631: PPUSH
17632: LD_VAR 0 2
17636: PPUSH
17637: CALL 43988 0 2
// end ;
17641: PPOPN 2
17643: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17644: LD_VAR 0 1
17648: PPUSH
17649: CALL 46995 0 1
// end ;
17653: PPOPN 1
17655: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17656: LD_VAR 0 1
17660: PPUSH
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL 48222 0 2
// end ;
17670: PPOPN 2
17672: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17673: LD_VAR 0 1
17677: PPUSH
17678: LD_VAR 0 2
17682: PPUSH
17683: LD_VAR 0 3
17687: PPUSH
17688: LD_VAR 0 4
17692: PPUSH
17693: CALL 48438 0 4
// end ;
17697: PPOPN 4
17699: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17700: LD_VAR 0 1
17704: PPUSH
17705: CALL 103593 0 1
// end ; end_of_file
17709: PPOPN 1
17711: END
// every 0 0$1 trigger game do
17712: LD_EXP 2
17716: IFFALSE 17746
17718: GO 17720
17720: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17721: LD_INT 7
17723: PUSH
17724: LD_INT 6
17726: PUSH
17727: LD_INT 4
17729: PUSH
17730: LD_INT 6
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: LIST
17738: PPUSH
17739: LD_INT 1750
17741: PPUSH
17742: CALL 17747 0 2
17746: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17747: LD_INT 0
17749: PPUSH
17750: PPUSH
17751: PPUSH
// if not areas then
17752: LD_VAR 0 1
17756: NOT
17757: IFFALSE 17761
// exit ;
17759: GO 17891
// repeat wait ( time ) ;
17761: LD_VAR 0 2
17765: PPUSH
17766: CALL_OW 67
// for i in areas do
17770: LD_ADDR_VAR 0 4
17774: PUSH
17775: LD_VAR 0 1
17779: PUSH
17780: FOR_IN
17781: IFFALSE 17850
// begin p := rand ( 1 , 90 ) ;
17783: LD_ADDR_VAR 0 5
17787: PUSH
17788: LD_INT 1
17790: PPUSH
17791: LD_INT 90
17793: PPUSH
17794: CALL_OW 12
17798: ST_TO_ADDR
// if Prob ( p ) then
17799: LD_VAR 0 5
17803: PPUSH
17804: CALL_OW 13
17808: IFFALSE 17848
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17810: LD_INT 2
17812: PPUSH
17813: LD_INT 5
17815: PPUSH
17816: CALL_OW 12
17820: PPUSH
17821: LD_VAR 0 4
17825: PPUSH
17826: LD_INT 1
17828: PPUSH
17829: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17833: LD_INT 735
17835: PPUSH
17836: LD_INT 1295
17838: PPUSH
17839: CALL_OW 12
17843: PPUSH
17844: CALL_OW 67
// end ; end ;
17848: GO 17780
17850: POP
17851: POP
// time := time + 0 0$3 ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: LD_VAR 0 2
17861: PUSH
17862: LD_INT 105
17864: PLUS
17865: ST_TO_ADDR
// if time > 6 6$00 then
17866: LD_VAR 0 2
17870: PUSH
17871: LD_INT 12600
17873: GREATER
17874: IFFALSE 17884
// time := 0 0$40 ;
17876: LD_ADDR_VAR 0 2
17880: PUSH
17881: LD_INT 1400
17883: ST_TO_ADDR
// until not game ;
17884: LD_EXP 2
17888: NOT
17889: IFFALSE 17761
// end ;
17891: LD_VAR 0 3
17895: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17896: LD_OWVAR 1
17900: PUSH
17901: LD_INT 84000
17903: PUSH
17904: LD_INT 73500
17906: PUSH
17907: LD_INT 63000
17909: PUSH
17910: LD_INT 52500
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: LIST
17917: LIST
17918: PUSH
17919: LD_OWVAR 67
17923: ARRAY
17924: LESS
17925: IFFALSE 17952
17927: GO 17929
17929: DISABLE
// begin enable ;
17930: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17931: LD_INT 1
17933: PPUSH
17934: LD_INT 5
17936: PPUSH
17937: CALL_OW 12
17941: PPUSH
17942: LD_INT 7
17944: PPUSH
17945: LD_INT 1
17947: PPUSH
17948: CALL_OW 55
// end ; end_of_file
17952: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17953: LD_INT 0
17955: PPUSH
17956: PPUSH
// skirmish := false ;
17957: LD_ADDR_EXP 48
17961: PUSH
17962: LD_INT 0
17964: ST_TO_ADDR
// debug_mc := false ;
17965: LD_ADDR_EXP 49
17969: PUSH
17970: LD_INT 0
17972: ST_TO_ADDR
// mc_bases := [ ] ;
17973: LD_ADDR_EXP 50
17977: PUSH
17978: EMPTY
17979: ST_TO_ADDR
// mc_sides := [ ] ;
17980: LD_ADDR_EXP 76
17984: PUSH
17985: EMPTY
17986: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17987: LD_ADDR_EXP 51
17991: PUSH
17992: EMPTY
17993: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17994: LD_ADDR_EXP 52
17998: PUSH
17999: EMPTY
18000: ST_TO_ADDR
// mc_need_heal := [ ] ;
18001: LD_ADDR_EXP 53
18005: PUSH
18006: EMPTY
18007: ST_TO_ADDR
// mc_healers := [ ] ;
18008: LD_ADDR_EXP 54
18012: PUSH
18013: EMPTY
18014: ST_TO_ADDR
// mc_build_list := [ ] ;
18015: LD_ADDR_EXP 55
18019: PUSH
18020: EMPTY
18021: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18022: LD_ADDR_EXP 82
18026: PUSH
18027: EMPTY
18028: ST_TO_ADDR
// mc_builders := [ ] ;
18029: LD_ADDR_EXP 56
18033: PUSH
18034: EMPTY
18035: ST_TO_ADDR
// mc_construct_list := [ ] ;
18036: LD_ADDR_EXP 57
18040: PUSH
18041: EMPTY
18042: ST_TO_ADDR
// mc_turret_list := [ ] ;
18043: LD_ADDR_EXP 58
18047: PUSH
18048: EMPTY
18049: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18050: LD_ADDR_EXP 59
18054: PUSH
18055: EMPTY
18056: ST_TO_ADDR
// mc_miners := [ ] ;
18057: LD_ADDR_EXP 64
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// mc_mines := [ ] ;
18064: LD_ADDR_EXP 63
18068: PUSH
18069: EMPTY
18070: ST_TO_ADDR
// mc_minefields := [ ] ;
18071: LD_ADDR_EXP 65
18075: PUSH
18076: EMPTY
18077: ST_TO_ADDR
// mc_crates := [ ] ;
18078: LD_ADDR_EXP 66
18082: PUSH
18083: EMPTY
18084: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18085: LD_ADDR_EXP 67
18089: PUSH
18090: EMPTY
18091: ST_TO_ADDR
// mc_crates_area := [ ] ;
18092: LD_ADDR_EXP 68
18096: PUSH
18097: EMPTY
18098: ST_TO_ADDR
// mc_vehicles := [ ] ;
18099: LD_ADDR_EXP 69
18103: PUSH
18104: EMPTY
18105: ST_TO_ADDR
// mc_attack := [ ] ;
18106: LD_ADDR_EXP 70
18110: PUSH
18111: EMPTY
18112: ST_TO_ADDR
// mc_produce := [ ] ;
18113: LD_ADDR_EXP 71
18117: PUSH
18118: EMPTY
18119: ST_TO_ADDR
// mc_defender := [ ] ;
18120: LD_ADDR_EXP 72
18124: PUSH
18125: EMPTY
18126: ST_TO_ADDR
// mc_parking := [ ] ;
18127: LD_ADDR_EXP 74
18131: PUSH
18132: EMPTY
18133: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18134: LD_ADDR_EXP 60
18138: PUSH
18139: EMPTY
18140: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18141: LD_ADDR_EXP 62
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// mc_scan := [ ] ;
18148: LD_ADDR_EXP 73
18152: PUSH
18153: EMPTY
18154: ST_TO_ADDR
// mc_scan_area := [ ] ;
18155: LD_ADDR_EXP 75
18159: PUSH
18160: EMPTY
18161: ST_TO_ADDR
// mc_tech := [ ] ;
18162: LD_ADDR_EXP 77
18166: PUSH
18167: EMPTY
18168: ST_TO_ADDR
// mc_class := [ ] ;
18169: LD_ADDR_EXP 91
18173: PUSH
18174: EMPTY
18175: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18176: LD_ADDR_EXP 92
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// mc_is_defending := [ ] ;
18183: LD_ADDR_EXP 93
18187: PUSH
18188: EMPTY
18189: ST_TO_ADDR
// end ;
18190: LD_VAR 0 1
18194: RET
// export function MC_Kill ( base ) ; begin
18195: LD_INT 0
18197: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: EMPTY
18214: PPUSH
18215: CALL_OW 1
18219: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18220: LD_ADDR_EXP 51
18224: PUSH
18225: LD_EXP 51
18229: PPUSH
18230: LD_VAR 0 1
18234: PPUSH
18235: EMPTY
18236: PPUSH
18237: CALL_OW 1
18241: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18242: LD_ADDR_EXP 52
18246: PUSH
18247: LD_EXP 52
18251: PPUSH
18252: LD_VAR 0 1
18256: PPUSH
18257: EMPTY
18258: PPUSH
18259: CALL_OW 1
18263: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18264: LD_ADDR_EXP 53
18268: PUSH
18269: LD_EXP 53
18273: PPUSH
18274: LD_VAR 0 1
18278: PPUSH
18279: EMPTY
18280: PPUSH
18281: CALL_OW 1
18285: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18286: LD_ADDR_EXP 54
18290: PUSH
18291: LD_EXP 54
18295: PPUSH
18296: LD_VAR 0 1
18300: PPUSH
18301: EMPTY
18302: PPUSH
18303: CALL_OW 1
18307: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18308: LD_ADDR_EXP 55
18312: PUSH
18313: LD_EXP 55
18317: PPUSH
18318: LD_VAR 0 1
18322: PPUSH
18323: EMPTY
18324: PPUSH
18325: CALL_OW 1
18329: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18330: LD_ADDR_EXP 56
18334: PUSH
18335: LD_EXP 56
18339: PPUSH
18340: LD_VAR 0 1
18344: PPUSH
18345: EMPTY
18346: PPUSH
18347: CALL_OW 1
18351: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18352: LD_ADDR_EXP 57
18356: PUSH
18357: LD_EXP 57
18361: PPUSH
18362: LD_VAR 0 1
18366: PPUSH
18367: EMPTY
18368: PPUSH
18369: CALL_OW 1
18373: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18374: LD_ADDR_EXP 58
18378: PUSH
18379: LD_EXP 58
18383: PPUSH
18384: LD_VAR 0 1
18388: PPUSH
18389: EMPTY
18390: PPUSH
18391: CALL_OW 1
18395: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18396: LD_ADDR_EXP 59
18400: PUSH
18401: LD_EXP 59
18405: PPUSH
18406: LD_VAR 0 1
18410: PPUSH
18411: EMPTY
18412: PPUSH
18413: CALL_OW 1
18417: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18418: LD_ADDR_EXP 60
18422: PUSH
18423: LD_EXP 60
18427: PPUSH
18428: LD_VAR 0 1
18432: PPUSH
18433: EMPTY
18434: PPUSH
18435: CALL_OW 1
18439: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18440: LD_ADDR_EXP 61
18444: PUSH
18445: LD_EXP 61
18449: PPUSH
18450: LD_VAR 0 1
18454: PPUSH
18455: LD_INT 0
18457: PPUSH
18458: CALL_OW 1
18462: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18463: LD_ADDR_EXP 62
18467: PUSH
18468: LD_EXP 62
18472: PPUSH
18473: LD_VAR 0 1
18477: PPUSH
18478: EMPTY
18479: PPUSH
18480: CALL_OW 1
18484: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18485: LD_ADDR_EXP 63
18489: PUSH
18490: LD_EXP 63
18494: PPUSH
18495: LD_VAR 0 1
18499: PPUSH
18500: EMPTY
18501: PPUSH
18502: CALL_OW 1
18506: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18507: LD_ADDR_EXP 64
18511: PUSH
18512: LD_EXP 64
18516: PPUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: EMPTY
18523: PPUSH
18524: CALL_OW 1
18528: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18529: LD_ADDR_EXP 65
18533: PUSH
18534: LD_EXP 65
18538: PPUSH
18539: LD_VAR 0 1
18543: PPUSH
18544: EMPTY
18545: PPUSH
18546: CALL_OW 1
18550: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18551: LD_ADDR_EXP 66
18555: PUSH
18556: LD_EXP 66
18560: PPUSH
18561: LD_VAR 0 1
18565: PPUSH
18566: EMPTY
18567: PPUSH
18568: CALL_OW 1
18572: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18573: LD_ADDR_EXP 67
18577: PUSH
18578: LD_EXP 67
18582: PPUSH
18583: LD_VAR 0 1
18587: PPUSH
18588: EMPTY
18589: PPUSH
18590: CALL_OW 1
18594: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18595: LD_ADDR_EXP 68
18599: PUSH
18600: LD_EXP 68
18604: PPUSH
18605: LD_VAR 0 1
18609: PPUSH
18610: EMPTY
18611: PPUSH
18612: CALL_OW 1
18616: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18617: LD_ADDR_EXP 69
18621: PUSH
18622: LD_EXP 69
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: EMPTY
18633: PPUSH
18634: CALL_OW 1
18638: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18639: LD_ADDR_EXP 70
18643: PUSH
18644: LD_EXP 70
18648: PPUSH
18649: LD_VAR 0 1
18653: PPUSH
18654: EMPTY
18655: PPUSH
18656: CALL_OW 1
18660: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18661: LD_ADDR_EXP 71
18665: PUSH
18666: LD_EXP 71
18670: PPUSH
18671: LD_VAR 0 1
18675: PPUSH
18676: EMPTY
18677: PPUSH
18678: CALL_OW 1
18682: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18683: LD_ADDR_EXP 72
18687: PUSH
18688: LD_EXP 72
18692: PPUSH
18693: LD_VAR 0 1
18697: PPUSH
18698: EMPTY
18699: PPUSH
18700: CALL_OW 1
18704: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18705: LD_ADDR_EXP 73
18709: PUSH
18710: LD_EXP 73
18714: PPUSH
18715: LD_VAR 0 1
18719: PPUSH
18720: EMPTY
18721: PPUSH
18722: CALL_OW 1
18726: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18727: LD_ADDR_EXP 74
18731: PUSH
18732: LD_EXP 74
18736: PPUSH
18737: LD_VAR 0 1
18741: PPUSH
18742: EMPTY
18743: PPUSH
18744: CALL_OW 1
18748: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18749: LD_ADDR_EXP 75
18753: PUSH
18754: LD_EXP 75
18758: PPUSH
18759: LD_VAR 0 1
18763: PPUSH
18764: EMPTY
18765: PPUSH
18766: CALL_OW 1
18770: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18771: LD_ADDR_EXP 77
18775: PUSH
18776: LD_EXP 77
18780: PPUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: EMPTY
18787: PPUSH
18788: CALL_OW 1
18792: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18793: LD_ADDR_EXP 79
18797: PUSH
18798: LD_EXP 79
18802: PPUSH
18803: LD_VAR 0 1
18807: PPUSH
18808: EMPTY
18809: PPUSH
18810: CALL_OW 1
18814: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18815: LD_ADDR_EXP 80
18819: PUSH
18820: LD_EXP 80
18824: PPUSH
18825: LD_VAR 0 1
18829: PPUSH
18830: EMPTY
18831: PPUSH
18832: CALL_OW 1
18836: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18837: LD_ADDR_EXP 81
18841: PUSH
18842: LD_EXP 81
18846: PPUSH
18847: LD_VAR 0 1
18851: PPUSH
18852: EMPTY
18853: PPUSH
18854: CALL_OW 1
18858: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18859: LD_ADDR_EXP 82
18863: PUSH
18864: LD_EXP 82
18868: PPUSH
18869: LD_VAR 0 1
18873: PPUSH
18874: EMPTY
18875: PPUSH
18876: CALL_OW 1
18880: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18881: LD_ADDR_EXP 83
18885: PUSH
18886: LD_EXP 83
18890: PPUSH
18891: LD_VAR 0 1
18895: PPUSH
18896: EMPTY
18897: PPUSH
18898: CALL_OW 1
18902: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18903: LD_ADDR_EXP 84
18907: PUSH
18908: LD_EXP 84
18912: PPUSH
18913: LD_VAR 0 1
18917: PPUSH
18918: EMPTY
18919: PPUSH
18920: CALL_OW 1
18924: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18925: LD_ADDR_EXP 85
18929: PUSH
18930: LD_EXP 85
18934: PPUSH
18935: LD_VAR 0 1
18939: PPUSH
18940: EMPTY
18941: PPUSH
18942: CALL_OW 1
18946: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18947: LD_ADDR_EXP 86
18951: PUSH
18952: LD_EXP 86
18956: PPUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: EMPTY
18963: PPUSH
18964: CALL_OW 1
18968: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18969: LD_ADDR_EXP 87
18973: PUSH
18974: LD_EXP 87
18978: PPUSH
18979: LD_VAR 0 1
18983: PPUSH
18984: EMPTY
18985: PPUSH
18986: CALL_OW 1
18990: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18991: LD_ADDR_EXP 88
18995: PUSH
18996: LD_EXP 88
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: EMPTY
19007: PPUSH
19008: CALL_OW 1
19012: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19013: LD_ADDR_EXP 89
19017: PUSH
19018: LD_EXP 89
19022: PPUSH
19023: LD_VAR 0 1
19027: PPUSH
19028: EMPTY
19029: PPUSH
19030: CALL_OW 1
19034: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19035: LD_ADDR_EXP 90
19039: PUSH
19040: LD_EXP 90
19044: PPUSH
19045: LD_VAR 0 1
19049: PPUSH
19050: EMPTY
19051: PPUSH
19052: CALL_OW 1
19056: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19057: LD_ADDR_EXP 91
19061: PUSH
19062: LD_EXP 91
19066: PPUSH
19067: LD_VAR 0 1
19071: PPUSH
19072: EMPTY
19073: PPUSH
19074: CALL_OW 1
19078: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19079: LD_ADDR_EXP 92
19083: PUSH
19084: LD_EXP 92
19088: PPUSH
19089: LD_VAR 0 1
19093: PPUSH
19094: LD_INT 0
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19102: LD_ADDR_EXP 93
19106: PUSH
19107: LD_EXP 93
19111: PPUSH
19112: LD_VAR 0 1
19116: PPUSH
19117: LD_INT 0
19119: PPUSH
19120: CALL_OW 1
19124: ST_TO_ADDR
// end ;
19125: LD_VAR 0 2
19129: RET
// export function MC_Add ( side , units ) ; var base ; begin
19130: LD_INT 0
19132: PPUSH
19133: PPUSH
// base := mc_bases + 1 ;
19134: LD_ADDR_VAR 0 4
19138: PUSH
19139: LD_EXP 50
19143: PUSH
19144: LD_INT 1
19146: PLUS
19147: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19148: LD_ADDR_EXP 76
19152: PUSH
19153: LD_EXP 76
19157: PPUSH
19158: LD_VAR 0 4
19162: PPUSH
19163: LD_VAR 0 1
19167: PPUSH
19168: CALL_OW 1
19172: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19173: LD_ADDR_EXP 50
19177: PUSH
19178: LD_EXP 50
19182: PPUSH
19183: LD_VAR 0 4
19187: PPUSH
19188: LD_VAR 0 2
19192: PPUSH
19193: CALL_OW 1
19197: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19198: LD_ADDR_EXP 51
19202: PUSH
19203: LD_EXP 51
19207: PPUSH
19208: LD_VAR 0 4
19212: PPUSH
19213: EMPTY
19214: PPUSH
19215: CALL_OW 1
19219: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19220: LD_ADDR_EXP 52
19224: PUSH
19225: LD_EXP 52
19229: PPUSH
19230: LD_VAR 0 4
19234: PPUSH
19235: EMPTY
19236: PPUSH
19237: CALL_OW 1
19241: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19242: LD_ADDR_EXP 53
19246: PUSH
19247: LD_EXP 53
19251: PPUSH
19252: LD_VAR 0 4
19256: PPUSH
19257: EMPTY
19258: PPUSH
19259: CALL_OW 1
19263: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19264: LD_ADDR_EXP 54
19268: PUSH
19269: LD_EXP 54
19273: PPUSH
19274: LD_VAR 0 4
19278: PPUSH
19279: EMPTY
19280: PPUSH
19281: CALL_OW 1
19285: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19286: LD_ADDR_EXP 55
19290: PUSH
19291: LD_EXP 55
19295: PPUSH
19296: LD_VAR 0 4
19300: PPUSH
19301: EMPTY
19302: PPUSH
19303: CALL_OW 1
19307: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19308: LD_ADDR_EXP 56
19312: PUSH
19313: LD_EXP 56
19317: PPUSH
19318: LD_VAR 0 4
19322: PPUSH
19323: EMPTY
19324: PPUSH
19325: CALL_OW 1
19329: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19330: LD_ADDR_EXP 57
19334: PUSH
19335: LD_EXP 57
19339: PPUSH
19340: LD_VAR 0 4
19344: PPUSH
19345: EMPTY
19346: PPUSH
19347: CALL_OW 1
19351: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19352: LD_ADDR_EXP 58
19356: PUSH
19357: LD_EXP 58
19361: PPUSH
19362: LD_VAR 0 4
19366: PPUSH
19367: EMPTY
19368: PPUSH
19369: CALL_OW 1
19373: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19374: LD_ADDR_EXP 59
19378: PUSH
19379: LD_EXP 59
19383: PPUSH
19384: LD_VAR 0 4
19388: PPUSH
19389: EMPTY
19390: PPUSH
19391: CALL_OW 1
19395: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19396: LD_ADDR_EXP 60
19400: PUSH
19401: LD_EXP 60
19405: PPUSH
19406: LD_VAR 0 4
19410: PPUSH
19411: EMPTY
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19418: LD_ADDR_EXP 61
19422: PUSH
19423: LD_EXP 61
19427: PPUSH
19428: LD_VAR 0 4
19432: PPUSH
19433: LD_INT 0
19435: PPUSH
19436: CALL_OW 1
19440: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19441: LD_ADDR_EXP 62
19445: PUSH
19446: LD_EXP 62
19450: PPUSH
19451: LD_VAR 0 4
19455: PPUSH
19456: EMPTY
19457: PPUSH
19458: CALL_OW 1
19462: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19463: LD_ADDR_EXP 63
19467: PUSH
19468: LD_EXP 63
19472: PPUSH
19473: LD_VAR 0 4
19477: PPUSH
19478: EMPTY
19479: PPUSH
19480: CALL_OW 1
19484: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19485: LD_ADDR_EXP 64
19489: PUSH
19490: LD_EXP 64
19494: PPUSH
19495: LD_VAR 0 4
19499: PPUSH
19500: EMPTY
19501: PPUSH
19502: CALL_OW 1
19506: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19507: LD_ADDR_EXP 65
19511: PUSH
19512: LD_EXP 65
19516: PPUSH
19517: LD_VAR 0 4
19521: PPUSH
19522: EMPTY
19523: PPUSH
19524: CALL_OW 1
19528: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19529: LD_ADDR_EXP 66
19533: PUSH
19534: LD_EXP 66
19538: PPUSH
19539: LD_VAR 0 4
19543: PPUSH
19544: EMPTY
19545: PPUSH
19546: CALL_OW 1
19550: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19551: LD_ADDR_EXP 67
19555: PUSH
19556: LD_EXP 67
19560: PPUSH
19561: LD_VAR 0 4
19565: PPUSH
19566: EMPTY
19567: PPUSH
19568: CALL_OW 1
19572: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19573: LD_ADDR_EXP 68
19577: PUSH
19578: LD_EXP 68
19582: PPUSH
19583: LD_VAR 0 4
19587: PPUSH
19588: EMPTY
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19595: LD_ADDR_EXP 69
19599: PUSH
19600: LD_EXP 69
19604: PPUSH
19605: LD_VAR 0 4
19609: PPUSH
19610: EMPTY
19611: PPUSH
19612: CALL_OW 1
19616: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19617: LD_ADDR_EXP 70
19621: PUSH
19622: LD_EXP 70
19626: PPUSH
19627: LD_VAR 0 4
19631: PPUSH
19632: EMPTY
19633: PPUSH
19634: CALL_OW 1
19638: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19639: LD_ADDR_EXP 71
19643: PUSH
19644: LD_EXP 71
19648: PPUSH
19649: LD_VAR 0 4
19653: PPUSH
19654: EMPTY
19655: PPUSH
19656: CALL_OW 1
19660: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19661: LD_ADDR_EXP 72
19665: PUSH
19666: LD_EXP 72
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: EMPTY
19677: PPUSH
19678: CALL_OW 1
19682: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19683: LD_ADDR_EXP 73
19687: PUSH
19688: LD_EXP 73
19692: PPUSH
19693: LD_VAR 0 4
19697: PPUSH
19698: EMPTY
19699: PPUSH
19700: CALL_OW 1
19704: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19705: LD_ADDR_EXP 74
19709: PUSH
19710: LD_EXP 74
19714: PPUSH
19715: LD_VAR 0 4
19719: PPUSH
19720: EMPTY
19721: PPUSH
19722: CALL_OW 1
19726: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19727: LD_ADDR_EXP 75
19731: PUSH
19732: LD_EXP 75
19736: PPUSH
19737: LD_VAR 0 4
19741: PPUSH
19742: EMPTY
19743: PPUSH
19744: CALL_OW 1
19748: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19749: LD_ADDR_EXP 77
19753: PUSH
19754: LD_EXP 77
19758: PPUSH
19759: LD_VAR 0 4
19763: PPUSH
19764: EMPTY
19765: PPUSH
19766: CALL_OW 1
19770: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19771: LD_ADDR_EXP 79
19775: PUSH
19776: LD_EXP 79
19780: PPUSH
19781: LD_VAR 0 4
19785: PPUSH
19786: EMPTY
19787: PPUSH
19788: CALL_OW 1
19792: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19793: LD_ADDR_EXP 80
19797: PUSH
19798: LD_EXP 80
19802: PPUSH
19803: LD_VAR 0 4
19807: PPUSH
19808: EMPTY
19809: PPUSH
19810: CALL_OW 1
19814: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19815: LD_ADDR_EXP 81
19819: PUSH
19820: LD_EXP 81
19824: PPUSH
19825: LD_VAR 0 4
19829: PPUSH
19830: EMPTY
19831: PPUSH
19832: CALL_OW 1
19836: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19837: LD_ADDR_EXP 82
19841: PUSH
19842: LD_EXP 82
19846: PPUSH
19847: LD_VAR 0 4
19851: PPUSH
19852: EMPTY
19853: PPUSH
19854: CALL_OW 1
19858: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19859: LD_ADDR_EXP 83
19863: PUSH
19864: LD_EXP 83
19868: PPUSH
19869: LD_VAR 0 4
19873: PPUSH
19874: EMPTY
19875: PPUSH
19876: CALL_OW 1
19880: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19881: LD_ADDR_EXP 84
19885: PUSH
19886: LD_EXP 84
19890: PPUSH
19891: LD_VAR 0 4
19895: PPUSH
19896: EMPTY
19897: PPUSH
19898: CALL_OW 1
19902: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19903: LD_ADDR_EXP 85
19907: PUSH
19908: LD_EXP 85
19912: PPUSH
19913: LD_VAR 0 4
19917: PPUSH
19918: EMPTY
19919: PPUSH
19920: CALL_OW 1
19924: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19925: LD_ADDR_EXP 86
19929: PUSH
19930: LD_EXP 86
19934: PPUSH
19935: LD_VAR 0 4
19939: PPUSH
19940: EMPTY
19941: PPUSH
19942: CALL_OW 1
19946: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19947: LD_ADDR_EXP 87
19951: PUSH
19952: LD_EXP 87
19956: PPUSH
19957: LD_VAR 0 4
19961: PPUSH
19962: EMPTY
19963: PPUSH
19964: CALL_OW 1
19968: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19969: LD_ADDR_EXP 88
19973: PUSH
19974: LD_EXP 88
19978: PPUSH
19979: LD_VAR 0 4
19983: PPUSH
19984: EMPTY
19985: PPUSH
19986: CALL_OW 1
19990: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19991: LD_ADDR_EXP 89
19995: PUSH
19996: LD_EXP 89
20000: PPUSH
20001: LD_VAR 0 4
20005: PPUSH
20006: EMPTY
20007: PPUSH
20008: CALL_OW 1
20012: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20013: LD_ADDR_EXP 90
20017: PUSH
20018: LD_EXP 90
20022: PPUSH
20023: LD_VAR 0 4
20027: PPUSH
20028: EMPTY
20029: PPUSH
20030: CALL_OW 1
20034: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20035: LD_ADDR_EXP 91
20039: PUSH
20040: LD_EXP 91
20044: PPUSH
20045: LD_VAR 0 4
20049: PPUSH
20050: EMPTY
20051: PPUSH
20052: CALL_OW 1
20056: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20057: LD_ADDR_EXP 92
20061: PUSH
20062: LD_EXP 92
20066: PPUSH
20067: LD_VAR 0 4
20071: PPUSH
20072: LD_INT 0
20074: PPUSH
20075: CALL_OW 1
20079: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20080: LD_ADDR_EXP 93
20084: PUSH
20085: LD_EXP 93
20089: PPUSH
20090: LD_VAR 0 4
20094: PPUSH
20095: LD_INT 0
20097: PPUSH
20098: CALL_OW 1
20102: ST_TO_ADDR
// result := base ;
20103: LD_ADDR_VAR 0 3
20107: PUSH
20108: LD_VAR 0 4
20112: ST_TO_ADDR
// end ;
20113: LD_VAR 0 3
20117: RET
// export function MC_Start ( ) ; var i ; begin
20118: LD_INT 0
20120: PPUSH
20121: PPUSH
// for i = 1 to mc_bases do
20122: LD_ADDR_VAR 0 2
20126: PUSH
20127: DOUBLE
20128: LD_INT 1
20130: DEC
20131: ST_TO_ADDR
20132: LD_EXP 50
20136: PUSH
20137: FOR_TO
20138: IFFALSE 21238
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20140: LD_ADDR_EXP 50
20144: PUSH
20145: LD_EXP 50
20149: PPUSH
20150: LD_VAR 0 2
20154: PPUSH
20155: LD_EXP 50
20159: PUSH
20160: LD_VAR 0 2
20164: ARRAY
20165: PUSH
20166: LD_INT 0
20168: DIFF
20169: PPUSH
20170: CALL_OW 1
20174: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20175: LD_ADDR_EXP 51
20179: PUSH
20180: LD_EXP 51
20184: PPUSH
20185: LD_VAR 0 2
20189: PPUSH
20190: EMPTY
20191: PPUSH
20192: CALL_OW 1
20196: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20197: LD_ADDR_EXP 52
20201: PUSH
20202: LD_EXP 52
20206: PPUSH
20207: LD_VAR 0 2
20211: PPUSH
20212: EMPTY
20213: PPUSH
20214: CALL_OW 1
20218: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20219: LD_ADDR_EXP 53
20223: PUSH
20224: LD_EXP 53
20228: PPUSH
20229: LD_VAR 0 2
20233: PPUSH
20234: EMPTY
20235: PPUSH
20236: CALL_OW 1
20240: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20241: LD_ADDR_EXP 54
20245: PUSH
20246: LD_EXP 54
20250: PPUSH
20251: LD_VAR 0 2
20255: PPUSH
20256: EMPTY
20257: PUSH
20258: EMPTY
20259: PUSH
20260: EMPTY
20261: LIST
20262: LIST
20263: PPUSH
20264: CALL_OW 1
20268: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20269: LD_ADDR_EXP 55
20273: PUSH
20274: LD_EXP 55
20278: PPUSH
20279: LD_VAR 0 2
20283: PPUSH
20284: EMPTY
20285: PPUSH
20286: CALL_OW 1
20290: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20291: LD_ADDR_EXP 82
20295: PUSH
20296: LD_EXP 82
20300: PPUSH
20301: LD_VAR 0 2
20305: PPUSH
20306: EMPTY
20307: PPUSH
20308: CALL_OW 1
20312: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20313: LD_ADDR_EXP 56
20317: PUSH
20318: LD_EXP 56
20322: PPUSH
20323: LD_VAR 0 2
20327: PPUSH
20328: EMPTY
20329: PPUSH
20330: CALL_OW 1
20334: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20335: LD_ADDR_EXP 57
20339: PUSH
20340: LD_EXP 57
20344: PPUSH
20345: LD_VAR 0 2
20349: PPUSH
20350: EMPTY
20351: PPUSH
20352: CALL_OW 1
20356: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20357: LD_ADDR_EXP 58
20361: PUSH
20362: LD_EXP 58
20366: PPUSH
20367: LD_VAR 0 2
20371: PPUSH
20372: LD_EXP 50
20376: PUSH
20377: LD_VAR 0 2
20381: ARRAY
20382: PPUSH
20383: LD_INT 2
20385: PUSH
20386: LD_INT 30
20388: PUSH
20389: LD_INT 32
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 30
20398: PUSH
20399: LD_INT 33
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: LIST
20410: PPUSH
20411: CALL_OW 72
20415: PPUSH
20416: CALL_OW 1
20420: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20421: LD_ADDR_EXP 59
20425: PUSH
20426: LD_EXP 59
20430: PPUSH
20431: LD_VAR 0 2
20435: PPUSH
20436: LD_EXP 50
20440: PUSH
20441: LD_VAR 0 2
20445: ARRAY
20446: PPUSH
20447: LD_INT 2
20449: PUSH
20450: LD_INT 30
20452: PUSH
20453: LD_INT 32
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PUSH
20460: LD_INT 30
20462: PUSH
20463: LD_INT 31
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: LIST
20474: PUSH
20475: LD_INT 58
20477: PUSH
20478: EMPTY
20479: LIST
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PPUSH
20485: CALL_OW 72
20489: PPUSH
20490: CALL_OW 1
20494: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20495: LD_ADDR_EXP 60
20499: PUSH
20500: LD_EXP 60
20504: PPUSH
20505: LD_VAR 0 2
20509: PPUSH
20510: EMPTY
20511: PPUSH
20512: CALL_OW 1
20516: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20517: LD_ADDR_EXP 64
20521: PUSH
20522: LD_EXP 64
20526: PPUSH
20527: LD_VAR 0 2
20531: PPUSH
20532: EMPTY
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20539: LD_ADDR_EXP 63
20543: PUSH
20544: LD_EXP 63
20548: PPUSH
20549: LD_VAR 0 2
20553: PPUSH
20554: EMPTY
20555: PPUSH
20556: CALL_OW 1
20560: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20561: LD_ADDR_EXP 65
20565: PUSH
20566: LD_EXP 65
20570: PPUSH
20571: LD_VAR 0 2
20575: PPUSH
20576: EMPTY
20577: PPUSH
20578: CALL_OW 1
20582: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20583: LD_ADDR_EXP 66
20587: PUSH
20588: LD_EXP 66
20592: PPUSH
20593: LD_VAR 0 2
20597: PPUSH
20598: EMPTY
20599: PPUSH
20600: CALL_OW 1
20604: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20605: LD_ADDR_EXP 67
20609: PUSH
20610: LD_EXP 67
20614: PPUSH
20615: LD_VAR 0 2
20619: PPUSH
20620: EMPTY
20621: PPUSH
20622: CALL_OW 1
20626: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20627: LD_ADDR_EXP 68
20631: PUSH
20632: LD_EXP 68
20636: PPUSH
20637: LD_VAR 0 2
20641: PPUSH
20642: EMPTY
20643: PPUSH
20644: CALL_OW 1
20648: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20649: LD_ADDR_EXP 69
20653: PUSH
20654: LD_EXP 69
20658: PPUSH
20659: LD_VAR 0 2
20663: PPUSH
20664: EMPTY
20665: PPUSH
20666: CALL_OW 1
20670: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20671: LD_ADDR_EXP 70
20675: PUSH
20676: LD_EXP 70
20680: PPUSH
20681: LD_VAR 0 2
20685: PPUSH
20686: EMPTY
20687: PPUSH
20688: CALL_OW 1
20692: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20693: LD_ADDR_EXP 71
20697: PUSH
20698: LD_EXP 71
20702: PPUSH
20703: LD_VAR 0 2
20707: PPUSH
20708: EMPTY
20709: PPUSH
20710: CALL_OW 1
20714: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20715: LD_ADDR_EXP 72
20719: PUSH
20720: LD_EXP 72
20724: PPUSH
20725: LD_VAR 0 2
20729: PPUSH
20730: EMPTY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20737: LD_ADDR_EXP 61
20741: PUSH
20742: LD_EXP 61
20746: PPUSH
20747: LD_VAR 0 2
20751: PPUSH
20752: LD_INT 0
20754: PPUSH
20755: CALL_OW 1
20759: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20760: LD_ADDR_EXP 74
20764: PUSH
20765: LD_EXP 74
20769: PPUSH
20770: LD_VAR 0 2
20774: PPUSH
20775: LD_INT 0
20777: PPUSH
20778: CALL_OW 1
20782: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20783: LD_ADDR_EXP 62
20787: PUSH
20788: LD_EXP 62
20792: PPUSH
20793: LD_VAR 0 2
20797: PPUSH
20798: EMPTY
20799: PPUSH
20800: CALL_OW 1
20804: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20805: LD_ADDR_EXP 73
20809: PUSH
20810: LD_EXP 73
20814: PPUSH
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_INT 0
20822: PPUSH
20823: CALL_OW 1
20827: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20828: LD_ADDR_EXP 75
20832: PUSH
20833: LD_EXP 75
20837: PPUSH
20838: LD_VAR 0 2
20842: PPUSH
20843: EMPTY
20844: PPUSH
20845: CALL_OW 1
20849: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20850: LD_ADDR_EXP 78
20854: PUSH
20855: LD_EXP 78
20859: PPUSH
20860: LD_VAR 0 2
20864: PPUSH
20865: LD_INT 0
20867: PPUSH
20868: CALL_OW 1
20872: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20873: LD_ADDR_EXP 79
20877: PUSH
20878: LD_EXP 79
20882: PPUSH
20883: LD_VAR 0 2
20887: PPUSH
20888: EMPTY
20889: PPUSH
20890: CALL_OW 1
20894: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20895: LD_ADDR_EXP 80
20899: PUSH
20900: LD_EXP 80
20904: PPUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: EMPTY
20911: PPUSH
20912: CALL_OW 1
20916: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20917: LD_ADDR_EXP 81
20921: PUSH
20922: LD_EXP 81
20926: PPUSH
20927: LD_VAR 0 2
20931: PPUSH
20932: EMPTY
20933: PPUSH
20934: CALL_OW 1
20938: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20939: LD_ADDR_EXP 83
20943: PUSH
20944: LD_EXP 83
20948: PPUSH
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_EXP 50
20958: PUSH
20959: LD_VAR 0 2
20963: ARRAY
20964: PPUSH
20965: LD_INT 2
20967: PUSH
20968: LD_INT 30
20970: PUSH
20971: LD_INT 6
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: PUSH
20978: LD_INT 30
20980: PUSH
20981: LD_INT 7
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: PUSH
20988: LD_INT 30
20990: PUSH
20991: LD_INT 8
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: PPUSH
21004: CALL_OW 72
21008: PPUSH
21009: CALL_OW 1
21013: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21014: LD_ADDR_EXP 84
21018: PUSH
21019: LD_EXP 84
21023: PPUSH
21024: LD_VAR 0 2
21028: PPUSH
21029: EMPTY
21030: PPUSH
21031: CALL_OW 1
21035: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21036: LD_ADDR_EXP 85
21040: PUSH
21041: LD_EXP 85
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: EMPTY
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21058: LD_ADDR_EXP 86
21062: PUSH
21063: LD_EXP 86
21067: PPUSH
21068: LD_VAR 0 2
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21080: LD_ADDR_EXP 87
21084: PUSH
21085: LD_EXP 87
21089: PPUSH
21090: LD_VAR 0 2
21094: PPUSH
21095: EMPTY
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21102: LD_ADDR_EXP 88
21106: PUSH
21107: LD_EXP 88
21111: PPUSH
21112: LD_VAR 0 2
21116: PPUSH
21117: EMPTY
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21124: LD_ADDR_EXP 89
21128: PUSH
21129: LD_EXP 89
21133: PPUSH
21134: LD_VAR 0 2
21138: PPUSH
21139: EMPTY
21140: PPUSH
21141: CALL_OW 1
21145: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21146: LD_ADDR_EXP 90
21150: PUSH
21151: LD_EXP 90
21155: PPUSH
21156: LD_VAR 0 2
21160: PPUSH
21161: EMPTY
21162: PPUSH
21163: CALL_OW 1
21167: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21168: LD_ADDR_EXP 91
21172: PUSH
21173: LD_EXP 91
21177: PPUSH
21178: LD_VAR 0 2
21182: PPUSH
21183: EMPTY
21184: PPUSH
21185: CALL_OW 1
21189: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21190: LD_ADDR_EXP 92
21194: PUSH
21195: LD_EXP 92
21199: PPUSH
21200: LD_VAR 0 2
21204: PPUSH
21205: LD_INT 0
21207: PPUSH
21208: CALL_OW 1
21212: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21213: LD_ADDR_EXP 93
21217: PUSH
21218: LD_EXP 93
21222: PPUSH
21223: LD_VAR 0 2
21227: PPUSH
21228: LD_INT 0
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: GO 20137
21238: POP
21239: POP
// MC_InitSides ( ) ;
21240: CALL 21526 0 0
// MC_InitResearch ( ) ;
21244: CALL 21265 0 0
// CustomInitMacro ( ) ;
21248: CALL 308 0 0
// skirmish := true ;
21252: LD_ADDR_EXP 48
21256: PUSH
21257: LD_INT 1
21259: ST_TO_ADDR
// end ;
21260: LD_VAR 0 1
21264: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21265: LD_INT 0
21267: PPUSH
21268: PPUSH
21269: PPUSH
21270: PPUSH
21271: PPUSH
21272: PPUSH
// if not mc_bases then
21273: LD_EXP 50
21277: NOT
21278: IFFALSE 21282
// exit ;
21280: GO 21521
// for i = 1 to 8 do
21282: LD_ADDR_VAR 0 2
21286: PUSH
21287: DOUBLE
21288: LD_INT 1
21290: DEC
21291: ST_TO_ADDR
21292: LD_INT 8
21294: PUSH
21295: FOR_TO
21296: IFFALSE 21322
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21298: LD_ADDR_EXP 77
21302: PUSH
21303: LD_EXP 77
21307: PPUSH
21308: LD_VAR 0 2
21312: PPUSH
21313: EMPTY
21314: PPUSH
21315: CALL_OW 1
21319: ST_TO_ADDR
21320: GO 21295
21322: POP
21323: POP
// tmp := [ ] ;
21324: LD_ADDR_VAR 0 5
21328: PUSH
21329: EMPTY
21330: ST_TO_ADDR
// for i = 1 to mc_sides do
21331: LD_ADDR_VAR 0 2
21335: PUSH
21336: DOUBLE
21337: LD_INT 1
21339: DEC
21340: ST_TO_ADDR
21341: LD_EXP 76
21345: PUSH
21346: FOR_TO
21347: IFFALSE 21405
// if not mc_sides [ i ] in tmp then
21349: LD_EXP 76
21353: PUSH
21354: LD_VAR 0 2
21358: ARRAY
21359: PUSH
21360: LD_VAR 0 5
21364: IN
21365: NOT
21366: IFFALSE 21403
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21368: LD_ADDR_VAR 0 5
21372: PUSH
21373: LD_VAR 0 5
21377: PPUSH
21378: LD_VAR 0 5
21382: PUSH
21383: LD_INT 1
21385: PLUS
21386: PPUSH
21387: LD_EXP 76
21391: PUSH
21392: LD_VAR 0 2
21396: ARRAY
21397: PPUSH
21398: CALL_OW 2
21402: ST_TO_ADDR
21403: GO 21346
21405: POP
21406: POP
// if not tmp then
21407: LD_VAR 0 5
21411: NOT
21412: IFFALSE 21416
// exit ;
21414: GO 21521
// for j in tmp do
21416: LD_ADDR_VAR 0 3
21420: PUSH
21421: LD_VAR 0 5
21425: PUSH
21426: FOR_IN
21427: IFFALSE 21519
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21429: LD_ADDR_VAR 0 6
21433: PUSH
21434: LD_INT 22
21436: PUSH
21437: LD_VAR 0 3
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: PPUSH
21446: CALL_OW 69
21450: ST_TO_ADDR
// if not un then
21451: LD_VAR 0 6
21455: NOT
21456: IFFALSE 21460
// continue ;
21458: GO 21426
// nation := GetNation ( un [ 1 ] ) ;
21460: LD_ADDR_VAR 0 4
21464: PUSH
21465: LD_VAR 0 6
21469: PUSH
21470: LD_INT 1
21472: ARRAY
21473: PPUSH
21474: CALL_OW 248
21478: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21479: LD_ADDR_EXP 77
21483: PUSH
21484: LD_EXP 77
21488: PPUSH
21489: LD_VAR 0 3
21493: PPUSH
21494: LD_VAR 0 3
21498: PPUSH
21499: LD_VAR 0 4
21503: PPUSH
21504: LD_INT 1
21506: PPUSH
21507: CALL 48642 0 3
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// end ;
21517: GO 21426
21519: POP
21520: POP
// end ;
21521: LD_VAR 0 1
21525: RET
// export function MC_InitSides ( ) ; var i ; begin
21526: LD_INT 0
21528: PPUSH
21529: PPUSH
// if not mc_bases then
21530: LD_EXP 50
21534: NOT
21535: IFFALSE 21539
// exit ;
21537: GO 21613
// for i = 1 to mc_bases do
21539: LD_ADDR_VAR 0 2
21543: PUSH
21544: DOUBLE
21545: LD_INT 1
21547: DEC
21548: ST_TO_ADDR
21549: LD_EXP 50
21553: PUSH
21554: FOR_TO
21555: IFFALSE 21611
// if mc_bases [ i ] then
21557: LD_EXP 50
21561: PUSH
21562: LD_VAR 0 2
21566: ARRAY
21567: IFFALSE 21609
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21569: LD_ADDR_EXP 76
21573: PUSH
21574: LD_EXP 76
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: LD_EXP 50
21588: PUSH
21589: LD_VAR 0 2
21593: ARRAY
21594: PUSH
21595: LD_INT 1
21597: ARRAY
21598: PPUSH
21599: CALL_OW 255
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
21609: GO 21554
21611: POP
21612: POP
// end ;
21613: LD_VAR 0 1
21617: RET
// every 0 0$03 trigger skirmish do
21618: LD_EXP 48
21622: IFFALSE 21776
21624: GO 21626
21626: DISABLE
// begin enable ;
21627: ENABLE
// MC_CheckBuildings ( ) ;
21628: CALL 26274 0 0
// MC_CheckPeopleLife ( ) ;
21632: CALL 26435 0 0
// RaiseSailEvent ( 100 ) ;
21636: LD_INT 100
21638: PPUSH
21639: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21643: LD_INT 103
21645: PPUSH
21646: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21650: LD_INT 104
21652: PPUSH
21653: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21657: LD_INT 105
21659: PPUSH
21660: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21664: LD_INT 106
21666: PPUSH
21667: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21671: LD_INT 107
21673: PPUSH
21674: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21678: LD_INT 108
21680: PPUSH
21681: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21685: LD_INT 109
21687: PPUSH
21688: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21692: LD_INT 110
21694: PPUSH
21695: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21699: LD_INT 111
21701: PPUSH
21702: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21706: LD_INT 112
21708: PPUSH
21709: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21713: LD_INT 113
21715: PPUSH
21716: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21720: LD_INT 120
21722: PPUSH
21723: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21727: LD_INT 121
21729: PPUSH
21730: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21734: LD_INT 122
21736: PPUSH
21737: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21741: LD_INT 123
21743: PPUSH
21744: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21748: LD_INT 124
21750: PPUSH
21751: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21755: LD_INT 125
21757: PPUSH
21758: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21762: LD_INT 126
21764: PPUSH
21765: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21769: LD_INT 200
21771: PPUSH
21772: CALL_OW 427
// end ;
21776: END
// on SailEvent ( event ) do begin if event < 100 then
21777: LD_VAR 0 1
21781: PUSH
21782: LD_INT 100
21784: LESS
21785: IFFALSE 21796
// CustomEvent ( event ) ;
21787: LD_VAR 0 1
21791: PPUSH
21792: CALL 17139 0 1
// if event = 100 then
21796: LD_VAR 0 1
21800: PUSH
21801: LD_INT 100
21803: EQUAL
21804: IFFALSE 21810
// MC_ClassManager ( ) ;
21806: CALL 22202 0 0
// if event = 101 then
21810: LD_VAR 0 1
21814: PUSH
21815: LD_INT 101
21817: EQUAL
21818: IFFALSE 21824
// MC_RepairBuildings ( ) ;
21820: CALL 27020 0 0
// if event = 102 then
21824: LD_VAR 0 1
21828: PUSH
21829: LD_INT 102
21831: EQUAL
21832: IFFALSE 21838
// MC_Heal ( ) ;
21834: CALL 27927 0 0
// if event = 103 then
21838: LD_VAR 0 1
21842: PUSH
21843: LD_INT 103
21845: EQUAL
21846: IFFALSE 21852
// MC_Build ( ) ;
21848: CALL 28349 0 0
// if event = 104 then
21852: LD_VAR 0 1
21856: PUSH
21857: LD_INT 104
21859: EQUAL
21860: IFFALSE 21866
// MC_TurretWeapon ( ) ;
21862: CALL 29990 0 0
// if event = 105 then
21866: LD_VAR 0 1
21870: PUSH
21871: LD_INT 105
21873: EQUAL
21874: IFFALSE 21880
// MC_BuildUpgrade ( ) ;
21876: CALL 29541 0 0
// if event = 106 then
21880: LD_VAR 0 1
21884: PUSH
21885: LD_INT 106
21887: EQUAL
21888: IFFALSE 21894
// MC_PlantMines ( ) ;
21890: CALL 30420 0 0
// if event = 107 then
21894: LD_VAR 0 1
21898: PUSH
21899: LD_INT 107
21901: EQUAL
21902: IFFALSE 21908
// MC_CollectCrates ( ) ;
21904: CALL 31211 0 0
// if event = 108 then
21908: LD_VAR 0 1
21912: PUSH
21913: LD_INT 108
21915: EQUAL
21916: IFFALSE 21922
// MC_LinkRemoteControl ( ) ;
21918: CALL 33061 0 0
// if event = 109 then
21922: LD_VAR 0 1
21926: PUSH
21927: LD_INT 109
21929: EQUAL
21930: IFFALSE 21936
// MC_ProduceVehicle ( ) ;
21932: CALL 33242 0 0
// if event = 110 then
21936: LD_VAR 0 1
21940: PUSH
21941: LD_INT 110
21943: EQUAL
21944: IFFALSE 21950
// MC_SendAttack ( ) ;
21946: CALL 33708 0 0
// if event = 111 then
21950: LD_VAR 0 1
21954: PUSH
21955: LD_INT 111
21957: EQUAL
21958: IFFALSE 21964
// MC_Defend ( ) ;
21960: CALL 33816 0 0
// if event = 112 then
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 112
21971: EQUAL
21972: IFFALSE 21978
// MC_Research ( ) ;
21974: CALL 34696 0 0
// if event = 113 then
21978: LD_VAR 0 1
21982: PUSH
21983: LD_INT 113
21985: EQUAL
21986: IFFALSE 21992
// MC_MinesTrigger ( ) ;
21988: CALL 35810 0 0
// if event = 120 then
21992: LD_VAR 0 1
21996: PUSH
21997: LD_INT 120
21999: EQUAL
22000: IFFALSE 22006
// MC_RepairVehicle ( ) ;
22002: CALL 35909 0 0
// if event = 121 then
22006: LD_VAR 0 1
22010: PUSH
22011: LD_INT 121
22013: EQUAL
22014: IFFALSE 22020
// MC_TameApe ( ) ;
22016: CALL 36650 0 0
// if event = 122 then
22020: LD_VAR 0 1
22024: PUSH
22025: LD_INT 122
22027: EQUAL
22028: IFFALSE 22034
// MC_ChangeApeClass ( ) ;
22030: CALL 37479 0 0
// if event = 123 then
22034: LD_VAR 0 1
22038: PUSH
22039: LD_INT 123
22041: EQUAL
22042: IFFALSE 22048
// MC_Bazooka ( ) ;
22044: CALL 38129 0 0
// if event = 124 then
22048: LD_VAR 0 1
22052: PUSH
22053: LD_INT 124
22055: EQUAL
22056: IFFALSE 22062
// MC_TeleportExit ( ) ;
22058: CALL 38327 0 0
// if event = 125 then
22062: LD_VAR 0 1
22066: PUSH
22067: LD_INT 125
22069: EQUAL
22070: IFFALSE 22076
// MC_Deposits ( ) ;
22072: CALL 38974 0 0
// if event = 126 then
22076: LD_VAR 0 1
22080: PUSH
22081: LD_INT 126
22083: EQUAL
22084: IFFALSE 22090
// MC_RemoteDriver ( ) ;
22086: CALL 39599 0 0
// if event = 200 then
22090: LD_VAR 0 1
22094: PUSH
22095: LD_INT 200
22097: EQUAL
22098: IFFALSE 22104
// MC_Idle ( ) ;
22100: CALL 41548 0 0
// end ;
22104: PPOPN 1
22106: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22107: LD_INT 0
22109: PPUSH
22110: PPUSH
// if not mc_bases [ base ] or not tag then
22111: LD_EXP 50
22115: PUSH
22116: LD_VAR 0 1
22120: ARRAY
22121: NOT
22122: PUSH
22123: LD_VAR 0 2
22127: NOT
22128: OR
22129: IFFALSE 22133
// exit ;
22131: GO 22197
// for i in mc_bases [ base ] union mc_ape [ base ] do
22133: LD_ADDR_VAR 0 4
22137: PUSH
22138: LD_EXP 50
22142: PUSH
22143: LD_VAR 0 1
22147: ARRAY
22148: PUSH
22149: LD_EXP 79
22153: PUSH
22154: LD_VAR 0 1
22158: ARRAY
22159: UNION
22160: PUSH
22161: FOR_IN
22162: IFFALSE 22195
// if GetTag ( i ) = tag then
22164: LD_VAR 0 4
22168: PPUSH
22169: CALL_OW 110
22173: PUSH
22174: LD_VAR 0 2
22178: EQUAL
22179: IFFALSE 22193
// SetTag ( i , 0 ) ;
22181: LD_VAR 0 4
22185: PPUSH
22186: LD_INT 0
22188: PPUSH
22189: CALL_OW 109
22193: GO 22161
22195: POP
22196: POP
// end ;
22197: LD_VAR 0 3
22201: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22202: LD_INT 0
22204: PPUSH
22205: PPUSH
22206: PPUSH
22207: PPUSH
22208: PPUSH
22209: PPUSH
22210: PPUSH
22211: PPUSH
// if not mc_bases then
22212: LD_EXP 50
22216: NOT
22217: IFFALSE 22221
// exit ;
22219: GO 22679
// for i = 1 to mc_bases do
22221: LD_ADDR_VAR 0 2
22225: PUSH
22226: DOUBLE
22227: LD_INT 1
22229: DEC
22230: ST_TO_ADDR
22231: LD_EXP 50
22235: PUSH
22236: FOR_TO
22237: IFFALSE 22677
// begin tmp := MC_ClassCheckReq ( i ) ;
22239: LD_ADDR_VAR 0 4
22243: PUSH
22244: LD_VAR 0 2
22248: PPUSH
22249: CALL 22684 0 1
22253: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22254: LD_ADDR_EXP 91
22258: PUSH
22259: LD_EXP 91
22263: PPUSH
22264: LD_VAR 0 2
22268: PPUSH
22269: LD_VAR 0 4
22273: PPUSH
22274: CALL_OW 1
22278: ST_TO_ADDR
// if not tmp then
22279: LD_VAR 0 4
22283: NOT
22284: IFFALSE 22288
// continue ;
22286: GO 22236
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22288: LD_ADDR_VAR 0 6
22292: PUSH
22293: LD_EXP 50
22297: PUSH
22298: LD_VAR 0 2
22302: ARRAY
22303: PPUSH
22304: LD_INT 2
22306: PUSH
22307: LD_INT 30
22309: PUSH
22310: LD_INT 4
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 5
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: LIST
22331: PPUSH
22332: CALL_OW 72
22336: PUSH
22337: LD_EXP 50
22341: PUSH
22342: LD_VAR 0 2
22346: ARRAY
22347: PPUSH
22348: LD_INT 2
22350: PUSH
22351: LD_INT 30
22353: PUSH
22354: LD_INT 0
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: PUSH
22361: LD_INT 30
22363: PUSH
22364: LD_INT 1
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: PUSH
22371: EMPTY
22372: LIST
22373: LIST
22374: LIST
22375: PPUSH
22376: CALL_OW 72
22380: PUSH
22381: LD_EXP 50
22385: PUSH
22386: LD_VAR 0 2
22390: ARRAY
22391: PPUSH
22392: LD_INT 30
22394: PUSH
22395: LD_INT 3
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PPUSH
22402: CALL_OW 72
22406: PUSH
22407: LD_EXP 50
22411: PUSH
22412: LD_VAR 0 2
22416: ARRAY
22417: PPUSH
22418: LD_INT 2
22420: PUSH
22421: LD_INT 30
22423: PUSH
22424: LD_INT 6
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: LD_INT 30
22433: PUSH
22434: LD_INT 7
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: PUSH
22441: LD_INT 30
22443: PUSH
22444: LD_INT 8
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: PPUSH
22457: CALL_OW 72
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: ST_TO_ADDR
// for j = 1 to 4 do
22468: LD_ADDR_VAR 0 3
22472: PUSH
22473: DOUBLE
22474: LD_INT 1
22476: DEC
22477: ST_TO_ADDR
22478: LD_INT 4
22480: PUSH
22481: FOR_TO
22482: IFFALSE 22673
// begin if not tmp [ j ] then
22484: LD_VAR 0 4
22488: PUSH
22489: LD_VAR 0 3
22493: ARRAY
22494: NOT
22495: IFFALSE 22499
// continue ;
22497: GO 22481
// for p in tmp [ j ] do
22499: LD_ADDR_VAR 0 5
22503: PUSH
22504: LD_VAR 0 4
22508: PUSH
22509: LD_VAR 0 3
22513: ARRAY
22514: PUSH
22515: FOR_IN
22516: IFFALSE 22669
// begin if not b [ j ] then
22518: LD_VAR 0 6
22522: PUSH
22523: LD_VAR 0 3
22527: ARRAY
22528: NOT
22529: IFFALSE 22533
// break ;
22531: GO 22669
// e := 0 ;
22533: LD_ADDR_VAR 0 7
22537: PUSH
22538: LD_INT 0
22540: ST_TO_ADDR
// for k in b [ j ] do
22541: LD_ADDR_VAR 0 8
22545: PUSH
22546: LD_VAR 0 6
22550: PUSH
22551: LD_VAR 0 3
22555: ARRAY
22556: PUSH
22557: FOR_IN
22558: IFFALSE 22585
// if IsNotFull ( k ) then
22560: LD_VAR 0 8
22564: PPUSH
22565: CALL 50795 0 1
22569: IFFALSE 22583
// begin e := k ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_VAR 0 8
22580: ST_TO_ADDR
// break ;
22581: GO 22585
// end ;
22583: GO 22557
22585: POP
22586: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22587: LD_VAR 0 7
22591: PUSH
22592: LD_VAR 0 5
22596: PPUSH
22597: LD_VAR 0 7
22601: PPUSH
22602: CALL 83906 0 2
22606: NOT
22607: AND
22608: IFFALSE 22667
// begin if IsInUnit ( p ) then
22610: LD_VAR 0 5
22614: PPUSH
22615: CALL_OW 310
22619: IFFALSE 22630
// ComExitBuilding ( p ) ;
22621: LD_VAR 0 5
22625: PPUSH
22626: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22630: LD_VAR 0 5
22634: PPUSH
22635: LD_VAR 0 7
22639: PPUSH
22640: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22644: LD_VAR 0 5
22648: PPUSH
22649: LD_VAR 0 3
22653: PPUSH
22654: CALL_OW 183
// AddComExitBuilding ( p ) ;
22658: LD_VAR 0 5
22662: PPUSH
22663: CALL_OW 182
// end ; end ;
22667: GO 22515
22669: POP
22670: POP
// end ;
22671: GO 22481
22673: POP
22674: POP
// end ;
22675: GO 22236
22677: POP
22678: POP
// end ;
22679: LD_VAR 0 1
22683: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22684: LD_INT 0
22686: PPUSH
22687: PPUSH
22688: PPUSH
22689: PPUSH
22690: PPUSH
22691: PPUSH
22692: PPUSH
22693: PPUSH
22694: PPUSH
22695: PPUSH
22696: PPUSH
22697: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22698: LD_VAR 0 1
22702: NOT
22703: PUSH
22704: LD_EXP 50
22708: PUSH
22709: LD_VAR 0 1
22713: ARRAY
22714: NOT
22715: OR
22716: PUSH
22717: LD_EXP 50
22721: PUSH
22722: LD_VAR 0 1
22726: ARRAY
22727: PPUSH
22728: LD_INT 2
22730: PUSH
22731: LD_INT 30
22733: PUSH
22734: LD_INT 0
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: PPUSH
22756: CALL_OW 72
22760: NOT
22761: OR
22762: IFFALSE 22766
// exit ;
22764: GO 26269
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22766: LD_ADDR_VAR 0 4
22770: PUSH
22771: LD_EXP 50
22775: PUSH
22776: LD_VAR 0 1
22780: ARRAY
22781: PPUSH
22782: LD_INT 2
22784: PUSH
22785: LD_INT 25
22787: PUSH
22788: LD_INT 1
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: PUSH
22795: LD_INT 25
22797: PUSH
22798: LD_INT 2
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 3
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: LD_INT 25
22817: PUSH
22818: LD_INT 4
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: PUSH
22825: LD_INT 25
22827: PUSH
22828: LD_INT 5
22830: PUSH
22831: EMPTY
22832: LIST
22833: LIST
22834: PUSH
22835: LD_INT 25
22837: PUSH
22838: LD_INT 8
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: PUSH
22845: LD_INT 25
22847: PUSH
22848: LD_INT 9
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 72
22869: ST_TO_ADDR
// if not tmp then
22870: LD_VAR 0 4
22874: NOT
22875: IFFALSE 22879
// exit ;
22877: GO 26269
// for i in tmp do
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_VAR 0 4
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22921
// if GetTag ( i ) then
22892: LD_VAR 0 3
22896: PPUSH
22897: CALL_OW 110
22901: IFFALSE 22919
// tmp := tmp diff i ;
22903: LD_ADDR_VAR 0 4
22907: PUSH
22908: LD_VAR 0 4
22912: PUSH
22913: LD_VAR 0 3
22917: DIFF
22918: ST_TO_ADDR
22919: GO 22889
22921: POP
22922: POP
// if not tmp then
22923: LD_VAR 0 4
22927: NOT
22928: IFFALSE 22932
// exit ;
22930: GO 26269
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22932: LD_ADDR_VAR 0 5
22936: PUSH
22937: LD_EXP 50
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 25
22953: PUSH
22954: LD_INT 1
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 25
22963: PUSH
22964: LD_INT 5
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 25
22973: PUSH
22974: LD_INT 8
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: LD_INT 25
22983: PUSH
22984: LD_INT 9
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: LIST
22995: LIST
22996: LIST
22997: PPUSH
22998: CALL_OW 72
23002: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23003: LD_ADDR_VAR 0 6
23007: PUSH
23008: LD_EXP 50
23012: PUSH
23013: LD_VAR 0 1
23017: ARRAY
23018: PPUSH
23019: LD_INT 25
23021: PUSH
23022: LD_INT 2
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PPUSH
23029: CALL_OW 72
23033: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23034: LD_ADDR_VAR 0 7
23038: PUSH
23039: LD_EXP 50
23043: PUSH
23044: LD_VAR 0 1
23048: ARRAY
23049: PPUSH
23050: LD_INT 25
23052: PUSH
23053: LD_INT 3
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PPUSH
23060: CALL_OW 72
23064: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23065: LD_ADDR_VAR 0 8
23069: PUSH
23070: LD_EXP 50
23074: PUSH
23075: LD_VAR 0 1
23079: ARRAY
23080: PPUSH
23081: LD_INT 25
23083: PUSH
23084: LD_INT 4
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PUSH
23091: LD_INT 24
23093: PUSH
23094: LD_INT 251
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: PPUSH
23105: CALL_OW 72
23109: ST_TO_ADDR
// if mc_is_defending [ base ] then
23110: LD_EXP 93
23114: PUSH
23115: LD_VAR 0 1
23119: ARRAY
23120: IFFALSE 23581
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23122: LD_ADDR_EXP 92
23126: PUSH
23127: LD_EXP 92
23131: PPUSH
23132: LD_VAR 0 1
23136: PPUSH
23137: LD_INT 4
23139: PPUSH
23140: CALL_OW 1
23144: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23145: LD_ADDR_VAR 0 12
23149: PUSH
23150: LD_EXP 50
23154: PUSH
23155: LD_VAR 0 1
23159: ARRAY
23160: PPUSH
23161: LD_INT 2
23163: PUSH
23164: LD_INT 30
23166: PUSH
23167: LD_INT 4
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PUSH
23174: LD_INT 30
23176: PUSH
23177: LD_INT 5
23179: PUSH
23180: EMPTY
23181: LIST
23182: LIST
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: LIST
23188: PPUSH
23189: CALL_OW 72
23193: ST_TO_ADDR
// if not b then
23194: LD_VAR 0 12
23198: NOT
23199: IFFALSE 23203
// exit ;
23201: GO 26269
// p := [ ] ;
23203: LD_ADDR_VAR 0 11
23207: PUSH
23208: EMPTY
23209: ST_TO_ADDR
// if sci >= 2 then
23210: LD_VAR 0 8
23214: PUSH
23215: LD_INT 2
23217: GREATEREQUAL
23218: IFFALSE 23249
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23220: LD_ADDR_VAR 0 8
23224: PUSH
23225: LD_VAR 0 8
23229: PUSH
23230: LD_INT 1
23232: ARRAY
23233: PUSH
23234: LD_VAR 0 8
23238: PUSH
23239: LD_INT 2
23241: ARRAY
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: ST_TO_ADDR
23247: GO 23310
// if sci = 1 then
23249: LD_VAR 0 8
23253: PUSH
23254: LD_INT 1
23256: EQUAL
23257: IFFALSE 23278
// sci := [ sci [ 1 ] ] else
23259: LD_ADDR_VAR 0 8
23263: PUSH
23264: LD_VAR 0 8
23268: PUSH
23269: LD_INT 1
23271: ARRAY
23272: PUSH
23273: EMPTY
23274: LIST
23275: ST_TO_ADDR
23276: GO 23310
// if sci = 0 then
23278: LD_VAR 0 8
23282: PUSH
23283: LD_INT 0
23285: EQUAL
23286: IFFALSE 23310
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23288: LD_ADDR_VAR 0 11
23292: PUSH
23293: LD_VAR 0 4
23297: PPUSH
23298: LD_INT 4
23300: PPUSH
23301: CALL 83769 0 2
23305: PUSH
23306: LD_INT 1
23308: ARRAY
23309: ST_TO_ADDR
// if eng > 4 then
23310: LD_VAR 0 6
23314: PUSH
23315: LD_INT 4
23317: GREATER
23318: IFFALSE 23364
// for i = eng downto 4 do
23320: LD_ADDR_VAR 0 3
23324: PUSH
23325: DOUBLE
23326: LD_VAR 0 6
23330: INC
23331: ST_TO_ADDR
23332: LD_INT 4
23334: PUSH
23335: FOR_DOWNTO
23336: IFFALSE 23362
// eng := eng diff eng [ i ] ;
23338: LD_ADDR_VAR 0 6
23342: PUSH
23343: LD_VAR 0 6
23347: PUSH
23348: LD_VAR 0 6
23352: PUSH
23353: LD_VAR 0 3
23357: ARRAY
23358: DIFF
23359: ST_TO_ADDR
23360: GO 23335
23362: POP
23363: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23364: LD_ADDR_VAR 0 4
23368: PUSH
23369: LD_VAR 0 4
23373: PUSH
23374: LD_VAR 0 5
23378: PUSH
23379: LD_VAR 0 6
23383: UNION
23384: PUSH
23385: LD_VAR 0 7
23389: UNION
23390: PUSH
23391: LD_VAR 0 8
23395: UNION
23396: DIFF
23397: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23398: LD_ADDR_VAR 0 13
23402: PUSH
23403: LD_EXP 50
23407: PUSH
23408: LD_VAR 0 1
23412: ARRAY
23413: PPUSH
23414: LD_INT 2
23416: PUSH
23417: LD_INT 30
23419: PUSH
23420: LD_INT 32
23422: PUSH
23423: EMPTY
23424: LIST
23425: LIST
23426: PUSH
23427: LD_INT 30
23429: PUSH
23430: LD_INT 31
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: LIST
23441: PPUSH
23442: CALL_OW 72
23446: PUSH
23447: LD_EXP 50
23451: PUSH
23452: LD_VAR 0 1
23456: ARRAY
23457: PPUSH
23458: LD_INT 2
23460: PUSH
23461: LD_INT 30
23463: PUSH
23464: LD_INT 4
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PUSH
23471: LD_INT 30
23473: PUSH
23474: LD_INT 5
23476: PUSH
23477: EMPTY
23478: LIST
23479: LIST
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: LIST
23485: PPUSH
23486: CALL_OW 72
23490: PUSH
23491: LD_INT 6
23493: MUL
23494: PLUS
23495: ST_TO_ADDR
// if bcount < tmp then
23496: LD_VAR 0 13
23500: PUSH
23501: LD_VAR 0 4
23505: LESS
23506: IFFALSE 23552
// for i = tmp downto bcount do
23508: LD_ADDR_VAR 0 3
23512: PUSH
23513: DOUBLE
23514: LD_VAR 0 4
23518: INC
23519: ST_TO_ADDR
23520: LD_VAR 0 13
23524: PUSH
23525: FOR_DOWNTO
23526: IFFALSE 23550
// tmp := Delete ( tmp , tmp ) ;
23528: LD_ADDR_VAR 0 4
23532: PUSH
23533: LD_VAR 0 4
23537: PPUSH
23538: LD_VAR 0 4
23542: PPUSH
23543: CALL_OW 3
23547: ST_TO_ADDR
23548: GO 23525
23550: POP
23551: POP
// result := [ tmp , 0 , 0 , p ] ;
23552: LD_ADDR_VAR 0 2
23556: PUSH
23557: LD_VAR 0 4
23561: PUSH
23562: LD_INT 0
23564: PUSH
23565: LD_INT 0
23567: PUSH
23568: LD_VAR 0 11
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: ST_TO_ADDR
// exit ;
23579: GO 26269
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23581: LD_EXP 50
23585: PUSH
23586: LD_VAR 0 1
23590: ARRAY
23591: PPUSH
23592: LD_INT 2
23594: PUSH
23595: LD_INT 30
23597: PUSH
23598: LD_INT 6
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: PUSH
23605: LD_INT 30
23607: PUSH
23608: LD_INT 7
23610: PUSH
23611: EMPTY
23612: LIST
23613: LIST
23614: PUSH
23615: LD_INT 30
23617: PUSH
23618: LD_INT 8
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: LIST
23629: LIST
23630: PPUSH
23631: CALL_OW 72
23635: NOT
23636: PUSH
23637: LD_EXP 50
23641: PUSH
23642: LD_VAR 0 1
23646: ARRAY
23647: PPUSH
23648: LD_INT 30
23650: PUSH
23651: LD_INT 3
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: NOT
23663: AND
23664: IFFALSE 23736
// begin if eng = tmp then
23666: LD_VAR 0 6
23670: PUSH
23671: LD_VAR 0 4
23675: EQUAL
23676: IFFALSE 23680
// exit ;
23678: GO 26269
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23680: LD_ADDR_EXP 92
23684: PUSH
23685: LD_EXP 92
23689: PPUSH
23690: LD_VAR 0 1
23694: PPUSH
23695: LD_INT 1
23697: PPUSH
23698: CALL_OW 1
23702: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23703: LD_ADDR_VAR 0 2
23707: PUSH
23708: LD_INT 0
23710: PUSH
23711: LD_VAR 0 4
23715: PUSH
23716: LD_VAR 0 6
23720: DIFF
23721: PUSH
23722: LD_INT 0
23724: PUSH
23725: LD_INT 0
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: ST_TO_ADDR
// exit ;
23734: GO 26269
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23736: LD_EXP 77
23740: PUSH
23741: LD_EXP 76
23745: PUSH
23746: LD_VAR 0 1
23750: ARRAY
23751: ARRAY
23752: PUSH
23753: LD_EXP 50
23757: PUSH
23758: LD_VAR 0 1
23762: ARRAY
23763: PPUSH
23764: LD_INT 2
23766: PUSH
23767: LD_INT 30
23769: PUSH
23770: LD_INT 6
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: PUSH
23777: LD_INT 30
23779: PUSH
23780: LD_INT 7
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 8
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: LIST
23801: LIST
23802: PPUSH
23803: CALL_OW 72
23807: AND
23808: PUSH
23809: LD_EXP 50
23813: PUSH
23814: LD_VAR 0 1
23818: ARRAY
23819: PPUSH
23820: LD_INT 30
23822: PUSH
23823: LD_INT 3
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: PPUSH
23830: CALL_OW 72
23834: NOT
23835: AND
23836: IFFALSE 24050
// begin if sci >= 6 then
23838: LD_VAR 0 8
23842: PUSH
23843: LD_INT 6
23845: GREATEREQUAL
23846: IFFALSE 23850
// exit ;
23848: GO 26269
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23850: LD_ADDR_EXP 92
23854: PUSH
23855: LD_EXP 92
23859: PPUSH
23860: LD_VAR 0 1
23864: PPUSH
23865: LD_INT 2
23867: PPUSH
23868: CALL_OW 1
23872: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23873: LD_ADDR_VAR 0 9
23877: PUSH
23878: LD_VAR 0 4
23882: PUSH
23883: LD_VAR 0 8
23887: DIFF
23888: PPUSH
23889: LD_INT 4
23891: PPUSH
23892: CALL 83769 0 2
23896: ST_TO_ADDR
// p := [ ] ;
23897: LD_ADDR_VAR 0 11
23901: PUSH
23902: EMPTY
23903: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23904: LD_VAR 0 8
23908: PUSH
23909: LD_INT 6
23911: LESS
23912: PUSH
23913: LD_VAR 0 9
23917: PUSH
23918: LD_INT 6
23920: GREATER
23921: AND
23922: IFFALSE 24003
// begin for i = 1 to 6 - sci do
23924: LD_ADDR_VAR 0 3
23928: PUSH
23929: DOUBLE
23930: LD_INT 1
23932: DEC
23933: ST_TO_ADDR
23934: LD_INT 6
23936: PUSH
23937: LD_VAR 0 8
23941: MINUS
23942: PUSH
23943: FOR_TO
23944: IFFALSE 23999
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23946: LD_ADDR_VAR 0 11
23950: PUSH
23951: LD_VAR 0 11
23955: PPUSH
23956: LD_VAR 0 11
23960: PUSH
23961: LD_INT 1
23963: PLUS
23964: PPUSH
23965: LD_VAR 0 9
23969: PUSH
23970: LD_INT 1
23972: ARRAY
23973: PPUSH
23974: CALL_OW 2
23978: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23979: LD_ADDR_VAR 0 9
23983: PUSH
23984: LD_VAR 0 9
23988: PPUSH
23989: LD_INT 1
23991: PPUSH
23992: CALL_OW 3
23996: ST_TO_ADDR
// end ;
23997: GO 23943
23999: POP
24000: POP
// end else
24001: GO 24023
// if sort then
24003: LD_VAR 0 9
24007: IFFALSE 24023
// p := sort [ 1 ] ;
24009: LD_ADDR_VAR 0 11
24013: PUSH
24014: LD_VAR 0 9
24018: PUSH
24019: LD_INT 1
24021: ARRAY
24022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24023: LD_ADDR_VAR 0 2
24027: PUSH
24028: LD_INT 0
24030: PUSH
24031: LD_INT 0
24033: PUSH
24034: LD_INT 0
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: LIST
24047: ST_TO_ADDR
// exit ;
24048: GO 26269
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24050: LD_EXP 77
24054: PUSH
24055: LD_EXP 76
24059: PUSH
24060: LD_VAR 0 1
24064: ARRAY
24065: ARRAY
24066: PUSH
24067: LD_EXP 50
24071: PUSH
24072: LD_VAR 0 1
24076: ARRAY
24077: PPUSH
24078: LD_INT 2
24080: PUSH
24081: LD_INT 30
24083: PUSH
24084: LD_INT 6
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: PUSH
24091: LD_INT 30
24093: PUSH
24094: LD_INT 7
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: PUSH
24101: LD_INT 30
24103: PUSH
24104: LD_INT 8
24106: PUSH
24107: EMPTY
24108: LIST
24109: LIST
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: LIST
24115: LIST
24116: PPUSH
24117: CALL_OW 72
24121: AND
24122: PUSH
24123: LD_EXP 50
24127: PUSH
24128: LD_VAR 0 1
24132: ARRAY
24133: PPUSH
24134: LD_INT 30
24136: PUSH
24137: LD_INT 3
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PPUSH
24144: CALL_OW 72
24148: AND
24149: IFFALSE 24883
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24151: LD_ADDR_EXP 92
24155: PUSH
24156: LD_EXP 92
24160: PPUSH
24161: LD_VAR 0 1
24165: PPUSH
24166: LD_INT 3
24168: PPUSH
24169: CALL_OW 1
24173: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24174: LD_ADDR_VAR 0 2
24178: PUSH
24179: LD_INT 0
24181: PUSH
24182: LD_INT 0
24184: PUSH
24185: LD_INT 0
24187: PUSH
24188: LD_INT 0
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: LIST
24195: LIST
24196: ST_TO_ADDR
// if not eng then
24197: LD_VAR 0 6
24201: NOT
24202: IFFALSE 24265
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24204: LD_ADDR_VAR 0 11
24208: PUSH
24209: LD_VAR 0 4
24213: PPUSH
24214: LD_INT 2
24216: PPUSH
24217: CALL 83769 0 2
24221: PUSH
24222: LD_INT 1
24224: ARRAY
24225: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24226: LD_ADDR_VAR 0 2
24230: PUSH
24231: LD_VAR 0 2
24235: PPUSH
24236: LD_INT 2
24238: PPUSH
24239: LD_VAR 0 11
24243: PPUSH
24244: CALL_OW 1
24248: ST_TO_ADDR
// tmp := tmp diff p ;
24249: LD_ADDR_VAR 0 4
24253: PUSH
24254: LD_VAR 0 4
24258: PUSH
24259: LD_VAR 0 11
24263: DIFF
24264: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24265: LD_VAR 0 4
24269: PUSH
24270: LD_VAR 0 8
24274: PUSH
24275: LD_INT 6
24277: LESS
24278: AND
24279: IFFALSE 24467
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24281: LD_ADDR_VAR 0 9
24285: PUSH
24286: LD_VAR 0 4
24290: PUSH
24291: LD_VAR 0 8
24295: PUSH
24296: LD_VAR 0 7
24300: UNION
24301: DIFF
24302: PPUSH
24303: LD_INT 4
24305: PPUSH
24306: CALL 83769 0 2
24310: ST_TO_ADDR
// p := [ ] ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: EMPTY
24317: ST_TO_ADDR
// if sort then
24318: LD_VAR 0 9
24322: IFFALSE 24438
// for i = 1 to 6 - sci do
24324: LD_ADDR_VAR 0 3
24328: PUSH
24329: DOUBLE
24330: LD_INT 1
24332: DEC
24333: ST_TO_ADDR
24334: LD_INT 6
24336: PUSH
24337: LD_VAR 0 8
24341: MINUS
24342: PUSH
24343: FOR_TO
24344: IFFALSE 24436
// begin if i = sort then
24346: LD_VAR 0 3
24350: PUSH
24351: LD_VAR 0 9
24355: EQUAL
24356: IFFALSE 24360
// break ;
24358: GO 24436
// if GetClass ( i ) = 4 then
24360: LD_VAR 0 3
24364: PPUSH
24365: CALL_OW 257
24369: PUSH
24370: LD_INT 4
24372: EQUAL
24373: IFFALSE 24377
// continue ;
24375: GO 24343
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24377: LD_ADDR_VAR 0 11
24381: PUSH
24382: LD_VAR 0 11
24386: PPUSH
24387: LD_VAR 0 11
24391: PUSH
24392: LD_INT 1
24394: PLUS
24395: PPUSH
24396: LD_VAR 0 9
24400: PUSH
24401: LD_VAR 0 3
24405: ARRAY
24406: PPUSH
24407: CALL_OW 2
24411: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24412: LD_ADDR_VAR 0 4
24416: PUSH
24417: LD_VAR 0 4
24421: PUSH
24422: LD_VAR 0 9
24426: PUSH
24427: LD_VAR 0 3
24431: ARRAY
24432: DIFF
24433: ST_TO_ADDR
// end ;
24434: GO 24343
24436: POP
24437: POP
// if p then
24438: LD_VAR 0 11
24442: IFFALSE 24467
// result := Replace ( result , 4 , p ) ;
24444: LD_ADDR_VAR 0 2
24448: PUSH
24449: LD_VAR 0 2
24453: PPUSH
24454: LD_INT 4
24456: PPUSH
24457: LD_VAR 0 11
24461: PPUSH
24462: CALL_OW 1
24466: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24467: LD_VAR 0 4
24471: PUSH
24472: LD_VAR 0 7
24476: PUSH
24477: LD_INT 6
24479: LESS
24480: AND
24481: IFFALSE 24669
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24483: LD_ADDR_VAR 0 9
24487: PUSH
24488: LD_VAR 0 4
24492: PUSH
24493: LD_VAR 0 8
24497: PUSH
24498: LD_VAR 0 7
24502: UNION
24503: DIFF
24504: PPUSH
24505: LD_INT 3
24507: PPUSH
24508: CALL 83769 0 2
24512: ST_TO_ADDR
// p := [ ] ;
24513: LD_ADDR_VAR 0 11
24517: PUSH
24518: EMPTY
24519: ST_TO_ADDR
// if sort then
24520: LD_VAR 0 9
24524: IFFALSE 24640
// for i = 1 to 6 - mech do
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: DOUBLE
24532: LD_INT 1
24534: DEC
24535: ST_TO_ADDR
24536: LD_INT 6
24538: PUSH
24539: LD_VAR 0 7
24543: MINUS
24544: PUSH
24545: FOR_TO
24546: IFFALSE 24638
// begin if i = sort then
24548: LD_VAR 0 3
24552: PUSH
24553: LD_VAR 0 9
24557: EQUAL
24558: IFFALSE 24562
// break ;
24560: GO 24638
// if GetClass ( i ) = 3 then
24562: LD_VAR 0 3
24566: PPUSH
24567: CALL_OW 257
24571: PUSH
24572: LD_INT 3
24574: EQUAL
24575: IFFALSE 24579
// continue ;
24577: GO 24545
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24579: LD_ADDR_VAR 0 11
24583: PUSH
24584: LD_VAR 0 11
24588: PPUSH
24589: LD_VAR 0 11
24593: PUSH
24594: LD_INT 1
24596: PLUS
24597: PPUSH
24598: LD_VAR 0 9
24602: PUSH
24603: LD_VAR 0 3
24607: ARRAY
24608: PPUSH
24609: CALL_OW 2
24613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24614: LD_ADDR_VAR 0 4
24618: PUSH
24619: LD_VAR 0 4
24623: PUSH
24624: LD_VAR 0 9
24628: PUSH
24629: LD_VAR 0 3
24633: ARRAY
24634: DIFF
24635: ST_TO_ADDR
// end ;
24636: GO 24545
24638: POP
24639: POP
// if p then
24640: LD_VAR 0 11
24644: IFFALSE 24669
// result := Replace ( result , 3 , p ) ;
24646: LD_ADDR_VAR 0 2
24650: PUSH
24651: LD_VAR 0 2
24655: PPUSH
24656: LD_INT 3
24658: PPUSH
24659: LD_VAR 0 11
24663: PPUSH
24664: CALL_OW 1
24668: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24669: LD_VAR 0 4
24673: PUSH
24674: LD_INT 6
24676: GREATER
24677: PUSH
24678: LD_VAR 0 6
24682: PUSH
24683: LD_INT 6
24685: LESS
24686: AND
24687: IFFALSE 24881
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24689: LD_ADDR_VAR 0 9
24693: PUSH
24694: LD_VAR 0 4
24698: PUSH
24699: LD_VAR 0 8
24703: PUSH
24704: LD_VAR 0 7
24708: UNION
24709: PUSH
24710: LD_VAR 0 6
24714: UNION
24715: DIFF
24716: PPUSH
24717: LD_INT 2
24719: PPUSH
24720: CALL 83769 0 2
24724: ST_TO_ADDR
// p := [ ] ;
24725: LD_ADDR_VAR 0 11
24729: PUSH
24730: EMPTY
24731: ST_TO_ADDR
// if sort then
24732: LD_VAR 0 9
24736: IFFALSE 24852
// for i = 1 to 6 - eng do
24738: LD_ADDR_VAR 0 3
24742: PUSH
24743: DOUBLE
24744: LD_INT 1
24746: DEC
24747: ST_TO_ADDR
24748: LD_INT 6
24750: PUSH
24751: LD_VAR 0 6
24755: MINUS
24756: PUSH
24757: FOR_TO
24758: IFFALSE 24850
// begin if i = sort then
24760: LD_VAR 0 3
24764: PUSH
24765: LD_VAR 0 9
24769: EQUAL
24770: IFFALSE 24774
// break ;
24772: GO 24850
// if GetClass ( i ) = 2 then
24774: LD_VAR 0 3
24778: PPUSH
24779: CALL_OW 257
24783: PUSH
24784: LD_INT 2
24786: EQUAL
24787: IFFALSE 24791
// continue ;
24789: GO 24757
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24791: LD_ADDR_VAR 0 11
24795: PUSH
24796: LD_VAR 0 11
24800: PPUSH
24801: LD_VAR 0 11
24805: PUSH
24806: LD_INT 1
24808: PLUS
24809: PPUSH
24810: LD_VAR 0 9
24814: PUSH
24815: LD_VAR 0 3
24819: ARRAY
24820: PPUSH
24821: CALL_OW 2
24825: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24826: LD_ADDR_VAR 0 4
24830: PUSH
24831: LD_VAR 0 4
24835: PUSH
24836: LD_VAR 0 9
24840: PUSH
24841: LD_VAR 0 3
24845: ARRAY
24846: DIFF
24847: ST_TO_ADDR
// end ;
24848: GO 24757
24850: POP
24851: POP
// if p then
24852: LD_VAR 0 11
24856: IFFALSE 24881
// result := Replace ( result , 2 , p ) ;
24858: LD_ADDR_VAR 0 2
24862: PUSH
24863: LD_VAR 0 2
24867: PPUSH
24868: LD_INT 2
24870: PPUSH
24871: LD_VAR 0 11
24875: PPUSH
24876: CALL_OW 1
24880: ST_TO_ADDR
// end ; exit ;
24881: GO 26269
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24883: LD_EXP 77
24887: PUSH
24888: LD_EXP 76
24892: PUSH
24893: LD_VAR 0 1
24897: ARRAY
24898: ARRAY
24899: NOT
24900: PUSH
24901: LD_EXP 50
24905: PUSH
24906: LD_VAR 0 1
24910: ARRAY
24911: PPUSH
24912: LD_INT 30
24914: PUSH
24915: LD_INT 3
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: PPUSH
24922: CALL_OW 72
24926: AND
24927: PUSH
24928: LD_EXP 55
24932: PUSH
24933: LD_VAR 0 1
24937: ARRAY
24938: AND
24939: IFFALSE 25547
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24941: LD_ADDR_EXP 92
24945: PUSH
24946: LD_EXP 92
24950: PPUSH
24951: LD_VAR 0 1
24955: PPUSH
24956: LD_INT 5
24958: PPUSH
24959: CALL_OW 1
24963: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24964: LD_ADDR_VAR 0 2
24968: PUSH
24969: LD_INT 0
24971: PUSH
24972: LD_INT 0
24974: PUSH
24975: LD_INT 0
24977: PUSH
24978: LD_INT 0
24980: PUSH
24981: EMPTY
24982: LIST
24983: LIST
24984: LIST
24985: LIST
24986: ST_TO_ADDR
// if sci > 1 then
24987: LD_VAR 0 8
24991: PUSH
24992: LD_INT 1
24994: GREATER
24995: IFFALSE 25023
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24997: LD_ADDR_VAR 0 4
25001: PUSH
25002: LD_VAR 0 4
25006: PUSH
25007: LD_VAR 0 8
25011: PUSH
25012: LD_VAR 0 8
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: DIFF
25021: DIFF
25022: ST_TO_ADDR
// if tmp and not sci then
25023: LD_VAR 0 4
25027: PUSH
25028: LD_VAR 0 8
25032: NOT
25033: AND
25034: IFFALSE 25103
// begin sort := SortBySkill ( tmp , 4 ) ;
25036: LD_ADDR_VAR 0 9
25040: PUSH
25041: LD_VAR 0 4
25045: PPUSH
25046: LD_INT 4
25048: PPUSH
25049: CALL 83769 0 2
25053: ST_TO_ADDR
// if sort then
25054: LD_VAR 0 9
25058: IFFALSE 25074
// p := sort [ 1 ] ;
25060: LD_ADDR_VAR 0 11
25064: PUSH
25065: LD_VAR 0 9
25069: PUSH
25070: LD_INT 1
25072: ARRAY
25073: ST_TO_ADDR
// if p then
25074: LD_VAR 0 11
25078: IFFALSE 25103
// result := Replace ( result , 4 , p ) ;
25080: LD_ADDR_VAR 0 2
25084: PUSH
25085: LD_VAR 0 2
25089: PPUSH
25090: LD_INT 4
25092: PPUSH
25093: LD_VAR 0 11
25097: PPUSH
25098: CALL_OW 1
25102: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25103: LD_ADDR_VAR 0 4
25107: PUSH
25108: LD_VAR 0 4
25112: PUSH
25113: LD_VAR 0 7
25117: DIFF
25118: ST_TO_ADDR
// if tmp and mech < 6 then
25119: LD_VAR 0 4
25123: PUSH
25124: LD_VAR 0 7
25128: PUSH
25129: LD_INT 6
25131: LESS
25132: AND
25133: IFFALSE 25321
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25135: LD_ADDR_VAR 0 9
25139: PUSH
25140: LD_VAR 0 4
25144: PUSH
25145: LD_VAR 0 8
25149: PUSH
25150: LD_VAR 0 7
25154: UNION
25155: DIFF
25156: PPUSH
25157: LD_INT 3
25159: PPUSH
25160: CALL 83769 0 2
25164: ST_TO_ADDR
// p := [ ] ;
25165: LD_ADDR_VAR 0 11
25169: PUSH
25170: EMPTY
25171: ST_TO_ADDR
// if sort then
25172: LD_VAR 0 9
25176: IFFALSE 25292
// for i = 1 to 6 - mech do
25178: LD_ADDR_VAR 0 3
25182: PUSH
25183: DOUBLE
25184: LD_INT 1
25186: DEC
25187: ST_TO_ADDR
25188: LD_INT 6
25190: PUSH
25191: LD_VAR 0 7
25195: MINUS
25196: PUSH
25197: FOR_TO
25198: IFFALSE 25290
// begin if i = sort then
25200: LD_VAR 0 3
25204: PUSH
25205: LD_VAR 0 9
25209: EQUAL
25210: IFFALSE 25214
// break ;
25212: GO 25290
// if GetClass ( i ) = 3 then
25214: LD_VAR 0 3
25218: PPUSH
25219: CALL_OW 257
25223: PUSH
25224: LD_INT 3
25226: EQUAL
25227: IFFALSE 25231
// continue ;
25229: GO 25197
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25231: LD_ADDR_VAR 0 11
25235: PUSH
25236: LD_VAR 0 11
25240: PPUSH
25241: LD_VAR 0 11
25245: PUSH
25246: LD_INT 1
25248: PLUS
25249: PPUSH
25250: LD_VAR 0 9
25254: PUSH
25255: LD_VAR 0 3
25259: ARRAY
25260: PPUSH
25261: CALL_OW 2
25265: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25266: LD_ADDR_VAR 0 4
25270: PUSH
25271: LD_VAR 0 4
25275: PUSH
25276: LD_VAR 0 9
25280: PUSH
25281: LD_VAR 0 3
25285: ARRAY
25286: DIFF
25287: ST_TO_ADDR
// end ;
25288: GO 25197
25290: POP
25291: POP
// if p then
25292: LD_VAR 0 11
25296: IFFALSE 25321
// result := Replace ( result , 3 , p ) ;
25298: LD_ADDR_VAR 0 2
25302: PUSH
25303: LD_VAR 0 2
25307: PPUSH
25308: LD_INT 3
25310: PPUSH
25311: LD_VAR 0 11
25315: PPUSH
25316: CALL_OW 1
25320: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25321: LD_ADDR_VAR 0 4
25325: PUSH
25326: LD_VAR 0 4
25330: PUSH
25331: LD_VAR 0 6
25335: DIFF
25336: ST_TO_ADDR
// if tmp and eng < 6 then
25337: LD_VAR 0 4
25341: PUSH
25342: LD_VAR 0 6
25346: PUSH
25347: LD_INT 6
25349: LESS
25350: AND
25351: IFFALSE 25545
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25353: LD_ADDR_VAR 0 9
25357: PUSH
25358: LD_VAR 0 4
25362: PUSH
25363: LD_VAR 0 8
25367: PUSH
25368: LD_VAR 0 7
25372: UNION
25373: PUSH
25374: LD_VAR 0 6
25378: UNION
25379: DIFF
25380: PPUSH
25381: LD_INT 2
25383: PPUSH
25384: CALL 83769 0 2
25388: ST_TO_ADDR
// p := [ ] ;
25389: LD_ADDR_VAR 0 11
25393: PUSH
25394: EMPTY
25395: ST_TO_ADDR
// if sort then
25396: LD_VAR 0 9
25400: IFFALSE 25516
// for i = 1 to 6 - eng do
25402: LD_ADDR_VAR 0 3
25406: PUSH
25407: DOUBLE
25408: LD_INT 1
25410: DEC
25411: ST_TO_ADDR
25412: LD_INT 6
25414: PUSH
25415: LD_VAR 0 6
25419: MINUS
25420: PUSH
25421: FOR_TO
25422: IFFALSE 25514
// begin if i = sort then
25424: LD_VAR 0 3
25428: PUSH
25429: LD_VAR 0 9
25433: EQUAL
25434: IFFALSE 25438
// break ;
25436: GO 25514
// if GetClass ( i ) = 2 then
25438: LD_VAR 0 3
25442: PPUSH
25443: CALL_OW 257
25447: PUSH
25448: LD_INT 2
25450: EQUAL
25451: IFFALSE 25455
// continue ;
25453: GO 25421
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25455: LD_ADDR_VAR 0 11
25459: PUSH
25460: LD_VAR 0 11
25464: PPUSH
25465: LD_VAR 0 11
25469: PUSH
25470: LD_INT 1
25472: PLUS
25473: PPUSH
25474: LD_VAR 0 9
25478: PUSH
25479: LD_VAR 0 3
25483: ARRAY
25484: PPUSH
25485: CALL_OW 2
25489: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25490: LD_ADDR_VAR 0 4
25494: PUSH
25495: LD_VAR 0 4
25499: PUSH
25500: LD_VAR 0 9
25504: PUSH
25505: LD_VAR 0 3
25509: ARRAY
25510: DIFF
25511: ST_TO_ADDR
// end ;
25512: GO 25421
25514: POP
25515: POP
// if p then
25516: LD_VAR 0 11
25520: IFFALSE 25545
// result := Replace ( result , 2 , p ) ;
25522: LD_ADDR_VAR 0 2
25526: PUSH
25527: LD_VAR 0 2
25531: PPUSH
25532: LD_INT 2
25534: PPUSH
25535: LD_VAR 0 11
25539: PPUSH
25540: CALL_OW 1
25544: ST_TO_ADDR
// end ; exit ;
25545: GO 26269
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25547: LD_EXP 77
25551: PUSH
25552: LD_EXP 76
25556: PUSH
25557: LD_VAR 0 1
25561: ARRAY
25562: ARRAY
25563: NOT
25564: PUSH
25565: LD_EXP 50
25569: PUSH
25570: LD_VAR 0 1
25574: ARRAY
25575: PPUSH
25576: LD_INT 30
25578: PUSH
25579: LD_INT 3
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PPUSH
25586: CALL_OW 72
25590: AND
25591: PUSH
25592: LD_EXP 55
25596: PUSH
25597: LD_VAR 0 1
25601: ARRAY
25602: NOT
25603: AND
25604: IFFALSE 26269
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25606: LD_ADDR_EXP 92
25610: PUSH
25611: LD_EXP 92
25615: PPUSH
25616: LD_VAR 0 1
25620: PPUSH
25621: LD_INT 6
25623: PPUSH
25624: CALL_OW 1
25628: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25629: LD_ADDR_VAR 0 2
25633: PUSH
25634: LD_INT 0
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: ST_TO_ADDR
// if sci >= 1 then
25652: LD_VAR 0 8
25656: PUSH
25657: LD_INT 1
25659: GREATEREQUAL
25660: IFFALSE 25682
// tmp := tmp diff sci [ 1 ] ;
25662: LD_ADDR_VAR 0 4
25666: PUSH
25667: LD_VAR 0 4
25671: PUSH
25672: LD_VAR 0 8
25676: PUSH
25677: LD_INT 1
25679: ARRAY
25680: DIFF
25681: ST_TO_ADDR
// if tmp and not sci then
25682: LD_VAR 0 4
25686: PUSH
25687: LD_VAR 0 8
25691: NOT
25692: AND
25693: IFFALSE 25762
// begin sort := SortBySkill ( tmp , 4 ) ;
25695: LD_ADDR_VAR 0 9
25699: PUSH
25700: LD_VAR 0 4
25704: PPUSH
25705: LD_INT 4
25707: PPUSH
25708: CALL 83769 0 2
25712: ST_TO_ADDR
// if sort then
25713: LD_VAR 0 9
25717: IFFALSE 25733
// p := sort [ 1 ] ;
25719: LD_ADDR_VAR 0 11
25723: PUSH
25724: LD_VAR 0 9
25728: PUSH
25729: LD_INT 1
25731: ARRAY
25732: ST_TO_ADDR
// if p then
25733: LD_VAR 0 11
25737: IFFALSE 25762
// result := Replace ( result , 4 , p ) ;
25739: LD_ADDR_VAR 0 2
25743: PUSH
25744: LD_VAR 0 2
25748: PPUSH
25749: LD_INT 4
25751: PPUSH
25752: LD_VAR 0 11
25756: PPUSH
25757: CALL_OW 1
25761: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25762: LD_ADDR_VAR 0 4
25766: PUSH
25767: LD_VAR 0 4
25771: PUSH
25772: LD_VAR 0 7
25776: DIFF
25777: ST_TO_ADDR
// if tmp and mech < 6 then
25778: LD_VAR 0 4
25782: PUSH
25783: LD_VAR 0 7
25787: PUSH
25788: LD_INT 6
25790: LESS
25791: AND
25792: IFFALSE 25974
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25794: LD_ADDR_VAR 0 9
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 7
25808: DIFF
25809: PPUSH
25810: LD_INT 3
25812: PPUSH
25813: CALL 83769 0 2
25817: ST_TO_ADDR
// p := [ ] ;
25818: LD_ADDR_VAR 0 11
25822: PUSH
25823: EMPTY
25824: ST_TO_ADDR
// if sort then
25825: LD_VAR 0 9
25829: IFFALSE 25945
// for i = 1 to 6 - mech do
25831: LD_ADDR_VAR 0 3
25835: PUSH
25836: DOUBLE
25837: LD_INT 1
25839: DEC
25840: ST_TO_ADDR
25841: LD_INT 6
25843: PUSH
25844: LD_VAR 0 7
25848: MINUS
25849: PUSH
25850: FOR_TO
25851: IFFALSE 25943
// begin if i = sort then
25853: LD_VAR 0 3
25857: PUSH
25858: LD_VAR 0 9
25862: EQUAL
25863: IFFALSE 25867
// break ;
25865: GO 25943
// if GetClass ( i ) = 3 then
25867: LD_VAR 0 3
25871: PPUSH
25872: CALL_OW 257
25876: PUSH
25877: LD_INT 3
25879: EQUAL
25880: IFFALSE 25884
// continue ;
25882: GO 25850
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25884: LD_ADDR_VAR 0 11
25888: PUSH
25889: LD_VAR 0 11
25893: PPUSH
25894: LD_VAR 0 11
25898: PUSH
25899: LD_INT 1
25901: PLUS
25902: PPUSH
25903: LD_VAR 0 9
25907: PUSH
25908: LD_VAR 0 3
25912: ARRAY
25913: PPUSH
25914: CALL_OW 2
25918: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25919: LD_ADDR_VAR 0 4
25923: PUSH
25924: LD_VAR 0 4
25928: PUSH
25929: LD_VAR 0 9
25933: PUSH
25934: LD_VAR 0 3
25938: ARRAY
25939: DIFF
25940: ST_TO_ADDR
// end ;
25941: GO 25850
25943: POP
25944: POP
// if p then
25945: LD_VAR 0 11
25949: IFFALSE 25974
// result := Replace ( result , 3 , p ) ;
25951: LD_ADDR_VAR 0 2
25955: PUSH
25956: LD_VAR 0 2
25960: PPUSH
25961: LD_INT 3
25963: PPUSH
25964: LD_VAR 0 11
25968: PPUSH
25969: CALL_OW 1
25973: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25974: LD_ADDR_VAR 0 4
25978: PUSH
25979: LD_VAR 0 4
25983: PUSH
25984: LD_VAR 0 6
25988: DIFF
25989: ST_TO_ADDR
// if tmp and eng < 4 then
25990: LD_VAR 0 4
25994: PUSH
25995: LD_VAR 0 6
25999: PUSH
26000: LD_INT 4
26002: LESS
26003: AND
26004: IFFALSE 26194
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26006: LD_ADDR_VAR 0 9
26010: PUSH
26011: LD_VAR 0 4
26015: PUSH
26016: LD_VAR 0 7
26020: PUSH
26021: LD_VAR 0 6
26025: UNION
26026: DIFF
26027: PPUSH
26028: LD_INT 2
26030: PPUSH
26031: CALL 83769 0 2
26035: ST_TO_ADDR
// p := [ ] ;
26036: LD_ADDR_VAR 0 11
26040: PUSH
26041: EMPTY
26042: ST_TO_ADDR
// if sort then
26043: LD_VAR 0 9
26047: IFFALSE 26163
// for i = 1 to 4 - eng do
26049: LD_ADDR_VAR 0 3
26053: PUSH
26054: DOUBLE
26055: LD_INT 1
26057: DEC
26058: ST_TO_ADDR
26059: LD_INT 4
26061: PUSH
26062: LD_VAR 0 6
26066: MINUS
26067: PUSH
26068: FOR_TO
26069: IFFALSE 26161
// begin if i = sort then
26071: LD_VAR 0 3
26075: PUSH
26076: LD_VAR 0 9
26080: EQUAL
26081: IFFALSE 26085
// break ;
26083: GO 26161
// if GetClass ( i ) = 2 then
26085: LD_VAR 0 3
26089: PPUSH
26090: CALL_OW 257
26094: PUSH
26095: LD_INT 2
26097: EQUAL
26098: IFFALSE 26102
// continue ;
26100: GO 26068
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26102: LD_ADDR_VAR 0 11
26106: PUSH
26107: LD_VAR 0 11
26111: PPUSH
26112: LD_VAR 0 11
26116: PUSH
26117: LD_INT 1
26119: PLUS
26120: PPUSH
26121: LD_VAR 0 9
26125: PUSH
26126: LD_VAR 0 3
26130: ARRAY
26131: PPUSH
26132: CALL_OW 2
26136: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26137: LD_ADDR_VAR 0 4
26141: PUSH
26142: LD_VAR 0 4
26146: PUSH
26147: LD_VAR 0 9
26151: PUSH
26152: LD_VAR 0 3
26156: ARRAY
26157: DIFF
26158: ST_TO_ADDR
// end ;
26159: GO 26068
26161: POP
26162: POP
// if p then
26163: LD_VAR 0 11
26167: IFFALSE 26192
// result := Replace ( result , 2 , p ) ;
26169: LD_ADDR_VAR 0 2
26173: PUSH
26174: LD_VAR 0 2
26178: PPUSH
26179: LD_INT 2
26181: PPUSH
26182: LD_VAR 0 11
26186: PPUSH
26187: CALL_OW 1
26191: ST_TO_ADDR
// end else
26192: GO 26238
// for i = eng downto 5 do
26194: LD_ADDR_VAR 0 3
26198: PUSH
26199: DOUBLE
26200: LD_VAR 0 6
26204: INC
26205: ST_TO_ADDR
26206: LD_INT 5
26208: PUSH
26209: FOR_DOWNTO
26210: IFFALSE 26236
// tmp := tmp union eng [ i ] ;
26212: LD_ADDR_VAR 0 4
26216: PUSH
26217: LD_VAR 0 4
26221: PUSH
26222: LD_VAR 0 6
26226: PUSH
26227: LD_VAR 0 3
26231: ARRAY
26232: UNION
26233: ST_TO_ADDR
26234: GO 26209
26236: POP
26237: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26238: LD_ADDR_VAR 0 2
26242: PUSH
26243: LD_VAR 0 2
26247: PPUSH
26248: LD_INT 1
26250: PPUSH
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 5
26260: DIFF
26261: PPUSH
26262: CALL_OW 1
26266: ST_TO_ADDR
// exit ;
26267: GO 26269
// end ; end ;
26269: LD_VAR 0 2
26273: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26274: LD_INT 0
26276: PPUSH
26277: PPUSH
26278: PPUSH
// if not mc_bases then
26279: LD_EXP 50
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 26430
// for i = 1 to mc_bases do
26288: LD_ADDR_VAR 0 2
26292: PUSH
26293: DOUBLE
26294: LD_INT 1
26296: DEC
26297: ST_TO_ADDR
26298: LD_EXP 50
26302: PUSH
26303: FOR_TO
26304: IFFALSE 26421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26306: LD_ADDR_VAR 0 3
26310: PUSH
26311: LD_EXP 50
26315: PUSH
26316: LD_VAR 0 2
26320: ARRAY
26321: PPUSH
26322: LD_INT 21
26324: PUSH
26325: LD_INT 3
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 3
26334: PUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 29
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 30
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 3
26369: PUSH
26370: LD_INT 24
26372: PUSH
26373: LD_INT 1000
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: LIST
26388: PPUSH
26389: CALL_OW 72
26393: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26394: LD_ADDR_EXP 51
26398: PUSH
26399: LD_EXP 51
26403: PPUSH
26404: LD_VAR 0 2
26408: PPUSH
26409: LD_VAR 0 3
26413: PPUSH
26414: CALL_OW 1
26418: ST_TO_ADDR
// end ;
26419: GO 26303
26421: POP
26422: POP
// RaiseSailEvent ( 101 ) ;
26423: LD_INT 101
26425: PPUSH
26426: CALL_OW 427
// end ;
26430: LD_VAR 0 1
26434: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26435: LD_INT 0
26437: PPUSH
26438: PPUSH
26439: PPUSH
26440: PPUSH
26441: PPUSH
26442: PPUSH
26443: PPUSH
// if not mc_bases then
26444: LD_EXP 50
26448: NOT
26449: IFFALSE 26453
// exit ;
26451: GO 27015
// for i = 1 to mc_bases do
26453: LD_ADDR_VAR 0 2
26457: PUSH
26458: DOUBLE
26459: LD_INT 1
26461: DEC
26462: ST_TO_ADDR
26463: LD_EXP 50
26467: PUSH
26468: FOR_TO
26469: IFFALSE 27006
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26471: LD_ADDR_VAR 0 5
26475: PUSH
26476: LD_EXP 50
26480: PUSH
26481: LD_VAR 0 2
26485: ARRAY
26486: PUSH
26487: LD_EXP 79
26491: PUSH
26492: LD_VAR 0 2
26496: ARRAY
26497: UNION
26498: PPUSH
26499: LD_INT 21
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: LD_INT 3
26514: PUSH
26515: LD_INT 54
26517: PUSH
26518: EMPTY
26519: LIST
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 3
26527: PUSH
26528: LD_INT 24
26530: PUSH
26531: LD_INT 1000
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: LIST
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PPUSH
26551: CALL_OW 72
26555: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26556: LD_ADDR_VAR 0 6
26560: PUSH
26561: LD_EXP 50
26565: PUSH
26566: LD_VAR 0 2
26570: ARRAY
26571: PPUSH
26572: LD_INT 21
26574: PUSH
26575: LD_INT 1
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 1
26584: PUSH
26585: LD_INT 3
26587: PUSH
26588: LD_INT 54
26590: PUSH
26591: EMPTY
26592: LIST
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 3
26600: PUSH
26601: LD_INT 24
26603: PUSH
26604: LD_INT 250
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: LIST
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PPUSH
26624: CALL_OW 72
26628: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26629: LD_ADDR_VAR 0 7
26633: PUSH
26634: LD_VAR 0 5
26638: PUSH
26639: LD_VAR 0 6
26643: DIFF
26644: ST_TO_ADDR
// if not need_heal_1 then
26645: LD_VAR 0 6
26649: NOT
26650: IFFALSE 26683
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26652: LD_ADDR_EXP 53
26656: PUSH
26657: LD_EXP 53
26661: PPUSH
26662: LD_VAR 0 2
26666: PUSH
26667: LD_INT 1
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PPUSH
26674: EMPTY
26675: PPUSH
26676: CALL 53565 0 3
26680: ST_TO_ADDR
26681: GO 26753
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26683: LD_ADDR_EXP 53
26687: PUSH
26688: LD_EXP 53
26692: PPUSH
26693: LD_VAR 0 2
26697: PUSH
26698: LD_INT 1
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PPUSH
26705: LD_EXP 53
26709: PUSH
26710: LD_VAR 0 2
26714: ARRAY
26715: PUSH
26716: LD_INT 1
26718: ARRAY
26719: PPUSH
26720: LD_INT 3
26722: PUSH
26723: LD_INT 24
26725: PUSH
26726: LD_INT 1000
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PPUSH
26737: CALL_OW 72
26741: PUSH
26742: LD_VAR 0 6
26746: UNION
26747: PPUSH
26748: CALL 53565 0 3
26752: ST_TO_ADDR
// if not need_heal_2 then
26753: LD_VAR 0 7
26757: NOT
26758: IFFALSE 26791
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26760: LD_ADDR_EXP 53
26764: PUSH
26765: LD_EXP 53
26769: PPUSH
26770: LD_VAR 0 2
26774: PUSH
26775: LD_INT 2
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PPUSH
26782: EMPTY
26783: PPUSH
26784: CALL 53565 0 3
26788: ST_TO_ADDR
26789: GO 26823
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26791: LD_ADDR_EXP 53
26795: PUSH
26796: LD_EXP 53
26800: PPUSH
26801: LD_VAR 0 2
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PPUSH
26813: LD_VAR 0 7
26817: PPUSH
26818: CALL 53565 0 3
26822: ST_TO_ADDR
// if need_heal_2 then
26823: LD_VAR 0 7
26827: IFFALSE 26988
// for j in need_heal_2 do
26829: LD_ADDR_VAR 0 3
26833: PUSH
26834: LD_VAR 0 7
26838: PUSH
26839: FOR_IN
26840: IFFALSE 26986
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26842: LD_ADDR_VAR 0 5
26846: PUSH
26847: LD_EXP 50
26851: PUSH
26852: LD_VAR 0 2
26856: ARRAY
26857: PPUSH
26858: LD_INT 2
26860: PUSH
26861: LD_INT 30
26863: PUSH
26864: LD_INT 6
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 30
26873: PUSH
26874: LD_INT 7
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 30
26883: PUSH
26884: LD_INT 8
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 30
26893: PUSH
26894: LD_INT 0
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 30
26903: PUSH
26904: LD_INT 1
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: PPUSH
26919: CALL_OW 72
26923: ST_TO_ADDR
// if tmp then
26924: LD_VAR 0 5
26928: IFFALSE 26984
// begin k := NearestUnitToUnit ( tmp , j ) ;
26930: LD_ADDR_VAR 0 4
26934: PUSH
26935: LD_VAR 0 5
26939: PPUSH
26940: LD_VAR 0 3
26944: PPUSH
26945: CALL_OW 74
26949: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: CALL_OW 296
26964: PUSH
26965: LD_INT 5
26967: GREATER
26968: IFFALSE 26984
// ComMoveToNearbyEntrance ( j , k ) ;
26970: LD_VAR 0 3
26974: PPUSH
26975: LD_VAR 0 4
26979: PPUSH
26980: CALL 86127 0 2
// end ; end ;
26984: GO 26839
26986: POP
26987: POP
// if not need_heal_1 and not need_heal_2 then
26988: LD_VAR 0 6
26992: NOT
26993: PUSH
26994: LD_VAR 0 7
26998: NOT
26999: AND
27000: IFFALSE 27004
// continue ;
27002: GO 26468
// end ;
27004: GO 26468
27006: POP
27007: POP
// RaiseSailEvent ( 102 ) ;
27008: LD_INT 102
27010: PPUSH
27011: CALL_OW 427
// end ;
27015: LD_VAR 0 1
27019: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27020: LD_INT 0
27022: PPUSH
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
27029: PPUSH
// if not mc_bases then
27030: LD_EXP 50
27034: NOT
27035: IFFALSE 27039
// exit ;
27037: GO 27922
// for i = 1 to mc_bases do
27039: LD_ADDR_VAR 0 2
27043: PUSH
27044: DOUBLE
27045: LD_INT 1
27047: DEC
27048: ST_TO_ADDR
27049: LD_EXP 50
27053: PUSH
27054: FOR_TO
27055: IFFALSE 27920
// begin if not mc_building_need_repair [ i ] then
27057: LD_EXP 51
27061: PUSH
27062: LD_VAR 0 2
27066: ARRAY
27067: NOT
27068: IFFALSE 27255
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27070: LD_ADDR_VAR 0 6
27074: PUSH
27075: LD_EXP 69
27079: PUSH
27080: LD_VAR 0 2
27084: ARRAY
27085: PPUSH
27086: LD_INT 3
27088: PUSH
27089: LD_INT 24
27091: PUSH
27092: LD_INT 1000
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PUSH
27103: LD_INT 2
27105: PUSH
27106: LD_INT 34
27108: PUSH
27109: LD_INT 13
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 34
27118: PUSH
27119: LD_INT 52
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PUSH
27126: LD_INT 34
27128: PUSH
27129: LD_EXP 100
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: LIST
27142: LIST
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PPUSH
27148: CALL_OW 72
27152: ST_TO_ADDR
// if cranes then
27153: LD_VAR 0 6
27157: IFFALSE 27219
// for j in cranes do
27159: LD_ADDR_VAR 0 3
27163: PUSH
27164: LD_VAR 0 6
27168: PUSH
27169: FOR_IN
27170: IFFALSE 27217
// if not IsInArea ( j , mc_parking [ i ] ) then
27172: LD_VAR 0 3
27176: PPUSH
27177: LD_EXP 74
27181: PUSH
27182: LD_VAR 0 2
27186: ARRAY
27187: PPUSH
27188: CALL_OW 308
27192: NOT
27193: IFFALSE 27215
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27195: LD_VAR 0 3
27199: PPUSH
27200: LD_EXP 74
27204: PUSH
27205: LD_VAR 0 2
27209: ARRAY
27210: PPUSH
27211: CALL_OW 113
27215: GO 27169
27217: POP
27218: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27219: LD_ADDR_EXP 52
27223: PUSH
27224: LD_EXP 52
27228: PPUSH
27229: LD_VAR 0 2
27233: PPUSH
27234: EMPTY
27235: PPUSH
27236: CALL_OW 1
27240: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27241: LD_VAR 0 2
27245: PPUSH
27246: LD_INT 101
27248: PPUSH
27249: CALL 22107 0 2
// continue ;
27253: GO 27054
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27255: LD_ADDR_EXP 56
27259: PUSH
27260: LD_EXP 56
27264: PPUSH
27265: LD_VAR 0 2
27269: PPUSH
27270: EMPTY
27271: PPUSH
27272: CALL_OW 1
27276: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27277: LD_VAR 0 2
27281: PPUSH
27282: LD_INT 103
27284: PPUSH
27285: CALL 22107 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27289: LD_ADDR_VAR 0 5
27293: PUSH
27294: LD_EXP 50
27298: PUSH
27299: LD_VAR 0 2
27303: ARRAY
27304: PUSH
27305: LD_EXP 79
27309: PUSH
27310: LD_VAR 0 2
27314: ARRAY
27315: UNION
27316: PPUSH
27317: LD_INT 2
27319: PUSH
27320: LD_INT 25
27322: PUSH
27323: LD_INT 2
27325: PUSH
27326: EMPTY
27327: LIST
27328: LIST
27329: PUSH
27330: LD_INT 25
27332: PUSH
27333: LD_INT 16
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: LIST
27344: PUSH
27345: EMPTY
27346: LIST
27347: PPUSH
27348: CALL_OW 72
27352: ST_TO_ADDR
// if mc_need_heal [ i ] then
27353: LD_EXP 53
27357: PUSH
27358: LD_VAR 0 2
27362: ARRAY
27363: IFFALSE 27407
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27365: LD_ADDR_VAR 0 5
27369: PUSH
27370: LD_VAR 0 5
27374: PUSH
27375: LD_EXP 53
27379: PUSH
27380: LD_VAR 0 2
27384: ARRAY
27385: PUSH
27386: LD_INT 1
27388: ARRAY
27389: PUSH
27390: LD_EXP 53
27394: PUSH
27395: LD_VAR 0 2
27399: ARRAY
27400: PUSH
27401: LD_INT 2
27403: ARRAY
27404: UNION
27405: DIFF
27406: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27407: LD_ADDR_VAR 0 6
27411: PUSH
27412: LD_EXP 69
27416: PUSH
27417: LD_VAR 0 2
27421: ARRAY
27422: PPUSH
27423: LD_INT 2
27425: PUSH
27426: LD_INT 34
27428: PUSH
27429: LD_INT 13
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 34
27438: PUSH
27439: LD_INT 52
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 34
27448: PUSH
27449: LD_EXP 100
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: LIST
27462: LIST
27463: PPUSH
27464: CALL_OW 72
27468: ST_TO_ADDR
// if cranes then
27469: LD_VAR 0 6
27473: IFFALSE 27609
// begin for j in cranes do
27475: LD_ADDR_VAR 0 3
27479: PUSH
27480: LD_VAR 0 6
27484: PUSH
27485: FOR_IN
27486: IFFALSE 27607
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27488: LD_VAR 0 3
27492: PPUSH
27493: CALL_OW 256
27497: PUSH
27498: LD_INT 1000
27500: EQUAL
27501: PUSH
27502: LD_VAR 0 3
27506: PPUSH
27507: CALL_OW 314
27511: NOT
27512: AND
27513: IFFALSE 27547
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27515: LD_VAR 0 3
27519: PPUSH
27520: LD_EXP 51
27524: PUSH
27525: LD_VAR 0 2
27529: ARRAY
27530: PPUSH
27531: LD_VAR 0 3
27535: PPUSH
27536: CALL_OW 74
27540: PPUSH
27541: CALL_OW 130
27545: GO 27605
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27547: LD_VAR 0 3
27551: PPUSH
27552: CALL_OW 256
27556: PUSH
27557: LD_INT 500
27559: LESS
27560: PUSH
27561: LD_VAR 0 3
27565: PPUSH
27566: LD_EXP 74
27570: PUSH
27571: LD_VAR 0 2
27575: ARRAY
27576: PPUSH
27577: CALL_OW 308
27581: NOT
27582: AND
27583: IFFALSE 27605
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27585: LD_VAR 0 3
27589: PPUSH
27590: LD_EXP 74
27594: PUSH
27595: LD_VAR 0 2
27599: ARRAY
27600: PPUSH
27601: CALL_OW 113
// end ;
27605: GO 27485
27607: POP
27608: POP
// end ; if tmp > 3 then
27609: LD_VAR 0 5
27613: PUSH
27614: LD_INT 3
27616: GREATER
27617: IFFALSE 27637
// tmp := ShrinkArray ( tmp , 4 ) ;
27619: LD_ADDR_VAR 0 5
27623: PUSH
27624: LD_VAR 0 5
27628: PPUSH
27629: LD_INT 4
27631: PPUSH
27632: CALL 85575 0 2
27636: ST_TO_ADDR
// if not tmp then
27637: LD_VAR 0 5
27641: NOT
27642: IFFALSE 27646
// continue ;
27644: GO 27054
// for j in tmp do
27646: LD_ADDR_VAR 0 3
27650: PUSH
27651: LD_VAR 0 5
27655: PUSH
27656: FOR_IN
27657: IFFALSE 27916
// begin if IsInUnit ( j ) then
27659: LD_VAR 0 3
27663: PPUSH
27664: CALL_OW 310
27668: IFFALSE 27679
// ComExitBuilding ( j ) ;
27670: LD_VAR 0 3
27674: PPUSH
27675: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27679: LD_VAR 0 3
27683: PUSH
27684: LD_EXP 52
27688: PUSH
27689: LD_VAR 0 2
27693: ARRAY
27694: IN
27695: NOT
27696: IFFALSE 27754
// begin SetTag ( j , 101 ) ;
27698: LD_VAR 0 3
27702: PPUSH
27703: LD_INT 101
27705: PPUSH
27706: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27710: LD_ADDR_EXP 52
27714: PUSH
27715: LD_EXP 52
27719: PPUSH
27720: LD_VAR 0 2
27724: PUSH
27725: LD_EXP 52
27729: PUSH
27730: LD_VAR 0 2
27734: ARRAY
27735: PUSH
27736: LD_INT 1
27738: PLUS
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PPUSH
27744: LD_VAR 0 3
27748: PPUSH
27749: CALL 53565 0 3
27753: ST_TO_ADDR
// end ; wait ( 1 ) ;
27754: LD_INT 1
27756: PPUSH
27757: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27761: LD_ADDR_VAR 0 7
27765: PUSH
27766: LD_EXP 51
27770: PUSH
27771: LD_VAR 0 2
27775: ARRAY
27776: ST_TO_ADDR
// if mc_scan [ i ] then
27777: LD_EXP 73
27781: PUSH
27782: LD_VAR 0 2
27786: ARRAY
27787: IFFALSE 27849
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27789: LD_ADDR_VAR 0 7
27793: PUSH
27794: LD_EXP 51
27798: PUSH
27799: LD_VAR 0 2
27803: ARRAY
27804: PPUSH
27805: LD_INT 3
27807: PUSH
27808: LD_INT 30
27810: PUSH
27811: LD_INT 32
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 30
27820: PUSH
27821: LD_INT 33
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 30
27830: PUSH
27831: LD_INT 31
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: PPUSH
27844: CALL_OW 72
27848: ST_TO_ADDR
// if not to_repair_tmp then
27849: LD_VAR 0 7
27853: NOT
27854: IFFALSE 27858
// continue ;
27856: GO 27656
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27858: LD_ADDR_VAR 0 8
27862: PUSH
27863: LD_VAR 0 7
27867: PPUSH
27868: LD_VAR 0 3
27872: PPUSH
27873: CALL_OW 74
27877: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27878: LD_VAR 0 8
27882: PPUSH
27883: LD_INT 16
27885: PPUSH
27886: CALL 56164 0 2
27890: PUSH
27891: LD_INT 4
27893: ARRAY
27894: PUSH
27895: LD_INT 10
27897: LESS
27898: IFFALSE 27914
// ComRepairBuilding ( j , to_repair ) ;
27900: LD_VAR 0 3
27904: PPUSH
27905: LD_VAR 0 8
27909: PPUSH
27910: CALL_OW 130
// end ;
27914: GO 27656
27916: POP
27917: POP
// end ;
27918: GO 27054
27920: POP
27921: POP
// end ;
27922: LD_VAR 0 1
27926: RET
// export function MC_Heal ; var i , j , tmp ; begin
27927: LD_INT 0
27929: PPUSH
27930: PPUSH
27931: PPUSH
27932: PPUSH
// if not mc_bases then
27933: LD_EXP 50
27937: NOT
27938: IFFALSE 27942
// exit ;
27940: GO 28344
// for i = 1 to mc_bases do
27942: LD_ADDR_VAR 0 2
27946: PUSH
27947: DOUBLE
27948: LD_INT 1
27950: DEC
27951: ST_TO_ADDR
27952: LD_EXP 50
27956: PUSH
27957: FOR_TO
27958: IFFALSE 28342
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27960: LD_EXP 53
27964: PUSH
27965: LD_VAR 0 2
27969: ARRAY
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: NOT
27975: PUSH
27976: LD_EXP 53
27980: PUSH
27981: LD_VAR 0 2
27985: ARRAY
27986: PUSH
27987: LD_INT 2
27989: ARRAY
27990: NOT
27991: AND
27992: IFFALSE 28030
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27994: LD_ADDR_EXP 54
27998: PUSH
27999: LD_EXP 54
28003: PPUSH
28004: LD_VAR 0 2
28008: PPUSH
28009: EMPTY
28010: PPUSH
28011: CALL_OW 1
28015: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28016: LD_VAR 0 2
28020: PPUSH
28021: LD_INT 102
28023: PPUSH
28024: CALL 22107 0 2
// continue ;
28028: GO 27957
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28030: LD_ADDR_VAR 0 4
28034: PUSH
28035: LD_EXP 50
28039: PUSH
28040: LD_VAR 0 2
28044: ARRAY
28045: PPUSH
28046: LD_INT 25
28048: PUSH
28049: LD_INT 4
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PPUSH
28056: CALL_OW 72
28060: ST_TO_ADDR
// if not tmp then
28061: LD_VAR 0 4
28065: NOT
28066: IFFALSE 28070
// continue ;
28068: GO 27957
// if mc_taming [ i ] then
28070: LD_EXP 81
28074: PUSH
28075: LD_VAR 0 2
28079: ARRAY
28080: IFFALSE 28104
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28082: LD_ADDR_EXP 81
28086: PUSH
28087: LD_EXP 81
28091: PPUSH
28092: LD_VAR 0 2
28096: PPUSH
28097: EMPTY
28098: PPUSH
28099: CALL_OW 1
28103: ST_TO_ADDR
// for j in tmp do
28104: LD_ADDR_VAR 0 3
28108: PUSH
28109: LD_VAR 0 4
28113: PUSH
28114: FOR_IN
28115: IFFALSE 28338
// begin if IsInUnit ( j ) then
28117: LD_VAR 0 3
28121: PPUSH
28122: CALL_OW 310
28126: IFFALSE 28137
// ComExitBuilding ( j ) ;
28128: LD_VAR 0 3
28132: PPUSH
28133: CALL_OW 122
// if not j in mc_healers [ i ] then
28137: LD_VAR 0 3
28141: PUSH
28142: LD_EXP 54
28146: PUSH
28147: LD_VAR 0 2
28151: ARRAY
28152: IN
28153: NOT
28154: IFFALSE 28200
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28156: LD_ADDR_EXP 54
28160: PUSH
28161: LD_EXP 54
28165: PPUSH
28166: LD_VAR 0 2
28170: PUSH
28171: LD_EXP 54
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: PUSH
28182: LD_INT 1
28184: PLUS
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PPUSH
28190: LD_VAR 0 3
28194: PPUSH
28195: CALL 53565 0 3
28199: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28200: LD_VAR 0 3
28204: PPUSH
28205: CALL_OW 110
28209: PUSH
28210: LD_INT 102
28212: NONEQUAL
28213: IFFALSE 28227
// SetTag ( j , 102 ) ;
28215: LD_VAR 0 3
28219: PPUSH
28220: LD_INT 102
28222: PPUSH
28223: CALL_OW 109
// Wait ( 3 ) ;
28227: LD_INT 3
28229: PPUSH
28230: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28234: LD_EXP 53
28238: PUSH
28239: LD_VAR 0 2
28243: ARRAY
28244: PUSH
28245: LD_INT 1
28247: ARRAY
28248: IFFALSE 28280
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28250: LD_VAR 0 3
28254: PPUSH
28255: LD_EXP 53
28259: PUSH
28260: LD_VAR 0 2
28264: ARRAY
28265: PUSH
28266: LD_INT 1
28268: ARRAY
28269: PUSH
28270: LD_INT 1
28272: ARRAY
28273: PPUSH
28274: CALL_OW 128
28278: GO 28336
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28280: LD_VAR 0 3
28284: PPUSH
28285: CALL_OW 314
28289: NOT
28290: PUSH
28291: LD_EXP 53
28295: PUSH
28296: LD_VAR 0 2
28300: ARRAY
28301: PUSH
28302: LD_INT 2
28304: ARRAY
28305: AND
28306: IFFALSE 28336
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28308: LD_VAR 0 3
28312: PPUSH
28313: LD_EXP 53
28317: PUSH
28318: LD_VAR 0 2
28322: ARRAY
28323: PUSH
28324: LD_INT 2
28326: ARRAY
28327: PUSH
28328: LD_INT 1
28330: ARRAY
28331: PPUSH
28332: CALL_OW 128
// end ;
28336: GO 28114
28338: POP
28339: POP
// end ;
28340: GO 27957
28342: POP
28343: POP
// end ;
28344: LD_VAR 0 1
28348: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28349: LD_INT 0
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
// if not mc_bases then
28356: LD_EXP 50
28360: NOT
28361: IFFALSE 28365
// exit ;
28363: GO 29536
// for i = 1 to mc_bases do
28365: LD_ADDR_VAR 0 2
28369: PUSH
28370: DOUBLE
28371: LD_INT 1
28373: DEC
28374: ST_TO_ADDR
28375: LD_EXP 50
28379: PUSH
28380: FOR_TO
28381: IFFALSE 29534
// begin if mc_scan [ i ] then
28383: LD_EXP 73
28387: PUSH
28388: LD_VAR 0 2
28392: ARRAY
28393: IFFALSE 28397
// continue ;
28395: GO 28380
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28397: LD_EXP 55
28401: PUSH
28402: LD_VAR 0 2
28406: ARRAY
28407: NOT
28408: PUSH
28409: LD_EXP 57
28413: PUSH
28414: LD_VAR 0 2
28418: ARRAY
28419: NOT
28420: AND
28421: PUSH
28422: LD_EXP 56
28426: PUSH
28427: LD_VAR 0 2
28431: ARRAY
28432: AND
28433: IFFALSE 28471
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28435: LD_ADDR_EXP 56
28439: PUSH
28440: LD_EXP 56
28444: PPUSH
28445: LD_VAR 0 2
28449: PPUSH
28450: EMPTY
28451: PPUSH
28452: CALL_OW 1
28456: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28457: LD_VAR 0 2
28461: PPUSH
28462: LD_INT 103
28464: PPUSH
28465: CALL 22107 0 2
// continue ;
28469: GO 28380
// end ; if mc_construct_list [ i ] then
28471: LD_EXP 57
28475: PUSH
28476: LD_VAR 0 2
28480: ARRAY
28481: IFFALSE 28701
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28483: LD_ADDR_VAR 0 4
28487: PUSH
28488: LD_EXP 50
28492: PUSH
28493: LD_VAR 0 2
28497: ARRAY
28498: PPUSH
28499: LD_INT 25
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PPUSH
28509: CALL_OW 72
28513: PUSH
28514: LD_EXP 52
28518: PUSH
28519: LD_VAR 0 2
28523: ARRAY
28524: DIFF
28525: ST_TO_ADDR
// if not tmp then
28526: LD_VAR 0 4
28530: NOT
28531: IFFALSE 28535
// continue ;
28533: GO 28380
// for j in tmp do
28535: LD_ADDR_VAR 0 3
28539: PUSH
28540: LD_VAR 0 4
28544: PUSH
28545: FOR_IN
28546: IFFALSE 28697
// begin if not mc_builders [ i ] then
28548: LD_EXP 56
28552: PUSH
28553: LD_VAR 0 2
28557: ARRAY
28558: NOT
28559: IFFALSE 28617
// begin SetTag ( j , 103 ) ;
28561: LD_VAR 0 3
28565: PPUSH
28566: LD_INT 103
28568: PPUSH
28569: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28573: LD_ADDR_EXP 56
28577: PUSH
28578: LD_EXP 56
28582: PPUSH
28583: LD_VAR 0 2
28587: PUSH
28588: LD_EXP 56
28592: PUSH
28593: LD_VAR 0 2
28597: ARRAY
28598: PUSH
28599: LD_INT 1
28601: PLUS
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PPUSH
28607: LD_VAR 0 3
28611: PPUSH
28612: CALL 53565 0 3
28616: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28617: LD_VAR 0 3
28621: PPUSH
28622: CALL_OW 310
28626: IFFALSE 28637
// ComExitBuilding ( j ) ;
28628: LD_VAR 0 3
28632: PPUSH
28633: CALL_OW 122
// wait ( 3 ) ;
28637: LD_INT 3
28639: PPUSH
28640: CALL_OW 67
// if not mc_construct_list [ i ] then
28644: LD_EXP 57
28648: PUSH
28649: LD_VAR 0 2
28653: ARRAY
28654: NOT
28655: IFFALSE 28659
// break ;
28657: GO 28697
// if not HasTask ( j ) then
28659: LD_VAR 0 3
28663: PPUSH
28664: CALL_OW 314
28668: NOT
28669: IFFALSE 28695
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28671: LD_VAR 0 3
28675: PPUSH
28676: LD_EXP 57
28680: PUSH
28681: LD_VAR 0 2
28685: ARRAY
28686: PUSH
28687: LD_INT 1
28689: ARRAY
28690: PPUSH
28691: CALL 56428 0 2
// end ;
28695: GO 28545
28697: POP
28698: POP
// end else
28699: GO 29532
// if mc_build_list [ i ] then
28701: LD_EXP 55
28705: PUSH
28706: LD_VAR 0 2
28710: ARRAY
28711: IFFALSE 29532
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28713: LD_ADDR_VAR 0 5
28717: PUSH
28718: LD_EXP 50
28722: PUSH
28723: LD_VAR 0 2
28727: ARRAY
28728: PPUSH
28729: LD_INT 2
28731: PUSH
28732: LD_INT 30
28734: PUSH
28735: LD_INT 0
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 30
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: PPUSH
28757: CALL_OW 72
28761: ST_TO_ADDR
// if depot then
28762: LD_VAR 0 5
28766: IFFALSE 28784
// depot := depot [ 1 ] else
28768: LD_ADDR_VAR 0 5
28772: PUSH
28773: LD_VAR 0 5
28777: PUSH
28778: LD_INT 1
28780: ARRAY
28781: ST_TO_ADDR
28782: GO 28792
// depot := 0 ;
28784: LD_ADDR_VAR 0 5
28788: PUSH
28789: LD_INT 0
28791: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28792: LD_EXP 55
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 1
28805: ARRAY
28806: PUSH
28807: LD_INT 1
28809: ARRAY
28810: PPUSH
28811: CALL 56252 0 1
28815: PUSH
28816: LD_EXP 50
28820: PUSH
28821: LD_VAR 0 2
28825: ARRAY
28826: PPUSH
28827: LD_INT 2
28829: PUSH
28830: LD_INT 30
28832: PUSH
28833: LD_INT 2
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 30
28842: PUSH
28843: LD_INT 3
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: LIST
28854: PPUSH
28855: CALL_OW 72
28859: NOT
28860: AND
28861: IFFALSE 28966
// begin for j = 1 to mc_build_list [ i ] do
28863: LD_ADDR_VAR 0 3
28867: PUSH
28868: DOUBLE
28869: LD_INT 1
28871: DEC
28872: ST_TO_ADDR
28873: LD_EXP 55
28877: PUSH
28878: LD_VAR 0 2
28882: ARRAY
28883: PUSH
28884: FOR_TO
28885: IFFALSE 28964
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28887: LD_EXP 55
28891: PUSH
28892: LD_VAR 0 2
28896: ARRAY
28897: PUSH
28898: LD_VAR 0 3
28902: ARRAY
28903: PUSH
28904: LD_INT 1
28906: ARRAY
28907: PUSH
28908: LD_INT 2
28910: EQUAL
28911: IFFALSE 28962
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28913: LD_ADDR_EXP 55
28917: PUSH
28918: LD_EXP 55
28922: PPUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_EXP 55
28932: PUSH
28933: LD_VAR 0 2
28937: ARRAY
28938: PPUSH
28939: LD_VAR 0 3
28943: PPUSH
28944: LD_INT 1
28946: PPUSH
28947: LD_INT 0
28949: PPUSH
28950: CALL 52983 0 4
28954: PPUSH
28955: CALL_OW 1
28959: ST_TO_ADDR
// break ;
28960: GO 28964
// end ;
28962: GO 28884
28964: POP
28965: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28966: LD_EXP 55
28970: PUSH
28971: LD_VAR 0 2
28975: ARRAY
28976: PUSH
28977: LD_INT 1
28979: ARRAY
28980: PUSH
28981: LD_INT 1
28983: ARRAY
28984: PUSH
28985: LD_INT 0
28987: EQUAL
28988: PUSH
28989: LD_VAR 0 5
28993: PUSH
28994: LD_VAR 0 5
28998: PPUSH
28999: LD_EXP 55
29003: PUSH
29004: LD_VAR 0 2
29008: ARRAY
29009: PUSH
29010: LD_INT 1
29012: ARRAY
29013: PUSH
29014: LD_INT 1
29016: ARRAY
29017: PPUSH
29018: LD_EXP 55
29022: PUSH
29023: LD_VAR 0 2
29027: ARRAY
29028: PUSH
29029: LD_INT 1
29031: ARRAY
29032: PUSH
29033: LD_INT 2
29035: ARRAY
29036: PPUSH
29037: LD_EXP 55
29041: PUSH
29042: LD_VAR 0 2
29046: ARRAY
29047: PUSH
29048: LD_INT 1
29050: ARRAY
29051: PUSH
29052: LD_INT 3
29054: ARRAY
29055: PPUSH
29056: LD_EXP 55
29060: PUSH
29061: LD_VAR 0 2
29065: ARRAY
29066: PUSH
29067: LD_INT 1
29069: ARRAY
29070: PUSH
29071: LD_INT 4
29073: ARRAY
29074: PPUSH
29075: CALL 61668 0 5
29079: AND
29080: OR
29081: IFFALSE 29362
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29083: LD_ADDR_VAR 0 4
29087: PUSH
29088: LD_EXP 50
29092: PUSH
29093: LD_VAR 0 2
29097: ARRAY
29098: PPUSH
29099: LD_INT 25
29101: PUSH
29102: LD_INT 2
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: CALL_OW 72
29113: PUSH
29114: LD_EXP 52
29118: PUSH
29119: LD_VAR 0 2
29123: ARRAY
29124: DIFF
29125: ST_TO_ADDR
// if not tmp then
29126: LD_VAR 0 4
29130: NOT
29131: IFFALSE 29135
// continue ;
29133: GO 28380
// for j in tmp do
29135: LD_ADDR_VAR 0 3
29139: PUSH
29140: LD_VAR 0 4
29144: PUSH
29145: FOR_IN
29146: IFFALSE 29358
// begin if not mc_builders [ i ] then
29148: LD_EXP 56
29152: PUSH
29153: LD_VAR 0 2
29157: ARRAY
29158: NOT
29159: IFFALSE 29217
// begin SetTag ( j , 103 ) ;
29161: LD_VAR 0 3
29165: PPUSH
29166: LD_INT 103
29168: PPUSH
29169: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29173: LD_ADDR_EXP 56
29177: PUSH
29178: LD_EXP 56
29182: PPUSH
29183: LD_VAR 0 2
29187: PUSH
29188: LD_EXP 56
29192: PUSH
29193: LD_VAR 0 2
29197: ARRAY
29198: PUSH
29199: LD_INT 1
29201: PLUS
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PPUSH
29207: LD_VAR 0 3
29211: PPUSH
29212: CALL 53565 0 3
29216: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29217: LD_VAR 0 3
29221: PPUSH
29222: CALL_OW 310
29226: IFFALSE 29237
// ComExitBuilding ( j ) ;
29228: LD_VAR 0 3
29232: PPUSH
29233: CALL_OW 122
// wait ( 3 ) ;
29237: LD_INT 3
29239: PPUSH
29240: CALL_OW 67
// if not mc_build_list [ i ] then
29244: LD_EXP 55
29248: PUSH
29249: LD_VAR 0 2
29253: ARRAY
29254: NOT
29255: IFFALSE 29259
// break ;
29257: GO 29358
// if not HasTask ( j ) then
29259: LD_VAR 0 3
29263: PPUSH
29264: CALL_OW 314
29268: NOT
29269: IFFALSE 29356
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29271: LD_VAR 0 3
29275: PPUSH
29276: LD_EXP 55
29280: PUSH
29281: LD_VAR 0 2
29285: ARRAY
29286: PUSH
29287: LD_INT 1
29289: ARRAY
29290: PUSH
29291: LD_INT 1
29293: ARRAY
29294: PPUSH
29295: LD_EXP 55
29299: PUSH
29300: LD_VAR 0 2
29304: ARRAY
29305: PUSH
29306: LD_INT 1
29308: ARRAY
29309: PUSH
29310: LD_INT 2
29312: ARRAY
29313: PPUSH
29314: LD_EXP 55
29318: PUSH
29319: LD_VAR 0 2
29323: ARRAY
29324: PUSH
29325: LD_INT 1
29327: ARRAY
29328: PUSH
29329: LD_INT 3
29331: ARRAY
29332: PPUSH
29333: LD_EXP 55
29337: PUSH
29338: LD_VAR 0 2
29342: ARRAY
29343: PUSH
29344: LD_INT 1
29346: ARRAY
29347: PUSH
29348: LD_INT 4
29350: ARRAY
29351: PPUSH
29352: CALL_OW 145
// end ;
29356: GO 29145
29358: POP
29359: POP
// end else
29360: GO 29532
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29362: LD_EXP 50
29366: PUSH
29367: LD_VAR 0 2
29371: ARRAY
29372: PPUSH
29373: LD_EXP 55
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: PUSH
29384: LD_INT 1
29386: ARRAY
29387: PUSH
29388: LD_INT 1
29390: ARRAY
29391: PPUSH
29392: LD_EXP 55
29396: PUSH
29397: LD_VAR 0 2
29401: ARRAY
29402: PUSH
29403: LD_INT 1
29405: ARRAY
29406: PUSH
29407: LD_INT 2
29409: ARRAY
29410: PPUSH
29411: LD_EXP 55
29415: PUSH
29416: LD_VAR 0 2
29420: ARRAY
29421: PUSH
29422: LD_INT 1
29424: ARRAY
29425: PUSH
29426: LD_INT 3
29428: ARRAY
29429: PPUSH
29430: LD_EXP 55
29434: PUSH
29435: LD_VAR 0 2
29439: ARRAY
29440: PUSH
29441: LD_INT 1
29443: ARRAY
29444: PUSH
29445: LD_INT 4
29447: ARRAY
29448: PPUSH
29449: LD_EXP 50
29453: PUSH
29454: LD_VAR 0 2
29458: ARRAY
29459: PPUSH
29460: LD_INT 21
29462: PUSH
29463: LD_INT 3
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PPUSH
29470: CALL_OW 72
29474: PPUSH
29475: EMPTY
29476: PPUSH
29477: CALL 60418 0 7
29481: NOT
29482: IFFALSE 29532
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29484: LD_ADDR_EXP 55
29488: PUSH
29489: LD_EXP 55
29493: PPUSH
29494: LD_VAR 0 2
29498: PPUSH
29499: LD_EXP 55
29503: PUSH
29504: LD_VAR 0 2
29508: ARRAY
29509: PPUSH
29510: LD_INT 1
29512: PPUSH
29513: LD_INT 1
29515: NEG
29516: PPUSH
29517: LD_INT 0
29519: PPUSH
29520: CALL 52983 0 4
29524: PPUSH
29525: CALL_OW 1
29529: ST_TO_ADDR
// continue ;
29530: GO 28380
// end ; end ; end ;
29532: GO 28380
29534: POP
29535: POP
// end ;
29536: LD_VAR 0 1
29540: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29541: LD_INT 0
29543: PPUSH
29544: PPUSH
29545: PPUSH
29546: PPUSH
29547: PPUSH
29548: PPUSH
// if not mc_bases then
29549: LD_EXP 50
29553: NOT
29554: IFFALSE 29558
// exit ;
29556: GO 29985
// for i = 1 to mc_bases do
29558: LD_ADDR_VAR 0 2
29562: PUSH
29563: DOUBLE
29564: LD_INT 1
29566: DEC
29567: ST_TO_ADDR
29568: LD_EXP 50
29572: PUSH
29573: FOR_TO
29574: IFFALSE 29983
// begin tmp := mc_build_upgrade [ i ] ;
29576: LD_ADDR_VAR 0 4
29580: PUSH
29581: LD_EXP 82
29585: PUSH
29586: LD_VAR 0 2
29590: ARRAY
29591: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29592: LD_ADDR_VAR 0 6
29596: PUSH
29597: LD_EXP 83
29601: PUSH
29602: LD_VAR 0 2
29606: ARRAY
29607: PPUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 30
29613: PUSH
29614: LD_INT 6
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 30
29623: PUSH
29624: LD_INT 7
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: LIST
29635: PPUSH
29636: CALL_OW 72
29640: ST_TO_ADDR
// if not tmp and not lab then
29641: LD_VAR 0 4
29645: NOT
29646: PUSH
29647: LD_VAR 0 6
29651: NOT
29652: AND
29653: IFFALSE 29657
// continue ;
29655: GO 29573
// if tmp then
29657: LD_VAR 0 4
29661: IFFALSE 29781
// for j in tmp do
29663: LD_ADDR_VAR 0 3
29667: PUSH
29668: LD_VAR 0 4
29672: PUSH
29673: FOR_IN
29674: IFFALSE 29779
// begin if UpgradeCost ( j ) then
29676: LD_VAR 0 3
29680: PPUSH
29681: CALL 60078 0 1
29685: IFFALSE 29777
// begin ComUpgrade ( j ) ;
29687: LD_VAR 0 3
29691: PPUSH
29692: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29696: LD_ADDR_EXP 82
29700: PUSH
29701: LD_EXP 82
29705: PPUSH
29706: LD_VAR 0 2
29710: PPUSH
29711: LD_EXP 82
29715: PUSH
29716: LD_VAR 0 2
29720: ARRAY
29721: PUSH
29722: LD_VAR 0 3
29726: DIFF
29727: PPUSH
29728: CALL_OW 1
29732: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29733: LD_ADDR_EXP 57
29737: PUSH
29738: LD_EXP 57
29742: PPUSH
29743: LD_VAR 0 2
29747: PUSH
29748: LD_EXP 57
29752: PUSH
29753: LD_VAR 0 2
29757: ARRAY
29758: PUSH
29759: LD_INT 1
29761: PLUS
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PPUSH
29767: LD_VAR 0 3
29771: PPUSH
29772: CALL 53565 0 3
29776: ST_TO_ADDR
// end ; end ;
29777: GO 29673
29779: POP
29780: POP
// if not lab or not mc_lab_upgrade [ i ] then
29781: LD_VAR 0 6
29785: NOT
29786: PUSH
29787: LD_EXP 84
29791: PUSH
29792: LD_VAR 0 2
29796: ARRAY
29797: NOT
29798: OR
29799: IFFALSE 29803
// continue ;
29801: GO 29573
// for j in lab do
29803: LD_ADDR_VAR 0 3
29807: PUSH
29808: LD_VAR 0 6
29812: PUSH
29813: FOR_IN
29814: IFFALSE 29979
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29816: LD_VAR 0 3
29820: PPUSH
29821: CALL_OW 266
29825: PUSH
29826: LD_INT 6
29828: PUSH
29829: LD_INT 7
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: IN
29836: PUSH
29837: LD_VAR 0 3
29841: PPUSH
29842: CALL_OW 461
29846: PUSH
29847: LD_INT 1
29849: NONEQUAL
29850: AND
29851: IFFALSE 29977
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29853: LD_VAR 0 3
29857: PPUSH
29858: LD_EXP 84
29862: PUSH
29863: LD_VAR 0 2
29867: ARRAY
29868: PUSH
29869: LD_INT 1
29871: ARRAY
29872: PPUSH
29873: CALL 60283 0 2
29877: IFFALSE 29977
// begin ComCancel ( j ) ;
29879: LD_VAR 0 3
29883: PPUSH
29884: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29888: LD_VAR 0 3
29892: PPUSH
29893: LD_EXP 84
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: PUSH
29904: LD_INT 1
29906: ARRAY
29907: PPUSH
29908: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29912: LD_VAR 0 3
29916: PUSH
29917: LD_EXP 57
29921: PUSH
29922: LD_VAR 0 2
29926: ARRAY
29927: IN
29928: NOT
29929: IFFALSE 29975
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29931: LD_ADDR_EXP 57
29935: PUSH
29936: LD_EXP 57
29940: PPUSH
29941: LD_VAR 0 2
29945: PUSH
29946: LD_EXP 57
29950: PUSH
29951: LD_VAR 0 2
29955: ARRAY
29956: PUSH
29957: LD_INT 1
29959: PLUS
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PPUSH
29965: LD_VAR 0 3
29969: PPUSH
29970: CALL 53565 0 3
29974: ST_TO_ADDR
// break ;
29975: GO 29979
// end ; end ; end ;
29977: GO 29813
29979: POP
29980: POP
// end ;
29981: GO 29573
29983: POP
29984: POP
// end ;
29985: LD_VAR 0 1
29989: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29990: LD_INT 0
29992: PPUSH
29993: PPUSH
29994: PPUSH
29995: PPUSH
29996: PPUSH
29997: PPUSH
29998: PPUSH
29999: PPUSH
30000: PPUSH
// if not mc_bases then
30001: LD_EXP 50
30005: NOT
30006: IFFALSE 30010
// exit ;
30008: GO 30415
// for i = 1 to mc_bases do
30010: LD_ADDR_VAR 0 2
30014: PUSH
30015: DOUBLE
30016: LD_INT 1
30018: DEC
30019: ST_TO_ADDR
30020: LD_EXP 50
30024: PUSH
30025: FOR_TO
30026: IFFALSE 30413
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30028: LD_EXP 58
30032: PUSH
30033: LD_VAR 0 2
30037: ARRAY
30038: NOT
30039: PUSH
30040: LD_EXP 50
30044: PUSH
30045: LD_VAR 0 2
30049: ARRAY
30050: PPUSH
30051: LD_INT 30
30053: PUSH
30054: LD_INT 3
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PPUSH
30061: CALL_OW 72
30065: NOT
30066: OR
30067: IFFALSE 30071
// continue ;
30069: GO 30025
// busy := false ;
30071: LD_ADDR_VAR 0 8
30075: PUSH
30076: LD_INT 0
30078: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30079: LD_ADDR_VAR 0 4
30083: PUSH
30084: LD_EXP 50
30088: PUSH
30089: LD_VAR 0 2
30093: ARRAY
30094: PPUSH
30095: LD_INT 30
30097: PUSH
30098: LD_INT 3
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PPUSH
30105: CALL_OW 72
30109: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30110: LD_ADDR_VAR 0 6
30114: PUSH
30115: LD_EXP 58
30119: PUSH
30120: LD_VAR 0 2
30124: ARRAY
30125: PPUSH
30126: LD_INT 2
30128: PUSH
30129: LD_INT 30
30131: PUSH
30132: LD_INT 32
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 30
30141: PUSH
30142: LD_INT 33
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: PPUSH
30154: CALL_OW 72
30158: ST_TO_ADDR
// if not t then
30159: LD_VAR 0 6
30163: NOT
30164: IFFALSE 30168
// continue ;
30166: GO 30025
// for j in tmp do
30168: LD_ADDR_VAR 0 3
30172: PUSH
30173: LD_VAR 0 4
30177: PUSH
30178: FOR_IN
30179: IFFALSE 30209
// if not BuildingStatus ( j ) = bs_idle then
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 461
30190: PUSH
30191: LD_INT 2
30193: EQUAL
30194: NOT
30195: IFFALSE 30207
// begin busy := true ;
30197: LD_ADDR_VAR 0 8
30201: PUSH
30202: LD_INT 1
30204: ST_TO_ADDR
// break ;
30205: GO 30209
// end ;
30207: GO 30178
30209: POP
30210: POP
// if busy then
30211: LD_VAR 0 8
30215: IFFALSE 30219
// continue ;
30217: GO 30025
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30219: LD_ADDR_VAR 0 7
30223: PUSH
30224: LD_VAR 0 6
30228: PPUSH
30229: LD_INT 35
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PPUSH
30239: CALL_OW 72
30243: ST_TO_ADDR
// if tw then
30244: LD_VAR 0 7
30248: IFFALSE 30325
// begin tw := tw [ 1 ] ;
30250: LD_ADDR_VAR 0 7
30254: PUSH
30255: LD_VAR 0 7
30259: PUSH
30260: LD_INT 1
30262: ARRAY
30263: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30264: LD_ADDR_VAR 0 9
30268: PUSH
30269: LD_VAR 0 7
30273: PPUSH
30274: LD_EXP 75
30278: PUSH
30279: LD_VAR 0 2
30283: ARRAY
30284: PPUSH
30285: CALL 58575 0 2
30289: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30290: LD_EXP 89
30294: PUSH
30295: LD_VAR 0 2
30299: ARRAY
30300: IFFALSE 30323
// if not weapon in mc_allowed_tower_weapons [ i ] then
30302: LD_VAR 0 9
30306: PUSH
30307: LD_EXP 89
30311: PUSH
30312: LD_VAR 0 2
30316: ARRAY
30317: IN
30318: NOT
30319: IFFALSE 30323
// continue ;
30321: GO 30025
// end else
30323: GO 30388
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30325: LD_ADDR_VAR 0 5
30329: PUSH
30330: LD_EXP 58
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: PPUSH
30341: LD_VAR 0 4
30345: PPUSH
30346: CALL 84808 0 2
30350: ST_TO_ADDR
// if not tmp2 then
30351: LD_VAR 0 5
30355: NOT
30356: IFFALSE 30360
// continue ;
30358: GO 30025
// tw := tmp2 [ 1 ] ;
30360: LD_ADDR_VAR 0 7
30364: PUSH
30365: LD_VAR 0 5
30369: PUSH
30370: LD_INT 1
30372: ARRAY
30373: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30374: LD_ADDR_VAR 0 9
30378: PUSH
30379: LD_VAR 0 5
30383: PUSH
30384: LD_INT 2
30386: ARRAY
30387: ST_TO_ADDR
// end ; if not weapon then
30388: LD_VAR 0 9
30392: NOT
30393: IFFALSE 30397
// continue ;
30395: GO 30025
// ComPlaceWeapon ( tw , weapon ) ;
30397: LD_VAR 0 7
30401: PPUSH
30402: LD_VAR 0 9
30406: PPUSH
30407: CALL_OW 148
// end ;
30411: GO 30025
30413: POP
30414: POP
// end ;
30415: LD_VAR 0 1
30419: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30420: LD_INT 0
30422: PPUSH
30423: PPUSH
30424: PPUSH
30425: PPUSH
30426: PPUSH
30427: PPUSH
30428: PPUSH
// if not mc_bases then
30429: LD_EXP 50
30433: NOT
30434: IFFALSE 30438
// exit ;
30436: GO 31206
// for i = 1 to mc_bases do
30438: LD_ADDR_VAR 0 2
30442: PUSH
30443: DOUBLE
30444: LD_INT 1
30446: DEC
30447: ST_TO_ADDR
30448: LD_EXP 50
30452: PUSH
30453: FOR_TO
30454: IFFALSE 31204
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30456: LD_EXP 63
30460: PUSH
30461: LD_VAR 0 2
30465: ARRAY
30466: NOT
30467: PUSH
30468: LD_EXP 63
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: PUSH
30479: LD_EXP 64
30483: PUSH
30484: LD_VAR 0 2
30488: ARRAY
30489: EQUAL
30490: OR
30491: PUSH
30492: LD_EXP 73
30496: PUSH
30497: LD_VAR 0 2
30501: ARRAY
30502: OR
30503: IFFALSE 30507
// continue ;
30505: GO 30453
// if mc_miners [ i ] then
30507: LD_EXP 64
30511: PUSH
30512: LD_VAR 0 2
30516: ARRAY
30517: IFFALSE 30891
// begin for j = mc_miners [ i ] downto 1 do
30519: LD_ADDR_VAR 0 3
30523: PUSH
30524: DOUBLE
30525: LD_EXP 64
30529: PUSH
30530: LD_VAR 0 2
30534: ARRAY
30535: INC
30536: ST_TO_ADDR
30537: LD_INT 1
30539: PUSH
30540: FOR_DOWNTO
30541: IFFALSE 30889
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30543: LD_EXP 64
30547: PUSH
30548: LD_VAR 0 2
30552: ARRAY
30553: PUSH
30554: LD_VAR 0 3
30558: ARRAY
30559: PPUSH
30560: CALL_OW 301
30564: PUSH
30565: LD_EXP 64
30569: PUSH
30570: LD_VAR 0 2
30574: ARRAY
30575: PUSH
30576: LD_VAR 0 3
30580: ARRAY
30581: PPUSH
30582: CALL_OW 257
30586: PUSH
30587: LD_INT 1
30589: NONEQUAL
30590: OR
30591: IFFALSE 30654
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30593: LD_ADDR_VAR 0 5
30597: PUSH
30598: LD_EXP 64
30602: PUSH
30603: LD_VAR 0 2
30607: ARRAY
30608: PUSH
30609: LD_EXP 64
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PUSH
30620: LD_VAR 0 3
30624: ARRAY
30625: DIFF
30626: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30627: LD_ADDR_EXP 64
30631: PUSH
30632: LD_EXP 64
30636: PPUSH
30637: LD_VAR 0 2
30641: PPUSH
30642: LD_VAR 0 5
30646: PPUSH
30647: CALL_OW 1
30651: ST_TO_ADDR
// continue ;
30652: GO 30540
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30654: LD_EXP 64
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: PUSH
30665: LD_VAR 0 3
30669: ARRAY
30670: PPUSH
30671: CALL_OW 257
30675: PUSH
30676: LD_INT 1
30678: EQUAL
30679: PUSH
30680: LD_EXP 64
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: PUSH
30691: LD_VAR 0 3
30695: ARRAY
30696: PPUSH
30697: CALL_OW 459
30701: NOT
30702: AND
30703: PUSH
30704: LD_EXP 64
30708: PUSH
30709: LD_VAR 0 2
30713: ARRAY
30714: PUSH
30715: LD_VAR 0 3
30719: ARRAY
30720: PPUSH
30721: CALL_OW 314
30725: NOT
30726: AND
30727: IFFALSE 30887
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30729: LD_EXP 64
30733: PUSH
30734: LD_VAR 0 2
30738: ARRAY
30739: PUSH
30740: LD_VAR 0 3
30744: ARRAY
30745: PPUSH
30746: CALL_OW 310
30750: IFFALSE 30773
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30752: LD_EXP 64
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: PUSH
30763: LD_VAR 0 3
30767: ARRAY
30768: PPUSH
30769: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30773: LD_EXP 64
30777: PUSH
30778: LD_VAR 0 2
30782: ARRAY
30783: PUSH
30784: LD_VAR 0 3
30788: ARRAY
30789: PPUSH
30790: CALL_OW 314
30794: NOT
30795: IFFALSE 30887
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30797: LD_ADDR_VAR 0 7
30801: PUSH
30802: LD_INT 1
30804: PPUSH
30805: LD_EXP 63
30809: PUSH
30810: LD_VAR 0 2
30814: ARRAY
30815: PPUSH
30816: CALL_OW 12
30820: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30821: LD_EXP 64
30825: PUSH
30826: LD_VAR 0 2
30830: ARRAY
30831: PUSH
30832: LD_VAR 0 3
30836: ARRAY
30837: PPUSH
30838: LD_EXP 63
30842: PUSH
30843: LD_VAR 0 2
30847: ARRAY
30848: PUSH
30849: LD_VAR 0 7
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: ARRAY
30858: PPUSH
30859: LD_EXP 63
30863: PUSH
30864: LD_VAR 0 2
30868: ARRAY
30869: PUSH
30870: LD_VAR 0 7
30874: ARRAY
30875: PUSH
30876: LD_INT 2
30878: ARRAY
30879: PPUSH
30880: LD_INT 0
30882: PPUSH
30883: CALL_OW 193
// end ; end ; end ;
30887: GO 30540
30889: POP
30890: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30891: LD_ADDR_VAR 0 5
30895: PUSH
30896: LD_EXP 50
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PPUSH
30907: LD_INT 2
30909: PUSH
30910: LD_INT 30
30912: PUSH
30913: LD_INT 4
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 30
30922: PUSH
30923: LD_INT 5
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 30
30932: PUSH
30933: LD_INT 32
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: PPUSH
30946: CALL_OW 72
30950: ST_TO_ADDR
// if not tmp then
30951: LD_VAR 0 5
30955: NOT
30956: IFFALSE 30960
// continue ;
30958: GO 30453
// list := [ ] ;
30960: LD_ADDR_VAR 0 6
30964: PUSH
30965: EMPTY
30966: ST_TO_ADDR
// for j in tmp do
30967: LD_ADDR_VAR 0 3
30971: PUSH
30972: LD_VAR 0 5
30976: PUSH
30977: FOR_IN
30978: IFFALSE 31047
// begin for k in UnitsInside ( j ) do
30980: LD_ADDR_VAR 0 4
30984: PUSH
30985: LD_VAR 0 3
30989: PPUSH
30990: CALL_OW 313
30994: PUSH
30995: FOR_IN
30996: IFFALSE 31043
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30998: LD_VAR 0 4
31002: PPUSH
31003: CALL_OW 257
31007: PUSH
31008: LD_INT 1
31010: EQUAL
31011: PUSH
31012: LD_VAR 0 4
31016: PPUSH
31017: CALL_OW 459
31021: NOT
31022: AND
31023: IFFALSE 31041
// list := list ^ k ;
31025: LD_ADDR_VAR 0 6
31029: PUSH
31030: LD_VAR 0 6
31034: PUSH
31035: LD_VAR 0 4
31039: ADD
31040: ST_TO_ADDR
31041: GO 30995
31043: POP
31044: POP
// end ;
31045: GO 30977
31047: POP
31048: POP
// list := list diff mc_miners [ i ] ;
31049: LD_ADDR_VAR 0 6
31053: PUSH
31054: LD_VAR 0 6
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: DIFF
31070: ST_TO_ADDR
// if not list then
31071: LD_VAR 0 6
31075: NOT
31076: IFFALSE 31080
// continue ;
31078: GO 30453
// k := mc_mines [ i ] - mc_miners [ i ] ;
31080: LD_ADDR_VAR 0 4
31084: PUSH
31085: LD_EXP 63
31089: PUSH
31090: LD_VAR 0 2
31094: ARRAY
31095: PUSH
31096: LD_EXP 64
31100: PUSH
31101: LD_VAR 0 2
31105: ARRAY
31106: MINUS
31107: ST_TO_ADDR
// if k > list then
31108: LD_VAR 0 4
31112: PUSH
31113: LD_VAR 0 6
31117: GREATER
31118: IFFALSE 31130
// k := list ;
31120: LD_ADDR_VAR 0 4
31124: PUSH
31125: LD_VAR 0 6
31129: ST_TO_ADDR
// for j = 1 to k do
31130: LD_ADDR_VAR 0 3
31134: PUSH
31135: DOUBLE
31136: LD_INT 1
31138: DEC
31139: ST_TO_ADDR
31140: LD_VAR 0 4
31144: PUSH
31145: FOR_TO
31146: IFFALSE 31200
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31148: LD_ADDR_EXP 64
31152: PUSH
31153: LD_EXP 64
31157: PPUSH
31158: LD_VAR 0 2
31162: PUSH
31163: LD_EXP 64
31167: PUSH
31168: LD_VAR 0 2
31172: ARRAY
31173: PUSH
31174: LD_INT 1
31176: PLUS
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PPUSH
31182: LD_VAR 0 6
31186: PUSH
31187: LD_VAR 0 3
31191: ARRAY
31192: PPUSH
31193: CALL 53565 0 3
31197: ST_TO_ADDR
31198: GO 31145
31200: POP
31201: POP
// end ;
31202: GO 30453
31204: POP
31205: POP
// end ;
31206: LD_VAR 0 1
31210: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
31217: PPUSH
31218: PPUSH
31219: PPUSH
31220: PPUSH
31221: PPUSH
31222: PPUSH
31223: PPUSH
// if not mc_bases then
31224: LD_EXP 50
31228: NOT
31229: IFFALSE 31233
// exit ;
31231: GO 33056
// for i = 1 to mc_bases do
31233: LD_ADDR_VAR 0 2
31237: PUSH
31238: DOUBLE
31239: LD_INT 1
31241: DEC
31242: ST_TO_ADDR
31243: LD_EXP 50
31247: PUSH
31248: FOR_TO
31249: IFFALSE 33054
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31251: LD_EXP 50
31255: PUSH
31256: LD_VAR 0 2
31260: ARRAY
31261: NOT
31262: PUSH
31263: LD_EXP 57
31267: PUSH
31268: LD_VAR 0 2
31272: ARRAY
31273: OR
31274: IFFALSE 31278
// continue ;
31276: GO 31248
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31278: LD_EXP 66
31282: PUSH
31283: LD_VAR 0 2
31287: ARRAY
31288: NOT
31289: PUSH
31290: LD_EXP 67
31294: PUSH
31295: LD_VAR 0 2
31299: ARRAY
31300: AND
31301: IFFALSE 31339
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31303: LD_ADDR_EXP 67
31307: PUSH
31308: LD_EXP 67
31312: PPUSH
31313: LD_VAR 0 2
31317: PPUSH
31318: EMPTY
31319: PPUSH
31320: CALL_OW 1
31324: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31325: LD_VAR 0 2
31329: PPUSH
31330: LD_INT 107
31332: PPUSH
31333: CALL 22107 0 2
// continue ;
31337: GO 31248
// end ; target := [ ] ;
31339: LD_ADDR_VAR 0 7
31343: PUSH
31344: EMPTY
31345: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31346: LD_ADDR_VAR 0 6
31350: PUSH
31351: LD_EXP 50
31355: PUSH
31356: LD_VAR 0 2
31360: ARRAY
31361: PUSH
31362: LD_INT 1
31364: ARRAY
31365: PPUSH
31366: CALL_OW 255
31370: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31371: LD_ADDR_VAR 0 9
31375: PUSH
31376: LD_EXP 50
31380: PUSH
31381: LD_VAR 0 2
31385: ARRAY
31386: PPUSH
31387: LD_INT 2
31389: PUSH
31390: LD_INT 30
31392: PUSH
31393: LD_INT 0
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 30
31402: PUSH
31403: LD_INT 1
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: LIST
31414: PPUSH
31415: CALL_OW 72
31419: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31420: LD_ADDR_VAR 0 3
31424: PUSH
31425: DOUBLE
31426: LD_EXP 66
31430: PUSH
31431: LD_VAR 0 2
31435: ARRAY
31436: INC
31437: ST_TO_ADDR
31438: LD_INT 1
31440: PUSH
31441: FOR_DOWNTO
31442: IFFALSE 31687
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31444: LD_EXP 66
31448: PUSH
31449: LD_VAR 0 2
31453: ARRAY
31454: PUSH
31455: LD_VAR 0 3
31459: ARRAY
31460: PUSH
31461: LD_INT 2
31463: ARRAY
31464: PPUSH
31465: LD_EXP 66
31469: PUSH
31470: LD_VAR 0 2
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 3
31480: ARRAY
31481: PUSH
31482: LD_INT 3
31484: ARRAY
31485: PPUSH
31486: CALL_OW 488
31490: PUSH
31491: LD_EXP 66
31495: PUSH
31496: LD_VAR 0 2
31500: ARRAY
31501: PUSH
31502: LD_VAR 0 3
31506: ARRAY
31507: PUSH
31508: LD_INT 2
31510: ARRAY
31511: PPUSH
31512: LD_EXP 66
31516: PUSH
31517: LD_VAR 0 2
31521: ARRAY
31522: PUSH
31523: LD_VAR 0 3
31527: ARRAY
31528: PUSH
31529: LD_INT 3
31531: ARRAY
31532: PPUSH
31533: CALL_OW 284
31537: PUSH
31538: LD_INT 0
31540: EQUAL
31541: AND
31542: IFFALSE 31597
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31544: LD_ADDR_VAR 0 5
31548: PUSH
31549: LD_EXP 66
31553: PUSH
31554: LD_VAR 0 2
31558: ARRAY
31559: PPUSH
31560: LD_VAR 0 3
31564: PPUSH
31565: CALL_OW 3
31569: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31570: LD_ADDR_EXP 66
31574: PUSH
31575: LD_EXP 66
31579: PPUSH
31580: LD_VAR 0 2
31584: PPUSH
31585: LD_VAR 0 5
31589: PPUSH
31590: CALL_OW 1
31594: ST_TO_ADDR
// continue ;
31595: GO 31441
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31597: LD_VAR 0 6
31601: PPUSH
31602: LD_EXP 66
31606: PUSH
31607: LD_VAR 0 2
31611: ARRAY
31612: PUSH
31613: LD_VAR 0 3
31617: ARRAY
31618: PUSH
31619: LD_INT 2
31621: ARRAY
31622: PPUSH
31623: LD_EXP 66
31627: PUSH
31628: LD_VAR 0 2
31632: ARRAY
31633: PUSH
31634: LD_VAR 0 3
31638: ARRAY
31639: PUSH
31640: LD_INT 3
31642: ARRAY
31643: PPUSH
31644: LD_INT 30
31646: PPUSH
31647: CALL 54461 0 4
31651: PUSH
31652: LD_INT 4
31654: ARRAY
31655: PUSH
31656: LD_INT 0
31658: EQUAL
31659: IFFALSE 31685
// begin target := mc_crates [ i ] [ j ] ;
31661: LD_ADDR_VAR 0 7
31665: PUSH
31666: LD_EXP 66
31670: PUSH
31671: LD_VAR 0 2
31675: ARRAY
31676: PUSH
31677: LD_VAR 0 3
31681: ARRAY
31682: ST_TO_ADDR
// break ;
31683: GO 31687
// end ; end ;
31685: GO 31441
31687: POP
31688: POP
// if not target then
31689: LD_VAR 0 7
31693: NOT
31694: IFFALSE 31698
// continue ;
31696: GO 31248
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31698: LD_ADDR_VAR 0 8
31702: PUSH
31703: LD_EXP 69
31707: PUSH
31708: LD_VAR 0 2
31712: ARRAY
31713: PPUSH
31714: LD_INT 2
31716: PUSH
31717: LD_INT 3
31719: PUSH
31720: LD_INT 58
31722: PUSH
31723: EMPTY
31724: LIST
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 61
31732: PUSH
31733: EMPTY
31734: LIST
31735: PUSH
31736: LD_INT 33
31738: PUSH
31739: LD_INT 5
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 33
31748: PUSH
31749: LD_INT 3
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 2
31765: PUSH
31766: LD_INT 34
31768: PUSH
31769: LD_INT 32
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 34
31778: PUSH
31779: LD_INT 51
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 34
31788: PUSH
31789: LD_INT 12
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PPUSH
31806: CALL_OW 72
31810: ST_TO_ADDR
// if not cargo then
31811: LD_VAR 0 8
31815: NOT
31816: IFFALSE 32522
// begin if mc_crates_collector [ i ] < 5 then
31818: LD_EXP 67
31822: PUSH
31823: LD_VAR 0 2
31827: ARRAY
31828: PUSH
31829: LD_INT 5
31831: LESS
31832: IFFALSE 32198
// begin if mc_ape [ i ] then
31834: LD_EXP 79
31838: PUSH
31839: LD_VAR 0 2
31843: ARRAY
31844: IFFALSE 31891
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31846: LD_ADDR_VAR 0 5
31850: PUSH
31851: LD_EXP 79
31855: PUSH
31856: LD_VAR 0 2
31860: ARRAY
31861: PPUSH
31862: LD_INT 25
31864: PUSH
31865: LD_INT 16
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 24
31874: PUSH
31875: LD_INT 750
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PPUSH
31886: CALL_OW 72
31890: ST_TO_ADDR
// if not tmp then
31891: LD_VAR 0 5
31895: NOT
31896: IFFALSE 31943
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31898: LD_ADDR_VAR 0 5
31902: PUSH
31903: LD_EXP 50
31907: PUSH
31908: LD_VAR 0 2
31912: ARRAY
31913: PPUSH
31914: LD_INT 25
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 24
31926: PUSH
31927: LD_INT 750
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PPUSH
31938: CALL_OW 72
31942: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31943: LD_EXP 79
31947: PUSH
31948: LD_VAR 0 2
31952: ARRAY
31953: PUSH
31954: LD_EXP 50
31958: PUSH
31959: LD_VAR 0 2
31963: ARRAY
31964: PPUSH
31965: LD_INT 25
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 24
31977: PUSH
31978: LD_INT 750
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PPUSH
31989: CALL_OW 72
31993: AND
31994: PUSH
31995: LD_VAR 0 5
31999: PUSH
32000: LD_INT 5
32002: LESS
32003: AND
32004: IFFALSE 32086
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32006: LD_ADDR_VAR 0 3
32010: PUSH
32011: LD_EXP 50
32015: PUSH
32016: LD_VAR 0 2
32020: ARRAY
32021: PPUSH
32022: LD_INT 25
32024: PUSH
32025: LD_INT 2
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 24
32034: PUSH
32035: LD_INT 750
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PPUSH
32046: CALL_OW 72
32050: PUSH
32051: FOR_IN
32052: IFFALSE 32084
// begin tmp := tmp union j ;
32054: LD_ADDR_VAR 0 5
32058: PUSH
32059: LD_VAR 0 5
32063: PUSH
32064: LD_VAR 0 3
32068: UNION
32069: ST_TO_ADDR
// if tmp >= 5 then
32070: LD_VAR 0 5
32074: PUSH
32075: LD_INT 5
32077: GREATEREQUAL
32078: IFFALSE 32082
// break ;
32080: GO 32084
// end ;
32082: GO 32051
32084: POP
32085: POP
// end ; if not tmp then
32086: LD_VAR 0 5
32090: NOT
32091: IFFALSE 32095
// continue ;
32093: GO 31248
// for j in tmp do
32095: LD_ADDR_VAR 0 3
32099: PUSH
32100: LD_VAR 0 5
32104: PUSH
32105: FOR_IN
32106: IFFALSE 32196
// if not GetTag ( j ) then
32108: LD_VAR 0 3
32112: PPUSH
32113: CALL_OW 110
32117: NOT
32118: IFFALSE 32194
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32120: LD_ADDR_EXP 67
32124: PUSH
32125: LD_EXP 67
32129: PPUSH
32130: LD_VAR 0 2
32134: PUSH
32135: LD_EXP 67
32139: PUSH
32140: LD_VAR 0 2
32144: ARRAY
32145: PUSH
32146: LD_INT 1
32148: PLUS
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: LD_VAR 0 3
32158: PPUSH
32159: CALL 53565 0 3
32163: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32164: LD_VAR 0 3
32168: PPUSH
32169: LD_INT 107
32171: PPUSH
32172: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32176: LD_EXP 67
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: PUSH
32187: LD_INT 5
32189: GREATEREQUAL
32190: IFFALSE 32194
// break ;
32192: GO 32196
// end ;
32194: GO 32105
32196: POP
32197: POP
// end ; if mc_crates_collector [ i ] and target then
32198: LD_EXP 67
32202: PUSH
32203: LD_VAR 0 2
32207: ARRAY
32208: PUSH
32209: LD_VAR 0 7
32213: AND
32214: IFFALSE 32520
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32216: LD_EXP 67
32220: PUSH
32221: LD_VAR 0 2
32225: ARRAY
32226: PUSH
32227: LD_VAR 0 7
32231: PUSH
32232: LD_INT 1
32234: ARRAY
32235: LESS
32236: IFFALSE 32256
// tmp := mc_crates_collector [ i ] else
32238: LD_ADDR_VAR 0 5
32242: PUSH
32243: LD_EXP 67
32247: PUSH
32248: LD_VAR 0 2
32252: ARRAY
32253: ST_TO_ADDR
32254: GO 32270
// tmp := target [ 1 ] ;
32256: LD_ADDR_VAR 0 5
32260: PUSH
32261: LD_VAR 0 7
32265: PUSH
32266: LD_INT 1
32268: ARRAY
32269: ST_TO_ADDR
// k := 0 ;
32270: LD_ADDR_VAR 0 4
32274: PUSH
32275: LD_INT 0
32277: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32278: LD_ADDR_VAR 0 3
32282: PUSH
32283: LD_EXP 67
32287: PUSH
32288: LD_VAR 0 2
32292: ARRAY
32293: PUSH
32294: FOR_IN
32295: IFFALSE 32518
// begin k := k + 1 ;
32297: LD_ADDR_VAR 0 4
32301: PUSH
32302: LD_VAR 0 4
32306: PUSH
32307: LD_INT 1
32309: PLUS
32310: ST_TO_ADDR
// if k > tmp then
32311: LD_VAR 0 4
32315: PUSH
32316: LD_VAR 0 5
32320: GREATER
32321: IFFALSE 32325
// break ;
32323: GO 32518
// if not GetClass ( j ) in [ 2 , 16 ] then
32325: LD_VAR 0 3
32329: PPUSH
32330: CALL_OW 257
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: LD_INT 16
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: IN
32345: NOT
32346: IFFALSE 32399
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32348: LD_ADDR_EXP 67
32352: PUSH
32353: LD_EXP 67
32357: PPUSH
32358: LD_VAR 0 2
32362: PPUSH
32363: LD_EXP 67
32367: PUSH
32368: LD_VAR 0 2
32372: ARRAY
32373: PUSH
32374: LD_VAR 0 3
32378: DIFF
32379: PPUSH
32380: CALL_OW 1
32384: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32385: LD_VAR 0 3
32389: PPUSH
32390: LD_INT 0
32392: PPUSH
32393: CALL_OW 109
// continue ;
32397: GO 32294
// end ; if IsInUnit ( j ) then
32399: LD_VAR 0 3
32403: PPUSH
32404: CALL_OW 310
32408: IFFALSE 32419
// ComExitBuilding ( j ) ;
32410: LD_VAR 0 3
32414: PPUSH
32415: CALL_OW 122
// wait ( 3 ) ;
32419: LD_INT 3
32421: PPUSH
32422: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32426: LD_VAR 0 3
32430: PPUSH
32431: CALL_OW 314
32435: PUSH
32436: LD_VAR 0 6
32440: PPUSH
32441: LD_VAR 0 7
32445: PUSH
32446: LD_INT 2
32448: ARRAY
32449: PPUSH
32450: LD_VAR 0 7
32454: PUSH
32455: LD_INT 3
32457: ARRAY
32458: PPUSH
32459: LD_INT 30
32461: PPUSH
32462: CALL 54461 0 4
32466: PUSH
32467: LD_INT 4
32469: ARRAY
32470: AND
32471: IFFALSE 32489
// ComStandNearbyBuilding ( j , depot ) else
32473: LD_VAR 0 3
32477: PPUSH
32478: LD_VAR 0 9
32482: PPUSH
32483: CALL 50143 0 2
32487: GO 32516
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32489: LD_VAR 0 3
32493: PPUSH
32494: LD_VAR 0 7
32498: PUSH
32499: LD_INT 2
32501: ARRAY
32502: PPUSH
32503: LD_VAR 0 7
32507: PUSH
32508: LD_INT 3
32510: ARRAY
32511: PPUSH
32512: CALL_OW 117
// end ;
32516: GO 32294
32518: POP
32519: POP
// end ; end else
32520: GO 33052
// begin for j in cargo do
32522: LD_ADDR_VAR 0 3
32526: PUSH
32527: LD_VAR 0 8
32531: PUSH
32532: FOR_IN
32533: IFFALSE 33050
// begin if GetTag ( j ) <> 0 then
32535: LD_VAR 0 3
32539: PPUSH
32540: CALL_OW 110
32544: PUSH
32545: LD_INT 0
32547: NONEQUAL
32548: IFFALSE 32552
// continue ;
32550: GO 32532
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32552: LD_VAR 0 3
32556: PPUSH
32557: CALL_OW 256
32561: PUSH
32562: LD_INT 1000
32564: LESS
32565: PUSH
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 74
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PPUSH
32582: CALL_OW 308
32586: NOT
32587: AND
32588: IFFALSE 32610
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32590: LD_VAR 0 3
32594: PPUSH
32595: LD_EXP 74
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: PPUSH
32606: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32610: LD_VAR 0 3
32614: PPUSH
32615: CALL_OW 256
32619: PUSH
32620: LD_INT 1000
32622: LESS
32623: PUSH
32624: LD_VAR 0 3
32628: PPUSH
32629: LD_EXP 74
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PPUSH
32640: CALL_OW 308
32644: AND
32645: IFFALSE 32649
// continue ;
32647: GO 32532
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32649: LD_VAR 0 3
32653: PPUSH
32654: CALL_OW 262
32658: PUSH
32659: LD_INT 2
32661: EQUAL
32662: PUSH
32663: LD_VAR 0 3
32667: PPUSH
32668: CALL_OW 261
32672: PUSH
32673: LD_INT 15
32675: LESS
32676: AND
32677: IFFALSE 32681
// continue ;
32679: GO 32532
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32681: LD_VAR 0 3
32685: PPUSH
32686: CALL_OW 262
32690: PUSH
32691: LD_INT 1
32693: EQUAL
32694: PUSH
32695: LD_VAR 0 3
32699: PPUSH
32700: CALL_OW 261
32704: PUSH
32705: LD_INT 10
32707: LESS
32708: AND
32709: IFFALSE 32989
// begin if not depot then
32711: LD_VAR 0 9
32715: NOT
32716: IFFALSE 32720
// continue ;
32718: GO 32532
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32720: LD_VAR 0 3
32724: PPUSH
32725: LD_VAR 0 9
32729: PPUSH
32730: LD_VAR 0 3
32734: PPUSH
32735: CALL_OW 74
32739: PPUSH
32740: CALL_OW 296
32744: PUSH
32745: LD_INT 6
32747: LESS
32748: IFFALSE 32764
// SetFuel ( j , 100 ) else
32750: LD_VAR 0 3
32754: PPUSH
32755: LD_INT 100
32757: PPUSH
32758: CALL_OW 240
32762: GO 32989
// if GetFuel ( j ) = 0 then
32764: LD_VAR 0 3
32768: PPUSH
32769: CALL_OW 261
32773: PUSH
32774: LD_INT 0
32776: EQUAL
32777: IFFALSE 32989
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32779: LD_ADDR_EXP 69
32783: PUSH
32784: LD_EXP 69
32788: PPUSH
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_EXP 69
32798: PUSH
32799: LD_VAR 0 2
32803: ARRAY
32804: PUSH
32805: LD_VAR 0 3
32809: DIFF
32810: PPUSH
32811: CALL_OW 1
32815: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32816: LD_VAR 0 3
32820: PPUSH
32821: CALL_OW 263
32825: PUSH
32826: LD_INT 1
32828: EQUAL
32829: IFFALSE 32845
// ComExitVehicle ( IsInUnit ( j ) ) ;
32831: LD_VAR 0 3
32835: PPUSH
32836: CALL_OW 310
32840: PPUSH
32841: CALL_OW 121
// if GetControl ( j ) = control_remote then
32845: LD_VAR 0 3
32849: PPUSH
32850: CALL_OW 263
32854: PUSH
32855: LD_INT 2
32857: EQUAL
32858: IFFALSE 32869
// ComUnlink ( j ) ;
32860: LD_VAR 0 3
32864: PPUSH
32865: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32869: LD_ADDR_VAR 0 10
32873: PUSH
32874: LD_VAR 0 2
32878: PPUSH
32879: LD_INT 3
32881: PPUSH
32882: CALL 42628 0 2
32886: ST_TO_ADDR
// if fac then
32887: LD_VAR 0 10
32891: IFFALSE 32987
// begin for k in fac do
32893: LD_ADDR_VAR 0 4
32897: PUSH
32898: LD_VAR 0 10
32902: PUSH
32903: FOR_IN
32904: IFFALSE 32985
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32906: LD_ADDR_VAR 0 11
32910: PUSH
32911: LD_VAR 0 10
32915: PPUSH
32916: LD_VAR 0 3
32920: PPUSH
32921: CALL_OW 265
32925: PPUSH
32926: LD_VAR 0 3
32930: PPUSH
32931: CALL_OW 262
32935: PPUSH
32936: LD_VAR 0 3
32940: PPUSH
32941: CALL_OW 263
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 264
32955: PPUSH
32956: CALL 51061 0 5
32960: ST_TO_ADDR
// if components then
32961: LD_VAR 0 11
32965: IFFALSE 32983
// begin MC_InsertProduceList ( i , components ) ;
32967: LD_VAR 0 2
32971: PPUSH
32972: LD_VAR 0 11
32976: PPUSH
32977: CALL 42173 0 2
// break ;
32981: GO 32985
// end ; end ;
32983: GO 32903
32985: POP
32986: POP
// end ; continue ;
32987: GO 32532
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32989: LD_VAR 0 3
32993: PPUSH
32994: LD_INT 1
32996: PPUSH
32997: CALL_OW 289
33001: PUSH
33002: LD_INT 100
33004: LESS
33005: PUSH
33006: LD_VAR 0 3
33010: PPUSH
33011: CALL_OW 314
33015: NOT
33016: AND
33017: IFFALSE 33046
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33019: LD_VAR 0 3
33023: PPUSH
33024: LD_VAR 0 7
33028: PUSH
33029: LD_INT 2
33031: ARRAY
33032: PPUSH
33033: LD_VAR 0 7
33037: PUSH
33038: LD_INT 3
33040: ARRAY
33041: PPUSH
33042: CALL_OW 117
// break ;
33046: GO 33050
// end ;
33048: GO 32532
33050: POP
33051: POP
// end ; end ;
33052: GO 31248
33054: POP
33055: POP
// end ;
33056: LD_VAR 0 1
33060: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33061: LD_INT 0
33063: PPUSH
33064: PPUSH
33065: PPUSH
33066: PPUSH
// if not mc_bases then
33067: LD_EXP 50
33071: NOT
33072: IFFALSE 33076
// exit ;
33074: GO 33237
// for i = 1 to mc_bases do
33076: LD_ADDR_VAR 0 2
33080: PUSH
33081: DOUBLE
33082: LD_INT 1
33084: DEC
33085: ST_TO_ADDR
33086: LD_EXP 50
33090: PUSH
33091: FOR_TO
33092: IFFALSE 33235
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33094: LD_ADDR_VAR 0 4
33098: PUSH
33099: LD_EXP 69
33103: PUSH
33104: LD_VAR 0 2
33108: ARRAY
33109: PUSH
33110: LD_EXP 72
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: UNION
33121: PPUSH
33122: LD_INT 33
33124: PUSH
33125: LD_INT 2
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PPUSH
33132: CALL_OW 72
33136: ST_TO_ADDR
// if tmp then
33137: LD_VAR 0 4
33141: IFFALSE 33233
// for j in tmp do
33143: LD_ADDR_VAR 0 3
33147: PUSH
33148: LD_VAR 0 4
33152: PUSH
33153: FOR_IN
33154: IFFALSE 33231
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33156: LD_VAR 0 3
33160: PPUSH
33161: CALL_OW 312
33165: NOT
33166: PUSH
33167: LD_VAR 0 3
33171: PPUSH
33172: CALL_OW 256
33176: PUSH
33177: LD_INT 250
33179: GREATEREQUAL
33180: AND
33181: IFFALSE 33194
// Connect ( j ) else
33183: LD_VAR 0 3
33187: PPUSH
33188: CALL 56536 0 1
33192: GO 33229
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33194: LD_VAR 0 3
33198: PPUSH
33199: CALL_OW 256
33203: PUSH
33204: LD_INT 250
33206: LESS
33207: PUSH
33208: LD_VAR 0 3
33212: PPUSH
33213: CALL_OW 312
33217: AND
33218: IFFALSE 33229
// ComUnlink ( j ) ;
33220: LD_VAR 0 3
33224: PPUSH
33225: CALL_OW 136
33229: GO 33153
33231: POP
33232: POP
// end ;
33233: GO 33091
33235: POP
33236: POP
// end ;
33237: LD_VAR 0 1
33241: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33242: LD_INT 0
33244: PPUSH
33245: PPUSH
33246: PPUSH
33247: PPUSH
33248: PPUSH
// if not mc_bases then
33249: LD_EXP 50
33253: NOT
33254: IFFALSE 33258
// exit ;
33256: GO 33703
// for i = 1 to mc_bases do
33258: LD_ADDR_VAR 0 2
33262: PUSH
33263: DOUBLE
33264: LD_INT 1
33266: DEC
33267: ST_TO_ADDR
33268: LD_EXP 50
33272: PUSH
33273: FOR_TO
33274: IFFALSE 33701
// begin if not mc_produce [ i ] then
33276: LD_EXP 71
33280: PUSH
33281: LD_VAR 0 2
33285: ARRAY
33286: NOT
33287: IFFALSE 33291
// continue ;
33289: GO 33273
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33291: LD_ADDR_VAR 0 5
33295: PUSH
33296: LD_EXP 50
33300: PUSH
33301: LD_VAR 0 2
33305: ARRAY
33306: PPUSH
33307: LD_INT 30
33309: PUSH
33310: LD_INT 3
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PPUSH
33317: CALL_OW 72
33321: ST_TO_ADDR
// if not fac then
33322: LD_VAR 0 5
33326: NOT
33327: IFFALSE 33331
// continue ;
33329: GO 33273
// for j in fac do
33331: LD_ADDR_VAR 0 3
33335: PUSH
33336: LD_VAR 0 5
33340: PUSH
33341: FOR_IN
33342: IFFALSE 33697
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33344: LD_VAR 0 3
33348: PPUSH
33349: CALL_OW 461
33353: PUSH
33354: LD_INT 2
33356: NONEQUAL
33357: PUSH
33358: LD_VAR 0 3
33362: PPUSH
33363: LD_INT 15
33365: PPUSH
33366: CALL 56164 0 2
33370: PUSH
33371: LD_INT 4
33373: ARRAY
33374: OR
33375: IFFALSE 33379
// continue ;
33377: GO 33341
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33379: LD_VAR 0 3
33383: PPUSH
33384: LD_EXP 71
33388: PUSH
33389: LD_VAR 0 2
33393: ARRAY
33394: PUSH
33395: LD_INT 1
33397: ARRAY
33398: PUSH
33399: LD_INT 1
33401: ARRAY
33402: PPUSH
33403: LD_EXP 71
33407: PUSH
33408: LD_VAR 0 2
33412: ARRAY
33413: PUSH
33414: LD_INT 1
33416: ARRAY
33417: PUSH
33418: LD_INT 2
33420: ARRAY
33421: PPUSH
33422: LD_EXP 71
33426: PUSH
33427: LD_VAR 0 2
33431: ARRAY
33432: PUSH
33433: LD_INT 1
33435: ARRAY
33436: PUSH
33437: LD_INT 3
33439: ARRAY
33440: PPUSH
33441: LD_EXP 71
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: PUSH
33452: LD_INT 1
33454: ARRAY
33455: PUSH
33456: LD_INT 4
33458: ARRAY
33459: PPUSH
33460: CALL_OW 448
33464: PUSH
33465: LD_VAR 0 3
33469: PPUSH
33470: LD_EXP 71
33474: PUSH
33475: LD_VAR 0 2
33479: ARRAY
33480: PUSH
33481: LD_INT 1
33483: ARRAY
33484: PUSH
33485: LD_INT 1
33487: ARRAY
33488: PUSH
33489: LD_EXP 71
33493: PUSH
33494: LD_VAR 0 2
33498: ARRAY
33499: PUSH
33500: LD_INT 1
33502: ARRAY
33503: PUSH
33504: LD_INT 2
33506: ARRAY
33507: PUSH
33508: LD_EXP 71
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: PUSH
33519: LD_INT 1
33521: ARRAY
33522: PUSH
33523: LD_INT 3
33525: ARRAY
33526: PUSH
33527: LD_EXP 71
33531: PUSH
33532: LD_VAR 0 2
33536: ARRAY
33537: PUSH
33538: LD_INT 1
33540: ARRAY
33541: PUSH
33542: LD_INT 4
33544: ARRAY
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: PPUSH
33552: CALL 59931 0 2
33556: AND
33557: IFFALSE 33695
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33559: LD_VAR 0 3
33563: PPUSH
33564: LD_EXP 71
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: PUSH
33575: LD_INT 1
33577: ARRAY
33578: PUSH
33579: LD_INT 1
33581: ARRAY
33582: PPUSH
33583: LD_EXP 71
33587: PUSH
33588: LD_VAR 0 2
33592: ARRAY
33593: PUSH
33594: LD_INT 1
33596: ARRAY
33597: PUSH
33598: LD_INT 2
33600: ARRAY
33601: PPUSH
33602: LD_EXP 71
33606: PUSH
33607: LD_VAR 0 2
33611: ARRAY
33612: PUSH
33613: LD_INT 1
33615: ARRAY
33616: PUSH
33617: LD_INT 3
33619: ARRAY
33620: PPUSH
33621: LD_EXP 71
33625: PUSH
33626: LD_VAR 0 2
33630: ARRAY
33631: PUSH
33632: LD_INT 1
33634: ARRAY
33635: PUSH
33636: LD_INT 4
33638: ARRAY
33639: PPUSH
33640: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33644: LD_ADDR_VAR 0 4
33648: PUSH
33649: LD_EXP 71
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: PPUSH
33660: LD_INT 1
33662: PPUSH
33663: CALL_OW 3
33667: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33668: LD_ADDR_EXP 71
33672: PUSH
33673: LD_EXP 71
33677: PPUSH
33678: LD_VAR 0 2
33682: PPUSH
33683: LD_VAR 0 4
33687: PPUSH
33688: CALL_OW 1
33692: ST_TO_ADDR
// break ;
33693: GO 33697
// end ; end ;
33695: GO 33341
33697: POP
33698: POP
// end ;
33699: GO 33273
33701: POP
33702: POP
// end ;
33703: LD_VAR 0 1
33707: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33708: LD_INT 0
33710: PPUSH
33711: PPUSH
33712: PPUSH
// if not mc_bases then
33713: LD_EXP 50
33717: NOT
33718: IFFALSE 33722
// exit ;
33720: GO 33811
// for i = 1 to mc_bases do
33722: LD_ADDR_VAR 0 2
33726: PUSH
33727: DOUBLE
33728: LD_INT 1
33730: DEC
33731: ST_TO_ADDR
33732: LD_EXP 50
33736: PUSH
33737: FOR_TO
33738: IFFALSE 33809
// begin if mc_attack [ i ] then
33740: LD_EXP 70
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: IFFALSE 33807
// begin tmp := mc_attack [ i ] [ 1 ] ;
33752: LD_ADDR_VAR 0 3
33756: PUSH
33757: LD_EXP 70
33761: PUSH
33762: LD_VAR 0 2
33766: ARRAY
33767: PUSH
33768: LD_INT 1
33770: ARRAY
33771: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33772: LD_ADDR_EXP 70
33776: PUSH
33777: LD_EXP 70
33781: PPUSH
33782: LD_VAR 0 2
33786: PPUSH
33787: EMPTY
33788: PPUSH
33789: CALL_OW 1
33793: ST_TO_ADDR
// Attack ( tmp ) ;
33794: LD_VAR 0 3
33798: PPUSH
33799: CALL 108127 0 1
// exit ;
33803: POP
33804: POP
33805: GO 33811
// end ; end ;
33807: GO 33737
33809: POP
33810: POP
// end ;
33811: LD_VAR 0 1
33815: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33816: LD_INT 0
33818: PPUSH
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
33824: PPUSH
// if not mc_bases then
33825: LD_EXP 50
33829: NOT
33830: IFFALSE 33834
// exit ;
33832: GO 34691
// for i = 1 to mc_bases do
33834: LD_ADDR_VAR 0 2
33838: PUSH
33839: DOUBLE
33840: LD_INT 1
33842: DEC
33843: ST_TO_ADDR
33844: LD_EXP 50
33848: PUSH
33849: FOR_TO
33850: IFFALSE 34689
// begin if not mc_bases [ i ] then
33852: LD_EXP 50
33856: PUSH
33857: LD_VAR 0 2
33861: ARRAY
33862: NOT
33863: IFFALSE 33867
// continue ;
33865: GO 33849
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33867: LD_ADDR_VAR 0 7
33871: PUSH
33872: LD_EXP 50
33876: PUSH
33877: LD_VAR 0 2
33881: ARRAY
33882: PUSH
33883: LD_INT 1
33885: ARRAY
33886: PPUSH
33887: CALL 50365 0 1
33891: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33892: LD_ADDR_EXP 73
33896: PUSH
33897: LD_EXP 73
33901: PPUSH
33902: LD_VAR 0 2
33906: PPUSH
33907: LD_EXP 50
33911: PUSH
33912: LD_VAR 0 2
33916: ARRAY
33917: PUSH
33918: LD_INT 1
33920: ARRAY
33921: PPUSH
33922: CALL_OW 255
33926: PPUSH
33927: LD_EXP 75
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: PPUSH
33938: CALL 50330 0 2
33942: PPUSH
33943: CALL_OW 1
33947: ST_TO_ADDR
// if not mc_scan [ i ] then
33948: LD_EXP 73
33952: PUSH
33953: LD_VAR 0 2
33957: ARRAY
33958: NOT
33959: IFFALSE 34137
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33961: LD_ADDR_EXP 93
33965: PUSH
33966: LD_EXP 93
33970: PPUSH
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_INT 0
33978: PPUSH
33979: CALL_OW 1
33983: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33984: LD_ADDR_VAR 0 4
33988: PUSH
33989: LD_EXP 50
33993: PUSH
33994: LD_VAR 0 2
33998: ARRAY
33999: PPUSH
34000: LD_INT 2
34002: PUSH
34003: LD_INT 25
34005: PUSH
34006: LD_INT 5
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 25
34015: PUSH
34016: LD_INT 8
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 25
34025: PUSH
34026: LD_INT 9
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: PPUSH
34039: CALL_OW 72
34043: ST_TO_ADDR
// if not tmp then
34044: LD_VAR 0 4
34048: NOT
34049: IFFALSE 34053
// continue ;
34051: GO 33849
// for j in tmp do
34053: LD_ADDR_VAR 0 3
34057: PUSH
34058: LD_VAR 0 4
34062: PUSH
34063: FOR_IN
34064: IFFALSE 34135
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34066: LD_VAR 0 3
34070: PPUSH
34071: CALL_OW 310
34075: PPUSH
34076: CALL_OW 266
34080: PUSH
34081: LD_INT 5
34083: EQUAL
34084: PUSH
34085: LD_VAR 0 3
34089: PPUSH
34090: CALL_OW 257
34094: PUSH
34095: LD_INT 1
34097: EQUAL
34098: AND
34099: PUSH
34100: LD_VAR 0 3
34104: PPUSH
34105: CALL_OW 459
34109: NOT
34110: AND
34111: PUSH
34112: LD_VAR 0 7
34116: AND
34117: IFFALSE 34133
// ComChangeProfession ( j , class ) ;
34119: LD_VAR 0 3
34123: PPUSH
34124: LD_VAR 0 7
34128: PPUSH
34129: CALL_OW 123
34133: GO 34063
34135: POP
34136: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34137: LD_EXP 73
34141: PUSH
34142: LD_VAR 0 2
34146: ARRAY
34147: PUSH
34148: LD_EXP 93
34152: PUSH
34153: LD_VAR 0 2
34157: ARRAY
34158: NOT
34159: AND
34160: PUSH
34161: LD_EXP 72
34165: PUSH
34166: LD_VAR 0 2
34170: ARRAY
34171: NOT
34172: AND
34173: PUSH
34174: LD_EXP 50
34178: PUSH
34179: LD_VAR 0 2
34183: ARRAY
34184: PPUSH
34185: LD_INT 50
34187: PUSH
34188: EMPTY
34189: LIST
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: LD_INT 30
34196: PUSH
34197: LD_INT 32
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 30
34206: PUSH
34207: LD_INT 33
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 30
34216: PUSH
34217: LD_INT 4
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 30
34226: PUSH
34227: LD_INT 5
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PPUSH
34245: CALL_OW 72
34249: PUSH
34250: LD_INT 4
34252: LESS
34253: PUSH
34254: LD_EXP 50
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PPUSH
34265: LD_INT 3
34267: PUSH
34268: LD_INT 24
34270: PUSH
34271: LD_INT 1000
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: LD_INT 30
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 30
34297: PUSH
34298: LD_INT 1
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: LIST
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PPUSH
34314: CALL_OW 72
34318: OR
34319: AND
34320: IFFALSE 34571
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34322: LD_ADDR_EXP 93
34326: PUSH
34327: LD_EXP 93
34331: PPUSH
34332: LD_VAR 0 2
34336: PPUSH
34337: LD_INT 1
34339: PPUSH
34340: CALL_OW 1
34344: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34345: LD_ADDR_VAR 0 4
34349: PUSH
34350: LD_EXP 50
34354: PUSH
34355: LD_VAR 0 2
34359: ARRAY
34360: PPUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 25
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 25
34376: PUSH
34377: LD_INT 5
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 25
34386: PUSH
34387: LD_INT 8
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 25
34396: PUSH
34397: LD_INT 9
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: PPUSH
34411: CALL_OW 72
34415: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34416: LD_ADDR_VAR 0 4
34420: PUSH
34421: LD_VAR 0 4
34425: PUSH
34426: LD_VAR 0 4
34430: PPUSH
34431: LD_INT 18
34433: PPUSH
34434: CALL 82834 0 2
34438: DIFF
34439: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34440: LD_VAR 0 4
34444: NOT
34445: PUSH
34446: LD_EXP 50
34450: PUSH
34451: LD_VAR 0 2
34455: ARRAY
34456: PPUSH
34457: LD_INT 2
34459: PUSH
34460: LD_INT 30
34462: PUSH
34463: LD_INT 4
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 30
34472: PUSH
34473: LD_INT 5
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: LIST
34484: PPUSH
34485: CALL_OW 72
34489: NOT
34490: AND
34491: IFFALSE 34553
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34493: LD_ADDR_VAR 0 4
34497: PUSH
34498: LD_EXP 50
34502: PUSH
34503: LD_VAR 0 2
34507: ARRAY
34508: PPUSH
34509: LD_INT 2
34511: PUSH
34512: LD_INT 25
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 25
34524: PUSH
34525: LD_INT 3
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 25
34534: PUSH
34535: LD_INT 4
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34553: LD_VAR 0 2
34557: PPUSH
34558: LD_VAR 0 4
34562: PPUSH
34563: CALL 112836 0 2
// exit ;
34567: POP
34568: POP
34569: GO 34691
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34571: LD_EXP 73
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_EXP 93
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: NOT
34593: AND
34594: PUSH
34595: LD_EXP 72
34599: PUSH
34600: LD_VAR 0 2
34604: ARRAY
34605: AND
34606: IFFALSE 34687
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34608: LD_ADDR_EXP 93
34612: PUSH
34613: LD_EXP 93
34617: PPUSH
34618: LD_VAR 0 2
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 1
34630: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34631: LD_ADDR_VAR 0 4
34635: PUSH
34636: LD_EXP 72
34640: PUSH
34641: LD_VAR 0 2
34645: ARRAY
34646: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34647: LD_ADDR_EXP 72
34651: PUSH
34652: LD_EXP 72
34656: PPUSH
34657: LD_VAR 0 2
34661: PPUSH
34662: EMPTY
34663: PPUSH
34664: CALL_OW 1
34668: ST_TO_ADDR
// Defend ( i , tmp ) ;
34669: LD_VAR 0 2
34673: PPUSH
34674: LD_VAR 0 4
34678: PPUSH
34679: CALL 113432 0 2
// exit ;
34683: POP
34684: POP
34685: GO 34691
// end ; end ;
34687: GO 33849
34689: POP
34690: POP
// end ;
34691: LD_VAR 0 1
34695: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34696: LD_INT 0
34698: PPUSH
34699: PPUSH
34700: PPUSH
34701: PPUSH
34702: PPUSH
34703: PPUSH
34704: PPUSH
34705: PPUSH
34706: PPUSH
34707: PPUSH
34708: PPUSH
// if not mc_bases then
34709: LD_EXP 50
34713: NOT
34714: IFFALSE 34718
// exit ;
34716: GO 35805
// for i = 1 to mc_bases do
34718: LD_ADDR_VAR 0 2
34722: PUSH
34723: DOUBLE
34724: LD_INT 1
34726: DEC
34727: ST_TO_ADDR
34728: LD_EXP 50
34732: PUSH
34733: FOR_TO
34734: IFFALSE 35803
// begin tmp := mc_lab [ i ] ;
34736: LD_ADDR_VAR 0 6
34740: PUSH
34741: LD_EXP 83
34745: PUSH
34746: LD_VAR 0 2
34750: ARRAY
34751: ST_TO_ADDR
// if not tmp then
34752: LD_VAR 0 6
34756: NOT
34757: IFFALSE 34761
// continue ;
34759: GO 34733
// idle_lab := 0 ;
34761: LD_ADDR_VAR 0 11
34765: PUSH
34766: LD_INT 0
34768: ST_TO_ADDR
// for j in tmp do
34769: LD_ADDR_VAR 0 3
34773: PUSH
34774: LD_VAR 0 6
34778: PUSH
34779: FOR_IN
34780: IFFALSE 35799
// begin researching := false ;
34782: LD_ADDR_VAR 0 10
34786: PUSH
34787: LD_INT 0
34789: ST_TO_ADDR
// side := GetSide ( j ) ;
34790: LD_ADDR_VAR 0 4
34794: PUSH
34795: LD_VAR 0 3
34799: PPUSH
34800: CALL_OW 255
34804: ST_TO_ADDR
// if not mc_tech [ side ] then
34805: LD_EXP 77
34809: PUSH
34810: LD_VAR 0 4
34814: ARRAY
34815: NOT
34816: IFFALSE 34820
// continue ;
34818: GO 34779
// if BuildingStatus ( j ) = bs_idle then
34820: LD_VAR 0 3
34824: PPUSH
34825: CALL_OW 461
34829: PUSH
34830: LD_INT 2
34832: EQUAL
34833: IFFALSE 35021
// begin if idle_lab and UnitsInside ( j ) < 6 then
34835: LD_VAR 0 11
34839: PUSH
34840: LD_VAR 0 3
34844: PPUSH
34845: CALL_OW 313
34849: PUSH
34850: LD_INT 6
34852: LESS
34853: AND
34854: IFFALSE 34925
// begin tmp2 := UnitsInside ( idle_lab ) ;
34856: LD_ADDR_VAR 0 9
34860: PUSH
34861: LD_VAR 0 11
34865: PPUSH
34866: CALL_OW 313
34870: ST_TO_ADDR
// if tmp2 then
34871: LD_VAR 0 9
34875: IFFALSE 34917
// for x in tmp2 do
34877: LD_ADDR_VAR 0 7
34881: PUSH
34882: LD_VAR 0 9
34886: PUSH
34887: FOR_IN
34888: IFFALSE 34915
// begin ComExitBuilding ( x ) ;
34890: LD_VAR 0 7
34894: PPUSH
34895: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34899: LD_VAR 0 7
34903: PPUSH
34904: LD_VAR 0 3
34908: PPUSH
34909: CALL_OW 180
// end ;
34913: GO 34887
34915: POP
34916: POP
// idle_lab := 0 ;
34917: LD_ADDR_VAR 0 11
34921: PUSH
34922: LD_INT 0
34924: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34925: LD_ADDR_VAR 0 5
34929: PUSH
34930: LD_EXP 77
34934: PUSH
34935: LD_VAR 0 4
34939: ARRAY
34940: PUSH
34941: FOR_IN
34942: IFFALSE 35002
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34944: LD_VAR 0 3
34948: PPUSH
34949: LD_VAR 0 5
34953: PPUSH
34954: CALL_OW 430
34958: PUSH
34959: LD_VAR 0 4
34963: PPUSH
34964: LD_VAR 0 5
34968: PPUSH
34969: CALL 49435 0 2
34973: AND
34974: IFFALSE 35000
// begin researching := true ;
34976: LD_ADDR_VAR 0 10
34980: PUSH
34981: LD_INT 1
34983: ST_TO_ADDR
// ComResearch ( j , t ) ;
34984: LD_VAR 0 3
34988: PPUSH
34989: LD_VAR 0 5
34993: PPUSH
34994: CALL_OW 124
// break ;
34998: GO 35002
// end ;
35000: GO 34941
35002: POP
35003: POP
// if not researching then
35004: LD_VAR 0 10
35008: NOT
35009: IFFALSE 35021
// idle_lab := j ;
35011: LD_ADDR_VAR 0 11
35015: PUSH
35016: LD_VAR 0 3
35020: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35021: LD_VAR 0 3
35025: PPUSH
35026: CALL_OW 461
35030: PUSH
35031: LD_INT 10
35033: EQUAL
35034: IFFALSE 35622
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35036: LD_EXP 79
35040: PUSH
35041: LD_VAR 0 2
35045: ARRAY
35046: NOT
35047: PUSH
35048: LD_EXP 80
35052: PUSH
35053: LD_VAR 0 2
35057: ARRAY
35058: NOT
35059: AND
35060: PUSH
35061: LD_EXP 77
35065: PUSH
35066: LD_VAR 0 4
35070: ARRAY
35071: PUSH
35072: LD_INT 1
35074: GREATER
35075: AND
35076: IFFALSE 35207
// begin ComCancel ( j ) ;
35078: LD_VAR 0 3
35082: PPUSH
35083: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35087: LD_ADDR_EXP 77
35091: PUSH
35092: LD_EXP 77
35096: PPUSH
35097: LD_VAR 0 4
35101: PPUSH
35102: LD_EXP 77
35106: PUSH
35107: LD_VAR 0 4
35111: ARRAY
35112: PPUSH
35113: LD_EXP 77
35117: PUSH
35118: LD_VAR 0 4
35122: ARRAY
35123: PUSH
35124: LD_INT 1
35126: MINUS
35127: PPUSH
35128: LD_EXP 77
35132: PUSH
35133: LD_VAR 0 4
35137: ARRAY
35138: PPUSH
35139: LD_INT 0
35141: PPUSH
35142: CALL 52983 0 4
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35152: LD_ADDR_EXP 77
35156: PUSH
35157: LD_EXP 77
35161: PPUSH
35162: LD_VAR 0 4
35166: PPUSH
35167: LD_EXP 77
35171: PUSH
35172: LD_VAR 0 4
35176: ARRAY
35177: PPUSH
35178: LD_EXP 77
35182: PUSH
35183: LD_VAR 0 4
35187: ARRAY
35188: PPUSH
35189: LD_INT 1
35191: PPUSH
35192: LD_INT 0
35194: PPUSH
35195: CALL 52983 0 4
35199: PPUSH
35200: CALL_OW 1
35204: ST_TO_ADDR
// continue ;
35205: GO 34779
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35207: LD_EXP 79
35211: PUSH
35212: LD_VAR 0 2
35216: ARRAY
35217: PUSH
35218: LD_EXP 80
35222: PUSH
35223: LD_VAR 0 2
35227: ARRAY
35228: NOT
35229: AND
35230: IFFALSE 35357
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35232: LD_ADDR_EXP 80
35236: PUSH
35237: LD_EXP 80
35241: PPUSH
35242: LD_VAR 0 2
35246: PUSH
35247: LD_EXP 80
35251: PUSH
35252: LD_VAR 0 2
35256: ARRAY
35257: PUSH
35258: LD_INT 1
35260: PLUS
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PPUSH
35266: LD_EXP 79
35270: PUSH
35271: LD_VAR 0 2
35275: ARRAY
35276: PUSH
35277: LD_INT 1
35279: ARRAY
35280: PPUSH
35281: CALL 53565 0 3
35285: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35286: LD_EXP 79
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: PUSH
35297: LD_INT 1
35299: ARRAY
35300: PPUSH
35301: LD_INT 112
35303: PPUSH
35304: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35308: LD_ADDR_VAR 0 9
35312: PUSH
35313: LD_EXP 79
35317: PUSH
35318: LD_VAR 0 2
35322: ARRAY
35323: PPUSH
35324: LD_INT 1
35326: PPUSH
35327: CALL_OW 3
35331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35332: LD_ADDR_EXP 79
35336: PUSH
35337: LD_EXP 79
35341: PPUSH
35342: LD_VAR 0 2
35346: PPUSH
35347: LD_VAR 0 9
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35357: LD_EXP 79
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_EXP 80
35372: PUSH
35373: LD_VAR 0 2
35377: ARRAY
35378: AND
35379: PUSH
35380: LD_EXP 80
35384: PUSH
35385: LD_VAR 0 2
35389: ARRAY
35390: PUSH
35391: LD_INT 1
35393: ARRAY
35394: PPUSH
35395: CALL_OW 310
35399: NOT
35400: AND
35401: PUSH
35402: LD_VAR 0 3
35406: PPUSH
35407: CALL_OW 313
35411: PUSH
35412: LD_INT 6
35414: EQUAL
35415: AND
35416: IFFALSE 35472
// begin tmp2 := UnitsInside ( j ) ;
35418: LD_ADDR_VAR 0 9
35422: PUSH
35423: LD_VAR 0 3
35427: PPUSH
35428: CALL_OW 313
35432: ST_TO_ADDR
// if tmp2 = 6 then
35433: LD_VAR 0 9
35437: PUSH
35438: LD_INT 6
35440: EQUAL
35441: IFFALSE 35472
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35443: LD_VAR 0 9
35447: PUSH
35448: LD_INT 1
35450: ARRAY
35451: PPUSH
35452: LD_INT 112
35454: PPUSH
35455: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35459: LD_VAR 0 9
35463: PUSH
35464: LD_INT 1
35466: ARRAY
35467: PPUSH
35468: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35472: LD_EXP 80
35476: PUSH
35477: LD_VAR 0 2
35481: ARRAY
35482: PUSH
35483: LD_EXP 80
35487: PUSH
35488: LD_VAR 0 2
35492: ARRAY
35493: PUSH
35494: LD_INT 1
35496: ARRAY
35497: PPUSH
35498: CALL_OW 314
35502: NOT
35503: AND
35504: PUSH
35505: LD_EXP 80
35509: PUSH
35510: LD_VAR 0 2
35514: ARRAY
35515: PUSH
35516: LD_INT 1
35518: ARRAY
35519: PPUSH
35520: CALL_OW 310
35524: NOT
35525: AND
35526: IFFALSE 35552
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35528: LD_EXP 80
35532: PUSH
35533: LD_VAR 0 2
35537: ARRAY
35538: PUSH
35539: LD_INT 1
35541: ARRAY
35542: PPUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35552: LD_EXP 80
35556: PUSH
35557: LD_VAR 0 2
35561: ARRAY
35562: PUSH
35563: LD_INT 1
35565: ARRAY
35566: PPUSH
35567: CALL_OW 310
35571: PUSH
35572: LD_EXP 80
35576: PUSH
35577: LD_VAR 0 2
35581: ARRAY
35582: PUSH
35583: LD_INT 1
35585: ARRAY
35586: PPUSH
35587: CALL_OW 310
35591: PPUSH
35592: CALL_OW 461
35596: PUSH
35597: LD_INT 3
35599: NONEQUAL
35600: AND
35601: IFFALSE 35622
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35603: LD_EXP 80
35607: PUSH
35608: LD_VAR 0 2
35612: ARRAY
35613: PUSH
35614: LD_INT 1
35616: ARRAY
35617: PPUSH
35618: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35622: LD_VAR 0 3
35626: PPUSH
35627: CALL_OW 461
35631: PUSH
35632: LD_INT 6
35634: EQUAL
35635: PUSH
35636: LD_VAR 0 6
35640: PUSH
35641: LD_INT 1
35643: GREATER
35644: AND
35645: IFFALSE 35797
// begin sci := [ ] ;
35647: LD_ADDR_VAR 0 8
35651: PUSH
35652: EMPTY
35653: ST_TO_ADDR
// for x in ( tmp diff j ) do
35654: LD_ADDR_VAR 0 7
35658: PUSH
35659: LD_VAR 0 6
35663: PUSH
35664: LD_VAR 0 3
35668: DIFF
35669: PUSH
35670: FOR_IN
35671: IFFALSE 35723
// begin if sci = 6 then
35673: LD_VAR 0 8
35677: PUSH
35678: LD_INT 6
35680: EQUAL
35681: IFFALSE 35685
// break ;
35683: GO 35723
// if BuildingStatus ( x ) = bs_idle then
35685: LD_VAR 0 7
35689: PPUSH
35690: CALL_OW 461
35694: PUSH
35695: LD_INT 2
35697: EQUAL
35698: IFFALSE 35721
// sci := sci ^ UnitsInside ( x ) ;
35700: LD_ADDR_VAR 0 8
35704: PUSH
35705: LD_VAR 0 8
35709: PUSH
35710: LD_VAR 0 7
35714: PPUSH
35715: CALL_OW 313
35719: ADD
35720: ST_TO_ADDR
// end ;
35721: GO 35670
35723: POP
35724: POP
// if not sci then
35725: LD_VAR 0 8
35729: NOT
35730: IFFALSE 35734
// continue ;
35732: GO 34779
// for x in sci do
35734: LD_ADDR_VAR 0 7
35738: PUSH
35739: LD_VAR 0 8
35743: PUSH
35744: FOR_IN
35745: IFFALSE 35795
// if IsInUnit ( x ) and not HasTask ( x ) then
35747: LD_VAR 0 7
35751: PPUSH
35752: CALL_OW 310
35756: PUSH
35757: LD_VAR 0 7
35761: PPUSH
35762: CALL_OW 314
35766: NOT
35767: AND
35768: IFFALSE 35793
// begin ComExitBuilding ( x ) ;
35770: LD_VAR 0 7
35774: PPUSH
35775: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35779: LD_VAR 0 7
35783: PPUSH
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 180
// end ;
35793: GO 35744
35795: POP
35796: POP
// end ; end ;
35797: GO 34779
35799: POP
35800: POP
// end ;
35801: GO 34733
35803: POP
35804: POP
// end ;
35805: LD_VAR 0 1
35809: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35810: LD_INT 0
35812: PPUSH
35813: PPUSH
// if not mc_bases then
35814: LD_EXP 50
35818: NOT
35819: IFFALSE 35823
// exit ;
35821: GO 35904
// for i = 1 to mc_bases do
35823: LD_ADDR_VAR 0 2
35827: PUSH
35828: DOUBLE
35829: LD_INT 1
35831: DEC
35832: ST_TO_ADDR
35833: LD_EXP 50
35837: PUSH
35838: FOR_TO
35839: IFFALSE 35902
// if mc_mines [ i ] and mc_miners [ i ] then
35841: LD_EXP 63
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_EXP 64
35856: PUSH
35857: LD_VAR 0 2
35861: ARRAY
35862: AND
35863: IFFALSE 35900
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35865: LD_EXP 64
35869: PUSH
35870: LD_VAR 0 2
35874: ARRAY
35875: PUSH
35876: LD_INT 1
35878: ARRAY
35879: PPUSH
35880: CALL_OW 255
35884: PPUSH
35885: LD_EXP 63
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PPUSH
35896: CALL 50518 0 2
35900: GO 35838
35902: POP
35903: POP
// end ;
35904: LD_VAR 0 1
35908: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35909: LD_INT 0
35911: PPUSH
35912: PPUSH
35913: PPUSH
35914: PPUSH
35915: PPUSH
35916: PPUSH
35917: PPUSH
35918: PPUSH
// if not mc_bases or not mc_parking then
35919: LD_EXP 50
35923: NOT
35924: PUSH
35925: LD_EXP 74
35929: NOT
35930: OR
35931: IFFALSE 35935
// exit ;
35933: GO 36645
// for i = 1 to mc_bases do
35935: LD_ADDR_VAR 0 2
35939: PUSH
35940: DOUBLE
35941: LD_INT 1
35943: DEC
35944: ST_TO_ADDR
35945: LD_EXP 50
35949: PUSH
35950: FOR_TO
35951: IFFALSE 36643
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35953: LD_EXP 50
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: NOT
35964: PUSH
35965: LD_EXP 74
35969: PUSH
35970: LD_VAR 0 2
35974: ARRAY
35975: NOT
35976: OR
35977: IFFALSE 35981
// continue ;
35979: GO 35950
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35981: LD_ADDR_VAR 0 5
35985: PUSH
35986: LD_EXP 50
35990: PUSH
35991: LD_VAR 0 2
35995: ARRAY
35996: PUSH
35997: LD_INT 1
35999: ARRAY
36000: PPUSH
36001: CALL_OW 255
36005: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36006: LD_ADDR_VAR 0 6
36010: PUSH
36011: LD_EXP 50
36015: PUSH
36016: LD_VAR 0 2
36020: ARRAY
36021: PPUSH
36022: LD_INT 30
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PPUSH
36032: CALL_OW 72
36036: ST_TO_ADDR
// if not fac then
36037: LD_VAR 0 6
36041: NOT
36042: IFFALSE 36093
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36044: LD_ADDR_VAR 0 6
36048: PUSH
36049: LD_EXP 50
36053: PUSH
36054: LD_VAR 0 2
36058: ARRAY
36059: PPUSH
36060: LD_INT 2
36062: PUSH
36063: LD_INT 30
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 30
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: LIST
36087: PPUSH
36088: CALL_OW 72
36092: ST_TO_ADDR
// if not fac then
36093: LD_VAR 0 6
36097: NOT
36098: IFFALSE 36102
// continue ;
36100: GO 35950
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36102: LD_ADDR_VAR 0 7
36106: PUSH
36107: LD_EXP 74
36111: PUSH
36112: LD_VAR 0 2
36116: ARRAY
36117: PPUSH
36118: LD_INT 22
36120: PUSH
36121: LD_VAR 0 5
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 21
36132: PUSH
36133: LD_INT 2
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: LD_INT 24
36145: PUSH
36146: LD_INT 1000
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL_OW 70
36166: ST_TO_ADDR
// for j in fac do
36167: LD_ADDR_VAR 0 3
36171: PUSH
36172: LD_VAR 0 6
36176: PUSH
36177: FOR_IN
36178: IFFALSE 36259
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36180: LD_ADDR_VAR 0 7
36184: PUSH
36185: LD_VAR 0 7
36189: PUSH
36190: LD_INT 22
36192: PUSH
36193: LD_VAR 0 5
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 91
36204: PUSH
36205: LD_VAR 0 3
36209: PUSH
36210: LD_INT 15
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 21
36220: PUSH
36221: LD_INT 2
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 3
36230: PUSH
36231: LD_INT 24
36233: PUSH
36234: LD_INT 1000
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: LIST
36249: LIST
36250: PPUSH
36251: CALL_OW 69
36255: UNION
36256: ST_TO_ADDR
36257: GO 36177
36259: POP
36260: POP
// if not vehs then
36261: LD_VAR 0 7
36265: NOT
36266: IFFALSE 36292
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36268: LD_ADDR_EXP 62
36272: PUSH
36273: LD_EXP 62
36277: PPUSH
36278: LD_VAR 0 2
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// continue ;
36290: GO 35950
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36292: LD_ADDR_VAR 0 8
36296: PUSH
36297: LD_EXP 50
36301: PUSH
36302: LD_VAR 0 2
36306: ARRAY
36307: PPUSH
36308: LD_INT 30
36310: PUSH
36311: LD_INT 3
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PPUSH
36318: CALL_OW 72
36322: ST_TO_ADDR
// if tmp then
36323: LD_VAR 0 8
36327: IFFALSE 36430
// begin for j in tmp do
36329: LD_ADDR_VAR 0 3
36333: PUSH
36334: LD_VAR 0 8
36338: PUSH
36339: FOR_IN
36340: IFFALSE 36428
// for k in UnitsInside ( j ) do
36342: LD_ADDR_VAR 0 4
36346: PUSH
36347: LD_VAR 0 3
36351: PPUSH
36352: CALL_OW 313
36356: PUSH
36357: FOR_IN
36358: IFFALSE 36424
// if k then
36360: LD_VAR 0 4
36364: IFFALSE 36422
// if not k in mc_repair_vehicle [ i ] then
36366: LD_VAR 0 4
36370: PUSH
36371: LD_EXP 62
36375: PUSH
36376: LD_VAR 0 2
36380: ARRAY
36381: IN
36382: NOT
36383: IFFALSE 36422
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36385: LD_ADDR_EXP 62
36389: PUSH
36390: LD_EXP 62
36394: PPUSH
36395: LD_VAR 0 2
36399: PPUSH
36400: LD_EXP 62
36404: PUSH
36405: LD_VAR 0 2
36409: ARRAY
36410: PUSH
36411: LD_VAR 0 4
36415: UNION
36416: PPUSH
36417: CALL_OW 1
36421: ST_TO_ADDR
36422: GO 36357
36424: POP
36425: POP
36426: GO 36339
36428: POP
36429: POP
// end ; if not mc_repair_vehicle [ i ] then
36430: LD_EXP 62
36434: PUSH
36435: LD_VAR 0 2
36439: ARRAY
36440: NOT
36441: IFFALSE 36445
// continue ;
36443: GO 35950
// for j in mc_repair_vehicle [ i ] do
36445: LD_ADDR_VAR 0 3
36449: PUSH
36450: LD_EXP 62
36454: PUSH
36455: LD_VAR 0 2
36459: ARRAY
36460: PUSH
36461: FOR_IN
36462: IFFALSE 36639
// begin if GetClass ( j ) <> 3 then
36464: LD_VAR 0 3
36468: PPUSH
36469: CALL_OW 257
36473: PUSH
36474: LD_INT 3
36476: NONEQUAL
36477: IFFALSE 36518
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36479: LD_ADDR_EXP 62
36483: PUSH
36484: LD_EXP 62
36488: PPUSH
36489: LD_VAR 0 2
36493: PPUSH
36494: LD_EXP 62
36498: PUSH
36499: LD_VAR 0 2
36503: ARRAY
36504: PUSH
36505: LD_VAR 0 3
36509: DIFF
36510: PPUSH
36511: CALL_OW 1
36515: ST_TO_ADDR
// continue ;
36516: GO 36461
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36518: LD_VAR 0 3
36522: PPUSH
36523: CALL_OW 311
36527: NOT
36528: PUSH
36529: LD_VAR 0 3
36533: PUSH
36534: LD_EXP 53
36538: PUSH
36539: LD_VAR 0 2
36543: ARRAY
36544: PUSH
36545: LD_INT 1
36547: ARRAY
36548: IN
36549: NOT
36550: AND
36551: PUSH
36552: LD_VAR 0 3
36556: PUSH
36557: LD_EXP 53
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: PUSH
36568: LD_INT 2
36570: ARRAY
36571: IN
36572: NOT
36573: AND
36574: IFFALSE 36637
// begin if IsInUnit ( j ) then
36576: LD_VAR 0 3
36580: PPUSH
36581: CALL_OW 310
36585: IFFALSE 36598
// ComExitBuilding ( j ) else
36587: LD_VAR 0 3
36591: PPUSH
36592: CALL_OW 122
36596: GO 36637
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36598: LD_VAR 0 3
36602: PPUSH
36603: LD_VAR 0 7
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 87317 0 2
36616: NOT
36617: IFFALSE 36637
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36619: LD_VAR 0 3
36623: PPUSH
36624: LD_VAR 0 7
36628: PUSH
36629: LD_INT 1
36631: ARRAY
36632: PPUSH
36633: CALL_OW 129
// end ; end ;
36637: GO 36461
36639: POP
36640: POP
// end ;
36641: GO 35950
36643: POP
36644: POP
// end ;
36645: LD_VAR 0 1
36649: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36650: LD_INT 0
36652: PPUSH
36653: PPUSH
36654: PPUSH
36655: PPUSH
36656: PPUSH
36657: PPUSH
36658: PPUSH
36659: PPUSH
36660: PPUSH
36661: PPUSH
36662: PPUSH
// if not mc_bases then
36663: LD_EXP 50
36667: NOT
36668: IFFALSE 36672
// exit ;
36670: GO 37474
// for i = 1 to mc_bases do
36672: LD_ADDR_VAR 0 2
36676: PUSH
36677: DOUBLE
36678: LD_INT 1
36680: DEC
36681: ST_TO_ADDR
36682: LD_EXP 50
36686: PUSH
36687: FOR_TO
36688: IFFALSE 37472
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36690: LD_EXP 78
36694: PUSH
36695: LD_VAR 0 2
36699: ARRAY
36700: NOT
36701: PUSH
36702: LD_EXP 53
36706: PUSH
36707: LD_VAR 0 2
36711: ARRAY
36712: PUSH
36713: LD_INT 1
36715: ARRAY
36716: OR
36717: PUSH
36718: LD_EXP 53
36722: PUSH
36723: LD_VAR 0 2
36727: ARRAY
36728: PUSH
36729: LD_INT 2
36731: ARRAY
36732: OR
36733: PUSH
36734: LD_EXP 76
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: PPUSH
36745: LD_INT 1
36747: PPUSH
36748: CALL_OW 325
36752: NOT
36753: OR
36754: PUSH
36755: LD_EXP 73
36759: PUSH
36760: LD_VAR 0 2
36764: ARRAY
36765: OR
36766: IFFALSE 36770
// continue ;
36768: GO 36687
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36770: LD_ADDR_VAR 0 8
36774: PUSH
36775: LD_EXP 50
36779: PUSH
36780: LD_VAR 0 2
36784: ARRAY
36785: PPUSH
36786: LD_INT 25
36788: PUSH
36789: LD_INT 4
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 50
36798: PUSH
36799: EMPTY
36800: LIST
36801: PUSH
36802: LD_INT 3
36804: PUSH
36805: LD_INT 60
36807: PUSH
36808: EMPTY
36809: LIST
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: LIST
36819: PPUSH
36820: CALL_OW 72
36824: PUSH
36825: LD_EXP 54
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: DIFF
36836: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36837: LD_ADDR_VAR 0 9
36841: PUSH
36842: LD_EXP 50
36846: PUSH
36847: LD_VAR 0 2
36851: ARRAY
36852: PPUSH
36853: LD_INT 2
36855: PUSH
36856: LD_INT 30
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 30
36868: PUSH
36869: LD_INT 1
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: LIST
36880: PPUSH
36881: CALL_OW 72
36885: ST_TO_ADDR
// if not tmp or not dep then
36886: LD_VAR 0 8
36890: NOT
36891: PUSH
36892: LD_VAR 0 9
36896: NOT
36897: OR
36898: IFFALSE 36902
// continue ;
36900: GO 36687
// side := GetSide ( tmp [ 1 ] ) ;
36902: LD_ADDR_VAR 0 11
36906: PUSH
36907: LD_VAR 0 8
36911: PUSH
36912: LD_INT 1
36914: ARRAY
36915: PPUSH
36916: CALL_OW 255
36920: ST_TO_ADDR
// dep := dep [ 1 ] ;
36921: LD_ADDR_VAR 0 9
36925: PUSH
36926: LD_VAR 0 9
36930: PUSH
36931: LD_INT 1
36933: ARRAY
36934: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36935: LD_ADDR_VAR 0 7
36939: PUSH
36940: LD_EXP 78
36944: PUSH
36945: LD_VAR 0 2
36949: ARRAY
36950: PPUSH
36951: LD_INT 22
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 25
36963: PUSH
36964: LD_INT 12
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL_OW 70
36979: PUSH
36980: LD_INT 22
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 25
36992: PUSH
36993: LD_INT 12
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 91
37002: PUSH
37003: LD_VAR 0 9
37007: PUSH
37008: LD_INT 20
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: LIST
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: LIST
37020: PPUSH
37021: CALL_OW 69
37025: UNION
37026: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37027: LD_ADDR_VAR 0 10
37031: PUSH
37032: LD_EXP 78
37036: PUSH
37037: LD_VAR 0 2
37041: ARRAY
37042: PPUSH
37043: LD_INT 81
37045: PUSH
37046: LD_VAR 0 11
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL_OW 70
37059: ST_TO_ADDR
// if not apes or danger_at_area then
37060: LD_VAR 0 7
37064: NOT
37065: PUSH
37066: LD_VAR 0 10
37070: OR
37071: IFFALSE 37121
// begin if mc_taming [ i ] then
37073: LD_EXP 81
37077: PUSH
37078: LD_VAR 0 2
37082: ARRAY
37083: IFFALSE 37119
// begin MC_Reset ( i , 121 ) ;
37085: LD_VAR 0 2
37089: PPUSH
37090: LD_INT 121
37092: PPUSH
37093: CALL 22107 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37097: LD_ADDR_EXP 81
37101: PUSH
37102: LD_EXP 81
37106: PPUSH
37107: LD_VAR 0 2
37111: PPUSH
37112: EMPTY
37113: PPUSH
37114: CALL_OW 1
37118: ST_TO_ADDR
// end ; continue ;
37119: GO 36687
// end ; for j in tmp do
37121: LD_ADDR_VAR 0 3
37125: PUSH
37126: LD_VAR 0 8
37130: PUSH
37131: FOR_IN
37132: IFFALSE 37468
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37134: LD_VAR 0 3
37138: PUSH
37139: LD_EXP 81
37143: PUSH
37144: LD_VAR 0 2
37148: ARRAY
37149: IN
37150: NOT
37151: PUSH
37152: LD_EXP 81
37156: PUSH
37157: LD_VAR 0 2
37161: ARRAY
37162: PUSH
37163: LD_INT 3
37165: LESS
37166: AND
37167: IFFALSE 37225
// begin SetTag ( j , 121 ) ;
37169: LD_VAR 0 3
37173: PPUSH
37174: LD_INT 121
37176: PPUSH
37177: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37181: LD_ADDR_EXP 81
37185: PUSH
37186: LD_EXP 81
37190: PPUSH
37191: LD_VAR 0 2
37195: PUSH
37196: LD_EXP 81
37200: PUSH
37201: LD_VAR 0 2
37205: ARRAY
37206: PUSH
37207: LD_INT 1
37209: PLUS
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PPUSH
37215: LD_VAR 0 3
37219: PPUSH
37220: CALL 53565 0 3
37224: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37225: LD_VAR 0 3
37229: PUSH
37230: LD_EXP 81
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: IN
37241: IFFALSE 37466
// begin if GetClass ( j ) <> 4 then
37243: LD_VAR 0 3
37247: PPUSH
37248: CALL_OW 257
37252: PUSH
37253: LD_INT 4
37255: NONEQUAL
37256: IFFALSE 37309
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37258: LD_ADDR_EXP 81
37262: PUSH
37263: LD_EXP 81
37267: PPUSH
37268: LD_VAR 0 2
37272: PPUSH
37273: LD_EXP 81
37277: PUSH
37278: LD_VAR 0 2
37282: ARRAY
37283: PUSH
37284: LD_VAR 0 3
37288: DIFF
37289: PPUSH
37290: CALL_OW 1
37294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37295: LD_VAR 0 3
37299: PPUSH
37300: LD_INT 0
37302: PPUSH
37303: CALL_OW 109
// continue ;
37307: GO 37131
// end ; if IsInUnit ( j ) then
37309: LD_VAR 0 3
37313: PPUSH
37314: CALL_OW 310
37318: IFFALSE 37329
// ComExitBuilding ( j ) ;
37320: LD_VAR 0 3
37324: PPUSH
37325: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37329: LD_ADDR_VAR 0 6
37333: PUSH
37334: LD_VAR 0 7
37338: PPUSH
37339: LD_VAR 0 3
37343: PPUSH
37344: CALL_OW 74
37348: ST_TO_ADDR
// if not ape then
37349: LD_VAR 0 6
37353: NOT
37354: IFFALSE 37358
// break ;
37356: GO 37468
// x := GetX ( ape ) ;
37358: LD_ADDR_VAR 0 4
37362: PUSH
37363: LD_VAR 0 6
37367: PPUSH
37368: CALL_OW 250
37372: ST_TO_ADDR
// y := GetY ( ape ) ;
37373: LD_ADDR_VAR 0 5
37377: PUSH
37378: LD_VAR 0 6
37382: PPUSH
37383: CALL_OW 251
37387: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37388: LD_VAR 0 4
37392: PPUSH
37393: LD_VAR 0 5
37397: PPUSH
37398: CALL_OW 488
37402: NOT
37403: PUSH
37404: LD_VAR 0 11
37408: PPUSH
37409: LD_VAR 0 4
37413: PPUSH
37414: LD_VAR 0 5
37418: PPUSH
37419: LD_INT 20
37421: PPUSH
37422: CALL 54461 0 4
37426: PUSH
37427: LD_INT 4
37429: ARRAY
37430: OR
37431: IFFALSE 37435
// break ;
37433: GO 37468
// if not HasTask ( j ) then
37435: LD_VAR 0 3
37439: PPUSH
37440: CALL_OW 314
37444: NOT
37445: IFFALSE 37466
// ComTameXY ( j , x , y ) ;
37447: LD_VAR 0 3
37451: PPUSH
37452: LD_VAR 0 4
37456: PPUSH
37457: LD_VAR 0 5
37461: PPUSH
37462: CALL_OW 131
// end ; end ;
37466: GO 37131
37468: POP
37469: POP
// end ;
37470: GO 36687
37472: POP
37473: POP
// end ;
37474: LD_VAR 0 1
37478: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37479: LD_INT 0
37481: PPUSH
37482: PPUSH
37483: PPUSH
37484: PPUSH
37485: PPUSH
37486: PPUSH
37487: PPUSH
37488: PPUSH
// if not mc_bases then
37489: LD_EXP 50
37493: NOT
37494: IFFALSE 37498
// exit ;
37496: GO 38124
// for i = 1 to mc_bases do
37498: LD_ADDR_VAR 0 2
37502: PUSH
37503: DOUBLE
37504: LD_INT 1
37506: DEC
37507: ST_TO_ADDR
37508: LD_EXP 50
37512: PUSH
37513: FOR_TO
37514: IFFALSE 38122
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37516: LD_EXP 79
37520: PUSH
37521: LD_VAR 0 2
37525: ARRAY
37526: NOT
37527: PUSH
37528: LD_EXP 79
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: PPUSH
37539: LD_INT 25
37541: PUSH
37542: LD_INT 12
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PPUSH
37549: CALL_OW 72
37553: NOT
37554: OR
37555: IFFALSE 37559
// continue ;
37557: GO 37513
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37559: LD_ADDR_VAR 0 5
37563: PUSH
37564: LD_EXP 79
37568: PUSH
37569: LD_VAR 0 2
37573: ARRAY
37574: PUSH
37575: LD_INT 1
37577: ARRAY
37578: PPUSH
37579: CALL_OW 255
37583: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37584: LD_VAR 0 5
37588: PPUSH
37589: LD_INT 2
37591: PPUSH
37592: CALL_OW 325
37596: IFFALSE 37849
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37598: LD_ADDR_VAR 0 4
37602: PUSH
37603: LD_EXP 79
37607: PUSH
37608: LD_VAR 0 2
37612: ARRAY
37613: PPUSH
37614: LD_INT 25
37616: PUSH
37617: LD_INT 16
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PPUSH
37624: CALL_OW 72
37628: ST_TO_ADDR
// if tmp < 6 then
37629: LD_VAR 0 4
37633: PUSH
37634: LD_INT 6
37636: LESS
37637: IFFALSE 37849
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37639: LD_ADDR_VAR 0 6
37643: PUSH
37644: LD_EXP 50
37648: PUSH
37649: LD_VAR 0 2
37653: ARRAY
37654: PPUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 30
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 30
37670: PUSH
37671: LD_INT 1
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: LIST
37682: PPUSH
37683: CALL_OW 72
37687: ST_TO_ADDR
// if depot then
37688: LD_VAR 0 6
37692: IFFALSE 37849
// begin selected := 0 ;
37694: LD_ADDR_VAR 0 7
37698: PUSH
37699: LD_INT 0
37701: ST_TO_ADDR
// for j in depot do
37702: LD_ADDR_VAR 0 3
37706: PUSH
37707: LD_VAR 0 6
37711: PUSH
37712: FOR_IN
37713: IFFALSE 37744
// begin if UnitsInside ( j ) < 6 then
37715: LD_VAR 0 3
37719: PPUSH
37720: CALL_OW 313
37724: PUSH
37725: LD_INT 6
37727: LESS
37728: IFFALSE 37742
// begin selected := j ;
37730: LD_ADDR_VAR 0 7
37734: PUSH
37735: LD_VAR 0 3
37739: ST_TO_ADDR
// break ;
37740: GO 37744
// end ; end ;
37742: GO 37712
37744: POP
37745: POP
// if selected then
37746: LD_VAR 0 7
37750: IFFALSE 37849
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37752: LD_ADDR_VAR 0 3
37756: PUSH
37757: LD_EXP 79
37761: PUSH
37762: LD_VAR 0 2
37766: ARRAY
37767: PPUSH
37768: LD_INT 25
37770: PUSH
37771: LD_INT 12
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PPUSH
37778: CALL_OW 72
37782: PUSH
37783: FOR_IN
37784: IFFALSE 37847
// if not HasTask ( j ) then
37786: LD_VAR 0 3
37790: PPUSH
37791: CALL_OW 314
37795: NOT
37796: IFFALSE 37845
// begin if not IsInUnit ( j ) then
37798: LD_VAR 0 3
37802: PPUSH
37803: CALL_OW 310
37807: NOT
37808: IFFALSE 37824
// ComEnterUnit ( j , selected ) ;
37810: LD_VAR 0 3
37814: PPUSH
37815: LD_VAR 0 7
37819: PPUSH
37820: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 16
37831: PPUSH
37832: CALL_OW 183
// AddComExitBuilding ( j ) ;
37836: LD_VAR 0 3
37840: PPUSH
37841: CALL_OW 182
// end ;
37845: GO 37783
37847: POP
37848: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37849: LD_VAR 0 5
37853: PPUSH
37854: LD_INT 11
37856: PPUSH
37857: CALL_OW 325
37861: IFFALSE 38120
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37863: LD_ADDR_VAR 0 4
37867: PUSH
37868: LD_EXP 79
37872: PUSH
37873: LD_VAR 0 2
37877: ARRAY
37878: PPUSH
37879: LD_INT 25
37881: PUSH
37882: LD_INT 16
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PPUSH
37889: CALL_OW 72
37893: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37894: LD_VAR 0 4
37898: PUSH
37899: LD_INT 6
37901: GREATEREQUAL
37902: PUSH
37903: LD_VAR 0 5
37907: PPUSH
37908: LD_INT 2
37910: PPUSH
37911: CALL_OW 325
37915: NOT
37916: OR
37917: IFFALSE 38120
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37919: LD_ADDR_VAR 0 8
37923: PUSH
37924: LD_EXP 50
37928: PUSH
37929: LD_VAR 0 2
37933: ARRAY
37934: PPUSH
37935: LD_INT 2
37937: PUSH
37938: LD_INT 30
37940: PUSH
37941: LD_INT 4
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 30
37950: PUSH
37951: LD_INT 5
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: LIST
37962: PPUSH
37963: CALL_OW 72
37967: ST_TO_ADDR
// if barracks then
37968: LD_VAR 0 8
37972: IFFALSE 38120
// begin selected := 0 ;
37974: LD_ADDR_VAR 0 7
37978: PUSH
37979: LD_INT 0
37981: ST_TO_ADDR
// for j in barracks do
37982: LD_ADDR_VAR 0 3
37986: PUSH
37987: LD_VAR 0 8
37991: PUSH
37992: FOR_IN
37993: IFFALSE 38024
// begin if UnitsInside ( j ) < 6 then
37995: LD_VAR 0 3
37999: PPUSH
38000: CALL_OW 313
38004: PUSH
38005: LD_INT 6
38007: LESS
38008: IFFALSE 38022
// begin selected := j ;
38010: LD_ADDR_VAR 0 7
38014: PUSH
38015: LD_VAR 0 3
38019: ST_TO_ADDR
// break ;
38020: GO 38024
// end ; end ;
38022: GO 37992
38024: POP
38025: POP
// if selected then
38026: LD_VAR 0 7
38030: IFFALSE 38120
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38032: LD_ADDR_VAR 0 3
38036: PUSH
38037: LD_EXP 79
38041: PUSH
38042: LD_VAR 0 2
38046: ARRAY
38047: PPUSH
38048: LD_INT 25
38050: PUSH
38051: LD_INT 12
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PPUSH
38058: CALL_OW 72
38062: PUSH
38063: FOR_IN
38064: IFFALSE 38118
// if not IsInUnit ( j ) and not HasTask ( j ) then
38066: LD_VAR 0 3
38070: PPUSH
38071: CALL_OW 310
38075: NOT
38076: PUSH
38077: LD_VAR 0 3
38081: PPUSH
38082: CALL_OW 314
38086: NOT
38087: AND
38088: IFFALSE 38116
// begin ComEnterUnit ( j , selected ) ;
38090: LD_VAR 0 3
38094: PPUSH
38095: LD_VAR 0 7
38099: PPUSH
38100: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38104: LD_VAR 0 3
38108: PPUSH
38109: LD_INT 15
38111: PPUSH
38112: CALL_OW 183
// end ;
38116: GO 38063
38118: POP
38119: POP
// end ; end ; end ; end ; end ;
38120: GO 37513
38122: POP
38123: POP
// end ;
38124: LD_VAR 0 1
38128: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38129: LD_INT 0
38131: PPUSH
38132: PPUSH
38133: PPUSH
38134: PPUSH
// if not mc_bases then
38135: LD_EXP 50
38139: NOT
38140: IFFALSE 38144
// exit ;
38142: GO 38322
// for i = 1 to mc_bases do
38144: LD_ADDR_VAR 0 2
38148: PUSH
38149: DOUBLE
38150: LD_INT 1
38152: DEC
38153: ST_TO_ADDR
38154: LD_EXP 50
38158: PUSH
38159: FOR_TO
38160: IFFALSE 38320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38162: LD_ADDR_VAR 0 4
38166: PUSH
38167: LD_EXP 50
38171: PUSH
38172: LD_VAR 0 2
38176: ARRAY
38177: PPUSH
38178: LD_INT 25
38180: PUSH
38181: LD_INT 9
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PPUSH
38188: CALL_OW 72
38192: ST_TO_ADDR
// if not tmp then
38193: LD_VAR 0 4
38197: NOT
38198: IFFALSE 38202
// continue ;
38200: GO 38159
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38202: LD_EXP 76
38206: PUSH
38207: LD_VAR 0 2
38211: ARRAY
38212: PPUSH
38213: LD_INT 29
38215: PPUSH
38216: CALL_OW 325
38220: NOT
38221: PUSH
38222: LD_EXP 76
38226: PUSH
38227: LD_VAR 0 2
38231: ARRAY
38232: PPUSH
38233: LD_INT 28
38235: PPUSH
38236: CALL_OW 325
38240: NOT
38241: AND
38242: IFFALSE 38246
// continue ;
38244: GO 38159
// for j in tmp do
38246: LD_ADDR_VAR 0 3
38250: PUSH
38251: LD_VAR 0 4
38255: PUSH
38256: FOR_IN
38257: IFFALSE 38316
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38259: LD_VAR 0 3
38263: PUSH
38264: LD_EXP 53
38268: PUSH
38269: LD_VAR 0 2
38273: ARRAY
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: IN
38279: NOT
38280: PUSH
38281: LD_VAR 0 3
38285: PUSH
38286: LD_EXP 53
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PUSH
38297: LD_INT 2
38299: ARRAY
38300: IN
38301: NOT
38302: AND
38303: IFFALSE 38314
// ComSpaceTimeShoot ( j ) ;
38305: LD_VAR 0 3
38309: PPUSH
38310: CALL 49526 0 1
38314: GO 38256
38316: POP
38317: POP
// end ;
38318: GO 38159
38320: POP
38321: POP
// end ;
38322: LD_VAR 0 1
38326: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38327: LD_INT 0
38329: PPUSH
38330: PPUSH
38331: PPUSH
38332: PPUSH
38333: PPUSH
38334: PPUSH
38335: PPUSH
38336: PPUSH
38337: PPUSH
// if not mc_bases then
38338: LD_EXP 50
38342: NOT
38343: IFFALSE 38347
// exit ;
38345: GO 38969
// for i = 1 to mc_bases do
38347: LD_ADDR_VAR 0 2
38351: PUSH
38352: DOUBLE
38353: LD_INT 1
38355: DEC
38356: ST_TO_ADDR
38357: LD_EXP 50
38361: PUSH
38362: FOR_TO
38363: IFFALSE 38967
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38365: LD_EXP 85
38369: PUSH
38370: LD_VAR 0 2
38374: ARRAY
38375: NOT
38376: PUSH
38377: LD_INT 38
38379: PPUSH
38380: LD_EXP 76
38384: PUSH
38385: LD_VAR 0 2
38389: ARRAY
38390: PPUSH
38391: CALL_OW 321
38395: PUSH
38396: LD_INT 2
38398: NONEQUAL
38399: OR
38400: IFFALSE 38404
// continue ;
38402: GO 38362
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38404: LD_ADDR_VAR 0 8
38408: PUSH
38409: LD_EXP 50
38413: PUSH
38414: LD_VAR 0 2
38418: ARRAY
38419: PPUSH
38420: LD_INT 30
38422: PUSH
38423: LD_INT 34
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PPUSH
38430: CALL_OW 72
38434: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38435: LD_ADDR_VAR 0 9
38439: PUSH
38440: LD_EXP 50
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: PPUSH
38451: LD_INT 25
38453: PUSH
38454: LD_INT 4
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PPUSH
38461: CALL_OW 72
38465: PPUSH
38466: LD_INT 0
38468: PPUSH
38469: CALL 82834 0 2
38473: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38474: LD_VAR 0 9
38478: NOT
38479: PUSH
38480: LD_VAR 0 8
38484: NOT
38485: OR
38486: PUSH
38487: LD_EXP 50
38491: PUSH
38492: LD_VAR 0 2
38496: ARRAY
38497: PPUSH
38498: LD_INT 124
38500: PPUSH
38501: CALL 82834 0 2
38505: OR
38506: IFFALSE 38510
// continue ;
38508: GO 38362
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38510: LD_EXP 86
38514: PUSH
38515: LD_VAR 0 2
38519: ARRAY
38520: PUSH
38521: LD_EXP 85
38525: PUSH
38526: LD_VAR 0 2
38530: ARRAY
38531: LESS
38532: PUSH
38533: LD_EXP 86
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: PUSH
38544: LD_VAR 0 8
38548: LESS
38549: AND
38550: IFFALSE 38965
// begin tmp := sci [ 1 ] ;
38552: LD_ADDR_VAR 0 7
38556: PUSH
38557: LD_VAR 0 9
38561: PUSH
38562: LD_INT 1
38564: ARRAY
38565: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38566: LD_VAR 0 7
38570: PPUSH
38571: LD_INT 124
38573: PPUSH
38574: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38578: LD_ADDR_VAR 0 3
38582: PUSH
38583: DOUBLE
38584: LD_EXP 85
38588: PUSH
38589: LD_VAR 0 2
38593: ARRAY
38594: INC
38595: ST_TO_ADDR
38596: LD_EXP 85
38600: PUSH
38601: LD_VAR 0 2
38605: ARRAY
38606: PUSH
38607: FOR_DOWNTO
38608: IFFALSE 38951
// begin if IsInUnit ( tmp ) then
38610: LD_VAR 0 7
38614: PPUSH
38615: CALL_OW 310
38619: IFFALSE 38630
// ComExitBuilding ( tmp ) ;
38621: LD_VAR 0 7
38625: PPUSH
38626: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38630: LD_INT 35
38632: PPUSH
38633: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38637: LD_VAR 0 7
38641: PPUSH
38642: CALL_OW 310
38646: NOT
38647: PUSH
38648: LD_VAR 0 7
38652: PPUSH
38653: CALL_OW 314
38657: NOT
38658: AND
38659: IFFALSE 38630
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38661: LD_ADDR_VAR 0 6
38665: PUSH
38666: LD_VAR 0 7
38670: PPUSH
38671: CALL_OW 250
38675: PUSH
38676: LD_VAR 0 7
38680: PPUSH
38681: CALL_OW 251
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38690: LD_INT 35
38692: PPUSH
38693: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38697: LD_ADDR_VAR 0 4
38701: PUSH
38702: LD_EXP 85
38706: PUSH
38707: LD_VAR 0 2
38711: ARRAY
38712: PUSH
38713: LD_VAR 0 3
38717: ARRAY
38718: PUSH
38719: LD_INT 1
38721: ARRAY
38722: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38723: LD_ADDR_VAR 0 5
38727: PUSH
38728: LD_EXP 85
38732: PUSH
38733: LD_VAR 0 2
38737: ARRAY
38738: PUSH
38739: LD_VAR 0 3
38743: ARRAY
38744: PUSH
38745: LD_INT 2
38747: ARRAY
38748: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38749: LD_VAR 0 7
38753: PPUSH
38754: LD_INT 10
38756: PPUSH
38757: CALL 56164 0 2
38761: PUSH
38762: LD_INT 4
38764: ARRAY
38765: IFFALSE 38803
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38767: LD_VAR 0 7
38771: PPUSH
38772: LD_VAR 0 6
38776: PUSH
38777: LD_INT 1
38779: ARRAY
38780: PPUSH
38781: LD_VAR 0 6
38785: PUSH
38786: LD_INT 2
38788: ARRAY
38789: PPUSH
38790: CALL_OW 111
// wait ( 0 0$10 ) ;
38794: LD_INT 350
38796: PPUSH
38797: CALL_OW 67
// end else
38801: GO 38829
// begin ComMoveXY ( tmp , x , y ) ;
38803: LD_VAR 0 7
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_VAR 0 5
38817: PPUSH
38818: CALL_OW 111
// wait ( 0 0$3 ) ;
38822: LD_INT 105
38824: PPUSH
38825: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38829: LD_VAR 0 7
38833: PPUSH
38834: LD_VAR 0 4
38838: PPUSH
38839: LD_VAR 0 5
38843: PPUSH
38844: CALL_OW 307
38848: IFFALSE 38690
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38850: LD_VAR 0 7
38854: PPUSH
38855: LD_VAR 0 4
38859: PPUSH
38860: LD_VAR 0 5
38864: PPUSH
38865: LD_VAR 0 8
38869: PUSH
38870: LD_VAR 0 3
38874: ARRAY
38875: PPUSH
38876: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38880: LD_INT 35
38882: PPUSH
38883: CALL_OW 67
// until not HasTask ( tmp ) ;
38887: LD_VAR 0 7
38891: PPUSH
38892: CALL_OW 314
38896: NOT
38897: IFFALSE 38880
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38899: LD_ADDR_EXP 86
38903: PUSH
38904: LD_EXP 86
38908: PPUSH
38909: LD_VAR 0 2
38913: PUSH
38914: LD_EXP 86
38918: PUSH
38919: LD_VAR 0 2
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: PLUS
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PPUSH
38933: LD_VAR 0 8
38937: PUSH
38938: LD_VAR 0 3
38942: ARRAY
38943: PPUSH
38944: CALL 53565 0 3
38948: ST_TO_ADDR
// end ;
38949: GO 38607
38951: POP
38952: POP
// MC_Reset ( i , 124 ) ;
38953: LD_VAR 0 2
38957: PPUSH
38958: LD_INT 124
38960: PPUSH
38961: CALL 22107 0 2
// end ; end ;
38965: GO 38362
38967: POP
38968: POP
// end ;
38969: LD_VAR 0 1
38973: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38974: LD_INT 0
38976: PPUSH
38977: PPUSH
38978: PPUSH
// if not mc_bases then
38979: LD_EXP 50
38983: NOT
38984: IFFALSE 38988
// exit ;
38986: GO 39594
// for i = 1 to mc_bases do
38988: LD_ADDR_VAR 0 2
38992: PUSH
38993: DOUBLE
38994: LD_INT 1
38996: DEC
38997: ST_TO_ADDR
38998: LD_EXP 50
39002: PUSH
39003: FOR_TO
39004: IFFALSE 39592
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39006: LD_ADDR_VAR 0 3
39010: PUSH
39011: LD_EXP 50
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PPUSH
39022: LD_INT 25
39024: PUSH
39025: LD_INT 4
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PPUSH
39032: CALL_OW 72
39036: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39037: LD_VAR 0 3
39041: NOT
39042: PUSH
39043: LD_EXP 87
39047: PUSH
39048: LD_VAR 0 2
39052: ARRAY
39053: NOT
39054: OR
39055: PUSH
39056: LD_EXP 50
39060: PUSH
39061: LD_VAR 0 2
39065: ARRAY
39066: PPUSH
39067: LD_INT 2
39069: PUSH
39070: LD_INT 30
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 30
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: LIST
39094: PPUSH
39095: CALL_OW 72
39099: NOT
39100: OR
39101: IFFALSE 39151
// begin if mc_deposits_finder [ i ] then
39103: LD_EXP 88
39107: PUSH
39108: LD_VAR 0 2
39112: ARRAY
39113: IFFALSE 39149
// begin MC_Reset ( i , 125 ) ;
39115: LD_VAR 0 2
39119: PPUSH
39120: LD_INT 125
39122: PPUSH
39123: CALL 22107 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39127: LD_ADDR_EXP 88
39131: PUSH
39132: LD_EXP 88
39136: PPUSH
39137: LD_VAR 0 2
39141: PPUSH
39142: EMPTY
39143: PPUSH
39144: CALL_OW 1
39148: ST_TO_ADDR
// end ; continue ;
39149: GO 39003
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39151: LD_EXP 87
39155: PUSH
39156: LD_VAR 0 2
39160: ARRAY
39161: PUSH
39162: LD_INT 1
39164: ARRAY
39165: PUSH
39166: LD_INT 3
39168: ARRAY
39169: PUSH
39170: LD_INT 1
39172: EQUAL
39173: PUSH
39174: LD_INT 20
39176: PPUSH
39177: LD_EXP 76
39181: PUSH
39182: LD_VAR 0 2
39186: ARRAY
39187: PPUSH
39188: CALL_OW 321
39192: PUSH
39193: LD_INT 2
39195: NONEQUAL
39196: AND
39197: IFFALSE 39247
// begin if mc_deposits_finder [ i ] then
39199: LD_EXP 88
39203: PUSH
39204: LD_VAR 0 2
39208: ARRAY
39209: IFFALSE 39245
// begin MC_Reset ( i , 125 ) ;
39211: LD_VAR 0 2
39215: PPUSH
39216: LD_INT 125
39218: PPUSH
39219: CALL 22107 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39223: LD_ADDR_EXP 88
39227: PUSH
39228: LD_EXP 88
39232: PPUSH
39233: LD_VAR 0 2
39237: PPUSH
39238: EMPTY
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// end ; continue ;
39245: GO 39003
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39247: LD_EXP 87
39251: PUSH
39252: LD_VAR 0 2
39256: ARRAY
39257: PUSH
39258: LD_INT 1
39260: ARRAY
39261: PUSH
39262: LD_INT 1
39264: ARRAY
39265: PPUSH
39266: LD_EXP 87
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PUSH
39277: LD_INT 1
39279: ARRAY
39280: PUSH
39281: LD_INT 2
39283: ARRAY
39284: PPUSH
39285: LD_EXP 76
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: PPUSH
39296: CALL_OW 440
39300: IFFALSE 39343
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39302: LD_ADDR_EXP 87
39306: PUSH
39307: LD_EXP 87
39311: PPUSH
39312: LD_VAR 0 2
39316: PPUSH
39317: LD_EXP 87
39321: PUSH
39322: LD_VAR 0 2
39326: ARRAY
39327: PPUSH
39328: LD_INT 1
39330: PPUSH
39331: CALL_OW 3
39335: PPUSH
39336: CALL_OW 1
39340: ST_TO_ADDR
39341: GO 39590
// begin if not mc_deposits_finder [ i ] then
39343: LD_EXP 88
39347: PUSH
39348: LD_VAR 0 2
39352: ARRAY
39353: NOT
39354: IFFALSE 39406
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39356: LD_ADDR_EXP 88
39360: PUSH
39361: LD_EXP 88
39365: PPUSH
39366: LD_VAR 0 2
39370: PPUSH
39371: LD_VAR 0 3
39375: PUSH
39376: LD_INT 1
39378: ARRAY
39379: PUSH
39380: EMPTY
39381: LIST
39382: PPUSH
39383: CALL_OW 1
39387: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39388: LD_VAR 0 3
39392: PUSH
39393: LD_INT 1
39395: ARRAY
39396: PPUSH
39397: LD_INT 125
39399: PPUSH
39400: CALL_OW 109
// end else
39404: GO 39590
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39406: LD_EXP 88
39410: PUSH
39411: LD_VAR 0 2
39415: ARRAY
39416: PUSH
39417: LD_INT 1
39419: ARRAY
39420: PPUSH
39421: CALL_OW 310
39425: IFFALSE 39448
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39427: LD_EXP 88
39431: PUSH
39432: LD_VAR 0 2
39436: ARRAY
39437: PUSH
39438: LD_INT 1
39440: ARRAY
39441: PPUSH
39442: CALL_OW 122
39446: GO 39590
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39448: LD_EXP 88
39452: PUSH
39453: LD_VAR 0 2
39457: ARRAY
39458: PUSH
39459: LD_INT 1
39461: ARRAY
39462: PPUSH
39463: CALL_OW 314
39467: NOT
39468: PUSH
39469: LD_EXP 88
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: PUSH
39480: LD_INT 1
39482: ARRAY
39483: PPUSH
39484: LD_EXP 87
39488: PUSH
39489: LD_VAR 0 2
39493: ARRAY
39494: PUSH
39495: LD_INT 1
39497: ARRAY
39498: PUSH
39499: LD_INT 1
39501: ARRAY
39502: PPUSH
39503: LD_EXP 87
39507: PUSH
39508: LD_VAR 0 2
39512: ARRAY
39513: PUSH
39514: LD_INT 1
39516: ARRAY
39517: PUSH
39518: LD_INT 2
39520: ARRAY
39521: PPUSH
39522: CALL_OW 297
39526: PUSH
39527: LD_INT 6
39529: GREATER
39530: AND
39531: IFFALSE 39590
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39533: LD_EXP 88
39537: PUSH
39538: LD_VAR 0 2
39542: ARRAY
39543: PUSH
39544: LD_INT 1
39546: ARRAY
39547: PPUSH
39548: LD_EXP 87
39552: PUSH
39553: LD_VAR 0 2
39557: ARRAY
39558: PUSH
39559: LD_INT 1
39561: ARRAY
39562: PUSH
39563: LD_INT 1
39565: ARRAY
39566: PPUSH
39567: LD_EXP 87
39571: PUSH
39572: LD_VAR 0 2
39576: ARRAY
39577: PUSH
39578: LD_INT 1
39580: ARRAY
39581: PUSH
39582: LD_INT 2
39584: ARRAY
39585: PPUSH
39586: CALL_OW 111
// end ; end ; end ;
39590: GO 39003
39592: POP
39593: POP
// end ;
39594: LD_VAR 0 1
39598: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39599: LD_INT 0
39601: PPUSH
39602: PPUSH
39603: PPUSH
39604: PPUSH
39605: PPUSH
39606: PPUSH
39607: PPUSH
39608: PPUSH
39609: PPUSH
39610: PPUSH
39611: PPUSH
// if not mc_bases then
39612: LD_EXP 50
39616: NOT
39617: IFFALSE 39621
// exit ;
39619: GO 40561
// for i = 1 to mc_bases do
39621: LD_ADDR_VAR 0 2
39625: PUSH
39626: DOUBLE
39627: LD_INT 1
39629: DEC
39630: ST_TO_ADDR
39631: LD_EXP 50
39635: PUSH
39636: FOR_TO
39637: IFFALSE 40559
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39639: LD_EXP 50
39643: PUSH
39644: LD_VAR 0 2
39648: ARRAY
39649: NOT
39650: PUSH
39651: LD_EXP 73
39655: PUSH
39656: LD_VAR 0 2
39660: ARRAY
39661: OR
39662: IFFALSE 39666
// continue ;
39664: GO 39636
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39666: LD_ADDR_VAR 0 7
39670: PUSH
39671: LD_EXP 50
39675: PUSH
39676: LD_VAR 0 2
39680: ARRAY
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: PPUSH
39686: CALL_OW 248
39690: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39691: LD_VAR 0 7
39695: PUSH
39696: LD_INT 3
39698: EQUAL
39699: PUSH
39700: LD_EXP 69
39704: PUSH
39705: LD_VAR 0 2
39709: ARRAY
39710: PUSH
39711: LD_EXP 72
39715: PUSH
39716: LD_VAR 0 2
39720: ARRAY
39721: UNION
39722: PPUSH
39723: LD_INT 33
39725: PUSH
39726: LD_INT 2
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PPUSH
39733: CALL_OW 72
39737: NOT
39738: OR
39739: IFFALSE 39743
// continue ;
39741: GO 39636
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39743: LD_ADDR_VAR 0 9
39747: PUSH
39748: LD_EXP 50
39752: PUSH
39753: LD_VAR 0 2
39757: ARRAY
39758: PPUSH
39759: LD_INT 30
39761: PUSH
39762: LD_INT 36
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PPUSH
39769: CALL_OW 72
39773: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39774: LD_ADDR_VAR 0 10
39778: PUSH
39779: LD_EXP 69
39783: PUSH
39784: LD_VAR 0 2
39788: ARRAY
39789: PPUSH
39790: LD_INT 34
39792: PUSH
39793: LD_INT 31
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PPUSH
39800: CALL_OW 72
39804: ST_TO_ADDR
// if not cts and not mcts then
39805: LD_VAR 0 9
39809: NOT
39810: PUSH
39811: LD_VAR 0 10
39815: NOT
39816: AND
39817: IFFALSE 39821
// continue ;
39819: GO 39636
// x := cts ;
39821: LD_ADDR_VAR 0 11
39825: PUSH
39826: LD_VAR 0 9
39830: ST_TO_ADDR
// if not x then
39831: LD_VAR 0 11
39835: NOT
39836: IFFALSE 39848
// x := mcts ;
39838: LD_ADDR_VAR 0 11
39842: PUSH
39843: LD_VAR 0 10
39847: ST_TO_ADDR
// if not x then
39848: LD_VAR 0 11
39852: NOT
39853: IFFALSE 39857
// continue ;
39855: GO 39636
// if mc_remote_driver [ i ] then
39857: LD_EXP 90
39861: PUSH
39862: LD_VAR 0 2
39866: ARRAY
39867: IFFALSE 40254
// for j in mc_remote_driver [ i ] do
39869: LD_ADDR_VAR 0 3
39873: PUSH
39874: LD_EXP 90
39878: PUSH
39879: LD_VAR 0 2
39883: ARRAY
39884: PUSH
39885: FOR_IN
39886: IFFALSE 40252
// begin if GetClass ( j ) <> 3 then
39888: LD_VAR 0 3
39892: PPUSH
39893: CALL_OW 257
39897: PUSH
39898: LD_INT 3
39900: NONEQUAL
39901: IFFALSE 39954
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39903: LD_ADDR_EXP 90
39907: PUSH
39908: LD_EXP 90
39912: PPUSH
39913: LD_VAR 0 2
39917: PPUSH
39918: LD_EXP 90
39922: PUSH
39923: LD_VAR 0 2
39927: ARRAY
39928: PUSH
39929: LD_VAR 0 3
39933: DIFF
39934: PPUSH
39935: CALL_OW 1
39939: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39940: LD_VAR 0 3
39944: PPUSH
39945: LD_INT 0
39947: PPUSH
39948: CALL_OW 109
// continue ;
39952: GO 39885
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39954: LD_EXP 69
39958: PUSH
39959: LD_VAR 0 2
39963: ARRAY
39964: PPUSH
39965: LD_INT 34
39967: PUSH
39968: LD_INT 31
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 58
39977: PUSH
39978: EMPTY
39979: LIST
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PPUSH
39985: CALL_OW 72
39989: PUSH
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL 82869 0 1
39999: NOT
40000: AND
40001: IFFALSE 40072
// begin if IsInUnit ( j ) then
40003: LD_VAR 0 3
40007: PPUSH
40008: CALL_OW 310
40012: IFFALSE 40023
// ComExitBuilding ( j ) ;
40014: LD_VAR 0 3
40018: PPUSH
40019: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40023: LD_VAR 0 3
40027: PPUSH
40028: LD_EXP 69
40032: PUSH
40033: LD_VAR 0 2
40037: ARRAY
40038: PPUSH
40039: LD_INT 34
40041: PUSH
40042: LD_INT 31
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 58
40051: PUSH
40052: EMPTY
40053: LIST
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PPUSH
40059: CALL_OW 72
40063: PUSH
40064: LD_INT 1
40066: ARRAY
40067: PPUSH
40068: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40072: LD_VAR 0 3
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: PUSH
40083: LD_VAR 0 3
40087: PPUSH
40088: CALL_OW 310
40092: PPUSH
40093: CALL_OW 266
40097: PUSH
40098: LD_INT 36
40100: NONEQUAL
40101: PUSH
40102: LD_VAR 0 3
40106: PPUSH
40107: CALL 82869 0 1
40111: NOT
40112: AND
40113: OR
40114: IFFALSE 40250
// begin if IsInUnit ( j ) then
40116: LD_VAR 0 3
40120: PPUSH
40121: CALL_OW 310
40125: IFFALSE 40136
// ComExitBuilding ( j ) ;
40127: LD_VAR 0 3
40131: PPUSH
40132: CALL_OW 122
// ct := 0 ;
40136: LD_ADDR_VAR 0 8
40140: PUSH
40141: LD_INT 0
40143: ST_TO_ADDR
// for k in x do
40144: LD_ADDR_VAR 0 4
40148: PUSH
40149: LD_VAR 0 11
40153: PUSH
40154: FOR_IN
40155: IFFALSE 40228
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40157: LD_VAR 0 4
40161: PPUSH
40162: CALL_OW 264
40166: PUSH
40167: LD_INT 31
40169: EQUAL
40170: PUSH
40171: LD_VAR 0 4
40175: PPUSH
40176: CALL_OW 311
40180: NOT
40181: AND
40182: PUSH
40183: LD_VAR 0 4
40187: PPUSH
40188: CALL_OW 266
40192: PUSH
40193: LD_INT 36
40195: EQUAL
40196: PUSH
40197: LD_VAR 0 4
40201: PPUSH
40202: CALL_OW 313
40206: PUSH
40207: LD_INT 3
40209: LESS
40210: AND
40211: OR
40212: IFFALSE 40226
// begin ct := k ;
40214: LD_ADDR_VAR 0 8
40218: PUSH
40219: LD_VAR 0 4
40223: ST_TO_ADDR
// break ;
40224: GO 40228
// end ;
40226: GO 40154
40228: POP
40229: POP
// if ct then
40230: LD_VAR 0 8
40234: IFFALSE 40250
// ComEnterUnit ( j , ct ) ;
40236: LD_VAR 0 3
40240: PPUSH
40241: LD_VAR 0 8
40245: PPUSH
40246: CALL_OW 120
// end ; end ;
40250: GO 39885
40252: POP
40253: POP
// places := 0 ;
40254: LD_ADDR_VAR 0 5
40258: PUSH
40259: LD_INT 0
40261: ST_TO_ADDR
// for j = 1 to x do
40262: LD_ADDR_VAR 0 3
40266: PUSH
40267: DOUBLE
40268: LD_INT 1
40270: DEC
40271: ST_TO_ADDR
40272: LD_VAR 0 11
40276: PUSH
40277: FOR_TO
40278: IFFALSE 40354
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40280: LD_VAR 0 11
40284: PUSH
40285: LD_VAR 0 3
40289: ARRAY
40290: PPUSH
40291: CALL_OW 264
40295: PUSH
40296: LD_INT 31
40298: EQUAL
40299: IFFALSE 40317
// places := places + 1 else
40301: LD_ADDR_VAR 0 5
40305: PUSH
40306: LD_VAR 0 5
40310: PUSH
40311: LD_INT 1
40313: PLUS
40314: ST_TO_ADDR
40315: GO 40352
// if GetBType ( x [ j ] ) = b_control_tower then
40317: LD_VAR 0 11
40321: PUSH
40322: LD_VAR 0 3
40326: ARRAY
40327: PPUSH
40328: CALL_OW 266
40332: PUSH
40333: LD_INT 36
40335: EQUAL
40336: IFFALSE 40352
// places := places + 3 ;
40338: LD_ADDR_VAR 0 5
40342: PUSH
40343: LD_VAR 0 5
40347: PUSH
40348: LD_INT 3
40350: PLUS
40351: ST_TO_ADDR
40352: GO 40277
40354: POP
40355: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40356: LD_VAR 0 5
40360: PUSH
40361: LD_INT 0
40363: EQUAL
40364: PUSH
40365: LD_VAR 0 5
40369: PUSH
40370: LD_EXP 90
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: LESSEQUAL
40381: OR
40382: IFFALSE 40386
// continue ;
40384: GO 39636
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40386: LD_ADDR_VAR 0 6
40390: PUSH
40391: LD_EXP 50
40395: PUSH
40396: LD_VAR 0 2
40400: ARRAY
40401: PPUSH
40402: LD_INT 25
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PPUSH
40412: CALL_OW 72
40416: PUSH
40417: LD_EXP 90
40421: PUSH
40422: LD_VAR 0 2
40426: ARRAY
40427: DIFF
40428: PPUSH
40429: LD_INT 3
40431: PPUSH
40432: CALL 83769 0 2
40436: ST_TO_ADDR
// for j in tmp do
40437: LD_ADDR_VAR 0 3
40441: PUSH
40442: LD_VAR 0 6
40446: PUSH
40447: FOR_IN
40448: IFFALSE 40483
// if GetTag ( j ) > 0 then
40450: LD_VAR 0 3
40454: PPUSH
40455: CALL_OW 110
40459: PUSH
40460: LD_INT 0
40462: GREATER
40463: IFFALSE 40481
// tmp := tmp diff j ;
40465: LD_ADDR_VAR 0 6
40469: PUSH
40470: LD_VAR 0 6
40474: PUSH
40475: LD_VAR 0 3
40479: DIFF
40480: ST_TO_ADDR
40481: GO 40447
40483: POP
40484: POP
// if not tmp then
40485: LD_VAR 0 6
40489: NOT
40490: IFFALSE 40494
// continue ;
40492: GO 39636
// if places then
40494: LD_VAR 0 5
40498: IFFALSE 40557
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40500: LD_ADDR_EXP 90
40504: PUSH
40505: LD_EXP 90
40509: PPUSH
40510: LD_VAR 0 2
40514: PPUSH
40515: LD_EXP 90
40519: PUSH
40520: LD_VAR 0 2
40524: ARRAY
40525: PUSH
40526: LD_VAR 0 6
40530: PUSH
40531: LD_INT 1
40533: ARRAY
40534: UNION
40535: PPUSH
40536: CALL_OW 1
40540: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40541: LD_VAR 0 6
40545: PUSH
40546: LD_INT 1
40548: ARRAY
40549: PPUSH
40550: LD_INT 126
40552: PPUSH
40553: CALL_OW 109
// end ; end ;
40557: GO 39636
40559: POP
40560: POP
// end ;
40561: LD_VAR 0 1
40565: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40566: LD_INT 0
40568: PPUSH
40569: PPUSH
40570: PPUSH
40571: PPUSH
40572: PPUSH
40573: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40574: LD_VAR 0 1
40578: NOT
40579: PUSH
40580: LD_VAR 0 2
40584: NOT
40585: OR
40586: PUSH
40587: LD_VAR 0 3
40591: NOT
40592: OR
40593: PUSH
40594: LD_VAR 0 4
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: LD_INT 2
40604: PUSH
40605: LD_INT 3
40607: PUSH
40608: LD_INT 4
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: LD_INT 8
40616: PUSH
40617: LD_INT 9
40619: PUSH
40620: LD_INT 15
40622: PUSH
40623: LD_INT 16
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: LIST
40636: IN
40637: NOT
40638: OR
40639: IFFALSE 40643
// exit ;
40641: GO 41543
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40643: LD_ADDR_VAR 0 2
40647: PUSH
40648: LD_VAR 0 2
40652: PPUSH
40653: LD_INT 21
40655: PUSH
40656: LD_INT 3
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 24
40665: PUSH
40666: LD_INT 250
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PPUSH
40677: CALL_OW 72
40681: ST_TO_ADDR
// case class of 1 , 15 :
40682: LD_VAR 0 4
40686: PUSH
40687: LD_INT 1
40689: DOUBLE
40690: EQUAL
40691: IFTRUE 40701
40693: LD_INT 15
40695: DOUBLE
40696: EQUAL
40697: IFTRUE 40701
40699: GO 40786
40701: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40702: LD_ADDR_VAR 0 8
40706: PUSH
40707: LD_VAR 0 2
40711: PPUSH
40712: LD_INT 2
40714: PUSH
40715: LD_INT 30
40717: PUSH
40718: LD_INT 32
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 30
40727: PUSH
40728: LD_INT 31
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: PPUSH
40740: CALL_OW 72
40744: PUSH
40745: LD_VAR 0 2
40749: PPUSH
40750: LD_INT 2
40752: PUSH
40753: LD_INT 30
40755: PUSH
40756: LD_INT 4
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 30
40765: PUSH
40766: LD_INT 5
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: PPUSH
40778: CALL_OW 72
40782: ADD
40783: ST_TO_ADDR
40784: GO 41032
40786: LD_INT 2
40788: DOUBLE
40789: EQUAL
40790: IFTRUE 40800
40792: LD_INT 16
40794: DOUBLE
40795: EQUAL
40796: IFTRUE 40800
40798: GO 40846
40800: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40801: LD_ADDR_VAR 0 8
40805: PUSH
40806: LD_VAR 0 2
40810: PPUSH
40811: LD_INT 2
40813: PUSH
40814: LD_INT 30
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: PUSH
40824: LD_INT 30
40826: PUSH
40827: LD_INT 1
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: LIST
40838: PPUSH
40839: CALL_OW 72
40843: ST_TO_ADDR
40844: GO 41032
40846: LD_INT 3
40848: DOUBLE
40849: EQUAL
40850: IFTRUE 40854
40852: GO 40900
40854: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40855: LD_ADDR_VAR 0 8
40859: PUSH
40860: LD_VAR 0 2
40864: PPUSH
40865: LD_INT 2
40867: PUSH
40868: LD_INT 30
40870: PUSH
40871: LD_INT 2
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 30
40880: PUSH
40881: LD_INT 3
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: LIST
40892: PPUSH
40893: CALL_OW 72
40897: ST_TO_ADDR
40898: GO 41032
40900: LD_INT 4
40902: DOUBLE
40903: EQUAL
40904: IFTRUE 40908
40906: GO 40965
40908: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40909: LD_ADDR_VAR 0 8
40913: PUSH
40914: LD_VAR 0 2
40918: PPUSH
40919: LD_INT 2
40921: PUSH
40922: LD_INT 30
40924: PUSH
40925: LD_INT 6
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 30
40934: PUSH
40935: LD_INT 7
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 30
40944: PUSH
40945: LD_INT 8
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: PPUSH
40958: CALL_OW 72
40962: ST_TO_ADDR
40963: GO 41032
40965: LD_INT 5
40967: DOUBLE
40968: EQUAL
40969: IFTRUE 40985
40971: LD_INT 8
40973: DOUBLE
40974: EQUAL
40975: IFTRUE 40985
40977: LD_INT 9
40979: DOUBLE
40980: EQUAL
40981: IFTRUE 40985
40983: GO 41031
40985: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40986: LD_ADDR_VAR 0 8
40990: PUSH
40991: LD_VAR 0 2
40995: PPUSH
40996: LD_INT 2
40998: PUSH
40999: LD_INT 30
41001: PUSH
41002: LD_INT 4
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 30
41011: PUSH
41012: LD_INT 5
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: LIST
41023: PPUSH
41024: CALL_OW 72
41028: ST_TO_ADDR
41029: GO 41032
41031: POP
// if not tmp then
41032: LD_VAR 0 8
41036: NOT
41037: IFFALSE 41041
// exit ;
41039: GO 41543
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41041: LD_VAR 0 4
41045: PUSH
41046: LD_INT 1
41048: PUSH
41049: LD_INT 15
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: IN
41056: PUSH
41057: LD_EXP 59
41061: PUSH
41062: LD_VAR 0 1
41066: ARRAY
41067: AND
41068: IFFALSE 41224
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41070: LD_ADDR_VAR 0 9
41074: PUSH
41075: LD_EXP 59
41079: PUSH
41080: LD_VAR 0 1
41084: ARRAY
41085: PUSH
41086: LD_INT 1
41088: ARRAY
41089: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41090: LD_VAR 0 9
41094: PUSH
41095: LD_EXP 60
41099: PUSH
41100: LD_VAR 0 1
41104: ARRAY
41105: IN
41106: NOT
41107: IFFALSE 41222
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41109: LD_ADDR_EXP 60
41113: PUSH
41114: LD_EXP 60
41118: PPUSH
41119: LD_VAR 0 1
41123: PUSH
41124: LD_EXP 60
41128: PUSH
41129: LD_VAR 0 1
41133: ARRAY
41134: PUSH
41135: LD_INT 1
41137: PLUS
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PPUSH
41143: LD_VAR 0 9
41147: PPUSH
41148: CALL 53565 0 3
41152: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41153: LD_ADDR_EXP 59
41157: PUSH
41158: LD_EXP 59
41162: PPUSH
41163: LD_VAR 0 1
41167: PPUSH
41168: LD_EXP 59
41172: PUSH
41173: LD_VAR 0 1
41177: ARRAY
41178: PUSH
41179: LD_VAR 0 9
41183: DIFF
41184: PPUSH
41185: CALL_OW 1
41189: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41190: LD_VAR 0 3
41194: PPUSH
41195: LD_EXP 60
41199: PUSH
41200: LD_VAR 0 1
41204: ARRAY
41205: PUSH
41206: LD_EXP 60
41210: PUSH
41211: LD_VAR 0 1
41215: ARRAY
41216: ARRAY
41217: PPUSH
41218: CALL_OW 120
// end ; exit ;
41222: GO 41543
// end ; if tmp > 1 then
41224: LD_VAR 0 8
41228: PUSH
41229: LD_INT 1
41231: GREATER
41232: IFFALSE 41336
// for i = 2 to tmp do
41234: LD_ADDR_VAR 0 6
41238: PUSH
41239: DOUBLE
41240: LD_INT 2
41242: DEC
41243: ST_TO_ADDR
41244: LD_VAR 0 8
41248: PUSH
41249: FOR_TO
41250: IFFALSE 41334
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41252: LD_VAR 0 8
41256: PUSH
41257: LD_VAR 0 6
41261: ARRAY
41262: PPUSH
41263: CALL_OW 461
41267: PUSH
41268: LD_INT 6
41270: EQUAL
41271: IFFALSE 41332
// begin x := tmp [ i ] ;
41273: LD_ADDR_VAR 0 9
41277: PUSH
41278: LD_VAR 0 8
41282: PUSH
41283: LD_VAR 0 6
41287: ARRAY
41288: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41289: LD_ADDR_VAR 0 8
41293: PUSH
41294: LD_VAR 0 8
41298: PPUSH
41299: LD_VAR 0 6
41303: PPUSH
41304: CALL_OW 3
41308: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41309: LD_ADDR_VAR 0 8
41313: PUSH
41314: LD_VAR 0 8
41318: PPUSH
41319: LD_INT 1
41321: PPUSH
41322: LD_VAR 0 9
41326: PPUSH
41327: CALL_OW 2
41331: ST_TO_ADDR
// end ;
41332: GO 41249
41334: POP
41335: POP
// for i in tmp do
41336: LD_ADDR_VAR 0 6
41340: PUSH
41341: LD_VAR 0 8
41345: PUSH
41346: FOR_IN
41347: IFFALSE 41416
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41349: LD_VAR 0 6
41353: PPUSH
41354: CALL_OW 313
41358: PUSH
41359: LD_INT 6
41361: LESS
41362: PUSH
41363: LD_VAR 0 6
41367: PPUSH
41368: CALL_OW 266
41372: PUSH
41373: LD_INT 31
41375: PUSH
41376: LD_INT 32
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: IN
41383: NOT
41384: AND
41385: PUSH
41386: LD_VAR 0 6
41390: PPUSH
41391: CALL_OW 313
41395: PUSH
41396: LD_INT 0
41398: EQUAL
41399: OR
41400: IFFALSE 41414
// begin j := i ;
41402: LD_ADDR_VAR 0 7
41406: PUSH
41407: LD_VAR 0 6
41411: ST_TO_ADDR
// break ;
41412: GO 41416
// end ; end ;
41414: GO 41346
41416: POP
41417: POP
// if j then
41418: LD_VAR 0 7
41422: IFFALSE 41440
// ComEnterUnit ( unit , j ) else
41424: LD_VAR 0 3
41428: PPUSH
41429: LD_VAR 0 7
41433: PPUSH
41434: CALL_OW 120
41438: GO 41543
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41440: LD_ADDR_VAR 0 10
41444: PUSH
41445: LD_VAR 0 2
41449: PPUSH
41450: LD_INT 2
41452: PUSH
41453: LD_INT 30
41455: PUSH
41456: LD_INT 0
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 30
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: LIST
41477: PPUSH
41478: CALL_OW 72
41482: ST_TO_ADDR
// if depot then
41483: LD_VAR 0 10
41487: IFFALSE 41543
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41489: LD_ADDR_VAR 0 10
41493: PUSH
41494: LD_VAR 0 10
41498: PPUSH
41499: LD_VAR 0 3
41503: PPUSH
41504: CALL_OW 74
41508: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41509: LD_VAR 0 3
41513: PPUSH
41514: LD_VAR 0 10
41518: PPUSH
41519: CALL_OW 296
41523: PUSH
41524: LD_INT 10
41526: GREATER
41527: IFFALSE 41543
// ComStandNearbyBuilding ( unit , depot ) ;
41529: LD_VAR 0 3
41533: PPUSH
41534: LD_VAR 0 10
41538: PPUSH
41539: CALL 50143 0 2
// end ; end ; end ;
41543: LD_VAR 0 5
41547: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41548: LD_INT 0
41550: PPUSH
41551: PPUSH
41552: PPUSH
41553: PPUSH
// if not mc_bases then
41554: LD_EXP 50
41558: NOT
41559: IFFALSE 41563
// exit ;
41561: GO 41802
// for i = 1 to mc_bases do
41563: LD_ADDR_VAR 0 2
41567: PUSH
41568: DOUBLE
41569: LD_INT 1
41571: DEC
41572: ST_TO_ADDR
41573: LD_EXP 50
41577: PUSH
41578: FOR_TO
41579: IFFALSE 41800
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41581: LD_ADDR_VAR 0 4
41585: PUSH
41586: LD_EXP 50
41590: PUSH
41591: LD_VAR 0 2
41595: ARRAY
41596: PPUSH
41597: LD_INT 21
41599: PUSH
41600: LD_INT 1
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PPUSH
41607: CALL_OW 72
41611: PUSH
41612: LD_EXP 79
41616: PUSH
41617: LD_VAR 0 2
41621: ARRAY
41622: UNION
41623: ST_TO_ADDR
// if not tmp then
41624: LD_VAR 0 4
41628: NOT
41629: IFFALSE 41633
// continue ;
41631: GO 41578
// for j in tmp do
41633: LD_ADDR_VAR 0 3
41637: PUSH
41638: LD_VAR 0 4
41642: PUSH
41643: FOR_IN
41644: IFFALSE 41796
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41646: LD_VAR 0 3
41650: PPUSH
41651: CALL_OW 110
41655: NOT
41656: PUSH
41657: LD_VAR 0 3
41661: PPUSH
41662: CALL_OW 314
41666: NOT
41667: AND
41668: PUSH
41669: LD_VAR 0 3
41673: PPUSH
41674: CALL_OW 311
41678: NOT
41679: AND
41680: PUSH
41681: LD_VAR 0 3
41685: PPUSH
41686: CALL_OW 310
41690: NOT
41691: AND
41692: PUSH
41693: LD_VAR 0 3
41697: PUSH
41698: LD_EXP 53
41702: PUSH
41703: LD_VAR 0 2
41707: ARRAY
41708: PUSH
41709: LD_INT 1
41711: ARRAY
41712: IN
41713: NOT
41714: AND
41715: PUSH
41716: LD_VAR 0 3
41720: PUSH
41721: LD_EXP 53
41725: PUSH
41726: LD_VAR 0 2
41730: ARRAY
41731: PUSH
41732: LD_INT 2
41734: ARRAY
41735: IN
41736: NOT
41737: AND
41738: PUSH
41739: LD_VAR 0 3
41743: PUSH
41744: LD_EXP 62
41748: PUSH
41749: LD_VAR 0 2
41753: ARRAY
41754: IN
41755: NOT
41756: AND
41757: IFFALSE 41794
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41759: LD_VAR 0 2
41763: PPUSH
41764: LD_EXP 50
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PPUSH
41775: LD_VAR 0 3
41779: PPUSH
41780: LD_VAR 0 3
41784: PPUSH
41785: CALL_OW 257
41789: PPUSH
41790: CALL 40566 0 4
// end ;
41794: GO 41643
41796: POP
41797: POP
// end ;
41798: GO 41578
41800: POP
41801: POP
// end ;
41802: LD_VAR 0 1
41806: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41807: LD_INT 0
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
41814: PPUSH
// if not mc_bases [ base ] then
41815: LD_EXP 50
41819: PUSH
41820: LD_VAR 0 1
41824: ARRAY
41825: NOT
41826: IFFALSE 41830
// exit ;
41828: GO 42012
// tmp := [ ] ;
41830: LD_ADDR_VAR 0 6
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41837: LD_ADDR_VAR 0 7
41841: PUSH
41842: LD_VAR 0 3
41846: PPUSH
41847: LD_INT 0
41849: PPUSH
41850: CALL_OW 517
41854: ST_TO_ADDR
// if not list then
41855: LD_VAR 0 7
41859: NOT
41860: IFFALSE 41864
// exit ;
41862: GO 42012
// for i = 1 to amount do
41864: LD_ADDR_VAR 0 5
41868: PUSH
41869: DOUBLE
41870: LD_INT 1
41872: DEC
41873: ST_TO_ADDR
41874: LD_VAR 0 2
41878: PUSH
41879: FOR_TO
41880: IFFALSE 41960
// begin x := rand ( 1 , list [ 1 ] ) ;
41882: LD_ADDR_VAR 0 8
41886: PUSH
41887: LD_INT 1
41889: PPUSH
41890: LD_VAR 0 7
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: PPUSH
41899: CALL_OW 12
41903: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41904: LD_ADDR_VAR 0 6
41908: PUSH
41909: LD_VAR 0 6
41913: PPUSH
41914: LD_VAR 0 5
41918: PPUSH
41919: LD_VAR 0 7
41923: PUSH
41924: LD_INT 1
41926: ARRAY
41927: PUSH
41928: LD_VAR 0 8
41932: ARRAY
41933: PUSH
41934: LD_VAR 0 7
41938: PUSH
41939: LD_INT 2
41941: ARRAY
41942: PUSH
41943: LD_VAR 0 8
41947: ARRAY
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PPUSH
41953: CALL_OW 1
41957: ST_TO_ADDR
// end ;
41958: GO 41879
41960: POP
41961: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41962: LD_ADDR_EXP 63
41966: PUSH
41967: LD_EXP 63
41971: PPUSH
41972: LD_VAR 0 1
41976: PPUSH
41977: LD_VAR 0 6
41981: PPUSH
41982: CALL_OW 1
41986: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41987: LD_ADDR_EXP 65
41991: PUSH
41992: LD_EXP 65
41996: PPUSH
41997: LD_VAR 0 1
42001: PPUSH
42002: LD_VAR 0 3
42006: PPUSH
42007: CALL_OW 1
42011: ST_TO_ADDR
// end ;
42012: LD_VAR 0 4
42016: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42017: LD_INT 0
42019: PPUSH
// if not mc_bases [ base ] then
42020: LD_EXP 50
42024: PUSH
42025: LD_VAR 0 1
42029: ARRAY
42030: NOT
42031: IFFALSE 42035
// exit ;
42033: GO 42060
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42035: LD_ADDR_EXP 55
42039: PUSH
42040: LD_EXP 55
42044: PPUSH
42045: LD_VAR 0 1
42049: PPUSH
42050: LD_VAR 0 2
42054: PPUSH
42055: CALL_OW 1
42059: ST_TO_ADDR
// end ;
42060: LD_VAR 0 3
42064: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42065: LD_INT 0
42067: PPUSH
// if not mc_bases [ base ] then
42068: LD_EXP 50
42072: PUSH
42073: LD_VAR 0 1
42077: ARRAY
42078: NOT
42079: IFFALSE 42083
// exit ;
42081: GO 42120
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42083: LD_ADDR_EXP 55
42087: PUSH
42088: LD_EXP 55
42092: PPUSH
42093: LD_VAR 0 1
42097: PPUSH
42098: LD_EXP 55
42102: PUSH
42103: LD_VAR 0 1
42107: ARRAY
42108: PUSH
42109: LD_VAR 0 2
42113: UNION
42114: PPUSH
42115: CALL_OW 1
42119: ST_TO_ADDR
// end ;
42120: LD_VAR 0 3
42124: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42125: LD_INT 0
42127: PPUSH
// if not mc_bases [ base ] then
42128: LD_EXP 50
42132: PUSH
42133: LD_VAR 0 1
42137: ARRAY
42138: NOT
42139: IFFALSE 42143
// exit ;
42141: GO 42168
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42143: LD_ADDR_EXP 71
42147: PUSH
42148: LD_EXP 71
42152: PPUSH
42153: LD_VAR 0 1
42157: PPUSH
42158: LD_VAR 0 2
42162: PPUSH
42163: CALL_OW 1
42167: ST_TO_ADDR
// end ;
42168: LD_VAR 0 3
42172: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42173: LD_INT 0
42175: PPUSH
// if not mc_bases [ base ] then
42176: LD_EXP 50
42180: PUSH
42181: LD_VAR 0 1
42185: ARRAY
42186: NOT
42187: IFFALSE 42191
// exit ;
42189: GO 42228
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42191: LD_ADDR_EXP 71
42195: PUSH
42196: LD_EXP 71
42200: PPUSH
42201: LD_VAR 0 1
42205: PPUSH
42206: LD_EXP 71
42210: PUSH
42211: LD_VAR 0 1
42215: ARRAY
42216: PUSH
42217: LD_VAR 0 2
42221: ADD
42222: PPUSH
42223: CALL_OW 1
42227: ST_TO_ADDR
// end ;
42228: LD_VAR 0 3
42232: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42233: LD_INT 0
42235: PPUSH
// if not mc_bases [ base ] then
42236: LD_EXP 50
42240: PUSH
42241: LD_VAR 0 1
42245: ARRAY
42246: NOT
42247: IFFALSE 42251
// exit ;
42249: GO 42305
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42251: LD_ADDR_EXP 72
42255: PUSH
42256: LD_EXP 72
42260: PPUSH
42261: LD_VAR 0 1
42265: PPUSH
42266: LD_VAR 0 2
42270: PPUSH
42271: CALL_OW 1
42275: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42276: LD_ADDR_EXP 61
42280: PUSH
42281: LD_EXP 61
42285: PPUSH
42286: LD_VAR 0 1
42290: PPUSH
42291: LD_VAR 0 2
42295: PUSH
42296: LD_INT 0
42298: PLUS
42299: PPUSH
42300: CALL_OW 1
42304: ST_TO_ADDR
// end ;
42305: LD_VAR 0 3
42309: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42310: LD_INT 0
42312: PPUSH
// if not mc_bases [ base ] then
42313: LD_EXP 50
42317: PUSH
42318: LD_VAR 0 1
42322: ARRAY
42323: NOT
42324: IFFALSE 42328
// exit ;
42326: GO 42353
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42328: LD_ADDR_EXP 61
42332: PUSH
42333: LD_EXP 61
42337: PPUSH
42338: LD_VAR 0 1
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: CALL_OW 1
42352: ST_TO_ADDR
// end ;
42353: LD_VAR 0 3
42357: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42358: LD_INT 0
42360: PPUSH
42361: PPUSH
42362: PPUSH
42363: PPUSH
// if not mc_bases [ base ] then
42364: LD_EXP 50
42368: PUSH
42369: LD_VAR 0 1
42373: ARRAY
42374: NOT
42375: IFFALSE 42379
// exit ;
42377: GO 42444
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42379: LD_ADDR_EXP 70
42383: PUSH
42384: LD_EXP 70
42388: PPUSH
42389: LD_VAR 0 1
42393: PUSH
42394: LD_EXP 70
42398: PUSH
42399: LD_VAR 0 1
42403: ARRAY
42404: PUSH
42405: LD_INT 1
42407: PLUS
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PPUSH
42413: LD_VAR 0 1
42417: PUSH
42418: LD_VAR 0 2
42422: PUSH
42423: LD_VAR 0 3
42427: PUSH
42428: LD_VAR 0 4
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: PPUSH
42439: CALL 53565 0 3
42443: ST_TO_ADDR
// end ;
42444: LD_VAR 0 5
42448: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42449: LD_INT 0
42451: PPUSH
// if not mc_bases [ base ] then
42452: LD_EXP 50
42456: PUSH
42457: LD_VAR 0 1
42461: ARRAY
42462: NOT
42463: IFFALSE 42467
// exit ;
42465: GO 42492
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42467: LD_ADDR_EXP 87
42471: PUSH
42472: LD_EXP 87
42476: PPUSH
42477: LD_VAR 0 1
42481: PPUSH
42482: LD_VAR 0 2
42486: PPUSH
42487: CALL_OW 1
42491: ST_TO_ADDR
// end ;
42492: LD_VAR 0 3
42496: RET
// export function MC_GetMinesField ( base ) ; begin
42497: LD_INT 0
42499: PPUSH
// result := mc_mines [ base ] ;
42500: LD_ADDR_VAR 0 2
42504: PUSH
42505: LD_EXP 63
42509: PUSH
42510: LD_VAR 0 1
42514: ARRAY
42515: ST_TO_ADDR
// end ;
42516: LD_VAR 0 2
42520: RET
// export function MC_GetProduceList ( base ) ; begin
42521: LD_INT 0
42523: PPUSH
// result := mc_produce [ base ] ;
42524: LD_ADDR_VAR 0 2
42528: PUSH
42529: LD_EXP 71
42533: PUSH
42534: LD_VAR 0 1
42538: ARRAY
42539: ST_TO_ADDR
// end ;
42540: LD_VAR 0 2
42544: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42545: LD_INT 0
42547: PPUSH
42548: PPUSH
// if not mc_bases then
42549: LD_EXP 50
42553: NOT
42554: IFFALSE 42558
// exit ;
42556: GO 42623
// if mc_bases [ base ] then
42558: LD_EXP 50
42562: PUSH
42563: LD_VAR 0 1
42567: ARRAY
42568: IFFALSE 42623
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42570: LD_ADDR_VAR 0 3
42574: PUSH
42575: LD_EXP 50
42579: PUSH
42580: LD_VAR 0 1
42584: ARRAY
42585: PPUSH
42586: LD_INT 30
42588: PUSH
42589: LD_VAR 0 2
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PPUSH
42598: CALL_OW 72
42602: ST_TO_ADDR
// if result then
42603: LD_VAR 0 3
42607: IFFALSE 42623
// result := result [ 1 ] ;
42609: LD_ADDR_VAR 0 3
42613: PUSH
42614: LD_VAR 0 3
42618: PUSH
42619: LD_INT 1
42621: ARRAY
42622: ST_TO_ADDR
// end ; end ;
42623: LD_VAR 0 3
42627: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42628: LD_INT 0
42630: PPUSH
42631: PPUSH
// if not mc_bases then
42632: LD_EXP 50
42636: NOT
42637: IFFALSE 42641
// exit ;
42639: GO 42686
// if mc_bases [ base ] then
42641: LD_EXP 50
42645: PUSH
42646: LD_VAR 0 1
42650: ARRAY
42651: IFFALSE 42686
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42653: LD_ADDR_VAR 0 3
42657: PUSH
42658: LD_EXP 50
42662: PUSH
42663: LD_VAR 0 1
42667: ARRAY
42668: PPUSH
42669: LD_INT 30
42671: PUSH
42672: LD_VAR 0 2
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PPUSH
42681: CALL_OW 72
42685: ST_TO_ADDR
// end ;
42686: LD_VAR 0 3
42690: RET
// export function MC_SetTame ( base , area ) ; begin
42691: LD_INT 0
42693: PPUSH
// if not mc_bases or not base then
42694: LD_EXP 50
42698: NOT
42699: PUSH
42700: LD_VAR 0 1
42704: NOT
42705: OR
42706: IFFALSE 42710
// exit ;
42708: GO 42735
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42710: LD_ADDR_EXP 78
42714: PUSH
42715: LD_EXP 78
42719: PPUSH
42720: LD_VAR 0 1
42724: PPUSH
42725: LD_VAR 0 2
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// end ;
42735: LD_VAR 0 3
42739: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42740: LD_INT 0
42742: PPUSH
42743: PPUSH
// if not mc_bases or not base then
42744: LD_EXP 50
42748: NOT
42749: PUSH
42750: LD_VAR 0 1
42754: NOT
42755: OR
42756: IFFALSE 42760
// exit ;
42758: GO 42862
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42760: LD_ADDR_VAR 0 4
42764: PUSH
42765: LD_EXP 50
42769: PUSH
42770: LD_VAR 0 1
42774: ARRAY
42775: PPUSH
42776: LD_INT 30
42778: PUSH
42779: LD_VAR 0 2
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PPUSH
42788: CALL_OW 72
42792: ST_TO_ADDR
// if not tmp then
42793: LD_VAR 0 4
42797: NOT
42798: IFFALSE 42802
// exit ;
42800: GO 42862
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42802: LD_ADDR_EXP 82
42806: PUSH
42807: LD_EXP 82
42811: PPUSH
42812: LD_VAR 0 1
42816: PPUSH
42817: LD_EXP 82
42821: PUSH
42822: LD_VAR 0 1
42826: ARRAY
42827: PPUSH
42828: LD_EXP 82
42832: PUSH
42833: LD_VAR 0 1
42837: ARRAY
42838: PUSH
42839: LD_INT 1
42841: PLUS
42842: PPUSH
42843: LD_VAR 0 4
42847: PUSH
42848: LD_INT 1
42850: ARRAY
42851: PPUSH
42852: CALL_OW 2
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// end ;
42862: LD_VAR 0 3
42866: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42867: LD_INT 0
42869: PPUSH
42870: PPUSH
// if not mc_bases or not base or not kinds then
42871: LD_EXP 50
42875: NOT
42876: PUSH
42877: LD_VAR 0 1
42881: NOT
42882: OR
42883: PUSH
42884: LD_VAR 0 2
42888: NOT
42889: OR
42890: IFFALSE 42894
// exit ;
42892: GO 42955
// for i in kinds do
42894: LD_ADDR_VAR 0 4
42898: PUSH
42899: LD_VAR 0 2
42903: PUSH
42904: FOR_IN
42905: IFFALSE 42953
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42907: LD_ADDR_EXP 84
42911: PUSH
42912: LD_EXP 84
42916: PPUSH
42917: LD_VAR 0 1
42921: PUSH
42922: LD_EXP 84
42926: PUSH
42927: LD_VAR 0 1
42931: ARRAY
42932: PUSH
42933: LD_INT 1
42935: PLUS
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PPUSH
42941: LD_VAR 0 4
42945: PPUSH
42946: CALL 53565 0 3
42950: ST_TO_ADDR
42951: GO 42904
42953: POP
42954: POP
// end ;
42955: LD_VAR 0 3
42959: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42960: LD_INT 0
42962: PPUSH
// if not mc_bases or not base or not areas then
42963: LD_EXP 50
42967: NOT
42968: PUSH
42969: LD_VAR 0 1
42973: NOT
42974: OR
42975: PUSH
42976: LD_VAR 0 2
42980: NOT
42981: OR
42982: IFFALSE 42986
// exit ;
42984: GO 43011
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42986: LD_ADDR_EXP 68
42990: PUSH
42991: LD_EXP 68
42995: PPUSH
42996: LD_VAR 0 1
43000: PPUSH
43001: LD_VAR 0 2
43005: PPUSH
43006: CALL_OW 1
43010: ST_TO_ADDR
// end ;
43011: LD_VAR 0 3
43015: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43016: LD_INT 0
43018: PPUSH
// if not mc_bases or not base or not teleports_exit then
43019: LD_EXP 50
43023: NOT
43024: PUSH
43025: LD_VAR 0 1
43029: NOT
43030: OR
43031: PUSH
43032: LD_VAR 0 2
43036: NOT
43037: OR
43038: IFFALSE 43042
// exit ;
43040: GO 43067
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43042: LD_ADDR_EXP 85
43046: PUSH
43047: LD_EXP 85
43051: PPUSH
43052: LD_VAR 0 1
43056: PPUSH
43057: LD_VAR 0 2
43061: PPUSH
43062: CALL_OW 1
43066: ST_TO_ADDR
// end ;
43067: LD_VAR 0 3
43071: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43072: LD_INT 0
43074: PPUSH
43075: PPUSH
43076: PPUSH
// if not mc_bases or not base or not ext_list then
43077: LD_EXP 50
43081: NOT
43082: PUSH
43083: LD_VAR 0 1
43087: NOT
43088: OR
43089: PUSH
43090: LD_VAR 0 5
43094: NOT
43095: OR
43096: IFFALSE 43100
// exit ;
43098: GO 43273
// tmp := GetFacExtXYD ( x , y , d ) ;
43100: LD_ADDR_VAR 0 8
43104: PUSH
43105: LD_VAR 0 2
43109: PPUSH
43110: LD_VAR 0 3
43114: PPUSH
43115: LD_VAR 0 4
43119: PPUSH
43120: CALL 82899 0 3
43124: ST_TO_ADDR
// if not tmp then
43125: LD_VAR 0 8
43129: NOT
43130: IFFALSE 43134
// exit ;
43132: GO 43273
// for i in tmp do
43134: LD_ADDR_VAR 0 7
43138: PUSH
43139: LD_VAR 0 8
43143: PUSH
43144: FOR_IN
43145: IFFALSE 43271
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43147: LD_ADDR_EXP 55
43151: PUSH
43152: LD_EXP 55
43156: PPUSH
43157: LD_VAR 0 1
43161: PPUSH
43162: LD_EXP 55
43166: PUSH
43167: LD_VAR 0 1
43171: ARRAY
43172: PPUSH
43173: LD_EXP 55
43177: PUSH
43178: LD_VAR 0 1
43182: ARRAY
43183: PUSH
43184: LD_INT 1
43186: PLUS
43187: PPUSH
43188: LD_VAR 0 5
43192: PUSH
43193: LD_INT 1
43195: ARRAY
43196: PUSH
43197: LD_VAR 0 7
43201: PUSH
43202: LD_INT 1
43204: ARRAY
43205: PUSH
43206: LD_VAR 0 7
43210: PUSH
43211: LD_INT 2
43213: ARRAY
43214: PUSH
43215: LD_VAR 0 7
43219: PUSH
43220: LD_INT 3
43222: ARRAY
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: PPUSH
43230: CALL_OW 2
43234: PPUSH
43235: CALL_OW 1
43239: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43240: LD_ADDR_VAR 0 5
43244: PUSH
43245: LD_VAR 0 5
43249: PPUSH
43250: LD_INT 1
43252: PPUSH
43253: CALL_OW 3
43257: ST_TO_ADDR
// if not ext_list then
43258: LD_VAR 0 5
43262: NOT
43263: IFFALSE 43269
// exit ;
43265: POP
43266: POP
43267: GO 43273
// end ;
43269: GO 43144
43271: POP
43272: POP
// end ;
43273: LD_VAR 0 6
43277: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43278: LD_INT 0
43280: PPUSH
// if not mc_bases or not base or not weapon_list then
43281: LD_EXP 50
43285: NOT
43286: PUSH
43287: LD_VAR 0 1
43291: NOT
43292: OR
43293: PUSH
43294: LD_VAR 0 2
43298: NOT
43299: OR
43300: IFFALSE 43304
// exit ;
43302: GO 43329
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43304: LD_ADDR_EXP 89
43308: PUSH
43309: LD_EXP 89
43313: PPUSH
43314: LD_VAR 0 1
43318: PPUSH
43319: LD_VAR 0 2
43323: PPUSH
43324: CALL_OW 1
43328: ST_TO_ADDR
// end ;
43329: LD_VAR 0 3
43333: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43334: LD_INT 0
43336: PPUSH
// if not mc_bases or not base or not tech_list then
43337: LD_EXP 50
43341: NOT
43342: PUSH
43343: LD_VAR 0 1
43347: NOT
43348: OR
43349: PUSH
43350: LD_VAR 0 2
43354: NOT
43355: OR
43356: IFFALSE 43360
// exit ;
43358: GO 43385
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43360: LD_ADDR_EXP 77
43364: PUSH
43365: LD_EXP 77
43369: PPUSH
43370: LD_VAR 0 1
43374: PPUSH
43375: LD_VAR 0 2
43379: PPUSH
43380: CALL_OW 1
43384: ST_TO_ADDR
// end ;
43385: LD_VAR 0 3
43389: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43390: LD_INT 0
43392: PPUSH
// if not mc_bases or not parking_area or not base then
43393: LD_EXP 50
43397: NOT
43398: PUSH
43399: LD_VAR 0 2
43403: NOT
43404: OR
43405: PUSH
43406: LD_VAR 0 1
43410: NOT
43411: OR
43412: IFFALSE 43416
// exit ;
43414: GO 43441
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43416: LD_ADDR_EXP 74
43420: PUSH
43421: LD_EXP 74
43425: PPUSH
43426: LD_VAR 0 1
43430: PPUSH
43431: LD_VAR 0 2
43435: PPUSH
43436: CALL_OW 1
43440: ST_TO_ADDR
// end ;
43441: LD_VAR 0 3
43445: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43446: LD_INT 0
43448: PPUSH
// if not mc_bases or not base or not scan_area then
43449: LD_EXP 50
43453: NOT
43454: PUSH
43455: LD_VAR 0 1
43459: NOT
43460: OR
43461: PUSH
43462: LD_VAR 0 2
43466: NOT
43467: OR
43468: IFFALSE 43472
// exit ;
43470: GO 43497
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43472: LD_ADDR_EXP 75
43476: PUSH
43477: LD_EXP 75
43481: PPUSH
43482: LD_VAR 0 1
43486: PPUSH
43487: LD_VAR 0 2
43491: PPUSH
43492: CALL_OW 1
43496: ST_TO_ADDR
// end ;
43497: LD_VAR 0 3
43501: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43502: LD_INT 0
43504: PPUSH
43505: PPUSH
// if not mc_bases or not base then
43506: LD_EXP 50
43510: NOT
43511: PUSH
43512: LD_VAR 0 1
43516: NOT
43517: OR
43518: IFFALSE 43522
// exit ;
43520: GO 43586
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43522: LD_ADDR_VAR 0 3
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: LD_INT 2
43532: PUSH
43533: LD_INT 3
43535: PUSH
43536: LD_INT 4
43538: PUSH
43539: LD_INT 11
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43549: LD_ADDR_EXP 77
43553: PUSH
43554: LD_EXP 77
43558: PPUSH
43559: LD_VAR 0 1
43563: PPUSH
43564: LD_EXP 77
43568: PUSH
43569: LD_VAR 0 1
43573: ARRAY
43574: PUSH
43575: LD_VAR 0 3
43579: DIFF
43580: PPUSH
43581: CALL_OW 1
43585: ST_TO_ADDR
// end ;
43586: LD_VAR 0 2
43590: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43591: LD_INT 0
43593: PPUSH
// result := mc_vehicles [ base ] ;
43594: LD_ADDR_VAR 0 3
43598: PUSH
43599: LD_EXP 69
43603: PUSH
43604: LD_VAR 0 1
43608: ARRAY
43609: ST_TO_ADDR
// if onlyCombat then
43610: LD_VAR 0 2
43614: IFFALSE 43792
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43616: LD_ADDR_VAR 0 3
43620: PUSH
43621: LD_VAR 0 3
43625: PUSH
43626: LD_VAR 0 3
43630: PPUSH
43631: LD_INT 2
43633: PUSH
43634: LD_INT 34
43636: PUSH
43637: LD_INT 12
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 34
43646: PUSH
43647: LD_INT 51
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 34
43656: PUSH
43657: LD_EXP 95
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 34
43668: PUSH
43669: LD_INT 32
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 34
43678: PUSH
43679: LD_INT 13
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 34
43688: PUSH
43689: LD_INT 52
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 34
43698: PUSH
43699: LD_EXP 100
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 34
43710: PUSH
43711: LD_INT 14
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 34
43720: PUSH
43721: LD_INT 53
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 34
43730: PUSH
43731: LD_EXP 94
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: PUSH
43740: LD_INT 34
43742: PUSH
43743: LD_INT 31
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 34
43752: PUSH
43753: LD_INT 48
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 34
43762: PUSH
43763: LD_INT 8
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: LIST
43785: PPUSH
43786: CALL_OW 72
43790: DIFF
43791: ST_TO_ADDR
// end ; end_of_file
43792: LD_VAR 0 3
43796: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43797: LD_INT 0
43799: PPUSH
43800: PPUSH
43801: PPUSH
// if not mc_bases or not skirmish then
43802: LD_EXP 50
43806: NOT
43807: PUSH
43808: LD_EXP 48
43812: NOT
43813: OR
43814: IFFALSE 43818
// exit ;
43816: GO 43983
// for i = 1 to mc_bases do
43818: LD_ADDR_VAR 0 4
43822: PUSH
43823: DOUBLE
43824: LD_INT 1
43826: DEC
43827: ST_TO_ADDR
43828: LD_EXP 50
43832: PUSH
43833: FOR_TO
43834: IFFALSE 43981
// begin if sci in mc_bases [ i ] then
43836: LD_VAR 0 2
43840: PUSH
43841: LD_EXP 50
43845: PUSH
43846: LD_VAR 0 4
43850: ARRAY
43851: IN
43852: IFFALSE 43979
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43854: LD_ADDR_EXP 79
43858: PUSH
43859: LD_EXP 79
43863: PPUSH
43864: LD_VAR 0 4
43868: PUSH
43869: LD_EXP 79
43873: PUSH
43874: LD_VAR 0 4
43878: ARRAY
43879: PUSH
43880: LD_INT 1
43882: PLUS
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PPUSH
43888: LD_VAR 0 1
43892: PPUSH
43893: CALL 53565 0 3
43897: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43898: LD_ADDR_VAR 0 5
43902: PUSH
43903: LD_EXP 50
43907: PUSH
43908: LD_VAR 0 4
43912: ARRAY
43913: PPUSH
43914: LD_INT 2
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 30
43929: PUSH
43930: LD_INT 1
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: LIST
43941: PPUSH
43942: CALL_OW 72
43946: PPUSH
43947: LD_VAR 0 1
43951: PPUSH
43952: CALL_OW 74
43956: ST_TO_ADDR
// if tmp then
43957: LD_VAR 0 5
43961: IFFALSE 43977
// ComStandNearbyBuilding ( ape , tmp ) ;
43963: LD_VAR 0 1
43967: PPUSH
43968: LD_VAR 0 5
43972: PPUSH
43973: CALL 50143 0 2
// break ;
43977: GO 43981
// end ; end ;
43979: GO 43833
43981: POP
43982: POP
// end ;
43983: LD_VAR 0 3
43987: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43988: LD_INT 0
43990: PPUSH
43991: PPUSH
43992: PPUSH
// if not mc_bases or not skirmish then
43993: LD_EXP 50
43997: NOT
43998: PUSH
43999: LD_EXP 48
44003: NOT
44004: OR
44005: IFFALSE 44009
// exit ;
44007: GO 44098
// for i = 1 to mc_bases do
44009: LD_ADDR_VAR 0 4
44013: PUSH
44014: DOUBLE
44015: LD_INT 1
44017: DEC
44018: ST_TO_ADDR
44019: LD_EXP 50
44023: PUSH
44024: FOR_TO
44025: IFFALSE 44096
// begin if building in mc_busy_turret_list [ i ] then
44027: LD_VAR 0 1
44031: PUSH
44032: LD_EXP 60
44036: PUSH
44037: LD_VAR 0 4
44041: ARRAY
44042: IN
44043: IFFALSE 44094
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44045: LD_ADDR_VAR 0 5
44049: PUSH
44050: LD_EXP 60
44054: PUSH
44055: LD_VAR 0 4
44059: ARRAY
44060: PUSH
44061: LD_VAR 0 1
44065: DIFF
44066: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44067: LD_ADDR_EXP 60
44071: PUSH
44072: LD_EXP 60
44076: PPUSH
44077: LD_VAR 0 4
44081: PPUSH
44082: LD_VAR 0 5
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// break ;
44092: GO 44096
// end ; end ;
44094: GO 44024
44096: POP
44097: POP
// end ;
44098: LD_VAR 0 3
44102: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44103: LD_INT 0
44105: PPUSH
44106: PPUSH
44107: PPUSH
// if not mc_bases or not skirmish then
44108: LD_EXP 50
44112: NOT
44113: PUSH
44114: LD_EXP 48
44118: NOT
44119: OR
44120: IFFALSE 44124
// exit ;
44122: GO 44323
// for i = 1 to mc_bases do
44124: LD_ADDR_VAR 0 5
44128: PUSH
44129: DOUBLE
44130: LD_INT 1
44132: DEC
44133: ST_TO_ADDR
44134: LD_EXP 50
44138: PUSH
44139: FOR_TO
44140: IFFALSE 44321
// if building in mc_bases [ i ] then
44142: LD_VAR 0 1
44146: PUSH
44147: LD_EXP 50
44151: PUSH
44152: LD_VAR 0 5
44156: ARRAY
44157: IN
44158: IFFALSE 44319
// begin tmp := mc_bases [ i ] diff building ;
44160: LD_ADDR_VAR 0 6
44164: PUSH
44165: LD_EXP 50
44169: PUSH
44170: LD_VAR 0 5
44174: ARRAY
44175: PUSH
44176: LD_VAR 0 1
44180: DIFF
44181: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44182: LD_ADDR_EXP 50
44186: PUSH
44187: LD_EXP 50
44191: PPUSH
44192: LD_VAR 0 5
44196: PPUSH
44197: LD_VAR 0 6
44201: PPUSH
44202: CALL_OW 1
44206: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44207: LD_VAR 0 1
44211: PUSH
44212: LD_EXP 58
44216: PUSH
44217: LD_VAR 0 5
44221: ARRAY
44222: IN
44223: IFFALSE 44262
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44225: LD_ADDR_EXP 58
44229: PUSH
44230: LD_EXP 58
44234: PPUSH
44235: LD_VAR 0 5
44239: PPUSH
44240: LD_EXP 58
44244: PUSH
44245: LD_VAR 0 5
44249: ARRAY
44250: PUSH
44251: LD_VAR 0 1
44255: DIFF
44256: PPUSH
44257: CALL_OW 1
44261: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44262: LD_VAR 0 1
44266: PUSH
44267: LD_EXP 59
44271: PUSH
44272: LD_VAR 0 5
44276: ARRAY
44277: IN
44278: IFFALSE 44317
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44280: LD_ADDR_EXP 59
44284: PUSH
44285: LD_EXP 59
44289: PPUSH
44290: LD_VAR 0 5
44294: PPUSH
44295: LD_EXP 59
44299: PUSH
44300: LD_VAR 0 5
44304: ARRAY
44305: PUSH
44306: LD_VAR 0 1
44310: DIFF
44311: PPUSH
44312: CALL_OW 1
44316: ST_TO_ADDR
// break ;
44317: GO 44321
// end ;
44319: GO 44139
44321: POP
44322: POP
// end ;
44323: LD_VAR 0 4
44327: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44328: LD_INT 0
44330: PPUSH
44331: PPUSH
44332: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44333: LD_EXP 50
44337: NOT
44338: PUSH
44339: LD_EXP 48
44343: NOT
44344: OR
44345: PUSH
44346: LD_VAR 0 3
44350: PUSH
44351: LD_EXP 76
44355: IN
44356: NOT
44357: OR
44358: IFFALSE 44362
// exit ;
44360: GO 44485
// for i = 1 to mc_vehicles do
44362: LD_ADDR_VAR 0 6
44366: PUSH
44367: DOUBLE
44368: LD_INT 1
44370: DEC
44371: ST_TO_ADDR
44372: LD_EXP 69
44376: PUSH
44377: FOR_TO
44378: IFFALSE 44483
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44380: LD_VAR 0 2
44384: PUSH
44385: LD_EXP 69
44389: PUSH
44390: LD_VAR 0 6
44394: ARRAY
44395: IN
44396: PUSH
44397: LD_VAR 0 1
44401: PUSH
44402: LD_EXP 69
44406: PUSH
44407: LD_VAR 0 6
44411: ARRAY
44412: IN
44413: OR
44414: IFFALSE 44481
// begin tmp := mc_vehicles [ i ] diff old ;
44416: LD_ADDR_VAR 0 7
44420: PUSH
44421: LD_EXP 69
44425: PUSH
44426: LD_VAR 0 6
44430: ARRAY
44431: PUSH
44432: LD_VAR 0 2
44436: DIFF
44437: ST_TO_ADDR
// tmp := tmp diff new ;
44438: LD_ADDR_VAR 0 7
44442: PUSH
44443: LD_VAR 0 7
44447: PUSH
44448: LD_VAR 0 1
44452: DIFF
44453: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44454: LD_ADDR_EXP 69
44458: PUSH
44459: LD_EXP 69
44463: PPUSH
44464: LD_VAR 0 6
44468: PPUSH
44469: LD_VAR 0 7
44473: PPUSH
44474: CALL_OW 1
44478: ST_TO_ADDR
// break ;
44479: GO 44483
// end ;
44481: GO 44377
44483: POP
44484: POP
// end ;
44485: LD_VAR 0 5
44489: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44490: LD_INT 0
44492: PPUSH
44493: PPUSH
44494: PPUSH
44495: PPUSH
// if not mc_bases or not skirmish then
44496: LD_EXP 50
44500: NOT
44501: PUSH
44502: LD_EXP 48
44506: NOT
44507: OR
44508: IFFALSE 44512
// exit ;
44510: GO 44904
// side := GetSide ( vehicle ) ;
44512: LD_ADDR_VAR 0 5
44516: PUSH
44517: LD_VAR 0 1
44521: PPUSH
44522: CALL_OW 255
44526: ST_TO_ADDR
// for i = 1 to mc_bases do
44527: LD_ADDR_VAR 0 4
44531: PUSH
44532: DOUBLE
44533: LD_INT 1
44535: DEC
44536: ST_TO_ADDR
44537: LD_EXP 50
44541: PUSH
44542: FOR_TO
44543: IFFALSE 44902
// begin if factory in mc_bases [ i ] then
44545: LD_VAR 0 2
44549: PUSH
44550: LD_EXP 50
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: IN
44561: IFFALSE 44900
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44563: LD_EXP 72
44567: PUSH
44568: LD_VAR 0 4
44572: ARRAY
44573: PUSH
44574: LD_EXP 61
44578: PUSH
44579: LD_VAR 0 4
44583: ARRAY
44584: LESS
44585: PUSH
44586: LD_VAR 0 1
44590: PPUSH
44591: CALL_OW 264
44595: PUSH
44596: LD_INT 31
44598: PUSH
44599: LD_INT 32
44601: PUSH
44602: LD_INT 51
44604: PUSH
44605: LD_EXP 95
44609: PUSH
44610: LD_INT 12
44612: PUSH
44613: LD_INT 30
44615: PUSH
44616: LD_EXP 94
44620: PUSH
44621: LD_INT 11
44623: PUSH
44624: LD_INT 53
44626: PUSH
44627: LD_INT 14
44629: PUSH
44630: LD_EXP 98
44634: PUSH
44635: LD_INT 29
44637: PUSH
44638: LD_EXP 96
44642: PUSH
44643: LD_INT 13
44645: PUSH
44646: LD_INT 52
44648: PUSH
44649: LD_EXP 100
44653: PUSH
44654: LD_INT 48
44656: PUSH
44657: LD_INT 8
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: IN
44680: NOT
44681: AND
44682: IFFALSE 44730
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44684: LD_ADDR_EXP 72
44688: PUSH
44689: LD_EXP 72
44693: PPUSH
44694: LD_VAR 0 4
44698: PUSH
44699: LD_EXP 72
44703: PUSH
44704: LD_VAR 0 4
44708: ARRAY
44709: PUSH
44710: LD_INT 1
44712: PLUS
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PPUSH
44718: LD_VAR 0 1
44722: PPUSH
44723: CALL 53565 0 3
44727: ST_TO_ADDR
44728: GO 44774
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44730: LD_ADDR_EXP 69
44734: PUSH
44735: LD_EXP 69
44739: PPUSH
44740: LD_VAR 0 4
44744: PUSH
44745: LD_EXP 69
44749: PUSH
44750: LD_VAR 0 4
44754: ARRAY
44755: PUSH
44756: LD_INT 1
44758: PLUS
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PPUSH
44764: LD_VAR 0 1
44768: PPUSH
44769: CALL 53565 0 3
44773: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44774: LD_VAR 0 1
44778: PPUSH
44779: CALL_OW 263
44783: PUSH
44784: LD_INT 2
44786: EQUAL
44787: IFFALSE 44816
// begin repeat wait ( 0 0$3 ) ;
44789: LD_INT 105
44791: PPUSH
44792: CALL_OW 67
// Connect ( vehicle ) ;
44796: LD_VAR 0 1
44800: PPUSH
44801: CALL 56536 0 1
// until IsControledBy ( vehicle ) ;
44805: LD_VAR 0 1
44809: PPUSH
44810: CALL_OW 312
44814: IFFALSE 44789
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44816: LD_VAR 0 1
44820: PPUSH
44821: LD_EXP 74
44825: PUSH
44826: LD_VAR 0 4
44830: ARRAY
44831: PPUSH
44832: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44836: LD_VAR 0 1
44840: PPUSH
44841: CALL_OW 263
44845: PUSH
44846: LD_INT 1
44848: NONEQUAL
44849: IFFALSE 44853
// break ;
44851: GO 44902
// repeat wait ( 0 0$1 ) ;
44853: LD_INT 35
44855: PPUSH
44856: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44860: LD_VAR 0 1
44864: PPUSH
44865: LD_EXP 74
44869: PUSH
44870: LD_VAR 0 4
44874: ARRAY
44875: PPUSH
44876: CALL_OW 308
44880: IFFALSE 44853
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44882: LD_VAR 0 1
44886: PPUSH
44887: CALL_OW 311
44891: PPUSH
44892: CALL_OW 121
// exit ;
44896: POP
44897: POP
44898: GO 44904
// end ; end ;
44900: GO 44542
44902: POP
44903: POP
// end ;
44904: LD_VAR 0 3
44908: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44909: LD_INT 0
44911: PPUSH
44912: PPUSH
44913: PPUSH
44914: PPUSH
// if not mc_bases or not skirmish then
44915: LD_EXP 50
44919: NOT
44920: PUSH
44921: LD_EXP 48
44925: NOT
44926: OR
44927: IFFALSE 44931
// exit ;
44929: GO 45284
// repeat wait ( 0 0$1 ) ;
44931: LD_INT 35
44933: PPUSH
44934: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44938: LD_VAR 0 2
44942: PPUSH
44943: LD_VAR 0 3
44947: PPUSH
44948: CALL_OW 284
44952: IFFALSE 44931
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44954: LD_VAR 0 2
44958: PPUSH
44959: LD_VAR 0 3
44963: PPUSH
44964: CALL_OW 283
44968: PUSH
44969: LD_INT 4
44971: EQUAL
44972: IFFALSE 44976
// exit ;
44974: GO 45284
// for i = 1 to mc_bases do
44976: LD_ADDR_VAR 0 7
44980: PUSH
44981: DOUBLE
44982: LD_INT 1
44984: DEC
44985: ST_TO_ADDR
44986: LD_EXP 50
44990: PUSH
44991: FOR_TO
44992: IFFALSE 45282
// begin if mc_crates_area [ i ] then
44994: LD_EXP 68
44998: PUSH
44999: LD_VAR 0 7
45003: ARRAY
45004: IFFALSE 45115
// for j in mc_crates_area [ i ] do
45006: LD_ADDR_VAR 0 8
45010: PUSH
45011: LD_EXP 68
45015: PUSH
45016: LD_VAR 0 7
45020: ARRAY
45021: PUSH
45022: FOR_IN
45023: IFFALSE 45113
// if InArea ( x , y , j ) then
45025: LD_VAR 0 2
45029: PPUSH
45030: LD_VAR 0 3
45034: PPUSH
45035: LD_VAR 0 8
45039: PPUSH
45040: CALL_OW 309
45044: IFFALSE 45111
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45046: LD_ADDR_EXP 66
45050: PUSH
45051: LD_EXP 66
45055: PPUSH
45056: LD_VAR 0 7
45060: PUSH
45061: LD_EXP 66
45065: PUSH
45066: LD_VAR 0 7
45070: ARRAY
45071: PUSH
45072: LD_INT 1
45074: PLUS
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PPUSH
45080: LD_VAR 0 4
45084: PUSH
45085: LD_VAR 0 2
45089: PUSH
45090: LD_VAR 0 3
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: LIST
45099: PPUSH
45100: CALL 53565 0 3
45104: ST_TO_ADDR
// exit ;
45105: POP
45106: POP
45107: POP
45108: POP
45109: GO 45284
// end ;
45111: GO 45022
45113: POP
45114: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45115: LD_ADDR_VAR 0 9
45119: PUSH
45120: LD_EXP 50
45124: PUSH
45125: LD_VAR 0 7
45129: ARRAY
45130: PPUSH
45131: LD_INT 2
45133: PUSH
45134: LD_INT 30
45136: PUSH
45137: LD_INT 0
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: LD_INT 30
45146: PUSH
45147: LD_INT 1
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: LIST
45158: PPUSH
45159: CALL_OW 72
45163: ST_TO_ADDR
// if not depot then
45164: LD_VAR 0 9
45168: NOT
45169: IFFALSE 45173
// continue ;
45171: GO 44991
// for j in depot do
45173: LD_ADDR_VAR 0 8
45177: PUSH
45178: LD_VAR 0 9
45182: PUSH
45183: FOR_IN
45184: IFFALSE 45278
// if GetDistUnitXY ( j , x , y ) < 30 then
45186: LD_VAR 0 8
45190: PPUSH
45191: LD_VAR 0 2
45195: PPUSH
45196: LD_VAR 0 3
45200: PPUSH
45201: CALL_OW 297
45205: PUSH
45206: LD_INT 30
45208: LESS
45209: IFFALSE 45276
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45211: LD_ADDR_EXP 66
45215: PUSH
45216: LD_EXP 66
45220: PPUSH
45221: LD_VAR 0 7
45225: PUSH
45226: LD_EXP 66
45230: PUSH
45231: LD_VAR 0 7
45235: ARRAY
45236: PUSH
45237: LD_INT 1
45239: PLUS
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PPUSH
45245: LD_VAR 0 4
45249: PUSH
45250: LD_VAR 0 2
45254: PUSH
45255: LD_VAR 0 3
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: LIST
45264: PPUSH
45265: CALL 53565 0 3
45269: ST_TO_ADDR
// exit ;
45270: POP
45271: POP
45272: POP
45273: POP
45274: GO 45284
// end ;
45276: GO 45183
45278: POP
45279: POP
// end ;
45280: GO 44991
45282: POP
45283: POP
// end ;
45284: LD_VAR 0 6
45288: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45289: LD_INT 0
45291: PPUSH
45292: PPUSH
45293: PPUSH
45294: PPUSH
// if not mc_bases or not skirmish then
45295: LD_EXP 50
45299: NOT
45300: PUSH
45301: LD_EXP 48
45305: NOT
45306: OR
45307: IFFALSE 45311
// exit ;
45309: GO 45588
// side := GetSide ( lab ) ;
45311: LD_ADDR_VAR 0 4
45315: PUSH
45316: LD_VAR 0 2
45320: PPUSH
45321: CALL_OW 255
45325: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45326: LD_VAR 0 4
45330: PUSH
45331: LD_EXP 76
45335: IN
45336: NOT
45337: PUSH
45338: LD_EXP 77
45342: NOT
45343: OR
45344: PUSH
45345: LD_EXP 50
45349: NOT
45350: OR
45351: IFFALSE 45355
// exit ;
45353: GO 45588
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45355: LD_ADDR_EXP 77
45359: PUSH
45360: LD_EXP 77
45364: PPUSH
45365: LD_VAR 0 4
45369: PPUSH
45370: LD_EXP 77
45374: PUSH
45375: LD_VAR 0 4
45379: ARRAY
45380: PUSH
45381: LD_VAR 0 1
45385: DIFF
45386: PPUSH
45387: CALL_OW 1
45391: ST_TO_ADDR
// for i = 1 to mc_bases do
45392: LD_ADDR_VAR 0 5
45396: PUSH
45397: DOUBLE
45398: LD_INT 1
45400: DEC
45401: ST_TO_ADDR
45402: LD_EXP 50
45406: PUSH
45407: FOR_TO
45408: IFFALSE 45586
// begin if lab in mc_bases [ i ] then
45410: LD_VAR 0 2
45414: PUSH
45415: LD_EXP 50
45419: PUSH
45420: LD_VAR 0 5
45424: ARRAY
45425: IN
45426: IFFALSE 45584
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45428: LD_VAR 0 1
45432: PUSH
45433: LD_INT 11
45435: PUSH
45436: LD_INT 4
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: LD_INT 2
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: IN
45451: PUSH
45452: LD_EXP 80
45456: PUSH
45457: LD_VAR 0 5
45461: ARRAY
45462: AND
45463: IFFALSE 45584
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45465: LD_ADDR_VAR 0 6
45469: PUSH
45470: LD_EXP 80
45474: PUSH
45475: LD_VAR 0 5
45479: ARRAY
45480: PUSH
45481: LD_INT 1
45483: ARRAY
45484: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45485: LD_ADDR_EXP 80
45489: PUSH
45490: LD_EXP 80
45494: PPUSH
45495: LD_VAR 0 5
45499: PPUSH
45500: EMPTY
45501: PPUSH
45502: CALL_OW 1
45506: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45507: LD_VAR 0 6
45511: PPUSH
45512: LD_INT 0
45514: PPUSH
45515: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45519: LD_VAR 0 6
45523: PPUSH
45524: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45528: LD_ADDR_EXP 79
45532: PUSH
45533: LD_EXP 79
45537: PPUSH
45538: LD_VAR 0 5
45542: PPUSH
45543: LD_EXP 79
45547: PUSH
45548: LD_VAR 0 5
45552: ARRAY
45553: PPUSH
45554: LD_INT 1
45556: PPUSH
45557: LD_VAR 0 6
45561: PPUSH
45562: CALL_OW 2
45566: PPUSH
45567: CALL_OW 1
45571: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45572: LD_VAR 0 5
45576: PPUSH
45577: LD_INT 112
45579: PPUSH
45580: CALL 22107 0 2
// end ; end ; end ;
45584: GO 45407
45586: POP
45587: POP
// end ;
45588: LD_VAR 0 3
45592: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45593: LD_INT 0
45595: PPUSH
45596: PPUSH
45597: PPUSH
45598: PPUSH
45599: PPUSH
45600: PPUSH
45601: PPUSH
45602: PPUSH
// if not mc_bases or not skirmish then
45603: LD_EXP 50
45607: NOT
45608: PUSH
45609: LD_EXP 48
45613: NOT
45614: OR
45615: IFFALSE 45619
// exit ;
45617: GO 46990
// for i = 1 to mc_bases do
45619: LD_ADDR_VAR 0 3
45623: PUSH
45624: DOUBLE
45625: LD_INT 1
45627: DEC
45628: ST_TO_ADDR
45629: LD_EXP 50
45633: PUSH
45634: FOR_TO
45635: IFFALSE 46988
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45637: LD_VAR 0 1
45641: PUSH
45642: LD_EXP 50
45646: PUSH
45647: LD_VAR 0 3
45651: ARRAY
45652: IN
45653: PUSH
45654: LD_VAR 0 1
45658: PUSH
45659: LD_EXP 57
45663: PUSH
45664: LD_VAR 0 3
45668: ARRAY
45669: IN
45670: OR
45671: PUSH
45672: LD_VAR 0 1
45676: PUSH
45677: LD_EXP 72
45681: PUSH
45682: LD_VAR 0 3
45686: ARRAY
45687: IN
45688: OR
45689: PUSH
45690: LD_VAR 0 1
45694: PUSH
45695: LD_EXP 69
45699: PUSH
45700: LD_VAR 0 3
45704: ARRAY
45705: IN
45706: OR
45707: PUSH
45708: LD_VAR 0 1
45712: PUSH
45713: LD_EXP 79
45717: PUSH
45718: LD_VAR 0 3
45722: ARRAY
45723: IN
45724: OR
45725: PUSH
45726: LD_VAR 0 1
45730: PUSH
45731: LD_EXP 80
45735: PUSH
45736: LD_VAR 0 3
45740: ARRAY
45741: IN
45742: OR
45743: IFFALSE 46986
// begin if un in mc_ape [ i ] then
45745: LD_VAR 0 1
45749: PUSH
45750: LD_EXP 79
45754: PUSH
45755: LD_VAR 0 3
45759: ARRAY
45760: IN
45761: IFFALSE 45800
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45763: LD_ADDR_EXP 79
45767: PUSH
45768: LD_EXP 79
45772: PPUSH
45773: LD_VAR 0 3
45777: PPUSH
45778: LD_EXP 79
45782: PUSH
45783: LD_VAR 0 3
45787: ARRAY
45788: PUSH
45789: LD_VAR 0 1
45793: DIFF
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45800: LD_VAR 0 1
45804: PUSH
45805: LD_EXP 80
45809: PUSH
45810: LD_VAR 0 3
45814: ARRAY
45815: IN
45816: IFFALSE 45840
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45818: LD_ADDR_EXP 80
45822: PUSH
45823: LD_EXP 80
45827: PPUSH
45828: LD_VAR 0 3
45832: PPUSH
45833: EMPTY
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45840: LD_VAR 0 1
45844: PPUSH
45845: CALL_OW 247
45849: PUSH
45850: LD_INT 2
45852: EQUAL
45853: PUSH
45854: LD_VAR 0 1
45858: PPUSH
45859: CALL_OW 110
45863: PUSH
45864: LD_INT 20
45866: EQUAL
45867: PUSH
45868: LD_VAR 0 1
45872: PUSH
45873: LD_EXP 72
45877: PUSH
45878: LD_VAR 0 3
45882: ARRAY
45883: IN
45884: OR
45885: PUSH
45886: LD_VAR 0 1
45890: PPUSH
45891: CALL_OW 264
45895: PUSH
45896: LD_INT 12
45898: PUSH
45899: LD_INT 51
45901: PUSH
45902: LD_EXP 95
45906: PUSH
45907: LD_INT 32
45909: PUSH
45910: LD_INT 13
45912: PUSH
45913: LD_INT 52
45915: PUSH
45916: LD_INT 31
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: IN
45928: OR
45929: AND
45930: IFFALSE 46238
// begin if un in mc_defender [ i ] then
45932: LD_VAR 0 1
45936: PUSH
45937: LD_EXP 72
45941: PUSH
45942: LD_VAR 0 3
45946: ARRAY
45947: IN
45948: IFFALSE 45987
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45950: LD_ADDR_EXP 72
45954: PUSH
45955: LD_EXP 72
45959: PPUSH
45960: LD_VAR 0 3
45964: PPUSH
45965: LD_EXP 72
45969: PUSH
45970: LD_VAR 0 3
45974: ARRAY
45975: PUSH
45976: LD_VAR 0 1
45980: DIFF
45981: PPUSH
45982: CALL_OW 1
45986: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45987: LD_ADDR_VAR 0 8
45991: PUSH
45992: LD_VAR 0 3
45996: PPUSH
45997: LD_INT 3
45999: PPUSH
46000: CALL 42628 0 2
46004: ST_TO_ADDR
// if fac then
46005: LD_VAR 0 8
46009: IFFALSE 46238
// begin for j in fac do
46011: LD_ADDR_VAR 0 4
46015: PUSH
46016: LD_VAR 0 8
46020: PUSH
46021: FOR_IN
46022: IFFALSE 46236
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46024: LD_ADDR_VAR 0 9
46028: PUSH
46029: LD_VAR 0 8
46033: PPUSH
46034: LD_VAR 0 1
46038: PPUSH
46039: CALL_OW 265
46043: PPUSH
46044: LD_VAR 0 1
46048: PPUSH
46049: CALL_OW 262
46053: PPUSH
46054: LD_VAR 0 1
46058: PPUSH
46059: CALL_OW 263
46063: PPUSH
46064: LD_VAR 0 1
46068: PPUSH
46069: CALL_OW 264
46073: PPUSH
46074: CALL 51061 0 5
46078: ST_TO_ADDR
// if components then
46079: LD_VAR 0 9
46083: IFFALSE 46234
// begin if GetWeapon ( un ) = ar_control_tower then
46085: LD_VAR 0 1
46089: PPUSH
46090: CALL_OW 264
46094: PUSH
46095: LD_INT 31
46097: EQUAL
46098: IFFALSE 46215
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 311
46109: PPUSH
46110: LD_INT 0
46112: PPUSH
46113: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46117: LD_ADDR_EXP 90
46121: PUSH
46122: LD_EXP 90
46126: PPUSH
46127: LD_VAR 0 3
46131: PPUSH
46132: LD_EXP 90
46136: PUSH
46137: LD_VAR 0 3
46141: ARRAY
46142: PUSH
46143: LD_VAR 0 1
46147: PPUSH
46148: CALL_OW 311
46152: DIFF
46153: PPUSH
46154: CALL_OW 1
46158: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46159: LD_ADDR_VAR 0 7
46163: PUSH
46164: LD_EXP 71
46168: PUSH
46169: LD_VAR 0 3
46173: ARRAY
46174: PPUSH
46175: LD_INT 1
46177: PPUSH
46178: LD_VAR 0 9
46182: PPUSH
46183: CALL_OW 2
46187: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46188: LD_ADDR_EXP 71
46192: PUSH
46193: LD_EXP 71
46197: PPUSH
46198: LD_VAR 0 3
46202: PPUSH
46203: LD_VAR 0 7
46207: PPUSH
46208: CALL_OW 1
46212: ST_TO_ADDR
// end else
46213: GO 46232
// MC_InsertProduceList ( i , [ components ] ) ;
46215: LD_VAR 0 3
46219: PPUSH
46220: LD_VAR 0 9
46224: PUSH
46225: EMPTY
46226: LIST
46227: PPUSH
46228: CALL 42173 0 2
// break ;
46232: GO 46236
// end ; end ;
46234: GO 46021
46236: POP
46237: POP
// end ; end ; if GetType ( un ) = unit_building then
46238: LD_VAR 0 1
46242: PPUSH
46243: CALL_OW 247
46247: PUSH
46248: LD_INT 3
46250: EQUAL
46251: IFFALSE 46654
// begin btype := GetBType ( un ) ;
46253: LD_ADDR_VAR 0 5
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 266
46267: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46268: LD_VAR 0 5
46272: PUSH
46273: LD_INT 29
46275: PUSH
46276: LD_INT 30
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: IN
46283: IFFALSE 46356
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46285: LD_VAR 0 1
46289: PPUSH
46290: CALL_OW 250
46294: PPUSH
46295: LD_VAR 0 1
46299: PPUSH
46300: CALL_OW 251
46304: PPUSH
46305: LD_VAR 0 1
46309: PPUSH
46310: CALL_OW 255
46314: PPUSH
46315: CALL_OW 440
46319: NOT
46320: IFFALSE 46356
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46322: LD_VAR 0 1
46326: PPUSH
46327: CALL_OW 250
46331: PPUSH
46332: LD_VAR 0 1
46336: PPUSH
46337: CALL_OW 251
46341: PPUSH
46342: LD_VAR 0 1
46346: PPUSH
46347: CALL_OW 255
46351: PPUSH
46352: CALL_OW 441
// end ; if btype = b_warehouse then
46356: LD_VAR 0 5
46360: PUSH
46361: LD_INT 1
46363: EQUAL
46364: IFFALSE 46382
// begin btype := b_depot ;
46366: LD_ADDR_VAR 0 5
46370: PUSH
46371: LD_INT 0
46373: ST_TO_ADDR
// pos := 1 ;
46374: LD_ADDR_VAR 0 6
46378: PUSH
46379: LD_INT 1
46381: ST_TO_ADDR
// end ; if btype = b_factory then
46382: LD_VAR 0 5
46386: PUSH
46387: LD_INT 3
46389: EQUAL
46390: IFFALSE 46408
// begin btype := b_workshop ;
46392: LD_ADDR_VAR 0 5
46396: PUSH
46397: LD_INT 2
46399: ST_TO_ADDR
// pos := 1 ;
46400: LD_ADDR_VAR 0 6
46404: PUSH
46405: LD_INT 1
46407: ST_TO_ADDR
// end ; if btype = b_barracks then
46408: LD_VAR 0 5
46412: PUSH
46413: LD_INT 5
46415: EQUAL
46416: IFFALSE 46426
// btype := b_armoury ;
46418: LD_ADDR_VAR 0 5
46422: PUSH
46423: LD_INT 4
46425: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46426: LD_VAR 0 5
46430: PUSH
46431: LD_INT 7
46433: PUSH
46434: LD_INT 8
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: IN
46441: IFFALSE 46451
// btype := b_lab ;
46443: LD_ADDR_VAR 0 5
46447: PUSH
46448: LD_INT 6
46450: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46451: LD_ADDR_EXP 55
46455: PUSH
46456: LD_EXP 55
46460: PPUSH
46461: LD_VAR 0 3
46465: PUSH
46466: LD_EXP 55
46470: PUSH
46471: LD_VAR 0 3
46475: ARRAY
46476: PUSH
46477: LD_INT 1
46479: PLUS
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PPUSH
46485: LD_VAR 0 5
46489: PUSH
46490: LD_VAR 0 1
46494: PPUSH
46495: CALL_OW 250
46499: PUSH
46500: LD_VAR 0 1
46504: PPUSH
46505: CALL_OW 251
46509: PUSH
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 254
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: PPUSH
46526: CALL 53565 0 3
46530: ST_TO_ADDR
// if pos = 1 then
46531: LD_VAR 0 6
46535: PUSH
46536: LD_INT 1
46538: EQUAL
46539: IFFALSE 46654
// begin tmp := mc_build_list [ i ] ;
46541: LD_ADDR_VAR 0 7
46545: PUSH
46546: LD_EXP 55
46550: PUSH
46551: LD_VAR 0 3
46555: ARRAY
46556: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46557: LD_VAR 0 7
46561: PPUSH
46562: LD_INT 2
46564: PUSH
46565: LD_INT 30
46567: PUSH
46568: LD_INT 0
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 30
46577: PUSH
46578: LD_INT 1
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: LIST
46589: PPUSH
46590: CALL_OW 72
46594: IFFALSE 46604
// pos := 2 ;
46596: LD_ADDR_VAR 0 6
46600: PUSH
46601: LD_INT 2
46603: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46604: LD_ADDR_VAR 0 7
46608: PUSH
46609: LD_VAR 0 7
46613: PPUSH
46614: LD_VAR 0 6
46618: PPUSH
46619: LD_VAR 0 7
46623: PPUSH
46624: CALL 53891 0 3
46628: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46629: LD_ADDR_EXP 55
46633: PUSH
46634: LD_EXP 55
46638: PPUSH
46639: LD_VAR 0 3
46643: PPUSH
46644: LD_VAR 0 7
46648: PPUSH
46649: CALL_OW 1
46653: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46654: LD_VAR 0 1
46658: PUSH
46659: LD_EXP 50
46663: PUSH
46664: LD_VAR 0 3
46668: ARRAY
46669: IN
46670: IFFALSE 46709
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46672: LD_ADDR_EXP 50
46676: PUSH
46677: LD_EXP 50
46681: PPUSH
46682: LD_VAR 0 3
46686: PPUSH
46687: LD_EXP 50
46691: PUSH
46692: LD_VAR 0 3
46696: ARRAY
46697: PUSH
46698: LD_VAR 0 1
46702: DIFF
46703: PPUSH
46704: CALL_OW 1
46708: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46709: LD_VAR 0 1
46713: PUSH
46714: LD_EXP 57
46718: PUSH
46719: LD_VAR 0 3
46723: ARRAY
46724: IN
46725: IFFALSE 46764
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46727: LD_ADDR_EXP 57
46731: PUSH
46732: LD_EXP 57
46736: PPUSH
46737: LD_VAR 0 3
46741: PPUSH
46742: LD_EXP 57
46746: PUSH
46747: LD_VAR 0 3
46751: ARRAY
46752: PUSH
46753: LD_VAR 0 1
46757: DIFF
46758: PPUSH
46759: CALL_OW 1
46763: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46764: LD_VAR 0 1
46768: PUSH
46769: LD_EXP 69
46773: PUSH
46774: LD_VAR 0 3
46778: ARRAY
46779: IN
46780: IFFALSE 46819
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46782: LD_ADDR_EXP 69
46786: PUSH
46787: LD_EXP 69
46791: PPUSH
46792: LD_VAR 0 3
46796: PPUSH
46797: LD_EXP 69
46801: PUSH
46802: LD_VAR 0 3
46806: ARRAY
46807: PUSH
46808: LD_VAR 0 1
46812: DIFF
46813: PPUSH
46814: CALL_OW 1
46818: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46819: LD_VAR 0 1
46823: PUSH
46824: LD_EXP 72
46828: PUSH
46829: LD_VAR 0 3
46833: ARRAY
46834: IN
46835: IFFALSE 46874
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46837: LD_ADDR_EXP 72
46841: PUSH
46842: LD_EXP 72
46846: PPUSH
46847: LD_VAR 0 3
46851: PPUSH
46852: LD_EXP 72
46856: PUSH
46857: LD_VAR 0 3
46861: ARRAY
46862: PUSH
46863: LD_VAR 0 1
46867: DIFF
46868: PPUSH
46869: CALL_OW 1
46873: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46874: LD_VAR 0 1
46878: PUSH
46879: LD_EXP 59
46883: PUSH
46884: LD_VAR 0 3
46888: ARRAY
46889: IN
46890: IFFALSE 46929
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46892: LD_ADDR_EXP 59
46896: PUSH
46897: LD_EXP 59
46901: PPUSH
46902: LD_VAR 0 3
46906: PPUSH
46907: LD_EXP 59
46911: PUSH
46912: LD_VAR 0 3
46916: ARRAY
46917: PUSH
46918: LD_VAR 0 1
46922: DIFF
46923: PPUSH
46924: CALL_OW 1
46928: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46929: LD_VAR 0 1
46933: PUSH
46934: LD_EXP 58
46938: PUSH
46939: LD_VAR 0 3
46943: ARRAY
46944: IN
46945: IFFALSE 46984
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46947: LD_ADDR_EXP 58
46951: PUSH
46952: LD_EXP 58
46956: PPUSH
46957: LD_VAR 0 3
46961: PPUSH
46962: LD_EXP 58
46966: PUSH
46967: LD_VAR 0 3
46971: ARRAY
46972: PUSH
46973: LD_VAR 0 1
46977: DIFF
46978: PPUSH
46979: CALL_OW 1
46983: ST_TO_ADDR
// end ; break ;
46984: GO 46988
// end ;
46986: GO 45634
46988: POP
46989: POP
// end ;
46990: LD_VAR 0 2
46994: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46995: LD_INT 0
46997: PPUSH
46998: PPUSH
46999: PPUSH
// if not mc_bases or not skirmish then
47000: LD_EXP 50
47004: NOT
47005: PUSH
47006: LD_EXP 48
47010: NOT
47011: OR
47012: IFFALSE 47016
// exit ;
47014: GO 47231
// for i = 1 to mc_bases do
47016: LD_ADDR_VAR 0 3
47020: PUSH
47021: DOUBLE
47022: LD_INT 1
47024: DEC
47025: ST_TO_ADDR
47026: LD_EXP 50
47030: PUSH
47031: FOR_TO
47032: IFFALSE 47229
// begin if building in mc_construct_list [ i ] then
47034: LD_VAR 0 1
47038: PUSH
47039: LD_EXP 57
47043: PUSH
47044: LD_VAR 0 3
47048: ARRAY
47049: IN
47050: IFFALSE 47227
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47052: LD_ADDR_EXP 57
47056: PUSH
47057: LD_EXP 57
47061: PPUSH
47062: LD_VAR 0 3
47066: PPUSH
47067: LD_EXP 57
47071: PUSH
47072: LD_VAR 0 3
47076: ARRAY
47077: PUSH
47078: LD_VAR 0 1
47082: DIFF
47083: PPUSH
47084: CALL_OW 1
47088: ST_TO_ADDR
// if building in mc_lab [ i ] then
47089: LD_VAR 0 1
47093: PUSH
47094: LD_EXP 83
47098: PUSH
47099: LD_VAR 0 3
47103: ARRAY
47104: IN
47105: IFFALSE 47160
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47107: LD_ADDR_EXP 84
47111: PUSH
47112: LD_EXP 84
47116: PPUSH
47117: LD_VAR 0 3
47121: PPUSH
47122: LD_EXP 84
47126: PUSH
47127: LD_VAR 0 3
47131: ARRAY
47132: PPUSH
47133: LD_INT 1
47135: PPUSH
47136: LD_EXP 84
47140: PUSH
47141: LD_VAR 0 3
47145: ARRAY
47146: PPUSH
47147: LD_INT 0
47149: PPUSH
47150: CALL 52983 0 4
47154: PPUSH
47155: CALL_OW 1
47159: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47160: LD_VAR 0 1
47164: PUSH
47165: LD_EXP 50
47169: PUSH
47170: LD_VAR 0 3
47174: ARRAY
47175: IN
47176: NOT
47177: IFFALSE 47223
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47179: LD_ADDR_EXP 50
47183: PUSH
47184: LD_EXP 50
47188: PPUSH
47189: LD_VAR 0 3
47193: PUSH
47194: LD_EXP 50
47198: PUSH
47199: LD_VAR 0 3
47203: ARRAY
47204: PUSH
47205: LD_INT 1
47207: PLUS
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PPUSH
47213: LD_VAR 0 1
47217: PPUSH
47218: CALL 53565 0 3
47222: ST_TO_ADDR
// exit ;
47223: POP
47224: POP
47225: GO 47231
// end ; end ;
47227: GO 47031
47229: POP
47230: POP
// end ;
47231: LD_VAR 0 2
47235: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47236: LD_INT 0
47238: PPUSH
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
47243: PPUSH
47244: PPUSH
// if not mc_bases or not skirmish then
47245: LD_EXP 50
47249: NOT
47250: PUSH
47251: LD_EXP 48
47255: NOT
47256: OR
47257: IFFALSE 47261
// exit ;
47259: GO 47922
// for i = 1 to mc_bases do
47261: LD_ADDR_VAR 0 3
47265: PUSH
47266: DOUBLE
47267: LD_INT 1
47269: DEC
47270: ST_TO_ADDR
47271: LD_EXP 50
47275: PUSH
47276: FOR_TO
47277: IFFALSE 47920
// begin if building in mc_construct_list [ i ] then
47279: LD_VAR 0 1
47283: PUSH
47284: LD_EXP 57
47288: PUSH
47289: LD_VAR 0 3
47293: ARRAY
47294: IN
47295: IFFALSE 47918
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47297: LD_ADDR_EXP 57
47301: PUSH
47302: LD_EXP 57
47306: PPUSH
47307: LD_VAR 0 3
47311: PPUSH
47312: LD_EXP 57
47316: PUSH
47317: LD_VAR 0 3
47321: ARRAY
47322: PUSH
47323: LD_VAR 0 1
47327: DIFF
47328: PPUSH
47329: CALL_OW 1
47333: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47334: LD_ADDR_EXP 50
47338: PUSH
47339: LD_EXP 50
47343: PPUSH
47344: LD_VAR 0 3
47348: PUSH
47349: LD_EXP 50
47353: PUSH
47354: LD_VAR 0 3
47358: ARRAY
47359: PUSH
47360: LD_INT 1
47362: PLUS
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PPUSH
47368: LD_VAR 0 1
47372: PPUSH
47373: CALL 53565 0 3
47377: ST_TO_ADDR
// btype := GetBType ( building ) ;
47378: LD_ADDR_VAR 0 5
47382: PUSH
47383: LD_VAR 0 1
47387: PPUSH
47388: CALL_OW 266
47392: ST_TO_ADDR
// side := GetSide ( building ) ;
47393: LD_ADDR_VAR 0 8
47397: PUSH
47398: LD_VAR 0 1
47402: PPUSH
47403: CALL_OW 255
47407: ST_TO_ADDR
// if btype = b_lab then
47408: LD_VAR 0 5
47412: PUSH
47413: LD_INT 6
47415: EQUAL
47416: IFFALSE 47466
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47418: LD_ADDR_EXP 83
47422: PUSH
47423: LD_EXP 83
47427: PPUSH
47428: LD_VAR 0 3
47432: PUSH
47433: LD_EXP 83
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_INT 1
47446: PLUS
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: PPUSH
47452: LD_VAR 0 1
47456: PPUSH
47457: CALL 53565 0 3
47461: ST_TO_ADDR
// exit ;
47462: POP
47463: POP
47464: GO 47922
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47466: LD_VAR 0 5
47470: PUSH
47471: LD_INT 0
47473: PUSH
47474: LD_INT 2
47476: PUSH
47477: LD_INT 4
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: LIST
47484: IN
47485: IFFALSE 47609
// begin if btype = b_armoury then
47487: LD_VAR 0 5
47491: PUSH
47492: LD_INT 4
47494: EQUAL
47495: IFFALSE 47505
// btype := b_barracks ;
47497: LD_ADDR_VAR 0 5
47501: PUSH
47502: LD_INT 5
47504: ST_TO_ADDR
// if btype = b_depot then
47505: LD_VAR 0 5
47509: PUSH
47510: LD_INT 0
47512: EQUAL
47513: IFFALSE 47523
// btype := b_warehouse ;
47515: LD_ADDR_VAR 0 5
47519: PUSH
47520: LD_INT 1
47522: ST_TO_ADDR
// if btype = b_workshop then
47523: LD_VAR 0 5
47527: PUSH
47528: LD_INT 2
47530: EQUAL
47531: IFFALSE 47541
// btype := b_factory ;
47533: LD_ADDR_VAR 0 5
47537: PUSH
47538: LD_INT 3
47540: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47541: LD_VAR 0 5
47545: PPUSH
47546: LD_VAR 0 8
47550: PPUSH
47551: CALL_OW 323
47555: PUSH
47556: LD_INT 1
47558: EQUAL
47559: IFFALSE 47605
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47561: LD_ADDR_EXP 82
47565: PUSH
47566: LD_EXP 82
47570: PPUSH
47571: LD_VAR 0 3
47575: PUSH
47576: LD_EXP 82
47580: PUSH
47581: LD_VAR 0 3
47585: ARRAY
47586: PUSH
47587: LD_INT 1
47589: PLUS
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PPUSH
47595: LD_VAR 0 1
47599: PPUSH
47600: CALL 53565 0 3
47604: ST_TO_ADDR
// exit ;
47605: POP
47606: POP
47607: GO 47922
// end ; if btype in [ b_bunker , b_turret ] then
47609: LD_VAR 0 5
47613: PUSH
47614: LD_INT 32
47616: PUSH
47617: LD_INT 33
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: IN
47624: IFFALSE 47914
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47626: LD_ADDR_EXP 58
47630: PUSH
47631: LD_EXP 58
47635: PPUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_EXP 58
47645: PUSH
47646: LD_VAR 0 3
47650: ARRAY
47651: PUSH
47652: LD_INT 1
47654: PLUS
47655: PUSH
47656: EMPTY
47657: LIST
47658: LIST
47659: PPUSH
47660: LD_VAR 0 1
47664: PPUSH
47665: CALL 53565 0 3
47669: ST_TO_ADDR
// if btype = b_bunker then
47670: LD_VAR 0 5
47674: PUSH
47675: LD_INT 32
47677: EQUAL
47678: IFFALSE 47914
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47680: LD_ADDR_EXP 59
47684: PUSH
47685: LD_EXP 59
47689: PPUSH
47690: LD_VAR 0 3
47694: PUSH
47695: LD_EXP 59
47699: PUSH
47700: LD_VAR 0 3
47704: ARRAY
47705: PUSH
47706: LD_INT 1
47708: PLUS
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PPUSH
47714: LD_VAR 0 1
47718: PPUSH
47719: CALL 53565 0 3
47723: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47724: LD_ADDR_VAR 0 6
47728: PUSH
47729: LD_EXP 50
47733: PUSH
47734: LD_VAR 0 3
47738: ARRAY
47739: PPUSH
47740: LD_INT 25
47742: PUSH
47743: LD_INT 1
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: PUSH
47750: LD_INT 3
47752: PUSH
47753: LD_INT 54
47755: PUSH
47756: EMPTY
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PPUSH
47767: CALL_OW 72
47771: ST_TO_ADDR
// if tmp then
47772: LD_VAR 0 6
47776: IFFALSE 47782
// exit ;
47778: POP
47779: POP
47780: GO 47922
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47782: LD_ADDR_VAR 0 6
47786: PUSH
47787: LD_EXP 50
47791: PUSH
47792: LD_VAR 0 3
47796: ARRAY
47797: PPUSH
47798: LD_INT 2
47800: PUSH
47801: LD_INT 30
47803: PUSH
47804: LD_INT 4
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: LD_INT 30
47813: PUSH
47814: LD_INT 5
47816: PUSH
47817: EMPTY
47818: LIST
47819: LIST
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: LIST
47825: PPUSH
47826: CALL_OW 72
47830: ST_TO_ADDR
// if not tmp then
47831: LD_VAR 0 6
47835: NOT
47836: IFFALSE 47842
// exit ;
47838: POP
47839: POP
47840: GO 47922
// for j in tmp do
47842: LD_ADDR_VAR 0 4
47846: PUSH
47847: LD_VAR 0 6
47851: PUSH
47852: FOR_IN
47853: IFFALSE 47912
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47855: LD_ADDR_VAR 0 7
47859: PUSH
47860: LD_VAR 0 4
47864: PPUSH
47865: CALL_OW 313
47869: PPUSH
47870: LD_INT 25
47872: PUSH
47873: LD_INT 1
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PPUSH
47880: CALL_OW 72
47884: ST_TO_ADDR
// if units then
47885: LD_VAR 0 7
47889: IFFALSE 47910
// begin ComExitBuilding ( units [ 1 ] ) ;
47891: LD_VAR 0 7
47895: PUSH
47896: LD_INT 1
47898: ARRAY
47899: PPUSH
47900: CALL_OW 122
// exit ;
47904: POP
47905: POP
47906: POP
47907: POP
47908: GO 47922
// end ; end ;
47910: GO 47852
47912: POP
47913: POP
// end ; end ; exit ;
47914: POP
47915: POP
47916: GO 47922
// end ; end ;
47918: GO 47276
47920: POP
47921: POP
// end ;
47922: LD_VAR 0 2
47926: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47927: LD_INT 0
47929: PPUSH
47930: PPUSH
47931: PPUSH
47932: PPUSH
47933: PPUSH
47934: PPUSH
47935: PPUSH
// if not mc_bases or not skirmish then
47936: LD_EXP 50
47940: NOT
47941: PUSH
47942: LD_EXP 48
47946: NOT
47947: OR
47948: IFFALSE 47952
// exit ;
47950: GO 48217
// btype := GetBType ( building ) ;
47952: LD_ADDR_VAR 0 6
47956: PUSH
47957: LD_VAR 0 1
47961: PPUSH
47962: CALL_OW 266
47966: ST_TO_ADDR
// x := GetX ( building ) ;
47967: LD_ADDR_VAR 0 7
47971: PUSH
47972: LD_VAR 0 1
47976: PPUSH
47977: CALL_OW 250
47981: ST_TO_ADDR
// y := GetY ( building ) ;
47982: LD_ADDR_VAR 0 8
47986: PUSH
47987: LD_VAR 0 1
47991: PPUSH
47992: CALL_OW 251
47996: ST_TO_ADDR
// d := GetDir ( building ) ;
47997: LD_ADDR_VAR 0 9
48001: PUSH
48002: LD_VAR 0 1
48006: PPUSH
48007: CALL_OW 254
48011: ST_TO_ADDR
// for i = 1 to mc_bases do
48012: LD_ADDR_VAR 0 4
48016: PUSH
48017: DOUBLE
48018: LD_INT 1
48020: DEC
48021: ST_TO_ADDR
48022: LD_EXP 50
48026: PUSH
48027: FOR_TO
48028: IFFALSE 48215
// begin if not mc_build_list [ i ] then
48030: LD_EXP 55
48034: PUSH
48035: LD_VAR 0 4
48039: ARRAY
48040: NOT
48041: IFFALSE 48045
// continue ;
48043: GO 48027
// for j := 1 to mc_build_list [ i ] do
48045: LD_ADDR_VAR 0 5
48049: PUSH
48050: DOUBLE
48051: LD_INT 1
48053: DEC
48054: ST_TO_ADDR
48055: LD_EXP 55
48059: PUSH
48060: LD_VAR 0 4
48064: ARRAY
48065: PUSH
48066: FOR_TO
48067: IFFALSE 48211
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48069: LD_VAR 0 6
48073: PUSH
48074: LD_VAR 0 7
48078: PUSH
48079: LD_VAR 0 8
48083: PUSH
48084: LD_VAR 0 9
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: LIST
48093: LIST
48094: PPUSH
48095: LD_EXP 55
48099: PUSH
48100: LD_VAR 0 4
48104: ARRAY
48105: PUSH
48106: LD_VAR 0 5
48110: ARRAY
48111: PPUSH
48112: CALL 59747 0 2
48116: IFFALSE 48209
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48118: LD_ADDR_EXP 55
48122: PUSH
48123: LD_EXP 55
48127: PPUSH
48128: LD_VAR 0 4
48132: PPUSH
48133: LD_EXP 55
48137: PUSH
48138: LD_VAR 0 4
48142: ARRAY
48143: PPUSH
48144: LD_VAR 0 5
48148: PPUSH
48149: CALL_OW 3
48153: PPUSH
48154: CALL_OW 1
48158: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48159: LD_ADDR_EXP 57
48163: PUSH
48164: LD_EXP 57
48168: PPUSH
48169: LD_VAR 0 4
48173: PUSH
48174: LD_EXP 57
48178: PUSH
48179: LD_VAR 0 4
48183: ARRAY
48184: PUSH
48185: LD_INT 1
48187: PLUS
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PPUSH
48193: LD_VAR 0 1
48197: PPUSH
48198: CALL 53565 0 3
48202: ST_TO_ADDR
// exit ;
48203: POP
48204: POP
48205: POP
48206: POP
48207: GO 48217
// end ;
48209: GO 48066
48211: POP
48212: POP
// end ;
48213: GO 48027
48215: POP
48216: POP
// end ;
48217: LD_VAR 0 3
48221: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48222: LD_INT 0
48224: PPUSH
48225: PPUSH
48226: PPUSH
// if not mc_bases or not skirmish then
48227: LD_EXP 50
48231: NOT
48232: PUSH
48233: LD_EXP 48
48237: NOT
48238: OR
48239: IFFALSE 48243
// exit ;
48241: GO 48433
// for i = 1 to mc_bases do
48243: LD_ADDR_VAR 0 4
48247: PUSH
48248: DOUBLE
48249: LD_INT 1
48251: DEC
48252: ST_TO_ADDR
48253: LD_EXP 50
48257: PUSH
48258: FOR_TO
48259: IFFALSE 48346
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48261: LD_VAR 0 1
48265: PUSH
48266: LD_EXP 58
48270: PUSH
48271: LD_VAR 0 4
48275: ARRAY
48276: IN
48277: PUSH
48278: LD_VAR 0 1
48282: PUSH
48283: LD_EXP 59
48287: PUSH
48288: LD_VAR 0 4
48292: ARRAY
48293: IN
48294: NOT
48295: AND
48296: IFFALSE 48344
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48298: LD_ADDR_EXP 59
48302: PUSH
48303: LD_EXP 59
48307: PPUSH
48308: LD_VAR 0 4
48312: PUSH
48313: LD_EXP 59
48317: PUSH
48318: LD_VAR 0 4
48322: ARRAY
48323: PUSH
48324: LD_INT 1
48326: PLUS
48327: PUSH
48328: EMPTY
48329: LIST
48330: LIST
48331: PPUSH
48332: LD_VAR 0 1
48336: PPUSH
48337: CALL 53565 0 3
48341: ST_TO_ADDR
// break ;
48342: GO 48346
// end ; end ;
48344: GO 48258
48346: POP
48347: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48348: LD_VAR 0 1
48352: PPUSH
48353: CALL_OW 257
48357: PUSH
48358: LD_EXP 76
48362: IN
48363: PUSH
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 266
48373: PUSH
48374: LD_INT 5
48376: EQUAL
48377: AND
48378: PUSH
48379: LD_VAR 0 2
48383: PPUSH
48384: CALL_OW 110
48388: PUSH
48389: LD_INT 18
48391: NONEQUAL
48392: AND
48393: IFFALSE 48433
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48395: LD_VAR 0 2
48399: PPUSH
48400: CALL_OW 257
48404: PUSH
48405: LD_INT 5
48407: PUSH
48408: LD_INT 8
48410: PUSH
48411: LD_INT 9
48413: PUSH
48414: EMPTY
48415: LIST
48416: LIST
48417: LIST
48418: IN
48419: IFFALSE 48433
// SetClass ( unit , 1 ) ;
48421: LD_VAR 0 2
48425: PPUSH
48426: LD_INT 1
48428: PPUSH
48429: CALL_OW 336
// end ;
48433: LD_VAR 0 3
48437: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48438: LD_INT 0
48440: PPUSH
48441: PPUSH
// if not mc_bases or not skirmish then
48442: LD_EXP 50
48446: NOT
48447: PUSH
48448: LD_EXP 48
48452: NOT
48453: OR
48454: IFFALSE 48458
// exit ;
48456: GO 48574
// if GetLives ( abandoned_vehicle ) > 250 then
48458: LD_VAR 0 2
48462: PPUSH
48463: CALL_OW 256
48467: PUSH
48468: LD_INT 250
48470: GREATER
48471: IFFALSE 48475
// exit ;
48473: GO 48574
// for i = 1 to mc_bases do
48475: LD_ADDR_VAR 0 6
48479: PUSH
48480: DOUBLE
48481: LD_INT 1
48483: DEC
48484: ST_TO_ADDR
48485: LD_EXP 50
48489: PUSH
48490: FOR_TO
48491: IFFALSE 48572
// begin if driver in mc_bases [ i ] then
48493: LD_VAR 0 1
48497: PUSH
48498: LD_EXP 50
48502: PUSH
48503: LD_VAR 0 6
48507: ARRAY
48508: IN
48509: IFFALSE 48570
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48511: LD_VAR 0 1
48515: PPUSH
48516: LD_EXP 50
48520: PUSH
48521: LD_VAR 0 6
48525: ARRAY
48526: PPUSH
48527: LD_INT 2
48529: PUSH
48530: LD_INT 30
48532: PUSH
48533: LD_INT 0
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 30
48542: PUSH
48543: LD_INT 1
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PPUSH
48555: CALL_OW 72
48559: PUSH
48560: LD_INT 1
48562: ARRAY
48563: PPUSH
48564: CALL 86127 0 2
// break ;
48568: GO 48572
// end ; end ;
48570: GO 48490
48572: POP
48573: POP
// end ; end_of_file
48574: LD_VAR 0 5
48578: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48579: LD_INT 0
48581: PPUSH
48582: PPUSH
// if exist_mode then
48583: LD_VAR 0 2
48587: IFFALSE 48612
// unit := CreateCharacter ( prefix & ident ) else
48589: LD_ADDR_VAR 0 5
48593: PUSH
48594: LD_VAR 0 3
48598: PUSH
48599: LD_VAR 0 1
48603: STR
48604: PPUSH
48605: CALL_OW 34
48609: ST_TO_ADDR
48610: GO 48627
// unit := NewCharacter ( ident ) ;
48612: LD_ADDR_VAR 0 5
48616: PUSH
48617: LD_VAR 0 1
48621: PPUSH
48622: CALL_OW 25
48626: ST_TO_ADDR
// result := unit ;
48627: LD_ADDR_VAR 0 4
48631: PUSH
48632: LD_VAR 0 5
48636: ST_TO_ADDR
// end ;
48637: LD_VAR 0 4
48641: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48642: LD_INT 0
48644: PPUSH
48645: PPUSH
// if not side or not nation then
48646: LD_VAR 0 1
48650: NOT
48651: PUSH
48652: LD_VAR 0 2
48656: NOT
48657: OR
48658: IFFALSE 48662
// exit ;
48660: GO 49430
// case nation of nation_american :
48662: LD_VAR 0 2
48666: PUSH
48667: LD_INT 1
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48889
48675: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48676: LD_ADDR_VAR 0 4
48680: PUSH
48681: LD_INT 35
48683: PUSH
48684: LD_INT 45
48686: PUSH
48687: LD_INT 46
48689: PUSH
48690: LD_INT 47
48692: PUSH
48693: LD_INT 82
48695: PUSH
48696: LD_INT 83
48698: PUSH
48699: LD_INT 84
48701: PUSH
48702: LD_INT 85
48704: PUSH
48705: LD_INT 86
48707: PUSH
48708: LD_INT 1
48710: PUSH
48711: LD_INT 2
48713: PUSH
48714: LD_INT 6
48716: PUSH
48717: LD_INT 15
48719: PUSH
48720: LD_INT 16
48722: PUSH
48723: LD_INT 7
48725: PUSH
48726: LD_INT 12
48728: PUSH
48729: LD_INT 13
48731: PUSH
48732: LD_INT 10
48734: PUSH
48735: LD_INT 14
48737: PUSH
48738: LD_INT 20
48740: PUSH
48741: LD_INT 21
48743: PUSH
48744: LD_INT 22
48746: PUSH
48747: LD_INT 25
48749: PUSH
48750: LD_INT 32
48752: PUSH
48753: LD_INT 27
48755: PUSH
48756: LD_INT 36
48758: PUSH
48759: LD_INT 69
48761: PUSH
48762: LD_INT 39
48764: PUSH
48765: LD_INT 34
48767: PUSH
48768: LD_INT 40
48770: PUSH
48771: LD_INT 48
48773: PUSH
48774: LD_INT 49
48776: PUSH
48777: LD_INT 50
48779: PUSH
48780: LD_INT 51
48782: PUSH
48783: LD_INT 52
48785: PUSH
48786: LD_INT 53
48788: PUSH
48789: LD_INT 54
48791: PUSH
48792: LD_INT 55
48794: PUSH
48795: LD_INT 56
48797: PUSH
48798: LD_INT 57
48800: PUSH
48801: LD_INT 58
48803: PUSH
48804: LD_INT 59
48806: PUSH
48807: LD_INT 60
48809: PUSH
48810: LD_INT 61
48812: PUSH
48813: LD_INT 62
48815: PUSH
48816: LD_INT 80
48818: PUSH
48819: LD_INT 82
48821: PUSH
48822: LD_INT 83
48824: PUSH
48825: LD_INT 84
48827: PUSH
48828: LD_INT 85
48830: PUSH
48831: LD_INT 86
48833: PUSH
48834: EMPTY
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: LIST
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: LIST
48870: LIST
48871: LIST
48872: LIST
48873: LIST
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: LIST
48880: LIST
48881: LIST
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: ST_TO_ADDR
48887: GO 49354
48889: LD_INT 2
48891: DOUBLE
48892: EQUAL
48893: IFTRUE 48897
48895: GO 49123
48897: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48898: LD_ADDR_VAR 0 4
48902: PUSH
48903: LD_INT 35
48905: PUSH
48906: LD_INT 45
48908: PUSH
48909: LD_INT 46
48911: PUSH
48912: LD_INT 47
48914: PUSH
48915: LD_INT 82
48917: PUSH
48918: LD_INT 83
48920: PUSH
48921: LD_INT 84
48923: PUSH
48924: LD_INT 85
48926: PUSH
48927: LD_INT 87
48929: PUSH
48930: LD_INT 70
48932: PUSH
48933: LD_INT 1
48935: PUSH
48936: LD_INT 11
48938: PUSH
48939: LD_INT 3
48941: PUSH
48942: LD_INT 4
48944: PUSH
48945: LD_INT 5
48947: PUSH
48948: LD_INT 6
48950: PUSH
48951: LD_INT 15
48953: PUSH
48954: LD_INT 18
48956: PUSH
48957: LD_INT 7
48959: PUSH
48960: LD_INT 17
48962: PUSH
48963: LD_INT 8
48965: PUSH
48966: LD_INT 20
48968: PUSH
48969: LD_INT 21
48971: PUSH
48972: LD_INT 22
48974: PUSH
48975: LD_INT 72
48977: PUSH
48978: LD_INT 26
48980: PUSH
48981: LD_INT 69
48983: PUSH
48984: LD_INT 39
48986: PUSH
48987: LD_INT 40
48989: PUSH
48990: LD_INT 41
48992: PUSH
48993: LD_INT 42
48995: PUSH
48996: LD_INT 43
48998: PUSH
48999: LD_INT 48
49001: PUSH
49002: LD_INT 49
49004: PUSH
49005: LD_INT 50
49007: PUSH
49008: LD_INT 51
49010: PUSH
49011: LD_INT 52
49013: PUSH
49014: LD_INT 53
49016: PUSH
49017: LD_INT 54
49019: PUSH
49020: LD_INT 55
49022: PUSH
49023: LD_INT 56
49025: PUSH
49026: LD_INT 60
49028: PUSH
49029: LD_INT 61
49031: PUSH
49032: LD_INT 62
49034: PUSH
49035: LD_INT 66
49037: PUSH
49038: LD_INT 67
49040: PUSH
49041: LD_INT 68
49043: PUSH
49044: LD_INT 81
49046: PUSH
49047: LD_INT 82
49049: PUSH
49050: LD_INT 83
49052: PUSH
49053: LD_INT 84
49055: PUSH
49056: LD_INT 85
49058: PUSH
49059: LD_INT 87
49061: PUSH
49062: LD_INT 88
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: ST_TO_ADDR
49121: GO 49354
49123: LD_INT 3
49125: DOUBLE
49126: EQUAL
49127: IFTRUE 49131
49129: GO 49353
49131: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49132: LD_ADDR_VAR 0 4
49136: PUSH
49137: LD_INT 46
49139: PUSH
49140: LD_INT 47
49142: PUSH
49143: LD_INT 1
49145: PUSH
49146: LD_INT 2
49148: PUSH
49149: LD_INT 82
49151: PUSH
49152: LD_INT 83
49154: PUSH
49155: LD_INT 84
49157: PUSH
49158: LD_INT 85
49160: PUSH
49161: LD_INT 86
49163: PUSH
49164: LD_INT 11
49166: PUSH
49167: LD_INT 9
49169: PUSH
49170: LD_INT 20
49172: PUSH
49173: LD_INT 19
49175: PUSH
49176: LD_INT 21
49178: PUSH
49179: LD_INT 24
49181: PUSH
49182: LD_INT 22
49184: PUSH
49185: LD_INT 25
49187: PUSH
49188: LD_INT 28
49190: PUSH
49191: LD_INT 29
49193: PUSH
49194: LD_INT 30
49196: PUSH
49197: LD_INT 31
49199: PUSH
49200: LD_INT 37
49202: PUSH
49203: LD_INT 38
49205: PUSH
49206: LD_INT 32
49208: PUSH
49209: LD_INT 27
49211: PUSH
49212: LD_INT 33
49214: PUSH
49215: LD_INT 69
49217: PUSH
49218: LD_INT 39
49220: PUSH
49221: LD_INT 34
49223: PUSH
49224: LD_INT 40
49226: PUSH
49227: LD_INT 71
49229: PUSH
49230: LD_INT 23
49232: PUSH
49233: LD_INT 44
49235: PUSH
49236: LD_INT 48
49238: PUSH
49239: LD_INT 49
49241: PUSH
49242: LD_INT 50
49244: PUSH
49245: LD_INT 51
49247: PUSH
49248: LD_INT 52
49250: PUSH
49251: LD_INT 53
49253: PUSH
49254: LD_INT 54
49256: PUSH
49257: LD_INT 55
49259: PUSH
49260: LD_INT 56
49262: PUSH
49263: LD_INT 57
49265: PUSH
49266: LD_INT 58
49268: PUSH
49269: LD_INT 59
49271: PUSH
49272: LD_INT 63
49274: PUSH
49275: LD_INT 64
49277: PUSH
49278: LD_INT 65
49280: PUSH
49281: LD_INT 82
49283: PUSH
49284: LD_INT 83
49286: PUSH
49287: LD_INT 84
49289: PUSH
49290: LD_INT 85
49292: PUSH
49293: LD_INT 86
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: ST_TO_ADDR
49351: GO 49354
49353: POP
// if state > - 1 and state < 3 then
49354: LD_VAR 0 3
49358: PUSH
49359: LD_INT 1
49361: NEG
49362: GREATER
49363: PUSH
49364: LD_VAR 0 3
49368: PUSH
49369: LD_INT 3
49371: LESS
49372: AND
49373: IFFALSE 49430
// for i in result do
49375: LD_ADDR_VAR 0 5
49379: PUSH
49380: LD_VAR 0 4
49384: PUSH
49385: FOR_IN
49386: IFFALSE 49428
// if GetTech ( i , side ) <> state then
49388: LD_VAR 0 5
49392: PPUSH
49393: LD_VAR 0 1
49397: PPUSH
49398: CALL_OW 321
49402: PUSH
49403: LD_VAR 0 3
49407: NONEQUAL
49408: IFFALSE 49426
// result := result diff i ;
49410: LD_ADDR_VAR 0 4
49414: PUSH
49415: LD_VAR 0 4
49419: PUSH
49420: LD_VAR 0 5
49424: DIFF
49425: ST_TO_ADDR
49426: GO 49385
49428: POP
49429: POP
// end ;
49430: LD_VAR 0 4
49434: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49435: LD_INT 0
49437: PPUSH
49438: PPUSH
49439: PPUSH
// result := true ;
49440: LD_ADDR_VAR 0 3
49444: PUSH
49445: LD_INT 1
49447: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49448: LD_ADDR_VAR 0 5
49452: PUSH
49453: LD_VAR 0 2
49457: PPUSH
49458: CALL_OW 480
49462: ST_TO_ADDR
// if not tmp then
49463: LD_VAR 0 5
49467: NOT
49468: IFFALSE 49472
// exit ;
49470: GO 49521
// for i in tmp do
49472: LD_ADDR_VAR 0 4
49476: PUSH
49477: LD_VAR 0 5
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49519
// if GetTech ( i , side ) <> state_researched then
49485: LD_VAR 0 4
49489: PPUSH
49490: LD_VAR 0 1
49494: PPUSH
49495: CALL_OW 321
49499: PUSH
49500: LD_INT 2
49502: NONEQUAL
49503: IFFALSE 49517
// begin result := false ;
49505: LD_ADDR_VAR 0 3
49509: PUSH
49510: LD_INT 0
49512: ST_TO_ADDR
// exit ;
49513: POP
49514: POP
49515: GO 49521
// end ;
49517: GO 49482
49519: POP
49520: POP
// end ;
49521: LD_VAR 0 3
49525: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49526: LD_INT 0
49528: PPUSH
49529: PPUSH
49530: PPUSH
49531: PPUSH
49532: PPUSH
49533: PPUSH
49534: PPUSH
49535: PPUSH
49536: PPUSH
49537: PPUSH
49538: PPUSH
49539: PPUSH
49540: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49541: LD_VAR 0 1
49545: NOT
49546: PUSH
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 257
49556: PUSH
49557: LD_INT 9
49559: NONEQUAL
49560: OR
49561: IFFALSE 49565
// exit ;
49563: GO 50138
// side := GetSide ( unit ) ;
49565: LD_ADDR_VAR 0 9
49569: PUSH
49570: LD_VAR 0 1
49574: PPUSH
49575: CALL_OW 255
49579: ST_TO_ADDR
// tech_space := tech_spacanom ;
49580: LD_ADDR_VAR 0 12
49584: PUSH
49585: LD_INT 29
49587: ST_TO_ADDR
// tech_time := tech_taurad ;
49588: LD_ADDR_VAR 0 13
49592: PUSH
49593: LD_INT 28
49595: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49596: LD_ADDR_VAR 0 11
49600: PUSH
49601: LD_VAR 0 1
49605: PPUSH
49606: CALL_OW 310
49610: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49611: LD_VAR 0 11
49615: PPUSH
49616: CALL_OW 247
49620: PUSH
49621: LD_INT 2
49623: EQUAL
49624: IFFALSE 49628
// exit ;
49626: GO 50138
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49628: LD_ADDR_VAR 0 8
49632: PUSH
49633: LD_INT 81
49635: PUSH
49636: LD_VAR 0 9
49640: PUSH
49641: EMPTY
49642: LIST
49643: LIST
49644: PUSH
49645: LD_INT 3
49647: PUSH
49648: LD_INT 21
49650: PUSH
49651: LD_INT 3
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PPUSH
49666: CALL_OW 69
49670: ST_TO_ADDR
// if not tmp then
49671: LD_VAR 0 8
49675: NOT
49676: IFFALSE 49680
// exit ;
49678: GO 50138
// if in_unit then
49680: LD_VAR 0 11
49684: IFFALSE 49708
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49686: LD_ADDR_VAR 0 10
49690: PUSH
49691: LD_VAR 0 8
49695: PPUSH
49696: LD_VAR 0 11
49700: PPUSH
49701: CALL_OW 74
49705: ST_TO_ADDR
49706: GO 49728
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49708: LD_ADDR_VAR 0 10
49712: PUSH
49713: LD_VAR 0 8
49717: PPUSH
49718: LD_VAR 0 1
49722: PPUSH
49723: CALL_OW 74
49727: ST_TO_ADDR
// if not enemy then
49728: LD_VAR 0 10
49732: NOT
49733: IFFALSE 49737
// exit ;
49735: GO 50138
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49737: LD_VAR 0 11
49741: PUSH
49742: LD_VAR 0 11
49746: PPUSH
49747: LD_VAR 0 10
49751: PPUSH
49752: CALL_OW 296
49756: PUSH
49757: LD_INT 13
49759: GREATER
49760: AND
49761: PUSH
49762: LD_VAR 0 1
49766: PPUSH
49767: LD_VAR 0 10
49771: PPUSH
49772: CALL_OW 296
49776: PUSH
49777: LD_INT 12
49779: GREATER
49780: OR
49781: IFFALSE 49785
// exit ;
49783: GO 50138
// missile := [ 1 ] ;
49785: LD_ADDR_VAR 0 14
49789: PUSH
49790: LD_INT 1
49792: PUSH
49793: EMPTY
49794: LIST
49795: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49796: LD_VAR 0 9
49800: PPUSH
49801: LD_VAR 0 12
49805: PPUSH
49806: CALL_OW 325
49810: IFFALSE 49839
// missile := Replace ( missile , missile + 1 , 2 ) ;
49812: LD_ADDR_VAR 0 14
49816: PUSH
49817: LD_VAR 0 14
49821: PPUSH
49822: LD_VAR 0 14
49826: PUSH
49827: LD_INT 1
49829: PLUS
49830: PPUSH
49831: LD_INT 2
49833: PPUSH
49834: CALL_OW 1
49838: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49839: LD_VAR 0 9
49843: PPUSH
49844: LD_VAR 0 13
49848: PPUSH
49849: CALL_OW 325
49853: PUSH
49854: LD_VAR 0 10
49858: PPUSH
49859: CALL_OW 255
49863: PPUSH
49864: LD_VAR 0 13
49868: PPUSH
49869: CALL_OW 325
49873: NOT
49874: AND
49875: IFFALSE 49904
// missile := Replace ( missile , missile + 1 , 3 ) ;
49877: LD_ADDR_VAR 0 14
49881: PUSH
49882: LD_VAR 0 14
49886: PPUSH
49887: LD_VAR 0 14
49891: PUSH
49892: LD_INT 1
49894: PLUS
49895: PPUSH
49896: LD_INT 3
49898: PPUSH
49899: CALL_OW 1
49903: ST_TO_ADDR
// if missile < 2 then
49904: LD_VAR 0 14
49908: PUSH
49909: LD_INT 2
49911: LESS
49912: IFFALSE 49916
// exit ;
49914: GO 50138
// x := GetX ( enemy ) ;
49916: LD_ADDR_VAR 0 4
49920: PUSH
49921: LD_VAR 0 10
49925: PPUSH
49926: CALL_OW 250
49930: ST_TO_ADDR
// y := GetY ( enemy ) ;
49931: LD_ADDR_VAR 0 5
49935: PUSH
49936: LD_VAR 0 10
49940: PPUSH
49941: CALL_OW 251
49945: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49946: LD_ADDR_VAR 0 6
49950: PUSH
49951: LD_VAR 0 4
49955: PUSH
49956: LD_INT 1
49958: NEG
49959: PPUSH
49960: LD_INT 1
49962: PPUSH
49963: CALL_OW 12
49967: PLUS
49968: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49969: LD_ADDR_VAR 0 7
49973: PUSH
49974: LD_VAR 0 5
49978: PUSH
49979: LD_INT 1
49981: NEG
49982: PPUSH
49983: LD_INT 1
49985: PPUSH
49986: CALL_OW 12
49990: PLUS
49991: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49992: LD_VAR 0 6
49996: PPUSH
49997: LD_VAR 0 7
50001: PPUSH
50002: CALL_OW 488
50006: NOT
50007: IFFALSE 50029
// begin _x := x ;
50009: LD_ADDR_VAR 0 6
50013: PUSH
50014: LD_VAR 0 4
50018: ST_TO_ADDR
// _y := y ;
50019: LD_ADDR_VAR 0 7
50023: PUSH
50024: LD_VAR 0 5
50028: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50029: LD_ADDR_VAR 0 3
50033: PUSH
50034: LD_INT 1
50036: PPUSH
50037: LD_VAR 0 14
50041: PPUSH
50042: CALL_OW 12
50046: ST_TO_ADDR
// case i of 1 :
50047: LD_VAR 0 3
50051: PUSH
50052: LD_INT 1
50054: DOUBLE
50055: EQUAL
50056: IFTRUE 50060
50058: GO 50077
50060: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50061: LD_VAR 0 1
50065: PPUSH
50066: LD_VAR 0 10
50070: PPUSH
50071: CALL_OW 115
50075: GO 50138
50077: LD_INT 2
50079: DOUBLE
50080: EQUAL
50081: IFTRUE 50085
50083: GO 50107
50085: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_VAR 0 6
50095: PPUSH
50096: LD_VAR 0 7
50100: PPUSH
50101: CALL_OW 153
50105: GO 50138
50107: LD_INT 3
50109: DOUBLE
50110: EQUAL
50111: IFTRUE 50115
50113: GO 50137
50115: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50116: LD_VAR 0 1
50120: PPUSH
50121: LD_VAR 0 6
50125: PPUSH
50126: LD_VAR 0 7
50130: PPUSH
50131: CALL_OW 154
50135: GO 50138
50137: POP
// end ;
50138: LD_VAR 0 2
50142: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50143: LD_INT 0
50145: PPUSH
50146: PPUSH
50147: PPUSH
50148: PPUSH
50149: PPUSH
50150: PPUSH
// if not unit or not building then
50151: LD_VAR 0 1
50155: NOT
50156: PUSH
50157: LD_VAR 0 2
50161: NOT
50162: OR
50163: IFFALSE 50167
// exit ;
50165: GO 50325
// x := GetX ( building ) ;
50167: LD_ADDR_VAR 0 5
50171: PUSH
50172: LD_VAR 0 2
50176: PPUSH
50177: CALL_OW 250
50181: ST_TO_ADDR
// y := GetY ( building ) ;
50182: LD_ADDR_VAR 0 6
50186: PUSH
50187: LD_VAR 0 2
50191: PPUSH
50192: CALL_OW 251
50196: ST_TO_ADDR
// for i = 0 to 5 do
50197: LD_ADDR_VAR 0 4
50201: PUSH
50202: DOUBLE
50203: LD_INT 0
50205: DEC
50206: ST_TO_ADDR
50207: LD_INT 5
50209: PUSH
50210: FOR_TO
50211: IFFALSE 50323
// begin _x := ShiftX ( x , i , 3 ) ;
50213: LD_ADDR_VAR 0 7
50217: PUSH
50218: LD_VAR 0 5
50222: PPUSH
50223: LD_VAR 0 4
50227: PPUSH
50228: LD_INT 3
50230: PPUSH
50231: CALL_OW 272
50235: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50236: LD_ADDR_VAR 0 8
50240: PUSH
50241: LD_VAR 0 6
50245: PPUSH
50246: LD_VAR 0 4
50250: PPUSH
50251: LD_INT 3
50253: PPUSH
50254: CALL_OW 273
50258: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50259: LD_VAR 0 7
50263: PPUSH
50264: LD_VAR 0 8
50268: PPUSH
50269: CALL_OW 488
50273: NOT
50274: IFFALSE 50278
// continue ;
50276: GO 50210
// if HexInfo ( _x , _y ) = 0 then
50278: LD_VAR 0 7
50282: PPUSH
50283: LD_VAR 0 8
50287: PPUSH
50288: CALL_OW 428
50292: PUSH
50293: LD_INT 0
50295: EQUAL
50296: IFFALSE 50321
// begin ComMoveXY ( unit , _x , _y ) ;
50298: LD_VAR 0 1
50302: PPUSH
50303: LD_VAR 0 7
50307: PPUSH
50308: LD_VAR 0 8
50312: PPUSH
50313: CALL_OW 111
// exit ;
50317: POP
50318: POP
50319: GO 50325
// end ; end ;
50321: GO 50210
50323: POP
50324: POP
// end ;
50325: LD_VAR 0 3
50329: RET
// export function ScanBase ( side , base_area ) ; begin
50330: LD_INT 0
50332: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50333: LD_ADDR_VAR 0 3
50337: PUSH
50338: LD_VAR 0 2
50342: PPUSH
50343: LD_INT 81
50345: PUSH
50346: LD_VAR 0 1
50350: PUSH
50351: EMPTY
50352: LIST
50353: LIST
50354: PPUSH
50355: CALL_OW 70
50359: ST_TO_ADDR
// end ;
50360: LD_VAR 0 3
50364: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50365: LD_INT 0
50367: PPUSH
50368: PPUSH
50369: PPUSH
50370: PPUSH
// result := false ;
50371: LD_ADDR_VAR 0 2
50375: PUSH
50376: LD_INT 0
50378: ST_TO_ADDR
// side := GetSide ( unit ) ;
50379: LD_ADDR_VAR 0 3
50383: PUSH
50384: LD_VAR 0 1
50388: PPUSH
50389: CALL_OW 255
50393: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50394: LD_ADDR_VAR 0 4
50398: PUSH
50399: LD_VAR 0 1
50403: PPUSH
50404: CALL_OW 248
50408: ST_TO_ADDR
// case nat of 1 :
50409: LD_VAR 0 4
50413: PUSH
50414: LD_INT 1
50416: DOUBLE
50417: EQUAL
50418: IFTRUE 50422
50420: GO 50433
50422: POP
// tech := tech_lassight ; 2 :
50423: LD_ADDR_VAR 0 5
50427: PUSH
50428: LD_INT 12
50430: ST_TO_ADDR
50431: GO 50472
50433: LD_INT 2
50435: DOUBLE
50436: EQUAL
50437: IFTRUE 50441
50439: GO 50452
50441: POP
// tech := tech_mortar ; 3 :
50442: LD_ADDR_VAR 0 5
50446: PUSH
50447: LD_INT 41
50449: ST_TO_ADDR
50450: GO 50472
50452: LD_INT 3
50454: DOUBLE
50455: EQUAL
50456: IFTRUE 50460
50458: GO 50471
50460: POP
// tech := tech_bazooka ; end ;
50461: LD_ADDR_VAR 0 5
50465: PUSH
50466: LD_INT 44
50468: ST_TO_ADDR
50469: GO 50472
50471: POP
// if Researched ( side , tech ) then
50472: LD_VAR 0 3
50476: PPUSH
50477: LD_VAR 0 5
50481: PPUSH
50482: CALL_OW 325
50486: IFFALSE 50513
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50488: LD_ADDR_VAR 0 2
50492: PUSH
50493: LD_INT 5
50495: PUSH
50496: LD_INT 8
50498: PUSH
50499: LD_INT 9
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: LIST
50506: PUSH
50507: LD_VAR 0 4
50511: ARRAY
50512: ST_TO_ADDR
// end ;
50513: LD_VAR 0 2
50517: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50518: LD_INT 0
50520: PPUSH
50521: PPUSH
50522: PPUSH
// if not mines then
50523: LD_VAR 0 2
50527: NOT
50528: IFFALSE 50532
// exit ;
50530: GO 50676
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50532: LD_ADDR_VAR 0 5
50536: PUSH
50537: LD_INT 81
50539: PUSH
50540: LD_VAR 0 1
50544: PUSH
50545: EMPTY
50546: LIST
50547: LIST
50548: PUSH
50549: LD_INT 3
50551: PUSH
50552: LD_INT 21
50554: PUSH
50555: LD_INT 3
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: PPUSH
50570: CALL_OW 69
50574: ST_TO_ADDR
// for i in mines do
50575: LD_ADDR_VAR 0 4
50579: PUSH
50580: LD_VAR 0 2
50584: PUSH
50585: FOR_IN
50586: IFFALSE 50674
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50588: LD_VAR 0 4
50592: PUSH
50593: LD_INT 1
50595: ARRAY
50596: PPUSH
50597: LD_VAR 0 4
50601: PUSH
50602: LD_INT 2
50604: ARRAY
50605: PPUSH
50606: CALL_OW 458
50610: NOT
50611: IFFALSE 50615
// continue ;
50613: GO 50585
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50615: LD_VAR 0 4
50619: PUSH
50620: LD_INT 1
50622: ARRAY
50623: PPUSH
50624: LD_VAR 0 4
50628: PUSH
50629: LD_INT 2
50631: ARRAY
50632: PPUSH
50633: CALL_OW 428
50637: PUSH
50638: LD_VAR 0 5
50642: IN
50643: IFFALSE 50672
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50645: LD_VAR 0 4
50649: PUSH
50650: LD_INT 1
50652: ARRAY
50653: PPUSH
50654: LD_VAR 0 4
50658: PUSH
50659: LD_INT 2
50661: ARRAY
50662: PPUSH
50663: LD_VAR 0 1
50667: PPUSH
50668: CALL_OW 456
// end ;
50672: GO 50585
50674: POP
50675: POP
// end ;
50676: LD_VAR 0 3
50680: RET
// export function Count ( array ) ; var i ; begin
50681: LD_INT 0
50683: PPUSH
50684: PPUSH
// result := 0 ;
50685: LD_ADDR_VAR 0 2
50689: PUSH
50690: LD_INT 0
50692: ST_TO_ADDR
// for i in array do
50693: LD_ADDR_VAR 0 3
50697: PUSH
50698: LD_VAR 0 1
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50728
// if i then
50706: LD_VAR 0 3
50710: IFFALSE 50726
// result := result + 1 ;
50712: LD_ADDR_VAR 0 2
50716: PUSH
50717: LD_VAR 0 2
50721: PUSH
50722: LD_INT 1
50724: PLUS
50725: ST_TO_ADDR
50726: GO 50703
50728: POP
50729: POP
// end ;
50730: LD_VAR 0 2
50734: RET
// export function IsEmpty ( building ) ; begin
50735: LD_INT 0
50737: PPUSH
// if not building then
50738: LD_VAR 0 1
50742: NOT
50743: IFFALSE 50747
// exit ;
50745: GO 50790
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50747: LD_ADDR_VAR 0 2
50751: PUSH
50752: LD_VAR 0 1
50756: PUSH
50757: LD_INT 22
50759: PUSH
50760: LD_VAR 0 1
50764: PPUSH
50765: CALL_OW 255
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: LD_INT 58
50776: PUSH
50777: EMPTY
50778: LIST
50779: PUSH
50780: EMPTY
50781: LIST
50782: LIST
50783: PPUSH
50784: CALL_OW 69
50788: IN
50789: ST_TO_ADDR
// end ;
50790: LD_VAR 0 2
50794: RET
// export function IsNotFull ( building ) ; begin
50795: LD_INT 0
50797: PPUSH
// if not building then
50798: LD_VAR 0 1
50802: NOT
50803: IFFALSE 50807
// exit ;
50805: GO 50826
// result := UnitsInside ( building ) < 6 ;
50807: LD_ADDR_VAR 0 2
50811: PUSH
50812: LD_VAR 0 1
50816: PPUSH
50817: CALL_OW 313
50821: PUSH
50822: LD_INT 6
50824: LESS
50825: ST_TO_ADDR
// end ;
50826: LD_VAR 0 2
50830: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50831: LD_INT 0
50833: PPUSH
50834: PPUSH
50835: PPUSH
50836: PPUSH
// tmp := [ ] ;
50837: LD_ADDR_VAR 0 3
50841: PUSH
50842: EMPTY
50843: ST_TO_ADDR
// list := [ ] ;
50844: LD_ADDR_VAR 0 5
50848: PUSH
50849: EMPTY
50850: ST_TO_ADDR
// for i = 16 to 25 do
50851: LD_ADDR_VAR 0 4
50855: PUSH
50856: DOUBLE
50857: LD_INT 16
50859: DEC
50860: ST_TO_ADDR
50861: LD_INT 25
50863: PUSH
50864: FOR_TO
50865: IFFALSE 50938
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50867: LD_ADDR_VAR 0 3
50871: PUSH
50872: LD_VAR 0 3
50876: PUSH
50877: LD_INT 22
50879: PUSH
50880: LD_VAR 0 1
50884: PPUSH
50885: CALL_OW 255
50889: PUSH
50890: EMPTY
50891: LIST
50892: LIST
50893: PUSH
50894: LD_INT 91
50896: PUSH
50897: LD_VAR 0 1
50901: PUSH
50902: LD_INT 6
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 30
50912: PUSH
50913: LD_VAR 0 4
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: EMPTY
50923: LIST
50924: LIST
50925: LIST
50926: PUSH
50927: EMPTY
50928: LIST
50929: PPUSH
50930: CALL_OW 69
50934: ADD
50935: ST_TO_ADDR
50936: GO 50864
50938: POP
50939: POP
// for i = 1 to tmp do
50940: LD_ADDR_VAR 0 4
50944: PUSH
50945: DOUBLE
50946: LD_INT 1
50948: DEC
50949: ST_TO_ADDR
50950: LD_VAR 0 3
50954: PUSH
50955: FOR_TO
50956: IFFALSE 51044
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50958: LD_ADDR_VAR 0 5
50962: PUSH
50963: LD_VAR 0 5
50967: PUSH
50968: LD_VAR 0 3
50972: PUSH
50973: LD_VAR 0 4
50977: ARRAY
50978: PPUSH
50979: CALL_OW 266
50983: PUSH
50984: LD_VAR 0 3
50988: PUSH
50989: LD_VAR 0 4
50993: ARRAY
50994: PPUSH
50995: CALL_OW 250
50999: PUSH
51000: LD_VAR 0 3
51004: PUSH
51005: LD_VAR 0 4
51009: ARRAY
51010: PPUSH
51011: CALL_OW 251
51015: PUSH
51016: LD_VAR 0 3
51020: PUSH
51021: LD_VAR 0 4
51025: ARRAY
51026: PPUSH
51027: CALL_OW 254
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: PUSH
51038: EMPTY
51039: LIST
51040: ADD
51041: ST_TO_ADDR
51042: GO 50955
51044: POP
51045: POP
// result := list ;
51046: LD_ADDR_VAR 0 2
51050: PUSH
51051: LD_VAR 0 5
51055: ST_TO_ADDR
// end ;
51056: LD_VAR 0 2
51060: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51061: LD_INT 0
51063: PPUSH
51064: PPUSH
51065: PPUSH
51066: PPUSH
51067: PPUSH
51068: PPUSH
51069: PPUSH
// if not factory then
51070: LD_VAR 0 1
51074: NOT
51075: IFFALSE 51079
// exit ;
51077: GO 51672
// if control = control_apeman then
51079: LD_VAR 0 4
51083: PUSH
51084: LD_INT 5
51086: EQUAL
51087: IFFALSE 51196
// begin tmp := UnitsInside ( factory ) ;
51089: LD_ADDR_VAR 0 8
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 313
51103: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51104: LD_VAR 0 8
51108: PPUSH
51109: LD_INT 25
51111: PUSH
51112: LD_INT 12
51114: PUSH
51115: EMPTY
51116: LIST
51117: LIST
51118: PPUSH
51119: CALL_OW 72
51123: NOT
51124: IFFALSE 51134
// control := control_manual ;
51126: LD_ADDR_VAR 0 4
51130: PUSH
51131: LD_INT 1
51133: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51134: LD_ADDR_VAR 0 8
51138: PUSH
51139: LD_VAR 0 1
51143: PPUSH
51144: CALL 50831 0 1
51148: ST_TO_ADDR
// if tmp then
51149: LD_VAR 0 8
51153: IFFALSE 51196
// begin for i in tmp do
51155: LD_ADDR_VAR 0 7
51159: PUSH
51160: LD_VAR 0 8
51164: PUSH
51165: FOR_IN
51166: IFFALSE 51194
// if i [ 1 ] = b_ext_radio then
51168: LD_VAR 0 7
51172: PUSH
51173: LD_INT 1
51175: ARRAY
51176: PUSH
51177: LD_INT 22
51179: EQUAL
51180: IFFALSE 51192
// begin control := control_remote ;
51182: LD_ADDR_VAR 0 4
51186: PUSH
51187: LD_INT 2
51189: ST_TO_ADDR
// break ;
51190: GO 51194
// end ;
51192: GO 51165
51194: POP
51195: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51196: LD_VAR 0 1
51200: PPUSH
51201: LD_VAR 0 2
51205: PPUSH
51206: LD_VAR 0 3
51210: PPUSH
51211: LD_VAR 0 4
51215: PPUSH
51216: LD_VAR 0 5
51220: PPUSH
51221: CALL_OW 448
51225: IFFALSE 51260
// begin result := [ chassis , engine , control , weapon ] ;
51227: LD_ADDR_VAR 0 6
51231: PUSH
51232: LD_VAR 0 2
51236: PUSH
51237: LD_VAR 0 3
51241: PUSH
51242: LD_VAR 0 4
51246: PUSH
51247: LD_VAR 0 5
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: ST_TO_ADDR
// exit ;
51258: GO 51672
// end ; _chassis := AvailableChassisList ( factory ) ;
51260: LD_ADDR_VAR 0 9
51264: PUSH
51265: LD_VAR 0 1
51269: PPUSH
51270: CALL_OW 475
51274: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51275: LD_ADDR_VAR 0 11
51279: PUSH
51280: LD_VAR 0 1
51284: PPUSH
51285: CALL_OW 476
51289: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51290: LD_ADDR_VAR 0 12
51294: PUSH
51295: LD_VAR 0 1
51299: PPUSH
51300: CALL_OW 477
51304: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51305: LD_ADDR_VAR 0 10
51309: PUSH
51310: LD_VAR 0 1
51314: PPUSH
51315: CALL_OW 478
51319: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51320: LD_VAR 0 9
51324: NOT
51325: PUSH
51326: LD_VAR 0 11
51330: NOT
51331: OR
51332: PUSH
51333: LD_VAR 0 12
51337: NOT
51338: OR
51339: PUSH
51340: LD_VAR 0 10
51344: NOT
51345: OR
51346: IFFALSE 51381
// begin result := [ chassis , engine , control , weapon ] ;
51348: LD_ADDR_VAR 0 6
51352: PUSH
51353: LD_VAR 0 2
51357: PUSH
51358: LD_VAR 0 3
51362: PUSH
51363: LD_VAR 0 4
51367: PUSH
51368: LD_VAR 0 5
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: ST_TO_ADDR
// exit ;
51379: GO 51672
// end ; if not chassis in _chassis then
51381: LD_VAR 0 2
51385: PUSH
51386: LD_VAR 0 9
51390: IN
51391: NOT
51392: IFFALSE 51418
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51394: LD_ADDR_VAR 0 2
51398: PUSH
51399: LD_VAR 0 9
51403: PUSH
51404: LD_INT 1
51406: PPUSH
51407: LD_VAR 0 9
51411: PPUSH
51412: CALL_OW 12
51416: ARRAY
51417: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51418: LD_VAR 0 2
51422: PPUSH
51423: LD_VAR 0 3
51427: PPUSH
51428: CALL 51677 0 2
51432: NOT
51433: IFFALSE 51492
// repeat engine := _engine [ 1 ] ;
51435: LD_ADDR_VAR 0 3
51439: PUSH
51440: LD_VAR 0 11
51444: PUSH
51445: LD_INT 1
51447: ARRAY
51448: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51449: LD_ADDR_VAR 0 11
51453: PUSH
51454: LD_VAR 0 11
51458: PPUSH
51459: LD_INT 1
51461: PPUSH
51462: CALL_OW 3
51466: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51467: LD_VAR 0 2
51471: PPUSH
51472: LD_VAR 0 3
51476: PPUSH
51477: CALL 51677 0 2
51481: PUSH
51482: LD_VAR 0 11
51486: PUSH
51487: EMPTY
51488: EQUAL
51489: OR
51490: IFFALSE 51435
// if not control in _control then
51492: LD_VAR 0 4
51496: PUSH
51497: LD_VAR 0 12
51501: IN
51502: NOT
51503: IFFALSE 51529
// control := _control [ rand ( 1 , _control ) ] ;
51505: LD_ADDR_VAR 0 4
51509: PUSH
51510: LD_VAR 0 12
51514: PUSH
51515: LD_INT 1
51517: PPUSH
51518: LD_VAR 0 12
51522: PPUSH
51523: CALL_OW 12
51527: ARRAY
51528: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51529: LD_VAR 0 2
51533: PPUSH
51534: LD_VAR 0 5
51538: PPUSH
51539: CALL 51897 0 2
51543: NOT
51544: IFFALSE 51603
// repeat weapon := _weapon [ 1 ] ;
51546: LD_ADDR_VAR 0 5
51550: PUSH
51551: LD_VAR 0 10
51555: PUSH
51556: LD_INT 1
51558: ARRAY
51559: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51560: LD_ADDR_VAR 0 10
51564: PUSH
51565: LD_VAR 0 10
51569: PPUSH
51570: LD_INT 1
51572: PPUSH
51573: CALL_OW 3
51577: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51578: LD_VAR 0 2
51582: PPUSH
51583: LD_VAR 0 5
51587: PPUSH
51588: CALL 51897 0 2
51592: PUSH
51593: LD_VAR 0 10
51597: PUSH
51598: EMPTY
51599: EQUAL
51600: OR
51601: IFFALSE 51546
// result := [ ] ;
51603: LD_ADDR_VAR 0 6
51607: PUSH
51608: EMPTY
51609: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51610: LD_VAR 0 1
51614: PPUSH
51615: LD_VAR 0 2
51619: PPUSH
51620: LD_VAR 0 3
51624: PPUSH
51625: LD_VAR 0 4
51629: PPUSH
51630: LD_VAR 0 5
51634: PPUSH
51635: CALL_OW 448
51639: IFFALSE 51672
// result := [ chassis , engine , control , weapon ] ;
51641: LD_ADDR_VAR 0 6
51645: PUSH
51646: LD_VAR 0 2
51650: PUSH
51651: LD_VAR 0 3
51655: PUSH
51656: LD_VAR 0 4
51660: PUSH
51661: LD_VAR 0 5
51665: PUSH
51666: EMPTY
51667: LIST
51668: LIST
51669: LIST
51670: LIST
51671: ST_TO_ADDR
// end ;
51672: LD_VAR 0 6
51676: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51677: LD_INT 0
51679: PPUSH
// if not chassis or not engine then
51680: LD_VAR 0 1
51684: NOT
51685: PUSH
51686: LD_VAR 0 2
51690: NOT
51691: OR
51692: IFFALSE 51696
// exit ;
51694: GO 51892
// case engine of engine_solar :
51696: LD_VAR 0 2
51700: PUSH
51701: LD_INT 2
51703: DOUBLE
51704: EQUAL
51705: IFTRUE 51709
51707: GO 51747
51709: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51710: LD_ADDR_VAR 0 3
51714: PUSH
51715: LD_INT 11
51717: PUSH
51718: LD_INT 12
51720: PUSH
51721: LD_INT 13
51723: PUSH
51724: LD_INT 14
51726: PUSH
51727: LD_INT 1
51729: PUSH
51730: LD_INT 2
51732: PUSH
51733: LD_INT 3
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: LIST
51742: LIST
51743: LIST
51744: ST_TO_ADDR
51745: GO 51876
51747: LD_INT 1
51749: DOUBLE
51750: EQUAL
51751: IFTRUE 51755
51753: GO 51817
51755: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51756: LD_ADDR_VAR 0 3
51760: PUSH
51761: LD_INT 11
51763: PUSH
51764: LD_INT 12
51766: PUSH
51767: LD_INT 13
51769: PUSH
51770: LD_INT 14
51772: PUSH
51773: LD_INT 1
51775: PUSH
51776: LD_INT 2
51778: PUSH
51779: LD_INT 3
51781: PUSH
51782: LD_INT 4
51784: PUSH
51785: LD_INT 5
51787: PUSH
51788: LD_INT 21
51790: PUSH
51791: LD_INT 23
51793: PUSH
51794: LD_INT 22
51796: PUSH
51797: LD_INT 24
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: LIST
51806: LIST
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: LIST
51812: LIST
51813: LIST
51814: ST_TO_ADDR
51815: GO 51876
51817: LD_INT 3
51819: DOUBLE
51820: EQUAL
51821: IFTRUE 51825
51823: GO 51875
51825: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51826: LD_ADDR_VAR 0 3
51830: PUSH
51831: LD_INT 13
51833: PUSH
51834: LD_INT 14
51836: PUSH
51837: LD_INT 2
51839: PUSH
51840: LD_INT 3
51842: PUSH
51843: LD_INT 4
51845: PUSH
51846: LD_INT 5
51848: PUSH
51849: LD_INT 21
51851: PUSH
51852: LD_INT 22
51854: PUSH
51855: LD_INT 23
51857: PUSH
51858: LD_INT 24
51860: PUSH
51861: EMPTY
51862: LIST
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: ST_TO_ADDR
51873: GO 51876
51875: POP
// result := ( chassis in result ) ;
51876: LD_ADDR_VAR 0 3
51880: PUSH
51881: LD_VAR 0 1
51885: PUSH
51886: LD_VAR 0 3
51890: IN
51891: ST_TO_ADDR
// end ;
51892: LD_VAR 0 3
51896: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51897: LD_INT 0
51899: PPUSH
// if not chassis or not weapon then
51900: LD_VAR 0 1
51904: NOT
51905: PUSH
51906: LD_VAR 0 2
51910: NOT
51911: OR
51912: IFFALSE 51916
// exit ;
51914: GO 52978
// case weapon of us_machine_gun :
51916: LD_VAR 0 2
51920: PUSH
51921: LD_INT 2
51923: DOUBLE
51924: EQUAL
51925: IFTRUE 51929
51927: GO 51959
51929: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51930: LD_ADDR_VAR 0 3
51934: PUSH
51935: LD_INT 1
51937: PUSH
51938: LD_INT 2
51940: PUSH
51941: LD_INT 3
51943: PUSH
51944: LD_INT 4
51946: PUSH
51947: LD_INT 5
51949: PUSH
51950: EMPTY
51951: LIST
51952: LIST
51953: LIST
51954: LIST
51955: LIST
51956: ST_TO_ADDR
51957: GO 52962
51959: LD_INT 3
51961: DOUBLE
51962: EQUAL
51963: IFTRUE 51967
51965: GO 51997
51967: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51968: LD_ADDR_VAR 0 3
51972: PUSH
51973: LD_INT 1
51975: PUSH
51976: LD_INT 2
51978: PUSH
51979: LD_INT 3
51981: PUSH
51982: LD_INT 4
51984: PUSH
51985: LD_INT 5
51987: PUSH
51988: EMPTY
51989: LIST
51990: LIST
51991: LIST
51992: LIST
51993: LIST
51994: ST_TO_ADDR
51995: GO 52962
51997: LD_INT 11
51999: DOUBLE
52000: EQUAL
52001: IFTRUE 52005
52003: GO 52035
52005: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52006: LD_ADDR_VAR 0 3
52010: PUSH
52011: LD_INT 1
52013: PUSH
52014: LD_INT 2
52016: PUSH
52017: LD_INT 3
52019: PUSH
52020: LD_INT 4
52022: PUSH
52023: LD_INT 5
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: LIST
52032: ST_TO_ADDR
52033: GO 52962
52035: LD_INT 4
52037: DOUBLE
52038: EQUAL
52039: IFTRUE 52043
52041: GO 52069
52043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52044: LD_ADDR_VAR 0 3
52048: PUSH
52049: LD_INT 2
52051: PUSH
52052: LD_INT 3
52054: PUSH
52055: LD_INT 4
52057: PUSH
52058: LD_INT 5
52060: PUSH
52061: EMPTY
52062: LIST
52063: LIST
52064: LIST
52065: LIST
52066: ST_TO_ADDR
52067: GO 52962
52069: LD_INT 5
52071: DOUBLE
52072: EQUAL
52073: IFTRUE 52077
52075: GO 52103
52077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52078: LD_ADDR_VAR 0 3
52082: PUSH
52083: LD_INT 2
52085: PUSH
52086: LD_INT 3
52088: PUSH
52089: LD_INT 4
52091: PUSH
52092: LD_INT 5
52094: PUSH
52095: EMPTY
52096: LIST
52097: LIST
52098: LIST
52099: LIST
52100: ST_TO_ADDR
52101: GO 52962
52103: LD_INT 9
52105: DOUBLE
52106: EQUAL
52107: IFTRUE 52111
52109: GO 52137
52111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52112: LD_ADDR_VAR 0 3
52116: PUSH
52117: LD_INT 2
52119: PUSH
52120: LD_INT 3
52122: PUSH
52123: LD_INT 4
52125: PUSH
52126: LD_INT 5
52128: PUSH
52129: EMPTY
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: ST_TO_ADDR
52135: GO 52962
52137: LD_INT 7
52139: DOUBLE
52140: EQUAL
52141: IFTRUE 52145
52143: GO 52171
52145: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52146: LD_ADDR_VAR 0 3
52150: PUSH
52151: LD_INT 2
52153: PUSH
52154: LD_INT 3
52156: PUSH
52157: LD_INT 4
52159: PUSH
52160: LD_INT 5
52162: PUSH
52163: EMPTY
52164: LIST
52165: LIST
52166: LIST
52167: LIST
52168: ST_TO_ADDR
52169: GO 52962
52171: LD_INT 12
52173: DOUBLE
52174: EQUAL
52175: IFTRUE 52179
52177: GO 52205
52179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52180: LD_ADDR_VAR 0 3
52184: PUSH
52185: LD_INT 2
52187: PUSH
52188: LD_INT 3
52190: PUSH
52191: LD_INT 4
52193: PUSH
52194: LD_INT 5
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: LIST
52201: LIST
52202: ST_TO_ADDR
52203: GO 52962
52205: LD_INT 13
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52239
52213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 2
52221: PUSH
52222: LD_INT 3
52224: PUSH
52225: LD_INT 4
52227: PUSH
52228: LD_INT 5
52230: PUSH
52231: EMPTY
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: ST_TO_ADDR
52237: GO 52962
52239: LD_INT 14
52241: DOUBLE
52242: EQUAL
52243: IFTRUE 52247
52245: GO 52265
52247: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52248: LD_ADDR_VAR 0 3
52252: PUSH
52253: LD_INT 4
52255: PUSH
52256: LD_INT 5
52258: PUSH
52259: EMPTY
52260: LIST
52261: LIST
52262: ST_TO_ADDR
52263: GO 52962
52265: LD_INT 6
52267: DOUBLE
52268: EQUAL
52269: IFTRUE 52273
52271: GO 52291
52273: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52274: LD_ADDR_VAR 0 3
52278: PUSH
52279: LD_INT 4
52281: PUSH
52282: LD_INT 5
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: ST_TO_ADDR
52289: GO 52962
52291: LD_INT 10
52293: DOUBLE
52294: EQUAL
52295: IFTRUE 52299
52297: GO 52317
52299: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52300: LD_ADDR_VAR 0 3
52304: PUSH
52305: LD_INT 4
52307: PUSH
52308: LD_INT 5
52310: PUSH
52311: EMPTY
52312: LIST
52313: LIST
52314: ST_TO_ADDR
52315: GO 52962
52317: LD_INT 22
52319: DOUBLE
52320: EQUAL
52321: IFTRUE 52325
52323: GO 52351
52325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52326: LD_ADDR_VAR 0 3
52330: PUSH
52331: LD_INT 11
52333: PUSH
52334: LD_INT 12
52336: PUSH
52337: LD_INT 13
52339: PUSH
52340: LD_INT 14
52342: PUSH
52343: EMPTY
52344: LIST
52345: LIST
52346: LIST
52347: LIST
52348: ST_TO_ADDR
52349: GO 52962
52351: LD_INT 23
52353: DOUBLE
52354: EQUAL
52355: IFTRUE 52359
52357: GO 52385
52359: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52360: LD_ADDR_VAR 0 3
52364: PUSH
52365: LD_INT 11
52367: PUSH
52368: LD_INT 12
52370: PUSH
52371: LD_INT 13
52373: PUSH
52374: LD_INT 14
52376: PUSH
52377: EMPTY
52378: LIST
52379: LIST
52380: LIST
52381: LIST
52382: ST_TO_ADDR
52383: GO 52962
52385: LD_INT 24
52387: DOUBLE
52388: EQUAL
52389: IFTRUE 52393
52391: GO 52419
52393: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52394: LD_ADDR_VAR 0 3
52398: PUSH
52399: LD_INT 11
52401: PUSH
52402: LD_INT 12
52404: PUSH
52405: LD_INT 13
52407: PUSH
52408: LD_INT 14
52410: PUSH
52411: EMPTY
52412: LIST
52413: LIST
52414: LIST
52415: LIST
52416: ST_TO_ADDR
52417: GO 52962
52419: LD_INT 30
52421: DOUBLE
52422: EQUAL
52423: IFTRUE 52427
52425: GO 52453
52427: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52428: LD_ADDR_VAR 0 3
52432: PUSH
52433: LD_INT 11
52435: PUSH
52436: LD_INT 12
52438: PUSH
52439: LD_INT 13
52441: PUSH
52442: LD_INT 14
52444: PUSH
52445: EMPTY
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: ST_TO_ADDR
52451: GO 52962
52453: LD_INT 25
52455: DOUBLE
52456: EQUAL
52457: IFTRUE 52461
52459: GO 52479
52461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52462: LD_ADDR_VAR 0 3
52466: PUSH
52467: LD_INT 13
52469: PUSH
52470: LD_INT 14
52472: PUSH
52473: EMPTY
52474: LIST
52475: LIST
52476: ST_TO_ADDR
52477: GO 52962
52479: LD_INT 27
52481: DOUBLE
52482: EQUAL
52483: IFTRUE 52487
52485: GO 52505
52487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52488: LD_ADDR_VAR 0 3
52492: PUSH
52493: LD_INT 13
52495: PUSH
52496: LD_INT 14
52498: PUSH
52499: EMPTY
52500: LIST
52501: LIST
52502: ST_TO_ADDR
52503: GO 52962
52505: LD_EXP 99
52509: DOUBLE
52510: EQUAL
52511: IFTRUE 52515
52513: GO 52541
52515: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52516: LD_ADDR_VAR 0 3
52520: PUSH
52521: LD_INT 11
52523: PUSH
52524: LD_INT 12
52526: PUSH
52527: LD_INT 13
52529: PUSH
52530: LD_INT 14
52532: PUSH
52533: EMPTY
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: ST_TO_ADDR
52539: GO 52962
52541: LD_INT 28
52543: DOUBLE
52544: EQUAL
52545: IFTRUE 52549
52547: GO 52567
52549: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52550: LD_ADDR_VAR 0 3
52554: PUSH
52555: LD_INT 13
52557: PUSH
52558: LD_INT 14
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: ST_TO_ADDR
52565: GO 52962
52567: LD_INT 29
52569: DOUBLE
52570: EQUAL
52571: IFTRUE 52575
52573: GO 52593
52575: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52576: LD_ADDR_VAR 0 3
52580: PUSH
52581: LD_INT 13
52583: PUSH
52584: LD_INT 14
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: ST_TO_ADDR
52591: GO 52962
52593: LD_INT 31
52595: DOUBLE
52596: EQUAL
52597: IFTRUE 52601
52599: GO 52619
52601: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52602: LD_ADDR_VAR 0 3
52606: PUSH
52607: LD_INT 13
52609: PUSH
52610: LD_INT 14
52612: PUSH
52613: EMPTY
52614: LIST
52615: LIST
52616: ST_TO_ADDR
52617: GO 52962
52619: LD_INT 26
52621: DOUBLE
52622: EQUAL
52623: IFTRUE 52627
52625: GO 52645
52627: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52628: LD_ADDR_VAR 0 3
52632: PUSH
52633: LD_INT 13
52635: PUSH
52636: LD_INT 14
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: ST_TO_ADDR
52643: GO 52962
52645: LD_INT 42
52647: DOUBLE
52648: EQUAL
52649: IFTRUE 52653
52651: GO 52679
52653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52654: LD_ADDR_VAR 0 3
52658: PUSH
52659: LD_INT 21
52661: PUSH
52662: LD_INT 22
52664: PUSH
52665: LD_INT 23
52667: PUSH
52668: LD_INT 24
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: ST_TO_ADDR
52677: GO 52962
52679: LD_INT 43
52681: DOUBLE
52682: EQUAL
52683: IFTRUE 52687
52685: GO 52713
52687: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52688: LD_ADDR_VAR 0 3
52692: PUSH
52693: LD_INT 21
52695: PUSH
52696: LD_INT 22
52698: PUSH
52699: LD_INT 23
52701: PUSH
52702: LD_INT 24
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: LIST
52709: LIST
52710: ST_TO_ADDR
52711: GO 52962
52713: LD_INT 44
52715: DOUBLE
52716: EQUAL
52717: IFTRUE 52721
52719: GO 52747
52721: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52722: LD_ADDR_VAR 0 3
52726: PUSH
52727: LD_INT 21
52729: PUSH
52730: LD_INT 22
52732: PUSH
52733: LD_INT 23
52735: PUSH
52736: LD_INT 24
52738: PUSH
52739: EMPTY
52740: LIST
52741: LIST
52742: LIST
52743: LIST
52744: ST_TO_ADDR
52745: GO 52962
52747: LD_INT 45
52749: DOUBLE
52750: EQUAL
52751: IFTRUE 52755
52753: GO 52781
52755: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52756: LD_ADDR_VAR 0 3
52760: PUSH
52761: LD_INT 21
52763: PUSH
52764: LD_INT 22
52766: PUSH
52767: LD_INT 23
52769: PUSH
52770: LD_INT 24
52772: PUSH
52773: EMPTY
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: ST_TO_ADDR
52779: GO 52962
52781: LD_INT 49
52783: DOUBLE
52784: EQUAL
52785: IFTRUE 52789
52787: GO 52815
52789: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52790: LD_ADDR_VAR 0 3
52794: PUSH
52795: LD_INT 21
52797: PUSH
52798: LD_INT 22
52800: PUSH
52801: LD_INT 23
52803: PUSH
52804: LD_INT 24
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: LIST
52811: LIST
52812: ST_TO_ADDR
52813: GO 52962
52815: LD_INT 51
52817: DOUBLE
52818: EQUAL
52819: IFTRUE 52823
52821: GO 52849
52823: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52824: LD_ADDR_VAR 0 3
52828: PUSH
52829: LD_INT 21
52831: PUSH
52832: LD_INT 22
52834: PUSH
52835: LD_INT 23
52837: PUSH
52838: LD_INT 24
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: LIST
52845: LIST
52846: ST_TO_ADDR
52847: GO 52962
52849: LD_INT 52
52851: DOUBLE
52852: EQUAL
52853: IFTRUE 52857
52855: GO 52883
52857: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52858: LD_ADDR_VAR 0 3
52862: PUSH
52863: LD_INT 21
52865: PUSH
52866: LD_INT 22
52868: PUSH
52869: LD_INT 23
52871: PUSH
52872: LD_INT 24
52874: PUSH
52875: EMPTY
52876: LIST
52877: LIST
52878: LIST
52879: LIST
52880: ST_TO_ADDR
52881: GO 52962
52883: LD_INT 53
52885: DOUBLE
52886: EQUAL
52887: IFTRUE 52891
52889: GO 52909
52891: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52892: LD_ADDR_VAR 0 3
52896: PUSH
52897: LD_INT 23
52899: PUSH
52900: LD_INT 24
52902: PUSH
52903: EMPTY
52904: LIST
52905: LIST
52906: ST_TO_ADDR
52907: GO 52962
52909: LD_INT 46
52911: DOUBLE
52912: EQUAL
52913: IFTRUE 52917
52915: GO 52935
52917: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52918: LD_ADDR_VAR 0 3
52922: PUSH
52923: LD_INT 23
52925: PUSH
52926: LD_INT 24
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: ST_TO_ADDR
52933: GO 52962
52935: LD_INT 47
52937: DOUBLE
52938: EQUAL
52939: IFTRUE 52943
52941: GO 52961
52943: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52944: LD_ADDR_VAR 0 3
52948: PUSH
52949: LD_INT 23
52951: PUSH
52952: LD_INT 24
52954: PUSH
52955: EMPTY
52956: LIST
52957: LIST
52958: ST_TO_ADDR
52959: GO 52962
52961: POP
// result := ( chassis in result ) ;
52962: LD_ADDR_VAR 0 3
52966: PUSH
52967: LD_VAR 0 1
52971: PUSH
52972: LD_VAR 0 3
52976: IN
52977: ST_TO_ADDR
// end ;
52978: LD_VAR 0 3
52982: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52983: LD_INT 0
52985: PPUSH
52986: PPUSH
52987: PPUSH
52988: PPUSH
52989: PPUSH
52990: PPUSH
52991: PPUSH
// result := array ;
52992: LD_ADDR_VAR 0 5
52996: PUSH
52997: LD_VAR 0 1
53001: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53002: LD_VAR 0 1
53006: NOT
53007: PUSH
53008: LD_VAR 0 2
53012: NOT
53013: OR
53014: PUSH
53015: LD_VAR 0 3
53019: NOT
53020: OR
53021: PUSH
53022: LD_VAR 0 2
53026: PUSH
53027: LD_VAR 0 1
53031: GREATER
53032: OR
53033: PUSH
53034: LD_VAR 0 3
53038: PUSH
53039: LD_VAR 0 1
53043: GREATER
53044: OR
53045: IFFALSE 53049
// exit ;
53047: GO 53345
// if direction then
53049: LD_VAR 0 4
53053: IFFALSE 53117
// begin d := 1 ;
53055: LD_ADDR_VAR 0 9
53059: PUSH
53060: LD_INT 1
53062: ST_TO_ADDR
// if i_from > i_to then
53063: LD_VAR 0 2
53067: PUSH
53068: LD_VAR 0 3
53072: GREATER
53073: IFFALSE 53099
// length := ( array - i_from ) + i_to else
53075: LD_ADDR_VAR 0 11
53079: PUSH
53080: LD_VAR 0 1
53084: PUSH
53085: LD_VAR 0 2
53089: MINUS
53090: PUSH
53091: LD_VAR 0 3
53095: PLUS
53096: ST_TO_ADDR
53097: GO 53115
// length := i_to - i_from ;
53099: LD_ADDR_VAR 0 11
53103: PUSH
53104: LD_VAR 0 3
53108: PUSH
53109: LD_VAR 0 2
53113: MINUS
53114: ST_TO_ADDR
// end else
53115: GO 53178
// begin d := - 1 ;
53117: LD_ADDR_VAR 0 9
53121: PUSH
53122: LD_INT 1
53124: NEG
53125: ST_TO_ADDR
// if i_from > i_to then
53126: LD_VAR 0 2
53130: PUSH
53131: LD_VAR 0 3
53135: GREATER
53136: IFFALSE 53156
// length := i_from - i_to else
53138: LD_ADDR_VAR 0 11
53142: PUSH
53143: LD_VAR 0 2
53147: PUSH
53148: LD_VAR 0 3
53152: MINUS
53153: ST_TO_ADDR
53154: GO 53178
// length := ( array - i_to ) + i_from ;
53156: LD_ADDR_VAR 0 11
53160: PUSH
53161: LD_VAR 0 1
53165: PUSH
53166: LD_VAR 0 3
53170: MINUS
53171: PUSH
53172: LD_VAR 0 2
53176: PLUS
53177: ST_TO_ADDR
// end ; if not length then
53178: LD_VAR 0 11
53182: NOT
53183: IFFALSE 53187
// exit ;
53185: GO 53345
// tmp := array ;
53187: LD_ADDR_VAR 0 10
53191: PUSH
53192: LD_VAR 0 1
53196: ST_TO_ADDR
// for i = 1 to length do
53197: LD_ADDR_VAR 0 6
53201: PUSH
53202: DOUBLE
53203: LD_INT 1
53205: DEC
53206: ST_TO_ADDR
53207: LD_VAR 0 11
53211: PUSH
53212: FOR_TO
53213: IFFALSE 53333
// begin for j = 1 to array do
53215: LD_ADDR_VAR 0 7
53219: PUSH
53220: DOUBLE
53221: LD_INT 1
53223: DEC
53224: ST_TO_ADDR
53225: LD_VAR 0 1
53229: PUSH
53230: FOR_TO
53231: IFFALSE 53319
// begin k := j + d ;
53233: LD_ADDR_VAR 0 8
53237: PUSH
53238: LD_VAR 0 7
53242: PUSH
53243: LD_VAR 0 9
53247: PLUS
53248: ST_TO_ADDR
// if k > array then
53249: LD_VAR 0 8
53253: PUSH
53254: LD_VAR 0 1
53258: GREATER
53259: IFFALSE 53269
// k := 1 ;
53261: LD_ADDR_VAR 0 8
53265: PUSH
53266: LD_INT 1
53268: ST_TO_ADDR
// if not k then
53269: LD_VAR 0 8
53273: NOT
53274: IFFALSE 53286
// k := array ;
53276: LD_ADDR_VAR 0 8
53280: PUSH
53281: LD_VAR 0 1
53285: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53286: LD_ADDR_VAR 0 10
53290: PUSH
53291: LD_VAR 0 10
53295: PPUSH
53296: LD_VAR 0 8
53300: PPUSH
53301: LD_VAR 0 1
53305: PUSH
53306: LD_VAR 0 7
53310: ARRAY
53311: PPUSH
53312: CALL_OW 1
53316: ST_TO_ADDR
// end ;
53317: GO 53230
53319: POP
53320: POP
// array := tmp ;
53321: LD_ADDR_VAR 0 1
53325: PUSH
53326: LD_VAR 0 10
53330: ST_TO_ADDR
// end ;
53331: GO 53212
53333: POP
53334: POP
// result := array ;
53335: LD_ADDR_VAR 0 5
53339: PUSH
53340: LD_VAR 0 1
53344: ST_TO_ADDR
// end ;
53345: LD_VAR 0 5
53349: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53350: LD_INT 0
53352: PPUSH
53353: PPUSH
// result := 0 ;
53354: LD_ADDR_VAR 0 3
53358: PUSH
53359: LD_INT 0
53361: ST_TO_ADDR
// if not array or not value in array then
53362: LD_VAR 0 1
53366: NOT
53367: PUSH
53368: LD_VAR 0 2
53372: PUSH
53373: LD_VAR 0 1
53377: IN
53378: NOT
53379: OR
53380: IFFALSE 53384
// exit ;
53382: GO 53438
// for i = 1 to array do
53384: LD_ADDR_VAR 0 4
53388: PUSH
53389: DOUBLE
53390: LD_INT 1
53392: DEC
53393: ST_TO_ADDR
53394: LD_VAR 0 1
53398: PUSH
53399: FOR_TO
53400: IFFALSE 53436
// if value = array [ i ] then
53402: LD_VAR 0 2
53406: PUSH
53407: LD_VAR 0 1
53411: PUSH
53412: LD_VAR 0 4
53416: ARRAY
53417: EQUAL
53418: IFFALSE 53434
// begin result := i ;
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_VAR 0 4
53429: ST_TO_ADDR
// exit ;
53430: POP
53431: POP
53432: GO 53438
// end ;
53434: GO 53399
53436: POP
53437: POP
// end ;
53438: LD_VAR 0 3
53442: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53443: LD_INT 0
53445: PPUSH
// vc_chassis := chassis ;
53446: LD_ADDR_OWVAR 37
53450: PUSH
53451: LD_VAR 0 1
53455: ST_TO_ADDR
// vc_engine := engine ;
53456: LD_ADDR_OWVAR 39
53460: PUSH
53461: LD_VAR 0 2
53465: ST_TO_ADDR
// vc_control := control ;
53466: LD_ADDR_OWVAR 38
53470: PUSH
53471: LD_VAR 0 3
53475: ST_TO_ADDR
// vc_weapon := weapon ;
53476: LD_ADDR_OWVAR 40
53480: PUSH
53481: LD_VAR 0 4
53485: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53486: LD_ADDR_OWVAR 41
53490: PUSH
53491: LD_VAR 0 5
53495: ST_TO_ADDR
// end ;
53496: LD_VAR 0 6
53500: RET
// export function WantPlant ( unit ) ; var task ; begin
53501: LD_INT 0
53503: PPUSH
53504: PPUSH
// result := false ;
53505: LD_ADDR_VAR 0 2
53509: PUSH
53510: LD_INT 0
53512: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53513: LD_ADDR_VAR 0 3
53517: PUSH
53518: LD_VAR 0 1
53522: PPUSH
53523: CALL_OW 437
53527: ST_TO_ADDR
// if task then
53528: LD_VAR 0 3
53532: IFFALSE 53560
// if task [ 1 ] [ 1 ] = p then
53534: LD_VAR 0 3
53538: PUSH
53539: LD_INT 1
53541: ARRAY
53542: PUSH
53543: LD_INT 1
53545: ARRAY
53546: PUSH
53547: LD_STRING p
53549: EQUAL
53550: IFFALSE 53560
// result := true ;
53552: LD_ADDR_VAR 0 2
53556: PUSH
53557: LD_INT 1
53559: ST_TO_ADDR
// end ;
53560: LD_VAR 0 2
53564: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53565: LD_INT 0
53567: PPUSH
53568: PPUSH
53569: PPUSH
53570: PPUSH
// if pos < 1 then
53571: LD_VAR 0 2
53575: PUSH
53576: LD_INT 1
53578: LESS
53579: IFFALSE 53583
// exit ;
53581: GO 53886
// if pos = 1 then
53583: LD_VAR 0 2
53587: PUSH
53588: LD_INT 1
53590: EQUAL
53591: IFFALSE 53624
// result := Replace ( arr , pos [ 1 ] , value ) else
53593: LD_ADDR_VAR 0 4
53597: PUSH
53598: LD_VAR 0 1
53602: PPUSH
53603: LD_VAR 0 2
53607: PUSH
53608: LD_INT 1
53610: ARRAY
53611: PPUSH
53612: LD_VAR 0 3
53616: PPUSH
53617: CALL_OW 1
53621: ST_TO_ADDR
53622: GO 53886
// begin tmp := arr ;
53624: LD_ADDR_VAR 0 6
53628: PUSH
53629: LD_VAR 0 1
53633: ST_TO_ADDR
// s_arr := [ tmp ] ;
53634: LD_ADDR_VAR 0 7
53638: PUSH
53639: LD_VAR 0 6
53643: PUSH
53644: EMPTY
53645: LIST
53646: ST_TO_ADDR
// for i = 1 to pos - 1 do
53647: LD_ADDR_VAR 0 5
53651: PUSH
53652: DOUBLE
53653: LD_INT 1
53655: DEC
53656: ST_TO_ADDR
53657: LD_VAR 0 2
53661: PUSH
53662: LD_INT 1
53664: MINUS
53665: PUSH
53666: FOR_TO
53667: IFFALSE 53712
// begin tmp := tmp [ pos [ i ] ] ;
53669: LD_ADDR_VAR 0 6
53673: PUSH
53674: LD_VAR 0 6
53678: PUSH
53679: LD_VAR 0 2
53683: PUSH
53684: LD_VAR 0 5
53688: ARRAY
53689: ARRAY
53690: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53691: LD_ADDR_VAR 0 7
53695: PUSH
53696: LD_VAR 0 7
53700: PUSH
53701: LD_VAR 0 6
53705: PUSH
53706: EMPTY
53707: LIST
53708: ADD
53709: ST_TO_ADDR
// end ;
53710: GO 53666
53712: POP
53713: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53714: LD_ADDR_VAR 0 6
53718: PUSH
53719: LD_VAR 0 6
53723: PPUSH
53724: LD_VAR 0 2
53728: PUSH
53729: LD_VAR 0 2
53733: ARRAY
53734: PPUSH
53735: LD_VAR 0 3
53739: PPUSH
53740: CALL_OW 1
53744: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53745: LD_ADDR_VAR 0 7
53749: PUSH
53750: LD_VAR 0 7
53754: PPUSH
53755: LD_VAR 0 7
53759: PPUSH
53760: LD_VAR 0 6
53764: PPUSH
53765: CALL_OW 1
53769: ST_TO_ADDR
// for i = s_arr downto 2 do
53770: LD_ADDR_VAR 0 5
53774: PUSH
53775: DOUBLE
53776: LD_VAR 0 7
53780: INC
53781: ST_TO_ADDR
53782: LD_INT 2
53784: PUSH
53785: FOR_DOWNTO
53786: IFFALSE 53870
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53788: LD_ADDR_VAR 0 6
53792: PUSH
53793: LD_VAR 0 7
53797: PUSH
53798: LD_VAR 0 5
53802: PUSH
53803: LD_INT 1
53805: MINUS
53806: ARRAY
53807: PPUSH
53808: LD_VAR 0 2
53812: PUSH
53813: LD_VAR 0 5
53817: PUSH
53818: LD_INT 1
53820: MINUS
53821: ARRAY
53822: PPUSH
53823: LD_VAR 0 7
53827: PUSH
53828: LD_VAR 0 5
53832: ARRAY
53833: PPUSH
53834: CALL_OW 1
53838: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53839: LD_ADDR_VAR 0 7
53843: PUSH
53844: LD_VAR 0 7
53848: PPUSH
53849: LD_VAR 0 5
53853: PUSH
53854: LD_INT 1
53856: MINUS
53857: PPUSH
53858: LD_VAR 0 6
53862: PPUSH
53863: CALL_OW 1
53867: ST_TO_ADDR
// end ;
53868: GO 53785
53870: POP
53871: POP
// result := s_arr [ 1 ] ;
53872: LD_ADDR_VAR 0 4
53876: PUSH
53877: LD_VAR 0 7
53881: PUSH
53882: LD_INT 1
53884: ARRAY
53885: ST_TO_ADDR
// end ; end ;
53886: LD_VAR 0 4
53890: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53891: LD_INT 0
53893: PPUSH
53894: PPUSH
// if not list then
53895: LD_VAR 0 1
53899: NOT
53900: IFFALSE 53904
// exit ;
53902: GO 53995
// i := list [ pos1 ] ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 2
53918: ARRAY
53919: ST_TO_ADDR
// if not i then
53920: LD_VAR 0 5
53924: NOT
53925: IFFALSE 53929
// exit ;
53927: GO 53995
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53929: LD_ADDR_VAR 0 1
53933: PUSH
53934: LD_VAR 0 1
53938: PPUSH
53939: LD_VAR 0 2
53943: PPUSH
53944: LD_VAR 0 1
53948: PUSH
53949: LD_VAR 0 3
53953: ARRAY
53954: PPUSH
53955: CALL_OW 1
53959: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53960: LD_ADDR_VAR 0 1
53964: PUSH
53965: LD_VAR 0 1
53969: PPUSH
53970: LD_VAR 0 3
53974: PPUSH
53975: LD_VAR 0 5
53979: PPUSH
53980: CALL_OW 1
53984: ST_TO_ADDR
// result := list ;
53985: LD_ADDR_VAR 0 4
53989: PUSH
53990: LD_VAR 0 1
53994: ST_TO_ADDR
// end ;
53995: LD_VAR 0 4
53999: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54000: LD_INT 0
54002: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54003: LD_ADDR_VAR 0 5
54007: PUSH
54008: LD_VAR 0 1
54012: PPUSH
54013: CALL_OW 250
54017: PPUSH
54018: LD_VAR 0 1
54022: PPUSH
54023: CALL_OW 251
54027: PPUSH
54028: LD_VAR 0 2
54032: PPUSH
54033: LD_VAR 0 3
54037: PPUSH
54038: LD_VAR 0 4
54042: PPUSH
54043: CALL 54053 0 5
54047: ST_TO_ADDR
// end ;
54048: LD_VAR 0 5
54052: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54053: LD_INT 0
54055: PPUSH
54056: PPUSH
54057: PPUSH
54058: PPUSH
// if not list then
54059: LD_VAR 0 3
54063: NOT
54064: IFFALSE 54068
// exit ;
54066: GO 54456
// result := [ ] ;
54068: LD_ADDR_VAR 0 6
54072: PUSH
54073: EMPTY
54074: ST_TO_ADDR
// for i in list do
54075: LD_ADDR_VAR 0 7
54079: PUSH
54080: LD_VAR 0 3
54084: PUSH
54085: FOR_IN
54086: IFFALSE 54288
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54088: LD_ADDR_VAR 0 9
54092: PUSH
54093: LD_VAR 0 7
54097: PPUSH
54098: LD_VAR 0 1
54102: PPUSH
54103: LD_VAR 0 2
54107: PPUSH
54108: CALL_OW 297
54112: ST_TO_ADDR
// if not result then
54113: LD_VAR 0 6
54117: NOT
54118: IFFALSE 54144
// result := [ [ i , tmp ] ] else
54120: LD_ADDR_VAR 0 6
54124: PUSH
54125: LD_VAR 0 7
54129: PUSH
54130: LD_VAR 0 9
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: PUSH
54139: EMPTY
54140: LIST
54141: ST_TO_ADDR
54142: GO 54286
// begin if result [ result ] [ 2 ] < tmp then
54144: LD_VAR 0 6
54148: PUSH
54149: LD_VAR 0 6
54153: ARRAY
54154: PUSH
54155: LD_INT 2
54157: ARRAY
54158: PUSH
54159: LD_VAR 0 9
54163: LESS
54164: IFFALSE 54206
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54166: LD_ADDR_VAR 0 6
54170: PUSH
54171: LD_VAR 0 6
54175: PPUSH
54176: LD_VAR 0 6
54180: PUSH
54181: LD_INT 1
54183: PLUS
54184: PPUSH
54185: LD_VAR 0 7
54189: PUSH
54190: LD_VAR 0 9
54194: PUSH
54195: EMPTY
54196: LIST
54197: LIST
54198: PPUSH
54199: CALL_OW 2
54203: ST_TO_ADDR
54204: GO 54286
// for j = 1 to result do
54206: LD_ADDR_VAR 0 8
54210: PUSH
54211: DOUBLE
54212: LD_INT 1
54214: DEC
54215: ST_TO_ADDR
54216: LD_VAR 0 6
54220: PUSH
54221: FOR_TO
54222: IFFALSE 54284
// begin if tmp < result [ j ] [ 2 ] then
54224: LD_VAR 0 9
54228: PUSH
54229: LD_VAR 0 6
54233: PUSH
54234: LD_VAR 0 8
54238: ARRAY
54239: PUSH
54240: LD_INT 2
54242: ARRAY
54243: LESS
54244: IFFALSE 54282
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54246: LD_ADDR_VAR 0 6
54250: PUSH
54251: LD_VAR 0 6
54255: PPUSH
54256: LD_VAR 0 8
54260: PPUSH
54261: LD_VAR 0 7
54265: PUSH
54266: LD_VAR 0 9
54270: PUSH
54271: EMPTY
54272: LIST
54273: LIST
54274: PPUSH
54275: CALL_OW 2
54279: ST_TO_ADDR
// break ;
54280: GO 54284
// end ; end ;
54282: GO 54221
54284: POP
54285: POP
// end ; end ;
54286: GO 54085
54288: POP
54289: POP
// if result and not asc then
54290: LD_VAR 0 6
54294: PUSH
54295: LD_VAR 0 4
54299: NOT
54300: AND
54301: IFFALSE 54376
// begin tmp := result ;
54303: LD_ADDR_VAR 0 9
54307: PUSH
54308: LD_VAR 0 6
54312: ST_TO_ADDR
// for i = tmp downto 1 do
54313: LD_ADDR_VAR 0 7
54317: PUSH
54318: DOUBLE
54319: LD_VAR 0 9
54323: INC
54324: ST_TO_ADDR
54325: LD_INT 1
54327: PUSH
54328: FOR_DOWNTO
54329: IFFALSE 54374
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54331: LD_ADDR_VAR 0 6
54335: PUSH
54336: LD_VAR 0 6
54340: PPUSH
54341: LD_VAR 0 9
54345: PUSH
54346: LD_VAR 0 7
54350: MINUS
54351: PUSH
54352: LD_INT 1
54354: PLUS
54355: PPUSH
54356: LD_VAR 0 9
54360: PUSH
54361: LD_VAR 0 7
54365: ARRAY
54366: PPUSH
54367: CALL_OW 1
54371: ST_TO_ADDR
54372: GO 54328
54374: POP
54375: POP
// end ; tmp := [ ] ;
54376: LD_ADDR_VAR 0 9
54380: PUSH
54381: EMPTY
54382: ST_TO_ADDR
// if mode then
54383: LD_VAR 0 5
54387: IFFALSE 54456
// begin for i = 1 to result do
54389: LD_ADDR_VAR 0 7
54393: PUSH
54394: DOUBLE
54395: LD_INT 1
54397: DEC
54398: ST_TO_ADDR
54399: LD_VAR 0 6
54403: PUSH
54404: FOR_TO
54405: IFFALSE 54444
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54407: LD_ADDR_VAR 0 9
54411: PUSH
54412: LD_VAR 0 9
54416: PPUSH
54417: LD_VAR 0 7
54421: PPUSH
54422: LD_VAR 0 6
54426: PUSH
54427: LD_VAR 0 7
54431: ARRAY
54432: PUSH
54433: LD_INT 1
54435: ARRAY
54436: PPUSH
54437: CALL_OW 1
54441: ST_TO_ADDR
54442: GO 54404
54444: POP
54445: POP
// result := tmp ;
54446: LD_ADDR_VAR 0 6
54450: PUSH
54451: LD_VAR 0 9
54455: ST_TO_ADDR
// end ; end ;
54456: LD_VAR 0 6
54460: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54461: LD_INT 0
54463: PPUSH
54464: PPUSH
54465: PPUSH
54466: PPUSH
54467: PPUSH
54468: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54469: LD_ADDR_VAR 0 5
54473: PUSH
54474: LD_INT 0
54476: PUSH
54477: LD_INT 0
54479: PUSH
54480: LD_INT 0
54482: PUSH
54483: EMPTY
54484: PUSH
54485: EMPTY
54486: LIST
54487: LIST
54488: LIST
54489: LIST
54490: ST_TO_ADDR
// if not x or not y then
54491: LD_VAR 0 2
54495: NOT
54496: PUSH
54497: LD_VAR 0 3
54501: NOT
54502: OR
54503: IFFALSE 54507
// exit ;
54505: GO 56159
// if not range then
54507: LD_VAR 0 4
54511: NOT
54512: IFFALSE 54522
// range := 10 ;
54514: LD_ADDR_VAR 0 4
54518: PUSH
54519: LD_INT 10
54521: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54522: LD_ADDR_VAR 0 8
54526: PUSH
54527: LD_INT 81
54529: PUSH
54530: LD_VAR 0 1
54534: PUSH
54535: EMPTY
54536: LIST
54537: LIST
54538: PUSH
54539: LD_INT 92
54541: PUSH
54542: LD_VAR 0 2
54546: PUSH
54547: LD_VAR 0 3
54551: PUSH
54552: LD_VAR 0 4
54556: PUSH
54557: EMPTY
54558: LIST
54559: LIST
54560: LIST
54561: LIST
54562: PUSH
54563: LD_INT 3
54565: PUSH
54566: LD_INT 21
54568: PUSH
54569: LD_INT 3
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: PUSH
54580: EMPTY
54581: LIST
54582: LIST
54583: LIST
54584: PPUSH
54585: CALL_OW 69
54589: ST_TO_ADDR
// if not tmp then
54590: LD_VAR 0 8
54594: NOT
54595: IFFALSE 54599
// exit ;
54597: GO 56159
// for i in tmp do
54599: LD_ADDR_VAR 0 6
54603: PUSH
54604: LD_VAR 0 8
54608: PUSH
54609: FOR_IN
54610: IFFALSE 56134
// begin points := [ 0 , 0 , 0 ] ;
54612: LD_ADDR_VAR 0 9
54616: PUSH
54617: LD_INT 0
54619: PUSH
54620: LD_INT 0
54622: PUSH
54623: LD_INT 0
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: LIST
54630: ST_TO_ADDR
// bpoints := 1 ;
54631: LD_ADDR_VAR 0 10
54635: PUSH
54636: LD_INT 1
54638: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54639: LD_VAR 0 6
54643: PPUSH
54644: CALL_OW 247
54648: PUSH
54649: LD_INT 1
54651: DOUBLE
54652: EQUAL
54653: IFTRUE 54657
54655: GO 55235
54657: POP
// begin if GetClass ( i ) = 1 then
54658: LD_VAR 0 6
54662: PPUSH
54663: CALL_OW 257
54667: PUSH
54668: LD_INT 1
54670: EQUAL
54671: IFFALSE 54692
// points := [ 10 , 5 , 3 ] ;
54673: LD_ADDR_VAR 0 9
54677: PUSH
54678: LD_INT 10
54680: PUSH
54681: LD_INT 5
54683: PUSH
54684: LD_INT 3
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: LIST
54691: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54692: LD_VAR 0 6
54696: PPUSH
54697: CALL_OW 257
54701: PUSH
54702: LD_INT 2
54704: PUSH
54705: LD_INT 3
54707: PUSH
54708: LD_INT 4
54710: PUSH
54711: EMPTY
54712: LIST
54713: LIST
54714: LIST
54715: IN
54716: IFFALSE 54737
// points := [ 3 , 2 , 1 ] ;
54718: LD_ADDR_VAR 0 9
54722: PUSH
54723: LD_INT 3
54725: PUSH
54726: LD_INT 2
54728: PUSH
54729: LD_INT 1
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: LIST
54736: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54737: LD_VAR 0 6
54741: PPUSH
54742: CALL_OW 257
54746: PUSH
54747: LD_INT 5
54749: EQUAL
54750: IFFALSE 54771
// points := [ 130 , 5 , 2 ] ;
54752: LD_ADDR_VAR 0 9
54756: PUSH
54757: LD_INT 130
54759: PUSH
54760: LD_INT 5
54762: PUSH
54763: LD_INT 2
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: LIST
54770: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54771: LD_VAR 0 6
54775: PPUSH
54776: CALL_OW 257
54780: PUSH
54781: LD_INT 8
54783: EQUAL
54784: IFFALSE 54805
// points := [ 35 , 35 , 30 ] ;
54786: LD_ADDR_VAR 0 9
54790: PUSH
54791: LD_INT 35
54793: PUSH
54794: LD_INT 35
54796: PUSH
54797: LD_INT 30
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: LIST
54804: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54805: LD_VAR 0 6
54809: PPUSH
54810: CALL_OW 257
54814: PUSH
54815: LD_INT 9
54817: EQUAL
54818: IFFALSE 54839
// points := [ 20 , 55 , 40 ] ;
54820: LD_ADDR_VAR 0 9
54824: PUSH
54825: LD_INT 20
54827: PUSH
54828: LD_INT 55
54830: PUSH
54831: LD_INT 40
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: LIST
54838: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54839: LD_VAR 0 6
54843: PPUSH
54844: CALL_OW 257
54848: PUSH
54849: LD_INT 12
54851: PUSH
54852: LD_INT 16
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: IN
54859: IFFALSE 54880
// points := [ 5 , 3 , 2 ] ;
54861: LD_ADDR_VAR 0 9
54865: PUSH
54866: LD_INT 5
54868: PUSH
54869: LD_INT 3
54871: PUSH
54872: LD_INT 2
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: LIST
54879: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54880: LD_VAR 0 6
54884: PPUSH
54885: CALL_OW 257
54889: PUSH
54890: LD_INT 17
54892: EQUAL
54893: IFFALSE 54914
// points := [ 100 , 50 , 75 ] ;
54895: LD_ADDR_VAR 0 9
54899: PUSH
54900: LD_INT 100
54902: PUSH
54903: LD_INT 50
54905: PUSH
54906: LD_INT 75
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: LIST
54913: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54914: LD_VAR 0 6
54918: PPUSH
54919: CALL_OW 257
54923: PUSH
54924: LD_INT 15
54926: EQUAL
54927: IFFALSE 54948
// points := [ 10 , 5 , 3 ] ;
54929: LD_ADDR_VAR 0 9
54933: PUSH
54934: LD_INT 10
54936: PUSH
54937: LD_INT 5
54939: PUSH
54940: LD_INT 3
54942: PUSH
54943: EMPTY
54944: LIST
54945: LIST
54946: LIST
54947: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54948: LD_VAR 0 6
54952: PPUSH
54953: CALL_OW 257
54957: PUSH
54958: LD_INT 14
54960: EQUAL
54961: IFFALSE 54982
// points := [ 10 , 0 , 0 ] ;
54963: LD_ADDR_VAR 0 9
54967: PUSH
54968: LD_INT 10
54970: PUSH
54971: LD_INT 0
54973: PUSH
54974: LD_INT 0
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: LIST
54981: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54982: LD_VAR 0 6
54986: PPUSH
54987: CALL_OW 257
54991: PUSH
54992: LD_INT 11
54994: EQUAL
54995: IFFALSE 55016
// points := [ 30 , 10 , 5 ] ;
54997: LD_ADDR_VAR 0 9
55001: PUSH
55002: LD_INT 30
55004: PUSH
55005: LD_INT 10
55007: PUSH
55008: LD_INT 5
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: LIST
55015: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55016: LD_VAR 0 1
55020: PPUSH
55021: LD_INT 5
55023: PPUSH
55024: CALL_OW 321
55028: PUSH
55029: LD_INT 2
55031: EQUAL
55032: IFFALSE 55049
// bpoints := bpoints * 1.8 ;
55034: LD_ADDR_VAR 0 10
55038: PUSH
55039: LD_VAR 0 10
55043: PUSH
55044: LD_REAL  1.80000000000000E+0000
55047: MUL
55048: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55049: LD_VAR 0 6
55053: PPUSH
55054: CALL_OW 257
55058: PUSH
55059: LD_INT 1
55061: PUSH
55062: LD_INT 2
55064: PUSH
55065: LD_INT 3
55067: PUSH
55068: LD_INT 4
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: LIST
55075: LIST
55076: IN
55077: PUSH
55078: LD_VAR 0 1
55082: PPUSH
55083: LD_INT 51
55085: PPUSH
55086: CALL_OW 321
55090: PUSH
55091: LD_INT 2
55093: EQUAL
55094: AND
55095: IFFALSE 55112
// bpoints := bpoints * 1.2 ;
55097: LD_ADDR_VAR 0 10
55101: PUSH
55102: LD_VAR 0 10
55106: PUSH
55107: LD_REAL  1.20000000000000E+0000
55110: MUL
55111: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55112: LD_VAR 0 6
55116: PPUSH
55117: CALL_OW 257
55121: PUSH
55122: LD_INT 5
55124: PUSH
55125: LD_INT 7
55127: PUSH
55128: LD_INT 9
55130: PUSH
55131: EMPTY
55132: LIST
55133: LIST
55134: LIST
55135: IN
55136: PUSH
55137: LD_VAR 0 1
55141: PPUSH
55142: LD_INT 52
55144: PPUSH
55145: CALL_OW 321
55149: PUSH
55150: LD_INT 2
55152: EQUAL
55153: AND
55154: IFFALSE 55171
// bpoints := bpoints * 1.5 ;
55156: LD_ADDR_VAR 0 10
55160: PUSH
55161: LD_VAR 0 10
55165: PUSH
55166: LD_REAL  1.50000000000000E+0000
55169: MUL
55170: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55171: LD_VAR 0 1
55175: PPUSH
55176: LD_INT 66
55178: PPUSH
55179: CALL_OW 321
55183: PUSH
55184: LD_INT 2
55186: EQUAL
55187: IFFALSE 55204
// bpoints := bpoints * 1.1 ;
55189: LD_ADDR_VAR 0 10
55193: PUSH
55194: LD_VAR 0 10
55198: PUSH
55199: LD_REAL  1.10000000000000E+0000
55202: MUL
55203: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55204: LD_ADDR_VAR 0 10
55208: PUSH
55209: LD_VAR 0 10
55213: PUSH
55214: LD_VAR 0 6
55218: PPUSH
55219: LD_INT 1
55221: PPUSH
55222: CALL_OW 259
55226: PUSH
55227: LD_REAL  1.15000000000000E+0000
55230: MUL
55231: MUL
55232: ST_TO_ADDR
// end ; unit_vehicle :
55233: GO 56063
55235: LD_INT 2
55237: DOUBLE
55238: EQUAL
55239: IFTRUE 55243
55241: GO 56051
55243: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55244: LD_VAR 0 6
55248: PPUSH
55249: CALL_OW 264
55253: PUSH
55254: LD_INT 2
55256: PUSH
55257: LD_INT 42
55259: PUSH
55260: LD_INT 24
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: LIST
55267: IN
55268: IFFALSE 55289
// points := [ 25 , 5 , 3 ] ;
55270: LD_ADDR_VAR 0 9
55274: PUSH
55275: LD_INT 25
55277: PUSH
55278: LD_INT 5
55280: PUSH
55281: LD_INT 3
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: LIST
55288: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55289: LD_VAR 0 6
55293: PPUSH
55294: CALL_OW 264
55298: PUSH
55299: LD_INT 4
55301: PUSH
55302: LD_INT 43
55304: PUSH
55305: LD_INT 25
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: LIST
55312: IN
55313: IFFALSE 55334
// points := [ 40 , 15 , 5 ] ;
55315: LD_ADDR_VAR 0 9
55319: PUSH
55320: LD_INT 40
55322: PUSH
55323: LD_INT 15
55325: PUSH
55326: LD_INT 5
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: LIST
55333: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55334: LD_VAR 0 6
55338: PPUSH
55339: CALL_OW 264
55343: PUSH
55344: LD_INT 3
55346: PUSH
55347: LD_INT 23
55349: PUSH
55350: EMPTY
55351: LIST
55352: LIST
55353: IN
55354: IFFALSE 55375
// points := [ 7 , 25 , 8 ] ;
55356: LD_ADDR_VAR 0 9
55360: PUSH
55361: LD_INT 7
55363: PUSH
55364: LD_INT 25
55366: PUSH
55367: LD_INT 8
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: LIST
55374: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55375: LD_VAR 0 6
55379: PPUSH
55380: CALL_OW 264
55384: PUSH
55385: LD_INT 5
55387: PUSH
55388: LD_INT 27
55390: PUSH
55391: LD_INT 44
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: LIST
55398: IN
55399: IFFALSE 55420
// points := [ 14 , 50 , 16 ] ;
55401: LD_ADDR_VAR 0 9
55405: PUSH
55406: LD_INT 14
55408: PUSH
55409: LD_INT 50
55411: PUSH
55412: LD_INT 16
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: LIST
55419: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55420: LD_VAR 0 6
55424: PPUSH
55425: CALL_OW 264
55429: PUSH
55430: LD_INT 6
55432: PUSH
55433: LD_INT 46
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: IN
55440: IFFALSE 55461
// points := [ 32 , 120 , 70 ] ;
55442: LD_ADDR_VAR 0 9
55446: PUSH
55447: LD_INT 32
55449: PUSH
55450: LD_INT 120
55452: PUSH
55453: LD_INT 70
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: LIST
55460: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55461: LD_VAR 0 6
55465: PPUSH
55466: CALL_OW 264
55470: PUSH
55471: LD_INT 7
55473: PUSH
55474: LD_INT 28
55476: PUSH
55477: LD_INT 45
55479: PUSH
55480: LD_EXP 99
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: LIST
55489: LIST
55490: IN
55491: IFFALSE 55512
// points := [ 35 , 20 , 45 ] ;
55493: LD_ADDR_VAR 0 9
55497: PUSH
55498: LD_INT 35
55500: PUSH
55501: LD_INT 20
55503: PUSH
55504: LD_INT 45
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55512: LD_VAR 0 6
55516: PPUSH
55517: CALL_OW 264
55521: PUSH
55522: LD_INT 47
55524: PUSH
55525: EMPTY
55526: LIST
55527: IN
55528: IFFALSE 55549
// points := [ 67 , 45 , 75 ] ;
55530: LD_ADDR_VAR 0 9
55534: PUSH
55535: LD_INT 67
55537: PUSH
55538: LD_INT 45
55540: PUSH
55541: LD_INT 75
55543: PUSH
55544: EMPTY
55545: LIST
55546: LIST
55547: LIST
55548: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55549: LD_VAR 0 6
55553: PPUSH
55554: CALL_OW 264
55558: PUSH
55559: LD_INT 26
55561: PUSH
55562: EMPTY
55563: LIST
55564: IN
55565: IFFALSE 55586
// points := [ 120 , 30 , 80 ] ;
55567: LD_ADDR_VAR 0 9
55571: PUSH
55572: LD_INT 120
55574: PUSH
55575: LD_INT 30
55577: PUSH
55578: LD_INT 80
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: LIST
55585: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55586: LD_VAR 0 6
55590: PPUSH
55591: CALL_OW 264
55595: PUSH
55596: LD_INT 22
55598: PUSH
55599: EMPTY
55600: LIST
55601: IN
55602: IFFALSE 55623
// points := [ 40 , 1 , 1 ] ;
55604: LD_ADDR_VAR 0 9
55608: PUSH
55609: LD_INT 40
55611: PUSH
55612: LD_INT 1
55614: PUSH
55615: LD_INT 1
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: LIST
55622: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55623: LD_VAR 0 6
55627: PPUSH
55628: CALL_OW 264
55632: PUSH
55633: LD_INT 29
55635: PUSH
55636: EMPTY
55637: LIST
55638: IN
55639: IFFALSE 55660
// points := [ 70 , 200 , 400 ] ;
55641: LD_ADDR_VAR 0 9
55645: PUSH
55646: LD_INT 70
55648: PUSH
55649: LD_INT 200
55651: PUSH
55652: LD_INT 400
55654: PUSH
55655: EMPTY
55656: LIST
55657: LIST
55658: LIST
55659: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55660: LD_VAR 0 6
55664: PPUSH
55665: CALL_OW 264
55669: PUSH
55670: LD_INT 14
55672: PUSH
55673: LD_INT 53
55675: PUSH
55676: EMPTY
55677: LIST
55678: LIST
55679: IN
55680: IFFALSE 55701
// points := [ 40 , 10 , 20 ] ;
55682: LD_ADDR_VAR 0 9
55686: PUSH
55687: LD_INT 40
55689: PUSH
55690: LD_INT 10
55692: PUSH
55693: LD_INT 20
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: LIST
55700: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55701: LD_VAR 0 6
55705: PPUSH
55706: CALL_OW 264
55710: PUSH
55711: LD_INT 9
55713: PUSH
55714: EMPTY
55715: LIST
55716: IN
55717: IFFALSE 55738
// points := [ 5 , 70 , 20 ] ;
55719: LD_ADDR_VAR 0 9
55723: PUSH
55724: LD_INT 5
55726: PUSH
55727: LD_INT 70
55729: PUSH
55730: LD_INT 20
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: LIST
55737: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55738: LD_VAR 0 6
55742: PPUSH
55743: CALL_OW 264
55747: PUSH
55748: LD_INT 10
55750: PUSH
55751: EMPTY
55752: LIST
55753: IN
55754: IFFALSE 55775
// points := [ 35 , 110 , 70 ] ;
55756: LD_ADDR_VAR 0 9
55760: PUSH
55761: LD_INT 35
55763: PUSH
55764: LD_INT 110
55766: PUSH
55767: LD_INT 70
55769: PUSH
55770: EMPTY
55771: LIST
55772: LIST
55773: LIST
55774: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55775: LD_VAR 0 6
55779: PPUSH
55780: CALL_OW 265
55784: PUSH
55785: LD_INT 25
55787: EQUAL
55788: IFFALSE 55809
// points := [ 80 , 65 , 100 ] ;
55790: LD_ADDR_VAR 0 9
55794: PUSH
55795: LD_INT 80
55797: PUSH
55798: LD_INT 65
55800: PUSH
55801: LD_INT 100
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: LIST
55808: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55809: LD_VAR 0 6
55813: PPUSH
55814: CALL_OW 263
55818: PUSH
55819: LD_INT 1
55821: EQUAL
55822: IFFALSE 55857
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55824: LD_ADDR_VAR 0 10
55828: PUSH
55829: LD_VAR 0 10
55833: PUSH
55834: LD_VAR 0 6
55838: PPUSH
55839: CALL_OW 311
55843: PPUSH
55844: LD_INT 3
55846: PPUSH
55847: CALL_OW 259
55851: PUSH
55852: LD_INT 4
55854: MUL
55855: MUL
55856: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55857: LD_VAR 0 6
55861: PPUSH
55862: CALL_OW 263
55866: PUSH
55867: LD_INT 2
55869: EQUAL
55870: IFFALSE 55921
// begin j := IsControledBy ( i ) ;
55872: LD_ADDR_VAR 0 7
55876: PUSH
55877: LD_VAR 0 6
55881: PPUSH
55882: CALL_OW 312
55886: ST_TO_ADDR
// if j then
55887: LD_VAR 0 7
55891: IFFALSE 55921
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55893: LD_ADDR_VAR 0 10
55897: PUSH
55898: LD_VAR 0 10
55902: PUSH
55903: LD_VAR 0 7
55907: PPUSH
55908: LD_INT 3
55910: PPUSH
55911: CALL_OW 259
55915: PUSH
55916: LD_INT 3
55918: MUL
55919: MUL
55920: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55921: LD_VAR 0 6
55925: PPUSH
55926: CALL_OW 264
55930: PUSH
55931: LD_INT 5
55933: PUSH
55934: LD_INT 6
55936: PUSH
55937: LD_INT 46
55939: PUSH
55940: LD_INT 44
55942: PUSH
55943: LD_INT 47
55945: PUSH
55946: LD_INT 45
55948: PUSH
55949: LD_INT 28
55951: PUSH
55952: LD_INT 7
55954: PUSH
55955: LD_INT 27
55957: PUSH
55958: LD_INT 29
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: LIST
55965: LIST
55966: LIST
55967: LIST
55968: LIST
55969: LIST
55970: LIST
55971: LIST
55972: IN
55973: PUSH
55974: LD_VAR 0 1
55978: PPUSH
55979: LD_INT 52
55981: PPUSH
55982: CALL_OW 321
55986: PUSH
55987: LD_INT 2
55989: EQUAL
55990: AND
55991: IFFALSE 56008
// bpoints := bpoints * 1.2 ;
55993: LD_ADDR_VAR 0 10
55997: PUSH
55998: LD_VAR 0 10
56002: PUSH
56003: LD_REAL  1.20000000000000E+0000
56006: MUL
56007: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56008: LD_VAR 0 6
56012: PPUSH
56013: CALL_OW 264
56017: PUSH
56018: LD_INT 6
56020: PUSH
56021: LD_INT 46
56023: PUSH
56024: LD_INT 47
56026: PUSH
56027: EMPTY
56028: LIST
56029: LIST
56030: LIST
56031: IN
56032: IFFALSE 56049
// bpoints := bpoints * 1.2 ;
56034: LD_ADDR_VAR 0 10
56038: PUSH
56039: LD_VAR 0 10
56043: PUSH
56044: LD_REAL  1.20000000000000E+0000
56047: MUL
56048: ST_TO_ADDR
// end ; unit_building :
56049: GO 56063
56051: LD_INT 3
56053: DOUBLE
56054: EQUAL
56055: IFTRUE 56059
56057: GO 56062
56059: POP
// ; end ;
56060: GO 56063
56062: POP
// for j = 1 to 3 do
56063: LD_ADDR_VAR 0 7
56067: PUSH
56068: DOUBLE
56069: LD_INT 1
56071: DEC
56072: ST_TO_ADDR
56073: LD_INT 3
56075: PUSH
56076: FOR_TO
56077: IFFALSE 56130
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56079: LD_ADDR_VAR 0 5
56083: PUSH
56084: LD_VAR 0 5
56088: PPUSH
56089: LD_VAR 0 7
56093: PPUSH
56094: LD_VAR 0 5
56098: PUSH
56099: LD_VAR 0 7
56103: ARRAY
56104: PUSH
56105: LD_VAR 0 9
56109: PUSH
56110: LD_VAR 0 7
56114: ARRAY
56115: PUSH
56116: LD_VAR 0 10
56120: MUL
56121: PLUS
56122: PPUSH
56123: CALL_OW 1
56127: ST_TO_ADDR
56128: GO 56076
56130: POP
56131: POP
// end ;
56132: GO 54609
56134: POP
56135: POP
// result := Replace ( result , 4 , tmp ) ;
56136: LD_ADDR_VAR 0 5
56140: PUSH
56141: LD_VAR 0 5
56145: PPUSH
56146: LD_INT 4
56148: PPUSH
56149: LD_VAR 0 8
56153: PPUSH
56154: CALL_OW 1
56158: ST_TO_ADDR
// end ;
56159: LD_VAR 0 5
56163: RET
// export function DangerAtRange ( unit , range ) ; begin
56164: LD_INT 0
56166: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56167: LD_ADDR_VAR 0 3
56171: PUSH
56172: LD_VAR 0 1
56176: PPUSH
56177: CALL_OW 255
56181: PPUSH
56182: LD_VAR 0 1
56186: PPUSH
56187: CALL_OW 250
56191: PPUSH
56192: LD_VAR 0 1
56196: PPUSH
56197: CALL_OW 251
56201: PPUSH
56202: LD_VAR 0 2
56206: PPUSH
56207: CALL 54461 0 4
56211: ST_TO_ADDR
// end ;
56212: LD_VAR 0 3
56216: RET
// export function DangerInArea ( side , area ) ; begin
56217: LD_INT 0
56219: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56220: LD_ADDR_VAR 0 3
56224: PUSH
56225: LD_VAR 0 2
56229: PPUSH
56230: LD_INT 81
56232: PUSH
56233: LD_VAR 0 1
56237: PUSH
56238: EMPTY
56239: LIST
56240: LIST
56241: PPUSH
56242: CALL_OW 70
56246: ST_TO_ADDR
// end ;
56247: LD_VAR 0 3
56251: RET
// export function IsExtension ( b ) ; begin
56252: LD_INT 0
56254: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56255: LD_ADDR_VAR 0 2
56259: PUSH
56260: LD_VAR 0 1
56264: PUSH
56265: LD_INT 23
56267: PUSH
56268: LD_INT 20
56270: PUSH
56271: LD_INT 22
56273: PUSH
56274: LD_INT 17
56276: PUSH
56277: LD_INT 24
56279: PUSH
56280: LD_INT 21
56282: PUSH
56283: LD_INT 19
56285: PUSH
56286: LD_INT 16
56288: PUSH
56289: LD_INT 25
56291: PUSH
56292: LD_INT 18
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: LIST
56299: LIST
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: LIST
56305: LIST
56306: IN
56307: ST_TO_ADDR
// end ;
56308: LD_VAR 0 2
56312: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56313: LD_INT 0
56315: PPUSH
56316: PPUSH
56317: PPUSH
// result := [ ] ;
56318: LD_ADDR_VAR 0 4
56322: PUSH
56323: EMPTY
56324: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56325: LD_ADDR_VAR 0 5
56329: PUSH
56330: LD_VAR 0 2
56334: PPUSH
56335: LD_INT 21
56337: PUSH
56338: LD_INT 3
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: PPUSH
56345: CALL_OW 70
56349: ST_TO_ADDR
// if not tmp then
56350: LD_VAR 0 5
56354: NOT
56355: IFFALSE 56359
// exit ;
56357: GO 56423
// if checkLink then
56359: LD_VAR 0 3
56363: IFFALSE 56413
// begin for i in tmp do
56365: LD_ADDR_VAR 0 6
56369: PUSH
56370: LD_VAR 0 5
56374: PUSH
56375: FOR_IN
56376: IFFALSE 56411
// if GetBase ( i ) <> base then
56378: LD_VAR 0 6
56382: PPUSH
56383: CALL_OW 274
56387: PUSH
56388: LD_VAR 0 1
56392: NONEQUAL
56393: IFFALSE 56409
// ComLinkToBase ( base , i ) ;
56395: LD_VAR 0 1
56399: PPUSH
56400: LD_VAR 0 6
56404: PPUSH
56405: CALL_OW 169
56409: GO 56375
56411: POP
56412: POP
// end ; result := tmp ;
56413: LD_ADDR_VAR 0 4
56417: PUSH
56418: LD_VAR 0 5
56422: ST_TO_ADDR
// end ;
56423: LD_VAR 0 4
56427: RET
// export function ComComplete ( units , b ) ; var i ; begin
56428: LD_INT 0
56430: PPUSH
56431: PPUSH
// if not units then
56432: LD_VAR 0 1
56436: NOT
56437: IFFALSE 56441
// exit ;
56439: GO 56531
// for i in units do
56441: LD_ADDR_VAR 0 4
56445: PUSH
56446: LD_VAR 0 1
56450: PUSH
56451: FOR_IN
56452: IFFALSE 56529
// if BuildingStatus ( b ) = bs_build then
56454: LD_VAR 0 2
56458: PPUSH
56459: CALL_OW 461
56463: PUSH
56464: LD_INT 1
56466: EQUAL
56467: IFFALSE 56527
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56469: LD_VAR 0 4
56473: PPUSH
56474: LD_STRING h
56476: PUSH
56477: LD_VAR 0 2
56481: PPUSH
56482: CALL_OW 250
56486: PUSH
56487: LD_VAR 0 2
56491: PPUSH
56492: CALL_OW 251
56496: PUSH
56497: LD_VAR 0 2
56501: PUSH
56502: LD_INT 0
56504: PUSH
56505: LD_INT 0
56507: PUSH
56508: LD_INT 0
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: LIST
56515: LIST
56516: LIST
56517: LIST
56518: LIST
56519: PUSH
56520: EMPTY
56521: LIST
56522: PPUSH
56523: CALL_OW 446
56527: GO 56451
56529: POP
56530: POP
// end ;
56531: LD_VAR 0 3
56535: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56536: LD_INT 0
56538: PPUSH
56539: PPUSH
56540: PPUSH
56541: PPUSH
56542: PPUSH
56543: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56544: LD_VAR 0 1
56548: NOT
56549: PUSH
56550: LD_VAR 0 1
56554: PPUSH
56555: CALL_OW 263
56559: PUSH
56560: LD_INT 2
56562: NONEQUAL
56563: OR
56564: IFFALSE 56568
// exit ;
56566: GO 56884
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56568: LD_ADDR_VAR 0 6
56572: PUSH
56573: LD_INT 22
56575: PUSH
56576: LD_VAR 0 1
56580: PPUSH
56581: CALL_OW 255
56585: PUSH
56586: EMPTY
56587: LIST
56588: LIST
56589: PUSH
56590: LD_INT 2
56592: PUSH
56593: LD_INT 30
56595: PUSH
56596: LD_INT 36
56598: PUSH
56599: EMPTY
56600: LIST
56601: LIST
56602: PUSH
56603: LD_INT 34
56605: PUSH
56606: LD_INT 31
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: LIST
56617: PUSH
56618: EMPTY
56619: LIST
56620: LIST
56621: PPUSH
56622: CALL_OW 69
56626: ST_TO_ADDR
// if not tmp then
56627: LD_VAR 0 6
56631: NOT
56632: IFFALSE 56636
// exit ;
56634: GO 56884
// result := [ ] ;
56636: LD_ADDR_VAR 0 2
56640: PUSH
56641: EMPTY
56642: ST_TO_ADDR
// for i in tmp do
56643: LD_ADDR_VAR 0 3
56647: PUSH
56648: LD_VAR 0 6
56652: PUSH
56653: FOR_IN
56654: IFFALSE 56725
// begin t := UnitsInside ( i ) ;
56656: LD_ADDR_VAR 0 4
56660: PUSH
56661: LD_VAR 0 3
56665: PPUSH
56666: CALL_OW 313
56670: ST_TO_ADDR
// if t then
56671: LD_VAR 0 4
56675: IFFALSE 56723
// for j in t do
56677: LD_ADDR_VAR 0 7
56681: PUSH
56682: LD_VAR 0 4
56686: PUSH
56687: FOR_IN
56688: IFFALSE 56721
// result := Replace ( result , result + 1 , j ) ;
56690: LD_ADDR_VAR 0 2
56694: PUSH
56695: LD_VAR 0 2
56699: PPUSH
56700: LD_VAR 0 2
56704: PUSH
56705: LD_INT 1
56707: PLUS
56708: PPUSH
56709: LD_VAR 0 7
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
56719: GO 56687
56721: POP
56722: POP
// end ;
56723: GO 56653
56725: POP
56726: POP
// if not result then
56727: LD_VAR 0 2
56731: NOT
56732: IFFALSE 56736
// exit ;
56734: GO 56884
// mech := result [ 1 ] ;
56736: LD_ADDR_VAR 0 5
56740: PUSH
56741: LD_VAR 0 2
56745: PUSH
56746: LD_INT 1
56748: ARRAY
56749: ST_TO_ADDR
// if result > 1 then
56750: LD_VAR 0 2
56754: PUSH
56755: LD_INT 1
56757: GREATER
56758: IFFALSE 56870
// begin for i = 2 to result do
56760: LD_ADDR_VAR 0 3
56764: PUSH
56765: DOUBLE
56766: LD_INT 2
56768: DEC
56769: ST_TO_ADDR
56770: LD_VAR 0 2
56774: PUSH
56775: FOR_TO
56776: IFFALSE 56868
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56778: LD_ADDR_VAR 0 4
56782: PUSH
56783: LD_VAR 0 2
56787: PUSH
56788: LD_VAR 0 3
56792: ARRAY
56793: PPUSH
56794: LD_INT 3
56796: PPUSH
56797: CALL_OW 259
56801: PUSH
56802: LD_VAR 0 2
56806: PUSH
56807: LD_VAR 0 3
56811: ARRAY
56812: PPUSH
56813: CALL_OW 432
56817: MINUS
56818: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56819: LD_VAR 0 4
56823: PUSH
56824: LD_VAR 0 5
56828: PPUSH
56829: LD_INT 3
56831: PPUSH
56832: CALL_OW 259
56836: PUSH
56837: LD_VAR 0 5
56841: PPUSH
56842: CALL_OW 432
56846: MINUS
56847: GREATEREQUAL
56848: IFFALSE 56866
// mech := result [ i ] ;
56850: LD_ADDR_VAR 0 5
56854: PUSH
56855: LD_VAR 0 2
56859: PUSH
56860: LD_VAR 0 3
56864: ARRAY
56865: ST_TO_ADDR
// end ;
56866: GO 56775
56868: POP
56869: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56870: LD_VAR 0 1
56874: PPUSH
56875: LD_VAR 0 5
56879: PPUSH
56880: CALL_OW 135
// end ;
56884: LD_VAR 0 2
56888: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56889: LD_INT 0
56891: PPUSH
56892: PPUSH
56893: PPUSH
56894: PPUSH
56895: PPUSH
56896: PPUSH
56897: PPUSH
56898: PPUSH
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
56903: PPUSH
// result := [ ] ;
56904: LD_ADDR_VAR 0 7
56908: PUSH
56909: EMPTY
56910: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56911: LD_VAR 0 1
56915: PPUSH
56916: CALL_OW 266
56920: PUSH
56921: LD_INT 0
56923: PUSH
56924: LD_INT 1
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: IN
56931: NOT
56932: IFFALSE 56936
// exit ;
56934: GO 58570
// if name then
56936: LD_VAR 0 3
56940: IFFALSE 56956
// SetBName ( base_dep , name ) ;
56942: LD_VAR 0 1
56946: PPUSH
56947: LD_VAR 0 3
56951: PPUSH
56952: CALL_OW 500
// base := GetBase ( base_dep ) ;
56956: LD_ADDR_VAR 0 15
56960: PUSH
56961: LD_VAR 0 1
56965: PPUSH
56966: CALL_OW 274
56970: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56971: LD_ADDR_VAR 0 16
56975: PUSH
56976: LD_VAR 0 1
56980: PPUSH
56981: CALL_OW 255
56985: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56986: LD_ADDR_VAR 0 17
56990: PUSH
56991: LD_VAR 0 1
56995: PPUSH
56996: CALL_OW 248
57000: ST_TO_ADDR
// if sources then
57001: LD_VAR 0 5
57005: IFFALSE 57052
// for i = 1 to 3 do
57007: LD_ADDR_VAR 0 8
57011: PUSH
57012: DOUBLE
57013: LD_INT 1
57015: DEC
57016: ST_TO_ADDR
57017: LD_INT 3
57019: PUSH
57020: FOR_TO
57021: IFFALSE 57050
// AddResourceType ( base , i , sources [ i ] ) ;
57023: LD_VAR 0 15
57027: PPUSH
57028: LD_VAR 0 8
57032: PPUSH
57033: LD_VAR 0 5
57037: PUSH
57038: LD_VAR 0 8
57042: ARRAY
57043: PPUSH
57044: CALL_OW 276
57048: GO 57020
57050: POP
57051: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57052: LD_ADDR_VAR 0 18
57056: PUSH
57057: LD_VAR 0 15
57061: PPUSH
57062: LD_VAR 0 2
57066: PPUSH
57067: LD_INT 1
57069: PPUSH
57070: CALL 56313 0 3
57074: ST_TO_ADDR
// InitHc ;
57075: CALL_OW 19
// InitUc ;
57079: CALL_OW 18
// uc_side := side ;
57083: LD_ADDR_OWVAR 20
57087: PUSH
57088: LD_VAR 0 16
57092: ST_TO_ADDR
// uc_nation := nation ;
57093: LD_ADDR_OWVAR 21
57097: PUSH
57098: LD_VAR 0 17
57102: ST_TO_ADDR
// if buildings then
57103: LD_VAR 0 18
57107: IFFALSE 58429
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57109: LD_ADDR_VAR 0 19
57113: PUSH
57114: LD_VAR 0 18
57118: PPUSH
57119: LD_INT 2
57121: PUSH
57122: LD_INT 30
57124: PUSH
57125: LD_INT 29
57127: PUSH
57128: EMPTY
57129: LIST
57130: LIST
57131: PUSH
57132: LD_INT 30
57134: PUSH
57135: LD_INT 30
57137: PUSH
57138: EMPTY
57139: LIST
57140: LIST
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: LIST
57146: PPUSH
57147: CALL_OW 72
57151: ST_TO_ADDR
// if tmp then
57152: LD_VAR 0 19
57156: IFFALSE 57204
// for i in tmp do
57158: LD_ADDR_VAR 0 8
57162: PUSH
57163: LD_VAR 0 19
57167: PUSH
57168: FOR_IN
57169: IFFALSE 57202
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57171: LD_VAR 0 8
57175: PPUSH
57176: CALL_OW 250
57180: PPUSH
57181: LD_VAR 0 8
57185: PPUSH
57186: CALL_OW 251
57190: PPUSH
57191: LD_VAR 0 16
57195: PPUSH
57196: CALL_OW 441
57200: GO 57168
57202: POP
57203: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57204: LD_VAR 0 18
57208: PPUSH
57209: LD_INT 2
57211: PUSH
57212: LD_INT 30
57214: PUSH
57215: LD_INT 32
57217: PUSH
57218: EMPTY
57219: LIST
57220: LIST
57221: PUSH
57222: LD_INT 30
57224: PUSH
57225: LD_INT 33
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: LIST
57236: PPUSH
57237: CALL_OW 72
57241: IFFALSE 57329
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57243: LD_ADDR_VAR 0 8
57247: PUSH
57248: LD_VAR 0 18
57252: PPUSH
57253: LD_INT 2
57255: PUSH
57256: LD_INT 30
57258: PUSH
57259: LD_INT 32
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: PUSH
57266: LD_INT 30
57268: PUSH
57269: LD_INT 33
57271: PUSH
57272: EMPTY
57273: LIST
57274: LIST
57275: PUSH
57276: EMPTY
57277: LIST
57278: LIST
57279: LIST
57280: PPUSH
57281: CALL_OW 72
57285: PUSH
57286: FOR_IN
57287: IFFALSE 57327
// begin if not GetBWeapon ( i ) then
57289: LD_VAR 0 8
57293: PPUSH
57294: CALL_OW 269
57298: NOT
57299: IFFALSE 57325
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57301: LD_VAR 0 8
57305: PPUSH
57306: LD_VAR 0 8
57310: PPUSH
57311: LD_VAR 0 2
57315: PPUSH
57316: CALL 58575 0 2
57320: PPUSH
57321: CALL_OW 431
// end ;
57325: GO 57286
57327: POP
57328: POP
// end ; for i = 1 to personel do
57329: LD_ADDR_VAR 0 8
57333: PUSH
57334: DOUBLE
57335: LD_INT 1
57337: DEC
57338: ST_TO_ADDR
57339: LD_VAR 0 6
57343: PUSH
57344: FOR_TO
57345: IFFALSE 58409
// begin if i > 4 then
57347: LD_VAR 0 8
57351: PUSH
57352: LD_INT 4
57354: GREATER
57355: IFFALSE 57359
// break ;
57357: GO 58409
// case i of 1 :
57359: LD_VAR 0 8
57363: PUSH
57364: LD_INT 1
57366: DOUBLE
57367: EQUAL
57368: IFTRUE 57372
57370: GO 57452
57372: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57373: LD_ADDR_VAR 0 12
57377: PUSH
57378: LD_VAR 0 18
57382: PPUSH
57383: LD_INT 22
57385: PUSH
57386: LD_VAR 0 16
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 58
57397: PUSH
57398: EMPTY
57399: LIST
57400: PUSH
57401: LD_INT 2
57403: PUSH
57404: LD_INT 30
57406: PUSH
57407: LD_INT 32
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: LD_INT 30
57416: PUSH
57417: LD_INT 4
57419: PUSH
57420: EMPTY
57421: LIST
57422: LIST
57423: PUSH
57424: LD_INT 30
57426: PUSH
57427: LD_INT 5
57429: PUSH
57430: EMPTY
57431: LIST
57432: LIST
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: LIST
57438: LIST
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: LIST
57444: PPUSH
57445: CALL_OW 72
57449: ST_TO_ADDR
57450: GO 57674
57452: LD_INT 2
57454: DOUBLE
57455: EQUAL
57456: IFTRUE 57460
57458: GO 57522
57460: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57461: LD_ADDR_VAR 0 12
57465: PUSH
57466: LD_VAR 0 18
57470: PPUSH
57471: LD_INT 22
57473: PUSH
57474: LD_VAR 0 16
57478: PUSH
57479: EMPTY
57480: LIST
57481: LIST
57482: PUSH
57483: LD_INT 2
57485: PUSH
57486: LD_INT 30
57488: PUSH
57489: LD_INT 0
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: PUSH
57496: LD_INT 30
57498: PUSH
57499: LD_INT 1
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: PUSH
57506: EMPTY
57507: LIST
57508: LIST
57509: LIST
57510: PUSH
57511: EMPTY
57512: LIST
57513: LIST
57514: PPUSH
57515: CALL_OW 72
57519: ST_TO_ADDR
57520: GO 57674
57522: LD_INT 3
57524: DOUBLE
57525: EQUAL
57526: IFTRUE 57530
57528: GO 57592
57530: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57531: LD_ADDR_VAR 0 12
57535: PUSH
57536: LD_VAR 0 18
57540: PPUSH
57541: LD_INT 22
57543: PUSH
57544: LD_VAR 0 16
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PUSH
57553: LD_INT 2
57555: PUSH
57556: LD_INT 30
57558: PUSH
57559: LD_INT 2
57561: PUSH
57562: EMPTY
57563: LIST
57564: LIST
57565: PUSH
57566: LD_INT 30
57568: PUSH
57569: LD_INT 3
57571: PUSH
57572: EMPTY
57573: LIST
57574: LIST
57575: PUSH
57576: EMPTY
57577: LIST
57578: LIST
57579: LIST
57580: PUSH
57581: EMPTY
57582: LIST
57583: LIST
57584: PPUSH
57585: CALL_OW 72
57589: ST_TO_ADDR
57590: GO 57674
57592: LD_INT 4
57594: DOUBLE
57595: EQUAL
57596: IFTRUE 57600
57598: GO 57673
57600: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57601: LD_ADDR_VAR 0 12
57605: PUSH
57606: LD_VAR 0 18
57610: PPUSH
57611: LD_INT 22
57613: PUSH
57614: LD_VAR 0 16
57618: PUSH
57619: EMPTY
57620: LIST
57621: LIST
57622: PUSH
57623: LD_INT 2
57625: PUSH
57626: LD_INT 30
57628: PUSH
57629: LD_INT 6
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: PUSH
57636: LD_INT 30
57638: PUSH
57639: LD_INT 7
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PUSH
57646: LD_INT 30
57648: PUSH
57649: LD_INT 8
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: LIST
57660: LIST
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: PPUSH
57666: CALL_OW 72
57670: ST_TO_ADDR
57671: GO 57674
57673: POP
// if i = 1 then
57674: LD_VAR 0 8
57678: PUSH
57679: LD_INT 1
57681: EQUAL
57682: IFFALSE 57793
// begin tmp := [ ] ;
57684: LD_ADDR_VAR 0 19
57688: PUSH
57689: EMPTY
57690: ST_TO_ADDR
// for j in f do
57691: LD_ADDR_VAR 0 9
57695: PUSH
57696: LD_VAR 0 12
57700: PUSH
57701: FOR_IN
57702: IFFALSE 57775
// if GetBType ( j ) = b_bunker then
57704: LD_VAR 0 9
57708: PPUSH
57709: CALL_OW 266
57713: PUSH
57714: LD_INT 32
57716: EQUAL
57717: IFFALSE 57744
// tmp := Insert ( tmp , 1 , j ) else
57719: LD_ADDR_VAR 0 19
57723: PUSH
57724: LD_VAR 0 19
57728: PPUSH
57729: LD_INT 1
57731: PPUSH
57732: LD_VAR 0 9
57736: PPUSH
57737: CALL_OW 2
57741: ST_TO_ADDR
57742: GO 57773
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57744: LD_ADDR_VAR 0 19
57748: PUSH
57749: LD_VAR 0 19
57753: PPUSH
57754: LD_VAR 0 19
57758: PUSH
57759: LD_INT 1
57761: PLUS
57762: PPUSH
57763: LD_VAR 0 9
57767: PPUSH
57768: CALL_OW 2
57772: ST_TO_ADDR
57773: GO 57701
57775: POP
57776: POP
// if tmp then
57777: LD_VAR 0 19
57781: IFFALSE 57793
// f := tmp ;
57783: LD_ADDR_VAR 0 12
57787: PUSH
57788: LD_VAR 0 19
57792: ST_TO_ADDR
// end ; x := personel [ i ] ;
57793: LD_ADDR_VAR 0 13
57797: PUSH
57798: LD_VAR 0 6
57802: PUSH
57803: LD_VAR 0 8
57807: ARRAY
57808: ST_TO_ADDR
// if x = - 1 then
57809: LD_VAR 0 13
57813: PUSH
57814: LD_INT 1
57816: NEG
57817: EQUAL
57818: IFFALSE 58027
// begin for j in f do
57820: LD_ADDR_VAR 0 9
57824: PUSH
57825: LD_VAR 0 12
57829: PUSH
57830: FOR_IN
57831: IFFALSE 58023
// repeat InitHc ;
57833: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57837: LD_VAR 0 9
57841: PPUSH
57842: CALL_OW 266
57846: PUSH
57847: LD_INT 5
57849: EQUAL
57850: IFFALSE 57920
// begin if UnitsInside ( j ) < 3 then
57852: LD_VAR 0 9
57856: PPUSH
57857: CALL_OW 313
57861: PUSH
57862: LD_INT 3
57864: LESS
57865: IFFALSE 57901
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57867: LD_INT 0
57869: PPUSH
57870: LD_INT 5
57872: PUSH
57873: LD_INT 8
57875: PUSH
57876: LD_INT 9
57878: PUSH
57879: EMPTY
57880: LIST
57881: LIST
57882: LIST
57883: PUSH
57884: LD_VAR 0 17
57888: ARRAY
57889: PPUSH
57890: LD_VAR 0 4
57894: PPUSH
57895: CALL_OW 380
57899: GO 57918
// PrepareHuman ( false , i , skill ) ;
57901: LD_INT 0
57903: PPUSH
57904: LD_VAR 0 8
57908: PPUSH
57909: LD_VAR 0 4
57913: PPUSH
57914: CALL_OW 380
// end else
57918: GO 57937
// PrepareHuman ( false , i , skill ) ;
57920: LD_INT 0
57922: PPUSH
57923: LD_VAR 0 8
57927: PPUSH
57928: LD_VAR 0 4
57932: PPUSH
57933: CALL_OW 380
// un := CreateHuman ;
57937: LD_ADDR_VAR 0 14
57941: PUSH
57942: CALL_OW 44
57946: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57947: LD_ADDR_VAR 0 7
57951: PUSH
57952: LD_VAR 0 7
57956: PPUSH
57957: LD_INT 1
57959: PPUSH
57960: LD_VAR 0 14
57964: PPUSH
57965: CALL_OW 2
57969: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57970: LD_VAR 0 14
57974: PPUSH
57975: LD_VAR 0 9
57979: PPUSH
57980: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57984: LD_VAR 0 9
57988: PPUSH
57989: CALL_OW 313
57993: PUSH
57994: LD_INT 6
57996: EQUAL
57997: PUSH
57998: LD_VAR 0 9
58002: PPUSH
58003: CALL_OW 266
58007: PUSH
58008: LD_INT 32
58010: PUSH
58011: LD_INT 31
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: IN
58018: OR
58019: IFFALSE 57833
58021: GO 57830
58023: POP
58024: POP
// end else
58025: GO 58407
// for j = 1 to x do
58027: LD_ADDR_VAR 0 9
58031: PUSH
58032: DOUBLE
58033: LD_INT 1
58035: DEC
58036: ST_TO_ADDR
58037: LD_VAR 0 13
58041: PUSH
58042: FOR_TO
58043: IFFALSE 58405
// begin InitHc ;
58045: CALL_OW 19
// if not f then
58049: LD_VAR 0 12
58053: NOT
58054: IFFALSE 58143
// begin PrepareHuman ( false , i , skill ) ;
58056: LD_INT 0
58058: PPUSH
58059: LD_VAR 0 8
58063: PPUSH
58064: LD_VAR 0 4
58068: PPUSH
58069: CALL_OW 380
// un := CreateHuman ;
58073: LD_ADDR_VAR 0 14
58077: PUSH
58078: CALL_OW 44
58082: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58083: LD_ADDR_VAR 0 7
58087: PUSH
58088: LD_VAR 0 7
58092: PPUSH
58093: LD_INT 1
58095: PPUSH
58096: LD_VAR 0 14
58100: PPUSH
58101: CALL_OW 2
58105: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58106: LD_VAR 0 14
58110: PPUSH
58111: LD_VAR 0 1
58115: PPUSH
58116: CALL_OW 250
58120: PPUSH
58121: LD_VAR 0 1
58125: PPUSH
58126: CALL_OW 251
58130: PPUSH
58131: LD_INT 10
58133: PPUSH
58134: LD_INT 0
58136: PPUSH
58137: CALL_OW 50
// continue ;
58141: GO 58042
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58143: LD_VAR 0 12
58147: PUSH
58148: LD_INT 1
58150: ARRAY
58151: PPUSH
58152: CALL_OW 313
58156: PUSH
58157: LD_VAR 0 12
58161: PUSH
58162: LD_INT 1
58164: ARRAY
58165: PPUSH
58166: CALL_OW 266
58170: PUSH
58171: LD_INT 32
58173: PUSH
58174: LD_INT 31
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: IN
58181: AND
58182: PUSH
58183: LD_VAR 0 12
58187: PUSH
58188: LD_INT 1
58190: ARRAY
58191: PPUSH
58192: CALL_OW 313
58196: PUSH
58197: LD_INT 6
58199: EQUAL
58200: OR
58201: IFFALSE 58221
// f := Delete ( f , 1 ) ;
58203: LD_ADDR_VAR 0 12
58207: PUSH
58208: LD_VAR 0 12
58212: PPUSH
58213: LD_INT 1
58215: PPUSH
58216: CALL_OW 3
58220: ST_TO_ADDR
// if not f then
58221: LD_VAR 0 12
58225: NOT
58226: IFFALSE 58244
// begin x := x + 2 ;
58228: LD_ADDR_VAR 0 13
58232: PUSH
58233: LD_VAR 0 13
58237: PUSH
58238: LD_INT 2
58240: PLUS
58241: ST_TO_ADDR
// continue ;
58242: GO 58042
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58244: LD_VAR 0 12
58248: PUSH
58249: LD_INT 1
58251: ARRAY
58252: PPUSH
58253: CALL_OW 266
58257: PUSH
58258: LD_INT 5
58260: EQUAL
58261: IFFALSE 58335
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58263: LD_VAR 0 12
58267: PUSH
58268: LD_INT 1
58270: ARRAY
58271: PPUSH
58272: CALL_OW 313
58276: PUSH
58277: LD_INT 3
58279: LESS
58280: IFFALSE 58316
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58282: LD_INT 0
58284: PPUSH
58285: LD_INT 5
58287: PUSH
58288: LD_INT 8
58290: PUSH
58291: LD_INT 9
58293: PUSH
58294: EMPTY
58295: LIST
58296: LIST
58297: LIST
58298: PUSH
58299: LD_VAR 0 17
58303: ARRAY
58304: PPUSH
58305: LD_VAR 0 4
58309: PPUSH
58310: CALL_OW 380
58314: GO 58333
// PrepareHuman ( false , i , skill ) ;
58316: LD_INT 0
58318: PPUSH
58319: LD_VAR 0 8
58323: PPUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: CALL_OW 380
// end else
58333: GO 58352
// PrepareHuman ( false , i , skill ) ;
58335: LD_INT 0
58337: PPUSH
58338: LD_VAR 0 8
58342: PPUSH
58343: LD_VAR 0 4
58347: PPUSH
58348: CALL_OW 380
// un := CreateHuman ;
58352: LD_ADDR_VAR 0 14
58356: PUSH
58357: CALL_OW 44
58361: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58362: LD_ADDR_VAR 0 7
58366: PUSH
58367: LD_VAR 0 7
58371: PPUSH
58372: LD_INT 1
58374: PPUSH
58375: LD_VAR 0 14
58379: PPUSH
58380: CALL_OW 2
58384: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58385: LD_VAR 0 14
58389: PPUSH
58390: LD_VAR 0 12
58394: PUSH
58395: LD_INT 1
58397: ARRAY
58398: PPUSH
58399: CALL_OW 52
// end ;
58403: GO 58042
58405: POP
58406: POP
// end ;
58407: GO 57344
58409: POP
58410: POP
// result := result ^ buildings ;
58411: LD_ADDR_VAR 0 7
58415: PUSH
58416: LD_VAR 0 7
58420: PUSH
58421: LD_VAR 0 18
58425: ADD
58426: ST_TO_ADDR
// end else
58427: GO 58570
// begin for i = 1 to personel do
58429: LD_ADDR_VAR 0 8
58433: PUSH
58434: DOUBLE
58435: LD_INT 1
58437: DEC
58438: ST_TO_ADDR
58439: LD_VAR 0 6
58443: PUSH
58444: FOR_TO
58445: IFFALSE 58568
// begin if i > 4 then
58447: LD_VAR 0 8
58451: PUSH
58452: LD_INT 4
58454: GREATER
58455: IFFALSE 58459
// break ;
58457: GO 58568
// x := personel [ i ] ;
58459: LD_ADDR_VAR 0 13
58463: PUSH
58464: LD_VAR 0 6
58468: PUSH
58469: LD_VAR 0 8
58473: ARRAY
58474: ST_TO_ADDR
// if x = - 1 then
58475: LD_VAR 0 13
58479: PUSH
58480: LD_INT 1
58482: NEG
58483: EQUAL
58484: IFFALSE 58488
// continue ;
58486: GO 58444
// PrepareHuman ( false , i , skill ) ;
58488: LD_INT 0
58490: PPUSH
58491: LD_VAR 0 8
58495: PPUSH
58496: LD_VAR 0 4
58500: PPUSH
58501: CALL_OW 380
// un := CreateHuman ;
58505: LD_ADDR_VAR 0 14
58509: PUSH
58510: CALL_OW 44
58514: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58515: LD_VAR 0 14
58519: PPUSH
58520: LD_VAR 0 1
58524: PPUSH
58525: CALL_OW 250
58529: PPUSH
58530: LD_VAR 0 1
58534: PPUSH
58535: CALL_OW 251
58539: PPUSH
58540: LD_INT 10
58542: PPUSH
58543: LD_INT 0
58545: PPUSH
58546: CALL_OW 50
// result := result ^ un ;
58550: LD_ADDR_VAR 0 7
58554: PUSH
58555: LD_VAR 0 7
58559: PUSH
58560: LD_VAR 0 14
58564: ADD
58565: ST_TO_ADDR
// end ;
58566: GO 58444
58568: POP
58569: POP
// end ; end ;
58570: LD_VAR 0 7
58574: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58575: LD_INT 0
58577: PPUSH
58578: PPUSH
58579: PPUSH
58580: PPUSH
58581: PPUSH
58582: PPUSH
58583: PPUSH
58584: PPUSH
58585: PPUSH
58586: PPUSH
58587: PPUSH
58588: PPUSH
58589: PPUSH
58590: PPUSH
58591: PPUSH
58592: PPUSH
// result := false ;
58593: LD_ADDR_VAR 0 3
58597: PUSH
58598: LD_INT 0
58600: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58601: LD_VAR 0 1
58605: NOT
58606: PUSH
58607: LD_VAR 0 1
58611: PPUSH
58612: CALL_OW 266
58616: PUSH
58617: LD_INT 32
58619: PUSH
58620: LD_INT 33
58622: PUSH
58623: EMPTY
58624: LIST
58625: LIST
58626: IN
58627: NOT
58628: OR
58629: IFFALSE 58633
// exit ;
58631: GO 59742
// nat := GetNation ( tower ) ;
58633: LD_ADDR_VAR 0 12
58637: PUSH
58638: LD_VAR 0 1
58642: PPUSH
58643: CALL_OW 248
58647: ST_TO_ADDR
// side := GetSide ( tower ) ;
58648: LD_ADDR_VAR 0 16
58652: PUSH
58653: LD_VAR 0 1
58657: PPUSH
58658: CALL_OW 255
58662: ST_TO_ADDR
// x := GetX ( tower ) ;
58663: LD_ADDR_VAR 0 10
58667: PUSH
58668: LD_VAR 0 1
58672: PPUSH
58673: CALL_OW 250
58677: ST_TO_ADDR
// y := GetY ( tower ) ;
58678: LD_ADDR_VAR 0 11
58682: PUSH
58683: LD_VAR 0 1
58687: PPUSH
58688: CALL_OW 251
58692: ST_TO_ADDR
// if not x or not y then
58693: LD_VAR 0 10
58697: NOT
58698: PUSH
58699: LD_VAR 0 11
58703: NOT
58704: OR
58705: IFFALSE 58709
// exit ;
58707: GO 59742
// weapon := 0 ;
58709: LD_ADDR_VAR 0 18
58713: PUSH
58714: LD_INT 0
58716: ST_TO_ADDR
// fac_list := [ ] ;
58717: LD_ADDR_VAR 0 17
58721: PUSH
58722: EMPTY
58723: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58724: LD_ADDR_VAR 0 6
58728: PUSH
58729: LD_VAR 0 1
58733: PPUSH
58734: CALL_OW 274
58738: PPUSH
58739: LD_VAR 0 2
58743: PPUSH
58744: LD_INT 0
58746: PPUSH
58747: CALL 56313 0 3
58751: PPUSH
58752: LD_INT 30
58754: PUSH
58755: LD_INT 3
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: PPUSH
58762: CALL_OW 72
58766: ST_TO_ADDR
// if not factories then
58767: LD_VAR 0 6
58771: NOT
58772: IFFALSE 58776
// exit ;
58774: GO 59742
// for i in factories do
58776: LD_ADDR_VAR 0 8
58780: PUSH
58781: LD_VAR 0 6
58785: PUSH
58786: FOR_IN
58787: IFFALSE 58812
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58789: LD_ADDR_VAR 0 17
58793: PUSH
58794: LD_VAR 0 17
58798: PUSH
58799: LD_VAR 0 8
58803: PPUSH
58804: CALL_OW 478
58808: UNION
58809: ST_TO_ADDR
58810: GO 58786
58812: POP
58813: POP
// if not fac_list then
58814: LD_VAR 0 17
58818: NOT
58819: IFFALSE 58823
// exit ;
58821: GO 59742
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58823: LD_ADDR_VAR 0 5
58827: PUSH
58828: LD_INT 4
58830: PUSH
58831: LD_INT 5
58833: PUSH
58834: LD_INT 9
58836: PUSH
58837: LD_INT 10
58839: PUSH
58840: LD_INT 6
58842: PUSH
58843: LD_INT 7
58845: PUSH
58846: LD_INT 11
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: LIST
58853: LIST
58854: LIST
58855: LIST
58856: LIST
58857: PUSH
58858: LD_INT 27
58860: PUSH
58861: LD_INT 28
58863: PUSH
58864: LD_INT 26
58866: PUSH
58867: LD_INT 30
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: PUSH
58876: LD_INT 43
58878: PUSH
58879: LD_INT 44
58881: PUSH
58882: LD_INT 46
58884: PUSH
58885: LD_INT 45
58887: PUSH
58888: LD_INT 47
58890: PUSH
58891: LD_INT 49
58893: PUSH
58894: EMPTY
58895: LIST
58896: LIST
58897: LIST
58898: LIST
58899: LIST
58900: LIST
58901: PUSH
58902: EMPTY
58903: LIST
58904: LIST
58905: LIST
58906: PUSH
58907: LD_VAR 0 12
58911: ARRAY
58912: ST_TO_ADDR
// list := list isect fac_list ;
58913: LD_ADDR_VAR 0 5
58917: PUSH
58918: LD_VAR 0 5
58922: PUSH
58923: LD_VAR 0 17
58927: ISECT
58928: ST_TO_ADDR
// if not list then
58929: LD_VAR 0 5
58933: NOT
58934: IFFALSE 58938
// exit ;
58936: GO 59742
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58938: LD_VAR 0 12
58942: PUSH
58943: LD_INT 3
58945: EQUAL
58946: PUSH
58947: LD_INT 49
58949: PUSH
58950: LD_VAR 0 5
58954: IN
58955: AND
58956: PUSH
58957: LD_INT 31
58959: PPUSH
58960: LD_VAR 0 16
58964: PPUSH
58965: CALL_OW 321
58969: PUSH
58970: LD_INT 2
58972: EQUAL
58973: AND
58974: IFFALSE 59034
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58976: LD_INT 22
58978: PUSH
58979: LD_VAR 0 16
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: PUSH
58988: LD_INT 35
58990: PUSH
58991: LD_INT 49
58993: PUSH
58994: EMPTY
58995: LIST
58996: LIST
58997: PUSH
58998: LD_INT 91
59000: PUSH
59001: LD_VAR 0 1
59005: PUSH
59006: LD_INT 10
59008: PUSH
59009: EMPTY
59010: LIST
59011: LIST
59012: LIST
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: LIST
59018: PPUSH
59019: CALL_OW 69
59023: NOT
59024: IFFALSE 59034
// weapon := ru_time_lapser ;
59026: LD_ADDR_VAR 0 18
59030: PUSH
59031: LD_INT 49
59033: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59034: LD_VAR 0 12
59038: PUSH
59039: LD_INT 1
59041: PUSH
59042: LD_INT 2
59044: PUSH
59045: EMPTY
59046: LIST
59047: LIST
59048: IN
59049: PUSH
59050: LD_INT 11
59052: PUSH
59053: LD_VAR 0 5
59057: IN
59058: PUSH
59059: LD_INT 30
59061: PUSH
59062: LD_VAR 0 5
59066: IN
59067: OR
59068: AND
59069: PUSH
59070: LD_INT 6
59072: PPUSH
59073: LD_VAR 0 16
59077: PPUSH
59078: CALL_OW 321
59082: PUSH
59083: LD_INT 2
59085: EQUAL
59086: AND
59087: IFFALSE 59252
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59089: LD_INT 22
59091: PUSH
59092: LD_VAR 0 16
59096: PUSH
59097: EMPTY
59098: LIST
59099: LIST
59100: PUSH
59101: LD_INT 2
59103: PUSH
59104: LD_INT 35
59106: PUSH
59107: LD_INT 11
59109: PUSH
59110: EMPTY
59111: LIST
59112: LIST
59113: PUSH
59114: LD_INT 35
59116: PUSH
59117: LD_INT 30
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: LIST
59128: PUSH
59129: LD_INT 91
59131: PUSH
59132: LD_VAR 0 1
59136: PUSH
59137: LD_INT 18
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: LIST
59144: PUSH
59145: EMPTY
59146: LIST
59147: LIST
59148: LIST
59149: PPUSH
59150: CALL_OW 69
59154: NOT
59155: PUSH
59156: LD_INT 22
59158: PUSH
59159: LD_VAR 0 16
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: PUSH
59168: LD_INT 2
59170: PUSH
59171: LD_INT 30
59173: PUSH
59174: LD_INT 32
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 30
59183: PUSH
59184: LD_INT 33
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PUSH
59191: EMPTY
59192: LIST
59193: LIST
59194: LIST
59195: PUSH
59196: LD_INT 91
59198: PUSH
59199: LD_VAR 0 1
59203: PUSH
59204: LD_INT 12
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: PUSH
59212: EMPTY
59213: LIST
59214: LIST
59215: LIST
59216: PUSH
59217: EMPTY
59218: LIST
59219: PPUSH
59220: CALL_OW 69
59224: PUSH
59225: LD_INT 2
59227: GREATER
59228: AND
59229: IFFALSE 59252
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59231: LD_ADDR_VAR 0 18
59235: PUSH
59236: LD_INT 11
59238: PUSH
59239: LD_INT 30
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PUSH
59246: LD_VAR 0 12
59250: ARRAY
59251: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59252: LD_VAR 0 18
59256: NOT
59257: PUSH
59258: LD_INT 40
59260: PPUSH
59261: LD_VAR 0 16
59265: PPUSH
59266: CALL_OW 321
59270: PUSH
59271: LD_INT 2
59273: EQUAL
59274: AND
59275: PUSH
59276: LD_INT 7
59278: PUSH
59279: LD_VAR 0 5
59283: IN
59284: PUSH
59285: LD_INT 28
59287: PUSH
59288: LD_VAR 0 5
59292: IN
59293: OR
59294: PUSH
59295: LD_INT 45
59297: PUSH
59298: LD_VAR 0 5
59302: IN
59303: OR
59304: AND
59305: IFFALSE 59559
// begin hex := GetHexInfo ( x , y ) ;
59307: LD_ADDR_VAR 0 4
59311: PUSH
59312: LD_VAR 0 10
59316: PPUSH
59317: LD_VAR 0 11
59321: PPUSH
59322: CALL_OW 546
59326: ST_TO_ADDR
// if hex [ 1 ] then
59327: LD_VAR 0 4
59331: PUSH
59332: LD_INT 1
59334: ARRAY
59335: IFFALSE 59339
// exit ;
59337: GO 59742
// height := hex [ 2 ] ;
59339: LD_ADDR_VAR 0 15
59343: PUSH
59344: LD_VAR 0 4
59348: PUSH
59349: LD_INT 2
59351: ARRAY
59352: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59353: LD_ADDR_VAR 0 14
59357: PUSH
59358: LD_INT 0
59360: PUSH
59361: LD_INT 2
59363: PUSH
59364: LD_INT 3
59366: PUSH
59367: LD_INT 5
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: LIST
59374: LIST
59375: ST_TO_ADDR
// for i in tmp do
59376: LD_ADDR_VAR 0 8
59380: PUSH
59381: LD_VAR 0 14
59385: PUSH
59386: FOR_IN
59387: IFFALSE 59557
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59389: LD_ADDR_VAR 0 9
59393: PUSH
59394: LD_VAR 0 10
59398: PPUSH
59399: LD_VAR 0 8
59403: PPUSH
59404: LD_INT 5
59406: PPUSH
59407: CALL_OW 272
59411: PUSH
59412: LD_VAR 0 11
59416: PPUSH
59417: LD_VAR 0 8
59421: PPUSH
59422: LD_INT 5
59424: PPUSH
59425: CALL_OW 273
59429: PUSH
59430: EMPTY
59431: LIST
59432: LIST
59433: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59434: LD_VAR 0 9
59438: PUSH
59439: LD_INT 1
59441: ARRAY
59442: PPUSH
59443: LD_VAR 0 9
59447: PUSH
59448: LD_INT 2
59450: ARRAY
59451: PPUSH
59452: CALL_OW 488
59456: IFFALSE 59555
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59458: LD_ADDR_VAR 0 4
59462: PUSH
59463: LD_VAR 0 9
59467: PUSH
59468: LD_INT 1
59470: ARRAY
59471: PPUSH
59472: LD_VAR 0 9
59476: PUSH
59477: LD_INT 2
59479: ARRAY
59480: PPUSH
59481: CALL_OW 546
59485: ST_TO_ADDR
// if hex [ 1 ] then
59486: LD_VAR 0 4
59490: PUSH
59491: LD_INT 1
59493: ARRAY
59494: IFFALSE 59498
// continue ;
59496: GO 59386
// h := hex [ 2 ] ;
59498: LD_ADDR_VAR 0 13
59502: PUSH
59503: LD_VAR 0 4
59507: PUSH
59508: LD_INT 2
59510: ARRAY
59511: ST_TO_ADDR
// if h + 7 < height then
59512: LD_VAR 0 13
59516: PUSH
59517: LD_INT 7
59519: PLUS
59520: PUSH
59521: LD_VAR 0 15
59525: LESS
59526: IFFALSE 59555
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59528: LD_ADDR_VAR 0 18
59532: PUSH
59533: LD_INT 7
59535: PUSH
59536: LD_INT 28
59538: PUSH
59539: LD_INT 45
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: LIST
59546: PUSH
59547: LD_VAR 0 12
59551: ARRAY
59552: ST_TO_ADDR
// break ;
59553: GO 59557
// end ; end ; end ;
59555: GO 59386
59557: POP
59558: POP
// end ; if not weapon then
59559: LD_VAR 0 18
59563: NOT
59564: IFFALSE 59624
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59566: LD_ADDR_VAR 0 5
59570: PUSH
59571: LD_VAR 0 5
59575: PUSH
59576: LD_INT 11
59578: PUSH
59579: LD_INT 30
59581: PUSH
59582: LD_INT 49
59584: PUSH
59585: EMPTY
59586: LIST
59587: LIST
59588: LIST
59589: DIFF
59590: ST_TO_ADDR
// if not list then
59591: LD_VAR 0 5
59595: NOT
59596: IFFALSE 59600
// exit ;
59598: GO 59742
// weapon := list [ rand ( 1 , list ) ] ;
59600: LD_ADDR_VAR 0 18
59604: PUSH
59605: LD_VAR 0 5
59609: PUSH
59610: LD_INT 1
59612: PPUSH
59613: LD_VAR 0 5
59617: PPUSH
59618: CALL_OW 12
59622: ARRAY
59623: ST_TO_ADDR
// end ; if weapon then
59624: LD_VAR 0 18
59628: IFFALSE 59742
// begin tmp := CostOfWeapon ( weapon ) ;
59630: LD_ADDR_VAR 0 14
59634: PUSH
59635: LD_VAR 0 18
59639: PPUSH
59640: CALL_OW 451
59644: ST_TO_ADDR
// j := GetBase ( tower ) ;
59645: LD_ADDR_VAR 0 9
59649: PUSH
59650: LD_VAR 0 1
59654: PPUSH
59655: CALL_OW 274
59659: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59660: LD_VAR 0 9
59664: PPUSH
59665: LD_INT 1
59667: PPUSH
59668: CALL_OW 275
59672: PUSH
59673: LD_VAR 0 14
59677: PUSH
59678: LD_INT 1
59680: ARRAY
59681: GREATEREQUAL
59682: PUSH
59683: LD_VAR 0 9
59687: PPUSH
59688: LD_INT 2
59690: PPUSH
59691: CALL_OW 275
59695: PUSH
59696: LD_VAR 0 14
59700: PUSH
59701: LD_INT 2
59703: ARRAY
59704: GREATEREQUAL
59705: AND
59706: PUSH
59707: LD_VAR 0 9
59711: PPUSH
59712: LD_INT 3
59714: PPUSH
59715: CALL_OW 275
59719: PUSH
59720: LD_VAR 0 14
59724: PUSH
59725: LD_INT 3
59727: ARRAY
59728: GREATEREQUAL
59729: AND
59730: IFFALSE 59742
// result := weapon ;
59732: LD_ADDR_VAR 0 3
59736: PUSH
59737: LD_VAR 0 18
59741: ST_TO_ADDR
// end ; end ;
59742: LD_VAR 0 3
59746: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59747: LD_INT 0
59749: PPUSH
59750: PPUSH
// result := true ;
59751: LD_ADDR_VAR 0 3
59755: PUSH
59756: LD_INT 1
59758: ST_TO_ADDR
// if array1 = array2 then
59759: LD_VAR 0 1
59763: PUSH
59764: LD_VAR 0 2
59768: EQUAL
59769: IFFALSE 59829
// begin for i = 1 to array1 do
59771: LD_ADDR_VAR 0 4
59775: PUSH
59776: DOUBLE
59777: LD_INT 1
59779: DEC
59780: ST_TO_ADDR
59781: LD_VAR 0 1
59785: PUSH
59786: FOR_TO
59787: IFFALSE 59825
// if array1 [ i ] <> array2 [ i ] then
59789: LD_VAR 0 1
59793: PUSH
59794: LD_VAR 0 4
59798: ARRAY
59799: PUSH
59800: LD_VAR 0 2
59804: PUSH
59805: LD_VAR 0 4
59809: ARRAY
59810: NONEQUAL
59811: IFFALSE 59823
// begin result := false ;
59813: LD_ADDR_VAR 0 3
59817: PUSH
59818: LD_INT 0
59820: ST_TO_ADDR
// break ;
59821: GO 59825
// end ;
59823: GO 59786
59825: POP
59826: POP
// end else
59827: GO 59837
// result := false ;
59829: LD_ADDR_VAR 0 3
59833: PUSH
59834: LD_INT 0
59836: ST_TO_ADDR
// end ;
59837: LD_VAR 0 3
59841: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59842: LD_INT 0
59844: PPUSH
59845: PPUSH
// if not array1 or not array2 then
59846: LD_VAR 0 1
59850: NOT
59851: PUSH
59852: LD_VAR 0 2
59856: NOT
59857: OR
59858: IFFALSE 59862
// exit ;
59860: GO 59926
// result := true ;
59862: LD_ADDR_VAR 0 3
59866: PUSH
59867: LD_INT 1
59869: ST_TO_ADDR
// for i = 1 to array1 do
59870: LD_ADDR_VAR 0 4
59874: PUSH
59875: DOUBLE
59876: LD_INT 1
59878: DEC
59879: ST_TO_ADDR
59880: LD_VAR 0 1
59884: PUSH
59885: FOR_TO
59886: IFFALSE 59924
// if array1 [ i ] <> array2 [ i ] then
59888: LD_VAR 0 1
59892: PUSH
59893: LD_VAR 0 4
59897: ARRAY
59898: PUSH
59899: LD_VAR 0 2
59903: PUSH
59904: LD_VAR 0 4
59908: ARRAY
59909: NONEQUAL
59910: IFFALSE 59922
// begin result := false ;
59912: LD_ADDR_VAR 0 3
59916: PUSH
59917: LD_INT 0
59919: ST_TO_ADDR
// break ;
59920: GO 59924
// end ;
59922: GO 59885
59924: POP
59925: POP
// end ;
59926: LD_VAR 0 3
59930: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59931: LD_INT 0
59933: PPUSH
59934: PPUSH
59935: PPUSH
// pom := GetBase ( fac ) ;
59936: LD_ADDR_VAR 0 5
59940: PUSH
59941: LD_VAR 0 1
59945: PPUSH
59946: CALL_OW 274
59950: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59951: LD_ADDR_VAR 0 4
59955: PUSH
59956: LD_VAR 0 2
59960: PUSH
59961: LD_INT 1
59963: ARRAY
59964: PPUSH
59965: LD_VAR 0 2
59969: PUSH
59970: LD_INT 2
59972: ARRAY
59973: PPUSH
59974: LD_VAR 0 2
59978: PUSH
59979: LD_INT 3
59981: ARRAY
59982: PPUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_INT 4
59990: ARRAY
59991: PPUSH
59992: CALL_OW 449
59996: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59997: LD_ADDR_VAR 0 3
60001: PUSH
60002: LD_VAR 0 5
60006: PPUSH
60007: LD_INT 1
60009: PPUSH
60010: CALL_OW 275
60014: PUSH
60015: LD_VAR 0 4
60019: PUSH
60020: LD_INT 1
60022: ARRAY
60023: GREATEREQUAL
60024: PUSH
60025: LD_VAR 0 5
60029: PPUSH
60030: LD_INT 2
60032: PPUSH
60033: CALL_OW 275
60037: PUSH
60038: LD_VAR 0 4
60042: PUSH
60043: LD_INT 2
60045: ARRAY
60046: GREATEREQUAL
60047: AND
60048: PUSH
60049: LD_VAR 0 5
60053: PPUSH
60054: LD_INT 3
60056: PPUSH
60057: CALL_OW 275
60061: PUSH
60062: LD_VAR 0 4
60066: PUSH
60067: LD_INT 3
60069: ARRAY
60070: GREATEREQUAL
60071: AND
60072: ST_TO_ADDR
// end ;
60073: LD_VAR 0 3
60077: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60078: LD_INT 0
60080: PPUSH
60081: PPUSH
60082: PPUSH
60083: PPUSH
// pom := GetBase ( building ) ;
60084: LD_ADDR_VAR 0 3
60088: PUSH
60089: LD_VAR 0 1
60093: PPUSH
60094: CALL_OW 274
60098: ST_TO_ADDR
// if not pom then
60099: LD_VAR 0 3
60103: NOT
60104: IFFALSE 60108
// exit ;
60106: GO 60278
// btype := GetBType ( building ) ;
60108: LD_ADDR_VAR 0 5
60112: PUSH
60113: LD_VAR 0 1
60117: PPUSH
60118: CALL_OW 266
60122: ST_TO_ADDR
// if btype = b_armoury then
60123: LD_VAR 0 5
60127: PUSH
60128: LD_INT 4
60130: EQUAL
60131: IFFALSE 60141
// btype := b_barracks ;
60133: LD_ADDR_VAR 0 5
60137: PUSH
60138: LD_INT 5
60140: ST_TO_ADDR
// if btype = b_depot then
60141: LD_VAR 0 5
60145: PUSH
60146: LD_INT 0
60148: EQUAL
60149: IFFALSE 60159
// btype := b_warehouse ;
60151: LD_ADDR_VAR 0 5
60155: PUSH
60156: LD_INT 1
60158: ST_TO_ADDR
// if btype = b_workshop then
60159: LD_VAR 0 5
60163: PUSH
60164: LD_INT 2
60166: EQUAL
60167: IFFALSE 60177
// btype := b_factory ;
60169: LD_ADDR_VAR 0 5
60173: PUSH
60174: LD_INT 3
60176: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60177: LD_ADDR_VAR 0 4
60181: PUSH
60182: LD_VAR 0 5
60186: PPUSH
60187: LD_VAR 0 1
60191: PPUSH
60192: CALL_OW 248
60196: PPUSH
60197: CALL_OW 450
60201: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60202: LD_ADDR_VAR 0 2
60206: PUSH
60207: LD_VAR 0 3
60211: PPUSH
60212: LD_INT 1
60214: PPUSH
60215: CALL_OW 275
60219: PUSH
60220: LD_VAR 0 4
60224: PUSH
60225: LD_INT 1
60227: ARRAY
60228: GREATEREQUAL
60229: PUSH
60230: LD_VAR 0 3
60234: PPUSH
60235: LD_INT 2
60237: PPUSH
60238: CALL_OW 275
60242: PUSH
60243: LD_VAR 0 4
60247: PUSH
60248: LD_INT 2
60250: ARRAY
60251: GREATEREQUAL
60252: AND
60253: PUSH
60254: LD_VAR 0 3
60258: PPUSH
60259: LD_INT 3
60261: PPUSH
60262: CALL_OW 275
60266: PUSH
60267: LD_VAR 0 4
60271: PUSH
60272: LD_INT 3
60274: ARRAY
60275: GREATEREQUAL
60276: AND
60277: ST_TO_ADDR
// end ;
60278: LD_VAR 0 2
60282: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60283: LD_INT 0
60285: PPUSH
60286: PPUSH
60287: PPUSH
// pom := GetBase ( building ) ;
60288: LD_ADDR_VAR 0 4
60292: PUSH
60293: LD_VAR 0 1
60297: PPUSH
60298: CALL_OW 274
60302: ST_TO_ADDR
// if not pom then
60303: LD_VAR 0 4
60307: NOT
60308: IFFALSE 60312
// exit ;
60310: GO 60413
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60312: LD_ADDR_VAR 0 5
60316: PUSH
60317: LD_VAR 0 2
60321: PPUSH
60322: LD_VAR 0 1
60326: PPUSH
60327: CALL_OW 248
60331: PPUSH
60332: CALL_OW 450
60336: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60337: LD_ADDR_VAR 0 3
60341: PUSH
60342: LD_VAR 0 4
60346: PPUSH
60347: LD_INT 1
60349: PPUSH
60350: CALL_OW 275
60354: PUSH
60355: LD_VAR 0 5
60359: PUSH
60360: LD_INT 1
60362: ARRAY
60363: GREATEREQUAL
60364: PUSH
60365: LD_VAR 0 4
60369: PPUSH
60370: LD_INT 2
60372: PPUSH
60373: CALL_OW 275
60377: PUSH
60378: LD_VAR 0 5
60382: PUSH
60383: LD_INT 2
60385: ARRAY
60386: GREATEREQUAL
60387: AND
60388: PUSH
60389: LD_VAR 0 4
60393: PPUSH
60394: LD_INT 3
60396: PPUSH
60397: CALL_OW 275
60401: PUSH
60402: LD_VAR 0 5
60406: PUSH
60407: LD_INT 3
60409: ARRAY
60410: GREATEREQUAL
60411: AND
60412: ST_TO_ADDR
// end ;
60413: LD_VAR 0 3
60417: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60418: LD_INT 0
60420: PPUSH
60421: PPUSH
60422: PPUSH
60423: PPUSH
60424: PPUSH
60425: PPUSH
60426: PPUSH
60427: PPUSH
60428: PPUSH
60429: PPUSH
60430: PPUSH
// result := false ;
60431: LD_ADDR_VAR 0 8
60435: PUSH
60436: LD_INT 0
60438: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60439: LD_VAR 0 5
60443: NOT
60444: PUSH
60445: LD_VAR 0 1
60449: NOT
60450: OR
60451: PUSH
60452: LD_VAR 0 2
60456: NOT
60457: OR
60458: PUSH
60459: LD_VAR 0 3
60463: NOT
60464: OR
60465: IFFALSE 60469
// exit ;
60467: GO 61283
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60469: LD_ADDR_VAR 0 14
60473: PUSH
60474: LD_VAR 0 1
60478: PPUSH
60479: LD_VAR 0 2
60483: PPUSH
60484: LD_VAR 0 3
60488: PPUSH
60489: LD_VAR 0 4
60493: PPUSH
60494: LD_VAR 0 5
60498: PUSH
60499: LD_INT 1
60501: ARRAY
60502: PPUSH
60503: CALL_OW 248
60507: PPUSH
60508: LD_INT 0
60510: PPUSH
60511: CALL 62520 0 6
60515: ST_TO_ADDR
// if not hexes then
60516: LD_VAR 0 14
60520: NOT
60521: IFFALSE 60525
// exit ;
60523: GO 61283
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60525: LD_ADDR_VAR 0 17
60529: PUSH
60530: LD_VAR 0 5
60534: PPUSH
60535: LD_INT 22
60537: PUSH
60538: LD_VAR 0 13
60542: PPUSH
60543: CALL_OW 255
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PUSH
60552: LD_INT 2
60554: PUSH
60555: LD_INT 30
60557: PUSH
60558: LD_INT 0
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: PUSH
60565: LD_INT 30
60567: PUSH
60568: LD_INT 1
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: LIST
60579: PUSH
60580: EMPTY
60581: LIST
60582: LIST
60583: PPUSH
60584: CALL_OW 72
60588: ST_TO_ADDR
// for i = 1 to hexes do
60589: LD_ADDR_VAR 0 9
60593: PUSH
60594: DOUBLE
60595: LD_INT 1
60597: DEC
60598: ST_TO_ADDR
60599: LD_VAR 0 14
60603: PUSH
60604: FOR_TO
60605: IFFALSE 61281
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60607: LD_ADDR_VAR 0 13
60611: PUSH
60612: LD_VAR 0 14
60616: PUSH
60617: LD_VAR 0 9
60621: ARRAY
60622: PUSH
60623: LD_INT 1
60625: ARRAY
60626: PPUSH
60627: LD_VAR 0 14
60631: PUSH
60632: LD_VAR 0 9
60636: ARRAY
60637: PUSH
60638: LD_INT 2
60640: ARRAY
60641: PPUSH
60642: CALL_OW 428
60646: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60647: LD_VAR 0 14
60651: PUSH
60652: LD_VAR 0 9
60656: ARRAY
60657: PUSH
60658: LD_INT 1
60660: ARRAY
60661: PPUSH
60662: LD_VAR 0 14
60666: PUSH
60667: LD_VAR 0 9
60671: ARRAY
60672: PUSH
60673: LD_INT 2
60675: ARRAY
60676: PPUSH
60677: CALL_OW 351
60681: PUSH
60682: LD_VAR 0 14
60686: PUSH
60687: LD_VAR 0 9
60691: ARRAY
60692: PUSH
60693: LD_INT 1
60695: ARRAY
60696: PPUSH
60697: LD_VAR 0 14
60701: PUSH
60702: LD_VAR 0 9
60706: ARRAY
60707: PUSH
60708: LD_INT 2
60710: ARRAY
60711: PPUSH
60712: CALL_OW 488
60716: NOT
60717: OR
60718: PUSH
60719: LD_VAR 0 13
60723: PPUSH
60724: CALL_OW 247
60728: PUSH
60729: LD_INT 3
60731: EQUAL
60732: OR
60733: IFFALSE 60739
// exit ;
60735: POP
60736: POP
60737: GO 61283
// if not tmp then
60739: LD_VAR 0 13
60743: NOT
60744: IFFALSE 60748
// continue ;
60746: GO 60604
// result := true ;
60748: LD_ADDR_VAR 0 8
60752: PUSH
60753: LD_INT 1
60755: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60756: LD_VAR 0 6
60760: PUSH
60761: LD_VAR 0 13
60765: PPUSH
60766: CALL_OW 247
60770: PUSH
60771: LD_INT 2
60773: EQUAL
60774: AND
60775: PUSH
60776: LD_VAR 0 13
60780: PPUSH
60781: CALL_OW 263
60785: PUSH
60786: LD_INT 1
60788: EQUAL
60789: AND
60790: IFFALSE 60954
// begin if IsDrivenBy ( tmp ) then
60792: LD_VAR 0 13
60796: PPUSH
60797: CALL_OW 311
60801: IFFALSE 60805
// continue ;
60803: GO 60604
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60805: LD_VAR 0 6
60809: PPUSH
60810: LD_INT 3
60812: PUSH
60813: LD_INT 60
60815: PUSH
60816: EMPTY
60817: LIST
60818: PUSH
60819: EMPTY
60820: LIST
60821: LIST
60822: PUSH
60823: LD_INT 3
60825: PUSH
60826: LD_INT 55
60828: PUSH
60829: EMPTY
60830: LIST
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: PPUSH
60840: CALL_OW 72
60844: IFFALSE 60952
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60846: LD_ADDR_VAR 0 18
60850: PUSH
60851: LD_VAR 0 6
60855: PPUSH
60856: LD_INT 3
60858: PUSH
60859: LD_INT 60
60861: PUSH
60862: EMPTY
60863: LIST
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: LD_INT 3
60871: PUSH
60872: LD_INT 55
60874: PUSH
60875: EMPTY
60876: LIST
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PPUSH
60886: CALL_OW 72
60890: PUSH
60891: LD_INT 1
60893: ARRAY
60894: ST_TO_ADDR
// if IsInUnit ( driver ) then
60895: LD_VAR 0 18
60899: PPUSH
60900: CALL_OW 310
60904: IFFALSE 60915
// ComExit ( driver ) ;
60906: LD_VAR 0 18
60910: PPUSH
60911: CALL 85648 0 1
// AddComEnterUnit ( driver , tmp ) ;
60915: LD_VAR 0 18
60919: PPUSH
60920: LD_VAR 0 13
60924: PPUSH
60925: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60929: LD_VAR 0 18
60933: PPUSH
60934: LD_VAR 0 7
60938: PPUSH
60939: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60943: LD_VAR 0 18
60947: PPUSH
60948: CALL_OW 181
// end ; continue ;
60952: GO 60604
// end ; if not cleaners or not tmp in cleaners then
60954: LD_VAR 0 6
60958: NOT
60959: PUSH
60960: LD_VAR 0 13
60964: PUSH
60965: LD_VAR 0 6
60969: IN
60970: NOT
60971: OR
60972: IFFALSE 61279
// begin if dep then
60974: LD_VAR 0 17
60978: IFFALSE 61114
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60980: LD_ADDR_VAR 0 16
60984: PUSH
60985: LD_VAR 0 17
60989: PUSH
60990: LD_INT 1
60992: ARRAY
60993: PPUSH
60994: CALL_OW 250
60998: PPUSH
60999: LD_VAR 0 17
61003: PUSH
61004: LD_INT 1
61006: ARRAY
61007: PPUSH
61008: CALL_OW 254
61012: PPUSH
61013: LD_INT 5
61015: PPUSH
61016: CALL_OW 272
61020: PUSH
61021: LD_VAR 0 17
61025: PUSH
61026: LD_INT 1
61028: ARRAY
61029: PPUSH
61030: CALL_OW 251
61034: PPUSH
61035: LD_VAR 0 17
61039: PUSH
61040: LD_INT 1
61042: ARRAY
61043: PPUSH
61044: CALL_OW 254
61048: PPUSH
61049: LD_INT 5
61051: PPUSH
61052: CALL_OW 273
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61061: LD_VAR 0 16
61065: PUSH
61066: LD_INT 1
61068: ARRAY
61069: PPUSH
61070: LD_VAR 0 16
61074: PUSH
61075: LD_INT 2
61077: ARRAY
61078: PPUSH
61079: CALL_OW 488
61083: IFFALSE 61114
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61085: LD_VAR 0 13
61089: PPUSH
61090: LD_VAR 0 16
61094: PUSH
61095: LD_INT 1
61097: ARRAY
61098: PPUSH
61099: LD_VAR 0 16
61103: PUSH
61104: LD_INT 2
61106: ARRAY
61107: PPUSH
61108: CALL_OW 111
// continue ;
61112: GO 60604
// end ; end ; r := GetDir ( tmp ) ;
61114: LD_ADDR_VAR 0 15
61118: PUSH
61119: LD_VAR 0 13
61123: PPUSH
61124: CALL_OW 254
61128: ST_TO_ADDR
// if r = 5 then
61129: LD_VAR 0 15
61133: PUSH
61134: LD_INT 5
61136: EQUAL
61137: IFFALSE 61147
// r := 0 ;
61139: LD_ADDR_VAR 0 15
61143: PUSH
61144: LD_INT 0
61146: ST_TO_ADDR
// for j = r to 5 do
61147: LD_ADDR_VAR 0 10
61151: PUSH
61152: DOUBLE
61153: LD_VAR 0 15
61157: DEC
61158: ST_TO_ADDR
61159: LD_INT 5
61161: PUSH
61162: FOR_TO
61163: IFFALSE 61277
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61165: LD_ADDR_VAR 0 11
61169: PUSH
61170: LD_VAR 0 13
61174: PPUSH
61175: CALL_OW 250
61179: PPUSH
61180: LD_VAR 0 10
61184: PPUSH
61185: LD_INT 2
61187: PPUSH
61188: CALL_OW 272
61192: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61193: LD_ADDR_VAR 0 12
61197: PUSH
61198: LD_VAR 0 13
61202: PPUSH
61203: CALL_OW 251
61207: PPUSH
61208: LD_VAR 0 10
61212: PPUSH
61213: LD_INT 2
61215: PPUSH
61216: CALL_OW 273
61220: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61221: LD_VAR 0 11
61225: PPUSH
61226: LD_VAR 0 12
61230: PPUSH
61231: CALL_OW 488
61235: PUSH
61236: LD_VAR 0 11
61240: PPUSH
61241: LD_VAR 0 12
61245: PPUSH
61246: CALL_OW 428
61250: NOT
61251: AND
61252: IFFALSE 61275
// begin ComMoveXY ( tmp , _x , _y ) ;
61254: LD_VAR 0 13
61258: PPUSH
61259: LD_VAR 0 11
61263: PPUSH
61264: LD_VAR 0 12
61268: PPUSH
61269: CALL_OW 111
// break ;
61273: GO 61277
// end ; end ;
61275: GO 61162
61277: POP
61278: POP
// end ; end ;
61279: GO 60604
61281: POP
61282: POP
// end ;
61283: LD_VAR 0 8
61287: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61288: LD_INT 0
61290: PPUSH
// result := true ;
61291: LD_ADDR_VAR 0 3
61295: PUSH
61296: LD_INT 1
61298: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61299: LD_VAR 0 2
61303: PUSH
61304: LD_INT 24
61306: DOUBLE
61307: EQUAL
61308: IFTRUE 61318
61310: LD_INT 33
61312: DOUBLE
61313: EQUAL
61314: IFTRUE 61318
61316: GO 61343
61318: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61319: LD_ADDR_VAR 0 3
61323: PUSH
61324: LD_INT 32
61326: PPUSH
61327: LD_VAR 0 1
61331: PPUSH
61332: CALL_OW 321
61336: PUSH
61337: LD_INT 2
61339: EQUAL
61340: ST_TO_ADDR
61341: GO 61663
61343: LD_INT 20
61345: DOUBLE
61346: EQUAL
61347: IFTRUE 61351
61349: GO 61376
61351: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61352: LD_ADDR_VAR 0 3
61356: PUSH
61357: LD_INT 6
61359: PPUSH
61360: LD_VAR 0 1
61364: PPUSH
61365: CALL_OW 321
61369: PUSH
61370: LD_INT 2
61372: EQUAL
61373: ST_TO_ADDR
61374: GO 61663
61376: LD_INT 22
61378: DOUBLE
61379: EQUAL
61380: IFTRUE 61390
61382: LD_INT 36
61384: DOUBLE
61385: EQUAL
61386: IFTRUE 61390
61388: GO 61415
61390: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61391: LD_ADDR_VAR 0 3
61395: PUSH
61396: LD_INT 15
61398: PPUSH
61399: LD_VAR 0 1
61403: PPUSH
61404: CALL_OW 321
61408: PUSH
61409: LD_INT 2
61411: EQUAL
61412: ST_TO_ADDR
61413: GO 61663
61415: LD_INT 30
61417: DOUBLE
61418: EQUAL
61419: IFTRUE 61423
61421: GO 61448
61423: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61424: LD_ADDR_VAR 0 3
61428: PUSH
61429: LD_INT 20
61431: PPUSH
61432: LD_VAR 0 1
61436: PPUSH
61437: CALL_OW 321
61441: PUSH
61442: LD_INT 2
61444: EQUAL
61445: ST_TO_ADDR
61446: GO 61663
61448: LD_INT 28
61450: DOUBLE
61451: EQUAL
61452: IFTRUE 61462
61454: LD_INT 21
61456: DOUBLE
61457: EQUAL
61458: IFTRUE 61462
61460: GO 61487
61462: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61463: LD_ADDR_VAR 0 3
61467: PUSH
61468: LD_INT 21
61470: PPUSH
61471: LD_VAR 0 1
61475: PPUSH
61476: CALL_OW 321
61480: PUSH
61481: LD_INT 2
61483: EQUAL
61484: ST_TO_ADDR
61485: GO 61663
61487: LD_INT 16
61489: DOUBLE
61490: EQUAL
61491: IFTRUE 61495
61493: GO 61522
61495: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61496: LD_ADDR_VAR 0 3
61500: PUSH
61501: LD_EXP 107
61505: PPUSH
61506: LD_VAR 0 1
61510: PPUSH
61511: CALL_OW 321
61515: PUSH
61516: LD_INT 2
61518: EQUAL
61519: ST_TO_ADDR
61520: GO 61663
61522: LD_INT 19
61524: DOUBLE
61525: EQUAL
61526: IFTRUE 61536
61528: LD_INT 23
61530: DOUBLE
61531: EQUAL
61532: IFTRUE 61536
61534: GO 61563
61536: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61537: LD_ADDR_VAR 0 3
61541: PUSH
61542: LD_EXP 106
61546: PPUSH
61547: LD_VAR 0 1
61551: PPUSH
61552: CALL_OW 321
61556: PUSH
61557: LD_INT 2
61559: EQUAL
61560: ST_TO_ADDR
61561: GO 61663
61563: LD_INT 17
61565: DOUBLE
61566: EQUAL
61567: IFTRUE 61571
61569: GO 61596
61571: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61572: LD_ADDR_VAR 0 3
61576: PUSH
61577: LD_INT 39
61579: PPUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: CALL_OW 321
61589: PUSH
61590: LD_INT 2
61592: EQUAL
61593: ST_TO_ADDR
61594: GO 61663
61596: LD_INT 18
61598: DOUBLE
61599: EQUAL
61600: IFTRUE 61604
61602: GO 61629
61604: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61605: LD_ADDR_VAR 0 3
61609: PUSH
61610: LD_INT 40
61612: PPUSH
61613: LD_VAR 0 1
61617: PPUSH
61618: CALL_OW 321
61622: PUSH
61623: LD_INT 2
61625: EQUAL
61626: ST_TO_ADDR
61627: GO 61663
61629: LD_INT 27
61631: DOUBLE
61632: EQUAL
61633: IFTRUE 61637
61635: GO 61662
61637: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61638: LD_ADDR_VAR 0 3
61642: PUSH
61643: LD_INT 35
61645: PPUSH
61646: LD_VAR 0 1
61650: PPUSH
61651: CALL_OW 321
61655: PUSH
61656: LD_INT 2
61658: EQUAL
61659: ST_TO_ADDR
61660: GO 61663
61662: POP
// end ;
61663: LD_VAR 0 3
61667: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61668: LD_INT 0
61670: PPUSH
61671: PPUSH
61672: PPUSH
61673: PPUSH
61674: PPUSH
61675: PPUSH
61676: PPUSH
61677: PPUSH
61678: PPUSH
61679: PPUSH
61680: PPUSH
// result := false ;
61681: LD_ADDR_VAR 0 6
61685: PUSH
61686: LD_INT 0
61688: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61689: LD_VAR 0 1
61693: NOT
61694: PUSH
61695: LD_VAR 0 1
61699: PPUSH
61700: CALL_OW 266
61704: PUSH
61705: LD_INT 0
61707: PUSH
61708: LD_INT 1
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: IN
61715: NOT
61716: OR
61717: PUSH
61718: LD_VAR 0 2
61722: NOT
61723: OR
61724: PUSH
61725: LD_VAR 0 5
61729: PUSH
61730: LD_INT 0
61732: PUSH
61733: LD_INT 1
61735: PUSH
61736: LD_INT 2
61738: PUSH
61739: LD_INT 3
61741: PUSH
61742: LD_INT 4
61744: PUSH
61745: LD_INT 5
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: LIST
61755: IN
61756: NOT
61757: OR
61758: PUSH
61759: LD_VAR 0 3
61763: PPUSH
61764: LD_VAR 0 4
61768: PPUSH
61769: CALL_OW 488
61773: NOT
61774: OR
61775: IFFALSE 61779
// exit ;
61777: GO 62515
// side := GetSide ( depot ) ;
61779: LD_ADDR_VAR 0 9
61783: PUSH
61784: LD_VAR 0 1
61788: PPUSH
61789: CALL_OW 255
61793: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61794: LD_VAR 0 9
61798: PPUSH
61799: LD_VAR 0 2
61803: PPUSH
61804: CALL 61288 0 2
61808: NOT
61809: IFFALSE 61813
// exit ;
61811: GO 62515
// pom := GetBase ( depot ) ;
61813: LD_ADDR_VAR 0 10
61817: PUSH
61818: LD_VAR 0 1
61822: PPUSH
61823: CALL_OW 274
61827: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61828: LD_ADDR_VAR 0 11
61832: PUSH
61833: LD_VAR 0 2
61837: PPUSH
61838: LD_VAR 0 1
61842: PPUSH
61843: CALL_OW 248
61847: PPUSH
61848: CALL_OW 450
61852: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61853: LD_VAR 0 10
61857: PPUSH
61858: LD_INT 1
61860: PPUSH
61861: CALL_OW 275
61865: PUSH
61866: LD_VAR 0 11
61870: PUSH
61871: LD_INT 1
61873: ARRAY
61874: GREATEREQUAL
61875: PUSH
61876: LD_VAR 0 10
61880: PPUSH
61881: LD_INT 2
61883: PPUSH
61884: CALL_OW 275
61888: PUSH
61889: LD_VAR 0 11
61893: PUSH
61894: LD_INT 2
61896: ARRAY
61897: GREATEREQUAL
61898: AND
61899: PUSH
61900: LD_VAR 0 10
61904: PPUSH
61905: LD_INT 3
61907: PPUSH
61908: CALL_OW 275
61912: PUSH
61913: LD_VAR 0 11
61917: PUSH
61918: LD_INT 3
61920: ARRAY
61921: GREATEREQUAL
61922: AND
61923: NOT
61924: IFFALSE 61928
// exit ;
61926: GO 62515
// if GetBType ( depot ) = b_depot then
61928: LD_VAR 0 1
61932: PPUSH
61933: CALL_OW 266
61937: PUSH
61938: LD_INT 0
61940: EQUAL
61941: IFFALSE 61953
// dist := 28 else
61943: LD_ADDR_VAR 0 14
61947: PUSH
61948: LD_INT 28
61950: ST_TO_ADDR
61951: GO 61961
// dist := 36 ;
61953: LD_ADDR_VAR 0 14
61957: PUSH
61958: LD_INT 36
61960: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61961: LD_VAR 0 1
61965: PPUSH
61966: LD_VAR 0 3
61970: PPUSH
61971: LD_VAR 0 4
61975: PPUSH
61976: CALL_OW 297
61980: PUSH
61981: LD_VAR 0 14
61985: GREATER
61986: IFFALSE 61990
// exit ;
61988: GO 62515
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61990: LD_ADDR_VAR 0 12
61994: PUSH
61995: LD_VAR 0 2
61999: PPUSH
62000: LD_VAR 0 3
62004: PPUSH
62005: LD_VAR 0 4
62009: PPUSH
62010: LD_VAR 0 5
62014: PPUSH
62015: LD_VAR 0 1
62019: PPUSH
62020: CALL_OW 248
62024: PPUSH
62025: LD_INT 0
62027: PPUSH
62028: CALL 62520 0 6
62032: ST_TO_ADDR
// if not hexes then
62033: LD_VAR 0 12
62037: NOT
62038: IFFALSE 62042
// exit ;
62040: GO 62515
// hex := GetHexInfo ( x , y ) ;
62042: LD_ADDR_VAR 0 15
62046: PUSH
62047: LD_VAR 0 3
62051: PPUSH
62052: LD_VAR 0 4
62056: PPUSH
62057: CALL_OW 546
62061: ST_TO_ADDR
// if hex [ 1 ] then
62062: LD_VAR 0 15
62066: PUSH
62067: LD_INT 1
62069: ARRAY
62070: IFFALSE 62074
// exit ;
62072: GO 62515
// height := hex [ 2 ] ;
62074: LD_ADDR_VAR 0 13
62078: PUSH
62079: LD_VAR 0 15
62083: PUSH
62084: LD_INT 2
62086: ARRAY
62087: ST_TO_ADDR
// for i = 1 to hexes do
62088: LD_ADDR_VAR 0 7
62092: PUSH
62093: DOUBLE
62094: LD_INT 1
62096: DEC
62097: ST_TO_ADDR
62098: LD_VAR 0 12
62102: PUSH
62103: FOR_TO
62104: IFFALSE 62434
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62106: LD_VAR 0 12
62110: PUSH
62111: LD_VAR 0 7
62115: ARRAY
62116: PUSH
62117: LD_INT 1
62119: ARRAY
62120: PPUSH
62121: LD_VAR 0 12
62125: PUSH
62126: LD_VAR 0 7
62130: ARRAY
62131: PUSH
62132: LD_INT 2
62134: ARRAY
62135: PPUSH
62136: CALL_OW 488
62140: NOT
62141: PUSH
62142: LD_VAR 0 12
62146: PUSH
62147: LD_VAR 0 7
62151: ARRAY
62152: PUSH
62153: LD_INT 1
62155: ARRAY
62156: PPUSH
62157: LD_VAR 0 12
62161: PUSH
62162: LD_VAR 0 7
62166: ARRAY
62167: PUSH
62168: LD_INT 2
62170: ARRAY
62171: PPUSH
62172: CALL_OW 428
62176: PUSH
62177: LD_INT 0
62179: GREATER
62180: OR
62181: PUSH
62182: LD_VAR 0 12
62186: PUSH
62187: LD_VAR 0 7
62191: ARRAY
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: PPUSH
62197: LD_VAR 0 12
62201: PUSH
62202: LD_VAR 0 7
62206: ARRAY
62207: PUSH
62208: LD_INT 2
62210: ARRAY
62211: PPUSH
62212: CALL_OW 351
62216: OR
62217: IFFALSE 62223
// exit ;
62219: POP
62220: POP
62221: GO 62515
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62223: LD_ADDR_VAR 0 8
62227: PUSH
62228: LD_VAR 0 12
62232: PUSH
62233: LD_VAR 0 7
62237: ARRAY
62238: PUSH
62239: LD_INT 1
62241: ARRAY
62242: PPUSH
62243: LD_VAR 0 12
62247: PUSH
62248: LD_VAR 0 7
62252: ARRAY
62253: PUSH
62254: LD_INT 2
62256: ARRAY
62257: PPUSH
62258: CALL_OW 546
62262: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62263: LD_VAR 0 8
62267: PUSH
62268: LD_INT 1
62270: ARRAY
62271: PUSH
62272: LD_VAR 0 8
62276: PUSH
62277: LD_INT 2
62279: ARRAY
62280: PUSH
62281: LD_VAR 0 13
62285: PUSH
62286: LD_INT 2
62288: PLUS
62289: GREATER
62290: OR
62291: PUSH
62292: LD_VAR 0 8
62296: PUSH
62297: LD_INT 2
62299: ARRAY
62300: PUSH
62301: LD_VAR 0 13
62305: PUSH
62306: LD_INT 2
62308: MINUS
62309: LESS
62310: OR
62311: PUSH
62312: LD_VAR 0 8
62316: PUSH
62317: LD_INT 3
62319: ARRAY
62320: PUSH
62321: LD_INT 0
62323: PUSH
62324: LD_INT 8
62326: PUSH
62327: LD_INT 9
62329: PUSH
62330: LD_INT 10
62332: PUSH
62333: LD_INT 11
62335: PUSH
62336: LD_INT 12
62338: PUSH
62339: LD_INT 13
62341: PUSH
62342: LD_INT 16
62344: PUSH
62345: LD_INT 17
62347: PUSH
62348: LD_INT 18
62350: PUSH
62351: LD_INT 19
62353: PUSH
62354: LD_INT 20
62356: PUSH
62357: LD_INT 21
62359: PUSH
62360: EMPTY
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: LIST
62366: LIST
62367: LIST
62368: LIST
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: LIST
62374: IN
62375: NOT
62376: OR
62377: PUSH
62378: LD_VAR 0 8
62382: PUSH
62383: LD_INT 5
62385: ARRAY
62386: NOT
62387: OR
62388: PUSH
62389: LD_VAR 0 8
62393: PUSH
62394: LD_INT 6
62396: ARRAY
62397: PUSH
62398: LD_INT 1
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: LD_INT 7
62406: PUSH
62407: LD_INT 9
62409: PUSH
62410: LD_INT 10
62412: PUSH
62413: LD_INT 11
62415: PUSH
62416: EMPTY
62417: LIST
62418: LIST
62419: LIST
62420: LIST
62421: LIST
62422: LIST
62423: IN
62424: NOT
62425: OR
62426: IFFALSE 62432
// exit ;
62428: POP
62429: POP
62430: GO 62515
// end ;
62432: GO 62103
62434: POP
62435: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62436: LD_VAR 0 9
62440: PPUSH
62441: LD_VAR 0 3
62445: PPUSH
62446: LD_VAR 0 4
62450: PPUSH
62451: LD_INT 20
62453: PPUSH
62454: CALL 54461 0 4
62458: PUSH
62459: LD_INT 4
62461: ARRAY
62462: IFFALSE 62466
// exit ;
62464: GO 62515
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62466: LD_VAR 0 2
62470: PUSH
62471: LD_INT 29
62473: PUSH
62474: LD_INT 30
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: IN
62481: PUSH
62482: LD_VAR 0 3
62486: PPUSH
62487: LD_VAR 0 4
62491: PPUSH
62492: LD_VAR 0 9
62496: PPUSH
62497: CALL_OW 440
62501: NOT
62502: AND
62503: IFFALSE 62507
// exit ;
62505: GO 62515
// result := true ;
62507: LD_ADDR_VAR 0 6
62511: PUSH
62512: LD_INT 1
62514: ST_TO_ADDR
// end ;
62515: LD_VAR 0 6
62519: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62520: LD_INT 0
62522: PPUSH
62523: PPUSH
62524: PPUSH
62525: PPUSH
62526: PPUSH
62527: PPUSH
62528: PPUSH
62529: PPUSH
62530: PPUSH
62531: PPUSH
62532: PPUSH
62533: PPUSH
62534: PPUSH
62535: PPUSH
62536: PPUSH
62537: PPUSH
62538: PPUSH
62539: PPUSH
62540: PPUSH
62541: PPUSH
62542: PPUSH
62543: PPUSH
62544: PPUSH
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
62551: PPUSH
62552: PPUSH
62553: PPUSH
62554: PPUSH
62555: PPUSH
62556: PPUSH
62557: PPUSH
62558: PPUSH
62559: PPUSH
62560: PPUSH
62561: PPUSH
62562: PPUSH
62563: PPUSH
62564: PPUSH
62565: PPUSH
62566: PPUSH
62567: PPUSH
62568: PPUSH
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
62574: PPUSH
62575: PPUSH
62576: PPUSH
62577: PPUSH
62578: PPUSH
62579: PPUSH
// result = [ ] ;
62580: LD_ADDR_VAR 0 7
62584: PUSH
62585: EMPTY
62586: ST_TO_ADDR
// temp_list = [ ] ;
62587: LD_ADDR_VAR 0 9
62591: PUSH
62592: EMPTY
62593: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62594: LD_VAR 0 4
62598: PUSH
62599: LD_INT 0
62601: PUSH
62602: LD_INT 1
62604: PUSH
62605: LD_INT 2
62607: PUSH
62608: LD_INT 3
62610: PUSH
62611: LD_INT 4
62613: PUSH
62614: LD_INT 5
62616: PUSH
62617: EMPTY
62618: LIST
62619: LIST
62620: LIST
62621: LIST
62622: LIST
62623: LIST
62624: IN
62625: NOT
62626: PUSH
62627: LD_VAR 0 1
62631: PUSH
62632: LD_INT 0
62634: PUSH
62635: LD_INT 1
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: IN
62642: PUSH
62643: LD_VAR 0 5
62647: PUSH
62648: LD_INT 1
62650: PUSH
62651: LD_INT 2
62653: PUSH
62654: LD_INT 3
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: LIST
62661: IN
62662: NOT
62663: AND
62664: OR
62665: IFFALSE 62669
// exit ;
62667: GO 81060
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62669: LD_VAR 0 1
62673: PUSH
62674: LD_INT 6
62676: PUSH
62677: LD_INT 7
62679: PUSH
62680: LD_INT 8
62682: PUSH
62683: LD_INT 13
62685: PUSH
62686: LD_INT 12
62688: PUSH
62689: LD_INT 15
62691: PUSH
62692: LD_INT 11
62694: PUSH
62695: LD_INT 14
62697: PUSH
62698: LD_INT 10
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: LIST
62705: LIST
62706: LIST
62707: LIST
62708: LIST
62709: LIST
62710: LIST
62711: IN
62712: IFFALSE 62722
// btype = b_lab ;
62714: LD_ADDR_VAR 0 1
62718: PUSH
62719: LD_INT 6
62721: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62722: LD_VAR 0 6
62726: PUSH
62727: LD_INT 0
62729: PUSH
62730: LD_INT 1
62732: PUSH
62733: LD_INT 2
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: LIST
62740: IN
62741: NOT
62742: PUSH
62743: LD_VAR 0 1
62747: PUSH
62748: LD_INT 0
62750: PUSH
62751: LD_INT 1
62753: PUSH
62754: LD_INT 2
62756: PUSH
62757: LD_INT 3
62759: PUSH
62760: LD_INT 6
62762: PUSH
62763: LD_INT 36
62765: PUSH
62766: LD_INT 4
62768: PUSH
62769: LD_INT 5
62771: PUSH
62772: LD_INT 31
62774: PUSH
62775: LD_INT 32
62777: PUSH
62778: LD_INT 33
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: IN
62794: NOT
62795: PUSH
62796: LD_VAR 0 6
62800: PUSH
62801: LD_INT 1
62803: EQUAL
62804: AND
62805: OR
62806: PUSH
62807: LD_VAR 0 1
62811: PUSH
62812: LD_INT 2
62814: PUSH
62815: LD_INT 3
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: IN
62822: NOT
62823: PUSH
62824: LD_VAR 0 6
62828: PUSH
62829: LD_INT 2
62831: EQUAL
62832: AND
62833: OR
62834: IFFALSE 62844
// mode = 0 ;
62836: LD_ADDR_VAR 0 6
62840: PUSH
62841: LD_INT 0
62843: ST_TO_ADDR
// case mode of 0 :
62844: LD_VAR 0 6
62848: PUSH
62849: LD_INT 0
62851: DOUBLE
62852: EQUAL
62853: IFTRUE 62857
62855: GO 74310
62857: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62858: LD_ADDR_VAR 0 11
62862: PUSH
62863: LD_INT 0
62865: PUSH
62866: LD_INT 0
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: PUSH
62873: LD_INT 0
62875: PUSH
62876: LD_INT 1
62878: NEG
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PUSH
62884: LD_INT 1
62886: PUSH
62887: LD_INT 0
62889: PUSH
62890: EMPTY
62891: LIST
62892: LIST
62893: PUSH
62894: LD_INT 1
62896: PUSH
62897: LD_INT 1
62899: PUSH
62900: EMPTY
62901: LIST
62902: LIST
62903: PUSH
62904: LD_INT 0
62906: PUSH
62907: LD_INT 1
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 1
62916: NEG
62917: PUSH
62918: LD_INT 0
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 1
62927: NEG
62928: PUSH
62929: LD_INT 1
62931: NEG
62932: PUSH
62933: EMPTY
62934: LIST
62935: LIST
62936: PUSH
62937: LD_INT 1
62939: NEG
62940: PUSH
62941: LD_INT 2
62943: NEG
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: PUSH
62949: LD_INT 0
62951: PUSH
62952: LD_INT 2
62954: NEG
62955: PUSH
62956: EMPTY
62957: LIST
62958: LIST
62959: PUSH
62960: LD_INT 1
62962: PUSH
62963: LD_INT 1
62965: NEG
62966: PUSH
62967: EMPTY
62968: LIST
62969: LIST
62970: PUSH
62971: LD_INT 1
62973: PUSH
62974: LD_INT 2
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: PUSH
62981: LD_INT 0
62983: PUSH
62984: LD_INT 2
62986: PUSH
62987: EMPTY
62988: LIST
62989: LIST
62990: PUSH
62991: LD_INT 1
62993: NEG
62994: PUSH
62995: LD_INT 1
62997: PUSH
62998: EMPTY
62999: LIST
63000: LIST
63001: PUSH
63002: LD_INT 1
63004: PUSH
63005: LD_INT 3
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: PUSH
63012: LD_INT 0
63014: PUSH
63015: LD_INT 3
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: PUSH
63022: LD_INT 1
63024: NEG
63025: PUSH
63026: LD_INT 2
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: LIST
63037: LIST
63038: LIST
63039: LIST
63040: LIST
63041: LIST
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: LIST
63047: LIST
63048: LIST
63049: LIST
63050: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63051: LD_ADDR_VAR 0 12
63055: PUSH
63056: LD_INT 0
63058: PUSH
63059: LD_INT 0
63061: PUSH
63062: EMPTY
63063: LIST
63064: LIST
63065: PUSH
63066: LD_INT 0
63068: PUSH
63069: LD_INT 1
63071: NEG
63072: PUSH
63073: EMPTY
63074: LIST
63075: LIST
63076: PUSH
63077: LD_INT 1
63079: PUSH
63080: LD_INT 0
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PUSH
63087: LD_INT 1
63089: PUSH
63090: LD_INT 1
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 0
63099: PUSH
63100: LD_INT 1
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PUSH
63107: LD_INT 1
63109: NEG
63110: PUSH
63111: LD_INT 0
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 1
63120: NEG
63121: PUSH
63122: LD_INT 1
63124: NEG
63125: PUSH
63126: EMPTY
63127: LIST
63128: LIST
63129: PUSH
63130: LD_INT 1
63132: PUSH
63133: LD_INT 1
63135: NEG
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: PUSH
63141: LD_INT 2
63143: PUSH
63144: LD_INT 0
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 2
63153: PUSH
63154: LD_INT 1
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 1
63163: NEG
63164: PUSH
63165: LD_INT 1
63167: PUSH
63168: EMPTY
63169: LIST
63170: LIST
63171: PUSH
63172: LD_INT 2
63174: NEG
63175: PUSH
63176: LD_INT 0
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 2
63185: NEG
63186: PUSH
63187: LD_INT 1
63189: NEG
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 2
63197: NEG
63198: PUSH
63199: LD_INT 1
63201: PUSH
63202: EMPTY
63203: LIST
63204: LIST
63205: PUSH
63206: LD_INT 3
63208: NEG
63209: PUSH
63210: LD_INT 0
63212: PUSH
63213: EMPTY
63214: LIST
63215: LIST
63216: PUSH
63217: LD_INT 3
63219: NEG
63220: PUSH
63221: LD_INT 1
63223: NEG
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PUSH
63229: EMPTY
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: LIST
63246: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63247: LD_ADDR_VAR 0 13
63251: PUSH
63252: LD_INT 0
63254: PUSH
63255: LD_INT 0
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 0
63264: PUSH
63265: LD_INT 1
63267: NEG
63268: PUSH
63269: EMPTY
63270: LIST
63271: LIST
63272: PUSH
63273: LD_INT 1
63275: PUSH
63276: LD_INT 0
63278: PUSH
63279: EMPTY
63280: LIST
63281: LIST
63282: PUSH
63283: LD_INT 1
63285: PUSH
63286: LD_INT 1
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: PUSH
63293: LD_INT 0
63295: PUSH
63296: LD_INT 1
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 1
63305: NEG
63306: PUSH
63307: LD_INT 0
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 1
63316: NEG
63317: PUSH
63318: LD_INT 1
63320: NEG
63321: PUSH
63322: EMPTY
63323: LIST
63324: LIST
63325: PUSH
63326: LD_INT 1
63328: NEG
63329: PUSH
63330: LD_INT 2
63332: NEG
63333: PUSH
63334: EMPTY
63335: LIST
63336: LIST
63337: PUSH
63338: LD_INT 2
63340: PUSH
63341: LD_INT 1
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 2
63350: PUSH
63351: LD_INT 2
63353: PUSH
63354: EMPTY
63355: LIST
63356: LIST
63357: PUSH
63358: LD_INT 1
63360: PUSH
63361: LD_INT 2
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: PUSH
63368: LD_INT 2
63370: NEG
63371: PUSH
63372: LD_INT 1
63374: NEG
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 2
63382: NEG
63383: PUSH
63384: LD_INT 2
63386: NEG
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: PUSH
63392: LD_INT 2
63394: NEG
63395: PUSH
63396: LD_INT 3
63398: NEG
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: LD_INT 3
63406: NEG
63407: PUSH
63408: LD_INT 2
63410: NEG
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: PUSH
63416: LD_INT 3
63418: NEG
63419: PUSH
63420: LD_INT 3
63422: NEG
63423: PUSH
63424: EMPTY
63425: LIST
63426: LIST
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: LIST
63442: LIST
63443: LIST
63444: LIST
63445: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63446: LD_ADDR_VAR 0 14
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: LD_INT 0
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: PUSH
63461: LD_INT 0
63463: PUSH
63464: LD_INT 1
63466: NEG
63467: PUSH
63468: EMPTY
63469: LIST
63470: LIST
63471: PUSH
63472: LD_INT 1
63474: PUSH
63475: LD_INT 0
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: PUSH
63482: LD_INT 1
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: EMPTY
63489: LIST
63490: LIST
63491: PUSH
63492: LD_INT 0
63494: PUSH
63495: LD_INT 1
63497: PUSH
63498: EMPTY
63499: LIST
63500: LIST
63501: PUSH
63502: LD_INT 1
63504: NEG
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 1
63515: NEG
63516: PUSH
63517: LD_INT 1
63519: NEG
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: PUSH
63525: LD_INT 1
63527: NEG
63528: PUSH
63529: LD_INT 2
63531: NEG
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: LD_INT 2
63542: NEG
63543: PUSH
63544: EMPTY
63545: LIST
63546: LIST
63547: PUSH
63548: LD_INT 1
63550: PUSH
63551: LD_INT 1
63553: NEG
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: LD_INT 2
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 0
63571: PUSH
63572: LD_INT 2
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: PUSH
63579: LD_INT 1
63581: NEG
63582: PUSH
63583: LD_INT 1
63585: PUSH
63586: EMPTY
63587: LIST
63588: LIST
63589: PUSH
63590: LD_INT 1
63592: NEG
63593: PUSH
63594: LD_INT 3
63596: NEG
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 0
63604: PUSH
63605: LD_INT 3
63607: NEG
63608: PUSH
63609: EMPTY
63610: LIST
63611: LIST
63612: PUSH
63613: LD_INT 1
63615: PUSH
63616: LD_INT 2
63618: NEG
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63642: LD_ADDR_VAR 0 15
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: LD_INT 0
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PUSH
63657: LD_INT 0
63659: PUSH
63660: LD_INT 1
63662: NEG
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 1
63670: PUSH
63671: LD_INT 0
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: PUSH
63678: LD_INT 1
63680: PUSH
63681: LD_INT 1
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: PUSH
63688: LD_INT 0
63690: PUSH
63691: LD_INT 1
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PUSH
63698: LD_INT 1
63700: NEG
63701: PUSH
63702: LD_INT 0
63704: PUSH
63705: EMPTY
63706: LIST
63707: LIST
63708: PUSH
63709: LD_INT 1
63711: NEG
63712: PUSH
63713: LD_INT 1
63715: NEG
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 1
63723: PUSH
63724: LD_INT 1
63726: NEG
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 2
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 2
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: EMPTY
63749: LIST
63750: LIST
63751: PUSH
63752: LD_INT 1
63754: NEG
63755: PUSH
63756: LD_INT 1
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: PUSH
63763: LD_INT 2
63765: NEG
63766: PUSH
63767: LD_INT 0
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 2
63776: NEG
63777: PUSH
63778: LD_INT 1
63780: NEG
63781: PUSH
63782: EMPTY
63783: LIST
63784: LIST
63785: PUSH
63786: LD_INT 2
63788: PUSH
63789: LD_INT 1
63791: NEG
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 3
63799: PUSH
63800: LD_INT 0
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: LD_INT 3
63809: PUSH
63810: LD_INT 1
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: LIST
63821: LIST
63822: LIST
63823: LIST
63824: LIST
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63835: LD_ADDR_VAR 0 16
63839: PUSH
63840: LD_INT 0
63842: PUSH
63843: LD_INT 0
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: LD_INT 0
63852: PUSH
63853: LD_INT 1
63855: NEG
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 1
63863: PUSH
63864: LD_INT 0
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 1
63873: PUSH
63874: LD_INT 1
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 0
63883: PUSH
63884: LD_INT 1
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: PUSH
63891: LD_INT 1
63893: NEG
63894: PUSH
63895: LD_INT 0
63897: PUSH
63898: EMPTY
63899: LIST
63900: LIST
63901: PUSH
63902: LD_INT 1
63904: NEG
63905: PUSH
63906: LD_INT 1
63908: NEG
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: PUSH
63914: LD_INT 1
63916: NEG
63917: PUSH
63918: LD_INT 2
63920: NEG
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: PUSH
63926: LD_INT 2
63928: PUSH
63929: LD_INT 1
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: PUSH
63936: LD_INT 2
63938: PUSH
63939: LD_INT 2
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: PUSH
63946: LD_INT 1
63948: PUSH
63949: LD_INT 2
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PUSH
63956: LD_INT 2
63958: NEG
63959: PUSH
63960: LD_INT 1
63962: NEG
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PUSH
63968: LD_INT 2
63970: NEG
63971: PUSH
63972: LD_INT 2
63974: NEG
63975: PUSH
63976: EMPTY
63977: LIST
63978: LIST
63979: PUSH
63980: LD_INT 3
63982: PUSH
63983: LD_INT 2
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: PUSH
63990: LD_INT 3
63992: PUSH
63993: LD_INT 3
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: LD_INT 2
64002: PUSH
64003: LD_INT 3
64005: PUSH
64006: EMPTY
64007: LIST
64008: LIST
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: LIST
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: LIST
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: LIST
64027: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64028: LD_ADDR_VAR 0 17
64032: PUSH
64033: LD_INT 0
64035: PUSH
64036: LD_INT 0
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 0
64045: PUSH
64046: LD_INT 1
64048: NEG
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: LD_INT 1
64056: PUSH
64057: LD_INT 0
64059: PUSH
64060: EMPTY
64061: LIST
64062: LIST
64063: PUSH
64064: LD_INT 1
64066: PUSH
64067: LD_INT 1
64069: PUSH
64070: EMPTY
64071: LIST
64072: LIST
64073: PUSH
64074: LD_INT 0
64076: PUSH
64077: LD_INT 1
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 1
64086: NEG
64087: PUSH
64088: LD_INT 0
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PUSH
64095: LD_INT 1
64097: NEG
64098: PUSH
64099: LD_INT 1
64101: NEG
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 1
64109: NEG
64110: PUSH
64111: LD_INT 2
64113: NEG
64114: PUSH
64115: EMPTY
64116: LIST
64117: LIST
64118: PUSH
64119: LD_INT 0
64121: PUSH
64122: LD_INT 2
64124: NEG
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: PUSH
64130: LD_INT 1
64132: PUSH
64133: LD_INT 1
64135: NEG
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PUSH
64141: LD_INT 2
64143: PUSH
64144: LD_INT 0
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: PUSH
64151: LD_INT 2
64153: PUSH
64154: LD_INT 1
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: PUSH
64161: LD_INT 2
64163: PUSH
64164: LD_INT 2
64166: PUSH
64167: EMPTY
64168: LIST
64169: LIST
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: LD_INT 2
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 0
64183: PUSH
64184: LD_INT 2
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PUSH
64191: LD_INT 1
64193: NEG
64194: PUSH
64195: LD_INT 1
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: LD_INT 2
64204: NEG
64205: PUSH
64206: LD_INT 0
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: LD_INT 2
64215: NEG
64216: PUSH
64217: LD_INT 1
64219: NEG
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 2
64227: NEG
64228: PUSH
64229: LD_INT 2
64231: NEG
64232: PUSH
64233: EMPTY
64234: LIST
64235: LIST
64236: PUSH
64237: EMPTY
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: LIST
64257: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64258: LD_ADDR_VAR 0 18
64262: PUSH
64263: LD_INT 0
64265: PUSH
64266: LD_INT 0
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 0
64275: PUSH
64276: LD_INT 1
64278: NEG
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 1
64286: PUSH
64287: LD_INT 0
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 1
64296: PUSH
64297: LD_INT 1
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 0
64306: PUSH
64307: LD_INT 1
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: LD_INT 0
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 1
64327: NEG
64328: PUSH
64329: LD_INT 1
64331: NEG
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 1
64339: NEG
64340: PUSH
64341: LD_INT 2
64343: NEG
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: LD_INT 0
64351: PUSH
64352: LD_INT 2
64354: NEG
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: LD_INT 1
64362: PUSH
64363: LD_INT 1
64365: NEG
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: LD_INT 2
64373: PUSH
64374: LD_INT 0
64376: PUSH
64377: EMPTY
64378: LIST
64379: LIST
64380: PUSH
64381: LD_INT 2
64383: PUSH
64384: LD_INT 1
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: PUSH
64391: LD_INT 2
64393: PUSH
64394: LD_INT 2
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: LD_INT 1
64403: PUSH
64404: LD_INT 2
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 0
64413: PUSH
64414: LD_INT 2
64416: PUSH
64417: EMPTY
64418: LIST
64419: LIST
64420: PUSH
64421: LD_INT 1
64423: NEG
64424: PUSH
64425: LD_INT 1
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 2
64434: NEG
64435: PUSH
64436: LD_INT 0
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: LD_INT 1
64449: NEG
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 2
64457: NEG
64458: PUSH
64459: LD_INT 2
64461: NEG
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64488: LD_ADDR_VAR 0 19
64492: PUSH
64493: LD_INT 0
64495: PUSH
64496: LD_INT 0
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 0
64505: PUSH
64506: LD_INT 1
64508: NEG
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: LD_INT 1
64516: PUSH
64517: LD_INT 0
64519: PUSH
64520: EMPTY
64521: LIST
64522: LIST
64523: PUSH
64524: LD_INT 1
64526: PUSH
64527: LD_INT 1
64529: PUSH
64530: EMPTY
64531: LIST
64532: LIST
64533: PUSH
64534: LD_INT 0
64536: PUSH
64537: LD_INT 1
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PUSH
64544: LD_INT 1
64546: NEG
64547: PUSH
64548: LD_INT 0
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 1
64557: NEG
64558: PUSH
64559: LD_INT 1
64561: NEG
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 1
64569: NEG
64570: PUSH
64571: LD_INT 2
64573: NEG
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 0
64581: PUSH
64582: LD_INT 2
64584: NEG
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: LD_INT 1
64592: PUSH
64593: LD_INT 1
64595: NEG
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: PUSH
64601: LD_INT 2
64603: PUSH
64604: LD_INT 0
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: PUSH
64611: LD_INT 2
64613: PUSH
64614: LD_INT 1
64616: PUSH
64617: EMPTY
64618: LIST
64619: LIST
64620: PUSH
64621: LD_INT 2
64623: PUSH
64624: LD_INT 2
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: LD_INT 2
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 0
64643: PUSH
64644: LD_INT 2
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: NEG
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: EMPTY
64659: LIST
64660: LIST
64661: PUSH
64662: LD_INT 2
64664: NEG
64665: PUSH
64666: LD_INT 0
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: NEG
64676: PUSH
64677: LD_INT 1
64679: NEG
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 2
64687: NEG
64688: PUSH
64689: LD_INT 2
64691: NEG
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64718: LD_ADDR_VAR 0 20
64722: PUSH
64723: LD_INT 0
64725: PUSH
64726: LD_INT 0
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: LD_INT 1
64738: NEG
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: PUSH
64744: LD_INT 1
64746: PUSH
64747: LD_INT 0
64749: PUSH
64750: EMPTY
64751: LIST
64752: LIST
64753: PUSH
64754: LD_INT 1
64756: PUSH
64757: LD_INT 1
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 0
64766: PUSH
64767: LD_INT 1
64769: PUSH
64770: EMPTY
64771: LIST
64772: LIST
64773: PUSH
64774: LD_INT 1
64776: NEG
64777: PUSH
64778: LD_INT 0
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: LD_INT 1
64791: NEG
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 1
64799: NEG
64800: PUSH
64801: LD_INT 2
64803: NEG
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 0
64811: PUSH
64812: LD_INT 2
64814: NEG
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 1
64822: PUSH
64823: LD_INT 1
64825: NEG
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PUSH
64831: LD_INT 2
64833: PUSH
64834: LD_INT 0
64836: PUSH
64837: EMPTY
64838: LIST
64839: LIST
64840: PUSH
64841: LD_INT 2
64843: PUSH
64844: LD_INT 1
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 2
64853: PUSH
64854: LD_INT 2
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 1
64863: PUSH
64864: LD_INT 2
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 0
64873: PUSH
64874: LD_INT 2
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 1
64883: NEG
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: EMPTY
64889: LIST
64890: LIST
64891: PUSH
64892: LD_INT 2
64894: NEG
64895: PUSH
64896: LD_INT 0
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: LD_INT 1
64909: NEG
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 2
64917: NEG
64918: PUSH
64919: LD_INT 2
64921: NEG
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64948: LD_ADDR_VAR 0 21
64952: PUSH
64953: LD_INT 0
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 0
64965: PUSH
64966: LD_INT 1
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: LD_INT 1
64976: PUSH
64977: LD_INT 0
64979: PUSH
64980: EMPTY
64981: LIST
64982: LIST
64983: PUSH
64984: LD_INT 1
64986: PUSH
64987: LD_INT 1
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 0
64996: PUSH
64997: LD_INT 1
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 1
65006: NEG
65007: PUSH
65008: LD_INT 0
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 1
65029: NEG
65030: PUSH
65031: LD_INT 2
65033: NEG
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 0
65041: PUSH
65042: LD_INT 2
65044: NEG
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 1
65052: PUSH
65053: LD_INT 1
65055: NEG
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 2
65063: PUSH
65064: LD_INT 0
65066: PUSH
65067: EMPTY
65068: LIST
65069: LIST
65070: PUSH
65071: LD_INT 2
65073: PUSH
65074: LD_INT 1
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 2
65083: PUSH
65084: LD_INT 2
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 1
65093: PUSH
65094: LD_INT 2
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 0
65103: PUSH
65104: LD_INT 2
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 1
65113: NEG
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 2
65124: NEG
65125: PUSH
65126: LD_INT 0
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: NEG
65136: PUSH
65137: LD_INT 1
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 2
65147: NEG
65148: PUSH
65149: LD_INT 2
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65178: LD_ADDR_VAR 0 22
65182: PUSH
65183: LD_INT 0
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 0
65195: PUSH
65196: LD_INT 1
65198: NEG
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 1
65206: PUSH
65207: LD_INT 0
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: PUSH
65214: LD_INT 1
65216: PUSH
65217: LD_INT 1
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 0
65226: PUSH
65227: LD_INT 1
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: PUSH
65234: LD_INT 1
65236: NEG
65237: PUSH
65238: LD_INT 0
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 1
65247: NEG
65248: PUSH
65249: LD_INT 1
65251: NEG
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 1
65259: NEG
65260: PUSH
65261: LD_INT 2
65263: NEG
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 0
65271: PUSH
65272: LD_INT 2
65274: NEG
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: LD_INT 1
65285: NEG
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 2
65293: PUSH
65294: LD_INT 0
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 2
65303: PUSH
65304: LD_INT 1
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 2
65313: PUSH
65314: LD_INT 2
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 1
65323: PUSH
65324: LD_INT 2
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 0
65333: PUSH
65334: LD_INT 2
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: LD_INT 1
65343: NEG
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: LD_INT 2
65354: NEG
65355: PUSH
65356: LD_INT 0
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: NEG
65366: PUSH
65367: LD_INT 1
65369: NEG
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: LD_INT 2
65377: NEG
65378: PUSH
65379: LD_INT 2
65381: NEG
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65408: LD_ADDR_VAR 0 23
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: LD_INT 0
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PUSH
65423: LD_INT 0
65425: PUSH
65426: LD_INT 1
65428: NEG
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 1
65436: PUSH
65437: LD_INT 0
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 1
65446: PUSH
65447: LD_INT 1
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 0
65456: PUSH
65457: LD_INT 1
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 1
65466: NEG
65467: PUSH
65468: LD_INT 0
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: NEG
65490: PUSH
65491: LD_INT 2
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 0
65501: PUSH
65502: LD_INT 2
65504: NEG
65505: PUSH
65506: EMPTY
65507: LIST
65508: LIST
65509: PUSH
65510: LD_INT 1
65512: PUSH
65513: LD_INT 1
65515: NEG
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: LD_INT 2
65523: PUSH
65524: LD_INT 0
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 2
65533: PUSH
65534: LD_INT 1
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 2
65543: PUSH
65544: LD_INT 2
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: LD_INT 2
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 0
65563: PUSH
65564: LD_INT 2
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: PUSH
65571: LD_INT 1
65573: NEG
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 2
65584: NEG
65585: PUSH
65586: LD_INT 0
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 1
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 2
65607: NEG
65608: PUSH
65609: LD_INT 2
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 2
65619: NEG
65620: PUSH
65621: LD_INT 3
65623: NEG
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 1
65631: NEG
65632: PUSH
65633: LD_INT 3
65635: NEG
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 1
65643: PUSH
65644: LD_INT 2
65646: NEG
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 2
65654: PUSH
65655: LD_INT 1
65657: NEG
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: PUSH
65663: EMPTY
65664: LIST
65665: LIST
65666: LIST
65667: LIST
65668: LIST
65669: LIST
65670: LIST
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65688: LD_ADDR_VAR 0 24
65692: PUSH
65693: LD_INT 0
65695: PUSH
65696: LD_INT 0
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: PUSH
65703: LD_INT 0
65705: PUSH
65706: LD_INT 1
65708: NEG
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 1
65716: PUSH
65717: LD_INT 0
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 1
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: PUSH
65734: LD_INT 0
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PUSH
65744: LD_INT 1
65746: NEG
65747: PUSH
65748: LD_INT 0
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 1
65757: NEG
65758: PUSH
65759: LD_INT 1
65761: NEG
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 1
65769: NEG
65770: PUSH
65771: LD_INT 2
65773: NEG
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: LD_INT 2
65784: NEG
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: PUSH
65790: LD_INT 1
65792: PUSH
65793: LD_INT 1
65795: NEG
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: LD_INT 2
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 2
65813: PUSH
65814: LD_INT 1
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 2
65823: PUSH
65824: LD_INT 2
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 1
65833: PUSH
65834: LD_INT 2
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 0
65843: PUSH
65844: LD_INT 2
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 1
65853: NEG
65854: PUSH
65855: LD_INT 1
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 2
65864: NEG
65865: PUSH
65866: LD_INT 0
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 2
65875: NEG
65876: PUSH
65877: LD_INT 1
65879: NEG
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: LD_INT 2
65887: NEG
65888: PUSH
65889: LD_INT 2
65891: NEG
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 1
65899: PUSH
65900: LD_INT 2
65902: NEG
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: LD_INT 1
65913: NEG
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 3
65921: PUSH
65922: LD_INT 1
65924: PUSH
65925: EMPTY
65926: LIST
65927: LIST
65928: PUSH
65929: LD_INT 3
65931: PUSH
65932: LD_INT 2
65934: PUSH
65935: EMPTY
65936: LIST
65937: LIST
65938: PUSH
65939: EMPTY
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: LIST
65949: LIST
65950: LIST
65951: LIST
65952: LIST
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65964: LD_ADDR_VAR 0 25
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: LD_INT 0
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 0
65981: PUSH
65982: LD_INT 1
65984: NEG
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 1
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 1
66002: PUSH
66003: LD_INT 1
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 0
66012: PUSH
66013: LD_INT 1
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 1
66022: NEG
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 1
66033: NEG
66034: PUSH
66035: LD_INT 1
66037: NEG
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: LD_INT 1
66045: NEG
66046: PUSH
66047: LD_INT 2
66049: NEG
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 0
66057: PUSH
66058: LD_INT 2
66060: NEG
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 1
66068: PUSH
66069: LD_INT 1
66071: NEG
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 2
66079: PUSH
66080: LD_INT 0
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: LD_INT 2
66089: PUSH
66090: LD_INT 1
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 2
66099: PUSH
66100: LD_INT 2
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 1
66109: PUSH
66110: LD_INT 2
66112: PUSH
66113: EMPTY
66114: LIST
66115: LIST
66116: PUSH
66117: LD_INT 0
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: NEG
66130: PUSH
66131: LD_INT 1
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 2
66140: NEG
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 2
66151: NEG
66152: PUSH
66153: LD_INT 1
66155: NEG
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: LD_INT 2
66163: NEG
66164: PUSH
66165: LD_INT 2
66167: NEG
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PUSH
66173: LD_INT 3
66175: PUSH
66176: LD_INT 1
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PUSH
66183: LD_INT 3
66185: PUSH
66186: LD_INT 2
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 2
66195: PUSH
66196: LD_INT 3
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: LD_INT 3
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66238: LD_ADDR_VAR 0 26
66242: PUSH
66243: LD_INT 0
66245: PUSH
66246: LD_INT 0
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: PUSH
66253: LD_INT 0
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 1
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 1
66276: PUSH
66277: LD_INT 1
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 0
66286: PUSH
66287: LD_INT 1
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: LD_INT 1
66296: NEG
66297: PUSH
66298: LD_INT 0
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 1
66307: NEG
66308: PUSH
66309: LD_INT 1
66311: NEG
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: LD_INT 1
66319: NEG
66320: PUSH
66321: LD_INT 2
66323: NEG
66324: PUSH
66325: EMPTY
66326: LIST
66327: LIST
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: LD_INT 2
66334: NEG
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: LD_INT 1
66345: NEG
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 2
66353: PUSH
66354: LD_INT 0
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 2
66363: PUSH
66364: LD_INT 1
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PUSH
66371: LD_INT 2
66373: PUSH
66374: LD_INT 2
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: LD_INT 2
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: LD_INT 2
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 1
66403: NEG
66404: PUSH
66405: LD_INT 1
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 2
66414: NEG
66415: PUSH
66416: LD_INT 0
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 2
66425: NEG
66426: PUSH
66427: LD_INT 1
66429: NEG
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 2
66437: NEG
66438: PUSH
66439: LD_INT 2
66441: NEG
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 2
66449: PUSH
66450: LD_INT 3
66452: PUSH
66453: EMPTY
66454: LIST
66455: LIST
66456: PUSH
66457: LD_INT 1
66459: PUSH
66460: LD_INT 3
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 1
66469: NEG
66470: PUSH
66471: LD_INT 2
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 2
66480: NEG
66481: PUSH
66482: LD_INT 1
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66514: LD_ADDR_VAR 0 27
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: LD_INT 0
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 1
66542: PUSH
66543: LD_INT 0
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 1
66552: PUSH
66553: LD_INT 1
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: LD_INT 0
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: LD_INT 1
66587: NEG
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 2
66599: NEG
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: LD_INT 2
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 2
66629: PUSH
66630: LD_INT 0
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 2
66639: PUSH
66640: LD_INT 1
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 2
66649: PUSH
66650: LD_INT 2
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: LD_INT 2
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: LD_INT 2
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 2
66690: NEG
66691: PUSH
66692: LD_INT 0
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: LD_INT 1
66705: NEG
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: NEG
66714: PUSH
66715: LD_INT 2
66717: NEG
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 1
66725: NEG
66726: PUSH
66727: LD_INT 2
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 2
66736: NEG
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 3
66747: NEG
66748: PUSH
66749: LD_INT 1
66751: NEG
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 3
66759: NEG
66760: PUSH
66761: LD_INT 2
66763: NEG
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: LIST
66773: LIST
66774: LIST
66775: LIST
66776: LIST
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66794: LD_ADDR_VAR 0 28
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: LD_INT 0
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 0
66811: PUSH
66812: LD_INT 1
66814: NEG
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 1
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: PUSH
66833: LD_INT 1
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: LD_INT 0
66842: PUSH
66843: LD_INT 1
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 1
66852: NEG
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 1
66863: NEG
66864: PUSH
66865: LD_INT 1
66867: NEG
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 1
66875: NEG
66876: PUSH
66877: LD_INT 2
66879: NEG
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: LD_INT 2
66890: NEG
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 1
66898: PUSH
66899: LD_INT 1
66901: NEG
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 2
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 2
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 2
66929: PUSH
66930: LD_INT 2
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: LD_INT 2
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: LD_INT 0
66949: PUSH
66950: LD_INT 2
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 1
66959: NEG
66960: PUSH
66961: LD_INT 1
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 2
66970: NEG
66971: PUSH
66972: LD_INT 0
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 2
66993: NEG
66994: PUSH
66995: LD_INT 2
66997: NEG
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 2
67005: NEG
67006: PUSH
67007: LD_INT 3
67009: NEG
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 1
67017: NEG
67018: PUSH
67019: LD_INT 3
67021: NEG
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 3
67029: NEG
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 3
67041: NEG
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67076: LD_ADDR_VAR 0 29
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: LD_INT 1
67096: NEG
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: LD_INT 1
67104: PUSH
67105: LD_INT 0
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 1
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PUSH
67136: LD_INT 0
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 1
67145: NEG
67146: PUSH
67147: LD_INT 1
67149: NEG
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 1
67157: NEG
67158: PUSH
67159: LD_INT 2
67161: NEG
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 2
67172: NEG
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: LD_INT 1
67183: NEG
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 2
67201: PUSH
67202: LD_INT 1
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 1
67211: PUSH
67212: LD_INT 2
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: LD_INT 2
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: PUSH
67240: LD_INT 2
67242: NEG
67243: PUSH
67244: LD_INT 1
67246: NEG
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: NEG
67255: PUSH
67256: LD_INT 2
67258: NEG
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 2
67266: NEG
67267: PUSH
67268: LD_INT 3
67270: NEG
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: LD_INT 1
67281: NEG
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 3
67289: PUSH
67290: LD_INT 1
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 1
67299: PUSH
67300: LD_INT 3
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 1
67309: NEG
67310: PUSH
67311: LD_INT 2
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 3
67320: NEG
67321: PUSH
67322: LD_INT 2
67324: NEG
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67355: LD_ADDR_VAR 0 30
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 0
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 0
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 1
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 0
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 1
67413: NEG
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 1
67424: NEG
67425: PUSH
67426: LD_INT 1
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 1
67436: NEG
67437: PUSH
67438: LD_INT 2
67440: NEG
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 0
67448: PUSH
67449: LD_INT 2
67451: NEG
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 1
67459: PUSH
67460: LD_INT 1
67462: NEG
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PUSH
67468: LD_INT 2
67470: PUSH
67471: LD_INT 0
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 2
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 2
67490: PUSH
67491: LD_INT 2
67493: PUSH
67494: EMPTY
67495: LIST
67496: LIST
67497: PUSH
67498: LD_INT 1
67500: PUSH
67501: LD_INT 2
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PUSH
67508: LD_INT 1
67510: NEG
67511: PUSH
67512: LD_INT 1
67514: PUSH
67515: EMPTY
67516: LIST
67517: LIST
67518: PUSH
67519: LD_INT 2
67521: NEG
67522: PUSH
67523: LD_INT 0
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 2
67532: NEG
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 3
67548: NEG
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: PUSH
67557: LD_INT 2
67559: NEG
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 3
67567: PUSH
67568: LD_INT 2
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 2
67577: PUSH
67578: LD_INT 3
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 2
67587: NEG
67588: PUSH
67589: LD_INT 1
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 3
67598: NEG
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67633: LD_ADDR_VAR 0 31
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 0
67650: PUSH
67651: LD_INT 1
67653: NEG
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 1
67661: PUSH
67662: LD_INT 0
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PUSH
67669: LD_INT 1
67671: PUSH
67672: LD_INT 1
67674: PUSH
67675: EMPTY
67676: LIST
67677: LIST
67678: PUSH
67679: LD_INT 0
67681: PUSH
67682: LD_INT 1
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 1
67691: NEG
67692: PUSH
67693: LD_INT 0
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: NEG
67703: PUSH
67704: LD_INT 1
67706: NEG
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 1
67714: NEG
67715: PUSH
67716: LD_INT 2
67718: NEG
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 1
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 2
67737: PUSH
67738: LD_INT 0
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 2
67747: PUSH
67748: LD_INT 1
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 2
67757: PUSH
67758: LD_INT 2
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: LD_INT 1
67767: PUSH
67768: LD_INT 2
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: PUSH
67775: LD_INT 0
67777: PUSH
67778: LD_INT 2
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: PUSH
67785: LD_INT 1
67787: NEG
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 2
67798: NEG
67799: PUSH
67800: LD_INT 1
67802: NEG
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PUSH
67808: LD_INT 2
67810: NEG
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 2
67822: NEG
67823: PUSH
67824: LD_INT 3
67826: NEG
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 2
67834: PUSH
67835: LD_INT 1
67837: NEG
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 3
67845: PUSH
67846: LD_INT 1
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: LD_INT 3
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 1
67865: NEG
67866: PUSH
67867: LD_INT 2
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 3
67876: NEG
67877: PUSH
67878: LD_INT 2
67880: NEG
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67911: LD_ADDR_VAR 0 32
67915: PUSH
67916: LD_INT 0
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 1
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 1
67949: PUSH
67950: LD_INT 1
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: EMPTY
67964: LIST
67965: LIST
67966: PUSH
67967: LD_INT 1
67969: NEG
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 1
67980: NEG
67981: PUSH
67982: LD_INT 1
67984: NEG
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 1
67992: NEG
67993: PUSH
67994: LD_INT 2
67996: NEG
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: LD_INT 2
68007: NEG
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: PUSH
68016: LD_INT 1
68018: NEG
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 2
68026: PUSH
68027: LD_INT 1
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 2
68036: PUSH
68037: LD_INT 2
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 2
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 0
68056: PUSH
68057: LD_INT 2
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: NEG
68067: PUSH
68068: LD_INT 1
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 2
68077: NEG
68078: PUSH
68079: LD_INT 0
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PUSH
68086: LD_INT 2
68088: NEG
68089: PUSH
68090: LD_INT 1
68092: NEG
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 1
68100: NEG
68101: PUSH
68102: LD_INT 3
68104: NEG
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 1
68112: PUSH
68113: LD_INT 2
68115: NEG
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 3
68123: PUSH
68124: LD_INT 2
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 2
68133: PUSH
68134: LD_INT 3
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 2
68143: NEG
68144: PUSH
68145: LD_INT 1
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 3
68154: NEG
68155: PUSH
68156: LD_INT 1
68158: NEG
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68189: LD_ADDR_VAR 0 33
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 0
68206: PUSH
68207: LD_INT 1
68209: NEG
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 1
68217: PUSH
68218: LD_INT 0
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 1
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PUSH
68235: LD_INT 0
68237: PUSH
68238: LD_INT 1
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 1
68247: NEG
68248: PUSH
68249: LD_INT 0
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 1
68258: NEG
68259: PUSH
68260: LD_INT 1
68262: NEG
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 1
68270: NEG
68271: PUSH
68272: LD_INT 2
68274: NEG
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: LD_INT 1
68285: NEG
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 2
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: PUSH
68304: LD_INT 1
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 1
68313: PUSH
68314: LD_INT 2
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 0
68323: PUSH
68324: LD_INT 2
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: NEG
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 2
68344: NEG
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 2
68355: NEG
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 2
68367: NEG
68368: PUSH
68369: LD_INT 2
68371: NEG
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 2
68379: NEG
68380: PUSH
68381: LD_INT 3
68383: NEG
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 2
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 3
68402: PUSH
68403: LD_INT 1
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 1
68412: PUSH
68413: LD_INT 3
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 1
68422: NEG
68423: PUSH
68424: LD_INT 2
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 3
68433: NEG
68434: PUSH
68435: LD_INT 2
68437: NEG
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68468: LD_ADDR_VAR 0 34
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 1
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 0
68516: PUSH
68517: LD_INT 1
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 1
68526: NEG
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 1
68537: NEG
68538: PUSH
68539: LD_INT 1
68541: NEG
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 1
68549: NEG
68550: PUSH
68551: LD_INT 2
68553: NEG
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 0
68561: PUSH
68562: LD_INT 2
68564: NEG
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: LD_INT 1
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 2
68583: PUSH
68584: LD_INT 1
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 2
68593: PUSH
68594: LD_INT 2
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 1
68613: NEG
68614: PUSH
68615: LD_INT 1
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 2
68624: NEG
68625: PUSH
68626: LD_INT 0
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 2
68635: NEG
68636: PUSH
68637: LD_INT 1
68639: NEG
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 2
68647: NEG
68648: PUSH
68649: LD_INT 2
68651: NEG
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 1
68659: NEG
68660: PUSH
68661: LD_INT 3
68663: NEG
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 1
68671: PUSH
68672: LD_INT 2
68674: NEG
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PUSH
68680: LD_INT 3
68682: PUSH
68683: LD_INT 2
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 2
68692: PUSH
68693: LD_INT 3
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 2
68702: NEG
68703: PUSH
68704: LD_INT 1
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: PUSH
68711: LD_INT 3
68713: NEG
68714: PUSH
68715: LD_INT 1
68717: NEG
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: LIST
68734: LIST
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68748: LD_ADDR_VAR 0 35
68752: PUSH
68753: LD_INT 0
68755: PUSH
68756: LD_INT 0
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 0
68765: PUSH
68766: LD_INT 1
68768: NEG
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: LD_INT 0
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 1
68786: PUSH
68787: LD_INT 1
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 0
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 1
68806: NEG
68807: PUSH
68808: LD_INT 0
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: LD_INT 1
68821: NEG
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 2
68829: PUSH
68830: LD_INT 1
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 2
68839: NEG
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68860: LD_ADDR_VAR 0 36
68864: PUSH
68865: LD_INT 0
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 0
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 1
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 1
68898: PUSH
68899: LD_INT 1
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 1
68918: NEG
68919: PUSH
68920: LD_INT 0
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 1
68929: NEG
68930: PUSH
68931: LD_INT 1
68933: NEG
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 2
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 2
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68972: LD_ADDR_VAR 0 37
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: LD_INT 0
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 0
68989: PUSH
68990: LD_INT 1
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 1
69010: PUSH
69011: LD_INT 1
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: LD_INT 1
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 1
69030: NEG
69031: PUSH
69032: LD_INT 0
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 1
69041: NEG
69042: PUSH
69043: LD_INT 1
69045: NEG
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: LD_INT 1
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 1
69064: NEG
69065: PUSH
69066: LD_INT 1
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69084: LD_ADDR_VAR 0 38
69088: PUSH
69089: LD_INT 0
69091: PUSH
69092: LD_INT 0
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 0
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: LD_INT 0
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: PUSH
69123: LD_INT 1
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 0
69132: PUSH
69133: LD_INT 1
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: LD_INT 0
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 1
69153: NEG
69154: PUSH
69155: LD_INT 1
69157: NEG
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 2
69165: PUSH
69166: LD_INT 1
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 2
69175: NEG
69176: PUSH
69177: LD_INT 1
69179: NEG
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69196: LD_ADDR_VAR 0 39
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: LD_INT 0
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 0
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 1
69224: PUSH
69225: LD_INT 0
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 1
69234: PUSH
69235: LD_INT 1
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 0
69244: PUSH
69245: LD_INT 1
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: LD_INT 0
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 1
69277: NEG
69278: PUSH
69279: LD_INT 2
69281: NEG
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 1
69289: PUSH
69290: LD_INT 2
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69308: LD_ADDR_VAR 0 40
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: LD_INT 0
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 0
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 1
69336: PUSH
69337: LD_INT 0
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: LD_INT 1
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: LD_INT 1
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: PUSH
69364: LD_INT 1
69366: NEG
69367: PUSH
69368: LD_INT 0
69370: PUSH
69371: EMPTY
69372: LIST
69373: LIST
69374: PUSH
69375: LD_INT 1
69377: NEG
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: LD_INT 1
69392: NEG
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: PUSH
69398: LD_INT 1
69400: NEG
69401: PUSH
69402: LD_INT 1
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69420: LD_ADDR_VAR 0 41
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: LD_INT 0
69437: PUSH
69438: LD_INT 1
69440: NEG
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 1
69448: PUSH
69449: LD_INT 0
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 1
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: LD_INT 1
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 1
69478: NEG
69479: PUSH
69480: LD_INT 0
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 1
69489: NEG
69490: PUSH
69491: LD_INT 1
69493: NEG
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: PUSH
69499: LD_INT 1
69501: NEG
69502: PUSH
69503: LD_INT 2
69505: NEG
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: PUSH
69522: LD_INT 2
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 2
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 2
69544: PUSH
69545: LD_INT 2
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: PUSH
69555: LD_INT 2
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: NEG
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 2
69575: NEG
69576: PUSH
69577: LD_INT 0
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 2
69586: NEG
69587: PUSH
69588: LD_INT 1
69590: NEG
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: NEG
69599: PUSH
69600: LD_INT 2
69602: NEG
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 3
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 3
69633: PUSH
69634: LD_INT 0
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 3
69643: PUSH
69644: LD_INT 1
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 3
69653: PUSH
69654: LD_INT 2
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 3
69663: PUSH
69664: LD_INT 3
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 2
69673: PUSH
69674: LD_INT 3
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 2
69683: NEG
69684: PUSH
69685: LD_INT 1
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: LD_INT 3
69694: NEG
69695: PUSH
69696: LD_INT 0
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 3
69705: NEG
69706: PUSH
69707: LD_INT 1
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 3
69717: NEG
69718: PUSH
69719: LD_INT 2
69721: NEG
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: LD_INT 3
69729: NEG
69730: PUSH
69731: LD_INT 3
69733: NEG
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69770: LD_ADDR_VAR 0 42
69774: PUSH
69775: LD_INT 0
69777: PUSH
69778: LD_INT 0
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 0
69787: PUSH
69788: LD_INT 1
69790: NEG
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: PUSH
69796: LD_INT 1
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: LD_INT 1
69808: PUSH
69809: LD_INT 1
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 0
69818: PUSH
69819: LD_INT 1
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 1
69828: NEG
69829: PUSH
69830: LD_INT 0
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 1
69839: NEG
69840: PUSH
69841: LD_INT 1
69843: NEG
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 1
69851: NEG
69852: PUSH
69853: LD_INT 2
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 0
69863: PUSH
69864: LD_INT 2
69866: NEG
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: LD_INT 1
69874: PUSH
69875: LD_INT 1
69877: NEG
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: LD_INT 2
69885: PUSH
69886: LD_INT 1
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 2
69895: PUSH
69896: LD_INT 2
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: LD_INT 2
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: LD_INT 2
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 1
69925: NEG
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 2
69936: NEG
69937: PUSH
69938: LD_INT 1
69940: NEG
69941: PUSH
69942: EMPTY
69943: LIST
69944: LIST
69945: PUSH
69946: LD_INT 2
69948: NEG
69949: PUSH
69950: LD_INT 2
69952: NEG
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: LD_INT 3
69964: NEG
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 1
69972: NEG
69973: PUSH
69974: LD_INT 3
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: LD_INT 3
69987: NEG
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: PUSH
69996: LD_INT 2
69998: NEG
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 3
70006: PUSH
70007: LD_INT 2
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 3
70016: PUSH
70017: LD_INT 3
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 2
70026: PUSH
70027: LD_INT 3
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: PUSH
70037: LD_INT 3
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: LD_INT 3
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 1
70056: NEG
70057: PUSH
70058: LD_INT 2
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 3
70067: NEG
70068: PUSH
70069: LD_INT 2
70071: NEG
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 3
70079: NEG
70080: PUSH
70081: LD_INT 3
70083: NEG
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: LIST
70109: LIST
70110: LIST
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: LIST
70119: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70120: LD_ADDR_VAR 0 43
70124: PUSH
70125: LD_INT 0
70127: PUSH
70128: LD_INT 0
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 0
70137: PUSH
70138: LD_INT 1
70140: NEG
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: LD_INT 1
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 0
70168: PUSH
70169: LD_INT 1
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 1
70178: NEG
70179: PUSH
70180: LD_INT 0
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 1
70189: NEG
70190: PUSH
70191: LD_INT 1
70193: NEG
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 1
70201: NEG
70202: PUSH
70203: LD_INT 2
70205: NEG
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 2
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 2
70245: PUSH
70246: LD_INT 1
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: LD_INT 2
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: LD_INT 2
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 1
70275: NEG
70276: PUSH
70277: LD_INT 1
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 2
70286: NEG
70287: PUSH
70288: LD_INT 0
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 2
70297: NEG
70298: PUSH
70299: LD_INT 1
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: LD_INT 1
70309: NEG
70310: PUSH
70311: LD_INT 3
70313: NEG
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: LD_INT 3
70324: NEG
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 1
70332: PUSH
70333: LD_INT 2
70335: NEG
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 2
70343: PUSH
70344: LD_INT 1
70346: NEG
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: LD_INT 3
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 3
70364: PUSH
70365: LD_INT 1
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: LD_INT 3
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 0
70384: PUSH
70385: LD_INT 3
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 2
70405: NEG
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 3
70416: NEG
70417: PUSH
70418: LD_INT 0
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 3
70427: NEG
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: LIST
70457: LIST
70458: LIST
70459: LIST
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70468: LD_ADDR_VAR 0 44
70472: PUSH
70473: LD_INT 0
70475: PUSH
70476: LD_INT 0
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 0
70485: PUSH
70486: LD_INT 1
70488: NEG
70489: PUSH
70490: EMPTY
70491: LIST
70492: LIST
70493: PUSH
70494: LD_INT 1
70496: PUSH
70497: LD_INT 0
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PUSH
70504: LD_INT 1
70506: PUSH
70507: LD_INT 1
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: LD_INT 1
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: NEG
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: NEG
70538: PUSH
70539: LD_INT 1
70541: NEG
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 1
70549: NEG
70550: PUSH
70551: LD_INT 2
70553: NEG
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: LD_INT 1
70564: NEG
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 2
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 2
70582: PUSH
70583: LD_INT 1
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 2
70592: PUSH
70593: LD_INT 2
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 1
70602: PUSH
70603: LD_INT 2
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: LD_INT 1
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 2
70623: NEG
70624: PUSH
70625: LD_INT 0
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 2
70634: NEG
70635: PUSH
70636: LD_INT 1
70638: NEG
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: NEG
70647: PUSH
70648: LD_INT 2
70650: NEG
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 2
70658: NEG
70659: PUSH
70660: LD_INT 3
70662: NEG
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 2
70670: PUSH
70671: LD_INT 1
70673: NEG
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 3
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 3
70691: PUSH
70692: LD_INT 1
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 3
70701: PUSH
70702: LD_INT 2
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 3
70711: PUSH
70712: LD_INT 3
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 2
70721: PUSH
70722: LD_INT 3
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 2
70731: NEG
70732: PUSH
70733: LD_INT 1
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 3
70742: NEG
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 3
70753: NEG
70754: PUSH
70755: LD_INT 1
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 3
70765: NEG
70766: PUSH
70767: LD_INT 2
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 3
70777: NEG
70778: PUSH
70779: LD_INT 3
70781: NEG
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70818: LD_ADDR_VAR 0 45
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: LD_INT 0
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: LD_INT 0
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 1
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 0
70866: PUSH
70867: LD_INT 1
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: LD_INT 0
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: LD_INT 1
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: LD_INT 2
70903: NEG
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 0
70911: PUSH
70912: LD_INT 2
70914: NEG
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: LD_INT 1
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 2
70933: PUSH
70934: LD_INT 1
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: LD_INT 2
70943: PUSH
70944: LD_INT 2
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: LD_INT 2
70956: PUSH
70957: EMPTY
70958: LIST
70959: LIST
70960: PUSH
70961: LD_INT 0
70963: PUSH
70964: LD_INT 2
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 1
70973: NEG
70974: PUSH
70975: LD_INT 1
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: LD_INT 1
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 2
70996: NEG
70997: PUSH
70998: LD_INT 2
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 2
71008: NEG
71009: PUSH
71010: LD_INT 3
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 3
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 0
71032: PUSH
71033: LD_INT 3
71035: NEG
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 1
71043: PUSH
71044: LD_INT 2
71046: NEG
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 3
71054: PUSH
71055: LD_INT 2
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 3
71064: PUSH
71065: LD_INT 3
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 2
71074: PUSH
71075: LD_INT 3
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 1
71084: PUSH
71085: LD_INT 3
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 0
71094: PUSH
71095: LD_INT 3
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 1
71104: NEG
71105: PUSH
71106: LD_INT 2
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 3
71115: NEG
71116: PUSH
71117: LD_INT 2
71119: NEG
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 3
71127: NEG
71128: PUSH
71129: LD_INT 3
71131: NEG
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71168: LD_ADDR_VAR 0 46
71172: PUSH
71173: LD_INT 0
71175: PUSH
71176: LD_INT 0
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: LD_INT 0
71185: PUSH
71186: LD_INT 1
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 0
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: LD_INT 1
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 0
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: NEG
71227: PUSH
71228: LD_INT 0
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: NEG
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: EMPTY
71244: LIST
71245: LIST
71246: PUSH
71247: LD_INT 1
71249: NEG
71250: PUSH
71251: LD_INT 2
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 1
71272: PUSH
71273: LD_INT 1
71275: NEG
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: LD_INT 0
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 2
71293: PUSH
71294: LD_INT 1
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 2
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: LD_INT 1
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 2
71334: NEG
71335: PUSH
71336: LD_INT 0
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 2
71345: NEG
71346: PUSH
71347: LD_INT 1
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: LD_INT 3
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 0
71369: PUSH
71370: LD_INT 3
71372: NEG
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 1
71380: PUSH
71381: LD_INT 2
71383: NEG
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 2
71391: PUSH
71392: LD_INT 1
71394: NEG
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 3
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 3
71412: PUSH
71413: LD_INT 1
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: LD_INT 3
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 0
71432: PUSH
71433: LD_INT 3
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 1
71442: NEG
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PUSH
71451: LD_INT 2
71453: NEG
71454: PUSH
71455: LD_INT 1
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 3
71464: NEG
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 3
71475: NEG
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: LIST
71512: LIST
71513: LIST
71514: LIST
71515: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71516: LD_ADDR_VAR 0 47
71520: PUSH
71521: LD_INT 0
71523: PUSH
71524: LD_INT 0
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: LD_INT 1
71536: NEG
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 1
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PUSH
71552: LD_INT 1
71554: PUSH
71555: LD_INT 1
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: LD_INT 1
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 1
71574: NEG
71575: PUSH
71576: LD_INT 0
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: NEG
71586: PUSH
71587: LD_INT 1
71589: NEG
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 1
71597: NEG
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 0
71609: PUSH
71610: LD_INT 2
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 1
71620: PUSH
71621: LD_INT 1
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 2
71631: NEG
71632: PUSH
71633: LD_INT 1
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 2
71643: NEG
71644: PUSH
71645: LD_INT 2
71647: NEG
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71667: LD_ADDR_VAR 0 48
71671: PUSH
71672: LD_INT 0
71674: PUSH
71675: LD_INT 0
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 1
71687: NEG
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: LD_INT 0
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 1
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 0
71715: PUSH
71716: LD_INT 1
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 1
71725: NEG
71726: PUSH
71727: LD_INT 0
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 1
71736: NEG
71737: PUSH
71738: LD_INT 1
71740: NEG
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 1
71748: NEG
71749: PUSH
71750: LD_INT 2
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 0
71760: PUSH
71761: LD_INT 2
71763: NEG
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: LD_INT 1
71771: PUSH
71772: LD_INT 1
71774: NEG
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 2
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 2
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71814: LD_ADDR_VAR 0 49
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: LD_INT 0
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 0
71831: PUSH
71832: LD_INT 1
71834: NEG
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 1
71842: PUSH
71843: LD_INT 0
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: LD_INT 1
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 0
71862: PUSH
71863: LD_INT 1
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 1
71872: NEG
71873: PUSH
71874: LD_INT 0
71876: PUSH
71877: EMPTY
71878: LIST
71879: LIST
71880: PUSH
71881: LD_INT 1
71883: NEG
71884: PUSH
71885: LD_INT 1
71887: NEG
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 1
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: LD_INT 0
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 2
71926: PUSH
71927: LD_INT 2
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: LD_INT 2
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71958: LD_ADDR_VAR 0 50
71962: PUSH
71963: LD_INT 0
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 0
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 1
71986: PUSH
71987: LD_INT 0
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: PUSH
71997: LD_INT 1
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 0
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: NEG
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 2
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: PUSH
72050: LD_INT 2
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 1
72059: PUSH
72060: LD_INT 2
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 0
72069: PUSH
72070: LD_INT 2
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 1
72079: NEG
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72102: LD_ADDR_VAR 0 51
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: NEG
72172: PUSH
72173: LD_INT 1
72175: NEG
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 1
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: LD_INT 2
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: LD_INT 1
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 2
72214: NEG
72215: PUSH
72216: LD_INT 0
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 2
72225: NEG
72226: PUSH
72227: LD_INT 1
72229: NEG
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72249: LD_ADDR_VAR 0 52
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 1
72277: PUSH
72278: LD_INT 0
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: PUSH
72288: LD_INT 1
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 0
72297: PUSH
72298: LD_INT 1
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 1
72307: NEG
72308: PUSH
72309: LD_INT 0
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 1
72318: NEG
72319: PUSH
72320: LD_INT 1
72322: NEG
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 1
72330: NEG
72331: PUSH
72332: LD_INT 2
72334: NEG
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 1
72342: NEG
72343: PUSH
72344: LD_INT 1
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 2
72353: NEG
72354: PUSH
72355: LD_INT 0
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 2
72364: NEG
72365: PUSH
72366: LD_INT 1
72368: NEG
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 2
72376: NEG
72377: PUSH
72378: LD_INT 2
72380: NEG
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72400: LD_ADDR_VAR 0 53
72404: PUSH
72405: LD_INT 0
72407: PUSH
72408: LD_INT 0
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 0
72417: PUSH
72418: LD_INT 1
72420: NEG
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 1
72438: PUSH
72439: LD_INT 1
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 0
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 1
72458: NEG
72459: PUSH
72460: LD_INT 0
72462: PUSH
72463: EMPTY
72464: LIST
72465: LIST
72466: PUSH
72467: LD_INT 1
72469: NEG
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: EMPTY
72476: LIST
72477: LIST
72478: PUSH
72479: LD_INT 1
72481: NEG
72482: PUSH
72483: LD_INT 2
72485: NEG
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 0
72493: PUSH
72494: LD_INT 2
72496: NEG
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 1
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 2
72515: PUSH
72516: LD_INT 0
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 2
72525: PUSH
72526: LD_INT 1
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 2
72535: PUSH
72536: LD_INT 2
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: LD_INT 2
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: LD_INT 2
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 2
72576: NEG
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 2
72587: NEG
72588: PUSH
72589: LD_INT 1
72591: NEG
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PUSH
72597: LD_INT 2
72599: NEG
72600: PUSH
72601: LD_INT 2
72603: NEG
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72630: LD_ADDR_VAR 0 54
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: LD_INT 0
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 0
72647: PUSH
72648: LD_INT 1
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 1
72658: PUSH
72659: LD_INT 0
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 1
72688: NEG
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: LD_INT 1
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 1
72711: NEG
72712: PUSH
72713: LD_INT 2
72715: NEG
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: LD_INT 2
72726: NEG
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 2
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 2
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 2
72765: PUSH
72766: LD_INT 2
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: LD_INT 2
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: LD_INT 2
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 1
72795: NEG
72796: PUSH
72797: LD_INT 1
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 2
72806: NEG
72807: PUSH
72808: LD_INT 0
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: NEG
72818: PUSH
72819: LD_INT 1
72821: NEG
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 2
72829: NEG
72830: PUSH
72831: LD_INT 2
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: LIST
72852: LIST
72853: LIST
72854: LIST
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72860: LD_ADDR_VAR 0 55
72864: PUSH
72865: LD_INT 0
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: LD_INT 1
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 0
72908: PUSH
72909: LD_INT 1
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: NEG
72919: PUSH
72920: LD_INT 0
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 1
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: NEG
72942: PUSH
72943: LD_INT 2
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 0
72953: PUSH
72954: LD_INT 2
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 1
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 2
72975: PUSH
72976: LD_INT 0
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 2
72985: PUSH
72986: LD_INT 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 2
72995: PUSH
72996: LD_INT 2
72998: PUSH
72999: EMPTY
73000: LIST
73001: LIST
73002: PUSH
73003: LD_INT 1
73005: PUSH
73006: LD_INT 2
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: LD_INT 2
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 1
73025: NEG
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 2
73036: NEG
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: NEG
73048: PUSH
73049: LD_INT 1
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 2
73059: NEG
73060: PUSH
73061: LD_INT 2
73063: NEG
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: LIST
73088: LIST
73089: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73090: LD_ADDR_VAR 0 56
73094: PUSH
73095: LD_INT 0
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 0
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 1
73118: PUSH
73119: LD_INT 0
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: LD_INT 1
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 0
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 1
73148: NEG
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: LD_INT 1
73163: NEG
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 1
73171: NEG
73172: PUSH
73173: LD_INT 2
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 0
73183: PUSH
73184: LD_INT 2
73186: NEG
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 1
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 2
73205: PUSH
73206: LD_INT 0
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 2
73215: PUSH
73216: LD_INT 1
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 2
73225: PUSH
73226: LD_INT 2
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: LD_INT 2
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: LD_INT 2
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 2
73266: NEG
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: LD_INT 1
73281: NEG
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: LD_INT 2
73289: NEG
73290: PUSH
73291: LD_INT 2
73293: NEG
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: LIST
73310: LIST
73311: LIST
73312: LIST
73313: LIST
73314: LIST
73315: LIST
73316: LIST
73317: LIST
73318: LIST
73319: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73320: LD_ADDR_VAR 0 57
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 0
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 1
73348: PUSH
73349: LD_INT 0
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: LD_INT 1
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: LD_INT 1
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: NEG
73379: PUSH
73380: LD_INT 0
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 1
73389: NEG
73390: PUSH
73391: LD_INT 1
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: NEG
73402: PUSH
73403: LD_INT 2
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 0
73413: PUSH
73414: LD_INT 2
73416: NEG
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: LD_INT 1
73427: NEG
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 0
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 2
73445: PUSH
73446: LD_INT 1
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 2
73455: PUSH
73456: LD_INT 2
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: LD_INT 2
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: LD_INT 2
73478: PUSH
73479: EMPTY
73480: LIST
73481: LIST
73482: PUSH
73483: LD_INT 1
73485: NEG
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 2
73496: NEG
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: LD_INT 1
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 2
73519: NEG
73520: PUSH
73521: LD_INT 2
73523: NEG
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73550: LD_ADDR_VAR 0 58
73554: PUSH
73555: LD_INT 0
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 0
73567: PUSH
73568: LD_INT 1
73570: NEG
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: LD_INT 0
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: LD_INT 1
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: LD_INT 1
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: NEG
73609: PUSH
73610: LD_INT 0
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 1
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: NEG
73632: PUSH
73633: LD_INT 2
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 0
73643: PUSH
73644: LD_INT 2
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: LD_INT 1
73657: NEG
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 2
73665: PUSH
73666: LD_INT 0
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 2
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 2
73685: PUSH
73686: LD_INT 2
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: LD_INT 2
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: LD_INT 2
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: NEG
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: NEG
73738: PUSH
73739: LD_INT 1
73741: NEG
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73780: LD_ADDR_VAR 0 59
73784: PUSH
73785: LD_INT 0
73787: PUSH
73788: LD_INT 0
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PUSH
73795: LD_INT 0
73797: PUSH
73798: LD_INT 1
73800: NEG
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: PUSH
73809: LD_INT 0
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 0
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 1
73838: NEG
73839: PUSH
73840: LD_INT 0
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 1
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73868: LD_ADDR_VAR 0 60
73872: PUSH
73873: LD_INT 0
73875: PUSH
73876: LD_INT 0
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: LD_INT 0
73885: PUSH
73886: LD_INT 1
73888: NEG
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: LD_INT 0
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 1
73906: PUSH
73907: LD_INT 1
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: LD_INT 1
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 1
73926: NEG
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: NEG
73938: PUSH
73939: LD_INT 1
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73956: LD_ADDR_VAR 0 61
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: LD_INT 0
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 0
73973: PUSH
73974: LD_INT 1
73976: NEG
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 1
73984: PUSH
73985: LD_INT 0
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: LD_INT 1
73994: PUSH
73995: LD_INT 1
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 1
74014: NEG
74015: PUSH
74016: LD_INT 0
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 1
74025: NEG
74026: PUSH
74027: LD_INT 1
74029: NEG
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74044: LD_ADDR_VAR 0 62
74048: PUSH
74049: LD_INT 0
74051: PUSH
74052: LD_INT 0
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PUSH
74059: LD_INT 0
74061: PUSH
74062: LD_INT 1
74064: NEG
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 1
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 1
74082: PUSH
74083: LD_INT 1
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: LD_INT 1
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 1
74102: NEG
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: NEG
74114: PUSH
74115: LD_INT 1
74117: NEG
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74132: LD_ADDR_VAR 0 63
74136: PUSH
74137: LD_INT 0
74139: PUSH
74140: LD_INT 0
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 0
74149: PUSH
74150: LD_INT 1
74152: NEG
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PUSH
74158: LD_INT 1
74160: PUSH
74161: LD_INT 0
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 1
74170: PUSH
74171: LD_INT 1
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: LD_INT 0
74180: PUSH
74181: LD_INT 1
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 1
74190: NEG
74191: PUSH
74192: LD_INT 0
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: LD_INT 1
74201: NEG
74202: PUSH
74203: LD_INT 1
74205: NEG
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74220: LD_ADDR_VAR 0 64
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 0
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 1
74248: PUSH
74249: LD_INT 0
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 1
74258: PUSH
74259: LD_INT 1
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 0
74268: PUSH
74269: LD_INT 1
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 1
74278: NEG
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 1
74289: NEG
74290: PUSH
74291: LD_INT 1
74293: NEG
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: ST_TO_ADDR
// end ; 1 :
74308: GO 80205
74310: LD_INT 1
74312: DOUBLE
74313: EQUAL
74314: IFTRUE 74318
74316: GO 76941
74318: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74319: LD_ADDR_VAR 0 11
74323: PUSH
74324: LD_INT 1
74326: NEG
74327: PUSH
74328: LD_INT 3
74330: NEG
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 0
74338: PUSH
74339: LD_INT 3
74341: NEG
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: LD_INT 2
74352: NEG
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: LIST
74362: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74363: LD_ADDR_VAR 0 12
74367: PUSH
74368: LD_INT 2
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 3
74381: PUSH
74382: LD_INT 0
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 3
74391: PUSH
74392: LD_INT 1
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: LIST
74403: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74404: LD_ADDR_VAR 0 13
74408: PUSH
74409: LD_INT 3
74411: PUSH
74412: LD_INT 2
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 3
74421: PUSH
74422: LD_INT 3
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 2
74431: PUSH
74432: LD_INT 3
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: LIST
74443: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74444: LD_ADDR_VAR 0 14
74448: PUSH
74449: LD_INT 1
74451: PUSH
74452: LD_INT 3
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: PUSH
74459: LD_INT 0
74461: PUSH
74462: LD_INT 3
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 1
74471: NEG
74472: PUSH
74473: LD_INT 2
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: LIST
74484: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74485: LD_ADDR_VAR 0 15
74489: PUSH
74490: LD_INT 2
74492: NEG
74493: PUSH
74494: LD_INT 1
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 3
74503: NEG
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 3
74514: NEG
74515: PUSH
74516: LD_INT 1
74518: NEG
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: LIST
74528: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74529: LD_ADDR_VAR 0 16
74533: PUSH
74534: LD_INT 2
74536: NEG
74537: PUSH
74538: LD_INT 3
74540: NEG
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 3
74548: NEG
74549: PUSH
74550: LD_INT 2
74552: NEG
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 3
74560: NEG
74561: PUSH
74562: LD_INT 3
74564: NEG
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: LIST
74574: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74575: LD_ADDR_VAR 0 17
74579: PUSH
74580: LD_INT 1
74582: NEG
74583: PUSH
74584: LD_INT 3
74586: NEG
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 0
74594: PUSH
74595: LD_INT 3
74597: NEG
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 1
74605: PUSH
74606: LD_INT 2
74608: NEG
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: LIST
74618: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74619: LD_ADDR_VAR 0 18
74623: PUSH
74624: LD_INT 2
74626: PUSH
74627: LD_INT 1
74629: NEG
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 3
74637: PUSH
74638: LD_INT 0
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 3
74647: PUSH
74648: LD_INT 1
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: LIST
74659: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74660: LD_ADDR_VAR 0 19
74664: PUSH
74665: LD_INT 3
74667: PUSH
74668: LD_INT 2
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: PUSH
74675: LD_INT 3
74677: PUSH
74678: LD_INT 3
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 2
74687: PUSH
74688: LD_INT 3
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: LIST
74699: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74700: LD_ADDR_VAR 0 20
74704: PUSH
74705: LD_INT 1
74707: PUSH
74708: LD_INT 3
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 0
74717: PUSH
74718: LD_INT 3
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 1
74727: NEG
74728: PUSH
74729: LD_INT 2
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74741: LD_ADDR_VAR 0 21
74745: PUSH
74746: LD_INT 2
74748: NEG
74749: PUSH
74750: LD_INT 1
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 3
74759: NEG
74760: PUSH
74761: LD_INT 0
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 3
74770: NEG
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: LIST
74784: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74785: LD_ADDR_VAR 0 22
74789: PUSH
74790: LD_INT 2
74792: NEG
74793: PUSH
74794: LD_INT 3
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 3
74804: NEG
74805: PUSH
74806: LD_INT 2
74808: NEG
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 3
74816: NEG
74817: PUSH
74818: LD_INT 3
74820: NEG
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: LIST
74830: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74831: LD_ADDR_VAR 0 23
74835: PUSH
74836: LD_INT 0
74838: PUSH
74839: LD_INT 3
74841: NEG
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 1
74849: NEG
74850: PUSH
74851: LD_INT 4
74853: NEG
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 1
74861: PUSH
74862: LD_INT 3
74864: NEG
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: LIST
74874: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74875: LD_ADDR_VAR 0 24
74879: PUSH
74880: LD_INT 3
74882: PUSH
74883: LD_INT 0
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 3
74892: PUSH
74893: LD_INT 1
74895: NEG
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 4
74903: PUSH
74904: LD_INT 1
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: LIST
74915: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74916: LD_ADDR_VAR 0 25
74920: PUSH
74921: LD_INT 3
74923: PUSH
74924: LD_INT 3
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: LD_INT 4
74933: PUSH
74934: LD_INT 3
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 3
74943: PUSH
74944: LD_INT 4
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: LIST
74955: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74956: LD_ADDR_VAR 0 26
74960: PUSH
74961: LD_INT 0
74963: PUSH
74964: LD_INT 3
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 1
74973: PUSH
74974: LD_INT 4
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 1
74983: NEG
74984: PUSH
74985: LD_INT 3
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: LIST
74996: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74997: LD_ADDR_VAR 0 27
75001: PUSH
75002: LD_INT 3
75004: NEG
75005: PUSH
75006: LD_INT 0
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: PUSH
75013: LD_INT 3
75015: NEG
75016: PUSH
75017: LD_INT 1
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 4
75026: NEG
75027: PUSH
75028: LD_INT 1
75030: NEG
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: LIST
75040: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75041: LD_ADDR_VAR 0 28
75045: PUSH
75046: LD_INT 3
75048: NEG
75049: PUSH
75050: LD_INT 3
75052: NEG
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 3
75060: NEG
75061: PUSH
75062: LD_INT 4
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 4
75072: NEG
75073: PUSH
75074: LD_INT 3
75076: NEG
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: EMPTY
75083: LIST
75084: LIST
75085: LIST
75086: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75087: LD_ADDR_VAR 0 29
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: LD_INT 3
75098: NEG
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 0
75106: PUSH
75107: LD_INT 3
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 1
75117: PUSH
75118: LD_INT 2
75120: NEG
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 1
75128: NEG
75129: PUSH
75130: LD_INT 4
75132: NEG
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 0
75140: PUSH
75141: LD_INT 4
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 1
75151: PUSH
75152: LD_INT 3
75154: NEG
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 1
75162: NEG
75163: PUSH
75164: LD_INT 5
75166: NEG
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 0
75174: PUSH
75175: LD_INT 5
75177: NEG
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 1
75185: PUSH
75186: LD_INT 4
75188: NEG
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 1
75196: NEG
75197: PUSH
75198: LD_INT 6
75200: NEG
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: LD_INT 6
75211: NEG
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: PUSH
75217: LD_INT 1
75219: PUSH
75220: LD_INT 5
75222: NEG
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: LIST
75232: LIST
75233: LIST
75234: LIST
75235: LIST
75236: LIST
75237: LIST
75238: LIST
75239: LIST
75240: LIST
75241: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75242: LD_ADDR_VAR 0 30
75246: PUSH
75247: LD_INT 2
75249: PUSH
75250: LD_INT 1
75252: NEG
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 3
75260: PUSH
75261: LD_INT 0
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 3
75270: PUSH
75271: LD_INT 1
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 3
75280: PUSH
75281: LD_INT 1
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 4
75291: PUSH
75292: LD_INT 0
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 4
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 4
75311: PUSH
75312: LD_INT 1
75314: NEG
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 5
75322: PUSH
75323: LD_INT 0
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 5
75332: PUSH
75333: LD_INT 1
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 5
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 6
75353: PUSH
75354: LD_INT 0
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 6
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75385: LD_ADDR_VAR 0 31
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: LD_INT 2
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 3
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: LD_INT 3
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 4
75422: PUSH
75423: LD_INT 3
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 4
75432: PUSH
75433: LD_INT 4
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 3
75442: PUSH
75443: LD_INT 4
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 5
75452: PUSH
75453: LD_INT 4
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 5
75462: PUSH
75463: LD_INT 5
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 4
75472: PUSH
75473: LD_INT 5
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: PUSH
75480: LD_INT 6
75482: PUSH
75483: LD_INT 5
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 6
75492: PUSH
75493: LD_INT 6
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: PUSH
75500: LD_INT 5
75502: PUSH
75503: LD_INT 6
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: LIST
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75524: LD_ADDR_VAR 0 32
75528: PUSH
75529: LD_INT 1
75531: PUSH
75532: LD_INT 3
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 0
75541: PUSH
75542: LD_INT 3
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 1
75551: NEG
75552: PUSH
75553: LD_INT 2
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 1
75562: PUSH
75563: LD_INT 4
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 0
75572: PUSH
75573: LD_INT 4
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 1
75582: NEG
75583: PUSH
75584: LD_INT 3
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 1
75593: PUSH
75594: LD_INT 5
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: LD_INT 5
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 1
75613: NEG
75614: PUSH
75615: LD_INT 4
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 1
75624: PUSH
75625: LD_INT 6
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 0
75634: PUSH
75635: LD_INT 6
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 1
75644: NEG
75645: PUSH
75646: LD_INT 5
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75667: LD_ADDR_VAR 0 33
75671: PUSH
75672: LD_INT 2
75674: NEG
75675: PUSH
75676: LD_INT 1
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 3
75685: NEG
75686: PUSH
75687: LD_INT 0
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 3
75696: NEG
75697: PUSH
75698: LD_INT 1
75700: NEG
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 3
75708: NEG
75709: PUSH
75710: LD_INT 1
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 4
75719: NEG
75720: PUSH
75721: LD_INT 0
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 4
75730: NEG
75731: PUSH
75732: LD_INT 1
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 4
75742: NEG
75743: PUSH
75744: LD_INT 1
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PUSH
75751: LD_INT 5
75753: NEG
75754: PUSH
75755: LD_INT 0
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 5
75764: NEG
75765: PUSH
75766: LD_INT 1
75768: NEG
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 5
75776: NEG
75777: PUSH
75778: LD_INT 1
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 6
75787: NEG
75788: PUSH
75789: LD_INT 0
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 6
75798: NEG
75799: PUSH
75800: LD_INT 1
75802: NEG
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: LIST
75820: LIST
75821: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75822: LD_ADDR_VAR 0 34
75826: PUSH
75827: LD_INT 2
75829: NEG
75830: PUSH
75831: LD_INT 3
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 3
75841: NEG
75842: PUSH
75843: LD_INT 2
75845: NEG
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 3
75853: NEG
75854: PUSH
75855: LD_INT 3
75857: NEG
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 3
75865: NEG
75866: PUSH
75867: LD_INT 4
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 4
75877: NEG
75878: PUSH
75879: LD_INT 3
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 4
75889: NEG
75890: PUSH
75891: LD_INT 4
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 4
75901: NEG
75902: PUSH
75903: LD_INT 5
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 5
75913: NEG
75914: PUSH
75915: LD_INT 4
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 5
75925: NEG
75926: PUSH
75927: LD_INT 5
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 5
75937: NEG
75938: PUSH
75939: LD_INT 6
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 6
75949: NEG
75950: PUSH
75951: LD_INT 5
75953: NEG
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 6
75961: NEG
75962: PUSH
75963: LD_INT 6
75965: NEG
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75985: LD_ADDR_VAR 0 41
75989: PUSH
75990: LD_INT 0
75992: PUSH
75993: LD_INT 2
75995: NEG
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 1
76003: NEG
76004: PUSH
76005: LD_INT 3
76007: NEG
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: LD_INT 2
76018: NEG
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: LIST
76028: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76029: LD_ADDR_VAR 0 42
76033: PUSH
76034: LD_INT 2
76036: PUSH
76037: LD_INT 0
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 2
76046: PUSH
76047: LD_INT 1
76049: NEG
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 3
76057: PUSH
76058: LD_INT 1
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: LIST
76069: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76070: LD_ADDR_VAR 0 43
76074: PUSH
76075: LD_INT 2
76077: PUSH
76078: LD_INT 2
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 3
76087: PUSH
76088: LD_INT 2
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 2
76097: PUSH
76098: LD_INT 3
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: LIST
76109: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76110: LD_ADDR_VAR 0 44
76114: PUSH
76115: LD_INT 0
76117: PUSH
76118: LD_INT 2
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 1
76127: PUSH
76128: LD_INT 3
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 1
76137: NEG
76138: PUSH
76139: LD_INT 2
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: LIST
76150: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76151: LD_ADDR_VAR 0 45
76155: PUSH
76156: LD_INT 2
76158: NEG
76159: PUSH
76160: LD_INT 0
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 2
76169: NEG
76170: PUSH
76171: LD_INT 1
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 3
76180: NEG
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: LIST
76194: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76195: LD_ADDR_VAR 0 46
76199: PUSH
76200: LD_INT 2
76202: NEG
76203: PUSH
76204: LD_INT 2
76206: NEG
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PUSH
76212: LD_INT 2
76214: NEG
76215: PUSH
76216: LD_INT 3
76218: NEG
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 3
76226: NEG
76227: PUSH
76228: LD_INT 2
76230: NEG
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: LIST
76240: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76241: LD_ADDR_VAR 0 47
76245: PUSH
76246: LD_INT 2
76248: NEG
76249: PUSH
76250: LD_INT 3
76252: NEG
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 1
76260: NEG
76261: PUSH
76262: LD_INT 3
76264: NEG
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76274: LD_ADDR_VAR 0 48
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: LD_INT 2
76284: NEG
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 2
76292: PUSH
76293: LD_INT 1
76295: NEG
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76305: LD_ADDR_VAR 0 49
76309: PUSH
76310: LD_INT 3
76312: PUSH
76313: LD_INT 1
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 3
76322: PUSH
76323: LD_INT 2
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76334: LD_ADDR_VAR 0 50
76338: PUSH
76339: LD_INT 2
76341: PUSH
76342: LD_INT 3
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 1
76351: PUSH
76352: LD_INT 3
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76363: LD_ADDR_VAR 0 51
76367: PUSH
76368: LD_INT 1
76370: NEG
76371: PUSH
76372: LD_INT 2
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 2
76381: NEG
76382: PUSH
76383: LD_INT 1
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76394: LD_ADDR_VAR 0 52
76398: PUSH
76399: LD_INT 3
76401: NEG
76402: PUSH
76403: LD_INT 1
76405: NEG
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 3
76413: NEG
76414: PUSH
76415: LD_INT 2
76417: NEG
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76427: LD_ADDR_VAR 0 53
76431: PUSH
76432: LD_INT 1
76434: NEG
76435: PUSH
76436: LD_INT 3
76438: NEG
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 0
76446: PUSH
76447: LD_INT 3
76449: NEG
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 1
76457: PUSH
76458: LD_INT 2
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: LIST
76470: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76471: LD_ADDR_VAR 0 54
76475: PUSH
76476: LD_INT 2
76478: PUSH
76479: LD_INT 1
76481: NEG
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 3
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 3
76499: PUSH
76500: LD_INT 1
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: LIST
76511: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76512: LD_ADDR_VAR 0 55
76516: PUSH
76517: LD_INT 3
76519: PUSH
76520: LD_INT 2
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 3
76529: PUSH
76530: LD_INT 3
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: PUSH
76537: LD_INT 2
76539: PUSH
76540: LD_INT 3
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: LIST
76551: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76552: LD_ADDR_VAR 0 56
76556: PUSH
76557: LD_INT 1
76559: PUSH
76560: LD_INT 3
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 0
76569: PUSH
76570: LD_INT 3
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 1
76579: NEG
76580: PUSH
76581: LD_INT 2
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: LIST
76592: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76593: LD_ADDR_VAR 0 57
76597: PUSH
76598: LD_INT 2
76600: NEG
76601: PUSH
76602: LD_INT 1
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 3
76611: NEG
76612: PUSH
76613: LD_INT 0
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 3
76622: NEG
76623: PUSH
76624: LD_INT 1
76626: NEG
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: LIST
76636: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76637: LD_ADDR_VAR 0 58
76641: PUSH
76642: LD_INT 2
76644: NEG
76645: PUSH
76646: LD_INT 3
76648: NEG
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 3
76656: NEG
76657: PUSH
76658: LD_INT 2
76660: NEG
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 3
76668: NEG
76669: PUSH
76670: LD_INT 3
76672: NEG
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: LIST
76682: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76683: LD_ADDR_VAR 0 59
76687: PUSH
76688: LD_INT 1
76690: NEG
76691: PUSH
76692: LD_INT 2
76694: NEG
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 0
76702: PUSH
76703: LD_INT 2
76705: NEG
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 1
76713: PUSH
76714: LD_INT 1
76716: NEG
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: LIST
76726: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76727: LD_ADDR_VAR 0 60
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: LD_INT 1
76737: NEG
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 2
76745: PUSH
76746: LD_INT 0
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 2
76755: PUSH
76756: LD_INT 1
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: LIST
76767: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76768: LD_ADDR_VAR 0 61
76772: PUSH
76773: LD_INT 2
76775: PUSH
76776: LD_INT 1
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 2
76785: PUSH
76786: LD_INT 2
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 1
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: LIST
76807: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76808: LD_ADDR_VAR 0 62
76812: PUSH
76813: LD_INT 1
76815: PUSH
76816: LD_INT 2
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 0
76825: PUSH
76826: LD_INT 2
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 1
76835: NEG
76836: PUSH
76837: LD_INT 1
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: LIST
76848: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76849: LD_ADDR_VAR 0 63
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: LD_INT 1
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: LD_INT 1
76882: NEG
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: LIST
76892: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76893: LD_ADDR_VAR 0 64
76897: PUSH
76898: LD_INT 1
76900: NEG
76901: PUSH
76902: LD_INT 2
76904: NEG
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: LD_INT 2
76912: NEG
76913: PUSH
76914: LD_INT 1
76916: NEG
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 2
76924: NEG
76925: PUSH
76926: LD_INT 2
76928: NEG
76929: PUSH
76930: EMPTY
76931: LIST
76932: LIST
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: LIST
76938: ST_TO_ADDR
// end ; 2 :
76939: GO 80205
76941: LD_INT 2
76943: DOUBLE
76944: EQUAL
76945: IFTRUE 76949
76947: GO 80204
76949: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76950: LD_ADDR_VAR 0 29
76954: PUSH
76955: LD_INT 4
76957: PUSH
76958: LD_INT 0
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: LD_INT 4
76967: PUSH
76968: LD_INT 1
76970: NEG
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: LD_INT 5
76978: PUSH
76979: LD_INT 0
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 5
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 4
76998: PUSH
76999: LD_INT 1
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 3
77008: PUSH
77009: LD_INT 0
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 3
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 3
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 5
77040: PUSH
77041: LD_INT 2
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 3
77050: PUSH
77051: LD_INT 3
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 3
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 4
77070: PUSH
77071: LD_INT 3
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 4
77080: PUSH
77081: LD_INT 4
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 3
77090: PUSH
77091: LD_INT 4
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 2
77100: PUSH
77101: LD_INT 3
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 2
77110: PUSH
77111: LD_INT 2
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 4
77120: PUSH
77121: LD_INT 2
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 2
77130: PUSH
77131: LD_INT 4
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 0
77140: PUSH
77141: LD_INT 4
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 0
77150: PUSH
77151: LD_INT 3
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 1
77160: PUSH
77161: LD_INT 4
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 1
77170: PUSH
77171: LD_INT 5
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 0
77180: PUSH
77181: LD_INT 5
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 1
77190: NEG
77191: PUSH
77192: LD_INT 4
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 1
77201: NEG
77202: PUSH
77203: LD_INT 3
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 2
77212: PUSH
77213: LD_INT 5
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 2
77222: NEG
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 3
77233: NEG
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 3
77244: NEG
77245: PUSH
77246: LD_INT 1
77248: NEG
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 2
77256: NEG
77257: PUSH
77258: LD_INT 0
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 2
77267: NEG
77268: PUSH
77269: LD_INT 1
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 3
77278: NEG
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 4
77289: NEG
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 4
77300: NEG
77301: PUSH
77302: LD_INT 1
77304: NEG
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: PUSH
77310: LD_INT 4
77312: NEG
77313: PUSH
77314: LD_INT 2
77316: NEG
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 2
77324: NEG
77325: PUSH
77326: LD_INT 2
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 4
77335: NEG
77336: PUSH
77337: LD_INT 4
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 4
77347: NEG
77348: PUSH
77349: LD_INT 5
77351: NEG
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 3
77359: NEG
77360: PUSH
77361: LD_INT 4
77363: NEG
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 3
77371: NEG
77372: PUSH
77373: LD_INT 3
77375: NEG
77376: PUSH
77377: EMPTY
77378: LIST
77379: LIST
77380: PUSH
77381: LD_INT 4
77383: NEG
77384: PUSH
77385: LD_INT 3
77387: NEG
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 5
77395: NEG
77396: PUSH
77397: LD_INT 4
77399: NEG
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 5
77407: NEG
77408: PUSH
77409: LD_INT 5
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 3
77419: NEG
77420: PUSH
77421: LD_INT 5
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 5
77431: NEG
77432: PUSH
77433: LD_INT 3
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: LIST
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77488: LD_ADDR_VAR 0 30
77492: PUSH
77493: LD_INT 4
77495: PUSH
77496: LD_INT 4
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 4
77505: PUSH
77506: LD_INT 3
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 5
77515: PUSH
77516: LD_INT 4
77518: PUSH
77519: EMPTY
77520: LIST
77521: LIST
77522: PUSH
77523: LD_INT 5
77525: PUSH
77526: LD_INT 5
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 4
77535: PUSH
77536: LD_INT 5
77538: PUSH
77539: EMPTY
77540: LIST
77541: LIST
77542: PUSH
77543: LD_INT 3
77545: PUSH
77546: LD_INT 4
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 3
77555: PUSH
77556: LD_INT 3
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 5
77565: PUSH
77566: LD_INT 3
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 3
77575: PUSH
77576: LD_INT 5
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: LD_INT 3
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: LD_INT 2
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 1
77605: PUSH
77606: LD_INT 3
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: LD_INT 1
77615: PUSH
77616: LD_INT 4
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 0
77625: PUSH
77626: LD_INT 4
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 1
77635: NEG
77636: PUSH
77637: LD_INT 3
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 1
77646: NEG
77647: PUSH
77648: LD_INT 2
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 2
77657: PUSH
77658: LD_INT 4
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 2
77667: NEG
77668: PUSH
77669: LD_INT 2
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 4
77678: NEG
77679: PUSH
77680: LD_INT 0
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 4
77689: NEG
77690: PUSH
77691: LD_INT 1
77693: NEG
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 3
77701: NEG
77702: PUSH
77703: LD_INT 0
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: LD_INT 3
77712: NEG
77713: PUSH
77714: LD_INT 1
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 4
77723: NEG
77724: PUSH
77725: LD_INT 1
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: LD_INT 5
77734: NEG
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 5
77745: NEG
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 5
77757: NEG
77758: PUSH
77759: LD_INT 2
77761: NEG
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 3
77769: NEG
77770: PUSH
77771: LD_INT 2
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 3
77780: NEG
77781: PUSH
77782: LD_INT 3
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 3
77792: NEG
77793: PUSH
77794: LD_INT 4
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 2
77804: NEG
77805: PUSH
77806: LD_INT 3
77808: NEG
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: PUSH
77814: LD_INT 2
77816: NEG
77817: PUSH
77818: LD_INT 2
77820: NEG
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 3
77828: NEG
77829: PUSH
77830: LD_INT 2
77832: NEG
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 4
77840: NEG
77841: PUSH
77842: LD_INT 3
77844: NEG
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 4
77852: NEG
77853: PUSH
77854: LD_INT 4
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 2
77864: NEG
77865: PUSH
77866: LD_INT 4
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 4
77876: NEG
77877: PUSH
77878: LD_INT 2
77880: NEG
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: LD_INT 4
77891: NEG
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 0
77899: PUSH
77900: LD_INT 5
77902: NEG
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 1
77910: PUSH
77911: LD_INT 4
77913: NEG
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 0
77932: PUSH
77933: LD_INT 3
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: LD_INT 4
77947: NEG
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 1
77955: NEG
77956: PUSH
77957: LD_INT 5
77959: NEG
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 3
77970: NEG
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 2
77978: NEG
77979: PUSH
77980: LD_INT 5
77982: NEG
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: EMPTY
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78035: LD_ADDR_VAR 0 31
78039: PUSH
78040: LD_INT 0
78042: PUSH
78043: LD_INT 4
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 0
78052: PUSH
78053: LD_INT 3
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 1
78062: PUSH
78063: LD_INT 4
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 1
78072: PUSH
78073: LD_INT 5
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 0
78082: PUSH
78083: LD_INT 5
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: NEG
78093: PUSH
78094: LD_INT 4
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 1
78103: NEG
78104: PUSH
78105: LD_INT 3
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 2
78114: PUSH
78115: LD_INT 5
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 2
78124: NEG
78125: PUSH
78126: LD_INT 3
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 3
78135: NEG
78136: PUSH
78137: LD_INT 0
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 3
78146: NEG
78147: PUSH
78148: LD_INT 1
78150: NEG
78151: PUSH
78152: EMPTY
78153: LIST
78154: LIST
78155: PUSH
78156: LD_INT 2
78158: NEG
78159: PUSH
78160: LD_INT 0
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 2
78169: NEG
78170: PUSH
78171: LD_INT 1
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PUSH
78178: LD_INT 3
78180: NEG
78181: PUSH
78182: LD_INT 1
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 4
78191: NEG
78192: PUSH
78193: LD_INT 0
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 4
78202: NEG
78203: PUSH
78204: LD_INT 1
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 4
78214: NEG
78215: PUSH
78216: LD_INT 2
78218: NEG
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 2
78226: NEG
78227: PUSH
78228: LD_INT 2
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 4
78237: NEG
78238: PUSH
78239: LD_INT 4
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 4
78249: NEG
78250: PUSH
78251: LD_INT 5
78253: NEG
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 3
78261: NEG
78262: PUSH
78263: LD_INT 4
78265: NEG
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 3
78273: NEG
78274: PUSH
78275: LD_INT 3
78277: NEG
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 4
78285: NEG
78286: PUSH
78287: LD_INT 3
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 5
78297: NEG
78298: PUSH
78299: LD_INT 4
78301: NEG
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 5
78309: NEG
78310: PUSH
78311: LD_INT 5
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 3
78321: NEG
78322: PUSH
78323: LD_INT 5
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 5
78333: NEG
78334: PUSH
78335: LD_INT 3
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: LD_INT 3
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 0
78356: PUSH
78357: LD_INT 4
78359: NEG
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: PUSH
78365: LD_INT 1
78367: PUSH
78368: LD_INT 3
78370: NEG
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 1
78378: PUSH
78379: LD_INT 2
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 0
78389: PUSH
78390: LD_INT 2
78392: NEG
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 1
78400: NEG
78401: PUSH
78402: LD_INT 3
78404: NEG
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 1
78412: NEG
78413: PUSH
78414: LD_INT 4
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 2
78424: PUSH
78425: LD_INT 2
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 2
78435: NEG
78436: PUSH
78437: LD_INT 4
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 4
78447: PUSH
78448: LD_INT 0
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 4
78457: PUSH
78458: LD_INT 1
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 5
78468: PUSH
78469: LD_INT 0
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 5
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 4
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 3
78498: PUSH
78499: LD_INT 0
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 3
78508: PUSH
78509: LD_INT 1
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 3
78519: PUSH
78520: LD_INT 2
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 5
78530: PUSH
78531: LD_INT 2
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: LIST
78562: LIST
78563: LIST
78564: LIST
78565: LIST
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78585: LD_ADDR_VAR 0 32
78589: PUSH
78590: LD_INT 4
78592: NEG
78593: PUSH
78594: LD_INT 0
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 4
78603: NEG
78604: PUSH
78605: LD_INT 1
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 3
78615: NEG
78616: PUSH
78617: LD_INT 0
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 3
78626: NEG
78627: PUSH
78628: LD_INT 1
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 4
78637: NEG
78638: PUSH
78639: LD_INT 1
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 5
78648: NEG
78649: PUSH
78650: LD_INT 0
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 5
78659: NEG
78660: PUSH
78661: LD_INT 1
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 5
78671: NEG
78672: PUSH
78673: LD_INT 2
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 3
78683: NEG
78684: PUSH
78685: LD_INT 2
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 3
78694: NEG
78695: PUSH
78696: LD_INT 3
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 3
78706: NEG
78707: PUSH
78708: LD_INT 4
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 2
78718: NEG
78719: PUSH
78720: LD_INT 3
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 2
78730: NEG
78731: PUSH
78732: LD_INT 2
78734: NEG
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 4
78754: NEG
78755: PUSH
78756: LD_INT 3
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: LD_INT 4
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 2
78778: NEG
78779: PUSH
78780: LD_INT 4
78782: NEG
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: LD_INT 2
78794: NEG
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 0
78802: PUSH
78803: LD_INT 4
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 0
78813: PUSH
78814: LD_INT 5
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 1
78824: PUSH
78825: LD_INT 4
78827: NEG
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 1
78835: PUSH
78836: LD_INT 3
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 0
78846: PUSH
78847: LD_INT 3
78849: NEG
78850: PUSH
78851: EMPTY
78852: LIST
78853: LIST
78854: PUSH
78855: LD_INT 1
78857: NEG
78858: PUSH
78859: LD_INT 4
78861: NEG
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 1
78869: NEG
78870: PUSH
78871: LD_INT 5
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 2
78881: PUSH
78882: LD_INT 3
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 2
78892: NEG
78893: PUSH
78894: LD_INT 5
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 3
78904: PUSH
78905: LD_INT 0
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 3
78914: PUSH
78915: LD_INT 1
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 4
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 4
78935: PUSH
78936: LD_INT 1
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 3
78945: PUSH
78946: LD_INT 1
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 2
78955: PUSH
78956: LD_INT 0
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 2
78965: PUSH
78966: LD_INT 1
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 2
78976: PUSH
78977: LD_INT 2
78979: NEG
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 4
78987: PUSH
78988: LD_INT 2
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 4
78997: PUSH
78998: LD_INT 4
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 4
79007: PUSH
79008: LD_INT 3
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 5
79017: PUSH
79018: LD_INT 4
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 5
79027: PUSH
79028: LD_INT 5
79030: PUSH
79031: EMPTY
79032: LIST
79033: LIST
79034: PUSH
79035: LD_INT 4
79037: PUSH
79038: LD_INT 5
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PUSH
79045: LD_INT 3
79047: PUSH
79048: LD_INT 4
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PUSH
79055: LD_INT 3
79057: PUSH
79058: LD_INT 3
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 5
79067: PUSH
79068: LD_INT 3
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 3
79077: PUSH
79078: LD_INT 5
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79132: LD_ADDR_VAR 0 33
79136: PUSH
79137: LD_INT 4
79139: NEG
79140: PUSH
79141: LD_INT 4
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 4
79151: NEG
79152: PUSH
79153: LD_INT 5
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: NEG
79164: PUSH
79165: LD_INT 4
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 3
79175: NEG
79176: PUSH
79177: LD_INT 3
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 4
79187: NEG
79188: PUSH
79189: LD_INT 3
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 5
79199: NEG
79200: PUSH
79201: LD_INT 4
79203: NEG
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 5
79211: NEG
79212: PUSH
79213: LD_INT 5
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 3
79223: NEG
79224: PUSH
79225: LD_INT 5
79227: NEG
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 5
79235: NEG
79236: PUSH
79237: LD_INT 3
79239: NEG
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 0
79247: PUSH
79248: LD_INT 3
79250: NEG
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: LD_INT 4
79261: NEG
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 1
79269: PUSH
79270: LD_INT 3
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: PUSH
79281: LD_INT 2
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 0
79291: PUSH
79292: LD_INT 2
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 1
79302: NEG
79303: PUSH
79304: LD_INT 3
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: LD_INT 4
79318: NEG
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 2
79326: PUSH
79327: LD_INT 2
79329: NEG
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 2
79337: NEG
79338: PUSH
79339: LD_INT 4
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 4
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 4
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 5
79370: PUSH
79371: LD_INT 0
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 5
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 4
79390: PUSH
79391: LD_INT 1
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 3
79400: PUSH
79401: LD_INT 0
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 3
79410: PUSH
79411: LD_INT 1
79413: NEG
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 3
79421: PUSH
79422: LD_INT 2
79424: NEG
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 5
79432: PUSH
79433: LD_INT 2
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 3
79442: PUSH
79443: LD_INT 3
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 3
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 4
79462: PUSH
79463: LD_INT 3
79465: PUSH
79466: EMPTY
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 4
79472: PUSH
79473: LD_INT 4
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 3
79482: PUSH
79483: LD_INT 4
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 2
79492: PUSH
79493: LD_INT 3
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 2
79502: PUSH
79503: LD_INT 2
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 4
79512: PUSH
79513: LD_INT 2
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 2
79522: PUSH
79523: LD_INT 4
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 0
79532: PUSH
79533: LD_INT 4
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 0
79542: PUSH
79543: LD_INT 3
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 1
79552: PUSH
79553: LD_INT 4
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: LD_INT 5
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 0
79572: PUSH
79573: LD_INT 5
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 1
79582: NEG
79583: PUSH
79584: LD_INT 4
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: LD_INT 3
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 2
79604: PUSH
79605: LD_INT 5
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 2
79614: NEG
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79670: LD_ADDR_VAR 0 34
79674: PUSH
79675: LD_INT 0
79677: PUSH
79678: LD_INT 4
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 0
79688: PUSH
79689: LD_INT 5
79691: NEG
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 1
79699: PUSH
79700: LD_INT 4
79702: NEG
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 1
79710: PUSH
79711: LD_INT 3
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 0
79721: PUSH
79722: LD_INT 3
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 1
79732: NEG
79733: PUSH
79734: LD_INT 4
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: NEG
79745: PUSH
79746: LD_INT 5
79748: NEG
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 2
79756: PUSH
79757: LD_INT 3
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 2
79767: NEG
79768: PUSH
79769: LD_INT 5
79771: NEG
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 3
79779: PUSH
79780: LD_INT 0
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: LD_INT 3
79789: PUSH
79790: LD_INT 1
79792: NEG
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 4
79800: PUSH
79801: LD_INT 0
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 4
79810: PUSH
79811: LD_INT 1
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 3
79820: PUSH
79821: LD_INT 1
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 2
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 2
79840: PUSH
79841: LD_INT 1
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 2
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 4
79862: PUSH
79863: LD_INT 2
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 4
79872: PUSH
79873: LD_INT 4
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 4
79882: PUSH
79883: LD_INT 3
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 5
79892: PUSH
79893: LD_INT 4
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 5
79902: PUSH
79903: LD_INT 5
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: LD_INT 4
79912: PUSH
79913: LD_INT 5
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 3
79922: PUSH
79923: LD_INT 4
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 3
79932: PUSH
79933: LD_INT 3
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 5
79942: PUSH
79943: LD_INT 3
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 3
79952: PUSH
79953: LD_INT 5
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: LD_INT 3
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: LD_INT 2
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 1
79982: PUSH
79983: LD_INT 3
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: LD_INT 4
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 0
80002: PUSH
80003: LD_INT 4
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: LD_INT 3
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 1
80023: NEG
80024: PUSH
80025: LD_INT 2
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 2
80034: PUSH
80035: LD_INT 4
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 2
80044: NEG
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 4
80055: NEG
80056: PUSH
80057: LD_INT 0
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 4
80066: NEG
80067: PUSH
80068: LD_INT 1
80070: NEG
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: LD_INT 3
80078: NEG
80079: PUSH
80080: LD_INT 0
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 3
80089: NEG
80090: PUSH
80091: LD_INT 1
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 4
80100: NEG
80101: PUSH
80102: LD_INT 1
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 5
80111: NEG
80112: PUSH
80113: LD_INT 0
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 5
80122: NEG
80123: PUSH
80124: LD_INT 1
80126: NEG
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 5
80134: NEG
80135: PUSH
80136: LD_INT 2
80138: NEG
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 3
80146: NEG
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: ST_TO_ADDR
// end ; end ;
80202: GO 80205
80204: POP
// case btype of b_depot , b_warehouse :
80205: LD_VAR 0 1
80209: PUSH
80210: LD_INT 0
80212: DOUBLE
80213: EQUAL
80214: IFTRUE 80224
80216: LD_INT 1
80218: DOUBLE
80219: EQUAL
80220: IFTRUE 80224
80222: GO 80425
80224: POP
// case nation of nation_american :
80225: LD_VAR 0 5
80229: PUSH
80230: LD_INT 1
80232: DOUBLE
80233: EQUAL
80234: IFTRUE 80238
80236: GO 80294
80238: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80239: LD_ADDR_VAR 0 9
80243: PUSH
80244: LD_VAR 0 11
80248: PUSH
80249: LD_VAR 0 12
80253: PUSH
80254: LD_VAR 0 13
80258: PUSH
80259: LD_VAR 0 14
80263: PUSH
80264: LD_VAR 0 15
80268: PUSH
80269: LD_VAR 0 16
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: PUSH
80282: LD_VAR 0 4
80286: PUSH
80287: LD_INT 1
80289: PLUS
80290: ARRAY
80291: ST_TO_ADDR
80292: GO 80423
80294: LD_INT 2
80296: DOUBLE
80297: EQUAL
80298: IFTRUE 80302
80300: GO 80358
80302: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80303: LD_ADDR_VAR 0 9
80307: PUSH
80308: LD_VAR 0 17
80312: PUSH
80313: LD_VAR 0 18
80317: PUSH
80318: LD_VAR 0 19
80322: PUSH
80323: LD_VAR 0 20
80327: PUSH
80328: LD_VAR 0 21
80332: PUSH
80333: LD_VAR 0 22
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: PUSH
80346: LD_VAR 0 4
80350: PUSH
80351: LD_INT 1
80353: PLUS
80354: ARRAY
80355: ST_TO_ADDR
80356: GO 80423
80358: LD_INT 3
80360: DOUBLE
80361: EQUAL
80362: IFTRUE 80366
80364: GO 80422
80366: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80367: LD_ADDR_VAR 0 9
80371: PUSH
80372: LD_VAR 0 23
80376: PUSH
80377: LD_VAR 0 24
80381: PUSH
80382: LD_VAR 0 25
80386: PUSH
80387: LD_VAR 0 26
80391: PUSH
80392: LD_VAR 0 27
80396: PUSH
80397: LD_VAR 0 28
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: PUSH
80410: LD_VAR 0 4
80414: PUSH
80415: LD_INT 1
80417: PLUS
80418: ARRAY
80419: ST_TO_ADDR
80420: GO 80423
80422: POP
80423: GO 80978
80425: LD_INT 2
80427: DOUBLE
80428: EQUAL
80429: IFTRUE 80439
80431: LD_INT 3
80433: DOUBLE
80434: EQUAL
80435: IFTRUE 80439
80437: GO 80495
80439: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80440: LD_ADDR_VAR 0 9
80444: PUSH
80445: LD_VAR 0 29
80449: PUSH
80450: LD_VAR 0 30
80454: PUSH
80455: LD_VAR 0 31
80459: PUSH
80460: LD_VAR 0 32
80464: PUSH
80465: LD_VAR 0 33
80469: PUSH
80470: LD_VAR 0 34
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: PUSH
80483: LD_VAR 0 4
80487: PUSH
80488: LD_INT 1
80490: PLUS
80491: ARRAY
80492: ST_TO_ADDR
80493: GO 80978
80495: LD_INT 16
80497: DOUBLE
80498: EQUAL
80499: IFTRUE 80557
80501: LD_INT 17
80503: DOUBLE
80504: EQUAL
80505: IFTRUE 80557
80507: LD_INT 18
80509: DOUBLE
80510: EQUAL
80511: IFTRUE 80557
80513: LD_INT 19
80515: DOUBLE
80516: EQUAL
80517: IFTRUE 80557
80519: LD_INT 22
80521: DOUBLE
80522: EQUAL
80523: IFTRUE 80557
80525: LD_INT 20
80527: DOUBLE
80528: EQUAL
80529: IFTRUE 80557
80531: LD_INT 21
80533: DOUBLE
80534: EQUAL
80535: IFTRUE 80557
80537: LD_INT 23
80539: DOUBLE
80540: EQUAL
80541: IFTRUE 80557
80543: LD_INT 24
80545: DOUBLE
80546: EQUAL
80547: IFTRUE 80557
80549: LD_INT 25
80551: DOUBLE
80552: EQUAL
80553: IFTRUE 80557
80555: GO 80613
80557: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80558: LD_ADDR_VAR 0 9
80562: PUSH
80563: LD_VAR 0 35
80567: PUSH
80568: LD_VAR 0 36
80572: PUSH
80573: LD_VAR 0 37
80577: PUSH
80578: LD_VAR 0 38
80582: PUSH
80583: LD_VAR 0 39
80587: PUSH
80588: LD_VAR 0 40
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: PUSH
80601: LD_VAR 0 4
80605: PUSH
80606: LD_INT 1
80608: PLUS
80609: ARRAY
80610: ST_TO_ADDR
80611: GO 80978
80613: LD_INT 6
80615: DOUBLE
80616: EQUAL
80617: IFTRUE 80669
80619: LD_INT 7
80621: DOUBLE
80622: EQUAL
80623: IFTRUE 80669
80625: LD_INT 8
80627: DOUBLE
80628: EQUAL
80629: IFTRUE 80669
80631: LD_INT 13
80633: DOUBLE
80634: EQUAL
80635: IFTRUE 80669
80637: LD_INT 12
80639: DOUBLE
80640: EQUAL
80641: IFTRUE 80669
80643: LD_INT 15
80645: DOUBLE
80646: EQUAL
80647: IFTRUE 80669
80649: LD_INT 11
80651: DOUBLE
80652: EQUAL
80653: IFTRUE 80669
80655: LD_INT 14
80657: DOUBLE
80658: EQUAL
80659: IFTRUE 80669
80661: LD_INT 10
80663: DOUBLE
80664: EQUAL
80665: IFTRUE 80669
80667: GO 80725
80669: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80670: LD_ADDR_VAR 0 9
80674: PUSH
80675: LD_VAR 0 41
80679: PUSH
80680: LD_VAR 0 42
80684: PUSH
80685: LD_VAR 0 43
80689: PUSH
80690: LD_VAR 0 44
80694: PUSH
80695: LD_VAR 0 45
80699: PUSH
80700: LD_VAR 0 46
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: PUSH
80713: LD_VAR 0 4
80717: PUSH
80718: LD_INT 1
80720: PLUS
80721: ARRAY
80722: ST_TO_ADDR
80723: GO 80978
80725: LD_INT 36
80727: DOUBLE
80728: EQUAL
80729: IFTRUE 80733
80731: GO 80789
80733: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80734: LD_ADDR_VAR 0 9
80738: PUSH
80739: LD_VAR 0 47
80743: PUSH
80744: LD_VAR 0 48
80748: PUSH
80749: LD_VAR 0 49
80753: PUSH
80754: LD_VAR 0 50
80758: PUSH
80759: LD_VAR 0 51
80763: PUSH
80764: LD_VAR 0 52
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: PUSH
80777: LD_VAR 0 4
80781: PUSH
80782: LD_INT 1
80784: PLUS
80785: ARRAY
80786: ST_TO_ADDR
80787: GO 80978
80789: LD_INT 4
80791: DOUBLE
80792: EQUAL
80793: IFTRUE 80815
80795: LD_INT 5
80797: DOUBLE
80798: EQUAL
80799: IFTRUE 80815
80801: LD_INT 34
80803: DOUBLE
80804: EQUAL
80805: IFTRUE 80815
80807: LD_INT 37
80809: DOUBLE
80810: EQUAL
80811: IFTRUE 80815
80813: GO 80871
80815: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80816: LD_ADDR_VAR 0 9
80820: PUSH
80821: LD_VAR 0 53
80825: PUSH
80826: LD_VAR 0 54
80830: PUSH
80831: LD_VAR 0 55
80835: PUSH
80836: LD_VAR 0 56
80840: PUSH
80841: LD_VAR 0 57
80845: PUSH
80846: LD_VAR 0 58
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: PUSH
80859: LD_VAR 0 4
80863: PUSH
80864: LD_INT 1
80866: PLUS
80867: ARRAY
80868: ST_TO_ADDR
80869: GO 80978
80871: LD_INT 31
80873: DOUBLE
80874: EQUAL
80875: IFTRUE 80921
80877: LD_INT 32
80879: DOUBLE
80880: EQUAL
80881: IFTRUE 80921
80883: LD_INT 33
80885: DOUBLE
80886: EQUAL
80887: IFTRUE 80921
80889: LD_INT 27
80891: DOUBLE
80892: EQUAL
80893: IFTRUE 80921
80895: LD_INT 26
80897: DOUBLE
80898: EQUAL
80899: IFTRUE 80921
80901: LD_INT 28
80903: DOUBLE
80904: EQUAL
80905: IFTRUE 80921
80907: LD_INT 29
80909: DOUBLE
80910: EQUAL
80911: IFTRUE 80921
80913: LD_INT 30
80915: DOUBLE
80916: EQUAL
80917: IFTRUE 80921
80919: GO 80977
80921: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80922: LD_ADDR_VAR 0 9
80926: PUSH
80927: LD_VAR 0 59
80931: PUSH
80932: LD_VAR 0 60
80936: PUSH
80937: LD_VAR 0 61
80941: PUSH
80942: LD_VAR 0 62
80946: PUSH
80947: LD_VAR 0 63
80951: PUSH
80952: LD_VAR 0 64
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: PUSH
80965: LD_VAR 0 4
80969: PUSH
80970: LD_INT 1
80972: PLUS
80973: ARRAY
80974: ST_TO_ADDR
80975: GO 80978
80977: POP
// temp_list2 = [ ] ;
80978: LD_ADDR_VAR 0 10
80982: PUSH
80983: EMPTY
80984: ST_TO_ADDR
// for i in temp_list do
80985: LD_ADDR_VAR 0 8
80989: PUSH
80990: LD_VAR 0 9
80994: PUSH
80995: FOR_IN
80996: IFFALSE 81048
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80998: LD_ADDR_VAR 0 10
81002: PUSH
81003: LD_VAR 0 10
81007: PUSH
81008: LD_VAR 0 8
81012: PUSH
81013: LD_INT 1
81015: ARRAY
81016: PUSH
81017: LD_VAR 0 2
81021: PLUS
81022: PUSH
81023: LD_VAR 0 8
81027: PUSH
81028: LD_INT 2
81030: ARRAY
81031: PUSH
81032: LD_VAR 0 3
81036: PLUS
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: EMPTY
81043: LIST
81044: ADD
81045: ST_TO_ADDR
81046: GO 80995
81048: POP
81049: POP
// result = temp_list2 ;
81050: LD_ADDR_VAR 0 7
81054: PUSH
81055: LD_VAR 0 10
81059: ST_TO_ADDR
// end ;
81060: LD_VAR 0 7
81064: RET
// export function EnemyInRange ( unit , dist ) ; begin
81065: LD_INT 0
81067: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81068: LD_ADDR_VAR 0 3
81072: PUSH
81073: LD_VAR 0 1
81077: PPUSH
81078: CALL_OW 255
81082: PPUSH
81083: LD_VAR 0 1
81087: PPUSH
81088: CALL_OW 250
81092: PPUSH
81093: LD_VAR 0 1
81097: PPUSH
81098: CALL_OW 251
81102: PPUSH
81103: LD_VAR 0 2
81107: PPUSH
81108: CALL 54461 0 4
81112: PUSH
81113: LD_INT 4
81115: ARRAY
81116: ST_TO_ADDR
// end ;
81117: LD_VAR 0 3
81121: RET
// export function PlayerSeeMe ( unit ) ; begin
81122: LD_INT 0
81124: PPUSH
// result := See ( your_side , unit ) ;
81125: LD_ADDR_VAR 0 2
81129: PUSH
81130: LD_OWVAR 2
81134: PPUSH
81135: LD_VAR 0 1
81139: PPUSH
81140: CALL_OW 292
81144: ST_TO_ADDR
// end ;
81145: LD_VAR 0 2
81149: RET
// export function ReverseDir ( unit ) ; begin
81150: LD_INT 0
81152: PPUSH
// if not unit then
81153: LD_VAR 0 1
81157: NOT
81158: IFFALSE 81162
// exit ;
81160: GO 81185
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81162: LD_ADDR_VAR 0 2
81166: PUSH
81167: LD_VAR 0 1
81171: PPUSH
81172: CALL_OW 254
81176: PUSH
81177: LD_INT 3
81179: PLUS
81180: PUSH
81181: LD_INT 6
81183: MOD
81184: ST_TO_ADDR
// end ;
81185: LD_VAR 0 2
81189: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
81190: LD_INT 0
81192: PPUSH
81193: PPUSH
81194: PPUSH
81195: PPUSH
81196: PPUSH
// if not hexes then
81197: LD_VAR 0 2
81201: NOT
81202: IFFALSE 81206
// exit ;
81204: GO 81354
// dist := 9999 ;
81206: LD_ADDR_VAR 0 5
81210: PUSH
81211: LD_INT 9999
81213: ST_TO_ADDR
// for i = 1 to hexes do
81214: LD_ADDR_VAR 0 4
81218: PUSH
81219: DOUBLE
81220: LD_INT 1
81222: DEC
81223: ST_TO_ADDR
81224: LD_VAR 0 2
81228: PUSH
81229: FOR_TO
81230: IFFALSE 81342
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
81232: LD_VAR 0 1
81236: PPUSH
81237: LD_VAR 0 2
81241: PUSH
81242: LD_VAR 0 4
81246: ARRAY
81247: PUSH
81248: LD_INT 1
81250: ARRAY
81251: PPUSH
81252: LD_VAR 0 2
81256: PUSH
81257: LD_VAR 0 4
81261: ARRAY
81262: PUSH
81263: LD_INT 2
81265: ARRAY
81266: PPUSH
81267: CALL_OW 297
81271: PUSH
81272: LD_VAR 0 5
81276: LESS
81277: IFFALSE 81340
// begin hex := hexes [ i ] ;
81279: LD_ADDR_VAR 0 7
81283: PUSH
81284: LD_VAR 0 2
81288: PUSH
81289: LD_VAR 0 4
81293: ARRAY
81294: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81295: LD_ADDR_VAR 0 5
81299: PUSH
81300: LD_VAR 0 1
81304: PPUSH
81305: LD_VAR 0 2
81309: PUSH
81310: LD_VAR 0 4
81314: ARRAY
81315: PUSH
81316: LD_INT 1
81318: ARRAY
81319: PPUSH
81320: LD_VAR 0 2
81324: PUSH
81325: LD_VAR 0 4
81329: ARRAY
81330: PUSH
81331: LD_INT 2
81333: ARRAY
81334: PPUSH
81335: CALL_OW 297
81339: ST_TO_ADDR
// end ; end ;
81340: GO 81229
81342: POP
81343: POP
// result := hex ;
81344: LD_ADDR_VAR 0 3
81348: PUSH
81349: LD_VAR 0 7
81353: ST_TO_ADDR
// end ;
81354: LD_VAR 0 3
81358: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81359: LD_INT 0
81361: PPUSH
81362: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81363: LD_VAR 0 1
81367: NOT
81368: PUSH
81369: LD_VAR 0 1
81373: PUSH
81374: LD_INT 21
81376: PUSH
81377: LD_INT 2
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 23
81386: PUSH
81387: LD_INT 2
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PPUSH
81398: CALL_OW 69
81402: IN
81403: NOT
81404: OR
81405: IFFALSE 81409
// exit ;
81407: GO 81456
// for i = 1 to 3 do
81409: LD_ADDR_VAR 0 3
81413: PUSH
81414: DOUBLE
81415: LD_INT 1
81417: DEC
81418: ST_TO_ADDR
81419: LD_INT 3
81421: PUSH
81422: FOR_TO
81423: IFFALSE 81454
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81425: LD_VAR 0 1
81429: PPUSH
81430: CALL_OW 250
81434: PPUSH
81435: LD_VAR 0 1
81439: PPUSH
81440: CALL_OW 251
81444: PPUSH
81445: LD_INT 1
81447: PPUSH
81448: CALL_OW 453
81452: GO 81422
81454: POP
81455: POP
// end ;
81456: LD_VAR 0 2
81460: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81461: LD_INT 0
81463: PPUSH
81464: PPUSH
81465: PPUSH
81466: PPUSH
81467: PPUSH
81468: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81469: LD_VAR 0 1
81473: NOT
81474: PUSH
81475: LD_VAR 0 2
81479: NOT
81480: OR
81481: PUSH
81482: LD_VAR 0 1
81486: PPUSH
81487: CALL_OW 314
81491: OR
81492: IFFALSE 81496
// exit ;
81494: GO 81937
// x := GetX ( enemy_unit ) ;
81496: LD_ADDR_VAR 0 7
81500: PUSH
81501: LD_VAR 0 2
81505: PPUSH
81506: CALL_OW 250
81510: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81511: LD_ADDR_VAR 0 8
81515: PUSH
81516: LD_VAR 0 2
81520: PPUSH
81521: CALL_OW 251
81525: ST_TO_ADDR
// if not x or not y then
81526: LD_VAR 0 7
81530: NOT
81531: PUSH
81532: LD_VAR 0 8
81536: NOT
81537: OR
81538: IFFALSE 81542
// exit ;
81540: GO 81937
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81542: LD_ADDR_VAR 0 6
81546: PUSH
81547: LD_VAR 0 7
81551: PPUSH
81552: LD_INT 0
81554: PPUSH
81555: LD_INT 4
81557: PPUSH
81558: CALL_OW 272
81562: PUSH
81563: LD_VAR 0 8
81567: PPUSH
81568: LD_INT 0
81570: PPUSH
81571: LD_INT 4
81573: PPUSH
81574: CALL_OW 273
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_VAR 0 7
81587: PPUSH
81588: LD_INT 1
81590: PPUSH
81591: LD_INT 4
81593: PPUSH
81594: CALL_OW 272
81598: PUSH
81599: LD_VAR 0 8
81603: PPUSH
81604: LD_INT 1
81606: PPUSH
81607: LD_INT 4
81609: PPUSH
81610: CALL_OW 273
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_VAR 0 7
81623: PPUSH
81624: LD_INT 2
81626: PPUSH
81627: LD_INT 4
81629: PPUSH
81630: CALL_OW 272
81634: PUSH
81635: LD_VAR 0 8
81639: PPUSH
81640: LD_INT 2
81642: PPUSH
81643: LD_INT 4
81645: PPUSH
81646: CALL_OW 273
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_VAR 0 7
81659: PPUSH
81660: LD_INT 3
81662: PPUSH
81663: LD_INT 4
81665: PPUSH
81666: CALL_OW 272
81670: PUSH
81671: LD_VAR 0 8
81675: PPUSH
81676: LD_INT 3
81678: PPUSH
81679: LD_INT 4
81681: PPUSH
81682: CALL_OW 273
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_VAR 0 7
81695: PPUSH
81696: LD_INT 4
81698: PPUSH
81699: LD_INT 4
81701: PPUSH
81702: CALL_OW 272
81706: PUSH
81707: LD_VAR 0 8
81711: PPUSH
81712: LD_INT 4
81714: PPUSH
81715: LD_INT 4
81717: PPUSH
81718: CALL_OW 273
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_VAR 0 7
81731: PPUSH
81732: LD_INT 5
81734: PPUSH
81735: LD_INT 4
81737: PPUSH
81738: CALL_OW 272
81742: PUSH
81743: LD_VAR 0 8
81747: PPUSH
81748: LD_INT 5
81750: PPUSH
81751: LD_INT 4
81753: PPUSH
81754: CALL_OW 273
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: ST_TO_ADDR
// for i = tmp downto 1 do
81771: LD_ADDR_VAR 0 4
81775: PUSH
81776: DOUBLE
81777: LD_VAR 0 6
81781: INC
81782: ST_TO_ADDR
81783: LD_INT 1
81785: PUSH
81786: FOR_DOWNTO
81787: IFFALSE 81888
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81789: LD_VAR 0 6
81793: PUSH
81794: LD_VAR 0 4
81798: ARRAY
81799: PUSH
81800: LD_INT 1
81802: ARRAY
81803: PPUSH
81804: LD_VAR 0 6
81808: PUSH
81809: LD_VAR 0 4
81813: ARRAY
81814: PUSH
81815: LD_INT 2
81817: ARRAY
81818: PPUSH
81819: CALL_OW 488
81823: NOT
81824: PUSH
81825: LD_VAR 0 6
81829: PUSH
81830: LD_VAR 0 4
81834: ARRAY
81835: PUSH
81836: LD_INT 1
81838: ARRAY
81839: PPUSH
81840: LD_VAR 0 6
81844: PUSH
81845: LD_VAR 0 4
81849: ARRAY
81850: PUSH
81851: LD_INT 2
81853: ARRAY
81854: PPUSH
81855: CALL_OW 428
81859: PUSH
81860: LD_INT 0
81862: NONEQUAL
81863: OR
81864: IFFALSE 81886
// tmp := Delete ( tmp , i ) ;
81866: LD_ADDR_VAR 0 6
81870: PUSH
81871: LD_VAR 0 6
81875: PPUSH
81876: LD_VAR 0 4
81880: PPUSH
81881: CALL_OW 3
81885: ST_TO_ADDR
81886: GO 81786
81888: POP
81889: POP
// j := GetClosestHex ( unit , tmp ) ;
81890: LD_ADDR_VAR 0 5
81894: PUSH
81895: LD_VAR 0 1
81899: PPUSH
81900: LD_VAR 0 6
81904: PPUSH
81905: CALL 81190 0 2
81909: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81910: LD_VAR 0 1
81914: PPUSH
81915: LD_VAR 0 5
81919: PUSH
81920: LD_INT 1
81922: ARRAY
81923: PPUSH
81924: LD_VAR 0 5
81928: PUSH
81929: LD_INT 2
81931: ARRAY
81932: PPUSH
81933: CALL_OW 111
// end ;
81937: LD_VAR 0 3
81941: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81942: LD_INT 0
81944: PPUSH
81945: PPUSH
81946: PPUSH
// uc_side = 0 ;
81947: LD_ADDR_OWVAR 20
81951: PUSH
81952: LD_INT 0
81954: ST_TO_ADDR
// uc_nation = 0 ;
81955: LD_ADDR_OWVAR 21
81959: PUSH
81960: LD_INT 0
81962: ST_TO_ADDR
// InitHc_All ( ) ;
81963: CALL_OW 584
// InitVc ;
81967: CALL_OW 20
// if mastodonts then
81971: LD_VAR 0 6
81975: IFFALSE 82042
// for i = 1 to mastodonts do
81977: LD_ADDR_VAR 0 11
81981: PUSH
81982: DOUBLE
81983: LD_INT 1
81985: DEC
81986: ST_TO_ADDR
81987: LD_VAR 0 6
81991: PUSH
81992: FOR_TO
81993: IFFALSE 82040
// begin vc_chassis := 31 ;
81995: LD_ADDR_OWVAR 37
81999: PUSH
82000: LD_INT 31
82002: ST_TO_ADDR
// vc_control := control_rider ;
82003: LD_ADDR_OWVAR 38
82007: PUSH
82008: LD_INT 4
82010: ST_TO_ADDR
// animal := CreateVehicle ;
82011: LD_ADDR_VAR 0 12
82015: PUSH
82016: CALL_OW 45
82020: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82021: LD_VAR 0 12
82025: PPUSH
82026: LD_VAR 0 8
82030: PPUSH
82031: LD_INT 0
82033: PPUSH
82034: CALL 84177 0 3
// end ;
82038: GO 81992
82040: POP
82041: POP
// if horses then
82042: LD_VAR 0 5
82046: IFFALSE 82113
// for i = 1 to horses do
82048: LD_ADDR_VAR 0 11
82052: PUSH
82053: DOUBLE
82054: LD_INT 1
82056: DEC
82057: ST_TO_ADDR
82058: LD_VAR 0 5
82062: PUSH
82063: FOR_TO
82064: IFFALSE 82111
// begin hc_class := 21 ;
82066: LD_ADDR_OWVAR 28
82070: PUSH
82071: LD_INT 21
82073: ST_TO_ADDR
// hc_gallery :=  ;
82074: LD_ADDR_OWVAR 33
82078: PUSH
82079: LD_STRING 
82081: ST_TO_ADDR
// animal := CreateHuman ;
82082: LD_ADDR_VAR 0 12
82086: PUSH
82087: CALL_OW 44
82091: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82092: LD_VAR 0 12
82096: PPUSH
82097: LD_VAR 0 8
82101: PPUSH
82102: LD_INT 0
82104: PPUSH
82105: CALL 84177 0 3
// end ;
82109: GO 82063
82111: POP
82112: POP
// if birds then
82113: LD_VAR 0 1
82117: IFFALSE 82184
// for i = 1 to birds do
82119: LD_ADDR_VAR 0 11
82123: PUSH
82124: DOUBLE
82125: LD_INT 1
82127: DEC
82128: ST_TO_ADDR
82129: LD_VAR 0 1
82133: PUSH
82134: FOR_TO
82135: IFFALSE 82182
// begin hc_class = 18 ;
82137: LD_ADDR_OWVAR 28
82141: PUSH
82142: LD_INT 18
82144: ST_TO_ADDR
// hc_gallery =  ;
82145: LD_ADDR_OWVAR 33
82149: PUSH
82150: LD_STRING 
82152: ST_TO_ADDR
// animal := CreateHuman ;
82153: LD_ADDR_VAR 0 12
82157: PUSH
82158: CALL_OW 44
82162: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82163: LD_VAR 0 12
82167: PPUSH
82168: LD_VAR 0 8
82172: PPUSH
82173: LD_INT 0
82175: PPUSH
82176: CALL 84177 0 3
// end ;
82180: GO 82134
82182: POP
82183: POP
// if tigers then
82184: LD_VAR 0 2
82188: IFFALSE 82272
// for i = 1 to tigers do
82190: LD_ADDR_VAR 0 11
82194: PUSH
82195: DOUBLE
82196: LD_INT 1
82198: DEC
82199: ST_TO_ADDR
82200: LD_VAR 0 2
82204: PUSH
82205: FOR_TO
82206: IFFALSE 82270
// begin hc_class = class_tiger ;
82208: LD_ADDR_OWVAR 28
82212: PUSH
82213: LD_INT 14
82215: ST_TO_ADDR
// hc_gallery =  ;
82216: LD_ADDR_OWVAR 33
82220: PUSH
82221: LD_STRING 
82223: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
82224: LD_ADDR_OWVAR 35
82228: PUSH
82229: LD_INT 7
82231: NEG
82232: PPUSH
82233: LD_INT 7
82235: PPUSH
82236: CALL_OW 12
82240: ST_TO_ADDR
// animal := CreateHuman ;
82241: LD_ADDR_VAR 0 12
82245: PUSH
82246: CALL_OW 44
82250: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82251: LD_VAR 0 12
82255: PPUSH
82256: LD_VAR 0 8
82260: PPUSH
82261: LD_INT 0
82263: PPUSH
82264: CALL 84177 0 3
// end ;
82268: GO 82205
82270: POP
82271: POP
// if apemans then
82272: LD_VAR 0 3
82276: IFFALSE 82399
// for i = 1 to apemans do
82278: LD_ADDR_VAR 0 11
82282: PUSH
82283: DOUBLE
82284: LD_INT 1
82286: DEC
82287: ST_TO_ADDR
82288: LD_VAR 0 3
82292: PUSH
82293: FOR_TO
82294: IFFALSE 82397
// begin hc_class = class_apeman ;
82296: LD_ADDR_OWVAR 28
82300: PUSH
82301: LD_INT 12
82303: ST_TO_ADDR
// hc_gallery =  ;
82304: LD_ADDR_OWVAR 33
82308: PUSH
82309: LD_STRING 
82311: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82312: LD_ADDR_OWVAR 35
82316: PUSH
82317: LD_INT 2
82319: NEG
82320: PPUSH
82321: LD_INT 2
82323: PPUSH
82324: CALL_OW 12
82328: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82329: LD_ADDR_OWVAR 31
82333: PUSH
82334: LD_INT 1
82336: PPUSH
82337: LD_INT 3
82339: PPUSH
82340: CALL_OW 12
82344: PUSH
82345: LD_INT 1
82347: PPUSH
82348: LD_INT 3
82350: PPUSH
82351: CALL_OW 12
82355: PUSH
82356: LD_INT 0
82358: PUSH
82359: LD_INT 0
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: ST_TO_ADDR
// animal := CreateHuman ;
82368: LD_ADDR_VAR 0 12
82372: PUSH
82373: CALL_OW 44
82377: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82378: LD_VAR 0 12
82382: PPUSH
82383: LD_VAR 0 8
82387: PPUSH
82388: LD_INT 0
82390: PPUSH
82391: CALL 84177 0 3
// end ;
82395: GO 82293
82397: POP
82398: POP
// if enchidnas then
82399: LD_VAR 0 4
82403: IFFALSE 82470
// for i = 1 to enchidnas do
82405: LD_ADDR_VAR 0 11
82409: PUSH
82410: DOUBLE
82411: LD_INT 1
82413: DEC
82414: ST_TO_ADDR
82415: LD_VAR 0 4
82419: PUSH
82420: FOR_TO
82421: IFFALSE 82468
// begin hc_class = 13 ;
82423: LD_ADDR_OWVAR 28
82427: PUSH
82428: LD_INT 13
82430: ST_TO_ADDR
// hc_gallery =  ;
82431: LD_ADDR_OWVAR 33
82435: PUSH
82436: LD_STRING 
82438: ST_TO_ADDR
// animal := CreateHuman ;
82439: LD_ADDR_VAR 0 12
82443: PUSH
82444: CALL_OW 44
82448: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82449: LD_VAR 0 12
82453: PPUSH
82454: LD_VAR 0 8
82458: PPUSH
82459: LD_INT 0
82461: PPUSH
82462: CALL 84177 0 3
// end ;
82466: GO 82420
82468: POP
82469: POP
// if fishes then
82470: LD_VAR 0 7
82474: IFFALSE 82541
// for i = 1 to fishes do
82476: LD_ADDR_VAR 0 11
82480: PUSH
82481: DOUBLE
82482: LD_INT 1
82484: DEC
82485: ST_TO_ADDR
82486: LD_VAR 0 7
82490: PUSH
82491: FOR_TO
82492: IFFALSE 82539
// begin hc_class = 20 ;
82494: LD_ADDR_OWVAR 28
82498: PUSH
82499: LD_INT 20
82501: ST_TO_ADDR
// hc_gallery =  ;
82502: LD_ADDR_OWVAR 33
82506: PUSH
82507: LD_STRING 
82509: ST_TO_ADDR
// animal := CreateHuman ;
82510: LD_ADDR_VAR 0 12
82514: PUSH
82515: CALL_OW 44
82519: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82520: LD_VAR 0 12
82524: PPUSH
82525: LD_VAR 0 9
82529: PPUSH
82530: LD_INT 0
82532: PPUSH
82533: CALL 84177 0 3
// end ;
82537: GO 82491
82539: POP
82540: POP
// end ;
82541: LD_VAR 0 10
82545: RET
// export function WantHeal ( sci , unit ) ; begin
82546: LD_INT 0
82548: PPUSH
// if GetTaskList ( sci ) > 0 then
82549: LD_VAR 0 1
82553: PPUSH
82554: CALL_OW 437
82558: PUSH
82559: LD_INT 0
82561: GREATER
82562: IFFALSE 82632
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82564: LD_VAR 0 1
82568: PPUSH
82569: CALL_OW 437
82573: PUSH
82574: LD_INT 1
82576: ARRAY
82577: PUSH
82578: LD_INT 1
82580: ARRAY
82581: PUSH
82582: LD_STRING l
82584: EQUAL
82585: PUSH
82586: LD_VAR 0 1
82590: PPUSH
82591: CALL_OW 437
82595: PUSH
82596: LD_INT 1
82598: ARRAY
82599: PUSH
82600: LD_INT 4
82602: ARRAY
82603: PUSH
82604: LD_VAR 0 2
82608: EQUAL
82609: AND
82610: IFFALSE 82622
// result := true else
82612: LD_ADDR_VAR 0 3
82616: PUSH
82617: LD_INT 1
82619: ST_TO_ADDR
82620: GO 82630
// result := false ;
82622: LD_ADDR_VAR 0 3
82626: PUSH
82627: LD_INT 0
82629: ST_TO_ADDR
// end else
82630: GO 82640
// result := false ;
82632: LD_ADDR_VAR 0 3
82636: PUSH
82637: LD_INT 0
82639: ST_TO_ADDR
// end ;
82640: LD_VAR 0 3
82644: RET
// export function HealTarget ( sci ) ; begin
82645: LD_INT 0
82647: PPUSH
// if not sci then
82648: LD_VAR 0 1
82652: NOT
82653: IFFALSE 82657
// exit ;
82655: GO 82722
// result := 0 ;
82657: LD_ADDR_VAR 0 2
82661: PUSH
82662: LD_INT 0
82664: ST_TO_ADDR
// if GetTaskList ( sci ) then
82665: LD_VAR 0 1
82669: PPUSH
82670: CALL_OW 437
82674: IFFALSE 82722
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82676: LD_VAR 0 1
82680: PPUSH
82681: CALL_OW 437
82685: PUSH
82686: LD_INT 1
82688: ARRAY
82689: PUSH
82690: LD_INT 1
82692: ARRAY
82693: PUSH
82694: LD_STRING l
82696: EQUAL
82697: IFFALSE 82722
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82699: LD_ADDR_VAR 0 2
82703: PUSH
82704: LD_VAR 0 1
82708: PPUSH
82709: CALL_OW 437
82713: PUSH
82714: LD_INT 1
82716: ARRAY
82717: PUSH
82718: LD_INT 4
82720: ARRAY
82721: ST_TO_ADDR
// end ;
82722: LD_VAR 0 2
82726: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82727: LD_INT 0
82729: PPUSH
82730: PPUSH
82731: PPUSH
82732: PPUSH
// if not base_units then
82733: LD_VAR 0 1
82737: NOT
82738: IFFALSE 82742
// exit ;
82740: GO 82829
// result := false ;
82742: LD_ADDR_VAR 0 2
82746: PUSH
82747: LD_INT 0
82749: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82750: LD_ADDR_VAR 0 5
82754: PUSH
82755: LD_VAR 0 1
82759: PPUSH
82760: LD_INT 21
82762: PUSH
82763: LD_INT 3
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PPUSH
82770: CALL_OW 72
82774: ST_TO_ADDR
// if not tmp then
82775: LD_VAR 0 5
82779: NOT
82780: IFFALSE 82784
// exit ;
82782: GO 82829
// for i in tmp do
82784: LD_ADDR_VAR 0 3
82788: PUSH
82789: LD_VAR 0 5
82793: PUSH
82794: FOR_IN
82795: IFFALSE 82827
// begin result := EnemyInRange ( i , 22 ) ;
82797: LD_ADDR_VAR 0 2
82801: PUSH
82802: LD_VAR 0 3
82806: PPUSH
82807: LD_INT 22
82809: PPUSH
82810: CALL 81065 0 2
82814: ST_TO_ADDR
// if result then
82815: LD_VAR 0 2
82819: IFFALSE 82825
// exit ;
82821: POP
82822: POP
82823: GO 82829
// end ;
82825: GO 82794
82827: POP
82828: POP
// end ;
82829: LD_VAR 0 2
82833: RET
// export function FilterByTag ( units , tag ) ; begin
82834: LD_INT 0
82836: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
82837: LD_ADDR_VAR 0 3
82841: PUSH
82842: LD_VAR 0 1
82846: PPUSH
82847: LD_INT 120
82849: PUSH
82850: LD_VAR 0 2
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PPUSH
82859: CALL_OW 72
82863: ST_TO_ADDR
// end ;
82864: LD_VAR 0 3
82868: RET
// export function IsDriver ( un ) ; begin
82869: LD_INT 0
82871: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82872: LD_ADDR_VAR 0 2
82876: PUSH
82877: LD_VAR 0 1
82881: PUSH
82882: LD_INT 55
82884: PUSH
82885: EMPTY
82886: LIST
82887: PPUSH
82888: CALL_OW 69
82892: IN
82893: ST_TO_ADDR
// end ;
82894: LD_VAR 0 2
82898: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82899: LD_INT 0
82901: PPUSH
82902: PPUSH
// list := [ ] ;
82903: LD_ADDR_VAR 0 5
82907: PUSH
82908: EMPTY
82909: ST_TO_ADDR
// case d of 0 :
82910: LD_VAR 0 3
82914: PUSH
82915: LD_INT 0
82917: DOUBLE
82918: EQUAL
82919: IFTRUE 82923
82921: GO 83056
82923: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82924: LD_ADDR_VAR 0 5
82928: PUSH
82929: LD_VAR 0 1
82933: PUSH
82934: LD_INT 4
82936: MINUS
82937: PUSH
82938: LD_VAR 0 2
82942: PUSH
82943: LD_INT 4
82945: MINUS
82946: PUSH
82947: LD_INT 2
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: LIST
82954: PUSH
82955: LD_VAR 0 1
82959: PUSH
82960: LD_INT 3
82962: MINUS
82963: PUSH
82964: LD_VAR 0 2
82968: PUSH
82969: LD_INT 1
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: LIST
82976: PUSH
82977: LD_VAR 0 1
82981: PUSH
82982: LD_INT 4
82984: PLUS
82985: PUSH
82986: LD_VAR 0 2
82990: PUSH
82991: LD_INT 4
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: LIST
82998: PUSH
82999: LD_VAR 0 1
83003: PUSH
83004: LD_INT 3
83006: PLUS
83007: PUSH
83008: LD_VAR 0 2
83012: PUSH
83013: LD_INT 3
83015: PLUS
83016: PUSH
83017: LD_INT 5
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: LIST
83024: PUSH
83025: LD_VAR 0 1
83029: PUSH
83030: LD_VAR 0 2
83034: PUSH
83035: LD_INT 4
83037: PLUS
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: LIST
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: ST_TO_ADDR
// end ; 1 :
83054: GO 83754
83056: LD_INT 1
83058: DOUBLE
83059: EQUAL
83060: IFTRUE 83064
83062: GO 83197
83064: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83065: LD_ADDR_VAR 0 5
83069: PUSH
83070: LD_VAR 0 1
83074: PUSH
83075: LD_VAR 0 2
83079: PUSH
83080: LD_INT 4
83082: MINUS
83083: PUSH
83084: LD_INT 3
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: LIST
83091: PUSH
83092: LD_VAR 0 1
83096: PUSH
83097: LD_INT 3
83099: MINUS
83100: PUSH
83101: LD_VAR 0 2
83105: PUSH
83106: LD_INT 3
83108: MINUS
83109: PUSH
83110: LD_INT 2
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: LIST
83117: PUSH
83118: LD_VAR 0 1
83122: PUSH
83123: LD_INT 4
83125: MINUS
83126: PUSH
83127: LD_VAR 0 2
83131: PUSH
83132: LD_INT 1
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: LIST
83139: PUSH
83140: LD_VAR 0 1
83144: PUSH
83145: LD_VAR 0 2
83149: PUSH
83150: LD_INT 3
83152: PLUS
83153: PUSH
83154: LD_INT 0
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: LIST
83161: PUSH
83162: LD_VAR 0 1
83166: PUSH
83167: LD_INT 4
83169: PLUS
83170: PUSH
83171: LD_VAR 0 2
83175: PUSH
83176: LD_INT 4
83178: PLUS
83179: PUSH
83180: LD_INT 5
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: LIST
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: ST_TO_ADDR
// end ; 2 :
83195: GO 83754
83197: LD_INT 2
83199: DOUBLE
83200: EQUAL
83201: IFTRUE 83205
83203: GO 83334
83205: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83206: LD_ADDR_VAR 0 5
83210: PUSH
83211: LD_VAR 0 1
83215: PUSH
83216: LD_VAR 0 2
83220: PUSH
83221: LD_INT 3
83223: MINUS
83224: PUSH
83225: LD_INT 3
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: LIST
83232: PUSH
83233: LD_VAR 0 1
83237: PUSH
83238: LD_INT 4
83240: PLUS
83241: PUSH
83242: LD_VAR 0 2
83246: PUSH
83247: LD_INT 4
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: LIST
83254: PUSH
83255: LD_VAR 0 1
83259: PUSH
83260: LD_VAR 0 2
83264: PUSH
83265: LD_INT 4
83267: PLUS
83268: PUSH
83269: LD_INT 0
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: LIST
83276: PUSH
83277: LD_VAR 0 1
83281: PUSH
83282: LD_INT 3
83284: MINUS
83285: PUSH
83286: LD_VAR 0 2
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: LIST
83298: PUSH
83299: LD_VAR 0 1
83303: PUSH
83304: LD_INT 4
83306: MINUS
83307: PUSH
83308: LD_VAR 0 2
83312: PUSH
83313: LD_INT 4
83315: MINUS
83316: PUSH
83317: LD_INT 2
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: LIST
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: ST_TO_ADDR
// end ; 3 :
83332: GO 83754
83334: LD_INT 3
83336: DOUBLE
83337: EQUAL
83338: IFTRUE 83342
83340: GO 83475
83342: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83343: LD_ADDR_VAR 0 5
83347: PUSH
83348: LD_VAR 0 1
83352: PUSH
83353: LD_INT 3
83355: PLUS
83356: PUSH
83357: LD_VAR 0 2
83361: PUSH
83362: LD_INT 4
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: LIST
83369: PUSH
83370: LD_VAR 0 1
83374: PUSH
83375: LD_INT 4
83377: PLUS
83378: PUSH
83379: LD_VAR 0 2
83383: PUSH
83384: LD_INT 4
83386: PLUS
83387: PUSH
83388: LD_INT 5
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: LIST
83395: PUSH
83396: LD_VAR 0 1
83400: PUSH
83401: LD_INT 4
83403: MINUS
83404: PUSH
83405: LD_VAR 0 2
83409: PUSH
83410: LD_INT 1
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: LIST
83417: PUSH
83418: LD_VAR 0 1
83422: PUSH
83423: LD_VAR 0 2
83427: PUSH
83428: LD_INT 4
83430: MINUS
83431: PUSH
83432: LD_INT 3
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: LIST
83439: PUSH
83440: LD_VAR 0 1
83444: PUSH
83445: LD_INT 3
83447: MINUS
83448: PUSH
83449: LD_VAR 0 2
83453: PUSH
83454: LD_INT 3
83456: MINUS
83457: PUSH
83458: LD_INT 2
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: LIST
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: ST_TO_ADDR
// end ; 4 :
83473: GO 83754
83475: LD_INT 4
83477: DOUBLE
83478: EQUAL
83479: IFTRUE 83483
83481: GO 83616
83483: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83484: LD_ADDR_VAR 0 5
83488: PUSH
83489: LD_VAR 0 1
83493: PUSH
83494: LD_VAR 0 2
83498: PUSH
83499: LD_INT 4
83501: PLUS
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: LIST
83510: PUSH
83511: LD_VAR 0 1
83515: PUSH
83516: LD_INT 3
83518: PLUS
83519: PUSH
83520: LD_VAR 0 2
83524: PUSH
83525: LD_INT 3
83527: PLUS
83528: PUSH
83529: LD_INT 5
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: LIST
83536: PUSH
83537: LD_VAR 0 1
83541: PUSH
83542: LD_INT 4
83544: PLUS
83545: PUSH
83546: LD_VAR 0 2
83550: PUSH
83551: LD_INT 4
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: LIST
83558: PUSH
83559: LD_VAR 0 1
83563: PUSH
83564: LD_VAR 0 2
83568: PUSH
83569: LD_INT 3
83571: MINUS
83572: PUSH
83573: LD_INT 3
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: LIST
83580: PUSH
83581: LD_VAR 0 1
83585: PUSH
83586: LD_INT 4
83588: MINUS
83589: PUSH
83590: LD_VAR 0 2
83594: PUSH
83595: LD_INT 4
83597: MINUS
83598: PUSH
83599: LD_INT 2
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: ST_TO_ADDR
// end ; 5 :
83614: GO 83754
83616: LD_INT 5
83618: DOUBLE
83619: EQUAL
83620: IFTRUE 83624
83622: GO 83753
83624: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83625: LD_ADDR_VAR 0 5
83629: PUSH
83630: LD_VAR 0 1
83634: PUSH
83635: LD_INT 4
83637: MINUS
83638: PUSH
83639: LD_VAR 0 2
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: LIST
83651: PUSH
83652: LD_VAR 0 1
83656: PUSH
83657: LD_VAR 0 2
83661: PUSH
83662: LD_INT 4
83664: MINUS
83665: PUSH
83666: LD_INT 3
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: LIST
83673: PUSH
83674: LD_VAR 0 1
83678: PUSH
83679: LD_INT 4
83681: PLUS
83682: PUSH
83683: LD_VAR 0 2
83687: PUSH
83688: LD_INT 4
83690: PLUS
83691: PUSH
83692: LD_INT 5
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: LIST
83699: PUSH
83700: LD_VAR 0 1
83704: PUSH
83705: LD_INT 3
83707: PLUS
83708: PUSH
83709: LD_VAR 0 2
83713: PUSH
83714: LD_INT 4
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: LIST
83721: PUSH
83722: LD_VAR 0 1
83726: PUSH
83727: LD_VAR 0 2
83731: PUSH
83732: LD_INT 3
83734: PLUS
83735: PUSH
83736: LD_INT 0
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: LIST
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: ST_TO_ADDR
// end ; end ;
83751: GO 83754
83753: POP
// result := list ;
83754: LD_ADDR_VAR 0 4
83758: PUSH
83759: LD_VAR 0 5
83763: ST_TO_ADDR
// end ;
83764: LD_VAR 0 4
83768: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83769: LD_INT 0
83771: PPUSH
83772: PPUSH
83773: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83774: LD_VAR 0 1
83778: NOT
83779: PUSH
83780: LD_VAR 0 2
83784: PUSH
83785: LD_INT 1
83787: PUSH
83788: LD_INT 2
83790: PUSH
83791: LD_INT 3
83793: PUSH
83794: LD_INT 4
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: IN
83803: NOT
83804: OR
83805: IFFALSE 83809
// exit ;
83807: GO 83901
// tmp := [ ] ;
83809: LD_ADDR_VAR 0 5
83813: PUSH
83814: EMPTY
83815: ST_TO_ADDR
// for i in units do
83816: LD_ADDR_VAR 0 4
83820: PUSH
83821: LD_VAR 0 1
83825: PUSH
83826: FOR_IN
83827: IFFALSE 83870
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83829: LD_ADDR_VAR 0 5
83833: PUSH
83834: LD_VAR 0 5
83838: PPUSH
83839: LD_VAR 0 5
83843: PUSH
83844: LD_INT 1
83846: PLUS
83847: PPUSH
83848: LD_VAR 0 4
83852: PPUSH
83853: LD_VAR 0 2
83857: PPUSH
83858: CALL_OW 259
83862: PPUSH
83863: CALL_OW 2
83867: ST_TO_ADDR
83868: GO 83826
83870: POP
83871: POP
// if not tmp then
83872: LD_VAR 0 5
83876: NOT
83877: IFFALSE 83881
// exit ;
83879: GO 83901
// result := SortListByListDesc ( units , tmp ) ;
83881: LD_ADDR_VAR 0 3
83885: PUSH
83886: LD_VAR 0 1
83890: PPUSH
83891: LD_VAR 0 5
83895: PPUSH
83896: CALL_OW 77
83900: ST_TO_ADDR
// end ;
83901: LD_VAR 0 3
83905: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83906: LD_INT 0
83908: PPUSH
83909: PPUSH
83910: PPUSH
// result := false ;
83911: LD_ADDR_VAR 0 3
83915: PUSH
83916: LD_INT 0
83918: ST_TO_ADDR
// x := GetX ( building ) ;
83919: LD_ADDR_VAR 0 4
83923: PUSH
83924: LD_VAR 0 2
83928: PPUSH
83929: CALL_OW 250
83933: ST_TO_ADDR
// y := GetY ( building ) ;
83934: LD_ADDR_VAR 0 5
83938: PUSH
83939: LD_VAR 0 2
83943: PPUSH
83944: CALL_OW 251
83948: ST_TO_ADDR
// if not building or not x or not y then
83949: LD_VAR 0 2
83953: NOT
83954: PUSH
83955: LD_VAR 0 4
83959: NOT
83960: OR
83961: PUSH
83962: LD_VAR 0 5
83966: NOT
83967: OR
83968: IFFALSE 83972
// exit ;
83970: GO 84064
// if GetTaskList ( unit ) then
83972: LD_VAR 0 1
83976: PPUSH
83977: CALL_OW 437
83981: IFFALSE 84064
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83983: LD_STRING e
83985: PUSH
83986: LD_VAR 0 1
83990: PPUSH
83991: CALL_OW 437
83995: PUSH
83996: LD_INT 1
83998: ARRAY
83999: PUSH
84000: LD_INT 1
84002: ARRAY
84003: EQUAL
84004: PUSH
84005: LD_VAR 0 4
84009: PUSH
84010: LD_VAR 0 1
84014: PPUSH
84015: CALL_OW 437
84019: PUSH
84020: LD_INT 1
84022: ARRAY
84023: PUSH
84024: LD_INT 2
84026: ARRAY
84027: EQUAL
84028: AND
84029: PUSH
84030: LD_VAR 0 5
84034: PUSH
84035: LD_VAR 0 1
84039: PPUSH
84040: CALL_OW 437
84044: PUSH
84045: LD_INT 1
84047: ARRAY
84048: PUSH
84049: LD_INT 3
84051: ARRAY
84052: EQUAL
84053: AND
84054: IFFALSE 84064
// result := true end ;
84056: LD_ADDR_VAR 0 3
84060: PUSH
84061: LD_INT 1
84063: ST_TO_ADDR
// end ;
84064: LD_VAR 0 3
84068: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84069: LD_INT 0
84071: PPUSH
// result := false ;
84072: LD_ADDR_VAR 0 4
84076: PUSH
84077: LD_INT 0
84079: ST_TO_ADDR
// if GetTaskList ( unit ) then
84080: LD_VAR 0 1
84084: PPUSH
84085: CALL_OW 437
84089: IFFALSE 84172
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84091: LD_STRING M
84093: PUSH
84094: LD_VAR 0 1
84098: PPUSH
84099: CALL_OW 437
84103: PUSH
84104: LD_INT 1
84106: ARRAY
84107: PUSH
84108: LD_INT 1
84110: ARRAY
84111: EQUAL
84112: PUSH
84113: LD_VAR 0 2
84117: PUSH
84118: LD_VAR 0 1
84122: PPUSH
84123: CALL_OW 437
84127: PUSH
84128: LD_INT 1
84130: ARRAY
84131: PUSH
84132: LD_INT 2
84134: ARRAY
84135: EQUAL
84136: AND
84137: PUSH
84138: LD_VAR 0 3
84142: PUSH
84143: LD_VAR 0 1
84147: PPUSH
84148: CALL_OW 437
84152: PUSH
84153: LD_INT 1
84155: ARRAY
84156: PUSH
84157: LD_INT 3
84159: ARRAY
84160: EQUAL
84161: AND
84162: IFFALSE 84172
// result := true ;
84164: LD_ADDR_VAR 0 4
84168: PUSH
84169: LD_INT 1
84171: ST_TO_ADDR
// end ; end ;
84172: LD_VAR 0 4
84176: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84177: LD_INT 0
84179: PPUSH
84180: PPUSH
84181: PPUSH
84182: PPUSH
// if not unit or not area then
84183: LD_VAR 0 1
84187: NOT
84188: PUSH
84189: LD_VAR 0 2
84193: NOT
84194: OR
84195: IFFALSE 84199
// exit ;
84197: GO 84363
// tmp := AreaToList ( area , i ) ;
84199: LD_ADDR_VAR 0 6
84203: PUSH
84204: LD_VAR 0 2
84208: PPUSH
84209: LD_VAR 0 5
84213: PPUSH
84214: CALL_OW 517
84218: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84219: LD_ADDR_VAR 0 5
84223: PUSH
84224: DOUBLE
84225: LD_INT 1
84227: DEC
84228: ST_TO_ADDR
84229: LD_VAR 0 6
84233: PUSH
84234: LD_INT 1
84236: ARRAY
84237: PUSH
84238: FOR_TO
84239: IFFALSE 84361
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84241: LD_ADDR_VAR 0 7
84245: PUSH
84246: LD_VAR 0 6
84250: PUSH
84251: LD_INT 1
84253: ARRAY
84254: PUSH
84255: LD_VAR 0 5
84259: ARRAY
84260: PUSH
84261: LD_VAR 0 6
84265: PUSH
84266: LD_INT 2
84268: ARRAY
84269: PUSH
84270: LD_VAR 0 5
84274: ARRAY
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84280: LD_VAR 0 7
84284: PUSH
84285: LD_INT 1
84287: ARRAY
84288: PPUSH
84289: LD_VAR 0 7
84293: PUSH
84294: LD_INT 2
84296: ARRAY
84297: PPUSH
84298: CALL_OW 428
84302: PUSH
84303: LD_INT 0
84305: EQUAL
84306: IFFALSE 84359
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84308: LD_VAR 0 1
84312: PPUSH
84313: LD_VAR 0 7
84317: PUSH
84318: LD_INT 1
84320: ARRAY
84321: PPUSH
84322: LD_VAR 0 7
84326: PUSH
84327: LD_INT 2
84329: ARRAY
84330: PPUSH
84331: LD_VAR 0 3
84335: PPUSH
84336: CALL_OW 48
// result := IsPlaced ( unit ) ;
84340: LD_ADDR_VAR 0 4
84344: PUSH
84345: LD_VAR 0 1
84349: PPUSH
84350: CALL_OW 305
84354: ST_TO_ADDR
// exit ;
84355: POP
84356: POP
84357: GO 84363
// end ; end ;
84359: GO 84238
84361: POP
84362: POP
// end ;
84363: LD_VAR 0 4
84367: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84368: LD_INT 0
84370: PPUSH
84371: PPUSH
84372: PPUSH
// if not side or side > 8 then
84373: LD_VAR 0 1
84377: NOT
84378: PUSH
84379: LD_VAR 0 1
84383: PUSH
84384: LD_INT 8
84386: GREATER
84387: OR
84388: IFFALSE 84392
// exit ;
84390: GO 84579
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84392: LD_ADDR_VAR 0 4
84396: PUSH
84397: LD_INT 22
84399: PUSH
84400: LD_VAR 0 1
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 21
84411: PUSH
84412: LD_INT 3
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PPUSH
84423: CALL_OW 69
84427: ST_TO_ADDR
// if not tmp then
84428: LD_VAR 0 4
84432: NOT
84433: IFFALSE 84437
// exit ;
84435: GO 84579
// enable_addtolog := true ;
84437: LD_ADDR_OWVAR 81
84441: PUSH
84442: LD_INT 1
84444: ST_TO_ADDR
// AddToLog ( [ ) ;
84445: LD_STRING [
84447: PPUSH
84448: CALL_OW 561
// for i in tmp do
84452: LD_ADDR_VAR 0 3
84456: PUSH
84457: LD_VAR 0 4
84461: PUSH
84462: FOR_IN
84463: IFFALSE 84570
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84465: LD_STRING [
84467: PUSH
84468: LD_VAR 0 3
84472: PPUSH
84473: CALL_OW 266
84477: STR
84478: PUSH
84479: LD_STRING , 
84481: STR
84482: PUSH
84483: LD_VAR 0 3
84487: PPUSH
84488: CALL_OW 250
84492: STR
84493: PUSH
84494: LD_STRING , 
84496: STR
84497: PUSH
84498: LD_VAR 0 3
84502: PPUSH
84503: CALL_OW 251
84507: STR
84508: PUSH
84509: LD_STRING , 
84511: STR
84512: PUSH
84513: LD_VAR 0 3
84517: PPUSH
84518: CALL_OW 254
84522: STR
84523: PUSH
84524: LD_STRING , 
84526: STR
84527: PUSH
84528: LD_VAR 0 3
84532: PPUSH
84533: LD_INT 1
84535: PPUSH
84536: CALL_OW 268
84540: STR
84541: PUSH
84542: LD_STRING , 
84544: STR
84545: PUSH
84546: LD_VAR 0 3
84550: PPUSH
84551: LD_INT 2
84553: PPUSH
84554: CALL_OW 268
84558: STR
84559: PUSH
84560: LD_STRING ],
84562: STR
84563: PPUSH
84564: CALL_OW 561
// end ;
84568: GO 84462
84570: POP
84571: POP
// AddToLog ( ]; ) ;
84572: LD_STRING ];
84574: PPUSH
84575: CALL_OW 561
// end ;
84579: LD_VAR 0 2
84583: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84584: LD_INT 0
84586: PPUSH
84587: PPUSH
84588: PPUSH
84589: PPUSH
84590: PPUSH
// if not area or not rate or not max then
84591: LD_VAR 0 1
84595: NOT
84596: PUSH
84597: LD_VAR 0 2
84601: NOT
84602: OR
84603: PUSH
84604: LD_VAR 0 4
84608: NOT
84609: OR
84610: IFFALSE 84614
// exit ;
84612: GO 84803
// while 1 do
84614: LD_INT 1
84616: IFFALSE 84803
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84618: LD_ADDR_VAR 0 9
84622: PUSH
84623: LD_VAR 0 1
84627: PPUSH
84628: LD_INT 1
84630: PPUSH
84631: CALL_OW 287
84635: PUSH
84636: LD_INT 10
84638: MUL
84639: ST_TO_ADDR
// r := rate / 10 ;
84640: LD_ADDR_VAR 0 7
84644: PUSH
84645: LD_VAR 0 2
84649: PUSH
84650: LD_INT 10
84652: DIVREAL
84653: ST_TO_ADDR
// time := 1 1$00 ;
84654: LD_ADDR_VAR 0 8
84658: PUSH
84659: LD_INT 2100
84661: ST_TO_ADDR
// if amount < min then
84662: LD_VAR 0 9
84666: PUSH
84667: LD_VAR 0 3
84671: LESS
84672: IFFALSE 84690
// r := r * 2 else
84674: LD_ADDR_VAR 0 7
84678: PUSH
84679: LD_VAR 0 7
84683: PUSH
84684: LD_INT 2
84686: MUL
84687: ST_TO_ADDR
84688: GO 84716
// if amount > max then
84690: LD_VAR 0 9
84694: PUSH
84695: LD_VAR 0 4
84699: GREATER
84700: IFFALSE 84716
// r := r / 2 ;
84702: LD_ADDR_VAR 0 7
84706: PUSH
84707: LD_VAR 0 7
84711: PUSH
84712: LD_INT 2
84714: DIVREAL
84715: ST_TO_ADDR
// time := time / r ;
84716: LD_ADDR_VAR 0 8
84720: PUSH
84721: LD_VAR 0 8
84725: PUSH
84726: LD_VAR 0 7
84730: DIVREAL
84731: ST_TO_ADDR
// if time < 0 then
84732: LD_VAR 0 8
84736: PUSH
84737: LD_INT 0
84739: LESS
84740: IFFALSE 84757
// time := time * - 1 ;
84742: LD_ADDR_VAR 0 8
84746: PUSH
84747: LD_VAR 0 8
84751: PUSH
84752: LD_INT 1
84754: NEG
84755: MUL
84756: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
84757: LD_VAR 0 8
84761: PUSH
84762: LD_INT 35
84764: PPUSH
84765: LD_INT 875
84767: PPUSH
84768: CALL_OW 12
84772: PLUS
84773: PPUSH
84774: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84778: LD_INT 1
84780: PPUSH
84781: LD_INT 5
84783: PPUSH
84784: CALL_OW 12
84788: PPUSH
84789: LD_VAR 0 1
84793: PPUSH
84794: LD_INT 1
84796: PPUSH
84797: CALL_OW 55
// end ;
84801: GO 84614
// end ;
84803: LD_VAR 0 5
84807: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84808: LD_INT 0
84810: PPUSH
84811: PPUSH
84812: PPUSH
84813: PPUSH
84814: PPUSH
84815: PPUSH
84816: PPUSH
84817: PPUSH
// if not turrets or not factories then
84818: LD_VAR 0 1
84822: NOT
84823: PUSH
84824: LD_VAR 0 2
84828: NOT
84829: OR
84830: IFFALSE 84834
// exit ;
84832: GO 85141
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84834: LD_ADDR_VAR 0 10
84838: PUSH
84839: LD_INT 5
84841: PUSH
84842: LD_INT 6
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 2
84851: PUSH
84852: LD_INT 4
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 3
84861: PUSH
84862: LD_INT 5
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 24
84876: PUSH
84877: LD_INT 25
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 23
84886: PUSH
84887: LD_INT 27
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: PUSH
84898: LD_INT 42
84900: PUSH
84901: LD_INT 43
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 44
84910: PUSH
84911: LD_INT 46
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: LD_INT 45
84920: PUSH
84921: LD_INT 47
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: LIST
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: LIST
84937: ST_TO_ADDR
// result := [ ] ;
84938: LD_ADDR_VAR 0 3
84942: PUSH
84943: EMPTY
84944: ST_TO_ADDR
// for i in turrets do
84945: LD_ADDR_VAR 0 4
84949: PUSH
84950: LD_VAR 0 1
84954: PUSH
84955: FOR_IN
84956: IFFALSE 85139
// begin nat := GetNation ( i ) ;
84958: LD_ADDR_VAR 0 7
84962: PUSH
84963: LD_VAR 0 4
84967: PPUSH
84968: CALL_OW 248
84972: ST_TO_ADDR
// weapon := 0 ;
84973: LD_ADDR_VAR 0 8
84977: PUSH
84978: LD_INT 0
84980: ST_TO_ADDR
// if not nat then
84981: LD_VAR 0 7
84985: NOT
84986: IFFALSE 84990
// continue ;
84988: GO 84955
// for j in list [ nat ] do
84990: LD_ADDR_VAR 0 5
84994: PUSH
84995: LD_VAR 0 10
84999: PUSH
85000: LD_VAR 0 7
85004: ARRAY
85005: PUSH
85006: FOR_IN
85007: IFFALSE 85048
// if GetBWeapon ( i ) = j [ 1 ] then
85009: LD_VAR 0 4
85013: PPUSH
85014: CALL_OW 269
85018: PUSH
85019: LD_VAR 0 5
85023: PUSH
85024: LD_INT 1
85026: ARRAY
85027: EQUAL
85028: IFFALSE 85046
// begin weapon := j [ 2 ] ;
85030: LD_ADDR_VAR 0 8
85034: PUSH
85035: LD_VAR 0 5
85039: PUSH
85040: LD_INT 2
85042: ARRAY
85043: ST_TO_ADDR
// break ;
85044: GO 85048
// end ;
85046: GO 85006
85048: POP
85049: POP
// if not weapon then
85050: LD_VAR 0 8
85054: NOT
85055: IFFALSE 85059
// continue ;
85057: GO 84955
// for k in factories do
85059: LD_ADDR_VAR 0 6
85063: PUSH
85064: LD_VAR 0 2
85068: PUSH
85069: FOR_IN
85070: IFFALSE 85135
// begin weapons := AvailableWeaponList ( k ) ;
85072: LD_ADDR_VAR 0 9
85076: PUSH
85077: LD_VAR 0 6
85081: PPUSH
85082: CALL_OW 478
85086: ST_TO_ADDR
// if not weapons then
85087: LD_VAR 0 9
85091: NOT
85092: IFFALSE 85096
// continue ;
85094: GO 85069
// if weapon in weapons then
85096: LD_VAR 0 8
85100: PUSH
85101: LD_VAR 0 9
85105: IN
85106: IFFALSE 85133
// begin result := [ i , weapon ] ;
85108: LD_ADDR_VAR 0 3
85112: PUSH
85113: LD_VAR 0 4
85117: PUSH
85118: LD_VAR 0 8
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: ST_TO_ADDR
// exit ;
85127: POP
85128: POP
85129: POP
85130: POP
85131: GO 85141
// end ; end ;
85133: GO 85069
85135: POP
85136: POP
// end ;
85137: GO 84955
85139: POP
85140: POP
// end ;
85141: LD_VAR 0 3
85145: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85146: LD_INT 0
85148: PPUSH
// if not side or side > 8 then
85149: LD_VAR 0 3
85153: NOT
85154: PUSH
85155: LD_VAR 0 3
85159: PUSH
85160: LD_INT 8
85162: GREATER
85163: OR
85164: IFFALSE 85168
// exit ;
85166: GO 85227
// if not range then
85168: LD_VAR 0 4
85172: NOT
85173: IFFALSE 85184
// range := - 12 ;
85175: LD_ADDR_VAR 0 4
85179: PUSH
85180: LD_INT 12
85182: NEG
85183: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
85184: LD_VAR 0 1
85188: PPUSH
85189: LD_VAR 0 2
85193: PPUSH
85194: LD_VAR 0 3
85198: PPUSH
85199: LD_VAR 0 4
85203: PPUSH
85204: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85208: LD_VAR 0 1
85212: PPUSH
85213: LD_VAR 0 2
85217: PPUSH
85218: LD_VAR 0 3
85222: PPUSH
85223: CALL_OW 331
// end ;
85227: LD_VAR 0 5
85231: RET
// export function Video ( mode ) ; begin
85232: LD_INT 0
85234: PPUSH
// ingame_video = mode ;
85235: LD_ADDR_OWVAR 52
85239: PUSH
85240: LD_VAR 0 1
85244: ST_TO_ADDR
// interface_hidden = mode ;
85245: LD_ADDR_OWVAR 54
85249: PUSH
85250: LD_VAR 0 1
85254: ST_TO_ADDR
// end ;
85255: LD_VAR 0 2
85259: RET
// export function Join ( array , element ) ; begin
85260: LD_INT 0
85262: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85263: LD_ADDR_VAR 0 3
85267: PUSH
85268: LD_VAR 0 1
85272: PPUSH
85273: LD_VAR 0 1
85277: PUSH
85278: LD_INT 1
85280: PLUS
85281: PPUSH
85282: LD_VAR 0 2
85286: PPUSH
85287: CALL_OW 1
85291: ST_TO_ADDR
// end ;
85292: LD_VAR 0 3
85296: RET
// export function JoinUnion ( array , element ) ; begin
85297: LD_INT 0
85299: PPUSH
// result := array union element ;
85300: LD_ADDR_VAR 0 3
85304: PUSH
85305: LD_VAR 0 1
85309: PUSH
85310: LD_VAR 0 2
85314: UNION
85315: ST_TO_ADDR
// end ;
85316: LD_VAR 0 3
85320: RET
// export function GetBehemoths ( side ) ; begin
85321: LD_INT 0
85323: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85324: LD_ADDR_VAR 0 2
85328: PUSH
85329: LD_INT 22
85331: PUSH
85332: LD_VAR 0 1
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 31
85343: PUSH
85344: LD_INT 25
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PPUSH
85355: CALL_OW 69
85359: ST_TO_ADDR
// end ;
85360: LD_VAR 0 2
85364: RET
// export function Shuffle ( array ) ; var i , index ; begin
85365: LD_INT 0
85367: PPUSH
85368: PPUSH
85369: PPUSH
// result := [ ] ;
85370: LD_ADDR_VAR 0 2
85374: PUSH
85375: EMPTY
85376: ST_TO_ADDR
// if not array then
85377: LD_VAR 0 1
85381: NOT
85382: IFFALSE 85386
// exit ;
85384: GO 85485
// Randomize ;
85386: CALL_OW 10
// for i = array downto 1 do
85390: LD_ADDR_VAR 0 3
85394: PUSH
85395: DOUBLE
85396: LD_VAR 0 1
85400: INC
85401: ST_TO_ADDR
85402: LD_INT 1
85404: PUSH
85405: FOR_DOWNTO
85406: IFFALSE 85483
// begin index := rand ( 1 , array ) ;
85408: LD_ADDR_VAR 0 4
85412: PUSH
85413: LD_INT 1
85415: PPUSH
85416: LD_VAR 0 1
85420: PPUSH
85421: CALL_OW 12
85425: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85426: LD_ADDR_VAR 0 2
85430: PUSH
85431: LD_VAR 0 2
85435: PPUSH
85436: LD_VAR 0 2
85440: PUSH
85441: LD_INT 1
85443: PLUS
85444: PPUSH
85445: LD_VAR 0 1
85449: PUSH
85450: LD_VAR 0 4
85454: ARRAY
85455: PPUSH
85456: CALL_OW 2
85460: ST_TO_ADDR
// array := Delete ( array , index ) ;
85461: LD_ADDR_VAR 0 1
85465: PUSH
85466: LD_VAR 0 1
85470: PPUSH
85471: LD_VAR 0 4
85475: PPUSH
85476: CALL_OW 3
85480: ST_TO_ADDR
// end ;
85481: GO 85405
85483: POP
85484: POP
// end ;
85485: LD_VAR 0 2
85489: RET
// export function GetBaseMaterials ( base ) ; begin
85490: LD_INT 0
85492: PPUSH
// result := [ 0 , 0 , 0 ] ;
85493: LD_ADDR_VAR 0 2
85497: PUSH
85498: LD_INT 0
85500: PUSH
85501: LD_INT 0
85503: PUSH
85504: LD_INT 0
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: LIST
85511: ST_TO_ADDR
// if not base then
85512: LD_VAR 0 1
85516: NOT
85517: IFFALSE 85521
// exit ;
85519: GO 85570
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85521: LD_ADDR_VAR 0 2
85525: PUSH
85526: LD_VAR 0 1
85530: PPUSH
85531: LD_INT 1
85533: PPUSH
85534: CALL_OW 275
85538: PUSH
85539: LD_VAR 0 1
85543: PPUSH
85544: LD_INT 2
85546: PPUSH
85547: CALL_OW 275
85551: PUSH
85552: LD_VAR 0 1
85556: PPUSH
85557: LD_INT 3
85559: PPUSH
85560: CALL_OW 275
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: LIST
85569: ST_TO_ADDR
// end ;
85570: LD_VAR 0 2
85574: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85575: LD_INT 0
85577: PPUSH
85578: PPUSH
// result := array ;
85579: LD_ADDR_VAR 0 3
85583: PUSH
85584: LD_VAR 0 1
85588: ST_TO_ADDR
// if size > 0 then
85589: LD_VAR 0 2
85593: PUSH
85594: LD_INT 0
85596: GREATER
85597: IFFALSE 85643
// for i := array downto size do
85599: LD_ADDR_VAR 0 4
85603: PUSH
85604: DOUBLE
85605: LD_VAR 0 1
85609: INC
85610: ST_TO_ADDR
85611: LD_VAR 0 2
85615: PUSH
85616: FOR_DOWNTO
85617: IFFALSE 85641
// result := Delete ( result , result ) ;
85619: LD_ADDR_VAR 0 3
85623: PUSH
85624: LD_VAR 0 3
85628: PPUSH
85629: LD_VAR 0 3
85633: PPUSH
85634: CALL_OW 3
85638: ST_TO_ADDR
85639: GO 85616
85641: POP
85642: POP
// end ;
85643: LD_VAR 0 3
85647: RET
// export function ComExit ( unit ) ; var tmp ; begin
85648: LD_INT 0
85650: PPUSH
85651: PPUSH
// if not IsInUnit ( unit ) then
85652: LD_VAR 0 1
85656: PPUSH
85657: CALL_OW 310
85661: NOT
85662: IFFALSE 85666
// exit ;
85664: GO 85726
// tmp := IsInUnit ( unit ) ;
85666: LD_ADDR_VAR 0 3
85670: PUSH
85671: LD_VAR 0 1
85675: PPUSH
85676: CALL_OW 310
85680: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85681: LD_VAR 0 3
85685: PPUSH
85686: CALL_OW 247
85690: PUSH
85691: LD_INT 2
85693: EQUAL
85694: IFFALSE 85707
// ComExitVehicle ( unit ) else
85696: LD_VAR 0 1
85700: PPUSH
85701: CALL_OW 121
85705: GO 85716
// ComExitBuilding ( unit ) ;
85707: LD_VAR 0 1
85711: PPUSH
85712: CALL_OW 122
// result := tmp ;
85716: LD_ADDR_VAR 0 2
85720: PUSH
85721: LD_VAR 0 3
85725: ST_TO_ADDR
// end ;
85726: LD_VAR 0 2
85730: RET
// export function ComExitAll ( units ) ; var i ; begin
85731: LD_INT 0
85733: PPUSH
85734: PPUSH
// if not units then
85735: LD_VAR 0 1
85739: NOT
85740: IFFALSE 85744
// exit ;
85742: GO 85770
// for i in units do
85744: LD_ADDR_VAR 0 3
85748: PUSH
85749: LD_VAR 0 1
85753: PUSH
85754: FOR_IN
85755: IFFALSE 85768
// ComExit ( i ) ;
85757: LD_VAR 0 3
85761: PPUSH
85762: CALL 85648 0 1
85766: GO 85754
85768: POP
85769: POP
// end ;
85770: LD_VAR 0 2
85774: RET
// export function ResetHc ; begin
85775: LD_INT 0
85777: PPUSH
// InitHc ;
85778: CALL_OW 19
// hc_importance := 0 ;
85782: LD_ADDR_OWVAR 32
85786: PUSH
85787: LD_INT 0
85789: ST_TO_ADDR
// end ;
85790: LD_VAR 0 1
85794: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85795: LD_INT 0
85797: PPUSH
85798: PPUSH
85799: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85800: LD_ADDR_VAR 0 6
85804: PUSH
85805: LD_VAR 0 1
85809: PUSH
85810: LD_VAR 0 3
85814: PLUS
85815: PUSH
85816: LD_INT 2
85818: DIV
85819: ST_TO_ADDR
// if _x < 0 then
85820: LD_VAR 0 6
85824: PUSH
85825: LD_INT 0
85827: LESS
85828: IFFALSE 85845
// _x := _x * - 1 ;
85830: LD_ADDR_VAR 0 6
85834: PUSH
85835: LD_VAR 0 6
85839: PUSH
85840: LD_INT 1
85842: NEG
85843: MUL
85844: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85845: LD_ADDR_VAR 0 7
85849: PUSH
85850: LD_VAR 0 2
85854: PUSH
85855: LD_VAR 0 4
85859: PLUS
85860: PUSH
85861: LD_INT 2
85863: DIV
85864: ST_TO_ADDR
// if _y < 0 then
85865: LD_VAR 0 7
85869: PUSH
85870: LD_INT 0
85872: LESS
85873: IFFALSE 85890
// _y := _y * - 1 ;
85875: LD_ADDR_VAR 0 7
85879: PUSH
85880: LD_VAR 0 7
85884: PUSH
85885: LD_INT 1
85887: NEG
85888: MUL
85889: ST_TO_ADDR
// result := [ _x , _y ] ;
85890: LD_ADDR_VAR 0 5
85894: PUSH
85895: LD_VAR 0 6
85899: PUSH
85900: LD_VAR 0 7
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: ST_TO_ADDR
// end ;
85909: LD_VAR 0 5
85913: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85914: LD_INT 0
85916: PPUSH
85917: PPUSH
85918: PPUSH
85919: PPUSH
// task := GetTaskList ( unit ) ;
85920: LD_ADDR_VAR 0 7
85924: PUSH
85925: LD_VAR 0 1
85929: PPUSH
85930: CALL_OW 437
85934: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85935: LD_VAR 0 7
85939: NOT
85940: PUSH
85941: LD_VAR 0 1
85945: PPUSH
85946: LD_VAR 0 2
85950: PPUSH
85951: CALL_OW 308
85955: NOT
85956: AND
85957: IFFALSE 85961
// exit ;
85959: GO 86079
// if IsInArea ( unit , area ) then
85961: LD_VAR 0 1
85965: PPUSH
85966: LD_VAR 0 2
85970: PPUSH
85971: CALL_OW 308
85975: IFFALSE 85993
// begin ComMoveToArea ( unit , goAway ) ;
85977: LD_VAR 0 1
85981: PPUSH
85982: LD_VAR 0 3
85986: PPUSH
85987: CALL_OW 113
// exit ;
85991: GO 86079
// end ; if task [ 1 ] [ 1 ] <> M then
85993: LD_VAR 0 7
85997: PUSH
85998: LD_INT 1
86000: ARRAY
86001: PUSH
86002: LD_INT 1
86004: ARRAY
86005: PUSH
86006: LD_STRING M
86008: NONEQUAL
86009: IFFALSE 86013
// exit ;
86011: GO 86079
// x := task [ 1 ] [ 2 ] ;
86013: LD_ADDR_VAR 0 5
86017: PUSH
86018: LD_VAR 0 7
86022: PUSH
86023: LD_INT 1
86025: ARRAY
86026: PUSH
86027: LD_INT 2
86029: ARRAY
86030: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86031: LD_ADDR_VAR 0 6
86035: PUSH
86036: LD_VAR 0 7
86040: PUSH
86041: LD_INT 1
86043: ARRAY
86044: PUSH
86045: LD_INT 3
86047: ARRAY
86048: ST_TO_ADDR
// if InArea ( x , y , area ) then
86049: LD_VAR 0 5
86053: PPUSH
86054: LD_VAR 0 6
86058: PPUSH
86059: LD_VAR 0 2
86063: PPUSH
86064: CALL_OW 309
86068: IFFALSE 86079
// ComStop ( unit ) ;
86070: LD_VAR 0 1
86074: PPUSH
86075: CALL_OW 141
// end ;
86079: LD_VAR 0 4
86083: RET
// export function Abs ( value ) ; begin
86084: LD_INT 0
86086: PPUSH
// result := value ;
86087: LD_ADDR_VAR 0 2
86091: PUSH
86092: LD_VAR 0 1
86096: ST_TO_ADDR
// if value < 0 then
86097: LD_VAR 0 1
86101: PUSH
86102: LD_INT 0
86104: LESS
86105: IFFALSE 86122
// result := value * - 1 ;
86107: LD_ADDR_VAR 0 2
86111: PUSH
86112: LD_VAR 0 1
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: MUL
86121: ST_TO_ADDR
// end ;
86122: LD_VAR 0 2
86126: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86127: LD_INT 0
86129: PPUSH
86130: PPUSH
86131: PPUSH
86132: PPUSH
86133: PPUSH
86134: PPUSH
86135: PPUSH
86136: PPUSH
// if not unit or not building then
86137: LD_VAR 0 1
86141: NOT
86142: PUSH
86143: LD_VAR 0 2
86147: NOT
86148: OR
86149: IFFALSE 86153
// exit ;
86151: GO 86379
// x := GetX ( building ) ;
86153: LD_ADDR_VAR 0 4
86157: PUSH
86158: LD_VAR 0 2
86162: PPUSH
86163: CALL_OW 250
86167: ST_TO_ADDR
// y := GetY ( building ) ;
86168: LD_ADDR_VAR 0 6
86172: PUSH
86173: LD_VAR 0 2
86177: PPUSH
86178: CALL_OW 251
86182: ST_TO_ADDR
// d := GetDir ( building ) ;
86183: LD_ADDR_VAR 0 8
86187: PUSH
86188: LD_VAR 0 2
86192: PPUSH
86193: CALL_OW 254
86197: ST_TO_ADDR
// r := 4 ;
86198: LD_ADDR_VAR 0 9
86202: PUSH
86203: LD_INT 4
86205: ST_TO_ADDR
// for i := 1 to 5 do
86206: LD_ADDR_VAR 0 10
86210: PUSH
86211: DOUBLE
86212: LD_INT 1
86214: DEC
86215: ST_TO_ADDR
86216: LD_INT 5
86218: PUSH
86219: FOR_TO
86220: IFFALSE 86377
// begin _x := ShiftX ( x , d , r + i ) ;
86222: LD_ADDR_VAR 0 5
86226: PUSH
86227: LD_VAR 0 4
86231: PPUSH
86232: LD_VAR 0 8
86236: PPUSH
86237: LD_VAR 0 9
86241: PUSH
86242: LD_VAR 0 10
86246: PLUS
86247: PPUSH
86248: CALL_OW 272
86252: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86253: LD_ADDR_VAR 0 7
86257: PUSH
86258: LD_VAR 0 6
86262: PPUSH
86263: LD_VAR 0 8
86267: PPUSH
86268: LD_VAR 0 9
86272: PUSH
86273: LD_VAR 0 10
86277: PLUS
86278: PPUSH
86279: CALL_OW 273
86283: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86284: LD_VAR 0 5
86288: PPUSH
86289: LD_VAR 0 7
86293: PPUSH
86294: CALL_OW 488
86298: PUSH
86299: LD_VAR 0 5
86303: PPUSH
86304: LD_VAR 0 7
86308: PPUSH
86309: CALL_OW 428
86313: PPUSH
86314: CALL_OW 247
86318: PUSH
86319: LD_INT 3
86321: PUSH
86322: LD_INT 2
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: IN
86329: NOT
86330: AND
86331: IFFALSE 86375
// begin ComMoveXY ( unit , _x , _y ) ;
86333: LD_VAR 0 1
86337: PPUSH
86338: LD_VAR 0 5
86342: PPUSH
86343: LD_VAR 0 7
86347: PPUSH
86348: CALL_OW 111
// result := [ _x , _y ] ;
86352: LD_ADDR_VAR 0 3
86356: PUSH
86357: LD_VAR 0 5
86361: PUSH
86362: LD_VAR 0 7
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: ST_TO_ADDR
// exit ;
86371: POP
86372: POP
86373: GO 86379
// end ; end ;
86375: GO 86219
86377: POP
86378: POP
// end ;
86379: LD_VAR 0 3
86383: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86384: LD_INT 0
86386: PPUSH
86387: PPUSH
86388: PPUSH
// result := 0 ;
86389: LD_ADDR_VAR 0 3
86393: PUSH
86394: LD_INT 0
86396: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86397: LD_VAR 0 1
86401: PUSH
86402: LD_INT 0
86404: LESS
86405: PUSH
86406: LD_VAR 0 1
86410: PUSH
86411: LD_INT 8
86413: GREATER
86414: OR
86415: PUSH
86416: LD_VAR 0 2
86420: PUSH
86421: LD_INT 0
86423: LESS
86424: OR
86425: PUSH
86426: LD_VAR 0 2
86430: PUSH
86431: LD_INT 8
86433: GREATER
86434: OR
86435: IFFALSE 86439
// exit ;
86437: GO 86514
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86439: LD_ADDR_VAR 0 4
86443: PUSH
86444: LD_INT 22
86446: PUSH
86447: LD_VAR 0 2
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PPUSH
86456: CALL_OW 69
86460: PUSH
86461: FOR_IN
86462: IFFALSE 86512
// begin un := UnitShoot ( i ) ;
86464: LD_ADDR_VAR 0 5
86468: PUSH
86469: LD_VAR 0 4
86473: PPUSH
86474: CALL_OW 504
86478: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86479: LD_VAR 0 5
86483: PPUSH
86484: CALL_OW 255
86488: PUSH
86489: LD_VAR 0 1
86493: EQUAL
86494: IFFALSE 86510
// begin result := un ;
86496: LD_ADDR_VAR 0 3
86500: PUSH
86501: LD_VAR 0 5
86505: ST_TO_ADDR
// exit ;
86506: POP
86507: POP
86508: GO 86514
// end ; end ;
86510: GO 86461
86512: POP
86513: POP
// end ;
86514: LD_VAR 0 3
86518: RET
// export function GetCargoBay ( units ) ; begin
86519: LD_INT 0
86521: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86522: LD_ADDR_VAR 0 2
86526: PUSH
86527: LD_VAR 0 1
86531: PPUSH
86532: LD_INT 2
86534: PUSH
86535: LD_INT 34
86537: PUSH
86538: LD_INT 12
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 34
86547: PUSH
86548: LD_INT 51
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 34
86557: PUSH
86558: LD_INT 32
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 34
86567: PUSH
86568: LD_EXP 95
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: PPUSH
86584: CALL_OW 72
86588: ST_TO_ADDR
// end ;
86589: LD_VAR 0 2
86593: RET
// export function Negate ( value ) ; begin
86594: LD_INT 0
86596: PPUSH
// result := not value ;
86597: LD_ADDR_VAR 0 2
86601: PUSH
86602: LD_VAR 0 1
86606: NOT
86607: ST_TO_ADDR
// end ;
86608: LD_VAR 0 2
86612: RET
// export function Inc ( value ) ; begin
86613: LD_INT 0
86615: PPUSH
// result := value + 1 ;
86616: LD_ADDR_VAR 0 2
86620: PUSH
86621: LD_VAR 0 1
86625: PUSH
86626: LD_INT 1
86628: PLUS
86629: ST_TO_ADDR
// end ;
86630: LD_VAR 0 2
86634: RET
// export function Dec ( value ) ; begin
86635: LD_INT 0
86637: PPUSH
// result := value - 1 ;
86638: LD_ADDR_VAR 0 2
86642: PUSH
86643: LD_VAR 0 1
86647: PUSH
86648: LD_INT 1
86650: MINUS
86651: ST_TO_ADDR
// end ;
86652: LD_VAR 0 2
86656: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
86657: LD_INT 0
86659: PPUSH
86660: PPUSH
86661: PPUSH
86662: PPUSH
86663: PPUSH
86664: PPUSH
86665: PPUSH
86666: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
86667: LD_VAR 0 1
86671: PPUSH
86672: LD_VAR 0 2
86676: PPUSH
86677: CALL_OW 488
86681: NOT
86682: PUSH
86683: LD_VAR 0 3
86687: PPUSH
86688: LD_VAR 0 4
86692: PPUSH
86693: CALL_OW 488
86697: NOT
86698: OR
86699: IFFALSE 86712
// begin result := - 1 ;
86701: LD_ADDR_VAR 0 5
86705: PUSH
86706: LD_INT 1
86708: NEG
86709: ST_TO_ADDR
// exit ;
86710: GO 86947
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
86712: LD_ADDR_VAR 0 12
86716: PUSH
86717: LD_VAR 0 1
86721: PPUSH
86722: LD_VAR 0 2
86726: PPUSH
86727: LD_VAR 0 3
86731: PPUSH
86732: LD_VAR 0 4
86736: PPUSH
86737: CALL 85795 0 4
86741: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
86742: LD_ADDR_VAR 0 11
86746: PUSH
86747: LD_VAR 0 1
86751: PPUSH
86752: LD_VAR 0 2
86756: PPUSH
86757: LD_VAR 0 12
86761: PUSH
86762: LD_INT 1
86764: ARRAY
86765: PPUSH
86766: LD_VAR 0 12
86770: PUSH
86771: LD_INT 2
86773: ARRAY
86774: PPUSH
86775: CALL_OW 298
86779: ST_TO_ADDR
// distance := 9999 ;
86780: LD_ADDR_VAR 0 10
86784: PUSH
86785: LD_INT 9999
86787: ST_TO_ADDR
// for i := 0 to 5 do
86788: LD_ADDR_VAR 0 6
86792: PUSH
86793: DOUBLE
86794: LD_INT 0
86796: DEC
86797: ST_TO_ADDR
86798: LD_INT 5
86800: PUSH
86801: FOR_TO
86802: IFFALSE 86945
// begin _x := ShiftX ( x1 , i , centerDist ) ;
86804: LD_ADDR_VAR 0 7
86808: PUSH
86809: LD_VAR 0 1
86813: PPUSH
86814: LD_VAR 0 6
86818: PPUSH
86819: LD_VAR 0 11
86823: PPUSH
86824: CALL_OW 272
86828: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
86829: LD_ADDR_VAR 0 8
86833: PUSH
86834: LD_VAR 0 2
86838: PPUSH
86839: LD_VAR 0 6
86843: PPUSH
86844: LD_VAR 0 11
86848: PPUSH
86849: CALL_OW 273
86853: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
86854: LD_VAR 0 7
86858: PPUSH
86859: LD_VAR 0 8
86863: PPUSH
86864: CALL_OW 488
86868: NOT
86869: IFFALSE 86873
// continue ;
86871: GO 86801
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
86873: LD_ADDR_VAR 0 9
86877: PUSH
86878: LD_VAR 0 12
86882: PUSH
86883: LD_INT 1
86885: ARRAY
86886: PPUSH
86887: LD_VAR 0 12
86891: PUSH
86892: LD_INT 2
86894: ARRAY
86895: PPUSH
86896: LD_VAR 0 7
86900: PPUSH
86901: LD_VAR 0 8
86905: PPUSH
86906: CALL_OW 298
86910: ST_TO_ADDR
// if tmp < distance then
86911: LD_VAR 0 9
86915: PUSH
86916: LD_VAR 0 10
86920: LESS
86921: IFFALSE 86943
// begin result := i ;
86923: LD_ADDR_VAR 0 5
86927: PUSH
86928: LD_VAR 0 6
86932: ST_TO_ADDR
// distance := tmp ;
86933: LD_ADDR_VAR 0 10
86937: PUSH
86938: LD_VAR 0 9
86942: ST_TO_ADDR
// end ; end ;
86943: GO 86801
86945: POP
86946: POP
// end ;
86947: LD_VAR 0 5
86951: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86952: LD_INT 0
86954: PPUSH
86955: PPUSH
// if not driver or not IsInUnit ( driver ) then
86956: LD_VAR 0 1
86960: NOT
86961: PUSH
86962: LD_VAR 0 1
86966: PPUSH
86967: CALL_OW 310
86971: NOT
86972: OR
86973: IFFALSE 86977
// exit ;
86975: GO 87067
// vehicle := IsInUnit ( driver ) ;
86977: LD_ADDR_VAR 0 3
86981: PUSH
86982: LD_VAR 0 1
86986: PPUSH
86987: CALL_OW 310
86991: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86992: LD_VAR 0 1
86996: PPUSH
86997: LD_STRING \
86999: PUSH
87000: LD_INT 0
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: LD_INT 0
87008: PUSH
87009: LD_INT 0
87011: PUSH
87012: LD_INT 0
87014: PUSH
87015: LD_INT 0
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: PUSH
87027: LD_STRING E
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: LD_VAR 0 3
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: LD_INT 0
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PPUSH
87063: CALL_OW 446
// end ;
87067: LD_VAR 0 2
87071: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87072: LD_INT 0
87074: PPUSH
87075: PPUSH
// if not driver or not IsInUnit ( driver ) then
87076: LD_VAR 0 1
87080: NOT
87081: PUSH
87082: LD_VAR 0 1
87086: PPUSH
87087: CALL_OW 310
87091: NOT
87092: OR
87093: IFFALSE 87097
// exit ;
87095: GO 87187
// vehicle := IsInUnit ( driver ) ;
87097: LD_ADDR_VAR 0 3
87101: PUSH
87102: LD_VAR 0 1
87106: PPUSH
87107: CALL_OW 310
87111: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87112: LD_VAR 0 1
87116: PPUSH
87117: LD_STRING \
87119: PUSH
87120: LD_INT 0
87122: PUSH
87123: LD_INT 0
87125: PUSH
87126: LD_INT 0
87128: PUSH
87129: LD_INT 0
87131: PUSH
87132: LD_INT 0
87134: PUSH
87135: LD_INT 0
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: PUSH
87147: LD_STRING E
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: LD_INT 0
87155: PUSH
87156: LD_VAR 0 3
87160: PUSH
87161: LD_INT 0
87163: PUSH
87164: LD_INT 0
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PPUSH
87183: CALL_OW 447
// end ;
87187: LD_VAR 0 2
87191: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
87192: LD_INT 0
87194: PPUSH
87195: PPUSH
87196: PPUSH
// tmp := [ ] ;
87197: LD_ADDR_VAR 0 5
87201: PUSH
87202: EMPTY
87203: ST_TO_ADDR
// for i in units do
87204: LD_ADDR_VAR 0 4
87208: PUSH
87209: LD_VAR 0 1
87213: PUSH
87214: FOR_IN
87215: IFFALSE 87253
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
87217: LD_ADDR_VAR 0 5
87221: PUSH
87222: LD_VAR 0 5
87226: PPUSH
87227: LD_VAR 0 5
87231: PUSH
87232: LD_INT 1
87234: PLUS
87235: PPUSH
87236: LD_VAR 0 4
87240: PPUSH
87241: CALL_OW 256
87245: PPUSH
87246: CALL_OW 2
87250: ST_TO_ADDR
87251: GO 87214
87253: POP
87254: POP
// if not tmp then
87255: LD_VAR 0 5
87259: NOT
87260: IFFALSE 87264
// exit ;
87262: GO 87312
// if asc then
87264: LD_VAR 0 2
87268: IFFALSE 87292
// result := SortListByListAsc ( units , tmp ) else
87270: LD_ADDR_VAR 0 3
87274: PUSH
87275: LD_VAR 0 1
87279: PPUSH
87280: LD_VAR 0 5
87284: PPUSH
87285: CALL_OW 76
87289: ST_TO_ADDR
87290: GO 87312
// result := SortListByListDesc ( units , tmp ) ;
87292: LD_ADDR_VAR 0 3
87296: PUSH
87297: LD_VAR 0 1
87301: PPUSH
87302: LD_VAR 0 5
87306: PPUSH
87307: CALL_OW 77
87311: ST_TO_ADDR
// end ;
87312: LD_VAR 0 3
87316: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
87317: LD_INT 0
87319: PPUSH
87320: PPUSH
// task := GetTaskList ( mech ) ;
87321: LD_ADDR_VAR 0 4
87325: PUSH
87326: LD_VAR 0 1
87330: PPUSH
87331: CALL_OW 437
87335: ST_TO_ADDR
// if not task then
87336: LD_VAR 0 4
87340: NOT
87341: IFFALSE 87345
// exit ;
87343: GO 87387
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
87345: LD_ADDR_VAR 0 3
87349: PUSH
87350: LD_VAR 0 4
87354: PUSH
87355: LD_INT 1
87357: ARRAY
87358: PUSH
87359: LD_INT 1
87361: ARRAY
87362: PUSH
87363: LD_STRING r
87365: EQUAL
87366: PUSH
87367: LD_VAR 0 4
87371: PUSH
87372: LD_INT 1
87374: ARRAY
87375: PUSH
87376: LD_INT 4
87378: ARRAY
87379: PUSH
87380: LD_VAR 0 2
87384: EQUAL
87385: AND
87386: ST_TO_ADDR
// end ;
87387: LD_VAR 0 3
87391: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
87392: LD_INT 0
87394: PPUSH
// SetDir ( unit , d ) ;
87395: LD_VAR 0 1
87399: PPUSH
87400: LD_VAR 0 4
87404: PPUSH
87405: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87409: LD_VAR 0 1
87413: PPUSH
87414: LD_VAR 0 2
87418: PPUSH
87419: LD_VAR 0 3
87423: PPUSH
87424: LD_VAR 0 5
87428: PPUSH
87429: CALL_OW 48
// end ;
87433: LD_VAR 0 6
87437: RET
// export function ToNaturalNumber ( number ) ; begin
87438: LD_INT 0
87440: PPUSH
// result := number div 1 ;
87441: LD_ADDR_VAR 0 2
87445: PUSH
87446: LD_VAR 0 1
87450: PUSH
87451: LD_INT 1
87453: DIV
87454: ST_TO_ADDR
// if number < 0 then
87455: LD_VAR 0 1
87459: PUSH
87460: LD_INT 0
87462: LESS
87463: IFFALSE 87473
// result := 0 ;
87465: LD_ADDR_VAR 0 2
87469: PUSH
87470: LD_INT 0
87472: ST_TO_ADDR
// end ;
87473: LD_VAR 0 2
87477: RET
// export function SortByClass ( units , class ) ; var un ; begin
87478: LD_INT 0
87480: PPUSH
87481: PPUSH
// if not units or not class then
87482: LD_VAR 0 1
87486: NOT
87487: PUSH
87488: LD_VAR 0 2
87492: NOT
87493: OR
87494: IFFALSE 87498
// exit ;
87496: GO 87593
// result := [ ] ;
87498: LD_ADDR_VAR 0 3
87502: PUSH
87503: EMPTY
87504: ST_TO_ADDR
// for un in units do
87505: LD_ADDR_VAR 0 4
87509: PUSH
87510: LD_VAR 0 1
87514: PUSH
87515: FOR_IN
87516: IFFALSE 87591
// if GetClass ( un ) = class then
87518: LD_VAR 0 4
87522: PPUSH
87523: CALL_OW 257
87527: PUSH
87528: LD_VAR 0 2
87532: EQUAL
87533: IFFALSE 87560
// result := Insert ( result , 1 , un ) else
87535: LD_ADDR_VAR 0 3
87539: PUSH
87540: LD_VAR 0 3
87544: PPUSH
87545: LD_INT 1
87547: PPUSH
87548: LD_VAR 0 4
87552: PPUSH
87553: CALL_OW 2
87557: ST_TO_ADDR
87558: GO 87589
// result := Replace ( result , result + 1 , un ) ;
87560: LD_ADDR_VAR 0 3
87564: PUSH
87565: LD_VAR 0 3
87569: PPUSH
87570: LD_VAR 0 3
87574: PUSH
87575: LD_INT 1
87577: PLUS
87578: PPUSH
87579: LD_VAR 0 4
87583: PPUSH
87584: CALL_OW 1
87588: ST_TO_ADDR
87589: GO 87515
87591: POP
87592: POP
// end ;
87593: LD_VAR 0 3
87597: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
87598: LD_INT 0
87600: PPUSH
87601: PPUSH
87602: PPUSH
87603: PPUSH
87604: PPUSH
87605: PPUSH
87606: PPUSH
// result := [ ] ;
87607: LD_ADDR_VAR 0 4
87611: PUSH
87612: EMPTY
87613: ST_TO_ADDR
// if x - r < 0 then
87614: LD_VAR 0 1
87618: PUSH
87619: LD_VAR 0 3
87623: MINUS
87624: PUSH
87625: LD_INT 0
87627: LESS
87628: IFFALSE 87640
// min_x := 0 else
87630: LD_ADDR_VAR 0 8
87634: PUSH
87635: LD_INT 0
87637: ST_TO_ADDR
87638: GO 87656
// min_x := x - r ;
87640: LD_ADDR_VAR 0 8
87644: PUSH
87645: LD_VAR 0 1
87649: PUSH
87650: LD_VAR 0 3
87654: MINUS
87655: ST_TO_ADDR
// if y - r < 0 then
87656: LD_VAR 0 2
87660: PUSH
87661: LD_VAR 0 3
87665: MINUS
87666: PUSH
87667: LD_INT 0
87669: LESS
87670: IFFALSE 87682
// min_y := 0 else
87672: LD_ADDR_VAR 0 7
87676: PUSH
87677: LD_INT 0
87679: ST_TO_ADDR
87680: GO 87698
// min_y := y - r ;
87682: LD_ADDR_VAR 0 7
87686: PUSH
87687: LD_VAR 0 2
87691: PUSH
87692: LD_VAR 0 3
87696: MINUS
87697: ST_TO_ADDR
// max_x := x + r ;
87698: LD_ADDR_VAR 0 9
87702: PUSH
87703: LD_VAR 0 1
87707: PUSH
87708: LD_VAR 0 3
87712: PLUS
87713: ST_TO_ADDR
// max_y := y + r ;
87714: LD_ADDR_VAR 0 10
87718: PUSH
87719: LD_VAR 0 2
87723: PUSH
87724: LD_VAR 0 3
87728: PLUS
87729: ST_TO_ADDR
// for _x = min_x to max_x do
87730: LD_ADDR_VAR 0 5
87734: PUSH
87735: DOUBLE
87736: LD_VAR 0 8
87740: DEC
87741: ST_TO_ADDR
87742: LD_VAR 0 9
87746: PUSH
87747: FOR_TO
87748: IFFALSE 87849
// for _y = min_y to max_y do
87750: LD_ADDR_VAR 0 6
87754: PUSH
87755: DOUBLE
87756: LD_VAR 0 7
87760: DEC
87761: ST_TO_ADDR
87762: LD_VAR 0 10
87766: PUSH
87767: FOR_TO
87768: IFFALSE 87845
// begin if not ValidHex ( _x , _y ) then
87770: LD_VAR 0 5
87774: PPUSH
87775: LD_VAR 0 6
87779: PPUSH
87780: CALL_OW 488
87784: NOT
87785: IFFALSE 87789
// continue ;
87787: GO 87767
// if GetResourceTypeXY ( _x , _y ) then
87789: LD_VAR 0 5
87793: PPUSH
87794: LD_VAR 0 6
87798: PPUSH
87799: CALL_OW 283
87803: IFFALSE 87843
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
87805: LD_ADDR_VAR 0 4
87809: PUSH
87810: LD_VAR 0 4
87814: PPUSH
87815: LD_VAR 0 4
87819: PUSH
87820: LD_INT 1
87822: PLUS
87823: PPUSH
87824: LD_VAR 0 5
87828: PUSH
87829: LD_VAR 0 6
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PPUSH
87838: CALL_OW 1
87842: ST_TO_ADDR
// end ;
87843: GO 87767
87845: POP
87846: POP
87847: GO 87747
87849: POP
87850: POP
// end ;
87851: LD_VAR 0 4
87855: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
87856: LD_INT 0
87858: PPUSH
87859: PPUSH
87860: PPUSH
87861: PPUSH
87862: PPUSH
87863: PPUSH
87864: PPUSH
87865: PPUSH
// if not units then
87866: LD_VAR 0 1
87870: NOT
87871: IFFALSE 87875
// exit ;
87873: GO 88386
// result := UnitFilter ( units , [ f_ok ] ) ;
87875: LD_ADDR_VAR 0 3
87879: PUSH
87880: LD_VAR 0 1
87884: PPUSH
87885: LD_INT 50
87887: PUSH
87888: EMPTY
87889: LIST
87890: PPUSH
87891: CALL_OW 72
87895: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
87896: LD_ADDR_VAR 0 8
87900: PUSH
87901: LD_VAR 0 1
87905: PUSH
87906: LD_INT 1
87908: ARRAY
87909: PPUSH
87910: CALL_OW 255
87914: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
87915: LD_ADDR_VAR 0 10
87919: PUSH
87920: LD_INT 29
87922: PUSH
87923: LD_EXP 98
87927: PUSH
87928: LD_INT 49
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: LIST
87935: ST_TO_ADDR
// if not result then
87936: LD_VAR 0 3
87940: NOT
87941: IFFALSE 87945
// exit ;
87943: GO 88386
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
87945: LD_ADDR_VAR 0 5
87949: PUSH
87950: LD_INT 81
87952: PUSH
87953: LD_VAR 0 8
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PPUSH
87962: CALL_OW 69
87966: ST_TO_ADDR
// for i in result do
87967: LD_ADDR_VAR 0 4
87971: PUSH
87972: LD_VAR 0 3
87976: PUSH
87977: FOR_IN
87978: IFFALSE 88384
// begin tag := GetTag ( i ) + 1 ;
87980: LD_ADDR_VAR 0 9
87984: PUSH
87985: LD_VAR 0 4
87989: PPUSH
87990: CALL_OW 110
87994: PUSH
87995: LD_INT 1
87997: PLUS
87998: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
87999: LD_ADDR_VAR 0 7
88003: PUSH
88004: LD_VAR 0 4
88008: PPUSH
88009: CALL_OW 250
88013: PPUSH
88014: LD_VAR 0 4
88018: PPUSH
88019: CALL_OW 251
88023: PPUSH
88024: LD_INT 6
88026: PPUSH
88027: CALL 87598 0 3
88031: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88032: LD_VAR 0 7
88036: PUSH
88037: LD_VAR 0 4
88041: PPUSH
88042: CALL_OW 264
88046: PUSH
88047: LD_VAR 0 10
88051: IN
88052: NOT
88053: AND
88054: IFFALSE 88093
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88056: LD_VAR 0 4
88060: PPUSH
88061: LD_VAR 0 7
88065: PUSH
88066: LD_INT 1
88068: ARRAY
88069: PUSH
88070: LD_INT 1
88072: ARRAY
88073: PPUSH
88074: LD_VAR 0 7
88078: PUSH
88079: LD_INT 1
88081: ARRAY
88082: PUSH
88083: LD_INT 2
88085: ARRAY
88086: PPUSH
88087: CALL_OW 116
88091: GO 88382
// if path > tag then
88093: LD_VAR 0 2
88097: PUSH
88098: LD_VAR 0 9
88102: GREATER
88103: IFFALSE 88311
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
88105: LD_ADDR_VAR 0 6
88109: PUSH
88110: LD_VAR 0 5
88114: PPUSH
88115: LD_INT 91
88117: PUSH
88118: LD_VAR 0 4
88122: PUSH
88123: LD_INT 12
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: LIST
88130: PPUSH
88131: CALL_OW 72
88135: ST_TO_ADDR
// if nearEnemy then
88136: LD_VAR 0 6
88140: IFFALSE 88209
// begin if GetWeapon ( i ) = ru_time_lapser then
88142: LD_VAR 0 4
88146: PPUSH
88147: CALL_OW 264
88151: PUSH
88152: LD_INT 49
88154: EQUAL
88155: IFFALSE 88183
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
88157: LD_VAR 0 4
88161: PPUSH
88162: LD_VAR 0 6
88166: PPUSH
88167: LD_VAR 0 4
88171: PPUSH
88172: CALL_OW 74
88176: PPUSH
88177: CALL_OW 112
88181: GO 88207
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
88183: LD_VAR 0 4
88187: PPUSH
88188: LD_VAR 0 6
88192: PPUSH
88193: LD_VAR 0 4
88197: PPUSH
88198: CALL_OW 74
88202: PPUSH
88203: CALL_OW 115
// end else
88207: GO 88309
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
88209: LD_VAR 0 4
88213: PPUSH
88214: LD_VAR 0 2
88218: PUSH
88219: LD_VAR 0 9
88223: ARRAY
88224: PUSH
88225: LD_INT 1
88227: ARRAY
88228: PPUSH
88229: LD_VAR 0 2
88233: PUSH
88234: LD_VAR 0 9
88238: ARRAY
88239: PUSH
88240: LD_INT 2
88242: ARRAY
88243: PPUSH
88244: CALL_OW 297
88248: PUSH
88249: LD_INT 6
88251: GREATER
88252: IFFALSE 88295
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
88254: LD_VAR 0 4
88258: PPUSH
88259: LD_VAR 0 2
88263: PUSH
88264: LD_VAR 0 9
88268: ARRAY
88269: PUSH
88270: LD_INT 1
88272: ARRAY
88273: PPUSH
88274: LD_VAR 0 2
88278: PUSH
88279: LD_VAR 0 9
88283: ARRAY
88284: PUSH
88285: LD_INT 2
88287: ARRAY
88288: PPUSH
88289: CALL_OW 114
88293: GO 88309
// SetTag ( i , tag ) ;
88295: LD_VAR 0 4
88299: PPUSH
88300: LD_VAR 0 9
88304: PPUSH
88305: CALL_OW 109
// end else
88309: GO 88382
// if enemy then
88311: LD_VAR 0 5
88315: IFFALSE 88382
// begin if GetWeapon ( i ) = ru_time_lapser then
88317: LD_VAR 0 4
88321: PPUSH
88322: CALL_OW 264
88326: PUSH
88327: LD_INT 49
88329: EQUAL
88330: IFFALSE 88358
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
88332: LD_VAR 0 4
88336: PPUSH
88337: LD_VAR 0 5
88341: PPUSH
88342: LD_VAR 0 4
88346: PPUSH
88347: CALL_OW 74
88351: PPUSH
88352: CALL_OW 112
88356: GO 88382
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
88358: LD_VAR 0 4
88362: PPUSH
88363: LD_VAR 0 5
88367: PPUSH
88368: LD_VAR 0 4
88372: PPUSH
88373: CALL_OW 74
88377: PPUSH
88378: CALL_OW 115
// end ; end ;
88382: GO 87977
88384: POP
88385: POP
// end ;
88386: LD_VAR 0 3
88390: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
88391: LD_INT 0
88393: PPUSH
88394: PPUSH
88395: PPUSH
// if not unit or IsInUnit ( unit ) then
88396: LD_VAR 0 1
88400: NOT
88401: PUSH
88402: LD_VAR 0 1
88406: PPUSH
88407: CALL_OW 310
88411: OR
88412: IFFALSE 88416
// exit ;
88414: GO 88507
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
88416: LD_ADDR_VAR 0 4
88420: PUSH
88421: LD_VAR 0 1
88425: PPUSH
88426: CALL_OW 250
88430: PPUSH
88431: LD_VAR 0 2
88435: PPUSH
88436: LD_INT 1
88438: PPUSH
88439: CALL_OW 272
88443: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
88444: LD_ADDR_VAR 0 5
88448: PUSH
88449: LD_VAR 0 1
88453: PPUSH
88454: CALL_OW 251
88458: PPUSH
88459: LD_VAR 0 2
88463: PPUSH
88464: LD_INT 1
88466: PPUSH
88467: CALL_OW 273
88471: ST_TO_ADDR
// if ValidHex ( x , y ) then
88472: LD_VAR 0 4
88476: PPUSH
88477: LD_VAR 0 5
88481: PPUSH
88482: CALL_OW 488
88486: IFFALSE 88507
// ComTurnXY ( unit , x , y ) ;
88488: LD_VAR 0 1
88492: PPUSH
88493: LD_VAR 0 4
88497: PPUSH
88498: LD_VAR 0 5
88502: PPUSH
88503: CALL_OW 118
// end ;
88507: LD_VAR 0 3
88511: RET
// export function SeeUnits ( side , units ) ; var i ; begin
88512: LD_INT 0
88514: PPUSH
88515: PPUSH
// result := false ;
88516: LD_ADDR_VAR 0 3
88520: PUSH
88521: LD_INT 0
88523: ST_TO_ADDR
// if not units then
88524: LD_VAR 0 2
88528: NOT
88529: IFFALSE 88533
// exit ;
88531: GO 88578
// for i in units do
88533: LD_ADDR_VAR 0 4
88537: PUSH
88538: LD_VAR 0 2
88542: PUSH
88543: FOR_IN
88544: IFFALSE 88576
// if See ( side , i ) then
88546: LD_VAR 0 1
88550: PPUSH
88551: LD_VAR 0 4
88555: PPUSH
88556: CALL_OW 292
88560: IFFALSE 88574
// begin result := true ;
88562: LD_ADDR_VAR 0 3
88566: PUSH
88567: LD_INT 1
88569: ST_TO_ADDR
// exit ;
88570: POP
88571: POP
88572: GO 88578
// end ;
88574: GO 88543
88576: POP
88577: POP
// end ;
88578: LD_VAR 0 3
88582: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
88583: LD_INT 0
88585: PPUSH
88586: PPUSH
88587: PPUSH
88588: PPUSH
// if not unit or not points then
88589: LD_VAR 0 1
88593: NOT
88594: PUSH
88595: LD_VAR 0 2
88599: NOT
88600: OR
88601: IFFALSE 88605
// exit ;
88603: GO 88695
// dist := 99999 ;
88605: LD_ADDR_VAR 0 5
88609: PUSH
88610: LD_INT 99999
88612: ST_TO_ADDR
// for i in points do
88613: LD_ADDR_VAR 0 4
88617: PUSH
88618: LD_VAR 0 2
88622: PUSH
88623: FOR_IN
88624: IFFALSE 88693
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
88626: LD_ADDR_VAR 0 6
88630: PUSH
88631: LD_VAR 0 1
88635: PPUSH
88636: LD_VAR 0 4
88640: PUSH
88641: LD_INT 1
88643: ARRAY
88644: PPUSH
88645: LD_VAR 0 4
88649: PUSH
88650: LD_INT 2
88652: ARRAY
88653: PPUSH
88654: CALL_OW 297
88658: ST_TO_ADDR
// if tmpDist < dist then
88659: LD_VAR 0 6
88663: PUSH
88664: LD_VAR 0 5
88668: LESS
88669: IFFALSE 88691
// begin result := i ;
88671: LD_ADDR_VAR 0 3
88675: PUSH
88676: LD_VAR 0 4
88680: ST_TO_ADDR
// dist := tmpDist ;
88681: LD_ADDR_VAR 0 5
88685: PUSH
88686: LD_VAR 0 6
88690: ST_TO_ADDR
// end ; end ;
88691: GO 88623
88693: POP
88694: POP
// end ;
88695: LD_VAR 0 3
88699: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
88700: LD_INT 0
88702: PPUSH
// uc_side := side ;
88703: LD_ADDR_OWVAR 20
88707: PUSH
88708: LD_VAR 0 1
88712: ST_TO_ADDR
// uc_nation := 3 ;
88713: LD_ADDR_OWVAR 21
88717: PUSH
88718: LD_INT 3
88720: ST_TO_ADDR
// vc_chassis := 25 ;
88721: LD_ADDR_OWVAR 37
88725: PUSH
88726: LD_INT 25
88728: ST_TO_ADDR
// vc_engine := engine_siberite ;
88729: LD_ADDR_OWVAR 39
88733: PUSH
88734: LD_INT 3
88736: ST_TO_ADDR
// vc_control := control_computer ;
88737: LD_ADDR_OWVAR 38
88741: PUSH
88742: LD_INT 3
88744: ST_TO_ADDR
// vc_weapon := 59 ;
88745: LD_ADDR_OWVAR 40
88749: PUSH
88750: LD_INT 59
88752: ST_TO_ADDR
// result := CreateVehicle ;
88753: LD_ADDR_VAR 0 5
88757: PUSH
88758: CALL_OW 45
88762: ST_TO_ADDR
// SetDir ( result , d ) ;
88763: LD_VAR 0 5
88767: PPUSH
88768: LD_VAR 0 4
88772: PPUSH
88773: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
88777: LD_VAR 0 5
88781: PPUSH
88782: LD_VAR 0 2
88786: PPUSH
88787: LD_VAR 0 3
88791: PPUSH
88792: LD_INT 0
88794: PPUSH
88795: CALL_OW 48
// end ;
88799: LD_VAR 0 5
88803: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
88804: LD_INT 0
88806: PPUSH
88807: PPUSH
88808: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
88809: LD_ADDR_VAR 0 2
88813: PUSH
88814: LD_INT 0
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: LD_INT 0
88822: PUSH
88823: LD_INT 0
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
88832: LD_VAR 0 1
88836: NOT
88837: PUSH
88838: LD_VAR 0 1
88842: PPUSH
88843: CALL_OW 264
88847: PUSH
88848: LD_INT 12
88850: PUSH
88851: LD_INT 51
88853: PUSH
88854: LD_INT 32
88856: PUSH
88857: LD_EXP 95
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: IN
88868: NOT
88869: OR
88870: IFFALSE 88874
// exit ;
88872: GO 88972
// for i := 1 to 3 do
88874: LD_ADDR_VAR 0 3
88878: PUSH
88879: DOUBLE
88880: LD_INT 1
88882: DEC
88883: ST_TO_ADDR
88884: LD_INT 3
88886: PUSH
88887: FOR_TO
88888: IFFALSE 88970
// begin tmp := GetCargo ( cargo , i ) ;
88890: LD_ADDR_VAR 0 4
88894: PUSH
88895: LD_VAR 0 1
88899: PPUSH
88900: LD_VAR 0 3
88904: PPUSH
88905: CALL_OW 289
88909: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
88910: LD_ADDR_VAR 0 2
88914: PUSH
88915: LD_VAR 0 2
88919: PPUSH
88920: LD_VAR 0 3
88924: PPUSH
88925: LD_VAR 0 4
88929: PPUSH
88930: CALL_OW 1
88934: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
88935: LD_ADDR_VAR 0 2
88939: PUSH
88940: LD_VAR 0 2
88944: PPUSH
88945: LD_INT 4
88947: PPUSH
88948: LD_VAR 0 2
88952: PUSH
88953: LD_INT 4
88955: ARRAY
88956: PUSH
88957: LD_VAR 0 4
88961: PLUS
88962: PPUSH
88963: CALL_OW 1
88967: ST_TO_ADDR
// end ;
88968: GO 88887
88970: POP
88971: POP
// end ; end_of_file
88972: LD_VAR 0 2
88976: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
88977: LD_INT 0
88979: PPUSH
// ar_miner := 81 ;
88980: LD_ADDR_EXP 101
88984: PUSH
88985: LD_INT 81
88987: ST_TO_ADDR
// ar_crane := 88 ;
88988: LD_ADDR_EXP 100
88992: PUSH
88993: LD_INT 88
88995: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
88996: LD_ADDR_EXP 95
89000: PUSH
89001: LD_INT 89
89003: ST_TO_ADDR
// us_hack := 99 ;
89004: LD_ADDR_EXP 96
89008: PUSH
89009: LD_INT 99
89011: ST_TO_ADDR
// us_artillery := 97 ;
89012: LD_ADDR_EXP 97
89016: PUSH
89017: LD_INT 97
89019: ST_TO_ADDR
// ar_bio_bomb := 91 ;
89020: LD_ADDR_EXP 98
89024: PUSH
89025: LD_INT 91
89027: ST_TO_ADDR
// ar_mortar := 92 ;
89028: LD_ADDR_EXP 99
89032: PUSH
89033: LD_INT 92
89035: ST_TO_ADDR
// ru_flamethrower := 93 ;
89036: LD_ADDR_EXP 102
89040: PUSH
89041: LD_INT 93
89043: ST_TO_ADDR
// ru_radar := 98 ;
89044: LD_ADDR_EXP 94
89048: PUSH
89049: LD_INT 98
89051: ST_TO_ADDR
// tech_Artillery := 80 ;
89052: LD_ADDR_EXP 103
89056: PUSH
89057: LD_INT 80
89059: ST_TO_ADDR
// tech_RadMat := 81 ;
89060: LD_ADDR_EXP 104
89064: PUSH
89065: LD_INT 81
89067: ST_TO_ADDR
// tech_BasicTools := 82 ;
89068: LD_ADDR_EXP 105
89072: PUSH
89073: LD_INT 82
89075: ST_TO_ADDR
// tech_Cargo := 83 ;
89076: LD_ADDR_EXP 106
89080: PUSH
89081: LD_INT 83
89083: ST_TO_ADDR
// tech_Track := 84 ;
89084: LD_ADDR_EXP 107
89088: PUSH
89089: LD_INT 84
89091: ST_TO_ADDR
// tech_Crane := 85 ;
89092: LD_ADDR_EXP 108
89096: PUSH
89097: LD_INT 85
89099: ST_TO_ADDR
// tech_Bulldozer := 86 ;
89100: LD_ADDR_EXP 109
89104: PUSH
89105: LD_INT 86
89107: ST_TO_ADDR
// tech_Hovercraft := 87 ;
89108: LD_ADDR_EXP 110
89112: PUSH
89113: LD_INT 87
89115: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
89116: LD_ADDR_EXP 111
89120: PUSH
89121: LD_INT 88
89123: ST_TO_ADDR
// class_mastodont := 31 ;
89124: LD_ADDR_EXP 112
89128: PUSH
89129: LD_INT 31
89131: ST_TO_ADDR
// class_horse := 21 ;
89132: LD_ADDR_EXP 113
89136: PUSH
89137: LD_INT 21
89139: ST_TO_ADDR
// end ;
89140: LD_VAR 0 1
89144: RET
// every 1 do
89145: GO 89147
89147: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
89148: CALL 88977 0 0
89152: END
// every 0 0$1 do
89153: GO 89155
89155: DISABLE
// begin enable ;
89156: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89157: LD_STRING updateTimer(
89159: PUSH
89160: LD_OWVAR 1
89164: STR
89165: PUSH
89166: LD_STRING );
89168: STR
89169: PPUSH
89170: CALL_OW 559
// end ;
89174: END
// export function SOS_MapStart ( ) ; begin
89175: LD_INT 0
89177: PPUSH
// if streamModeActive then
89178: LD_EXP 114
89182: IFFALSE 89191
// DefineStreamItems ( true ) ;
89184: LD_INT 1
89186: PPUSH
89187: CALL 90841 0 1
// UpdateFactoryWaypoints ( ) ;
89191: CALL 104425 0 0
// end ;
89195: LD_VAR 0 1
89199: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89200: LD_INT 0
89202: PPUSH
// if p2 = 100 then
89203: LD_VAR 0 2
89207: PUSH
89208: LD_INT 100
89210: EQUAL
89211: IFFALSE 90214
// begin if not StreamModeActive then
89213: LD_EXP 114
89217: NOT
89218: IFFALSE 89228
// StreamModeActive := true ;
89220: LD_ADDR_EXP 114
89224: PUSH
89225: LD_INT 1
89227: ST_TO_ADDR
// if p3 = 0 then
89228: LD_VAR 0 3
89232: PUSH
89233: LD_INT 0
89235: EQUAL
89236: IFFALSE 89242
// InitStreamMode ;
89238: CALL 90377 0 0
// if p3 = 1 then
89242: LD_VAR 0 3
89246: PUSH
89247: LD_INT 1
89249: EQUAL
89250: IFFALSE 89260
// sRocket := true ;
89252: LD_ADDR_EXP 119
89256: PUSH
89257: LD_INT 1
89259: ST_TO_ADDR
// if p3 = 2 then
89260: LD_VAR 0 3
89264: PUSH
89265: LD_INT 2
89267: EQUAL
89268: IFFALSE 89278
// sSpeed := true ;
89270: LD_ADDR_EXP 118
89274: PUSH
89275: LD_INT 1
89277: ST_TO_ADDR
// if p3 = 3 then
89278: LD_VAR 0 3
89282: PUSH
89283: LD_INT 3
89285: EQUAL
89286: IFFALSE 89296
// sEngine := true ;
89288: LD_ADDR_EXP 120
89292: PUSH
89293: LD_INT 1
89295: ST_TO_ADDR
// if p3 = 4 then
89296: LD_VAR 0 3
89300: PUSH
89301: LD_INT 4
89303: EQUAL
89304: IFFALSE 89314
// sSpec := true ;
89306: LD_ADDR_EXP 117
89310: PUSH
89311: LD_INT 1
89313: ST_TO_ADDR
// if p3 = 5 then
89314: LD_VAR 0 3
89318: PUSH
89319: LD_INT 5
89321: EQUAL
89322: IFFALSE 89332
// sLevel := true ;
89324: LD_ADDR_EXP 121
89328: PUSH
89329: LD_INT 1
89331: ST_TO_ADDR
// if p3 = 6 then
89332: LD_VAR 0 3
89336: PUSH
89337: LD_INT 6
89339: EQUAL
89340: IFFALSE 89350
// sArmoury := true ;
89342: LD_ADDR_EXP 122
89346: PUSH
89347: LD_INT 1
89349: ST_TO_ADDR
// if p3 = 7 then
89350: LD_VAR 0 3
89354: PUSH
89355: LD_INT 7
89357: EQUAL
89358: IFFALSE 89368
// sRadar := true ;
89360: LD_ADDR_EXP 123
89364: PUSH
89365: LD_INT 1
89367: ST_TO_ADDR
// if p3 = 8 then
89368: LD_VAR 0 3
89372: PUSH
89373: LD_INT 8
89375: EQUAL
89376: IFFALSE 89386
// sBunker := true ;
89378: LD_ADDR_EXP 124
89382: PUSH
89383: LD_INT 1
89385: ST_TO_ADDR
// if p3 = 9 then
89386: LD_VAR 0 3
89390: PUSH
89391: LD_INT 9
89393: EQUAL
89394: IFFALSE 89404
// sHack := true ;
89396: LD_ADDR_EXP 125
89400: PUSH
89401: LD_INT 1
89403: ST_TO_ADDR
// if p3 = 10 then
89404: LD_VAR 0 3
89408: PUSH
89409: LD_INT 10
89411: EQUAL
89412: IFFALSE 89422
// sFire := true ;
89414: LD_ADDR_EXP 126
89418: PUSH
89419: LD_INT 1
89421: ST_TO_ADDR
// if p3 = 11 then
89422: LD_VAR 0 3
89426: PUSH
89427: LD_INT 11
89429: EQUAL
89430: IFFALSE 89440
// sRefresh := true ;
89432: LD_ADDR_EXP 127
89436: PUSH
89437: LD_INT 1
89439: ST_TO_ADDR
// if p3 = 12 then
89440: LD_VAR 0 3
89444: PUSH
89445: LD_INT 12
89447: EQUAL
89448: IFFALSE 89458
// sExp := true ;
89450: LD_ADDR_EXP 128
89454: PUSH
89455: LD_INT 1
89457: ST_TO_ADDR
// if p3 = 13 then
89458: LD_VAR 0 3
89462: PUSH
89463: LD_INT 13
89465: EQUAL
89466: IFFALSE 89476
// sDepot := true ;
89468: LD_ADDR_EXP 129
89472: PUSH
89473: LD_INT 1
89475: ST_TO_ADDR
// if p3 = 14 then
89476: LD_VAR 0 3
89480: PUSH
89481: LD_INT 14
89483: EQUAL
89484: IFFALSE 89494
// sFlag := true ;
89486: LD_ADDR_EXP 130
89490: PUSH
89491: LD_INT 1
89493: ST_TO_ADDR
// if p3 = 15 then
89494: LD_VAR 0 3
89498: PUSH
89499: LD_INT 15
89501: EQUAL
89502: IFFALSE 89512
// sKamikadze := true ;
89504: LD_ADDR_EXP 138
89508: PUSH
89509: LD_INT 1
89511: ST_TO_ADDR
// if p3 = 16 then
89512: LD_VAR 0 3
89516: PUSH
89517: LD_INT 16
89519: EQUAL
89520: IFFALSE 89530
// sTroll := true ;
89522: LD_ADDR_EXP 139
89526: PUSH
89527: LD_INT 1
89529: ST_TO_ADDR
// if p3 = 17 then
89530: LD_VAR 0 3
89534: PUSH
89535: LD_INT 17
89537: EQUAL
89538: IFFALSE 89548
// sSlow := true ;
89540: LD_ADDR_EXP 140
89544: PUSH
89545: LD_INT 1
89547: ST_TO_ADDR
// if p3 = 18 then
89548: LD_VAR 0 3
89552: PUSH
89553: LD_INT 18
89555: EQUAL
89556: IFFALSE 89566
// sLack := true ;
89558: LD_ADDR_EXP 141
89562: PUSH
89563: LD_INT 1
89565: ST_TO_ADDR
// if p3 = 19 then
89566: LD_VAR 0 3
89570: PUSH
89571: LD_INT 19
89573: EQUAL
89574: IFFALSE 89584
// sTank := true ;
89576: LD_ADDR_EXP 143
89580: PUSH
89581: LD_INT 1
89583: ST_TO_ADDR
// if p3 = 20 then
89584: LD_VAR 0 3
89588: PUSH
89589: LD_INT 20
89591: EQUAL
89592: IFFALSE 89602
// sRemote := true ;
89594: LD_ADDR_EXP 144
89598: PUSH
89599: LD_INT 1
89601: ST_TO_ADDR
// if p3 = 21 then
89602: LD_VAR 0 3
89606: PUSH
89607: LD_INT 21
89609: EQUAL
89610: IFFALSE 89620
// sPowell := true ;
89612: LD_ADDR_EXP 145
89616: PUSH
89617: LD_INT 1
89619: ST_TO_ADDR
// if p3 = 22 then
89620: LD_VAR 0 3
89624: PUSH
89625: LD_INT 22
89627: EQUAL
89628: IFFALSE 89638
// sTeleport := true ;
89630: LD_ADDR_EXP 148
89634: PUSH
89635: LD_INT 1
89637: ST_TO_ADDR
// if p3 = 23 then
89638: LD_VAR 0 3
89642: PUSH
89643: LD_INT 23
89645: EQUAL
89646: IFFALSE 89656
// sOilTower := true ;
89648: LD_ADDR_EXP 150
89652: PUSH
89653: LD_INT 1
89655: ST_TO_ADDR
// if p3 = 24 then
89656: LD_VAR 0 3
89660: PUSH
89661: LD_INT 24
89663: EQUAL
89664: IFFALSE 89674
// sShovel := true ;
89666: LD_ADDR_EXP 151
89670: PUSH
89671: LD_INT 1
89673: ST_TO_ADDR
// if p3 = 25 then
89674: LD_VAR 0 3
89678: PUSH
89679: LD_INT 25
89681: EQUAL
89682: IFFALSE 89692
// sSheik := true ;
89684: LD_ADDR_EXP 152
89688: PUSH
89689: LD_INT 1
89691: ST_TO_ADDR
// if p3 = 26 then
89692: LD_VAR 0 3
89696: PUSH
89697: LD_INT 26
89699: EQUAL
89700: IFFALSE 89710
// sEarthquake := true ;
89702: LD_ADDR_EXP 154
89706: PUSH
89707: LD_INT 1
89709: ST_TO_ADDR
// if p3 = 27 then
89710: LD_VAR 0 3
89714: PUSH
89715: LD_INT 27
89717: EQUAL
89718: IFFALSE 89728
// sAI := true ;
89720: LD_ADDR_EXP 155
89724: PUSH
89725: LD_INT 1
89727: ST_TO_ADDR
// if p3 = 28 then
89728: LD_VAR 0 3
89732: PUSH
89733: LD_INT 28
89735: EQUAL
89736: IFFALSE 89746
// sCargo := true ;
89738: LD_ADDR_EXP 158
89742: PUSH
89743: LD_INT 1
89745: ST_TO_ADDR
// if p3 = 29 then
89746: LD_VAR 0 3
89750: PUSH
89751: LD_INT 29
89753: EQUAL
89754: IFFALSE 89764
// sDLaser := true ;
89756: LD_ADDR_EXP 159
89760: PUSH
89761: LD_INT 1
89763: ST_TO_ADDR
// if p3 = 30 then
89764: LD_VAR 0 3
89768: PUSH
89769: LD_INT 30
89771: EQUAL
89772: IFFALSE 89782
// sExchange := true ;
89774: LD_ADDR_EXP 160
89778: PUSH
89779: LD_INT 1
89781: ST_TO_ADDR
// if p3 = 31 then
89782: LD_VAR 0 3
89786: PUSH
89787: LD_INT 31
89789: EQUAL
89790: IFFALSE 89800
// sFac := true ;
89792: LD_ADDR_EXP 161
89796: PUSH
89797: LD_INT 1
89799: ST_TO_ADDR
// if p3 = 32 then
89800: LD_VAR 0 3
89804: PUSH
89805: LD_INT 32
89807: EQUAL
89808: IFFALSE 89818
// sPower := true ;
89810: LD_ADDR_EXP 162
89814: PUSH
89815: LD_INT 1
89817: ST_TO_ADDR
// if p3 = 33 then
89818: LD_VAR 0 3
89822: PUSH
89823: LD_INT 33
89825: EQUAL
89826: IFFALSE 89836
// sRandom := true ;
89828: LD_ADDR_EXP 163
89832: PUSH
89833: LD_INT 1
89835: ST_TO_ADDR
// if p3 = 34 then
89836: LD_VAR 0 3
89840: PUSH
89841: LD_INT 34
89843: EQUAL
89844: IFFALSE 89854
// sShield := true ;
89846: LD_ADDR_EXP 164
89850: PUSH
89851: LD_INT 1
89853: ST_TO_ADDR
// if p3 = 35 then
89854: LD_VAR 0 3
89858: PUSH
89859: LD_INT 35
89861: EQUAL
89862: IFFALSE 89872
// sTime := true ;
89864: LD_ADDR_EXP 165
89868: PUSH
89869: LD_INT 1
89871: ST_TO_ADDR
// if p3 = 36 then
89872: LD_VAR 0 3
89876: PUSH
89877: LD_INT 36
89879: EQUAL
89880: IFFALSE 89890
// sTools := true ;
89882: LD_ADDR_EXP 166
89886: PUSH
89887: LD_INT 1
89889: ST_TO_ADDR
// if p3 = 101 then
89890: LD_VAR 0 3
89894: PUSH
89895: LD_INT 101
89897: EQUAL
89898: IFFALSE 89908
// sSold := true ;
89900: LD_ADDR_EXP 131
89904: PUSH
89905: LD_INT 1
89907: ST_TO_ADDR
// if p3 = 102 then
89908: LD_VAR 0 3
89912: PUSH
89913: LD_INT 102
89915: EQUAL
89916: IFFALSE 89926
// sDiff := true ;
89918: LD_ADDR_EXP 132
89922: PUSH
89923: LD_INT 1
89925: ST_TO_ADDR
// if p3 = 103 then
89926: LD_VAR 0 3
89930: PUSH
89931: LD_INT 103
89933: EQUAL
89934: IFFALSE 89944
// sFog := true ;
89936: LD_ADDR_EXP 135
89940: PUSH
89941: LD_INT 1
89943: ST_TO_ADDR
// if p3 = 104 then
89944: LD_VAR 0 3
89948: PUSH
89949: LD_INT 104
89951: EQUAL
89952: IFFALSE 89962
// sReset := true ;
89954: LD_ADDR_EXP 136
89958: PUSH
89959: LD_INT 1
89961: ST_TO_ADDR
// if p3 = 105 then
89962: LD_VAR 0 3
89966: PUSH
89967: LD_INT 105
89969: EQUAL
89970: IFFALSE 89980
// sSun := true ;
89972: LD_ADDR_EXP 137
89976: PUSH
89977: LD_INT 1
89979: ST_TO_ADDR
// if p3 = 106 then
89980: LD_VAR 0 3
89984: PUSH
89985: LD_INT 106
89987: EQUAL
89988: IFFALSE 89998
// sTiger := true ;
89990: LD_ADDR_EXP 133
89994: PUSH
89995: LD_INT 1
89997: ST_TO_ADDR
// if p3 = 107 then
89998: LD_VAR 0 3
90002: PUSH
90003: LD_INT 107
90005: EQUAL
90006: IFFALSE 90016
// sBomb := true ;
90008: LD_ADDR_EXP 134
90012: PUSH
90013: LD_INT 1
90015: ST_TO_ADDR
// if p3 = 108 then
90016: LD_VAR 0 3
90020: PUSH
90021: LD_INT 108
90023: EQUAL
90024: IFFALSE 90034
// sWound := true ;
90026: LD_ADDR_EXP 142
90030: PUSH
90031: LD_INT 1
90033: ST_TO_ADDR
// if p3 = 109 then
90034: LD_VAR 0 3
90038: PUSH
90039: LD_INT 109
90041: EQUAL
90042: IFFALSE 90052
// sBetray := true ;
90044: LD_ADDR_EXP 146
90048: PUSH
90049: LD_INT 1
90051: ST_TO_ADDR
// if p3 = 110 then
90052: LD_VAR 0 3
90056: PUSH
90057: LD_INT 110
90059: EQUAL
90060: IFFALSE 90070
// sContamin := true ;
90062: LD_ADDR_EXP 147
90066: PUSH
90067: LD_INT 1
90069: ST_TO_ADDR
// if p3 = 111 then
90070: LD_VAR 0 3
90074: PUSH
90075: LD_INT 111
90077: EQUAL
90078: IFFALSE 90088
// sOil := true ;
90080: LD_ADDR_EXP 149
90084: PUSH
90085: LD_INT 1
90087: ST_TO_ADDR
// if p3 = 112 then
90088: LD_VAR 0 3
90092: PUSH
90093: LD_INT 112
90095: EQUAL
90096: IFFALSE 90106
// sStu := true ;
90098: LD_ADDR_EXP 153
90102: PUSH
90103: LD_INT 1
90105: ST_TO_ADDR
// if p3 = 113 then
90106: LD_VAR 0 3
90110: PUSH
90111: LD_INT 113
90113: EQUAL
90114: IFFALSE 90124
// sBazooka := true ;
90116: LD_ADDR_EXP 156
90120: PUSH
90121: LD_INT 1
90123: ST_TO_ADDR
// if p3 = 114 then
90124: LD_VAR 0 3
90128: PUSH
90129: LD_INT 114
90131: EQUAL
90132: IFFALSE 90142
// sMortar := true ;
90134: LD_ADDR_EXP 157
90138: PUSH
90139: LD_INT 1
90141: ST_TO_ADDR
// if p3 = 115 then
90142: LD_VAR 0 3
90146: PUSH
90147: LD_INT 115
90149: EQUAL
90150: IFFALSE 90160
// sRanger := true ;
90152: LD_ADDR_EXP 167
90156: PUSH
90157: LD_INT 1
90159: ST_TO_ADDR
// if p3 = 116 then
90160: LD_VAR 0 3
90164: PUSH
90165: LD_INT 116
90167: EQUAL
90168: IFFALSE 90178
// sComputer := true ;
90170: LD_ADDR_EXP 168
90174: PUSH
90175: LD_INT 1
90177: ST_TO_ADDR
// if p3 = 117 then
90178: LD_VAR 0 3
90182: PUSH
90183: LD_INT 117
90185: EQUAL
90186: IFFALSE 90196
// s30 := true ;
90188: LD_ADDR_EXP 169
90192: PUSH
90193: LD_INT 1
90195: ST_TO_ADDR
// if p3 = 118 then
90196: LD_VAR 0 3
90200: PUSH
90201: LD_INT 118
90203: EQUAL
90204: IFFALSE 90214
// s60 := true ;
90206: LD_ADDR_EXP 170
90210: PUSH
90211: LD_INT 1
90213: ST_TO_ADDR
// end ; if p2 = 101 then
90214: LD_VAR 0 2
90218: PUSH
90219: LD_INT 101
90221: EQUAL
90222: IFFALSE 90350
// begin case p3 of 1 :
90224: LD_VAR 0 3
90228: PUSH
90229: LD_INT 1
90231: DOUBLE
90232: EQUAL
90233: IFTRUE 90237
90235: GO 90244
90237: POP
// hHackUnlimitedResources ; 2 :
90238: CALL 102448 0 0
90242: GO 90350
90244: LD_INT 2
90246: DOUBLE
90247: EQUAL
90248: IFTRUE 90252
90250: GO 90259
90252: POP
// hHackSetLevel10 ; 3 :
90253: CALL 102581 0 0
90257: GO 90350
90259: LD_INT 3
90261: DOUBLE
90262: EQUAL
90263: IFTRUE 90267
90265: GO 90274
90267: POP
// hHackSetLevel10YourUnits ; 4 :
90268: CALL 102666 0 0
90272: GO 90350
90274: LD_INT 4
90276: DOUBLE
90277: EQUAL
90278: IFTRUE 90282
90280: GO 90289
90282: POP
// hHackInvincible ; 5 :
90283: CALL 103114 0 0
90287: GO 90350
90289: LD_INT 5
90291: DOUBLE
90292: EQUAL
90293: IFTRUE 90297
90295: GO 90304
90297: POP
// hHackInvisible ; 6 :
90298: CALL 103225 0 0
90302: GO 90350
90304: LD_INT 6
90306: DOUBLE
90307: EQUAL
90308: IFTRUE 90312
90310: GO 90319
90312: POP
// hHackChangeYourSide ; 7 :
90313: CALL 103282 0 0
90317: GO 90350
90319: LD_INT 7
90321: DOUBLE
90322: EQUAL
90323: IFTRUE 90327
90325: GO 90334
90327: POP
// hHackChangeUnitSide ; 8 :
90328: CALL 103324 0 0
90332: GO 90350
90334: LD_INT 8
90336: DOUBLE
90337: EQUAL
90338: IFTRUE 90342
90340: GO 90349
90342: POP
// hHackFog ; end ;
90343: CALL 103425 0 0
90347: GO 90350
90349: POP
// end ; end ;
90350: LD_VAR 0 7
90354: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
90355: GO 90357
90357: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90358: LD_STRING initStreamRollete();
90360: PPUSH
90361: CALL_OW 559
// InitStreamMode ;
90365: CALL 90377 0 0
// DefineStreamItems ( false ) ;
90369: LD_INT 0
90371: PPUSH
90372: CALL 90841 0 1
// end ;
90376: END
// function InitStreamMode ; begin
90377: LD_INT 0
90379: PPUSH
// streamModeActive := false ;
90380: LD_ADDR_EXP 114
90384: PUSH
90385: LD_INT 0
90387: ST_TO_ADDR
// normalCounter := 36 ;
90388: LD_ADDR_EXP 115
90392: PUSH
90393: LD_INT 36
90395: ST_TO_ADDR
// hardcoreCounter := 18 ;
90396: LD_ADDR_EXP 116
90400: PUSH
90401: LD_INT 18
90403: ST_TO_ADDR
// sRocket := false ;
90404: LD_ADDR_EXP 119
90408: PUSH
90409: LD_INT 0
90411: ST_TO_ADDR
// sSpeed := false ;
90412: LD_ADDR_EXP 118
90416: PUSH
90417: LD_INT 0
90419: ST_TO_ADDR
// sEngine := false ;
90420: LD_ADDR_EXP 120
90424: PUSH
90425: LD_INT 0
90427: ST_TO_ADDR
// sSpec := false ;
90428: LD_ADDR_EXP 117
90432: PUSH
90433: LD_INT 0
90435: ST_TO_ADDR
// sLevel := false ;
90436: LD_ADDR_EXP 121
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
// sArmoury := false ;
90444: LD_ADDR_EXP 122
90448: PUSH
90449: LD_INT 0
90451: ST_TO_ADDR
// sRadar := false ;
90452: LD_ADDR_EXP 123
90456: PUSH
90457: LD_INT 0
90459: ST_TO_ADDR
// sBunker := false ;
90460: LD_ADDR_EXP 124
90464: PUSH
90465: LD_INT 0
90467: ST_TO_ADDR
// sHack := false ;
90468: LD_ADDR_EXP 125
90472: PUSH
90473: LD_INT 0
90475: ST_TO_ADDR
// sFire := false ;
90476: LD_ADDR_EXP 126
90480: PUSH
90481: LD_INT 0
90483: ST_TO_ADDR
// sRefresh := false ;
90484: LD_ADDR_EXP 127
90488: PUSH
90489: LD_INT 0
90491: ST_TO_ADDR
// sExp := false ;
90492: LD_ADDR_EXP 128
90496: PUSH
90497: LD_INT 0
90499: ST_TO_ADDR
// sDepot := false ;
90500: LD_ADDR_EXP 129
90504: PUSH
90505: LD_INT 0
90507: ST_TO_ADDR
// sFlag := false ;
90508: LD_ADDR_EXP 130
90512: PUSH
90513: LD_INT 0
90515: ST_TO_ADDR
// sKamikadze := false ;
90516: LD_ADDR_EXP 138
90520: PUSH
90521: LD_INT 0
90523: ST_TO_ADDR
// sTroll := false ;
90524: LD_ADDR_EXP 139
90528: PUSH
90529: LD_INT 0
90531: ST_TO_ADDR
// sSlow := false ;
90532: LD_ADDR_EXP 140
90536: PUSH
90537: LD_INT 0
90539: ST_TO_ADDR
// sLack := false ;
90540: LD_ADDR_EXP 141
90544: PUSH
90545: LD_INT 0
90547: ST_TO_ADDR
// sTank := false ;
90548: LD_ADDR_EXP 143
90552: PUSH
90553: LD_INT 0
90555: ST_TO_ADDR
// sRemote := false ;
90556: LD_ADDR_EXP 144
90560: PUSH
90561: LD_INT 0
90563: ST_TO_ADDR
// sPowell := false ;
90564: LD_ADDR_EXP 145
90568: PUSH
90569: LD_INT 0
90571: ST_TO_ADDR
// sTeleport := false ;
90572: LD_ADDR_EXP 148
90576: PUSH
90577: LD_INT 0
90579: ST_TO_ADDR
// sOilTower := false ;
90580: LD_ADDR_EXP 150
90584: PUSH
90585: LD_INT 0
90587: ST_TO_ADDR
// sShovel := false ;
90588: LD_ADDR_EXP 151
90592: PUSH
90593: LD_INT 0
90595: ST_TO_ADDR
// sSheik := false ;
90596: LD_ADDR_EXP 152
90600: PUSH
90601: LD_INT 0
90603: ST_TO_ADDR
// sEarthquake := false ;
90604: LD_ADDR_EXP 154
90608: PUSH
90609: LD_INT 0
90611: ST_TO_ADDR
// sAI := false ;
90612: LD_ADDR_EXP 155
90616: PUSH
90617: LD_INT 0
90619: ST_TO_ADDR
// sCargo := false ;
90620: LD_ADDR_EXP 158
90624: PUSH
90625: LD_INT 0
90627: ST_TO_ADDR
// sDLaser := false ;
90628: LD_ADDR_EXP 159
90632: PUSH
90633: LD_INT 0
90635: ST_TO_ADDR
// sExchange := false ;
90636: LD_ADDR_EXP 160
90640: PUSH
90641: LD_INT 0
90643: ST_TO_ADDR
// sFac := false ;
90644: LD_ADDR_EXP 161
90648: PUSH
90649: LD_INT 0
90651: ST_TO_ADDR
// sPower := false ;
90652: LD_ADDR_EXP 162
90656: PUSH
90657: LD_INT 0
90659: ST_TO_ADDR
// sRandom := false ;
90660: LD_ADDR_EXP 163
90664: PUSH
90665: LD_INT 0
90667: ST_TO_ADDR
// sShield := false ;
90668: LD_ADDR_EXP 164
90672: PUSH
90673: LD_INT 0
90675: ST_TO_ADDR
// sTime := false ;
90676: LD_ADDR_EXP 165
90680: PUSH
90681: LD_INT 0
90683: ST_TO_ADDR
// sTools := false ;
90684: LD_ADDR_EXP 166
90688: PUSH
90689: LD_INT 0
90691: ST_TO_ADDR
// sSold := false ;
90692: LD_ADDR_EXP 131
90696: PUSH
90697: LD_INT 0
90699: ST_TO_ADDR
// sDiff := false ;
90700: LD_ADDR_EXP 132
90704: PUSH
90705: LD_INT 0
90707: ST_TO_ADDR
// sFog := false ;
90708: LD_ADDR_EXP 135
90712: PUSH
90713: LD_INT 0
90715: ST_TO_ADDR
// sReset := false ;
90716: LD_ADDR_EXP 136
90720: PUSH
90721: LD_INT 0
90723: ST_TO_ADDR
// sSun := false ;
90724: LD_ADDR_EXP 137
90728: PUSH
90729: LD_INT 0
90731: ST_TO_ADDR
// sTiger := false ;
90732: LD_ADDR_EXP 133
90736: PUSH
90737: LD_INT 0
90739: ST_TO_ADDR
// sBomb := false ;
90740: LD_ADDR_EXP 134
90744: PUSH
90745: LD_INT 0
90747: ST_TO_ADDR
// sWound := false ;
90748: LD_ADDR_EXP 142
90752: PUSH
90753: LD_INT 0
90755: ST_TO_ADDR
// sBetray := false ;
90756: LD_ADDR_EXP 146
90760: PUSH
90761: LD_INT 0
90763: ST_TO_ADDR
// sContamin := false ;
90764: LD_ADDR_EXP 147
90768: PUSH
90769: LD_INT 0
90771: ST_TO_ADDR
// sOil := false ;
90772: LD_ADDR_EXP 149
90776: PUSH
90777: LD_INT 0
90779: ST_TO_ADDR
// sStu := false ;
90780: LD_ADDR_EXP 153
90784: PUSH
90785: LD_INT 0
90787: ST_TO_ADDR
// sBazooka := false ;
90788: LD_ADDR_EXP 156
90792: PUSH
90793: LD_INT 0
90795: ST_TO_ADDR
// sMortar := false ;
90796: LD_ADDR_EXP 157
90800: PUSH
90801: LD_INT 0
90803: ST_TO_ADDR
// sRanger := false ;
90804: LD_ADDR_EXP 167
90808: PUSH
90809: LD_INT 0
90811: ST_TO_ADDR
// sComputer := false ;
90812: LD_ADDR_EXP 168
90816: PUSH
90817: LD_INT 0
90819: ST_TO_ADDR
// s30 := false ;
90820: LD_ADDR_EXP 169
90824: PUSH
90825: LD_INT 0
90827: ST_TO_ADDR
// s60 := false ;
90828: LD_ADDR_EXP 170
90832: PUSH
90833: LD_INT 0
90835: ST_TO_ADDR
// end ;
90836: LD_VAR 0 1
90840: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
90841: LD_INT 0
90843: PPUSH
90844: PPUSH
90845: PPUSH
90846: PPUSH
90847: PPUSH
90848: PPUSH
90849: PPUSH
// result := [ ] ;
90850: LD_ADDR_VAR 0 2
90854: PUSH
90855: EMPTY
90856: ST_TO_ADDR
// if campaign_id = 1 then
90857: LD_OWVAR 69
90861: PUSH
90862: LD_INT 1
90864: EQUAL
90865: IFFALSE 94031
// begin case mission_number of 1 :
90867: LD_OWVAR 70
90871: PUSH
90872: LD_INT 1
90874: DOUBLE
90875: EQUAL
90876: IFTRUE 90880
90878: GO 90956
90880: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
90881: LD_ADDR_VAR 0 2
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: LD_INT 4
90891: PUSH
90892: LD_INT 11
90894: PUSH
90895: LD_INT 12
90897: PUSH
90898: LD_INT 15
90900: PUSH
90901: LD_INT 16
90903: PUSH
90904: LD_INT 22
90906: PUSH
90907: LD_INT 23
90909: PUSH
90910: LD_INT 26
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 101
90926: PUSH
90927: LD_INT 102
90929: PUSH
90930: LD_INT 106
90932: PUSH
90933: LD_INT 116
90935: PUSH
90936: LD_INT 117
90938: PUSH
90939: LD_INT 118
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: ST_TO_ADDR
90954: GO 94029
90956: LD_INT 2
90958: DOUBLE
90959: EQUAL
90960: IFTRUE 90964
90962: GO 91048
90964: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90965: LD_ADDR_VAR 0 2
90969: PUSH
90970: LD_INT 2
90972: PUSH
90973: LD_INT 4
90975: PUSH
90976: LD_INT 11
90978: PUSH
90979: LD_INT 12
90981: PUSH
90982: LD_INT 15
90984: PUSH
90985: LD_INT 16
90987: PUSH
90988: LD_INT 22
90990: PUSH
90991: LD_INT 23
90993: PUSH
90994: LD_INT 26
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 101
91010: PUSH
91011: LD_INT 102
91013: PUSH
91014: LD_INT 105
91016: PUSH
91017: LD_INT 106
91019: PUSH
91020: LD_INT 108
91022: PUSH
91023: LD_INT 116
91025: PUSH
91026: LD_INT 117
91028: PUSH
91029: LD_INT 118
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: ST_TO_ADDR
91046: GO 94029
91048: LD_INT 3
91050: DOUBLE
91051: EQUAL
91052: IFTRUE 91056
91054: GO 91144
91056: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91057: LD_ADDR_VAR 0 2
91061: PUSH
91062: LD_INT 2
91064: PUSH
91065: LD_INT 4
91067: PUSH
91068: LD_INT 5
91070: PUSH
91071: LD_INT 11
91073: PUSH
91074: LD_INT 12
91076: PUSH
91077: LD_INT 15
91079: PUSH
91080: LD_INT 16
91082: PUSH
91083: LD_INT 22
91085: PUSH
91086: LD_INT 26
91088: PUSH
91089: LD_INT 36
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 101
91106: PUSH
91107: LD_INT 102
91109: PUSH
91110: LD_INT 105
91112: PUSH
91113: LD_INT 106
91115: PUSH
91116: LD_INT 108
91118: PUSH
91119: LD_INT 116
91121: PUSH
91122: LD_INT 117
91124: PUSH
91125: LD_INT 118
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: ST_TO_ADDR
91142: GO 94029
91144: LD_INT 4
91146: DOUBLE
91147: EQUAL
91148: IFTRUE 91152
91150: GO 91248
91152: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91153: LD_ADDR_VAR 0 2
91157: PUSH
91158: LD_INT 2
91160: PUSH
91161: LD_INT 4
91163: PUSH
91164: LD_INT 5
91166: PUSH
91167: LD_INT 8
91169: PUSH
91170: LD_INT 11
91172: PUSH
91173: LD_INT 12
91175: PUSH
91176: LD_INT 15
91178: PUSH
91179: LD_INT 16
91181: PUSH
91182: LD_INT 22
91184: PUSH
91185: LD_INT 23
91187: PUSH
91188: LD_INT 26
91190: PUSH
91191: LD_INT 36
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 101
91210: PUSH
91211: LD_INT 102
91213: PUSH
91214: LD_INT 105
91216: PUSH
91217: LD_INT 106
91219: PUSH
91220: LD_INT 108
91222: PUSH
91223: LD_INT 116
91225: PUSH
91226: LD_INT 117
91228: PUSH
91229: LD_INT 118
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: ST_TO_ADDR
91246: GO 94029
91248: LD_INT 5
91250: DOUBLE
91251: EQUAL
91252: IFTRUE 91256
91254: GO 91368
91256: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
91257: LD_ADDR_VAR 0 2
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: LD_INT 4
91267: PUSH
91268: LD_INT 5
91270: PUSH
91271: LD_INT 6
91273: PUSH
91274: LD_INT 8
91276: PUSH
91277: LD_INT 11
91279: PUSH
91280: LD_INT 12
91282: PUSH
91283: LD_INT 15
91285: PUSH
91286: LD_INT 16
91288: PUSH
91289: LD_INT 22
91291: PUSH
91292: LD_INT 23
91294: PUSH
91295: LD_INT 25
91297: PUSH
91298: LD_INT 26
91300: PUSH
91301: LD_INT 36
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 101
91322: PUSH
91323: LD_INT 102
91325: PUSH
91326: LD_INT 105
91328: PUSH
91329: LD_INT 106
91331: PUSH
91332: LD_INT 108
91334: PUSH
91335: LD_INT 109
91337: PUSH
91338: LD_INT 112
91340: PUSH
91341: LD_INT 116
91343: PUSH
91344: LD_INT 117
91346: PUSH
91347: LD_INT 118
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: ST_TO_ADDR
91366: GO 94029
91368: LD_INT 6
91370: DOUBLE
91371: EQUAL
91372: IFTRUE 91376
91374: GO 91508
91376: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91377: LD_ADDR_VAR 0 2
91381: PUSH
91382: LD_INT 2
91384: PUSH
91385: LD_INT 4
91387: PUSH
91388: LD_INT 5
91390: PUSH
91391: LD_INT 6
91393: PUSH
91394: LD_INT 8
91396: PUSH
91397: LD_INT 11
91399: PUSH
91400: LD_INT 12
91402: PUSH
91403: LD_INT 15
91405: PUSH
91406: LD_INT 16
91408: PUSH
91409: LD_INT 20
91411: PUSH
91412: LD_INT 21
91414: PUSH
91415: LD_INT 22
91417: PUSH
91418: LD_INT 23
91420: PUSH
91421: LD_INT 25
91423: PUSH
91424: LD_INT 26
91426: PUSH
91427: LD_INT 30
91429: PUSH
91430: LD_INT 31
91432: PUSH
91433: LD_INT 32
91435: PUSH
91436: LD_INT 36
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 101
91462: PUSH
91463: LD_INT 102
91465: PUSH
91466: LD_INT 105
91468: PUSH
91469: LD_INT 106
91471: PUSH
91472: LD_INT 108
91474: PUSH
91475: LD_INT 109
91477: PUSH
91478: LD_INT 112
91480: PUSH
91481: LD_INT 116
91483: PUSH
91484: LD_INT 117
91486: PUSH
91487: LD_INT 118
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: ST_TO_ADDR
91506: GO 94029
91508: LD_INT 7
91510: DOUBLE
91511: EQUAL
91512: IFTRUE 91516
91514: GO 91628
91516: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
91517: LD_ADDR_VAR 0 2
91521: PUSH
91522: LD_INT 2
91524: PUSH
91525: LD_INT 4
91527: PUSH
91528: LD_INT 5
91530: PUSH
91531: LD_INT 7
91533: PUSH
91534: LD_INT 11
91536: PUSH
91537: LD_INT 12
91539: PUSH
91540: LD_INT 15
91542: PUSH
91543: LD_INT 16
91545: PUSH
91546: LD_INT 20
91548: PUSH
91549: LD_INT 21
91551: PUSH
91552: LD_INT 22
91554: PUSH
91555: LD_INT 23
91557: PUSH
91558: LD_INT 25
91560: PUSH
91561: LD_INT 26
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: PUSH
91580: LD_INT 101
91582: PUSH
91583: LD_INT 102
91585: PUSH
91586: LD_INT 103
91588: PUSH
91589: LD_INT 105
91591: PUSH
91592: LD_INT 106
91594: PUSH
91595: LD_INT 108
91597: PUSH
91598: LD_INT 112
91600: PUSH
91601: LD_INT 116
91603: PUSH
91604: LD_INT 117
91606: PUSH
91607: LD_INT 118
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: ST_TO_ADDR
91626: GO 94029
91628: LD_INT 8
91630: DOUBLE
91631: EQUAL
91632: IFTRUE 91636
91634: GO 91776
91636: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
91637: LD_ADDR_VAR 0 2
91641: PUSH
91642: LD_INT 2
91644: PUSH
91645: LD_INT 4
91647: PUSH
91648: LD_INT 5
91650: PUSH
91651: LD_INT 6
91653: PUSH
91654: LD_INT 7
91656: PUSH
91657: LD_INT 8
91659: PUSH
91660: LD_INT 11
91662: PUSH
91663: LD_INT 12
91665: PUSH
91666: LD_INT 15
91668: PUSH
91669: LD_INT 16
91671: PUSH
91672: LD_INT 20
91674: PUSH
91675: LD_INT 21
91677: PUSH
91678: LD_INT 22
91680: PUSH
91681: LD_INT 23
91683: PUSH
91684: LD_INT 25
91686: PUSH
91687: LD_INT 26
91689: PUSH
91690: LD_INT 30
91692: PUSH
91693: LD_INT 31
91695: PUSH
91696: LD_INT 32
91698: PUSH
91699: LD_INT 36
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 101
91726: PUSH
91727: LD_INT 102
91729: PUSH
91730: LD_INT 103
91732: PUSH
91733: LD_INT 105
91735: PUSH
91736: LD_INT 106
91738: PUSH
91739: LD_INT 108
91741: PUSH
91742: LD_INT 109
91744: PUSH
91745: LD_INT 112
91747: PUSH
91748: LD_INT 116
91750: PUSH
91751: LD_INT 117
91753: PUSH
91754: LD_INT 118
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: ST_TO_ADDR
91774: GO 94029
91776: LD_INT 9
91778: DOUBLE
91779: EQUAL
91780: IFTRUE 91784
91782: GO 91932
91784: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
91785: LD_ADDR_VAR 0 2
91789: PUSH
91790: LD_INT 2
91792: PUSH
91793: LD_INT 4
91795: PUSH
91796: LD_INT 5
91798: PUSH
91799: LD_INT 6
91801: PUSH
91802: LD_INT 7
91804: PUSH
91805: LD_INT 8
91807: PUSH
91808: LD_INT 11
91810: PUSH
91811: LD_INT 12
91813: PUSH
91814: LD_INT 15
91816: PUSH
91817: LD_INT 16
91819: PUSH
91820: LD_INT 20
91822: PUSH
91823: LD_INT 21
91825: PUSH
91826: LD_INT 22
91828: PUSH
91829: LD_INT 23
91831: PUSH
91832: LD_INT 25
91834: PUSH
91835: LD_INT 26
91837: PUSH
91838: LD_INT 28
91840: PUSH
91841: LD_INT 30
91843: PUSH
91844: LD_INT 31
91846: PUSH
91847: LD_INT 32
91849: PUSH
91850: LD_INT 36
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 101
91878: PUSH
91879: LD_INT 102
91881: PUSH
91882: LD_INT 103
91884: PUSH
91885: LD_INT 105
91887: PUSH
91888: LD_INT 106
91890: PUSH
91891: LD_INT 108
91893: PUSH
91894: LD_INT 109
91896: PUSH
91897: LD_INT 112
91899: PUSH
91900: LD_INT 114
91902: PUSH
91903: LD_INT 116
91905: PUSH
91906: LD_INT 117
91908: PUSH
91909: LD_INT 118
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: ST_TO_ADDR
91930: GO 94029
91932: LD_INT 10
91934: DOUBLE
91935: EQUAL
91936: IFTRUE 91940
91938: GO 92136
91940: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91941: LD_ADDR_VAR 0 2
91945: PUSH
91946: LD_INT 2
91948: PUSH
91949: LD_INT 4
91951: PUSH
91952: LD_INT 5
91954: PUSH
91955: LD_INT 6
91957: PUSH
91958: LD_INT 7
91960: PUSH
91961: LD_INT 8
91963: PUSH
91964: LD_INT 9
91966: PUSH
91967: LD_INT 10
91969: PUSH
91970: LD_INT 11
91972: PUSH
91973: LD_INT 12
91975: PUSH
91976: LD_INT 13
91978: PUSH
91979: LD_INT 14
91981: PUSH
91982: LD_INT 15
91984: PUSH
91985: LD_INT 16
91987: PUSH
91988: LD_INT 17
91990: PUSH
91991: LD_INT 18
91993: PUSH
91994: LD_INT 19
91996: PUSH
91997: LD_INT 20
91999: PUSH
92000: LD_INT 21
92002: PUSH
92003: LD_INT 22
92005: PUSH
92006: LD_INT 23
92008: PUSH
92009: LD_INT 24
92011: PUSH
92012: LD_INT 25
92014: PUSH
92015: LD_INT 26
92017: PUSH
92018: LD_INT 28
92020: PUSH
92021: LD_INT 30
92023: PUSH
92024: LD_INT 31
92026: PUSH
92027: LD_INT 32
92029: PUSH
92030: LD_INT 36
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 101
92066: PUSH
92067: LD_INT 102
92069: PUSH
92070: LD_INT 103
92072: PUSH
92073: LD_INT 104
92075: PUSH
92076: LD_INT 105
92078: PUSH
92079: LD_INT 106
92081: PUSH
92082: LD_INT 107
92084: PUSH
92085: LD_INT 108
92087: PUSH
92088: LD_INT 109
92090: PUSH
92091: LD_INT 110
92093: PUSH
92094: LD_INT 111
92096: PUSH
92097: LD_INT 112
92099: PUSH
92100: LD_INT 114
92102: PUSH
92103: LD_INT 116
92105: PUSH
92106: LD_INT 117
92108: PUSH
92109: LD_INT 118
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: ST_TO_ADDR
92134: GO 94029
92136: LD_INT 11
92138: DOUBLE
92139: EQUAL
92140: IFTRUE 92144
92142: GO 92348
92144: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92145: LD_ADDR_VAR 0 2
92149: PUSH
92150: LD_INT 2
92152: PUSH
92153: LD_INT 3
92155: PUSH
92156: LD_INT 4
92158: PUSH
92159: LD_INT 5
92161: PUSH
92162: LD_INT 6
92164: PUSH
92165: LD_INT 7
92167: PUSH
92168: LD_INT 8
92170: PUSH
92171: LD_INT 9
92173: PUSH
92174: LD_INT 10
92176: PUSH
92177: LD_INT 11
92179: PUSH
92180: LD_INT 12
92182: PUSH
92183: LD_INT 13
92185: PUSH
92186: LD_INT 14
92188: PUSH
92189: LD_INT 15
92191: PUSH
92192: LD_INT 16
92194: PUSH
92195: LD_INT 17
92197: PUSH
92198: LD_INT 18
92200: PUSH
92201: LD_INT 19
92203: PUSH
92204: LD_INT 20
92206: PUSH
92207: LD_INT 21
92209: PUSH
92210: LD_INT 22
92212: PUSH
92213: LD_INT 23
92215: PUSH
92216: LD_INT 24
92218: PUSH
92219: LD_INT 25
92221: PUSH
92222: LD_INT 26
92224: PUSH
92225: LD_INT 28
92227: PUSH
92228: LD_INT 30
92230: PUSH
92231: LD_INT 31
92233: PUSH
92234: LD_INT 32
92236: PUSH
92237: LD_INT 34
92239: PUSH
92240: LD_INT 36
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 101
92278: PUSH
92279: LD_INT 102
92281: PUSH
92282: LD_INT 103
92284: PUSH
92285: LD_INT 104
92287: PUSH
92288: LD_INT 105
92290: PUSH
92291: LD_INT 106
92293: PUSH
92294: LD_INT 107
92296: PUSH
92297: LD_INT 108
92299: PUSH
92300: LD_INT 109
92302: PUSH
92303: LD_INT 110
92305: PUSH
92306: LD_INT 111
92308: PUSH
92309: LD_INT 112
92311: PUSH
92312: LD_INT 114
92314: PUSH
92315: LD_INT 116
92317: PUSH
92318: LD_INT 117
92320: PUSH
92321: LD_INT 118
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: ST_TO_ADDR
92346: GO 94029
92348: LD_INT 12
92350: DOUBLE
92351: EQUAL
92352: IFTRUE 92356
92354: GO 92576
92356: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
92357: LD_ADDR_VAR 0 2
92361: PUSH
92362: LD_INT 1
92364: PUSH
92365: LD_INT 2
92367: PUSH
92368: LD_INT 3
92370: PUSH
92371: LD_INT 4
92373: PUSH
92374: LD_INT 5
92376: PUSH
92377: LD_INT 6
92379: PUSH
92380: LD_INT 7
92382: PUSH
92383: LD_INT 8
92385: PUSH
92386: LD_INT 9
92388: PUSH
92389: LD_INT 10
92391: PUSH
92392: LD_INT 11
92394: PUSH
92395: LD_INT 12
92397: PUSH
92398: LD_INT 13
92400: PUSH
92401: LD_INT 14
92403: PUSH
92404: LD_INT 15
92406: PUSH
92407: LD_INT 16
92409: PUSH
92410: LD_INT 17
92412: PUSH
92413: LD_INT 18
92415: PUSH
92416: LD_INT 19
92418: PUSH
92419: LD_INT 20
92421: PUSH
92422: LD_INT 21
92424: PUSH
92425: LD_INT 22
92427: PUSH
92428: LD_INT 23
92430: PUSH
92431: LD_INT 24
92433: PUSH
92434: LD_INT 25
92436: PUSH
92437: LD_INT 26
92439: PUSH
92440: LD_INT 27
92442: PUSH
92443: LD_INT 28
92445: PUSH
92446: LD_INT 30
92448: PUSH
92449: LD_INT 31
92451: PUSH
92452: LD_INT 32
92454: PUSH
92455: LD_INT 33
92457: PUSH
92458: LD_INT 34
92460: PUSH
92461: LD_INT 36
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 101
92502: PUSH
92503: LD_INT 102
92505: PUSH
92506: LD_INT 103
92508: PUSH
92509: LD_INT 104
92511: PUSH
92512: LD_INT 105
92514: PUSH
92515: LD_INT 106
92517: PUSH
92518: LD_INT 107
92520: PUSH
92521: LD_INT 108
92523: PUSH
92524: LD_INT 109
92526: PUSH
92527: LD_INT 110
92529: PUSH
92530: LD_INT 111
92532: PUSH
92533: LD_INT 112
92535: PUSH
92536: LD_INT 113
92538: PUSH
92539: LD_INT 114
92541: PUSH
92542: LD_INT 116
92544: PUSH
92545: LD_INT 117
92547: PUSH
92548: LD_INT 118
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: ST_TO_ADDR
92574: GO 94029
92576: LD_INT 13
92578: DOUBLE
92579: EQUAL
92580: IFTRUE 92584
92582: GO 92792
92584: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
92585: LD_ADDR_VAR 0 2
92589: PUSH
92590: LD_INT 1
92592: PUSH
92593: LD_INT 2
92595: PUSH
92596: LD_INT 3
92598: PUSH
92599: LD_INT 4
92601: PUSH
92602: LD_INT 5
92604: PUSH
92605: LD_INT 8
92607: PUSH
92608: LD_INT 9
92610: PUSH
92611: LD_INT 10
92613: PUSH
92614: LD_INT 11
92616: PUSH
92617: LD_INT 12
92619: PUSH
92620: LD_INT 14
92622: PUSH
92623: LD_INT 15
92625: PUSH
92626: LD_INT 16
92628: PUSH
92629: LD_INT 17
92631: PUSH
92632: LD_INT 18
92634: PUSH
92635: LD_INT 19
92637: PUSH
92638: LD_INT 20
92640: PUSH
92641: LD_INT 21
92643: PUSH
92644: LD_INT 22
92646: PUSH
92647: LD_INT 23
92649: PUSH
92650: LD_INT 24
92652: PUSH
92653: LD_INT 25
92655: PUSH
92656: LD_INT 26
92658: PUSH
92659: LD_INT 27
92661: PUSH
92662: LD_INT 28
92664: PUSH
92665: LD_INT 30
92667: PUSH
92668: LD_INT 31
92670: PUSH
92671: LD_INT 32
92673: PUSH
92674: LD_INT 33
92676: PUSH
92677: LD_INT 34
92679: PUSH
92680: LD_INT 36
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 101
92718: PUSH
92719: LD_INT 102
92721: PUSH
92722: LD_INT 103
92724: PUSH
92725: LD_INT 104
92727: PUSH
92728: LD_INT 105
92730: PUSH
92731: LD_INT 106
92733: PUSH
92734: LD_INT 107
92736: PUSH
92737: LD_INT 108
92739: PUSH
92740: LD_INT 109
92742: PUSH
92743: LD_INT 110
92745: PUSH
92746: LD_INT 111
92748: PUSH
92749: LD_INT 112
92751: PUSH
92752: LD_INT 113
92754: PUSH
92755: LD_INT 114
92757: PUSH
92758: LD_INT 116
92760: PUSH
92761: LD_INT 117
92763: PUSH
92764: LD_INT 118
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: ST_TO_ADDR
92790: GO 94029
92792: LD_INT 14
92794: DOUBLE
92795: EQUAL
92796: IFTRUE 92800
92798: GO 93024
92800: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
92801: LD_ADDR_VAR 0 2
92805: PUSH
92806: LD_INT 1
92808: PUSH
92809: LD_INT 2
92811: PUSH
92812: LD_INT 3
92814: PUSH
92815: LD_INT 4
92817: PUSH
92818: LD_INT 5
92820: PUSH
92821: LD_INT 6
92823: PUSH
92824: LD_INT 7
92826: PUSH
92827: LD_INT 8
92829: PUSH
92830: LD_INT 9
92832: PUSH
92833: LD_INT 10
92835: PUSH
92836: LD_INT 11
92838: PUSH
92839: LD_INT 12
92841: PUSH
92842: LD_INT 13
92844: PUSH
92845: LD_INT 14
92847: PUSH
92848: LD_INT 15
92850: PUSH
92851: LD_INT 16
92853: PUSH
92854: LD_INT 17
92856: PUSH
92857: LD_INT 18
92859: PUSH
92860: LD_INT 19
92862: PUSH
92863: LD_INT 20
92865: PUSH
92866: LD_INT 21
92868: PUSH
92869: LD_INT 22
92871: PUSH
92872: LD_INT 23
92874: PUSH
92875: LD_INT 24
92877: PUSH
92878: LD_INT 25
92880: PUSH
92881: LD_INT 26
92883: PUSH
92884: LD_INT 27
92886: PUSH
92887: LD_INT 28
92889: PUSH
92890: LD_INT 29
92892: PUSH
92893: LD_INT 30
92895: PUSH
92896: LD_INT 31
92898: PUSH
92899: LD_INT 32
92901: PUSH
92902: LD_INT 33
92904: PUSH
92905: LD_INT 34
92907: PUSH
92908: LD_INT 36
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 101
92950: PUSH
92951: LD_INT 102
92953: PUSH
92954: LD_INT 103
92956: PUSH
92957: LD_INT 104
92959: PUSH
92960: LD_INT 105
92962: PUSH
92963: LD_INT 106
92965: PUSH
92966: LD_INT 107
92968: PUSH
92969: LD_INT 108
92971: PUSH
92972: LD_INT 109
92974: PUSH
92975: LD_INT 110
92977: PUSH
92978: LD_INT 111
92980: PUSH
92981: LD_INT 112
92983: PUSH
92984: LD_INT 113
92986: PUSH
92987: LD_INT 114
92989: PUSH
92990: LD_INT 116
92992: PUSH
92993: LD_INT 117
92995: PUSH
92996: LD_INT 118
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: ST_TO_ADDR
93022: GO 94029
93024: LD_INT 15
93026: DOUBLE
93027: EQUAL
93028: IFTRUE 93032
93030: GO 93256
93032: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93033: LD_ADDR_VAR 0 2
93037: PUSH
93038: LD_INT 1
93040: PUSH
93041: LD_INT 2
93043: PUSH
93044: LD_INT 3
93046: PUSH
93047: LD_INT 4
93049: PUSH
93050: LD_INT 5
93052: PUSH
93053: LD_INT 6
93055: PUSH
93056: LD_INT 7
93058: PUSH
93059: LD_INT 8
93061: PUSH
93062: LD_INT 9
93064: PUSH
93065: LD_INT 10
93067: PUSH
93068: LD_INT 11
93070: PUSH
93071: LD_INT 12
93073: PUSH
93074: LD_INT 13
93076: PUSH
93077: LD_INT 14
93079: PUSH
93080: LD_INT 15
93082: PUSH
93083: LD_INT 16
93085: PUSH
93086: LD_INT 17
93088: PUSH
93089: LD_INT 18
93091: PUSH
93092: LD_INT 19
93094: PUSH
93095: LD_INT 20
93097: PUSH
93098: LD_INT 21
93100: PUSH
93101: LD_INT 22
93103: PUSH
93104: LD_INT 23
93106: PUSH
93107: LD_INT 24
93109: PUSH
93110: LD_INT 25
93112: PUSH
93113: LD_INT 26
93115: PUSH
93116: LD_INT 27
93118: PUSH
93119: LD_INT 28
93121: PUSH
93122: LD_INT 29
93124: PUSH
93125: LD_INT 30
93127: PUSH
93128: LD_INT 31
93130: PUSH
93131: LD_INT 32
93133: PUSH
93134: LD_INT 33
93136: PUSH
93137: LD_INT 34
93139: PUSH
93140: LD_INT 36
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: LIST
93161: LIST
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 101
93182: PUSH
93183: LD_INT 102
93185: PUSH
93186: LD_INT 103
93188: PUSH
93189: LD_INT 104
93191: PUSH
93192: LD_INT 105
93194: PUSH
93195: LD_INT 106
93197: PUSH
93198: LD_INT 107
93200: PUSH
93201: LD_INT 108
93203: PUSH
93204: LD_INT 109
93206: PUSH
93207: LD_INT 110
93209: PUSH
93210: LD_INT 111
93212: PUSH
93213: LD_INT 112
93215: PUSH
93216: LD_INT 113
93218: PUSH
93219: LD_INT 114
93221: PUSH
93222: LD_INT 116
93224: PUSH
93225: LD_INT 117
93227: PUSH
93228: LD_INT 118
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: ST_TO_ADDR
93254: GO 94029
93256: LD_INT 16
93258: DOUBLE
93259: EQUAL
93260: IFTRUE 93264
93262: GO 93400
93264: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
93265: LD_ADDR_VAR 0 2
93269: PUSH
93270: LD_INT 2
93272: PUSH
93273: LD_INT 4
93275: PUSH
93276: LD_INT 5
93278: PUSH
93279: LD_INT 7
93281: PUSH
93282: LD_INT 11
93284: PUSH
93285: LD_INT 12
93287: PUSH
93288: LD_INT 15
93290: PUSH
93291: LD_INT 16
93293: PUSH
93294: LD_INT 20
93296: PUSH
93297: LD_INT 21
93299: PUSH
93300: LD_INT 22
93302: PUSH
93303: LD_INT 23
93305: PUSH
93306: LD_INT 25
93308: PUSH
93309: LD_INT 26
93311: PUSH
93312: LD_INT 30
93314: PUSH
93315: LD_INT 31
93317: PUSH
93318: LD_INT 32
93320: PUSH
93321: LD_INT 33
93323: PUSH
93324: LD_INT 34
93326: PUSH
93327: EMPTY
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 101
93350: PUSH
93351: LD_INT 102
93353: PUSH
93354: LD_INT 103
93356: PUSH
93357: LD_INT 106
93359: PUSH
93360: LD_INT 108
93362: PUSH
93363: LD_INT 112
93365: PUSH
93366: LD_INT 113
93368: PUSH
93369: LD_INT 114
93371: PUSH
93372: LD_INT 116
93374: PUSH
93375: LD_INT 117
93377: PUSH
93378: LD_INT 118
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: ST_TO_ADDR
93398: GO 94029
93400: LD_INT 17
93402: DOUBLE
93403: EQUAL
93404: IFTRUE 93408
93406: GO 93632
93408: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93409: LD_ADDR_VAR 0 2
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: LD_INT 2
93419: PUSH
93420: LD_INT 3
93422: PUSH
93423: LD_INT 4
93425: PUSH
93426: LD_INT 5
93428: PUSH
93429: LD_INT 6
93431: PUSH
93432: LD_INT 7
93434: PUSH
93435: LD_INT 8
93437: PUSH
93438: LD_INT 9
93440: PUSH
93441: LD_INT 10
93443: PUSH
93444: LD_INT 11
93446: PUSH
93447: LD_INT 12
93449: PUSH
93450: LD_INT 13
93452: PUSH
93453: LD_INT 14
93455: PUSH
93456: LD_INT 15
93458: PUSH
93459: LD_INT 16
93461: PUSH
93462: LD_INT 17
93464: PUSH
93465: LD_INT 18
93467: PUSH
93468: LD_INT 19
93470: PUSH
93471: LD_INT 20
93473: PUSH
93474: LD_INT 21
93476: PUSH
93477: LD_INT 22
93479: PUSH
93480: LD_INT 23
93482: PUSH
93483: LD_INT 24
93485: PUSH
93486: LD_INT 25
93488: PUSH
93489: LD_INT 26
93491: PUSH
93492: LD_INT 27
93494: PUSH
93495: LD_INT 28
93497: PUSH
93498: LD_INT 29
93500: PUSH
93501: LD_INT 30
93503: PUSH
93504: LD_INT 31
93506: PUSH
93507: LD_INT 32
93509: PUSH
93510: LD_INT 33
93512: PUSH
93513: LD_INT 34
93515: PUSH
93516: LD_INT 36
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 101
93558: PUSH
93559: LD_INT 102
93561: PUSH
93562: LD_INT 103
93564: PUSH
93565: LD_INT 104
93567: PUSH
93568: LD_INT 105
93570: PUSH
93571: LD_INT 106
93573: PUSH
93574: LD_INT 107
93576: PUSH
93577: LD_INT 108
93579: PUSH
93580: LD_INT 109
93582: PUSH
93583: LD_INT 110
93585: PUSH
93586: LD_INT 111
93588: PUSH
93589: LD_INT 112
93591: PUSH
93592: LD_INT 113
93594: PUSH
93595: LD_INT 114
93597: PUSH
93598: LD_INT 116
93600: PUSH
93601: LD_INT 117
93603: PUSH
93604: LD_INT 118
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: ST_TO_ADDR
93630: GO 94029
93632: LD_INT 18
93634: DOUBLE
93635: EQUAL
93636: IFTRUE 93640
93638: GO 93788
93640: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
93641: LD_ADDR_VAR 0 2
93645: PUSH
93646: LD_INT 2
93648: PUSH
93649: LD_INT 4
93651: PUSH
93652: LD_INT 5
93654: PUSH
93655: LD_INT 7
93657: PUSH
93658: LD_INT 11
93660: PUSH
93661: LD_INT 12
93663: PUSH
93664: LD_INT 15
93666: PUSH
93667: LD_INT 16
93669: PUSH
93670: LD_INT 20
93672: PUSH
93673: LD_INT 21
93675: PUSH
93676: LD_INT 22
93678: PUSH
93679: LD_INT 23
93681: PUSH
93682: LD_INT 25
93684: PUSH
93685: LD_INT 26
93687: PUSH
93688: LD_INT 30
93690: PUSH
93691: LD_INT 31
93693: PUSH
93694: LD_INT 32
93696: PUSH
93697: LD_INT 33
93699: PUSH
93700: LD_INT 34
93702: PUSH
93703: LD_INT 35
93705: PUSH
93706: LD_INT 36
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 101
93734: PUSH
93735: LD_INT 102
93737: PUSH
93738: LD_INT 103
93740: PUSH
93741: LD_INT 106
93743: PUSH
93744: LD_INT 108
93746: PUSH
93747: LD_INT 112
93749: PUSH
93750: LD_INT 113
93752: PUSH
93753: LD_INT 114
93755: PUSH
93756: LD_INT 115
93758: PUSH
93759: LD_INT 116
93761: PUSH
93762: LD_INT 117
93764: PUSH
93765: LD_INT 118
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: ST_TO_ADDR
93786: GO 94029
93788: LD_INT 19
93790: DOUBLE
93791: EQUAL
93792: IFTRUE 93796
93794: GO 94028
93796: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
93797: LD_ADDR_VAR 0 2
93801: PUSH
93802: LD_INT 1
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: LD_INT 3
93810: PUSH
93811: LD_INT 4
93813: PUSH
93814: LD_INT 5
93816: PUSH
93817: LD_INT 6
93819: PUSH
93820: LD_INT 7
93822: PUSH
93823: LD_INT 8
93825: PUSH
93826: LD_INT 9
93828: PUSH
93829: LD_INT 10
93831: PUSH
93832: LD_INT 11
93834: PUSH
93835: LD_INT 12
93837: PUSH
93838: LD_INT 13
93840: PUSH
93841: LD_INT 14
93843: PUSH
93844: LD_INT 15
93846: PUSH
93847: LD_INT 16
93849: PUSH
93850: LD_INT 17
93852: PUSH
93853: LD_INT 18
93855: PUSH
93856: LD_INT 19
93858: PUSH
93859: LD_INT 20
93861: PUSH
93862: LD_INT 21
93864: PUSH
93865: LD_INT 22
93867: PUSH
93868: LD_INT 23
93870: PUSH
93871: LD_INT 24
93873: PUSH
93874: LD_INT 25
93876: PUSH
93877: LD_INT 26
93879: PUSH
93880: LD_INT 27
93882: PUSH
93883: LD_INT 28
93885: PUSH
93886: LD_INT 29
93888: PUSH
93889: LD_INT 30
93891: PUSH
93892: LD_INT 31
93894: PUSH
93895: LD_INT 32
93897: PUSH
93898: LD_INT 33
93900: PUSH
93901: LD_INT 34
93903: PUSH
93904: LD_INT 35
93906: PUSH
93907: LD_INT 36
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 101
93950: PUSH
93951: LD_INT 102
93953: PUSH
93954: LD_INT 103
93956: PUSH
93957: LD_INT 104
93959: PUSH
93960: LD_INT 105
93962: PUSH
93963: LD_INT 106
93965: PUSH
93966: LD_INT 107
93968: PUSH
93969: LD_INT 108
93971: PUSH
93972: LD_INT 109
93974: PUSH
93975: LD_INT 110
93977: PUSH
93978: LD_INT 111
93980: PUSH
93981: LD_INT 112
93983: PUSH
93984: LD_INT 113
93986: PUSH
93987: LD_INT 114
93989: PUSH
93990: LD_INT 115
93992: PUSH
93993: LD_INT 116
93995: PUSH
93996: LD_INT 117
93998: PUSH
93999: LD_INT 118
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: ST_TO_ADDR
94026: GO 94029
94028: POP
// end else
94029: GO 94260
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94031: LD_ADDR_VAR 0 2
94035: PUSH
94036: LD_INT 1
94038: PUSH
94039: LD_INT 2
94041: PUSH
94042: LD_INT 3
94044: PUSH
94045: LD_INT 4
94047: PUSH
94048: LD_INT 5
94050: PUSH
94051: LD_INT 6
94053: PUSH
94054: LD_INT 7
94056: PUSH
94057: LD_INT 8
94059: PUSH
94060: LD_INT 9
94062: PUSH
94063: LD_INT 10
94065: PUSH
94066: LD_INT 11
94068: PUSH
94069: LD_INT 12
94071: PUSH
94072: LD_INT 13
94074: PUSH
94075: LD_INT 14
94077: PUSH
94078: LD_INT 15
94080: PUSH
94081: LD_INT 16
94083: PUSH
94084: LD_INT 17
94086: PUSH
94087: LD_INT 18
94089: PUSH
94090: LD_INT 19
94092: PUSH
94093: LD_INT 20
94095: PUSH
94096: LD_INT 21
94098: PUSH
94099: LD_INT 22
94101: PUSH
94102: LD_INT 23
94104: PUSH
94105: LD_INT 24
94107: PUSH
94108: LD_INT 25
94110: PUSH
94111: LD_INT 26
94113: PUSH
94114: LD_INT 27
94116: PUSH
94117: LD_INT 28
94119: PUSH
94120: LD_INT 29
94122: PUSH
94123: LD_INT 30
94125: PUSH
94126: LD_INT 31
94128: PUSH
94129: LD_INT 32
94131: PUSH
94132: LD_INT 33
94134: PUSH
94135: LD_INT 34
94137: PUSH
94138: LD_INT 35
94140: PUSH
94141: LD_INT 36
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 101
94184: PUSH
94185: LD_INT 102
94187: PUSH
94188: LD_INT 103
94190: PUSH
94191: LD_INT 104
94193: PUSH
94194: LD_INT 105
94196: PUSH
94197: LD_INT 106
94199: PUSH
94200: LD_INT 107
94202: PUSH
94203: LD_INT 108
94205: PUSH
94206: LD_INT 109
94208: PUSH
94209: LD_INT 110
94211: PUSH
94212: LD_INT 111
94214: PUSH
94215: LD_INT 112
94217: PUSH
94218: LD_INT 113
94220: PUSH
94221: LD_INT 114
94223: PUSH
94224: LD_INT 115
94226: PUSH
94227: LD_INT 116
94229: PUSH
94230: LD_INT 117
94232: PUSH
94233: LD_INT 118
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: ST_TO_ADDR
// if result then
94260: LD_VAR 0 2
94264: IFFALSE 95050
// begin normal :=  ;
94266: LD_ADDR_VAR 0 5
94270: PUSH
94271: LD_STRING 
94273: ST_TO_ADDR
// hardcore :=  ;
94274: LD_ADDR_VAR 0 6
94278: PUSH
94279: LD_STRING 
94281: ST_TO_ADDR
// active :=  ;
94282: LD_ADDR_VAR 0 7
94286: PUSH
94287: LD_STRING 
94289: ST_TO_ADDR
// for i = 1 to normalCounter do
94290: LD_ADDR_VAR 0 8
94294: PUSH
94295: DOUBLE
94296: LD_INT 1
94298: DEC
94299: ST_TO_ADDR
94300: LD_EXP 115
94304: PUSH
94305: FOR_TO
94306: IFFALSE 94407
// begin tmp := 0 ;
94308: LD_ADDR_VAR 0 3
94312: PUSH
94313: LD_STRING 0
94315: ST_TO_ADDR
// if result [ 1 ] then
94316: LD_VAR 0 2
94320: PUSH
94321: LD_INT 1
94323: ARRAY
94324: IFFALSE 94389
// if result [ 1 ] [ 1 ] = i then
94326: LD_VAR 0 2
94330: PUSH
94331: LD_INT 1
94333: ARRAY
94334: PUSH
94335: LD_INT 1
94337: ARRAY
94338: PUSH
94339: LD_VAR 0 8
94343: EQUAL
94344: IFFALSE 94389
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94346: LD_ADDR_VAR 0 2
94350: PUSH
94351: LD_VAR 0 2
94355: PPUSH
94356: LD_INT 1
94358: PPUSH
94359: LD_VAR 0 2
94363: PUSH
94364: LD_INT 1
94366: ARRAY
94367: PPUSH
94368: LD_INT 1
94370: PPUSH
94371: CALL_OW 3
94375: PPUSH
94376: CALL_OW 1
94380: ST_TO_ADDR
// tmp := 1 ;
94381: LD_ADDR_VAR 0 3
94385: PUSH
94386: LD_STRING 1
94388: ST_TO_ADDR
// end ; normal := normal & tmp ;
94389: LD_ADDR_VAR 0 5
94393: PUSH
94394: LD_VAR 0 5
94398: PUSH
94399: LD_VAR 0 3
94403: STR
94404: ST_TO_ADDR
// end ;
94405: GO 94305
94407: POP
94408: POP
// for i = 1 to hardcoreCounter do
94409: LD_ADDR_VAR 0 8
94413: PUSH
94414: DOUBLE
94415: LD_INT 1
94417: DEC
94418: ST_TO_ADDR
94419: LD_EXP 116
94423: PUSH
94424: FOR_TO
94425: IFFALSE 94530
// begin tmp := 0 ;
94427: LD_ADDR_VAR 0 3
94431: PUSH
94432: LD_STRING 0
94434: ST_TO_ADDR
// if result [ 2 ] then
94435: LD_VAR 0 2
94439: PUSH
94440: LD_INT 2
94442: ARRAY
94443: IFFALSE 94512
// if result [ 2 ] [ 1 ] = 100 + i then
94445: LD_VAR 0 2
94449: PUSH
94450: LD_INT 2
94452: ARRAY
94453: PUSH
94454: LD_INT 1
94456: ARRAY
94457: PUSH
94458: LD_INT 100
94460: PUSH
94461: LD_VAR 0 8
94465: PLUS
94466: EQUAL
94467: IFFALSE 94512
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94469: LD_ADDR_VAR 0 2
94473: PUSH
94474: LD_VAR 0 2
94478: PPUSH
94479: LD_INT 2
94481: PPUSH
94482: LD_VAR 0 2
94486: PUSH
94487: LD_INT 2
94489: ARRAY
94490: PPUSH
94491: LD_INT 1
94493: PPUSH
94494: CALL_OW 3
94498: PPUSH
94499: CALL_OW 1
94503: ST_TO_ADDR
// tmp := 1 ;
94504: LD_ADDR_VAR 0 3
94508: PUSH
94509: LD_STRING 1
94511: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94512: LD_ADDR_VAR 0 6
94516: PUSH
94517: LD_VAR 0 6
94521: PUSH
94522: LD_VAR 0 3
94526: STR
94527: ST_TO_ADDR
// end ;
94528: GO 94424
94530: POP
94531: POP
// if isGameLoad then
94532: LD_VAR 0 1
94536: IFFALSE 95011
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
94538: LD_ADDR_VAR 0 4
94542: PUSH
94543: LD_EXP 119
94547: PUSH
94548: LD_EXP 118
94552: PUSH
94553: LD_EXP 120
94557: PUSH
94558: LD_EXP 117
94562: PUSH
94563: LD_EXP 121
94567: PUSH
94568: LD_EXP 122
94572: PUSH
94573: LD_EXP 123
94577: PUSH
94578: LD_EXP 124
94582: PUSH
94583: LD_EXP 125
94587: PUSH
94588: LD_EXP 126
94592: PUSH
94593: LD_EXP 127
94597: PUSH
94598: LD_EXP 128
94602: PUSH
94603: LD_EXP 129
94607: PUSH
94608: LD_EXP 130
94612: PUSH
94613: LD_EXP 138
94617: PUSH
94618: LD_EXP 139
94622: PUSH
94623: LD_EXP 140
94627: PUSH
94628: LD_EXP 141
94632: PUSH
94633: LD_EXP 143
94637: PUSH
94638: LD_EXP 144
94642: PUSH
94643: LD_EXP 145
94647: PUSH
94648: LD_EXP 148
94652: PUSH
94653: LD_EXP 150
94657: PUSH
94658: LD_EXP 151
94662: PUSH
94663: LD_EXP 152
94667: PUSH
94668: LD_EXP 154
94672: PUSH
94673: LD_EXP 155
94677: PUSH
94678: LD_EXP 158
94682: PUSH
94683: LD_EXP 159
94687: PUSH
94688: LD_EXP 160
94692: PUSH
94693: LD_EXP 161
94697: PUSH
94698: LD_EXP 162
94702: PUSH
94703: LD_EXP 163
94707: PUSH
94708: LD_EXP 164
94712: PUSH
94713: LD_EXP 165
94717: PUSH
94718: LD_EXP 166
94722: PUSH
94723: LD_EXP 131
94727: PUSH
94728: LD_EXP 132
94732: PUSH
94733: LD_EXP 135
94737: PUSH
94738: LD_EXP 136
94742: PUSH
94743: LD_EXP 137
94747: PUSH
94748: LD_EXP 133
94752: PUSH
94753: LD_EXP 134
94757: PUSH
94758: LD_EXP 142
94762: PUSH
94763: LD_EXP 146
94767: PUSH
94768: LD_EXP 147
94772: PUSH
94773: LD_EXP 149
94777: PUSH
94778: LD_EXP 153
94782: PUSH
94783: LD_EXP 156
94787: PUSH
94788: LD_EXP 157
94792: PUSH
94793: LD_EXP 167
94797: PUSH
94798: LD_EXP 168
94802: PUSH
94803: LD_EXP 169
94807: PUSH
94808: LD_EXP 170
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: ST_TO_ADDR
// tmp :=  ;
94869: LD_ADDR_VAR 0 3
94873: PUSH
94874: LD_STRING 
94876: ST_TO_ADDR
// for i = 1 to normalCounter do
94877: LD_ADDR_VAR 0 8
94881: PUSH
94882: DOUBLE
94883: LD_INT 1
94885: DEC
94886: ST_TO_ADDR
94887: LD_EXP 115
94891: PUSH
94892: FOR_TO
94893: IFFALSE 94929
// begin if flags [ i ] then
94895: LD_VAR 0 4
94899: PUSH
94900: LD_VAR 0 8
94904: ARRAY
94905: IFFALSE 94927
// tmp := tmp & i & ; ;
94907: LD_ADDR_VAR 0 3
94911: PUSH
94912: LD_VAR 0 3
94916: PUSH
94917: LD_VAR 0 8
94921: STR
94922: PUSH
94923: LD_STRING ;
94925: STR
94926: ST_TO_ADDR
// end ;
94927: GO 94892
94929: POP
94930: POP
// for i = 1 to hardcoreCounter do
94931: LD_ADDR_VAR 0 8
94935: PUSH
94936: DOUBLE
94937: LD_INT 1
94939: DEC
94940: ST_TO_ADDR
94941: LD_EXP 116
94945: PUSH
94946: FOR_TO
94947: IFFALSE 94993
// begin if flags [ normalCounter + i ] then
94949: LD_VAR 0 4
94953: PUSH
94954: LD_EXP 115
94958: PUSH
94959: LD_VAR 0 8
94963: PLUS
94964: ARRAY
94965: IFFALSE 94991
// tmp := tmp & ( 100 + i ) & ; ;
94967: LD_ADDR_VAR 0 3
94971: PUSH
94972: LD_VAR 0 3
94976: PUSH
94977: LD_INT 100
94979: PUSH
94980: LD_VAR 0 8
94984: PLUS
94985: STR
94986: PUSH
94987: LD_STRING ;
94989: STR
94990: ST_TO_ADDR
// end ;
94991: GO 94946
94993: POP
94994: POP
// if tmp then
94995: LD_VAR 0 3
94999: IFFALSE 95011
// active := tmp ;
95001: LD_ADDR_VAR 0 7
95005: PUSH
95006: LD_VAR 0 3
95010: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95011: LD_STRING getStreamItemsFromMission("
95013: PUSH
95014: LD_VAR 0 5
95018: STR
95019: PUSH
95020: LD_STRING ","
95022: STR
95023: PUSH
95024: LD_VAR 0 6
95028: STR
95029: PUSH
95030: LD_STRING ","
95032: STR
95033: PUSH
95034: LD_VAR 0 7
95038: STR
95039: PUSH
95040: LD_STRING ")
95042: STR
95043: PPUSH
95044: CALL_OW 559
// end else
95048: GO 95057
// ToLua ( getStreamItemsFromMission("","","") ) ;
95050: LD_STRING getStreamItemsFromMission("","","")
95052: PPUSH
95053: CALL_OW 559
// end ;
95057: LD_VAR 0 2
95061: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95062: LD_EXP 114
95066: PUSH
95067: LD_EXP 119
95071: AND
95072: IFFALSE 95196
95074: GO 95076
95076: DISABLE
95077: LD_INT 0
95079: PPUSH
95080: PPUSH
// begin enable ;
95081: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95082: LD_ADDR_VAR 0 2
95086: PUSH
95087: LD_INT 22
95089: PUSH
95090: LD_OWVAR 2
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 2
95101: PUSH
95102: LD_INT 34
95104: PUSH
95105: LD_INT 7
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 34
95114: PUSH
95115: LD_INT 45
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 34
95124: PUSH
95125: LD_INT 28
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 34
95134: PUSH
95135: LD_INT 47
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PPUSH
95153: CALL_OW 69
95157: ST_TO_ADDR
// if not tmp then
95158: LD_VAR 0 2
95162: NOT
95163: IFFALSE 95167
// exit ;
95165: GO 95196
// for i in tmp do
95167: LD_ADDR_VAR 0 1
95171: PUSH
95172: LD_VAR 0 2
95176: PUSH
95177: FOR_IN
95178: IFFALSE 95194
// begin SetLives ( i , 0 ) ;
95180: LD_VAR 0 1
95184: PPUSH
95185: LD_INT 0
95187: PPUSH
95188: CALL_OW 234
// end ;
95192: GO 95177
95194: POP
95195: POP
// end ;
95196: PPOPN 2
95198: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95199: LD_EXP 114
95203: PUSH
95204: LD_EXP 120
95208: AND
95209: IFFALSE 95293
95211: GO 95213
95213: DISABLE
95214: LD_INT 0
95216: PPUSH
95217: PPUSH
// begin enable ;
95218: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95219: LD_ADDR_VAR 0 2
95223: PUSH
95224: LD_INT 22
95226: PUSH
95227: LD_OWVAR 2
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 32
95238: PUSH
95239: LD_INT 3
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PPUSH
95250: CALL_OW 69
95254: ST_TO_ADDR
// if not tmp then
95255: LD_VAR 0 2
95259: NOT
95260: IFFALSE 95264
// exit ;
95262: GO 95293
// for i in tmp do
95264: LD_ADDR_VAR 0 1
95268: PUSH
95269: LD_VAR 0 2
95273: PUSH
95274: FOR_IN
95275: IFFALSE 95291
// begin SetLives ( i , 0 ) ;
95277: LD_VAR 0 1
95281: PPUSH
95282: LD_INT 0
95284: PPUSH
95285: CALL_OW 234
// end ;
95289: GO 95274
95291: POP
95292: POP
// end ;
95293: PPOPN 2
95295: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95296: LD_EXP 114
95300: PUSH
95301: LD_EXP 117
95305: AND
95306: IFFALSE 95399
95308: GO 95310
95310: DISABLE
95311: LD_INT 0
95313: PPUSH
// begin enable ;
95314: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95315: LD_ADDR_VAR 0 1
95319: PUSH
95320: LD_INT 22
95322: PUSH
95323: LD_OWVAR 2
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 2
95334: PUSH
95335: LD_INT 25
95337: PUSH
95338: LD_INT 5
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 25
95347: PUSH
95348: LD_INT 9
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 25
95357: PUSH
95358: LD_INT 8
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PPUSH
95375: CALL_OW 69
95379: PUSH
95380: FOR_IN
95381: IFFALSE 95397
// begin SetClass ( i , 1 ) ;
95383: LD_VAR 0 1
95387: PPUSH
95388: LD_INT 1
95390: PPUSH
95391: CALL_OW 336
// end ;
95395: GO 95380
95397: POP
95398: POP
// end ;
95399: PPOPN 1
95401: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95402: LD_EXP 114
95406: PUSH
95407: LD_EXP 118
95411: AND
95412: PUSH
95413: LD_OWVAR 65
95417: PUSH
95418: LD_INT 7
95420: LESS
95421: AND
95422: IFFALSE 95436
95424: GO 95426
95426: DISABLE
// begin enable ;
95427: ENABLE
// game_speed := 7 ;
95428: LD_ADDR_OWVAR 65
95432: PUSH
95433: LD_INT 7
95435: ST_TO_ADDR
// end ;
95436: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95437: LD_EXP 114
95441: PUSH
95442: LD_EXP 121
95446: AND
95447: IFFALSE 95649
95449: GO 95451
95451: DISABLE
95452: LD_INT 0
95454: PPUSH
95455: PPUSH
95456: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95457: LD_ADDR_VAR 0 3
95461: PUSH
95462: LD_INT 81
95464: PUSH
95465: LD_OWVAR 2
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 21
95476: PUSH
95477: LD_INT 1
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: EMPTY
95485: LIST
95486: LIST
95487: PPUSH
95488: CALL_OW 69
95492: ST_TO_ADDR
// if not tmp then
95493: LD_VAR 0 3
95497: NOT
95498: IFFALSE 95502
// exit ;
95500: GO 95649
// if tmp > 5 then
95502: LD_VAR 0 3
95506: PUSH
95507: LD_INT 5
95509: GREATER
95510: IFFALSE 95522
// k := 5 else
95512: LD_ADDR_VAR 0 2
95516: PUSH
95517: LD_INT 5
95519: ST_TO_ADDR
95520: GO 95532
// k := tmp ;
95522: LD_ADDR_VAR 0 2
95526: PUSH
95527: LD_VAR 0 3
95531: ST_TO_ADDR
// for i := 1 to k do
95532: LD_ADDR_VAR 0 1
95536: PUSH
95537: DOUBLE
95538: LD_INT 1
95540: DEC
95541: ST_TO_ADDR
95542: LD_VAR 0 2
95546: PUSH
95547: FOR_TO
95548: IFFALSE 95647
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95550: LD_VAR 0 3
95554: PUSH
95555: LD_VAR 0 1
95559: ARRAY
95560: PPUSH
95561: LD_VAR 0 1
95565: PUSH
95566: LD_INT 4
95568: MOD
95569: PUSH
95570: LD_INT 1
95572: PLUS
95573: PPUSH
95574: CALL_OW 259
95578: PUSH
95579: LD_INT 10
95581: LESS
95582: IFFALSE 95645
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95584: LD_VAR 0 3
95588: PUSH
95589: LD_VAR 0 1
95593: ARRAY
95594: PPUSH
95595: LD_VAR 0 1
95599: PUSH
95600: LD_INT 4
95602: MOD
95603: PUSH
95604: LD_INT 1
95606: PLUS
95607: PPUSH
95608: LD_VAR 0 3
95612: PUSH
95613: LD_VAR 0 1
95617: ARRAY
95618: PPUSH
95619: LD_VAR 0 1
95623: PUSH
95624: LD_INT 4
95626: MOD
95627: PUSH
95628: LD_INT 1
95630: PLUS
95631: PPUSH
95632: CALL_OW 259
95636: PUSH
95637: LD_INT 1
95639: PLUS
95640: PPUSH
95641: CALL_OW 237
95645: GO 95547
95647: POP
95648: POP
// end ;
95649: PPOPN 3
95651: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95652: LD_EXP 114
95656: PUSH
95657: LD_EXP 122
95661: AND
95662: IFFALSE 95682
95664: GO 95666
95666: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95667: LD_INT 4
95669: PPUSH
95670: LD_OWVAR 2
95674: PPUSH
95675: LD_INT 0
95677: PPUSH
95678: CALL_OW 324
95682: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95683: LD_EXP 114
95687: PUSH
95688: LD_EXP 151
95692: AND
95693: IFFALSE 95713
95695: GO 95697
95697: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95698: LD_INT 19
95700: PPUSH
95701: LD_OWVAR 2
95705: PPUSH
95706: LD_INT 0
95708: PPUSH
95709: CALL_OW 324
95713: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95714: LD_EXP 114
95718: PUSH
95719: LD_EXP 123
95723: AND
95724: IFFALSE 95826
95726: GO 95728
95728: DISABLE
95729: LD_INT 0
95731: PPUSH
95732: PPUSH
// begin enable ;
95733: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95734: LD_ADDR_VAR 0 2
95738: PUSH
95739: LD_INT 22
95741: PUSH
95742: LD_OWVAR 2
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 2
95753: PUSH
95754: LD_INT 34
95756: PUSH
95757: LD_INT 11
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 34
95766: PUSH
95767: LD_INT 30
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: LIST
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PPUSH
95783: CALL_OW 69
95787: ST_TO_ADDR
// if not tmp then
95788: LD_VAR 0 2
95792: NOT
95793: IFFALSE 95797
// exit ;
95795: GO 95826
// for i in tmp do
95797: LD_ADDR_VAR 0 1
95801: PUSH
95802: LD_VAR 0 2
95806: PUSH
95807: FOR_IN
95808: IFFALSE 95824
// begin SetLives ( i , 0 ) ;
95810: LD_VAR 0 1
95814: PPUSH
95815: LD_INT 0
95817: PPUSH
95818: CALL_OW 234
// end ;
95822: GO 95807
95824: POP
95825: POP
// end ;
95826: PPOPN 2
95828: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95829: LD_EXP 114
95833: PUSH
95834: LD_EXP 124
95838: AND
95839: IFFALSE 95859
95841: GO 95843
95843: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95844: LD_INT 32
95846: PPUSH
95847: LD_OWVAR 2
95851: PPUSH
95852: LD_INT 0
95854: PPUSH
95855: CALL_OW 324
95859: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95860: LD_EXP 114
95864: PUSH
95865: LD_EXP 125
95869: AND
95870: IFFALSE 96051
95872: GO 95874
95874: DISABLE
95875: LD_INT 0
95877: PPUSH
95878: PPUSH
95879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95880: LD_ADDR_VAR 0 2
95884: PUSH
95885: LD_INT 22
95887: PUSH
95888: LD_OWVAR 2
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 33
95899: PUSH
95900: LD_INT 3
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PPUSH
95911: CALL_OW 69
95915: ST_TO_ADDR
// if not tmp then
95916: LD_VAR 0 2
95920: NOT
95921: IFFALSE 95925
// exit ;
95923: GO 96051
// side := 0 ;
95925: LD_ADDR_VAR 0 3
95929: PUSH
95930: LD_INT 0
95932: ST_TO_ADDR
// for i := 1 to 8 do
95933: LD_ADDR_VAR 0 1
95937: PUSH
95938: DOUBLE
95939: LD_INT 1
95941: DEC
95942: ST_TO_ADDR
95943: LD_INT 8
95945: PUSH
95946: FOR_TO
95947: IFFALSE 95995
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95949: LD_OWVAR 2
95953: PUSH
95954: LD_VAR 0 1
95958: NONEQUAL
95959: PUSH
95960: LD_OWVAR 2
95964: PPUSH
95965: LD_VAR 0 1
95969: PPUSH
95970: CALL_OW 81
95974: PUSH
95975: LD_INT 2
95977: EQUAL
95978: AND
95979: IFFALSE 95993
// begin side := i ;
95981: LD_ADDR_VAR 0 3
95985: PUSH
95986: LD_VAR 0 1
95990: ST_TO_ADDR
// break ;
95991: GO 95995
// end ;
95993: GO 95946
95995: POP
95996: POP
// if not side then
95997: LD_VAR 0 3
96001: NOT
96002: IFFALSE 96006
// exit ;
96004: GO 96051
// for i := 1 to tmp do
96006: LD_ADDR_VAR 0 1
96010: PUSH
96011: DOUBLE
96012: LD_INT 1
96014: DEC
96015: ST_TO_ADDR
96016: LD_VAR 0 2
96020: PUSH
96021: FOR_TO
96022: IFFALSE 96049
// if Prob ( 60 ) then
96024: LD_INT 60
96026: PPUSH
96027: CALL_OW 13
96031: IFFALSE 96047
// SetSide ( i , side ) ;
96033: LD_VAR 0 1
96037: PPUSH
96038: LD_VAR 0 3
96042: PPUSH
96043: CALL_OW 235
96047: GO 96021
96049: POP
96050: POP
// end ;
96051: PPOPN 3
96053: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96054: LD_EXP 114
96058: PUSH
96059: LD_EXP 127
96063: AND
96064: IFFALSE 96183
96066: GO 96068
96068: DISABLE
96069: LD_INT 0
96071: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96072: LD_ADDR_VAR 0 1
96076: PUSH
96077: LD_INT 22
96079: PUSH
96080: LD_OWVAR 2
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 21
96091: PUSH
96092: LD_INT 1
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PUSH
96099: LD_INT 3
96101: PUSH
96102: LD_INT 23
96104: PUSH
96105: LD_INT 0
96107: PUSH
96108: EMPTY
96109: LIST
96110: LIST
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: LIST
96120: PPUSH
96121: CALL_OW 69
96125: PUSH
96126: FOR_IN
96127: IFFALSE 96181
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96129: LD_VAR 0 1
96133: PPUSH
96134: CALL_OW 257
96138: PUSH
96139: LD_INT 1
96141: PUSH
96142: LD_INT 2
96144: PUSH
96145: LD_INT 3
96147: PUSH
96148: LD_INT 4
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: IN
96157: IFFALSE 96179
// SetClass ( un , rand ( 1 , 4 ) ) ;
96159: LD_VAR 0 1
96163: PPUSH
96164: LD_INT 1
96166: PPUSH
96167: LD_INT 4
96169: PPUSH
96170: CALL_OW 12
96174: PPUSH
96175: CALL_OW 336
96179: GO 96126
96181: POP
96182: POP
// end ;
96183: PPOPN 1
96185: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96186: LD_EXP 114
96190: PUSH
96191: LD_EXP 126
96195: AND
96196: IFFALSE 96275
96198: GO 96200
96200: DISABLE
96201: LD_INT 0
96203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96204: LD_ADDR_VAR 0 1
96208: PUSH
96209: LD_INT 22
96211: PUSH
96212: LD_OWVAR 2
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 21
96223: PUSH
96224: LD_INT 3
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PPUSH
96235: CALL_OW 69
96239: ST_TO_ADDR
// if not tmp then
96240: LD_VAR 0 1
96244: NOT
96245: IFFALSE 96249
// exit ;
96247: GO 96275
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96249: LD_VAR 0 1
96253: PUSH
96254: LD_INT 1
96256: PPUSH
96257: LD_VAR 0 1
96261: PPUSH
96262: CALL_OW 12
96266: ARRAY
96267: PPUSH
96268: LD_INT 100
96270: PPUSH
96271: CALL_OW 234
// end ;
96275: PPOPN 1
96277: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96278: LD_EXP 114
96282: PUSH
96283: LD_EXP 128
96287: AND
96288: IFFALSE 96386
96290: GO 96292
96292: DISABLE
96293: LD_INT 0
96295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96296: LD_ADDR_VAR 0 1
96300: PUSH
96301: LD_INT 22
96303: PUSH
96304: LD_OWVAR 2
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 21
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PPUSH
96327: CALL_OW 69
96331: ST_TO_ADDR
// if not tmp then
96332: LD_VAR 0 1
96336: NOT
96337: IFFALSE 96341
// exit ;
96339: GO 96386
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96341: LD_VAR 0 1
96345: PUSH
96346: LD_INT 1
96348: PPUSH
96349: LD_VAR 0 1
96353: PPUSH
96354: CALL_OW 12
96358: ARRAY
96359: PPUSH
96360: LD_INT 1
96362: PPUSH
96363: LD_INT 4
96365: PPUSH
96366: CALL_OW 12
96370: PPUSH
96371: LD_INT 3000
96373: PPUSH
96374: LD_INT 9000
96376: PPUSH
96377: CALL_OW 12
96381: PPUSH
96382: CALL_OW 492
// end ;
96386: PPOPN 1
96388: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96389: LD_EXP 114
96393: PUSH
96394: LD_EXP 129
96398: AND
96399: IFFALSE 96419
96401: GO 96403
96403: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96404: LD_INT 1
96406: PPUSH
96407: LD_OWVAR 2
96411: PPUSH
96412: LD_INT 0
96414: PPUSH
96415: CALL_OW 324
96419: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96420: LD_EXP 114
96424: PUSH
96425: LD_EXP 130
96429: AND
96430: IFFALSE 96513
96432: GO 96434
96434: DISABLE
96435: LD_INT 0
96437: PPUSH
96438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96439: LD_ADDR_VAR 0 2
96443: PUSH
96444: LD_INT 22
96446: PUSH
96447: LD_OWVAR 2
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 21
96458: PUSH
96459: LD_INT 3
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PPUSH
96470: CALL_OW 69
96474: ST_TO_ADDR
// if not tmp then
96475: LD_VAR 0 2
96479: NOT
96480: IFFALSE 96484
// exit ;
96482: GO 96513
// for i in tmp do
96484: LD_ADDR_VAR 0 1
96488: PUSH
96489: LD_VAR 0 2
96493: PUSH
96494: FOR_IN
96495: IFFALSE 96511
// SetBLevel ( i , 10 ) ;
96497: LD_VAR 0 1
96501: PPUSH
96502: LD_INT 10
96504: PPUSH
96505: CALL_OW 241
96509: GO 96494
96511: POP
96512: POP
// end ;
96513: PPOPN 2
96515: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96516: LD_EXP 114
96520: PUSH
96521: LD_EXP 131
96525: AND
96526: IFFALSE 96637
96528: GO 96530
96530: DISABLE
96531: LD_INT 0
96533: PPUSH
96534: PPUSH
96535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96536: LD_ADDR_VAR 0 3
96540: PUSH
96541: LD_INT 22
96543: PUSH
96544: LD_OWVAR 2
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 25
96555: PUSH
96556: LD_INT 1
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: PPUSH
96567: CALL_OW 69
96571: ST_TO_ADDR
// if not tmp then
96572: LD_VAR 0 3
96576: NOT
96577: IFFALSE 96581
// exit ;
96579: GO 96637
// un := tmp [ rand ( 1 , tmp ) ] ;
96581: LD_ADDR_VAR 0 2
96585: PUSH
96586: LD_VAR 0 3
96590: PUSH
96591: LD_INT 1
96593: PPUSH
96594: LD_VAR 0 3
96598: PPUSH
96599: CALL_OW 12
96603: ARRAY
96604: ST_TO_ADDR
// if Crawls ( un ) then
96605: LD_VAR 0 2
96609: PPUSH
96610: CALL_OW 318
96614: IFFALSE 96625
// ComWalk ( un ) ;
96616: LD_VAR 0 2
96620: PPUSH
96621: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96625: LD_VAR 0 2
96629: PPUSH
96630: LD_INT 5
96632: PPUSH
96633: CALL_OW 336
// end ;
96637: PPOPN 3
96639: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
96640: LD_EXP 114
96644: PUSH
96645: LD_EXP 132
96649: AND
96650: PUSH
96651: LD_OWVAR 67
96655: PUSH
96656: LD_INT 4
96658: LESS
96659: AND
96660: IFFALSE 96679
96662: GO 96664
96664: DISABLE
// begin Difficulty := Difficulty + 1 ;
96665: LD_ADDR_OWVAR 67
96669: PUSH
96670: LD_OWVAR 67
96674: PUSH
96675: LD_INT 1
96677: PLUS
96678: ST_TO_ADDR
// end ;
96679: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96680: LD_EXP 114
96684: PUSH
96685: LD_EXP 133
96689: AND
96690: IFFALSE 96793
96692: GO 96694
96694: DISABLE
96695: LD_INT 0
96697: PPUSH
// begin for i := 1 to 5 do
96698: LD_ADDR_VAR 0 1
96702: PUSH
96703: DOUBLE
96704: LD_INT 1
96706: DEC
96707: ST_TO_ADDR
96708: LD_INT 5
96710: PUSH
96711: FOR_TO
96712: IFFALSE 96791
// begin uc_nation := nation_nature ;
96714: LD_ADDR_OWVAR 21
96718: PUSH
96719: LD_INT 0
96721: ST_TO_ADDR
// uc_side := 0 ;
96722: LD_ADDR_OWVAR 20
96726: PUSH
96727: LD_INT 0
96729: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96730: LD_ADDR_OWVAR 29
96734: PUSH
96735: LD_INT 12
96737: PUSH
96738: LD_INT 12
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: ST_TO_ADDR
// hc_agressivity := 20 ;
96745: LD_ADDR_OWVAR 35
96749: PUSH
96750: LD_INT 20
96752: ST_TO_ADDR
// hc_class := class_tiger ;
96753: LD_ADDR_OWVAR 28
96757: PUSH
96758: LD_INT 14
96760: ST_TO_ADDR
// hc_gallery :=  ;
96761: LD_ADDR_OWVAR 33
96765: PUSH
96766: LD_STRING 
96768: ST_TO_ADDR
// hc_name :=  ;
96769: LD_ADDR_OWVAR 26
96773: PUSH
96774: LD_STRING 
96776: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96777: CALL_OW 44
96781: PPUSH
96782: LD_INT 0
96784: PPUSH
96785: CALL_OW 51
// end ;
96789: GO 96711
96791: POP
96792: POP
// end ;
96793: PPOPN 1
96795: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96796: LD_EXP 114
96800: PUSH
96801: LD_EXP 134
96805: AND
96806: IFFALSE 96815
96808: GO 96810
96810: DISABLE
// StreamSibBomb ;
96811: CALL 96816 0 0
96815: END
// export function StreamSibBomb ; var i , x , y ; begin
96816: LD_INT 0
96818: PPUSH
96819: PPUSH
96820: PPUSH
96821: PPUSH
// result := false ;
96822: LD_ADDR_VAR 0 1
96826: PUSH
96827: LD_INT 0
96829: ST_TO_ADDR
// for i := 1 to 16 do
96830: LD_ADDR_VAR 0 2
96834: PUSH
96835: DOUBLE
96836: LD_INT 1
96838: DEC
96839: ST_TO_ADDR
96840: LD_INT 16
96842: PUSH
96843: FOR_TO
96844: IFFALSE 97043
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96846: LD_ADDR_VAR 0 3
96850: PUSH
96851: LD_INT 10
96853: PUSH
96854: LD_INT 20
96856: PUSH
96857: LD_INT 30
96859: PUSH
96860: LD_INT 40
96862: PUSH
96863: LD_INT 50
96865: PUSH
96866: LD_INT 60
96868: PUSH
96869: LD_INT 70
96871: PUSH
96872: LD_INT 80
96874: PUSH
96875: LD_INT 90
96877: PUSH
96878: LD_INT 100
96880: PUSH
96881: LD_INT 110
96883: PUSH
96884: LD_INT 120
96886: PUSH
96887: LD_INT 130
96889: PUSH
96890: LD_INT 140
96892: PUSH
96893: LD_INT 150
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 1
96915: PPUSH
96916: LD_INT 15
96918: PPUSH
96919: CALL_OW 12
96923: ARRAY
96924: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96925: LD_ADDR_VAR 0 4
96929: PUSH
96930: LD_INT 10
96932: PUSH
96933: LD_INT 20
96935: PUSH
96936: LD_INT 30
96938: PUSH
96939: LD_INT 40
96941: PUSH
96942: LD_INT 50
96944: PUSH
96945: LD_INT 60
96947: PUSH
96948: LD_INT 70
96950: PUSH
96951: LD_INT 80
96953: PUSH
96954: LD_INT 90
96956: PUSH
96957: LD_INT 100
96959: PUSH
96960: LD_INT 110
96962: PUSH
96963: LD_INT 120
96965: PUSH
96966: LD_INT 130
96968: PUSH
96969: LD_INT 140
96971: PUSH
96972: LD_INT 150
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 1
96994: PPUSH
96995: LD_INT 15
96997: PPUSH
96998: CALL_OW 12
97002: ARRAY
97003: ST_TO_ADDR
// if ValidHex ( x , y ) then
97004: LD_VAR 0 3
97008: PPUSH
97009: LD_VAR 0 4
97013: PPUSH
97014: CALL_OW 488
97018: IFFALSE 97041
// begin result := [ x , y ] ;
97020: LD_ADDR_VAR 0 1
97024: PUSH
97025: LD_VAR 0 3
97029: PUSH
97030: LD_VAR 0 4
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: ST_TO_ADDR
// break ;
97039: GO 97043
// end ; end ;
97041: GO 96843
97043: POP
97044: POP
// if result then
97045: LD_VAR 0 1
97049: IFFALSE 97109
// begin ToLua ( playSibBomb() ) ;
97051: LD_STRING playSibBomb()
97053: PPUSH
97054: CALL_OW 559
// wait ( 0 0$14 ) ;
97058: LD_INT 490
97060: PPUSH
97061: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97065: LD_VAR 0 1
97069: PUSH
97070: LD_INT 1
97072: ARRAY
97073: PPUSH
97074: LD_VAR 0 1
97078: PUSH
97079: LD_INT 2
97081: ARRAY
97082: PPUSH
97083: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97087: LD_VAR 0 1
97091: PUSH
97092: LD_INT 1
97094: ARRAY
97095: PPUSH
97096: LD_VAR 0 1
97100: PUSH
97101: LD_INT 2
97103: ARRAY
97104: PPUSH
97105: CALL_OW 429
// end ; end ;
97109: LD_VAR 0 1
97113: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97114: LD_EXP 114
97118: PUSH
97119: LD_EXP 136
97123: AND
97124: IFFALSE 97136
97126: GO 97128
97128: DISABLE
// YouLost (  ) ;
97129: LD_STRING 
97131: PPUSH
97132: CALL_OW 104
97136: END
// every 0 0$1 trigger StreamModeActive and sFog do
97137: LD_EXP 114
97141: PUSH
97142: LD_EXP 135
97146: AND
97147: IFFALSE 97161
97149: GO 97151
97151: DISABLE
// FogOff ( your_side ) ;
97152: LD_OWVAR 2
97156: PPUSH
97157: CALL_OW 344
97161: END
// every 0 0$1 trigger StreamModeActive and sSun do
97162: LD_EXP 114
97166: PUSH
97167: LD_EXP 137
97171: AND
97172: IFFALSE 97200
97174: GO 97176
97176: DISABLE
// begin solar_recharge_percent := 0 ;
97177: LD_ADDR_OWVAR 79
97181: PUSH
97182: LD_INT 0
97184: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97185: LD_INT 10500
97187: PPUSH
97188: CALL_OW 67
// solar_recharge_percent := 100 ;
97192: LD_ADDR_OWVAR 79
97196: PUSH
97197: LD_INT 100
97199: ST_TO_ADDR
// end ;
97200: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97201: LD_EXP 114
97205: PUSH
97206: LD_EXP 138
97210: AND
97211: IFFALSE 97450
97213: GO 97215
97215: DISABLE
97216: LD_INT 0
97218: PPUSH
97219: PPUSH
97220: PPUSH
// begin tmp := [ ] ;
97221: LD_ADDR_VAR 0 3
97225: PUSH
97226: EMPTY
97227: ST_TO_ADDR
// for i := 1 to 6 do
97228: LD_ADDR_VAR 0 1
97232: PUSH
97233: DOUBLE
97234: LD_INT 1
97236: DEC
97237: ST_TO_ADDR
97238: LD_INT 6
97240: PUSH
97241: FOR_TO
97242: IFFALSE 97347
// begin uc_nation := nation_nature ;
97244: LD_ADDR_OWVAR 21
97248: PUSH
97249: LD_INT 0
97251: ST_TO_ADDR
// uc_side := 0 ;
97252: LD_ADDR_OWVAR 20
97256: PUSH
97257: LD_INT 0
97259: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97260: LD_ADDR_OWVAR 29
97264: PUSH
97265: LD_INT 12
97267: PUSH
97268: LD_INT 12
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: ST_TO_ADDR
// hc_agressivity := 20 ;
97275: LD_ADDR_OWVAR 35
97279: PUSH
97280: LD_INT 20
97282: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97283: LD_ADDR_OWVAR 28
97287: PUSH
97288: LD_INT 17
97290: ST_TO_ADDR
// hc_gallery :=  ;
97291: LD_ADDR_OWVAR 33
97295: PUSH
97296: LD_STRING 
97298: ST_TO_ADDR
// hc_name :=  ;
97299: LD_ADDR_OWVAR 26
97303: PUSH
97304: LD_STRING 
97306: ST_TO_ADDR
// un := CreateHuman ;
97307: LD_ADDR_VAR 0 2
97311: PUSH
97312: CALL_OW 44
97316: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97317: LD_VAR 0 2
97321: PPUSH
97322: LD_INT 1
97324: PPUSH
97325: CALL_OW 51
// tmp := tmp ^ un ;
97329: LD_ADDR_VAR 0 3
97333: PUSH
97334: LD_VAR 0 3
97338: PUSH
97339: LD_VAR 0 2
97343: ADD
97344: ST_TO_ADDR
// end ;
97345: GO 97241
97347: POP
97348: POP
// repeat wait ( 0 0$1 ) ;
97349: LD_INT 35
97351: PPUSH
97352: CALL_OW 67
// for un in tmp do
97356: LD_ADDR_VAR 0 2
97360: PUSH
97361: LD_VAR 0 3
97365: PUSH
97366: FOR_IN
97367: IFFALSE 97441
// begin if IsDead ( un ) then
97369: LD_VAR 0 2
97373: PPUSH
97374: CALL_OW 301
97378: IFFALSE 97398
// begin tmp := tmp diff un ;
97380: LD_ADDR_VAR 0 3
97384: PUSH
97385: LD_VAR 0 3
97389: PUSH
97390: LD_VAR 0 2
97394: DIFF
97395: ST_TO_ADDR
// continue ;
97396: GO 97366
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97398: LD_VAR 0 2
97402: PPUSH
97403: LD_INT 3
97405: PUSH
97406: LD_INT 22
97408: PUSH
97409: LD_INT 0
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: PPUSH
97420: CALL_OW 69
97424: PPUSH
97425: LD_VAR 0 2
97429: PPUSH
97430: CALL_OW 74
97434: PPUSH
97435: CALL_OW 115
// end ;
97439: GO 97366
97441: POP
97442: POP
// until not tmp ;
97443: LD_VAR 0 3
97447: NOT
97448: IFFALSE 97349
// end ;
97450: PPOPN 3
97452: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97453: LD_EXP 114
97457: PUSH
97458: LD_EXP 139
97462: AND
97463: IFFALSE 97517
97465: GO 97467
97467: DISABLE
// begin ToLua ( displayTroll(); ) ;
97468: LD_STRING displayTroll();
97470: PPUSH
97471: CALL_OW 559
// wait ( 3 3$00 ) ;
97475: LD_INT 6300
97477: PPUSH
97478: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97482: LD_STRING hideTroll();
97484: PPUSH
97485: CALL_OW 559
// wait ( 1 1$00 ) ;
97489: LD_INT 2100
97491: PPUSH
97492: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97496: LD_STRING displayTroll();
97498: PPUSH
97499: CALL_OW 559
// wait ( 1 1$00 ) ;
97503: LD_INT 2100
97505: PPUSH
97506: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97510: LD_STRING hideTroll();
97512: PPUSH
97513: CALL_OW 559
// end ;
97517: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97518: LD_EXP 114
97522: PUSH
97523: LD_EXP 140
97527: AND
97528: IFFALSE 97591
97530: GO 97532
97532: DISABLE
97533: LD_INT 0
97535: PPUSH
// begin p := 0 ;
97536: LD_ADDR_VAR 0 1
97540: PUSH
97541: LD_INT 0
97543: ST_TO_ADDR
// repeat game_speed := 1 ;
97544: LD_ADDR_OWVAR 65
97548: PUSH
97549: LD_INT 1
97551: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97552: LD_INT 35
97554: PPUSH
97555: CALL_OW 67
// p := p + 1 ;
97559: LD_ADDR_VAR 0 1
97563: PUSH
97564: LD_VAR 0 1
97568: PUSH
97569: LD_INT 1
97571: PLUS
97572: ST_TO_ADDR
// until p >= 60 ;
97573: LD_VAR 0 1
97577: PUSH
97578: LD_INT 60
97580: GREATEREQUAL
97581: IFFALSE 97544
// game_speed := 4 ;
97583: LD_ADDR_OWVAR 65
97587: PUSH
97588: LD_INT 4
97590: ST_TO_ADDR
// end ;
97591: PPOPN 1
97593: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97594: LD_EXP 114
97598: PUSH
97599: LD_EXP 141
97603: AND
97604: IFFALSE 97750
97606: GO 97608
97608: DISABLE
97609: LD_INT 0
97611: PPUSH
97612: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97613: LD_ADDR_VAR 0 1
97617: PUSH
97618: LD_INT 22
97620: PUSH
97621: LD_OWVAR 2
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: LD_INT 2
97632: PUSH
97633: LD_INT 30
97635: PUSH
97636: LD_INT 0
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: PUSH
97643: LD_INT 30
97645: PUSH
97646: LD_INT 1
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: LIST
97657: PUSH
97658: EMPTY
97659: LIST
97660: LIST
97661: PPUSH
97662: CALL_OW 69
97666: ST_TO_ADDR
// if not depot then
97667: LD_VAR 0 1
97671: NOT
97672: IFFALSE 97676
// exit ;
97674: GO 97750
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97676: LD_ADDR_VAR 0 2
97680: PUSH
97681: LD_VAR 0 1
97685: PUSH
97686: LD_INT 1
97688: PPUSH
97689: LD_VAR 0 1
97693: PPUSH
97694: CALL_OW 12
97698: ARRAY
97699: PPUSH
97700: CALL_OW 274
97704: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97705: LD_VAR 0 2
97709: PPUSH
97710: LD_INT 1
97712: PPUSH
97713: LD_INT 0
97715: PPUSH
97716: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97720: LD_VAR 0 2
97724: PPUSH
97725: LD_INT 2
97727: PPUSH
97728: LD_INT 0
97730: PPUSH
97731: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97735: LD_VAR 0 2
97739: PPUSH
97740: LD_INT 3
97742: PPUSH
97743: LD_INT 0
97745: PPUSH
97746: CALL_OW 277
// end ;
97750: PPOPN 2
97752: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97753: LD_EXP 114
97757: PUSH
97758: LD_EXP 142
97762: AND
97763: IFFALSE 97860
97765: GO 97767
97767: DISABLE
97768: LD_INT 0
97770: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97771: LD_ADDR_VAR 0 1
97775: PUSH
97776: LD_INT 22
97778: PUSH
97779: LD_OWVAR 2
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 21
97790: PUSH
97791: LD_INT 1
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 3
97800: PUSH
97801: LD_INT 23
97803: PUSH
97804: LD_INT 0
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: LIST
97819: PPUSH
97820: CALL_OW 69
97824: ST_TO_ADDR
// if not tmp then
97825: LD_VAR 0 1
97829: NOT
97830: IFFALSE 97834
// exit ;
97832: GO 97860
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97834: LD_VAR 0 1
97838: PUSH
97839: LD_INT 1
97841: PPUSH
97842: LD_VAR 0 1
97846: PPUSH
97847: CALL_OW 12
97851: ARRAY
97852: PPUSH
97853: LD_INT 200
97855: PPUSH
97856: CALL_OW 234
// end ;
97860: PPOPN 1
97862: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97863: LD_EXP 114
97867: PUSH
97868: LD_EXP 143
97872: AND
97873: IFFALSE 97952
97875: GO 97877
97877: DISABLE
97878: LD_INT 0
97880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97881: LD_ADDR_VAR 0 1
97885: PUSH
97886: LD_INT 22
97888: PUSH
97889: LD_OWVAR 2
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 21
97900: PUSH
97901: LD_INT 2
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PPUSH
97912: CALL_OW 69
97916: ST_TO_ADDR
// if not tmp then
97917: LD_VAR 0 1
97921: NOT
97922: IFFALSE 97926
// exit ;
97924: GO 97952
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97926: LD_VAR 0 1
97930: PUSH
97931: LD_INT 1
97933: PPUSH
97934: LD_VAR 0 1
97938: PPUSH
97939: CALL_OW 12
97943: ARRAY
97944: PPUSH
97945: LD_INT 60
97947: PPUSH
97948: CALL_OW 234
// end ;
97952: PPOPN 1
97954: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97955: LD_EXP 114
97959: PUSH
97960: LD_EXP 144
97964: AND
97965: IFFALSE 98064
97967: GO 97969
97969: DISABLE
97970: LD_INT 0
97972: PPUSH
97973: PPUSH
// begin enable ;
97974: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97975: LD_ADDR_VAR 0 1
97979: PUSH
97980: LD_INT 22
97982: PUSH
97983: LD_OWVAR 2
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 61
97994: PUSH
97995: EMPTY
97996: LIST
97997: PUSH
97998: LD_INT 33
98000: PUSH
98001: LD_INT 2
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: LIST
98012: PPUSH
98013: CALL_OW 69
98017: ST_TO_ADDR
// if not tmp then
98018: LD_VAR 0 1
98022: NOT
98023: IFFALSE 98027
// exit ;
98025: GO 98064
// for i in tmp do
98027: LD_ADDR_VAR 0 2
98031: PUSH
98032: LD_VAR 0 1
98036: PUSH
98037: FOR_IN
98038: IFFALSE 98062
// if IsControledBy ( i ) then
98040: LD_VAR 0 2
98044: PPUSH
98045: CALL_OW 312
98049: IFFALSE 98060
// ComUnlink ( i ) ;
98051: LD_VAR 0 2
98055: PPUSH
98056: CALL_OW 136
98060: GO 98037
98062: POP
98063: POP
// end ;
98064: PPOPN 2
98066: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98067: LD_EXP 114
98071: PUSH
98072: LD_EXP 145
98076: AND
98077: IFFALSE 98217
98079: GO 98081
98081: DISABLE
98082: LD_INT 0
98084: PPUSH
98085: PPUSH
// begin ToLua ( displayPowell(); ) ;
98086: LD_STRING displayPowell();
98088: PPUSH
98089: CALL_OW 559
// uc_side := 0 ;
98093: LD_ADDR_OWVAR 20
98097: PUSH
98098: LD_INT 0
98100: ST_TO_ADDR
// uc_nation := 2 ;
98101: LD_ADDR_OWVAR 21
98105: PUSH
98106: LD_INT 2
98108: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98109: LD_ADDR_OWVAR 37
98113: PUSH
98114: LD_INT 14
98116: ST_TO_ADDR
// vc_engine := engine_siberite ;
98117: LD_ADDR_OWVAR 39
98121: PUSH
98122: LD_INT 3
98124: ST_TO_ADDR
// vc_control := control_apeman ;
98125: LD_ADDR_OWVAR 38
98129: PUSH
98130: LD_INT 5
98132: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98133: LD_ADDR_OWVAR 40
98137: PUSH
98138: LD_INT 29
98140: ST_TO_ADDR
// un := CreateVehicle ;
98141: LD_ADDR_VAR 0 2
98145: PUSH
98146: CALL_OW 45
98150: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98151: LD_VAR 0 2
98155: PPUSH
98156: LD_INT 1
98158: PPUSH
98159: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98163: LD_INT 35
98165: PPUSH
98166: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98170: LD_VAR 0 2
98174: PPUSH
98175: LD_INT 22
98177: PUSH
98178: LD_OWVAR 2
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: PPUSH
98187: CALL_OW 69
98191: PPUSH
98192: LD_VAR 0 2
98196: PPUSH
98197: CALL_OW 74
98201: PPUSH
98202: CALL_OW 115
// until IsDead ( un ) ;
98206: LD_VAR 0 2
98210: PPUSH
98211: CALL_OW 301
98215: IFFALSE 98163
// end ;
98217: PPOPN 2
98219: END
// every 0 0$1 trigger StreamModeActive and sStu do
98220: LD_EXP 114
98224: PUSH
98225: LD_EXP 153
98229: AND
98230: IFFALSE 98246
98232: GO 98234
98234: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98235: LD_STRING displayStucuk();
98237: PPUSH
98238: CALL_OW 559
// ResetFog ;
98242: CALL_OW 335
// end ;
98246: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98247: LD_EXP 114
98251: PUSH
98252: LD_EXP 146
98256: AND
98257: IFFALSE 98398
98259: GO 98261
98261: DISABLE
98262: LD_INT 0
98264: PPUSH
98265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98266: LD_ADDR_VAR 0 2
98270: PUSH
98271: LD_INT 22
98273: PUSH
98274: LD_OWVAR 2
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PUSH
98283: LD_INT 21
98285: PUSH
98286: LD_INT 1
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PPUSH
98297: CALL_OW 69
98301: ST_TO_ADDR
// if not tmp then
98302: LD_VAR 0 2
98306: NOT
98307: IFFALSE 98311
// exit ;
98309: GO 98398
// un := tmp [ rand ( 1 , tmp ) ] ;
98311: LD_ADDR_VAR 0 1
98315: PUSH
98316: LD_VAR 0 2
98320: PUSH
98321: LD_INT 1
98323: PPUSH
98324: LD_VAR 0 2
98328: PPUSH
98329: CALL_OW 12
98333: ARRAY
98334: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98335: LD_VAR 0 1
98339: PPUSH
98340: LD_INT 0
98342: PPUSH
98343: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98347: LD_VAR 0 1
98351: PPUSH
98352: LD_OWVAR 3
98356: PUSH
98357: LD_VAR 0 1
98361: DIFF
98362: PPUSH
98363: LD_VAR 0 1
98367: PPUSH
98368: CALL_OW 74
98372: PPUSH
98373: CALL_OW 115
// wait ( 0 0$20 ) ;
98377: LD_INT 700
98379: PPUSH
98380: CALL_OW 67
// SetSide ( un , your_side ) ;
98384: LD_VAR 0 1
98388: PPUSH
98389: LD_OWVAR 2
98393: PPUSH
98394: CALL_OW 235
// end ;
98398: PPOPN 2
98400: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98401: LD_EXP 114
98405: PUSH
98406: LD_EXP 147
98410: AND
98411: IFFALSE 98517
98413: GO 98415
98415: DISABLE
98416: LD_INT 0
98418: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98419: LD_ADDR_VAR 0 1
98423: PUSH
98424: LD_INT 22
98426: PUSH
98427: LD_OWVAR 2
98431: PUSH
98432: EMPTY
98433: LIST
98434: LIST
98435: PUSH
98436: LD_INT 2
98438: PUSH
98439: LD_INT 30
98441: PUSH
98442: LD_INT 0
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 30
98451: PUSH
98452: LD_INT 1
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: LIST
98463: PUSH
98464: EMPTY
98465: LIST
98466: LIST
98467: PPUSH
98468: CALL_OW 69
98472: ST_TO_ADDR
// if not depot then
98473: LD_VAR 0 1
98477: NOT
98478: IFFALSE 98482
// exit ;
98480: GO 98517
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98482: LD_VAR 0 1
98486: PUSH
98487: LD_INT 1
98489: ARRAY
98490: PPUSH
98491: CALL_OW 250
98495: PPUSH
98496: LD_VAR 0 1
98500: PUSH
98501: LD_INT 1
98503: ARRAY
98504: PPUSH
98505: CALL_OW 251
98509: PPUSH
98510: LD_INT 70
98512: PPUSH
98513: CALL_OW 495
// end ;
98517: PPOPN 1
98519: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98520: LD_EXP 114
98524: PUSH
98525: LD_EXP 148
98529: AND
98530: IFFALSE 98741
98532: GO 98534
98534: DISABLE
98535: LD_INT 0
98537: PPUSH
98538: PPUSH
98539: PPUSH
98540: PPUSH
98541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98542: LD_ADDR_VAR 0 5
98546: PUSH
98547: LD_INT 22
98549: PUSH
98550: LD_OWVAR 2
98554: PUSH
98555: EMPTY
98556: LIST
98557: LIST
98558: PUSH
98559: LD_INT 21
98561: PUSH
98562: LD_INT 1
98564: PUSH
98565: EMPTY
98566: LIST
98567: LIST
98568: PUSH
98569: EMPTY
98570: LIST
98571: LIST
98572: PPUSH
98573: CALL_OW 69
98577: ST_TO_ADDR
// if not tmp then
98578: LD_VAR 0 5
98582: NOT
98583: IFFALSE 98587
// exit ;
98585: GO 98741
// for i in tmp do
98587: LD_ADDR_VAR 0 1
98591: PUSH
98592: LD_VAR 0 5
98596: PUSH
98597: FOR_IN
98598: IFFALSE 98739
// begin d := rand ( 0 , 5 ) ;
98600: LD_ADDR_VAR 0 4
98604: PUSH
98605: LD_INT 0
98607: PPUSH
98608: LD_INT 5
98610: PPUSH
98611: CALL_OW 12
98615: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98616: LD_ADDR_VAR 0 2
98620: PUSH
98621: LD_VAR 0 1
98625: PPUSH
98626: CALL_OW 250
98630: PPUSH
98631: LD_VAR 0 4
98635: PPUSH
98636: LD_INT 3
98638: PPUSH
98639: LD_INT 12
98641: PPUSH
98642: CALL_OW 12
98646: PPUSH
98647: CALL_OW 272
98651: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98652: LD_ADDR_VAR 0 3
98656: PUSH
98657: LD_VAR 0 1
98661: PPUSH
98662: CALL_OW 251
98666: PPUSH
98667: LD_VAR 0 4
98671: PPUSH
98672: LD_INT 3
98674: PPUSH
98675: LD_INT 12
98677: PPUSH
98678: CALL_OW 12
98682: PPUSH
98683: CALL_OW 273
98687: ST_TO_ADDR
// if ValidHex ( x , y ) then
98688: LD_VAR 0 2
98692: PPUSH
98693: LD_VAR 0 3
98697: PPUSH
98698: CALL_OW 488
98702: IFFALSE 98737
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98704: LD_VAR 0 1
98708: PPUSH
98709: LD_VAR 0 2
98713: PPUSH
98714: LD_VAR 0 3
98718: PPUSH
98719: LD_INT 3
98721: PPUSH
98722: LD_INT 6
98724: PPUSH
98725: CALL_OW 12
98729: PPUSH
98730: LD_INT 1
98732: PPUSH
98733: CALL_OW 483
// end ;
98737: GO 98597
98739: POP
98740: POP
// end ;
98741: PPOPN 5
98743: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98744: LD_EXP 114
98748: PUSH
98749: LD_EXP 149
98753: AND
98754: IFFALSE 98848
98756: GO 98758
98758: DISABLE
98759: LD_INT 0
98761: PPUSH
98762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98763: LD_ADDR_VAR 0 2
98767: PUSH
98768: LD_INT 22
98770: PUSH
98771: LD_OWVAR 2
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 32
98782: PUSH
98783: LD_INT 1
98785: PUSH
98786: EMPTY
98787: LIST
98788: LIST
98789: PUSH
98790: LD_INT 21
98792: PUSH
98793: LD_INT 2
98795: PUSH
98796: EMPTY
98797: LIST
98798: LIST
98799: PUSH
98800: EMPTY
98801: LIST
98802: LIST
98803: LIST
98804: PPUSH
98805: CALL_OW 69
98809: ST_TO_ADDR
// if not tmp then
98810: LD_VAR 0 2
98814: NOT
98815: IFFALSE 98819
// exit ;
98817: GO 98848
// for i in tmp do
98819: LD_ADDR_VAR 0 1
98823: PUSH
98824: LD_VAR 0 2
98828: PUSH
98829: FOR_IN
98830: IFFALSE 98846
// SetFuel ( i , 0 ) ;
98832: LD_VAR 0 1
98836: PPUSH
98837: LD_INT 0
98839: PPUSH
98840: CALL_OW 240
98844: GO 98829
98846: POP
98847: POP
// end ;
98848: PPOPN 2
98850: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98851: LD_EXP 114
98855: PUSH
98856: LD_EXP 150
98860: AND
98861: IFFALSE 98927
98863: GO 98865
98865: DISABLE
98866: LD_INT 0
98868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98869: LD_ADDR_VAR 0 1
98873: PUSH
98874: LD_INT 22
98876: PUSH
98877: LD_OWVAR 2
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: PUSH
98886: LD_INT 30
98888: PUSH
98889: LD_INT 29
98891: PUSH
98892: EMPTY
98893: LIST
98894: LIST
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PPUSH
98900: CALL_OW 69
98904: ST_TO_ADDR
// if not tmp then
98905: LD_VAR 0 1
98909: NOT
98910: IFFALSE 98914
// exit ;
98912: GO 98927
// DestroyUnit ( tmp [ 1 ] ) ;
98914: LD_VAR 0 1
98918: PUSH
98919: LD_INT 1
98921: ARRAY
98922: PPUSH
98923: CALL_OW 65
// end ;
98927: PPOPN 1
98929: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98930: LD_EXP 114
98934: PUSH
98935: LD_EXP 152
98939: AND
98940: IFFALSE 99069
98942: GO 98944
98944: DISABLE
98945: LD_INT 0
98947: PPUSH
// begin uc_side := 0 ;
98948: LD_ADDR_OWVAR 20
98952: PUSH
98953: LD_INT 0
98955: ST_TO_ADDR
// uc_nation := nation_arabian ;
98956: LD_ADDR_OWVAR 21
98960: PUSH
98961: LD_INT 2
98963: ST_TO_ADDR
// hc_gallery :=  ;
98964: LD_ADDR_OWVAR 33
98968: PUSH
98969: LD_STRING 
98971: ST_TO_ADDR
// hc_name :=  ;
98972: LD_ADDR_OWVAR 26
98976: PUSH
98977: LD_STRING 
98979: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98980: LD_INT 1
98982: PPUSH
98983: LD_INT 11
98985: PPUSH
98986: LD_INT 10
98988: PPUSH
98989: CALL_OW 380
// un := CreateHuman ;
98993: LD_ADDR_VAR 0 1
98997: PUSH
98998: CALL_OW 44
99002: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99003: LD_VAR 0 1
99007: PPUSH
99008: LD_INT 1
99010: PPUSH
99011: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99015: LD_INT 35
99017: PPUSH
99018: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99022: LD_VAR 0 1
99026: PPUSH
99027: LD_INT 22
99029: PUSH
99030: LD_OWVAR 2
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PPUSH
99039: CALL_OW 69
99043: PPUSH
99044: LD_VAR 0 1
99048: PPUSH
99049: CALL_OW 74
99053: PPUSH
99054: CALL_OW 115
// until IsDead ( un ) ;
99058: LD_VAR 0 1
99062: PPUSH
99063: CALL_OW 301
99067: IFFALSE 99015
// end ;
99069: PPOPN 1
99071: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99072: LD_EXP 114
99076: PUSH
99077: LD_EXP 154
99081: AND
99082: IFFALSE 99094
99084: GO 99086
99086: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99087: LD_STRING earthquake(getX(game), 0, 32)
99089: PPUSH
99090: CALL_OW 559
99094: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99095: LD_EXP 114
99099: PUSH
99100: LD_EXP 155
99104: AND
99105: IFFALSE 99196
99107: GO 99109
99109: DISABLE
99110: LD_INT 0
99112: PPUSH
// begin enable ;
99113: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99114: LD_ADDR_VAR 0 1
99118: PUSH
99119: LD_INT 22
99121: PUSH
99122: LD_OWVAR 2
99126: PUSH
99127: EMPTY
99128: LIST
99129: LIST
99130: PUSH
99131: LD_INT 21
99133: PUSH
99134: LD_INT 2
99136: PUSH
99137: EMPTY
99138: LIST
99139: LIST
99140: PUSH
99141: LD_INT 33
99143: PUSH
99144: LD_INT 3
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: LIST
99155: PPUSH
99156: CALL_OW 69
99160: ST_TO_ADDR
// if not tmp then
99161: LD_VAR 0 1
99165: NOT
99166: IFFALSE 99170
// exit ;
99168: GO 99196
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99170: LD_VAR 0 1
99174: PUSH
99175: LD_INT 1
99177: PPUSH
99178: LD_VAR 0 1
99182: PPUSH
99183: CALL_OW 12
99187: ARRAY
99188: PPUSH
99189: LD_INT 1
99191: PPUSH
99192: CALL_OW 234
// end ;
99196: PPOPN 1
99198: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99199: LD_EXP 114
99203: PUSH
99204: LD_EXP 156
99208: AND
99209: IFFALSE 99350
99211: GO 99213
99213: DISABLE
99214: LD_INT 0
99216: PPUSH
99217: PPUSH
99218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99219: LD_ADDR_VAR 0 3
99223: PUSH
99224: LD_INT 22
99226: PUSH
99227: LD_OWVAR 2
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PUSH
99236: LD_INT 25
99238: PUSH
99239: LD_INT 1
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: EMPTY
99247: LIST
99248: LIST
99249: PPUSH
99250: CALL_OW 69
99254: ST_TO_ADDR
// if not tmp then
99255: LD_VAR 0 3
99259: NOT
99260: IFFALSE 99264
// exit ;
99262: GO 99350
// un := tmp [ rand ( 1 , tmp ) ] ;
99264: LD_ADDR_VAR 0 2
99268: PUSH
99269: LD_VAR 0 3
99273: PUSH
99274: LD_INT 1
99276: PPUSH
99277: LD_VAR 0 3
99281: PPUSH
99282: CALL_OW 12
99286: ARRAY
99287: ST_TO_ADDR
// if Crawls ( un ) then
99288: LD_VAR 0 2
99292: PPUSH
99293: CALL_OW 318
99297: IFFALSE 99308
// ComWalk ( un ) ;
99299: LD_VAR 0 2
99303: PPUSH
99304: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99308: LD_VAR 0 2
99312: PPUSH
99313: LD_INT 9
99315: PPUSH
99316: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99320: LD_INT 28
99322: PPUSH
99323: LD_OWVAR 2
99327: PPUSH
99328: LD_INT 2
99330: PPUSH
99331: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99335: LD_INT 29
99337: PPUSH
99338: LD_OWVAR 2
99342: PPUSH
99343: LD_INT 2
99345: PPUSH
99346: CALL_OW 322
// end ;
99350: PPOPN 3
99352: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99353: LD_EXP 114
99357: PUSH
99358: LD_EXP 157
99362: AND
99363: IFFALSE 99474
99365: GO 99367
99367: DISABLE
99368: LD_INT 0
99370: PPUSH
99371: PPUSH
99372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99373: LD_ADDR_VAR 0 3
99377: PUSH
99378: LD_INT 22
99380: PUSH
99381: LD_OWVAR 2
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: PUSH
99390: LD_INT 25
99392: PUSH
99393: LD_INT 1
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: PUSH
99400: EMPTY
99401: LIST
99402: LIST
99403: PPUSH
99404: CALL_OW 69
99408: ST_TO_ADDR
// if not tmp then
99409: LD_VAR 0 3
99413: NOT
99414: IFFALSE 99418
// exit ;
99416: GO 99474
// un := tmp [ rand ( 1 , tmp ) ] ;
99418: LD_ADDR_VAR 0 2
99422: PUSH
99423: LD_VAR 0 3
99427: PUSH
99428: LD_INT 1
99430: PPUSH
99431: LD_VAR 0 3
99435: PPUSH
99436: CALL_OW 12
99440: ARRAY
99441: ST_TO_ADDR
// if Crawls ( un ) then
99442: LD_VAR 0 2
99446: PPUSH
99447: CALL_OW 318
99451: IFFALSE 99462
// ComWalk ( un ) ;
99453: LD_VAR 0 2
99457: PPUSH
99458: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99462: LD_VAR 0 2
99466: PPUSH
99467: LD_INT 8
99469: PPUSH
99470: CALL_OW 336
// end ;
99474: PPOPN 3
99476: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99477: LD_EXP 114
99481: PUSH
99482: LD_EXP 158
99486: AND
99487: IFFALSE 99631
99489: GO 99491
99491: DISABLE
99492: LD_INT 0
99494: PPUSH
99495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99496: LD_ADDR_VAR 0 2
99500: PUSH
99501: LD_INT 22
99503: PUSH
99504: LD_OWVAR 2
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PUSH
99513: LD_INT 21
99515: PUSH
99516: LD_INT 2
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: PUSH
99523: LD_INT 2
99525: PUSH
99526: LD_INT 34
99528: PUSH
99529: LD_INT 12
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: LD_INT 34
99538: PUSH
99539: LD_INT 51
99541: PUSH
99542: EMPTY
99543: LIST
99544: LIST
99545: PUSH
99546: LD_INT 34
99548: PUSH
99549: LD_INT 32
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: PUSH
99562: EMPTY
99563: LIST
99564: LIST
99565: LIST
99566: PPUSH
99567: CALL_OW 69
99571: ST_TO_ADDR
// if not tmp then
99572: LD_VAR 0 2
99576: NOT
99577: IFFALSE 99581
// exit ;
99579: GO 99631
// for i in tmp do
99581: LD_ADDR_VAR 0 1
99585: PUSH
99586: LD_VAR 0 2
99590: PUSH
99591: FOR_IN
99592: IFFALSE 99629
// if GetCargo ( i , mat_artifact ) = 0 then
99594: LD_VAR 0 1
99598: PPUSH
99599: LD_INT 4
99601: PPUSH
99602: CALL_OW 289
99606: PUSH
99607: LD_INT 0
99609: EQUAL
99610: IFFALSE 99627
// SetCargo ( i , mat_siberit , 100 ) ;
99612: LD_VAR 0 1
99616: PPUSH
99617: LD_INT 3
99619: PPUSH
99620: LD_INT 100
99622: PPUSH
99623: CALL_OW 290
99627: GO 99591
99629: POP
99630: POP
// end ;
99631: PPOPN 2
99633: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99634: LD_EXP 114
99638: PUSH
99639: LD_EXP 159
99643: AND
99644: IFFALSE 99827
99646: GO 99648
99648: DISABLE
99649: LD_INT 0
99651: PPUSH
99652: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99653: LD_ADDR_VAR 0 2
99657: PUSH
99658: LD_INT 22
99660: PUSH
99661: LD_OWVAR 2
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PPUSH
99670: CALL_OW 69
99674: ST_TO_ADDR
// if not tmp then
99675: LD_VAR 0 2
99679: NOT
99680: IFFALSE 99684
// exit ;
99682: GO 99827
// for i := 1 to 2 do
99684: LD_ADDR_VAR 0 1
99688: PUSH
99689: DOUBLE
99690: LD_INT 1
99692: DEC
99693: ST_TO_ADDR
99694: LD_INT 2
99696: PUSH
99697: FOR_TO
99698: IFFALSE 99825
// begin uc_side := your_side ;
99700: LD_ADDR_OWVAR 20
99704: PUSH
99705: LD_OWVAR 2
99709: ST_TO_ADDR
// uc_nation := nation_american ;
99710: LD_ADDR_OWVAR 21
99714: PUSH
99715: LD_INT 1
99717: ST_TO_ADDR
// vc_chassis := us_morphling ;
99718: LD_ADDR_OWVAR 37
99722: PUSH
99723: LD_INT 5
99725: ST_TO_ADDR
// vc_engine := engine_siberite ;
99726: LD_ADDR_OWVAR 39
99730: PUSH
99731: LD_INT 3
99733: ST_TO_ADDR
// vc_control := control_computer ;
99734: LD_ADDR_OWVAR 38
99738: PUSH
99739: LD_INT 3
99741: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99742: LD_ADDR_OWVAR 40
99746: PUSH
99747: LD_INT 10
99749: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99750: LD_VAR 0 2
99754: PUSH
99755: LD_INT 1
99757: ARRAY
99758: PPUSH
99759: CALL_OW 310
99763: NOT
99764: IFFALSE 99811
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99766: CALL_OW 45
99770: PPUSH
99771: LD_VAR 0 2
99775: PUSH
99776: LD_INT 1
99778: ARRAY
99779: PPUSH
99780: CALL_OW 250
99784: PPUSH
99785: LD_VAR 0 2
99789: PUSH
99790: LD_INT 1
99792: ARRAY
99793: PPUSH
99794: CALL_OW 251
99798: PPUSH
99799: LD_INT 12
99801: PPUSH
99802: LD_INT 1
99804: PPUSH
99805: CALL_OW 50
99809: GO 99823
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99811: CALL_OW 45
99815: PPUSH
99816: LD_INT 1
99818: PPUSH
99819: CALL_OW 51
// end ;
99823: GO 99697
99825: POP
99826: POP
// end ;
99827: PPOPN 2
99829: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99830: LD_EXP 114
99834: PUSH
99835: LD_EXP 160
99839: AND
99840: IFFALSE 100062
99842: GO 99844
99844: DISABLE
99845: LD_INT 0
99847: PPUSH
99848: PPUSH
99849: PPUSH
99850: PPUSH
99851: PPUSH
99852: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99853: LD_ADDR_VAR 0 6
99857: PUSH
99858: LD_INT 22
99860: PUSH
99861: LD_OWVAR 2
99865: PUSH
99866: EMPTY
99867: LIST
99868: LIST
99869: PUSH
99870: LD_INT 21
99872: PUSH
99873: LD_INT 1
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 3
99882: PUSH
99883: LD_INT 23
99885: PUSH
99886: LD_INT 0
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: LIST
99901: PPUSH
99902: CALL_OW 69
99906: ST_TO_ADDR
// if not tmp then
99907: LD_VAR 0 6
99911: NOT
99912: IFFALSE 99916
// exit ;
99914: GO 100062
// s1 := rand ( 1 , 4 ) ;
99916: LD_ADDR_VAR 0 2
99920: PUSH
99921: LD_INT 1
99923: PPUSH
99924: LD_INT 4
99926: PPUSH
99927: CALL_OW 12
99931: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99932: LD_ADDR_VAR 0 4
99936: PUSH
99937: LD_VAR 0 6
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PPUSH
99946: LD_VAR 0 2
99950: PPUSH
99951: CALL_OW 259
99955: ST_TO_ADDR
// if s1 = 1 then
99956: LD_VAR 0 2
99960: PUSH
99961: LD_INT 1
99963: EQUAL
99964: IFFALSE 99984
// s2 := rand ( 2 , 4 ) else
99966: LD_ADDR_VAR 0 3
99970: PUSH
99971: LD_INT 2
99973: PPUSH
99974: LD_INT 4
99976: PPUSH
99977: CALL_OW 12
99981: ST_TO_ADDR
99982: GO 99992
// s2 := 1 ;
99984: LD_ADDR_VAR 0 3
99988: PUSH
99989: LD_INT 1
99991: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99992: LD_ADDR_VAR 0 5
99996: PUSH
99997: LD_VAR 0 6
100001: PUSH
100002: LD_INT 1
100004: ARRAY
100005: PPUSH
100006: LD_VAR 0 3
100010: PPUSH
100011: CALL_OW 259
100015: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100016: LD_VAR 0 6
100020: PUSH
100021: LD_INT 1
100023: ARRAY
100024: PPUSH
100025: LD_VAR 0 2
100029: PPUSH
100030: LD_VAR 0 5
100034: PPUSH
100035: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100039: LD_VAR 0 6
100043: PUSH
100044: LD_INT 1
100046: ARRAY
100047: PPUSH
100048: LD_VAR 0 3
100052: PPUSH
100053: LD_VAR 0 4
100057: PPUSH
100058: CALL_OW 237
// end ;
100062: PPOPN 6
100064: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100065: LD_EXP 114
100069: PUSH
100070: LD_EXP 161
100074: AND
100075: IFFALSE 100154
100077: GO 100079
100079: DISABLE
100080: LD_INT 0
100082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100083: LD_ADDR_VAR 0 1
100087: PUSH
100088: LD_INT 22
100090: PUSH
100091: LD_OWVAR 2
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: PUSH
100100: LD_INT 30
100102: PUSH
100103: LD_INT 3
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: PUSH
100110: EMPTY
100111: LIST
100112: LIST
100113: PPUSH
100114: CALL_OW 69
100118: ST_TO_ADDR
// if not tmp then
100119: LD_VAR 0 1
100123: NOT
100124: IFFALSE 100128
// exit ;
100126: GO 100154
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100128: LD_VAR 0 1
100132: PUSH
100133: LD_INT 1
100135: PPUSH
100136: LD_VAR 0 1
100140: PPUSH
100141: CALL_OW 12
100145: ARRAY
100146: PPUSH
100147: LD_INT 1
100149: PPUSH
100150: CALL_OW 234
// end ;
100154: PPOPN 1
100156: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100157: LD_EXP 114
100161: PUSH
100162: LD_EXP 162
100166: AND
100167: IFFALSE 100279
100169: GO 100171
100171: DISABLE
100172: LD_INT 0
100174: PPUSH
100175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100176: LD_ADDR_VAR 0 2
100180: PUSH
100181: LD_INT 22
100183: PUSH
100184: LD_OWVAR 2
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 2
100195: PUSH
100196: LD_INT 30
100198: PUSH
100199: LD_INT 27
100201: PUSH
100202: EMPTY
100203: LIST
100204: LIST
100205: PUSH
100206: LD_INT 30
100208: PUSH
100209: LD_INT 26
100211: PUSH
100212: EMPTY
100213: LIST
100214: LIST
100215: PUSH
100216: LD_INT 30
100218: PUSH
100219: LD_INT 28
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: PUSH
100226: EMPTY
100227: LIST
100228: LIST
100229: LIST
100230: LIST
100231: PUSH
100232: EMPTY
100233: LIST
100234: LIST
100235: PPUSH
100236: CALL_OW 69
100240: ST_TO_ADDR
// if not tmp then
100241: LD_VAR 0 2
100245: NOT
100246: IFFALSE 100250
// exit ;
100248: GO 100279
// for i in tmp do
100250: LD_ADDR_VAR 0 1
100254: PUSH
100255: LD_VAR 0 2
100259: PUSH
100260: FOR_IN
100261: IFFALSE 100277
// SetLives ( i , 1 ) ;
100263: LD_VAR 0 1
100267: PPUSH
100268: LD_INT 1
100270: PPUSH
100271: CALL_OW 234
100275: GO 100260
100277: POP
100278: POP
// end ;
100279: PPOPN 2
100281: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100282: LD_EXP 114
100286: PUSH
100287: LD_EXP 163
100291: AND
100292: IFFALSE 100579
100294: GO 100296
100296: DISABLE
100297: LD_INT 0
100299: PPUSH
100300: PPUSH
100301: PPUSH
// begin i := rand ( 1 , 7 ) ;
100302: LD_ADDR_VAR 0 1
100306: PUSH
100307: LD_INT 1
100309: PPUSH
100310: LD_INT 7
100312: PPUSH
100313: CALL_OW 12
100317: ST_TO_ADDR
// case i of 1 :
100318: LD_VAR 0 1
100322: PUSH
100323: LD_INT 1
100325: DOUBLE
100326: EQUAL
100327: IFTRUE 100331
100329: GO 100341
100331: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100332: LD_STRING earthquake(getX(game), 0, 32)
100334: PPUSH
100335: CALL_OW 559
100339: GO 100579
100341: LD_INT 2
100343: DOUBLE
100344: EQUAL
100345: IFTRUE 100349
100347: GO 100363
100349: POP
// begin ToLua ( displayStucuk(); ) ;
100350: LD_STRING displayStucuk();
100352: PPUSH
100353: CALL_OW 559
// ResetFog ;
100357: CALL_OW 335
// end ; 3 :
100361: GO 100579
100363: LD_INT 3
100365: DOUBLE
100366: EQUAL
100367: IFTRUE 100371
100369: GO 100475
100371: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100372: LD_ADDR_VAR 0 2
100376: PUSH
100377: LD_INT 22
100379: PUSH
100380: LD_OWVAR 2
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 25
100391: PUSH
100392: LD_INT 1
100394: PUSH
100395: EMPTY
100396: LIST
100397: LIST
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: PPUSH
100403: CALL_OW 69
100407: ST_TO_ADDR
// if not tmp then
100408: LD_VAR 0 2
100412: NOT
100413: IFFALSE 100417
// exit ;
100415: GO 100579
// un := tmp [ rand ( 1 , tmp ) ] ;
100417: LD_ADDR_VAR 0 3
100421: PUSH
100422: LD_VAR 0 2
100426: PUSH
100427: LD_INT 1
100429: PPUSH
100430: LD_VAR 0 2
100434: PPUSH
100435: CALL_OW 12
100439: ARRAY
100440: ST_TO_ADDR
// if Crawls ( un ) then
100441: LD_VAR 0 3
100445: PPUSH
100446: CALL_OW 318
100450: IFFALSE 100461
// ComWalk ( un ) ;
100452: LD_VAR 0 3
100456: PPUSH
100457: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100461: LD_VAR 0 3
100465: PPUSH
100466: LD_INT 8
100468: PPUSH
100469: CALL_OW 336
// end ; 4 :
100473: GO 100579
100475: LD_INT 4
100477: DOUBLE
100478: EQUAL
100479: IFTRUE 100483
100481: GO 100557
100483: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100484: LD_ADDR_VAR 0 2
100488: PUSH
100489: LD_INT 22
100491: PUSH
100492: LD_OWVAR 2
100496: PUSH
100497: EMPTY
100498: LIST
100499: LIST
100500: PUSH
100501: LD_INT 30
100503: PUSH
100504: LD_INT 29
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PUSH
100511: EMPTY
100512: LIST
100513: LIST
100514: PPUSH
100515: CALL_OW 69
100519: ST_TO_ADDR
// if not tmp then
100520: LD_VAR 0 2
100524: NOT
100525: IFFALSE 100529
// exit ;
100527: GO 100579
// CenterNowOnUnits ( tmp [ 1 ] ) ;
100529: LD_VAR 0 2
100533: PUSH
100534: LD_INT 1
100536: ARRAY
100537: PPUSH
100538: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
100542: LD_VAR 0 2
100546: PUSH
100547: LD_INT 1
100549: ARRAY
100550: PPUSH
100551: CALL_OW 65
// end ; 5 .. 7 :
100555: GO 100579
100557: LD_INT 5
100559: DOUBLE
100560: GREATEREQUAL
100561: IFFALSE 100569
100563: LD_INT 7
100565: DOUBLE
100566: LESSEQUAL
100567: IFTRUE 100571
100569: GO 100578
100571: POP
// StreamSibBomb ; end ;
100572: CALL 96816 0 0
100576: GO 100579
100578: POP
// end ;
100579: PPOPN 3
100581: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100582: LD_EXP 114
100586: PUSH
100587: LD_EXP 164
100591: AND
100592: IFFALSE 100748
100594: GO 100596
100596: DISABLE
100597: LD_INT 0
100599: PPUSH
100600: PPUSH
100601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100602: LD_ADDR_VAR 0 2
100606: PUSH
100607: LD_INT 81
100609: PUSH
100610: LD_OWVAR 2
100614: PUSH
100615: EMPTY
100616: LIST
100617: LIST
100618: PUSH
100619: LD_INT 2
100621: PUSH
100622: LD_INT 21
100624: PUSH
100625: LD_INT 1
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: PUSH
100632: LD_INT 21
100634: PUSH
100635: LD_INT 2
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: LIST
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: PPUSH
100651: CALL_OW 69
100655: ST_TO_ADDR
// if not tmp then
100656: LD_VAR 0 2
100660: NOT
100661: IFFALSE 100665
// exit ;
100663: GO 100748
// p := 0 ;
100665: LD_ADDR_VAR 0 3
100669: PUSH
100670: LD_INT 0
100672: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100673: LD_INT 35
100675: PPUSH
100676: CALL_OW 67
// p := p + 1 ;
100680: LD_ADDR_VAR 0 3
100684: PUSH
100685: LD_VAR 0 3
100689: PUSH
100690: LD_INT 1
100692: PLUS
100693: ST_TO_ADDR
// for i in tmp do
100694: LD_ADDR_VAR 0 1
100698: PUSH
100699: LD_VAR 0 2
100703: PUSH
100704: FOR_IN
100705: IFFALSE 100736
// if GetLives ( i ) < 1000 then
100707: LD_VAR 0 1
100711: PPUSH
100712: CALL_OW 256
100716: PUSH
100717: LD_INT 1000
100719: LESS
100720: IFFALSE 100734
// SetLives ( i , 1000 ) ;
100722: LD_VAR 0 1
100726: PPUSH
100727: LD_INT 1000
100729: PPUSH
100730: CALL_OW 234
100734: GO 100704
100736: POP
100737: POP
// until p > 20 ;
100738: LD_VAR 0 3
100742: PUSH
100743: LD_INT 20
100745: GREATER
100746: IFFALSE 100673
// end ;
100748: PPOPN 3
100750: END
// every 0 0$1 trigger StreamModeActive and sTime do
100751: LD_EXP 114
100755: PUSH
100756: LD_EXP 165
100760: AND
100761: IFFALSE 100796
100763: GO 100765
100765: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100766: LD_INT 28
100768: PPUSH
100769: LD_OWVAR 2
100773: PPUSH
100774: LD_INT 2
100776: PPUSH
100777: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100781: LD_INT 30
100783: PPUSH
100784: LD_OWVAR 2
100788: PPUSH
100789: LD_INT 2
100791: PPUSH
100792: CALL_OW 322
// end ;
100796: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100797: LD_EXP 114
100801: PUSH
100802: LD_EXP 166
100806: AND
100807: IFFALSE 100928
100809: GO 100811
100811: DISABLE
100812: LD_INT 0
100814: PPUSH
100815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100816: LD_ADDR_VAR 0 2
100820: PUSH
100821: LD_INT 22
100823: PUSH
100824: LD_OWVAR 2
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 21
100835: PUSH
100836: LD_INT 1
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: LD_INT 3
100845: PUSH
100846: LD_INT 23
100848: PUSH
100849: LD_INT 0
100851: PUSH
100852: EMPTY
100853: LIST
100854: LIST
100855: PUSH
100856: EMPTY
100857: LIST
100858: LIST
100859: PUSH
100860: EMPTY
100861: LIST
100862: LIST
100863: LIST
100864: PPUSH
100865: CALL_OW 69
100869: ST_TO_ADDR
// if not tmp then
100870: LD_VAR 0 2
100874: NOT
100875: IFFALSE 100879
// exit ;
100877: GO 100928
// for i in tmp do
100879: LD_ADDR_VAR 0 1
100883: PUSH
100884: LD_VAR 0 2
100888: PUSH
100889: FOR_IN
100890: IFFALSE 100926
// begin if Crawls ( i ) then
100892: LD_VAR 0 1
100896: PPUSH
100897: CALL_OW 318
100901: IFFALSE 100912
// ComWalk ( i ) ;
100903: LD_VAR 0 1
100907: PPUSH
100908: CALL_OW 138
// SetClass ( i , 2 ) ;
100912: LD_VAR 0 1
100916: PPUSH
100917: LD_INT 2
100919: PPUSH
100920: CALL_OW 336
// end ;
100924: GO 100889
100926: POP
100927: POP
// end ;
100928: PPOPN 2
100930: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100931: LD_EXP 114
100935: PUSH
100936: LD_EXP 167
100940: AND
100941: IFFALSE 101229
100943: GO 100945
100945: DISABLE
100946: LD_INT 0
100948: PPUSH
100949: PPUSH
100950: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100951: LD_OWVAR 2
100955: PPUSH
100956: LD_INT 9
100958: PPUSH
100959: LD_INT 1
100961: PPUSH
100962: LD_INT 1
100964: PPUSH
100965: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100969: LD_INT 9
100971: PPUSH
100972: LD_OWVAR 2
100976: PPUSH
100977: CALL_OW 343
// uc_side := 9 ;
100981: LD_ADDR_OWVAR 20
100985: PUSH
100986: LD_INT 9
100988: ST_TO_ADDR
// uc_nation := 2 ;
100989: LD_ADDR_OWVAR 21
100993: PUSH
100994: LD_INT 2
100996: ST_TO_ADDR
// hc_name := Dark Warrior ;
100997: LD_ADDR_OWVAR 26
101001: PUSH
101002: LD_STRING Dark Warrior
101004: ST_TO_ADDR
// hc_gallery :=  ;
101005: LD_ADDR_OWVAR 33
101009: PUSH
101010: LD_STRING 
101012: ST_TO_ADDR
// hc_noskilllimit := true ;
101013: LD_ADDR_OWVAR 76
101017: PUSH
101018: LD_INT 1
101020: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101021: LD_ADDR_OWVAR 31
101025: PUSH
101026: LD_INT 30
101028: PUSH
101029: LD_INT 30
101031: PUSH
101032: LD_INT 30
101034: PUSH
101035: LD_INT 30
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: ST_TO_ADDR
// un := CreateHuman ;
101044: LD_ADDR_VAR 0 3
101048: PUSH
101049: CALL_OW 44
101053: ST_TO_ADDR
// hc_noskilllimit := false ;
101054: LD_ADDR_OWVAR 76
101058: PUSH
101059: LD_INT 0
101061: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101062: LD_VAR 0 3
101066: PPUSH
101067: LD_INT 1
101069: PPUSH
101070: CALL_OW 51
// ToLua ( playRanger() ) ;
101074: LD_STRING playRanger()
101076: PPUSH
101077: CALL_OW 559
// p := 0 ;
101081: LD_ADDR_VAR 0 2
101085: PUSH
101086: LD_INT 0
101088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101089: LD_INT 35
101091: PPUSH
101092: CALL_OW 67
// p := p + 1 ;
101096: LD_ADDR_VAR 0 2
101100: PUSH
101101: LD_VAR 0 2
101105: PUSH
101106: LD_INT 1
101108: PLUS
101109: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101110: LD_VAR 0 3
101114: PPUSH
101115: CALL_OW 256
101119: PUSH
101120: LD_INT 1000
101122: LESS
101123: IFFALSE 101137
// SetLives ( un , 1000 ) ;
101125: LD_VAR 0 3
101129: PPUSH
101130: LD_INT 1000
101132: PPUSH
101133: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101137: LD_VAR 0 3
101141: PPUSH
101142: LD_INT 81
101144: PUSH
101145: LD_OWVAR 2
101149: PUSH
101150: EMPTY
101151: LIST
101152: LIST
101153: PUSH
101154: LD_INT 91
101156: PUSH
101157: LD_VAR 0 3
101161: PUSH
101162: LD_INT 30
101164: PUSH
101165: EMPTY
101166: LIST
101167: LIST
101168: LIST
101169: PUSH
101170: EMPTY
101171: LIST
101172: LIST
101173: PPUSH
101174: CALL_OW 69
101178: PPUSH
101179: LD_VAR 0 3
101183: PPUSH
101184: CALL_OW 74
101188: PPUSH
101189: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101193: LD_VAR 0 2
101197: PUSH
101198: LD_INT 80
101200: GREATER
101201: PUSH
101202: LD_VAR 0 3
101206: PPUSH
101207: CALL_OW 301
101211: OR
101212: IFFALSE 101089
// if un then
101214: LD_VAR 0 3
101218: IFFALSE 101229
// RemoveUnit ( un ) ;
101220: LD_VAR 0 3
101224: PPUSH
101225: CALL_OW 64
// end ;
101229: PPOPN 3
101231: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
101232: LD_EXP 168
101236: IFFALSE 101352
101238: GO 101240
101240: DISABLE
101241: LD_INT 0
101243: PPUSH
101244: PPUSH
101245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101246: LD_ADDR_VAR 0 2
101250: PUSH
101251: LD_INT 81
101253: PUSH
101254: LD_OWVAR 2
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 21
101265: PUSH
101266: LD_INT 1
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PPUSH
101277: CALL_OW 69
101281: ST_TO_ADDR
// ToLua ( playComputer() ) ;
101282: LD_STRING playComputer()
101284: PPUSH
101285: CALL_OW 559
// if not tmp then
101289: LD_VAR 0 2
101293: NOT
101294: IFFALSE 101298
// exit ;
101296: GO 101352
// for i in tmp do
101298: LD_ADDR_VAR 0 1
101302: PUSH
101303: LD_VAR 0 2
101307: PUSH
101308: FOR_IN
101309: IFFALSE 101350
// for j := 1 to 4 do
101311: LD_ADDR_VAR 0 3
101315: PUSH
101316: DOUBLE
101317: LD_INT 1
101319: DEC
101320: ST_TO_ADDR
101321: LD_INT 4
101323: PUSH
101324: FOR_TO
101325: IFFALSE 101346
// SetSkill ( i , j , 10 ) ;
101327: LD_VAR 0 1
101331: PPUSH
101332: LD_VAR 0 3
101336: PPUSH
101337: LD_INT 10
101339: PPUSH
101340: CALL_OW 237
101344: GO 101324
101346: POP
101347: POP
101348: GO 101308
101350: POP
101351: POP
// end ;
101352: PPOPN 3
101354: END
// every 0 0$1 trigger s30 do var i , tmp ;
101355: LD_EXP 169
101359: IFFALSE 101428
101361: GO 101363
101363: DISABLE
101364: LD_INT 0
101366: PPUSH
101367: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101368: LD_ADDR_VAR 0 2
101372: PUSH
101373: LD_INT 22
101375: PUSH
101376: LD_OWVAR 2
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: PPUSH
101385: CALL_OW 69
101389: ST_TO_ADDR
// if not tmp then
101390: LD_VAR 0 2
101394: NOT
101395: IFFALSE 101399
// exit ;
101397: GO 101428
// for i in tmp do
101399: LD_ADDR_VAR 0 1
101403: PUSH
101404: LD_VAR 0 2
101408: PUSH
101409: FOR_IN
101410: IFFALSE 101426
// SetLives ( i , 300 ) ;
101412: LD_VAR 0 1
101416: PPUSH
101417: LD_INT 300
101419: PPUSH
101420: CALL_OW 234
101424: GO 101409
101426: POP
101427: POP
// end ;
101428: PPOPN 2
101430: END
// every 0 0$1 trigger s60 do var i , tmp ;
101431: LD_EXP 170
101435: IFFALSE 101504
101437: GO 101439
101439: DISABLE
101440: LD_INT 0
101442: PPUSH
101443: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101444: LD_ADDR_VAR 0 2
101448: PUSH
101449: LD_INT 22
101451: PUSH
101452: LD_OWVAR 2
101456: PUSH
101457: EMPTY
101458: LIST
101459: LIST
101460: PPUSH
101461: CALL_OW 69
101465: ST_TO_ADDR
// if not tmp then
101466: LD_VAR 0 2
101470: NOT
101471: IFFALSE 101475
// exit ;
101473: GO 101504
// for i in tmp do
101475: LD_ADDR_VAR 0 1
101479: PUSH
101480: LD_VAR 0 2
101484: PUSH
101485: FOR_IN
101486: IFFALSE 101502
// SetLives ( i , 600 ) ;
101488: LD_VAR 0 1
101492: PPUSH
101493: LD_INT 600
101495: PPUSH
101496: CALL_OW 234
101500: GO 101485
101502: POP
101503: POP
// end ;
101504: PPOPN 2
101506: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101507: LD_INT 0
101509: PPUSH
// case cmd of 301 :
101510: LD_VAR 0 1
101514: PUSH
101515: LD_INT 301
101517: DOUBLE
101518: EQUAL
101519: IFTRUE 101523
101521: GO 101555
101523: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101524: LD_VAR 0 6
101528: PPUSH
101529: LD_VAR 0 7
101533: PPUSH
101534: LD_VAR 0 8
101538: PPUSH
101539: LD_VAR 0 4
101543: PPUSH
101544: LD_VAR 0 5
101548: PPUSH
101549: CALL 102756 0 5
101553: GO 101676
101555: LD_INT 302
101557: DOUBLE
101558: EQUAL
101559: IFTRUE 101563
101561: GO 101600
101563: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101564: LD_VAR 0 6
101568: PPUSH
101569: LD_VAR 0 7
101573: PPUSH
101574: LD_VAR 0 8
101578: PPUSH
101579: LD_VAR 0 9
101583: PPUSH
101584: LD_VAR 0 4
101588: PPUSH
101589: LD_VAR 0 5
101593: PPUSH
101594: CALL 102847 0 6
101598: GO 101676
101600: LD_INT 303
101602: DOUBLE
101603: EQUAL
101604: IFTRUE 101608
101606: GO 101645
101608: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101609: LD_VAR 0 6
101613: PPUSH
101614: LD_VAR 0 7
101618: PPUSH
101619: LD_VAR 0 8
101623: PPUSH
101624: LD_VAR 0 9
101628: PPUSH
101629: LD_VAR 0 4
101633: PPUSH
101634: LD_VAR 0 5
101638: PPUSH
101639: CALL 101681 0 6
101643: GO 101676
101645: LD_INT 304
101647: DOUBLE
101648: EQUAL
101649: IFTRUE 101653
101651: GO 101675
101653: POP
// hHackTeleport ( unit , x , y ) ; end ;
101654: LD_VAR 0 2
101658: PPUSH
101659: LD_VAR 0 4
101663: PPUSH
101664: LD_VAR 0 5
101668: PPUSH
101669: CALL 103440 0 3
101673: GO 101676
101675: POP
// end ;
101676: LD_VAR 0 12
101680: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101681: LD_INT 0
101683: PPUSH
101684: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101685: LD_VAR 0 1
101689: PUSH
101690: LD_INT 1
101692: LESS
101693: PUSH
101694: LD_VAR 0 1
101698: PUSH
101699: LD_INT 3
101701: GREATER
101702: OR
101703: PUSH
101704: LD_VAR 0 5
101708: PPUSH
101709: LD_VAR 0 6
101713: PPUSH
101714: CALL_OW 428
101718: OR
101719: IFFALSE 101723
// exit ;
101721: GO 102443
// uc_side := your_side ;
101723: LD_ADDR_OWVAR 20
101727: PUSH
101728: LD_OWVAR 2
101732: ST_TO_ADDR
// uc_nation := nation ;
101733: LD_ADDR_OWVAR 21
101737: PUSH
101738: LD_VAR 0 1
101742: ST_TO_ADDR
// bc_level = 1 ;
101743: LD_ADDR_OWVAR 43
101747: PUSH
101748: LD_INT 1
101750: ST_TO_ADDR
// case btype of 1 :
101751: LD_VAR 0 2
101755: PUSH
101756: LD_INT 1
101758: DOUBLE
101759: EQUAL
101760: IFTRUE 101764
101762: GO 101775
101764: POP
// bc_type := b_depot ; 2 :
101765: LD_ADDR_OWVAR 42
101769: PUSH
101770: LD_INT 0
101772: ST_TO_ADDR
101773: GO 102387
101775: LD_INT 2
101777: DOUBLE
101778: EQUAL
101779: IFTRUE 101783
101781: GO 101794
101783: POP
// bc_type := b_warehouse ; 3 :
101784: LD_ADDR_OWVAR 42
101788: PUSH
101789: LD_INT 1
101791: ST_TO_ADDR
101792: GO 102387
101794: LD_INT 3
101796: DOUBLE
101797: EQUAL
101798: IFTRUE 101802
101800: GO 101813
101802: POP
// bc_type := b_lab ; 4 .. 9 :
101803: LD_ADDR_OWVAR 42
101807: PUSH
101808: LD_INT 6
101810: ST_TO_ADDR
101811: GO 102387
101813: LD_INT 4
101815: DOUBLE
101816: GREATEREQUAL
101817: IFFALSE 101825
101819: LD_INT 9
101821: DOUBLE
101822: LESSEQUAL
101823: IFTRUE 101827
101825: GO 101879
101827: POP
// begin bc_type := b_lab_half ;
101828: LD_ADDR_OWVAR 42
101832: PUSH
101833: LD_INT 7
101835: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101836: LD_ADDR_OWVAR 44
101840: PUSH
101841: LD_INT 10
101843: PUSH
101844: LD_INT 11
101846: PUSH
101847: LD_INT 12
101849: PUSH
101850: LD_INT 15
101852: PUSH
101853: LD_INT 14
101855: PUSH
101856: LD_INT 13
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: LIST
101863: LIST
101864: LIST
101865: LIST
101866: PUSH
101867: LD_VAR 0 2
101871: PUSH
101872: LD_INT 3
101874: MINUS
101875: ARRAY
101876: ST_TO_ADDR
// end ; 10 .. 13 :
101877: GO 102387
101879: LD_INT 10
101881: DOUBLE
101882: GREATEREQUAL
101883: IFFALSE 101891
101885: LD_INT 13
101887: DOUBLE
101888: LESSEQUAL
101889: IFTRUE 101893
101891: GO 101970
101893: POP
// begin bc_type := b_lab_full ;
101894: LD_ADDR_OWVAR 42
101898: PUSH
101899: LD_INT 8
101901: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101902: LD_ADDR_OWVAR 44
101906: PUSH
101907: LD_INT 10
101909: PUSH
101910: LD_INT 12
101912: PUSH
101913: LD_INT 14
101915: PUSH
101916: LD_INT 13
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: LIST
101923: LIST
101924: PUSH
101925: LD_VAR 0 2
101929: PUSH
101930: LD_INT 9
101932: MINUS
101933: ARRAY
101934: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101935: LD_ADDR_OWVAR 45
101939: PUSH
101940: LD_INT 11
101942: PUSH
101943: LD_INT 15
101945: PUSH
101946: LD_INT 12
101948: PUSH
101949: LD_INT 15
101951: PUSH
101952: EMPTY
101953: LIST
101954: LIST
101955: LIST
101956: LIST
101957: PUSH
101958: LD_VAR 0 2
101962: PUSH
101963: LD_INT 9
101965: MINUS
101966: ARRAY
101967: ST_TO_ADDR
// end ; 14 :
101968: GO 102387
101970: LD_INT 14
101972: DOUBLE
101973: EQUAL
101974: IFTRUE 101978
101976: GO 101989
101978: POP
// bc_type := b_workshop ; 15 :
101979: LD_ADDR_OWVAR 42
101983: PUSH
101984: LD_INT 2
101986: ST_TO_ADDR
101987: GO 102387
101989: LD_INT 15
101991: DOUBLE
101992: EQUAL
101993: IFTRUE 101997
101995: GO 102008
101997: POP
// bc_type := b_factory ; 16 :
101998: LD_ADDR_OWVAR 42
102002: PUSH
102003: LD_INT 3
102005: ST_TO_ADDR
102006: GO 102387
102008: LD_INT 16
102010: DOUBLE
102011: EQUAL
102012: IFTRUE 102016
102014: GO 102027
102016: POP
// bc_type := b_ext_gun ; 17 :
102017: LD_ADDR_OWVAR 42
102021: PUSH
102022: LD_INT 17
102024: ST_TO_ADDR
102025: GO 102387
102027: LD_INT 17
102029: DOUBLE
102030: EQUAL
102031: IFTRUE 102035
102033: GO 102063
102035: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102036: LD_ADDR_OWVAR 42
102040: PUSH
102041: LD_INT 19
102043: PUSH
102044: LD_INT 23
102046: PUSH
102047: LD_INT 19
102049: PUSH
102050: EMPTY
102051: LIST
102052: LIST
102053: LIST
102054: PUSH
102055: LD_VAR 0 1
102059: ARRAY
102060: ST_TO_ADDR
102061: GO 102387
102063: LD_INT 18
102065: DOUBLE
102066: EQUAL
102067: IFTRUE 102071
102069: GO 102082
102071: POP
// bc_type := b_ext_radar ; 19 :
102072: LD_ADDR_OWVAR 42
102076: PUSH
102077: LD_INT 20
102079: ST_TO_ADDR
102080: GO 102387
102082: LD_INT 19
102084: DOUBLE
102085: EQUAL
102086: IFTRUE 102090
102088: GO 102101
102090: POP
// bc_type := b_ext_radio ; 20 :
102091: LD_ADDR_OWVAR 42
102095: PUSH
102096: LD_INT 22
102098: ST_TO_ADDR
102099: GO 102387
102101: LD_INT 20
102103: DOUBLE
102104: EQUAL
102105: IFTRUE 102109
102107: GO 102120
102109: POP
// bc_type := b_ext_siberium ; 21 :
102110: LD_ADDR_OWVAR 42
102114: PUSH
102115: LD_INT 21
102117: ST_TO_ADDR
102118: GO 102387
102120: LD_INT 21
102122: DOUBLE
102123: EQUAL
102124: IFTRUE 102128
102126: GO 102139
102128: POP
// bc_type := b_ext_computer ; 22 :
102129: LD_ADDR_OWVAR 42
102133: PUSH
102134: LD_INT 24
102136: ST_TO_ADDR
102137: GO 102387
102139: LD_INT 22
102141: DOUBLE
102142: EQUAL
102143: IFTRUE 102147
102145: GO 102158
102147: POP
// bc_type := b_ext_track ; 23 :
102148: LD_ADDR_OWVAR 42
102152: PUSH
102153: LD_INT 16
102155: ST_TO_ADDR
102156: GO 102387
102158: LD_INT 23
102160: DOUBLE
102161: EQUAL
102162: IFTRUE 102166
102164: GO 102177
102166: POP
// bc_type := b_ext_laser ; 24 :
102167: LD_ADDR_OWVAR 42
102171: PUSH
102172: LD_INT 25
102174: ST_TO_ADDR
102175: GO 102387
102177: LD_INT 24
102179: DOUBLE
102180: EQUAL
102181: IFTRUE 102185
102183: GO 102196
102185: POP
// bc_type := b_control_tower ; 25 :
102186: LD_ADDR_OWVAR 42
102190: PUSH
102191: LD_INT 36
102193: ST_TO_ADDR
102194: GO 102387
102196: LD_INT 25
102198: DOUBLE
102199: EQUAL
102200: IFTRUE 102204
102202: GO 102215
102204: POP
// bc_type := b_breastwork ; 26 :
102205: LD_ADDR_OWVAR 42
102209: PUSH
102210: LD_INT 31
102212: ST_TO_ADDR
102213: GO 102387
102215: LD_INT 26
102217: DOUBLE
102218: EQUAL
102219: IFTRUE 102223
102221: GO 102234
102223: POP
// bc_type := b_bunker ; 27 :
102224: LD_ADDR_OWVAR 42
102228: PUSH
102229: LD_INT 32
102231: ST_TO_ADDR
102232: GO 102387
102234: LD_INT 27
102236: DOUBLE
102237: EQUAL
102238: IFTRUE 102242
102240: GO 102253
102242: POP
// bc_type := b_turret ; 28 :
102243: LD_ADDR_OWVAR 42
102247: PUSH
102248: LD_INT 33
102250: ST_TO_ADDR
102251: GO 102387
102253: LD_INT 28
102255: DOUBLE
102256: EQUAL
102257: IFTRUE 102261
102259: GO 102272
102261: POP
// bc_type := b_armoury ; 29 :
102262: LD_ADDR_OWVAR 42
102266: PUSH
102267: LD_INT 4
102269: ST_TO_ADDR
102270: GO 102387
102272: LD_INT 29
102274: DOUBLE
102275: EQUAL
102276: IFTRUE 102280
102278: GO 102291
102280: POP
// bc_type := b_barracks ; 30 :
102281: LD_ADDR_OWVAR 42
102285: PUSH
102286: LD_INT 5
102288: ST_TO_ADDR
102289: GO 102387
102291: LD_INT 30
102293: DOUBLE
102294: EQUAL
102295: IFTRUE 102299
102297: GO 102310
102299: POP
// bc_type := b_solar_power ; 31 :
102300: LD_ADDR_OWVAR 42
102304: PUSH
102305: LD_INT 27
102307: ST_TO_ADDR
102308: GO 102387
102310: LD_INT 31
102312: DOUBLE
102313: EQUAL
102314: IFTRUE 102318
102316: GO 102329
102318: POP
// bc_type := b_oil_power ; 32 :
102319: LD_ADDR_OWVAR 42
102323: PUSH
102324: LD_INT 26
102326: ST_TO_ADDR
102327: GO 102387
102329: LD_INT 32
102331: DOUBLE
102332: EQUAL
102333: IFTRUE 102337
102335: GO 102348
102337: POP
// bc_type := b_siberite_power ; 33 :
102338: LD_ADDR_OWVAR 42
102342: PUSH
102343: LD_INT 28
102345: ST_TO_ADDR
102346: GO 102387
102348: LD_INT 33
102350: DOUBLE
102351: EQUAL
102352: IFTRUE 102356
102354: GO 102367
102356: POP
// bc_type := b_oil_mine ; 34 :
102357: LD_ADDR_OWVAR 42
102361: PUSH
102362: LD_INT 29
102364: ST_TO_ADDR
102365: GO 102387
102367: LD_INT 34
102369: DOUBLE
102370: EQUAL
102371: IFTRUE 102375
102373: GO 102386
102375: POP
// bc_type := b_siberite_mine ; end ;
102376: LD_ADDR_OWVAR 42
102380: PUSH
102381: LD_INT 30
102383: ST_TO_ADDR
102384: GO 102387
102386: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102387: LD_ADDR_VAR 0 8
102391: PUSH
102392: LD_VAR 0 5
102396: PPUSH
102397: LD_VAR 0 6
102401: PPUSH
102402: LD_VAR 0 3
102406: PPUSH
102407: CALL_OW 47
102411: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102412: LD_OWVAR 42
102416: PUSH
102417: LD_INT 32
102419: PUSH
102420: LD_INT 33
102422: PUSH
102423: EMPTY
102424: LIST
102425: LIST
102426: IN
102427: IFFALSE 102443
// PlaceWeaponTurret ( b , weapon ) ;
102429: LD_VAR 0 8
102433: PPUSH
102434: LD_VAR 0 4
102438: PPUSH
102439: CALL_OW 431
// end ;
102443: LD_VAR 0 7
102447: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102448: LD_INT 0
102450: PPUSH
102451: PPUSH
102452: PPUSH
102453: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102454: LD_ADDR_VAR 0 4
102458: PUSH
102459: LD_INT 22
102461: PUSH
102462: LD_OWVAR 2
102466: PUSH
102467: EMPTY
102468: LIST
102469: LIST
102470: PUSH
102471: LD_INT 2
102473: PUSH
102474: LD_INT 30
102476: PUSH
102477: LD_INT 0
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PUSH
102484: LD_INT 30
102486: PUSH
102487: LD_INT 1
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: PUSH
102494: EMPTY
102495: LIST
102496: LIST
102497: LIST
102498: PUSH
102499: EMPTY
102500: LIST
102501: LIST
102502: PPUSH
102503: CALL_OW 69
102507: ST_TO_ADDR
// if not tmp then
102508: LD_VAR 0 4
102512: NOT
102513: IFFALSE 102517
// exit ;
102515: GO 102576
// for i in tmp do
102517: LD_ADDR_VAR 0 2
102521: PUSH
102522: LD_VAR 0 4
102526: PUSH
102527: FOR_IN
102528: IFFALSE 102574
// for j = 1 to 3 do
102530: LD_ADDR_VAR 0 3
102534: PUSH
102535: DOUBLE
102536: LD_INT 1
102538: DEC
102539: ST_TO_ADDR
102540: LD_INT 3
102542: PUSH
102543: FOR_TO
102544: IFFALSE 102570
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102546: LD_VAR 0 2
102550: PPUSH
102551: CALL_OW 274
102555: PPUSH
102556: LD_VAR 0 3
102560: PPUSH
102561: LD_INT 99999
102563: PPUSH
102564: CALL_OW 277
102568: GO 102543
102570: POP
102571: POP
102572: GO 102527
102574: POP
102575: POP
// end ;
102576: LD_VAR 0 1
102580: RET
// export function hHackSetLevel10 ; var i , j ; begin
102581: LD_INT 0
102583: PPUSH
102584: PPUSH
102585: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102586: LD_ADDR_VAR 0 2
102590: PUSH
102591: LD_INT 21
102593: PUSH
102594: LD_INT 1
102596: PUSH
102597: EMPTY
102598: LIST
102599: LIST
102600: PPUSH
102601: CALL_OW 69
102605: PUSH
102606: FOR_IN
102607: IFFALSE 102659
// if IsSelected ( i ) then
102609: LD_VAR 0 2
102613: PPUSH
102614: CALL_OW 306
102618: IFFALSE 102657
// begin for j := 1 to 4 do
102620: LD_ADDR_VAR 0 3
102624: PUSH
102625: DOUBLE
102626: LD_INT 1
102628: DEC
102629: ST_TO_ADDR
102630: LD_INT 4
102632: PUSH
102633: FOR_TO
102634: IFFALSE 102655
// SetSkill ( i , j , 10 ) ;
102636: LD_VAR 0 2
102640: PPUSH
102641: LD_VAR 0 3
102645: PPUSH
102646: LD_INT 10
102648: PPUSH
102649: CALL_OW 237
102653: GO 102633
102655: POP
102656: POP
// end ;
102657: GO 102606
102659: POP
102660: POP
// end ;
102661: LD_VAR 0 1
102665: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102666: LD_INT 0
102668: PPUSH
102669: PPUSH
102670: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102671: LD_ADDR_VAR 0 2
102675: PUSH
102676: LD_INT 22
102678: PUSH
102679: LD_OWVAR 2
102683: PUSH
102684: EMPTY
102685: LIST
102686: LIST
102687: PUSH
102688: LD_INT 21
102690: PUSH
102691: LD_INT 1
102693: PUSH
102694: EMPTY
102695: LIST
102696: LIST
102697: PUSH
102698: EMPTY
102699: LIST
102700: LIST
102701: PPUSH
102702: CALL_OW 69
102706: PUSH
102707: FOR_IN
102708: IFFALSE 102749
// begin for j := 1 to 4 do
102710: LD_ADDR_VAR 0 3
102714: PUSH
102715: DOUBLE
102716: LD_INT 1
102718: DEC
102719: ST_TO_ADDR
102720: LD_INT 4
102722: PUSH
102723: FOR_TO
102724: IFFALSE 102745
// SetSkill ( i , j , 10 ) ;
102726: LD_VAR 0 2
102730: PPUSH
102731: LD_VAR 0 3
102735: PPUSH
102736: LD_INT 10
102738: PPUSH
102739: CALL_OW 237
102743: GO 102723
102745: POP
102746: POP
// end ;
102747: GO 102707
102749: POP
102750: POP
// end ;
102751: LD_VAR 0 1
102755: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102756: LD_INT 0
102758: PPUSH
// uc_side := your_side ;
102759: LD_ADDR_OWVAR 20
102763: PUSH
102764: LD_OWVAR 2
102768: ST_TO_ADDR
// uc_nation := nation ;
102769: LD_ADDR_OWVAR 21
102773: PUSH
102774: LD_VAR 0 1
102778: ST_TO_ADDR
// InitHc ;
102779: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102783: LD_INT 0
102785: PPUSH
102786: LD_VAR 0 2
102790: PPUSH
102791: LD_VAR 0 3
102795: PPUSH
102796: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102800: LD_VAR 0 4
102804: PPUSH
102805: LD_VAR 0 5
102809: PPUSH
102810: CALL_OW 428
102814: PUSH
102815: LD_INT 0
102817: EQUAL
102818: IFFALSE 102842
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102820: CALL_OW 44
102824: PPUSH
102825: LD_VAR 0 4
102829: PPUSH
102830: LD_VAR 0 5
102834: PPUSH
102835: LD_INT 1
102837: PPUSH
102838: CALL_OW 48
// end ;
102842: LD_VAR 0 6
102846: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102847: LD_INT 0
102849: PPUSH
102850: PPUSH
// uc_side := your_side ;
102851: LD_ADDR_OWVAR 20
102855: PUSH
102856: LD_OWVAR 2
102860: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102861: LD_VAR 0 1
102865: PUSH
102866: LD_INT 1
102868: PUSH
102869: LD_INT 2
102871: PUSH
102872: LD_INT 3
102874: PUSH
102875: LD_INT 4
102877: PUSH
102878: LD_INT 5
102880: PUSH
102881: EMPTY
102882: LIST
102883: LIST
102884: LIST
102885: LIST
102886: LIST
102887: IN
102888: IFFALSE 102900
// uc_nation := nation_american else
102890: LD_ADDR_OWVAR 21
102894: PUSH
102895: LD_INT 1
102897: ST_TO_ADDR
102898: GO 102943
// if chassis in [ 11 , 12 , 13 , 14 ] then
102900: LD_VAR 0 1
102904: PUSH
102905: LD_INT 11
102907: PUSH
102908: LD_INT 12
102910: PUSH
102911: LD_INT 13
102913: PUSH
102914: LD_INT 14
102916: PUSH
102917: EMPTY
102918: LIST
102919: LIST
102920: LIST
102921: LIST
102922: IN
102923: IFFALSE 102935
// uc_nation := nation_arabian else
102925: LD_ADDR_OWVAR 21
102929: PUSH
102930: LD_INT 2
102932: ST_TO_ADDR
102933: GO 102943
// uc_nation := nation_russian ;
102935: LD_ADDR_OWVAR 21
102939: PUSH
102940: LD_INT 3
102942: ST_TO_ADDR
// vc_chassis := chassis ;
102943: LD_ADDR_OWVAR 37
102947: PUSH
102948: LD_VAR 0 1
102952: ST_TO_ADDR
// vc_engine := engine ;
102953: LD_ADDR_OWVAR 39
102957: PUSH
102958: LD_VAR 0 2
102962: ST_TO_ADDR
// vc_control := control ;
102963: LD_ADDR_OWVAR 38
102967: PUSH
102968: LD_VAR 0 3
102972: ST_TO_ADDR
// vc_weapon := weapon ;
102973: LD_ADDR_OWVAR 40
102977: PUSH
102978: LD_VAR 0 4
102982: ST_TO_ADDR
// un := CreateVehicle ;
102983: LD_ADDR_VAR 0 8
102987: PUSH
102988: CALL_OW 45
102992: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102993: LD_VAR 0 8
102997: PPUSH
102998: LD_INT 0
103000: PPUSH
103001: LD_INT 5
103003: PPUSH
103004: CALL_OW 12
103008: PPUSH
103009: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103013: LD_VAR 0 8
103017: PPUSH
103018: LD_VAR 0 5
103022: PPUSH
103023: LD_VAR 0 6
103027: PPUSH
103028: LD_INT 1
103030: PPUSH
103031: CALL_OW 48
// end ;
103035: LD_VAR 0 7
103039: RET
// export hInvincible ; every 1 do
103040: GO 103042
103042: DISABLE
// hInvincible := [ ] ;
103043: LD_ADDR_EXP 171
103047: PUSH
103048: EMPTY
103049: ST_TO_ADDR
103050: END
// every 10 do var i ;
103051: GO 103053
103053: DISABLE
103054: LD_INT 0
103056: PPUSH
// begin enable ;
103057: ENABLE
// if not hInvincible then
103058: LD_EXP 171
103062: NOT
103063: IFFALSE 103067
// exit ;
103065: GO 103111
// for i in hInvincible do
103067: LD_ADDR_VAR 0 1
103071: PUSH
103072: LD_EXP 171
103076: PUSH
103077: FOR_IN
103078: IFFALSE 103109
// if GetLives ( i ) < 1000 then
103080: LD_VAR 0 1
103084: PPUSH
103085: CALL_OW 256
103089: PUSH
103090: LD_INT 1000
103092: LESS
103093: IFFALSE 103107
// SetLives ( i , 1000 ) ;
103095: LD_VAR 0 1
103099: PPUSH
103100: LD_INT 1000
103102: PPUSH
103103: CALL_OW 234
103107: GO 103077
103109: POP
103110: POP
// end ;
103111: PPOPN 1
103113: END
// export function hHackInvincible ; var i ; begin
103114: LD_INT 0
103116: PPUSH
103117: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103118: LD_ADDR_VAR 0 2
103122: PUSH
103123: LD_INT 2
103125: PUSH
103126: LD_INT 21
103128: PUSH
103129: LD_INT 1
103131: PUSH
103132: EMPTY
103133: LIST
103134: LIST
103135: PUSH
103136: LD_INT 21
103138: PUSH
103139: LD_INT 2
103141: PUSH
103142: EMPTY
103143: LIST
103144: LIST
103145: PUSH
103146: EMPTY
103147: LIST
103148: LIST
103149: LIST
103150: PPUSH
103151: CALL_OW 69
103155: PUSH
103156: FOR_IN
103157: IFFALSE 103218
// if IsSelected ( i ) then
103159: LD_VAR 0 2
103163: PPUSH
103164: CALL_OW 306
103168: IFFALSE 103216
// begin if i in hInvincible then
103170: LD_VAR 0 2
103174: PUSH
103175: LD_EXP 171
103179: IN
103180: IFFALSE 103200
// hInvincible := hInvincible diff i else
103182: LD_ADDR_EXP 171
103186: PUSH
103187: LD_EXP 171
103191: PUSH
103192: LD_VAR 0 2
103196: DIFF
103197: ST_TO_ADDR
103198: GO 103216
// hInvincible := hInvincible union i ;
103200: LD_ADDR_EXP 171
103204: PUSH
103205: LD_EXP 171
103209: PUSH
103210: LD_VAR 0 2
103214: UNION
103215: ST_TO_ADDR
// end ;
103216: GO 103156
103218: POP
103219: POP
// end ;
103220: LD_VAR 0 1
103224: RET
// export function hHackInvisible ; var i , j ; begin
103225: LD_INT 0
103227: PPUSH
103228: PPUSH
103229: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103230: LD_ADDR_VAR 0 2
103234: PUSH
103235: LD_INT 21
103237: PUSH
103238: LD_INT 1
103240: PUSH
103241: EMPTY
103242: LIST
103243: LIST
103244: PPUSH
103245: CALL_OW 69
103249: PUSH
103250: FOR_IN
103251: IFFALSE 103275
// if IsSelected ( i ) then
103253: LD_VAR 0 2
103257: PPUSH
103258: CALL_OW 306
103262: IFFALSE 103273
// ComForceInvisible ( i ) ;
103264: LD_VAR 0 2
103268: PPUSH
103269: CALL_OW 496
103273: GO 103250
103275: POP
103276: POP
// end ;
103277: LD_VAR 0 1
103281: RET
// export function hHackChangeYourSide ; begin
103282: LD_INT 0
103284: PPUSH
// if your_side = 8 then
103285: LD_OWVAR 2
103289: PUSH
103290: LD_INT 8
103292: EQUAL
103293: IFFALSE 103305
// your_side := 0 else
103295: LD_ADDR_OWVAR 2
103299: PUSH
103300: LD_INT 0
103302: ST_TO_ADDR
103303: GO 103319
// your_side := your_side + 1 ;
103305: LD_ADDR_OWVAR 2
103309: PUSH
103310: LD_OWVAR 2
103314: PUSH
103315: LD_INT 1
103317: PLUS
103318: ST_TO_ADDR
// end ;
103319: LD_VAR 0 1
103323: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103324: LD_INT 0
103326: PPUSH
103327: PPUSH
103328: PPUSH
// for i in all_units do
103329: LD_ADDR_VAR 0 2
103333: PUSH
103334: LD_OWVAR 3
103338: PUSH
103339: FOR_IN
103340: IFFALSE 103418
// if IsSelected ( i ) then
103342: LD_VAR 0 2
103346: PPUSH
103347: CALL_OW 306
103351: IFFALSE 103416
// begin j := GetSide ( i ) ;
103353: LD_ADDR_VAR 0 3
103357: PUSH
103358: LD_VAR 0 2
103362: PPUSH
103363: CALL_OW 255
103367: ST_TO_ADDR
// if j = 8 then
103368: LD_VAR 0 3
103372: PUSH
103373: LD_INT 8
103375: EQUAL
103376: IFFALSE 103388
// j := 0 else
103378: LD_ADDR_VAR 0 3
103382: PUSH
103383: LD_INT 0
103385: ST_TO_ADDR
103386: GO 103402
// j := j + 1 ;
103388: LD_ADDR_VAR 0 3
103392: PUSH
103393: LD_VAR 0 3
103397: PUSH
103398: LD_INT 1
103400: PLUS
103401: ST_TO_ADDR
// SetSide ( i , j ) ;
103402: LD_VAR 0 2
103406: PPUSH
103407: LD_VAR 0 3
103411: PPUSH
103412: CALL_OW 235
// end ;
103416: GO 103339
103418: POP
103419: POP
// end ;
103420: LD_VAR 0 1
103424: RET
// export function hHackFog ; begin
103425: LD_INT 0
103427: PPUSH
// FogOff ( true ) ;
103428: LD_INT 1
103430: PPUSH
103431: CALL_OW 344
// end ;
103435: LD_VAR 0 1
103439: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103440: LD_INT 0
103442: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103443: LD_VAR 0 1
103447: PPUSH
103448: LD_VAR 0 2
103452: PPUSH
103453: LD_VAR 0 3
103457: PPUSH
103458: LD_INT 1
103460: PPUSH
103461: LD_INT 1
103463: PPUSH
103464: CALL_OW 483
// CenterOnXY ( x , y ) ;
103468: LD_VAR 0 2
103472: PPUSH
103473: LD_VAR 0 3
103477: PPUSH
103478: CALL_OW 84
// end ; end_of_file
103482: LD_VAR 0 4
103486: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103487: LD_INT 0
103489: PPUSH
103490: PPUSH
103491: PPUSH
103492: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103493: LD_VAR 0 1
103497: PPUSH
103498: CALL_OW 264
103502: PUSH
103503: LD_EXP 98
103507: EQUAL
103508: IFFALSE 103580
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103510: LD_INT 68
103512: PPUSH
103513: LD_VAR 0 1
103517: PPUSH
103518: CALL_OW 255
103522: PPUSH
103523: CALL_OW 321
103527: PUSH
103528: LD_INT 2
103530: EQUAL
103531: IFFALSE 103543
// eff := 70 else
103533: LD_ADDR_VAR 0 4
103537: PUSH
103538: LD_INT 70
103540: ST_TO_ADDR
103541: GO 103551
// eff := 30 ;
103543: LD_ADDR_VAR 0 4
103547: PUSH
103548: LD_INT 30
103550: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103551: LD_VAR 0 1
103555: PPUSH
103556: CALL_OW 250
103560: PPUSH
103561: LD_VAR 0 1
103565: PPUSH
103566: CALL_OW 251
103570: PPUSH
103571: LD_VAR 0 4
103575: PPUSH
103576: CALL_OW 495
// end ; end ;
103580: LD_VAR 0 2
103584: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103585: LD_INT 0
103587: PPUSH
// end ;
103588: LD_VAR 0 4
103592: RET
// export function SOS_Command ( cmd ) ; begin
103593: LD_INT 0
103595: PPUSH
// end ;
103596: LD_VAR 0 2
103600: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103601: LD_INT 0
103603: PPUSH
// end ;
103604: LD_VAR 0 6
103608: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103609: LD_INT 0
103611: PPUSH
103612: PPUSH
// if not vehicle or not factory then
103613: LD_VAR 0 1
103617: NOT
103618: PUSH
103619: LD_VAR 0 2
103623: NOT
103624: OR
103625: IFFALSE 103629
// exit ;
103627: GO 103860
// if factoryWaypoints >= factory then
103629: LD_EXP 172
103633: PUSH
103634: LD_VAR 0 2
103638: GREATEREQUAL
103639: IFFALSE 103860
// if factoryWaypoints [ factory ] then
103641: LD_EXP 172
103645: PUSH
103646: LD_VAR 0 2
103650: ARRAY
103651: IFFALSE 103860
// begin if GetControl ( vehicle ) = control_manual then
103653: LD_VAR 0 1
103657: PPUSH
103658: CALL_OW 263
103662: PUSH
103663: LD_INT 1
103665: EQUAL
103666: IFFALSE 103747
// begin driver := IsDrivenBy ( vehicle ) ;
103668: LD_ADDR_VAR 0 4
103672: PUSH
103673: LD_VAR 0 1
103677: PPUSH
103678: CALL_OW 311
103682: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103683: LD_VAR 0 4
103687: PPUSH
103688: LD_EXP 172
103692: PUSH
103693: LD_VAR 0 2
103697: ARRAY
103698: PUSH
103699: LD_INT 3
103701: ARRAY
103702: PPUSH
103703: LD_EXP 172
103707: PUSH
103708: LD_VAR 0 2
103712: ARRAY
103713: PUSH
103714: LD_INT 4
103716: ARRAY
103717: PPUSH
103718: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103722: LD_VAR 0 4
103726: PPUSH
103727: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103731: LD_VAR 0 4
103735: PPUSH
103736: LD_VAR 0 2
103740: PPUSH
103741: CALL_OW 180
// end else
103745: GO 103860
// if GetControl ( vehicle ) = control_remote then
103747: LD_VAR 0 1
103751: PPUSH
103752: CALL_OW 263
103756: PUSH
103757: LD_INT 2
103759: EQUAL
103760: IFFALSE 103821
// begin wait ( 0 0$2 ) ;
103762: LD_INT 70
103764: PPUSH
103765: CALL_OW 67
// if Connect ( vehicle ) then
103769: LD_VAR 0 1
103773: PPUSH
103774: CALL 56536 0 1
103778: IFFALSE 103819
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103780: LD_VAR 0 1
103784: PPUSH
103785: LD_EXP 172
103789: PUSH
103790: LD_VAR 0 2
103794: ARRAY
103795: PUSH
103796: LD_INT 3
103798: ARRAY
103799: PPUSH
103800: LD_EXP 172
103804: PUSH
103805: LD_VAR 0 2
103809: ARRAY
103810: PUSH
103811: LD_INT 4
103813: ARRAY
103814: PPUSH
103815: CALL_OW 171
// end else
103819: GO 103860
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103821: LD_VAR 0 1
103825: PPUSH
103826: LD_EXP 172
103830: PUSH
103831: LD_VAR 0 2
103835: ARRAY
103836: PUSH
103837: LD_INT 3
103839: ARRAY
103840: PPUSH
103841: LD_EXP 172
103845: PUSH
103846: LD_VAR 0 2
103850: ARRAY
103851: PUSH
103852: LD_INT 4
103854: ARRAY
103855: PPUSH
103856: CALL_OW 171
// end ; end ;
103860: LD_VAR 0 3
103864: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103865: LD_INT 0
103867: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103868: LD_VAR 0 1
103872: PUSH
103873: LD_INT 250
103875: EQUAL
103876: PUSH
103877: LD_VAR 0 2
103881: PPUSH
103882: CALL_OW 264
103886: PUSH
103887: LD_EXP 101
103891: EQUAL
103892: AND
103893: IFFALSE 103914
// MinerPlaceMine ( unit , x , y ) ;
103895: LD_VAR 0 2
103899: PPUSH
103900: LD_VAR 0 4
103904: PPUSH
103905: LD_VAR 0 5
103909: PPUSH
103910: CALL 106642 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103914: LD_VAR 0 1
103918: PUSH
103919: LD_INT 251
103921: EQUAL
103922: PUSH
103923: LD_VAR 0 2
103927: PPUSH
103928: CALL_OW 264
103932: PUSH
103933: LD_EXP 101
103937: EQUAL
103938: AND
103939: IFFALSE 103960
// MinerDetonateMine ( unit , x , y ) ;
103941: LD_VAR 0 2
103945: PPUSH
103946: LD_VAR 0 4
103950: PPUSH
103951: LD_VAR 0 5
103955: PPUSH
103956: CALL 106919 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103960: LD_VAR 0 1
103964: PUSH
103965: LD_INT 252
103967: EQUAL
103968: PUSH
103969: LD_VAR 0 2
103973: PPUSH
103974: CALL_OW 264
103978: PUSH
103979: LD_EXP 101
103983: EQUAL
103984: AND
103985: IFFALSE 104006
// MinerCreateMinefield ( unit , x , y ) ;
103987: LD_VAR 0 2
103991: PPUSH
103992: LD_VAR 0 4
103996: PPUSH
103997: LD_VAR 0 5
104001: PPUSH
104002: CALL 107336 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104006: LD_VAR 0 1
104010: PUSH
104011: LD_INT 253
104013: EQUAL
104014: PUSH
104015: LD_VAR 0 2
104019: PPUSH
104020: CALL_OW 257
104024: PUSH
104025: LD_INT 5
104027: EQUAL
104028: AND
104029: IFFALSE 104050
// ComBinocular ( unit , x , y ) ;
104031: LD_VAR 0 2
104035: PPUSH
104036: LD_VAR 0 4
104040: PPUSH
104041: LD_VAR 0 5
104045: PPUSH
104046: CALL 107707 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104050: LD_VAR 0 1
104054: PUSH
104055: LD_INT 254
104057: EQUAL
104058: PUSH
104059: LD_VAR 0 2
104063: PPUSH
104064: CALL_OW 264
104068: PUSH
104069: LD_EXP 96
104073: EQUAL
104074: AND
104075: PUSH
104076: LD_VAR 0 3
104080: PPUSH
104081: CALL_OW 263
104085: PUSH
104086: LD_INT 3
104088: EQUAL
104089: AND
104090: IFFALSE 104106
// HackDestroyVehicle ( unit , selectedUnit ) ;
104092: LD_VAR 0 2
104096: PPUSH
104097: LD_VAR 0 3
104101: PPUSH
104102: CALL 106002 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104106: LD_VAR 0 1
104110: PUSH
104111: LD_INT 255
104113: EQUAL
104114: PUSH
104115: LD_VAR 0 2
104119: PPUSH
104120: CALL_OW 264
104124: PUSH
104125: LD_INT 14
104127: PUSH
104128: LD_INT 53
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: IN
104135: AND
104136: PUSH
104137: LD_VAR 0 4
104141: PPUSH
104142: LD_VAR 0 5
104146: PPUSH
104147: CALL_OW 488
104151: AND
104152: IFFALSE 104176
// CutTreeXYR ( unit , x , y , 12 ) ;
104154: LD_VAR 0 2
104158: PPUSH
104159: LD_VAR 0 4
104163: PPUSH
104164: LD_VAR 0 5
104168: PPUSH
104169: LD_INT 12
104171: PPUSH
104172: CALL 104568 0 4
// if cmd = 256 then
104176: LD_VAR 0 1
104180: PUSH
104181: LD_INT 256
104183: EQUAL
104184: IFFALSE 104205
// SetFactoryWaypoint ( unit , x , y ) ;
104186: LD_VAR 0 2
104190: PPUSH
104191: LD_VAR 0 4
104195: PPUSH
104196: LD_VAR 0 5
104200: PPUSH
104201: CALL 104210 0 3
// end ;
104205: LD_VAR 0 6
104209: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104210: LD_INT 0
104212: PPUSH
104213: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104214: LD_VAR 0 1
104218: NOT
104219: PUSH
104220: LD_VAR 0 2
104224: PPUSH
104225: LD_VAR 0 3
104229: PPUSH
104230: CALL_OW 488
104234: NOT
104235: OR
104236: PUSH
104237: LD_VAR 0 1
104241: PPUSH
104242: CALL_OW 266
104246: PUSH
104247: LD_INT 3
104249: NONEQUAL
104250: PUSH
104251: LD_VAR 0 1
104255: PPUSH
104256: CALL_OW 247
104260: PUSH
104261: LD_INT 1
104263: EQUAL
104264: NOT
104265: AND
104266: OR
104267: IFFALSE 104271
// exit ;
104269: GO 104420
// if GetType ( factory ) = unit_human then
104271: LD_VAR 0 1
104275: PPUSH
104276: CALL_OW 247
104280: PUSH
104281: LD_INT 1
104283: EQUAL
104284: IFFALSE 104301
// factory := IsInUnit ( factory ) ;
104286: LD_ADDR_VAR 0 1
104290: PUSH
104291: LD_VAR 0 1
104295: PPUSH
104296: CALL_OW 310
104300: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104301: LD_VAR 0 1
104305: PPUSH
104306: CALL_OW 266
104310: PUSH
104311: LD_INT 3
104313: NONEQUAL
104314: IFFALSE 104318
// exit ;
104316: GO 104420
// if HexInfo ( x , y ) = factory then
104318: LD_VAR 0 2
104322: PPUSH
104323: LD_VAR 0 3
104327: PPUSH
104328: CALL_OW 428
104332: PUSH
104333: LD_VAR 0 1
104337: EQUAL
104338: IFFALSE 104365
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104340: LD_ADDR_EXP 172
104344: PUSH
104345: LD_EXP 172
104349: PPUSH
104350: LD_VAR 0 1
104354: PPUSH
104355: LD_INT 0
104357: PPUSH
104358: CALL_OW 1
104362: ST_TO_ADDR
104363: GO 104416
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104365: LD_ADDR_EXP 172
104369: PUSH
104370: LD_EXP 172
104374: PPUSH
104375: LD_VAR 0 1
104379: PPUSH
104380: LD_VAR 0 1
104384: PPUSH
104385: CALL_OW 255
104389: PUSH
104390: LD_VAR 0 1
104394: PUSH
104395: LD_VAR 0 2
104399: PUSH
104400: LD_VAR 0 3
104404: PUSH
104405: EMPTY
104406: LIST
104407: LIST
104408: LIST
104409: LIST
104410: PPUSH
104411: CALL_OW 1
104415: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104416: CALL 104425 0 0
// end ;
104420: LD_VAR 0 4
104424: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
104425: LD_INT 0
104427: PPUSH
104428: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104429: LD_STRING resetFactoryWaypoint();
104431: PPUSH
104432: CALL_OW 559
// if factoryWaypoints then
104436: LD_EXP 172
104440: IFFALSE 104563
// begin for i := 1 to factoryWaypoints do
104442: LD_ADDR_VAR 0 2
104446: PUSH
104447: DOUBLE
104448: LD_INT 1
104450: DEC
104451: ST_TO_ADDR
104452: LD_EXP 172
104456: PUSH
104457: FOR_TO
104458: IFFALSE 104561
// if factoryWaypoints [ i ] then
104460: LD_EXP 172
104464: PUSH
104465: LD_VAR 0 2
104469: ARRAY
104470: IFFALSE 104559
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
104472: LD_STRING setFactoryWaypointXY(
104474: PUSH
104475: LD_EXP 172
104479: PUSH
104480: LD_VAR 0 2
104484: ARRAY
104485: PUSH
104486: LD_INT 1
104488: ARRAY
104489: STR
104490: PUSH
104491: LD_STRING ,
104493: STR
104494: PUSH
104495: LD_EXP 172
104499: PUSH
104500: LD_VAR 0 2
104504: ARRAY
104505: PUSH
104506: LD_INT 2
104508: ARRAY
104509: STR
104510: PUSH
104511: LD_STRING ,
104513: STR
104514: PUSH
104515: LD_EXP 172
104519: PUSH
104520: LD_VAR 0 2
104524: ARRAY
104525: PUSH
104526: LD_INT 3
104528: ARRAY
104529: STR
104530: PUSH
104531: LD_STRING ,
104533: STR
104534: PUSH
104535: LD_EXP 172
104539: PUSH
104540: LD_VAR 0 2
104544: ARRAY
104545: PUSH
104546: LD_INT 4
104548: ARRAY
104549: STR
104550: PUSH
104551: LD_STRING )
104553: STR
104554: PPUSH
104555: CALL_OW 559
104559: GO 104457
104561: POP
104562: POP
// end ; end ;
104563: LD_VAR 0 1
104567: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104568: LD_INT 0
104570: PPUSH
104571: PPUSH
104572: PPUSH
104573: PPUSH
104574: PPUSH
104575: PPUSH
104576: PPUSH
104577: PPUSH
104578: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104579: LD_VAR 0 1
104583: NOT
104584: PUSH
104585: LD_VAR 0 2
104589: PPUSH
104590: LD_VAR 0 3
104594: PPUSH
104595: CALL_OW 488
104599: NOT
104600: OR
104601: PUSH
104602: LD_VAR 0 4
104606: NOT
104607: OR
104608: IFFALSE 104612
// exit ;
104610: GO 104952
// list := [ ] ;
104612: LD_ADDR_VAR 0 13
104616: PUSH
104617: EMPTY
104618: ST_TO_ADDR
// if x - r < 0 then
104619: LD_VAR 0 2
104623: PUSH
104624: LD_VAR 0 4
104628: MINUS
104629: PUSH
104630: LD_INT 0
104632: LESS
104633: IFFALSE 104645
// min_x := 0 else
104635: LD_ADDR_VAR 0 7
104639: PUSH
104640: LD_INT 0
104642: ST_TO_ADDR
104643: GO 104661
// min_x := x - r ;
104645: LD_ADDR_VAR 0 7
104649: PUSH
104650: LD_VAR 0 2
104654: PUSH
104655: LD_VAR 0 4
104659: MINUS
104660: ST_TO_ADDR
// if y - r < 0 then
104661: LD_VAR 0 3
104665: PUSH
104666: LD_VAR 0 4
104670: MINUS
104671: PUSH
104672: LD_INT 0
104674: LESS
104675: IFFALSE 104687
// min_y := 0 else
104677: LD_ADDR_VAR 0 8
104681: PUSH
104682: LD_INT 0
104684: ST_TO_ADDR
104685: GO 104703
// min_y := y - r ;
104687: LD_ADDR_VAR 0 8
104691: PUSH
104692: LD_VAR 0 3
104696: PUSH
104697: LD_VAR 0 4
104701: MINUS
104702: ST_TO_ADDR
// max_x := x + r ;
104703: LD_ADDR_VAR 0 9
104707: PUSH
104708: LD_VAR 0 2
104712: PUSH
104713: LD_VAR 0 4
104717: PLUS
104718: ST_TO_ADDR
// max_y := y + r ;
104719: LD_ADDR_VAR 0 10
104723: PUSH
104724: LD_VAR 0 3
104728: PUSH
104729: LD_VAR 0 4
104733: PLUS
104734: ST_TO_ADDR
// for _x = min_x to max_x do
104735: LD_ADDR_VAR 0 11
104739: PUSH
104740: DOUBLE
104741: LD_VAR 0 7
104745: DEC
104746: ST_TO_ADDR
104747: LD_VAR 0 9
104751: PUSH
104752: FOR_TO
104753: IFFALSE 104870
// for _y = min_y to max_y do
104755: LD_ADDR_VAR 0 12
104759: PUSH
104760: DOUBLE
104761: LD_VAR 0 8
104765: DEC
104766: ST_TO_ADDR
104767: LD_VAR 0 10
104771: PUSH
104772: FOR_TO
104773: IFFALSE 104866
// begin if not ValidHex ( _x , _y ) then
104775: LD_VAR 0 11
104779: PPUSH
104780: LD_VAR 0 12
104784: PPUSH
104785: CALL_OW 488
104789: NOT
104790: IFFALSE 104794
// continue ;
104792: GO 104772
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104794: LD_VAR 0 11
104798: PPUSH
104799: LD_VAR 0 12
104803: PPUSH
104804: CALL_OW 351
104808: PUSH
104809: LD_VAR 0 11
104813: PPUSH
104814: LD_VAR 0 12
104818: PPUSH
104819: CALL_OW 554
104823: AND
104824: IFFALSE 104864
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104826: LD_ADDR_VAR 0 13
104830: PUSH
104831: LD_VAR 0 13
104835: PPUSH
104836: LD_VAR 0 13
104840: PUSH
104841: LD_INT 1
104843: PLUS
104844: PPUSH
104845: LD_VAR 0 11
104849: PUSH
104850: LD_VAR 0 12
104854: PUSH
104855: EMPTY
104856: LIST
104857: LIST
104858: PPUSH
104859: CALL_OW 2
104863: ST_TO_ADDR
// end ;
104864: GO 104772
104866: POP
104867: POP
104868: GO 104752
104870: POP
104871: POP
// if not list then
104872: LD_VAR 0 13
104876: NOT
104877: IFFALSE 104881
// exit ;
104879: GO 104952
// for i in list do
104881: LD_ADDR_VAR 0 6
104885: PUSH
104886: LD_VAR 0 13
104890: PUSH
104891: FOR_IN
104892: IFFALSE 104950
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104894: LD_VAR 0 1
104898: PPUSH
104899: LD_STRING M
104901: PUSH
104902: LD_VAR 0 6
104906: PUSH
104907: LD_INT 1
104909: ARRAY
104910: PUSH
104911: LD_VAR 0 6
104915: PUSH
104916: LD_INT 2
104918: ARRAY
104919: PUSH
104920: LD_INT 0
104922: PUSH
104923: LD_INT 0
104925: PUSH
104926: LD_INT 0
104928: PUSH
104929: LD_INT 0
104931: PUSH
104932: EMPTY
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: PUSH
104941: EMPTY
104942: LIST
104943: PPUSH
104944: CALL_OW 447
104948: GO 104891
104950: POP
104951: POP
// end ;
104952: LD_VAR 0 5
104956: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104957: LD_EXP 173
104961: NOT
104962: IFFALSE 105012
104964: GO 104966
104966: DISABLE
// begin initHack := true ;
104967: LD_ADDR_EXP 173
104971: PUSH
104972: LD_INT 1
104974: ST_TO_ADDR
// hackTanks := [ ] ;
104975: LD_ADDR_EXP 174
104979: PUSH
104980: EMPTY
104981: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104982: LD_ADDR_EXP 175
104986: PUSH
104987: EMPTY
104988: ST_TO_ADDR
// hackLimit := 3 ;
104989: LD_ADDR_EXP 176
104993: PUSH
104994: LD_INT 3
104996: ST_TO_ADDR
// hackDist := 12 ;
104997: LD_ADDR_EXP 177
105001: PUSH
105002: LD_INT 12
105004: ST_TO_ADDR
// hackCounter := [ ] ;
105005: LD_ADDR_EXP 178
105009: PUSH
105010: EMPTY
105011: ST_TO_ADDR
// end ;
105012: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
105013: LD_EXP 173
105017: PUSH
105018: LD_INT 34
105020: PUSH
105021: LD_EXP 96
105025: PUSH
105026: EMPTY
105027: LIST
105028: LIST
105029: PPUSH
105030: CALL_OW 69
105034: AND
105035: IFFALSE 105290
105037: GO 105039
105039: DISABLE
105040: LD_INT 0
105042: PPUSH
105043: PPUSH
// begin enable ;
105044: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
105045: LD_ADDR_VAR 0 1
105049: PUSH
105050: LD_INT 34
105052: PUSH
105053: LD_EXP 96
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: PPUSH
105062: CALL_OW 69
105066: PUSH
105067: FOR_IN
105068: IFFALSE 105288
// begin if not i in hackTanks then
105070: LD_VAR 0 1
105074: PUSH
105075: LD_EXP 174
105079: IN
105080: NOT
105081: IFFALSE 105164
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
105083: LD_ADDR_EXP 174
105087: PUSH
105088: LD_EXP 174
105092: PPUSH
105093: LD_EXP 174
105097: PUSH
105098: LD_INT 1
105100: PLUS
105101: PPUSH
105102: LD_VAR 0 1
105106: PPUSH
105107: CALL_OW 1
105111: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
105112: LD_ADDR_EXP 175
105116: PUSH
105117: LD_EXP 175
105121: PPUSH
105122: LD_EXP 175
105126: PUSH
105127: LD_INT 1
105129: PLUS
105130: PPUSH
105131: EMPTY
105132: PPUSH
105133: CALL_OW 1
105137: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
105138: LD_ADDR_EXP 178
105142: PUSH
105143: LD_EXP 178
105147: PPUSH
105148: LD_EXP 178
105152: PUSH
105153: LD_INT 1
105155: PLUS
105156: PPUSH
105157: EMPTY
105158: PPUSH
105159: CALL_OW 1
105163: ST_TO_ADDR
// end ; if not IsOk ( i ) then
105164: LD_VAR 0 1
105168: PPUSH
105169: CALL_OW 302
105173: NOT
105174: IFFALSE 105187
// begin HackUnlinkAll ( i ) ;
105176: LD_VAR 0 1
105180: PPUSH
105181: CALL 105293 0 1
// continue ;
105185: GO 105067
// end ; HackCheckCapturedStatus ( i ) ;
105187: LD_VAR 0 1
105191: PPUSH
105192: CALL 105736 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
105196: LD_ADDR_VAR 0 2
105200: PUSH
105201: LD_INT 81
105203: PUSH
105204: LD_VAR 0 1
105208: PPUSH
105209: CALL_OW 255
105213: PUSH
105214: EMPTY
105215: LIST
105216: LIST
105217: PUSH
105218: LD_INT 33
105220: PUSH
105221: LD_INT 3
105223: PUSH
105224: EMPTY
105225: LIST
105226: LIST
105227: PUSH
105228: LD_INT 91
105230: PUSH
105231: LD_VAR 0 1
105235: PUSH
105236: LD_EXP 177
105240: PUSH
105241: EMPTY
105242: LIST
105243: LIST
105244: LIST
105245: PUSH
105246: LD_INT 50
105248: PUSH
105249: EMPTY
105250: LIST
105251: PUSH
105252: EMPTY
105253: LIST
105254: LIST
105255: LIST
105256: LIST
105257: PPUSH
105258: CALL_OW 69
105262: ST_TO_ADDR
// if not tmp then
105263: LD_VAR 0 2
105267: NOT
105268: IFFALSE 105272
// continue ;
105270: GO 105067
// HackLink ( i , tmp ) ;
105272: LD_VAR 0 1
105276: PPUSH
105277: LD_VAR 0 2
105281: PPUSH
105282: CALL 105429 0 2
// end ;
105286: GO 105067
105288: POP
105289: POP
// end ;
105290: PPOPN 2
105292: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105293: LD_INT 0
105295: PPUSH
105296: PPUSH
105297: PPUSH
// if not hack in hackTanks then
105298: LD_VAR 0 1
105302: PUSH
105303: LD_EXP 174
105307: IN
105308: NOT
105309: IFFALSE 105313
// exit ;
105311: GO 105424
// index := GetElementIndex ( hackTanks , hack ) ;
105313: LD_ADDR_VAR 0 4
105317: PUSH
105318: LD_EXP 174
105322: PPUSH
105323: LD_VAR 0 1
105327: PPUSH
105328: CALL 53350 0 2
105332: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105333: LD_EXP 175
105337: PUSH
105338: LD_VAR 0 4
105342: ARRAY
105343: IFFALSE 105424
// begin for i in hackTanksCaptured [ index ] do
105345: LD_ADDR_VAR 0 3
105349: PUSH
105350: LD_EXP 175
105354: PUSH
105355: LD_VAR 0 4
105359: ARRAY
105360: PUSH
105361: FOR_IN
105362: IFFALSE 105388
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105364: LD_VAR 0 3
105368: PUSH
105369: LD_INT 1
105371: ARRAY
105372: PPUSH
105373: LD_VAR 0 3
105377: PUSH
105378: LD_INT 2
105380: ARRAY
105381: PPUSH
105382: CALL_OW 235
105386: GO 105361
105388: POP
105389: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105390: LD_ADDR_EXP 175
105394: PUSH
105395: LD_EXP 175
105399: PPUSH
105400: LD_VAR 0 4
105404: PPUSH
105405: EMPTY
105406: PPUSH
105407: CALL_OW 1
105411: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105412: LD_VAR 0 1
105416: PPUSH
105417: LD_INT 0
105419: PPUSH
105420: CALL_OW 505
// end ; end ;
105424: LD_VAR 0 2
105428: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105429: LD_INT 0
105431: PPUSH
105432: PPUSH
105433: PPUSH
// if not hack in hackTanks or not vehicles then
105434: LD_VAR 0 1
105438: PUSH
105439: LD_EXP 174
105443: IN
105444: NOT
105445: PUSH
105446: LD_VAR 0 2
105450: NOT
105451: OR
105452: IFFALSE 105456
// exit ;
105454: GO 105731
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105456: LD_ADDR_VAR 0 2
105460: PUSH
105461: LD_VAR 0 1
105465: PPUSH
105466: LD_VAR 0 2
105470: PPUSH
105471: LD_INT 1
105473: PPUSH
105474: LD_INT 1
105476: PPUSH
105477: CALL 54000 0 4
105481: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105482: LD_ADDR_VAR 0 5
105486: PUSH
105487: LD_EXP 174
105491: PPUSH
105492: LD_VAR 0 1
105496: PPUSH
105497: CALL 53350 0 2
105501: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105502: LD_EXP 175
105506: PUSH
105507: LD_VAR 0 5
105511: ARRAY
105512: PUSH
105513: LD_EXP 176
105517: LESS
105518: IFFALSE 105707
// begin for i := 1 to vehicles do
105520: LD_ADDR_VAR 0 4
105524: PUSH
105525: DOUBLE
105526: LD_INT 1
105528: DEC
105529: ST_TO_ADDR
105530: LD_VAR 0 2
105534: PUSH
105535: FOR_TO
105536: IFFALSE 105705
// begin if hackTanksCaptured [ index ] = hackLimit then
105538: LD_EXP 175
105542: PUSH
105543: LD_VAR 0 5
105547: ARRAY
105548: PUSH
105549: LD_EXP 176
105553: EQUAL
105554: IFFALSE 105558
// break ;
105556: GO 105705
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105558: LD_ADDR_EXP 178
105562: PUSH
105563: LD_EXP 178
105567: PPUSH
105568: LD_VAR 0 5
105572: PPUSH
105573: LD_EXP 178
105577: PUSH
105578: LD_VAR 0 5
105582: ARRAY
105583: PUSH
105584: LD_INT 1
105586: PLUS
105587: PPUSH
105588: CALL_OW 1
105592: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105593: LD_ADDR_EXP 175
105597: PUSH
105598: LD_EXP 175
105602: PPUSH
105603: LD_VAR 0 5
105607: PUSH
105608: LD_EXP 175
105612: PUSH
105613: LD_VAR 0 5
105617: ARRAY
105618: PUSH
105619: LD_INT 1
105621: PLUS
105622: PUSH
105623: EMPTY
105624: LIST
105625: LIST
105626: PPUSH
105627: LD_VAR 0 2
105631: PUSH
105632: LD_VAR 0 4
105636: ARRAY
105637: PUSH
105638: LD_VAR 0 2
105642: PUSH
105643: LD_VAR 0 4
105647: ARRAY
105648: PPUSH
105649: CALL_OW 255
105653: PUSH
105654: EMPTY
105655: LIST
105656: LIST
105657: PPUSH
105658: CALL 53565 0 3
105662: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105663: LD_VAR 0 2
105667: PUSH
105668: LD_VAR 0 4
105672: ARRAY
105673: PPUSH
105674: LD_VAR 0 1
105678: PPUSH
105679: CALL_OW 255
105683: PPUSH
105684: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105688: LD_VAR 0 2
105692: PUSH
105693: LD_VAR 0 4
105697: ARRAY
105698: PPUSH
105699: CALL_OW 141
// end ;
105703: GO 105535
105705: POP
105706: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105707: LD_VAR 0 1
105711: PPUSH
105712: LD_EXP 175
105716: PUSH
105717: LD_VAR 0 5
105721: ARRAY
105722: PUSH
105723: LD_INT 0
105725: PLUS
105726: PPUSH
105727: CALL_OW 505
// end ;
105731: LD_VAR 0 3
105735: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105736: LD_INT 0
105738: PPUSH
105739: PPUSH
105740: PPUSH
105741: PPUSH
// if not hack in hackTanks then
105742: LD_VAR 0 1
105746: PUSH
105747: LD_EXP 174
105751: IN
105752: NOT
105753: IFFALSE 105757
// exit ;
105755: GO 105997
// index := GetElementIndex ( hackTanks , hack ) ;
105757: LD_ADDR_VAR 0 4
105761: PUSH
105762: LD_EXP 174
105766: PPUSH
105767: LD_VAR 0 1
105771: PPUSH
105772: CALL 53350 0 2
105776: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105777: LD_ADDR_VAR 0 3
105781: PUSH
105782: DOUBLE
105783: LD_EXP 175
105787: PUSH
105788: LD_VAR 0 4
105792: ARRAY
105793: INC
105794: ST_TO_ADDR
105795: LD_INT 1
105797: PUSH
105798: FOR_DOWNTO
105799: IFFALSE 105971
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105801: LD_ADDR_VAR 0 5
105805: PUSH
105806: LD_EXP 175
105810: PUSH
105811: LD_VAR 0 4
105815: ARRAY
105816: PUSH
105817: LD_VAR 0 3
105821: ARRAY
105822: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105823: LD_VAR 0 5
105827: PUSH
105828: LD_INT 1
105830: ARRAY
105831: PPUSH
105832: CALL_OW 302
105836: NOT
105837: PUSH
105838: LD_VAR 0 5
105842: PUSH
105843: LD_INT 1
105845: ARRAY
105846: PPUSH
105847: CALL_OW 255
105851: PUSH
105852: LD_VAR 0 1
105856: PPUSH
105857: CALL_OW 255
105861: NONEQUAL
105862: OR
105863: IFFALSE 105969
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105865: LD_VAR 0 5
105869: PUSH
105870: LD_INT 1
105872: ARRAY
105873: PPUSH
105874: CALL_OW 305
105878: PUSH
105879: LD_VAR 0 5
105883: PUSH
105884: LD_INT 1
105886: ARRAY
105887: PPUSH
105888: CALL_OW 255
105892: PUSH
105893: LD_VAR 0 1
105897: PPUSH
105898: CALL_OW 255
105902: EQUAL
105903: AND
105904: IFFALSE 105928
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105906: LD_VAR 0 5
105910: PUSH
105911: LD_INT 1
105913: ARRAY
105914: PPUSH
105915: LD_VAR 0 5
105919: PUSH
105920: LD_INT 2
105922: ARRAY
105923: PPUSH
105924: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105928: LD_ADDR_EXP 175
105932: PUSH
105933: LD_EXP 175
105937: PPUSH
105938: LD_VAR 0 4
105942: PPUSH
105943: LD_EXP 175
105947: PUSH
105948: LD_VAR 0 4
105952: ARRAY
105953: PPUSH
105954: LD_VAR 0 3
105958: PPUSH
105959: CALL_OW 3
105963: PPUSH
105964: CALL_OW 1
105968: ST_TO_ADDR
// end ; end ;
105969: GO 105798
105971: POP
105972: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105973: LD_VAR 0 1
105977: PPUSH
105978: LD_EXP 175
105982: PUSH
105983: LD_VAR 0 4
105987: ARRAY
105988: PUSH
105989: LD_INT 0
105991: PLUS
105992: PPUSH
105993: CALL_OW 505
// end ;
105997: LD_VAR 0 2
106001: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
106002: LD_INT 0
106004: PPUSH
106005: PPUSH
106006: PPUSH
106007: PPUSH
// if not hack in hackTanks then
106008: LD_VAR 0 1
106012: PUSH
106013: LD_EXP 174
106017: IN
106018: NOT
106019: IFFALSE 106023
// exit ;
106021: GO 106108
// index := GetElementIndex ( hackTanks , hack ) ;
106023: LD_ADDR_VAR 0 5
106027: PUSH
106028: LD_EXP 174
106032: PPUSH
106033: LD_VAR 0 1
106037: PPUSH
106038: CALL 53350 0 2
106042: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
106043: LD_ADDR_VAR 0 4
106047: PUSH
106048: DOUBLE
106049: LD_INT 1
106051: DEC
106052: ST_TO_ADDR
106053: LD_EXP 175
106057: PUSH
106058: LD_VAR 0 5
106062: ARRAY
106063: PUSH
106064: FOR_TO
106065: IFFALSE 106106
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
106067: LD_EXP 175
106071: PUSH
106072: LD_VAR 0 5
106076: ARRAY
106077: PUSH
106078: LD_VAR 0 4
106082: ARRAY
106083: PUSH
106084: LD_INT 1
106086: ARRAY
106087: PUSH
106088: LD_VAR 0 2
106092: EQUAL
106093: IFFALSE 106104
// KillUnit ( vehicle ) ;
106095: LD_VAR 0 2
106099: PPUSH
106100: CALL_OW 66
106104: GO 106064
106106: POP
106107: POP
// end ;
106108: LD_VAR 0 3
106112: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
106113: LD_EXP 179
106117: NOT
106118: IFFALSE 106153
106120: GO 106122
106122: DISABLE
// begin initMiner := true ;
106123: LD_ADDR_EXP 179
106127: PUSH
106128: LD_INT 1
106130: ST_TO_ADDR
// minersList := [ ] ;
106131: LD_ADDR_EXP 180
106135: PUSH
106136: EMPTY
106137: ST_TO_ADDR
// minerMinesList := [ ] ;
106138: LD_ADDR_EXP 181
106142: PUSH
106143: EMPTY
106144: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
106145: LD_ADDR_EXP 182
106149: PUSH
106150: LD_INT 5
106152: ST_TO_ADDR
// end ;
106153: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
106154: LD_EXP 179
106158: PUSH
106159: LD_INT 34
106161: PUSH
106162: LD_EXP 101
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: PPUSH
106171: CALL_OW 69
106175: AND
106176: IFFALSE 106639
106178: GO 106180
106180: DISABLE
106181: LD_INT 0
106183: PPUSH
106184: PPUSH
106185: PPUSH
106186: PPUSH
// begin enable ;
106187: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
106188: LD_ADDR_VAR 0 1
106192: PUSH
106193: LD_INT 34
106195: PUSH
106196: LD_EXP 101
106200: PUSH
106201: EMPTY
106202: LIST
106203: LIST
106204: PPUSH
106205: CALL_OW 69
106209: PUSH
106210: FOR_IN
106211: IFFALSE 106283
// begin if not i in minersList then
106213: LD_VAR 0 1
106217: PUSH
106218: LD_EXP 180
106222: IN
106223: NOT
106224: IFFALSE 106281
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
106226: LD_ADDR_EXP 180
106230: PUSH
106231: LD_EXP 180
106235: PPUSH
106236: LD_EXP 180
106240: PUSH
106241: LD_INT 1
106243: PLUS
106244: PPUSH
106245: LD_VAR 0 1
106249: PPUSH
106250: CALL_OW 1
106254: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
106255: LD_ADDR_EXP 181
106259: PUSH
106260: LD_EXP 181
106264: PPUSH
106265: LD_EXP 181
106269: PUSH
106270: LD_INT 1
106272: PLUS
106273: PPUSH
106274: EMPTY
106275: PPUSH
106276: CALL_OW 1
106280: ST_TO_ADDR
// end end ;
106281: GO 106210
106283: POP
106284: POP
// for i := minerMinesList downto 1 do
106285: LD_ADDR_VAR 0 1
106289: PUSH
106290: DOUBLE
106291: LD_EXP 181
106295: INC
106296: ST_TO_ADDR
106297: LD_INT 1
106299: PUSH
106300: FOR_DOWNTO
106301: IFFALSE 106637
// begin if IsLive ( minersList [ i ] ) then
106303: LD_EXP 180
106307: PUSH
106308: LD_VAR 0 1
106312: ARRAY
106313: PPUSH
106314: CALL_OW 300
106318: IFFALSE 106346
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106320: LD_EXP 180
106324: PUSH
106325: LD_VAR 0 1
106329: ARRAY
106330: PPUSH
106331: LD_EXP 181
106335: PUSH
106336: LD_VAR 0 1
106340: ARRAY
106341: PPUSH
106342: CALL_OW 505
// if not minerMinesList [ i ] then
106346: LD_EXP 181
106350: PUSH
106351: LD_VAR 0 1
106355: ARRAY
106356: NOT
106357: IFFALSE 106361
// continue ;
106359: GO 106300
// for j := minerMinesList [ i ] downto 1 do
106361: LD_ADDR_VAR 0 2
106365: PUSH
106366: DOUBLE
106367: LD_EXP 181
106371: PUSH
106372: LD_VAR 0 1
106376: ARRAY
106377: INC
106378: ST_TO_ADDR
106379: LD_INT 1
106381: PUSH
106382: FOR_DOWNTO
106383: IFFALSE 106633
// begin side := GetSide ( minersList [ i ] ) ;
106385: LD_ADDR_VAR 0 3
106389: PUSH
106390: LD_EXP 180
106394: PUSH
106395: LD_VAR 0 1
106399: ARRAY
106400: PPUSH
106401: CALL_OW 255
106405: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106406: LD_ADDR_VAR 0 4
106410: PUSH
106411: LD_EXP 181
106415: PUSH
106416: LD_VAR 0 1
106420: ARRAY
106421: PUSH
106422: LD_VAR 0 2
106426: ARRAY
106427: PUSH
106428: LD_INT 1
106430: ARRAY
106431: PPUSH
106432: LD_EXP 181
106436: PUSH
106437: LD_VAR 0 1
106441: ARRAY
106442: PUSH
106443: LD_VAR 0 2
106447: ARRAY
106448: PUSH
106449: LD_INT 2
106451: ARRAY
106452: PPUSH
106453: CALL_OW 428
106457: ST_TO_ADDR
// if not tmp then
106458: LD_VAR 0 4
106462: NOT
106463: IFFALSE 106467
// continue ;
106465: GO 106382
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106467: LD_VAR 0 4
106471: PUSH
106472: LD_INT 81
106474: PUSH
106475: LD_VAR 0 3
106479: PUSH
106480: EMPTY
106481: LIST
106482: LIST
106483: PPUSH
106484: CALL_OW 69
106488: IN
106489: PUSH
106490: LD_EXP 181
106494: PUSH
106495: LD_VAR 0 1
106499: ARRAY
106500: PUSH
106501: LD_VAR 0 2
106505: ARRAY
106506: PUSH
106507: LD_INT 1
106509: ARRAY
106510: PPUSH
106511: LD_EXP 181
106515: PUSH
106516: LD_VAR 0 1
106520: ARRAY
106521: PUSH
106522: LD_VAR 0 2
106526: ARRAY
106527: PUSH
106528: LD_INT 2
106530: ARRAY
106531: PPUSH
106532: CALL_OW 458
106536: AND
106537: IFFALSE 106631
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106539: LD_EXP 181
106543: PUSH
106544: LD_VAR 0 1
106548: ARRAY
106549: PUSH
106550: LD_VAR 0 2
106554: ARRAY
106555: PUSH
106556: LD_INT 1
106558: ARRAY
106559: PPUSH
106560: LD_EXP 181
106564: PUSH
106565: LD_VAR 0 1
106569: ARRAY
106570: PUSH
106571: LD_VAR 0 2
106575: ARRAY
106576: PUSH
106577: LD_INT 2
106579: ARRAY
106580: PPUSH
106581: LD_VAR 0 3
106585: PPUSH
106586: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106590: LD_ADDR_EXP 181
106594: PUSH
106595: LD_EXP 181
106599: PPUSH
106600: LD_VAR 0 1
106604: PPUSH
106605: LD_EXP 181
106609: PUSH
106610: LD_VAR 0 1
106614: ARRAY
106615: PPUSH
106616: LD_VAR 0 2
106620: PPUSH
106621: CALL_OW 3
106625: PPUSH
106626: CALL_OW 1
106630: ST_TO_ADDR
// end ; end ;
106631: GO 106382
106633: POP
106634: POP
// end ;
106635: GO 106300
106637: POP
106638: POP
// end ;
106639: PPOPN 4
106641: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106642: LD_INT 0
106644: PPUSH
106645: PPUSH
// result := false ;
106646: LD_ADDR_VAR 0 4
106650: PUSH
106651: LD_INT 0
106653: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106654: LD_VAR 0 1
106658: PPUSH
106659: CALL_OW 264
106663: PUSH
106664: LD_EXP 101
106668: EQUAL
106669: NOT
106670: IFFALSE 106674
// exit ;
106672: GO 106914
// index := GetElementIndex ( minersList , unit ) ;
106674: LD_ADDR_VAR 0 5
106678: PUSH
106679: LD_EXP 180
106683: PPUSH
106684: LD_VAR 0 1
106688: PPUSH
106689: CALL 53350 0 2
106693: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106694: LD_EXP 181
106698: PUSH
106699: LD_VAR 0 5
106703: ARRAY
106704: PUSH
106705: LD_EXP 182
106709: GREATEREQUAL
106710: IFFALSE 106714
// exit ;
106712: GO 106914
// ComMoveXY ( unit , x , y ) ;
106714: LD_VAR 0 1
106718: PPUSH
106719: LD_VAR 0 2
106723: PPUSH
106724: LD_VAR 0 3
106728: PPUSH
106729: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106733: LD_INT 35
106735: PPUSH
106736: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106740: LD_VAR 0 1
106744: PPUSH
106745: LD_VAR 0 2
106749: PPUSH
106750: LD_VAR 0 3
106754: PPUSH
106755: CALL 84069 0 3
106759: NOT
106760: PUSH
106761: LD_VAR 0 1
106765: PPUSH
106766: CALL_OW 314
106770: AND
106771: IFFALSE 106775
// exit ;
106773: GO 106914
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106775: LD_VAR 0 2
106779: PPUSH
106780: LD_VAR 0 3
106784: PPUSH
106785: CALL_OW 428
106789: PUSH
106790: LD_VAR 0 1
106794: EQUAL
106795: PUSH
106796: LD_VAR 0 1
106800: PPUSH
106801: CALL_OW 314
106805: NOT
106806: AND
106807: IFFALSE 106733
// PlaySoundXY ( x , y , PlantMine ) ;
106809: LD_VAR 0 2
106813: PPUSH
106814: LD_VAR 0 3
106818: PPUSH
106819: LD_STRING PlantMine
106821: PPUSH
106822: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106826: LD_VAR 0 2
106830: PPUSH
106831: LD_VAR 0 3
106835: PPUSH
106836: LD_VAR 0 1
106840: PPUSH
106841: CALL_OW 255
106845: PPUSH
106846: LD_INT 0
106848: PPUSH
106849: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106853: LD_ADDR_EXP 181
106857: PUSH
106858: LD_EXP 181
106862: PPUSH
106863: LD_VAR 0 5
106867: PUSH
106868: LD_EXP 181
106872: PUSH
106873: LD_VAR 0 5
106877: ARRAY
106878: PUSH
106879: LD_INT 1
106881: PLUS
106882: PUSH
106883: EMPTY
106884: LIST
106885: LIST
106886: PPUSH
106887: LD_VAR 0 2
106891: PUSH
106892: LD_VAR 0 3
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: PPUSH
106901: CALL 53565 0 3
106905: ST_TO_ADDR
// result := true ;
106906: LD_ADDR_VAR 0 4
106910: PUSH
106911: LD_INT 1
106913: ST_TO_ADDR
// end ;
106914: LD_VAR 0 4
106918: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106919: LD_INT 0
106921: PPUSH
106922: PPUSH
106923: PPUSH
// if not unit in minersList then
106924: LD_VAR 0 1
106928: PUSH
106929: LD_EXP 180
106933: IN
106934: NOT
106935: IFFALSE 106939
// exit ;
106937: GO 107331
// index := GetElementIndex ( minersList , unit ) ;
106939: LD_ADDR_VAR 0 6
106943: PUSH
106944: LD_EXP 180
106948: PPUSH
106949: LD_VAR 0 1
106953: PPUSH
106954: CALL 53350 0 2
106958: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106959: LD_ADDR_VAR 0 5
106963: PUSH
106964: DOUBLE
106965: LD_EXP 181
106969: PUSH
106970: LD_VAR 0 6
106974: ARRAY
106975: INC
106976: ST_TO_ADDR
106977: LD_INT 1
106979: PUSH
106980: FOR_DOWNTO
106981: IFFALSE 107142
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106983: LD_EXP 181
106987: PUSH
106988: LD_VAR 0 6
106992: ARRAY
106993: PUSH
106994: LD_VAR 0 5
106998: ARRAY
106999: PUSH
107000: LD_INT 1
107002: ARRAY
107003: PUSH
107004: LD_VAR 0 2
107008: EQUAL
107009: PUSH
107010: LD_EXP 181
107014: PUSH
107015: LD_VAR 0 6
107019: ARRAY
107020: PUSH
107021: LD_VAR 0 5
107025: ARRAY
107026: PUSH
107027: LD_INT 2
107029: ARRAY
107030: PUSH
107031: LD_VAR 0 3
107035: EQUAL
107036: AND
107037: IFFALSE 107140
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107039: LD_EXP 181
107043: PUSH
107044: LD_VAR 0 6
107048: ARRAY
107049: PUSH
107050: LD_VAR 0 5
107054: ARRAY
107055: PUSH
107056: LD_INT 1
107058: ARRAY
107059: PPUSH
107060: LD_EXP 181
107064: PUSH
107065: LD_VAR 0 6
107069: ARRAY
107070: PUSH
107071: LD_VAR 0 5
107075: ARRAY
107076: PUSH
107077: LD_INT 2
107079: ARRAY
107080: PPUSH
107081: LD_VAR 0 1
107085: PPUSH
107086: CALL_OW 255
107090: PPUSH
107091: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107095: LD_ADDR_EXP 181
107099: PUSH
107100: LD_EXP 181
107104: PPUSH
107105: LD_VAR 0 6
107109: PPUSH
107110: LD_EXP 181
107114: PUSH
107115: LD_VAR 0 6
107119: ARRAY
107120: PPUSH
107121: LD_VAR 0 5
107125: PPUSH
107126: CALL_OW 3
107130: PPUSH
107131: CALL_OW 1
107135: ST_TO_ADDR
// exit ;
107136: POP
107137: POP
107138: GO 107331
// end ; end ;
107140: GO 106980
107142: POP
107143: POP
// for i := minerMinesList [ index ] downto 1 do
107144: LD_ADDR_VAR 0 5
107148: PUSH
107149: DOUBLE
107150: LD_EXP 181
107154: PUSH
107155: LD_VAR 0 6
107159: ARRAY
107160: INC
107161: ST_TO_ADDR
107162: LD_INT 1
107164: PUSH
107165: FOR_DOWNTO
107166: IFFALSE 107329
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
107168: LD_EXP 181
107172: PUSH
107173: LD_VAR 0 6
107177: ARRAY
107178: PUSH
107179: LD_VAR 0 5
107183: ARRAY
107184: PUSH
107185: LD_INT 1
107187: ARRAY
107188: PPUSH
107189: LD_EXP 181
107193: PUSH
107194: LD_VAR 0 6
107198: ARRAY
107199: PUSH
107200: LD_VAR 0 5
107204: ARRAY
107205: PUSH
107206: LD_INT 2
107208: ARRAY
107209: PPUSH
107210: LD_VAR 0 2
107214: PPUSH
107215: LD_VAR 0 3
107219: PPUSH
107220: CALL_OW 298
107224: PUSH
107225: LD_INT 6
107227: LESS
107228: IFFALSE 107327
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
107230: LD_EXP 181
107234: PUSH
107235: LD_VAR 0 6
107239: ARRAY
107240: PUSH
107241: LD_VAR 0 5
107245: ARRAY
107246: PUSH
107247: LD_INT 1
107249: ARRAY
107250: PPUSH
107251: LD_EXP 181
107255: PUSH
107256: LD_VAR 0 6
107260: ARRAY
107261: PUSH
107262: LD_VAR 0 5
107266: ARRAY
107267: PUSH
107268: LD_INT 2
107270: ARRAY
107271: PPUSH
107272: LD_VAR 0 1
107276: PPUSH
107277: CALL_OW 255
107281: PPUSH
107282: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107286: LD_ADDR_EXP 181
107290: PUSH
107291: LD_EXP 181
107295: PPUSH
107296: LD_VAR 0 6
107300: PPUSH
107301: LD_EXP 181
107305: PUSH
107306: LD_VAR 0 6
107310: ARRAY
107311: PPUSH
107312: LD_VAR 0 5
107316: PPUSH
107317: CALL_OW 3
107321: PPUSH
107322: CALL_OW 1
107326: ST_TO_ADDR
// end ; end ;
107327: GO 107165
107329: POP
107330: POP
// end ;
107331: LD_VAR 0 4
107335: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107336: LD_INT 0
107338: PPUSH
107339: PPUSH
107340: PPUSH
107341: PPUSH
107342: PPUSH
107343: PPUSH
107344: PPUSH
107345: PPUSH
107346: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107347: LD_VAR 0 1
107351: PPUSH
107352: CALL_OW 264
107356: PUSH
107357: LD_EXP 101
107361: EQUAL
107362: NOT
107363: PUSH
107364: LD_VAR 0 1
107368: PUSH
107369: LD_EXP 180
107373: IN
107374: NOT
107375: OR
107376: IFFALSE 107380
// exit ;
107378: GO 107702
// index := GetElementIndex ( minersList , unit ) ;
107380: LD_ADDR_VAR 0 6
107384: PUSH
107385: LD_EXP 180
107389: PPUSH
107390: LD_VAR 0 1
107394: PPUSH
107395: CALL 53350 0 2
107399: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107400: LD_ADDR_VAR 0 8
107404: PUSH
107405: LD_EXP 182
107409: PUSH
107410: LD_EXP 181
107414: PUSH
107415: LD_VAR 0 6
107419: ARRAY
107420: MINUS
107421: ST_TO_ADDR
// if not minesFreeAmount then
107422: LD_VAR 0 8
107426: NOT
107427: IFFALSE 107431
// exit ;
107429: GO 107702
// tmp := [ ] ;
107431: LD_ADDR_VAR 0 7
107435: PUSH
107436: EMPTY
107437: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107438: LD_ADDR_VAR 0 5
107442: PUSH
107443: DOUBLE
107444: LD_INT 1
107446: DEC
107447: ST_TO_ADDR
107448: LD_VAR 0 8
107452: PUSH
107453: FOR_TO
107454: IFFALSE 107649
// begin _d := rand ( 0 , 5 ) ;
107456: LD_ADDR_VAR 0 11
107460: PUSH
107461: LD_INT 0
107463: PPUSH
107464: LD_INT 5
107466: PPUSH
107467: CALL_OW 12
107471: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107472: LD_ADDR_VAR 0 12
107476: PUSH
107477: LD_INT 2
107479: PPUSH
107480: LD_INT 6
107482: PPUSH
107483: CALL_OW 12
107487: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107488: LD_ADDR_VAR 0 9
107492: PUSH
107493: LD_VAR 0 2
107497: PPUSH
107498: LD_VAR 0 11
107502: PPUSH
107503: LD_VAR 0 12
107507: PPUSH
107508: CALL_OW 272
107512: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107513: LD_ADDR_VAR 0 10
107517: PUSH
107518: LD_VAR 0 3
107522: PPUSH
107523: LD_VAR 0 11
107527: PPUSH
107528: LD_VAR 0 12
107532: PPUSH
107533: CALL_OW 273
107537: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107538: LD_VAR 0 9
107542: PPUSH
107543: LD_VAR 0 10
107547: PPUSH
107548: CALL_OW 488
107552: PUSH
107553: LD_VAR 0 9
107557: PUSH
107558: LD_VAR 0 10
107562: PUSH
107563: EMPTY
107564: LIST
107565: LIST
107566: PUSH
107567: LD_VAR 0 7
107571: IN
107572: NOT
107573: AND
107574: PUSH
107575: LD_VAR 0 9
107579: PPUSH
107580: LD_VAR 0 10
107584: PPUSH
107585: CALL_OW 458
107589: NOT
107590: AND
107591: IFFALSE 107633
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107593: LD_ADDR_VAR 0 7
107597: PUSH
107598: LD_VAR 0 7
107602: PPUSH
107603: LD_VAR 0 7
107607: PUSH
107608: LD_INT 1
107610: PLUS
107611: PPUSH
107612: LD_VAR 0 9
107616: PUSH
107617: LD_VAR 0 10
107621: PUSH
107622: EMPTY
107623: LIST
107624: LIST
107625: PPUSH
107626: CALL_OW 1
107630: ST_TO_ADDR
107631: GO 107647
// i := i - 1 ;
107633: LD_ADDR_VAR 0 5
107637: PUSH
107638: LD_VAR 0 5
107642: PUSH
107643: LD_INT 1
107645: MINUS
107646: ST_TO_ADDR
// end ;
107647: GO 107453
107649: POP
107650: POP
// for i in tmp do
107651: LD_ADDR_VAR 0 5
107655: PUSH
107656: LD_VAR 0 7
107660: PUSH
107661: FOR_IN
107662: IFFALSE 107700
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107664: LD_VAR 0 1
107668: PPUSH
107669: LD_VAR 0 5
107673: PUSH
107674: LD_INT 1
107676: ARRAY
107677: PPUSH
107678: LD_VAR 0 5
107682: PUSH
107683: LD_INT 2
107685: ARRAY
107686: PPUSH
107687: CALL 106642 0 3
107691: NOT
107692: IFFALSE 107698
// exit ;
107694: POP
107695: POP
107696: GO 107702
107698: GO 107661
107700: POP
107701: POP
// end ;
107702: LD_VAR 0 4
107706: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107707: LD_INT 0
107709: PPUSH
107710: PPUSH
107711: PPUSH
107712: PPUSH
107713: PPUSH
107714: PPUSH
107715: PPUSH
// if not GetClass ( unit ) = class_sniper then
107716: LD_VAR 0 1
107720: PPUSH
107721: CALL_OW 257
107725: PUSH
107726: LD_INT 5
107728: EQUAL
107729: NOT
107730: IFFALSE 107734
// exit ;
107732: GO 108122
// dist := 8 ;
107734: LD_ADDR_VAR 0 5
107738: PUSH
107739: LD_INT 8
107741: ST_TO_ADDR
// viewRange := 12 ;
107742: LD_ADDR_VAR 0 7
107746: PUSH
107747: LD_INT 12
107749: ST_TO_ADDR
// side := GetSide ( unit ) ;
107750: LD_ADDR_VAR 0 6
107754: PUSH
107755: LD_VAR 0 1
107759: PPUSH
107760: CALL_OW 255
107764: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107765: LD_INT 61
107767: PPUSH
107768: LD_VAR 0 6
107772: PPUSH
107773: CALL_OW 321
107777: PUSH
107778: LD_INT 2
107780: EQUAL
107781: IFFALSE 107791
// viewRange := 16 ;
107783: LD_ADDR_VAR 0 7
107787: PUSH
107788: LD_INT 16
107790: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107791: LD_VAR 0 1
107795: PPUSH
107796: LD_VAR 0 2
107800: PPUSH
107801: LD_VAR 0 3
107805: PPUSH
107806: CALL_OW 297
107810: PUSH
107811: LD_VAR 0 5
107815: GREATER
107816: IFFALSE 107895
// begin ComMoveXY ( unit , x , y ) ;
107818: LD_VAR 0 1
107822: PPUSH
107823: LD_VAR 0 2
107827: PPUSH
107828: LD_VAR 0 3
107832: PPUSH
107833: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107837: LD_INT 35
107839: PPUSH
107840: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107844: LD_VAR 0 1
107848: PPUSH
107849: LD_VAR 0 2
107853: PPUSH
107854: LD_VAR 0 3
107858: PPUSH
107859: CALL 84069 0 3
107863: NOT
107864: IFFALSE 107868
// exit ;
107866: GO 108122
// until GetDistUnitXY ( unit , x , y ) < dist ;
107868: LD_VAR 0 1
107872: PPUSH
107873: LD_VAR 0 2
107877: PPUSH
107878: LD_VAR 0 3
107882: PPUSH
107883: CALL_OW 297
107887: PUSH
107888: LD_VAR 0 5
107892: LESS
107893: IFFALSE 107837
// end ; ComTurnXY ( unit , x , y ) ;
107895: LD_VAR 0 1
107899: PPUSH
107900: LD_VAR 0 2
107904: PPUSH
107905: LD_VAR 0 3
107909: PPUSH
107910: CALL_OW 118
// wait ( 5 ) ;
107914: LD_INT 5
107916: PPUSH
107917: CALL_OW 67
// _d := GetDir ( unit ) ;
107921: LD_ADDR_VAR 0 10
107925: PUSH
107926: LD_VAR 0 1
107930: PPUSH
107931: CALL_OW 254
107935: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107936: LD_ADDR_VAR 0 8
107940: PUSH
107941: LD_VAR 0 1
107945: PPUSH
107946: CALL_OW 250
107950: PPUSH
107951: LD_VAR 0 10
107955: PPUSH
107956: LD_VAR 0 5
107960: PPUSH
107961: CALL_OW 272
107965: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107966: LD_ADDR_VAR 0 9
107970: PUSH
107971: LD_VAR 0 1
107975: PPUSH
107976: CALL_OW 251
107980: PPUSH
107981: LD_VAR 0 10
107985: PPUSH
107986: LD_VAR 0 5
107990: PPUSH
107991: CALL_OW 273
107995: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107996: LD_VAR 0 8
108000: PPUSH
108001: LD_VAR 0 9
108005: PPUSH
108006: CALL_OW 488
108010: NOT
108011: IFFALSE 108015
// exit ;
108013: GO 108122
// ComAnimCustom ( unit , 1 ) ;
108015: LD_VAR 0 1
108019: PPUSH
108020: LD_INT 1
108022: PPUSH
108023: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
108027: LD_VAR 0 8
108031: PPUSH
108032: LD_VAR 0 9
108036: PPUSH
108037: LD_VAR 0 6
108041: PPUSH
108042: LD_VAR 0 7
108046: PPUSH
108047: CALL_OW 330
// repeat wait ( 1 ) ;
108051: LD_INT 1
108053: PPUSH
108054: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
108058: LD_VAR 0 1
108062: PPUSH
108063: CALL_OW 316
108067: PUSH
108068: LD_VAR 0 1
108072: PPUSH
108073: CALL_OW 314
108077: OR
108078: PUSH
108079: LD_VAR 0 1
108083: PPUSH
108084: CALL_OW 302
108088: NOT
108089: OR
108090: PUSH
108091: LD_VAR 0 1
108095: PPUSH
108096: CALL_OW 301
108100: OR
108101: IFFALSE 108051
// RemoveSeeing ( _x , _y , side ) ;
108103: LD_VAR 0 8
108107: PPUSH
108108: LD_VAR 0 9
108112: PPUSH
108113: LD_VAR 0 6
108117: PPUSH
108118: CALL_OW 331
// end ; end_of_file
108122: LD_VAR 0 4
108126: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
108127: LD_INT 0
108129: PPUSH
108130: PPUSH
108131: PPUSH
108132: PPUSH
108133: PPUSH
108134: PPUSH
108135: PPUSH
108136: PPUSH
108137: PPUSH
108138: PPUSH
108139: PPUSH
108140: PPUSH
108141: PPUSH
108142: PPUSH
108143: PPUSH
108144: PPUSH
108145: PPUSH
108146: PPUSH
108147: PPUSH
108148: PPUSH
108149: PPUSH
108150: PPUSH
108151: PPUSH
108152: PPUSH
108153: PPUSH
108154: PPUSH
108155: PPUSH
108156: PPUSH
108157: PPUSH
108158: PPUSH
108159: PPUSH
108160: PPUSH
108161: PPUSH
108162: PPUSH
// if not list then
108163: LD_VAR 0 1
108167: NOT
108168: IFFALSE 108172
// exit ;
108170: GO 112831
// base := list [ 1 ] ;
108172: LD_ADDR_VAR 0 3
108176: PUSH
108177: LD_VAR 0 1
108181: PUSH
108182: LD_INT 1
108184: ARRAY
108185: ST_TO_ADDR
// group := list [ 2 ] ;
108186: LD_ADDR_VAR 0 4
108190: PUSH
108191: LD_VAR 0 1
108195: PUSH
108196: LD_INT 2
108198: ARRAY
108199: ST_TO_ADDR
// path := list [ 3 ] ;
108200: LD_ADDR_VAR 0 5
108204: PUSH
108205: LD_VAR 0 1
108209: PUSH
108210: LD_INT 3
108212: ARRAY
108213: ST_TO_ADDR
// flags := list [ 4 ] ;
108214: LD_ADDR_VAR 0 6
108218: PUSH
108219: LD_VAR 0 1
108223: PUSH
108224: LD_INT 4
108226: ARRAY
108227: ST_TO_ADDR
// mined := [ ] ;
108228: LD_ADDR_VAR 0 27
108232: PUSH
108233: EMPTY
108234: ST_TO_ADDR
// bombed := [ ] ;
108235: LD_ADDR_VAR 0 28
108239: PUSH
108240: EMPTY
108241: ST_TO_ADDR
// healers := [ ] ;
108242: LD_ADDR_VAR 0 31
108246: PUSH
108247: EMPTY
108248: ST_TO_ADDR
// to_heal := [ ] ;
108249: LD_ADDR_VAR 0 30
108253: PUSH
108254: EMPTY
108255: ST_TO_ADDR
// repairs := [ ] ;
108256: LD_ADDR_VAR 0 33
108260: PUSH
108261: EMPTY
108262: ST_TO_ADDR
// to_repair := [ ] ;
108263: LD_ADDR_VAR 0 32
108267: PUSH
108268: EMPTY
108269: ST_TO_ADDR
// if not group or not path then
108270: LD_VAR 0 4
108274: NOT
108275: PUSH
108276: LD_VAR 0 5
108280: NOT
108281: OR
108282: IFFALSE 108286
// exit ;
108284: GO 112831
// side := GetSide ( group [ 1 ] ) ;
108286: LD_ADDR_VAR 0 35
108290: PUSH
108291: LD_VAR 0 4
108295: PUSH
108296: LD_INT 1
108298: ARRAY
108299: PPUSH
108300: CALL_OW 255
108304: ST_TO_ADDR
// if flags then
108305: LD_VAR 0 6
108309: IFFALSE 108453
// begin f_ignore_area := flags [ 1 ] ;
108311: LD_ADDR_VAR 0 17
108315: PUSH
108316: LD_VAR 0 6
108320: PUSH
108321: LD_INT 1
108323: ARRAY
108324: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108325: LD_ADDR_VAR 0 18
108329: PUSH
108330: LD_VAR 0 6
108334: PUSH
108335: LD_INT 2
108337: ARRAY
108338: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108339: LD_ADDR_VAR 0 19
108343: PUSH
108344: LD_VAR 0 6
108348: PUSH
108349: LD_INT 3
108351: ARRAY
108352: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108353: LD_ADDR_VAR 0 20
108357: PUSH
108358: LD_VAR 0 6
108362: PUSH
108363: LD_INT 4
108365: ARRAY
108366: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108367: LD_ADDR_VAR 0 21
108371: PUSH
108372: LD_VAR 0 6
108376: PUSH
108377: LD_INT 5
108379: ARRAY
108380: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108381: LD_ADDR_VAR 0 22
108385: PUSH
108386: LD_VAR 0 6
108390: PUSH
108391: LD_INT 6
108393: ARRAY
108394: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108395: LD_ADDR_VAR 0 23
108399: PUSH
108400: LD_VAR 0 6
108404: PUSH
108405: LD_INT 7
108407: ARRAY
108408: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108409: LD_ADDR_VAR 0 24
108413: PUSH
108414: LD_VAR 0 6
108418: PUSH
108419: LD_INT 8
108421: ARRAY
108422: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108423: LD_ADDR_VAR 0 25
108427: PUSH
108428: LD_VAR 0 6
108432: PUSH
108433: LD_INT 9
108435: ARRAY
108436: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108437: LD_ADDR_VAR 0 26
108441: PUSH
108442: LD_VAR 0 6
108446: PUSH
108447: LD_INT 10
108449: ARRAY
108450: ST_TO_ADDR
// end else
108451: GO 108533
// begin f_ignore_area := false ;
108453: LD_ADDR_VAR 0 17
108457: PUSH
108458: LD_INT 0
108460: ST_TO_ADDR
// f_capture := false ;
108461: LD_ADDR_VAR 0 18
108465: PUSH
108466: LD_INT 0
108468: ST_TO_ADDR
// f_ignore_civ := false ;
108469: LD_ADDR_VAR 0 19
108473: PUSH
108474: LD_INT 0
108476: ST_TO_ADDR
// f_murder := false ;
108477: LD_ADDR_VAR 0 20
108481: PUSH
108482: LD_INT 0
108484: ST_TO_ADDR
// f_mines := false ;
108485: LD_ADDR_VAR 0 21
108489: PUSH
108490: LD_INT 0
108492: ST_TO_ADDR
// f_repair := false ;
108493: LD_ADDR_VAR 0 22
108497: PUSH
108498: LD_INT 0
108500: ST_TO_ADDR
// f_heal := false ;
108501: LD_ADDR_VAR 0 23
108505: PUSH
108506: LD_INT 0
108508: ST_TO_ADDR
// f_spacetime := false ;
108509: LD_ADDR_VAR 0 24
108513: PUSH
108514: LD_INT 0
108516: ST_TO_ADDR
// f_attack_depot := false ;
108517: LD_ADDR_VAR 0 25
108521: PUSH
108522: LD_INT 0
108524: ST_TO_ADDR
// f_crawl := false ;
108525: LD_ADDR_VAR 0 26
108529: PUSH
108530: LD_INT 0
108532: ST_TO_ADDR
// end ; if f_heal then
108533: LD_VAR 0 23
108537: IFFALSE 108564
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108539: LD_ADDR_VAR 0 31
108543: PUSH
108544: LD_VAR 0 4
108548: PPUSH
108549: LD_INT 25
108551: PUSH
108552: LD_INT 4
108554: PUSH
108555: EMPTY
108556: LIST
108557: LIST
108558: PPUSH
108559: CALL_OW 72
108563: ST_TO_ADDR
// if f_repair then
108564: LD_VAR 0 22
108568: IFFALSE 108595
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108570: LD_ADDR_VAR 0 33
108574: PUSH
108575: LD_VAR 0 4
108579: PPUSH
108580: LD_INT 25
108582: PUSH
108583: LD_INT 3
108585: PUSH
108586: EMPTY
108587: LIST
108588: LIST
108589: PPUSH
108590: CALL_OW 72
108594: ST_TO_ADDR
// units_path := [ ] ;
108595: LD_ADDR_VAR 0 16
108599: PUSH
108600: EMPTY
108601: ST_TO_ADDR
// for i = 1 to group do
108602: LD_ADDR_VAR 0 7
108606: PUSH
108607: DOUBLE
108608: LD_INT 1
108610: DEC
108611: ST_TO_ADDR
108612: LD_VAR 0 4
108616: PUSH
108617: FOR_TO
108618: IFFALSE 108647
// units_path := Replace ( units_path , i , path ) ;
108620: LD_ADDR_VAR 0 16
108624: PUSH
108625: LD_VAR 0 16
108629: PPUSH
108630: LD_VAR 0 7
108634: PPUSH
108635: LD_VAR 0 5
108639: PPUSH
108640: CALL_OW 1
108644: ST_TO_ADDR
108645: GO 108617
108647: POP
108648: POP
// repeat for i = group downto 1 do
108649: LD_ADDR_VAR 0 7
108653: PUSH
108654: DOUBLE
108655: LD_VAR 0 4
108659: INC
108660: ST_TO_ADDR
108661: LD_INT 1
108663: PUSH
108664: FOR_DOWNTO
108665: IFFALSE 112787
// begin wait ( 5 ) ;
108667: LD_INT 5
108669: PPUSH
108670: CALL_OW 67
// tmp := [ ] ;
108674: LD_ADDR_VAR 0 14
108678: PUSH
108679: EMPTY
108680: ST_TO_ADDR
// attacking := false ;
108681: LD_ADDR_VAR 0 29
108685: PUSH
108686: LD_INT 0
108688: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108689: LD_VAR 0 4
108693: PUSH
108694: LD_VAR 0 7
108698: ARRAY
108699: PPUSH
108700: CALL_OW 301
108704: PUSH
108705: LD_VAR 0 4
108709: PUSH
108710: LD_VAR 0 7
108714: ARRAY
108715: NOT
108716: OR
108717: IFFALSE 108826
// begin if GetType ( group [ i ] ) = unit_human then
108719: LD_VAR 0 4
108723: PUSH
108724: LD_VAR 0 7
108728: ARRAY
108729: PPUSH
108730: CALL_OW 247
108734: PUSH
108735: LD_INT 1
108737: EQUAL
108738: IFFALSE 108784
// begin to_heal := to_heal diff group [ i ] ;
108740: LD_ADDR_VAR 0 30
108744: PUSH
108745: LD_VAR 0 30
108749: PUSH
108750: LD_VAR 0 4
108754: PUSH
108755: LD_VAR 0 7
108759: ARRAY
108760: DIFF
108761: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108762: LD_ADDR_VAR 0 31
108766: PUSH
108767: LD_VAR 0 31
108771: PUSH
108772: LD_VAR 0 4
108776: PUSH
108777: LD_VAR 0 7
108781: ARRAY
108782: DIFF
108783: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108784: LD_ADDR_VAR 0 4
108788: PUSH
108789: LD_VAR 0 4
108793: PPUSH
108794: LD_VAR 0 7
108798: PPUSH
108799: CALL_OW 3
108803: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108804: LD_ADDR_VAR 0 16
108808: PUSH
108809: LD_VAR 0 16
108813: PPUSH
108814: LD_VAR 0 7
108818: PPUSH
108819: CALL_OW 3
108823: ST_TO_ADDR
// continue ;
108824: GO 108664
// end ; if f_repair then
108826: LD_VAR 0 22
108830: IFFALSE 109319
// begin if GetType ( group [ i ] ) = unit_vehicle then
108832: LD_VAR 0 4
108836: PUSH
108837: LD_VAR 0 7
108841: ARRAY
108842: PPUSH
108843: CALL_OW 247
108847: PUSH
108848: LD_INT 2
108850: EQUAL
108851: IFFALSE 109041
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108853: LD_VAR 0 4
108857: PUSH
108858: LD_VAR 0 7
108862: ARRAY
108863: PPUSH
108864: CALL_OW 256
108868: PUSH
108869: LD_INT 700
108871: LESS
108872: PUSH
108873: LD_VAR 0 4
108877: PUSH
108878: LD_VAR 0 7
108882: ARRAY
108883: PUSH
108884: LD_VAR 0 32
108888: IN
108889: NOT
108890: AND
108891: IFFALSE 108915
// to_repair := to_repair union group [ i ] ;
108893: LD_ADDR_VAR 0 32
108897: PUSH
108898: LD_VAR 0 32
108902: PUSH
108903: LD_VAR 0 4
108907: PUSH
108908: LD_VAR 0 7
108912: ARRAY
108913: UNION
108914: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108915: LD_VAR 0 4
108919: PUSH
108920: LD_VAR 0 7
108924: ARRAY
108925: PPUSH
108926: CALL_OW 256
108930: PUSH
108931: LD_INT 1000
108933: EQUAL
108934: PUSH
108935: LD_VAR 0 4
108939: PUSH
108940: LD_VAR 0 7
108944: ARRAY
108945: PUSH
108946: LD_VAR 0 32
108950: IN
108951: AND
108952: IFFALSE 108976
// to_repair := to_repair diff group [ i ] ;
108954: LD_ADDR_VAR 0 32
108958: PUSH
108959: LD_VAR 0 32
108963: PUSH
108964: LD_VAR 0 4
108968: PUSH
108969: LD_VAR 0 7
108973: ARRAY
108974: DIFF
108975: ST_TO_ADDR
// if group [ i ] in to_repair then
108976: LD_VAR 0 4
108980: PUSH
108981: LD_VAR 0 7
108985: ARRAY
108986: PUSH
108987: LD_VAR 0 32
108991: IN
108992: IFFALSE 109039
// begin if not IsInArea ( group [ i ] , f_repair ) then
108994: LD_VAR 0 4
108998: PUSH
108999: LD_VAR 0 7
109003: ARRAY
109004: PPUSH
109005: LD_VAR 0 22
109009: PPUSH
109010: CALL_OW 308
109014: NOT
109015: IFFALSE 109037
// ComMoveToArea ( group [ i ] , f_repair ) ;
109017: LD_VAR 0 4
109021: PUSH
109022: LD_VAR 0 7
109026: ARRAY
109027: PPUSH
109028: LD_VAR 0 22
109032: PPUSH
109033: CALL_OW 113
// continue ;
109037: GO 108664
// end ; end else
109039: GO 109319
// if group [ i ] in repairs then
109041: LD_VAR 0 4
109045: PUSH
109046: LD_VAR 0 7
109050: ARRAY
109051: PUSH
109052: LD_VAR 0 33
109056: IN
109057: IFFALSE 109319
// begin if IsInUnit ( group [ i ] ) then
109059: LD_VAR 0 4
109063: PUSH
109064: LD_VAR 0 7
109068: ARRAY
109069: PPUSH
109070: CALL_OW 310
109074: IFFALSE 109142
// begin z := IsInUnit ( group [ i ] ) ;
109076: LD_ADDR_VAR 0 13
109080: PUSH
109081: LD_VAR 0 4
109085: PUSH
109086: LD_VAR 0 7
109090: ARRAY
109091: PPUSH
109092: CALL_OW 310
109096: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
109097: LD_VAR 0 13
109101: PUSH
109102: LD_VAR 0 32
109106: IN
109107: PUSH
109108: LD_VAR 0 13
109112: PPUSH
109113: LD_VAR 0 22
109117: PPUSH
109118: CALL_OW 308
109122: AND
109123: IFFALSE 109140
// ComExitVehicle ( group [ i ] ) ;
109125: LD_VAR 0 4
109129: PUSH
109130: LD_VAR 0 7
109134: ARRAY
109135: PPUSH
109136: CALL_OW 121
// end else
109140: GO 109319
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
109142: LD_ADDR_VAR 0 13
109146: PUSH
109147: LD_VAR 0 4
109151: PPUSH
109152: LD_INT 95
109154: PUSH
109155: LD_VAR 0 22
109159: PUSH
109160: EMPTY
109161: LIST
109162: LIST
109163: PUSH
109164: LD_INT 58
109166: PUSH
109167: EMPTY
109168: LIST
109169: PUSH
109170: EMPTY
109171: LIST
109172: LIST
109173: PPUSH
109174: CALL_OW 72
109178: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
109179: LD_VAR 0 4
109183: PUSH
109184: LD_VAR 0 7
109188: ARRAY
109189: PPUSH
109190: CALL_OW 314
109194: NOT
109195: IFFALSE 109317
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
109197: LD_ADDR_VAR 0 10
109201: PUSH
109202: LD_VAR 0 13
109206: PPUSH
109207: LD_VAR 0 4
109211: PUSH
109212: LD_VAR 0 7
109216: ARRAY
109217: PPUSH
109218: CALL_OW 74
109222: ST_TO_ADDR
// if not x then
109223: LD_VAR 0 10
109227: NOT
109228: IFFALSE 109232
// continue ;
109230: GO 108664
// if GetLives ( x ) < 1000 then
109232: LD_VAR 0 10
109236: PPUSH
109237: CALL_OW 256
109241: PUSH
109242: LD_INT 1000
109244: LESS
109245: IFFALSE 109269
// ComRepairVehicle ( group [ i ] , x ) else
109247: LD_VAR 0 4
109251: PUSH
109252: LD_VAR 0 7
109256: ARRAY
109257: PPUSH
109258: LD_VAR 0 10
109262: PPUSH
109263: CALL_OW 129
109267: GO 109317
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
109269: LD_VAR 0 23
109273: PUSH
109274: LD_VAR 0 4
109278: PUSH
109279: LD_VAR 0 7
109283: ARRAY
109284: PPUSH
109285: CALL_OW 256
109289: PUSH
109290: LD_INT 1000
109292: LESS
109293: AND
109294: NOT
109295: IFFALSE 109317
// ComEnterUnit ( group [ i ] , x ) ;
109297: LD_VAR 0 4
109301: PUSH
109302: LD_VAR 0 7
109306: ARRAY
109307: PPUSH
109308: LD_VAR 0 10
109312: PPUSH
109313: CALL_OW 120
// end ; continue ;
109317: GO 108664
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109319: LD_VAR 0 23
109323: PUSH
109324: LD_VAR 0 4
109328: PUSH
109329: LD_VAR 0 7
109333: ARRAY
109334: PPUSH
109335: CALL_OW 247
109339: PUSH
109340: LD_INT 1
109342: EQUAL
109343: AND
109344: IFFALSE 109822
// begin if group [ i ] in healers then
109346: LD_VAR 0 4
109350: PUSH
109351: LD_VAR 0 7
109355: ARRAY
109356: PUSH
109357: LD_VAR 0 31
109361: IN
109362: IFFALSE 109635
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109364: LD_VAR 0 4
109368: PUSH
109369: LD_VAR 0 7
109373: ARRAY
109374: PPUSH
109375: LD_VAR 0 23
109379: PPUSH
109380: CALL_OW 308
109384: NOT
109385: PUSH
109386: LD_VAR 0 4
109390: PUSH
109391: LD_VAR 0 7
109395: ARRAY
109396: PPUSH
109397: CALL_OW 314
109401: NOT
109402: AND
109403: IFFALSE 109427
// ComMoveToArea ( group [ i ] , f_heal ) else
109405: LD_VAR 0 4
109409: PUSH
109410: LD_VAR 0 7
109414: ARRAY
109415: PPUSH
109416: LD_VAR 0 23
109420: PPUSH
109421: CALL_OW 113
109425: GO 109633
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109427: LD_VAR 0 4
109431: PUSH
109432: LD_VAR 0 7
109436: ARRAY
109437: PPUSH
109438: CALL 82645 0 1
109442: PPUSH
109443: CALL_OW 256
109447: PUSH
109448: LD_INT 1000
109450: EQUAL
109451: IFFALSE 109470
// ComStop ( group [ i ] ) else
109453: LD_VAR 0 4
109457: PUSH
109458: LD_VAR 0 7
109462: ARRAY
109463: PPUSH
109464: CALL_OW 141
109468: GO 109633
// if not HasTask ( group [ i ] ) and to_heal then
109470: LD_VAR 0 4
109474: PUSH
109475: LD_VAR 0 7
109479: ARRAY
109480: PPUSH
109481: CALL_OW 314
109485: NOT
109486: PUSH
109487: LD_VAR 0 30
109491: AND
109492: IFFALSE 109633
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109494: LD_ADDR_VAR 0 13
109498: PUSH
109499: LD_VAR 0 30
109503: PPUSH
109504: LD_INT 3
109506: PUSH
109507: LD_INT 54
109509: PUSH
109510: EMPTY
109511: LIST
109512: PUSH
109513: EMPTY
109514: LIST
109515: LIST
109516: PPUSH
109517: CALL_OW 72
109521: PPUSH
109522: LD_VAR 0 4
109526: PUSH
109527: LD_VAR 0 7
109531: ARRAY
109532: PPUSH
109533: CALL_OW 74
109537: ST_TO_ADDR
// if z then
109538: LD_VAR 0 13
109542: IFFALSE 109633
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109544: LD_INT 91
109546: PUSH
109547: LD_VAR 0 13
109551: PUSH
109552: LD_INT 10
109554: PUSH
109555: EMPTY
109556: LIST
109557: LIST
109558: LIST
109559: PUSH
109560: LD_INT 81
109562: PUSH
109563: LD_VAR 0 13
109567: PPUSH
109568: CALL_OW 255
109572: PUSH
109573: EMPTY
109574: LIST
109575: LIST
109576: PUSH
109577: EMPTY
109578: LIST
109579: LIST
109580: PPUSH
109581: CALL_OW 69
109585: PUSH
109586: LD_INT 0
109588: EQUAL
109589: IFFALSE 109613
// ComHeal ( group [ i ] , z ) else
109591: LD_VAR 0 4
109595: PUSH
109596: LD_VAR 0 7
109600: ARRAY
109601: PPUSH
109602: LD_VAR 0 13
109606: PPUSH
109607: CALL_OW 128
109611: GO 109633
// ComMoveToArea ( group [ i ] , f_heal ) ;
109613: LD_VAR 0 4
109617: PUSH
109618: LD_VAR 0 7
109622: ARRAY
109623: PPUSH
109624: LD_VAR 0 23
109628: PPUSH
109629: CALL_OW 113
// end ; continue ;
109633: GO 108664
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109635: LD_VAR 0 4
109639: PUSH
109640: LD_VAR 0 7
109644: ARRAY
109645: PPUSH
109646: CALL_OW 256
109650: PUSH
109651: LD_INT 700
109653: LESS
109654: PUSH
109655: LD_VAR 0 4
109659: PUSH
109660: LD_VAR 0 7
109664: ARRAY
109665: PUSH
109666: LD_VAR 0 30
109670: IN
109671: NOT
109672: AND
109673: IFFALSE 109697
// to_heal := to_heal union group [ i ] ;
109675: LD_ADDR_VAR 0 30
109679: PUSH
109680: LD_VAR 0 30
109684: PUSH
109685: LD_VAR 0 4
109689: PUSH
109690: LD_VAR 0 7
109694: ARRAY
109695: UNION
109696: ST_TO_ADDR
// if group [ i ] in to_heal then
109697: LD_VAR 0 4
109701: PUSH
109702: LD_VAR 0 7
109706: ARRAY
109707: PUSH
109708: LD_VAR 0 30
109712: IN
109713: IFFALSE 109822
// begin if GetLives ( group [ i ] ) = 1000 then
109715: LD_VAR 0 4
109719: PUSH
109720: LD_VAR 0 7
109724: ARRAY
109725: PPUSH
109726: CALL_OW 256
109730: PUSH
109731: LD_INT 1000
109733: EQUAL
109734: IFFALSE 109760
// to_heal := to_heal diff group [ i ] else
109736: LD_ADDR_VAR 0 30
109740: PUSH
109741: LD_VAR 0 30
109745: PUSH
109746: LD_VAR 0 4
109750: PUSH
109751: LD_VAR 0 7
109755: ARRAY
109756: DIFF
109757: ST_TO_ADDR
109758: GO 109822
// begin if not IsInArea ( group [ i ] , to_heal ) then
109760: LD_VAR 0 4
109764: PUSH
109765: LD_VAR 0 7
109769: ARRAY
109770: PPUSH
109771: LD_VAR 0 30
109775: PPUSH
109776: CALL_OW 308
109780: NOT
109781: IFFALSE 109805
// ComMoveToArea ( group [ i ] , f_heal ) else
109783: LD_VAR 0 4
109787: PUSH
109788: LD_VAR 0 7
109792: ARRAY
109793: PPUSH
109794: LD_VAR 0 23
109798: PPUSH
109799: CALL_OW 113
109803: GO 109820
// ComHold ( group [ i ] ) ;
109805: LD_VAR 0 4
109809: PUSH
109810: LD_VAR 0 7
109814: ARRAY
109815: PPUSH
109816: CALL_OW 140
// continue ;
109820: GO 108664
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109822: LD_VAR 0 4
109826: PUSH
109827: LD_VAR 0 7
109831: ARRAY
109832: PPUSH
109833: LD_INT 10
109835: PPUSH
109836: CALL 81065 0 2
109840: NOT
109841: PUSH
109842: LD_VAR 0 16
109846: PUSH
109847: LD_VAR 0 7
109851: ARRAY
109852: PUSH
109853: EMPTY
109854: EQUAL
109855: NOT
109856: AND
109857: IFFALSE 110123
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109859: LD_VAR 0 4
109863: PUSH
109864: LD_VAR 0 7
109868: ARRAY
109869: PPUSH
109870: CALL_OW 262
109874: PUSH
109875: LD_INT 1
109877: PUSH
109878: LD_INT 2
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: IN
109885: IFFALSE 109926
// if GetFuel ( group [ i ] ) < 10 then
109887: LD_VAR 0 4
109891: PUSH
109892: LD_VAR 0 7
109896: ARRAY
109897: PPUSH
109898: CALL_OW 261
109902: PUSH
109903: LD_INT 10
109905: LESS
109906: IFFALSE 109926
// SetFuel ( group [ i ] , 12 ) ;
109908: LD_VAR 0 4
109912: PUSH
109913: LD_VAR 0 7
109917: ARRAY
109918: PPUSH
109919: LD_INT 12
109921: PPUSH
109922: CALL_OW 240
// if units_path [ i ] then
109926: LD_VAR 0 16
109930: PUSH
109931: LD_VAR 0 7
109935: ARRAY
109936: IFFALSE 110121
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109938: LD_VAR 0 4
109942: PUSH
109943: LD_VAR 0 7
109947: ARRAY
109948: PPUSH
109949: LD_VAR 0 16
109953: PUSH
109954: LD_VAR 0 7
109958: ARRAY
109959: PUSH
109960: LD_INT 1
109962: ARRAY
109963: PUSH
109964: LD_INT 1
109966: ARRAY
109967: PPUSH
109968: LD_VAR 0 16
109972: PUSH
109973: LD_VAR 0 7
109977: ARRAY
109978: PUSH
109979: LD_INT 1
109981: ARRAY
109982: PUSH
109983: LD_INT 2
109985: ARRAY
109986: PPUSH
109987: CALL_OW 297
109991: PUSH
109992: LD_INT 6
109994: GREATER
109995: IFFALSE 110070
// begin if not HasTask ( group [ i ] ) then
109997: LD_VAR 0 4
110001: PUSH
110002: LD_VAR 0 7
110006: ARRAY
110007: PPUSH
110008: CALL_OW 314
110012: NOT
110013: IFFALSE 110068
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
110015: LD_VAR 0 4
110019: PUSH
110020: LD_VAR 0 7
110024: ARRAY
110025: PPUSH
110026: LD_VAR 0 16
110030: PUSH
110031: LD_VAR 0 7
110035: ARRAY
110036: PUSH
110037: LD_INT 1
110039: ARRAY
110040: PUSH
110041: LD_INT 1
110043: ARRAY
110044: PPUSH
110045: LD_VAR 0 16
110049: PUSH
110050: LD_VAR 0 7
110054: ARRAY
110055: PUSH
110056: LD_INT 1
110058: ARRAY
110059: PUSH
110060: LD_INT 2
110062: ARRAY
110063: PPUSH
110064: CALL_OW 114
// end else
110068: GO 110121
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
110070: LD_ADDR_VAR 0 15
110074: PUSH
110075: LD_VAR 0 16
110079: PUSH
110080: LD_VAR 0 7
110084: ARRAY
110085: PPUSH
110086: LD_INT 1
110088: PPUSH
110089: CALL_OW 3
110093: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
110094: LD_ADDR_VAR 0 16
110098: PUSH
110099: LD_VAR 0 16
110103: PPUSH
110104: LD_VAR 0 7
110108: PPUSH
110109: LD_VAR 0 15
110113: PPUSH
110114: CALL_OW 1
110118: ST_TO_ADDR
// continue ;
110119: GO 108664
// end ; end ; end else
110121: GO 112785
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
110123: LD_ADDR_VAR 0 14
110127: PUSH
110128: LD_INT 81
110130: PUSH
110131: LD_VAR 0 4
110135: PUSH
110136: LD_VAR 0 7
110140: ARRAY
110141: PPUSH
110142: CALL_OW 255
110146: PUSH
110147: EMPTY
110148: LIST
110149: LIST
110150: PPUSH
110151: CALL_OW 69
110155: ST_TO_ADDR
// if not tmp then
110156: LD_VAR 0 14
110160: NOT
110161: IFFALSE 110165
// continue ;
110163: GO 108664
// if f_ignore_area then
110165: LD_VAR 0 17
110169: IFFALSE 110257
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
110171: LD_ADDR_VAR 0 15
110175: PUSH
110176: LD_VAR 0 14
110180: PPUSH
110181: LD_INT 3
110183: PUSH
110184: LD_INT 92
110186: PUSH
110187: LD_VAR 0 17
110191: PUSH
110192: LD_INT 1
110194: ARRAY
110195: PUSH
110196: LD_VAR 0 17
110200: PUSH
110201: LD_INT 2
110203: ARRAY
110204: PUSH
110205: LD_VAR 0 17
110209: PUSH
110210: LD_INT 3
110212: ARRAY
110213: PUSH
110214: EMPTY
110215: LIST
110216: LIST
110217: LIST
110218: LIST
110219: PUSH
110220: EMPTY
110221: LIST
110222: LIST
110223: PPUSH
110224: CALL_OW 72
110228: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110229: LD_VAR 0 14
110233: PUSH
110234: LD_VAR 0 15
110238: DIFF
110239: IFFALSE 110257
// tmp := tmp diff tmp2 ;
110241: LD_ADDR_VAR 0 14
110245: PUSH
110246: LD_VAR 0 14
110250: PUSH
110251: LD_VAR 0 15
110255: DIFF
110256: ST_TO_ADDR
// end ; if not f_murder then
110257: LD_VAR 0 20
110261: NOT
110262: IFFALSE 110320
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
110264: LD_ADDR_VAR 0 15
110268: PUSH
110269: LD_VAR 0 14
110273: PPUSH
110274: LD_INT 3
110276: PUSH
110277: LD_INT 50
110279: PUSH
110280: EMPTY
110281: LIST
110282: PUSH
110283: EMPTY
110284: LIST
110285: LIST
110286: PPUSH
110287: CALL_OW 72
110291: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110292: LD_VAR 0 14
110296: PUSH
110297: LD_VAR 0 15
110301: DIFF
110302: IFFALSE 110320
// tmp := tmp diff tmp2 ;
110304: LD_ADDR_VAR 0 14
110308: PUSH
110309: LD_VAR 0 14
110313: PUSH
110314: LD_VAR 0 15
110318: DIFF
110319: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110320: LD_ADDR_VAR 0 14
110324: PUSH
110325: LD_VAR 0 4
110329: PUSH
110330: LD_VAR 0 7
110334: ARRAY
110335: PPUSH
110336: LD_VAR 0 14
110340: PPUSH
110341: LD_INT 1
110343: PPUSH
110344: LD_INT 1
110346: PPUSH
110347: CALL 54000 0 4
110351: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110352: LD_VAR 0 4
110356: PUSH
110357: LD_VAR 0 7
110361: ARRAY
110362: PPUSH
110363: CALL_OW 257
110367: PUSH
110368: LD_INT 1
110370: EQUAL
110371: IFFALSE 110819
// begin if WantPlant ( group [ i ] ) then
110373: LD_VAR 0 4
110377: PUSH
110378: LD_VAR 0 7
110382: ARRAY
110383: PPUSH
110384: CALL 53501 0 1
110388: IFFALSE 110392
// continue ;
110390: GO 108664
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110392: LD_VAR 0 18
110396: PUSH
110397: LD_VAR 0 4
110401: PUSH
110402: LD_VAR 0 7
110406: ARRAY
110407: PPUSH
110408: CALL_OW 310
110412: NOT
110413: AND
110414: PUSH
110415: LD_VAR 0 14
110419: PUSH
110420: LD_INT 1
110422: ARRAY
110423: PUSH
110424: LD_VAR 0 14
110428: PPUSH
110429: LD_INT 21
110431: PUSH
110432: LD_INT 2
110434: PUSH
110435: EMPTY
110436: LIST
110437: LIST
110438: PUSH
110439: LD_INT 58
110441: PUSH
110442: EMPTY
110443: LIST
110444: PUSH
110445: EMPTY
110446: LIST
110447: LIST
110448: PPUSH
110449: CALL_OW 72
110453: IN
110454: AND
110455: IFFALSE 110491
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110457: LD_VAR 0 4
110461: PUSH
110462: LD_VAR 0 7
110466: ARRAY
110467: PPUSH
110468: LD_VAR 0 14
110472: PUSH
110473: LD_INT 1
110475: ARRAY
110476: PPUSH
110477: CALL_OW 120
// attacking := true ;
110481: LD_ADDR_VAR 0 29
110485: PUSH
110486: LD_INT 1
110488: ST_TO_ADDR
// continue ;
110489: GO 108664
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110491: LD_VAR 0 26
110495: PUSH
110496: LD_VAR 0 4
110500: PUSH
110501: LD_VAR 0 7
110505: ARRAY
110506: PPUSH
110507: CALL_OW 257
110511: PUSH
110512: LD_INT 1
110514: EQUAL
110515: AND
110516: PUSH
110517: LD_VAR 0 4
110521: PUSH
110522: LD_VAR 0 7
110526: ARRAY
110527: PPUSH
110528: CALL_OW 256
110532: PUSH
110533: LD_INT 800
110535: LESS
110536: AND
110537: PUSH
110538: LD_VAR 0 4
110542: PUSH
110543: LD_VAR 0 7
110547: ARRAY
110548: PPUSH
110549: CALL_OW 318
110553: NOT
110554: AND
110555: IFFALSE 110572
// ComCrawl ( group [ i ] ) ;
110557: LD_VAR 0 4
110561: PUSH
110562: LD_VAR 0 7
110566: ARRAY
110567: PPUSH
110568: CALL_OW 137
// if f_mines then
110572: LD_VAR 0 21
110576: IFFALSE 110819
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110578: LD_VAR 0 14
110582: PUSH
110583: LD_INT 1
110585: ARRAY
110586: PPUSH
110587: CALL_OW 247
110591: PUSH
110592: LD_INT 3
110594: EQUAL
110595: PUSH
110596: LD_VAR 0 14
110600: PUSH
110601: LD_INT 1
110603: ARRAY
110604: PUSH
110605: LD_VAR 0 27
110609: IN
110610: NOT
110611: AND
110612: IFFALSE 110819
// begin x := GetX ( tmp [ 1 ] ) ;
110614: LD_ADDR_VAR 0 10
110618: PUSH
110619: LD_VAR 0 14
110623: PUSH
110624: LD_INT 1
110626: ARRAY
110627: PPUSH
110628: CALL_OW 250
110632: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110633: LD_ADDR_VAR 0 11
110637: PUSH
110638: LD_VAR 0 14
110642: PUSH
110643: LD_INT 1
110645: ARRAY
110646: PPUSH
110647: CALL_OW 251
110651: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110652: LD_ADDR_VAR 0 12
110656: PUSH
110657: LD_VAR 0 4
110661: PUSH
110662: LD_VAR 0 7
110666: ARRAY
110667: PPUSH
110668: CALL 81150 0 1
110672: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110673: LD_VAR 0 4
110677: PUSH
110678: LD_VAR 0 7
110682: ARRAY
110683: PPUSH
110684: LD_VAR 0 10
110688: PPUSH
110689: LD_VAR 0 11
110693: PPUSH
110694: LD_VAR 0 14
110698: PUSH
110699: LD_INT 1
110701: ARRAY
110702: PPUSH
110703: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110707: LD_VAR 0 4
110711: PUSH
110712: LD_VAR 0 7
110716: ARRAY
110717: PPUSH
110718: LD_VAR 0 10
110722: PPUSH
110723: LD_VAR 0 12
110727: PPUSH
110728: LD_INT 7
110730: PPUSH
110731: CALL_OW 272
110735: PPUSH
110736: LD_VAR 0 11
110740: PPUSH
110741: LD_VAR 0 12
110745: PPUSH
110746: LD_INT 7
110748: PPUSH
110749: CALL_OW 273
110753: PPUSH
110754: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110758: LD_VAR 0 4
110762: PUSH
110763: LD_VAR 0 7
110767: ARRAY
110768: PPUSH
110769: LD_INT 71
110771: PPUSH
110772: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110776: LD_ADDR_VAR 0 27
110780: PUSH
110781: LD_VAR 0 27
110785: PPUSH
110786: LD_VAR 0 27
110790: PUSH
110791: LD_INT 1
110793: PLUS
110794: PPUSH
110795: LD_VAR 0 14
110799: PUSH
110800: LD_INT 1
110802: ARRAY
110803: PPUSH
110804: CALL_OW 1
110808: ST_TO_ADDR
// attacking := true ;
110809: LD_ADDR_VAR 0 29
110813: PUSH
110814: LD_INT 1
110816: ST_TO_ADDR
// continue ;
110817: GO 108664
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110819: LD_VAR 0 4
110823: PUSH
110824: LD_VAR 0 7
110828: ARRAY
110829: PPUSH
110830: CALL_OW 257
110834: PUSH
110835: LD_INT 17
110837: EQUAL
110838: PUSH
110839: LD_VAR 0 4
110843: PUSH
110844: LD_VAR 0 7
110848: ARRAY
110849: PPUSH
110850: CALL_OW 110
110854: PUSH
110855: LD_INT 71
110857: EQUAL
110858: NOT
110859: AND
110860: IFFALSE 111006
// begin attacking := false ;
110862: LD_ADDR_VAR 0 29
110866: PUSH
110867: LD_INT 0
110869: ST_TO_ADDR
// k := 5 ;
110870: LD_ADDR_VAR 0 9
110874: PUSH
110875: LD_INT 5
110877: ST_TO_ADDR
// if tmp < k then
110878: LD_VAR 0 14
110882: PUSH
110883: LD_VAR 0 9
110887: LESS
110888: IFFALSE 110900
// k := tmp ;
110890: LD_ADDR_VAR 0 9
110894: PUSH
110895: LD_VAR 0 14
110899: ST_TO_ADDR
// for j = 1 to k do
110900: LD_ADDR_VAR 0 8
110904: PUSH
110905: DOUBLE
110906: LD_INT 1
110908: DEC
110909: ST_TO_ADDR
110910: LD_VAR 0 9
110914: PUSH
110915: FOR_TO
110916: IFFALSE 111004
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110918: LD_VAR 0 14
110922: PUSH
110923: LD_VAR 0 8
110927: ARRAY
110928: PUSH
110929: LD_VAR 0 14
110933: PPUSH
110934: LD_INT 58
110936: PUSH
110937: EMPTY
110938: LIST
110939: PPUSH
110940: CALL_OW 72
110944: IN
110945: NOT
110946: IFFALSE 111002
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110948: LD_VAR 0 4
110952: PUSH
110953: LD_VAR 0 7
110957: ARRAY
110958: PPUSH
110959: LD_VAR 0 14
110963: PUSH
110964: LD_VAR 0 8
110968: ARRAY
110969: PPUSH
110970: CALL_OW 115
// attacking := true ;
110974: LD_ADDR_VAR 0 29
110978: PUSH
110979: LD_INT 1
110981: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110982: LD_VAR 0 4
110986: PUSH
110987: LD_VAR 0 7
110991: ARRAY
110992: PPUSH
110993: LD_INT 71
110995: PPUSH
110996: CALL_OW 109
// continue ;
111000: GO 110915
// end ; end ;
111002: GO 110915
111004: POP
111005: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
111006: LD_VAR 0 4
111010: PUSH
111011: LD_VAR 0 7
111015: ARRAY
111016: PPUSH
111017: CALL_OW 257
111021: PUSH
111022: LD_INT 8
111024: EQUAL
111025: PUSH
111026: LD_VAR 0 4
111030: PUSH
111031: LD_VAR 0 7
111035: ARRAY
111036: PPUSH
111037: CALL_OW 264
111041: PUSH
111042: LD_INT 28
111044: PUSH
111045: LD_INT 45
111047: PUSH
111048: LD_INT 7
111050: PUSH
111051: LD_INT 47
111053: PUSH
111054: EMPTY
111055: LIST
111056: LIST
111057: LIST
111058: LIST
111059: IN
111060: OR
111061: IFFALSE 111317
// begin attacking := false ;
111063: LD_ADDR_VAR 0 29
111067: PUSH
111068: LD_INT 0
111070: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
111071: LD_VAR 0 14
111075: PUSH
111076: LD_INT 1
111078: ARRAY
111079: PPUSH
111080: CALL_OW 266
111084: PUSH
111085: LD_INT 32
111087: PUSH
111088: LD_INT 31
111090: PUSH
111091: LD_INT 33
111093: PUSH
111094: LD_INT 4
111096: PUSH
111097: LD_INT 5
111099: PUSH
111100: EMPTY
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: LIST
111106: IN
111107: IFFALSE 111293
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
111109: LD_ADDR_VAR 0 9
111113: PUSH
111114: LD_VAR 0 14
111118: PUSH
111119: LD_INT 1
111121: ARRAY
111122: PPUSH
111123: CALL_OW 266
111127: PPUSH
111128: LD_VAR 0 14
111132: PUSH
111133: LD_INT 1
111135: ARRAY
111136: PPUSH
111137: CALL_OW 250
111141: PPUSH
111142: LD_VAR 0 14
111146: PUSH
111147: LD_INT 1
111149: ARRAY
111150: PPUSH
111151: CALL_OW 251
111155: PPUSH
111156: LD_VAR 0 14
111160: PUSH
111161: LD_INT 1
111163: ARRAY
111164: PPUSH
111165: CALL_OW 254
111169: PPUSH
111170: LD_VAR 0 14
111174: PUSH
111175: LD_INT 1
111177: ARRAY
111178: PPUSH
111179: CALL_OW 248
111183: PPUSH
111184: LD_INT 0
111186: PPUSH
111187: CALL 62520 0 6
111191: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
111192: LD_ADDR_VAR 0 8
111196: PUSH
111197: LD_VAR 0 4
111201: PUSH
111202: LD_VAR 0 7
111206: ARRAY
111207: PPUSH
111208: LD_VAR 0 9
111212: PPUSH
111213: CALL 81190 0 2
111217: ST_TO_ADDR
// if j then
111218: LD_VAR 0 8
111222: IFFALSE 111291
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
111224: LD_VAR 0 8
111228: PUSH
111229: LD_INT 1
111231: ARRAY
111232: PPUSH
111233: LD_VAR 0 8
111237: PUSH
111238: LD_INT 2
111240: ARRAY
111241: PPUSH
111242: CALL_OW 488
111246: IFFALSE 111291
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
111248: LD_VAR 0 4
111252: PUSH
111253: LD_VAR 0 7
111257: ARRAY
111258: PPUSH
111259: LD_VAR 0 8
111263: PUSH
111264: LD_INT 1
111266: ARRAY
111267: PPUSH
111268: LD_VAR 0 8
111272: PUSH
111273: LD_INT 2
111275: ARRAY
111276: PPUSH
111277: CALL_OW 116
// attacking := true ;
111281: LD_ADDR_VAR 0 29
111285: PUSH
111286: LD_INT 1
111288: ST_TO_ADDR
// continue ;
111289: GO 108664
// end ; end else
111291: GO 111317
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111293: LD_VAR 0 4
111297: PUSH
111298: LD_VAR 0 7
111302: ARRAY
111303: PPUSH
111304: LD_VAR 0 14
111308: PUSH
111309: LD_INT 1
111311: ARRAY
111312: PPUSH
111313: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111317: LD_VAR 0 4
111321: PUSH
111322: LD_VAR 0 7
111326: ARRAY
111327: PPUSH
111328: CALL_OW 265
111332: PUSH
111333: LD_INT 11
111335: EQUAL
111336: IFFALSE 111614
// begin k := 10 ;
111338: LD_ADDR_VAR 0 9
111342: PUSH
111343: LD_INT 10
111345: ST_TO_ADDR
// x := 0 ;
111346: LD_ADDR_VAR 0 10
111350: PUSH
111351: LD_INT 0
111353: ST_TO_ADDR
// if tmp < k then
111354: LD_VAR 0 14
111358: PUSH
111359: LD_VAR 0 9
111363: LESS
111364: IFFALSE 111376
// k := tmp ;
111366: LD_ADDR_VAR 0 9
111370: PUSH
111371: LD_VAR 0 14
111375: ST_TO_ADDR
// for j = k downto 1 do
111376: LD_ADDR_VAR 0 8
111380: PUSH
111381: DOUBLE
111382: LD_VAR 0 9
111386: INC
111387: ST_TO_ADDR
111388: LD_INT 1
111390: PUSH
111391: FOR_DOWNTO
111392: IFFALSE 111467
// begin if GetType ( tmp [ j ] ) = unit_human then
111394: LD_VAR 0 14
111398: PUSH
111399: LD_VAR 0 8
111403: ARRAY
111404: PPUSH
111405: CALL_OW 247
111409: PUSH
111410: LD_INT 1
111412: EQUAL
111413: IFFALSE 111465
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111415: LD_VAR 0 4
111419: PUSH
111420: LD_VAR 0 7
111424: ARRAY
111425: PPUSH
111426: LD_VAR 0 14
111430: PUSH
111431: LD_VAR 0 8
111435: ARRAY
111436: PPUSH
111437: CALL 81461 0 2
// x := tmp [ j ] ;
111441: LD_ADDR_VAR 0 10
111445: PUSH
111446: LD_VAR 0 14
111450: PUSH
111451: LD_VAR 0 8
111455: ARRAY
111456: ST_TO_ADDR
// attacking := true ;
111457: LD_ADDR_VAR 0 29
111461: PUSH
111462: LD_INT 1
111464: ST_TO_ADDR
// end ; end ;
111465: GO 111391
111467: POP
111468: POP
// if not x then
111469: LD_VAR 0 10
111473: NOT
111474: IFFALSE 111614
// begin attacking := true ;
111476: LD_ADDR_VAR 0 29
111480: PUSH
111481: LD_INT 1
111483: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111484: LD_VAR 0 4
111488: PUSH
111489: LD_VAR 0 7
111493: ARRAY
111494: PPUSH
111495: CALL_OW 250
111499: PPUSH
111500: LD_VAR 0 4
111504: PUSH
111505: LD_VAR 0 7
111509: ARRAY
111510: PPUSH
111511: CALL_OW 251
111515: PPUSH
111516: CALL_OW 546
111520: PUSH
111521: LD_INT 2
111523: ARRAY
111524: PUSH
111525: LD_VAR 0 14
111529: PUSH
111530: LD_INT 1
111532: ARRAY
111533: PPUSH
111534: CALL_OW 250
111538: PPUSH
111539: LD_VAR 0 14
111543: PUSH
111544: LD_INT 1
111546: ARRAY
111547: PPUSH
111548: CALL_OW 251
111552: PPUSH
111553: CALL_OW 546
111557: PUSH
111558: LD_INT 2
111560: ARRAY
111561: EQUAL
111562: IFFALSE 111590
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111564: LD_VAR 0 4
111568: PUSH
111569: LD_VAR 0 7
111573: ARRAY
111574: PPUSH
111575: LD_VAR 0 14
111579: PUSH
111580: LD_INT 1
111582: ARRAY
111583: PPUSH
111584: CALL 81461 0 2
111588: GO 111614
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111590: LD_VAR 0 4
111594: PUSH
111595: LD_VAR 0 7
111599: ARRAY
111600: PPUSH
111601: LD_VAR 0 14
111605: PUSH
111606: LD_INT 1
111608: ARRAY
111609: PPUSH
111610: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111614: LD_VAR 0 4
111618: PUSH
111619: LD_VAR 0 7
111623: ARRAY
111624: PPUSH
111625: CALL_OW 264
111629: PUSH
111630: LD_INT 29
111632: EQUAL
111633: IFFALSE 111999
// begin if WantsToAttack ( group [ i ] ) in bombed then
111635: LD_VAR 0 4
111639: PUSH
111640: LD_VAR 0 7
111644: ARRAY
111645: PPUSH
111646: CALL_OW 319
111650: PUSH
111651: LD_VAR 0 28
111655: IN
111656: IFFALSE 111660
// continue ;
111658: GO 108664
// k := 8 ;
111660: LD_ADDR_VAR 0 9
111664: PUSH
111665: LD_INT 8
111667: ST_TO_ADDR
// x := 0 ;
111668: LD_ADDR_VAR 0 10
111672: PUSH
111673: LD_INT 0
111675: ST_TO_ADDR
// if tmp < k then
111676: LD_VAR 0 14
111680: PUSH
111681: LD_VAR 0 9
111685: LESS
111686: IFFALSE 111698
// k := tmp ;
111688: LD_ADDR_VAR 0 9
111692: PUSH
111693: LD_VAR 0 14
111697: ST_TO_ADDR
// for j = 1 to k do
111698: LD_ADDR_VAR 0 8
111702: PUSH
111703: DOUBLE
111704: LD_INT 1
111706: DEC
111707: ST_TO_ADDR
111708: LD_VAR 0 9
111712: PUSH
111713: FOR_TO
111714: IFFALSE 111846
// begin if GetType ( tmp [ j ] ) = unit_building then
111716: LD_VAR 0 14
111720: PUSH
111721: LD_VAR 0 8
111725: ARRAY
111726: PPUSH
111727: CALL_OW 247
111731: PUSH
111732: LD_INT 3
111734: EQUAL
111735: IFFALSE 111844
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111737: LD_VAR 0 14
111741: PUSH
111742: LD_VAR 0 8
111746: ARRAY
111747: PUSH
111748: LD_VAR 0 28
111752: IN
111753: NOT
111754: PUSH
111755: LD_VAR 0 14
111759: PUSH
111760: LD_VAR 0 8
111764: ARRAY
111765: PPUSH
111766: CALL_OW 313
111770: AND
111771: IFFALSE 111844
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111773: LD_VAR 0 4
111777: PUSH
111778: LD_VAR 0 7
111782: ARRAY
111783: PPUSH
111784: LD_VAR 0 14
111788: PUSH
111789: LD_VAR 0 8
111793: ARRAY
111794: PPUSH
111795: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111799: LD_ADDR_VAR 0 28
111803: PUSH
111804: LD_VAR 0 28
111808: PPUSH
111809: LD_VAR 0 28
111813: PUSH
111814: LD_INT 1
111816: PLUS
111817: PPUSH
111818: LD_VAR 0 14
111822: PUSH
111823: LD_VAR 0 8
111827: ARRAY
111828: PPUSH
111829: CALL_OW 1
111833: ST_TO_ADDR
// attacking := true ;
111834: LD_ADDR_VAR 0 29
111838: PUSH
111839: LD_INT 1
111841: ST_TO_ADDR
// break ;
111842: GO 111846
// end ; end ;
111844: GO 111713
111846: POP
111847: POP
// if not attacking and f_attack_depot then
111848: LD_VAR 0 29
111852: NOT
111853: PUSH
111854: LD_VAR 0 25
111858: AND
111859: IFFALSE 111954
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111861: LD_ADDR_VAR 0 13
111865: PUSH
111866: LD_VAR 0 14
111870: PPUSH
111871: LD_INT 2
111873: PUSH
111874: LD_INT 30
111876: PUSH
111877: LD_INT 0
111879: PUSH
111880: EMPTY
111881: LIST
111882: LIST
111883: PUSH
111884: LD_INT 30
111886: PUSH
111887: LD_INT 1
111889: PUSH
111890: EMPTY
111891: LIST
111892: LIST
111893: PUSH
111894: EMPTY
111895: LIST
111896: LIST
111897: LIST
111898: PPUSH
111899: CALL_OW 72
111903: ST_TO_ADDR
// if z then
111904: LD_VAR 0 13
111908: IFFALSE 111954
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111910: LD_VAR 0 4
111914: PUSH
111915: LD_VAR 0 7
111919: ARRAY
111920: PPUSH
111921: LD_VAR 0 13
111925: PPUSH
111926: LD_VAR 0 4
111930: PUSH
111931: LD_VAR 0 7
111935: ARRAY
111936: PPUSH
111937: CALL_OW 74
111941: PPUSH
111942: CALL_OW 115
// attacking := true ;
111946: LD_ADDR_VAR 0 29
111950: PUSH
111951: LD_INT 1
111953: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111954: LD_VAR 0 4
111958: PUSH
111959: LD_VAR 0 7
111963: ARRAY
111964: PPUSH
111965: CALL_OW 256
111969: PUSH
111970: LD_INT 500
111972: LESS
111973: IFFALSE 111999
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111975: LD_VAR 0 4
111979: PUSH
111980: LD_VAR 0 7
111984: ARRAY
111985: PPUSH
111986: LD_VAR 0 14
111990: PUSH
111991: LD_INT 1
111993: ARRAY
111994: PPUSH
111995: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111999: LD_VAR 0 4
112003: PUSH
112004: LD_VAR 0 7
112008: ARRAY
112009: PPUSH
112010: CALL_OW 264
112014: PUSH
112015: LD_INT 49
112017: EQUAL
112018: IFFALSE 112139
// begin if not HasTask ( group [ i ] ) then
112020: LD_VAR 0 4
112024: PUSH
112025: LD_VAR 0 7
112029: ARRAY
112030: PPUSH
112031: CALL_OW 314
112035: NOT
112036: IFFALSE 112139
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
112038: LD_ADDR_VAR 0 9
112042: PUSH
112043: LD_INT 81
112045: PUSH
112046: LD_VAR 0 4
112050: PUSH
112051: LD_VAR 0 7
112055: ARRAY
112056: PPUSH
112057: CALL_OW 255
112061: PUSH
112062: EMPTY
112063: LIST
112064: LIST
112065: PPUSH
112066: CALL_OW 69
112070: PPUSH
112071: LD_VAR 0 4
112075: PUSH
112076: LD_VAR 0 7
112080: ARRAY
112081: PPUSH
112082: CALL_OW 74
112086: ST_TO_ADDR
// if k then
112087: LD_VAR 0 9
112091: IFFALSE 112139
// if GetDistUnits ( group [ i ] , k ) > 10 then
112093: LD_VAR 0 4
112097: PUSH
112098: LD_VAR 0 7
112102: ARRAY
112103: PPUSH
112104: LD_VAR 0 9
112108: PPUSH
112109: CALL_OW 296
112113: PUSH
112114: LD_INT 10
112116: GREATER
112117: IFFALSE 112139
// ComMoveUnit ( group [ i ] , k ) ;
112119: LD_VAR 0 4
112123: PUSH
112124: LD_VAR 0 7
112128: ARRAY
112129: PPUSH
112130: LD_VAR 0 9
112134: PPUSH
112135: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
112139: LD_VAR 0 4
112143: PUSH
112144: LD_VAR 0 7
112148: ARRAY
112149: PPUSH
112150: CALL_OW 256
112154: PUSH
112155: LD_INT 250
112157: LESS
112158: PUSH
112159: LD_VAR 0 4
112163: PUSH
112164: LD_VAR 0 7
112168: ARRAY
112169: PUSH
112170: LD_INT 21
112172: PUSH
112173: LD_INT 2
112175: PUSH
112176: EMPTY
112177: LIST
112178: LIST
112179: PUSH
112180: LD_INT 23
112182: PUSH
112183: LD_INT 2
112185: PUSH
112186: EMPTY
112187: LIST
112188: LIST
112189: PUSH
112190: EMPTY
112191: LIST
112192: LIST
112193: PPUSH
112194: CALL_OW 69
112198: IN
112199: AND
112200: IFFALSE 112325
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
112202: LD_ADDR_VAR 0 9
112206: PUSH
112207: LD_OWVAR 3
112211: PUSH
112212: LD_VAR 0 4
112216: PUSH
112217: LD_VAR 0 7
112221: ARRAY
112222: DIFF
112223: PPUSH
112224: LD_VAR 0 4
112228: PUSH
112229: LD_VAR 0 7
112233: ARRAY
112234: PPUSH
112235: CALL_OW 74
112239: ST_TO_ADDR
// if not k then
112240: LD_VAR 0 9
112244: NOT
112245: IFFALSE 112249
// continue ;
112247: GO 108664
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
112249: LD_VAR 0 9
112253: PUSH
112254: LD_INT 81
112256: PUSH
112257: LD_VAR 0 4
112261: PUSH
112262: LD_VAR 0 7
112266: ARRAY
112267: PPUSH
112268: CALL_OW 255
112272: PUSH
112273: EMPTY
112274: LIST
112275: LIST
112276: PPUSH
112277: CALL_OW 69
112281: IN
112282: PUSH
112283: LD_VAR 0 9
112287: PPUSH
112288: LD_VAR 0 4
112292: PUSH
112293: LD_VAR 0 7
112297: ARRAY
112298: PPUSH
112299: CALL_OW 296
112303: PUSH
112304: LD_INT 5
112306: LESS
112307: AND
112308: IFFALSE 112325
// ComAutodestruct ( group [ i ] ) ;
112310: LD_VAR 0 4
112314: PUSH
112315: LD_VAR 0 7
112319: ARRAY
112320: PPUSH
112321: CALL 81359 0 1
// end ; if f_attack_depot then
112325: LD_VAR 0 25
112329: IFFALSE 112441
// begin k := 6 ;
112331: LD_ADDR_VAR 0 9
112335: PUSH
112336: LD_INT 6
112338: ST_TO_ADDR
// if tmp < k then
112339: LD_VAR 0 14
112343: PUSH
112344: LD_VAR 0 9
112348: LESS
112349: IFFALSE 112361
// k := tmp ;
112351: LD_ADDR_VAR 0 9
112355: PUSH
112356: LD_VAR 0 14
112360: ST_TO_ADDR
// for j = 1 to k do
112361: LD_ADDR_VAR 0 8
112365: PUSH
112366: DOUBLE
112367: LD_INT 1
112369: DEC
112370: ST_TO_ADDR
112371: LD_VAR 0 9
112375: PUSH
112376: FOR_TO
112377: IFFALSE 112439
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112379: LD_VAR 0 8
112383: PPUSH
112384: CALL_OW 266
112388: PUSH
112389: LD_INT 0
112391: PUSH
112392: LD_INT 1
112394: PUSH
112395: EMPTY
112396: LIST
112397: LIST
112398: IN
112399: IFFALSE 112437
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112401: LD_VAR 0 4
112405: PUSH
112406: LD_VAR 0 7
112410: ARRAY
112411: PPUSH
112412: LD_VAR 0 14
112416: PUSH
112417: LD_VAR 0 8
112421: ARRAY
112422: PPUSH
112423: CALL_OW 115
// attacking := true ;
112427: LD_ADDR_VAR 0 29
112431: PUSH
112432: LD_INT 1
112434: ST_TO_ADDR
// break ;
112435: GO 112439
// end ;
112437: GO 112376
112439: POP
112440: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112441: LD_VAR 0 4
112445: PUSH
112446: LD_VAR 0 7
112450: ARRAY
112451: PPUSH
112452: CALL_OW 302
112456: PUSH
112457: LD_VAR 0 29
112461: NOT
112462: AND
112463: IFFALSE 112785
// begin if GetTag ( group [ i ] ) = 71 then
112465: LD_VAR 0 4
112469: PUSH
112470: LD_VAR 0 7
112474: ARRAY
112475: PPUSH
112476: CALL_OW 110
112480: PUSH
112481: LD_INT 71
112483: EQUAL
112484: IFFALSE 112525
// begin if HasTask ( group [ i ] ) then
112486: LD_VAR 0 4
112490: PUSH
112491: LD_VAR 0 7
112495: ARRAY
112496: PPUSH
112497: CALL_OW 314
112501: IFFALSE 112507
// continue else
112503: GO 108664
112505: GO 112525
// SetTag ( group [ i ] , 0 ) ;
112507: LD_VAR 0 4
112511: PUSH
112512: LD_VAR 0 7
112516: ARRAY
112517: PPUSH
112518: LD_INT 0
112520: PPUSH
112521: CALL_OW 109
// end ; k := 8 ;
112525: LD_ADDR_VAR 0 9
112529: PUSH
112530: LD_INT 8
112532: ST_TO_ADDR
// x := 0 ;
112533: LD_ADDR_VAR 0 10
112537: PUSH
112538: LD_INT 0
112540: ST_TO_ADDR
// if tmp < k then
112541: LD_VAR 0 14
112545: PUSH
112546: LD_VAR 0 9
112550: LESS
112551: IFFALSE 112563
// k := tmp ;
112553: LD_ADDR_VAR 0 9
112557: PUSH
112558: LD_VAR 0 14
112562: ST_TO_ADDR
// for j = 1 to k do
112563: LD_ADDR_VAR 0 8
112567: PUSH
112568: DOUBLE
112569: LD_INT 1
112571: DEC
112572: ST_TO_ADDR
112573: LD_VAR 0 9
112577: PUSH
112578: FOR_TO
112579: IFFALSE 112677
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112581: LD_VAR 0 14
112585: PUSH
112586: LD_VAR 0 8
112590: ARRAY
112591: PPUSH
112592: CALL_OW 247
112596: PUSH
112597: LD_INT 1
112599: EQUAL
112600: PUSH
112601: LD_VAR 0 14
112605: PUSH
112606: LD_VAR 0 8
112610: ARRAY
112611: PPUSH
112612: CALL_OW 256
112616: PUSH
112617: LD_INT 250
112619: LESS
112620: PUSH
112621: LD_VAR 0 20
112625: AND
112626: PUSH
112627: LD_VAR 0 20
112631: NOT
112632: PUSH
112633: LD_VAR 0 14
112637: PUSH
112638: LD_VAR 0 8
112642: ARRAY
112643: PPUSH
112644: CALL_OW 256
112648: PUSH
112649: LD_INT 250
112651: GREATEREQUAL
112652: AND
112653: OR
112654: AND
112655: IFFALSE 112675
// begin x := tmp [ j ] ;
112657: LD_ADDR_VAR 0 10
112661: PUSH
112662: LD_VAR 0 14
112666: PUSH
112667: LD_VAR 0 8
112671: ARRAY
112672: ST_TO_ADDR
// break ;
112673: GO 112677
// end ;
112675: GO 112578
112677: POP
112678: POP
// if x then
112679: LD_VAR 0 10
112683: IFFALSE 112707
// ComAttackUnit ( group [ i ] , x ) else
112685: LD_VAR 0 4
112689: PUSH
112690: LD_VAR 0 7
112694: ARRAY
112695: PPUSH
112696: LD_VAR 0 10
112700: PPUSH
112701: CALL_OW 115
112705: GO 112731
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112707: LD_VAR 0 4
112711: PUSH
112712: LD_VAR 0 7
112716: ARRAY
112717: PPUSH
112718: LD_VAR 0 14
112722: PUSH
112723: LD_INT 1
112725: ARRAY
112726: PPUSH
112727: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112731: LD_VAR 0 4
112735: PUSH
112736: LD_VAR 0 7
112740: ARRAY
112741: PPUSH
112742: CALL_OW 314
112746: NOT
112747: IFFALSE 112785
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112749: LD_VAR 0 4
112753: PUSH
112754: LD_VAR 0 7
112758: ARRAY
112759: PPUSH
112760: LD_VAR 0 14
112764: PPUSH
112765: LD_VAR 0 4
112769: PUSH
112770: LD_VAR 0 7
112774: ARRAY
112775: PPUSH
112776: CALL_OW 74
112780: PPUSH
112781: CALL_OW 115
// end ; end ; end ;
112785: GO 108664
112787: POP
112788: POP
// wait ( 0 0$2 ) ;
112789: LD_INT 70
112791: PPUSH
112792: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112796: LD_VAR 0 4
112800: NOT
112801: PUSH
112802: LD_VAR 0 4
112806: PUSH
112807: EMPTY
112808: EQUAL
112809: OR
112810: PUSH
112811: LD_INT 81
112813: PUSH
112814: LD_VAR 0 35
112818: PUSH
112819: EMPTY
112820: LIST
112821: LIST
112822: PPUSH
112823: CALL_OW 69
112827: NOT
112828: OR
112829: IFFALSE 108649
// end ;
112831: LD_VAR 0 2
112835: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112836: LD_INT 0
112838: PPUSH
112839: PPUSH
112840: PPUSH
112841: PPUSH
112842: PPUSH
112843: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112844: LD_VAR 0 1
112848: NOT
112849: PUSH
112850: LD_EXP 50
112854: PUSH
112855: LD_VAR 0 1
112859: ARRAY
112860: NOT
112861: OR
112862: PUSH
112863: LD_VAR 0 2
112867: NOT
112868: OR
112869: IFFALSE 112873
// exit ;
112871: GO 113427
// side := mc_sides [ base ] ;
112873: LD_ADDR_VAR 0 6
112877: PUSH
112878: LD_EXP 76
112882: PUSH
112883: LD_VAR 0 1
112887: ARRAY
112888: ST_TO_ADDR
// if not side then
112889: LD_VAR 0 6
112893: NOT
112894: IFFALSE 112898
// exit ;
112896: GO 113427
// for i in solds do
112898: LD_ADDR_VAR 0 7
112902: PUSH
112903: LD_VAR 0 2
112907: PUSH
112908: FOR_IN
112909: IFFALSE 112970
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112911: LD_VAR 0 7
112915: PPUSH
112916: CALL_OW 310
112920: PPUSH
112921: CALL_OW 266
112925: PUSH
112926: LD_INT 32
112928: PUSH
112929: LD_INT 31
112931: PUSH
112932: EMPTY
112933: LIST
112934: LIST
112935: IN
112936: IFFALSE 112956
// solds := solds diff i else
112938: LD_ADDR_VAR 0 2
112942: PUSH
112943: LD_VAR 0 2
112947: PUSH
112948: LD_VAR 0 7
112952: DIFF
112953: ST_TO_ADDR
112954: GO 112968
// SetTag ( i , 18 ) ;
112956: LD_VAR 0 7
112960: PPUSH
112961: LD_INT 18
112963: PPUSH
112964: CALL_OW 109
112968: GO 112908
112970: POP
112971: POP
// if not solds then
112972: LD_VAR 0 2
112976: NOT
112977: IFFALSE 112981
// exit ;
112979: GO 113427
// repeat wait ( 0 0$2 ) ;
112981: LD_INT 70
112983: PPUSH
112984: CALL_OW 67
// enemy := mc_scan [ base ] ;
112988: LD_ADDR_VAR 0 4
112992: PUSH
112993: LD_EXP 73
112997: PUSH
112998: LD_VAR 0 1
113002: ARRAY
113003: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113004: LD_EXP 50
113008: PUSH
113009: LD_VAR 0 1
113013: ARRAY
113014: NOT
113015: PUSH
113016: LD_EXP 50
113020: PUSH
113021: LD_VAR 0 1
113025: ARRAY
113026: PUSH
113027: EMPTY
113028: EQUAL
113029: OR
113030: IFFALSE 113067
// begin for i in solds do
113032: LD_ADDR_VAR 0 7
113036: PUSH
113037: LD_VAR 0 2
113041: PUSH
113042: FOR_IN
113043: IFFALSE 113056
// ComStop ( i ) ;
113045: LD_VAR 0 7
113049: PPUSH
113050: CALL_OW 141
113054: GO 113042
113056: POP
113057: POP
// solds := [ ] ;
113058: LD_ADDR_VAR 0 2
113062: PUSH
113063: EMPTY
113064: ST_TO_ADDR
// exit ;
113065: GO 113427
// end ; for i in solds do
113067: LD_ADDR_VAR 0 7
113071: PUSH
113072: LD_VAR 0 2
113076: PUSH
113077: FOR_IN
113078: IFFALSE 113399
// begin if IsInUnit ( i ) then
113080: LD_VAR 0 7
113084: PPUSH
113085: CALL_OW 310
113089: IFFALSE 113100
// ComExitBuilding ( i ) ;
113091: LD_VAR 0 7
113095: PPUSH
113096: CALL_OW 122
// if GetLives ( i ) > 500 then
113100: LD_VAR 0 7
113104: PPUSH
113105: CALL_OW 256
113109: PUSH
113110: LD_INT 500
113112: GREATER
113113: IFFALSE 113166
// begin e := NearestUnitToUnit ( enemy , i ) ;
113115: LD_ADDR_VAR 0 5
113119: PUSH
113120: LD_VAR 0 4
113124: PPUSH
113125: LD_VAR 0 7
113129: PPUSH
113130: CALL_OW 74
113134: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
113135: LD_VAR 0 7
113139: PPUSH
113140: LD_VAR 0 5
113144: PPUSH
113145: CALL_OW 250
113149: PPUSH
113150: LD_VAR 0 5
113154: PPUSH
113155: CALL_OW 251
113159: PPUSH
113160: CALL_OW 114
// end else
113164: GO 113397
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
113166: LD_VAR 0 7
113170: PPUSH
113171: LD_EXP 50
113175: PUSH
113176: LD_VAR 0 1
113180: ARRAY
113181: PPUSH
113182: LD_INT 2
113184: PUSH
113185: LD_INT 30
113187: PUSH
113188: LD_INT 0
113190: PUSH
113191: EMPTY
113192: LIST
113193: LIST
113194: PUSH
113195: LD_INT 30
113197: PUSH
113198: LD_INT 1
113200: PUSH
113201: EMPTY
113202: LIST
113203: LIST
113204: PUSH
113205: LD_INT 30
113207: PUSH
113208: LD_INT 6
113210: PUSH
113211: EMPTY
113212: LIST
113213: LIST
113214: PUSH
113215: EMPTY
113216: LIST
113217: LIST
113218: LIST
113219: LIST
113220: PPUSH
113221: CALL_OW 72
113225: PPUSH
113226: LD_VAR 0 7
113230: PPUSH
113231: CALL_OW 74
113235: PPUSH
113236: CALL_OW 296
113240: PUSH
113241: LD_INT 10
113243: GREATER
113244: IFFALSE 113397
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
113246: LD_ADDR_VAR 0 8
113250: PUSH
113251: LD_EXP 50
113255: PUSH
113256: LD_VAR 0 1
113260: ARRAY
113261: PPUSH
113262: LD_INT 2
113264: PUSH
113265: LD_INT 30
113267: PUSH
113268: LD_INT 0
113270: PUSH
113271: EMPTY
113272: LIST
113273: LIST
113274: PUSH
113275: LD_INT 30
113277: PUSH
113278: LD_INT 1
113280: PUSH
113281: EMPTY
113282: LIST
113283: LIST
113284: PUSH
113285: LD_INT 30
113287: PUSH
113288: LD_INT 6
113290: PUSH
113291: EMPTY
113292: LIST
113293: LIST
113294: PUSH
113295: EMPTY
113296: LIST
113297: LIST
113298: LIST
113299: LIST
113300: PPUSH
113301: CALL_OW 72
113305: PPUSH
113306: LD_VAR 0 7
113310: PPUSH
113311: CALL_OW 74
113315: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113316: LD_VAR 0 7
113320: PPUSH
113321: LD_VAR 0 8
113325: PPUSH
113326: CALL_OW 250
113330: PPUSH
113331: LD_INT 3
113333: PPUSH
113334: LD_INT 5
113336: PPUSH
113337: CALL_OW 272
113341: PPUSH
113342: LD_VAR 0 8
113346: PPUSH
113347: CALL_OW 251
113351: PPUSH
113352: LD_INT 3
113354: PPUSH
113355: LD_INT 5
113357: PPUSH
113358: CALL_OW 273
113362: PPUSH
113363: CALL_OW 111
// SetTag ( i , 0 ) ;
113367: LD_VAR 0 7
113371: PPUSH
113372: LD_INT 0
113374: PPUSH
113375: CALL_OW 109
// solds := solds diff i ;
113379: LD_ADDR_VAR 0 2
113383: PUSH
113384: LD_VAR 0 2
113388: PUSH
113389: LD_VAR 0 7
113393: DIFF
113394: ST_TO_ADDR
// continue ;
113395: GO 113077
// end ; end ;
113397: GO 113077
113399: POP
113400: POP
// until not solds or not enemy ;
113401: LD_VAR 0 2
113405: NOT
113406: PUSH
113407: LD_VAR 0 4
113411: NOT
113412: OR
113413: IFFALSE 112981
// MC_Reset ( base , 18 ) ;
113415: LD_VAR 0 1
113419: PPUSH
113420: LD_INT 18
113422: PPUSH
113423: CALL 22107 0 2
// end ;
113427: LD_VAR 0 3
113431: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113432: LD_INT 0
113434: PPUSH
113435: PPUSH
113436: PPUSH
113437: PPUSH
113438: PPUSH
113439: PPUSH
113440: PPUSH
113441: PPUSH
113442: PPUSH
113443: PPUSH
113444: PPUSH
113445: PPUSH
113446: PPUSH
113447: PPUSH
113448: PPUSH
113449: PPUSH
113450: PPUSH
113451: PPUSH
113452: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113453: LD_ADDR_VAR 0 12
113457: PUSH
113458: LD_EXP 50
113462: PUSH
113463: LD_VAR 0 1
113467: ARRAY
113468: PPUSH
113469: LD_INT 25
113471: PUSH
113472: LD_INT 3
113474: PUSH
113475: EMPTY
113476: LIST
113477: LIST
113478: PPUSH
113479: CALL_OW 72
113483: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113484: LD_EXP 90
113488: PUSH
113489: LD_VAR 0 1
113493: ARRAY
113494: IFFALSE 113518
// mechs := mechs diff mc_remote_driver [ base ] ;
113496: LD_ADDR_VAR 0 12
113500: PUSH
113501: LD_VAR 0 12
113505: PUSH
113506: LD_EXP 90
113510: PUSH
113511: LD_VAR 0 1
113515: ARRAY
113516: DIFF
113517: ST_TO_ADDR
// for i in mechs do
113518: LD_ADDR_VAR 0 4
113522: PUSH
113523: LD_VAR 0 12
113527: PUSH
113528: FOR_IN
113529: IFFALSE 113564
// if GetTag ( i ) > 0 then
113531: LD_VAR 0 4
113535: PPUSH
113536: CALL_OW 110
113540: PUSH
113541: LD_INT 0
113543: GREATER
113544: IFFALSE 113562
// mechs := mechs diff i ;
113546: LD_ADDR_VAR 0 12
113550: PUSH
113551: LD_VAR 0 12
113555: PUSH
113556: LD_VAR 0 4
113560: DIFF
113561: ST_TO_ADDR
113562: GO 113528
113564: POP
113565: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113566: LD_ADDR_VAR 0 8
113570: PUSH
113571: LD_EXP 50
113575: PUSH
113576: LD_VAR 0 1
113580: ARRAY
113581: PPUSH
113582: LD_INT 2
113584: PUSH
113585: LD_INT 25
113587: PUSH
113588: LD_INT 1
113590: PUSH
113591: EMPTY
113592: LIST
113593: LIST
113594: PUSH
113595: LD_INT 25
113597: PUSH
113598: LD_INT 5
113600: PUSH
113601: EMPTY
113602: LIST
113603: LIST
113604: PUSH
113605: LD_INT 25
113607: PUSH
113608: LD_INT 8
113610: PUSH
113611: EMPTY
113612: LIST
113613: LIST
113614: PUSH
113615: LD_INT 25
113617: PUSH
113618: LD_INT 9
113620: PUSH
113621: EMPTY
113622: LIST
113623: LIST
113624: PUSH
113625: EMPTY
113626: LIST
113627: LIST
113628: LIST
113629: LIST
113630: LIST
113631: PPUSH
113632: CALL_OW 72
113636: ST_TO_ADDR
// if not defenders and not solds then
113637: LD_VAR 0 2
113641: NOT
113642: PUSH
113643: LD_VAR 0 8
113647: NOT
113648: AND
113649: IFFALSE 113653
// exit ;
113651: GO 115423
// depot_under_attack := false ;
113653: LD_ADDR_VAR 0 16
113657: PUSH
113658: LD_INT 0
113660: ST_TO_ADDR
// sold_defenders := [ ] ;
113661: LD_ADDR_VAR 0 17
113665: PUSH
113666: EMPTY
113667: ST_TO_ADDR
// if mechs then
113668: LD_VAR 0 12
113672: IFFALSE 113825
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113674: LD_ADDR_VAR 0 4
113678: PUSH
113679: LD_VAR 0 2
113683: PPUSH
113684: LD_INT 21
113686: PUSH
113687: LD_INT 2
113689: PUSH
113690: EMPTY
113691: LIST
113692: LIST
113693: PPUSH
113694: CALL_OW 72
113698: PUSH
113699: FOR_IN
113700: IFFALSE 113823
// begin if GetTag ( i ) <> 20 then
113702: LD_VAR 0 4
113706: PPUSH
113707: CALL_OW 110
113711: PUSH
113712: LD_INT 20
113714: NONEQUAL
113715: IFFALSE 113729
// SetTag ( i , 20 ) ;
113717: LD_VAR 0 4
113721: PPUSH
113722: LD_INT 20
113724: PPUSH
113725: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113729: LD_VAR 0 4
113733: PPUSH
113734: CALL_OW 263
113738: PUSH
113739: LD_INT 1
113741: EQUAL
113742: PUSH
113743: LD_VAR 0 4
113747: PPUSH
113748: CALL_OW 311
113752: NOT
113753: AND
113754: IFFALSE 113821
// begin un := mechs [ 1 ] ;
113756: LD_ADDR_VAR 0 10
113760: PUSH
113761: LD_VAR 0 12
113765: PUSH
113766: LD_INT 1
113768: ARRAY
113769: ST_TO_ADDR
// ComExit ( un ) ;
113770: LD_VAR 0 10
113774: PPUSH
113775: CALL 85648 0 1
// AddComEnterUnit ( un , i ) ;
113779: LD_VAR 0 10
113783: PPUSH
113784: LD_VAR 0 4
113788: PPUSH
113789: CALL_OW 180
// SetTag ( un , 19 ) ;
113793: LD_VAR 0 10
113797: PPUSH
113798: LD_INT 19
113800: PPUSH
113801: CALL_OW 109
// mechs := mechs diff un ;
113805: LD_ADDR_VAR 0 12
113809: PUSH
113810: LD_VAR 0 12
113814: PUSH
113815: LD_VAR 0 10
113819: DIFF
113820: ST_TO_ADDR
// end ; end ;
113821: GO 113699
113823: POP
113824: POP
// if solds then
113825: LD_VAR 0 8
113829: IFFALSE 113888
// for i in solds do
113831: LD_ADDR_VAR 0 4
113835: PUSH
113836: LD_VAR 0 8
113840: PUSH
113841: FOR_IN
113842: IFFALSE 113886
// if not GetTag ( i ) then
113844: LD_VAR 0 4
113848: PPUSH
113849: CALL_OW 110
113853: NOT
113854: IFFALSE 113884
// begin defenders := defenders union i ;
113856: LD_ADDR_VAR 0 2
113860: PUSH
113861: LD_VAR 0 2
113865: PUSH
113866: LD_VAR 0 4
113870: UNION
113871: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113872: LD_VAR 0 4
113876: PPUSH
113877: LD_INT 18
113879: PPUSH
113880: CALL_OW 109
// end ;
113884: GO 113841
113886: POP
113887: POP
// repeat wait ( 0 0$2 ) ;
113888: LD_INT 70
113890: PPUSH
113891: CALL_OW 67
// enemy := mc_scan [ base ] ;
113895: LD_ADDR_VAR 0 21
113899: PUSH
113900: LD_EXP 73
113904: PUSH
113905: LD_VAR 0 1
113909: ARRAY
113910: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113911: LD_EXP 50
113915: PUSH
113916: LD_VAR 0 1
113920: ARRAY
113921: NOT
113922: PUSH
113923: LD_EXP 50
113927: PUSH
113928: LD_VAR 0 1
113932: ARRAY
113933: PUSH
113934: EMPTY
113935: EQUAL
113936: OR
113937: IFFALSE 113974
// begin for i in defenders do
113939: LD_ADDR_VAR 0 4
113943: PUSH
113944: LD_VAR 0 2
113948: PUSH
113949: FOR_IN
113950: IFFALSE 113963
// ComStop ( i ) ;
113952: LD_VAR 0 4
113956: PPUSH
113957: CALL_OW 141
113961: GO 113949
113963: POP
113964: POP
// defenders := [ ] ;
113965: LD_ADDR_VAR 0 2
113969: PUSH
113970: EMPTY
113971: ST_TO_ADDR
// exit ;
113972: GO 115423
// end ; for i in defenders do
113974: LD_ADDR_VAR 0 4
113978: PUSH
113979: LD_VAR 0 2
113983: PUSH
113984: FOR_IN
113985: IFFALSE 114883
// begin e := NearestUnitToUnit ( enemy , i ) ;
113987: LD_ADDR_VAR 0 13
113991: PUSH
113992: LD_VAR 0 21
113996: PPUSH
113997: LD_VAR 0 4
114001: PPUSH
114002: CALL_OW 74
114006: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114007: LD_ADDR_VAR 0 7
114011: PUSH
114012: LD_EXP 50
114016: PUSH
114017: LD_VAR 0 1
114021: ARRAY
114022: PPUSH
114023: LD_INT 2
114025: PUSH
114026: LD_INT 30
114028: PUSH
114029: LD_INT 0
114031: PUSH
114032: EMPTY
114033: LIST
114034: LIST
114035: PUSH
114036: LD_INT 30
114038: PUSH
114039: LD_INT 1
114041: PUSH
114042: EMPTY
114043: LIST
114044: LIST
114045: PUSH
114046: EMPTY
114047: LIST
114048: LIST
114049: LIST
114050: PPUSH
114051: CALL_OW 72
114055: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
114056: LD_ADDR_VAR 0 16
114060: PUSH
114061: LD_VAR 0 7
114065: NOT
114066: PUSH
114067: LD_VAR 0 7
114071: PPUSH
114072: LD_INT 3
114074: PUSH
114075: LD_INT 24
114077: PUSH
114078: LD_INT 600
114080: PUSH
114081: EMPTY
114082: LIST
114083: LIST
114084: PUSH
114085: EMPTY
114086: LIST
114087: LIST
114088: PPUSH
114089: CALL_OW 72
114093: OR
114094: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
114095: LD_VAR 0 4
114099: PPUSH
114100: CALL_OW 247
114104: PUSH
114105: LD_INT 2
114107: DOUBLE
114108: EQUAL
114109: IFTRUE 114113
114111: GO 114509
114113: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
114114: LD_VAR 0 4
114118: PPUSH
114119: CALL_OW 256
114123: PUSH
114124: LD_INT 1000
114126: EQUAL
114127: PUSH
114128: LD_VAR 0 4
114132: PPUSH
114133: LD_VAR 0 13
114137: PPUSH
114138: CALL_OW 296
114142: PUSH
114143: LD_INT 40
114145: LESS
114146: PUSH
114147: LD_VAR 0 13
114151: PPUSH
114152: LD_EXP 75
114156: PUSH
114157: LD_VAR 0 1
114161: ARRAY
114162: PPUSH
114163: CALL_OW 308
114167: OR
114168: AND
114169: IFFALSE 114291
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
114171: LD_VAR 0 4
114175: PPUSH
114176: CALL_OW 262
114180: PUSH
114181: LD_INT 1
114183: EQUAL
114184: PUSH
114185: LD_VAR 0 4
114189: PPUSH
114190: CALL_OW 261
114194: PUSH
114195: LD_INT 30
114197: LESS
114198: AND
114199: PUSH
114200: LD_VAR 0 7
114204: AND
114205: IFFALSE 114275
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
114207: LD_VAR 0 4
114211: PPUSH
114212: LD_VAR 0 7
114216: PPUSH
114217: LD_VAR 0 4
114221: PPUSH
114222: CALL_OW 74
114226: PPUSH
114227: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
114231: LD_VAR 0 4
114235: PPUSH
114236: LD_VAR 0 7
114240: PPUSH
114241: LD_VAR 0 4
114245: PPUSH
114246: CALL_OW 74
114250: PPUSH
114251: CALL_OW 296
114255: PUSH
114256: LD_INT 6
114258: LESS
114259: IFFALSE 114273
// SetFuel ( i , 100 ) ;
114261: LD_VAR 0 4
114265: PPUSH
114266: LD_INT 100
114268: PPUSH
114269: CALL_OW 240
// end else
114273: GO 114289
// ComAttackUnit ( i , e ) ;
114275: LD_VAR 0 4
114279: PPUSH
114280: LD_VAR 0 13
114284: PPUSH
114285: CALL_OW 115
// end else
114289: GO 114392
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114291: LD_VAR 0 13
114295: PPUSH
114296: LD_EXP 75
114300: PUSH
114301: LD_VAR 0 1
114305: ARRAY
114306: PPUSH
114307: CALL_OW 308
114311: NOT
114312: PUSH
114313: LD_VAR 0 4
114317: PPUSH
114318: LD_VAR 0 13
114322: PPUSH
114323: CALL_OW 296
114327: PUSH
114328: LD_INT 40
114330: GREATEREQUAL
114331: AND
114332: PUSH
114333: LD_VAR 0 4
114337: PPUSH
114338: CALL_OW 256
114342: PUSH
114343: LD_INT 650
114345: LESSEQUAL
114346: OR
114347: PUSH
114348: LD_VAR 0 4
114352: PPUSH
114353: LD_EXP 74
114357: PUSH
114358: LD_VAR 0 1
114362: ARRAY
114363: PPUSH
114364: CALL_OW 308
114368: NOT
114369: AND
114370: IFFALSE 114392
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114372: LD_VAR 0 4
114376: PPUSH
114377: LD_EXP 74
114381: PUSH
114382: LD_VAR 0 1
114386: ARRAY
114387: PPUSH
114388: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114392: LD_VAR 0 4
114396: PPUSH
114397: CALL_OW 256
114401: PUSH
114402: LD_INT 1000
114404: LESS
114405: PUSH
114406: LD_VAR 0 4
114410: PPUSH
114411: CALL_OW 263
114415: PUSH
114416: LD_INT 1
114418: EQUAL
114419: AND
114420: PUSH
114421: LD_VAR 0 4
114425: PPUSH
114426: CALL_OW 311
114430: AND
114431: PUSH
114432: LD_VAR 0 4
114436: PPUSH
114437: LD_EXP 74
114441: PUSH
114442: LD_VAR 0 1
114446: ARRAY
114447: PPUSH
114448: CALL_OW 308
114452: AND
114453: IFFALSE 114507
// begin mech := IsDrivenBy ( i ) ;
114455: LD_ADDR_VAR 0 9
114459: PUSH
114460: LD_VAR 0 4
114464: PPUSH
114465: CALL_OW 311
114469: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114470: LD_VAR 0 9
114474: PPUSH
114475: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114479: LD_VAR 0 9
114483: PPUSH
114484: LD_VAR 0 4
114488: PPUSH
114489: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114493: LD_VAR 0 9
114497: PPUSH
114498: LD_VAR 0 4
114502: PPUSH
114503: CALL_OW 180
// end ; end ; unit_human :
114507: GO 114854
114509: LD_INT 1
114511: DOUBLE
114512: EQUAL
114513: IFTRUE 114517
114515: GO 114853
114517: POP
// begin b := IsInUnit ( i ) ;
114518: LD_ADDR_VAR 0 18
114522: PUSH
114523: LD_VAR 0 4
114527: PPUSH
114528: CALL_OW 310
114532: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114533: LD_ADDR_VAR 0 19
114537: PUSH
114538: LD_VAR 0 18
114542: NOT
114543: PUSH
114544: LD_VAR 0 18
114548: PPUSH
114549: CALL_OW 266
114553: PUSH
114554: LD_INT 32
114556: PUSH
114557: LD_INT 31
114559: PUSH
114560: EMPTY
114561: LIST
114562: LIST
114563: IN
114564: OR
114565: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114566: LD_VAR 0 18
114570: PPUSH
114571: CALL_OW 266
114575: PUSH
114576: LD_INT 5
114578: EQUAL
114579: PUSH
114580: LD_VAR 0 4
114584: PPUSH
114585: CALL_OW 257
114589: PUSH
114590: LD_INT 1
114592: PUSH
114593: LD_INT 2
114595: PUSH
114596: LD_INT 3
114598: PUSH
114599: LD_INT 4
114601: PUSH
114602: EMPTY
114603: LIST
114604: LIST
114605: LIST
114606: LIST
114607: IN
114608: AND
114609: IFFALSE 114646
// begin class := AllowSpecClass ( i ) ;
114611: LD_ADDR_VAR 0 20
114615: PUSH
114616: LD_VAR 0 4
114620: PPUSH
114621: CALL 50365 0 1
114625: ST_TO_ADDR
// if class then
114626: LD_VAR 0 20
114630: IFFALSE 114646
// ComChangeProfession ( i , class ) ;
114632: LD_VAR 0 4
114636: PPUSH
114637: LD_VAR 0 20
114641: PPUSH
114642: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114646: LD_VAR 0 16
114650: PUSH
114651: LD_VAR 0 2
114655: PPUSH
114656: LD_INT 21
114658: PUSH
114659: LD_INT 2
114661: PUSH
114662: EMPTY
114663: LIST
114664: LIST
114665: PPUSH
114666: CALL_OW 72
114670: PUSH
114671: LD_INT 1
114673: LESSEQUAL
114674: OR
114675: PUSH
114676: LD_VAR 0 19
114680: AND
114681: PUSH
114682: LD_VAR 0 4
114686: PUSH
114687: LD_VAR 0 17
114691: IN
114692: NOT
114693: AND
114694: IFFALSE 114787
// begin if b then
114696: LD_VAR 0 18
114700: IFFALSE 114749
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114702: LD_VAR 0 18
114706: PPUSH
114707: LD_VAR 0 21
114711: PPUSH
114712: LD_VAR 0 18
114716: PPUSH
114717: CALL_OW 74
114721: PPUSH
114722: CALL_OW 296
114726: PUSH
114727: LD_INT 10
114729: LESS
114730: PUSH
114731: LD_VAR 0 18
114735: PPUSH
114736: CALL_OW 461
114740: PUSH
114741: LD_INT 7
114743: NONEQUAL
114744: AND
114745: IFFALSE 114749
// continue ;
114747: GO 113984
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114749: LD_ADDR_VAR 0 17
114753: PUSH
114754: LD_VAR 0 17
114758: PPUSH
114759: LD_VAR 0 17
114763: PUSH
114764: LD_INT 1
114766: PLUS
114767: PPUSH
114768: LD_VAR 0 4
114772: PPUSH
114773: CALL_OW 1
114777: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114778: LD_VAR 0 4
114782: PPUSH
114783: CALL_OW 122
// end ; if sold_defenders then
114787: LD_VAR 0 17
114791: IFFALSE 114851
// if i in sold_defenders then
114793: LD_VAR 0 4
114797: PUSH
114798: LD_VAR 0 17
114802: IN
114803: IFFALSE 114851
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114805: LD_VAR 0 4
114809: PPUSH
114810: CALL_OW 314
114814: NOT
114815: PUSH
114816: LD_VAR 0 4
114820: PPUSH
114821: LD_VAR 0 13
114825: PPUSH
114826: CALL_OW 296
114830: PUSH
114831: LD_INT 30
114833: LESS
114834: AND
114835: IFFALSE 114851
// ComAttackUnit ( i , e ) ;
114837: LD_VAR 0 4
114841: PPUSH
114842: LD_VAR 0 13
114846: PPUSH
114847: CALL_OW 115
// end ; end ; end ;
114851: GO 114854
114853: POP
// if IsDead ( i ) then
114854: LD_VAR 0 4
114858: PPUSH
114859: CALL_OW 301
114863: IFFALSE 114881
// defenders := defenders diff i ;
114865: LD_ADDR_VAR 0 2
114869: PUSH
114870: LD_VAR 0 2
114874: PUSH
114875: LD_VAR 0 4
114879: DIFF
114880: ST_TO_ADDR
// end ;
114881: GO 113984
114883: POP
114884: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114885: LD_VAR 0 21
114889: NOT
114890: PUSH
114891: LD_VAR 0 2
114895: NOT
114896: OR
114897: PUSH
114898: LD_EXP 50
114902: PUSH
114903: LD_VAR 0 1
114907: ARRAY
114908: NOT
114909: OR
114910: IFFALSE 113888
// MC_Reset ( base , 18 ) ;
114912: LD_VAR 0 1
114916: PPUSH
114917: LD_INT 18
114919: PPUSH
114920: CALL 22107 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114924: LD_ADDR_VAR 0 2
114928: PUSH
114929: LD_VAR 0 2
114933: PUSH
114934: LD_VAR 0 2
114938: PPUSH
114939: LD_INT 2
114941: PUSH
114942: LD_INT 25
114944: PUSH
114945: LD_INT 1
114947: PUSH
114948: EMPTY
114949: LIST
114950: LIST
114951: PUSH
114952: LD_INT 25
114954: PUSH
114955: LD_INT 5
114957: PUSH
114958: EMPTY
114959: LIST
114960: LIST
114961: PUSH
114962: LD_INT 25
114964: PUSH
114965: LD_INT 8
114967: PUSH
114968: EMPTY
114969: LIST
114970: LIST
114971: PUSH
114972: LD_INT 25
114974: PUSH
114975: LD_INT 9
114977: PUSH
114978: EMPTY
114979: LIST
114980: LIST
114981: PUSH
114982: EMPTY
114983: LIST
114984: LIST
114985: LIST
114986: LIST
114987: LIST
114988: PPUSH
114989: CALL_OW 72
114993: DIFF
114994: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114995: LD_VAR 0 21
114999: NOT
115000: PUSH
115001: LD_VAR 0 2
115005: PPUSH
115006: LD_INT 21
115008: PUSH
115009: LD_INT 2
115011: PUSH
115012: EMPTY
115013: LIST
115014: LIST
115015: PPUSH
115016: CALL_OW 72
115020: AND
115021: IFFALSE 115359
// begin tmp := FilterByTag ( defenders , 19 ) ;
115023: LD_ADDR_VAR 0 11
115027: PUSH
115028: LD_VAR 0 2
115032: PPUSH
115033: LD_INT 19
115035: PPUSH
115036: CALL 82834 0 2
115040: ST_TO_ADDR
// if tmp then
115041: LD_VAR 0 11
115045: IFFALSE 115115
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
115047: LD_ADDR_VAR 0 11
115051: PUSH
115052: LD_VAR 0 11
115056: PPUSH
115057: LD_INT 25
115059: PUSH
115060: LD_INT 3
115062: PUSH
115063: EMPTY
115064: LIST
115065: LIST
115066: PPUSH
115067: CALL_OW 72
115071: ST_TO_ADDR
// if tmp then
115072: LD_VAR 0 11
115076: IFFALSE 115115
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
115078: LD_ADDR_EXP 62
115082: PUSH
115083: LD_EXP 62
115087: PPUSH
115088: LD_VAR 0 1
115092: PPUSH
115093: LD_EXP 62
115097: PUSH
115098: LD_VAR 0 1
115102: ARRAY
115103: PUSH
115104: LD_VAR 0 11
115108: UNION
115109: PPUSH
115110: CALL_OW 1
115114: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
115115: LD_VAR 0 1
115119: PPUSH
115120: LD_INT 19
115122: PPUSH
115123: CALL 22107 0 2
// repeat wait ( 0 0$1 ) ;
115127: LD_INT 35
115129: PPUSH
115130: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115134: LD_EXP 50
115138: PUSH
115139: LD_VAR 0 1
115143: ARRAY
115144: NOT
115145: PUSH
115146: LD_EXP 50
115150: PUSH
115151: LD_VAR 0 1
115155: ARRAY
115156: PUSH
115157: EMPTY
115158: EQUAL
115159: OR
115160: IFFALSE 115197
// begin for i in defenders do
115162: LD_ADDR_VAR 0 4
115166: PUSH
115167: LD_VAR 0 2
115171: PUSH
115172: FOR_IN
115173: IFFALSE 115186
// ComStop ( i ) ;
115175: LD_VAR 0 4
115179: PPUSH
115180: CALL_OW 141
115184: GO 115172
115186: POP
115187: POP
// defenders := [ ] ;
115188: LD_ADDR_VAR 0 2
115192: PUSH
115193: EMPTY
115194: ST_TO_ADDR
// exit ;
115195: GO 115423
// end ; for i in defenders do
115197: LD_ADDR_VAR 0 4
115201: PUSH
115202: LD_VAR 0 2
115206: PUSH
115207: FOR_IN
115208: IFFALSE 115297
// begin if not IsInArea ( i , mc_parking [ base ] ) then
115210: LD_VAR 0 4
115214: PPUSH
115215: LD_EXP 74
115219: PUSH
115220: LD_VAR 0 1
115224: ARRAY
115225: PPUSH
115226: CALL_OW 308
115230: NOT
115231: IFFALSE 115255
// ComMoveToArea ( i , mc_parking [ base ] ) else
115233: LD_VAR 0 4
115237: PPUSH
115238: LD_EXP 74
115242: PUSH
115243: LD_VAR 0 1
115247: ARRAY
115248: PPUSH
115249: CALL_OW 113
115253: GO 115295
// if GetControl ( i ) = control_manual then
115255: LD_VAR 0 4
115259: PPUSH
115260: CALL_OW 263
115264: PUSH
115265: LD_INT 1
115267: EQUAL
115268: IFFALSE 115295
// if IsDrivenBy ( i ) then
115270: LD_VAR 0 4
115274: PPUSH
115275: CALL_OW 311
115279: IFFALSE 115295
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
115281: LD_VAR 0 4
115285: PPUSH
115286: CALL_OW 311
115290: PPUSH
115291: CALL_OW 121
// end ;
115295: GO 115207
115297: POP
115298: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
115299: LD_VAR 0 2
115303: PPUSH
115304: LD_INT 95
115306: PUSH
115307: LD_EXP 74
115311: PUSH
115312: LD_VAR 0 1
115316: ARRAY
115317: PUSH
115318: EMPTY
115319: LIST
115320: LIST
115321: PPUSH
115322: CALL_OW 72
115326: PUSH
115327: LD_VAR 0 2
115331: EQUAL
115332: PUSH
115333: LD_EXP 73
115337: PUSH
115338: LD_VAR 0 1
115342: ARRAY
115343: OR
115344: PUSH
115345: LD_EXP 50
115349: PUSH
115350: LD_VAR 0 1
115354: ARRAY
115355: NOT
115356: OR
115357: IFFALSE 115127
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115359: LD_ADDR_EXP 72
115363: PUSH
115364: LD_EXP 72
115368: PPUSH
115369: LD_VAR 0 1
115373: PPUSH
115374: LD_VAR 0 2
115378: PPUSH
115379: LD_INT 21
115381: PUSH
115382: LD_INT 2
115384: PUSH
115385: EMPTY
115386: LIST
115387: LIST
115388: PPUSH
115389: CALL_OW 72
115393: PPUSH
115394: CALL_OW 1
115398: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115399: LD_VAR 0 1
115403: PPUSH
115404: LD_INT 19
115406: PPUSH
115407: CALL 22107 0 2
// MC_Reset ( base , 20 ) ;
115411: LD_VAR 0 1
115415: PPUSH
115416: LD_INT 20
115418: PPUSH
115419: CALL 22107 0 2
// end ; end_of_file
115423: LD_VAR 0 3
115427: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115428: LD_VAR 0 1
115432: PUSH
115433: LD_INT 200
115435: DOUBLE
115436: GREATEREQUAL
115437: IFFALSE 115445
115439: LD_INT 299
115441: DOUBLE
115442: LESSEQUAL
115443: IFTRUE 115447
115445: GO 115479
115447: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115448: LD_VAR 0 1
115452: PPUSH
115453: LD_VAR 0 2
115457: PPUSH
115458: LD_VAR 0 3
115462: PPUSH
115463: LD_VAR 0 4
115467: PPUSH
115468: LD_VAR 0 5
115472: PPUSH
115473: CALL 103865 0 5
115477: GO 115556
115479: LD_INT 300
115481: DOUBLE
115482: GREATEREQUAL
115483: IFFALSE 115491
115485: LD_INT 399
115487: DOUBLE
115488: LESSEQUAL
115489: IFTRUE 115493
115491: GO 115555
115493: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115494: LD_VAR 0 1
115498: PPUSH
115499: LD_VAR 0 2
115503: PPUSH
115504: LD_VAR 0 3
115508: PPUSH
115509: LD_VAR 0 4
115513: PPUSH
115514: LD_VAR 0 5
115518: PPUSH
115519: LD_VAR 0 6
115523: PPUSH
115524: LD_VAR 0 7
115528: PPUSH
115529: LD_VAR 0 8
115533: PPUSH
115534: LD_VAR 0 9
115538: PPUSH
115539: LD_VAR 0 10
115543: PPUSH
115544: LD_VAR 0 11
115548: PPUSH
115549: CALL 101507 0 11
115553: GO 115556
115555: POP
// end ;
115556: PPOPN 11
115558: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115559: LD_VAR 0 1
115563: PPUSH
115564: LD_VAR 0 2
115568: PPUSH
115569: LD_VAR 0 3
115573: PPUSH
115574: LD_VAR 0 4
115578: PPUSH
115579: LD_VAR 0 5
115583: PPUSH
115584: CALL 103601 0 5
// end ; end_of_file
115588: PPOPN 5
115590: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115591: LD_VAR 0 1
115595: PPUSH
115596: LD_VAR 0 2
115600: PPUSH
115601: LD_VAR 0 3
115605: PPUSH
115606: LD_VAR 0 4
115610: PPUSH
115611: LD_VAR 0 5
115615: PPUSH
115616: LD_VAR 0 6
115620: PPUSH
115621: CALL 89200 0 6
// end ;
115625: PPOPN 6
115627: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115628: LD_INT 0
115630: PPUSH
// begin if not units then
115631: LD_VAR 0 1
115635: NOT
115636: IFFALSE 115640
// exit ;
115638: GO 115728
// if p1 = 1 then
115640: LD_VAR 0 2
115644: PUSH
115645: LD_INT 1
115647: EQUAL
115648: IFFALSE 115728
// begin if p2 = 1 then
115650: LD_VAR 0 3
115654: PUSH
115655: LD_INT 1
115657: EQUAL
115658: IFFALSE 115689
// begin for i in units do
115660: LD_ADDR_VAR 0 7
115664: PUSH
115665: LD_VAR 0 1
115669: PUSH
115670: FOR_IN
115671: IFFALSE 115687
// begin SetUnitAttackType ( i , 3 ) ;
115673: LD_VAR 0 7
115677: PPUSH
115678: LD_INT 3
115680: PPUSH
115681: CALL_OW 603
// end ;
115685: GO 115670
115687: POP
115688: POP
// end ; if p2 = 2 then
115689: LD_VAR 0 3
115693: PUSH
115694: LD_INT 2
115696: EQUAL
115697: IFFALSE 115728
// begin for i in units do
115699: LD_ADDR_VAR 0 7
115703: PUSH
115704: LD_VAR 0 1
115708: PUSH
115709: FOR_IN
115710: IFFALSE 115726
// begin SetUnitAttackType ( i , 1 ) ;
115712: LD_VAR 0 7
115716: PPUSH
115717: LD_INT 1
115719: PPUSH
115720: CALL_OW 603
// end ;
115724: GO 115709
115726: POP
115727: POP
// end ; end ; end ;
115728: PPOPN 7
115730: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115731: CALL 89175 0 0
// end ;
115735: PPOPN 1
115737: END
